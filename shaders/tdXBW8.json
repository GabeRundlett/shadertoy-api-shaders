{
    "Shader": {
        "info": {
            "date": "1588197791",
            "description": "Non PBR Path Tracer combining Ray Tracing, Ray Marching and 2D SDFs. +Bloom and depth of field, circular bokeh.\nDrag mouse to move camera.\nCommon = settings\nBufferA = scene\nBufferB = bloom horizontal pass\nImage = bloom vertical pass and display adaptation",
            "flags": 48,
            "hasliked": 0,
            "id": "tdXBW8",
            "likes": 55,
            "name": "Neon Desert",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 3488
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Does second pass of Bloom (vertical)\n    // Then does exposure, tone mapping & linear to sRGB conversion.\n    //fragColor = ImageFunction(iChannel0, iChannel1, fragCoord.xy, iResolution.xy);\n\n\t// get the linear color of the pixel\n    vec3 pixelColor = texture( iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    // add in bloom\n    pixelColor += BloomPass2(fragCoord.xy, iResolution.xy, iChannel1);\n    \n    // apply exposure\n    pixelColor *= c_exposure;\n    \n    // tone map the color to bring it from unbound HDR levels to SDR levels\n    pixelColor = ACESFilm(pixelColor);\n    \n    // convert to sRGB, then output\n    pixelColor = LinearToSRGB(pixelColor);\n    fragColor = vec4(pixelColor, 1.0f);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// =======================================================================\n// Scene Descriptions - both ray tracing and ray marched objects\n// =======================================================================\n\nvoid RayTraceMountainCylinders(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo, in float seed, in float radius, in float maxMountainHeight)\n{\n    SMaterial material;\n    material.diffuse = vec3(1.0f, 1.0f, 1.0f);\n    material.specular = vec3(0.0f, 0.0f, 0.0f);\n    material.roughness = 0.025f;\n    material.emissive = vec3(0.0f, 0.0f, 0.0f);\n\n    SRayHitInfo oldHitInfo = hitInfo;\n\n    if(TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, -15.0f, 0.0f), radius, maxMountainHeight, material))\n    {\n        vec3 hitPos = rayPos + rayDir * hitInfo.dist;\n        float azimuthPercent = clamp((atan(hitPos.z, hitPos.x) + c_pi) / c_twopi, 0.0f, 1.0f);\n        float heightPercent = (hitPos.y + 15.0f) / maxMountainHeight;\n\n        float thisHeightIndex = floor(azimuthPercent * 20.0f);\n        float nextHeightIndex = mod(thisHeightIndex + 1.0f, 20.0f);\n        float thisHeightIndexFraction = fract(azimuthPercent * 20.0f);\n\n        float thisHeight = hash12(vec2(thisHeightIndex, seed)) * 0.75f + 0.25f;\n        float nextHeight = hash12(vec2(nextHeightIndex, seed)) * 0.75f + 0.25f;\n\n        float mountainHeight = mix(thisHeight, nextHeight, thisHeightIndexFraction);\n\n        if (heightPercent > mountainHeight)\n        {\n            hitInfo = oldHitInfo;\n        }\n        else\n        {\n            vec3 brightPink = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f)) * 5.0f;\n            \n            float borderSize = 0.25f / maxMountainHeight;\n            \n            hitInfo.material.emissive = brightPink * smoothstep(mountainHeight - borderSize, mountainHeight, heightPercent);\n        }\n    }    \n}\n\nvoid RayTraceScene(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo hitInfo)\n{\n    // floor\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.1f, 0.1f, 0.1f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.02f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 1.0f, 0.0f)), -5.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = intersectPos.xz;\n                        \n            uv = fract(uv / 75.0f);\n            \n            float dist = min(abs(uv.x - 0.5), abs(uv.y - 0.5));\n            dist = step(dist, 0.005f);\n                       \n            float len2d = (cos(intersectPos.x * 0.01530f + intersectPos.y * 0.06320f) + 1.0f) / 2.5f;\n            \n            vec3 brightPurple = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f));\n            brightPurple = mix(brightPurple, vec3(0.0625f, 0.0f, 1.0f), len2d);\n            \n            vec3 darkPurple = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));\n            \n            hitInfo.material.emissive = mix(darkPurple, brightPurple, dist);\n            hitInfo.material.specular = mix(vec3(0.33f, 0.33f, 0.33f), vec3(0.0f, 0.0f, 0.0f), dist);\n        }\n    }\n    \n    // reflective balls\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.5f, 0.5f, 0.5f);\n        material.specular = vec3(1.0f, 1.0f, 1.0f);\n        material.roughness = 0.035f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n    \tTestSphereTrace(rayPos, rayDir, hitInfo, vec4(20.0f, 5.0f, -20.0f, 10.0f), material);\n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(-60.0f, 0.0f, 20.0f, 10.0f), material);\n        \n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 5.0f,  -65.0f, 10.0f), material);\n        \n        \n        TestSphereTrace(rayPos, rayDir, hitInfo, vec4(15.0f, -3.0f, 65.0f, 2.0f), material);\n    }\n    \n    // Cylinders with mountain cutouts - draw front to back\n    {\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo,  284.0f, 700.0f, 50.0f);\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1337.0f, 800.0f, 150.0f);\n        RayTraceMountainCylinders(rayPos, rayDir, hitInfo, 1932.0f, 900.0f, 250.0f);\n\t}\n    \n    // dark sun with gradient\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = vec3(0.0f, 0.0f, 0.0f);\n        \n        SRayHitInfo oldHitInfo = hitInfo;\n        \n    \tif (TestPlaneTrace(rayPos, rayDir, hitInfo, vec4( normalize(vec3(0.0f, 0.0f, -1.0f)), -1000.0f), material))\n        {\n            vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n            vec2 uv = intersectPos.xy;\n            \n            int stripe = int((-uv.y + 500.0f) / 50.0f);\n            if (stripe > 1)\n                stripe = (stripe-1) % 2;\n            else\n                stripe = 0;\n            \n            if (length(uv) > 500.0f)\n            {\n                hitInfo = oldHitInfo;\n            }\n            else if (stripe == 1)\n            {\n                hitInfo.material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));\n            }\n            else\n            {\n                vec3 topColor = pow(vec3(0.99f, 0.04f, 0.98f), vec3(2.2f, 2.2f, 2.2f));\n                vec3 bottomColor = pow(vec3(0.12f, 0.02f, 0.09f), vec3(2.2f, 2.2f, 2.2f));\n\n                float lerp = clamp((uv.y - 100.0f) / 400.0f, 0.0f, 1.0f);\n                lerp = Bias(lerp, 0.05);\n                hitInfo.material.emissive = mix(bottomColor, topColor, lerp);\n            }\n        }\n    }\n    \n    // ringed planet\n    {\n        // planet\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.0f, 0.0f, 0.0f);\n            if(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 500.0f, -1200.0f, 200.0f), material))\n            {\n                // TODO: gradient: yellow to red, then red to purple?\n                vec3 intersectPos = rayPos + rayDir * hitInfo.dist;\n\n                float lerpTop = clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);\n                float lerpMiddle = 1.0f - clamp((intersectPos.y - 500.0f) / 200.0f, 0.0f, 1.0f);\n                float lerpBottom = clamp((intersectPos.y - 500.0f) / -200.0f, 0.0f, 1.0f);\n                \n                lerpTop = Bias(lerpTop, 0.1f);\n                lerpMiddle = Bias(lerpMiddle, 0.9f);\n                lerpBottom = Bias(lerpBottom, 0.1f);\n\n                vec3 color = vec3(1.0f, 1.0f, 0.0f) * lerpTop;\n                color += vec3(1.0f, 0.0f, 0.0f) * lerpMiddle;\n                color += vec3(1.0f, 0.0f, 1.0f) * lerpBottom;\n\n                hitInfo.material.emissive = color;\n            }\n        }\n        \n        // ring\n        {\n            SMaterial material;\n            material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n            material.specular = vec3(0.0f, 0.0f, 0.0f);\n            material.roughness = 0.0f;\n            material.emissive = vec3(0.8f, 0.0f, 1.0f);// * 2.0f;// * 0.1f;\n\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 300.0f, 10.0f, material);\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 350.0f, 10.0f, material);\n            TestCylinderTrace(rayPos, rayDir, hitInfo, vec3(0.0f, 460.0f, -1200.0f), 375.0f, 10.0f, material);\n        }\n    }\n    \n    // sky dome\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.29f, 0.03f, 0.42f) * 0.55f, vec3(2.2f, 2.2f, 2.2f));\n    \tif(TestSphereTrace(rayPos, rayDir, hitInfo, vec4(0.0f, 0.0f, 0.0f, 2000.0f), material))\n        {\n            const float c_skyStarCells = 45.0f;\n            \n            // convert the hit position to polar, but percentages from 0 to 1.\n            // make the pole at the horizon to hide the distortion that would be in the sky otherwise.\n            vec3 hitPos = (rayPos + rayDir * hitInfo.dist).yzx;\n            float theta = (atan(hitPos.y, hitPos.x) + c_pi) / c_twopi;\n            float phi = (atan(sqrt(hitPos.x*hitPos.x + hitPos.y*hitPos.y), hitPos.z) + c_pi) / c_twopi;\n\n            // figure out what cell we are in and the offset in that cell\n            vec2 cellIndex = vec2(floor(theta * c_skyStarCells), floor(phi * c_skyStarCells));\n            vec2 cellUV = vec2(fract(theta * c_skyStarCells), fract(phi * c_skyStarCells));\n\n            // make a star at a random place in the cell\n            float starRadius = hash12(cellIndex) * 0.1f + 0.07f;\n\t\t\tvec2 starPos = hash22(cellIndex) * (1.0f - starRadius * 2.0f) + starRadius;\n            float dist = sdStar(starPos - cellUV, starRadius, 4, 3.75f);\n            \n            dist *= pow(length(starPos - cellUV) / starRadius, 10.0f);\n                       \n            float value = step(dist, 0.0f);\n\t\t\tvalue *= pow(1.0f - clamp(length(starPos - cellUV) / starRadius, 0.0f, 1.0f), 3.0f);\n                        \n            hitInfo.material.emissive = mix(material.emissive, vec3(1.0f, 1.0f, 1.0f), value);            \n        }\n    }\n}\n\nSRayHitInfo TestSceneMarch(in vec3 rayPos)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.hitAnObject = false;\n    hitInfo.dist = c_superFar;\n    \n    // glowing triangles\n    {\n\n        vec3 A = vec3(0.0f, 0.0f, 0.0f);\n        vec3 B = vec3(1.5f, 3.0f, 0.0f);\n        vec3 C = vec3(3.0f, 0.0f, 0.0f);\n        float lineWidth = 0.1f;\n        \n        vec3 center = (A + B + C) / 3.0f;\n        A -= center;\n        B -= center;\n        C -= center;\n        \n        A *= 3.0f;\n        B *= 3.0f;\n        C *= 3.0f;\n        \n        // foreground purple one\n        SMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;            \n\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);\n        \n        // blue one slightly behind\n        material.emissive = pow(vec3(0.3f, 0.15f, 1.0f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        A += vec3(0.0f, 0.0f, 5.0f);\n        B += vec3(0.0f, 0.0f, 5.0f);\n        C += vec3(0.0f, 0.0f, 5.0f);\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);        \n        \n        // red one behind more\n        material.emissive = pow(vec3(1.0f, 0.15f, 0.3f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        A += vec3(0.0f, 0.0f, 5.0f);\n        B += vec3(0.0f, 0.0f, 5.0f);\n        C += vec3(0.0f, 0.0f, 5.0f);\n        TestLineMarch(rayPos, hitInfo, A, B, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, B, C, lineWidth, material);\n        TestLineMarch(rayPos, hitInfo, C, A, lineWidth, material);              \n\t}    \n\n    // a neon cactus\n    {\n    \tSMaterial material;\n        material.diffuse = vec3(0.0f, 0.0f, 0.0f);\n        material.specular = vec3(0.0f, 0.0f, 0.0f);\n        material.roughness = 0.0f;\n        material.emissive = pow(vec3(0.73f, 0.06f, 0.99f), vec3(2.2f, 2.2f, 2.2f)) * 10.0f;\n        \n        vec3 cactusOffset = vec3(0.0f, 0.0f, 50.0f);\n        \n        // main body section\n        {\n            vec3 A = vec3(-40.0f, -10.0f, 0.0f) + cactusOffset;\n            vec3 B = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;\n            vec3 C = vec3(-40.0f, 20.0f, 0.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 2.0f, material);\n        }\n        \n        // Arm going to left\n        {\n            vec3 A = vec3(-40.0f, 5.0f, 1.0f) + cactusOffset;\n            vec3 B = vec3(-32.5f, 10.0f, 0.0f) + cactusOffset;\n            vec3 C = vec3(-32.5f, 15.0f, -1.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);\n        }\n        \n        // Arm going to right\n        {\n            vec3 A = vec3(-40.0f, 2.0f, 1.0f) + cactusOffset;\n            vec3 B = vec3(-47.5f, 7.0f, 2.0f) + cactusOffset;\n            vec3 C = vec3(-47.5f, 13.0f, 4.0f) + cactusOffset;\n            TestBezierMarch(rayPos, hitInfo, A, B, C, 1.0f, material);\n        }        \n        \n    }\n\n    return hitInfo;\n}\n\n// =======================================================================\n// Ray Marching\n// =======================================================================\n\nvoid RayMarchScene(in vec3 startingRayPos, in vec3 rayDir, inout SRayHitInfo oldHitInfo)\n{\n    SMaterial dummyMaterial = SMaterial(vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), 0.0f, vec3(0.0f, 0.0f, 0.0f));\n    \n    float rayDistance = c_minimumRayHitTime;\n    float lastRayDistance = c_minimumRayHitTime;\n    \n    float lastHitInfoDist = 0.0f;\n    \n    SRayHitInfo newHitInfo = oldHitInfo;\n    newHitInfo.hitAnObject = false;\n    \n    for (int stepIndex = 0; stepIndex < c_numSteps; ++stepIndex)\n    {\n        vec3 rayPos = startingRayPos + rayDistance * rayDir;\n        \n        newHitInfo = TestSceneMarch(rayPos);\n        \n        // these two lines are so that the material code goes away when the test functions are inlines\n        newHitInfo.normal = vec3(0.0f, 0.0f, 0.0f);\n        newHitInfo.material = dummyMaterial;\n        \n        newHitInfo.hitAnObject = newHitInfo.dist < 0.0f;\n        if (newHitInfo.hitAnObject)\n            break;\n        \n        lastRayDistance = rayDistance;\n        rayDistance += max(newHitInfo.dist, c_minStepDistance);\n\n        lastHitInfoDist = newHitInfo.dist;\n        \n        if (rayDistance > oldHitInfo.dist)\n            break;\n    }\n    \n    if (newHitInfo.hitAnObject)\n    {\n\t\tfloat refinedHitPercent = lastHitInfoDist / (lastHitInfoDist - newHitInfo.dist);\n        newHitInfo.dist = mix(lastRayDistance, rayDistance, refinedHitPercent);\n        \n        if (newHitInfo.dist < oldHitInfo.dist)\n            oldHitInfo = newHitInfo;\n    }\n}\n\n// =======================================================================\n// Iterative bounce ray tracing\n// =======================================================================\n    \nvec3 GetColorForRay(in vec3 startRayPos, in vec3 startRayDir, inout uint rngState)\n{\n    vec3 ret = vec3(0.0f, 0.0f, 0.0f);\n    vec3 colorMultiplier = vec3(1.0f, 1.0f, 1.0f);\n    \n    vec3 rayPos = startRayPos;\n    vec3 rayDir = startRayDir;\n       \n    for (int i = 0; i <= c_numBounces; ++i)\n    {\n        SRayHitInfo hitInfo;\n\t\thitInfo.hitAnObject = false;\n        hitInfo.dist = c_superFar;\n        \n        // ray trace first, which also gives a maximum distance for ray marching\n        RayTraceScene(rayPos, rayDir, hitInfo);\n        RayMarchScene(rayPos, rayDir, hitInfo);\n        \n        if (!hitInfo.hitAnObject)\n        {\n            // handle ray misses\n            ret += texture(iChannel1, rayDir).rgb * c_skyboxMultiplier * colorMultiplier;\n            break;\n        }\n                      \n        // update the ray position\n        rayPos += rayDir * hitInfo.dist;\n               \n        // get the material info if it was a ray marched object\n        if (hitInfo.rayMarchedObject)\n\t\t\thitInfo = TestSceneMarch(rayPos);       \n                \n\t\t// add in emissive lighting\n        ret += hitInfo.material.emissive * colorMultiplier;\n        \n        // figure out whether we are going to shoot out a specular or diffuse ray.\n        // If neither, exit\n        float diffuseLength = length(hitInfo.material.diffuse);        \n        float specularLength = length(hitInfo.material.specular);\n        if (diffuseLength + specularLength == 0.0f)\n            break;\n        float specularWeight = specularLength / (diffuseLength + specularLength);       \n        float doSpecular = float(RandomFloat01(rngState) < specularWeight);\n       \n        // set up the next ray direction\n        float roughness = mix(1.0f, hitInfo.material.roughness, doSpecular);\n        vec3 reflectDir = reflect(rayDir, hitInfo.normal);\n        vec3 randomDir = RandomUnitVector(rngState);\n        rayDir = normalize(mix(reflectDir, randomDir, roughness));\n        \n        if (dot(rayDir, hitInfo.normal) < 0.0f)\n            rayDir *= -1.0f;        \n        \n        // move the ray away from the surface it hit a little bit\n        rayPos += hitInfo.normal * c_rayPosNormalNudge;\n        \n        // Make all future light affected be modulated by either the diffuse or specular reflection color\n        // depending on which we are doing.\n        // Attenuate diffuse by the dot product of the outgoing ray and the normal (aka multiply diffuse by cosine theta or N dot L)\n        float NdotL = dot(hitInfo.normal, rayDir);\n        colorMultiplier *= mix(hitInfo.material.diffuse * NdotL, hitInfo.material.specular, doSpecular);        \n    }\n    \n    return ret;\n}\n\n// =======================================================================\n// Orbit Camera\n// =======================================================================\n\n\nvoid GetCameraVectors(out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraUp, out vec3 cameraRight)\n{   \n    vec2 mouse = iMouse.xy;\n    if (dot(mouse, vec2(1.0f, 1.0f)) == 0.0f)\n        mouse = c_defaultMousePos * iResolution.xy;\n    \n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(c_minCameraAngle, c_maxCameraAngle, mouse.y / float(iResolution.y));\n    \n    cameraPos.x = sin(angleX) * sin(angleY) * c_cameraDistance;\n    cameraPos.y = -cos(angleY) * c_cameraDistance;\n    cameraPos.z = cos(angleX) * sin(angleY) * c_cameraDistance;\n    \n    cameraPos += c_cameraAt;\n    \n    cameraFwd = normalize(c_cameraAt - cameraPos);\n    cameraRight = normalize(cross(cameraFwd, vec3(0.0f, 1.0f, 0.0f)));\n    cameraUp = normalize(cross(cameraRight, cameraFwd));   \n}\n\n// =======================================================================\n// Main function\n// =======================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    // add sub pixel jitter for anti aliasing\n    vec2 fragCoordJittered = fragCoord + (vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f);\n    \n    // get the camera vectors\n    vec3 cameraPos, cameraFwd, cameraUp, cameraRight;\n    GetCameraVectors(cameraPos, cameraFwd, cameraUp, cameraRight);\n    \n    // calculate the ray direction for this pixel\n    vec2 uvJittered = fragCoordJittered/iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayDir;\n    {   \n\t\tvec2 screen = uvJittered * 2.0f - 1.0f;\n        screen.y /= aspectRatio;\n                \n        float cameraDistance = tan(c_FOV * 0.5f * c_pi / 180.0f);       \n        rayDir = vec3(screen, cameraDistance);\n        rayDir = normalize(mat3(cameraRight, cameraUp, cameraFwd) * rayDir);\n    }\n    \n    // simulate a thin lens (depth of field and circular bokeh)\n    if (c_apertureRadius > 0.0f)\n    {\n        // calculate point on the focal plane\n        vec3 focalPlanePoint = cameraPos + rayDir * c_focalPlaneDistance;\n        \n        // calculate a random point on the aperture\n        float angle = RandomFloat01(rngState) * 2.0f * c_pi;\n\t\tfloat radius = sqrt(RandomFloat01(rngState)) * c_apertureRadius;\n\t\tvec2 offset = vec2(cos(angle), sin(angle)) * radius;\n        \n        // update the camera pos\n        cameraPos += offset.x * cameraRight + offset.y * cameraUp;\n        \n        // update the ray direction\n        rayDir = normalize(focalPlanePoint - cameraPos);  \n    }\n    \n    // get the linear color of the ray\n    vec3 color = GetColorForRay(cameraPos, rayDir, rngState);\n    \n    // integrate color with previous frame.\n    // incremental averaging: https://blog.demofox.org/2016/08/23/incremental-averaging/\n    bool spacePressed = (texture(iChannel2, vec2(KEY_SPACE,0.25)).x > 0.1);\n    vec4 oldColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (oldColor.a == 0.0f || iMouse.z > 0.0 || spacePressed) ? 1.0f : 1.0f / (1.0f + (1.0f / oldColor.a));\n    color = mix(oldColor.rgb, color, blend);    \n    fragColor = vec4(color, blend);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// =======================================================================\n// Constants\n// =======================================================================\n\nconst float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\nconst float KEY_SPACE = 32.5/256.0;\n\n// =======================================================================\n// Parameters\n// =======================================================================\n\n// camera parameters\nconst vec3 c_cameraAt = vec3(0.0f, 0.0f, 0.0f);\nconst float c_cameraDistance = 80.0f;\nconst float c_apertureRadius = 0.4f;  // in world units. 0 for pinhole camera.\nconst float c_focalPlaneDistance = 80.0f; // in world units. How far from the camera things are in focus at.\nconst float c_minCameraAngle = c_pi / 2.0f - 0.125f;\nconst float c_maxCameraAngle = (c_pi - 0.01f);\nconst float c_exposure = 2.0f;  // +1 fstops of exposure\nconst float c_FOV = 90.0f; // in degrees\n\n// the place to put the mouse if it hasn't moved yet (aka the default view)\nconst vec2 c_defaultMousePos = vec2(140.0f / 800.0f, 40.0f / 450.0f);  // viewing the dark sun\n//const vec2 c_defaultMousePos = vec2(300.0f / 800.0f, 30.0f / 450.0f);  // viewing saturn\n\n// bloom parameters\nconst vec3 c_bloomMin = vec3(1.0f, 1.0f, 1.0f);\n// The array below is a 1d gaussian which starts at index 0.\n// A nice gaussian calculator is at http://dev.theomader.com/gaussian-kernel-calculator/\n// Just calculate a kernel that is (c_radius * 2 + 1) large and use the second half of the result (including the center).\n// That should give you an array that is (c_radius+1) items large.\n//const int c_bloomRadius = 3;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.383103, 0.241843, 0.060626, 0.00598); // sigma 1.0\nconst int c_bloomRadius = 5;\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.382925, 0.24173, 0.060598, 0.005977, 0.000229, 0.000003); // sigma 1.0\nconst float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.163053, 0.150677, 0.118904, 0.080127, 0.046108, 0.022657); // sigma 2.5\n//const float c_bloomKernel[c_bloomRadius+1] = float[c_bloomRadius+1](0.109317, 0.107159, 0.100939, 0.091364, 0.079465, 0.066414); // sigma 5.0    \n\n// scene parameters\nconst float c_skyboxMultiplier = 0.0f; // for the cube map, if visible.\n\n// ray tracing parameters\nconst int c_numBounces = 4;\nconst float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\n\n// ray marching parameters\nconst int c_numSteps = 256;\nconst float c_minStepDistance = 0.1f;\n\n// other parameters\nconst float c_rayPosNormalNudge = 0.01f; // after a hit, it moves the ray this far along the normal away from a surface\n\n// =======================================================================\n// Display Adaptation Functions\n// =======================================================================\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n    \n    return mix(\n        pow(rgb * 1.055f, vec3(1.f / 2.4f)) - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// ACES tone mapping curve fit to go from HDR to LDR\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\n// =======================================================================\n// Bloom Functions\n// =======================================================================\n\nvec3 BloomPass1(in vec2 pixelPos, in vec2 resolution, in sampler2D linearImage)\n{\n    // horizontal & conditional\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int ix = -c_bloomRadius; ix <= c_bloomRadius; ++ix)\n    {\n        vec3 pixelColor = texture( linearImage, (pixelPos + vec2(ix, 0))/resolution.xy).rgb;\n        vec3 bloomColor = clamp(pixelColor - c_bloomMin, 0.0f, 1.0f);\n        \n        bloomColor = (dot(bloomColor, c_bloomMin) > 0.0f ? bloomColor : vec3(0.0f, 0.0f, 0.0f));\n\n        float weight = c_bloomKernel[abs(ix)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\nvec3 BloomPass2(in vec2 pixelPos, in vec2 resolution, in sampler2D bloomImage)\n{\n    // vertical\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    for (int iy = -c_bloomRadius; iy <= c_bloomRadius; ++iy)\n    {\n        vec3 bloomColor = texture( bloomImage, (pixelPos + vec2(0, iy))/resolution.xy).rgb;\n        float weight = c_bloomKernel[abs(iy)];\n        sum += bloomColor * weight;\n    }\n    \n    return sum;\n}\n\n// =======================================================================\n// RNG Functions\n// =======================================================================\n\n// from \"Hash without Sine\" https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n// =======================================================================\n// Misc Functions\n// =======================================================================\n\nfloat MaxComp(vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\nint MaxCompIndex(vec3 v)\n{\n    if (v.x > v.y)\n    {\n        if (v.x > v.z)\n            return 0;\n        else\n            return 2;\n    }\n    else\n    {\n        if (v.y > v.z)\n            return 1;\n        else\n            return 2;\n    }\n}\n\nfloat Bias(float x, float bias)\n{\n  return (x / ((((1.0f/bias) - 2.0f)*(1.0f - x))+1.0f));\n}\n\nfloat dot2(in vec3 v ) { return dot(v,v); }\n\n// =======================================================================\n// Distance Functions 2D\n// https://iquilezles.org/articles/distfunctions2d\n// =======================================================================\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n// =======================================================================\n// Distance Functions 3D\n// https://iquilezles.org/articles/distfunctions\n// =======================================================================\n\nfloat SphereDistance(in vec4 sphere, in vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat PlaneDistance(in vec4 plane, in vec3 point)\n{\n    return (dot(plane.xyz, point) - plane.w) / dot(plane.xyz, plane.xyz);\n}\n\nfloat BoxDistance(in vec3 boxPos, in vec3 boxRadius, in float width, in vec3 point)\n{\n    point -= boxPos;\n    width = max(width, 0.01f);  // fix for a problem i didn't investigate :P\n    \n    // from https://www.youtube.com/watch?reload=9&v=62-pRVZuS5c\n    // rounding the box from https://www.youtube.com/watch?v=s5NGeUV2EyU\n    vec3 q = abs(point) - boxRadius;\n    return length(max(q,vec3(0.0f,0.0f,0.0f))) + min(MaxComp(q), 0.0f) - width;\n}\n\nfloat LineDistance(in vec3 A, in vec3 B, float width, in vec3 point, out vec3 normal)\n{\n\tvec3 AP = point - A;\n    vec3 AB = B - A;\n    \n    // from https://www.youtube.com/watch?v=PMltMdi1Wzg\n    // added normal calculation though\n    float h = min(1.0f, max(0.0f, dot(AP, AB) / dot(AB, AB)));\n    vec3 closestPoint = A + h * AB;\n    normal = normalize(point - closestPoint);\n    return length(point - closestPoint) - width;\n}\n\nfloat BezierDistance( in vec3 pos, in vec3 A, in vec3 B, in vec3 C, in float width)\n{    \n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res ) - width;\n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Marching\n// =======================================================================\n\nstruct SMaterial\n{\n    vec3 diffuse;\n    vec3 specular;\n\tfloat roughness;\n    vec3 emissive;    \n};\n\nstruct SRayHitInfo\n{\n    bool hitAnObject;\n    bool rayMarchedObject;\n    float dist;\n    vec3 normal;\n    SMaterial material;\n};\n    \nvoid TestSphereMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n    float dist = SphereDistance(sphere, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = normalize(rayPos - sphere.xyz);\n        info.material = material;\n    }    \n}\n\nvoid TestPlaneMarch(in vec3 rayPos, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = PlaneDistance(plane, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = plane.xyz;\n        info.material = material;\n    }    \n}\n\nvoid TestBoxMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 boxPos, in vec3 boxRadius, in float width, in SMaterial material)\n{\n    float dist = BoxDistance(boxPos, boxRadius, width, rayPos);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;\n        \n        vec3 relPos = max(abs(rayPos - boxPos) - boxRadius, 0.0f);\n        int maxIndex = MaxCompIndex(relPos);\n        if (maxIndex == 0)\n        {\n            info.normal = (rayPos.x < boxPos.x) ? vec3(-1.0f, 0.0f, 0.0f) : vec3(1.0f, 0.0f, 0.0f);\n        }\n        else if(maxIndex == 1)\n        {\n            info.normal = (rayPos.y < boxPos.y) ? vec3(0.0f, -1.0f, 0.0f) : vec3(0.0f, 1.0f, 0.0f);\n        }\n        else\n        {\n            info.normal = (rayPos.z < boxPos.z) ? vec3(0.0f, 0.0f, -1.0f) : vec3(0.0f, 0.0f, 1.0f);\n        }\n        \n        info.material = material;\n    }    \n}\n\nvoid TestLineMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in float width, in SMaterial material)\n{   \n    vec3 normal;\n    float dist = LineDistance(A, B, width, rayPos, normal);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;        \n        info.normal = normal;\n        info.material = material;\n    }    \n}\n\nvoid TestBezierMarch(in vec3 rayPos, inout SRayHitInfo info, in vec3 A, in vec3 B, in vec3 C, in float width, in SMaterial material)\n{\n    float dist = BezierDistance(rayPos, A, B, C, width);\n    if (dist < info.dist)\n    {\n        info.rayMarchedObject = true;\n        info.dist = dist;    \n        info.normal = vec3(1.0f, 0.0f, 0.0f); // TODO: normal, if you ever need it!\n        info.material = material;\n    }    \n}\n\n// =======================================================================\n// Object Intersection Helpers for Ray Tracing\n// =======================================================================\n\nbool TestPlaneTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 plane, in SMaterial material)\n{\n    float dist = -1.0f;\n    float denom = dot(plane.xyz, rayDir);\n    if (abs(denom) > 0.001f)\n    {\n        dist = (plane.w - dot(plane.xyz, rayPos)) / denom;\n    \n        if (dist > c_minimumRayHitTime && dist < info.dist)\n        {\n            info.hitAnObject = true;\n            info.rayMarchedObject = false;\n            info.dist = dist;        \n            info.normal = plane.xyz;\n            info.material = material;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout SRayHitInfo info, in vec4 sphere, in SMaterial material)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.rayMarchedObject = false;\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n// Tests against a vertical cylinder without caps\n// Derived from the sphere function and not super optimal but whatever.\nbool TestCylinderTrace(in vec3 rayPos_, in vec3 rayDir_, inout SRayHitInfo info, in vec3 pos, in float radius, in float height, in SMaterial material)\n{\n    vec3 relativeRayPos = rayPos_ - pos;\n    vec3 projectedRayPos = vec3(relativeRayPos.x, 0.0f, relativeRayPos.z);\n    vec3 projectedRayDir = vec3(rayDir_.x, 0.0f, rayDir_.z);\n    \n    float lengthCorrection = length(projectedRayDir);\n    projectedRayDir /= lengthCorrection;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = projectedRayPos;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, projectedRayDir);\n\n\tfloat c = dot(m, m) - radius * radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n\n    // adjust distance\n    dist /= lengthCorrection;\n\n    // enforce height - note we may be invalid height for the first distance but not the second.\n    vec3 relativeHitPos = relativeRayPos + rayDir_ * dist;\n    if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n    {\n        dist = -b + sqrt(discr);\n        dist /= lengthCorrection;\n        relativeHitPos = relativeRayPos + rayDir_ * dist;\n        if (relativeHitPos.y < 0.0f || relativeHitPos.y > height)\n      \t\treturn false;\n    }\n        \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.hitAnObject = true;\n        info.rayMarchedObject = false;\n        info.dist = dist;        \n        info.normal = normalize(vec3(relativeHitPos.x, 0.0f, relativeHitPos.z)) * (fromInside ? -1.0f : 1.0f);\n\t\tinfo.material = material;        \n        return true;\n    }\n    \n    return false;\n}\n\n/*\n\n============================================\n\nNon PBR Path tracer version 1.\n\n* ray traced objects & ray marched objects\n* thin lens simulation (depth of field and bokeh) with a circular aperture.\n* bloom\n\nBranched to: https://www.shadertoy.com/view/wslfzX\n\n============================================\n\nmake a more traditional path traced scene next, just to have it?\n\n============================================\n\nImprovements for future versions (other shadertoys)...\n\n* blue noise for low sample counts. maybe low discrepancy sequences too for more than low sample counts.\n\n* spectral path tracing - different material properties for different wavelengths of light.\n\n* transparency & refraction?\n * would need ot be able to be inside of objects. maybe only allow for raytracing?\n * maybe combine this with subsurface scattering?\n\n* participating media:\n * https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n * https://shaderbits.com/blog/creating-volumetric-ray-marcher\n * https://www.shadertoy.com/view/tsScDG\n * also: do low step count ray marching, but use blue noise to offset each ray ftw!\n\n* subsurface scattering\n * https://my.eng.utah.edu/~darais/classes/cs6620/project/index.html\n * https://www.fxguide.com/fxfeatured/pixar-deep-dive-on-sss-siggraph-preview/\n\n* lens flare\n* motion blur\n* fresnel\n\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Does first pass of Bloom (horizontal & conditional)\n    fragColor = vec4(BloomPass1(fragCoord.xy, iResolution.xy, iChannel0), 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}