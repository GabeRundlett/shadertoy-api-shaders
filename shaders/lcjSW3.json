{
    "Shader": {
        "info": {
            "date": "1706908745",
            "description": "A simple demo of analytical fog computation using [url=https://www.shadertoy.com/view/lcBXDW]gabor blobs[/url], with some sdf scenery.\n\nThe fog is single-color, e.g. does not depend on dot(gradient(fog),light), or whatever, which can look a bit boring.",
            "flags": 0,
            "hasliked": 0,
            "id": "lcjSW3",
            "likes": 9,
            "name": "Mossscrapers",
            "published": 3,
            "tags": [
                "sdf",
                "fog",
                "blob",
                "gabor"
            ],
            "usePreview": 0,
            "username": "FordPerfect",
            "viewed": 184
        },
        "renderpass": [
            {
                "code": "// Public Domain under http://unlicense.org, see link for details.\n\n// A simple demo of analytical fog computation using\n// gabor blobs (https://www.shadertoy.com/view/lcBXDW).\n\n//==============================================================================\n// Noise.\n\nfloat rnd(vec3 v) {return sin(dot(sin(v*vec3(13.7,37.1,71.3)),3.7+17.3*v.yzx));}\n\nfloat vnoise(vec3 v)\n{\n    vec3 i=vec3(floor(v)),e=vec3(0,1,0);\n    v=smoothstep(0.0,1.0,v-i);\n    return mix(\n        mix(\n            mix(rnd(i+e.xxx),rnd(i+e.yxx),v.x),\n            mix(rnd(i+e.xyx),rnd(i+e.yyx),v.x),v.y),\n        mix(\n            mix(rnd(i+e.xxy),rnd(i+e.yxy),v.x),\n            mix(rnd(i+e.xyy),rnd(i+e.yyy),v.x),v.y),v.z);\n}\n\nfloat fbm(vec3 v)\n{\n    float ret=0.0,w=2.0;\n    //for(int i=0;i<3;++i) ret+=(w*=0.5)*vnoise(v*=0.016*mat3(45,60,-100,-12,109,60,116,-12,45));\n    for(int i=0;i<7;++i) ret+=(w*=0.5)*vnoise(v*=2.0);\n    return ret;\n}\n\n//==============================================================================\n// Gabor blobs from https://www.shadertoy.com/view/lcBXDW\n\nconst float pi=3.14159265358979;\n\n// Approximation of exp(-Im(z)^2)*erf(z).\n// Abs. error ~0.025.\n// See https://www.shadertoy.com/view/Mf2XWz for more\n// accurate version.\nvec2 F(vec2 z)\n{\n    float x=z.x,y=z.y,x2=x*x,y2=y*y;\n    float D=3.0*y*(4.0+y2)/(12.0+y2*(11.0+6.0*y2)); // Approx. of Dawson integral.\n    float E=tanh(x*(1.129675826+x2*0.099792702));   // Approx. of erf(x), see https://www.shadertoy.com/view/ml3yWj.\n    float w=1.12837*D*exp(-x2)/sqrt(1.0+0.363*x2);\n    float a=(1.0-0.590/(1.0+0.119*x2+0.538*y2))*2.0*x*y;\n    return vec2(E*exp(-y2)+w*sin(a),w*cos(a));\n}\n\n// ∫ exp(-P^2*t^2-Q*t-R)*cos(A*t+B) dt on (-∞;+∞).\nfloat K(float P,float Q,float R,float A,float B)\n{\n    return sqrt(pi)*cos(0.5*A*Q/(P*P)-B)*exp(-R+(Q*Q-A*A)/(4.0*P*P))/P;\n}\n\n// ∫ exp(-P^2*t^2-Q*t-R)*cos(A*t+B) dt on [L;H].\nfloat I(float P,float Q,float R,float A,float B,float L,float H)\n{\n    float X=0.5*Q/P;\n    float Y=0.5*A/P;\n    float Z=2.0*X*Y-B;\n    vec2 Fl=F(vec2(P*L+X,Y));\n    vec2 Fh=F(vec2(P*H+X,Y));\n    return (0.5*sqrt(pi)/P)*exp(X*X-R)*dot(vec2(cos(Z),-sin(Z)),Fh-Fl);\n}\n\n//==============================================================================\n// Data and functions for Gabor blobs.\n\n// A structure that describes a Gabor blob,\n// which defines a scalar field, with value\n// at point r being\n//     A*exp(-transpose(r-c)*M*(r-c))*cos(dot(k,r-c)+P)\n// NOTE: M is required to be positive semi-definite,\n// but is not required to by symmetric, though you might\n// just as well symmetrize it, seeing as (M+transpose(M))/2\n// defines the same field.\n// Examples:\n//   1. mat3(X,0,0,\n//           0,Y,0,\n//           0,0,Z)\n//      describes an axis-aligned ellipsoid with radii sqrt(1/X), sqrt(1/Y), sqrt(1/Z).\n//   2. mat3(D,0,0,\n//           0,D,0,\n//           0,0,0)\n//      describes a beam of radius sqrt(1/D) along z axis.\n//   3. mat3(0,0,0,\n//           0,0,0\n//           0,0,D)\n//      describes an xy plane of thickness sqrt(1/D).\n// All of these are valid values.\nstruct Blob\n{\n    float A; // Amplitude.\n    vec3  c; // Center.\n    mat3  M; // Quadratic form.\n    vec3  k; // Wave vector.\n    float P; // Phase offset.\n};\n\n// Evaluate blob's field at point r.\nfloat BlobG(Blob b,vec3 r)\n{\n    return b.A*exp(-dot((r-b.c)*b.M,r-b.c))*cos(dot(b.k,r-b.c)+b.P);\n}\n\n// Integrate blob's field along the\n// ray ro+t*rd, on (-∞;+∞).\nfloat BlobK(Blob b,vec3 ro,vec3 rd)\n{\n    return b.A*K(\n        sqrt(dot((rd*b.M),rd)),\n        (dot((ro-b.c)*b.M,rd)+dot(rd*b.M,ro-b.c)),\n        dot((ro-b.c)*b.M,ro-b.c),\n        dot(b.k,rd),\n        dot(b.k,ro-b.c)+b.P);\n}\n\n// Integrate blob's field along the\n// ray ro+t*rd, on [L,H].\nfloat BlobI(Blob b,vec3 ro,vec3 rd,float L,float H)\n{\n    return b.A*I(\n        sqrt(dot((rd*b.M),rd)),\n        (dot((ro-b.c)*b.M,rd)+dot(rd*b.M,ro-b.c)),\n        dot((ro-b.c)*b.M,ro-b.c),\n        dot(b.k,rd),\n        dot(b.k,ro-b.c)+b.P,\n        L,H);\n}\n\n// Expressions for product of 2 blobs.\n// Handy for (Blob(...))^2, producing\n// a non-negative field.\n\nfloat BlobProductG(Blob f,Blob g,vec3 r)\n{\n    return BlobG(f,r)*BlobG(g,r);\n}\n\nfloat BlobProductK(Blob f,Blob g,vec3 ro,vec3 rd)\n{\n    float P=sqrt(dot((rd*f.M),rd)+dot((rd*g.M),rd));\n    float Q=\n        (dot((ro-f.c)*f.M,rd)+dot(rd*f.M,ro-f.c))+\n        (dot((ro-g.c)*g.M,rd)+dot(rd*g.M,ro-g.c));\n    float R=dot((ro-f.c)*f.M,ro-f.c)+dot((ro-g.c)*g.M,ro-g.c);\n    float Am=dot(f.k-g.k,rd),Ap=dot(f.k+g.k,rd);\n    float Bm=(dot(f.k,ro-f.c)+f.P)-(dot(g.k,ro-g.c)+g.P);\n    float Bp=(dot(f.k,ro-f.c)+f.P)+(dot(g.k,ro-g.c)+g.P);\n    return 0.5*f.A*g.A*(K(P,Q,R,Am,Bm)+K(P,Q,R,Ap,Bp));\n}\n\nfloat BlobProductI(Blob f,Blob g,vec3 ro,vec3 rd,float L,float H)\n{\n    float P=sqrt(dot((rd*f.M),rd)+dot((rd*g.M),rd));\n    float Q=\n        (dot((ro-f.c)*f.M,rd)+dot(rd*f.M,ro-f.c))+\n        (dot((ro-g.c)*g.M,rd)+dot(rd*g.M,ro-g.c));\n    float R=dot((ro-f.c)*f.M,ro-f.c)+dot((ro-g.c)*g.M,ro-g.c);\n    float Am=dot(f.k-g.k,rd),Ap=dot(f.k+g.k,rd);\n    float Bm=(dot(f.k,ro-f.c)+f.P)-(dot(g.k,ro-g.c)+g.P);\n    float Bp=(dot(f.k,ro-f.c)+f.P)+(dot(g.k,ro-g.c)+g.P);\n    return 0.5*f.A*g.A*(I(P,Q,R,Am,Bm,L,H)+I(P,Q,R,Ap,Bp,L,H));\n}\n\nBlob Blob_translate(Blob b,vec3 r)\n{\n    return Blob(b.A,b.c+r,b.M,b.k,dot(b.k,r)+b.P);\n\n}\n\nBlob Blob_rotate(Blob b,mat3 R)\n{\n    return Blob(b.A,b.c,transpose(R)*b.M*R,transpose(R)*b.k,b.P);\n}\n\n//==============================================================================\n// SDF raymarching.\n// See e.g. https://iquilezles.org/articles/sdfrepetition/, etc..\n\nfloat H(vec3 r) {return -1e-3*dot(r,r);}\n\n// Based on https://www.shadertoy.com/view/wdXGDr\nfloat cylinder(vec3 p,float h,float r,float a)\n{\n  vec2 d=abs(vec2(length(p.xy),p.z))-vec2(r,h);\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0))-a;\n}\n\nfloat sdf(vec3 r)\n{\n    float ret=1e5;\n    mat2 m=mat2(0.8,-0.6,0.6,0.8);\n    for(int i=0;i<3;++i)\n    {\n        vec2 s=vec2(8.0);\n        vec3 v=r;\n        v.xy+=5.3*float(i);\n        v.xy*=(m*=m*m);\n        vec2 id=round(v.xy/s);\n        v.xy-=s*id;\n        v.z+=4.0-H(r);\n        ret=min(ret,cylinder(v,4.0,1.0,0.125));\n    }\n    return ret;\n}\n\n//==============================================================================\n// Main image.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 xy=(2.0*fragCoord-iResolution.xy)/iResolution.y;\n\tfloat a=0.0625*iTime;\n    // Camera setup.\n    // +x=East, +y=North, +z=Up.\n\tvec3 ro=vec3(7.0*cos(a)+sin(1.3*a),8.0*sin(0.7*a),3.5*sin(a)+cos(1.3*a)+7.0);\n    vec3 ta=vec3(0.0,0.0,2.0+4.0*sin(1.7*a));\n    if(false) // Static camera.\n    {\n        ro=vec3(2,5,7);\n        ta=vec3(0,0,5);\n    }\n    vec3 ww=normalize(ta-ro);\n    vec3 uu=normalize(cross(ww,vec3(0.0,0.0,1.0)));\n    vec3 vv=normalize(cross(uu,ww));\n    vec3 rd=normalize(xy.x*uu+xy.y*vv+1.5*ww);\n    vec3 fog_color=vec3(0.625,0.7,0.75);\n    vec3 light=normalize(vec3(1,2,5));\n    vec3 col=pow(vec3(0.5,0.75,0.75),1.0+vec3(9,7,2)*(rd.z+0.1));\n    col=mix(col,2.0*vec3(1.0,0.625,0.375),smoothstep(0.995,1.0,dot(rd,light)));\n    col=mix(col,fog_color,smoothstep(0.1,0.0,rd.z+0.1));\n    // Raymarching.\n    float t=0.0,M=1e2,m=1e-2;\n    vec3 r=ro;\n    const int N=70;\n    for(int i=0;i<N;++i)\n    {\n        r=ro+t*rd;\n        float d=sdf(r);\n        if(d<m) break;\n        t+=d;\n        if(t>M) break;\n    }\n    // Object.\n    if(t<M)\n    {\n        vec2 e=vec2(0,1);\n        vec3 n=normalize(vec3(\n            sdf(r+e.yxx)-sdf(r-e.yxx),\n            sdf(r+e.xyx)-sdf(r-e.xyx),\n            sdf(r+e.xxy)-sdf(r-e.xxy)));\n        col=vec3(0.8,0.75,0.7)*(0.5+0.25);\n        float b=\n            smoothstep(-0.51,-0.53,r.z-H(r))*\n            smoothstep(0.35,0.37,sin(16.0*r.z+1.0))*\n            smoothstep(-0.75,-0.73,sin(32.0*atan(n.y,n.x)+1.0));\n        float c=smoothstep(-0.05,-0.02,r.z-H(r)+2.0+fbm(vec3(2,2,0.5)*r));\n        c*=1.0-b;\n        col=mix(col,vec3(0.375,0.5,0.375)+5.0*pow(max(dot(n,normalize(light-rd)),0.0),8.0),b);\n        col=mix(col,vec3(0.25,0.625,0.125),c);\n        n=normalize(n+((1.0-b)*0.0625+0.0625*c)*fbm((7.3+5.3*c)*r)+b*n);\n        col*=(0.0625+mix(0.75*max(dot(n,light),0.0),1.0,0.125*b));\n    }\n    // Fog.\n    float f=0.0;\n    for(int i=0;i<7;++i)\n    {\n        float k=float(i);\n        Blob b=Blob(2.0+sin(k),vec3(0,0,-8),mat3(0,0,0,0,0,0,0,0,0.125),1.0*sin(2.0+vec3(3*i,4*i*i,5*i*i*i)),(1.0+sin(k*k))*iTime);\n        f+=BlobProductI(b,b,ro,rd,0.0,t);\n    }\n    col=mix(fog_color,col,exp(-f));\n    col=tanh(1.125*col); // Tonemap.\n    col.xyz=mix(12.92*col.xyz,1.055*pow(col.xyz,vec3(1.0/2.4))-0.055,step(0.0031308,col.xyz)); // sRGB\n    fragColor=vec4(col.xyz,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}