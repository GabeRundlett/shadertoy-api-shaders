{
    "Shader": {
        "info": {
            "date": "1674131402",
            "description": "Roman Pantheon; use mouse to select view and look around.",
            "flags": 0,
            "hasliked": 0,
            "id": "Dl2GDt",
            "likes": 21,
            "name": "Pantheon",
            "published": 3,
            "tags": [
                "oculus",
                "temple",
                "architecture",
                "dome",
                "rome"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 282
        },
        "renderpass": [
            {
                "code": "// \"Pantheon\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/* \n  Some of the Pantheon's architectural features are roughly reproduced.\n  \n  Views: interior and exterior, fixed and variable sections, panorama.\n\n  Interior is dim since occulus in only light source; an update with\n  modern lighting is coming soon.\n\n  No. 74 in \"Architecture\" series - listed at end\n*/\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (vec2 vAzEl);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 RotVF (vec3 v, vec4 cs);\nvec3 RotVB (vec3 v, vec4 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, doorSz, cutVec;\nvec2 bmAzEl, drAngCs;\nfloat tCur, dstFar, domeRd, domeBs, oculRd, wallRd, wallThk, wallHt;\nint idObj, dirCut;\nconst int idDomeI = 1, idDomeM = 2, idDomeO = 3, idDomeOx = 4, idWallin = 5, idWallex = 6,\n   idCeil = 7, idFlor = 8, idPort = 9, idPortRf = 10, idGrt = 11, idPil = 12, idPlin = 13,\n   idBall = 14, idEnt = 15, idDoor = 16, idBase = 17;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define CUT Cut (p, d);\n#define DMIN(id) CUT if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) CUT if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid Cut (vec3 p, inout float d)\n{\n  if (dirCut > 0) d = max (d, dot (p, cutVec));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 nSeg, a, b1, b2, dmx[3], u;\n  float dMin, d, dd, r, rh, t;\n  dMin = dstFar;\n  nSeg = vec2 (28., 27.);\n  rh = length (p.xz);\n  r = length (p - vec3 (0., domeBs, 0.));\n  q = p;\n  q.y -= domeBs;\n  a = 2. * pi * (floor (nSeg * atan (q.zy, - vec2 (q.x, rh)) / (2. * pi)) + 0.5) / nSeg;\n  b1 = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  b1.y = abs (b1.y);\n  b2 = Rot2Cs (vec2 (rh, q.y), sin (a.y + vec2 (0.5 * pi, 0.)));\n  b2.y = abs (b2.y);\n  for (int k = 0; k < 3; k ++) {\n    u = sin (0.1 * float (k + 1) * 2. * pi / nSeg + vec2 (0., 0.5 * pi));\n    dmx[k] = vec2 (dot (b1, u), dot (b2, u));\n  }\n  t = domeRd - r;\n  d = max (min (max (abs (t - 0.06) - 0.01, Minv2 (dmx[0])),\n     max (abs (t - 0.04) - 0.04, rh - 0.43)), max (oculRd - rh, -0.01 - q.y));\n  DMIN (idDomeI);\n  d = max (min (max (abs (t - 0.045) - 0.01, Minv2 (dmx[1])),\n     max (abs (t - 0.03) - 0.01, Minv2 (dmx[2]))), max (0.42 - rh, - q.y));\n  DMIN (idDomeM);\n  dd = domeRd + 0.45 - length (vec3 (q.x, q.y + 0.42, q.z));\n  d = max (- min (dd, q.y), t - 0.02);\n  d = max (max (d, oculRd - rh), min (1.6 - rh, 0.2 - abs (q.y + 0.2)));\n  DMIN (idDomeO);\n  d = max (min (max (abs (dd) - 0.02, max (oculRd - rh, dmx[0].x - 0.005)),\n     max (abs (dd) - 0.025, abs (oculRd + 0.05 - rh) - 0.05)), - q.y);\n  DMIN (idDomeOx);\n  d = max (min (min (min (max (abs (0.15 + dd) - 0.05, q.y - 0.44),\n     max (abs (0.1 + dd) - 0.05, q.y - 0.48)),\n     max (abs (0.05 + dd) - 0.05, q.y - 0.52)),\n     max (abs (dd) - 0.05, q.y - 0.56)), - q.y + 0.3);\n  DMIN (idDomeOx);\n  q = p;\n  d = max (max (rh - wallRd + wallThk, domeRd - rh - 0.025), abs (q.y - domeBs + 0.13) - 0.27);\n  dd = length (vec2 (Minv2 (abs (q.xz)), q.y - domeBs + 0.52)) - 0.2;\n  d = max (d, - max (rh - wallRd + wallThk + 0.03, dd));\n  DMIN (idCeil);\n  d = max (max (max (abs (domeRd - rh - 0.02) - 0.04, abs (q.y - domeBs + 0.2) - 0.2),\n     min (dmx[1].x, 0.09 - abs (q.y - domeBs + 0.15))), - dd);\n  DMIN (idWallin);\n  d = max (abs (wallRd - wallThk - rh) - 0.03, abs (q.y - domeBs + 0.86) - 0.54);\n  if (q.z > 0. && abs (q.x) < 0.23) {\n    t = min (0.22 - abs (q.x), - q.y + domeBs - 0.54);\n  } else {\n    d = max (d, min (dmx[1].x - 0.03, 0.25 - abs (q.y - domeBs + 0.8)));\n    u = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    t = 0.15 - length (vec3 (abs (u.x) - wallRd + wallThk + 0.05, max (0., q.y - domeBs + 0.59),\n       u.y));\n  }\n  d = max (d, t);\n  DMIN (idWallin);\n  d = max (max (abs (wallRd - rh) - wallThk, abs (q.y - wallHt - 0.03) - wallHt), t);\n  DMIN (idWallex);\n  d = max (length (vec2 (rh - wallRd - wallThk, abs (abs (q.y - wallHt - 0.03) - 0.6) -\n     0.27)) - 0.02, min (q.z, 1. - abs (q.x)));\n  DMIN (idWallex);\n  q = p;\n  q.y -= 0.51;\n  d = max (max (abs (wallRd - rh - 0.01) - wallThk - 0.07, length (vec2 (q.x,\n     max (q.y - 0.28, 0.))) - 0.24), -0.45 - q.y);\n  d = max (max (d, - max (abs (q.x) - 2. * doorSz.x - 0.01, abs (q.y) - doorSz.y)), - q.z);\n  dd = d;\n  DMIN (idEnt);\n  t = 0.97/12.;\n  q = p;\n  q.y -= 0.09;\n  d = max (rh - wallRd - wallThk, abs (q.y) - 0.05);\n  d = max (d, min (t - rh, q.y + 0.01));\n  d = max (d, - dd);\n  DMIN (idFlor);\n  q = p;\n  d = max (max (rh - t, abs (q.y - 0.13) - 0.01),\n     min (0.3 * t - abs (0.6 * t - rh), dmx[2].x));\n  DMIN (idGrt);\n  if (p.z < 0.3) {\n    q = p;\n    q.xz = (abs (q.x) > abs (q.z)) ? q.xz : q.zx;\n    q.y -= 0.28;\n    q.x = abs (q.x) - wallRd + wallThk + 0.04;\n    d = min (max (length (q.xz) - 0.02, abs (q.y) - 0.13),\n       PrRoundBoxDf (vec3 (q.xz, abs (q.y) - 0.13).xzy, vec3 (0.06, 0.005, 0.06), 0.005));\n    DMINQ (idPlin);\n    d = PrSphDf (vec3 (q.xz, q.y - 0.21).xzy, 0.07);\n    DMIN (idBall);\n  }\n  q = p;\n  q.z -= wallRd + wallThk;\n  d = max (PrBoxDf (vec3 (q.x, q.y - wallHt - 0.03, q.z + 0.1), vec3 (1.05, wallHt, 0.21)),\n     - PrBox2Df (vec2 (q.x, q.y - 0.6), vec2 (0.7, 0.46)));\n  d = min (d, PrBoxDf (vec3 (q.x, abs (q.y - 0.58) - 0.49, q.z - 0.47), vec3 (1.05, 0.05, 0.47)));\n  DMIN (idPort);\n  d = max (PrRoundBoxDf (vec3 (q.x, q.y - 2. * wallHt, q.z + 0.1), vec3 (1.05, 0., 0.21), 0.02),\n     wallRd + 0.03 - rh);\n  DMIN (idWallex);\n  q = p;\n  q.yz -= vec2 (1.56, wallRd + wallThk + 0.31);\n  d = PrBox2Df (q.xz, vec2 (1.09, 0.67));\n  q.x = abs (q.x);\n  u = Rot2Cs (q.xy, CosSin (0.125 * pi));\n  d = max (d, max (max (u.y - 0.01, -0.45 - q.y), - max (max (u.y + 0.04, -0.4 - q.y), 0.63 - q.z)));\n  d = max (d, - max (min (max (PrBox2Df (vec2 ((fract (16. * q.x + 0.5) - 0.5) / 16.,\n     q.y + 0.45), vec2 (1.2/64., 0.02)), q.x - 0.98), max (PrBox2Df (vec2 ((fract (16. * u.x +\n     0.75) - 0.5) / 16., u.y + 0.04), vec2 (1.2/64., 0.02)), u.x - 0.9)), 0.63 - q.z));\n  DMIN (idPortRf);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (2. * doorSz.x, 0.51, wallRd);\n  q.xz = Rot2Cs (q.xz, drAngCs) + doorSz.xz * vec2 (1., -1.);\n  d = PrBoxDf (q, doorSz);\n  DMINQ (idDoor);\n  q = p;\n  q.y -= 0.59;\n  d = 0.15 - Minv2 (abs (q.xz));\n  q.xz = Rot2Cs (q.xz, sin (a.x + vec2 (0.5 * pi, 0.)));\n  q.z = abs (q.z);\n  q.xz -= vec2 (- wallRd + wallThk + 0.15, 0.05);\n  u = vec2 (length (q.xz) - 0.025, abs (q.y) - 0.45);\n  d = max (d, max (Maxv2 (u), 0.022 - length (vec2 (u.x - 0.01, - max (u.y + 0.04, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  q.yz -= vec2 (0.585, wallRd + wallThk + 0.4);\n  d = max (max (abs (q.x) - 1.1, abs (q.z - 0.1) - 0.4),\n     - max (abs (abs (abs (q.x) - 0.42) - 0.27) - 0.11, q.z - 0.23));\n  q.xz = (1./3.7) * (abs (fract (3.7 * q.xz) - 0.5));\n  u = vec2 (length (q.xz) - 0.08, abs (q.y) - 0.44);\n  d = max (d, max (Maxv2 (u), 0.06 - length (vec2 (u.x - 0.02, - max (u.y + 0.09, 0.)))));\n  DMINQ (idPil);\n  q = p;\n  d = max (rh - wallRd - wallThk - 1.4, abs (q.y - 0.02) - 0.02);\n  DMINQ (idBase);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (h, 0.01);\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 FloorCol (vec2 p)\n{\n  vec4 col4;\n  vec2 wd, w;\n  p = 6. * p + 0.5;\n  wd = abs (fract (p + 0.5) - 0.5);\n  if (Minv2 (wd) < 0.01) {\n    col4 = vec4 (0.6, 0.6, 0.6, 0.);\n  } else {\n    w = mod (floor (p), 2.);\n    col4 = mix (vec4 (0., 0., 0.8, 0.1), vec4 (0.8, 0.8, 0.8, 0.1), smoothstep (0.15, 0.2,\n       fract (16. * Fbm2 (Rot2D (vec2 (2., 4./3.) * p,\n       0.25 * pi * (0.5 + w.x + 2. * w.y)) + 20.))));\n    if (w.x == w.y) col4 = mix (((dot (mod (floor (p), 4.), vec2 (1., -1.)) == 0.) ?\n       vec4 (0.4, 0., 0., 0.1) : vec4 (0.6, 0.6, 0.55, 0.1)), mix (vec4 (0.7, 0.5, 0., 0.1),\n       col4, 0.1 + 0.9 * step (Minv2 (wd - 0.13), 0.)), step (0.28, length (wd - 0.5)));\n    else col4 = mix (vec4 (0.4, 0., 0., 0.1), col4, 0.1 + 0.9 * step (0.07,\n       abs (Minv2 (wd - 0.2))));\n  }\n  return col4;\n}\n\nvec4 ObjCol (vec3 ro, out vec2 vf)\n{\n  vec4 col4, mCol4, dwCol4;\n  vec2 u;\n  float rh, a, x, wtm, wtp;\n  mCol4 = vec4 (0.8, 0.8, 0.75, 0.);\n  dwCol4 = vec4 (0.3, 0.3, 0.7, 0.);\n  vf = vec2 (0.);\n  rh = length (ro.xz);\n  wtm = wallRd - wallThk;\n  wtp = wallRd + wallThk;\n  if (idObj <= idFlor) {\n    if (idObj == idDomeI) {\n      if (rh < oculRd + 0.002) col4 = mCol4;\n      else if (rh < 0.43) col4 = dwCol4;\n      else col4 = 1.1 * mCol4;\n    } else if (idObj == idDomeM) {\n      col4 = 1.05 * mCol4;\n    } else if (idObj == idDomeO) {\n      if (length (ro - vec3 (0., domeBs, 0.)) < domeRd) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (32. *\n           atan ((ro.y - 1.12) / rh) / pi)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idDomeOx) {\n      col4 = vec4 (1., 1., 1.1, 1.) * mCol4;\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idWallin) {\n      a = atan (ro.z, - ro.x) / (2. * pi) + 0.5;\n      if (rh > wtm - 0.02 && ro.y < 1. && ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22)) {\n        col4 = dwCol4;\n      } else if (rh < wtm - 0.05 && ro.y < 1.15) {\n        col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.) * (1.2 - 0.2 * step (0.01,\n           PrBox2Df (vec2 (fract (224. * a + 0.5) - 0.5, ro.y - 1.14), vec2 (0.3, 0.004))));\n      } else {\n        a = fract (28. * a + 0.5) - 0.5;\n        col4 = mCol4 * (1.2 - 0.2 * step (0.01, min (PrBox2Df (vec2 (a, ro.y - domeBs + 0.15),\n           vec2 (0.35, 0.09)), PrBox2Df (vec2 (a, ro.y - domeBs + 0.8), vec2 (0.24, 0.25)))));\n        if (ro.y > 0.92) col4 *= 1.2 - 0.2 * step (0.2, length (vec2 (a, 3.3 * (ro.y - 0.92))));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idWallex) {\n      if (ro.y < 1. && (rh < wtm + 0.03 && abs (ro.x) > 0.22 || rh < wtm + 0.11 &&\n         ro.y > 0.12 && (ro.z < 0. || abs (ro.x) > 0.22))) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        if (rh > wtp - 0.02) {\n          u = Rot2Cs (ro.xz, CosSin (pi / 14.));\n          x = 0.5 * wtp * dot (u.yx, CosSin (2. * pi * (floor (14. *\n             atan (u.y, - u.x) / (2. * pi)) + 0.5) / 14.));\n          if (ro.y > 1.44 && abs (length (vec2 (x, ro.y - 1.12)) - 0.55) < 0.05 ||\n             abs (ro.y - 1.36) < 0.08 && abs (x) > 0.37) col4 = 1.03 * mCol4;\n          if (PrBox2Df (vec2 (x, ro.y - 1.34), vec2 (0.04, 0.06)) < 0.)\n             col4 = vec4 (0.3, 0.3, 0.3, 0.);\n        }\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idCeil) {\n      if (ro.y < 1.2 && rh < wtm - 0.01) {\n        col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n      } else if (rh < domeRd) {\n        col4 = dwCol4;\n      } else {\n        col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n        vf = vec2 (128., 0.8);\n      }\n    } else if (idObj == idFlor) {\n      if (ro.y > 0.12 && rh < wallRd) {\n        col4 = FloorCol (ro.xz);\n      } else if (rh < 0.85 * oculRd && ro.y > 0.05) {\n        col4 = vec4 (0., 0.3, 0., 0.);\n      } else {  \n        col4 = mCol4;\n        vf = vec2 (128., 0.8);\n      }\n    }\n  } else {\n    if (idObj == idPil || idObj == idPlin) a = abs (fract (16. * atan (qHit.z, qHit.x) /\n       (2. * pi) + 0.5) - 0.5);\n    if (idObj == idPort) {\n      col4 = mCol4 * (0.95 + 0.05 * smoothstep (0.05, 0.1, fract (8. * ro.y)));\n      if (abs (ro.x) < 1.04 && abs (dot (vec2 (abs (ro.x), ro.y), sin (0.125 * pi +\n         vec2 (0., 0.5 * pi))) - 1.54) < 0.02) col4 = 1.03 * mCol4;\n      if (abs (ro.x) > 1. && PrBox2Df (vec2 (abs (ro.y - 0.5 * wallHt - 0.5) - 0.5,\n         ro.z - wtp + 0.1), vec2 (0.08, 0.04)) < 0.) col4 = vec4 (0.3, 0.3, 0.3, 0.); \n      vf = vec2 (128., 0.8);\n    } else if (idObj == idPortRf) {\n      col4 = mCol4 * vec4 (1., 0.95, 0.95, 1.) * (0.9 +\n         0.1 * step (0.05, abs (fract (16. * ro.z + 0.8) - 0.5)));\n      vf = vec2 (128., 0.8);\n    } else if (idObj == idGrt) {\n      col4 = vec4 (1., 0.8, 0., 0.2);\n    } else if (idObj == idPil) {\n      col4 = (rh < wallRd) ? vec4 (0.65, 0.6, 0.6, 0.) : 0.95 * mCol4;\n      if (abs (qHit.y) < 0.41) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idPlin) {\n      col4 = vec4 (0.8, 0.7, 0.6, 0.);\n      if (abs (qHit.y) < 0.11) col4 *= 0.9 + 0.1 * smoothstep (0.1, 0.15, a);\n    } else if (idObj == idBall) {\n      col4 = vec4 (vec3 (0.9, 0.8, 0.5) * (1. - 0.2 * Fbm1 (16. * tCur)), -1.);\n    } else if (idObj == idEnt) {\n      col4 = mCol4 * vec4 (1.1, 1.1, 0.9, 1.);\n    } else if (idObj == idDoor) {\n      col4 = vec4 (0.3, 0.3, 0., 0.1) * (0.8 + 0.2 * step (0., PrBox2Df (qHit.xy,\n         doorSz.xy - 0.03)));\n    } else if (idObj == idBase) {\n      u = qHit.xz * vec2 (1./6., 1.) * 16.;\n      x = u.x + 1./3. + ((fract (0.5 * u.y) < 0.5) ? 0. : 0.5);\n      col4 = vec4 (0.5, 0.5, 0.5, 0.) * (0.9 + 0.1 * smoothstep (0.1, 0.15,\n         min (fract (u.y), 6. * min (fract (x), fract (x + 2./3.)))));\n    }\n  }\n  return col4;\n}\n\nvec4 CylHit (vec3 ro, vec3 rd, float rad, out vec3 rHit)\n{\n  vec3 vn;\n  float dMin, d, a, b, w;\n  dMin = 1e6;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  w = b * b - a * (dot (ro.xz, ro.xz) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      d /= a;\n      rHit = ro + d * rd;\n      dMin = d;\n      vn = vec3 (rHit.xz / rad, 0.).xzy;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BmVal (vec3 ro, vec3 rd, float dstLim, float bmRad, out vec3 bmHit, out vec3 bmAx)\n{  // (circular cross section)\n  vec4 dc4, csBm;\n  float bmVal;\n  csBm = vec4 (CosSin (bmAzEl.x), CosSin (bmAzEl.y));\n  bmAx = RotVF (vec3 (0., -1., 0.), csBm);\n  bmVal = 0.;\n  dc4 = CylHit (RotVB (ro, csBm), RotVB (rd, csBm), bmRad, bmHit);\n  if (dc4.x < dstLim) {\n    bmVal = max (- dot (RotVF (dc4.yzw, csBm), rd), 0.);\n    bmHit = RotVF (bmHit, csBm);\n  }\n  return bmVal;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltDir, col, vn, roo, bmHit, bmAx, oculPos;\n  vec2 vf;\n  float dstObj, dstGrnd, sh, bmVal;\n  bool inBldg, isBg;\n  domeRd = 1.2;\n  domeBs = domeRd + 0.24;\n  wallRd = 1.7;\n  wallHt = 0.9;\n  wallThk = 0.26;\n  oculRd = 0.16;\n  oculPos = vec3 (0., domeBs + domeRd, 0.);\n  doorSz = vec3 (0.09, 0.35, 0.013);\n  drAngCs = CosSin (-0.5 * pi * clamp (-0.3 + 1.6 * abs (2. * fract (0.25 * tCur) - 1.), 0., 1.));\n  roo = ro;\n  isBg = false;\n  inBldg = false;\n  dstGrnd = dstFar;\n  sh = 1.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    inBldg = ((dirCut == 0 && ((length (ro.xz) < wallRd && ro.y < 2. * wallHt ||\n       length (ro - vec3 (0., domeBs, 0.)) < domeRd && ro.y > domeBs) ||\n       idObj == idEnt && ro.z < wallRd || idObj == idDoor)) || idObj == idBall);\n    col4 = ObjCol (ro, vf);\n    if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      if (inBldg) {\n        ltDir = normalize (oculPos - ro);\n        col = col4.rgb * (0.05 + 0.4 * max (dot (vn, ltDir), 0.)) +\n           col4.a * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n      }\n    } else {\n      col = col4.rgb * (0.4 + 0.6 * max (- dot (rd, vn), 0.));\n    }\n  } else if (rd.y < 0. && dirCut == 0) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = VaryNf (16. * ro, vec3 (0., 1., 0.), 1. - smoothstep (0.5, 0.8, dstGrnd / dstFar));\n    col4 = vec4 (0.5 * mix (vec3 (0.8, 1., 0.5), vec3 (0.7, 0.9, 0.5), 0.2 +\n       0.8 * smoothstep (0.3, 0.7, Fbm2 (4. * ro.xz))), 0.05);\n  } else {\n    isBg = true;\n    col = (dirCut == 0) ? SkyBgCol (ro, rd) : vec3 (0.3, 0.4, 0.5) * (0.7 + 0.3 * rd.y);\n  }\n  if (! isBg && ! inBldg) {\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) +\n       0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    if (dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5), pow (1. + rd.y, 16.));\n  }\n  if (inBldg) {\n    bmVal = BmVal (roo - oculPos, rd, min (dstObj, dstFar), oculRd, bmHit, bmAx);\n    bmHit += oculPos;\n    if (bmVal > 0. && length (bmHit.xz) < wallRd - 0.12 && bmHit.y > 0.12) {\n      col += 0.2 * col4.rgb * max (0., - dot (vn, bmAx)) * (1. - smoothstep (-0.1, 0.1,\n         length (ro - oculPos - dot (ro - oculPos, bmAx) * bmAx) - oculRd));\n      if (bmHit.y < oculPos.y + 0.02) col += 0.2 * vec3 (1., 1., 0.9) * bmVal;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define N_WIN  4\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw, mAzEl, vAzEl;\n  float zmFac, asp, sr, t, tt;\n  int vuId, regId;\n  bool isPano;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (asp, 1.);\n  mMid[1] = (1. - mSize.y) * vec2 (- asp, 1.);\n  mMid[2] = (1. - mSize.y) * vec2 (- asp, -1.);\n  mMid[3] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  mAzEl = (mPtr.z > 0. && vuId == regId) ? vec2 (2., 1.) * pi * msw : vec2 (0.);\n  if (mPtr.z <= 0.) {\n    t = mod (0.04 * tCur, 2.);\n    t = (abs ((floor (8. * t) + smoothstep (0.8, 1., fract (8. * t))) / 8. - 1.) - 0.5);\n  } else t = 0.;\n  dirCut = 0;\n  isPano = false;\n  if (vuId == 0) {\n    ro = vec3 (0., 0.6, -1.);\n    vAzEl = vec2 (0.25 * pi + mAzEl.x + 0.2 * pi * t, clamp (0.04 * pi + mAzEl.y, -0.4 * pi, 0.4 * pi));\n    zmFac = 1.5;\n  } else if (vuId == 1) {\n    ro = vec3 (0., 1., -15.);\n    vAzEl = vec2 (pi + 1.1 * mAzEl.x + 0.4 * pi * t, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.));\n    zmFac = 5.5;\n  } else if (vuId == 2) {\n    ro = vec3 (0., 1.5, -0.1);\n    vAzEl = vec2 (1.1 * mAzEl.x, clamp (0.5 *  mAzEl.y, -0.15 * pi, 0.15 * pi));\n    zmFac = 0.3;\n    isPano = true;\n  } else if (vuId == 3) {\n    ro = vec3 (0., 1.2, -10.);\n    vAzEl = vec2 (1.1 * mAzEl.x, 0.);\n    zmFac = 5.;\n    dirCut = 2;\n  } else if (vuId == 4) {\n    ro = vec3 (0., 1.3, -10.);\n    vAzEl = vec2 (-0.5 * pi + 1.1 * mAzEl.x, clamp (-0.1 * pi + mAzEl.y, -0.4 * pi, 0.4 * pi));\n    zmFac = 5.;\n    dirCut = 1;\n  }\n  vuMat = StdVuMat (vAzEl);\n  ro = vuMat * ro;\n  if (vuId == 0) ro.y = max (ro.y, 0.2);\n  if (dirCut == 1) {\n    cutVec = vec3 (1., 0., 0.);\n  } else if (dirCut == 2) {\n    cutVec = vec3 (0., 0., -1.);\n    cutVec.xz = Rot2D (cutVec.xz, - vAzEl.x);\n  }\n  tt = 1. - fract (0.02 * tCur);\n  t = SmoothBump (0.25, 0.75, 0.23, tt);\n  bmAzEl = pi * ((tt < 0.5) ? vec2 (0.5 + t, 0.16) : vec2 (0.5, 0.16 * (1. - 2. * t)));\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 60.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (isPano ? vec3 (2. * sin (uvv.x / asp + vec2 (0., 0.5 * pi)),\n       uvv.y).xzy : vec3 (2. * tan (0.5 * atan (uvv / vec2 (asp, 1.))) * vec2 (asp, 1.), 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.7, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (Maxv2 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (vec2 vAzEl)\n{\n  vec2 ca, sa;\n  ca = cos (vAzEl);\n  sa = sin (vAzEl);\n  return mat3 (ca.x, 0., - sa.x, 0., 1., 0., sa.x, 0., ca.x) *\n         mat3 (1., 0., 0., 0., ca.y, - sa.y, 0., sa.y, ca.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, cs * vec2 (1., -1.)), dot (q.yx, cs));\n}\n\nvec3 RotVF (vec3 v, vec4 cs)\n{\n  v.yz = Rot2Cs (v.yz, cs.zw * vec2 (1., -1.));\n  v.xz = Rot2Cs (v.xz, cs.xy * vec2 (1., -1.));\n  return v;\n}\n\nvec3 RotVB (vec3 v, vec4 cs)\n{\n  v.xz = Rot2Cs (v.xz, cs.xy);\n  v.yz = Rot2Cs (v.yz, cs.zw);\n  return v;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/* \n \"Architecture\" series:\n   \"Rainbow Cavern\"                  (XsfBWM)\n   \"Fractal Bridge\"                  (XlsGRN)\n   \"Icy Moon\"                        (XllGDr)\n   \"Parthenon\"                       (MtX3DH)\n   \"Temple of the Waves\"             (Mll3W4)\n   \"Albert Mews\"                     (lts3zf)\n   \"Stairway to the Stars\"           (lt2Gzt)\n   \"Wobbly Blob\"                     (ll2SRz)\n   \"Gotham City\"                     (XljXR3)\n   \"Magic Tree\"                      (llBSDK)\n   \"Flame Ascending\"                 (Xdd3W7)\n   \"Garage\"                          (Ms33Dj)\n   \"Pannini's Rotunda\"               (Ms3SzH)\n   \"Pannini Flies Gotham\"            (4s3XzN)\n   \"Canal City\"                      (lsdXzM)\n   \"Amphitheater\"                    (Xs3XDB)\n   \"Aquatic Hippodrome\"              (4stSWB)\n   \"Urban Growth\"                    (XdXcRM)\n   \"Babel's Library\"                 (4slcW2)\n   \"Bibliotheque\"                    (lsXcWs)\n   \"Ultimate Library\"                (4s2czR)\n   \"Books and Stairs\"                (4djczw)\n   \"Mount Book\"                      (XsjcRc)\n   \"Literary Tunnel\"                 (ldSyDG)\n   \"Atlantis 2\"                      (XdlBzX)\n   \"Desert Town\"                     (XslBDl)\n   \"Voronoi Towers\"                  (XdBBRh)\n   \"Canal Ruins\"                     (4dBfzD)\n   \"Alphaville\"                      (XtfczN)\n   \"Rector's Palace\"                 (Xl2yzK)\n   \"Ocean Structure\"                 (ltBczc)\n   \"White Folly\"                     (ll2cDG)\n   \"White Folly 2\"                   (ltXfzr)\n   \"Lightweight Lighthouse\"          (XtfBz4)\n   \"Magic Tree 2\"                    (MllBzH)\n   \"Books and Stairs 2\"              (MtsfRl)\n   \"Opera Island\"                    (MlSBWG)\n   \"Blob Zoo\"                        (4sdcWN)\n   \"Hexpo\"                           (lsdcD7)\n   \"Alphapolis\"                      (4scyDj)\n   \"Paternoster\"                     (XsVyz1)\n   \"Tesla's Tower\"                   (MdycRK)\n   \"Parthenon 2\"                     (lldBDn)\n   \"Waterworld City\"                 (wlsGDn)\n   \"Palace on the Hill\"              (Wlj3DD)\n   \"Stairs to Nowhere\"               (wtB3R3)\n   \"Submerging Tower\"                (wdcGWr)\n   \"Racetrack\"                       (tscSDn)\n   \"Chateaux..\"                      (Wtd3Df)\n   \"Library Lost and Found\"          (tdlBzH)\n   \"Sand Album\"                      (3slBRf)\n   \"Water Falling\"                   (3sBfDR)\n   \"Belvedere\"                       (3dSfzt)\n   \"Escalator 2\"                     (3lBBWm)\n   \"Edible Edifices\"                 (3ljBWt)\n   \"Gliders Over Voropolis\"          (WdKcz1)\n   \"Underground Trains\"              (tsKyzw)\n   \"Energy Temple\"                   (tttyzB)\n   \"Chateaux... v2\"                  (fsjXWG)\n   \"Urban Smog\"                      (NsdGDN)\n   \"Spherical Metropolis\"            (ssG3W3)\n   \"Vessel Climbing\"                 (NdGXDD)\n   \"Mesh Dome\"                       (ssKXRt)\n   \"Wind Farm\"                       (Ntd3R2)\n   \"Gold Edifices\"                   (NldSzM)\n   \"Mausolea\"                        (ftcSWS)\n   \"Melange\"                         (slKXD3)\n   \"Losing Focus 2\"                  (sdSBzc)\n   \"Reading Room\"                    (fs3fzn)\n   \"Ultimate Library 2\"              (flKyDt)\n   \"Build the Palace\"                (7tKfRV)\n   \"Monorail\"                        (cdfSzl)\n   \"Palladian Schneekugel\"           (mtf3zl)\n*/                         \n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}