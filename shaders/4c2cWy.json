{
    "Shader": {
        "info": {
            "date": "1722926808",
            "description": "originals https://www.shadertoy.com/view/wdtczM https://www.shadertoy.com/view/4tyfWy https://www.shadertoy.com/view/Xf2yRt and other https://www.shadertoy.com/view/4f2cWG",
            "flags": 1,
            "hasliked": 0,
            "id": "4c2cWy",
            "likes": 7,
            "name": "universe new ",
            "published": 3,
            "tags": [
                "fractal",
                "space",
                "cosmos",
                "univese"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "float happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n#define iterations 12\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(1., 10.233))) * 40000.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat invs(float y) {\n    return 0.5 - sin(asin(1.0-2.0*y)/3.0);\n}\n\nfloat isBetween(float a, float b, float c) {\n    //float k = 3. / iResolution.y;\n    return smoothstep(-0.5, 0., -mod(c-a, 2. * pi) + mod(b-a - 0.1 * pi, 2. * pi));\n   //return exp( -1. * (abs(-mod(c-a, 2. * pi) + mod(b-a, 2. * pi))) );\n}\n\nfloat ellipse(vec2 uv, vec2 p, vec2 q, float i) {\n    float quadTest = 0.5 * (sign(q.x - p.x) * sign(q.y - p.y) + 1.);\n    i = 1.-quadTest;\n\n    // center point\n    vec2 c = (i == 1.) ? vec2(p.x, q.y)\n                       : vec2(q.x, p.y);\n\n    // axis distances between points\n    float x = abs(q.x - p.x), y = abs(q.y - p.y);\n\n    // ellipses (asymptotes when x==0 or y==0, annoying)\n    //float d = (i == 1.) ? length((uv - c) * vec2(y/x,1)) - y\n    //                    : length((uv - c) * vec2(1,x/y)) - x;\n\n    float d = sdEllipse(uv - c, vec2(x, y));\n\n    // (make this smoothstep or exp)\n    // float s = smoothstep(-0.02, 0.02, -abs(d) + 0.01);\n    float k = 1. / iResolution.y;\n    float s = smoothstep(-k, k, -abs(d) + 0.006);\n    s = exp(-100. * abs(d));\n    // a, b angles from center to points\n    // c angle from center to uv\n    float a1 = atan(p.x-c.x, p.y-c.y);\n    float a2 = atan(q.x-c.x, q.y-c.y); // move b from a-> b to \"draw\" thing\n    float b = atan(uv.x-c.x, uv.y-c.y);\n    \n    // flip clockwise <-> anticlockwise across diagonal quads\n    // float quadTest = 0.5 * (sign(q.x - p.x) * sign(q.y - p.y) + 1.);\n    \n    // cut out a1,a2 segment of ellipse\n    float as = isBetween(a1, a2, b);\n    return s;// * mix(as, 1. - as, quadTest);\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.02),sin(iTime*0.02),-sin(iTime*0.02),cos(iTime*0.02));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.01,1.);\t\n}\n\n \n #define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n \n\n\n\n\n    const int octaves = 6;\n\n\n\n    vec2 random2(vec2 st){\n      vec2 t = vec2(texture(iChannel0, st/1023.).x, texture(iChannel0, st/1023.+.5).x);\n      return t*t*4.;\n    }\n\n    // Value Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/lsf3WH\n    float noise(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        vec2 u = f*f*(3.0-2.0*f);\n\n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n  \n    float fbm1(in vec2 _st) {\n      float v = 0.0;\n      float a = 0.5;\n      vec2 shift = vec2(100.0);\n      // Rotate to reduce axial bias\n      mat2 rot = mat2(cos(0.5), sin(0.5),\n                      -sin(0.5), cos(0.50));\n      for (int i = 0; i < octaves; ++i) {\n          v += a * noise(_st);\n          _st = rot * _st * 2.0 + shift;\n          a *= 0.4;\n      }\n      return v;\n    }\n  \n    float pattern(vec2 uv, float time, inout vec2 q, inout vec2 r) {\n\n      q = vec2( fbm1( uv * .1 + vec2(0.0,0.0) ),\n                     fbm1( uv + vec2(5.2,1.3) ) );\n\n      r = vec2( fbm1( uv * .1 + 4.0*q + vec2(1.7 - time / 2.,9.2) ),\n                     fbm1( uv + 4.0*q + vec2(8.3 - time / 2.,2.8) ) );\n\n      vec2 s = vec2( fbm1( uv + 5.0*r + vec2(21.7 - time / 2.,90.2) ),\n                     fbm1( uv * .05 + 5.0*r + vec2(80.3 - time / 2.,20.8) ) ) * .25;\n\n      return fbm1( uv * .05 + 4.0 * s );\n    }\n\n#define PI 3.141592\n#define TWOPI 6.283184\n\n#define R2D 180.0/PI*\n#define D2R PI/180.0* \n\nmat2 rotMat(in float r){float c = cos(r);float s = sin(r);return mat2(c,-s,s,c);}\n\n//fract -> -0.5 -> ABS  : coordinate absolute Looping\nfloat abs1d(in float x){return abs(fract(x)-0.5);}\nvec2 abs2d(in vec2 v){return abs(fract(v)-0.5);}\n\n#define OC 15.0\nvec3 Oilnoise(in vec2 pos, in vec3 RGB)\n{\n    vec2 q = vec2(0.0);\n    float result = 0.0;\n    \n    float s = 2.2;\n    float gain = 0.44;\n    vec2 aPos = abs2d(pos)*0.5;//add pos\n\n    for(float i = 0.0; i < OC; i++)\n    {\n        pos *= rotMat(D2R 30.);\n        float time = (sin(iTime)*0.5+0.5)*0.2+iTime*0.8;\n        q =  pos * s + time;\n        q =  pos * s + aPos + time;\n        q = vec2(cos(q));\n\n        result += abs1d(dot(q, vec2(0.3))) * gain;\n\n        s *= 1.07;\n        aPos += cos(q);\n        aPos*= rotMat(D2R 5.0);\n        aPos*= 1.2; \n    }\n    \n    result = pow(result,4.0);\n    return clamp( RGB / result, vec3(0.0), vec3(1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\n\nvec2 uv2 = fragCoord.xy/iResolution.xy-.5;\n\n      float t5 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .37)) * 2.2;\n\tfloat si = sin(t5);\n\tfloat co = cos(t5);\n\tmat2 ma = mat2(co, si, -si, co);\n    uv*=ma;  \n     \n  \n    vec4 o = fragColor;\n       vec4 o2 = fragColor;\n    vec2 u=fragCoord;\n     vec2 v, q2, r3 = iResolution.xy;\n    u = (u - r3 / 2.) / r3.y;\n    \n    o = vec4(1, 2, 3, 0);\n    \n      vec2 R = iResolution.xy; \n       vec2 F =fragCoord; \n    o-=o;\n    for(float d,t = iTime*.1, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                     \n    }\n    float i, t = iTime*0.01;\n    \n    while(t++, i++ < 18.)\n        \n        v = cos(t * vec2(3, 2) + vec2(0, 11)) - 6. * u, \n        \n        u *= rot(i - .1 * t),\n        \n        u += cos(4. / exp(dot(o, o) / 1e2) + t) / 5.,\n        \n        q2= sin(\n                u / (2. - dot(u, u)) \n                - 9. * u.yx \n                + t\n            ), \n            \n        q2 *= 1. + i * dot(v, v),\n        \n        o += (cos(vec4(1, 8, 4, 0) + t) + 1.) / length(q2); \n    \n    \n    o *= 0.35;\n    o -= dot(u, u) / 30.;\n    // points\n \n\n    // should look bad if time gets too high\n    float t3 = 10. + 8. * h21(uv) + 15. *exp(-0.01 * length(uv)) * (650. + iTime);\n    int f = int(floor(t3)); \n    \n    float d = 10.;\n    float s = 0.;\n    vec2 pp = vec2(0.);\n    \n    vec3 e = vec3(1);\n    vec3 col = vec3(0);\n    \n    float n = 20.;\n    for (float i = 0.; i <= n; i++) {\n        float f2 = 0.0001 * float(f);\n        float f3 = 0.0001 * float(f + 1);\n\n        vec2 qp = pp;\n             \n        pp = vec2( h21(vec2(f2)), h21(vec2(0.01 + f2)) );\n        pp = pow(4. * pp * (1.-pp), vec2(4));\n\n        vec2 pp2 = vec2( h21(vec2(f3)), h21(vec2(0.01 + f3)) );\n        float fr = fract(t3);\n        fr = smoothstep(0., 1., fr); //idk if this changes anything\n        pp = mix(pp, pp2, fr); // looks cool if you remove this too\n        pp = 0.3 * (pp - 0.5);\n        f++;\n        \n        float s2;\n        if (i > 0.) s2 = ellipse(uv, pp, qp, 0.);//mod(i, 2.));\n        s = clamp(s + s2, 0., 1.);\n        vec3 col2 = pal(i/n, e, e, e, (i/n) * vec3(0,1,2)/3.);\n        col = mix(col, col2, s2);\n    }\n    \n   \n\t\n\tvec3 from=vec3(1.,.5,0.5);\n\n\tmainVR(fragColor, fragCoord, from, dir);\n    fragColor*=o*5.;\n    \n\n      \n      float time = iTime / 10.;\n      \n      mat2 rot = mat2(cos(time / 10.), sin(time / 10.),\n                      -sin(time / 10.), cos(time / 10.));\n      \n      uv = rot * uv;\n      uv *= 0.9 * (sin(time)) + 3.;\n      uv.x -= time / 5.;\n    \n      vec2 q = vec2(0.,0.);\n      vec2 r = vec2(0.,0.);\n      \n      float _pattern = 0.;\n      \n      \n    _pattern = pattern(uv, time, q, r);\n    \n      vec3 colour = vec3(_pattern) * 3.;\n      colour.r -= dot(q, r) * 15.;\n      colour = mix(colour, vec3(pattern(r, time, q, r), dot(q, r) * 15., -0.1), .5);\n      colour -= q.y * 4.5;\n      colour = mix(colour, vec3(.2, .2, .2), (clamp(q.x, -1., 0.)) * 3.);\n      vec3 col2 = vec3(0.0,0.0,0.0);\n    vec2 st = (fragCoord/iResolution.xy)-.5;\n            st.x = ((st.x - 0.5) *(iResolution.x / iResolution.y)) + 0.5;\n    float stMask = step(0.0, st.x * (1.0-st.x));\n\n\n    col2 =Oilnoise(st,vec3(0.30, 0.7, 1.200));\n  \n      fragColor*= vec4(-colour + (abs(colour) * 2.), 1./length(q));\n    \n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(st, anim) * vec3(0.35,0.2,0.715)*0.25, 1.0);\n  \n    }\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}