{
    "Shader": {
        "info": {
            "date": "1609766076",
            "description": "A rounded die randomly moving about the surface of other stacked dice.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sVBDd",
            "likes": 69,
            "name": "Marching Die",
            "published": 3,
            "tags": [
                "raymarch",
                "cube",
                "dice",
                "animate",
                "frame",
                "die"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1530
        },
        "renderpass": [
            {
                "code": "/*\n\n\tMarching Die\n\t------------\n    \n    I've had this scene sitting in my account for way too long, so thought I'd \n    put it up. I did it just for fun and to relieve boredom. At the time, I \n    thought it'd be cool to see what a standard infinite 2D hexagonal grid filled \n    with cubes would look like in 3D. Once I'd satisfied my curiosity, I figured \n    I'd randomly move a cube about the resultant surface for a bit of visual \n    interest and depth.\n    \n    All of that was simple enough, but texturing a moving animated die correctly\n    proved to be a little tricky. I got there in the end, but I might try to come \n    up with a better system next time.\n    \n    In order to move and texture the die correctly, I hardcoded 15 steps that \n    looped around to the surface die just in front of the original position, which \n    was necessary to keep up with a moving camera synchronized to meet it there. \n    The steps were simple enough: Pivot up and forward about the YZ axis, pivot \n    down and left about the XY axis, etc. Whilst doing this, it was necessary to \n    keep track of the pivot points, fractional rotation matrix, overall position, \n    overall rotation, etc, in order to obtain the correct texture. Texturing was \n    achieved via standard cube mapping -- Render one dot on face one, two dots on \n    face two, etc. I was able to fake randomness by changing the original looped \n    path slightly each time around, or something to that effect.\n    \n    I'm giving the performance a \"mildly OK\" rating. On machines like mine, it'll \n    run fine in the 800 by 450 window, but fullscreen will be slow. At some stage,\n    I'll get in amongst it and improve a few things. I'm also going to post my\n    original shader that doesn't have rounded stacked dice, reflections, etc, so\n    that will be much faster.\n \n    \n   \n    Other examples:\n\n\t// Quite watchable: Dave Hoskins was coding stacked cubes before it was cool. :D \n    Ray*Bert - Dave_Hoskins \n\thttps://www.shadertoy.com/view/4sl3RH\n    \n    // I really like this one. It'd be cool to see a fancier version at some stage.\n    hexastairs: ladder like + doors - FabriceNeyret2\n    https://www.shadertoy.com/view/wsyBDm\n    \n    // Here's another related example of Fabrice's. I like the way he's worked\n    // the camera.\n    rolling dice on surface - FabriceNeyret2 \n    https://www.shadertoy.com/view/WdGBRc\n \n\n*/\n\n// Bouncing the die from level to level... It works but needs a little fine tuning.\n//#define BOUNCE\n\n// Ray passes: For this example, just one intersection and one reflection.\n#define PASSES 2\n\n// Far plane, or max ray distance.\n#define FAR 40.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n// Global block scale.\n#define GSCALE vec2(1./1.5)\n\n\n#define PI 3.14159\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID, svObjID;\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function: Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IQ's signed box formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n// IQ's signed box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n  \n  // Unsigned.\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n// Exponential easing function.\nfloat exponentialOut(float t) {\n  return t == 1. ? t : 1. - pow(2., -8.*t);\n}\n\n// Quad easing function. \nfloat easeOutQuad(float t) {\n    return -t*(t - 2.);\n}\n \n \n// Various moving die storage containers. I added these as I went\n// along, so it definitiely needs a tidy up.\n\n// Cube distance and ID.\nvec3 svGID; \n\n// Die rotation storage matrices.\nmat2 gMat, svMat;\nmat2 lRot;\n\n// Texture pivot and offset matrices for the moving die.\nvec3 gTxP, svTxP;\nvec3 gPiv, svPiv;\nvec3 gOff;\n\n// Pivot total direction and direction storage.\nvec3 lPivot;\nvec3 lTotDist;\nvec3 dirI;\n// XY and YZ direction start positions.\nfloat lStartXY;\nfloat lStartYZ;\n// Bounce value.\nfloat gBounce = 0.;\n\n\n// Moving the cube whilst keeping track of pivot, offset, etc, variables\n// for texturing purposes. This is a long and ugly function, but thankfully,\n// it's only called once per frame.\nvoid moveCube(float gTime){\n\n   \n    const int ttm = 15;\n    float tm = gTime*float(ttm)/GSCALE.x; \n    \n    float modtm = mod(tm, float(ttm));\n \n    // Initial die offset -- Arrange to match the camera movement.\n    gOff = ((vec3(5, 4, -4) - 1./2.) + floor(tm/float(ttm))*vec3(0, 1, 1))*GSCALE.x;\n \n    lStartYZ = mod(floor(tm/float(ttm)), 2.);\n\n    // Directions -- All 15 of them.\n    vec3[ttm] dir = vec3[ttm](vec3(0, 1, 1), vec3(1, 1, 0), vec3(0, 1, 1), vec3(-1, -1, 0), vec3(0, 1, 1), vec3(-1, -1, 0),\n    vec3(0, 1, 1), vec3(-1, -1, 0), vec3(-1, -1, 0), vec3(0, -1, -1), vec3(1, 1, 0), vec3(0, -1, -1), \n    vec3(1, 1, 0), vec3(0, -1, -1), vec3(1, 1, 0));\n    \n    // Random swap.\n    for(int i = 0; i<15; i++){\n        if(hash21(vec2(floor(tm/float(ttm)), i)/15.)<.333) swap(dir[i], dir[(i + 1)%15]);\n    }\n    \n    lTotDist = vec3(0); // Total distance.\n    \n    // Cycle through the animation frames, then move the dice from one level to the\n    // the next in whatever random direction the array has chosen. Whilst doing so,\n    // keep track for the pivot point, rotation matrix, total distance, etc, for later\n    // texture usage... If you're thinking it looks fiddly, you'd be right, but it's\n    // all just basic physics and not as hard as you'd think.\n    for(int i = 0; i<ttm; i++){\n\n       float fi = float(i);\n       dirI = dir[i];\n\n       if(modtm<fi + 1.){ \n            \n            // Fractional time component.\n            float t = (modtm - fi)/1.;\n            \n            #ifdef BOUNCE\n            // Alternative level to level bounce.\n            t = easeOutQuad(t);\n            gBounce = (1. - abs(fract(t) - .5)*2.)*GSCALE.x*.25;\n            #else\n            // Exponential ease.\n            t = exponentialOut(t); \n            #endif\n            \n            // Rotate in the given direction from the pivot point.\n            t = mix(0., PI, t);\n            if(dirI.z<-.5 || dirI.x>.5) t *= -1.;            \n            lRot = rot2(t);\n            lPivot = dirI*GSCALE.x/2.;//vec3(0, GSCALE.x, GSCALE.x)/2.;\n            \n            // Save the pivol and rotation variables.\n            gPiv = lPivot;\n            gMat = lRot;\n           \n            break;\n\n\n       }\n\n       lTotDist += dirI; // Update the overall position.\n\n    }\n    \n\n}\n\n\n// Dice block levels.\n\nvec4 blocks(vec3 q){\n\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = GSCALE;//vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block central postions.\n    vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n \n    \n    float height = 0.; // Block height initialization.\n    \n    // Height scale.\n    const float hs = .125;\n\n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;// -  ps4[0]/2.;\n        \n \n        \n        p = q.xz - cntr*s;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n        \n        \n        // Correct positional individual tile ID.\n        vec2 idi = (ip + cntr)*s;\n\n  \n        // Block height.\n        float h1 = (ip.y - .5 - float(i/2)/2.)*GSCALE.y + 1.;//hm(idi);\n        h1 += (ip.x - .5)*GSCALE.x + 1.;\n        if(i==0 || i==3) h1 -= GSCALE.x/2.;\n        \n \n        // Render the dice.\n        float qy = mod(q.y - GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face1Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face1Ext = smax(face1Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        qy = mod(q.y + GSCALE.x/2., GSCALE.x*2.) - GSCALE.x;\n        float face2Ext = sBox(vec3(p, qy), vec3(dim.x/2.), .07);\n        face2Ext = smax(face2Ext, length(vec3(p, qy)) - GSCALE.x/2.*1.55, .1);\n        face1Ext = min(face1Ext, face2Ext);\n        \n        face1Ext = max(face1Ext, (q.y - h1*2. + .01));\n        \n        vec4 di = vec4(face1Ext, idi, h1);\n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box height. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w; \n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and triangle ID.\n    return vec4(d, id, height);\n}\n\n\n\n\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    \n    // Reflecting the wall opposite to give the light something to relect off of.\n    //p.y =  abs(p.y - .25) - .75;\n    \n    // Wall behind the pylons to stop the light getting through.\n    vec3 q = p;\n    \n    q.yz *= rot2(3.14159/4.);\n    q.xy *= rot2(-3.14159/5.);\n    float wall = 1e5;//q.y - .7071 + .1;//abs(q.y - .7017 + 1.) - 1.;//1.5*.7071;\n    \n \n    // Blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    \n    // Move and render the die.\n    \n    // Initial point.\n    q = p - gOff- lTotDist*GSCALE.x; \n    // Bounce.\n    q.y -= gBounce;\n    // Pivot about the pivot point.\n    q -= lPivot;\n    // Depending on direction rotate around the XY plane or the YZ one.\n    if(abs(dirI.x)>.5) q.xy = lRot*q.xy;\n    else q.yz = lRot*q.yz;\n    // Pivot back.\n    q += lPivot;\n \n    // Factor in the total rotation for each direction.\n    q.xy = rot2(mod(lTotDist.x, 2.)*PI)*q.xy;\n    q.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*q.yz;\n\n    // Keep a global texture copy for texturing later. \n    gTxP = q; \n    \n    // Render the smooth edged rounded cube.\n    float bx = sBox(q, vec3(GSCALE.x/2.), .07);\n    bx = smax(bx, length(q) - GSCALE.x/2.*1.55, .1);\n    \n \n    // Overall object ID.\n    objID = (wall<d4.x && wall<bx)? 2 : d4.x<bx? 0 : 1;\n    \n    // Combining the wall with the extruded blocks.\n    return min(wall, min(d4.x, bx));\n \n}\n\n\n// Basic raymarcher.\nfloat trace(vec3 ro, vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d; \n    \n    for(int i = 0; i<72; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(d*d<DELTA*DELTA || t>FAR) break; // Alternative: .001*max(t*.25, 1.), etc.\n        \n        t += i<32? d*.5 : d*.9; // Slower, but more accuracy.\n        //t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(iFrame, 0); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Render the dots on each face of each cube in the scene.\nfloat getDots(vec3 p, vec3 n){\n\n    // Choose the face. Based on some of Fizzer's cube mapping logic.\n    vec3 aN = abs(n);\n\n    ivec3 idF = ivec3(n.x<-.25? 0 : 5, n.y<-.25? 1 : 4, n.z<-.25? 2 : 3);\n\n    int face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z; \n\n    float zDist = GSCALE.x/2.;\n    \n    vec2 tuv = p.xy; // Face UV coordinates.\n\n    // Render the face dots, according to face ID.\n    // How you go about this is up to you. There'd probably be more efficient\n    // ways, but this will do.\n    float dots = 1e5;\n    const float dSz = .0;\n    const float dsp = .12;\n    //if(face == 0)  dots = length(vec3(tuv, p.z + zDist)); // 3D -- Not needed.\n    if(face == 0)  dots = length(tuv);\n    else if(face == 1){\n        dots = min(length(tuv - dsp), length(tuv + dsp));\n        // 3D -- Not needed.\n        //dots = length(vec3(tuv - dsp, p.z + zDist));\n        //dots = min(dots, length(vec3(tuv + dsp, p.z + zDist)));\n    }\n    else if(face == 2){\n        dots = length(tuv);\n        dots = min(dots, min(length(tuv - dsp), length(tuv + dsp)));\n    }\n    else if(face == 3){\n        tuv = abs(tuv) - dsp;\n        dots = length(tuv);\n    } \n    else if(face == 4){\n        dots = length(tuv);\n        tuv = abs(tuv) - dsp;\n        dots = min(dots, length(tuv));\n\n    }     \n    else if(face == 5){\n        tuv.y = abs(tuv.y) - dsp;\n        dots = length(tuv);\n        tuv.x = abs(tuv.x) - (dsp + .02);\n        dots = min(dots, length(tuv));\n\n    } \n    \n    return dots - dSz;\n                \n}\n\n\n// A global value to record the distance from the camera to the hit point. It's used to tone\n// down the sand height values that are further away. If you don't do this, really bad\n// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but\n// I didn't want to pass an extra variable through a bunch of different functions.\nfloat gT;\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 txP, in vec3 n){\n\n    \n    vec3 txN = n;\n     \n    vec3 tuv = vec3(0);\n    \n    // Background dice.\n    if(svObjID==0){  \n       \n        // Randomly rotate the faces.\n        float rndXY = hash21(svGID.yz);\n        float rndYZ = hash21(svGID.yz + .37);\n        float rndZX = hash21(svGID.yz + .71);\n        vec3 rSn = txN;\n        rSn.xy *= rot2(floor(rndXY*36.)*PI/2.);\n        rSn.yz *= rot2(floor(rndYZ*36.)*PI/2.);\n        rSn.xz *= rot2(floor(rndZX*36.)*PI/2.);\n        \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx*vec3(1, 1, -1) :  aN.y>.5? txP.zxy*vec3(1, 1, -1) : txP.xyz*vec3(1, 1, -1);\n    \n        tuv = mod(tuv, GSCALE.x) - GSCALE.x/2.;\n        \n        txN = rSn;\n    \n    }\n    \n    // Moving die.\n    if(svObjID==1){\n    \n    \n        // Saved rotation data to rotated the normal to the \n        // correct position.\n       \n        if(abs(svPiv.x)>.01){\n             txN.xy = svMat*txN.xy;\n        }\n        else {\n             txN.yz = svMat*txN.yz;\n        }  \n       \n        // Overall rotation.\n        txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n        txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;    \n \n        // Select the UV coordinates from the dominant normal.\n        // If X is dominant, then select the YZ face, etc.\n        vec3 aN = abs(txN);\n        tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n        \n    }\n    \n    \n    \n    \n    // Rendering the dots on the faces.\n    float d = 1.;\n    \n    if(svObjID<2) {\n        d = getDots(tuv, txN); //sin(tuv.x*64.)*.5 + .5;//\n        \n        //tuv = mod(tuv - GSCALE.x/2., GSCALE.x) - GSCALE.x/2.;\n        //float sq = max(abs(tuv.x), abs(tuv.y)) - GSCALE.x/2. + .01;\n        //d = min(d, abs(sq));\n\n        d = smoothstep(0., .06, d);\n        \n        // Corrugated grooves... Why I thought this would work, I'll never know. :D\n        //d *= sin((tuv.x)*40.)*.04 + .96;\n        \n    }\n    \n    \n    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n    // formed in the distance. Simply lessen the value when it's further away. Most people would\n    // figure this out pretty quickly, but it took far too long before it hit me. :)\n    return  d;//d/(1. + gT*gT*.015);\n   \n   \n}\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, inout float ref){\n\n\n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(0.001, 0);\n    \n    // It'd be nice to have elegant looking code, but in reality, it's all about \n    // hacks. The cube moves in relation to the rest of the scene, and needs \n    // to have it's relative position tracked for texturing purposes... \n    // And the relative sample offsets, it would appear... That's just painful. \n    // Not all coding is fun. :)\n    vec3 v0 = e.xyy;\n    vec3 v1 = e.yxy;\n    vec3 v2 = e.yyx;\n   \n    if(svObjID==1){\n    \n        p = svTxP;\n        \n        if(abs(svPiv.x)>.01){\n             v0.xy = svMat*v0.xy;\n             v1.xy = svMat*v1.xy;\n             v2.xy = svMat*v2.xy;\n        }\n        else {\n             v0.yz = svMat*v0.yz;\n             v1.yz = svMat*v1.yz;\n             v2.yz = svMat*v2.yz;\n        }  \n       \n        // Overall rotation.\n        v0.xy = rot2(mod(lTotDist.x, 2.)*PI)*v0.xy;\n        v0.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v0.yz;    \n        v1.xy = rot2(mod(lTotDist.x, 2.)*PI)*v1.xy;\n        v1.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v1.yz;    \n        v2.xy = rot2(mod(lTotDist.x, 2.)*PI)*v2.xy;\n        v2.yz = rot2((lStartYZ + mod(lTotDist.z, 2.))*PI)*v2.yz;\n        \n    }\n    \n     \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    ref = bumpSurf3D(p, nor); // The reference value is returned for later use.\n    vec3 grad = (vec3(bumpSurf3D(p - v0, nor),\n                      bumpSurf3D(p - v1, nor),\n                      bumpSurf3D(p - v2, nor)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n                     bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n                     bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// FBM.\nfloat fBm(vec3 p){ return n3D(p)*.57 + n3D(p*2.)*.28 + n3D(p*4.)*.15; }\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 5.;\n    p.x += iTime/2.;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(.4, 1., c); // Putting in some dark space.\n    \n    \n    //p = pow(min(vec3(1.4, 1, 1)*c, 1.), vec3(1, 3, 16)); // Fire.\n    p = vec3(c, c*c, c*c*c*c); // Orange tinge.\n   \n    p = mix(p, p.zyx, n3D2); // Mixing the color around.\n    \n    return p*p;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\n    // Ray origin.\n    float tm = iTime/12.;\n    vec3 ro = vec3(0, 5. + tm, -5. + tm); \n    // \"Look At\" position.\n    vec3 lk = ro + vec3(.18, -.15, .2);//vec3(0, -.25, iTime);  \n \n    // Light positioning.\n \tvec3 lp = ro + vec3(2.5, 1, 2.25); // Put near the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    //vec3 rd = mat3(rgt, up, fwd)*normalize(vec3(uv, 1./FOV));\n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0); \n    \n    float alpha = 1.;\n    \n    moveCube(tm);\n    \n    for(int j = 0; j<PASSES; j++){\n    \n         \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        // Used for refractions, but not here.    \n        //float distanceFactor = 1.;\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd);\n\n        // Saving the object ID, block ID and cell object (block part) ID.\n        svObjID = objID;\n        svGID = gID;\n        \n        // Saving the texture, pivot and rotaion matrices for the animated\n        // die on the surface.\n        svTxP = gTxP;\n        svPiv = gPiv;\n        svMat = gMat;\n        \n        //float svBounce = gBounce;\n\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n\n            // Surface normal.\n            vec3 sn = getNormal(sp);// *distanceFactor; // For refractions.\n            \n            \n            // Function based bump mapping.\n            //\n            // The bump value at the hit point -- Used for later shading purposes.\n            float bumpShade; \n            sn = doBumpMap(sp, sn, .1, bumpShade);///(1. + t*t/FAR/FAR*.25)\n            \n            // Texture size factor.\n            float sz0 = 1./2.;\n           \n             \n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            //vec3 smSn = sn;\n            //sn = texBump(iChannel0, sp*sz0, sn, .005);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n             \n            \n            // The reflective ray, which tends to be very helpful when\n            // calculating reflections. :)\n            vec3 reflection = reflect(rd, sn);\n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            if(j == 0) gSh = softShadow(sp, lp, sn, 8.);\n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            float sh = min(gSh + .2, 1.); // Shadow.\n            \n\n            float att = 1./(1. + lDist*lDist*.1); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 8.);\n            float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            \n            dif = pow(dif, 4.)*2.; // Ramping up the diffuse.\n\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n\n      \n            // Object color.\n            vec3 oCol;\n            \n             \n            if(svObjID == 0) {\n\n                // Coloring the background dice.\n                float rnd2 = hash21(svGID.yz + floor(sp.y/GSCALE.x) + .3);\n                \n                // Block coloring.\n                vec3 tx = tex3D(iChannel0, sp*sz0, sn);\n                tx = smoothstep(-.05, .5, tx);\n                //tx = mix(tx, vec3(1)*dot(tx, vec3(.299, .587, .144)), .5);\n                oCol = tx*mix(vec3(.9, 1, 1.2).zyx, vec3(.9, 1, 1.2), tx.x);\n                oCol *= vec3(.85, 1, 1.2);\n                 \n                //oCol *= mix(vec3(.8, 1, 1.2), 1./vec3(.8, 1, 1.2), \n                // mod(svGID.y + svGID.z, 2.)<.5? 0. : 1.);\n                //float rnd = hash21(svGID.yz);\n                //vec3 rCol = .6 + .4*cos(6.2831*rnd/4. + vec3(0, 1, 2));\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else if(svObjID == 1) {\n            \n                // Texture the colored moving die.\n                \n                // Saved texture value from the die movement function.\n                vec3 txP = svTxP;\n                \n                // Using the saved rotation matrices to rotate the face\n                // normal to the correct position.\n                vec3 txN = sn;\n \n                if(abs(svPiv.x)>.01){\n                      txN.xy = svMat*txN.xy;\n                }\n                else {\n                      txN.yz = svMat*txN.yz;\n                }\n               \n                // Overall rotation.\n                txN.xy = rot2(mod(lTotDist.x, 2.)*PI)*txN.xy;\n                txN.yz = rot2((mod(lStartYZ + lTotDist.z, 2.))*PI)*txN.yz;\n                   \n\n                // Block texturing and coloring.\n                vec3 tx = tex3D(iChannel0, txP*sz0, txN);\n                tx = smoothstep(-.05, .55, tx);\n                //tx = vec3(1)*dot(tx, vec3(.299, .587, .144));\n\n                //oCol = tx*vec3(1, .3, .5)*2.;\n                oCol = tx*mix(vec3(1, .42, .28).xzy, vec3(1, .42, .28), tx.x*1.1)*2.6;\n                //oCol = tx*vec3(.2, .58, 1)*2.6;\n        \n                \n                //vec3 aN = abs(txN);\n                //vec3 tuv = aN.x>.5? txP.yzx :  aN.y>.5? txP.zxy : txP.xyz;\n                //float sq = sBox(tuv.xy, vec2(GSCALE.x/2. - .07), .05);\n                //sq = abs(sq) - .02;\n                //oCol = mix(oCol, vec3(0), (1. - smoothstep(0., .003, sq))*.9);\n               \n                //objRef = .25;\n                // Arrange for less reflection in the dice holes.\n                objRef = mix(.125, .25, smoothstep(0., .1, bumpShade));\n\n                \n            }\n            else {\n                // Dark wall behind the tiny gaps in the blocks. \n                oCol = vec3(0);\n                objRef = .0;\n            }\n            \n \n\n            // Combining the diffuse, specular and Fresnel terms, if applicable.\n            colL = oCol*(dif + vec3(1, .7, .5)*spe*16. + .1);// + vec3(1, .7, .5).zyx*pow(freS, 2.)*2.;\n            \n            // Optional environmental mapping. Not used.\n            vec3 envCol = envMap(reflection);\n            //vec3 envCol = texture(iChannel1, reflection).xyz; envCol *= envCol;\n            colL += colL*envCol.zyx*8.;\n            \n            // Multiply the dice dots by the bump value for extra depth.\n            if(svObjID<2) colL *= bumpShade;\n            \n            // Combining it with the object color, then shading.\n            colL *= ao*att*sh;\n \n            \n            // Set the unit direction ray to the new reflected direction, and bump the \n            // ray off of the hit point by a fraction of the normal distance. Anyone who's\n            // been doing this for a while knows that you need to do this to stop self\n            // intersection with the current launch surface from occurring... It used to \n            // bring me unstuck all the time. I'd spend hours trying to figure out why my\n            // reflections weren't working. :)\n            rd = reflection;\n            sp += sn*DELTA*1.1;\n\n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);//mix(vec3(.1, .3, 1)/12., vec3(.25, .5, 1)/6., rd.y*.5 + .5);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n        \n        \n        // This is a more subtle way to blend layers. \n        //col = mix(col, min(colL, 1.), 1./float(1 + j)*alpha);\n        // In you face additive blend. Sometimes, I prefer this.\n        col += min(colL, 1.)*alpha;\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break.\n        if(objRef<.001 || t >= FAR) break;\n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n    }\n   \n    \n    /*\n    // Cheap hash pattern. Needs work... Much more work. :)\n    float gry = dot(col, vec3(.299, .587, .114));\n    gry = sqrt(gry);\n    float pat = 1.;\n      \n    const int NN = 5;\n    const float fn = float(NN);\n    float lns = 200.*iResolution.y/450.;\n    float sf = 1./iResolution.y;\n    for(int i = 0; i<NN; i++){\n        \n        vec2 rp = rot2(3.14159/3. - float(i)*6.2831/fn/2.)*uv;\n        rp += float(i)/fn;\n        float patL = abs(fract((rp.x)*lns) - .5)*2. - .05;\n        \n        if(gry<(fn - float(i))/(fn + 1.)) pat = min(pat, patL);\n    }\n    \n    pat = smoothstep(0., sf*lns*2., pat);\n    col = vec3(pat*;\n    */\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}