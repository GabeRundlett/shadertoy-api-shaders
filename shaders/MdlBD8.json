{
    "Shader": {
        "info": {
            "date": "1496104073",
            "description": "Combining a flower I made with a gradient.\n(Apologies for overwriting my dots one, I'm new to Shadertoy and thought it would save a new one!)",
            "flags": 0,
            "hasliked": 0,
            "id": "MdlBD8",
            "likes": 9,
            "name": "FlowerGradient",
            "published": 3,
            "tags": [
                "2d",
                "flower",
                "gradient"
            ],
            "usePreview": 0,
            "username": "misspurple",
            "viewed": 805
        },
        "renderpass": [
            {
                "code": "float spacing = 20.;\nfloat min_size = 5.;\nfloat max_size = 20.;\n\nvec2 offsets[9];\n\nconst float epsilon = 0.01;\nconst float pi = radians(180.);\nconst float two_pi = pi * 2.;\n//const float leaves = 5.;\n\nfloat rotationOffset(vec2 center)\n{\n    float arg1 = fract(sin(center.x) * 256.);\n    float arg2 = fract(sin(center.y) * 256.);\n    \n    float offset = arg1 + arg2;\n    float speed = 1.0 + (arg1 - 0.5) * (arg2 - 0.5);\n    return iTime * speed + offset;\n}\n\nbool singleTest(vec2 point, vec2 center, float size, out float brightness)\n{\n    float leaves =  4. + floor(fract(sin(length(center))*32.)*3.);  //leaves\n    vec2 offset = point - center;\n    float dist = length(offset);\n    if (dist < epsilon)\n    {\n     \tbrightness = 1.5;\n    \treturn true;\n    }\n   \tfloat prop_y = dist/size;\n    if (prop_y > 1.)\n    {\n        brightness = 0.;\n        return false;\n    }\n    \n    \n    float angle = atan(offset.x, offset.y)+rotationOffset(center);\n    \n    float prop_x = mod(((angle / two_pi) * leaves) + 0.5, 1.);\n    float from_mid = abs(prop_x - 0.5) * 2.;\n    float from_apex = from_mid - 0.2;\n    float threshold = max(\n    \t\t\t\t\t\t1. - 4. * from_mid,\n    \t\t\t\t\t\t1. - 0.6*(from_apex * from_apex) \n    \t\t\t\t\t);\n    \n    \n    brightness = max(1.,\n                     max( 2.0 - 8. * prop_y,\n                         max(\n                         0.3 + 0.5 * prop_y,\n                         1.5 - 8.*from_mid)));\n    return prop_y < threshold;\n}\n\n\nfloat singleCircleResult(vec2 pixel, vec2 direction, out float brightness)\n{\n    vec2 center_scaled = floor(pixel / spacing);\n    vec2 center = (center_scaled + vec2(0.5, 0.5))*spacing;\n    \n    vec2 image_center = iResolution.xy / 2.;\n    vec2 from_image_center = (center - image_center);\n    float prop_from_image_center = length(from_image_center) / (0.7*min(iResolution.x, iResolution.y));\n    float size_prop = abs(mod(1.5 * prop_from_image_center - 0.5*iTime, 2.)-1.);\n    float size = mix(min_size, max_size, size_prop * size_prop);\n    \n    int result = 0;\n    const int comparisons = 5;\n    for (int i = 0; i < comparisons; ++i)\n    {\n    \tvec2 point = pixel + (0.5 * offsets[i]);\n        float this_brightness = 0.;\n     \tif (singleTest(point, center, size, this_brightness))\n        {\n            result += 1;\n            brightness += this_brightness;\n        }\n    }\n    brightness = brightness / float(result);\n    return float(result) / float(comparisons);\n}\n\nfloat maxResult(vec2 pixel, out float brightness)\n{\n    float result = 0.;\n    const int checks = 9;\n    for (int i = 0; i < checks; ++i)\n    {\n        float this_brightness = 0.;\n        float this_result = singleCircleResult(pixel, offsets[i], this_brightness);\n        if (this_result > result)\n        {\n            result = this_result;\n            brightness = this_brightness;\n        }\n    }\n    return result;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //GLSL ES 2.0 compatability. Sandess\n    offsets[0] =  vec2(0.,0.);\n    offsets[1] =  vec2(1.,0.);\n    offsets[2] =  vec2(-1.,0.);\n    offsets[3] =  vec2(0.,1.);\n    offsets[4] =  vec2(0.,-1.);\n    offsets[5] =  vec2(1.,1.);\n    offsets[6] =  vec2(-1.,-1.);\n    offsets[7] =  vec2(1.,-1.);\n    offsets[8] =  vec2(-1.,1.);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float brightness = 0.;\n    float result = maxResult(fragCoord.xy, brightness);\n\tfragColor = mix(vec4(0.1 * uv.y, 0.2, 0.1 * uv.x, 1.),\n                    vec4(1., \n                         1. - uv.y,\n                         uv.y,\n                         1.) * brightness,\n                    result);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}