{
    "Shader": {
        "info": {
            "date": "1509627023",
            "description": "Procedural 2D (quantised) noise generation using alu based technique.\n\nInspired in part by: \"Creation by Silexars\" written by: Danguafer\n                     and: \"Sunrise, sunset\" written by: kig\n",
            "flags": 96,
            "hasliked": 0,
            "id": "4sc3WS",
            "likes": 6,
            "name": "Let Me [ Break It Down ]",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "audio",
                "soundcloud",
                "quantised",
                "alu"
            ],
            "usePreview": 0,
            "username": "Nimajamin",
            "viewed": 902
        },
        "renderpass": [
            {
                "code": "//\n// Let Me [ Break It Down ]\n//\n// Experiments in noise generation, scanline rendering effects \n//  and music visualisation..\n//\n// Soundtrack (C) N-e-b-u-l-o-u-s [ ngc4244 ]\n//\n// - https://soundcloud.com/ngc4244/sets/teal\n//\n\n//\n// Star / sun effect based in part on the wonderful shader:\n//\n// \"Creation by Silexars\" by: Danguafer\n//\n// - https://www.shadertoy.com/view/XsXXDn\n//\n\n//\n// Sky & Water background from the vibrant shader:\n//\n// \"Sunrise, sunset\" by: kig\n//\n// - https://www.shadertoy.com/view/XsBXDc\n//\n\n//#define MONO_PALETTE_FFT\n#define FIRE_PALETTE_FFT\n\n// -------- ------- ------ ----- ---- --- -- -\n\nvec4  saturate(  vec4 a ) { return clamp( a, 0.0, 1.0 ); }\nvec3  saturate(  vec3 a ) { return clamp( a, 0.0, 1.0 ); }\nvec2  saturate(  vec2 a ) { return clamp( a, 0.0, 1.0 ); }\nfloat saturate( float a ) { return clamp( a, 0.0, 1.0 ); }\n\n// -------- ------- ------ ----- ---- --- -- -\n//\n// BCH: This function returns the spectrograph 'rgba' data..\n//\n// -------- ------- ------ ----- ---- --- -- -\n\n//#define MONO_FFT\n#define FIRE_FFT\n\nvec4 GetSpectrograph( in vec2 uv )\n{\n    float fft = texture( iChannel0, uv ).x;\n    \n#ifdef MONO_FFT\n\n    return vec4( fft, fft, fft, fft );\n    \n#else  // MONO_FFT\n    \n  #ifdef FIRE_FFT\n    float lerp_r = saturate( 1.0 - uv.y * 1.0 );\n    float lerp_g = saturate( 1.0 - uv.y * 2.0 + ( 1.0 /   ( iResolution.y / 3.0 )         ) );\n    float lerp_b = saturate( 1.0 - uv.y * 3.0 + ( 1.0 / ( ( iResolution.y / 3.0 ) * 2.0 ) ) );\n  #else  // FIRE_FFT\n    float lerp_r = saturate( uv.y * 1.0 );\n    float lerp_g = saturate( uv.y * 2.0 + ( 1.0 /   ( iResolution.y / 3.0 )         ) );\n    float lerp_b = saturate( uv.y * 3.0 + ( 1.0 / ( ( iResolution.y / 3.0 ) * 2.0 ) ) );\n  #endif // FIRE_FFT\n    \n    return vec4( fft * lerp_r, fft * lerp_g, fft * lerp_b, fft );\n    \n  #endif // MONO_FFT\n}\n\n// -------- ------- ------ ----- ---- --- -- -\n\nfloat uvMask( in vec2 uv )\n{\n    return ( uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0 ) ? 1.0 : 0.0;\n}\n\nfloat fDist = 10.0;\n\nvec2 scatterCentre = vec2(0.5,0.5);\nvec2 scatterScalars1 = vec2(0.5,0.5);\nvec2 scatterNoise = vec2( 15.0, 1.0 );\n\n#define kGamma \t\t\t1.2\n#define kBrightness \t0.75\n#define kSaturation \t0.404\n\nconst vec3 deSatConst = vec3( 0.299, 0.587, 0.114 );\n\nvec4 de_sat( in vec4 col, in float sat )\n{\n    float deSat = dot( clamp(col.xyz, 0.0, 1.0), deSatConst );   \n   \tvec3 saturate = mix( vec3(deSat), clamp(col.xyz, vec3(0.0), vec3(1.0)), clamp(sat,0.0,1.0) );\n\treturn vec4( saturate.xyz, col.w );\n}\n\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.0) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.0) ).y; }\n\nvec3 B2_spline(vec3 x) \n{ \n    // returns 3 B-spline functions of degree 2\n    vec3 t = 3.0 * x;\n    vec3 b0 = step(0.0, t)     * step(0.0, 1.0-t);\n\tvec3 b1 = step(0.0, t-1.0) * step(0.0, 2.0-t);\n\tvec3 b2 = step(0.0, t-2.0) * step(0.0, 3.0-t);\n\treturn 0.5 * (\n    \tb0 * pow(t, vec3(2.0)) +\n    \tb1 * (-2.0*pow(t, vec3(2.0)) + 6.0*t - 3.0) + \n    \tb2 * pow(3.0-t,vec3(2.0))\n    );\n}\n\nprecision highp float;\n\nfloat noise( vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel2, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat map(vec3 p) {\n    vec3 q = p + 0.2*vec3(3.0, 0.3, 5.0)*mod(iTime,3600.0)*2.0;\n    float n = 0.0, f = 0.5;\n    n += f*noise(q); q *= 3.001; f *= 0.333;\n    n += f*noise(q); q *= 3.002; f *= 0.332;\n\tn += f*noise(q);\n    return n;\n}\n\nfloat scene(vec3 p)\n{\n\treturn p.y+2.0-0.003*map(vec3(p.x, 0.0, p.z));\n    /*\n        +0.0175*(1.0-sin(0.5*p.z+7.5*iTime))\n        -0.01*(1.0-sin(1.0*p.z+15.0*iTime))\n        -0.005*(1.0-sin(2.0*p.z+30.0*iTime))\n        -0.0025*(1.0-sin(4.0*p.z+60.0*iTime));\n\t*/\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.05;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n        sin(iTime*0.5)*0.1,\n\t\tcos(iTime*0.1)*0.6-0.3,\n        -1.0\n\t));\n    float sunD = dot(bgLight, nml) > 0.995 ? 1.0 : 0.0;\n\tvec3 sun = vec3(6.5, 3.5, 2.0);\n\tfloat skyPow = dot(nml, vec3(0.0, -1.0, 0.0));\n    float centerPow = 0.0; //-dot(uv,uv);\n    float horizonPow = pow(1.0-abs(skyPow), 3.0)*(5.0+centerPow);\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n    float scattering = clamp(1.0 - abs(2.0*(-bgLight.y)), 0.0, 1.0);\n\tvec3 bgCol = max(0.0, skyPow)*2.0*vec3(0.8);\n\tbgCol += 0.5*vec3(0.8)*(horizonPow);\n\tbgCol += sun*(sunD+pow( sp, max(128.0, abs(bgLight.y)*512.0) ));\n\tbgCol += vec3(0.4,0.2,0.15)*(pow( sp, 8.0) + pow( sp, max(8.0, abs(bgLight.y)*128.0) ));\n    bgCol *= mix(vec3(0.7, 0.85, 0.95), vec3(1.0, 0.45, 0.1), scattering);\n    bgCol *= 1.0 - clamp(bgLight.y*3.0, 0.0, 0.6);\n    float cloudFac = pow(abs(skyPow), 0.8)*1.0;\n\t//bgCol += cloudFac*map(nml*2.0/nml.y);\n    //bgCol += cloudFac*map(nml*5.0/nml.y);\n    float ufCloudCover = 0.5;\n    // 0% = 0.0\n    // 10% = 0.25\n    // 20% = 0.35\n    // 30% = 0.4\n    // 50% = 0.45\n    // 75% = 0.75\n    // 100% = 1.5\n    float cc = 0.0;\n    if (ufCloudCover < 0.1) {\n        cc = 0.0 + 0.2 * (ufCloudCover - 0.0)/0.1;\n    } else if (ufCloudCover < 0.2) {\n        cc = 0.2 + 0.1 * (ufCloudCover - 0.1)/0.1;\n    } else if (ufCloudCover < 0.3) {\n        cc = 0.3 + 0.1 * (ufCloudCover - 0.2)/0.1;\n    } else if (ufCloudCover < 0.5) {\n        cc = 0.4 + 0.1 * (ufCloudCover - 0.3)/0.3;\n    } else if (ufCloudCover < 0.75) {\n        cc = 0.5 + 0.2 * pow((ufCloudCover - 0.5)/0.25, 2.0);\n    } else {\n        cc = 0.7 + 0.75 * pow((ufCloudCover - 0.75)/0.25, 2.0);\n    }\n    float cloud = 0.0;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*1.03/nml.y)))) * 0.4;\n    cloud += min(1.0, (1.0-smoothstep(0.0, cc, map(nml*3.0/nml.y)))) * 0.3;\n    bgCol *= 1.0+cloudFac*cloud;\n\n\treturn pow(max(vec3(0.0), bgCol), vec3(2.6));\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n         cy, -sy, 0.0,\n         sy,  cy, 0.0,\n        0.0, 0.0, 1.0\n\t) * mat3(\n        cp, 0.0, -sp,\n        0.0, 1.0, 0.0,\n        sp, 0.0, cp\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * (fragCoord.xy / iResolution.xy) - 1.0) * aspect;\n    mat3 rot = rotationXY( vec2( 0.2+0.2*cos(0.5*iTime), -0.15*sin(0.5+0.5*iTime) ) );\n\tvec3 d = rot * normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(uv*-2.0, -9.5);\n    vec3 tr = vec3(1.0);\n    if (d.y < 0.0) {\n        float dist = -2.0 / d.y - p.y / d.y; // p.y + d.y * dist = -2.0;\n        p += d * dist;\n        vec3 nml = normal(p, 0.0);\n        float f = pow(1.0-dot(d, -vec3(0.0, 1.0, 0.0)), 5.0);\n        nml = mix(nml, vec3(0.0, 1.0, 0.0), f);\n        d = reflect(d, nml);\n        tr *= mix(0.5*vec3(0.5, 0.9, 0.75), vec3(1.0), f);\n    }\n    \n    vec3 col = tr * shadeBg(-d, fragCoord);\n    \n    vec4 noise = (texture(iChannel0, mod(fragCoord.xy/256.0, 1.0))-0.5) / 64.0;\n\tfragColor = 1.0 * pow(vec4( noise.rgb + (1.0 - exp(-1.3 * col.rgb)), 1.0 ), vec4(1.3));\n\n    vec2 fft = uv.xy;\n    \n   \tuv = fragCoord.yx/iResolution.yx;\n    \n\tvec3 dir=vec3(uv,1.0);\n\tfloat time=iTime+0.25;\n\n    vec2 centered = 2.0 * uv - 1.0;\n    centered.y *= iResolution.x / iResolution.y;\n    centered.xy *= audio_freq(iChannel1, - centered.x) * 8.0;\n    \n    float dist2 = dot(centered, centered);\n    float clamped_dist = smoothstep(0.0, 1.0, dist2);\n    float arclength1    = 1.00 * abs(atan(centered.y, centered.x) / radians(3.0 * 360.0))+0.01;\n    float arclength2    = 1.05 * abs(atan(centered.y, centered.x) / radians(2.0 * 360.0))+0.01;\n    float arclength3    = 1.10 * abs(atan(centered.y, centered.x) / radians(      360.0))+0.01;\n\n    // Un-comment the clamp bit for \"pixel-ish' kind of effect, \"1.0\" for scalines only..\n    float pixline = 1.0;//clamp(cos(fract(uv.y * 240.0))*1.44, 0.0, 1.0);\n    float scanline = 1.0 + clamp(tan(2.0 * fract(uv.x * (iResolution.y * 0.25))), 0.0, 1.0) * pixline;\n    \n    float sample1 = audio_freq(iChannel1, uv.x);\n\n    float sample2 = audio_ampl(iChannel1, clamped_dist);\n    float sample3 = audio_ampl(iChannel1, arclength1);\n    float sample3b = audio_ampl(iChannel1, arclength2);\n    float sample3c = audio_ampl(iChannel1, arclength3);\n    \n    vec4 pixelColor = fragColor;\n        \n    vec2         win_uv = -0.1 + uv * vec2( 2.5, 2.6 );\n    float  win_mask_mul = mix( 1.0, 0.0, uvMask( win_uv ) );\n\n    vec2         win_uv2 = vec2( -0.1, -1.5 ) + uv * vec2( 2.5, 2.6 );\n    float  win_mask_mul2 = mix( 1.0, 0.0, uvMask( win_uv2 ) );\n\n    vec2         win_uv3 = vec2( -1.4, -1.5 ) + uv * vec2( 2.5, 2.6 );\n    float  win_mask_mul3 = mix( 1.0, 0.0, uvMask( win_uv3 ) );\n\n    // Produce (left-most) twin spectrograph display content..\n\tvec4   spectrograph;\n    if (win_uv.y < 0.5)\n    \tspectrograph = texture( iChannel0, win_uv * vec2(1.0,2.0) ) * uvMask( win_uv );\n    else\n        spectrograph = 3.3 * texture( iChannel1, win_uv * vec2(1.0,2.0) ) * uvMask( win_uv - vec2(0.0, 0.5) );\n    \n    //\n    // Apply three-pass \"star effect\", each modulated by the audio..\n    //\n    \n#define t (sample2 * 2.01)\n      \n\tvec3 c;\n\tfloat l,z = t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/iResolution.xy;\n\t\tuv=p / 2.0;\n\t\tp-=.5;\n\t\tp.x*=iResolution.x/iResolution.y;\n\t\tz+=.035;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]=0.01/length(abs(mod(uv,1.0)-.5));\n\t}\n\tpixelColor += vec4( c/l, t ) * 0.3;    \n    \n#define t2 (sample1 * 1.01)\n      \n\tvec3 c2;\n\tfloat l2,z2 = t2;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/iResolution.xy;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=iResolution.x/iResolution.y;\n        p.xy *= fract( iTime / 21.0 ) * 21.0;\n\t\tz2+=.07;\n\t\tl2=length(p*0.3);\n\t\tuv+=p/l2*(sin(z2)+1.)*abs(sin(l2*9.-z2*2.));\n\t\tc2[i]=0.01/length(abs(mod(uv,1.0)-.5));\n\t}\n\tpixelColor += vec4( c2/l2, t2 ) * 0.5;    \n    \n#define t3 (sample3 * 3.01)\n      \n\tvec3 c3;\n\tfloat l3,z3 = t3;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/iResolution.xy;\n\t\tuv=p / 3.0;\n\t\tp-=.5;\n\t\tp.x*=iResolution.x/iResolution.y;\n\t\tz3+=.007;\n\t\tl3=length(p);\n\t\tuv+=p/l2*(sin(z3)+1.)*abs(sin(l2*9.-z3*2.));\n\t\tc3[i]=0.01/length(abs(mod(uv,1.0)-.5));\n\t}\n\tpixelColor += vec4( c3/l3, t3 ) * 0.3;    \n    \n   \t// Apply scanlines after - for the Teal..\n    if ( uv.x < 0.5 )\n    {\n    \tpixelColor *= clamp( (0.4 * vec4(pow(scanline,3.0))), 0.0, 1.0 );\n    }\n    \n    // Apply Lower-LEFT-HAND spectrograph display..\n\tpixelColor = mix( spectrograph, pixelColor, win_mask_mul );\n\n    // Apply Lower-RIGHT-HAND spectrograph display..\n    const vec2 quant_uv = vec2( 5.0, 12.0 );\n    vec2 spec_uv = floor(win_uv2.xy * quant_uv.xy) / quant_uv.xy;\n    vec4 spec_r0 = 1.0 * texture( iChannel0, spec_uv ) * uvMask( win_uv2 );\n    vec4 spec_r1 = 3.3 * texture( iChannel1, spec_uv ) * uvMask( win_uv2 );\n    vec4 spec_r = vec4(spec_r0.x * spec_r0.x + spec_r0.x, \n                       spec_r1.y * spec_r1.y, \n                       spec_r0.z * spec_r0.z + spec_r0.z, \n                       0.0 );\n\tpixelColor = mix( spec_r, pixelColor, win_mask_mul2 );\n    \n    fragColor = pixelColor;\n    \n   \t// Apply scanlines after everything..\n   \tfragColor *= clamp( (0.4 * vec4(pow(scanline,3.0))), 0.0, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float freq = audio_freq(iChannel0, uv.x);\n    float ampl = audio_ampl(iChannel0, uv.x);\n\t\n    vec4 prev = texture(iChannel1, uv);\n    \n    fragColor = mix( prev, vec4( freq, ampl, ampl, 0.0 ), 1.0-(uv.y) );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 12299,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/ngc4244/let-me-break-it-down"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat audio_freq( in sampler2D channel, in float f) { return texture( channel, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in sampler2D channel, in float t) { return texture( channel, vec2(t, 0.75) ).x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float freq = audio_freq(iChannel0, uv.x);\n    float ampl = audio_ampl(iChannel0, uv.x);\n    \n    vec4 curr = vec4( freq, ampl, ampl, 0.0 );\n\t\n    vec4 prev = texture(iChannel1, uv);\n    vec4 bufA = texture(iChannel0, uv);\n    \n//    fragColor = mix( prev, curr, 0.1 );\n    \n    vec4 blend = clamp(curr - prev, 0.0, 1.0) * 0.95;//mix( prev, curr, 1.0 );\n    \n    fragColor = vec4( blend.xyz, 0.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}