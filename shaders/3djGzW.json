{
    "Shader": {
        "info": {
            "date": "1548292836",
            "description": "Procedural fire-like noise warp. just moved some code to common",
            "flags": 32,
            "hasliked": 0,
            "id": "3djGzW",
            "likes": 30,
            "name": "Bring the heat-forked",
            "published": 3,
            "tags": [
                "procedural",
                "noise",
                "fire",
                "warp"
            ],
            "usePreview": 0,
            "username": "alvarobyrne",
            "viewed": 1380
        },
        "renderpass": [
            {
                "code": "// Fork of \"Bring the heat\" by ddsol. https://shadertoy.com/view/4sfBWj\n// 2019-01-24 00:41:16\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor=flames(iChannel0,iChannel1,fragCoord.xy,iResolution.xy);\n\tvec3 c = color_from_sampler(iChannel1, fragCoord.xy,iResolution.xy);\n    \n    finalColor = c + pow(finalColor, vec3(0.5)) * 0.5;\n    \n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const mat2 m = mat2( 0.8,  0.6, -0.6,  0.8 );\nconst mat3 m3 = mat3( 0.8,  0.6, 0.0, -0.6,  0.80, 0.0, 0.0, 0.0, 1.0) *\n                mat3( 1.0,  0.0, 0.0, 0.0, -0.60,  0.80, 0.0, 0.8, 0.6) *\n                mat3( 0.8, 0.6, 0.0, -0.6,  0.80, 0.0, 0.0, 0.0, 1.0) *\n                mat3( 1.0,  0.0, 0.0, 0.0, -0.60,  0.80, 0.0, 0.8, 0.6);\n\nfloat time;\n\nfloat n1f0(float p) {\n    return fract(sin(p * 1.7227636) * 8.03e2);\n}\n\nfloat n1f1(float p) {\n    return fract(sin(p * 1.42736 + 1.12) * 5.1e2);\n}\n\nfloat n1f2(float p) {\n    return fract(sin(p * 1.22712 + 12.161) * 5.2e2);\n}\n\n\nfloat n3f(vec3 p) {\n    return fract(n1f0(p.x) + n1f1(p.y) + n1f2(p.z) + n1f0(p.x * 1.613) + n1f1(p.y * 3.112) + n1f2(p.z * 4.112));\n}\n\nfloat n3(vec3 p) {\n    vec3 b = floor(p);\n    vec3 e = b + vec3(1.0);\n    vec3 f = smoothstep(vec3(0.0), vec3(1.0), fract(p));\n    float c000 = n3f(b);\n    float c001 = n3f(vec3(b.x, b.y, e.z));\n    float c010 = n3f(vec3(b.x, e.y, b.z));\n    float c011 = n3f(vec3(b.x, e.y, e.z));\n    float c100 = n3f(vec3(e.x, b.y, b.z));\n    float c101 = n3f(vec3(e.x, b.y, e.z));\n    float c110 = n3f(vec3(e.x, e.y, b.z));\n    float c111 = n3f(e);\n    vec4 z = mix(vec4(c000, c100, c010, c110), vec4(c001, c101, c011, c111),  f.z);\n    vec2 yz = mix(z.xy, z.zw, f.y);\n    return mix(yz.x, yz.y, f.x);\n    \n}\n\n\nfloat fbm4( vec3 p )\n{\n    float f = 0.0;\n    p = m3 * p;\n    f +=     0.5000*n3( p ); p = m3*p*2.02;\n    f +=     0.2500*n3( p ); p = m3*p*2.03;\n    f +=     0.1250*n3( p ); p = m3*p*2.01;\n    f +=     0.0625*n3( p );\n    return f/0.9375;\n}\n\nfloat fbm4( vec2 p )\n{\n    return fbm4(vec3(p, time));\n}\n\nfloat fbm6( vec3 p )\n{\n    float f = 0.0;\n    p = m3 * p;\n    f +=     0.500000*n3( p ); p = m3*p*2.02;\n    f +=     0.250000*n3( p ); p = m3*p*2.03;\n    f +=     0.125000*n3( p ); p = m3*p*2.01;\n    f +=     0.062500*n3( p ); p = m3*p*2.04;\n    f +=     0.031250*n3( p ); p = m3*p*2.01;\n    f +=     0.015625*n3( p );\n    return f/0.984375;\n}\n\n\nfloat fbm6( vec2 p )\n{\n    return fbm6(vec3(p, time));\n}\n\nfloat grid(vec2 p) {\n    p = sin(p * 3.1415);\n    return smoothstep(-0.01, 0.01, p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * 0.7;\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    p.y *= 0.3;\n    p.y -= time * 1.5;\n    float tc = time * 1.2;\n    float tw1 = time * 2.5;\n    float tw2 = time * 0.6;\n\n    vec3 vw1 = vec3(p, tw1);\n    vw1.y *= 2.8;\n    vec2 ofs1 = vec2(fbm4(vw1), fbm4(vw1 + vec3(10.0, 20.0, 50.0)));\n    ofs1.y *= 0.3;\n    ofs1.x *= 1.3;\n\n    vec3 vw2 = vec3(p, tw2);\n    vw2.y *= 0.8;\n    vec2 ofs2 = vec2(fbm4(vw2), fbm4(vw2 + vec3(10.0, 20.0, 50.0)));\n    ofs2.y *= 0.3;\n    ofs2.x *= 1.3;\n    \n    vec2 vs = (p + ofs1 * 0.5 + ofs2 * 0.9) * 4.0;\n    vec3 vc = vec3(vs, tc);\n    float l;\n    l = fbm6(vc);\n    l = smoothstep(0.0, 1.0, l);\n    l = max(0.0, (l - pow(q.y * 0.8, 0.6)) * 1.8);\n    float r = pow(l , 1.5);\n    float g = pow(l , 3.0);\n    float b = pow(l , 6.0);\n    \n    //r = grid(vs);\n    fragColor = vec4( r, g, b, 1.0 );\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor=flames(iChannel0,iChannel0,fragCoord.xy,iResolution.xy);\n\tvec3 c = color_from_sampler(iChannel0, fragCoord.xy,iResolution.xy);\n    \n\tfinalColor = c + finalColor * 0.3;\n\n    fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SIGMA 5.0\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvec3 color_from_sampler(sampler2D s, vec2 p, vec2 r){\n\treturn texture(s, p / r).rgb;\n}\nvec3 flames(sampler2D s1, sampler2D s2, vec2 p, vec2 r){\n\tvec3 c = color_from_sampler(s1, p , r);\n    //fragColor = vec4(c, 1.0);\n    //return;\n    //declare stuff\n    const int mSize = int(SIGMA * 11.0/7.0);\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 finalColor = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = SIGMA;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            finalColor += kernel[kSize+j]*kernel[kSize+i]*texture(s2, (p+vec2(float(i),float(j))) / r).rgb;\n\n        }\n    }\n\n    finalColor /= Z*Z;\n\n\treturn finalColor;\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}