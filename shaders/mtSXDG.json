{
    "Shader": {
        "info": {
            "date": "1676499487",
            "description": "Cartoon Version 1",
            "flags": 2,
            "hasliked": 0,
            "id": "mtSXDG",
            "likes": 1,
            "name": "Fork Cartoon 00 Tabyltop 468",
            "published": 3,
            "tags": [
                "cartoon"
            ],
            "usePreview": 0,
            "username": "Tabyltop",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "// Higher blur sizes are slower and will make large areas of very similar colours become very flat.\n// Low blur sizes are faster and will do nothing.\n// Recommended is 5\n#define BLUR_SIZE 9\n\n// High thresholds mean that the colour has to be very similar to use it with blurring.\n// A low threshold will look more like a normal blur.\n// Recommended is .93\n#define THRESHOLD .8\n\n// The below is for a very strange look that you might get from overdone noise removal.\n// #define BLUR_SIZE 15\n// #define THRESHOLD .85\n\n// Turn this on to see outlines where there are edges.\n// A higher value means more pronounced edges. The edges will also be darker/fatter\n// when there is a greater difference.\n// Note: Use lower values with lower blurs.\n// Recommended values:\n// Blur | Edge\n//   5  |  48\n//  15  |  386\n#define EDGES_AMNT 200.0\n\nvec4 quantize(vec4 color, float levels) {\n    color.r = floor(color.r * levels) / levels;\n   color.g = floor(color.g * levels) / levels;\n   color.b = floor(color.b * levels) / levels;\n\n    return color;\n}\n\nvec3 rgb2hsl(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord)\n{\n\tfloat w = 1./iResolution.x;\n\tfloat h = 1./iResolution.y;\n\n\tn[0] = texture(tex, coord + vec2( -w, -h));\n\tn[1] = texture(tex, coord + vec2(0.0, -h));\n\tn[2] = texture(tex, coord + vec2(  w, -h));\n\tn[3] = texture(tex, coord + vec2( -w, 0.0));\n\tn[4] = texture(tex, coord);\n\tn[5] = texture(tex, coord + vec2(  w, 0.0));\n\tn[6] = texture(tex, coord + vec2( -w, h));\n\tn[7] = texture(tex, coord + vec2(0.0, h));\n\tn[8] = texture(tex, coord + vec2(  w, h));\n}\n\n\n#define DOTSIZE 1.48\n#define D2R(d) radians(d)\n#define MIN_S 2.5\n#define MAX_S 19.0\n#define SPEED 0.57\n\n#define SST 0.888\n#define SSQ 0.288\n\n#define ORIGIN (0.5 * iResolution.xy)\nfloat R;\nfloat S;\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat k = max(max(c.r, c.g), c.b);\n\treturn min(vec4(c.rgb / k, k), 1.0);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn c.rgb * c.a;\n}\n\nvec2 px2uv(in vec2 px)\n{\n\treturn vec2(px / iResolution.xy);\n}\n\nvec2 grid(in vec2 px)\n{\n\treturn px - mod(px,S);\n}\n\nvec4 ss(in vec4 v)\n{\n\treturn smoothstep(SST-SSQ, SST+SSQ, v);\n}\n\nvec4 halftone(in vec2 fc,in mat2 m)\n{\n\tvec2 smp = (grid(m*fc) + 0.5*S) * m;\n\tfloat s = min(length(fc-smp) / (DOTSIZE*0.5*S), 1.0);\n    vec3 texc = texture(iChannel0, px2uv(smp+ORIGIN)).rgb;\n    texc = pow(texc, vec3(2.2)); // Gamma decode.\n\tvec4 c = rgb2cmyki(texc);\n\treturn c+s;\n}\n\nmat2 rotm(in float r)\n{\n\tfloat cr = cos(r);\n\tfloat sr = sin(r);\n\treturn mat2(\n\t\tcr,-sr,\n\t\tsr,cr\n\t);\n}\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    S = MIN_S + (MAX_S-MIN_S) * 2.0*16.0 / iResolution.x;\n    R = D2R(180.0 * (8.0) / iResolution.y);\n\n\tvec2 fc = fragCoord.xy - ORIGIN;\n\t\n\tmat2 mc = rotm(R + D2R(15.0));\n\tmat2 mm = rotm(R + D2R(75.0));\n\tmat2 my = rotm(R);\n\tmat2 mk = rotm(R + D2R(45.0));\n\t\n\tfloat k = halftone(fc, mk).a;\n\tvec3 c = cmyki2rgb(ss(vec4(\n\t\thalftone(fc, mc).r,\n\t\thalftone(fc, mm).g,\n\t\thalftone(fc, my).b,\n\t\thalftone(fc, mk).a\n\t)));\n    \n    c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n\tfragColor = vec4(c, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // find outlines\n    \n        float intensity = 1.5;\n        vec4 n[9];\n        make_kernel( n, iChannel0, fragCoord/iResolution.xy );\n\n        vec4 sobel_edge_h = (n[2]*intensity + (2.0*n[5])*intensity + n[8]*intensity - (n[0]*intensity + (2.0*n[3])*intensity + n[6]*intensity))*1.0;\n        vec4 sobel_edge_v = (n[0]*intensity + (2.0*n[1])*intensity + n[2]*intensity - (n[6]*intensity + (2.0*n[7])*intensity + n[8]*intensity))*1.0;\n        vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n    \n\n\n\n    // reduce noise\n    \n     vec2 uv = fragCoord.xy / iResolution.xy;   \n    //vec4 newColor = vec4(0., 0., 0., 1.);\n    vec4 currentColor = texture(iChannel0, uv);\n    float totalWeight = 1.;\n    vec3 colors = vec3(0.);\n\n     for (int y = -BLUR_SIZE; y < BLUR_SIZE; y++) {\n        for (int x = -BLUR_SIZE; x < BLUR_SIZE; x++) {\n            vec3 color = texture(iChannel0, uv + vec2(float(x), float(y)) / iResolution.xy).rgb;\n\n            float weight = 1. - sqrt(\n                pow(color.r - currentColor.r, 2.) +\n                pow(color.g - currentColor.g,  2.) +\n                pow(color.b - currentColor.b, 2.));\n\n            // threshold\n            if (weight > THRESHOLD) {\n                weight = 1.;\n            } else {\n                weight = 0.;\n            }\n\n            totalWeight += weight;\n\n            colors += color * weight * 1.0;\n\n            vec3 hsl = rgb2hsl(colors.rgb);\n            hsl.z = hsl.z*1.001;\n            hsl.y *= 0.999;\n            colors = hsl2rgb(hsl);\n            colors *= 1.003;\n\n        }\n    }\n    \n\n    fragColor = vec4(colors *=1.0 / totalWeight, 1.);\n    fragColor -= max(0., min(1., 1. - totalWeight / EDGES_AMNT));\n    \n     // Grayscale effect\n      \n        vec2 pixel = vec2(iResolution.x/iResolution.y*1.,1.);\n        vec2 coord = (fragCoord.xy / pixel) + (0.5 / pixel);\n        vec2 newCoord = coord - floor(coord);\n        vec4 grayScale = fragColor;\n        float gray = dot(grayScale.rgb, vec3(0.4, 0.9, 0.));\n        gray = gray*1.5-0.25; // this can raise the black-point and lower the white-point\n        grayScale.rgb = vec3(gray);\n        grayScale = quantize(grayScale, 4.0); // reduce the number of grays\n\n        fragColor = mix(grayScale, fragColor, 0.4); // mix in the grayscale\n         fragColor =  clamp(fragColor,0.0,100.0);\n\n    \n    //fragColor = quantize(fragColor, 6.0); // reduce the number of colors\n    \n    \n    // Halftone effect\n    \n        S = MIN_S + (MAX_S-MIN_S) * 2.0*(iResolution.x / 20.) / iResolution.x;\n        R = D2R(180.0 * (iResolution.x/80.) / iResolution.y);\n\n        vec2 fc = fragCoord.xy - ORIGIN;\n\n        mat2 mc = rotm(R + D2R(15.0));\n        mat2 mm = rotm(R + D2R(75.0));\n        mat2 my = rotm(R);\n        mat2 mk = rotm(R + D2R(45.0));\n\n        float k = halftone(fc, mk).a;\n        vec3 c = cmyki2rgb(ss(vec4(\n            halftone(fc, mc).r,\n            halftone(fc, mm).g,\n            halftone(fc, my).b,\n            halftone(fc, mk).a\n        )));\n\n        c = pow(c, vec3(1.0/2.2)); // Gamma encode.\n        fragColor = mix(fragColor, vec4(c, 1.0), 0.4); // mix in halftone\n    \n    \n    fragColor = mix(fragColor, vec4(0.0, 0.0, 0.0, 5.0), sobel); // add outlines\n \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}