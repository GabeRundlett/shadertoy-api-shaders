{
    "Shader": {
        "info": {
            "date": "1711405773",
            "description": "I don't know what I'm doing...\n(code needs cleanup, sorry for that)",
            "flags": 0,
            "hasliked": 0,
            "id": "lctGzH",
            "likes": 4,
            "name": "p-norm weirdness",
            "published": 3,
            "tags": [
                "pnorm"
            ],
            "usePreview": 0,
            "username": "sedcore",
            "viewed": 190
        },
        "renderpass": [
            {
                "code": "#define P3(x, x0, x1, y0, y1) ((y0) + ((x)-(x0)) / ((x1)-(x0)) * ((y1)-(y0)))\n\n#define rotate_x(x, y, z, angle)    {          \\\n  float y2 = y * cos(angle) - z * sin(angle); \\\n  float z2 = z * cos(angle) + y * sin(angle); \\\n  y = y2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_y(x, y, z, angle)    {          \\\n  float z2 = z * cos(angle) - x * sin(angle); \\\n  float x2 = x * cos(angle) + z * sin(angle); \\\n  x = x2;                                      \\\n  z = z2;                                      \\\n}\n\n#define rotate_z(x, y, z, angle)    {          \\\n  float x2 = x * cos(angle) - y * sin(angle); \\\n  float y2 = y * cos(angle) + x * sin(angle); \\\n  x = x2;                                      \\\n  y = y2;                                      \\\n}\n\nconst float M_PI = radians(180.);\n\n/****************************************************************************/\n/* bezier curve begin                                                       */\n/****************************************************************************/\n\n/* bezier curves are super nice for trajectories */\n\n#if 0\n\ntypedef struct {\n  float x;\n  float y;\n  float z;\n} point_t;\n\ntypedef struct {\n  point_t p0;\n  point_t p1;\n  point_t p2;\n  point_t p3;\n} bezier_t;\n\n#endif\n\n/* cubic bezier (4 control points) */\nvec3 bezier(in vec3 b[4], in float t)\n{\n  float _1_t = 1. - t;\n  float _1_t_2 = _1_t * _1_t;\n  float _1_t_3 = _1_t_2 * _1_t;\n  float t_2 = t * t;\n  float t_3 = t * t_2;\n  return vec3(\n    _1_t_3 * b[0].x + 3. * _1_t_2 * t * b[1].x + 3. * _1_t * t_2 * b[2].x + t_3 * b[3].x,\n    _1_t_3 * b[0].y + 3. * _1_t_2 * t * b[1].y + 3. * _1_t * t_2 * b[2].y + t_3 * b[3].y,\n    _1_t_3 * b[0].z + 3. * _1_t_2 * t * b[1].z + 3. * _1_t * t_2 * b[2].z + t_3 * b[3].z\n  );\n}\n\n/****************************************************************************/\n/* bezier curve end                                                         */\n/****************************************************************************/\n\n/****************************************************************************/\n/* camera management begin                                                  */\n/****************************************************************************/\n\n#define eye    camera[0]\n#define center camera[1]\n#define vx     camera[2]\n#define vy     camera[3]\n\n#if 0\n\n/* the 4 component of the camera array are defined as below */\ntypedef struct {\n  point_t eye;           /* position of the eye */\n  point_t center;        /* center of screen of camera */\n  point_t vx, vy;        /* unit vectors on screen */\n} camera_t;\n\n#endif\n\nvoid compute_camera(out vec3 camera[4], in float frame)\n{\n  float d;\n  float t;\n  float angle;\n\n  frame = mod(frame, 400.);\n\n  /* basic idea is to start the camera in front of cube (0,0,0) then move\n   * forward with some rotations for nice visual effect and end in front\n   * of cube (0,0,-24) so that we can loop the animation (the cube (0,0,-24)\n   * has the same neighbors as the cube (0,0,0), so we can loop)\n   */\n\n  /* position the eye */\n  /* eye movement is snakish, we start in front of cube (0,0,0) and end\n   * in front of cube (0,0,-24) turning around center of each cube on the path\n   */\n\n  if (frame < 100.) {\n    /* turn on the left */\n    angle = P3(frame, 0., 100., -M_PI/2., -3.*M_PI/2.);\n  } else if (frame < 200.) {\n    /* right */\n    angle = P3(frame, 100., 200., -M_PI/2., M_PI/2.);\n  } else if (frame < 300.) {\n    /* left */\n    angle = P3(frame, 200., 300., -M_PI/2., -3.*M_PI/2.);\n  } else {\n    /* right */\n    angle = P3(frame, 300., 400., -M_PI/2., M_PI/2.);\n  }\n  /* we start with a point pointing to the right: (3,0,0) */\n  vec3 p0 = vec3(3,0,0);\n  rotate_y(p0.x, p0.y, p0.z, angle);\n  /* we force z to move forward, the rotation-based stuff is ugly for z */\n  p0.z = P3(frame, 0., 100., 3., -3.);\n  /* move a bit closer to the shape */\n  p0.z += - .5;\n  /* tilt trajectory */\n  rotate_z(p0.x, p0.y, p0.z, M_PI/6.);\n\n  eye = p0;\n\n  /* position p1 (direction of camera from the eye) */\n  /* more or less going forward but some backward for not too much boring */\n  vec3 p1b[4];\n  p1b[0] = vec3(0, 0, 0);     /* start point */\n  p1b[1] = vec3(5, 3, 2);\n  p1b[2] = vec3(-5,-3, -46);\n  p1b[3] = vec3(0, 0, -24);   /* end point */\n  vec3 p1 = bezier(p1b, P3(frame, 0., 400., 0., 1.));\n\n  /* center is on vector (p1-p0) at right distance of the eye */\n  d = length(p1-p0); //sqrt((p1.x-p0.x)*(p1.x-p0.x) + (p1.y-p0.y)*(p1.y-p0.y) + (p1.z-p0.z)*(p1.z-p0.z));\n  /* distance of 0.2 in front of eye (quite close, wide camera angle) */\n  t = 0.2 / d;\n  center = p0 + t * (p1 - p0);\n\n  p1 = center;\n\n  /* position p2 (anchor for angle of camera) (not sure if that means\n   * something, but it's clear in my head: 'eye' is where is the eye, 'center',\n   * is where the eye looks at, but then the camera can rotate around this\n   * center, so we need a third point to define this rotation, this is p2)\n   */\n  /* rotate a bit, not too much, more or less randomly chosen */\n  vec3 p2b[4];\n  p2b[0] = vec3(10, 0, 0);      /* start: no rotation, horizontal cam */\n  p2b[1] = vec3(-10, -10, 0);\n  p2b[2] = vec3(10, 10, -20);\n  p2b[3] = vec3(10, 0, -24);    /* end: no rotation, horizontal cam */\n  vec3 p2 = bezier(p2b, P3(frame, 0., 400., 0., 1.));\n\n  /* project p2 on plane perpendicular to vector (p1-p0) containing p1 */\n  /* vector (p2p-p2) and (p1-p0) are parallel: (p2p-p2) = t * (p1-p0)\n   * and scalar product (p2p-p1) x (p1-p0) = 0\n   * (p2 + t * (p1-p0) - p1) x (p1-p0) = 0\n   * (p2.x + t * (p1.x-p0.x) - p1.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * ((p2.x - p1.x) + t * (p1.x-p0.x)) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * (p2.x - p1.x) * (p1.x - p0.x) + t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = 0\n   * t * (p1.x-p0.x) * (p1.x - p0.x)\n   * + [same y]\n   * + [same z] = -(p2.x - p1.x) * (p1.x - p0.x)\n   * t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n   *     ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z))\n   */\n  vec3 p2p;\n  t = (-(p2.x - p1.x) * (p1.x - p0.x) -(p2.y - p1.y) * (p1.y - p0.y) -(p2.z - p1.z) * (p1.z - p0.z)) /\n      ((p1.x-p0.x) * (p1.x - p0.x) + (p1.y-p0.y) * (p1.y - p0.y) + (p1.z-p0.z) * (p1.z - p0.z));\n  p2p = p2 + t * (p1 - p0);\n\n  /* vx is vector (p2p-p1) at right distance */\n  d = length(p2p - p1); //sqrt((p2p.x-p1.x)*(p2p.x-p1.x) + (p2p.y-p1.y)*(p2p.y-p1.y) + (p2p.z-p1.z)*(p2p.z-p1.z));\n  /* length (right distance) is chosen as 1/100 */\n  t = 1./100. / d;\n  vx = t * (p2p - p1);\n\n  /* vy is vectorial product of vx and vector (center-p0) */\n  vy = cross(vx, center - p0);\n  /* at the right length (also 1/100, as for vx) */\n  d = length(vy); //sqrt(ret.vy.x*ret.vy.x + ret.vy.y*ret.vy.y + ret.vy.z*ret.vy.z);\n  t = 1./100. / d;\n  vy *= t;\n}\n\n/****************************************************************************/\n/* camera management end                                                    */\n/****************************************************************************/\n\nfloat pnorm(float p, float t, float x0, float y0, float z0, float x1, float y1, float z1,\n             float frame,\n             float p2, float p3, float p4)\n{\n  /* the space is covered by cubes of size 6x6x6, repeating in all directions,\n   * each one containing a shape.\n   * We want 4 different shapes on screen for less boring, so each cube is\n   * numbered in [0, 1, 2, 3] and the numbering repeats like this in all\n   * directions, each numbering receives a shape (different shapes have\n   * different p for a given frame)\n   */\n\n  /* (x,y,z) is the point to test */\n  float x = x0 + t * (x1 - x0);\n  float y = y0 + t * (y1 - y0);\n  float z = z0 + t * (z1 - z0);\n\n  /* find in which cube we are */\n  int px = int(round(x / 6.)); px = (px % 4 + 4) % 4;\n  int py = int(round(y / 6.)); py = (py % 4 + 4) % 4;\n  int pz = int(round(z / 6.)); pz = (pz % 4 + 4) % 4;\n\n  /* put (x,y,z) in the cube (0,0,0) for processing */\n  x = mod(mod(x-3.,6.) + 6., 6.)-3.;\n  y = mod(mod(y-3.,6.) + 6., 6.)-3.;\n  z = mod(mod(z-3.,6.) + 6., 6.)-3.;\n\n  /* rotate the shape */\n  float angle = 2. * M_PI * frame / 100.;\n  rotate_y(x, y, z, angle);\n\n  /* select p depending on the cube we're in */\n  if ((px+py+pz) % 4 == 1) p = p2;\n  else if ((px+py+pz) % 4 == 2) p = p3;\n  else if ((px+py+pz) % 4 == 3) p = p4;\n\n  return pow(pow(abs(x), p)\n             + pow(abs(y), p)\n             + pow(abs(z), p),\n             1./p) - 1.;\n}\n\nfloat get_p(float frame)\n{\n  float p;\n  frame = mod(frame, 200.);\n  /* we get p from [1/2 .. 4], linear choice is ugly, so we use several\n   * linear ranges, looks more or less nice, there may be better choices\n   */\n  /* 1/2   1   2    4 */\n  if (frame < 50.)       p = P3(frame, 0., 50., 1./2., 1.);\n  else if (frame < 75.)  p = P3(frame, 50., 75., 1., 2.);\n  else if (frame < 100.) p = P3(frame, 75., 100., 2., 4.);\n  else if (frame < 125.) p = P3(frame, 100., 125., 4., 2.);\n  else if (frame < 150.) p = P3(frame, 125., 150., 2., 1.);\n  else                   p = P3(frame, 150., 200., 1., 1./2.);\n  return p;\n}\n\nfloat dig_t(float p, float x0, float y0, float z0, float x1, float y1, float z1, float frame, float p2, float p3, float p4)\n{\n  float t0;\n  float n0;\n  float delta = .1;\n\n  t0 = 0.;\n  do {\n    n0 = pnorm(p, t0, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n    t0 += delta * n0;\n  } while (n0 > .1 && t0 < 70.);\n  if (t0 >= 70.) return 1000.;\n  return t0-1.;\n}\n\nvec4 raytrace_pnorm(float x, float y, float frame)\n{\n  vec3 camera[4];\n  compute_camera(camera, frame);\n  float x0, y0, z0, x1, y1, z1;\n  float p;\n  float t;\n\n  /* ray is from eye to (x,y) on screen (center of screen is (0,0)) */\n  /* start of ray: eye */\n  x0 = eye.x;\n  y0 = eye.y;\n  z0 = eye.z;\n\n  /* end of ray */\n  /* (x,y) of screen is vector (x*vx + y*vx) starting at point center in\n   * our 3d space\n   */\n  x1 = center.x + x * vx.x + y * vy.x;\n  y1 = center.y + x * vx.y + y * vy.y;\n  z1 = center.z + x * vx.z + y * vy.z;\n\n  /* get the p in [1/2 .. 4], four of them for more diversity on screen */\n  p = get_p(frame);\n  float p2 = get_p(frame + 100.);\n  float p3 = get_p(frame + 50.);\n  float p4 = get_p(frame + 150.);\n\n  /* blue is actually black, looks better ('blue' name kept, lazy me) */\n  vec4 blue = vec4(0, 0, 0, 0);\n  t = dig_t(p, x0, y0, z0, x1, y1, z1, frame, p2, p3, p4);\n  if (t == 1000.) return blue;\n\n  /* a palette based on euclidian distance from (0,0,0) to the point */\n  /* close is yellow, farther is red, far is white */\n  float d = pnorm(2., t, x0, y0, z0, x1, y1, z1, frame, 2., 2., 2.);\n  /* g+rb define yellow */\n  float g = P3(d, 0., 0.6, 125., 10.);\n  float rb = P3(d, 0., 0.6, 125., 10.);\n  /* ra defines red */\n  float ra = P3(d, 0., 2., 0., 255.);\n  g = clamp(g, 0., 255.);\n  rb = clamp(rb, 0., 255.);\n  /* w defines white */\n  float w = clamp(P3(d, 1., 1.4, 0., 120.), 0., 255.);\n  /* alpha is used to fade to 'blue' when very far away, looks nice */\n  float alpha = clamp(P3(t, 10., 70., 1., 0.), 0., 1.);\n  return vec4(\n    alpha * max(clamp(ra+rb, 0., 255.), w) + (1.-alpha) * blue.r,\n    alpha * max(g, w) + (1.-alpha) * blue.g,\n    alpha * max(20., w) + (1.-alpha) * blue.b,\n    0\n  ) / 255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  /* weird coordinates' conversion */\n  float x = fragCoord.x-iResolution.x/2.;\n  float y = fragCoord.y-iResolution.y/2.;\n  x *= 640./iResolution.x;\n  y *= 640./iResolution.x;\n  float frame = iTime * 25.;\n  fragColor = raytrace_pnorm(x, y, frame);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}