{
    "Shader": {
        "info": {
            "date": "1570083865",
            "description": "Created live on-stream at https://twitch.tv/codebasealpha (Episode 64). Part 3 of the Introduction to Shaders series on my stream.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyGW1",
            "likes": 16,
            "name": "CodebaseAlpha3",
            "published": 3,
            "tags": [
                "3d",
                "reflections",
                "codebasealpha",
                "livestream"
            ],
            "usePreview": 0,
            "username": "codebasealpha",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "float sdSphere(in vec3 p, in float r)\n{\n  return length(p) - r;\n}\n\nfloat maxComp(in vec3 p)\n{\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3  di = abs(p) - b;\n  float mc = maxComp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nvec3 saturate(in vec3 a)   { return clamp(a, 0.0, 1.0); }\nvec2 saturate(in vec2 a)   { return clamp(a, 0.0, 1.0); }\nfloat saturate(in float a) { return clamp(a, 0.0, 1.0); }\n\nvoid rot(inout vec2 p, float a)\n{\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\n// soft min function\nfloat smin(float a, float b, float k)\n{\n  float res = exp( -k*a ) + exp( -k*b );\n  return -log( res )/k;\n}\n\nfloat distanceEstimator(in vec3 p, out float ref)\n{\n  float s0 = sdBox(p + vec3(0.0, 0.0, 0.0), vec3(0.7));\n  float s1 = max(s0, -sdSphere(p,0.9));\n  float s2 = sdSphere(p - sin(iTime * 0.3) * vec3(2.0 * sin(iTime), 0, 2.0 * cos(iTime)), 0.5);\n\n  float d = smin(s1, s2, 8.0);\n  float box = sdBox(p - vec3(0.0,-1.0,0.0), vec3(2.0, 0.1, 2.0));\n  \n  // return max(sphere1, -sphere2);\n  float o = min(box, d);\n  \n  if (o == box)\n  {\n    ref = 0.7;\n  }\n  else\n  {\n    ref = 0.3;\n  }\n  \n  return o;\n\n}\n\n#define TOLERANCE       0.001\n#define MAX_RAY_LENGTH  32.0\n#define MAX_RAY_MARCHES 60\n\nfloat rayMarch(in vec3 ro, in vec3 rd, out float ref)\n{\n  float t = 0.1;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++)\n  {\n    float distance = distanceEstimator(ro + rd*t, ref);\n    if (distance < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    t += distance;\n  }\n  return t;\n}\n\n// Calculate vector normal to pos\nvec3 normal(in vec3 pos)\n{\n  vec3 eps = vec3(.001,0.0,0.0);\n  vec3 nor;\n  float ref;\n  nor.x = distanceEstimator(pos+eps.xyy, ref) - distanceEstimator(pos-eps.xyy, ref);\n  nor.y = distanceEstimator(pos+eps.yxy, ref) - distanceEstimator(pos-eps.yxy, ref);\n  nor.z = distanceEstimator(pos+eps.yyx, ref) - distanceEstimator(pos-eps.yyx, ref);\n  return normalize(nor);\n}\n\n// Specular lighting\nfloat specular(in vec3 nor, in vec3 ld, in vec3 rd)\n{\n  return pow(max(dot(reflect(ld, nor), rd), 0.), 75.);\n}\n\n// Diffuse lighting\nfloat diffuse(in vec3 nor, in vec3 ld)\n{\n  return max(dot(nor, ld),0.0);\n}\n\nfloat softShadow(in vec3 pos, in vec3 ld, float mint, float k)\n{\n  float res = 1.0;\n  float t = mint;\n  for (int i=0; i<32; i++)\n  {\n    float ref;\n    float distance = distanceEstimator(pos + ld*t, ref);\n    res = min(res, k*distance/t);\n    t += max(distance, mint*0.2);\n  }\n  return clamp(res,0.25,1.0);\n}\n\nconst vec3 lightPos1 = 20.0*vec3(-0.3, 0.15, 1.0);\nconst vec3 lightPos2 = 20.0*vec3(-0.33,  -0.2, -1.0);\nconst vec3 lightCol1 = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2 = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nvec3 getSkyColor(in vec3 rayDir)\n{\n  vec3 lightDir1 = normalize(lightPos1);\n  vec3 lightDir2 = normalize(lightPos2);\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  float ld2      = max(dot(lightDir2, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n\n  //if ((rayDir.y > abs(rayDir.x)*1.0) && (rayDir.y > abs(rayDir.z*0.25))) final = vec3(2.0)*rayDir.y;\n  //float roundBox = length(max(abs(rayDir.xz/max(0.0,rayDir.y))-vec2(0.9, 4.0),0.0))-0.1;\n  //final += vec3(0.8)* pow(saturate(1.0 - roundBox*0.5), 6.0);\n  \n  final += pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += lightCol1 * pow(ld1, 200.0);\n  final += pow(lightCol2, vec3(2.0, 1.5, 1.5)) * pow(ld2, 8.0);\n  final += lightCol2 * pow(ld2, 200.0);\n  return final;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n  // position of light source\n  vec3 lightPos = -2.0*vec3(1.5, 3.0, -1.0);\n  // background color\n  vec3 skyCol = mix(vec3(0.8, 0.8, 1.0)*0.3, vec3(0.8, 0.8, 1.0)*0.6, 0.25 + 0.75*rd.y);\n  vec3 color  = vec3(0.5, 0.8, 1.0);\n\n  vec3 aggCol = vec3(0.0);\n  //float reflectionFactor = 0.3;\n  float aggReflectionFactor = 1.0;\n\n  for (int i = 0; i < 4; i++)\n  {\n    float reflectionFactor;\n    float t = rayMarch(ro,rd, reflectionFactor);\n    \n    if (t < MAX_RAY_LENGTH)\n    {\n        // Ray intersected object\n        vec3 pos = ro + t * rd;\n        vec3 ld = normalize(pos - lightPos);\n    \n        vec3 nor = normal(pos);\n    \n        // diffuse lighting\n        float d = diffuse(nor, ld);\n        // specular lighting\n        //float s = specular(nor, ld, rd);\n    \n        float sh = softShadow(pos, ld, 0.01, 16.0);\n        vec3 refDir = reflect(rd, nor);\n    \n        aggCol += aggReflectionFactor * reflectionFactor * color * d * sh;\n        aggReflectionFactor *= 1.0- reflectionFactor;\n        \n        ro = pos;\n        rd = refDir;\n    } \n    else\n    {\n        // Ray intersected sky\n        aggCol += aggReflectionFactor * getSkyColor(rd);\n        break;\n    }\n  }\n  \n  return aggCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 p = fragCoord/iResolution.xy - vec2(0.5);\n  p.x *= iResolution.x/iResolution.y;\n    \n  // camera\n  vec3 ro = 3.0*vec3(2.0, 1.0, 0.2);\n  rot(ro.xz, iTime*0.2);\n  vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);\n  vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  // ray direction\n  vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n  vec3 col = render(ro, rd);\n  \n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}