{
    "Shader": {
        "info": {
            "date": "1546790139",
            "description": "I used the volume render technique in this article\nhttps://shaderbits.com/blog/creating-volumetric-ray-marcher",
            "flags": 0,
            "hasliked": 0,
            "id": "WdXGRj",
            "likes": 212,
            "name": "Cloudy Shapes",
            "published": 3,
            "tags": [
                "volume",
                "raymarch",
                "cloud"
            ],
            "usePreview": 0,
            "username": "kaneta",
            "viewed": 7627
        },
        "renderpass": [
            {
                "code": "// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n// iq's smin\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat map( in vec3 p )\n{\n\tvec3 q = p - vec3(0.0,0.5,1.0)*iTime;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(iTime * 3.0) * 6.0, sin(iTime * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(iTime) * 4.0, cos(iTime * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(iTime * 2.0) * 3.0, 0.0, sin(iTime * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    float t = mod(stepUp(iTime, 4.0, 1.0), 4.0);\n    \n\tfloat d = mix(s1, s2, clamp(t, 0.0, 1.0));\n    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));\n    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\n    \n\treturn min(max(0.0, d), 1.0);\n}\n\nfloat jitter;\n\n#define MAX_STEPS 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n\n// Reference\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\nvec4 cloudMarch(vec3 p, vec3 ray)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = map(pos);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rgb += vec3(s * density) * vec3(1.1, 0.9, .5) * sum.a;\n            sum.a *= 1.-density;\n\n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    jitter = hash(p.x + p.y * 57.0 + iTime);\n    vec3 ro = vec3(cos(iTime * .333) * 8.0, -5.5, sin(iTime * .333) * 8.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 c = camera(ro, ta, 0.0);\n    vec3 ray = c * normalize(vec3(p, 1.75));\n    vec4 col = cloudMarch(ro, ray);\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}