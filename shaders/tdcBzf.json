{
    "Shader": {
        "info": {
            "date": "1605667115",
            "description": "Optimizing my earlier cube ray-tracing experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcBzf",
            "likes": 6,
            "name": "Optimized cube",
            "published": 3,
            "tags": [
                "raytracing",
                "lighting"
            ],
            "usePreview": 0,
            "username": "been_jamming",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n\ncube global_cube;\n\nray get_camera_ray(vec2 pixel){\n    float least_side;\n    \n    pixel -= vec2(0.5);\n    least_side = min(iResolution.x, iResolution.y);\n    return ray(vec3(0), vec3(FOV_CONST*pixel.x*iResolution.x/least_side, FOV_CONST*pixel.y*iResolution.y/least_side, FOV_CONST));\n}\n\n//I include this because I eventualy plan to have more than one cube in the scene\nbool lit(vec3 p, vec3 light){\n    ray r;\n    vec3 intersect_pos;\n    int side;\n    float edge_dist;\n    \n    p = p + (p - light)*0.01;//We don't want the ray to collide with the original triangle\n    r = ray(p, light - p);\n    intersect_pos = ray_cube_intersect(global_cube, r, side, edge_dist);\n    \n    return side != -1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ray camera_ray;\n    vec3 intersect_pos;\n    vec3 intersect_normal;\n    vec4 current_color;\n    vec3 light_pos = vec3(2.0, 2.0, 0.0);\n    float l;\n    float edge_dist;\n    int side;\n    \n    intersect_normals[0] = vec3(-1, 0, 0);\n    intersect_normals[1] = vec3(1, 0, 0);\n    intersect_normals[2] = vec3(0, -1, 0);\n    intersect_normals[3] = vec3(0, 1, 0);\n    intersect_normals[4] = vec3(0, 0, -1);\n    intersect_normals[5] = vec3(0, 0, 1);\n    global_cube.orientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n\tglobal_cube.center = vec3(0, 0, 4);\n    \n    camera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n    intersect_pos = ray_cube_intersect(global_cube, camera_ray, side, edge_dist);\n    current_color = edge_dist >= 6.0/7.0 ? vec4(1.0, 0.0, 0.0, 1.0) : vec4(1.0);\n    current_color = edge_dist >= 5.0/7.0 && edge_dist < 6.0/7.0 ? vec4(1.0, 0.5, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 4.0/7.0 && edge_dist < 5.0/7.0 ? vec4(1.0, 1.0, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 3.0/7.0 && edge_dist < 4.0/7.0 ? vec4(0.0, 1.0, 0.0, 1.0) : current_color;\n    current_color = edge_dist >= 2.0/7.0 && edge_dist < 3.0/7.0 ? vec4(0.0, 0.0, 1.0, 1.0) : current_color;\n    current_color = edge_dist >= 1.0/7.0 && edge_dist < 2.0/7.0 ? vec4(0.3, 0.0, 0.5, 1.0) : current_color;\n    current_color = edge_dist < 1.0/7.0 ? vec4(0.6, 0.0, 0.8, 1.0) : current_color;\n    \n    if(side != - 1){\n        if(lit(intersect_pos, light_pos)){\n            intersect_normal = apply_orientation(intersect_normals[side], global_cube.orientation);\n            l = max(dot(intersect_normal, normalize(intersect_pos - light_pos)), 0.0);\n            fragColor = current_color*(l*3.0 + 1.0)/4.0;\n            fragColor.w = 1.0;\n        } else {\n            fragColor = current_color*0.25;\n            fragColor.w = 1.0;\n        }\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct cube{\n    vec3 center;\n    vec4 orientation;\n};\n\nstruct ray{\n    vec3 p;\n    vec3 vec;\n};\n    \nvec3 intersect_normals[6];\n\nvec4 create_orientation(vec3 axis, float angle){\n    float len;\n    vec4 outvec;\n    \n    len = length(axis);\n    axis *= sin(angle)/len;\n    outvec.yzw = axis;\n    outvec.x = cos(angle);\n    \n    return outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n    return vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n    vec4 outvec;\n    \n    outvec.x = a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w;\n    outvec.y = a.x*b.y + a.y*b.x + a.z*b.w - a.w*b.z;\n    outvec.z = a.x*b.z - a.y*b.w + a.z*b.x + a.w*b.y;\n    outvec.w = a.x*b.w + a.y*b.z - a.z*b.y + a.w*b.x;\n    \n    return outvec;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n    vec4 v;\n    \n    v.x = 0.0;\n    v.yzw = p.xyz;\n    return compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nray apply_orientation_ray(ray r, vec4 o){\n    return ray(apply_orientation(r.p, o), apply_orientation(r.vec, o));\n}\n\n//Gets the intersection data between a ray and a cube with side length of 1\nvec3 ray_cube_intersect(cube c, ray r, out int side, out float edge_dist){\n    ray translated_ray;\n    float d = 10000.0;\n    float t = 0.0;\n    vec2 comps;\n    bool best;\n    \n    side = -1;\n    edge_dist = 0.0;\n    \n    translated_ray = ray(r.p - c.center, r.vec);\n    translated_ray = apply_orientation_ray(translated_ray, inverse_orientation(c.orientation));\n    \n    t = (1.0 - translated_ray.p.x)/translated_ray.vec.x;\n    comps = t*translated_ray.vec.yz + translated_ray.p.yz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 0 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.x)/translated_ray.vec.x;\n    comps = t*translated_ray.vec.yz + translated_ray.p.yz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 1 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (1.0 - translated_ray.p.y)/translated_ray.vec.y;\n    comps = t*translated_ray.vec.xz + translated_ray.p.xz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 2 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.y)/translated_ray.vec.y;\n    comps = t*translated_ray.vec.xz + translated_ray.p.xz;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 3 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (1.0 - translated_ray.p.z)/translated_ray.vec.z;\n    comps = t*translated_ray.vec.xy + translated_ray.p.xy;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 4 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    t = (-1.0 - translated_ray.p.z)/translated_ray.vec.z;\n    comps = t*translated_ray.vec.xy + translated_ray.p.xy;\n    best = t > 0.0 && t < d && abs(comps.x) < 1.0 && abs(comps.y) < 1.0;\n    side = best ? 5 : side;\n    d = best ? t : d;\n    edge_dist = best ? max(abs(comps.x), abs(comps.y)) : edge_dist;\n    \n    return d*r.vec + r.p;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}