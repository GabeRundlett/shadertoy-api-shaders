{
    "Shader": {
        "info": {
            "date": "1597708548",
            "description": "a trick i use to reduce iterations while rendering non-exact sdf.\nthe shape is contained inside a bounding sphere,\nand interpolation is used to get close to the surface.\nit takes max. 12 iterations, but it's not very precise.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lXfWj",
            "likes": 3,
            "name": "displacement mapping technique",
            "published": 3,
            "tags": [
                "displacementmapping"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "// this project is a mess !\n// it is an attempt to make raymarching work on my laptop with good fps\n// it kind of works, but i think i might be interested in simpler ideas\n\n// i used things from this shader by iq :\n// https://www.shadertoy.com/view/4d2XWV\n// and other things from Jamie Wong's article\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions\n// and also was inspired by this article\n// https://learnopengl.com/Advanced-Lighting/Parallax-Mapping\n\nconst int raySteps = 8;\nconst int precisionSteps = 4;\n\nconst vec3 lightDir = normalize(vec3(0.5,1.0,0.5));\n\nfloat iPlane( in vec3 ro, in vec3 rd ) {\n    return (-1.0 - ro.y)/rd.y;\n}\n\nfloat dot2(vec3 p) { return dot(p,p);}\n\nfloat getVal(vec3 p) {    \n      \n    //a collection of implicit surfaces.\n    \n    //the distances are not exact, therefore hasardous to draw with raymarching !\n    \n    //this is why i developed this weird\n    //displacement mapping technique.\n    \n    \n\t//return dot2(p)*1.4164 - max(p.x,max(p.y,p.z)) + min(p.x,min(p.y,p.z));\n    \n    //vec3 p2 = p*p.zxy; return max(dot2(p2) - 0.05, dot(p,p)-0.9999);\n\n    vec3 p1 = p*p.yzx; float d = dot(p,p)*0.7; return d*d*d - dot(p1,p1);\n    \n    //return .5 - cos(p.x*3.1415) - cos(p.y*3.1415) - cos(p.z*3.1415);\n    \n    //float d = dot2(p); return d*d - dot(p,vec3(p.xy,p.z*p.z)) + 0.2;\n    \n    //return dot2(p*p) - 0.333333;\n\n    //float d = dot2(p); vec3 p2 = p*p; vec3 c = p2*p2.yzx; return d*d*d - max( c.x, max(c.y, c.z ) )*4.0 - 0.0001;\n    \n\t//float d = dot2(p); return d*d - dot(abs(p.xyz*p.yzx),vec3(1));\n    \n    //float d = dot2(p); return d*d - abs(p.x*p.y*p.z)*5.1 - 0.0001;\n    \n\t//float d = dot(p,vec3(0.7)); float d2 = d*d; return d2*d2*d2 - dot(p,p.yzx)  - 0.0001;\n    \n    // float d = dot(p,p); vec3 c = p*p.yzx; return d*d - max( c.x, max(c.y, c.z ) );\n\n}\n\n//shape + floor, used to compute AO\nfloat scene(vec3 p) {    \n    return min(getVal(p),p.y+1.0);\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat h = b*b - dot( oc, oc ) + sph.w*sph.w;\n\tif( h<0.0 ) return vec2(-1.0);\n    float sh = sqrt( h );\n\treturn vec2(-sh,sh) - b;\n}\n\nconst float raySteps2 = 1.0/float(raySteps);\nfloat getDist(vec3 ro, vec3 rd, vec4 sph) {\n    \n    //do we hit the bounding sphere ?\n\tvec2 sphBound = sphIntersect( ro, rd, sph );\n    \n    if (sphBound.y == -1.0) { return -1.0; }\n\n    sphBound.x = max(0.0,sphBound.x);\n\n    //do we hit the 3D shape ?\n    //(we look at the shape at regular intervals)\n    vec3 ro2 = (sph.xyz - ro)/sph.w;    \n    float raySteps3 = (sphBound.y-sphBound.x)*raySteps2/sph.w;\n    \n    vec2 t   = vec2(sphBound.x/sph.w,      0.0);\n    vec2 val = vec2(getVal(ro2 - rd*t[0]), 0.0);\n    int i = 0;\n        \n    while (i<raySteps && val[0]>0.0) {\n    \n        t   = vec2(t[0] + raySteps3, t[0]);\n        val = vec2(getVal(ro2 - rd*t[0]), val[0]);\n          \n        i++;\n    }\n    \n    //no surface found\n    if (i == raySteps && val[0]>0.0) { return -1.0; }\n\t\n    //now we try to be more precise using linear interpolation\n    //between 2 points on the inside/outside of the shape\n\n    for (int j = 0; j<precisionSteps; j++) {\n                \n        float newT = mix(t[0],t[1],val[0]/(val[0]-val[1]));\n        \n        float newVal = getVal(ro2 - rd*newT);\n        int c = int(newVal>0.0);\n        \n        t[c]   = newT; \n        val[c] = newVal; \n                \n    }\n    return abs(mix(t[0],t[1],val[0]/(val[0]-val[1]))*sph.w); \n}\n\n\nbool shadowRay(vec3 ro, vec3 rd, vec4 sph) {\n    \n\tvec2 sphBound = sphIntersect( ro, rd, sph );\n    \n    if (sphBound.y < 0.0) { return true; }\n    \n    vec3 ro2 = (sph.xyz - ro)/sph.w;    \n    \n    sphBound.x = max(0.0,sphBound.x);\n    float t1 = sphBound.x/sph.w;\n    float raySteps3 = (sphBound.y-sphBound.x)*raySteps2/sph.w;\n        \n    int startInside = int(sphBound.x == 0.0);  //getVal(ro2 - rd*t1) < 0.;\n\n    t1 += raySteps3*float(startInside);\n    int i = startInside;\n\n    while (i < raySteps && getVal(ro2 - rd*t1) > 0.0 ) {\n        t1 += raySteps3;\n        i++;\n    }\n\n    if (i == raySteps) { return true; }\n    return false;\n        \n    \n}\n\nvec3 distance_field_normal(vec3 pos, float rad) {\n    vec2 eps = vec2(0.0001/rad,0.0);\n    pos /= rad;\n    float nx = getVal(pos + eps.xyy);\n    float ny = getVal(pos + eps.yxy);\n    float nz = getVal(pos + eps.yyx);\n    return normalize(getVal(pos)-vec3(nx, ny, nz));\n}\n\n\n//https://www.shadertoy.com/view/MtlBWB\nconst vec3 sq = 1./vec3(sqrt(2.),sqrt(3.),sqrt(4.));\nconst float eps = 0.125;\nconst vec3 eps2 = eps*vec3(2.,3.,4.);\nfloat ao2(vec3 p, vec3 n) {\n    \n    float c1 = float(abs(n.x) < abs(n.y) && abs(n.x) < abs(n.z));\n    float c2 = float(abs(n.y) < abs(n.z));\n    float c3 = c2 - c2*c1;\n    \n    vec3 t = vec3(c1, c3, 1. - c1 - c3);\n    vec3 u = cross(n, t);\n    vec3 v = cross(n, u);    \n    \n    vec3 epn = eps2[2]*n + p;\n    \n    float occ  = max(scene(p + eps*n),0.0);\n          occ += max(scene(p + eps*u),0.0);\n          occ += max(scene(p - eps*u),0.0);\n          occ += max(scene(p + eps*v),0.0);\n          occ += max(scene(p - eps*v),0.0);\n    \n    occ += (max(scene(epn + eps2.z*u),0.0)\n        +   max(scene(epn - eps2.z*u),0.0)\n        +   max(scene(epn + eps2.z*v),0.0)\n        +   max(scene(epn - eps2.z*v),0.0))*0.5;\n\n    occ += max(scene(p + eps2.x*n)*sq.x,0.0);\n    occ += max(scene(p + eps2.y*n)*sq.y,0.0);\n    occ += max(scene(epn         )*sq.z,0.0);\n\n    return max(1.0 - 1.0/(1.0+2.0*occ), 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    float time2 = iTime*0.25;\n    \n    //ray origin + direction\n\tvec3 ro = vec3(cos(-time2)*6.0, 0.9, sin(-time2)*6.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd.xz = vec2(rd.x*sin(time2)+rd.z*cos(time2),rd.x*cos(time2)-rd.z*sin(time2));\n    \n    //output color\n    vec3 col = vec3(0.0);\n    \n    //closest point\n    float tmin = 1e10;\n    \n    vec3 normals;\n    vec3 objCol = vec3(0.0);\n    vec3 pos;\n\n    //floor\n    float t1 = iPlane( ro, rd );\n    if( t1>0.0 ) {\n        tmin = t1;\n        objCol = vec3(3.0/t1);\n        normals = vec3(0.0,1.0,0.0);\n        pos = ro + tmin*rd;\n    }\n    \t\n    //sph : position of the object + size\n    vec4 sph = vec4(0.0, 0.5, 0.0, 2.0);\n    float dist = getDist( ro, rd, sph);\n    if (dist>0.0) {\n        tmin = min(tmin,dist);\n        objCol = vec3(0.01,0.36,0.64);\n        normals = distance_field_normal(sph.xyz - ro-rd*dist, sph.w);\n        pos = ro + tmin*rd ;\n    }\n    \n    //draw \n    float shadow = float(shadowRay( pos + normals*0.0001, lightDir, sph));\n    \n    float diffuse = max (dot(lightDir,normals),0.0);\n    diffuse = min(diffuse, shadow);\n    //diffuse = shadow;\n\n    vec3 reflectDir = reflect(-lightDir,-normals);\n    float specular = pow (max (dot (-rd, reflectDir), 0.0), 10.0)*0.25;\n    \n    float ao = ao2(pos/sph.w, normals);\n\n    col = ( objCol + specular )*( diffuse + 0.1 )*ao ;\n    \n    //col = vec3(ao);\n    //col = vec3(shadow);\n    \n    fragColor = vec4( sqrt(col.rgb), 1.0 );\n    //fragColor = vec4( col.rg, dist.y/float(raySteps), 1.0 );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}