{
    "Shader": {
        "info": {
            "date": "1582220208",
            "description": "Riemann's Zeta Function\n\nDerived from Justaway's [url]https://www.shadertoy.com/view/4lcBDs[/url], but computing the log of the Gamma function to avoid overflow.\n\nUse the mouse to move around (and see code header for other controls).",
            "flags": 16,
            "hasliked": 0,
            "id": "wlKXzh",
            "likes": 10,
            "name": "The Riemann Zeta Function",
            "published": 3,
            "tags": [
                "domain",
                "gamma",
                "zeta",
                "log"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 540
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Riemann zeta function using reflection.\n// Original by Justaway: https://www.shadertoy.com/view/4lcBDs\n// Use log gamma function to avoid overflow\n//\n// Method: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\n//\n// Also optimize log sin and log cos:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\n//\n// Grid lines at Re(z) = 10n, Im(z) = 0.5 (the critical line)\n//\n// Seems accurate up to about Re(z) = 50 or so, then the reflection starts\n// to be misaligned and the purported roots come away from the critical line.\n//\n// <mouse> to move\n// g: show grid\n// r: don't do the reflection\n// x: show log gamma instead of zeta\n// z: zoomed view\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\nconst float LOG2 = 0.6931471805599453;\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n  return cexp(cmul(z2,clog(z1)));\n}\n\nvec2 cpow(int n, vec2 z2) {\n  return cpow(vec2(n,0),z2);\n}\n\nvec2 cpow(float x, vec2 z2) {\n  return cpow(vec2(x,0),z2);\n}\n\nvec2 csin(vec2 z) {\n    return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\nvec2 ccos(vec2 z){\n  z += vec2(0.5*PI,0);\n  return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\n// Approximations to log(sin(z)) and log(cos(z)) from David Young:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\nvec2 clogsin(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(1.5*pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(0.5*pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(sin(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(1.5*PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(0.5*PI+x, 2.0*PI) - PI);\n  else return clog(csin(z));\n}\n\nvec2 clogcos(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(cos(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(PI+x, 2.0*PI) - PI);\n  else return clog(ccos(z));\n}\n\n// Lanczos approximation for Gamma function\n// See Numerical Recipes\nconst float[8] p = float[](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 cloggammaR(vec2 z) {\n  z -= vec2(1,0);\n  vec2 x = vec2(-1.9007e-13,0); // 0.99999999999980993 - 1\n  vec2 pval;\n  int N = 8;\n  // Add smallest first for hopefully increased accuracy.\n  for (int i = N-1; i >= 0; i--) {\n    x += p[i]*cinv(z+vec2(float(i+1),0));\n  }\n  x += vec2(1,0);\n  vec2 t = z + vec2(float(N)-0.5,0);\n  // Original non-log function\n  //return cmul(cmul(cmul(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  vec2 a = vec2(0.5*LOG2PI,0);\n  vec2 b = cmul(clog(t),z+vec2(0.5,0));\n  vec2 c = -t;\n  vec2 y = a+b+c+clog(x);\n  return y;\n}\n\nvec2 cloggammaL(vec2 z) {\n  vec2 a = vec2(LOGPI,0);\n  vec2 b = clogsin(PI*z);\n  vec2 c = cloggammaR(vec2(1,0)-z);\n  vec2 y = a-b-c;\n  return y;\n}\n\nvec2 cloggamma(vec2 z) {\n  if(z.x > 0.0) return cloggammaR(z);\n  else return cloggammaL(z);\n}\n\nvec2 zeta(vec2 s) {\n  int N = 10;//int(0.1*exp(iTime));  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\nvec2 zeta0(vec2 s) {\n  const int N = 20;\n  const float[N] ek = float[N](\n    1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*cinv(cpow(float(i), s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = 1.0;\n  for(int i = N + 1; i <= 2 * N; i++) {\n    sum2 += a*ek[i - N - 1]*cinv(cpow(float(i),s));\n    a = -a;\n  }\n  sum2 = sum2/1048576.0; // 2**N\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\nvec3 gradient(float theta) {\n    vec3 color = vec3(0);\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec3 plotDomain(vec2 z) {\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1), rgb, c.y);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 offset = vec2(0.0*iTime,0);\n    if (false && iMouse.x > 0.0) {\n      offset = -(2.0*iMouse.xy - iResolution.xy)/iResolution.x*100.0;\n    }\n    float zoom = 10.0;\n    if (keypress(CHAR_Z)) zoom = 2.0;\n    vec2 z = (zoom*uv + offset).yx; // Scale and shift\n    vec2 z0 = z; // Starting value of z\n    if (keypress(CHAR_X)) {\n        z = cloggamma(z);\n    } else if (keypress(CHAR_R) || z.x > 0.5){\n      z = zeta(z);\n    } else {\n      // Reflection\n      vec2 temp = zeta(vec2(1,0)-z);\n      temp = clog(temp);\n      temp -= cloggamma(z)+vec2(LOG2,0);\n      temp += LOG2PI*z;\n      temp -= clogcos(0.5*PI*z);\n      temp = cexp(temp);\n      z = temp;\n    }\n    vec3 color = plotDomain(z);\n    //color = hsv2rgb(vec3(atan(z.y,z.x)/(2.0*PI),1,1));\n    //float k = log(length(z));\n    //k = max(k,1.0/k);\n    //color = hsv2rgb(vec3(k,1,1));\n    if (keypress(CHAR_G)) {\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.x-0.5)));\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.y-10.0*round(z0.y/10.0))));\n    }\n    fragColor = vec4(color,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}