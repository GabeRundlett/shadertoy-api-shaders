{
    "Shader": {
        "info": {
            "date": "1727366209",
            "description": "An extruded video image with one level of subdivision.",
            "flags": 0,
            "hasliked": 0,
            "id": "lXBcRG",
            "likes": 7,
            "name": "Fork Extruded V rogo1965 202",
            "published": 3,
            "tags": [
                "grid",
                "video",
                "template",
                "square",
                "extrude",
                "subdivide"
            ],
            "usePreview": 0,
            "username": "rogo1965",
            "viewed": 111
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Video Image\n    --------------------\n\n\tI made this after looking at another one of Flockaroo's cool video effects,\n\tnamely his \"Voxel Video\" example. It's based on basic extruded grid code\n\tthat I've used from time to time. I wanted to see how things would look \n\ttaking a raymarched extruded approach. It lacks some of the multilevel\n    subdivided freakiness that you get with Flockaroo's example, but it's still \n\treasonably interesting.\n\n\tI originally started with one square size, but it was difficult to descern\n\tthe image for all but the smallest of grid cell dimensions, so I used the \n\tusual corner pixel techniques to subdivide down one level. The downside, of \n    course, was forcing the GPU to perform more work. That could be mitigated\n\tby precalculating on a buffer, etc, but I wanted to keep the example \n    relatively simple by restricting things to a single pass. Some might also\n\tnote that I've subdivided one object directly into four small squares, and \n\tleft out the rectangles. I did that for simplicity sake, but a \"power of\n    2\" subdivision would normally include those.\n\n\tAnyway, I did this for a bit of fun, and to satisfy my curiosity. I could \n\tmake a lot of improvements, but this will do for now. Later, I might start\n\twith larger block sizes, then divide down a couple more levels, just to see \n\tif it looks more like Flockaroo's original. However, dealing with \n\tneighboring subdivided grid cells in a raymarching environment can be \n\ttricky, not to mention expensive, so I might try that on the 2D plane first.\n\t\n    \n\n\tInspired by:\n    \n\t// As mentioned, Flockaroo makes all kinds of interesting video processing\n\t// examples, and this is just one of them.\n    voxel video - flockaroo\n\thttps://www.shadertoy.com/view/3stXzB  \n\n\n*/\n\n\n// Increased the visible resolution, where applicable. Uncomment to see what\n// a big diference it makes.\n#define SUBDIVIDE\n\n// Sparkles, or no sparkles.\n#define SPARKLES\n\n// Grayscale, for that artsy look.\n#define GRAYSCALE\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, fract(p/2. - .5)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n   \n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n \n// A regular extruded block grid, subdivided down one level, if necessary.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n//\n// For the subdivision step, split each square into four smaller squares, obtain\n// the heights, then check each against the main height to see whether any\n// exceed a certain threshold. If any do, render the four smaller pylons at\n// their respective heights. In theory, you could keep going this way, but not\n// on a single pass, because you'd soon fry your GPU. :)\n// \nvec4 blocks(vec3 q3){\n    \n    // Scale.\n    const float scale = 1./32.;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, -l, vec2(l.x, -l.y));\n    \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= (ip)*s; // New local position.\n\n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n \n        // The extruded block height. See the height map function, above.\n        float h = hm(idi);\n        #ifndef SUBDIVIDE\n        h = floor(h*15.999)/15.*.15; // Or just, \"h *= .15,\" for nondiscreet heights.\n        #endif\n        \n        #ifdef SUBDIVIDE\n        // Subdivide the block into four smaller blocks, then check it's height\n        // against the main block height (above). If any of the height differences\n        // exceed a threshold (I've chosen one block height unit), then flag then\n        // main block for subdivision.\n        vec4 h4;\n        int sub = 0;\n        for(int j = 0; j<4; j++){\n            h4[j] = hm(idi + ps4[j]/4.);\n            if(abs(h4[j] - h)>1./15.) sub = 1;\n        }\n        \n        \n        // Using the floor function to snap the heights to specific quantized values.\n        h = floor(h*35.999)/35.*.35;\n        h4 = floor(h4*35.999)/35.*.35;\n        \n        // Without discreet heights -- Comment out the two lines above first though.\n        //h *= .35;\n        //h4 *= .35;\n         \n        \n        // If subdividing, render the four smaller blocks at their respective\n        // heights. Otherwise, render the one larger block. Refer to the image\n        // for a visual representation.\n        if(sub==1){\n            \n            // Four smaller extruded blocks.\n            vec4 d4, di4;\n\n            for(int j = 0; j<4; j++){\n                d4[j] = sBoxS(p - ps4[j]/4., l/4. - .05*scale, .005);\n                di4[j] = opExtrusion(d4[j], (q3.z + h4[j]), h4[j]);\n                \n                // If applicable, update the overall minimum distance value,\n                // ID, and box ID.\n                if(di4[j]<d){\n                    d = di4[j];\n                    id = idi + ps4[j]/4.;\n                    // Not used in this example, so we're saving the calulation.\n                    //boxID = float(j)*4. + float(i);\n        \t\t}\n            }\n        }\n        else {\n        #endif\n            \n            // One larger extruded block.\n            float di2D = sBoxS(p, l/2. - .05*scale, .015);\n            \n            // Boring out some of the lower boxes. I like it, but thought it\n            // confused matters.\n            //if(h<1./15.*.15 + .001) di2D = max(di2D, -(di2D + .3*scale));\n            \n        \t// The extruded distance function value.\n            float di = opExtrusion(di2D, (q3.z + h), h);\n            \n            // If applicable, update the overall minimum distance value,\n                // ID, and box ID. \n            if(di<d){\n                d = di;\n                id = idi;\n                // Not used in this example, so we're saving the calulation.\n                //boxID = float(i);\n        \t}\n            \n        #ifdef SUBDIVIDE    \n        }\n        #endif\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec2 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yz; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.7; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n\n    for ( int i = 0 ; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(-.5*.3*cos(iTime/2.), -.5*.2*sin(iTime/2.), -2); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1.5, 2, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2( sin(iTime)/32. );\n\n    \n/*      \n    // Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (iMouse.xy - iResolution.xy*.5)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n*/    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec2 svGID = gID;\n    \n    float svObjID = objID;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID);\n            //vec3 tx = getTex(sp.xy - .5/16.); // See scale in the distance function.\n            // Greyscale value, just in case people switch to the Britney video, etc.\n            // Stylistically, the example works better with color. The Britney video\n            // looks OK, but I'm more of a Shirley Jones kind of guy. :)\n            #ifdef GRAYSCALE\n            texCol = vec3(1)*dot(tx, vec3(.299, .587, .114));\n            #else \n            texCol = tx;\n            #endif\n            \n            \n            #ifdef SPARKLES\n            \n            // Putting some blinking colored dots in the background. I did this to liven\n            // things up a bit. It's a little quirky, but looks... interesting, I guess. :D\n            float rnd = fract(sin(dot((svGID), vec2(141.13, 289.97)))*43758.5453);\n            float rnd2 = fract(sin(dot((svGID + .037), vec2(141.13, 289.97)))*43758.5453);\n            rnd = smoothstep(.9, .95, cos(rnd*6.283 + iTime*2.)*.5 + .5);\n            vec3 rndCol = (.5 + .45*cos(6.2831*mix(0., .3, rnd2) + vec3(0, 1, 2)/1.1));\n            rndCol = mix(rndCol, rndCol.xzy, uv.y*.75 + .5);\n            rndCol = mix(vec3(1), rndCol*50., rnd*smoothstep(1. - (1./1./15. + .001), 1., 1. - texCol.x));\n            \n            texCol *= rndCol;\n            \n            #endif\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(0., 1., texCol);\n \n        }\n        else {\n            \n            // The dark floor in the background. Hiddent behind the pylons, but\n            // you still need it.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(dot(sn, rd) + 1., 0., 1.), 2.);\n        \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff + ao*.3 + vec3(.25, .5, 1)*diff*fre*16. + vec3(1, .5, .2)*spec*2.);\n\n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n\t\n\t}\n    \n    //float rnd = hash21(rd.xy + fract(iTime));\n    //col = clamp(col + (rnd*rnd - .5)*.1, 0., 1.);\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}