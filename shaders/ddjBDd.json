{
    "Shader": {
        "info": {
            "date": "1690297198",
            "description": "More like wibbly rubber than water, lol. Just wanted to test some stuff out and try out raymarching again. I think this will serve as a base sketch for me to improve as I learn better techniques.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddjBDd",
            "likes": 1,
            "name": "raymarched-water",
            "published": 3,
            "tags": [
                "raymarching",
                "water"
            ],
            "usePreview": 0,
            "username": "LydianLights",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "const float MAX_STEPS = 80.0;\nconst float MIN_DIST = 0.01;\n\nconst float AMPLITUDE = 0.13;\nconst float OCTAVES = 5.0;\nconst float LACUNARITY = 1.8;\nconst float GAIN = 0.5;\n\nstruct RayResult {\n    vec3 ray;\n    float d;\n    float steps;\n    bool hit;\n    vec3 p;\n    vec3 color;\n};\n\nfloat fbm(in vec2 q) {\n    float value = 0.0;\n    float amplitude = AMPLITUDE;\n    for (float i = 0.0; i < OCTAVES; i++) {\n        float n = 0.7 * cos(0.5 * q.x + 0.5 * q.y + 0.5 * iTime) +\n                  0.7 * cos(0.5 * q.x - 0.5 * q.y + 0.5 * iTime) +\n                  0.7 * cos(q.x + 3.0 * iTime) +\n                  1.0 * cos(q.y + 5.0 * iTime);\n        n += sign(n) * pow(0.9 * n, 1.1);\n        value += amplitude * n;\n        q *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    float base = 0.2 * cos(0.05 * q.y + iTime);\n    base += sign(base) * pow(0.9 * base, 1.1);\n    return value + base;\n}\n\n\nfloat scene(in vec3 p) {\n    float y = p.y + fbm(p.xz);\n    float d = y;\n \treturn d;\n}\n\nvec3 sceneNormals(in vec3 p) {\n    const float h = 0.005;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(k.xyy * scene(p + k.xyy * h) +\n                     k.yyx * scene(p + k.yyx * h) +\n                     k.yxy * scene(p + k.yxy * h) +\n                     k.xxx * scene(p + k.xxx * h));\n}\n\nvoid shade(inout RayResult r) {\n    const vec3 SKY_COLOR = vec3(0.3, 0.65, 0.8);\n    const vec3 SUN = normalize(vec3(0.0, 9.0, 1.0));\n    const vec3 FAKE_SUN = normalize(vec3(0.0, 2.0, 1.0));\n    const float FOG_DIST = 70.0;\n    const vec3 WATER_COLOR = vec3(0.08, 0.3, 0.7);\n    \n    vec3 sky = SKY_COLOR + pow(dot(r.ray, FAKE_SUN), 5.0);\n    if (!r.hit) {\n        r.color = sky;\n        return;\n    }\n    \n    vec3 normal = sceneNormals(r.p);\n    float diffuse = max(dot(SUN, normal), 0.0);\n    float specular = pow(max(dot(SUN, normal), 0.0), 99.0);\n    \n    vec3 color = diffuse * WATER_COLOR + specular * vec3(1.0);\n    \n    float fog = min(r.d / FOG_DIST, 1.0);\n    color = mix(color, sky, fog);\n    \n    r.color = color;\n}\n\nRayResult march(in vec3 origin, in vec3 ray) {\n    RayResult r;\n    r.ray = ray;\n    r.d = 0.0;\n    for (r.steps = 0.0; r.steps < MAX_STEPS; r.steps++) {\n     \tr.p = origin + ray * r.d;\n        float sd = scene(r.p);\n        if (sd < MIN_DIST) {\n            r.hit = true;\n            break;\n        }\n        r.d += sd;\n    }\n    shade(r);\n    return r;\n}\n\nvec3 gamma(in vec3 color) {\n    return pow(max(color, 0.0), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0, 4.0, -1.0);\n\n    RayResult r = march(origin, ray);\n\n    vec3 color = r.color;\n    color = gamma(color);\n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}