{
    "Shader": {
        "info": {
            "date": "1459457299",
            "description": "based on my shader : https://www.shadertoy.com/view/4stXR7\n\nuncomment the line 29 for see the differents iteration of the fractal based on julia",
            "flags": 32,
            "hasliked": 0,
            "id": "MstSD4",
            "likes": 31,
            "name": "Fractal Experiment 15",
            "published": 3,
            "tags": [
                "15",
                "fracta",
                "lexperiment"
            ],
            "usePreview": 1,
            "username": "aiekick",
            "viewed": 1173
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nshader based on https://www.shadertoy.com/view/4stXR7\nantialiased code from shane simpleAA : https://www.shadertoy.com/view/4d3SWf\n*/\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n    vec2 si = iResolution.xy;\n   \n    const float AA = 2.;\n    \n    vec2 uv = g/si;\n    \n    vec2 pix = AA/si.yy/2.;\n\n    vec3 col = vec3(0);\n\n    for (float i=0.; i<AA; i++)\n    { \n        vec2 uvOffs = uv + vec2(floor(i/AA), mod(i, AA))*pix;\n        col += clamp(texture(iChannel0,uvOffs).rgb, 0., 1.);\n    }\n    \n    col /= AA;\n\n    f = vec4(col, 1.); \n   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/*\nbased on https://www.shadertoy.com/view/4stXR7\n*/\n\n#define mPi 3.14159\n\nconst vec3 ld = vec3(0.,1., .5);\n\nvec2 dstepf = vec2(0);\n\nfloat t = 0., ts = 0.;\n\nvec2 path(float z)\n{\n\treturn vec2(sin(z * 0.8), sin(z * 0.4));\n}\n\nfloat fractus(vec3 p)\n{\n\tvec2 z = p.xy;\n    vec2 c = vec2(0.28,-0.56) * cos(p.z*8.);\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<4.;i++)\n    {\n        //if (i/7. > (sin(iTime*.5)*.5+.5)) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        z = vec2(z.x * z.x - z.y * z.y, 1.5 * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n    float tex0, tex1;\n    tex1 = texture(iChannel1, p.xz*0.5).r * 0.01;\n    \n\tp.xy += path(p.z);\n\ttex0 = texture(iChannel0, p.xy*0.8).r * 0.5;\n    \n    p.xz = cos(p.xz) + sin(p.y*1.5);\n    tex0 -= texture(iChannel0, p.xz*0.01).r * 0.5;\n    \n\tfloat obj = fractus(p);\n\tvec2 res = vec2(obj + tex0 * 0.2, 1.);\n    \n    if (p.y < res.x)\n        res = vec2(p.y + tex1, 2.);\n\n\treturn res;\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<18; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// from velocibox by zackpudil : https://www.shadertoy.com/view/lsdXD8\nvec3 lighting(vec3 p, vec3 lp, vec3 rd, float prec) \n{\n    vec3 l = lp - p;\n    float dist = max(length(l), 0.01);\n    float atten = min(1./(1. + dist*0.5), 0.2);\n    l /= dist;\n    \n    vec3 n = nor(p, prec);\n   \tvec3 r = reflect(-l, n);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    float spe = pow(clamp(dot(r, rd), 0.0, 1.0), 32.0);\n    float fre = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 2.0);\n    float dom = smoothstep(-1.0, 1.0, r.y);\n    \n    vec3 lin = vec3(0.2);\n    lin += 1.0*dif*vec3(1, .97, .85);\n    lin += 2.5*spe*dif*vec3(1, .97, .85);\n    lin += 2.5*fre*vec3(1);\n    lin += 0.5*dom*vec3(1);\n    \n    return lin*atten*calcAO(p, n);\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n    sky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 f, vec2 g )\n{\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = iTime;\n\tts = sin(t)*.5+.5;\n    \n    /* proposal by shane */\n    vec3 rayOrg = vec3(0.,0.4,t);\n    rayOrg.xy -= path(t);\n\n    vec3 camUp = vec3(0,1,0);\n    vec3 camOrg = vec3(0.,0.4,t + .1);\n    camOrg.xy -= path(t + .1);\n    \n    /* original \n\tvec3 rayOrg = vec3(0.,0.4,t);\n\trayOrg.xy -= path(t);\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = rayOrg + vec3(0,0,1);*/\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tvec2 s = vec2(0.01), so=s;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.00001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (s.x<sMin || d>dMax) break;\n\t\ts = df(p);\n        s.x *= (s.x>so.x?2.:1.);\n        so=s;\n\t\td += s.x * 0.2;\n\t\tp = rayOrg + rayDir * d;\t\n        dstepf += vec2(0.01, 0.005);\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tfloat prec, dlight;\n        if (s.y == 2.) // sand\n\t\t{ \n\t\t\tprec = 0.001; \n\t\t\tf.rgb = vec3(1,1,0);\n\t\t\tdlight = dstepf.x; \n\t\t}\n        else if (s.y == 1.) // fractal\n\t\t{ \n\t\t\tprec = 0.01; \n\t\t\tf.rgb = vec3(1,1,1); \n\t\t\tdlight = dstepf.y; \n\t\t}\n        \n        f.rgb *= lighting(p, rayOrg, rayDir, prec);\n        \n        f.rgb *= dlight;\n        \n        f.rgb = mix( f.rgb, sky, 1.0-exp( -0.03*d*d ) ); \n\t}\n\telse\n\t{\n\t\tf.rgb = sky;\n\t}\n    \n    f.rgb = ACESFilm(f.rgb);\n    f = sqrt(f*f*f*1.5);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}