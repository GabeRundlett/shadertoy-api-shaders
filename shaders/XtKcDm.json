{
    "Shader": {
        "info": {
            "date": "1536602193",
            "description": "Simple 3D fractal for my portfolio. It kind of looks like spiders.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtKcDm",
            "likes": 37,
            "name": "Fractal Spiders",
            "published": 3,
            "tags": [
                "procedural",
                "3d"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 3083
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n#define BORDER 4.0\n\n// hash function for dithering\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// hsv function\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = cos( 2.0*PI*c.x + 2.0*PI/3.0*vec3(3,2,1) ) * 0.5 + 0.5;\n\treturn c.z * mix(vec3(1), rgb, c.y);\n}\n\n// from iq filterable procedurals\nfloat grid( in vec3 p, in vec3 dp, in float N ) {\n    vec3 w = abs(dp);\n    vec3 a = p + 0.5*w;                        \n    vec3 b = p - 0.5*w;           \n    vec3 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    return 1.0-(1.0-i.x)*(1.0-i.y)*(1.0-i.z);\n}\n\n// iq smin\nfloat smax( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0.0, 1.0 );\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// main distance function\nfloat de( vec3 p, float r, out float color ) {\n    \n    mat2 q = rot(sin(p.z*1.0)*0.8+0.6);\n    float t = length(p.xy);\n    p = fract(p)-0.5;\n    float d = 9e9;\n    float s = 1.0;\n    for (int i = 1 ; i <= 2 ; i++) {\n        float m = dot(p,p);\n        p = abs(fract(p/m)-0.5);\n        p.xy *= q;\n        s *= m;\n    }\n    d = (length(p.xz)-0.15)*s;\n    \n    color = 0.0;\n    color += grid(p*10.0*s, vec3(r)*s*500.0, 30.0)*0.2;\n    color += grid(p*10.0*s-0.03, vec3(r)*s*500.0, 100.0)*0.8;\n    \n    return smax(d,-t, 0.3);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if (any(greaterThan(fragCoord, iResolution.xy-BORDER)) ||\n        any(lessThan(fragCoord, vec2(BORDER)))) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    bool page = false;\n    vec2 uv = vec2(0);\n    if (iResolution.x > iResolution.y) {\n        uv = fragCoord/iResolution.xy;\n        uv = uv.yx-0.5;\n        uv.y *= iResolution.x/iResolution.y;\n        page = true;\n    } else {\n        fragCoord = iResolution.xy-fragCoord;\n    \tuv = (fragCoord - iResolution.x*0.5) / iResolution.x;\n    }\n    \n\tvec3 from = vec3(0);\n\t//vec3 dir = normalize(vec3(uv.x, 1.0 / tan(FOV*0.5), uv.y));\n    vec3 dir = normalize(vec3(uv.x, cos(length(uv*.5)), uv.y));\n    \n    mat2 rotx = rot(0.0);\n\tmat2 roty = rot(0.0);\n    \n\tif (iMouse.z > 0.5) {\n        vec2 delt = iMouse.xy-iMouse.zw;\n        if (page) {\n            delt = -delt.yx;\n        }\n        rotx = rot(-delt.x*0.004);\n        roty = rot(delt.y*0.004);\n    }\n\t\n\tdir.yz  *= roty;\n\tdir.xy  *= rotx;\n    from.z -= iTime*0.1;\n    \n    // dithering\n    vec3 dither = hash33(vec3(fragCoord.xy, iFrame));\n    \n    // get the sine of the angular extent of a pixel\n    float sinPix = sin(1.0 / iResolution.x)*1.5;\n    // accumulate color front to back\n    vec2 acc = vec2(0, 1);\n\n    float totdist = 0.0;\n    float dummy = 0.0;\n    totdist += dither.r*de(from, 0.0, dummy)*1.0;\n    \n\tfor (int i = 0 ; i < 80 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = totdist*sinPix;\n        float color = 0.0;\n        float dist = de(p, r, color);\n        color *= 1.0 - float(i) / 70.0;\n        \n        // cone trace the surface\n        float prox = dist / r;\n        float alpha = clamp(prox * -0.5 + 0.5, 0.0, 1.0);\n        \n        if (alpha > 0.01) {\n            // accumulate color\n            acc.x += acc.y * (alpha*color);\n            acc.y *= (1.0 - alpha);\n        }\n        \n        // hit a surface, stop\n        if (acc.y < 0.01) {\n            break;\n        }\n        \n        // continue forward\n        totdist += abs(dist*0.6);\n\t}\n    \n    // set random color per day\n    fragColor.rgb = hsv2rgb(vec3(totdist*0.3+iDate.w*0.001,\n                                 0.6, 0.4));\n    fragColor.rgb *= acc.x*0.99+0.01;\n    // gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    // dithering\n    fragColor.rgb += (dither-0.5)*0.01;\n    \n\tfragColor.a = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}