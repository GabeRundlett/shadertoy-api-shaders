{
    "Shader": {
        "info": {
            "date": "1691269374",
            "description": "Pack it up, pack it in",
            "flags": 32,
            "hasliked": 0,
            "id": "DtscDX",
            "likes": 43,
            "name": "Animated Colored Bubble Pack",
            "published": 3,
            "tags": [
                "bubble",
                "packing"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "// Animated Colored Bubble Pack\n// by Leon Denise\n// 05/08/2023\n\n// variation of Colored Bubble Pack\n// https://www.shadertoy.com/view/mtfcDf\n\n// inspired by stb with his amazing shape packing:\n// https://www.shadertoy.com/view/MdGGWt\n\n// this is a very naive understanding and implementation of distance packing\n// with a weird fancy light rendering so it feels a bit special\n\n// Buffer A: color pass\n// Buffer B: distance packing\n\n// update 06/08/2023\n// replace step to smoothstep to reduce aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    float radius = map.y;\n    vec2 pos = map.zw;\n    \n    // shape position\n    vec2 p = 2.*(uv-pos)*vec2(R.x/R.y,1);\n    float dist = length(p);\n    \n    // circle shape from distance\n    float shape = smoothstep(.0,-.01,dist-radius);\n    \n    // seed per shape\n    vec2 seed = floor(pos*R.xy);\n    \n    // uv per shape\n    uv = (p/radius)*.5+.5;\n    \n    // normal and direction\n    float z = sqrt(1.-dist/radius);\n    vec3 normal = normalize(vec3(p/map.y, z));\n    vec3 ray = normal;\n    vec3 axis = erot(vec3(0,0,1), vec3(0,1,0), iTime*hash12(seed+196.));\n    ray = rndrot(ray, hash42(seed)*2.-1.);\n    ray = erot(ray, axis, iTime*hash12(seed)*.5);\n    \n    float angle = dot(ray, vec3(0,1,0));\n    float material = hash12(seed+172.) * 10.;\n    vec3 color = vec3(1);\n\n    // strips\n    if (material < 1.)\n    {\n        color = vec3(1) * ss(abs(fract(ray.z*2.+iTime)-.5)-.25, .01/radius);\n    }\n    // normal axis\n    else if (material < 2.)\n    {\n        color = smoothstep(.0,.01/radius,ray);\n    }\n    // gradient\n    else if (material < 3.)\n    {\n        color = .5+.5*cos(vec3(1,2,3)*5.+hash12(seed+196.)*6.+ray.y*2.+iTime);\n    }\n    // gray\n    else if (material < 4.)\n    {\n        color = vec3(angle*.5+.5);\n    }\n    // dots\n    else if (material < 5.)\n    {\n        vec3 pr = ray*5.+iTime;\n        float cell = hash13(floor(pr));\n        float black = step(cell,.5);\n        float thin = .02/radius;\n        float circle = ss(length(fract(pr)-.5)-.5+thin, thin);\n        color *= black*circle*radius*3.;\n    }\n    // normal\n    else if (material < 6.)\n    {\n        color = ray*.5+.5;\n    }\n    // planet\n    else if (material < 7.)\n    {\n        float x = noise(vec3(ray)*2.+hash42(seed).xyz, 0., 0.5, 2.);\n        color = mix(vec3(0,0,1), vec3(0,1,0), ss(x, .05/radius));\n        color *= dot(normal, vec3(0,0,1));\n    }\n    // cross\n    else if (material < 8.)\n    {\n        float size = .1;\n        float thin = -.01/radius;\n        color *= ss(abs(ray.y)-size, thin)*ss(abs(ray.z)-size, thin)*ss(abs(ray.x)-size, thin);\n    }\n    // code bar\n    else if (material < 9.)\n    {\n        float lon = atan(ray.z, ray.x);\n        float lat = sin(angle+iTime);\n        lat = (acos(lat)/3.14)*.5+.5;\n        vec2 pl = vec2(lon*.5, lat)*10.;\n        float x = hash12(floor(pl));\n        float ex = 1.-(2.*abs(fract(pl.x)-.5));\n        float ey = 1.-(2.*abs(fract(pl.y)-.5));\n        color *= step(.8,x)*smoothstep(.0,.01/radius,ey)*smoothstep(.0,.1/radius,ex);\n    }\n    // noise\n    else\n    {\n        float x = noise(vec3(ray)+hash42(seed).xyz, iTime*.5, 4.*radius, 2.);\n        color *= smoothstep(.2,0.,abs(x));\n        color *= dot(normal, vec3(0,0,1))*radius*4.;\n    }\n    \n    // lighting\n    angle = dot(normal, normalize(vec3(0,-2,-1)));\n    float ratio = (acos(angle)/3.14)*.5+.5;\n    color += pow(ratio, 10.)*.5;\n    color *= ratio;\n    \n    fragColor = vec4(shape*color, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord/R.xy;\n    vec2 p = 2.*(fragCoord-R.xy/2.)/R.y;\n    \n    // random\n    float t = float(iFrame)+iDate.x+iDate.y+iDate.z+iDate.w;\n    vec2 q = hash21(t);\n    \n    // position\n    p -= (q-.5)*2.*vec2(R.x/R.y,1);\n    \n    // data\n    vec4 map = texture(iChannel0, uv);\n    vec4 d = texture(iChannel0, q);\n    float radius = d.x*.9;\n    \n    // distance test\n    float dist = length(p)-radius;\n    \n    // if farer, choose previous result\n    if (map.x < dist)\n    {\n        dist = map.x;\n        radius = map.y;\n        q = map.zw;\n    }\n    \n    // init and reset\n    if (iFrame < 1 || mod(float(iFrame), 60.*40.) < 1.\n    \n    // resolution changed\n    || texture(iChannel0, vec2(0)).xy != iResolution.xy)\n    {\n        // border distance\n        float edge = min(min(abs(uv.y), abs(1.-uv.y)), min(abs(uv.x), abs(1.-uv.x)));\n        float maxRadius = .5;\n        \n        // make it special sometimes\n        //dist = hash11(t) > .9 ? maxRadius : edge;\n        dist = maxRadius;\n        \n        // init/reset values\n        radius = maxRadius;\n        q = vec2(-1);\n    }\n    \n    // serve\n    fragColor = vec4(dist,radius,q);\n    \n    // store resolution so we can reset if it change the next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.)\n    {\n        fragColor = vec4(iResolution.xy, 0, 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define R iResolution.xy\n#define ss(x,t) smoothstep(t,.0,x)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n// Gyroid pattern\n// Explained by Martijn Steinrucken at:\n// https://www.youtube.com/watch?v=b0AayhCO7s8\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\n\n// FBM type of noise with gyroid pattern\nfloat noise (vec3 p, float t, float w, float aa)\n{\n    float result = 0., a = .5;\n    for (float i = 0.; i < 4.; ++i, a/=aa)\n    {\n        p.z += t+result*w; // distortion\n        result += (gyroid(p/a))*a; // noise pattern\n    }\n    return result;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Blackle\n// https://suricrasia.online/blog/shader-functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd)\n{\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*acos(-1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}