{
    "Shader": {
        "info": {
            "date": "1682008527",
            "description": "Another pathtraced Calanque!",
            "flags": 32,
            "hasliked": 0,
            "id": "dlSGWD",
            "likes": 113,
            "name": "RiverScape",
            "published": 3,
            "tags": [
                "water",
                "pathtracing",
                "rocks",
                "calanque"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 4269
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------------------\n// RiverScape\n//\n// Article -> http://www.aduprat.com/portfolio/?page=articles/riverscape\n// ----------------------------------------------------------------\n\nvec3 ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes * RESOLUTION * invRes;\n    vec3 col = texture(iChannel0, uv).rgb / float(iFrame+1);\n    \n    col = ACES(col*8.5 + pow(col,vec3(1.5))*0.0);\n    col = pow(col, vec3(1.0,1.035,1.115));\n    \n    // vignetting\n    col *= vec3(1.) * smoothstep(1.8,.5, length(uv*2.-1.))*.25+.75;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define RESOLUTION iResolution.xy\n//#define RESOLUTION (vec2(1920.,1080.))\n\n\n\n// ---------------------------------------------\n// Hash & Random - From iq\n// ---------------------------------------------\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(rand())/32767.0; }\nvec2 frand2() { return vec2(frand(), frand()); }\nvec3 frand3() { return vec3(frand(), frand(), frand()); }\nvoid  srand( ivec2 p, int frame )\n{\n    int n = frame;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589; // by Hugo Elias\n    n += p.y;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n=n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\nvec3 hash3(vec3 p) {\n    uvec3 x = uvec3(floatBitsToUint(p));\n    const uint k = 1103515245U; \n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\nfloat noise( vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3(i+vec3(0,0,0)).x, \n                        hash3(i+vec3(1,0,0)).x,f.x),\n                   mix( hash3(i+vec3(0,1,0)).x, \n                        hash3(i+vec3(1,1,0)).x,f.x),f.y),\n               mix(mix( hash3(i+vec3(0,0,1)).x, \n                        hash3(i+vec3(1,0,1)).x,f.x),\n                   mix( hash3(i+vec3(0,1,1)).x, \n                        hash3(i+vec3(1,1,1)).x,f.x),f.y),f.z);\n}\nvec4 noised( vec3 x )\n{\n\t// https://iquilezles.org/articles/gradientnoise\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash3( p+vec3(0,0,0) ).x;\n    float b = hash3( p+vec3(1,0,0) ).x;\n    float c = hash3( p+vec3(0,1,0) ).x;\n    float d = hash3( p+vec3(1,1,0) ).x;\n    float e = hash3( p+vec3(0,0,1) ).x;\n    float f = hash3( p+vec3(1,0,1) ).x;\n    float g = hash3( p+vec3(0,1,1) ).x;\n    float h = hash3( p+vec3(1,1,1) ).x;\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z), \n                      2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                      k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                      k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) ).yzwx;\n}\n\n\n// ---------------------------------------------\n// Maths\n// ---------------------------------------------\n#define saturate(x) clamp(x,0.,1.)\n#define PI 3.141592653589\n\nmat2 rot(float v) {\n    float a = cos(v);\n    float b = sin(v);\n    return mat2(a,b,-b,a);\n}\n\n// From Fizzer - https://web.archive.org/web/20170610002747/http://amietia.com/lambertnotangent.html\nvec3 cosineSampleHemisphere(vec3 n)\n{\n    vec2 rnd = frand2();\n\n    float a = PI*2.*rnd.x;\n    float b = 2.0*rnd.y-1.0;\n    \n    vec3 dir = vec3(sqrt(1.0-b*b)*vec2(cos(a),sin(a)),b);\n    return normalize(n + dir);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Microfacet\n// ---------------------------------------------\nfloat Fresnel(float n1, float n2, float VoH, float f0, float f90)\n{\n    float r0 = (n1-n2) / (n1+n2);\n    r0 *= r0;\n    if (n1 > n2)\n    {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-VoH*VoH);\n        if (sinT2 > 1.0)\n            return f90;\n        VoH = sqrt(1.0-sinT2);\n    }\n    float x = 1.0-VoH;\n    float ret = r0+(1.0-r0)*pow(x, 5.);\n    \n    return mix(f0, f90, ret);\n}\n\n\n// ---------------------------------------------\n// SDF Utils\n// ---------------------------------------------\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------\n// Sky\n// ---------------------------------------------\nfloat phaseFunction(float lightDotView)\n{\n    const float k = .9;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\nvec3 skyColor(vec3 rd, vec3 sundir)\n{\n    rd.y += .05;\n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.15, .0) * exp(-rd.y*9.); // Red / Green \n    col += vec3(.3, .4, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n    col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n    \n    return min(col,vec3(1.));\n    \n}\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Distance field \n// ---------------------------------------------\nfloat slice(vec3 p, vec3 dir, float offset, float smoothEdge, float baseD) {\n    //p *= .75;\n    float y = dot(p, dir);\n    float id = floor(y+.5);\n    offset *= max(0.,sign(hash(id)*100.-50.));\n    \n    float ksmooth = smoothEdge;\n    \n    float d =  smax(baseD + hash(id)*offset, abs(y-id)-.5, ksmooth);\n    d =  min(d, smax(baseD + hash(id+1.)*offset, abs(y-id-1.)-.5, ksmooth));\n    d =  min(d, smax(baseD + hash(id-1.)*offset, abs(y-id+1.)-.5, ksmooth));\n    \n    return d;\n}\n\n\n#define ROCKITERATION 7\nfloat fractal(in vec3 pos)\n{\n    const float scale = 2.8;\n    const float minRad2 = .822;\n    const vec4 scaled8 = vec4(3.51);\n\n    vec4 p = vec4(pos,1.), p0 = p;\n    float r2;\n    for (int i=0; i<ROCKITERATION; i++)\n    {\n        p.xz = rot(-p.y*.1) * p.xz;\n        p.xy = rot(-p.z*.1) * p.xy;\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n\n        p = p*scaled8 + p0;\n    }\n  \treturn ((length(p.xyz) - abs(scale - 1.0)) / p.w - pow(scale, float(1-ROCKITERATION)));\n}\n\nfloat displacement( vec3 p )\n{\n    // more cool tricks -> https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\n    vec3 pp = p;\n    float mgn = .5;\n    float d = 0.;\n    for(int i=0; i<4; i++)\n    {\n        vec4 rnd = noised(p+10.);\n        d += rnd.w * mgn;\n        \n        p *= 2.;\n        p += rnd.xyz*.4;\n        mgn *= .5;\n        \n    }\n    \n    \n    return d;\n}\n\n\n#define SLICE_SIZE 25.\nfloat rock(vec3 p) {\n    vec3 pp = p;\n    p.xz = mod(p.xz-2.,4.)-2.;\n    p.xz = rot(pp.x*.05) * p.xz;\n    \n\n   // float r = length(pp.yz)-1.;\n    //r = min(length(pp.yz-vec2(.5,-2.3))-1., r);\n    float r = fractal(p);\n    float d = smin(r, p.y+.1, .1);//smin(r, p.y+.3, .2);\n    d = max(d,p.y-1.2);\n    if (r<.3) {\n        d = mix(d*1.5, displacement(pp*25.+1.3)*.02-0.002, smoothstep(-1.,-1.3, p.z)*.25+.25);\n\n        d = slice(p*SLICE_SIZE, normalize(vec3(0.0,3.,2.+cos(p.x*5.)*.2)), 0.03,.3*smoothstep(0.8,0.3,noise(p*5.+1.1))*smoothstep(-.3,0.,p.y)*step(0.,length(p.xz-vec2(-.4,-1.))-.15), d*SLICE_SIZE)/SLICE_SIZE;\n    }\n    r = d;\n    \n    \n    return r;\n}\n\nfloat traceIn = 1.;\n\nfloat water(vec3 p) {\n    if (traceIn < 0.) return 9999.;\n    const mat2 mw = mat2(1.6,1.2,-1.2,1.6);\n    float d = p.y;\n    p *= 15.;\n    float amp = .005;\n    p.xz *= mw;\n    \n    // Add detail only if we are closed of the surface\n    if (d < .2) {\n        for(int i=0; i<3; i++)\n        {\n            d -= (1.-abs(sin(noise(p.xz)))) * amp;\n            amp *= .5;\n            p.xz *= mw;\n        }\n    }\n    return d;\n}\n\nfloat map(vec3 p) {\n    float d = min(rock(p), water(p));\n    return d;\n}\n\n\n\n\n\n\n\n\n\n// ---------------------------------------------\n// Ray tracing \n// ---------------------------------------------\nfloat trace(vec3 ro, vec3 rd, vec2 nf) {\n    traceIn = (ro+rd*nf.x).y < 0. ? -1. : 1.;\n    float t = nf.x;\n    for(int i=min(0,iFrame); i<128; i++) {\n        float d = map(ro+rd*t);\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\nfloat trace2(vec3 ro, vec3 rd, vec2 nf) {\n    traceIn = ro.y < 0. ? -1. : 1.;\n    float t = nf.x;\n    for(int i=min(0,iFrame); i<64; i++) {\n        float d = rock(ro+rd*t);\n        if (t > nf.y || abs(d)<0.001) break;\n        t += d;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p, float t) {\n    traceIn = p.y < 0. ? -1. : 1.;\n\n    vec2 eps = vec2(0.0001,0.0);\n    float d = map(p);\n    vec3 n;\n    n.x = d - map(p - eps.xyy);\n    n.y = d - map(p - eps.yxy);\n    n.z = d - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n\n\n\n\n// ---------------------------------------------\n// Raw Frame\n// ---------------------------------------------\n#define sundir normalize( vec3(-5.,5.5,-5.))\n#define suncolor vec3(1.,.45,.25)\n\n// ---------------------------------------------\n// BRDFs\n// ---------------------------------------------\nfloat moisture(vec3 p) {\n    return smoothstep(0.0,.1, abs(p.y)+(noise(p*10.)-.5)*.0);\n}\nvec3 rock_albedo(vec3 p, vec3 n) {\n    float t = moisture(p);\n    float c = displacement(p*vec3(15.));\n    \n    vec3 col = mix(vec3(1.,.6,.4)*.7, vec3(1.,.7,.5), smoothstep(0.1,.3, abs(cos(p.y*15.-p.x*3.+c*.5))))*.2;\n    \n    if (p.y > 0.)\n    col *= smoothstep(0.05,.13, abs(p.y))*.75+.25;\n    \n    col = mix(vec3(1.,.5,.8)*.05, col, saturate(t+.25));\n    return col;\n}\nvec4 sampleRockBRDF(vec3 v, vec3 n, vec3 p, out vec3 l) {\n    l = cosineSampleHemisphere(n);\n    \n    float refl = 1.-moisture(p);\n    if (frand() < refl)\n        l = reflect(-v,n);\n    return vec4(rock_albedo(p, n), 1.);\n}\n\nvec4 sampleWaterBSDF(vec3 v, vec3 n, out vec3 l, inout bool isRefracted) {\n    \n    const float ior = 1.01;\n    float dielF = Fresnel(1., ior, abs(dot(v,n)), 0., 1.);\n    \n    \n    vec4 brdf = vec4(.6,.8,1.,1.);\n    if (frand() < dielF) {\n        l = reflect(-v,n);\n        brdf.a = dielF;\n    } else {\n        isRefracted = true;\n        l = refract(-v,n, 1./ior);\n        brdf.a = 1.-dielF;\n    }\n    l = normalize(l + (frand3()*2.-1.)*.01);\n    return brdf;\n}\n\n\n// ---------------------------------------------\n// Pathtracing\n// ---------------------------------------------\nvec4 pathtrace(vec3 ro, vec3 rd) {\n    \n    float firstDepth = 0.;\n    vec3 acc = vec3(0.);\n    vec3 abso = vec3(1.);\n    \n    for(int i=min(0,iFrame); i<3; i++) {\n        // trace\n        float t = trace(ro,rd, vec2(0.01, 100.));\n        vec3 p = ro + rd * t;\n        if (i == 0) firstDepth = t;\n        \n        // sky intersection ?\n        if (t >= 100.) {\n            //acc += vec3(1.) * abso;\n            acc += skyColor(rd,sundir)*2. * abso;\n            break;\n        }\n        \n        // info at intersection point\n        vec3 n = normal(p, t);\n        \n        // sample BRDF\n        bool isWater = (map(p) == water(p));\n        vec3 outDir;\n        bool isRefracted = false;\n        vec4 bsdf;\n        if (isWater) {\n            bsdf = sampleWaterBSDF(-rd, n, outDir, isRefracted);\n        } else {\n            vec3 bump = vec3(0.);\n            bump += noised(p*1550.).xyz;\n            bump += noised(p*600.).xyz;\n            bump += noised(p*1200.).xyz;\n            bump = mix(noised(p*450.).xyz*1., bump, moisture(p));\n            n  = normalize(n+bump*.3 );\n            bsdf = sampleRockBRDF(-rd, n, p, outDir);\n        }\n        \n        // medium absorption\n        traceIn = 1.;\n        if (water(p) < 0. && t > 0.3) {\n            abso *= exp(-t * (vec3(3.,1.5,1.)) * 1.5 );\n        }\n        \n        // sun light\n        if (!isWater)\n        {\n            vec3 srd = normalize(sundir + (hash3(p)*2.-1.)*.05);\n            float tt = trace2(p+n*.0, srd, vec2(0.01, 20.));\n            acc += suncolor*12.5 * max(dot(n,srd),0.) * step(20., tt) * rock_albedo(p, n) * abso;\n        }\n        \n        // brdf absorption\n        if ( bsdf.a > 0.)\n            abso *= bsdf.rgb;\n        \n        \n        // next direction\n        ro = p;\n        rd = outDir;\n        if (isRefracted) {\n            ro -= n*0.01;\n        } else {\n            ro += n*0.01;\n        }\n    }\n\n    return vec4(acc, firstDepth);\n}\n\n\n// ---------------------------------------------\n// Entrypoint\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.x >= RESOLUTION.x || fragCoord.y >= RESOLUTION.y) {\n        fragColor = vec4(0.);\n        return;\n    }\n    vec2 invRes = vec2(1.) / RESOLUTION;\n    srand(ivec2(fragCoord), iFrame);\n    \n    // setup ray\n    vec2 uv = (fragCoord + frand2()-.5) * invRes;\n    vec3 ro = normalize(vec3(cos(-0.9), 0.1, sin(-0.9)))*1.5;\n    vec2 v = uv*2.-1.;\n    v.x *= RESOLUTION.x * invRes.y;\n    \n    // setup camera\n    const vec3 up = vec3(0.,1.,0.);\n    vec3 fw = normalize(vec3(0.,0.2,-1.1)-ro);\n    vec3 uu = normalize(cross(fw, up));\n    vec3 vv = normalize(cross(uu, fw));\n    vec3 er = normalize(vec3(v,6.8));\n    vec3 rd = uu * er.x + vv * er.y + fw * er.z;\n    \n    // depth of field\n    float focusDistance = 1.;\n    float blurAmount = 0.003;\n    vec3 go = blurAmount*vec3( normalize(frand2()*2.-1.)*sqrt(frand()), 0.0 );\n    vec3 gd = normalize( er*focusDistance - go );\n    ro += go.x*uu + go.y*vv;\n    rd += gd.x*uu + gd.y*vv;\n    rd = normalize(rd);\n    \n    \n    // pathtrace\n    vec4 col = pathtrace(ro, rd);\n    col.rgb = mix(col.rgb, vec3(.6,.8,1.)*.5, smoothstep(00.,30., col.a));\n\n    // light scattering\n    vec3 acc = vec3(0.);\n    float phase = phaseFunction(dot(sundir,rd));\n    vec3 p = ro + rd * col.a * frand();\n    vec3 srd = normalize(sundir + (hash3(p)*2.-1.)*.05);\n    float tt = trace2(p, srd, vec2(0., 20.));\n    acc += vec3(1.,.7,.5)*phase*2. * step(20., tt);\n    \n    fragColor = vec4(min(col.rgb+acc,vec3(10.)),1.);\n    fragColor += texture(iChannel0, fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}