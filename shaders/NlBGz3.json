{
    "Shader": {
        "info": {
            "date": "1625120774",
            "description": "From [url]https://raytracing.github.io/books/RayTracingInOneWeekend[/url]. A path tracer. Ported it over almost verbatim.\nAnimated it for stress testing speed. No temporal AA hack\nMuch improved version at [url]https://www.shadertoy.com/view/7tBXDh[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "NlBGz3",
            "likes": 7,
            "name": "Ray Tracing One Weekend",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "chenglou",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "//https://raytracing.github.io/books/RayTracingInOneWeekend.html\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = hash32(p * 10000. + test) * 2. - 1.;\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\n\nvec3 random_in_unit_disk(vec2 p) {\n    float test = 0.;\n    while (test < 9999.) {\n        vec3 pt = vec3(hash22(p * 10000. + test) * 2. - 1., 0);\n        float len = length(pt);\n        if (len * len >= 1.) {\n            test += 1.;\n            continue;\n        }\n        return pt;\n    }\n}\n\n\nconst int material_lambertian = 0;\nconst int material_metal = 1;\nconst int material_dielectric = 2;\n\nstruct ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct material {\n    int type;\n    vec3 albedo;\n    float metal_fuzz;\n    float dielectric_index_of_refraction;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    float t;\n    material material;\n};\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    material material;\n};\n\nsphere[] spheres = sphere[](\n    // ground\n    sphere(vec3( 0.0, -1000., -1.0), 1000., material(material_lambertian, vec3(0.5), 0., 0.)),\n\n    sphere(vec3(-4.0,    1.0, 2.),   1.0, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3( 0.0,    1.0, 0.),   1.0, material(material_metal, vec3(0.7, 0.6, 0.5), 0., 0.)),\n    sphere(vec3( 4.0,    1.0, 2.),   1.0, material(material_lambertian, vec3(0.7, 0.3, 0.3), 0., 0.)),\n\n    // smaller balls\n    sphere(vec3(-6, 0.2, 2.8), 0.2, material(material_dielectric, vec3(0, 0, 0.2), 0., 1.5)),\n    sphere(vec3(1.6, 0.2, -0.9), 0.2, material(material_dielectric, vec3(0), 0., 1.5)),\n    sphere(vec3(-5.7, 0.2, -2.7), 0.2, material(material_lambertian, vec3(0.8, 0.3, 0.3), 0., 0.)),\n    sphere(vec3(-3.6, 0.2, -4.4), 0.2, material(material_lambertian, vec3(0.9, 0.3, 0.2), 0., 0.)),\n    sphere(vec3(0.8, 0.2, 2.3), 0.2, material(material_lambertian, vec3(0.2, 0, 0.5), 0., 0.)),\n    sphere(vec3(3.8, 0.2, 4.2), 0.2, material(material_lambertian, vec3(0.4, 0.3, 0.7), 0., 0.)),\n    sphere(vec3(-0.1, 0.2, -1.9), 0.2, material(material_lambertian, vec3(0.4, 0, 0.4), 0., 0.)),\n    sphere(vec3(-2.5, 0.2, 5.4), 0.2, material(material_metal, vec3(0.3, 0.7, 0.9), 0.3, 0.)),\n    sphere(vec3(-3.9, 0.2, -0.3), 0.2, material(material_lambertian, vec3(0.9, 0.8, 0.5), 0., 0.)),\n    sphere(vec3(-6, 0.2, 4), 0.2, material(material_lambertian, vec3(0.9, 0.9, 0.5), 0., 0.)),\n    sphere(vec3(4.4, 0.2, -0.5), 0.2, material(material_lambertian, vec3(0.5, 0.4, 0.8), 0., 0.)),\n    sphere(vec3(3.4, 0.2, 5.3), 0.2, material(material_lambertian, vec3(0.1, 0.6, 0.2), 0., 0.)),\n    sphere(vec3(4.6, 0.2, -3.8), 0.2, material(material_lambertian, vec3(0.2, 0.2, 0.2), 0., 0.)),\n    sphere(vec3(0.7, 0.2, -2.5), 0.2, material(material_metal, vec3(0, 0.2, 0.1), 0., 0.)),\n    sphere(vec3(2.4, 0.2, -4.3), 0.2, material(material_lambertian, vec3(0.8, 0.9, 0), 0., 0.)),\n    sphere(vec3(4.4, 0.2, 4.9), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0), 0., 0.)),\n    sphere(vec3(-4.7, 0.2, 4.6), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.7), 0., 0.)),\n    sphere(vec3(4.2, 0.2, -3.5), 0.2, material(material_lambertian, vec3(0.8, 0.8, 0.6), 0., 0.)),\n    sphere(vec3(-5.2, 0.2, 0.5), 0.2, material(material_lambertian, vec3(0.2, 0.7, 0.9), 0., 0.)),\n    sphere(vec3(5.7, 0.2, -0.8), 0.2, material(material_lambertian, vec3(0.3, 0, 0.7), 0., 0.))\n);\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {    \n    vec3 oc = r.origin - sph.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.) {\n        return false;\n    }\n    \n    float sqrtd = sqrt(discriminant);\n    \n    // Find the nearest root that lies in the acceptable range\n    float root = (-half_b - sqrtd) / a; // the t. from -b - sqrt(dis) / 2a\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root) {\n            return false;\n        }\n    }\n    \n    vec3 p = r.origin + r.dir * root;\n    rec = hit_record(p, (p - sph.center) / sph.radius, root, sph.material);\n    \n    return true;\n}\n\nbool hit(ray r, float t_min, float t_max, out hit_record rec) {\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    hit_record rec_;\n    for (int i = 0; i < spheres.length(); i++) {\n        if (hit_sphere(spheres[i], r, t_min, closest_so_far, rec_)) {\n            hit_anything = true;\n            closest_so_far = rec_.t;\n            rec = rec_;\n        }\n    }\n    \n    return hit_anything;\n}\n\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance\n    float r0 = (1. - ref_idx) / (1. + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1. - r0) * pow((1. - cosine), 5.);\n}\n\nbool scatter(hit_record rec, ray r, vec2 seed, out vec3 attenuation, out ray scattered) {\n    material m = rec.material;\n    \n    if (m.type == material_lambertian) {\n        vec3 scatter_direction = rec.normal + random_unit_vector(seed);\n    \n        // catch degenerate scatter direction\n        if (near_zero(scatter_direction)) {\n            scatter_direction = rec.normal;\n        }\n\n        scattered = ray(rec.p, scatter_direction);\n        attenuation = m.albedo;\n        return true;\n    } else if (m.type == material_metal) {\n        vec3 reflected = reflect(normalize(r.dir), rec.normal);\n        scattered = ray(rec.p, reflected + m.metal_fuzz * random_in_unit_sphere(seed));\n        attenuation = m.albedo;\n        return dot(scattered.dir, rec.normal) > 0.;\n    } else if (m.type == material_dielectric) {\n        attenuation = vec3(1);\n        \n        bool front_face = dot(r.dir, rec.normal) < 0.;\n        vec3 adjusted_normal = front_face ? rec.normal : -rec.normal;\n        float ref = m.dielectric_index_of_refraction;\n        float refraction_ratio = front_face ? 1.0/ref : ref;\n        \n        vec3 unit_direction = normalize(r.dir);\n        float cos_theta = min(dot(-unit_direction, adjusted_normal), 1.0);\n        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n        \n        bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n        vec3 direction;\n\n        if (cannot_refract || reflectance(cos_theta, refraction_ratio) > hash12(seed)) {\n            direction = reflect(unit_direction, adjusted_normal);\n        } else {\n            direction = refract(unit_direction, adjusted_normal, refraction_ratio);\n        }\n        \n        scattered = ray(rec.p, direction);\n        return true;\n    }\n}\n\nvec3 ray_color(in ray r, vec2 seed, int max_depth) {\n    vec3 color = vec3(1);\n    \n    int depth = max_depth;\n    hit_record rec;\n    while (depth > 0) {\n        if (hit(r, 0.001, 99999., rec)) {\n            ray scattered;\n            vec3 attenuation;\n            if (scatter(rec, r, seed + float(depth), attenuation, scattered)) {\n                r = scattered;\n                color = attenuation * color;\n            }\n        } else {\n            // hit bg, aka nothing\n            vec3 unit_direction = normalize(r.dir);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color *= mix(vec3(1.), vec3(0.5, 0.7, 1.0), t);\n\n            break;\n        }\n        \n        depth--;\n    }\n    \n    if (depth == 0) {\n        return vec3(0);\n    }\n    return color;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image\n    float samples_per_pixel = 10.;\n    int max_depth = 6; // number of ray bounces\n    \n    // camera\n    vec3 lookfrom = vec3(cos(iTime) * 13., 2.0, sin(iTime) * 10.);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 vup = vec3(0, 1, 0);\n    float vfov = 30.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float aperture = 0.1;\n    float focus_dist = 10.0;\n    \n    float theta = radians(vfov);\n    float h = tan(theta / 2.);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n    vec3 origin = lookfrom;\n    vec3 horizontal = focus_dist * viewport_width * u;\n    vec3 vertical = focus_dist * viewport_height * v;\n    vec3 lower_left_corner = origin - horizontal / 2. - vertical / 2. - focus_dist * w;\n    \n    float lens_radius = aperture / 2.;\n    \n    // render\n    vec3 color = vec3(0);\n    for (float s = 0.; s < samples_per_pixel; s++) {\n        vec2 rand = hash22(fragCoord * 10000. + s);\n               \n        vec2 normalizedCoord = (fragCoord + rand) / (iResolution.xy - 1.);\n        vec3 rd = lens_radius * random_in_unit_disk(normalizedCoord);\n        vec3 offset = u * rd.x + v * rd.y;\n        ray r = ray(\n            origin + offset, \n            lower_left_corner + normalizedCoord.x * horizontal + normalizedCoord.y * vertical - origin - offset\n        );\n        color += ray_color(r, normalizedCoord, max_depth);\n    }\n    \n    fragColor = vec4(sqrt(color / samples_per_pixel), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}