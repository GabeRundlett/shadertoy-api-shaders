{
    "Shader": {
        "info": {
            "date": "1583348920",
            "description": "This shows conductive (complex) Fresnel on the bottom, dielectric Fresnel on the top.  Using wavelength-based IOR (n) and extinction (k) parameters.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttySzt",
            "likes": 5,
            "name": "Conductive Fresnel",
            "published": 3,
            "tags": [
                "fresnel",
                "metallic",
                "extinction",
                "conductive",
                "ior"
            ],
            "usePreview": 0,
            "username": "bhouston",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "vec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nconst float INFINITY = 100000.0;\n\n#define ENV_MAP // enable envmap\n//#define REFLETIVITY_METAL_APPROX // replace dieletric Fresnel with just 1.0    \n\n//\n// Wavelength dependent IOR and Extinction derived from\n// https://refractiveindex.info/\n// \n// Wavelength micrometers used are r = 0.63, g = 0.532, b = 0.465\n// \n\nvoid getNK( out vec3 n, out vec3 k ) { \n\n\tfloat stage = mod( iTime / ( 3.14156 * 2.0 ), 6.0 );\n    \n\tif( stage < 1.0 ) {\n\t\t// IRON\n\t\tn = vec3(2.943, 2.9211, 2.4728);\n\t\tk = vec3(2.9718, 2.9236, 2.7067);\t\n    }\n\telse if( stage < 2.0 ) {\n    \t// SILVER\n        // NOTE: almost no difference between Dielectric and Conductive Fresnel\n        n = vec3(0.056909, 0.054007, 0.046878);\n        k = vec3(4.2543, 3.429, 2.8028);\t\n    }\n\telse if( stage < 3.0 ) {\n        // COPPER\n        n = vec3(0.27527,1.1159,1.2469);\n        k = vec3(3.3726, 2.5956, 2.4562);\n    }\n\telse if( stage < 4.0 ) {\n\t\t// ALUMINIUM\n\t\tn = vec3(1.1167, 0.97274, 0.57037);\n\t\tk = vec3(6.8768, 6.5119, 5.2086);\t\n    }\n\telse if( stage < 5.0 ) {\n\t\t// NICKEL\n        n = vec3(1.9479, 1.8975, 1.7094);\n        k = vec3(3.7424, 3.5489, 2.8128);\t\n    }\n\telse if( stage < 6.0 ) {\n        // GOLD\n        // NOTE: almost no difference between Dielectric and Conductive Fresnel\n        n = vec3(0.18836, 0.54386, 1.3319);\n        k = vec3(3.4034, 2.2309, 1.8693);\n    }\n}\n\nfloat pow2( const in float a ) { return a *a; }\nvec3 pow2( const in vec3 a ) { return a *a; }\n\n//\n// Approximation of Spectral Complex Fresnel based on just sampling RGB wavelengths\n//\n// source: https://docs.chaosgroup.com/display/OSLShaders/Complex+Fresnel+shader\n//\nvec3 F_ConductiveFresnel( const in vec3 n, const in vec3 k, const in float dotNV ) {\n\n    vec3 rs_num = pow2( n ) + pow2( k ) - 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs_den = pow2( n ) + pow2( k ) + 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs = rs_num / rs_den;\n     \n    vec3 rp_num = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) - 2.0 * n * dotNV + 1.0;\n    vec3 rp_den = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) + 2.0 * n * dotNV + 1.0;\n    vec3 rp = rp_num / rp_den;\n     \n    return clamp( 0.5 * ( rs + rp ), vec3(0.0), vec3(1.0) );\n}\n\nvec3 F_DielectricFresnel( const in vec3 reflectivity, const in float dotNV ) {\n\t// Based on the standard Schlick approximation\n\tfloat fresnel = pow( 1.0 - dotNV, 5.0 );\n\treturn vec3( ( 1.0 - reflectivity ) * fresnel + reflectivity );\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n    vec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\t\n\t\n\tvec3 point, normal; \n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n    \n    vec3 viewDir = normalize( -point );\n    float dotVN = dot( viewDir, normal );\n    \n    vec3 n, k;\n    getNK( n, k );\n    \n    // Calculate reflectivity (F0) from the conductive Fresnel\n    vec3 reflectivity = F_ConductiveFresnel( n, k, 1.0 );\n    \n    vec3 reflection = reflect( viewDir, normal );\n\n    vec3 env = texture( iChannel2, reflection ).xyz;\n    \n    vec3 F = vec3( 0.0 );\n                  \n\tif (dist < INFINITY) {\n\t  \n        if( ( uv.y + cos( iTime ) ) < 0.0 ) {  \n#ifdef REFLETIVITY_METAL_APPROX        \n\t\t\tF = reflectivity;\n#else\n            F = F_DielectricFresnel( reflectivity, dotVN );\n#endif\n        }\n        else {\n\t\t\tF = F_ConductiveFresnel( n, k, dotVN );\n        }\n    }\n    \n    \n\tfragColor.xyz = F;\n#ifdef ENV_MAP\n    fragColor.xyz *= env * 1.5;\n#endif\n    \n    if (dist >= INFINITY) {\n\t  \n        if( ( uv.y + cos( iTime ) ) > 0.0 && abs( uv.x ) > 1.0 ) {  \n            fragColor.xyz = vec3( 0.2 );\n\t    }\n            \n    }\n    \n\tfragColor.w = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}