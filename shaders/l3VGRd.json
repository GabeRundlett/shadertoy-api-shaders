{
    "Shader": {
        "info": {
            "date": "1721864687",
            "description": "Trying to recreate this random sunset clock I found on amazon, I thought it looked nice: https://www.amazon.com/dp/B0CL9LTDHM\nThis is not an advertisement for this clock, I just thought it looked cool...\nSkipped the numbers for now, may do the reflection",
            "flags": 0,
            "hasliked": 0,
            "id": "l3VGRd",
            "likes": 3,
            "name": "Amazon Sunset Clock",
            "published": 3,
            "tags": [
                "sunset",
                "clock",
                "approximation",
                "replica",
                "shaderclockdenodev"
            ],
            "usePreview": 0,
            "username": "berelium",
            "viewed": 40
        },
        "renderpass": [
            {
                "code": "// Use fullscreen for the best effect. Some issues with aliasing at lower resolutions.\n\n#define   PI 3.1415926\n#define  TAU 6.2831852\n#define DEG_TO_RAD 0.01745329251\n#define bias 2.0 / iResolution.y\n\n\nconst float clockR = 0.5;\nconst vec3 sun = vec3(0.961,0.733,0.337);\n//#define INVERT\n\n//#define IMAGE_TIME\nconst float IMAGE_H = 0.46;\nconst float IMAGE_M = 44.3;\nconst float IMAGE_S = 19.5;\n\n// === Borrowed from @iq ===\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\nfloat sdBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\nvec3 line( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdLine( p, a, b );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.rgb, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\nvec3 box( in vec3 buf, in vec2 a, in vec2 b, in vec2 p, in vec2 w, in vec4 col )\n{\n   float f = sdBox( p, a, b, 0. );\n   float g = fwidth(f)*w.y;\n   return mix( buf, col.rgb, col.w*(1.0-smoothstep(w.x-g, w.x+g, f)) );\n}\n// =========================\n\nvec3 circle( in vec2 p, in float r, in vec3 col ) {\n    return smoothstep(r, r-bias, length(p)) * col;\n}\nvec3 circle( in vec3 buf, in vec2 p, in float r, in vec4 col ) { // Adapted circle function based on inigo's (for fun)\n    return mix(buf, col.rgb, col.a*smoothstep(r, r-bias, length(p)));\n}\n\n\nvec3 face( in vec2 uv, in float r ) {\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    \n    col = circle(col, uv, r, vec4(sun, 1.0)); // Initial face\n    col.gb -= (0.95 - d - clockR) * 1.25; // gradient\n    \n    if(d > clockR) col *= 0.0;\n    return col;\n}\n\nconst float tick_p = 0.075;\nvec3 ticks( in vec2 uv, in float r ) {\n    vec3 col = vec3(0.0);\n    float d = length(uv);\n    float a = atan(uv.y, uv.x) + PI;\n    float pos = tick_p, thick = 0.075;\n    \n    float f = abs(2.0*fract(0.5+a*60.0/6.2831)-1.0);\n\tfloat g = 1.0-smoothstep( 0.0, 0.1, abs(2.0*fract(0.5+a*12.0/6.2831)-1.0) );\n\tfloat w = fwidth(f);\n\tf = 1.0 - smoothstep( thick*g+thick/2.-w, thick*g+thick/2.+w, f );\n\tf *= smoothstep( r, r+bias, d+pos ) - smoothstep( r, r+bias, d+bias+pos*0.775 );\n\tcol = mix( col, vec3(1.0), f );\n    \n    return col;\n}\n\nvec3 dots( in vec2 uv, in float r ) {\n    vec3 col = vec3(0.0);\n    \n    vec2 p = vec2(0.0);\n    float a = 0.0, dr = 0.01;\n    // 12 dots, one for each hour\n    for(float i = 0.0; i < 12.0; i++) {\n        a = i * (TAU / 12.0);\n        p = vec2(cos(a), sin(a)) * 0.435;\n        p = vec2(cos(a), sin(a)) * (r+dr-tick_p);\n        col += circle(uv-p, dr, vec3(1.0));\n    }\n    \n    return col;\n}\n\nvec3 hands( in vec2 uv, bool shade ) {\n    vec4 color = shade ? vec4(1.0,1.0,1.0, 0.2) : vec4(1.0);\n    vec3 col = vec3(0.0);\n    vec2 dir = vec2(0.0), center = vec2(0.0);\n    \n    // Calculate current time from @iq (modified for smooth time)\n    float ms = fract(iDate.w);\n    float s = mod(floor(iDate.w), 60.0) + ms;\n    float m = mod(floor(iDate.w / 60.0), 60.0) + s / 60.0;\n    float h = mod(floor(iDate.w / 3600.0), 24.0) + m / 60.0;\n#ifdef IMAGE_TIME\n    h = IMAGE_H;  \n    m = IMAGE_M;\n    s = IMAGE_S;\n#endif\n\n    \n    // Render the hands\n    float thick = 0.006;\n    float blur = shade ? 5.0 : 1.5;\n    \n    dir = vec2( sin(TAU*s/60.0), cos(TAU*s/60.0) ) * clockR; // second hand\n    col = box( col, -dir*0.115, dir * 0.75, uv, vec2(thick/8.,blur), color );\n    col = box( col, -dir*0.30, -dir *0.115, uv, vec2(thick*.8,blur), color );\n    \n    \n    dir = vec2( sin(TAU*m/60.0), cos(TAU*m/60.0) ) * clockR; // minute hand\n    col = box( col, -dir*0.15, dir * 0.75, uv, vec2(thick,blur), color );\n    \n    dir = vec2( sin(TAU*h/12.0), cos(TAU*h/12.0) ) * clockR; // hour hand\n    col = box( col, -dir*0.15, dir * 0.50, uv, vec2(thick,blur), color );\n    \n    col = box( col, center, center+bias/50., uv, vec2(0.025,blur), color ); // center dot\n    col = box( col, center, center+bias/50., uv, vec2(0.0175,blur), color ); // mini dot\n    \n    return shade ? col : col * 2.0;\n}\n\n// ===================================================\n\nvec3 clock( in vec2 uv, in vec2 shadowDir ) {\n    vec3 clk = vec3(0.0);\n\n    clk += face(uv, clockR);\n#ifdef INVERT\n    clk += hands(uv+shadowDir, true);\n#else\n    clk -= hands(uv+shadowDir, true);\n#endif\n    clk += ticks(uv, clockR);\n    clk += dots(uv, clockR);\n    clk += hands(uv, false);\n    \n    return clk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    // TODO: Find new way to calculate shade because it would be better for hands to cast shadows on eachother...\n    // TODO: Add fake reflection like in the photo?\n    // TODO: Some simple numbers\n    \n    // Calculate shadow direction\n    float  lightDist = 0.03;\n    float lightAngle = 25.0; // light angle in degrees\n    vec2   shadowDir = vec2(sin(lightAngle*DEG_TO_RAD), cos(lightAngle*DEG_TO_RAD)) * lightDist;\n    \n    color += clock(uv, shadowDir);\n    \n#ifdef INVERT\n    color = 1.-color;\n#endif\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n/*\nvec3 handShade( in vec2 uv ) {\n    vec3 col = vec3(0.0);\n    vec2 dir = vec2(0.0), center = vec2(0.0);\n    \n    // Calculate current time from @iq (modified for smooth time)\n    float ms = fract(iDate.w);\n    float s = mod(floor(iDate.w), 60.0) + ms;\n    float m = mod(floor(iDate.w / 60.0), 60.0) + s / 60.0;\n    float h = mod(floor(iDate.w / 3600.0), 24.0) + m / 60.0;\n#ifdef IMAGE_TIME  \n    h = IMAGE_H;  \n    m = IMAGE_M;\n    s = IMAGE_S;\n#endif\n\n\n    // Calculate shadow direction\n    float lightDist = 0.03;\n    float lightAngle = 25.; // light angle in degrees\n    \n    vec2 shadowDir = vec2(sin(lightAngle*DEG_TO_RAD), cos(lightAngle*DEG_TO_RAD)) * lightDist;\n    uv += shadowDir; // shift UV space by shadow direction\n    \n    \n    // Initialize thick and blur for minute/hour hands\n    float thick = 0.006;\n    float blur = 5.;\n    vec4 shade = vec4(1.,1.,1., 0.2);\n    \n    \n    // Render the shadows\n    dir = vec2( sin(TAU*m/60.0), cos(TAU*m/60.0) ) * 0.5; // minute hand\n    col = box( col, -dir*0.15, dir*0.75, uv, vec2(thick,blur), shade );\n    \n    \n    dir = vec2( sin(TAU*h/12.0), cos(TAU*h/12.0) ) * 0.5; // hour hand\n    //col = box( col, -dir*0.15, dir*0.6, uv, vec2(thick,blur), shade );\n    \n    // center dot\n    col = box( col, center, center+bias, uv, vec2(0.025,blur), shade );\n    \n    return col;\n}\n\nvec3 hands( in vec2 uv ) {\n    vec3 col = vec3(0.0);\n    vec2 dir = vec2(0.0), center = vec2(0.0);\n    \n    // Calculate current time from @iq (modified for smooth time)\n    float ms = fract(iDate.w);\n    float s = mod(floor(iDate.w), 60.0) + ms;\n    float m = mod(floor(iDate.w / 60.0), 60.0) + s / 60.0;\n    float h = mod(floor(iDate.w / 3600.0), 24.0) + m / 60.0;\n#ifdef IMAGE_TIME\n    h = IMAGE_H;  \n    m = IMAGE_M;\n    s = IMAGE_S;\n#endif\n\n    // Initialize thick and blur for minute/hour hands\n    float thick = 0.006;\n    float blur = 1.5;\n    \n    \n    // Render the hands\n    dir = vec2( sin(TAU*s/60.0), cos(TAU*s/60.0) ) * 0.5; // second hand\n    //col = box( col, -dir*0.15, dir * 0.75, uv, vec2(thick,blur), vec4(1.0) );\n    \n    dir = vec2( sin(TAU*m/60.0), cos(TAU*m/60.0) ) * 0.5; // minute hand\n    col = box( col, -dir*0.15, dir * 0.75, uv, vec2(thick,blur), vec4(1.0) );\n    \n    dir = vec2( sin(TAU*h/12.0), cos(TAU*h/12.0) ) * 0.5; // hour hand\n    col = box( col, -dir*0.15, dir*0.5, uv, vec2(thick,blur), vec4(1.0) );\n    \n    // center dot\n    col = circle(col, uv, 0.025, vec4(1.0));\n    \n    return col * 2.0;\n}\n*/",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}