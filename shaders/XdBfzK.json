{
    "Shader": {
        "info": {
            "date": "1502281128",
            "description": "It converges very slowly. random generator is crap, too.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdBfzK",
            "likes": 9,
            "name": "pt-6: volume caustics",
            "published": 3,
            "tags": [
                "raymarching",
                "volume",
                "light",
                "pathtrace",
                "caustics",
                "scattering",
                "media",
                "pathmarch",
                "beams",
                "participating"
            ],
            "usePreview": 0,
            "username": "wuerzig",
            "viewed": 1347
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 col = texture(iChannel0, uv).xyz;\n\n   \tcol /= float(iFrame);\n\n    \n\tcol = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define EPSILON 0.001\n#define BOUNCES 8\n#define BOUNCES_F 8.0\n\n#define SIGMA_S \t\t0.1\t// foggyness\n#define AIR_ROUGHNESS\t0.7 // chance of backscattering\n\n// stolen from https://thebookofshaders.com/12/?lan=de\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat time;\n\nfloat seed = 0.;\nfloat rand() { seed += 0.237;return fract(sin(seed)*43758.5453123); }\n\nfloat hash( const float n ) {\n\treturn fract(sin(n)*43758.54554213);\n}\n\nvec2 random2f(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdDisplace(vec3 p) {\n    return 0.3*sin(20.0*p.x)+0.3*sin(10.0*p.y)+0.3*sin(10.0+p.z);\n}\n\nfloat sdPlaneZ(vec3 p) {\n\treturn abs(p.z);\n}\n\nfloat sdPlaneY(vec3 p) {\n\treturn abs(p.y);\n}\n\nfloat sdPlaneX(vec3 p) {\n\treturn abs(p.x);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdWobblySphere(vec3 p, float s) {\n    return sdSphere(p,s)+sdDisplace(p)*0.1;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n#define MAT_NOTHING -1\n#define MAT_CHECKER 0\n#define MAT_DIFF 1\n#define MAT_SPEC 2\n#define MAT_GLASS 3\n#define MAT_SCATTER 10\n\nstruct Material {\n\tvec3 col;\n    vec3 emm;\n    int type;\t\t\t// 0..CHECKERBOARD 1..DIFF 2..SPEC\n};\n\nstruct dfObject {\n    float d; // distance\n    Material mat; // material\n};\n    \nstruct marchRes {\n\tvec3 p;\n    Material mat;\n    float dist;\n};\n        \n\ndfObject dfUnion(dfObject d1, dfObject d2) {\n    if (d1.d < d2.d) {\n        return d1;\n    } else {\n        return d2;\n    }\n}\n\n// stolen from https://www.shadertoy.com/view/lsX3DH\nvec2 rv2;\nvec2 rv4;\nvec2 rv6;\nvec3 cosWeightedRandomHemisphereDirection2(const vec3 n) {\n\t\n    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));\n\tvec3  vv = cross(uu, n);\t\n    \n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831 * rv2.x); \n\tfloat ry = ra*sin(6.2831 * rv2.x);\n\tfloat rz = sqrt(1.0 - rv2.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\n    return normalize(rr);\n}\n\nvec3 cosWeightedRandomHemisphereDirection3(const vec3 n) {\n\t\n    rv2.x = rand();\n    rv2.y = rand();\n    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));\n\tvec3  vv = cross(uu, n);\t\n    \n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831 * rv2.x); \n\tfloat ry = ra*sin(6.2831 * rv2.x);\n\tfloat rz = sqrt(1.0 - rv2.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\n    return normalize(rr);\n}\n\nvec3 randomDirection() {\n\tvec3 res = vec3(-0.5 + rand(), -0.5 + rand(), -0.5 + rand());\n    \n    res = normalize(res);\n    return res;\n}\n\nvec3 randomHemi(vec3 normal) {\n\tvec3 guess = randomDirection();\n    float negate = step(0., dot(normal, guess))*2.-1.;\n    return guess * negate;\n}\n\n// ================ CHANGE SCENE HERE\ndfObject map(in vec3 p) {\n    dfObject res;\n    // bottom\n    res = dfObject(\n                    sdPlaneY(p), \n                    Material(vec3(0.1, 0.04, 0.02), vec3(0.), MAT_DIFF/*MAT_CHECKER*/)\n                );\n\t// shiny sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(1.55, 0.7, 0.2), 0.7),\n                        Material(vec3(1.0), vec3(0.), MAT_SPEC)\n                    )\n                  );\n    // glass sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(-0.7, 1.9, 0.0), 0.6),\n                        Material(vec3(0.9, 0.9, 0.9), vec3(0.), MAT_GLASS)\n                    )\n                  );\n    \n    // linksrechts, hÃ¶he, tiefe\n    // cube\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdBox(p - vec3(0.5, 1.3, 0.8), vec3(0.4)),\n                        Material(vec3(0.9, 0.7, 0.3), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // cube\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdBox(p - vec3(-0.5, 1.3, 1.1), vec3(0.4)),\n                        Material(vec3(0.3, 0.7, 0.9), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // light source sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(0.0, 4.5, 0.4), 0.45),\n                        Material(vec3(1.0, 1.0, 1.0), vec3(1500.), MAT_DIFF)\n                    )\n                  );  \n    // right wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(-10., 0., 0.)),\n                        Material(vec3(0.0, 0.0, 0.9), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // left wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(10., 0., 0.)),\n                        Material(vec3(0.9, 0.0, 0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // top wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneY(p - vec3(0.0, 10.0, 0.0)),\n                        Material(vec3(0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // back wall\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, 10.0)),\n                        Material(vec3(0.0, 0.0, 0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // back wall behind cam\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, -3.0)),\n                        Material(vec3(0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    return res;\n}\n\nfloat scatterPDF(float dist) {\n\t//return SIGMA_S * exp(dist); \n    return SIGMA_S * sqrt(dist);\n}\n\n\nmarchRes march(in vec3 rayStart, in vec3 rayDir) {\n    \n    // first step\n    float t = 100.0*EPSILON;//0.05;\n    float stepsize = 0.0;\n    \n    Material obj = Material(vec3(0.), vec3(0.), MAT_NOTHING);\n    \n    vec3 p;\n    \n    \n    for (int i = 0; i < 128; i++) {\n        // map on Distance Field\n        p = rayStart + t*rayDir;\n        dfObject res = map(p);\n        // hit\n        if (abs(res.d) < EPSILON)\n        \tbreak;\n       \n\n        stepsize = abs(res.d)*1.0;\n        t += stepsize;\n        obj = res.mat;\n    }\n    return marchRes(p, obj, t);\n    \n}\n\n// Stolen from https://iquilezles.org\n// Calculate Normal in a Distance Field\nvec3 dfNormal( in vec3 p ) {\n\tvec3 eps = vec3(0.0005, 0.0, 0.0);\n\tvec3 res = vec3(\n\t    map(p+eps.xyy).d - map(p-eps.xyy).d,\n\t    map(p+eps.yxy).d - map(p-eps.yxy).d,\n\t    map(p+eps.yyx).d - map(p-eps.yyx).d);\n\treturn normalize(res);\n}\n\n// stolen from https://www.shadertoy.com/view/4tKSWW\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n    float dt = dot(start, end), theta = acos(dt)*percent;\n    return start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\n\nmat3 makeCam( in vec3 origin, in vec3 target) {\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 lookVec = normalize(target-origin);\n\tvec3 right = normalize(cross(lookVec, worldUp));\n\tvec3 camUp = normalize(cross(right, lookVec));\n    return mat3(right, camUp, lookVec);\n}\n\nvec3 getObjectColor(in Material obj, in vec3 p) {\n    if( obj.type == MAT_CHECKER ) {\n\t\t// checkboard pattern\n        float f = mod( floor(p.z) + floor(p.x), 2.0);\n        vec3 col = 0.1+ 0.1 * f * vec3(1.0);\n        return col;\n    } \n    return obj.col;\n}\n\n// ported from http://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0;\n    } \n    else { \n        float cost = sqrt(max(0.0, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // 0...fragCoord...iResolution.xy\n    // Texture Sampler 0...uv...1\n    vec3 rayStart;\n    vec3 rayDirection;\n    vec3 camTarget;\n    vec2 point;\n\n    float j_float;\n    \n    // we start from outside to inside\n    int refrDir = 0; \n    \n    // have we already scattered along this path?\n    int scattered = 0;\n    \n    vec3 totalEnergy = vec3(0.);\n    vec3 totalColor = vec3(1.);\n    vec3 col, emm;\n    \n    time = iTime + 5.;\n    float time2 = time;\n    \n   \t// change camera perspective here (rotates)\n    time2 = 6.65; // 6.65\n  \n    point = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    seed = time*0.237*((point.x + iResolution.x*point.y)) * 1.51269341231;\n\n\tcamTarget = vec3(0.0, 1.0, 0.0);\n    {\n        rv2 = random2f(vec2(time + seed));\n        vec2 point2 = point + vec2(rand(), rand())/*rv2*//(1.5*iResolution.xy);\n        \n    \trayStart = vec3(-0.5 + 2.5*cos(-0.2*time2), 0.9, 0.0 + 2.5*sin(-0.2*time2));\n    \tmat3 cameraMatrix = makeCam(rayStart, camTarget);\n\n        rayDirection = cameraMatrix * normalize(vec3(point2.xy,2.0 ));\n\t\trayDirection = normalize(rayDirection);\n        \n        for (int j=0;j<BOUNCES;j++) {\n            \n            \n            j_float = float(j);\n\n            rv2 = random2f( vec2((rv2.x*2.4543263+rv2.y)*(iTime+1.)+.23 ));\n            \n            marchRes res = march(rayStart, rayDirection);\n            //float t = res.d;\n            Material obj = res.mat;\n            \n            vec3 intersection = res.p;\n            vec3 normal = dfNormal(intersection);\n        \n        \tif (obj.type >= 0) {\n            \t// we hit something, awesome!\n\t\t\t\tcol = getObjectColor(obj, intersection);\n\t\t\t\temm = obj.emm;\n\n               \n                \n                \n                vec2 scatterRand = random2f(vec2(rayDirection.xy)+float(iFrame)+iTime);\n                \n                if (\n                    (refrDir == 0) && \t\t\t\t\t\t// dont scatter inside glass\n                    (scatterPDF(res.dist)>scatterRand.x)\t// did it scatter?\n                ) {\n                \t// calculate random distance along ray\n                    float scatterDist = scatterRand.y * res.dist;\n\t\t\t\t\trayStart = rayStart + scatterDist * rayDirection;\n                    \n                    vec3 newdir = randomDirection();\n                    rayDirection = slerp(rayDirection, newdir, AIR_ROUGHNESS);\n                    \n                    continue;\n                 \t   \n                }\n\n                if (obj.type == MAT_GLASS) {\n\n                    float eps = 1.4;\n\n                    // normal used for refraction calculation\n                    vec3 refrNormal = normal;\n\n                    // from outside to inside\n                    if (refrDir == 0)\n                        eps = 1.0/eps;\n\n\n                    // if from inside to outside, flip distance field normal\n                    if (refrDir == 1)\n                        refrNormal = -normal;\n\n                    float fres = fresnel(rayDirection, refrNormal, 1.0/eps);\n                    if (rand() < fres) {\n                        // total reflection\n                        rayDirection = reflect(rayDirection, refrNormal);\n                        totalEnergy += totalColor * emm;\n                        totalColor *= col;\n                    } else {\n                        // refract\n                        vec3 refractResult = refract(normalize(rayDirection), normalize(refrNormal), eps);\n                        if (length(refractResult) < EPSILON) {\n                            // total inner reflection\n                            // we should not hit this branch because\n                            // fresnel already takes care of that\n                        } else {\n                            // do we go out or in?\n                            rayDirection = refractResult;\n                            refrDir = 1-refrDir;\n                        }\n                        rayStart = intersection + EPSILON*rayDirection;\n                    } // END IF FRESNEL\n\n\t\t\t\t\tcontinue;\n                    \n                // end IF MAT_GLASS\n                }\n\n\n               \tif (obj.type == MAT_SPEC) {\n                    rayDirection = reflect(rayDirection, normal);\n                    totalEnergy += totalColor * emm;\n                    totalColor *= col;\n               \t} else {\n                    rayDirection = cosWeightedRandomHemisphereDirection2(normal);\n                    totalEnergy += totalColor * emm;// + totalColor * col * e;\n                    totalColor *= col;\n                }\n\n                // get off the surface\n                rayStart = intersection + EPSILON*rayDirection;\n\n                // if the material emits light we stop bouncing around\n                //if (length(emm)>0.)\n                //   break;\n\n            // end IF obj.type==0\n            }\n            \n\t\t}\n        // if were still inside a refractive material\n        // theres energy loss because we didnt connect to a light source\n        \n    }\n    \n    vec3 pxl = totalEnergy / (j_float + 1.0);\n\n    fragColor = vec4(clamp(pxl, 0.0, 1.0), 1.0);\n    \n   \tcol = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n   \tif( iFrame==0 ) col = vec3(0.0);\n   \tcol += pxl;    \n   \tfragColor = vec4( col, 1.0 );\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}