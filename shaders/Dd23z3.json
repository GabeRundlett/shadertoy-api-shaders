{
    "Shader": {
        "info": {
            "date": "1668497929",
            "description": "Further experiments with slime molds. I wanted to know what they would look like rendered as a height map, and I think this shader answers the question: they look cool!\n*mouse to tilt camera*\n*space to reset*\n*left and right arrow keys to switch demos*",
            "flags": 48,
            "hasliked": 0,
            "id": "Dd23z3",
            "likes": 24,
            "name": "Slime Mold Terrain",
            "published": 3,
            "tags": [
                "terrain",
                "antialiasing",
                "slime",
                "mold",
                "slimemold"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 481
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This is essentially a mash-up of two of my previous shaders. The rendering method is\n// based on the terrain renderer in:\n//\n//   Dynamic Editable Terrain   https://www.shadertoy.com/view/NlyBWm\n//\n// Whereas the particle sim and demo framework come from:\n//\n//   Slime Mode Variations      https://www.shadertoy.com/view/Ddj3RG\n// \n// There are two expensive rendering options at the top of the Common tab, ADAPTIVE_AA\n// and SHADOW. Turn those on for higher quality at the expense of FPS. My graphics card\n// can't really do either at \"normal\" resolutions...I'd love to hear if anyone is able\n// to get 30+ FPS with either of those turned on. The shadows are definitely worth\n// trying out, but on my card the AA is way too costly.\n//\n// One interesting thing about the adaptive AA...it interacts badly with the analytic\n// AA for the checkerboard floor pattern, so I had to turn it off. I had hoped it would\n// just skip over those pixels but I guess there is too much contrast. To see the effect,\n// hack the code in pixelInternal with the comment \"Don't use analytic AA and adaptive AA\n// at the same time...\" and then use the arrow keys to switch to one of the checkered demos.\n//\n// The slime mold sim is roughly the same as previous, with the addition of a few more per-\n// demo, sometimes per-color tunable parameters. The particle sim now runs within a circle,\n// instead of over the entire frame buffer, to try to at least allow for the possibility\n// of rotational symmetry.\n//\n// All the rest of the changes have been to the rendering. The mixing of the colors was\n// more difficult than I expected, because I wanted the colors to come through brightly,\n// but to also blend smoothly at their edges.\n//\n// Buffer A runs the slime mode simulation\n// Buffer B performs voronoi neighbor computation\n// Buffer C renders the particles into the terrain texture\n// Buffer D renders the final image once for adaptive AA, if enabled\n//\n// --------------------------------------------------------------------------------------------\n\nvec4 render(vec2 u)\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse.xy / iResolution.xy, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(u, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    return pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n}\n\n// From FabriceNeyret2's easy adaptive sampling series\n// https://www.shadertoy.com/view/WlSBDt\n// https://www.shadertoy.com/view/Wt2fzV\n\n// --- my adaptive antialiasing: oversample only if neighborhood disagree\n\n#define hash12(p)  fract(sin( 99.*pass + float(p) * vec2(12.9898, 78.233) ) * 43758.5453)\nconst float pass = 1.;\n#define N 5\nconst float n = float(N);\n\nvec4 AArender( vec2 u )\n{ \n    vec2 un = u / iResolution.xy;\n    vec4  O =  textureLod(iChannel2, un, 0.), C;                // result of previous pass\n    \n    if ( length( textureLod(iChannel2, un, 3.).rgb - textureLod(iChannel2, un, 0.).rgb ) > 0.05 ) // neighborhood does not agree\n    { // neighborhood does not agree\n        C = vec4(0);\n        float w = 1., wt = 0.;           // weigth\n        for (int k=0; k<N*N; k++) // --- oversampling\n        {      \n          //vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. ) / n;     // subpixel : grid\n          //vec2 D = hash12(k) - .5;                            // subpixel : rand\n            vec2 D = ( vec2(k%N,k/N) - float(N-1)/2. + hash12(k)-.5 ) / n; // stratified\n            D *= 1.5; w = exp(-4.*dot(D,D)); wt += w;           // gaussian kernel filter\n            C += render(  u +  D ) * w;\n        }\n        C *= n*n / wt;                   // normalize by pass weigth (for kernel filter )\n        O *= n*n*(pass-1.);              // restore weigth\n        O += C;                          // add new contribs\n        O /= n*n *pass;                  // normalize by multipass weigth\n        O.a = pass;                      // 1: mark filtered aread\n    }\n    //else                                 // LOD#0 is ok\n    \n    return O;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n#if ADAPTIVE_AA\n    fragColor = AArender(fragCoord);\n#else\n    fragColor = render(fragCoord);\n#endif\n\n#if 0 // Debug terrain texture\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0) * 10.;\n#endif\n\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes particle positions and velocities\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;    \n\n    fxParticle data = fxGetParticle(id);\n    \n    if (iFrame == 0 || state.x < 0. || id >= g_MaxParticles)\n    {\n        data.pos = data.vel = vec2(0);\n    }\n    else\n    {\n        // probe the density texture ahead of us, to the left and to the right\n        vec2 p = data.pos * .5 * vec2(iResolution.y / iResolution.x, 1) + .5;\n        vec4 fwdC = texture(iChannel2, p + data.vel * 2.);\n        int type = id % g_Demo.colors;\n        vec2 leftV = data.vel * rot2(g_Demo.turn[type]);\n        vec4 leftC = texture(iChannel2, p + leftV * 3.);\n        vec2 rightV = data.vel * rot2(-g_Demo.turn[type]);\n        vec4 rightC = texture(iChannel2, p + rightV * 2.);\n        \n        vec4 color = colorFromId(id);\n        color = color * 2. - 1.;\n        \n        data.vel *= rot2(g_Demo.spin[type]);\n                \n        float fwd = dot(color, fwdC);\n        float left = dot(color, leftC);\n        float right = dot(color, rightC);\n\n        // turn towards our color and away from other colors\n        if (fwd < left || fwd < right)\n        {\n            if (left < right)\n            {\n                data.vel = mix(data.vel, rightV, 0.3*right / (fwd + right));\n            }\n            else\n            {\n                data.vel = mix(data.vel, leftV, 0.3*left / (fwd + left));\n            }\n        }\n\n        // always move at g_ParticleSpeed\n        if (length(data.vel) > 1e-10)\n        {\n            data.vel = normalize(data.vel) * g_Demo.speed;\n        }\n        else\n        {\n            vec3 h = hash3(uvec3(iFragCoord.x*iFragCoord.y, iFragCoord.y, iFrame*iFragCoord.x));\n            data.vel = g_Demo.speed*normalize((vec2(h.x, h.y) - .5));\n        }\n\n        // integrate position\n        data.pos = data.pos + data.vel;\n\n        // boundary\n        float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n        vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n        if (distToScene < 0.001)\n        {\n            data.pos = clamp(data.pos, vec2(-iResolution.x / iResolution.y, -1.0), vec2(iResolution.x / iResolution.y, 1.0));\n            float dp = dot(data.vel, distNormal);\n            if (dp < 0.)\n            {\n                data.vel = reflect(data.vel, distNormal);\n            }\n        }\n\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Turn these on only if you have a beefy graphics card\n#define ADAPTIVE_AA 0\n#define SHADOW 1\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nconst float PI = 3.141592653589793;\n\nmat2 rot2(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\nvoid fxCalcCamera(in float time, in vec2 mouse, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0,-.02,0);\n    vec3 delta = vec3(.2,sin(time*.1)*0.02 + 0.06 + mouse.y * 0.1,.2) * (.8 - mouse.y * .4);\n    delta.xz *= rot2(time * .05 + mouse.x * 4.);\n    cameraPos = cameraLookAt + delta;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat fxLinePointDist2(vec2 a, vec2 b, vec2 p)\n{\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);// proj coord on line\n    return length2(p - b * h); // squared dist to segment\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n#if 1\n    return 1. - length(point);\n#else\n    float minDist = 1e30;\n    minDist = min(minDist, point.x + resolution.x / resolution.y);\n    minDist = min(minDist, resolution.x / resolution.y - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n#endif\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define POS_VEL 0\n#define NUM_PARTICLE_DATA_TYPES 1\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData0.xy;\n    particle.vel = particleData0.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SPACE 32\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nstruct Demo\n{\n    float used;      // what pct of the total particle buffer should be used\n    float size;      // how big should the particle be\n    float speed;     // how fast should the particles travel\n    vec4 turn;       // how fast can the particles turn to follow a trail\n    vec4 spin;       // how fast do the particles turn on average (signed)\n    int colors;      // how many colors does this demo use\n    vec4 colorR;     // color for red particles (specular in alpha)\n    vec4 colorG;     // color for green particles\n    vec4 colorB;     // color for blue particles\n    vec4 colorA;     // color for alpha particles \n    vec4 background; // background color\n    float checker;   // should the floor be checkered\n};\n\nconst int NUM_DEMOS = 12;\nconst Demo DEMOS[NUM_DEMOS] = Demo[](\n\n    Demo(.9,   .001,  .006, vec4(.6),          vec4(.09),             2, vec4(.6,.05,.1,.2), vec4(.8,.1,.1,.2),   vec4(0),             vec4(0),            vec4(.8,.6,.4,0),    0.), // sand dunes\n    Demo(.05,  .0005, .001, vec4(.9),          vec4(0.),              4, vec4(0,0,0,1),      vec4(.1),            vec4(.2),            vec4(.3),           vec4(1,.3,.1,0),     0.), // lava\n    Demo(.05,  .0002, .001, vec4(.3,.3,.3,.0), vec4(-.01,.01,.02,1.), 4, vec4(1),            vec4(.9),            vec4(.8),            vec4(.8,.4,.2,0),   vec4(.4,.4,1,1),     0.), // islands\n    Demo(.9,   .0003, .001, vec4(.7),          vec4(0.),              1, vec4(1,0,1,1),      vec4(1,0,1,0),       vec4(1,0,1,0),       vec4(1,0,1,0),      vec4(.4,1,.4,1),     1.), // toxic snakes\n    Demo(.2,   .0004, .003, vec4(.3),          vec4(0.),              1, vec4(.2,.2,.2,1),   vec4(.2),            vec4(.2),            vec4(.2),           vec4(.9,.9,.8,0),    0.), // ink\n    Demo(.01,  .001,  .002, vec4(.3,.1,0,0),   vec4(0.),              2, vec4(.5,.2,.2,0),   vec4(.1,.5,.3,0),    vec4(.8),            vec4(.7),           vec4(.6,.9,.6,0),    0.), // redwood\n    Demo(.05,  .0002, .002, vec4(.3),          vec4(.05),             1, vec4(0,0,1,1),      vec4(0,0,1,0),       vec4(0,0,1,0),       vec4(0,0,1,0),      vec4(1,0,0,0),       0.), // red blue\n    Demo(.05,  .002,  .002, vec4(1,.7,.5,1),   vec4(.1,-.1,0,0),      4, vec4(1,1,0,0),      vec4(1, .7, 0,0),    vec4(1,.5,0,0),      vec4(.2,.4,.2,0),   vec4(.2),            0.), // red yellow\n    Demo(.5,   .0004, .004, vec4(1.5),         vec4(-.03),            2, vec4(0,0,1,1),      vec4(1,0,0,1),       vec4(1,0,0,0),       vec4(0,0,1,0),      vec4(1),             1.), // red blue\n    Demo(.1,   .0002, .002, vec4(1),           vec4(0,0,1,0),         3, vec4(.1,.5,.1,.3),  vec4(.2,.6,.7,1),    vec4(.4),            vec4(.4),           vec4(.5,.4,.1,0),    0.), // rock garden\n    Demo(.6,   .0001, .002, vec4(1),           vec4(0),               4, vec4(.22,.4,.4,0),  vec4(.58,.48,.32,0), vec4(.85,.85,.82,0), vec4(.2,.22,.24,0), vec4(.85,.77,.67,0), 0.), // pollock\n    Demo(.01,  .001,  .001, vec4(.3),          vec4(0),               1, vec4(.5,1.4,0,1),   vec4(0),             vec4(0),             vec4(0),            vec4(0),             0.)  // glow 'n the dark worms\n);\n\nDemo g_Demo;\nint g_MaxParticles = 10000; \n\nvoid initGlobals(vec3 res, vec4 state)\n{\n    Demo demo = DEMOS[int(state.w) % NUM_DEMOS];\n    Demo nextDemo = DEMOS[int(state.w + 1.) % NUM_DEMOS];\n    \n    float used = fract(state.w) > .9 ? min(demo.used, nextDemo.used) : demo.used;\n    g_MaxParticles = int(res.x * res.y * used) / NUM_PARTICLE_DATA_TYPES;\n    \n    float transition = smoothstep(.9, 1., fract(state.w));\n    g_Demo.colors = demo.colors;\n    g_Demo.size = mix(demo.size, nextDemo.size, transition)*.02;\n    g_Demo.speed = mix(demo.speed, nextDemo.speed, transition);\n    g_Demo.turn = mix(demo.turn, nextDemo.turn, transition);\n    g_Demo.spin = mix(demo.spin, nextDemo.spin, transition);\n    g_Demo.colorR = mix(demo.colorR, nextDemo.colorR, transition);\n    g_Demo.colorG = mix(demo.colorG, nextDemo.colorG, transition);\n    g_Demo.colorB = mix(demo.colorB, nextDemo.colorB, transition);\n    g_Demo.colorA = mix(demo.colorA, nextDemo.colorA, transition);\n    g_Demo.background = mix(demo.background, nextDemo.background, transition);\n    g_Demo.checker = mix(demo.checker, nextDemo.checker, transition);\n}\n\nvec4 colorFromId(int id)\n{\n    int index = id % g_Demo.colors;\n    \n    vec4 result = vec4(0);\n    result[index] = 1.;\n    \n    return result;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\nconst float MAX_Y = 0.003;\n\nfloat scene(sampler2D sampler, vec3 res, vec3 p)\n{\n    vec4 colors = min(texture(sampler, p.xz * vec2(1, res.x / res.y) + .5) * .012, vec4(MAX_Y));\n    float h = max(max(max(colors.x, colors.y), colors.z), colors.a);\n    float height = p.y - h;\n  \n    float b = sdCylinder(p, vec3(0,0,.25));\n    return max(b, height);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 grad( sampler2D sampler, vec3 res, in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*scene(sampler, res, pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*scene(sampler, res, pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*scene(sampler, res, pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*scene(sampler, res, pos + e.xxx*eps ) );\n}\n\nfloat g_MaxT = 0.4;\nconst float SDF_EPSILON = 0.00005;\nvec3 rayMarch(sampler2D sampler, vec3 res, vec3 pos, vec3 dir, out float t)\n{\n    t = 0.;\n    \n    if (pos.y > MAX_Y) // skip immediately down to the max Y so we don't do unnecessary texture fetches\n    {\n        if (dir.y > 0.) { t = g_MaxT; return vec3(1e6); }\n        t = (MAX_Y - pos.y) / dir.y;\n        pos += dir * t;\n    }\n    \n    float g = 1., s = .5;\n    for (int i = 0; i < 100; ++i)\n    {\n        float d = scene(sampler, res, pos);\n        \n        if (abs(d) < SDF_EPSILON || t > g_MaxT)\n        {\n            break;\n        }\n        \n        if (g != sign(d))\n        {\n            g = -g;\n            //s *= .5;\n        }\n        \n        t += d * s;\n        pos += dir * d * s;\n    }\n \n    return pos;\n}\n\n// From iq's  Filtered checker (triangle, 3D)\n// https://www.shadertoy.com/view/llffWs\n\n// --- analytically triangle-filtered checkerboard ---\nvec3 pri( in vec3 x )\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvec4 pixelInternal(sampler2D sampler, vec3 res, vec3 cameraPos, vec3 cameraFwd, vec3 rayDir, out vec3 hitPos, out vec3 normal)\n{\n    g_MaxT = .10 + length(cameraPos.xz);\n    \n    float t;\n    hitPos = rayMarch(sampler, res, cameraPos, rayDir, t);\n\n    normal = grad(sampler, res, hitPos);\n\n    // Compute color\n    vec4 background = g_Demo.background;\n    float checker = 0.;\n    if (g_Demo.checker > 0.)\n    {\n#if ADAPTIVE_AA // Don't use analytic AA and adaptive AA at the same time...they don't get along\n        vec2 m = mod(hitPos.xz, .02);\n\t\tchecker = float((m.x < .01) ^^ (m.y < .01));\n#else\n\t\tvec3 uvw = hitPos.xzy * 100.;\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec3 ddx_uvw = dFdx( uvw ); \n        vec3 ddy_uvw = dFdy( uvw ); \n        \n\t\t// shading\t\t\n        checker = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n#endif\n    }\n\n    background = 1.5*mix(g_Demo.background, g_Demo.background * checker, g_Demo.checker);\n    vec4 colors = textureLod(sampler, (hitPos.xz * vec2(1, res.x / res.y) + .5), 3.);\n\n    // Pretty much want the max, but we want to blend if the next-biggest color(s) are close\n    float cMax = max(max(max(colors.r, colors.g), colors.b), colors.a);\n    vec4 rdcd = max(vec4(0), colors - cMax + .01); // reduce all weights by the max with small offset\n    vec4 color = (rdcd.r * g_Demo.colorR + // weighted sum of reduced weights\n                  rdcd.g * g_Demo.colorG +\n                  rdcd.b * g_Demo.colorB +\n                  rdcd.a * g_Demo.colorA)\n        / (rdcd.r + rdcd.g + rdcd.b + rdcd.a);\n    \n    color = mix(background, color, smoothstep(0., .02, cMax));\n                         \n    // Apply light and shadow\n    const vec3 LIGHT_DIR = normalize(vec3(1, .2, 1));\n    const float AMBIENT = 0.3;\n\n#if SHADOW\n    float shadowT = g_MaxT;    \n    vec3 offsetPos = hitPos + normal * SDF_EPSILON * 2.;\n    rayMarch(sampler, res, offsetPos, LIGHT_DIR, shadowT);\n    \n    if (shadowT < g_MaxT)\n    {\n        color = color * AMBIENT;\n    }\n    else\n#endif // SHADOW\n    {\n        float dp = max(0., dot(normal, LIGHT_DIR));\n        color = color * (dp * (1. - AMBIENT) + AMBIENT);\n        \n        vec3 reflection = reflect(LIGHT_DIR, normal);\n        dp = dot(cameraFwd, reflection);\n        \n        color.rgb += color.a * pow(abs(dp), 15.0) * vec3(0.5);\n    }\n    \n    // Fade at distance\n    if (t >= g_MaxT*.75)\n    {\n        vec4 sky = g_Demo.background * (.5 - 2. * rayDir.y);\n        color = mix(color, sky, smoothstep(g_MaxT*.75, g_MaxT, t));\n    }\n    \n    return vec4(color.xyz, t);\n}\n\n#define pixel(A, B, C, D, E) pixelInternal(iChannel0, iResolution, A, B, C, D, E)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the nearest particles to each texel for buffer C\n// ---------------------------------------------------------------------------------------\n\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord)\n{\n    if(id==-1) return 1e20;\n    vec2 delta = (fxGetParticleData(id, POS_VEL).xy * vec2(iResolution.y / iResolution.x, 1.0))-fragCoord;\n    return dot(delta, delta);\n}\n\nconst float FRAMES_PER_DEMO = 500.;\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        if (iResolution.x * iResolution.y != abs(state.x) || iFrame == 0 || keyDown(KEY_SPACE))\n        {\n            state = vec4(-iResolution.x * iResolution.y, .5, .5, 0);\n        }\n        else\n        {\n            state.x = abs(state.x);\n\n            state.w += 1. / FRAMES_PER_DEMO;\n            \n            if (keyClick(KEY_LEFT))\n            {\n                state.w = trunc(state.w - 1.);\n            }\n            if (keyClick(KEY_RIGHT))\n            {\n                state.w = trunc(state.w + 1.);\n            }\n        }\n        \n        fragColor = state;\n        return;\n    }\n    \n    if (length((fragCoord - .5*iResolution.xy) / iResolution.y) > 1.)\n    {\n        fragColor = vec4(-1);\n        return;\n    }\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    \n    if (iFrame > 0)\n    {\n        //in this vector the distance to these particles will be stored \n        vec4 dis = vec4(1e6);\n\n        for(int x=-2; x<=2; x++){\n            for(int y=-2; y<=2; y++){\n                ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n                for(int j=0; j<4; j++){\n                    int id = old[j];\n                    float dis2 = distance2Particle(id, screen2world(fragCoord));\n                    insertion_sort( new, dis, id, dis2 );\n                }\n            }\n        }\n\n        int searchIterations = 3;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++){\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n\n            int p = int(h*float(g_MaxParticles));\n            insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n        }\n    }\n    \n    fragColor = vec4(new); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// This is the texture that the particles are rendered into, and that becomes the height\n// map for raymarching.\n// ---------------------------------------------------------------------------------------\n\nvoid renderParticle(in fxParticle p, int id, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    p.pos.x *= iResolution.y / iResolution.x;\n    float dist = fxLinePointDist2(p.pos, p.pos - 1.5 * p.vel, fragCoord);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, g_MaxParticles);\n\n    vec4 color = colorFromId(id) *.003;\n    fragColor += color * max(0.0, g_Demo.size - dist) / g_Demo.size;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n    \n    fragColor = vec4(0);\n  \tvec2 p = (2.*fragCoord - iResolution.xy) / iResolution.xy;\n        \n    // diffuse colors\n    for (int x = -1; x <= 1; ++x)\n    for (int y = -1; y <= 1; ++y)\n    {\n        vec4 n = texelFetch(iChannel2, ivec2(fragCoord) + ivec2(x, y), 0);\n        fragColor += n / (1.09 + 100.*dot(vec2(x, y), vec2(x, y))); // fall off with distance but also fade\n    }\n\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    // draw the particles\n    for(int i = 0; i < 4; i++)\n    {\n        int id = ids[i];\n        if (id < 0 || id >= g_MaxParticles) continue;\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, id, p, fragColor);\n    }\n    \n    fragColor = min(fragColor, max(vec4(MAX_Y * .8 / .012), vec4(MAX_Y * .8 / .012) + (fragColor - vec4(MAX_Y * .8 / .012)) * .7));\n\n    // reset\n    if (iFrame == 0 || state.x < 0.)\n    {\n        fragColor = vec4(0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Pre-render pass for adaptive AA, needed to compute the color gradient of each pixel.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n#if ADAPTIVE_AA\n    vec4 state = texelFetch(iChannel1, ivec2(0), 0);\n    initGlobals(iResolution, state);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(iTime, iMouse.xy / iResolution.xy, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n\tvec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    vec3 hitPos, normal;\n    fragColor = pixel(cameraPos, cameraFwd, rayDir, hitPos, normal);\n#endif // ADAPTIVE_AA\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}