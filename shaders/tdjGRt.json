{
    "Shader": {
        "info": {
            "date": "1549782990",
            "description": "3D Lissajous, drawn as chains of small spheres.\n\n[url]https://mathcurve.com/courbes3d.gb/lissajous3d/lissajous3d.shtml[/url]",
            "flags": 16,
            "hasliked": 0,
            "id": "tdjGRt",
            "likes": 23,
            "name": "3D Lissajous Figures",
            "published": 3,
            "tags": [
                "3d",
                "lissajous"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 763
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 3D Lissajous figures\n//\n// mouse rotates\n// 'c': use cos for z-rotation\n// 'p': phase shift\n// 'r': auto rotation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dophase = false;\nbool docos = false;\n\nconst float PI = 3.14159;\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  int id;\n};\n\nbool intersectSphere(Sphere s, Ray ray, out Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  vec3 q = ray.q-s.p, d = ray.d;\n  // |q + t*d|^2 = r^2\n  float B = dot(q,d);\n  float C = dot(q,q)-r2;\n  float D = B*B - C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float t,t1;\n  if (B >= 0.0) {\n    t = -B-D; t1 = C/t;\n  } else {\n    t1 = -B+D; t = C/t1;\n  }\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return false;\n  // Normal is the radial vector of sphere\n  // We normalize it later\n  hit = Hit(t, q+t*d, s.id);\n  return true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    //p.xy = rotate(p.xy,t*0.123);\n    p.zx = rotate(p.zx,t*0.2);\n  }\n  return p;\n}\n\nint imod(int n, int m) {\n  return n - n/m*m;\n}\n\nfloat P = 3.0;\nfloat Q = 2.0;\nfloat R = 1.0;\nfloat NN = 200.0;\nbool intersectScene(Ray ray, out Hit hit) {\n  float k = 0.5*(1.0+cos(0.2*iTime));\n  hit.t = 1e8;\n  NN = (P+Q+R)*20.0;\n  for (float i = 0.0; i < max(-iTime,NN); i++) {\n    float r = 0.1;\n    float t = i*2.0*PI/NN;\n    t += 0.1*iTime;\n    float phase = 0.0;\n    if (dophase) phase += 0.123*iTime;\n    if (docos) phase += 0.5*PI;\n    vec3 p = vec3(sin(P*t),sin(Q*t),sin(R*t+phase));\n    Sphere s = Sphere(r*r,p,int(i));\n    Hit hits;\n    if (intersectSphere(s,ray,hits) && hits.t < hit.t) {\n      hit = hits;\n    }\n  }\n  return hit.t < 1e8;\n}\n\nvec3 light;\nfloat ambient;\nfloat diffuse;\n\nvec3 hsv2rgb(float h, float s, float v) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec4 solve(Ray r) {\n  Hit hit;\n  if (!intersectScene(r,hit)) {\n    return vec4(0,0,0,1);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(r.d,n) > 0.0) n *= -1.0;\n    vec3 baseColor = hsv2rgb(float(hit.id)/NN,0.5,1.0);\n    vec3 color = vec3(0);\n    color += baseColor.xyz*ambient;\n    color += baseColor*diffuse*max(0.0,dot(light,n));\n    float specular = pow(max(0.0,dot(reflect(light,n),r.d)),10.0);\n    color += 1.0*specular*baseColor;\n    color *= clamp(1.0 - (hit.t-3.0)/5.0,0.0,1.0);\n    return vec4(sqrt(color),1.0);\n  }\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_P = 80;\nconst int CHAR_R = 82;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  docos = !keypress(CHAR_C);\n  dorotate = !keypress(CHAR_R);\n  dophase = keypress(CHAR_P);\n  vec2 uv = fragCoord.xy/iResolution.y;\n  uv.y = 1.0-uv.y;\n  uv *= 5.0;\n  vec2 pq = floor(uv)+1.0;\n  P = pq.x, Q = pq.y;\n  uv = 2.0*fract(uv)-1.0;;\n  vec3 p = vec3(0,0,-4.0);\n  vec3 d = vec3(uv.x, uv.y, 2.0);\n  p = transform(p);\n  d = transform(d);\n  d = normalize(d);\n  light = vec3(0.5,1.0,-1.0);\n  light = transform(light);\n  light = normalize(light);\n  ambient = 0.6;\n  diffuse = 0.2;\n  fragColor = solve(Ray(p,d));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}