{
    "Shader": {
        "info": {
            "date": "1565171446",
            "description": "show emission patterns from multiple mast antennas in 2d.\n\nSPREAD is how far the base frequency scales. i.e 1MHz Spread 400 1-400MHz\n\nhttps://www.radioworld.com/columns-and-views/roots-of-radio/the-development-of-the-directional-am-broadcast-antenna",
            "flags": 8,
            "hasliked": 0,
            "id": "WlXXR7",
            "likes": 3,
            "name": "Antennas AM Antenna Interference",
            "published": 3,
            "tags": [
                "radio"
            ],
            "usePreview": 0,
            "username": "milolouis",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "/*\n2D representation of AM radio interference patterns using\n'real' numbers. Inspired by article on how the super powerful US\nradio operators of the past used phasing to lower the strength of\ntheir signal directionally. It's really a pretty cardiod pattern generator\nwith procedural music that loses its mind after a minute or so.\n\nWilmotte had two base-isolated vertical towers constructed.\nEach was 200 feet high, separated by a quarter wavelength on\na bearing towards Milwaukee. The towers were on opposite\nsides of what is now the Courtney-Campbell Causeway in Clearwater.\nThe power from a new 5 kW Western Electric transmitter was\ndivided at the transmitter building and sent to each tower\nvia open-wire transmission lines suspended from poles.\nThe system was configured so that the two towers could\nbe operated in-phase during the day and 90 degrees out\nof phase at night, creating a cardioid pattern with a\nsharp null towards Milwaukee.\n\nhttps://www.radioworld.com/columns-and-views/roots-of-radio/the-development-of-the-directional-am-broadcast-antenna\n*/\n\n#define PI 3.14159265359\n#define LIGHTSPEED 299792458.00\n#define SCALE 800.\n\n#define SPREAD 10.\n\n#define FREQUENCY 1500000.\n\nfloat amplitude(float source_distance, float source_frequency, float source_phase)\n{\n    float wavelength = LIGHTSPEED / source_frequency;\n    float x = (source_distance / wavelength) / (2.0 * PI);\n\tfloat y = sin(x + source_phase - iTime);\n    return y;\n}\n\nvec3 normalise(float amp1, float amp2)\n{\n\n\treturn vec3((amp1 + amp2 + 2.) / 4.);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord - (iResolution.xy / 2.0);\n    \n    //seperation quarter of wavelength\n    vec2 ant1 = vec2(50.0, 0.0);\n    vec2 ant2 = vec2(-50.0, 0.0);\n    vec2 ant3 = vec2(0.0, 0.0);\n    \n    float f = abs(FREQUENCY * (sin(iTime / 400.) * SPREAD));\n    \n    float dist1 = sqrt(pow(uv.x + ant1.x, 2.0) + pow(uv.y + ant1.y, 2.0)) * SCALE;    \n    float amp1 = amplitude(dist1, f, PI / 2.);\n    \n    float dist2 = sqrt(pow(uv.x + ant2.x, 2.0) + pow(uv.y + ant2.y, 2.0)) * SCALE;    \n    float amp2 = amplitude(dist2, f, 0.0);\n    \n    //float dist3 = sqrt(pow(uv.x + ant3.x, 2.0) + pow(uv.y + ant3.y, 2.0)) * SCALE;    \n    //float amp3 = amplitude(dist3, f / 33., (iTime * PI * 2.));\n    \n    vec3 col = (normalise(amp1, amp2) * vec3(1.,.5,0.)) + (normalise(amp2, amp1) * vec3(0.,.5,1.));\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 mainSound( in int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    vec2 a = sin(6.2831*440.0*time)*exp(-2.0*(time)) * vec2(1,1);\n    vec2 b = sin(6.2831*554.0*time)*exp(-1.0*time) * vec2(1,1);\n    vec2 c = sin(6.2831*220.0*time)*exp(-0.2*time) * vec2(1,1);\n    \n    vec2 f = sin(6.2831*437.80*mod(time, 16383.))*clamp(tan(mod(time, 16383.)), 0. , 1.) * vec2(1,1);\n    \n    vec2 g = sin(6.2831*554.0*mod(time, 16383.))*clamp(tan(mod(time, 16383.) * 10.), 0. , 1.) * vec2(1,1);\n    \n    vec2 d = sin(6.2831*365.0*mod(time, 16383.) + sin(mod(time, 16383.) * 35.))*abs(sin(mod(time, 16383.) * 8.)) * vec2(.7,.7);\n    vec2 e = sin(6.2831*277.18*mod(time, 16383.))*abs(sin(mod(time, 16383.) * 2.666)) * vec2(1.,1.);\n    \n    \n    //a *= 0.;\n    //b *= 0.;\n    //c *= 0.;\n    //d *= 0.;\n    //e *= 0.;\n    //f *= 0.;\n    //g *= 0.;\n\n    return (a + b + c + d + e + f + g) / 7.;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}