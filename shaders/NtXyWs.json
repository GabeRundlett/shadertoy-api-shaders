{
    "Shader": {
        "info": {
            "date": "1648875687",
            "description": "A simple mosaic pattern.\nClick and drag to move around.",
            "flags": 40,
            "hasliked": 0,
            "id": "NtXyWs",
            "likes": 4,
            "name": "Banded mosaic",
            "published": 3,
            "tags": [
                "fractal",
                "music",
                "mosaic"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 376
        },
        "renderpass": [
            {
                "code": "\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 triangle_wave(vec2 a,float num){\n    //a = rotate(a,num*radians(180.));\n    //a += .5;\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; //makes another interesting pattern\n    return\n        to_return\n        //to_return + dot(to_return,to_return)/8. //makes another interesting pattern\n\n    ;\n    //return abs(fract((a+vec2(1.,1.5)+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    uv -= draggedPos/iResolution.y/t1;\n    float scale = 1.5;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 12; k++){\n            //k += int(uv.y<uv.x);\n            \n            //uv -= fpow(uv.x,2.); //flower pattern\n\n            //uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n            \n            //A really cool pattern:\n            //uv += floor(uv/1.5)/1.5;\n\n            uv.y += fmod1(uv.y,1.5); //lace pattern\n            //uv += floor(uv+vec2(1.,.5))/1.5;\n            float p1 = sign(uv.x);\n            //uv += ceil(uv.x)/2.;\n            //uv.x -= floor(uv.x)/scale;\n            //t2 = abs(t2*2.);\n            \n            //uv += floor(t2.x-t2.y);\n            \n            uv =\n                //fract(uv + t2+.5)\n                -abs(uv + t2)\n            ;\n            //uv += (distance(floor(uv),round(uv+.5)));\n            //uv = max(-uv,uv*sign(uv.yx-uv));\n            //uv = abs(uv);\n\n            //uv += t2-float(k)/(4.-(uv.x-uv.y)/(4.-(uv.x-uv.y))); //this makes an even crazier pattern\n            \n            //uv.y += fpow(uv.y,2.)/2.;\n            //uv.x += fpow(uv.x+1.,2.)/2.;\n            \n            uv /= scale;\n            //uv -= ceil(t2.x*t2.y+5.)/4.; //mosaic pattern\n\n            //uv += vec2(1.); //this also makes an interesting pattern\n            float num = (1.+(uv.x-uv.y)/8.)*float(k)/(7.);\n            \n            //uv = uv*sign(uv.y-uv.x) + floor(uv.x-uv.y)*floor(t2.y-t2.x);\n            //uv = abs(uv);\n            \n            //if(uv.y>uv.x) uv = -uv.yx; else uv *= -sign(uv-uv.yx);\n            t2 =\n                -p1*triangle_wave(uv-.5,num)\n                //-p1*triangle_wave(abs(uv-.5),num)\n                //-p1*triangle_wave(uv-.5,num)/(.5+fmod(t2.x,2.))\n                //-p1*triangle_wave(uv-.5-fmod(t2.x/1.5,2.),num)\n            ;\n            t3 =\n                p1*triangle_wave(uv.yx,num)\n                //p1*triangle_wave(abs(uv.yx),num)\n            ;\n            //t2 -= abs(t2-.5)/8.;\n            //t3 -= abs(t3-.5)/8.;\n            \n            \n            \n            uv = t2-t3;\n            //uv.y -= .5*sign(uv.y);\n            \n            //if(uv.x > uv.y) uv /= 1.5;\n\n            //col.x = abs(col.x-.5);\n            \n            //uv.x -= .5;\n            \n            //if(uv.x>uv.y)\n            col.x =\n                //max(floor((uv.y-uv.x*p1)*8.)/8.-col.x,col.x*2.25)\n                max(uv.y-uv.x*p1-col.x,col.x*2.25)\n            ;\n            col = abs(col.yzx-vec3(1.5-col.x))/2.;\n                            //if(uv.x < uv.y) col = col.yzx;\n            //if(uv.x>uv.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n            \n            //uv.x += .5; //pink flower pattern\n            //col *= col.yzx;\n            //if(uv.x>uv.y) uv *= 2.; else uv -= .5;\n            //if(uv.x<uv.y) uv.y += .5;\n\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  //t /= 1.5;\n  \n  //t *= (1.+mod(floor(t/8.),2.))/2.;\n  //t /= (1.+mod(floor(t*8.),2.));\n  \n  float t0=t, s1 =\n      8.\n      //pow(2.,2.+fmod(t/2.,2.))\n  ,\n  d1 = \n      //floor(t/s1+floor(t*s1))\n      fmod(t*s1,floor(t)+4.)\n  ;\n  float p1 = pow(2.,fmod(t,3.)+1.)/s1;\n  t = t + floor(t/p1)*p1;\n\n  //t = t + floor(floor(t*s1)+floor(t/s1))/s1;\n  \n  float\n  m1 =\n      fmod(t*s1+d1,s1)+1.\n      //fmod(t*s1+d1-mod(t*s1+d1,s1/2.),s1)+1.\n      //fmod(t*s1,s1)\n      //fmod(t+floor(t*s1),s1)\n      //fmod(t+floor(t)*floor(t/s1),s1)\n  ,\n  z1 =\n      (1.+fmod(t+m1,2.))\n      //(1.+fmod(t*sign(d1-m1)+m1,2.))\n      //(1.+fmod(t+m1+mod(t+m1,1.),2.))\n      //(1.+fmod(t/s1+floor(t),2.))\n      //(1.+fmod(t/s1+m1,2.))\n  ;\n  t /=\n      z1\n      //1.+fmod(floor(t*s1+m1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n  float m3 =\n      fmod((t*8.+z1*8.)/(m1*s1+1.+.5),s1)\n      //fmod((t*8.)/(fmod(t*s1,m1+1.)+.5),s1*z1)\n      //fmod((t*8.+m1),s1*z1)\n  ;\n\n      //1.+fmod(floor(t*s1/(.5+m1*2.))*floor(t/s1/(.5+m1*4.)+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t/s1+z1),2.)\n      //1.+fmod(floor(t/s1)*floor(t*s1+z1),2.)\n      //1.+fmod(floor(t*s1)*floor(t*s1+z1),2.)\n  ;\n      \n      \n  float a =\n      //2.*sqrt((1.-sqrt(max(fract(t*s1),fract(t/s1)))))*.2\n      log(max(fract(t*s1),fract(t/s1))/2.)/2.\n  ,\n\n  nb = pow(2.,(m3+z1)/5.+8.)*tempo;\n\n  return abs(.5-vec2(fract(t*nb*.998)\n   ,fract(t*nb)))*a;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "#define fmod3(a,b) mod(floor(a) + floor((a)/2.)*2.+floor((a)/4.)*4.+floor((a)/8.)*8.+floor((a)/16.)*16.,b)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n#define fmod1(x,y) mod(floor(x),y)\n#define fmod(x,y) max(mod(floor(x+floor(t0/y)),y),fmod1(x,y))\n//#define fmod(a,b) mod(mod(floor((a)),floor(1.+(a)/3.)),b)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,mod(floor(x),y))\n#define floor1(x) floor(x)*floor(mod((x)/4.,2.))",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//from https://www.shadertoy.com/view/dtGGzK\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}