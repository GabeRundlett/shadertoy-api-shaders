{
    "Shader": {
        "info": {
            "date": "1603118688",
            "description": "My first torus knot thanks to The Art of Code.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyyzy",
            "likes": 2,
            "name": "My First Torus Knot",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "sdf",
                "torus",
                "knot"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 160
        },
        "renderpass": [
            {
                "code": "/*\nThis shader uses an older version of my Raymarcher Template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1300.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.1, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, normalize(p)) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCone(in vec3 p, in float h, in float r) {\n    return 0.0;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3(-45.0, iTime * 20.0, 0.0));\n    vec2 p2D = vec2(length(p.xz) - 200.0, p.y);\n    float angle = atan(p.z, p.x) * 3.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    p2D *= mat2( c, s,\n                -s, c);\n    p2D.y = abs(p2D.y) - 75.0;\n    return (length(p2D) - 50.0) * 0.4;\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 8.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (abs(distanceToClosest) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}