{
    "Shader": {
        "info": {
            "date": "1694064977",
            "description": "Inspired by \"Screen Space Fluid Rendering for Games\"\n\nhttps://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n\n*mouse to control camera*\n*space to pause/resume sim*\n(see Image tab for more keyboard controls)",
            "flags": 48,
            "hasliked": 0,
            "id": "clScRG",
            "likes": 37,
            "name": "Flowing Water 3D",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "fluid",
                "particles",
                "shadows",
                "dynamics",
                "lights",
                "physics",
                "surface",
                "deferred"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 527
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  This shader was inspired by Simon Green's 2010 paper about fluid rendering, titled\n//  \"Screen Space Fluid Rendering for Games\":\n//\n//      https://developer.download.nvidia.com/presentations/2010/gdc/Direct3D_Effects.pdf\n//\n//  Honestly, it was a head-slapping moment when I read this paper. I had struggled with\n//  rendering 3D fluids before, because I had been trying to render the particles with\n//  ray marching, blending the particles with smooth minimum functions, like this attempt:\n//\n//      Boiling Mercury Hourglass 3D    https://shadertoy.com/view/sdcBWs\n//\n//  But Mr Green's paper points out, it's possible to blur the particles in screen space,\n//  and I've already used that technique in previous 2D shaders, like this shader's\n//  namesake, and one of my more popular shaders,\n//\n//      Flowing Water                   https://shadertoy.com/view/7s3Bz2\n//\n//  The basic idea is, particles simulate in buffer A. Buffer B then computes voronoi\n//  tracking, and buffer C renders the particles into a G buffer, sort of. It does render\n//  depth, but it also renders \"density\" which is just the particles overdrawn with\n//  each other (press D to toggle). Then buffer D blurs both the depth buffer, and the\n//  density, passing thru the unblurred depth as well. The Image tab reconstructs the\n//  normals from the blurred depth buffer, and applies lighting and reflection/refraction.\n//\n//  The refraction is only one-sided...I'm not attempting to reconstruct the back-side\n//  geometry of the water in this shader. It's probably possible, maybe by splitting\n//  the voronoi into four particles for the front side and four for the back. Maybe\n//  I'll try that in the next shader.\n//  \n//  The particle sim isn't that much different from my previous ones. Particles track\n//  the 16 closest neighbors, for collision and viscosity application. If there weren't\n//  constant motion, it probably wouldn't look that great since it wouldn't be very\n//  stable. But, it works well enough here.\n//\n//  I implemented the 8-neighbor screen-space voronoi tracking from my recent shader\n//\n//      Packed Voronoi Tracking        https://shadertoy.com/view/DtsBWM\n//\n//  But, with tuning I was able to get the old four-neighbor search working equally well,\n//  and it is slightly cheaper, for me. Try disabling FOUR_NBS in the common tab to try it.\n//\n//  Probably the two biggest challenges were the blurring process and the reconstruction\n//  of the normals. And the problems are intertwined, because they depend on each other.\n//  I tried lots of different blurring strategies, including ones using the mip map\n//  hardware, but that usually resulted in magnifying small artifacts.  I also tried\n//  implementing the blur using what I hoped was an approximation of the \"bilateral\n//  filter\" from the paper, but it didn't work for me. What I ended up with is a very\n//  simple but expensive Gaussian blur which enabled me to control it per-pixel, giving\n//  me the fewest rendering artifacts.\n//\n//  It appears that the blur pass is the most expensive thing in the shader, and in the\n//  paper they talk about the importance of the blur operation to be separable, which I\n//  think means two passes in different directions. But I tried that (I did one direction\n//  blur in Buffer D, and then the other direction when sampling Buffer D from the Image\n//  tab), and while it was definitely faster, I wasn't able to defeat the horrible\n//  artifacts I got.\n//\n//  There are a lot of keyboard/debug controls. Generally, you can disable various parts\n//  of the rendering (R for refraction, S for specular, and D for density, B for blur). \n//  There are three debug renderer modes (Z for depth, N for normal, P for \"paint\", i.e.\n//  opaque rendering, M for \"mercury\" i.e. reflective), all of which are compatible with\n//  toggling the blur (B). Turning off the blur makes the shader run faster, and the\n//  cheapest overall mode is (Z) depth render with blur disabled, since this also skips\n//  normal reconstruction. Use the mouse and the up/down arrow keys to control the camera,\n//  and press C to resume camera motions after you've clicked.\n//\n//  I also tried adding noise to the normal, since I believe this was recommended in the\n//  paper. Maybe I didn't do it right, but I think I like the shinier water better. Press\n//  O to try it.\n//\n//  * mouse to control camera * \n//  * 8 to disable/enable four-neighbor mode *\n//  * B to disable/enable blur\n//  * C to resume camera motion after mouse click\n//  * D to disable/enable density render\n//  * O to enable/disable blue noise\n//  * P to enable/disable \"paint\" (opaque) mode\n//  * R to disable/enable refraction\n//  * S to disable/enable specular\n//  * M to enable/disable \"mercury\" (reflect) mode\n//  * N to debug render normals\n//  * Z to debug render depth\n//  * space to pause/resume sim *\n//  * up/down to zoom camera *\n//\n//  One detail you might miss...the wood has a bump map, which you might notice in the\n//  underside of the top shelf, or on the side walls when they reflect the background.\n//  It seems to be cheap enough not to impact the shader performance, but it can be turned\n//  off with FANCY_WOOD below. \n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer of just the particles\n//  Buffer D blurs depth and density\n//  Image performs final composite render\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 LIGHT_DIR = normalize(vec3(1));\n\n#define FANCY_WOOD 1\n\n// blue noise from paniq's Hilber R1 Blue Noise \n// https://www.shadertoy.com/view/3tB3z3\n\n// from https://www.shadertoy.com/view/XtGBDW\nuint hilbert_index( uvec2 Position )\n{   \n    const uint LEVEL = 15U;\n    const uint WIDTH = (1U << LEVEL);\n    const uint AREA = WIDTH * WIDTH;\n    uvec2 Regions;\n\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\n// mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it\nfloat hilbert_r1_blue_noise(uvec2 p) {\n    #if 1\n    uint x = hilbert_index( p ) % (1u << 17u);\n    #else\n    //p = p ^ (p >> 1);\n    uint x = pack_morton2x16( p ) % (1u << 17u);    \n    //x = x ^ (x >> 1);\n    x = inverse_gray32(x);\n    #endif\n    // based on http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\treturn fract(0.5+phi*float(x));\n}\n\n// generate normal from blurred depth buffer\nvec3 reconstructNormal(fxState s, vec2 u, float cbz, mat3 w2c)\n{\n    const vec2 e = vec2(1, 0);\n    float lbz = fxGetGBuffer(u + e.xy).bz; // left blurred z, etc\n    float rbz = fxGetGBuffer(u - e.xy).bz;\n    float ubz = fxGetGBuffer(u + e.yx).bz;\n    float dbz = fxGetGBuffer(u - e.yx).bz;\n\n    // discard the larger of the two deltas in each direction, to reduce edge artifacts\n    float dx1 = cbz - lbz, dx2 = rbz - cbz;\n    float dx = abs(dx1) < abs(dx2) ? dx1 : dx2;\n    float dy1 = cbz - dbz, dy2 = ubz - cbz;\n    float dy = abs(dy1) < abs(dy2) ? dy1 : dy2;\n    \n    vec2 gr = vec2(dx, dy); // gradient\n    float noise = s.noise ? 1e-2 * hilbert_r1_blue_noise(uvec2(u)) : 0.;\n    vec3 sn = normalize(vec3(gr, 3e-2 + noise)); // screen-space normal\n    \n    return sn * w2c; // world space normal\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nbool boxIntersection(vec3 ro, vec3 rd, vec3 rad)\n{\n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\t\n    return tN < tF && tF > 0.;\n}\n\n// simple ray marching loop for rendering the shelves, returns (position, t)\nvec4 march(vec3 p, vec3 rd)\n{\n    float t = 0.;\n    for (int x = 0; x < 256; ++x)\n    {\n        float d = sdScene(p);\n        if (d < .001) return vec4(p, t);\n        p += rd * d;\n        t += d;\n    }\n    return vec4(1e6);\n}\n\n// from iq's Screen space bump mapping: https://www.shadertoy.com/view/ldSGzR\nvec3 doBump(vec3 dpdx, vec3 dpdy, vec3 nor, \n            float dbdx, float dbdy,\n            float scale)\n{\n    vec3  u = cross(dpdy, nor);\n    vec3  v = cross(nor, dpdx);\n    float d = dot(dpdx, u);\n\t\n\tvec3 surfGrad = dbdx * u + dbdy*v;\n    return normalize(abs(d) * nor - sign(d) * scale * surfGrad);\n}\n\n#define CUBE(u) pow(texture(iChannel0, u).rgb, vec3(2.2))\n\n// lighting calculations used by both scene render functions\nvec3 light(vec2 uv, vec3 rd, vec3 n)\n{\n    vec3 col = texture(iChannel3, uv).rgb * .1;\n\n#if FANCY_WOOD\n    vec3 rfl = reflect(rd, n);\n    float fre = 1. - max(dot(n, -rd), 0.);//pow(1. - max(dot(n, rd), 0.), 60.);\n    fre = pow(fre, 5.);\n    vec3 spec = fre * CUBE(rfl) * .2;\n    vec3 diff = textureLod(iChannel0, n, 4.).rgb; // low-mip cube sample\n#else\n    float diff = max(0., dot(n, LIGHT_DIR)) * .6 + .4;\n    float spec = 0.;\n#endif\n\n    return col * diff + spec;\n}\n\n// scene render (without particles), applies bump map to wood\nvec4 renderBump(fxState s, vec3 ro, vec3 rd, vec3 ddx_rd, vec3 ddy_rd)\n{\n    vec4 mr = march(ro, rd); // march result\n    if (mr.w > 1e5)\n        return vec4(CUBE(rd), 1e6);\n    else\n    {\n        vec3 nor = NORM(sdScene, mr.xyz);\n        if (s.normal) return vec4(nor, mr.w);\n        vec2 uv = uvScene(mr.xyz) / iChannelResolution[3].xy;\n\n#if FANCY_WOOD\n        vec3 ddx_pos = ro - ddx_rd * dot(ro - mr.xyz, nor) / dot(ddx_rd, nor);\n        vec3 ddy_pos = ro - ddy_rd * dot(ro - mr.xyz, nor) / dot(ddy_rd, nor);\n        vec3 dposdx = ddx_pos - mr.xyz;\n        vec3 dposdy = ddy_pos - mr.xyz;\n        float l = .1;\n\n        vec3 mate = texture(iChannel3, uv, l).xyz;\n        float signal = dot(mate,vec3(.33));\n        vec2 uvx = uvScene(ddx_pos) / iChannelResolution[3].xy;\n        vec2 uvy = uvScene(ddy_pos) / iChannelResolution[3].xy;\n        float dsignaldx = dot(texture(iChannel3, uvx, l).xyz, vec3(.33)) - signal;\n        float dsignaldy = dot(texture(iChannel3, uvy, l).xyz, vec3(.33)) - signal;\n\n        vec3 n = doBump(dposdx, dposdy, nor, dsignaldx, dsignaldy, .05);\n#else\n        vec3 n = nor;\n#endif // FANCY_WOOD\n\n        vec3 col = light(uv, rd, n);\n        return vec4(col, mr.w);\n    }\n}\n\n// reflected/refracted render, skips bump map (also no particles)\nvec3 render(fxState s, vec3 ro, vec3 rd)\n{\n    vec4 mr = march(ro, rd); // march result\n    if (mr.w > 1e5)\n        return CUBE(rd);\n    else\n    {\n        vec3 n = NORM(sdScene, mr.xyz);\n        if (s.normal) return n;\n        \n        vec2 uv = uvScene(mr.xyz) / iChannelResolution[3].xy;\n        vec3 col = light(uv, rd, n);\n\n        return col;\n    }\n}\n\nconst float IR_AIR = 1.;\nconst float IR_WATER = 1.33;\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    fxState s = fxGetState();\n    \n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, int(R.x), ro, fwd, lft, up); // camera basis\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up); // ray direction\n\n    // set up differntial rays for bump mapping\n\tvec3 ddx_rd = fxCalcRay(u + vec2(1, 0), R, fwd, lft, up);\n\tvec3 ddy_rd = fxCalcRay(u + vec2(0, 1), R, fwd, lft, up);\n\n    vec4 rr = renderBump(s, ro, rd, ddx_rd, ddy_rd); // render scene with bump map\n    O.rgb = rr.rgb;\n    \n    if (boxIntersection(ro - BBOX_CENTER, rd, BBOX_EXTENTS * .5))\n    {\n        fxGBufferPixel pix = fxGetGBuffer(u); // render water\n        \n        if (pix.t < rr.w) // check depth vs. scene\n        {\n            if (s.depth) { O.rgb = sin(pix.bz * .5 + vec3(0, 11, 33)) * .5 + .5; return; } // debug depth render\n            \n            mat3 w2c = inverse(mat3(-lft, up, -fwd)); // world to camera rotation matrix\n            vec3 n = reconstructNormal(s, u, pix.bz, w2c);\n\n            if (s.normal && s.ref) { O.rgb = n; return; } // debug render normal\n\n            vec3 hit = pix.t * rd + ro; // ray hit water position\n            vec3 rfl = reflect(rd, n); // reflected ray\n\n            if (s.paint) // \"paint\" (opaque) mode\n            {\n                float diff = max(0., dot(n, LIGHT_DIR)) + .4;\n                O.rgb = diff * vec3(.8, .2, .3) * .6 * .4;\n            }\n            else if (s.mercury)\n                O.rgb = render(s, hit, rfl);\n            else\n            {\n                if (s.ref)\n                {\n                    vec3 rfr = refract(rd, n, IR_AIR/IR_WATER); // refracted ray direction\n                    O.rgb = render(s, hit, rfr); // render refrected light\n                }\n\n                float den = s.density ? pix.d : 0.; // density\n                O.rgb *= 1. - smoothstep(.0, 4., den) * vec3(.5, .3, .1); // compute density color\n            }\n\n            float fre = 1. - max(dot(n, rd), 0.); // fresnel\n            fre = pow(fre, 50.);\n            vec3 spec = fre * render(s, hit, rfl); // render specular light\n            if (s.spec && !s.mercury) O.rgb += spec * .3;\n        }\n    }\n\n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = u / R;\n    uv *=  1. - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 15.; // multiply with sth for intensity\n    vig = pow(vig, .15); // change pow for modifying the extend of the  vignette\n    O *= vig;\n    \n    if (!s.normal) O.rgb = pow(ACESFilm(O.rgb), vec3(1./2.2));\n    O.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_COLL_SIZE = .25;\nconst float PARTICLE_RENDER_SIZE = .5;\nconst vec3 BBOX_MIN = vec3(-15, -100, -2.5);\nconst vec3 BBOX_MAX = vec3( 15,  100,  2.5);\nconst vec3 BBOX_EXTENTS = BBOX_MAX - BBOX_MIN;\nconst vec3 BBOX_CENTER = (BBOX_MIN + BBOX_MAX) * .5;\n#define R     iResolution.xy\n\n// set to zero for eight-neigbor voronoi search. four-neighbor seems faster enough to me to enable by default\n#define FOUR_NBS 1\n\n// PARTICLES\n\n// enum for the data types making up the structure of each particle\n#define UL_NEIGHBORS 0U\n#define UR_NEIGHBORS 1U\n#define LL_NEIGHBORS 2U\n#define LR_NEIGHBORS 3U\n#define POS 4U\n#define VEL 5U\n#define NUM_PARTICLE_DATA_TYPES 6U\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(uint wd, uint id, uint typ)\n{\n    uint idx = id * NUM_PARTICLE_DATA_TYPES + typ;\n    return ivec2(idx % wd, idx / wd);\n}\n\nstruct fxParticle\n{\n    uvec4 nbs[4];\n    vec3 pos;\n    vec3 vel;\n};\n\n// get the particle corresponding to the id\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, uint(R.x), X)\nfxParticle fxGetParticleImpl(sampler2D smp, uint wd, uint id)\n{\n    vec4 data0 = texelFetch(smp, fxLocFromID(wd, id, UL_NEIGHBORS), 0);\n    vec4 data1 = texelFetch(smp, fxLocFromID(wd, id, UR_NEIGHBORS), 0);\n    vec4 data2 = texelFetch(smp, fxLocFromID(wd, id, LL_NEIGHBORS), 0);\n    vec4 data3 = texelFetch(smp, fxLocFromID(wd, id, LR_NEIGHBORS), 0);\n    vec4 data4 = texelFetch(smp, fxLocFromID(wd, id, POS), 0);\n    vec4 data5 = texelFetch(smp, fxLocFromID(wd, id, VEL), 0);\n\n    fxParticle p;\n    p.nbs[0] = uvec4(data0);\n    p.nbs[1] = uvec4(data1);\n    p.nbs[2] = uvec4(data2);\n    p.nbs[3] = uvec4(data3);\n    p.pos = data4.xyz;\n    p.vel = data5.xyz;\n    \n    return p;\n}\n\n// write the correct channel of the particle\nvec4 fxSaveParticle(fxParticle p, uint dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, uint(R.x), X, Y)\nvec4 fxGetParticleDataImpl(sampler2D smp, uint wd, uint id, uint typ)\n{\n    return texelFetch(smp, fxLocFromID(wd, id, typ), 0);\n}\n\n// global variables, initialized via computeMaxParticles\nconst uint IDEAL_MAX_PARTICLES = 0x3ffeU;\nuint g_MaxParticles = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\n// must be called in each buffer before g_MaxParticles is valid\n#define computeMaxParticles() computeMaxParticlesImpl(R)\nvoid computeMaxParticlesImpl(vec2 r)\n{\n    g_MaxParticles = min(IDEAL_MAX_PARTICLES, uint(r.x * r.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 lastMouse;\n    vec2 camAngle;\n    float camOrbit;\n    float res;\n    bool normal;\n    bool sim;\n    bool spec;\n    bool depth;\n    bool ref;\n    bool density;\n    bool blur;\n    bool eightNbs;\n    bool paint;\n    bool camMotion;\n    bool mercury;\n    bool noise;\n};\n\n#define fxGetState() fxGetStateImpl(iChannel1) // channel 1 is Buffer B\nfxState fxGetStateImpl(sampler2D smp)\n{\n    vec4 data0 = texelFetch(smp, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(smp, ivec2(1, 0), 0);\n    vec4 data2 = texelFetch(smp, ivec2(2, 0), 0);\n    vec4 data3 = texelFetch(smp, ivec2(3, 0), 0);\n    vec4 data4 = texelFetch(smp, ivec2(4, 0), 0);\n    \n    fxState s;\n    s.camMotion = data0.x != 0.;\n    s.lastMouse = data0.yz;\n    s.camAngle = data3.yz;\n    s.res = data1.y;\n    s.normal = data1.z != 0.;\n    s.sim = data2.x != 0.;\n    s.spec = data2.y != 0.;\n    s.depth = data2.z != 0.;\n    s.ref = data2.w != 0.;\n    s.density = data3.x != 0.;\n    s.blur = data0.w != 0.;\n    s.camOrbit = data1.w;\n    s.eightNbs = data3.w != 0.;\n    s.paint = data1.x != 0.;\n    s.mercury = data4.x != 0.;\n    s.noise = data4.y != 0.;\n        \n    return s;\n}\n\nvec4 fxPutState(fxState s, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(s.camMotion ? 1 : 0, s.lastMouse, s.blur ? 1 : 0);\n    else if (ifc == ivec2(1, 0))\n        return vec4(s.paint ? 1. : 0., s.res, s.normal ? 1 : 0, s.camOrbit);\n    else if (ifc == ivec2(2, 0))\n        return vec4(s.sim ? 1 : 0, s.spec ? 1 : 0, s.depth ? 1 : 0, s.ref ? 1 : 0);\n    else if (ifc == ivec2(3, 0))\n        return vec4(s.density ? 1 : 0, s.camAngle, s.eightNbs ? 1 : 0);\n    else\n        return vec4(s.mercury ? 1 : 0, s.noise ? 1 : 0, 0, 0);\n}\n\nbool isStatePixel(ivec2 ifc)\n{\n    return ifc.y == 0 && ifc.x >= 0 && ifc.x < 5;\n}\n\n// CAMERA\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nvoid fxCalcCamera(fxState s, int resolutionWidth, out vec3 ro, out vec3 fwd, out vec3 lft, out vec3 up)\n{\n    vec3 ta = vec3(0);\n    \n    ro = vec3(0, 1, 1) * s.camOrbit;\n    ro.yz *= rotate(s.camAngle.y + .6);\n    ro.xz *= rotate(s.camAngle.x * 2.);\n    ro += ta;\n    \n    fwd = normalize(ta - ro);\n    lft = -normalize(cross(fwd, vec3(0.0,1.0,0.0)));\n    up = normalize(cross(lft, fwd));\n}\n\nmat4 fxCalcCameraMat(vec3 ro, vec3 fwd, vec3 lft, vec3 up)\n{\n    return mat4(vec4(-.5 * lft, 0),\n                vec4(-.5 * up , 0),\n                vec4(fwd      , 0),\n                vec4(ro       , 1));\n}\n\nvec3 fxCalcRay(vec2 u, vec2 r, vec3 fwd, vec3 lft, vec3 up)\n{\n\tvec2 s = (u - .5 * r.xy) / r.y;\n\treturn normalize(fwd - s.x * lft - s.y * up);\n}\n\n// G BUFFER\n\nstruct fxGBufferPixel\n{\n    float d; // density\n    float t; // distance from camera\n    float z; // z depth\n    float bz; // blurred z depth\n};\n\nvec4 fxSaveGBuffer(fxGBufferPixel pix)\n{\n    return vec4(pix.d, pix.t, pix.z, pix.bz);\n}\n\n#define fxGetGBuffer(X) fxGetGBufferImpl(iChannel2, X, R)\nfxGBufferPixel fxGetGBufferImpl(sampler2D smp, vec2 u, vec2 r)\n{\n    vec4 p = texture(smp, u/r);\n    \n    fxGBufferPixel pix;\n    pix.d = p.x;\n    pix.t = p.y;\n    pix.z = p.z;\n    pix.bz = p.w;\n    \n    return pix;\n}\n\n// MISC\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_8     56\n#define KEY_B     66\n#define KEY_C     67\n#define KEY_D     68\n#define KEY_M     77\n#define KEY_N     78\n#define KEY_O     79\n#define KEY_P     80\n#define KEY_R     82\n#define KEY_S     83\n#define KEY_Z     90\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1./float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n// https://iquilezles.org/articles/spherefunctions/\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w * sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.) return vec2(-1, -1);\n\treturn vec2(-b - sqrt( h ), -b + sqrt( h ));\n}\n\n// VORONOI\n\n#if FOUR_NBS\n\n// returns the ids of the four closest particles from the input\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X) // channel 1 is Buffer B\n#define fxGetClosestLight(X) fxGetClosestImpl(iChannel3, X) // channel 3 is buffer D\nuvec4 fxGetClosestImpl(sampler2D smp, ivec2 v)\n{\n    return uvec4(texelFetch(smp, v, 0));\n}\n\n#else // FOUR_NBS\n\nuvec4 pack2(uvec4 a, uvec4 b)\n{\n    return (a & 0xffffU) | ((b & 0xffffU) << 16);\n}\n\nvoid unpack2(uvec4 p, out uvec4 a, out uvec4 b)\n{\n    a = p & 0xffffU;\n    b = (p & 0xffff0000U) >> 16;\n}\n\n// returns the ids of the eight closest particles from the input\n#define fxGetClosest(X, Y, Z) fxGetClosestImpl(iChannel1, X, Y, Z) // channel 1 is Buffer B\n#define fxGetClosestLight(X, Y, Z) fxGetClosestImpl(iChannel3, X, Y, Z) // channel 3 is buffer D\nvoid fxGetClosestImpl(sampler2D smp, ivec2 v, out uvec4 a, out uvec4 b)\n{\n    uvec4 x = floatBitsToUint(texelFetch(smp, v, 0));\n    unpack2(x, a, b);\n}\n\nvec4 fxSaveClosest(uvec4 a, uvec4 b)\n{\n    return uintBitsToFloat(pack2(a, b));\n}\n\n#endif // FOUR_NBS\n\n// SCENE\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst float THICK = 1.;\n\nfloat sdScene(vec3 p)\n{\n    float d = sdBox(p, BBOX_EXTENTS * .5 + THICK);\n    float side = abs(mod(p.y, 20.) - 10.) > 5. ? 12.5: -12.5;\n    p.y = mod(p.y, 10.0);\n    const vec3 CUTOUT_A = vec3(BBOX_EXTENTS.x, 10. - THICK, BBOX_EXTENTS.z + 3.) * .5;\n    d = max(d, -sdBox(p - vec3(0, 5., 0), vec3(CUTOUT_A)));\n    const vec3 CUTOUT_B = vec3(5., 20, BBOX_EXTENTS.z + 3.) * .5;\n\n    d = max(d, -sdBox(p - vec3(side, 7.5, 0), vec3(CUTOUT_B)));\n    return d;\n}\n\nfloat sdPhysicsScene(vec3 p)\n{\n    float d = sdBox(p, BBOX_EXTENTS + THICK);\n    float side = abs(mod(p.y, 20.) - 10.) > 5. ? 12.5: -12.5;\n    p.y = mod(p.y, 10.0);\n    const vec3 CUTOUT_A = vec3(BBOX_EXTENTS.x, 10. - THICK, BBOX_EXTENTS.z) * .5;\n    d = max(d, -sdBox(p - vec3(0, 5., 0), vec3(CUTOUT_A)));\n    const vec3 CUTOUT_B = vec3(5., 20, BBOX_EXTENTS.z) * .5;\n\n    d = max(d, -sdBox(p - vec3(side, 7.5, 0), vec3(CUTOUT_B)));\n    return d;\n}\n\nconst vec2 e = vec2(1e-4, 0);\n\n#define NORM(S, p) normalize(vec3(S(p + e.xyy) - S(p - e.xyy), \\\n                                  S(p + e.yxy) - S(p - e.yxy), \\\n                                  S(p + e.yyx) - S(p - e.yyx)))\n\nvec2 uvScene(vec3 p)\n{\n    if (abs(p.z) > BBOX_MAX.z + .9)\n    {\n        if (abs(p.x) > BBOX_MAX.x - THICK) return p.yx * 40.;\n        return p.xy * 40.;\n    }\n    if (abs(p.x) > BBOX_MAX.x - THICK) return p.yz * 40.;\n    return p.xz * 40.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nvec3 GRAVITY = vec3(0,-.0005,0); // strength of gravity\nconst float VISCOSITY = .003; // how viscous is the fluid\nconst float VISCOSITY_RADIUS = PARTICLE_COLL_SIZE * 8.; // how far away to apply viscosity\n\nvoid particleStep(inout fxParticle p, fxState s, uint id, vec2 u);\nvec4 neighborUpdate(fxParticle p, fxState s, uint typ, ivec2 ifc, uint id);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    uint idx = uint(ifc.x + ifc.y * int(R.x));\n    uint id = idx / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    uint typ = idx - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles();\n    if(id >= g_MaxParticles) return;\n\n    fxState s = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (s.sim)\n    {\n        if (typ < POS)\n        {\n            O = neighborUpdate(p, s, typ, ifc, id);\n            return;\n        }\n        else\n        {\n            particleStep(p, s, id, u);\n        }\n    }\n        \n    O = fxSaveParticle(p, typ);\n}\n\n// PARTICLE UPDATE\n\nvoid particleStep(inout fxParticle p, fxState s, uint id, vec2 u)\n{\n    if (iFrame == 0 || s.res < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(u, iFrame) ) - .5;\n        vec3 sb = BBOX_EXTENTS;\n        sb.y = 30.;\n        p.pos = h * sb + vec3(0, 0, 0);\n        p.vel = vec3(0);//.08 * w, .10, .0) * .3;\n        \n        return;\n    } \n    \n    if (p.pos.y < -20.)\n    {\n        // reset particles that fall too far back to the top\n        vec3 h = hash3( uvec3(u, iFrame) ) - .5;\n        float w = (id % 2U) == 0U ? -1. : 1.;\n        vec3 sb = BBOX_EXTENTS;\n        sb.y = 10.;\n        p.pos = h * sb + vec3(0, 20., 0.);\n        p.vel = vec3(0);//.08 * w, .10, .0) * .3;\n    }\n\n    p.vel += GRAVITY;\n\n    // collide with neighbors\n    vec3 np = p.pos; // new pos\n    vec3 visc = vec3(0); // viscosity impulse\n    vec3 imp = vec3(0); // collision impulse\n    for (int i = 0; i < 4; ++i)\n    {\n        for (int j = 0; j < 4; ++j)\n        {\n            uint ri = ((uint(i + iFrame) + id) * 7U) % 4U; // randomize the order we process neighbors to avoid directional effects\n            uint nid = p.nbs[ri][j];\n            if (nid == -1U) break;\n            \n            fxParticle nb = fxGetParticle(nid);\n            float d2 = length2(nb.pos - p.pos);\n            \n            if (d2 < 1e-6) continue; // skip particles too close, because we lack a clear direction\n            if (d2 > VISCOSITY_RADIUS * VISCOSITY_RADIUS) break; // no need to search farther once we've reached viscosity radius\n            \n            float d = sqrt(d2);\n            \n            visc += (nb.vel - p.vel) * smoothstep(VISCOSITY_RADIUS, 0., d) * VISCOSITY; // compute viscosity\n\n            // collision\n            if (d < PARTICLE_COLL_SIZE * 2.)\n            {\n                // position correction\n                vec3 dir = normalize(p.pos - nb.pos);\n                np = nb.pos + dir * PARTICLE_COLL_SIZE * 2.;\n\n                vec3 relVel = p.vel - nb.vel;\n                float normVel = min(0., dot(relVel, dir));\n                \n                imp -= dir * normVel; // collisio impulse\n            }\n        }\n    }\n    \n    // update the position and velocity as affected by neighbors\n    p.pos = np;\n    p.vel += visc + imp;\n\n    // damping\n    p.vel *= .9995; // damping\n    const float MAX_SPEED = .9; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n    \n    // integrate\n    p.pos += p.vel;\n\n    // collide with boundary\n    float d = sdPhysicsScene(p.pos);\n    if (d < PARTICLE_COLL_SIZE)\n    {\n        vec3 sn = NORM(sdPhysicsScene, p.pos);\n        p.pos = p.pos + (PARTICLE_COLL_SIZE - d) * sn;\n        p.vel -= min(0., dot(sn, p.vel)) * sn;\n    }\n}\n\n// NEIGHBOR UPDATE\n\nbool iscoincidence(in uvec4 ids, uint cid, uint sid)\n{\n    return sid == cid || any(equal(ids,uvec4(sid)));\n}\n\nvoid insertion_sort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid sortParticle(inout uvec4 ids, inout vec4 ds, uint typ, uint pid, uint sid, in fxParticle p)\n{\n    if(iscoincidence(ids, pid, sid)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(sid, POS).xyz; \n\n    vec3 dx = nbX - p.pos;\n    \n    uint dir = uint(2.*(atan(dx.x, dx.z)+PI)/PI); \n    if(dir != typ) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(ids, ds, sid, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState s, uint typ, ivec2 ifc, uint id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    uvec4 ids = uvec4(-1U);\n    vec4 ds = vec4(1e6);\n\n    if (iFrame > 0 && s.res > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                uint nid = p.nbs[i][j];\n                if (nid == -1U) break;\n                sortParticle(ids, ds, typ, id, nid, p);\n\n                // consider neighbors' closest neighbor\n                for (uint x = 0U; x < 4U; ++x)\n                {\n                    uint nbNid = uint(fxGetParticleData(nid, x));\n                    if (nbNid != -1U)\n                        sortParticle(ids, ds, typ, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int iter = iFrame < 10 ? 8 : 3;\n        for(int k = 0; k < iter; k++)\n        {\n            uint h = hash(uvec4(ifc.x, ifc.y * int(R.x), iFrame, k)).x;\n            uint hi = h % uint(g_MaxParticles);\n            sortParticle(ids, ds, typ, id, hi, p);\n        }\n    }\n    \n    return vec4(ids);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer plus persistent state handling\n// ---------------------------------------------------------------------------------------\n\nvoid updateState(inout fxState s);\nvec4 voronoi(fxState s, vec2 u);\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    computeMaxParticles();\n    fxState s = fxGetState();\n    \n    ivec2 ifc = ivec2(u);\n    if(isStatePixel(ifc))\n    {\n        updateState(s);\n        \n        O = fxPutState(s, ifc);\n    }\n    else\n        O = voronoi(s, u);\n}\n\nvoid updateState(inout fxState s)\n{\n    if (iFrame == 0 || // bootstrap\n        abs(s.res) != R.x * R.y) // detect resolution change\n    {\n        s.res = -R.x * R.y;\n        s.camAngle = vec2(0, .7);\n        s.normal = false;\n        s.sim = true;\n        s.spec = true;\n        s.ref = true;\n        s.density = true;\n        s.blur = true;\n        s.eightNbs = true;\n        s.paint = false;\n        s.camMotion = true;\n        s.mercury = false;\n        s.noise = false;\n        s.camOrbit = 20.;\n    }\n    else\n    {\n        // update persistent state\n        s.res = abs(s.res); // positive res means, don't reset\n\n        if (iMouse.z > 0.)\n        {\n            if (iMouse.w < 0.)\n            {\n                vec2 d = s.lastMouse - iMouse.xy / R;\n                s.camAngle.x += .5 * d.x;\n                s.camAngle.y += .2 * d.y;\n            }\n            \n            s.camMotion = false;\n            s.lastMouse = iMouse.xy / R;\n        }\n\n        if (keyClick(KEY_8)) s.eightNbs = !s.eightNbs;\n        if (keyClick(KEY_B)) s.blur = !s.blur;\n        if (keyClick(KEY_C)) s.camMotion = true;\n        if (keyClick(KEY_D)) s.density = !s.density;\n        if (keyClick(KEY_O)) s.noise = !s.noise;\n        if (keyClick(KEY_P)) s.paint = !s.paint;\n        if (keyClick(KEY_R)) s.ref = !s.ref;\n        if (keyClick(KEY_S)) s.spec = !s.spec;\n        if (keyClick(KEY_M)) s.mercury = !s.mercury;\n        if (keyClick(KEY_N)) s.normal = !s.normal;\n        if (keyClick(KEY_Z)) s.depth = !s.depth;\n        if (keyClick(KEY_SPACE)) s.sim = !s.sim;\n        if (keyDown(KEY_UP)) s.camOrbit -= .1;\n        if (keyDown(KEY_DOWN)) s.camOrbit += .1;\n\n        if (s.camMotion)\n        {\n            s.camAngle.x += .005 * s.camAngle.y;\n            s.camAngle.y -= .005 * s.camAngle.x;\n            s.camAngle = mix(s.camAngle, normalize(s.camAngle) * .2, .005);\n        }\n    }\n}\n\nfloat distance2Particle(uint id, vec2 u, mat4 w2c, vec3 ro, vec3 rd)\n{\n    // compute screen space position\n    vec3 wp = fxGetParticleData(id, POS).xyz;\n    vec3 sp = (w2c * vec4(wp,1.0)).xyz;\n    sp.xy /= sp.z;\n    \n    vec2 t = sphIntersect(ro, rd, vec4(wp, PARTICLE_RENDER_SIZE));\n    if (t.x < 0.) return 1e9; // don't consider particles that aren't hit by this ray\n\n    return length2(sp.xy - u) + t.x * .0002;\n}\n\n#if FOUR_NBS\n// four-neighbor voronoi search, enable to compare\n\nvoid insertion_sort(inout uvec4 i, inout vec4 d, uint i_, float d_)\n{\t\n    if(any(equal(uvec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = uvec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = uvec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = uvec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = uvec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvec4 voronoi(fxState s, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n    int wd = int(R.x);\n\tvec2 p = (2. * u - R.xy) / R.y;\n\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, wd, ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    uvec4 new = uvec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        uvec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            uint id = old[j];\n            if (id == -1U) break;\n            if (id >= g_MaxParticles) continue;\n            float dis2 = distance2Particle(id, p, w2c, ro, rd);\n            insertion_sort(new, dis, id, dis2);\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            #if 0\n            uvec4 h = hash(uvec4(ifc.x, ifc.y * 3, iFrame, j));\n            uvec4 nbs = uvec4(fxGetParticleData(id, h.x % 4U));\n            uint nid = nbs[h.y % 4U];\n\n            if (nid >= 0U && nid < g_MaxParticles)\n            {\n                float dis2 = distance2Particle(nid, p, w2c, ro, rd);\n                insertion_sort(new, dis, nid, dis2);\n            }\n            #endif\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint rng = 16u;\n        uint cnt = max(2U, uint(R.y / 200.));\n\n        for(uint i = 0u; i < cnt; ++i)\n        {\n            uvec4 h0 = hash(uvec4(ifc, iFrame, i) * i);\n            uvec4 old = fxGetClosest(ifc + ivec2( h0.xy % rng - rng / 2u));      \n\n            for (int j = 0; j < 1; j++)\n            {\n                uint id = old[j];\n                if (id == -1U) break;\n                if (id >= g_MaxParticles) continue;\n                float dis2 = distance2Particle(id, p, w2c, ro, rd);\n                insertion_sort(new, dis, id, dis2);\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 2;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            uint id = hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x % g_MaxParticles;\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c, ro, rd));\n        }\n    }\n    \n    return vec4(new);\n}\n\n#else // FOUR_NBS\n// eight-neighbor voronoi search, enabled by default\n\nvoid insertionSort(inout uvec4 i, inout vec4 d, inout uint i_, inout float d_)\n{\t\n    uint ip = i_;\n    float dp = d_;\n    if     (d_ < d[0])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(ip,i.xyz),    d = vec4(dp,d.xyz);\n    else if(d_ < d[1])             \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.x,ip,i.yz), d = vec4(d.x,dp,d.yz);\n    else if(d_ < d[2])            \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xy,ip,i.z), d = vec4(d.xy,dp,d.z);\n    else if(d_ < d[3])           \n        i_ = i.w,               d_ = d.w,\n        i = uvec4(i.xyz,ip),    d = vec4(d.xyz,dp);\n}\n\nvoid insertionSort2(inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, uint id, vec2 p, mat4 w2c, vec3 ro, vec3 rd)\n{\n    if (any(equal(uvec4(id),na)) || any(equal(uvec4(id),nb))) return; // don't insert the same id twice\n    \n    float d = distance2Particle(id, p, w2c, ro, rd);\n    insertionSort(na, da, id, d);\n    insertionSort(nb, db, id, d);\n}\n\n// consider a new set of four candidate particles to insert into our arrays\nvoid sortNbs(uvec4 old, vec2 p, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, mat4 w2c, vec3 ro, vec3 rd)\n{\n    for (int j = 0; j < 4; j++)\n        insertionSort2(na, nb, da, db, old[j], p, w2c, ro, rd);\n}\n\n// consider a new set of eignt candidate particles to insert into our arrays\nvoid sortNbs2(uvec4 a, uvec4 b, inout uvec4 na, inout uvec4 nb, inout vec4 da, inout vec4 db, vec2 p, mat4 w2c, vec3 ro, vec3 rd)\n{\n    sortNbs(a, p, na, nb, da, db, w2c, ro, rd);\n    sortNbs(b, p, na, nb, da, db, w2c, ro, rd);\n}\n\nvec4 voronoi(fxState s, vec2 u)\n{\n    ivec2 ifc = ivec2(u);\n\tvec2 p = (2. * u - R) / R.y;\n\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(s, int(R.x), ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(ro, fwd, lft, up);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    uvec4 na = uvec4(-1), nb = uvec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 da = vec4(1e6), db = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        uvec4 oa, ob;\n        fxGetClosest(ifc, oa, ob);      \n        sortNbs2(oa, ob, na, nb, da, db, p, w2c, ro, rd);\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint rng = 16u;\n        uint cnt = uint(R.y / 100.);\n\n        for(uint i = 0u; i < cnt; ++i)\n        {\n            uvec4 h0 = hash(uvec4(ifc, iFrame, i) * i);\n            uvec4 oa, ob;\n            fxGetClosest(ifc + ivec2( h0.xy % rng - rng / 2u), oa, ob);      \n            sortNbs2(oa, ob, na, nb, da, db, p, w2c, ro, rd);     \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            uint id = uint(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % g_MaxParticles;\n            insertionSort2(na, nb, da, db, id, p, w2c, ro, rd);\n        }\n    }\n    \n    if (!s.eightNbs) nb = uvec4(-1);\n    return fxSaveClosest(na, nb);\n}\n#endif // FOUR_NBS\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// draw one particle\nvoid renderParticle(uint id, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    fxParticle p = fxGetParticle(id);\n    vec2 t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_RENDER_SIZE));\n    vec3 hit = ro + rd * t.x;\n    float z = t.x; // construct z from t\n    pix.d += t.y - t.x;\n        \n    if (z > 0.)\n    {\n        if (z < pix.t)\n        {\n            pix.bz = pix.z = z * dot(fwd, -rd);\n            pix.t = z;\n        }\n    }\n}\n\n// draw a sett of four particles\nvoid renderFourParticles(uvec4 ids, vec3 fwd, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    for (int j = 0; j < 4; j++)\n    {\n        uint id = ids[j];\n        if (id == -1U || id >= g_MaxParticles) break;\n        renderParticle(id, fwd, ro, rd, pix);\n    }\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec3 ro, fwd, lft, up;\n    fxCalcCamera(fxGetState(), int(R.x), ro, fwd, lft, up);\n\n    vec3 rd = fxCalcRay(u, R, fwd, lft, up);\n    \n    fxGBufferPixel pix;\n    pix.z = 1e6;\n    pix.t = 1e6;\n    pix.d = 0.;\n\n    // render particles\n#if FOUR_NBS\n    uvec4 clo = fxGetClosest(ivec2(u));\n    renderFourParticles(clo, fwd, ro, rd, pix);\n#else\n    uvec4 oa, ob;\n    fxGetClosest(ivec2(u), oa, ob);      \n    renderFourParticles(oa, fwd, ro, rd, pix);\n    renderFourParticles(ob, fwd, ro, rd, pix);\n#endif\n\n    O = fxSaveGBuffer(pix);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Density and depth gaussian blur\n// ---------------------------------------------------------------------------------------\n\n// clips the boundaries of particles, making individual particles look smaller\n// this helps balance out the fact that we render them deeply intersecting, so\n// if we don't make them smaller when separated, they would appear to gain volume\nconst float MIN_DEPTH = .8;\n\n// how far apart a nearby particle can be, in z depth, before it can be blured with us\n// too low, and you will see particle boundaries not blurring together\n// too high, and foreground particles will merge too much with background particles\nconst float BLUR_TOLERANCE_REL = .1;\nconst float BLUR_TOLERANCE_ABS = PARTICLE_RENDER_SIZE * .5;\n\n// kernel from Gaussian Blur by mrharicot\n// https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(float x, float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nfloat invnormpdf(float n, float sigma)\n{\n\treturn sqrt(-2. * log(n * sigma / 0.39894) * sigma * sigma);\n}\n\nvec4 blur(vec2 u)\n{\n    fxGBufferPixel pix = fxGetGBuffer(u);\n    if (pix.d < MIN_DEPTH) return vec4(1e6);\n\n    float sigma = .25 * iResolution.y / abs(pix.z); // blur falloff depends on resolution and depth\n\n    const float kMin = .0001; // min kernel value we care about sampling\n    int mSize = int(ceil(invnormpdf(kMin, sigma))); // compute convolution size that reaches kMin\n    int kSize = (mSize - 1) / 2;\n    pix.d = 0.;\n    pix.bz = 0.;\n\n    float Z = 0.;\n\n    for (int i = -kSize; i <= kSize; ++i)\n    {\n        for (int j = -kSize; j <= kSize; ++j)\n        {\n            float k = normpdf(float(i), sigma) * normpdf(float(j), sigma);\n            if (k < kMin) continue; // save the texture fetch when the kernel is small anyway\n            fxGBufferPixel n = fxGetGBuffer(u + vec2(i, j));\n            \n            if (abs(n.z - pix.z) < BLUR_TOLERANCE_ABS ||\n                abs((n.z - pix.z) / pix.z) < BLUR_TOLERANCE_REL) // exclude pixels not near our z depth\n            {\n                pix.d += k * n.d;\n                pix.bz += k * n.z;\n                Z += k;\n            }\n        }\n    }\n\n    pix.bz /= Z;\n    pix.d /= Z;\n    return fxSaveGBuffer(pix);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState s = fxGetState();\n    if (!s.blur)\n    {\n        fxGBufferPixel pix = fxGetGBuffer(u);\n        if (pix.d < MIN_DEPTH)\n            O = vec4(1e6);\n        else\n            O = fxSaveGBuffer(pix);\n    }\n    else\n        O = blur(u);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}