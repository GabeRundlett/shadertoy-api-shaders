{
    "Shader": {
        "info": {
            "date": "1532687102",
            "description": "iMouse.x changes pshape \nI failed an arrow shaped gradient  optimization (fold and cut theorem approach) and unintentionally made a generalized  owl instead.\ntherefore has lots of defunct arrow code",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttcD4",
            "likes": 2,
            "name": "unintentional owl",
            "published": 3,
            "tags": [
                "huuzi"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "\n//parent: https://www.shadertoy.com/view/XdtBD7\n\n\n//library of often used functions: //ounting,index starts at 0!\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u5(a)(a*.5+.5)\n#define u2(a)(a*2.-1.)\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}\nv0 mav(v2 a){return max(a.z,mav(a.xy));}\nv0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n//max of vector\n#define miv(a)-mav(-a)\n//triangle wave //euclidean grid\n#define tri(a)abs(u2(fract(a)))\n#define grid(a)mav(tri(a))\n//clamp().special clamp.general;//clamp().pseudo.inverse\n#define sat(a)clamp(a,0.,1.)\nv0 sat2(v0 a,v1 m){a=.5*(sign(a)+m.x)*a+m.y;a=(sign(2.-a)+1.)*(a-2.)+2.;return a*.5;}\n//stretch;mirror_centric,most common,atomic\n#define stretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretchMinus;positive values do not change;stretchPlus;negatives do not change.\n#define stretchM(u,m)stretch((u*2.+m),m)*.5\n#define stretchP(u,m)stretch((u*2.-m),m)*.5\n//return squared length of a()\n#define dd(a)dot(a,a)\nv1 perp(v1 a){return v1(-a.y,a.x);}//perpendicular ==90deg rotation\nv0 dotp(v1 a,v1 b){return dot(perp(a),b);}//return [perpendicular dot product],can be useful for distance to line with niormalizedd input\nv0 dLine(v1 p,v1 a,v1 b){p-=a;b-=a;return dd(p-b*sat(dot(p,b)/dd(b)));}//return squared distance of [u] from segment,from [a] to [b]\nvec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n//not sure if aXorB()is correct,but looks useful. //https://en.wikipedia.org/wiki/Alpha_compositing\nvec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n//---trigonometry,rotations and(distance to)Quadratic functions.\n//(distance to quadratic is a cubic with less than 2 intersections==roots)\n#define cs(a)vec2(cos(a),sin(a))\n//mirror p at half rotated axis==cheap SINGLE 2d rotation.\n#define rs(r)mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//golden ratios are the best factors for hashes because;phi.xy-1.=1/phi.xy\n\nconst float PI=3.14159,\n   size=.2,\n   period=1.5;\nvec2 R;\n\n#define rot(a)   mat2(cos(a),-sin(a),sin(a),cos(a))\nfloat easeInOut(float t){ return t<.5 ? 2.*t*t : -1.+(4.-2.*t)*t;}\nfloat angle(float t) { return(floor(t)+ easeInOut(fract(t)))*PI/2.;}\n\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\n\nfloat segment(vec2 p,vec2 a,vec2 b){\n vec2 ab=b-a,ap=p-a;\n return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab),0.0,1.0));\n}\n\nfloat one(vec2 u){return -dot(u-.5,vec2(sqrt(2.)))*.5;}\nfloat two(vec2 u){return u.y-.5;}//neck of afrow\nfloat three(vec2 u){return .25-u.x;}//rectangle stem of arrow\nfloat four(vec2 u){return u.y;}//gradient for central base of arrow\n\n\n//v0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n//rounded box,simple branch m interpolates from euclidean to taxicap.\n//turned into an owl-face-gradient\nfloat o3_(vec2 p,float m){p.x=abs(p.x);p.y-=1.\n ;return smoothstep(2.,1.,miv(p)+m)*(length(p-m)+m-mav(p))+mav(p)//smoothstep contstants made an owl\n ;return step(m,miv(p))*(length(p-m)+m-mav(p))+mav(p)//rounded box,not owl\n ;return mix(mav(p),length(p-m)+m,step(m,miv(p)));//branchless //rounded box,not owl\n //if(-mav(-p)>m)return length(p-m)+m;else return mav(p)\n ;}\n\nfloat raybox(vec2 u){//taxicap distance to ray\n ;u.x=abs(u.x)\n ;return mav(u)\n;}\n\nvec4 Arr(vec2 u\n){\n//u=fract(u)\n ;float x=abs(u.x-.5),y=u.y,p=1./R.y/size\n ;vec4 r=vec4(1)\n ;r.x=raybox(u.yx-2.)\n ;r.y=o3_(u,iMouse.x/iResolution.x)\n ;r=fract(r*4.)\n //;r.x=step(r.x,1.);r.y=step(r.y,1.)\n ;return r;}\n\n\n\n\nfloat arrow(vec2 u){\n u=fract(u);\n float x=abs(u.x-.5),y=u.y,p=1./R.y/size;\n return  smoothstep(-p,p,y<.5 || x<.25 ? y : y-.5) // bases\n   *smoothstep(p,-p,y<.5 ? x-.25 : x-1.+y);// sides\n}\n\nfloat drawArrow(vec2 coords,vec2 offset,float a){\n\n coords=rot(a)*(coords);\n vec2 origin=vec2(.5,.5);\n coords=(coords-origin)*rot(a)+ origin;\n coords=fract(coords);\n coords=rot(a)*(coords-origin) + origin;\n //coords*=rot(a);\n float r=arrow(coords-offset);\n return r;\n}\n\nfloat cell(vec2 U,float a){\n float v=0.;\n v+=drawArrow(U,vec2(0),a);\n //for(int i=0;i<6;i++)\n // v+=drawArrow(U,vec2(i%3-1,i/3),a);\n return v;\n}\n\nvoid mainImage(out vec4 O,vec2 U\n){R=iResolution.xy;\n ;U=3.*(U-.5*vec2(R.x,0))/R.y;\n ;float t=iTime/period,a=angle(t);\n //;int i=int(t)% 4;\n //;if(i%2==1)U+=.5;if(i%2==1)U=-U\n //;O=vec4(cell(U,a))\n ;O=vec4(Arr(U))\n //;O=vec4(cell(U,a))\n //;if(i%2==1)O.xyz=1.-O.xyz\n;}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}