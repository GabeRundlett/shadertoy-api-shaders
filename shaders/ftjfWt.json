{
    "Shader": {
        "info": {
            "date": "1654266967",
            "description": "Colored Art Room",
            "flags": 0,
            "hasliked": 0,
            "id": "ftjfWt",
            "likes": 1,
            "name": "Art Room Colored",
            "published": 3,
            "tags": [
                "art"
            ],
            "usePreview": 0,
            "username": "Charbake",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "struct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct material {\n    vec3 color;\n    int mat_type;\n    float mat_dep_var;\n    float fuzz;\n    float ir;\n};\n\nstruct hitRecord{\n    vec3 point;\n    vec3 normal;\n    float t;\n    bool front;\n    material mat;\n};\n\nbool zero(vec3 direction){\n    float minNum = 1e-8;\n    if (abs(direction.x) < minNum && abs(direction.y) < minNum && abs(direction.z) < minNum){\n        return true;\n    }\n    return false;\n}\n\nbool lambertian(ray r, hitRecord rec, out vec3 attenuation, out ray scatteredRay, material mat){\n    vec3 scatteredDir= rec.normal + normalize(random_in_unit_sphere(g_seed));\n    \n    if (zero(scatteredDir)){\n        scatteredDir = rec.normal;    \n    }\n    scatteredRay = ray(rec.point, scatteredDir);\n    attenuation = mat.color;\n    return true;\n}\n\nvec3 reflect(vec3 v, vec3 n) {\n    return v - 2.*dot(v,n)*n;\n}\n\nvec3 refract(vec3 uv, vec3 n, float etai_over_etat){\n    float cosTheta = min(dot(uv*-1.0, n), 1.0);\n    vec3 rOutPerp =  etai_over_etat * (uv + cosTheta*n);\n    vec3 rOutParallel = -sqrt(abs(1.0 - length(rOutPerp)*length(rOutPerp))) * n;\n    return rOutPerp + rOutParallel;\n}\n\nfloat reflectance(float cosine, float refIdx){\n    float r0 = (1.-refIdx) / (1.+refIdx);\n    float r = r0 * r0;\n    return r + (1.-r)*pow((1.-cosine),5.);\n}\n\nbool dielectric(material m, ray r_in, hitRecord rec, out vec3 attenuation, out ray scattered){\n    attenuation = vec3(1.,1.,1.);\n    float refractionRatio = m.ir;\n    if (rec.front){\n        refractionRatio = 1.0 / m.ir;\n    }\n    vec3 unitDirection = normalize(r_in.direction);\n    \n    float cosTheta = min(dot(-unitDirection, rec.normal), 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    bool cannotRefract = refractionRatio * sinTheta > 1.0;\n    vec3 direction;\n    if (cannotRefract || reflectance(cosTheta, refractionRatio) > rand1(g_seed)){\n        direction = reflect(unitDirection, rec.normal);\n    }\n    else{\n        direction = refract(unitDirection, rec.normal, refractionRatio);\n    }\n    scattered = ray(rec.point, direction);\n    return true;\n}\n\nstruct camera{\n    float aspect_ratio;\n    float viewport_height;\n    float viewport_width;\n    float focal_length;\n    \n    vec3 origin;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 lower_left;\n};\n\nstruct sphereStruct {\n    vec3 center;\n    float radius;\n    material mat;\n};\n\nbool metal(material mat, ray rIn, hitRecord rec, out vec3 attenuation, out ray scattered) {\n    float f = min(mat.fuzz, 1.0);\n    vec3 reflected = reflect(normalize(rIn.direction), rec.normal);\n    scattered = ray(rec.point, reflected + f*random_in_unit_sphere(g_seed));\n    attenuation = mat.color;\n    bool test = (dot(scattered.direction, rec.normal) > 0.);\n    return test;\n}\n\nbool materialScatter(material mat, ray rIn, hitRecord rec, out vec3 attenuation, out ray scattered) {\n    if (mat.mat_type == 8){\n        return lambertian(rIn, rec, attenuation, scattered, mat);\n    }\n    else if (mat.mat_type == 9){\n        return metal(mat, rIn, rec, attenuation, scattered);\n    }\n    else if (mat.mat_type == 10){\n        return dielectric(mat, rIn, rec, attenuation, scattered);\n    } \n    else{\n        return false;\n    }\n}\n\nray getRay(float u, float v, camera c){\n    return ray(c.origin, c.lower_left + u*c.horizontal + v*c.vertical - c.origin);\n}\n\nvoid setFaceNormal(const ray r, vec3 normalOut, out hitRecord rec) {\n    rec.front = dot(r.direction, normalOut) < 0.;\n    if (rec.front){\n        rec.normal = normalOut;\n    }\n    else{\n        rec.normal = -normalOut;\n    }\n}\nvec3 pointAt(float t, ray r)  {\n    return r.origin + t*r.direction;\n}\n \n\nbool sphere(ray r, float min_t, float max_t, out hitRecord temp, sphereStruct s) {\n    vec3 oc = r.origin - s.center;\n    float dir2 = length(r.direction)*length(r.direction);\n    float oc_dir =dot(oc, r.direction);\n    float oc_rad = length(oc) * length(oc) - s.radius*s.radius;\n    float discriminant = oc_dir*oc_dir - dir2*oc_rad;\n   \n    if (discriminant < 0.) return false;\n\n    float sqrtd = sqrt(discriminant);\n   \n    float root = (-oc_dir - sqrtd) / dir2;\n    if (root < min_t || max_t < root){\n       return false;\n    }\n\n    temp.t = root;\n    temp.point = pointAt(temp.t,r);\n    temp.normal = (temp.point - s.center)/s.radius;\n    vec3 outward_normal = (temp.point - s.center) / s.radius;\n    setFaceNormal(r, outward_normal, temp);\n    temp.mat = s.mat;\n    return true;\n   \n}\n\nbool hit(ray r, float minT, float maxT, inout hitRecord rec, sphereStruct s[9], int spheres) {\n   hitRecord temp;\n   bool hitCheck = false;\n   float closest = maxT;\n   \n   for (int i=0; i < spheres; i++){\n      if (sphere(r, minT, closest, temp, s[i])){\n          hitCheck = true;\n          closest = temp.t;\n          rec = temp;\n       }\n   }\n   return hitCheck;\n}\n\nbool rayColorHelper(out ray r, int depth, out vec3 result, out vec3 attenTotal) {\n    if (depth <= 0){\n        result = vec3(0., 0., 0.);\n        return false;\n    }\n    const int spheres = 9;\n    sphereStruct[spheres] sphereArray;\n    sphereArray[0] = sphereStruct(vec3(0., -100.5, -1.), 100., material(vec3(0.1, 0.1, 0.1), 8, 0., 0., 0.));   \n    sphereArray[1] = sphereStruct(vec3(-101.5, 0.0, -1.), 100., material(vec3(0.0, 0.9, 0.9), 8, 0., 0., 0.));   \n    sphereArray[2] = sphereStruct(vec3(101.5, 0.0, -1.), 100., material(vec3(0., 0.9, 0.9), 8, 0., 0., 0.));\n    sphereArray[3] = sphereStruct(vec3(0.0, 2.0, 120.), 100., material(vec3(0.,0.9,0.9), 8, 0., 0., 0.));\nsphereArray[4] = sphereStruct(vec3(0.19,1.07,3.0),0.09, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[5] = sphereStruct(vec3(-0.16,1.19,3.0),0.12, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[6] = sphereStruct(vec3(0.19,1.17,3.0),0.18, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[7] = sphereStruct(vec3(-0.42,1.12,3.0),0.19, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.)); \nsphereArray[8] = sphereStruct(vec3(-0.18,0.7,3.0),0.14, material(vec3(0.8, 0.8, 0.8),9, 0., 0.0, 1.));\n    \n    hitRecord rec;\n    if (hit(r, 0.001, 1e5, rec, sphereArray, spheres)){\n        ray scattered;\n        vec3 attenuation;\n        if (materialScatter(rec.mat, r, rec, attenuation, scattered)){\n            attenTotal *= attenuation;\n            r = scattered;\n            return true;\n        }\n        result = vec3(0.,0.,0.);\n        return true;\n    }\n   \n    vec3 dir = r.direction;\n    float t = 0.5 *(dir.y + 1.);\n    result = (1. - t)*vec3(1., 1., 1.) + t*vec3(0.5, 0.7, 1.);\n   \n    return false;\n   \n}\n\nvec3 rayColor(ray r, int depth){\n    vec3 result;\n    float count = 0.;\n    int d = depth;\n    vec3 attenTotal = vec3(1.,1.,1.);\n    \n    for (;rayColorHelper(r, d, result, attenTotal); d--);\n    return attenTotal*result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lookfrom = vec3(0.0,0.5,-4.);\n    vec3 lookat = vec3(0.,0.4,0.);\n    vec3 vup = vec3(0.,1.,0.);\n    \n    float vertFieldOfView = 20.;\n    float rads = vertFieldOfView * 3.14159265/180.;\n    float h = tan(rads/2.0);\n    \n    camera c;\n    c.aspect_ratio = 16.0 / 9.0;\n    c.viewport_height = 2.0 * h;\n    c.viewport_width = c.aspect_ratio * c.viewport_height;\n    c.focal_length = 1.0;\n    \n    vec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup,w));\n    vec3 v = cross(w,u);\n    \n    \n    c.origin = lookfrom;\n    c.horizontal = c.viewport_width * u;\n    c.vertical = c.viewport_height * v;\n    c.lower_left = c.origin - (c.horizontal/2.) - (c.vertical/2.) - w;\n   \n    int samples_per_pixel = 40;\n    const int max_depth = 20;\n    vec3 finColor = vec3(0., 0., 0.);\n    init_rand(fragCoord, iTime);\n   \n    for (int s = 0; s < samples_per_pixel; s++){\n        float x = (fragCoord.x + rand1(g_seed))/ (float(iResolution.x) - 1.);\n        float y = (fragCoord.y + rand1(g_seed))/ (float(iResolution.y) - 1.);\n        ray r = getRay(x, y, c);\n        vec3 color = rayColor(r, max_depth);\n        finColor += color * (1./float(samples_per_pixel));\n    }\n    fragColor = vec4(sqrt(finColor), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}