{
    "Shader": {
        "info": {
            "date": "1671839214",
            "description": "Yeah, so I uh, I made a 2D sdf out of a collection of projected 3D points, kind of silly, right? Oh yeah and the coloring code is a little messy (just a little)",
            "flags": 0,
            "hasliked": 0,
            "id": "dtfGD7",
            "likes": 18,
            "name": "2D 3D SDF of a Fibonacci Sphere",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 416
        },
        "renderpass": [
            {
                "code": "// An experiment into fibonacci spheres, originally was going to be just dots but that idea\n// was thrown out of the window pretty quickly\n\n#define FOCAL_LEN 1.\n\nmat2 rotMat(float r){ return  mat2(cos(r), -sin(r), sin(r), cos(r)); }\n\nvec3 rotX(vec3 p, float r)\n{\n    p.yz *= rotMat(r); return p;\n}\n\nvec3 rotY(vec3 p, float r)\n{\n    p.xz *= rotMat(r); return p;\n}\n\nvec3 rotZ(vec3 p, float r)\n{\n    p.xy *= rotMat(r); return p;\n}\n\nvec3 project(vec3 p)\n{\n    return vec3((p.xy*FOCAL_LEN), 1.)/(FOCAL_LEN+p.z);\n}\n\nfloat fibonacciSphere(vec2 p, float iter, float size)\n{\n    float st = 2./iter;\n    float d = 1e20;\n    float j = 0.;\n    for(float i = -1.; i < 1.; i += st)\n    {\n        float r = sqrt(1. - i*i);\n        float t = j*2.399963;\n        vec3 fp = vec3(cos(t)*r, i, sin(t)*r)*0.5;\n        fp = rotY(fp, -iTime*0.5);\n        fp = rotX(fp, -iTime*0.3);\n        vec3 projected = project(fp);\n        float dist = distance(p, projected.xy)-size*projected.z;\n        //if(fp.z < FOCAL_LEN)\n        d = min(d, dist);\n        j++;\n    }\n    return d;\n}\n\nfloat map(vec2 uv)\n{\n    return fibonacciSphere(uv, 50., 0.05);\n}\n\nvec3 colorSdf(vec2 uv, vec4 m, float px)\n{\n    #define PERIOD 200.\n    #define STR 0.2\n    #define STROKE_WIDTH 0.005\n    #define MOUSE_WIDTH 0.005\n    float d = map(uv);\n    float md = abs(map(m.xy));\n    vec3 col = mix(vec3(0.094,0.494,0.988), vec3(1.000,0.082,0.980), sign(d)*0.5+0.5);\n    col *= smoothstep(-px*PERIOD, px*PERIOD, cos(d*PERIOD))*STR+1.-STR;\n    col = mix(col, vec3(1), smoothstep(STROKE_WIDTH+px, STROKE_WIDTH-px, abs(d)));\n    if(m.z > 0.)\n    {\n        float mdc = smoothstep(px, -px, min(abs(distance(m.xy, uv)-md+MOUSE_WIDTH)-MOUSE_WIDTH, distance(m.xy, uv)-MOUSE_WIDTH*2.));\n        col = mix(col, vec3(1.000,0.875,0.000), mdc);\n    }\n    col /= d+1.;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec4 m = vec4((iMouse.xy*2.-iResolution.xy)/iResolution.y, iMouse.zw);\n    float px = 1.5/iResolution.y;\n\n    vec3 col = vec3(colorSdf(uv, m, px));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}