{
    "Shader": {
        "info": {
            "date": "1682033238",
            "description": "Automatic projector blending masks generation example",
            "flags": 0,
            "hasliked": 0,
            "id": "dldGR4",
            "likes": 2,
            "name": "Smooth Blending Mask",
            "published": 3,
            "tags": [
                "projectionmapping"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "screenSpaceQuad randomQuad(float t, vec2 pos, float w, float h, float randomness)\n{\n    screenSpaceQuad quad;\n    float rdm = randomness;\n    quad.a = pos + vec2(0.+sin(t*0.120)*rdm,0.+cos(t*0.143)*rdm);\n    quad.b = pos + vec2(w +cos(t*0.102)*rdm,0.+cos(t*0.107)*rdm);\n    quad.c = pos + vec2(w +sin(t*0.096)*rdm,h +sin(t*0.112)*rdm);\n    quad.d = pos + vec2(0.+sin(t*0.134)*rdm,h +cos(t*0.123)*rdm);\n    \n    return quad;\n}\n\nCam setupPerspectiveCamera()\n{\n    Cam kCam;\n    kCam.O = vec3(0,0,0);\n    kCam.R = vec3(1,0,0);\n    kCam.U = vec3(0,1,0);\n    kCam.D = vec3(0,0,-1);\n    return kCam;\n}\n\nfloat calcBlendingMask_surfaceSpace(vec2 surfaceUV, screenSpaceQuad ssQuad, screenSpaceQuad ssQuad_other)\n{\n    float self_w = maskWeight(surfaceUV, ssQuad);\n    float other_w = maskWeight(surfaceUV, ssQuad_other);\n    return self_w/(self_w+other_w);\n}\n\nfloat calcBlendingMask_projectorSpace(vec2 maskUV, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad, screenSpaceQuad ssQuad_other)\n{\n    Cam perspectiveCam = setupPerspectiveCamera();\n    vec2 surface_uv = inversePerspective_uv(perspectiveCam, maskUV, ssQuad, wsQuad);\n    return calcBlendingMask_surfaceSpace(surface_uv, ssQuad, ssQuad_other);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y/iResolution.x;\n\tvec2 uv = -vec2(0.5,0.3)+2.0*fragCoord.xy / iResolution.xx;\n   \n    Cam perspectiveCam = setupPerspectiveCamera();\n   \n    screenSpaceQuad quad1 = randomQuad(iTime, vec2(0,0), 1., h, 0.2);\n    worldSpaceQuad wsQuad1;\n    resolvePerspective(perspectiveCam,quad1,wsQuad1);\n    \n    screenSpaceQuad quad2 = randomQuad(iTime*1.764+2., vec2(0.5,0), 1., h, 0.1);\n    worldSpaceQuad wsQuad2;\n    resolvePerspective(perspectiveCam,quad2,wsQuad2);\n    \n    fragColor = vec4(0,0,0,1);\n    \n    float totalCoverage = 0.;\n    float c1 = 0.;\n    if(!isOutside(uv,quad1) && int(iTime)%3!=1 )\n    {\n        float mask = calcBlendingMask_surfaceSpace(uv, quad1, quad2);\n        totalCoverage += mask;\n    }\n    \n    float c2 = 0.;\n    if(!isOutside(uv,quad2) && int(iTime)%3!=2)\n    {\n        float mask = calcBlendingMask_surfaceSpace(uv, quad2, quad1);\n        totalCoverage += mask;\n    }\n    \n    fragColor.rgb += vec3(1,1,1)*totalCoverage;\n    \n    //Precision test : make sure the sum of both projectors does not exceed 1.0 (with \n    float eps = 0.0001;\n    if(totalCoverage > (1.0+eps))\n    {\n        //Magenta if total light exceeds 1.0\n        fragColor.rgb = vec3(1,0,1);\n    }\n    \n    const float maskScale = 5.;\n    \n    //Calc Projector 1 mask\n    vec2 left_mask_uv = fragCoord.xy*maskScale/iResolution.xy;\n    if(left_mask_uv.x<1. && left_mask_uv.y<1.)\n    {\n        float mask = calcBlendingMask_projectorSpace(left_mask_uv, quad1, wsQuad1, quad2);\n        fragColor = vec4(vec3(1,1,1)*mask,1);\n        return;\n    }\n    \n    //Calc Projector 2 mask\n    vec2 right_mask_uv = fragCoord.xy*maskScale/iResolution.xy-vec2(maskScale-1.,0);\n    if(right_mask_uv.x>0. && right_mask_uv.y<1.)\n    {\n        float mask = calcBlendingMask_projectorSpace(right_mask_uv, quad2, wsQuad2, quad1);\n        fragColor = vec4(vec3(1,1,1)*mask,1);\n        return;\n    }\n    \n    float lineThickness = 0.005;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1,0,0), smoothstep(lineThickness,0., distanceToQuadEdge(uv,quad1)));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0,1,0), smoothstep(lineThickness,0., distanceToQuadEdge(uv,quad2)));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "struct Cam { vec3 R; vec3 U; vec3 D; vec3 O;}; //R=Right, U=Up, D=Direction, O=Origin\nstruct screenSpaceQuad{ vec2 a; vec2 b; vec2 c; vec2 d; };\nstruct worldSpaceQuad{  vec3 a; vec3 b; vec3 c; vec3 d; };\n\n//Function to cast a ray through a given coordinate (uv) on the image plane.\n//It returns the direction of a 3D Ray.\n//Note : screen center is uv=[0,0]\nvec3 ray(vec2 uv, Cam cam)\n{\n    return normalize(uv.x*cam.R+uv.y*cam.U+cam.D);\n}\n\n//Function which does the opposite of the previous function:\n//It receives a 3D world space position, then flattens it on the image plane \n//and returns its [uv] coordinates.\n//Note : screen center is uv=[0,0]\nvec2 camProj(Cam c, vec3 p)\n{\n    p = p-c.O;\n    float cZ = dot(p,c.D);\n    float cX = dot(p,c.R);\n\tfloat cY = dot(p,c.U);\n    return vec2(cX/cZ,cY/cZ);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nbool isOutside(vec2 uv, screenSpaceQuad quad)\n{\n    //Note: a is bottom_left, b is bottom_right, c is top_right, d is top_left\n    return dot( (quad.c-quad.b).yx*vec2(-1,1), uv-quad.c) < 0.\n        || dot( (quad.b-quad.a).yx*vec2(-1,1), uv-quad.b) < 0.\n    \t|| dot( (quad.a-quad.d).yx*vec2(-1,1), uv-quad.a) < 0.\n    \t|| dot( (quad.d-quad.c).yx*vec2(-1,1), uv-quad.d) < 0.;\n}\n\nfloat distanceToQuadEdge(vec2 uv, screenSpaceQuad quad)\n{\n    float d1 = distanceToLineSeg(uv, quad.c, quad.b);\n    float d2 = distanceToLineSeg(uv, quad.b, quad.a);\n    float d3 = distanceToLineSeg(uv, quad.a, quad.d);\n    float d4 = distanceToLineSeg(uv, quad.d, quad.c);\n    \n    return min(d1,min(d2,min(d3,d4)));\n}\n\nfloat smoothInternalQuadGrad(vec2 uv, screenSpaceQuad quad)\n{\n    float d1 = distanceToLineSeg(uv, quad.c, quad.b);\n    float d2 = distanceToLineSeg(uv, quad.b, quad.a);\n    float d3 = distanceToLineSeg(uv, quad.a, quad.d);\n    float d4 = distanceToLineSeg(uv, quad.d, quad.c);\n    \n    //Note : a parameter controls smoothness (and scales value)\n    float a = 0.01;\n    float NORMALIZATION_TERM = log((1.+a)/a);\n    d1 = log((d1+a)/a)/NORMALIZATION_TERM;\n    d2 = log((d2+a)/a)/NORMALIZATION_TERM;\n    d3 = log((d3+a)/a)/NORMALIZATION_TERM;\n    d4 = log((d4+a)/a)/NORMALIZATION_TERM;\n    return d1*d2*d3*d4;\n}\n\nfloat maskWeight(vec2 uv, screenSpaceQuad quad)\n{\n    if(isOutside(uv,quad))\n    {\n        return 0.0;\n    }\n    else\n    {\n        return smoothInternalQuadGrad(uv,quad);\n    }\n}\n\n//Utility function returning the intersection point of two 2D lines\n//[p1a,p1b] = line1\n//[p2a,p2b] = line1\nvec2 lineLineIntersection(vec2 p1a, vec2 p1b, vec2 p2a, vec2 p2b)\n{\n    vec2 d1 = (p1b-p1a); //Direction Line 1\n    vec2 d2 = (p2b-p2a); //Direction Line 2\n    vec2 d1n = vec2(d1.y, -d1.x); //orthogonal line to d1 (normal), optimal direction to reach d1 from anywhere\n    float dist = dot(p1a-p2a,d1n);//projection on the optimal direction = distance\n    float rate = dot(d2,d1n); //rate : how much is our d2 line in the optimal direction? (<=1.0)\n    float t = 10000000.0 ; //INFINITY! (rare parallel case)\n    if(rate != 0.0)\n\t\tt = dist/rate; //Starting from p2a, find the distance to reach the other line along d2.\n    return p2a+t*d2;  //start point + distance along d2 * d2 direction = intersection.\n}\n\n//Utility function to compute the distance along a ray to reach a plane, in 3D.\n//The value returned is the distance along ray to the plane intersection.\n//o = ray origin\n//d = ray direction\n//po = plane origin\n//pn = plane normal\nfloat rayPlaneIntersec(vec3 o, vec3 d, vec3 po, vec3 pn) \n{\n    //Same principle as lineLineIntersection() :\n    //\"How far is the plane\"/\"approach rate\".\n    //No need to normalize pn, as dot product above and under cancel out and do not scale the result.\n    return dot(po-o,pn)/dot(d,pn);\n}\n\n//perspectiveCam : the camera from which the points in screen space come from\n//P1 : known world space position of p1\n//p1 : screen space p1 (which is resolved, already)\n//p2 : screen space p2 (which must be adjacent to p1 - cannot be the opposite corner)\n//parallel_a : first point (screen space) in the other line parallel to (p1,p2)\n//parallel_b : second point (screen space) in the other line parallel to (p1,p2)\nvec3 resolveAdjacentCorner(in Cam perspectiveCam, vec3 P1, vec2 p1_resolved, vec2 p2_adjacent, vec2 parallel_a, vec2 parallel_b)\n{\n    //screen space intersection (vanishing point on the projection plane)\n    vec2 ssIntersec = lineLineIntersection(p1_resolved,p2_adjacent,parallel_a,parallel_b);\n    //Vanishing point direction, from camera, in world space.\n    vec3 dirVanishingPoint = ray(ssIntersec, perspectiveCam);\n    vec3 p1_to_p2 = dirVanishingPoint; //Since vanishing point is at \"infinity\", p1_to_p2 == dirVanishingPoint\n    vec3 r2 = ray(p2_adjacent, perspectiveCam);//Ray from camera to p2, in world space\n    \n    //<Line3D intersection : where p1_to_p2 crosses r2>\n    //(Note : this could probably be made simpler with a proper 3D line intersection formula)\n    //Find (rb,p1_to_p2) intersection:\n    vec3 n_cam_p1_p2 = cross(p1_to_p2,r2); //normal to the triangle formed by point p1, point p2 and the camera origin\n    vec3 n_plane_p2 = cross(n_cam_p1_p2,r2); //normal to the plane which is crossed by line p1-p2 at point p2\n    float t = rayPlaneIntersec(P1,p1_to_p2,perspectiveCam.O,n_plane_p2);\n    vec3 p2_ws = P1+t*p1_to_p2;\n    //</Line3D intersection>\n    return p2_ws;\n}\n    \n//Finds each corner, one by one.\nvoid resolvePerspective(in Cam perspectiveCam, in screenSpaceQuad ssQuad, out worldSpaceQuad wsQuad)\n{\n    vec3 ra = ray(ssQuad.a, perspectiveCam); //Find the direction of the ray passing by point a in screen space.\n\t                                      //For the sake of simplicity, screenspace [uv.x,uv.y] = worldspace [x,y]. Z = depth.\n    //Let's place point a in an arbitrary position along the ray ra. \n    //It does not matter at which distance exactly, as it is the relationship between\n    //the corners that is important. The first corner distance simply defines the scaling of the 3D scene.\n    wsQuad.a = perspectiveCam.O + 5.5*ra; //5.5 = arbitrary scaling. Projective geometry does not preserve world space scaling.\n    wsQuad.b = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.b, ssQuad.c, ssQuad.d);\n    wsQuad.c = resolveAdjacentCorner(perspectiveCam, wsQuad.b, ssQuad.b, ssQuad.c, ssQuad.a, ssQuad.d);\n    wsQuad.d = resolveAdjacentCorner(perspectiveCam, wsQuad.a, ssQuad.a, ssQuad.d, ssQuad.b, ssQuad.c);\n}\n\n\n//wsQuad.a = origin (lower left corner)\n//wsQuad.a,b,c,d = CCW point order.\nvec2 findParallelogramUV(vec3 o, vec3 d, worldSpaceQuad wsQuad)\n{\n    //Note : This is tricky because axis are not orthogonal.\n    vec3 uvX_ref = wsQuad.b-wsQuad.a; //horitonal axis\n    vec3 uvY_ref = wsQuad.d-wsQuad.a; //vertical axis\n    vec3 quadN = cross(uvY_ref,uvX_ref);\n    float t = rayPlaneIntersec(o, d, wsQuad.a, quadN);\n        \n    vec3 p = o+t*d;\n    vec3 X0_N = cross(uvY_ref,quadN);\n    vec3 Y0_N = cross(uvX_ref,quadN);\n    \n    //Vertical component : find the point where plane X0 is crossed\n    float t_x0 = rayPlaneIntersec(p, uvX_ref, wsQuad.a, X0_N);\n    vec3 pY = p+t_x0*uvX_ref-wsQuad.a;\n    //Horizontal component : find the point where plane Y0 is crossed\n    float t_y0 = rayPlaneIntersec(p, uvY_ref, wsQuad.a, Y0_N);\n    vec3 pX = p+t_y0*uvY_ref-wsQuad.a;\n    \n    //All is left to find is the relative length ot pX, pY compared to each axis reference\n    return vec2(dot(pX,uvX_ref)/dot(uvX_ref,uvX_ref),\n\t            dot(pY,uvY_ref)/dot(uvY_ref,uvY_ref));\n}\n\nvec2 inversePerspective_uv(Cam perspectiveCam, vec2 uv_01, screenSpaceQuad ssQuad, worldSpaceQuad wsQuad )\n{\n    vec3 x_ws = wsQuad.b-wsQuad.a;\n    vec3 y_ws = wsQuad.d-wsQuad.a;\n    vec3 p_ws = wsQuad.a+uv_01.x*x_ws + uv_01.y*y_ws;\n    vec2 puv = camProj(perspectiveCam,p_ws);\n\treturn puv;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}