{
    "Shader": {
        "info": {
            "date": "1536332983",
            "description": "These shaders are my implementation of the ray/path tracer described in the book \"Raytracing in one weekend\" by Peter Shirley. Note: I didn't implement Perlin noise but used value noise instead.",
            "flags": 32,
            "hasliked": 0,
            "id": "4tGcWD",
            "likes": 18,
            "name": "RIOW 2.06: Rectangles and lights",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "tracer",
                "one",
                "in",
                "path",
                "weekend"
            ],
            "usePreview": 0,
            "username": "reinder",
            "viewed": 3486
        },
        "renderpass": [
            {
                "code": "// Ray tracing: the next week, chapter 6: Rectangles and lights. Created by Reinder Nijhoff 2018\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tGcWD\n//\n// These shaders are my implementation of the raytracer described in the (excellent) \n// book \"Ray tracing in one weekend\" and \"Ray tracing: the next week\"[1] by Peter Shirley \n// (@Peter_shirley). I have tried to follow the code from his book as much as possible, but \n// I had to make some changes to get it running in a fragment shader:\n//\n// - There are no classes (and methods) in glsl so I use structs and functions instead. \n//   Inheritance is implemented by adding a type variable to the struct and adding ugly \n//   if/else statements to the (not so overloaded) functions.\n// - The scene description is procedurally implemented in the world_hit function to save\n//   memory.\n// - The color function is implemented using a loop because it is not possible to have a \n//   recursive function call in glsl.\n// - Only one sample per pixel per frame is calculated. Samples of all frames are added \n//   in Buffer A and averaged in the Image tab.\n//\n// Besides that, I also made some other design choices. Most notably:\n//\n// - In my code ray.direction is always a unit vector so I could clean up the rest of\n//   the code by removing some implicit normalizations.\n// - Cosine weighted hemisphere sampling is used for the Lambertian material.\n//\n// You can find the raytracer / pathtracer in Buffer A.\n//\n// = Ray tracing in one week =\n// Chapter  7: Diffuse                           https://www.shadertoy.com/view/llVcDz\n// Chapter  9: Dielectrics                       https://www.shadertoy.com/view/MlVcDz\n// Chapter 11: Defocus blur                      https://www.shadertoy.com/view/XlGcWh\n// Chapter 12: Where next?                       https://www.shadertoy.com/view/XlycWh\n//\n// = Ray tracing: the next week =\n// Chapter  6: Rectangles and lights             https://www.shadertoy.com/view/4tGcWD\n// Chapter  7: Instances                         https://www.shadertoy.com/view/XlGcWD\n// Chapter  8: Volumes                           https://www.shadertoy.com/view/XtyyDD\n// Chapter  9: A Scene Testing All New Features  https://www.shadertoy.com/view/MtycDD\n//\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Ray tracing: the next week, chapter 6: Rectangles and lights. Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tGcWD\n//\n// These shaders are my implementation of the raytracer described in the (excellent) \n// book \"Ray tracing in one weekend\" and \"Ray tracing: the next week\"[1] by Peter Shirley \n// (@Peter_shirley). I have tried to follow the code from his book as much as possible.\n//\n// [1] http://in1weekend.blogspot.com/2016/01/ray-tracing-in-one-weekend.html\n//\n\n#define MAX_FLOAT 1e5\n#define EPSILON 0.0001\n#define MAX_RECURSION (6+min(0,iFrame))\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n#define DIFFUSE_LIGHT 3\n\n#define SPHERE 0\n#define MOVING_SPHERE 1\n#define BOX 2\n\n#define SOLID 0\n#define NOISE 1\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n//\n// Noise functions by Inigo Quilez:\n// https://www.shadertoy.com/view/4sfGzS\n//\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return 2. * fract( p.x*p.y*p.z*(p.x+p.y+p.z) ) - 1.;\n}\n\nfloat noise(const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat fbm(const in vec3 p, const in int octaves) {\n    float accum = 0.;\n    vec3 temp_p = p;\n    float weight = 1.;\n     \n    for (int i=0; i<octaves; i++) {\n        accum += weight * noise(temp_p);\n        weight *= .5;\n        temp_p *= 2.;\n    }\n    return abs(accum);\n}\n\n//\n// Ray trace helper functions\n//\n\nfloat schlick(float cosine, float ior) {\n    float r0 = (1.-ior)/(1.+ior);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \n                      out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else { \n        return false;\n    }\n}\n\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = hash2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n//\n// Ray\n//\n\nstruct ray {\n    vec3 origin, direction;\n    float time;\n};\n\n//\n// Texture\n//\n\nstruct texture_ {\n    int type;\n    vec3 v;\n};\n\nvec3 texture_value(const in texture_ t, const in vec3 p) {\n    if (t.type == SOLID) {\n\t    return t.v;\n    } else if (t.type == NOISE) {\n        return vec3(.5*(1. + sin(t.v.x*p.z + 5.*fbm((t.v.x*.5)*p, 7))));\n    }\n}\n\n#define NO_TEX texture_(SOLID,vec3(0))\n\n//\n// Material\n//\n\nstruct material {\n    int type;\n    texture_ albedo;\n    texture_ emit;\n    float v;\n};\n\n//\n// Hit record\n//\n\nstruct hit_record {\n    float t;\n    vec3 p, normal;\n    material mat;\n};\n\nbool material_scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, \n                      out ray scattered) {\n    if(rec.mat.type == LAMBERTIAN) {\n        scattered = ray(rec.p, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.time);\n        attenuation = texture_value(rec.mat.albedo, rec.p);\n        return true;\n    } else if(rec.mat.type == METAL) {\n        vec3 rd = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.time);\n        attenuation = texture_value(rec.mat.albedo, rec.p);\n        return true;\n    } else if(rec.mat.type == DIELECTRIC) {\n        vec3 outward_normal, refracted, \n             reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1);\n        if (dot(r_in.direction, rec.normal) > 0.) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, rec.normal);\n            cosine = sqrt(1. - rec.mat.v*rec.mat.v*(1.-cosine*cosine));\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1. / rec.mat.v;\n            cosine = -dot(r_in.direction, rec.normal);\n        }\n        \n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.;\n        }\n        \n        if (hash1(g_seed) < reflect_prob) {\n            scattered = ray(rec.p, reflected, r_in.time);\n        } else {\n            scattered = ray(rec.p, refracted, r_in.time);\n        }\n        return true;\n    }\n    return false;\n}\n\nvec3 material_emitted(const in hit_record rec) {\n    if (rec.mat.type == DIFFUSE_LIGHT) {\n        return texture_value(rec.mat.emit, rec.p);\n    } else {\n        return vec3(0);\n    }\n}\n\n//\n// Hitable\n//\n\nstruct hitable {\n    int type;\n    vec3 center, v3; // v3 is speed for moving sphere (with center at t=0) \n                     //    or dimensions for box.\n    float v;         // Radius for sphere.\n};\n    \n\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max,\n                      const in vec3 center, const in float radius, inout float dist) {\n\tvec3 oc = r.origin - center;\n    float b = dot(oc, r.direction);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - c;\n    if (discriminant < 0.0) return false;\n\n\tfloat s = sqrt(discriminant);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\tfloat t = t1 < t_min ? t2 : t1;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\nbool box_intersect(const in ray r, const in float t_min, const in float t_max,\n                   const in vec3 center, const in vec3 rad, out vec3 normal, inout float dist) {\n    vec3 m = 1./r.direction;\n    vec3 n = m*(r.origin - center);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return false;\n    \n    float t = tN < t_min ? tF : tN;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t\tnormal = -sign(r.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) {\n    \n    if(hb.type == SPHERE || hb.type == MOVING_SPHERE) {\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.time * hb.v3;\n        float radius = hb.v;\n        float dist;\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\n            rec.t = dist;\n            rec.p = r.origin + dist*r.direction;\n            rec.normal = (rec.p - center) / hb.v;\n            return true;\n        } else {\n            return false;\n        }\n    } else { // box\n        float dist;\n        vec3 normal;\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\n            rec.t = dist;\n            rec.p = r.origin + dist*r.direction;\n            rec.normal = normal;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n//\n// Camera\n//\n\nstruct camera {\n    vec3 origin, lower_left_corner, horizontal, vertical, u, v, w;\n    float time0, time1, lens_radius;\n};\n\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist, const in float time0, const in float time1) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    cam.time0 = time0;\n    cam.time1 = time1;\n    return cam;\n}\n    \nray camera_get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\n               mix(c.time0, c.time1, hash1(g_seed)));\n}\n\n//\n// Color & Scene\n//\n\nbool world_hit(const in ray r, const in float t_min, \n               const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n    const material perlin = material(LAMBERTIAN, texture_(NOISE,vec3(4.)), NO_TEX,0.);\n    const material light  = material(DIFFUSE_LIGHT, NO_TEX, texture_(SOLID,vec3(4.)),0.);\n    \n  \tif (hitable_hit(hitable(SPHERE, vec3(0,-1000,0), vec3(0), 1000.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=perlin;\n\n  \tif (hitable_hit(hitable(SPHERE, vec3(0,2,0), vec3(0), 2.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=perlin;\n\n  \tif (hitable_hit(hitable(SPHERE, vec3(0,7,0), vec3(0), 2.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;\n\n  \tif (hitable_hit(hitable(BOX, vec3(4,2,-2), vec3(1,1,0), 2.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;\n    \n    return hit;\n}\n\nvec3 color(in ray r) {\n    vec3 col = vec3(0);\n    vec3 emitted = vec3(0);\n\thit_record rec;\n    \n    for (int i=0; i<MAX_RECURSION; i++) {\n    \tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            vec3 emit = material_emitted(rec);\n            emitted += i == 0 ? emit : col * emit;\n            \n            if (material_scatter(r, rec, attenuation, scattered)) {\n                col = i == 0 ? attenuation : col * attenuation;\n                r = scattered;\n            } else {\n                return emitted;\n            }\n\t    } else {\n            return emitted;\n    \t}\n        if(dot(col,col) < 0.0001) return emitted; // optimisation\n    }\n    return emitted;\n}\n\n//\n// Main\n//\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n    if (ivec2(frag_coord) == ivec2(0)) {\n        frag_color = iResolution.xyxy;\n    } else {\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n\n        vec2 uv = (frag_coord + hash2(g_seed))/iResolution.xy;\n        float aspect = iResolution.x/iResolution.y;\n        vec3 lookfrom = vec3(25,3.5,6);\n        vec3 lookat = vec3(0,2,0);\n        \n        camera cam = camera_const(lookfrom, lookat, vec3(0,1,0), 20., aspect, .0, 10., 0., 1.);\n        ray r = camera_get_ray(cam, uv);\n        vec3 col = color(r);\n        \n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\n        } else {        \n\t        frag_color = vec4(col,1);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}