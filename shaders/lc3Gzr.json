{
    "Shader": {
        "info": {
            "date": "1714604490",
            "description": "With summer right around the corner the seedlings have just sprouted on this plantation. Uses both FXAA and TAA(Took me a long time implement correctly) for aliasing.",
            "flags": 32,
            "hasliked": 0,
            "id": "lc3Gzr",
            "likes": 10,
            "name": "Happy seedlings",
            "published": 3,
            "tags": [
                "sdf",
                "repetition",
                "fxaa",
                "summer",
                "plant",
                "taa",
                "seedling"
            ],
            "usePreview": 0,
            "username": "Mermersk",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\n// Taken from/credit to https://www.shadertoy.com/view/mtScRc\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\n\nfloat getLuminance(vec3 col) {\n\n    vec3 luminanceCoefficients = vec3(0.2126, 0.7152, 0.0722);\n    return dot(col.rgb, luminanceCoefficients);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texUV = uv;\n    uv = (uv * 2.0) - 1.0;\n\t\n    float ar = iResolution.x/iResolution.y;\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    \n    vec3 fxaaCol = fxaa(iChannel0, texUV, vec2(1.0/iResolution.x, 1.0/iResolution.y)).rgb;\n    \n    //Contrast\n    float contrastVal = 1.0;\n    //col = clamp(contrastVal * (fxaaCol - 0.5) + 0.5, 0.0, 1.0);\n    \n    //Saturation\n    float grayscale = dot(col, vec3(0.299, 0.587, 0.114));\n    float saturation = 1.0;\n    //col = clamp(mix(vec3(grayscale), col, saturation), 0.0, 1.0);\n    \n    fragColor = vec4(fxaaCol, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define a 0.4\n//#define lightPosition vec3(cos(iTime)*5.0, 0.0, sin(iTime)*5.0)\n//#define lightPosition vec3(10.0, 5.0, 10.0)\n#define lightPosition vec3(10.0, 5.0, 10.0)\n#define propRotSpeed 6.0\n\n//A struct that hold both the sdf value and the color\nstruct Surface {\n\tfloat distVal;\n\tvec4 color;\n};\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hashwithoutsine12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nmat2 Rot(float angle) {\n    float s=sin(angle), c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n//Polar distance formula, between 2 points:\nfloat polarDist(vec2 p1, vec2 p2) {\n    return sqrt(p1.x*p1.x + p2.x*p2.x - 2.0*p1.x*p2.x*cos(abs(p2.y - p1.y)));\n}\n\n//returns the distance for each angle to the lemniscate line-position. a controls the size of it.\nfloat basicLemniscate(float angle) {\n    float lemniR = a*a*cos(2.0*angle);\n    return lemniR;\n}\n\n//Distance to the lemniscate of Bernoulli\nfloat lemniscateDist(vec2 puv) {\n   \n   float bracket1 = 0.0;\n   //Its enough to check from 0 to 0.785. (We are only calculating for 1 quadrant(where x and y is +) all other quadrants are mirror of this)\n   float bracket2 = PI*0.25;\n   float midPoint = (bracket1 + bracket2) / 2.0;\n   \n   //Bisection method\n   for (int i = 0; i < 16; i++) {\n        //This is the derivative of polar distance formula where lemniscate equation is injected in for angle2. Found derivative via WolframAlpha.\n        float midPointVal = a*a*puv.x*(sin(puv.y + midPoint) - 3.0*sin(puv.y - 3.0*midPoint)) - 2.0*a*a*a*a*sin(4.0*midPoint);\n        \n        int gsign = midPointVal > 0.0 ? 1 : -1;\n        \n        if (gsign == 1) {\n            bracket2 = midPoint;\n        } else {\n            bracket1 = midPoint;\n        }\n        \n        midPoint = (bracket1 + bracket2) / 2.0;\n   }\n   \n   vec2 posOnLmeniscateClosest = vec2(basicLemniscate(midPoint), midPoint);\n   \n   float d = polarDist(posOnLmeniscateClosest, puv);\n   \n   //Give distance field the right sign, - inside and + outside.\n   vec2 puvCart = vec2(puv.x * cos(puv.y), puv.x * sin(puv.y));\n   vec2 polcCart = vec2(posOnLmeniscateClosest.x * cos(posOnLmeniscateClosest.y), posOnLmeniscateClosest.x * sin(posOnLmeniscateClosest.y));\n   \n   vec2 lemniscateToPos = puvCart - polcCart;\n   d = sign(lemniscateToPos.y) * d;\n   \n   return d;\n\n}\n\n//Extrusion From IQ. Use it for extruding the 2d lemniscate shape and adding veins for the leafes\nfloat opExtrusion( in vec3 p, in float sdf, in float h )\n{\n    float fpz = fract(p.z*1.0);\n    //Carves out a horizontal line on each leave\n    float horizontalLine = smoothstep(-0.4, 0.0, fpz) * (1.0 - smoothstep(0.0, 0.4, fpz));\n    horizontalLine = horizontalLine * 0.0001;\n    \n    //Carves out vertical slightly bended lines\n    float bendFactor = 0.2;\n    float verticalBendedUV = fract(abs(p.x)*25.0 - (pow(abs(p.z*2.0), 1.0 - bendFactor)*10.0));\n    float verticalBendedLine = smoothstep(-0.4, 0.0, verticalBendedUV) * (1.0 - smoothstep(0.0, 0.4, verticalBendedUV));\n    verticalBendedLine = verticalBendedLine * 0.0002;\n    \n    vec2 w = vec2( sdf, abs(p.y) - h - verticalBendedLine - horizontalLine);\n   \n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat gyroid (vec3 p) { return dot(sin(p),cos(p.yzx)); }\n\n//Gyroid nosie found here: https://www.shadertoy.com/view/cl23Wt\nfloat gnoise (vec3 p)\n{   \n    float result = 0.0, b = 0.5;\n    float count = 9.0;\n   \n    for (float i = 0.; i < count; i++)\n    {\n        //p.y -= iTime*0.06 + 16.0 + result*0.5;\n        p.x += iTime*(0.02) + 16.0 + result*0.5;\n       \n        result += gyroid(p/b)*b;\n        b = b / 2.0;\n    }\n    return max(result+0.3, 0.0);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n\n\tif (obj1.distVal < obj2.distVal) {\n\t\treturn obj1;\n\t}\n\t\n\treturn obj2;\n}\n/* opCheapBend from IQ\n\n    Takes in a single axis which we want to bend about/use as input to the bending.\n    Resulting matrix can then be used to bend some of the 2d planes in the 3d scene. \n    \n*/\nmat2 cheapBend(float amount, float axisToBendAbout) {\n    \n    float k = amount;\n    float c = cos(k*axisToBendAbout);\n    float s = sin(k*axisToBendAbout);\n    mat2  m = mat2(c,-s,s,c);\n    return m;\n    \n}\n\nSurface GetDist(vec3 p) {\n    \n    //represents the length of 1 complete coordinate system in the repetition, 4 = a space with range -2 to 2 on eaxh input axis\n    float repLength = 0.5;\n    \n    vec2 id = vec2(floor(p.x * (1.0/repLength)), floor(p.z * (1.0/repLength)));\n    vec3 rp = vec3(mod(p.x, repLength) - repLength*0.5, p.y, mod(p.z, repLength) - repLength*0.5);\n    \n    float cellRandomVal = hashwithoutsine12(id);\n    float cellRandomVal2 = hashwithoutsine12(id + vec2(261.0, 27.0));\n    \n    //Makes the leave curl up by some factor\n    mat2 curlLeave = cheapBend(cellRandomVal*1.0, rp.x);\n    //Wiggles the plant back and forth\n    mat2 wiggleLeave = cheapBend(sin(iTime*cellRandomVal)*0.5, rp.y);\n    rp.xy = curlLeave * rp.xy;\n    rp.yz = wiggleLeave * rp.yz;\n    \n    //tubeHeight is height from the ground\n    float tubeHeight = 0.1 + hashwithoutsine12(id)*0.2;\n    float tubeWidth = 0.006;\n    \n    //float d = sdBox(p - lightPosition, vec3(0.2));\n    \n    vec2 sp = rp.xz;\n    sp = abs(vec2(sp.x, sp.y));\n    float lemniD = lemniscateDist(vec2(length(sp.xy), atan(sp.y, sp.x)));\n    //Take lemniscate from 2d to 3d + add leafy veins\n    float lemniD3 = opExtrusion(vec3(rp.x, rp.y-tubeHeight, rp.z), lemniD, 0.002);\n    \n    vec3 leaveColor = vec3(cellRandomVal2, 1.0, 0.2);\n    Surface finalLeaf = Surface(lemniD3, vec4(leaveColor, 1.0));\n    \n    float stemD = length(rp.xz) - tubeWidth;\n    stemD = max(stemD, rp.y - tubeHeight);\n    Surface stem = Surface(stemD, vec4(0.0, 0.8, 0.0, 1.0));\n    \n    Surface plant = minWithColor(stem, finalLeaf);\n    plant.distVal *= 0.75; //Distance field not quite correct, march in smaller steps...\n    \n    vec4 groundTex = texture(iChannel0, p.xz*2.0);\n    //Use texture to offset the p.xz plane for something that looks like a frarm field\n    Surface ground = Surface(p.y - groundTex.r*0.05 + (sin(p.x*12.56 + 2.0)*0.035), vec4(0.5, 0.15, 0.0, 1.0)); //+ (sin(p.x*14.0 + 1.9)*0.03)\n    \n    Surface wholeScene = minWithColor(plant, ground);\n    \n    return wholeScene;\n}\n\nSurface RayMarch(vec3 ro, vec3 rd) {\n\tSurface wholeScene = Surface(0.0, vec4(1.0));\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*wholeScene.distVal;\n        Surface currScene = GetDist(p);\n        wholeScene.distVal += currScene.distVal;\n        wholeScene.color = currScene.color;\n        \n        if(wholeScene.distVal>MAX_DIST || abs(currScene.distVal)<SURF_DIST) break;\n    }\n    \n    return wholeScene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).distVal - \n        vec3(GetDist(p-e.xyy).distVal, GetDist(p-e.yxy).distVal,GetDist(p-e.yyx).distVal);\n    \n    return normalize(n);\n}\n\n\nfloat specularLightning(vec3 normals, vec3 lightDir, vec3 viewDir) {\n    //Controls strength of specular light, but doesnt really effect its range\n    float specularStrength = 0.15;\n    //Reflect light-direction over the normal vector\n    vec3 rlon = reflect(lightDir, normals);\n    \n    float g = max(0.0, dot(viewDir, rlon));\n    \n    //The power effects its range, lower numbers = greater area but lower intensity, higher number = less area but more intense\n    float spec = pow(g, 12.0);\n    \n    return max(0.0, spec * specularStrength); \n}\n\nvec3 fog(vec3 col, float d, vec3 p, vec3 rd) {\n\n    float nn = gnoise(p);\n    \n    //Adding fog on the ground\n    d = d + nn*4.0;\n    \n    float fogAmount = 1.0 - exp(-d*0.16);\n    \n    vec3 fogColor = vec3(0.65, 0.8, 1.1);\n    \n    vec3 sunColor = vec3(1.2, 1.0, 1.0);\n    \n    float ss = max(0.0, dot(rd, normalize(lightPosition)));\n    \n    fogColor = mix(fogColor, sunColor, pow(ss, 4.0));\n    \n    return mix(col, fogColor, fogAmount);\n    \n}\n\n/*\nfloat shadow(vec3 p, vec3 normal) {\n    \n    int shadowSteps = 33;\n    \n    float s = 1.0;\n   \n    //March towards the light position\n    vec3 rayDir = normalize(lightPosition - p);\n    //Adjust starting position slighlty up the normal so it doesnt immiedeatly return zero\n    vec3 startPos = p + (normal*0.02);\n    \n    float dd = 0.0;\n    \n    for (int i = 0; i < shadowSteps; i++) {\n        vec3 pp = startPos + rayDir * dd;\n        float currDist = GetDist(pp).distVal;\n        \n        dd += currDist;\n        \n        if (currDist < SURF_DIST) {\n            s = 0.0;\n            break;\n        }\n    }\n    \n    return s;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //TAA\n    //Buffer A -> current, Buffer C -> hist\n    vec2 jitter = halton23(iFrame & 15);\n    \n    vec2 uv = (fragCoord + jitter)/iResolution.xy;\n    \n    vec2 ouv = fragCoord/iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n\t\n    float ar = iResolution.x/iResolution.y;\n    \n    uv.x *= ar;\n    \n    vec3 ro = vec3(0.0, 0.6, -5.6);\n    \n    //ro.y += abs(sin(iTime*2.25))*0.3;\n    //ro.z += iTime*0.05;\n    //ro.y += iTime*0.1;\n    //uv.x += cos(iTime*0.15);\n    \n    //ro.y += iTime * 0.1;\n    //uv.y += -0.5;\n    //uv.x += iTime*0.1;\n    \n    /*\n        vec3(uv, 1.0) -> Represents a rectangle/plane in 3d space\n        normalize(vec3(uv, 1.0)) -> Now represents part of a sphere in 3d space, normalization forces it to be unit-spehere like.\n        \n        The vector normalize(vec3(uv, 1.0)) is in view space! Our view matrix here takes these vectors from view space\n        ans places them in world space.\n    */\n    vec3 lookAt = vec3(sin(iTime*0.25)*4.0, -0.75 + cos(iTime*0.2)*0.5, 0.0);\n    vec3 rd = getViewMatrix(ro, lookAt, vec3(0.0, 1.0, 0.0)) * normalize(vec3(uv, 1.0));\n    //rd = inverse(getViewMatrix(ro, lookAt, vec3(0.0, 1.0, 0.0))) * rd;\n    //vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n   \n    Surface d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d.distVal;\n    \n    vec3 n = GetNormal(p);\n \n    vec3 lightPos = lightPosition;\n    vec3 lightDir = normalize(lightPos - p);\n    float dif = max(dot(n, lightDir), 0.0);\n    float specular = specularLightning(n, lightDir, rd);\n    \n    //float shad = shadow(p, n);\n    \n    if(d.distVal<MAX_DIST) {\n        col = (d.color.rgb) * (dif + specular);\n    }\n    \n    col = fog(col, d.distVal, p, rd);\n    \n    //Contrast\n    float contrastVal = 1.2;\n    col = clamp(contrastVal * (col - 0.5) + 0.5, 0.0, 1.0);\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    //Pass on the rayOrigin and lookAt\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        col = ro;\n    }\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        col = lookAt;\n    }\n    \n    fragColor = vec4(col, d.distVal);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Main TAA pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 jitter = halton23(iFrame & 15);\n    vec2 uv = (fragCoord)/iResolution.xy;\n    vec2 ouv = uv;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    float ar = iResolution.x/iResolution.y;\n    \n    uv.x *= ar;\n    \n    //At frame number 0, then buffer C is empty, just continue on\n    if (iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    vec3 currRO = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 lastRO = texelFetch(iChannel1, ivec2(0, 0), 0).xyz;\n    \n    vec3 currLookAt = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    vec3 lastLookAt = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n    \n    float dist = texture(iChannel0, ouv).a;\n    vec3 curRD = getViewMatrix(currRO, currLookAt, vec3(0.0, 1.0, 0.0)) * normalize(vec3(uv, 1.0));\n    vec3 p = currRO + curRD * dist;\n    \n    //vec2 oldUV = viewToUV2(lastRO, iResolution.x/iResolution.y, p);\n    vec2 oldUV = viewToUV3(lastRO, lastLookAt, iResolution.x/iResolution.y, p);\n    \n    vec4 current = texture(iChannel0, ouv);\n    vec3 curCol = current.rgb;\n    vec4 hist = texture(iChannel1, oldUV);\n    vec3 histCol = hist.rgb;\n    \n    //-----------------------------------------------------------------------------------------\n    //Color clamping from https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n    // Arbitrary out of range numbers\n    vec3 minColor = vec3(9999.0);\n    vec3 maxColor = vec3(-9999.0);\n\n    // Sample a 3x3 neighborhood to create a box in color space\n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            vec3 color = texelFetch(iChannel0, ivec2(fragCoord) + ivec2(x, y), 0).rgb; // Sample neighbor\n            minColor = min(minColor, color); // Take min and max\n            maxColor = max(maxColor, color);\n        }\n    }\n\n    // Clamp previous color to min/max bounding box\n    vec3 previousColorClamped = clamp(histCol, minColor, maxColor);\n    //------------------------------------------------------------------------------------------\n    \n    vec3 finalCol = mix(curCol, previousColorClamped, vec3(0.9));\n    \n    //Debug view - See difference in current UV compared to last UV for this same current UV location\n    //finalCol = vec3(abs(ouv - oldUV)*25.0, 0.0);\n    \n    //Pass on what will become the old rayOrigin\n    if (ivec2(fragCoord) == ivec2(0, 0)) {\n        finalCol = currRO;\n    }\n    if (ivec2(fragCoord) == ivec2(1, 0)) {\n        finalCol = currLookAt;\n    }\n    \n    fragColor = vec4(finalCol, dist);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//TAA - History buffer. Keeps moving average of past frames and also keeps the previous frames rayOrigin and lookAt point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    float curDist = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    fragColor = vec4(col, curDist);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n    Author: Mermersk (ic4ruz39@gmail.com)\n*/\n\nmat3 getViewMatrix(vec3 cameraPos, vec3 cameraTarget, vec3 cameraUp)\n{\n    // Calculate the view direction vector\n    vec3 viewDir = normalize(cameraTarget - cameraPos);\n\n    // Calculate the right and up direction vectors\n    vec3 rightDir = normalize(cross(cameraUp, viewDir));\n    vec3 upDir = cross(viewDir, rightDir);\n\n    // Create the view matrix\n    mat3 viewMatrix = mat3(rightDir, upDir, viewDir);\n\n    return viewMatrix;\n}\n\n/*\n\nvec2 viewToUV(vec3 rayOrigin, vec3 rayDir) {\n    \n    mat3 viewMat = inverse(getViewMatrix(rayOrigin, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0)));\n    \n    vec3 uv = viewMat * rayDir;\n    \n    uv /= uv.z;\n    \n    uv = (uv + 1.0) / 2.0;\n    \n    return uv.xy;\n\n}\n\n//Taken and adapted from IQ Rainforest: https://www.shadertoy.com/view/4ttSWf\nvec2 viewToUV2(vec3 rayOrigin, float ar, vec3 rayDir) {\n    \n    mat3 viewMat = getViewMatrix(rayOrigin, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    mat3x4 oldCam = mat3x4( vec4(viewMat[0], -dot(viewMat[0], rayOrigin)),\n                            vec4(viewMat[1], -dot(viewMat[1], rayOrigin)),\n                            vec4(viewMat[2], -dot(viewMat[2], rayOrigin)));\n    \n    vec3 uv = vec4(rayDir, 1.0) * oldCam;\n    \n    uv /= uv.z;\n    \n    uv.x /= ar;\n    \n    uv = (uv + 1.0) / 2.0;\n    \n    return uv.xy;\n\n}\n*/\n/*\n    Function used to reproject world space positions to UV for some rayOrigin&lookAt state of the camera.\n    Takes in: rayOrigin, lookAt and some world space positions. \n*/\nvec2 viewToUV3(vec3 rayOrigin, vec3 lookAt, float ar, vec3 worldPosP) {\n    //Used to get the world positions as they were last frame(worldPosP is current, rayOrigin is the old/last frames rayOrigin)\n    vec3 lastFramesWorldPosP = worldPosP - rayOrigin;\n    /*\n        Note after some learning: This inverse view matrix takes positions from world space and into view space!\n    */\n    mat3 lastFrameViewMatInv = inverse(getViewMatrix(rayOrigin, lookAt, vec3(0.0, 1.0, 0.0)));\n    //Apply the matrix to world space positions.\n    vec3 pView = lastFrameViewMatInv * lastFramesWorldPosP;\n    /*  Not sure why we are dividing by the z-component, is this operation called something specific?\n        In buffer A we get the camera by doing: vec3 rd = getViewMatrix(ro, lookAt, vec3(0.0, 1.0, 0.0)) * normalize(vec3(uv, 1.0));\n        f. ex: the vector (1, 1, 1) when normalized is vec3(0.57735), so its viewMatrix * vec3(0.57735)\n        So now when we have applied the inverse to some world space positions, we get back vec3(0.57735), but we want this to map to vec3(1)\n        so dividing all components by the z component: vec3(0.57735/0.57735) = vec3(1)\n        \n        So we divide by z component her to map it from normalized vector and to a -1 <-> 1 space?\n        \n        Note after some learning: This is called prespective divide.\n    */\n    vec3 uv = pView / pView.z;\n    //Undo the aspect correction.\n    uv.x = uv.x / ar;\n    //Map from -1 <-> 1 to texture UVs space 0 <-> 1\n    uv = (uv + 1.0) / 2.0;\n    \n    return uv.xy;\n}\n\nfloat radicalInverse(int x, float base)\n{\n    int baseI = int(base);\n    float result = 0.0;\n    float b = 1.0 / base;\n    while (x > 0)\n    {\n        result += float(x % baseI) * b;\n        x /= baseI;\n        b /= base;\n    }\n    return result;\n}\n\n//Credit: https://www.shadertoy.com/view/dd2cWh\nvec2 halton23(int index)\n{\n    return vec2(radicalInverse(index, 2.0), radicalInverse(index, 3.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}