{
    "Shader": {
        "info": {
            "date": "1520348501",
            "description": "a simple path tracer",
            "flags": 32,
            "hasliked": 0,
            "id": "XscyD2",
            "likes": 20,
            "name": "MandelboxShrine",
            "published": 3,
            "tags": [
                "fractal",
                "gi",
                "global",
                "pathtracing",
                "mandelbox",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 2019
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if(iFrame>0)\n    {\n        col = texture(iChannel0, uv).xyz;\n        col /= float(iFrame);\n        col = pow(col, vec3(0.45));\n    }\n    \n    col = pow(col, vec3(1.,0.85,0.7));\n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A simple pathtracer for phong model.\n\n#define SAMPLES 1\n#define LIGHT_SAMPLES 1\n#define MAX_DEPTH 4\n\n#define PI 3.1415926\n\nfloat seed;\nfloat rnd() \n{ \n    return fract(sin(seed++)*43758.5453123); \n}\n\nvoid rz(inout vec3 p , float a)  \n{\n\tfloat c, s;\n    vec3 q=p; c=cos(a); s=sin(a);\n    p.x=c*q.x-s*q.y;\n    p.y=s*q.x+c*q.y;\n}\n\nconst float ang = 1.;\nconst mat2 rot = mat2(cos(ang), sin(ang), \n                      -sin(ang), cos(ang));\n\n//==========  mandelbox ===========================\nfloat fixed_radius2 = 2.0;\nfloat min_radius2 = 0.1;\nfloat folding_limit = 1.4;\nfloat scale = 3.;\nvec3 mtl = vec3(0.5, 0.5, 0.6);\nvec4 orb = vec4(1000);\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n\tz.z = mod(z.z + 1.0, 2.0) - 1.0;\n    orb = vec4(1000);\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < 13; ++n) {\n\t\tz.xy = rot*z.xy;\n        \n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 1.;\n\t\torb = min(orb, vec4(abs(z.xyz), dot(z,z)));\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\n\nfloat f(vec3 p){ \n\trz(p, 0.64);\n    return mb(p); \n} \n\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 0.0;\n    float tmax = 1.0;\n    float t = 0.001;\n    for(int i=0; i<30; i++ )\n    {\n        float h = f(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n    if( t>tmax ) res = 1.0;\n    return res;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < 0.0001 || res > 100.)\n            break;\n        t += res;\n    }\n    \n    if(res > 100.) t = -1.;\n    return t;\n}\n\n\nvec3 get_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\treturn normalize(vec3(\n           f(pos+eps.xyy) - f(pos-eps.xyy),\n           f(pos+eps.yxy) - f(pos-eps.yxy),\n           f(pos+eps.yyx) - f(pos-eps.yyx)));\n}\n\nvec3 get_material(vec3 x)\n{\n    float d = f(x);\n\tmtl = mix(mtl, vec3(1.2, 0.8, 0.5), clamp(orb.x*orb.x, 0.0, 1.0));\n\tmtl = mix(mtl, vec3(1.2, 0.4, 0.), clamp(orb.y*orb.y, 0.0, 1.0));\n\tmtl = mix(mtl, 0.1*vec3(0.5, 0.8, 1.0), clamp(orb.z*orb.z, 0.0, 1.0));\n\n    return mtl;\n}\n\nfloat schlick_fresnel(float rs, float cos_theta) \n{\n    return rs + pow(1.0 - cos_theta, 5.) * (1. - rs);\n}\n\n// http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nvoid basis(vec3 n, out vec3 b1, out vec3 b2) \n{\n    if(n.z < -0.999999) {\n        b1 = vec3(0 , -1, 0);\n        b2 = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tb1 = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tb2 = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\n\nvec3 local_to_world(vec3 local_dir, vec3 normal)\n{\n    vec3 a,b;\n    basis(normal, a, b);\n\treturn local_dir.x*a + local_dir.y*b + local_dir.z*normal;\n}\n\nvec3 spherical_to_cartesian(float rho, float phi, float theta) {\n    float sin_theta = sin(theta);\n    return vec3( sin_theta*cos(phi), sin_theta*sin(phi), cos(theta))*rho;\n}\n\nvec3 sample_hemisphere_cos_weighted(vec3 n, float Xi1, float Xi2) \n{\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = 2. * PI * Xi2;\n\n    return local_to_world(spherical_to_cartesian(1.0, phi, theta), n);\n}\n\nvec3 sample_phone_specular(vec3 n, float roughness, float Xi1, float Xi2)\n{\n    float theta = acos(pow(Xi1, 1./(roughness + 1.)));\n    float phi = 2. * PI * Xi2;\n    return local_to_world(spherical_to_cartesian(1., phi, theta), n);\n}\n\n\nvec3 sun_col = 10.0*vec3(1.0,0.8,0.6);\nvec3 sun_dir = normalize(vec3(10.0,3.,-3.));\nvec3 sky_col = vec3(0.02);\nconst float shininess = 32.;\nconst float spec_weight = 0.2;\n\n// standard phong brdf\n// kd*(1./pi) + ks*((n+2)/2pi * (reflect * eye)^n\nvec3 brdf(vec3 p, vec3 n, vec3 wo, vec3 wi)\n{\n    vec3 wh = normalize(wi + wo);\n    float F = schlick_fresnel(0.1, max(0.,dot(wi, wh)));\n    \n    float spe = pow(clamp(dot(wo, reflect(-wi, n)), 0.0, 1.0), shininess);\n    vec3 mtl = get_material(p);\n    \n\tvec3 spec_refl = spe * vec3(1.) * F * ((shininess + 2.)/(2.*PI));                        \n    vec3 diff_refl = mtl * (1. - F) / PI;\n    \n    return mix(diff_refl, spec_refl, spec_weight);\n}\n\n\nvec3 sample_light(vec3 x, vec3 n, vec3 rd, float t)\n{\n    vec3 Lo = vec3(0.);\n    \n    vec3 wi = sun_dir;\n    float light_sampling_pdf = 1.;\n    \n    for(int i = 0; i < LIGHT_SAMPLES; ++i)\n    {        \n        float n_dot_wi = dot(n, sun_dir);\n    \tif(n_dot_wi > 0.00001) \n        {\n        \tfloat sha = shadow(x, wi);\n        \n            // monte carlo estimator\n            Lo += sun_col * brdf(x, n, -rd, wi) * n_dot_wi * sha / light_sampling_pdf;\n        }\n        \n    }\n    Lo /= float(LIGHT_SAMPLES);\n    \n    Lo = mix(Lo, sky_col, 1.0-exp(-0.01*t*t*t)); \n\n    return Lo;\n}\n\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 Lo = vec3(0.); \n\n\tfloat t = intersect(ro, rd);\n    \n    if(t < 0.)\n    {\n        return sky_col;\n    }\n    \n    \n    for(int i = 0; i < MAX_DEPTH; ++i)\n    {\n        vec3 x = ro + t * rd;\n        vec3 n = get_normal(x);\n\n        Lo += sample_light(x, n, rd, t); \n\n        ro = x;\n        \n        float Xi1 = rnd();\n        float Xi2 = rnd();\n\n        // sample the next ray\n        if(rnd() > spec_weight)\n        {\n        \trd = sample_hemisphere_cos_weighted(n, Xi1, Xi2);\n        }\n        else\n        {\n            rd = sample_phone_specular(n, shininess, Xi1, Xi2);\n        }\n        \n        t = intersect(ro, rd);\n        \n        if(t < 0.)\n            break;\n    }\n    \n    return Lo;\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 cf = normalize(ta - ro);\n    vec3 cs = normalize(cross(cf, vec3(0,1,0)));\n    vec3 cu = normalize(cross(cs, cf));\n    return mat3(cs, cu, cf);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\n \tvec3 ta=vec3(-0.1,0.45,0.);\n    vec3 ro = vec3(1.7, .2, -1.6);\n    \n    vec2 offset = -0.5 + vec2(rnd(), rnd());\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+offset)) / iResolution.y;\n\n    mat3 cam = camera(ro, ta);\n    \n    vec3 rd = normalize(cam * vec3(p, 3.));\n    \n \tvec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    if(iFrame==0) col = vec3(0.0);\n    \n    vec3 col_acc = vec3(0.);\n    for(int i = 0; i < SAMPLES; ++i)\n    {\n        col_acc += radiance(ro, rd);\n    }\n    \n    col_acc /= float(SAMPLES);\n     \n   \tcol += col_acc;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}