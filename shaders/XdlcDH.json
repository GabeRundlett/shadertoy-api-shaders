{
    "Shader": {
        "info": {
            "date": "1488031979",
            "description": "This would be a lot easier if 3rd party images could be embedded.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdlcDH",
            "likes": 7,
            "name": "Krabby",
            "published": 3,
            "tags": [
                "pixelart",
                "pokemon",
                "krabby"
            ],
            "usePreview": 0,
            "username": "ChuckNorris",
            "viewed": 833
        },
        "renderpass": [
            {
                "code": "// Code licensed under CC0 or public domain, take your pick.\n// Image by Caribou11 and licensed under \"the creative commons\" [sic]\n// http://piq.codeus.net/picture/59323/krabby\n\nint mod2(int x){\n    // My browser does not support modulo and bitwise-and\n    return x - x/2*2;\n}\n\nint pow2(int exponent){\n    int result = 1;\n    // Fixed size loop for better compatibility.\n    for (int i = 0; i < 32; i++){\n        if (i < exponent) result *= 2;\n    }\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 position = fragCoord.xy/iResolution.xy*2.0 - 1.0;\n    position.x *= iResolution.x/iResolution.y;\n    position = position*16.0 + 16.0;\n    \n    int ix = int(position.x);\n    int iy = int(position.y);\n    \n    // Image size is 32x32, 3 bits per pixel.\n    if (ix < 0 || iy < 0 || ix >= 32 || iy >= 32 || /*bug*/ position.x < 0.0){\n    \t// Background color is white.\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    vec4 color = vec4(1.0);\n    \n    // Each row contains 31 bits.\n    // The sign bit is unused.\n    int rows0[32]; // Bit 0 of each pixel.\n    int rows1[32]; // Bit 1 of each pixel.\n    int rows2[32]; // Bit 2 of each pixel.\n    \n    // I could not make array initializers work with my browser.\n\trows0[0] = 0x01fc000c;\n\trows0[1] = 0x0603c01c;\n\trows0[2] = 0x0801f87e;\n\trows0[3] = 0x1001fffe;\n\trows0[4] = 0x2003fffe;\n\trows0[5] = 0x201efff8;\n\trows0[6] = 0x20fcc7f0;\n\trows0[7] = 0x21c887c0;\n\trows0[8] = 0x1208b9e0;\n\trows0[9] = 0x123147f0;\n\trows0[10] = 0x0a4287f0;\n\trows0[11] = 0x067c96f8;\n\trows0[12] = 0x000345f8;\n\trows0[13] = 0x000425f8;\n\trows0[14] = 0x000399f0;\n\trows0[15] = 0x000040f0;\n\trows0[16] = 0x000040f0;\n\trows0[17] = 0x000399f0;\n\trows0[18] = 0x000425f8;\n\trows0[19] = 0x000345f8;\n\trows0[20] = 0x0c7c96f8;\n\trows0[21] = 0x144287f0;\n\trows0[22] = 0x143147f0;\n\trows0[23] = 0x2208b9e0;\n\trows0[24] = 0x21c887c0;\n\trows0[25] = 0x20fcc7f0;\n\trows0[26] = 0x201efff8;\n\trows0[27] = 0x2003fffe;\n\trows0[28] = 0x1001fffe;\n\trows0[29] = 0x0801f87e;\n\trows0[30] = 0x0603c01c;\n\trows0[31] = 0x01fc000c;\n\trows1[0] = 0x00000000;\n\trows1[1] = 0x01fc0008;\n\trows1[2] = 0x07078014;\n\trows1[3] = 0x0c1ee024;\n\trows1[4] = 0x187c6918;\n\trows1[5] = 0x19e14030;\n\trows1[6] = 0x13010280;\n\trows1[7] = 0x16030000;\n\trows1[8] = 0x0c030080;\n\trows1[9] = 0x0c0639a0;\n\trows1[10] = 0x040c00a0;\n\trows1[11] = 0x00000130;\n\trows1[12] = 0x00008250;\n\trows1[13] = 0x00004250;\n\trows1[14] = 0x000024a0;\n\trows1[15] = 0x00002120;\n\trows1[16] = 0x00002120;\n\trows1[17] = 0x000024a0;\n\trows1[18] = 0x00004250;\n\trows1[19] = 0x00008250;\n\trows1[20] = 0x00000130;\n\trows1[21] = 0x080c00a0;\n\trows1[22] = 0x080639a0;\n\trows1[23] = 0x1c030080;\n\trows1[24] = 0x1e030000;\n\trows1[25] = 0x17010280;\n\trows1[26] = 0x11e14010;\n\trows1[27] = 0x187c6908;\n\trows1[28] = 0x0c1ee004;\n\trows1[29] = 0x07078014;\n\trows1[30] = 0x01fc0008;\n\trows1[31] = 0x00000000;\n\trows2[0] = 0x00000000;\n\trows2[1] = 0x00000000;\n\trows2[2] = 0x00f84000;\n\trows2[3] = 0x03e00840;\n\trows2[4] = 0x07800480;\n\trows2[5] = 0x06000240;\n\trows2[6] = 0x0c020000;\n\trows2[7] = 0x08040000;\n\trows2[8] = 0x00040000;\n\trows2[9] = 0x00083800;\n\trows2[10] = 0x00300300;\n\trows2[11] = 0x00000080;\n\trows2[12] = 0x00000080;\n\trows2[13] = 0x00038080;\n\trows2[14] = 0x00004240;\n\trows2[15] = 0x00001e40;\n\trows2[16] = 0x00001e40;\n\trows2[17] = 0x00004240;\n\trows2[18] = 0x00038080;\n\trows2[19] = 0x00000080;\n\trows2[20] = 0x00000080;\n\trows2[21] = 0x00300300;\n\trows2[22] = 0x00083800;\n\trows2[23] = 0x00040000;\n\trows2[24] = 0x00040000;\n\trows2[25] = 0x08020000;\n\trows2[26] = 0x0e000260;\n\trows2[27] = 0x07800490;\n\trows2[28] = 0x03e00860;\n\trows2[29] = 0x00f84000;\n\trows2[30] = 0x00000000;\n\trows2[31] = 0x00000000;\n    \n    for (int x = 0; x < 32; x++){\n        if (x != ix) continue;\n        \n        // Not sure if variable array indices are allowed.\n        // It works here anyway, so this loop is not necessary on my GPU.\n        // Maybe there are shitty GPUs where it has to be done that way,\n        // but they probably will have other problems like too little memory.\n        int row0 = rows0[x];\n        int row1 = rows1[x];\n        int row2 = rows2[x];\n\n        int p = pow2(iy);\n\n        // This does not work if row0/1/2 are negative.\n        // The image was transposed so this does not happen.\n        int bit0 = mod2(row0/p);\n        int bit1 = mod2(row1/p);\n        int bit2 = mod2(row2/p);\n\n        int bits = bit0 + bit1*2 + bit2*4;\n\n\t\tif (bits == 1) color = vec4(0.000000, 0.000000, 0.000000, 1.000000);\n\t\tif (bits == 2) color = vec4(0.584314, 0.082353, 0.082353, 1.000000);\n\t\tif (bits == 3) color = vec4(0.945098, 0.635294, 0.427451, 1.000000);\n\t\tif (bits == 4) color = vec4(0.933333, 0.133333, 0.133333, 1.000000);\n\t\tif (bits == 5) color = vec4(0.968627, 0.878431, 0.819608, 1.000000);\n\t\tif (bits == 6) color = vec4(0.364706, 0.737255, 0.725490, 1.000000);\n    }\n    \n\tfragColor = color;\n}\n\n\n// Python code to generate image code.\n\n/*\n\nimport numpy as np\nimport scipy.misc\nfrom collections import defaultdict\n\nimage = scipy.misc.imread(\"image.png\")\nimage = np.flipud(image)\nimage = image.transpose([1, 0, 2])\nd = defaultdict(int)\n\nfor row in image:\n    for pixel in row:\n        pixel = tuple(pixel)\n        d[pixel] += 1\n\ne = {}\nindex = 0\ndef second(values):\n    return values[1]\nfor key, value in sorted(d.items(), key=second, reverse=True):\n    e[key] = index\n    index += 1\n\nrows0 = []\nrows1 = []\nrows2 = []\n\nfor row in image:\n    row0 = 0\n    row1 = 0\n    row2 = 0\n    \n    for i, pixel in enumerate(row):\n        pixel = tuple(pixel)\n        bits = e[pixel]\n        \n        bit0 = (bits >> 0) & 1\n        bit1 = (bits >> 1) & 1\n        bit2 = (bits >> 2) & 1\n\n        row0 |= bit0 << i\n        row1 |= bit1 << i\n        row2 |= bit2 << i\n    \n    rows0.append(row0)\n    rows1.append(row1)\n    rows2.append(row2)\n\ndef print_rows(rows, name):\n    for i in range(32):\n        row = rows[i]\n        print(\"\\t%s[%d] = 0x%08x;\"%(name, i, row))\n\nif 1:\n    print_rows(rows0, \"rows0\")\n    print_rows(rows1, \"rows1\")\n    print_rows(rows2, \"rows2\")\n\nprint(\"\")\n\nif 1:\n    for key, value in sorted(e.items(), key=second):\n        r = key[0] / 255.0\n        g = key[1] / 255.0\n        b = key[2] / 255.0\n        a = key[3] / 255.0\n        print(\"\\t\\tif (bits == %d) color = vec4(%f, %f, %f, %f);\"%(value, r, g, b, a))\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}