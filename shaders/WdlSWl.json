{
    "Shader": {
        "info": {
            "date": "1552997376",
            "description": "A simplex weave. In particular, an extension of a 2D simplex pattern, interwoven depthwise along the third dimension.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdlSWl",
            "likes": 79,
            "name": "Simplex Weave",
            "published": 3,
            "tags": [
                "simplex",
                "truchet",
                "pattern",
                "weave"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2303
        },
        "renderpass": [
            {
                "code": "/*\n\n\tSimplex Weave\n\t-------------\n\n\tI was going to call this a 3D simplex weave, but technically that'd be a weave on a 3D \n    simplex grid, whereas this is a 2D simplex pattern, woven depthwise along the third\n    dimension, so I'll split the difference and call it a 2.5D simplex weave. :)\n    \n    I hadn't coded a shader for a while, which meant I'm out of practice, so wanted something \n\tnice and easy to start with. Extrapolating a 2D pattern to 3D tends to be simple enough, \n\tand I figured a 3D looking simplex weave would look interesting, so here it is. I thought \n\tthe process would be less complex than a hexagonal weave, but in reality found it \n\tsomewhat trickier, due to the uneven number of cell sides and restrictiveness of the \n    pattern. In fact, it took me a while just to divise a tile that'd work.\n\n\tEither way, the idea is pretty straight forward: Partition space into a 2D simplex grid \n    (space filling equilateral triangles), then construct a 3D triangular tile that will \n    produce a connected pattern when randomly rotated about the XY plane. \n\t\n\tEach tile consists of three arcs -- each cutting the mid section of the three triangle\n\tsides. One arc cuts two sides on the upper level, another cuts the two sides on the\n\tlower level, and the final one interpolates from a side on the upper level to one on\n\tthe lower level... So simple, yet it took me ages realize. :) Anyway, feel free to \n\tuncomment the \"SIMPLEX_GRID\" define for a better visual representation.\n\n\tThe rest is just window dressing and so forth -- A bit of diffuse, specular, fake \n\tenvironment mapping, etc., so you can ignore most of it. There's a few defines below, for\n\tanyone interested. The \"FLOOR_HOLES\" define adds a bit more depth to the scene. For anyone,\n    who doesn't wish to sift through a bunch of esoteric code, I'll put together a simpler\n\t2D example to accompany this. I have a 2D example on Shadertoy already, but I'll put\n\ttogether another one that utilizes the simpler random tile rotation logic.\n\n    The comments and code were written in a hurry, which will definitely require some \n    optimization and tidy up, so I'll get onto that in due course. For instance, I'm currently\n\trendering three detailed arcs. However, there is a way to find the closest arc curve, then \n    render only one, which in theory, should improve frame rates on slower machines quite a \n\tbit. However, it involves a lot of rearranging to the distance field function, so I'll \n    leave it in its current form for now.\n\n\t\n    Similar examples:\n\n    // Just one of a few of Flockaroo's really cool triangle-grid-based examples. :)\n    //\n\tSoldering Fun - Flockaroo\n    https://www.shadertoy.com/view/MlffDX\n\n    // A nice clean weave example, and the example that put me in the mood to code this. :)\n    //\n\tImpossible Chainmail - BigWIngs\n\thttps://www.shadertoy.com/view/td23zV\n\n\t// A 2D version of this particular example, but it uses sorting logic -- instead \n    // of rotational, so I'll produce another pretty soon. \n    //\n\t// Simplex Truchet Weave - Shane\n\thttps://www.shadertoy.com/view/4ltyRn\n\n\n    // Performed on a 3D simplex (tetrahedral) grid, but doesn't involve a weave.\n    //\n\tSimplex Truchet Tubing - Shane\n\thttps://www.shadertoy.com/view/XsffWj\n\n*/\n\n\n// Far plane. Because of the camera angle, I was able to maintain a small bound.\n#define FAR 10.\n\n// I really liked the extra depth the floor holes gave, but felt it took away from the main \n// woven pattern, so begrudgingly downgraded them to an option. :)\n//#define FLOOR_HOLES\n\n// This displays the simplex grid boundaries on the floor, which should make it a little\n// easier to visualize the individual cell tiles. I could have constructed some 3D boundaries,\n// but didn't wish to overcomplicate things... more than they already are. :)\n//#define SIMPLEX_GRID\n\n// A quick hack, for anyone who'd like to look at the bump mapped floor pattern \n// on its own. It looks better with the floor holes (see above).\n//#define FLOOR_PATTERN_ONLY\n\n// Global object ID - Floor: 0, Pylon: 1, Outer rails and bolts: 2, Colored center rail: 3.\n// It needs to be global to feed into other functions, and so forth.\nfloat svObjID = 0.;\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n) - .1, .001); // n = max(n*n - .2, 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n    vec3 tx1 = texture(tex, p.yz).xyz;\n    vec3 tx2 = texture(tex, p.zx).xyz;\n    vec3 tx3 = texture(tex, p.xy).xyz;\n    \n\treturn tx1*tx1*n.x + tx2*tx2*n.y + tx3*tx3*n.z;\n    \n}\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(mod(h, 6.2831))*43758.5453), fract(sin(mod(h + s.x, 6.2831))*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's standard 2x1 hash algorithm.\nfloat hash21(vec2 p){\n \n    float n = dot(p, vec2(127.183, 157.927));\n    return fract(sin(n)*43758.5453);\n}\n\n#ifdef SIMPLEX_GRID\n// Unsigned distance to the segment joining \"a\" and \"b.\"\nfloat distLine(vec2 a, vec2 b){\n    \n\tb = a - b;\n\tfloat h = clamp(dot(a, b) / dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n#endif\n\n/*\n// IQ's extrusion formula. To save calculations, cheap alternatives \n// are used, but it's here for completeness.\nfloat opExtrusion(in float sdf, in float pz, in float h)\n{\n    const float rnd = .0; // Hacky rounding factor.\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x,w.y), 0.) + length(max(w + rnd, 0.)) - rnd;\n}\n*/\n\n// Floor curve shape - Circle: 0, Hexagon: 1, Dodecahedron: 2.\n// This function is used for bump mapping.\n#define SHAPE 0\n\n// Distance metric.\nfloat dist(vec2 p){\n    \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #elif SHAPE == 1\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #else\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    vec2 p2 = p*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.x, p.y)); // Dodecahedron.\n    #endif\n    \n}\n\n// The main toroidal shapes, which consist of a center rail and some outer ones.\nvec2 tube(vec2 p){    \n     \n    p = abs(p);\n      \n    // Center rail.\n    float mid = max(p.x - .05, p.y - .01); // Square center.\n    //float mid = length(p.xy*vec2(.5, 1)) - .0325; // Rounder center.\n    \n    // Repeat offset trick to split the single rail into two. The X coordinate\n    // represents the radial distance component (as opposed to the angular one),\n    // so that's the one of interest. \n    p.x = abs(p.x - .08);\n    p.x -= .02; // Stretching the rails radially. Dodgy, but it works. :)\n    \n    // Outer rails.\n    float rail = max(max(p.x, p.y), (p.x + p.y)*.7071) - .02; // Octagonal.\n    //float rail = length(p) - .025; // Circular.\n    //float rail = max(p.x - .015, p.y - .015); // Square.\n    \n    // Return the center and outer rail components.\n    return vec2(rail, mid);\n    \n}\n\n\n// Toroidal curve shape. Hexagon and dodecahedron options are provided,\n// which don't really suit the scene, but are interesting enough. :)\n#define SHAPE3 0\n\n// Distance metric.\nfloat tubeOuter(vec2 p){\n    \n    #if SHAPE3 == 0\n    return length(p); // Circle.\n    #elif SHAPE3 == 1\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #else\n    p *= rot2(3.14159/12.);\n    p = abs(p);\n    vec2 p2 = p*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.x, p.y)); // Dodecahedron.\n    #endif\n    \n}\n\n\n// The pylons that hold up the toroidal curves.\n\nfloat pylon(vec2 p){\n    \n    //return length(p) - .03; // Circular.\n    \n    p = abs(p);\n    \n    p.y -= .02; // Stretch along the radial coordinate.\n    \n    // Octagonal -- You could also try\n    return max(max(p.x, p.y), (p.x + p.y)*.7071) - .025;\n    \n}\n\n\n#define SHAPE2 1 \n\n// Distance metric.\nfloat tube4(vec2 p){\n    \n    #if SHAPE2 == 0\n    return length(p); // Circle.\n    #elif SHAPE2 == 1\n    //p *= rot2(3.14159/12.);\n    p = abs(p);\n    return max(p.y*.8660254 + p.x*.5, p.x); // Hexagon.\n    #else\n    //p *= rot2(3.14159/12.);\n    p = abs(p);\n    vec2 p2 = p*.8660254 + p.yx*.5;\n    return max(max(p2.x, p2.y), max(p.x, p.y)); // Dodecahedron.\n    #endif\n    \n}\n\n// The bump mapped version of the simplex scene. It's similar to the distance field\n// version. Bump mapping adds extra complexity, but can save a lot of GPU power, so\n// can be worth it.\n\nvec4 simplexWeaveBump(vec3 q){   \n    \n    \n    \n    // SIMPLEX GRID SETUP\n    \n    vec2 p = q.xy; // 2D coordinate on the XY plane    \n    \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - ioffs + .2113248654, p2 = p - .577350269; \n\n    \n    // THE WEAVE PATTERN\n    \n    // A random value -- based on the triangle vertices, and ranging between zero and one.\n    float dh = hash21((s*3. + ioffs + 1.));\n    \n \n    // Based on the unique random value for the triangle cell, rotate the tile.\n    // In effect, we're swapping vertex positions... I figured it'd be cheaper,\n    // but I didn't think about it for long, so there could be a faster way. :)\n    //\n    if(dh<1./3.) { // Rotate by 60 degrees.\n        vec2 ang = p;\n        p = p1, p1 = p2, p2 = ang;\n        \n    }\n    else if(dh<2./3.){ // Rotate by 120 degrees.\n        vec2 ang = p;\n        p = p2, p2 = p1, p1 = ang;\n    }\n\n     \n    \n    // Angles subtended from the current position to each of the three vertices... There's probably a \n    // symmetrical way to make just one \"atan\" call. Anyway, you can use these angular values to create \n    // patterns that follow the contours. In this case, I'm using them to create some cheap repetitious lines.\n    vec3 a = vec3(atan(p.y, p.x), atan(p1.y, p1.x), atan(p2.y, p2.x));\n \n    // The torus rings. \n    // Toroidal axis width. Basically, the weave pattern width.\n    float tw = .2;\n    // For symmetry, we want the middle of the torus ring to cut dirrectly down the center\n    // of one of the equilateral triangle sides, which is half the distance from one of the\n    // vertices to the other. Add \".1\" to it to see that it's necessary.\n    float mid = dist((p2 - p))*.5;\n    // The three distance field functions: Stored in cir.x, cir.y and cir.z.\n    vec3 cir = vec3(dist(p), dist(p1), dist(p2));\n    // Equivalent to: vec3 tor =  cir - mid - tw; tor = max(tor, -(cir - mid + tw));\n    vec3 tor =  abs(cir - mid) - tw;\n        \n \n    \n\n    \n    // RENDERING\n    // Applying the layered distance field objects.\n    \n    // The background. I tried non-greyscale colors, but they didn't fit.\n    vec3 bg = vec3(.75);\n    // Floor pattern.\n    //bg *= clamp(cos((q.x - q.y)*6.2831*16.) - .25, 0., 1.)*.2 + .9;\n   \n    // The scene color. Initialized to the background.\n    vec3 col = bg;\n    \n    // Outer torus ring color. \n    vec3 rimCol = vec3(.5);\n    \n    // Use the angular component to create lines running perpendicular \n    // to the curves.\n    \n    // Angular floor ridges.\n    vec3 ridges = smoothstep(.05, -.05, -cos(a*12.) + .93)*.5;\n    \n    // Ridges pattern on the toroidal rails. Set it to zero, if you're not sure\n    // what it does.\n    vec3 ridges2 = smoothstep(.05, -.05, sin(a*18.) + .93);\n    \n    // Using the angle to create the height of the toroidal curves.\n    a = sin(a*3. - 6.283/9.)*.5 + .5; \n     \n\n    \n         \n    // Smoothing factor and line width.\n    const float sf = .015, lw = .02;\n   \n    // Rendering the the three ordered (random or otherwise) objects:\n    //\n    // This is all pretty standard stuff. If you're not familiar with using a 2D\n    // distance field value to mix a layer on top of another, it's worth learning.\n    // On a side note, \"1. - smoothstep(a, b, c)\" can be written in a more concise\n    // form (smoothstep(b, a, c), I think), but I've left it that particular way\n    // for readability. You could also reverse the first two \"mix\" values, etc.\n    // By readability, I mean the word \"col\" is always written on the left, the\n    // \"0.\" figure is always on the left, etc. If this were a more GPU intensive\n    // exercise, then I'd rewrite things.\n    \n    \n    // Bottom toroidal segment.\n    //\n    // Outer dark edges.\n    //col = mix(col, vec3(.1), 1. - smoothstep(0., sf, tor.z));\n    // The main toroidal face.\n    //col = mix(col, rimCol*(1. - ridges.z), 1. - smoothstep(0., sf, tor.z + lw));\n    \n    // Same layering routine for the middle toroidal segment.\n    col = mix(col, vec3(.1), 1. - smoothstep(0., sf, tor.y));\n    col = mix(col, rimCol*(1. - ridges.y), 1. - smoothstep(0., sf, tor.y + lw));\n  \n    // The final toroidal segment last.\n\tcol = mix(col, vec3(.1), (1. - smoothstep(0., sf, tor.x))*1.);\n    col = mix(col, rimCol*(1. - ridges.x), (1. - smoothstep(0., sf, tor.x + lw))*1.);\n  \n    //col = vec3(1);\n    \n    // Hexagon centers.\n    //col = mix(col, vec3(.5), (1. - smoothstep(0., sf, hole0)));\n\n    /*\n    float shp = min(tor.x, tor.y);\n    shp =  -shp + .035;//abs(shp - .075);\n    col = mix(col, vec3(.1), (1. - smoothstep(0., sf, shp)));\n    col = mix(col, vec3(rimCol), (1. - smoothstep(0., sf, shp + lw)));\n    */\n\n    \n    #ifdef SIMPLEX_GRID\n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\n    // each of the three triangular cell vertices to show the outline of the \n    // cell edges.\n    vec3 c = vec3(distLine(p, p1), distLine(p1, p2), distLine(p2, p));\n    c.x = min(min(c.x, c.y), c.z);\n    //col = mix(col, vec3(.1), (1. - smoothstep(0., sf*2., c.x - .0)));\n    col = mix(col, vec3(.1), (1. - smoothstep(0., sf*2., c.x - .02)));\n    col = mix(col, vec3(1, .8, .45)*1.35, (1. - smoothstep(0., sf*1.25, c.x - .005)));\n    #endif\n    \n    \n    // Arc tile calculations: This is a shading and bump mapping routine. However, \n    // we're using it in a 3D setting, so we need to determine which 3D tube is closest, \n    // in order to know where to apply the bump pattern.\n    vec2 d1 = vec2(1e5), d2 = vec2(1e5), d3 = vec2(1e5);\n    \n    // Moving the Z component to the right depth, in order to match the 3D\n    // pattern. I forgot to do this, and it led to all kinds of confusion. :)\n    q.z -= .5;\n     \n    // The three arc sweeps. By the way, you can change the define above the\n    // \"tubeOuter\" function to produce a hexagonal sweep, etc.\n    float depth = .125;\n    vec2 v1 = vec2(tubeOuter(p.xy) - mid, q.z - depth); // Bottom level arc.\n    // This arc sweeps between the bottom and top levels.\n    vec2 v2 = vec2(tubeOuter(p1.xy) - mid, q.z + depth*a.y - depth); \n    vec2 v3 = vec2(tubeOuter(p2.xy) - mid, q.z); // Top level arc.\n    \n    // Shaping the poloidal coordinate vectors above into rails.\n    d1 = tube(v1);\n    d2 = tube(v2);\n    d3 = tube(v3);\n\n    \n    // Based on which tube we've hit, apply the correct anular bump pattern.\n    // Try mixing this up, and you'll see why it's necessary.\n    float bump = d1.x<d2.x && d1.x<d3.x? ridges2.x : d2.x<d3.x? ridges2.y : ridges2.z;\n    \n     \n    \n    // Return the simplex weave value.\n    return vec4(col, 1. - bump);\n \n\n}\n\n\n// The simplex weave scene. A lot of it is made up on the fly, so it needs a tidy up,\n// and more than likely, some more optimization.\n//\n// It returns four objects -- to be sorted later:\n// Floor: 0, Pylon: 1, Outer rails and bolts: 2, Colored center rail: 3.\n//\n// The only object of interest is the weave tile. Each tile consists of three arcs -- each \n// cutting the mid section of the three triangle sides. One arc cuts two sides on the upper \n// level, another cuts the two sides on the lower level, and the final one interpolates from \n// a side on the upper level to one on the lower level. You can uncomment the \"SIMPLEX_GRID\" \n// define for a better visual representation.\n//\n// By the way, it's possible to find the distance to the closest arc only, then render the\n// the detailed version is that particular arc alone -- provided there's no overlap. I haven't\n// checked to see whether it will work, in this particular case, but will try it later. The\n// payoff is increased frame rate. The downside is more coding. :D Either way, I employ that \n// particular method here:\n//\n// Dual 3D Truchet Tiles - Shane\n// https://www.shadertoy.com/view/4l2cD3 \n\nvec4 simplexWeave(vec3 q){\n    \n   \n    // SIMPLEX GRID SETUP\n    \n    vec2 p = q.xy; // 2D coordinate on the XY plane.\n   \n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\n    \n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\n    \n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n    vec2 ioffs = vec2(1. - i, i);\n    \n    // Vectors to the other two triangle vertices.\n    vec2 p1 = p - ioffs + .2113248654, p2 = p - .577350269; \n    \n\n    \n    // THE WEAVE PATTERN\n    \n    // A random value -- based on the triangle vertices, and ranging between zero \n    // and one.\n    float dh = hash21((s*3. + ioffs + 1.));\n    \n \n    // Based on the unique random value for the triangle cell, rotate the tile.\n    // In effect, we're swapping vertex positions... I figured it'd be cheaper,\n    // but I didn't think about it for long, so there could be a faster way. :)\n    //\n    if(dh<1./3.) { // Rotate by 60 degrees.\n        vec2 ang = p;\n        p = p1, p1 = p2, p2 = ang;\n        \n    }\n    else if(dh<2./3.){ // Rotate by 120 degrees.\n        vec2 ang = p;\n        p = p2, p2 = p1, p1 = ang;\n    }\n     \n     \n    \n    // Angles subtended from the current position to each of the three vertices... There's probably a \n    // symmetrical way to make just one \"atan\" call. Anyway, you can use these angular values to create \n    // patterns that follow the contours. In this case, I'm using them to create some cheap repetitious lines.\n    vec3 a = vec3(atan(p.y, p.x), atan(p1.y, p1.x), atan(p2.y, p2.x));\n\n    // The torus rings. \n\n    // For symmetry, we want the middle of the torus ring to cut dirrectly down the center\n    // of one of the equilateral triangle sides, which is half the distance from one of the\n    // vertices to the other. Add \".1\" to it to see that it's necessary.\n    float mid = dist((p2 - p))*.5;\n \n    // Interspercing some pylons and bolts around the arcs using\n    // a standard fixed repeat partitioning of angular components.\n    \n    const float aNum = 6.;\n    vec3 ia = (floor(a/6.283*aNum) + .5)/aNum;\n    ia += .25/aNum; // A hack to move the objects to a better place.\n    \n    vec2 px = rot2(ia.x*6.283)*p;\n    px.x -= mid;\n\n    vec2 py = rot2(ia.y*6.283)*p1;\n    py.x -= mid;\n\n    vec2 pz = rot2(ia.z*6.283)*p2;\n    pz.x -= mid;\n    \n    px = abs(px);\n    py = abs(py);\n    pz = abs(pz);\n   \n    // A repeat trick to move the radial component of an object to a set distance\n    // on both sides of the radial origin... A bit hard to decribe, but if you comment\n    // the following lines out, you'll see what I mean. :)\n    px.x = abs(px.x - .08);\n    py.x = abs(py.x - .08);\n    pz.x = abs(pz.x - .08);\n\n    // Bolts.\n    float cdx = tube4(px) - .02;\n    float cdy = tube4(py) - .02;\n    float cdz = tube4(pz) - .02;\n \n    // Pylons.\n    float bdx = pylon(px);\n    float bdy = pylon(py);\n    float bdz = pylon(pz);\n     \n///\n    \n\n    // Relative arc heights -- Based on the angle, and arranged to vary between\n    // zero and one.\n    a = sin(a*3. - 6.283/9.)*.5 + .5;\n\n    q.z -= .5;\n    \n    \n    // Arc tile calculations. \n    vec2 d1 = vec2(1e5), d2 = vec2(1e5), d3 = vec2(1e5);\n    \n    // The three arc sweeps. By the way, you can change the define above the\n    // \"tubeOuter\" function to produce a hexagonal sweep, etc.\n    float depth = .125;\n    vec2 v1 = vec2(tubeOuter(p.xy) - mid, q.z - depth); // Bottom level arc.\n    // This arc sweeps between the bottom and top levels.\n    vec2 v2 = vec2(tubeOuter(p1.xy) - mid, q.z + depth*a.y - depth); \n    vec2 v3 = vec2(tubeOuter(p2.xy) - mid, q.z); // Top level arc.\n    \n    // Shaping the poloidal coordinate vectors above into rails.\n    d1 = tube(v1);\n    d2 = tube(v2);\n    d3 = tube(v3);\n    \n    \n    // Bolts.\n    cdx = max(cdx, abs(q.z) - .03);\n    cdy = max(cdy, abs(q.z) - .03);\n    cdz = max(cdz, abs(q.z) - .03);\n   \n    q.z -= .475;//.465;\n   \n    // Pylons.\n    bdx = max(bdx, abs(q.z) - .45);\n    bdy = max(bdy, abs(q.z) - .45);\n    bdz = max(bdz, abs(q.z) - .45);\n    bdx = min(min(bdx, bdy), bdz);\n\n    \n\n\n    \n    //////\n    // The three distance field functions: Stored in cir.x, cir.y and cir.z.\n    vec3 cir = vec3(dist(p), dist(p1), dist(p2));\n    // Equivalent to: vec3 tor =  cir - mid - tw; tor = max(tor, -(cir - mid + tw));\n    vec3 tor =  abs(cir - mid) - .21;\n    \n    // Optional floor holes that match the bump pattern. I like the extra detail, but \n    // figured it distracted from weave pattern itself, so left it as an option.\n    float hole0 = 0.;\n    #ifdef FLOOR_HOLES\n    hole0 = -min(tor.x, tor.y);\n    #endif\n    \n    // Bolts.\n    d1.x = min(d1.x, cdx);\n    d2.x = min(d2.x, cdy);\n    d3.x = min(d3.x, cdz);\n    \n   \n    // Obtaining the minimum of the center and outside rail objects.\n    d1.xy = min(min(d1.xy, d2.xy), d3.xy);\n    \n   \n    // Return the individual simplex weave object values:\n    // Holes, pylons, rails and bolts, and center strip.\n    return vec4(hole0, bdx, d1.xy);\n \n\n}\n\n// A container to hold the distances of four individual objects. The idea is to sort\n// the objects outside raymarching loop for identification.\nvec4 objID;\n\n\n// Raymarching a heightmap on an XY-plane. Pretty standard.\nfloat map(vec3 p){\n\n    // The floor plane.\n    float terr = .75 - p.z;\n    \n    // The simplex weave objects: \n    // hm.x - Optional floor holes, hm.y - Pylons, \n    // hm.z - Rails and bolts, hm.a - Center strip.\n    vec4 hm = simplexWeave(p);\n    \n    // Holes in the floor. Gives more depth to the scene, but it a little distracting.\n    #ifdef FLOOR_HOLES\n    terr = min(terr + .05, max(terr, -hm.x));\n    #endif\n    \n    // A quick hack, for anyone who'd like to look at the bump mapped floor pattern \n    // on its own. It looks better with the floor holes (see above).\n    #ifdef FLOOR_PATTERN_ONLY\n    hm += 1e5;\n    #endif\n    \n    // Adding some pylon base detatil... I wasn't feeling it. :)\n    //float pat = min(min(hm.y, hm.z), hm.a);\n    //terr += smoothstep(0., .05, pat - .01)*.02;\n     \n    // Store the individual object IDs for sorting and object identification later.\n    objID.xyzw = vec4(terr, hm.y, hm.z, hm.a);\n    \n    // Return the minimum distance.\n    return min(terr, min(min(hm.y, hm.z), hm.a));\n    \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n*/\n\n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // A reproduction of the simplex weave function, with some of the unnecessary\n    // calculations omitted... Having said that, there's still a little redundancy\n    // in there.\n    vec4 sw = simplexWeaveBump(p);\n    \n    float bump;\n    \n    if(svObjID == 0.) bump = sw.x; // Floor pattern.\n    else bump = sw.w/4.; // Curved line pattern on weaved rail object.\n    \n    return bump;\n   \n   \n}\n\n// Standard function-based bump mapping function. The default here is the more expensive\n// 6-tap version, but you could get away with the 4-tap, if you needed to save cycles.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel width, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(2./iResolution.y, 0); \n    \n    //float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p + e.yyx); // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/(e.x*1.);  // Without the extra samples.\n\n    \n    // Some kind of gradient correction... I'm getting so old that I've forgotten why\n    // you do this. It's a simple reason, and a necessary one. I remember that much. :D\n    // Actually, there's an explanation in one of my examples on Shadertoy, so I'll \n    // track it down and transcribe it later.\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n\n// Normal calculation, with some edging bundled in. Curvature is there too, but it's\n// commented out, in this case.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef) { \n\t\n    // Roughly two pixel edge spread, but increased slightly with larger resolution.\n    vec2 e = vec2(ef/mix(450., iResolution.y, .5), 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\n      \n    // Wider sample spread for the curvature.\n    //e = vec2(12./450., 0);\n\t//d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\t//d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\t//d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n \t \n    \n    e = vec2(.0025, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.0;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = float(i)*.125/5.;        \n        float dd = map(p + hr*n);\n        occ += (hr - dd)*sca;\n        sca *= .75;\n    }\n    return clamp(1. - occ, 0., 1.);   \n    \n}\n\n\n// Basic soft shadows.\nfloat getShad(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., sh = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i = min(0, iFrame); i<24; i++){\n        \n    \tdt = map(ro + ld*t);\n        \n        sh = min(sh, 8.*dt/t);\n         \n \t\tt += clamp(dt, .01, .25);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n    return max(sh, 0.);\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    // Note that the ray is starting just above the raised plane, since nothing is\n    // in the way. It's normal practice to start at zero.\n    float d, t = 0.; \n    for(int j = min(0, iFrame); j<64; j++){\n      \n        d = map(ro + rd*t); // distance to the function.\n        // The plane \"is\" the far plane, so no far=plane break is needed, but it's\n        // included anyway.\n        if(abs(d)<.001*(1. + t*.125) || t>FAR) break;\n\n        t += d; // Total distance from the camera to the surface.\n    \n    }\n\n    return min(t, FAR);\n    \n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\nvec3 envMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    //rd.z -= iTime*.25;\n    rd *= 2.5;\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(.4, 1., c); // Darken and add contast for more of a spotlight look.\n    \n    vec3 col = vec3(c, c*c, c*c*c*c); // Simple, warm coloring.\n    //vec3 col = pow(min(vec3(1.5, 1, 1)*c, 1.), vec3(1, 2.5, 12)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.zyx, sRd*.25 + .5); \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    // A lazy camera setup. There's no \"to\" or \"from\" vectors.\n    \n    // Unit directional ray with no divide, courtesy of Coyote.\n    //vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.5));\n    \n    // A warped (fisheye) unit directional ray.\n    vec3 rd = normalize(vec3(fragCoord - iResolution.xy*.5, iResolution.y*.525));\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.05));\n    \n    // Controlling the speed of the camera motion.\n    float tm = iTime*.75;\n    \n    // Tilting, and rotating the XY-plane back and forth, for a bit of variance.\n    rd.xy *= rot2(sin(tm/4.)*.25);\n    rd.yz *= rot2(-.35);\n    \n    \n    // Ray origin. Moving in the X-direction to the right.\n    vec3 ro = vec3(tm, cos(tm/4.), -.5);\n    \n    // Light position, hovering around camera.\n    vec3 lp = ro + vec3(cos(tm/2.)*.5, sin(tm/2.)*.5 + .25, -.25);\n    \n    // Standard raymarching function.\n \tfloat t = trace(ro, rd);\n    \n    \n    // Sorting the individual objects to obtain the object ID.\n    svObjID = objID.x<objID.y && objID.x<objID.z && objID.x<objID.w? 0. : \n    objID.y<objID.z && objID.y<objID.w? 1. : objID.z<objID.w? 2. : 3.;\n    \n   \n    // Surface postion, surface normal and light direction.\n    vec3 sp = ro + rd*t;\n    \n    \n    // Retrieving the normal at the hit point, whilst performing some edging.\n    float edge = 0., crv = 1., ef = 4.;\n\tvec3 sn = getNormal(sp, edge, crv, ef); // Curvature (crv) is not used here.\n \n    \n    \n    /*\n    // Texture-based bump mapping. I wasn't feeling it, so didn't use it, but it's there \n    // for anyone who wants to try it. Just be sure to uncomment the texture bump map function.\n\n\t// Texture bump factor.\n    float tBump = .005;\n    if(svObjID == 0.) tBump = .005;\n    \n    \n    if(svObjID != 3.) sn = doBumpMap(iChannel1, sp, sn, tBump);\n\tif(svObjID == 0.) sn = doBumpMap(iChannel1, sp, sn, tBump); \n    */\n      \n    // Function-based bump mapping.\n    if(svObjID==0. || svObjID==3.) sn = doBumpMap(sp, sn, .02/(1. + t*.5/FAR));  \n    \n    \n    // Point light.\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light distance.\n    float atten = 1./(1. + lDist*lDist*.1); // Light attenuation.\n    ld /= lDist; // Normalizing the light direction vector.\n    \n    // Obtaining the surface texel from each of the channels.\n    vec3 oC0 = tex3D(iChannel0, sp, sn)*1.5;\n    vec3 oC1 = tex3D(iChannel1, sp/2., sn)*1.5;\n \n    // Ramping up the contrast of the second texel in all objects except the colored\n    // middle rail.\n    if(svObjID != 3.) oC1 = smoothstep(0., .9, oC1);\n \n    vec3 oC; \n     \n    // Call the simplex function to obtain a color value. It's a bit\n    // wasteful, but it'll do.\n    vec4 sw = simplexWeaveBump(sp);\n     \n    // Texture, color, etc, each of the objects. A lot of this was made up on the\n    // spot. I should probably tidy it up later.\n    \n    if(svObjID == 0.) { // Ground plane.\n        \n        oC1 = mix(oC1, oC0, .25);\n        oC1 *= (sw.xyz*.95 + .05); // Subtle weave coloring.        \n        oC = oC1;\n    }\n    else if(svObjID == 1.) {  // Pylons. \n        \n        oC = vec3(.375)*oC1;\n        \n    }\n    else if(svObjID == 2.){ // Rails.\n        \n        oC1 = mix(oC1, oC0, .15);\n        \n        if(sp.z<.47) oC = oC1;\n        else oC = oC1/2.;\n\n    }\n    else { // Center strip.\n        \n        // Reddish pink coloring.\n        oC = vec3(1, .05, .1)*2.5;  \n    \toC = mix(oC, oC.yzx, dot(sin(sp*4. - cos(sp.yzx*4.))*.5 + .25, vec3(1./3.)*.375));\n        \n        // Green.\n        //oC = vec3(.4, 1, .1)*2.;  \n        //oC = mix(oC, oC.zyx, dot(sin(sp*4. + cos(sp.yzx*4.))*.5 + .5, vec3(1./3.)));\n        \n     \n        oC0 *= (sw.a*.9 + .15); // Dark bump line overlay -- For the reflective texture.\n        oC1 *= (sw.a*.9 + .15); // Dark bump line overlay.\n        oC *= oC1; // Give the red a bit of texture.\n        \n        \n        \n    }\n    \n \n\n    // Surface lighting.\n    //\n    float diff = max(dot(ld, sn), 0.); // Diffuse.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); // Specular.\n    float fre = clamp(dot(sn, rd) + 1., .0, 1.); // Fake fresnel, for the glow.\n    if(svObjID == 2.) diff = pow(diff, 2.)*1.25; // Metallicize the rails a bit.\n\n    // Shading -- Shadows and ambient occlusion. \n    //\n    float sh = getShad(sp, sn, lp);\n    float ao = calcAO(sp, sn); // Ambient occlusion, for self shadowing.\n    // Adding a partial ambient value to the shadow, for something to do. :)\n    sh = min(sh + ao*.3, 1.);\n    \n    // Combining the terms above to light the texel.\n    vec3 col = (oC*(diff + .3*ao) + vec3(.5, .7, 1)*spec*2.);// + vec3(.1, .3, 1)*pow(fre, 4.)*4.;\n    \n    \n\t// Fake environment mapping. It's a bit hacky, but reasonably effective,\n    // and far cheaper than a reflective pass.  \n    //\n    vec3 eMap = envMap(reflect(rd, sn), sn);\n    if(svObjID == 3.) col += oC0*eMap*5.;\n    else if(svObjID == 0.) col += oC1*eMap*3.;\n    else col += (oC1 + .5)*eMap*3.5;\n   \n    \n    // Edging.\n    col *= 1. - edge*.7;\n    \n    // Applying the shades.\n    col *= (atten*sh*ao);\n    \n    // Vignette.\n    //vec2 uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.125);\n\n    \n    // Performing rough gamma correction, the presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}