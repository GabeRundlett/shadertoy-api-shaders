{
    "Shader": {
        "info": {
            "date": "1572347697",
            "description": "voxel video using multi-scale subdivisions\nchange video source in Buffer A (e.g. webcam)\ngemetry version [url=https://www.shaderoo.org/?shader=TcIr3O]here[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3stXzB",
            "likes": 41,
            "name": "voxel video",
            "published": 3,
            "tags": [
                "video",
                "voxel",
                "effect"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 2030
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n#define VIGNETTE\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\n#define RandTex iChannel3\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(RandTex,0));\n    pos*=tres;\n    vec2 fr=fract(pos-.5);\n    vec2 uv=(pos-.7*sin(fr*PI2)/PI2)/tres.xy;\n    return textureLod(RandTex,uv,0.);\n}\n\nvoid getPhiThetaDist(inout float ph, inout float th, inout float dist)\n{\n    ph=(iMouse.x-.5*Res.x)/Res.x*12.6;\n    th=(Res.y-iMouse.y-.5*Res.y)/Res.y*13.6;\n    dist=260.;\n    if(iMouse.x==0.) {\n        vec4 r =getRand(iTime*.02*vec2(1,.001))-getRand(iTime*.02*vec2(1,.001)+10.5);\n        ph += .3*cos((iTime+15.)*.37)+(r.x*.0013);\n        th -= .7*cos((iTime+15.)*.15)+(r.y*.0026);\n        dist+=-100.*cos(iTime*.1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ph,th,dist; getPhiThetaDist(ph,th,dist);\n    //fragColor=texture(iChannel1,fragCoord/Res);\n    float mipOffs=1.2*abs((fragCoord.y-Res.y*.5)/Res.y)*(log2(Res.x)-5.)*abs(sin(th));\n    vec4 col=texture(iChannel3,fragCoord/Res,.4+mipOffs);\n    fragColor=col*.8;\n\n    vec4 c;\n    c=texture(iChannel3,fragCoord/Res,1.7+mipOffs);\n    fragColor+=(c*1.5-.5)*.3*.5;\n    c=texture(iChannel3,fragCoord/Res,3.7+mipOffs);\n    fragColor+=(c*1.5-.5)*.3*.5;\n    c=texture(iChannel3,fragCoord/Res,4.7+mipOffs);\n    fragColor+=(c*1.5-.5)*.3*.5;\n    \n    float br=dot(fragColor.xyz,vec3(.3333));\n    fragColor.xyz=clamp((fragColor.xyz-br)*1.7+br,0.,1.);\n    //fragColor.w=1.;\n    #ifdef VIGNETTE\n    vec2 scc=(fragCoord-.5*iResolution.xy)/iResolution.x;\n    float vign = 1.1-1.*dot(scc,scc);\n    vign*=1.-.5*exp(-sin(fragCoord.x/iResolution.x*3.1416)*20.);\n    vign*=1.-.5*exp(-sin(fragCoord.y/iResolution.y*3.1416)*10.);\n    fragColor.xyz *= vign;\n    #endif\n    fragColor.w=1.;\n    //fragColor = texture(iChannel3,fragCoord/iResolution.xy,5.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// emulating multiple passes by dedicating each frame to a different pass\n//#define CLIP_BG\n\nconst int NumPasses = 13;\n\n#define ResMap min(exp2(floor(log2(iResolution.xy))),vec2(256,128))\n#define iPassIndex (iFrame%NumPasses)\n\n#define PI2 6.28318530718\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// copy every NumPasses'th frame of video to Buffer\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec4 getCol(vec2 pos)\n{\n    vec2 tres = Res0;\n    // use max(...) for fitting full image or min(...) for fitting only one dir\n    vec2 tpos = (pos-.5*Res1)*min(tres.y/Res1.y,tres.x/Res1.x);\n    vec2 uv = (tpos+tres*.5)/tres;\n\tvec4 col=texture(iChannel0,uv);\n\tvec4 bg=textureLod(iChannel2,((uv-.5)*.9+.5)+.05*sin(.1*iTime*vec2(2,3)),(3.7+log2(Res1.x/600.))*0.+1.5);\n    bg=mix(vec4(1.),bg,cos(iTime*.1)*.5+.5);\n    bg=vec4(1.);\n   \t#ifndef CLIP_BG\n    col=mix(col,bg,dot(col.xyz,vec3(-.8,1.6,-.8)));\n    #endif\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iPassIndex==0)\n        fragColor=getCol(fragCoord);\n    else\n        fragColor=texture(iChannel1,fragCoord/iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// recursively find min and max pixel brightness in a certain region\n// going from small scales to higher scales\n// (emulating multiple passes by dedicating each frame to a different pass)\n\n#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nbool getNBPixPos(ivec2 coord, int level, inout ivec2 pos1, inout ivec2 pos2)\n{\n    if (level==0) { pos1=coord*ivec2(2,1); pos2=pos1+ivec2(1,0); return coord.x<int(Res1.x)/2; }\n    \n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n    \n    ivec2 c = coord-o;\n    pos1=op+c*(dir+1);\n    pos2=pos1+dir;\n    return c.x>=0 && c.x<s.x && c.y>=0 && c.y<s.y;\n}\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nbool isBigger(vec4 c1, vec4 c2)\n{\n    return colDist(c1,c2)>0.;\n}\n\nvec4 getCol(vec2 coord)\n{\n    return texture(iChannel0,coord/Res1.xy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if( fragCoord.x>Res1.x || fragCoord.y>Res1.y ) discard;\n    if(iPassIndex==0) {vec2 coord=fragCoord; fragColor=vec4(coord,coord); return; }\n    \n    int isVert = (iPassIndex+1)&1;\n    ivec2 dir = (ivec2(0,1)+iPassIndex+1)&1;\n    \n    ivec2 coord=ivec2(fragCoord);\n\n    // copy previous pass\n    fragColor=texelFetch(iChannel1,coord,0);\n    \n    // who are the neighbours?\n    ivec2 pos1, pos2;\n    if (!getNBPixPos(coord,iPassIndex-1,pos1,pos2)) { return; }\n    \n    vec4 coordMinMax1 = texelFetch(iChannel1,pos1,0);\n    vec4 coordMinMax2 = texelFetch(iChannel1,pos2,0);\n    vec4 cmin1=getCol(coordMinMax1.xy);\n    vec4 cmin2=getCol(coordMinMax2.xy);\n    vec4 cmax1=getCol(coordMinMax1.zw);\n    vec4 cmax2=getCol(coordMinMax2.zw);\n    \n    fragColor.xy = isBigger(cmin2,cmin1)?coordMinMax1.xy:coordMinMax2.xy;\n    fragColor.zw = isBigger(cmax1,cmax2)?coordMinMax1.zw:coordMinMax2.zw;\n    // debug pass levels\n    //fragColor.xyz = vec3(0) + float(iPassIndex)/15.;\n    //fragColor.w = 1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// multi scale subdivision\n\n// find voronoi cells\n\n// the effect is fast enough for realtime, but the video framerate is reduced due \n// to \"emulated passes\" (1 pass per frame - unfortunetely there's no passes in shadertoy)\n\n#define Res ResMap\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 ResMap\n#define Res2 vec2(textureSize(iChannel2,0))\n\nvec2 getLevelCoords(vec2 coord, int level, inout vec2 frameCoord)\n{\n\n    ivec2 dir = ivec2(1,0);\n    ivec2 s = ivec2(Res1)/(dir+1);\n    ivec2 sp = s;\n    ivec2 o = ivec2(0);\n    ivec2 op = o;\n    for(int i=0;i<level;i++) {\n        op=o; o+=s*dir;\n        dir=(dir+1)&1;\n        sp=s; s/=dir+1;\n    }\n\n    vec2 c = coord*vec2(s)+vec2(o);\n    frameCoord=fract(c);\n    return (floor(c)+.5)/Res1;\n}\n\n\nvec4 getCol(vec2 uv)\n{\n    return texture(iChannel0,uv);\n}\n\nfloat colDist(vec4 c1, vec4 c2)\n{\n    return dot(c1.xyz-c2.xyz,vec3(.3333));\n}\n\nvoid getCenterScaleColor( vec2 fragCoord, inout vec2 c, inout vec2 s, inout vec4 col )\n{\n    vec2 frameCoord;\n    vec2 fact=ResMap/vec2(512,256);\n    float detail=.2;\n\tfor(int i=11;i>=0;i--)\n    {\n        vec4 coordMinMax=textureLod(iChannel1,getLevelCoords(fragCoord/Res,i,frameCoord)*Res1/iResolution.xy,0.);\n        vec4 mi = getCol(coordMinMax.xy/Res1);\n        vec4 ma = getCol(coordMinMax.zw/Res1);\n        col=mix(mi,ma,1.)*.95+.15;\n        col.w=float(i)/11.;\n        if( abs(colDist(mi,ma))<detail /**float(i+10)/30.*/ ) break;\n    }\n}\n\nvec4 getPixRandS(vec2 pos)\n{\n    //return textureLod(iChannel2,(pos)/Res2,0.)-.5;\n    return textureLod(iChannel2,(floor(pos)+.5)/Res2,0.)-.5;\n}\n\nfloat randness = 0.5;\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    return uv+.6*sin(uv*res*PI2)/PI2/res;\n}\n\nvec4 getRand(vec2 pos)\n{\n    return textureLod(iChannel2,uvSmooth(pos/Res2,Res2),0.);\n}\n\n#define sc (iResolution.x/600.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x>ResMap.x ||fragCoord.y>ResMap.y ) discard;\n    // just render a new frame every NumPasses'th fame, otherwise copy old frame\n    if (iPassIndex!=NumPasses-1) \n    {\n    \tfragColor=texture(iChannel3,fragCoord/iResolution.xy);\n        return;\n    }\n    \n    vec2 c,s;\n    vec4 color=vec4(0);\n    getCenterScaleColor(fragCoord,c,s,color);\n    fragColor=color;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define Res iResolution.xy\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nint LevNum=11;\nvec3 Grid=vec3(1,1,1);\n\nvec4 getCol(vec3 pos, float lev) \n{\n    //if(iFrame<15) return texelFetch(iChannel3,ivec2(pos.xy*0.1)+100,0).wxyz*vec4(.5,.5,.5,1)+vec4(.5,.5,.5,-.3);\n    return textureLod(iChannel0,(pos.xy+ResMap.xy*.5)/iResolution.xy,lev);\n}\nvec4 getCol(vec3 pos) { return getCol(pos,0.); }\n\nbool checkSolid(vec3 pos)\n{\n    float h=getCol(floor(pos)+.5).w*float(LevNum);\n    vec3 c=getCol(floor(pos)+.5).xyz;\n    if(dot(c.xyz,vec3(-1,2,-1))>.3) return false;\n    return abs(pos.z)<h \n        && abs(pos.x)<ResMap.x*.49 \n        && abs(pos.y)<ResMap.y*.49\n        ;\n}\n\nbool gridStep(inout vec3 pos, inout vec3 n, vec3 grid, vec3 dir)\n{\n    float l,lmin=10000.;\n    vec3 s = sign(dir);\n    // find next nearest cube border (.00001 -> step a tiny bit into next cube)\n    vec3 next=floor(pos/grid+s*(.5+.00001)+.5)*grid; // assuming floor(x+1.)==ceil(x)\n    l=(next.x-pos.x)/dir.x; if (l>0. && l<lmin) { lmin=l; n=-vec3(1,0,0)*s; }\n    l=(next.y-pos.y)/dir.y; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,1,0)*s; }\n    l=(next.z-pos.z)/dir.z; if (l>0. && l<lmin) { lmin=l; n=-vec3(0,0,1)*s; }\n    \n    pos+=dir*lmin;\n    return checkSolid(pos-.5*n*grid);\n    //return checkSolid((floor((pos-.5*n*grid)/grid)+.5)*grid);\n}\n\nfloat march(inout vec3 pos, inout vec3 n, vec3 dir)\n{\n    for(int i=0;i<150;i++)\n    {\n        if(gridStep(pos,n,Grid,dir)) return 1.0;\n    }\n    return 0.0;\n}\n\nvoid ROT2(float ang, inout vec2 v)\n{\n    vec2 cs=cos(ang-vec2(0,1.57));\n    v=mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nvec4 myenv(vec3 pos, vec3 dir, float s)\n{\n    return texture(iChannel2,dir.xzy)*1.5;\n;\n}\n\n#define RandTex iChannel3\n\nvec4 getRand(vec2 pos)\n{\n    vec2 tres=vec2(textureSize(RandTex,0));\n    pos*=tres;\n    vec2 fr=fract(pos-.5);\n    vec2 uv=(pos-.7*sin(fr*PI2)/PI2)/tres.xy;\n    return textureLod(RandTex,uv,0.);\n}\n\nvoid getPhiThetaDist(inout float ph, inout float th, inout float dist)\n{\n    ph=(iMouse.x-.5*Res.x)/Res.x*12.6;\n    th=(Res.y-iMouse.y-.5*Res.y)/Res.y*13.6;\n    dist=260.;\n    if(iMouse.x==0.) {\n        vec4 r =getRand(iTime*.02*vec2(1,.001))-getRand(iTime*.02*vec2(1,.001)+10.5);\n        ph += .3*cos((iTime+15.)*.37)+(r.x*.0013);\n        th -= .7*cos((iTime+15.)*.15)+(r.y*.0026);\n        dist+=-100.*cos(iTime*.1);\n    }\n}\n\nvoid transform(inout vec3 v)\n{\n    float ph,th,dist;\n    getPhiThetaDist(ph,th,dist);\n\n    ROT2(th,v.yz); \n    ROT2(ph,v.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ph,th,dist;\n    getPhiThetaDist(ph,th,dist);\n    vec4 r = getRand(iTime*.007*vec2(.002,1))-getRand(iTime*.007*vec2(.003,1)+10.7);\n    \n    vec3 pos=vec3(0,0,dist)+r.xyz*1.;\n    vec3 dir=vec3(0,0,-1);\n    vec3 n=vec3(0,0,1);\n    dir.xy+=(fragCoord-iResolution.xy*.5)/iResolution.x;\n    dir=normalize(dir);\n    \n    transform(pos);\n    transform(dir);\n    \n    vec3 eye=pos;\n    \n    float h0=12.;\n    pos=pos+dir/abs(dir.z)*(abs(pos.z)-h0);\n    \n    float m = march(pos,n,dir);\n    //transform(n);\n    \n    vec4 c=getCol(floor(pos)+.5);\n    \n    // ambient occlusion\n    float ao=1.;\n    for(int i=0;i<7;i++)\n    {\n        float fi=float(i);\n        float l=fi*.7;\n        vec4 c2=getCol(pos,l)*vec4(1,1,1,LevNum);\n        float d = c2.w-abs(pos.z);\n        float s = (1.-sqrt(fi)*.1)*.12;\n        //ao*=d>0.?(1.-d*s):1.;\n        ao*=1.-(step(0.,d))*d*s;\n        ao*=1.-.2*(step(0.,-d))*d*s;\n    }\n    vec2 v=smoothstep(ResMap*.48,ResMap*.49,abs(pos.xy));\n    ao=mix(ao,max(ao,1.),max(v.x,v.y));\n    ao=mix(ao,sqrt(abs(ao)),.5)*.8;\n\n    // specular\n    vec3 R=reflect(normalize(pos-eye),n);\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    //fres*=fres;\n    fres*=fres*sqrt(abs(fres));\n    //fres*=fres*fres;\n    fres=fres*.93+.07;\n    vec3 env=myenv(vec3(pos*.02),R,1.).xyz;\n    //env*=env;\n    \n    fragColor.xyz=vec3(1.);\n    \n    fragColor.xyz=mix(fragColor.xyz,env,fres);    \n    fragColor.xyz *= c.xyz*ao + .05*n;\n    \n    if(m<1.) fragColor.xyz=myenv(vec3(0),dir,1.).xyz;\n    \n    fragColor*=.9;\n\n    //float br=dot(fragColor.xyz,vec3(.3333));\n    //fragColor.xyz = (fragColor.xyz-br)*1.7+br;\n\n    //fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    fragColor.w=1.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}