{
    "Shader": {
        "info": {
            "date": "1479599637",
            "description": "voronoi trencadís\n\ntook stuff from https://www.shadertoy.com/view/4df3DS and iq\n\ninspired by https://twitter.com/thespite/status/800003114161971200",
            "flags": 0,
            "hasliked": 0,
            "id": "ltcXDN",
            "likes": 12,
            "name": "trencadís",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "lebek",
            "viewed": 945
        },
        "renderpass": [
            {
                "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 hash2( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec4 m = vec4( 50.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      vec2  r = g - f + o;\n\t\tfloat d = dot( r, r );\n        \n        if( d < m.x )\n        {\n            m.y = m.x;\n            m.x = d;\n            m.zw = o;   \n        }\n        else if( d < m.y )\n        {\n            m.y = d;\n        }\n    }\n\n\t// height this, height closest, dist to closest border\n    return vec3(m.zw, sqrt(abs(m.y)) - sqrt(abs(m.x)));\n}\n\nvec3 map( vec3 pos)\n{\n\tvec3 v = voronoi(pos.xz);\n\tvec2 r = hash(v.xy)*0.2; // per-building seed\n\t\n\tfloat f = (.01+.3*r.y-v.z)*.5; //.7071; // correct for max gradient of voronoi x+z distance calc\n    \n\t// random height\n\tfloat h = r.x; // v.xy is position of cell centre, use it as random seed\n\th = mix(.01,2.0,pow(h,2.0));\n    h += texture(iChannel0, pos.xz*vec2(0.1)).x*0.002;\n    h += (noise(pos.xz)+.5)*0.1-0.01;\n\th = pos.y-h;\n\n\t// we get precision problems caused by the discontinuity in height\n\t// so clamp it near to the surface and then apply a plane at max height\t\n\th = max( min( h, .08 ), pos.y-2.0 );\n\n//\tf = max( f, h );\n\tif ( f > 0.0 && h > 0.0 )\n\t\tf = sqrt(f*f+h*h); // better distance computation, to reduce errors\n\telse\n\t\tf = max(f,h);\n\t\n\t//f = min( f, pos.y ); // ground plane\n    if (f > pos.y) {\n     \treturn vec3(pos.y, -1, -1);  \n    }\n\treturn vec3(f, r);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    float tmin = 0.1;\n    float tmax = 8.0;\n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    vec2 r = vec2(0);\n    for( int i=0; i<100; i++ )\n    {\n\t    vec3 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    r = res.yz;\n    }\n    \n    if (t >= tmax) return vec3(1.0, 1.0, 1.0);\n\n    \tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n    vec3 sky = texture(iChannel1, ref).xyz;\n    \n    vec3 col = vec3(0.2, 0.2, 0.9); //r.x\n    \n    col = col*pow(sky*1.5, vec3(.8));\n    if (r.x < 0.) col = vec3(.97);\n\n    // lighitng        \n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),18.0);\n        \n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00, 0.9, 0.9);\n\t\tlin += 6.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.10*amb*vec3(0.50,0.70,1.00);\n        lin += 0.30*dom*vec3(0.50,0.70,1.00);\n        lin += 0.30*bac*vec3(0.25,0.25,0.25);\n        lin += 0.40*fre*vec3(1.00,1.00,1.00);\n\t\tcol = col*lin;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n    \n    return col;\n    //return vec3(nor);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 2.0 + 2.0*mo.y, 0.5 + 2.5*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\t//col = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}