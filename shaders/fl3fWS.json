{
    "Shader": {
        "info": {
            "date": "1663563754",
            "description": "Animated balloon that I made with https://bauble.studio.",
            "flags": 0,
            "hasliked": 0,
            "id": "fl3fWS",
            "likes": 21,
            "name": "Balloon Trip",
            "published": 3,
            "tags": [
                "animation",
                "balloon",
                "bauble"
            ],
            "usePreview": 1,
            "username": "ianthehenry",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\nconst int MAX_STEPS = 256;\nconst float MINIMUM_HIT_DISTANCE = 0.1;\nconst float NORMAL_OFFSET = 0.005;\nconst float MAXIMUM_TRACE_DISTANCE = 64.0 * 1024.0;\n\n/*\n\nI created this using https://bauble.studio, although this code has\nbeen formatted to fit your TV.\n\nI recorded a video of myself modeling the balloon (the animation\nhere is a pretty simple modification):\n\nhttps://www.youtube.com/watch?v=0-OtdjiR7dc&list=PLjT5GDnW_UMBS6ih0kG7jWB0n1SnotnEu\n\nThis is the original Bauble source for the image:\n\n    (def bottom (+ -100 -50))\n\n    (defn quantize [x y]\n      (x * y | round / y))\n\n    (def envelope\n      (sphere 100\n      | union :r 50 (cylinder :y 25 50 | move :y -100)\n      | scale\n         :y (ss p.y bottom 100 1 0.80)\n         :z (ss p.y bottom (+ bottom 75) 1 0.50)\n      | onion 0.1\n      | subtract :r 1 (half-space :-y (+ bottom 7))\n      | radial :y 18 (fn [$ i]\n        (resurface $\n          (shade (hsv (/ p.y 100 - (* 0.2 t) | quantize 8) 1 1)\n          | move :y (sin (t * 1.5) | ss * 100 / 8 * (mod i 2))\n          | rotate :x (sin (t / 2) * pi/4)\n          | rotate :y (cos+ t)\n          )\n        | scale :z (mod i 2 * 2 - 1)))\n      | color (* c (ss occlusion 0 0.75 0 1))\n      | fresnel))\n\n    (def flame\n      (cone :-y 50 403\n      | union :r 10 (cone :y 31 148)\n      | bounded-offset 30 :threshold 3\n        (perlin (- (* p [0.05 0.025 0.05]) [0 (* 5 t) 0]))\n      | color (+ (* [1 1 0.7] (ss p.y -72 400))\n        (mix [1 0.25 0] [1 1 0] (- normal.y)))\n      | move :y -72))\n\n\n    (def metal\n      (shade [0.37 0.25 0.21] :gloss 7 :shine 1\n      | fresnel [0.5 0.5 1]))\n\n    (def torch\n      (sphere 20\n      | scale :y 0.75\n      | union :r 3 (cylinder :r 1 :y (+ 20 (sin (p.y * 2))) 2 | move :y 10)\n      | subtract (sphere 20 | move :y 20)\n      | union :r 1 (line [30 10 0] [0 -10 0] 0.5 | union :r 1 (torus :x 2 0.5 | move [30 12 0]) | radial :y 6)\n      | resurface metal\n      ))\n\n    (def basket\n      (box 50\n      | onion 10\n      | subtract :r 10\n        (half-space :y (+ 29 (pow (p.xz / 15) 2 | sum)))\n      | offset (* 0.25 (+\n        (cos (min (abs p.xz) * 3 + (step (sin (* 2 p.y)) 0 * pi/2)) | abs)\n        (sin (p.y * 1) | abs)))\n      | shade (hsv 0.10 0.54 0.88)\n      | union\n        (box [66 5 10] :r 5\n        | move [0 (+ 48 (pow (p.x / 15) 2)) 55]\n        | rotate :y (- tau/8)\n        | mirror :x :z :r 10\n        | rotate :y tau/8\n        | shade [0.4 0.05 0.1] :gloss 3 :shine 0.5\n        | fresnel)))\n\n    (def collar\n      (cylinder :y 50 8 :r 2\n      | subtract :r 4 (cylinder :y 46 100)\n      | union :r 1\n        (union :r 1\n          (cylinder :r 1 :x 4 4 | move :x 48)\n          (cone :r 1 :x 2 2 | move :x 51)\n        | radial :y 12)\n      | rotate :y tau/8\n      | resurface metal\n      ))\n\n    (def basket-corner [10 -38 10])\n    (def basket-ropes\n      (union\n        (line [24 4 6] basket-corner 0.15)\n        (line [17 4 17] basket-corner 0.15)\n        (line [6 4 24] basket-corner 0.15)\n      | mirror :x :z\n      | offset (sin+ (p.y * 20) * 0.01)\n      | shade (hsv 0.1 0.9 0.5)\n      | fresnel 0.05 :exponent 2\n      ))\n\n    (def torch-ropes\n      (line [24 4 6] [9 -10.25 0] 0.1\n      | mirror :z\n      | radial :y 6\n      | resurface metal))\n\n    (union\n      (envelope\n      | color (+ c (* 0.05 [1 1 0]\n        (ss (distance p [0 bottom 0]) 0 150 1 0)\n        (perlin [(* 2 t) 0]))))\n      (bound (union\n        (flame | scale 0.1 | move :y (- bottom 5))\n        (torch | scale 0.3 | move :y (- bottom 14))\n        (basket | scale 0.2 | move :y (- bottom 50))\n        (collar | scale 0.53 | move :y (- bottom -5))\n        (basket-ropes | move :y bottom)\n        (torch-ropes | move :y bottom))\n      (sphere 45 | move :y (- bottom 25)))\n    | rotate :y (sin t * 1.5 + t * 0.1)\n    | move :y 81)\n\n*/\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nstruct Light {\n  vec3 position;\n  vec3 color;\n  float radius;\n};\n\nconst Light lights[1] = Light[1](\n  Light(vec3(512.0, 512.0, 512.0), vec3(1.0), 4096.0)\n);\nfloat s3d_cylinder_0(vec3 p, float radius, float height) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n}\nfloat union_0(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (length(p) - 100.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -100.0, 0.0));\n    _r1 = s3d_cylinder_0(p1, 25.0, 50.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat min3(vec3 p) {\n  return min(p.x, min(p.y, p.z));\n}\nfloat subtract_0(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 scale0_1 = vec3(1.0, ((1.0 * (1.0 + (smoothstep(-150.0, 100.0, p.y) * -0.200000))) * 1.0), (1.0 * (1.0 + (smoothstep(-150.0, -75.0, p.y) * -0.500000))));\n    vec3 p1 = (p / scale0_1);\n    _r1 = (abs((union_0(p1, 50.0) * min3(abs(scale0_1)))) - 0.100000);\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -143.0, 0.0));\n    _r2 = p1.y;\n  }\n  b = _r2;\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat atan2(float y, float x) {\n  return x == 0.0 ? sign(y) * 0.5 * PI : atan(y, x);\n\n}\nmat3 rotate_y(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    c, 0.0, s,\n    0.0, 1.0, 0.0,\n    -s, 0.0, c);\n}\nfloat s3d_cone_0(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat s3d_cone_1(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.xz), height - p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat union_1(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = s3d_cone_0(p, 50.0, 403.0);\n  b = s3d_cone_1(p, 31.0, 148.0);\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nvec3 fade3(vec3 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nvec4 taylor_inv_sqrt4(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 mod289_3(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289_4(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute4(vec4 x) {\n  return mod289_4(((x * 34.0) + 10.0) * x);\n}\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nfloat perlin3(vec3 P) {\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289_3(Pi0);\n  Pi1 = mod289_3(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute4(permute4(ix) + iy);\n  vec4 ixy0 = permute4(ixy + iz0);\n  vec4 ixy1 = permute4(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n  vec4 norm0 = taylor_inv_sqrt4(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylor_inv_sqrt4(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade3(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n\n}\nfloat bound_0(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nfloat union_2(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 scale0_1 = vec3(1.0, 0.750000, 1.0);\n    vec3 p1 = (p / scale0_1);\n    _r1 = ((length(p1) - 20.0) * min3(abs(scale0_1)));\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, 10.0, 0.0));\n    _r2 = (s3d_cylinder_0(p1, ((20.0 + sin((p1.y * 2.0))) - 1.0), 1.0) - 1.0);\n  }\n  b = _r2;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat subtract_1(vec3 p) {\n  float d = union_2(p, 3.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, 20.0, 0.0));\n    _r1 = (length(p1) - 20.0);\n  }\n  d = max(d, -_r1);\n  return d;\n}\nfloat s3d_line(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n\n}\nfloat s3d_torus_0(vec3 p, float major_radius, float minor_radius) {\n  vec2 q = vec2(length(p.yz) - major_radius, p.x);\n  return length(q) - minor_radius;\n\n}\nfloat union_3(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (s3d_line(p, vec3(30.0, 10.0, 0.0), vec3(0.0, -10.0, 0.0)) - 0.500000);\n  float _r1; {\n    vec3 p1 = (p - vec3(30.0, 12.0, 0.0));\n    _r1 = s3d_torus_0(p1, 2.0, 0.500000);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat union_4(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = subtract_1(p);\n  float _r1; {\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    _r1 = union_3(p1, 1.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat s3d_box(vec3 p, vec3 size) {\n  vec3 q = abs(p) - size;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n\n}\nfloat sum2(vec2 p) {\n  return p.x + p.y;\n}\nfloat subtract_2(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (abs(s3d_box(p, vec3(50.0, 50.0, 50.0))) - 10.0);\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, (29.0 + sum2(pow((p.xz / 15.0), vec2(2.0)))), 0.0));\n    _r1 = (-p1.y);\n  }\n  b = _r1;\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat min2(vec2 p) {\n  return min(p.x, p.y);\n}\nvec3 biased_sqrt_xz_0(vec3 p, float r) {\n  p.xz = sqrt(p.xz * p.xz + r * r);\n  return p;\n}\nfloat union_5(vec3 p) {\n  float d = (subtract_2(p, 10.0) - (0.250000 * (abs(cos(((min2(abs(p.xz)) * 3.0) + (step(0.0, sin((2.0 * p.y))) * 1.570796)))) + abs(sin((p.y * 1.0))))));\n  float _r1; {\n    vec3 p1 = (p * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    vec3 p2 = biased_sqrt_xz_0(p1, 10.0);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, -0.707107, 0.0, 1.0, 0.0, 0.707107, 0.0, 0.707107));\n    vec3 p4 = (p3 - vec3(0.0, (0.0 + (48.0 + pow((p3.x / 15.0), 2.0))), 55.0));\n    _r1 = (s3d_box(p4, vec3(61.0, 0.0, 5.0)) - 5.0);\n  }\n  d = min(d, _r1);\n  return d;\n}\nfloat subtract_3(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = (s3d_cylinder_0(p, 48.0, 6.0) - 2.0);\n  b = s3d_cylinder_0(p, 46.0, 100.0);\n  h = clamp(0.5 - 0.5 * (a + b) / r, 0.0, 1.0);\n  a = mix(a, -b, h) + r * h * (1.0 - h);\n\n  return a;\n}\nfloat s3d_cylinder_1(vec3 p, float radius, float height) {\n  vec2 d = abs(vec2(length(p.yz), p.x)) - vec2(radius, height);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n}\nfloat s3d_cone_2(vec3 p, float radius, float height) {\n  vec2 q = vec2(radius, height);\n  vec2 w = vec2(length(p.yz), height - p.x);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n\n}\nfloat union_6(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float _r1; {\n    vec3 p1 = (p - vec3(48.0, 0.0, 0.0));\n    _r1 = (s3d_cylinder_1(p1, 3.0, 3.0) - 1.0);\n  }\n  float a = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(51.0, 0.0, 0.0));\n    float height0_1 = 2.0;\n    float radius0_1 = 2.0;\n    float r0_1 = 1.0;\n    float tip_offset0_1 = (r0_1 * (height0_1 / radius0_1));\n    vec3 p2 = (p1 - vec3(r0_1, 0.0, 0.0));\n    _r2 = (s3d_cone_2(p2, (radius0_1 - r0_1), (height0_1 - tip_offset0_1)) - r0_1);\n  }\n  b = _r2;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nfloat union_7(vec3 p, float r) {\n  float b, h = 0.0;\n  r = max(r, 0.0000000001);\n  float a = subtract_3(p, 4.0);\n  float _r1; {\n    float angle0_1 = 0.523599;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    _r1 = union_6(p1, 1.0);\n  }\n  b = _r1;\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n\n  return a;\n}\nvec3 abs_xz_0(vec3 p) {\n  p.xz = abs(p.xz);\n  return p;\n}\nfloat union_8(vec3 p) {\n  float d = (s3d_line(p, vec3(24.0, 4.0, 6.0), vec3(10.0, -38.0, 10.0)) - 0.150000);\n  d = min(d, (s3d_line(p, vec3(17.0, 4.0, 17.0), vec3(10.0, -38.0, 10.0)) - 0.150000));\n  d = min(d, (s3d_line(p, vec3(6.0, 4.0, 24.0), vec3(10.0, -38.0, 10.0)) - 0.150000));\n  return d;\n}\nvec3 abs_z_0(vec3 p) {\n  p.z = abs(p.z);\n  return p;\n}\nfloat union_9(float t, vec3 p) {\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n    float scale0_1 = 0.100000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n    float magnitude0_1 = 30.0;\n    _r1 = (bound_0(magnitude0_1, t, p3, 3.0) * scale0_1);\n  }\n  float d = _r1;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n    float scale0_1 = 0.300000;\n    vec3 p2 = (p1 / scale0_1);\n    _r2 = (union_4(p2, 1.0) * scale0_1);\n  }\n  d = min(d, _r2);\n  float _r3; {\n    vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n    float scale0_1 = 0.200000;\n    vec3 p2 = (p1 / scale0_1);\n    _r3 = (union_5(p2) * scale0_1);\n  }\n  d = min(d, _r3);\n  float _r4; {\n    vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n    float scale0_1 = 0.530000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    _r4 = (union_7(p3, 1.0) * scale0_1);\n  }\n  d = min(d, _r4);\n  float _r5; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    vec3 p2 = abs_xz_0(p1);\n    _r5 = (union_8(p2) - ((0.500000 * (sin((p1.y * 20.0)) + 1.0)) * 0.010000));\n  }\n  d = min(d, _r5);\n  float _r6; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p1.z, p1.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p2 = ((p1 * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 p3 = abs_z_0(p2);\n    _r6 = (s3d_line(p3, vec3(24.0, 4.0, 6.0), vec3(9.0, -10.250000, 0.0)) - 0.100000);\n  }\n  d = min(d, _r6);\n  return d;\n}\nfloat bound_1(float t, vec3 p, float threshold) {\n  vec3 p1 = (p - vec3(0.0, -175.0, 0.0));\n  float boundary_distance = (length(p1) - 45.0);\n  if (boundary_distance < threshold) {\n    return union_9(t, p);\n  } else {\n    return boundary_distance;\n  }\n}\nfloat union_10(float t, vec3 p) {\n  float _r1; {\n    float angle0_1 = 0.349066;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 scale0_1 = vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0)));\n    vec3 p2 = (p1 / scale0_1);\n    _r1 = (subtract_0(p2, 1.0) * min3(abs(scale0_1)));\n  }\n  float d = _r1;\n  d = min(d, bound_1(t, p, 1.0));\n  return d;\n}\nfloat bound_2(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nvec3 fresnel(vec3 normal, vec3 P, vec3 camera_origin, vec3 color, float strength, float exponent) {\n  vec3 view_dir = normalize(camera_origin - P);\n  float fresnel = pow(1.0 - dot(normal, view_dir), exponent);\n  return color * strength * fresnel;\n\n}\nvec3 blinn_phong(vec3 normal, float occlusion, vec3 P, float light_intensities[1], vec3 camera_origin, vec3 color, float shine, float gloss, float ambient) {\n  vec3 view_dir = normalize(camera_origin - P);\n  vec3 result = color * ambient;\n  for (int i = 0; i < lights.length(); i++) {\n    vec3 light_color = lights[i].color * light_intensities[i];\n    vec3 light_dir = normalize(lights[i].position - P);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n    float specular_strength = shine * pow(max(dot(normal, halfway_dir), 0.0), gloss * gloss);\n    float diffuse = max(0.0, dot(normal, light_dir));\n    result += light_color * specular_strength;\n    result += color * diffuse * light_color;\n  }\n  return result;\n\n}\nmat3 rotate_x(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, -s,\n    0.0, s, c);\n}\nvec3 hsv(float h, float s, float v) {\n  vec3 p = abs(fract(vec3(h, h, h) + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n  return v * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), s);\n\n}\nvec2 fade2(vec2 t) {\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Perlin noise functions by Stefan Gustavson\n// https://github.com/stegu/webgl-noise\nfloat perlin2(vec2 P) {\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289_4(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute4(permute4(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x, gy.x);\n  vec2 g10 = vec2(gx.y, gy.y);\n  vec2 g01 = vec2(gx.z, gy.z);\n  vec2 g11 = vec2(gx.w, gy.w);\n\n  vec4 norm = taylor_inv_sqrt4(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade2(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\nfloat bound_3(float magnitude0_, float t, vec3 p, float threshold) {\n  float boundary_distance = (union_1(p, 10.0) - magnitude0_);\n  if (boundary_distance < threshold) {\n    return (union_1(p, 10.0) - (magnitude0_ * perlin3(((p * vec3(0.050000, 0.025000, 0.050000)) - vec3(0.0, (5.0 * t), 0.0)))));\n  } else {\n    return boundary_distance;\n  }\n}\nvec3 union_color_0(vec3 normal, vec3 p, float r) {\n  float b, h;\n  r = max(r, 0.0000000001);\n  float a = s3d_cone_0(p, 50.0, 403.0);\n  vec3 color = (0.500000 * (1.0 + normal));\n  b = s3d_cone_1(p, 31.0, 148.0);\n  h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n  a = mix(b, a, h) - r * h * (1.0 - h);\n  color = mix((0.500000 * (1.0 + normal)), color, h);\n  return color;\n}\nvec3 union_color_1(vec3 p, vec3 normal, float occlusion, vec3 P, float light_intensities[1], vec3 camera_origin) {\n  float d = (subtract_2(p, 10.0) - (0.250000 * (abs(cos(((min2(abs(p.xz)) * 3.0) + (step(0.0, sin((2.0 * p.y))) * 1.570796)))) + abs(sin((p.y * 1.0))))));\n  float d2;\n  int surface = 0;\n  vec3 color;\n  float _r1; {\n    vec3 p1 = (p * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    vec3 p2 = biased_sqrt_xz_0(p1, 10.0);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, -0.707107, 0.0, 1.0, 0.0, 0.707107, 0.0, 0.707107));\n    vec3 p4 = (p3 - vec3(0.0, (0.0 + (48.0 + pow((p3.x / 15.0), 2.0))), 55.0));\n    _r1 = (s3d_box(p4, vec3(61.0, 0.0, 5.0)) - 5.0);\n  }\n  d2 = _r1;\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  switch (surface) {\n  case 0:\n    color = blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.880000, 0.689920, 0.404800), 0.250000, 4.0, 0.200000);\n    break;\n  case 1:\n    color = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.400000, 0.050000, 0.100000), 0.500000, 3.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.250000, 5.0));\n    break;\n  }\n  return color;\n}\nvec3 union_color_2(vec3 p, vec3 normal, float occlusion, vec3 P, float t, float light_intensities[1], vec3 camera_origin) {\n  float _r1; {\n    vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n    float scale0_1 = 0.100000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n    float magnitude0_1 = 30.0;\n    _r1 = (bound_3(magnitude0_1, t, p3, 3.0) * scale0_1);\n  }\n  float d = _r1;\n  float d2;\n  int surface = 0;\n  vec3 color;\n  float _r2; {\n    vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n    float scale0_1 = 0.300000;\n    vec3 p2 = (p1 / scale0_1);\n    _r2 = (union_4(p2, 1.0) * scale0_1);\n  }\n  d2 = _r2;\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  float _r3; {\n    vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n    float scale0_1 = 0.200000;\n    vec3 p2 = (p1 / scale0_1);\n    _r3 = (union_5(p2) * scale0_1);\n  }\n  d2 = _r3;\n  if (d2 < d) {\n    d = d2;\n    surface = 2;\n  }\n  float _r4; {\n    vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n    float scale0_1 = 0.530000;\n    vec3 p2 = (p1 / scale0_1);\n    vec3 p3 = (p2 * mat3(0.707107, 0.0, 0.707107, 0.0, 1.0, 0.0, -0.707107, 0.0, 0.707107));\n    _r4 = (union_7(p3, 1.0) * scale0_1);\n  }\n  d2 = _r4;\n  if (d2 < d) {\n    d = d2;\n    surface = 3;\n  }\n  float _r5; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    vec3 p2 = abs_xz_0(p1);\n    _r5 = (union_8(p2) - ((0.500000 * (sin((p1.y * 20.0)) + 1.0)) * 0.010000));\n  }\n  d2 = _r5;\n  if (d2 < d) {\n    d = d2;\n    surface = 4;\n  }\n  float _r6; {\n    vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n    float angle0_1 = 1.047198;\n    float index0_1 = floor((mod((atan2(p1.z, p1.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p2 = ((p1 * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 p3 = abs_z_0(p2);\n    _r6 = (s3d_line(p3, vec3(24.0, 4.0, 6.0), vec3(9.0, -10.250000, 0.0)) - 0.100000);\n  }\n  d2 = _r6;\n  if (d2 < d) {\n    d = d2;\n    surface = 5;\n  }\n  switch (surface) {\n  case 0:\n    vec3 _r7; {\n      vec3 p1 = (p - vec3(0.0, -155.0, 0.0));\n      vec3 p2 = (p1 / 0.100000);\n      vec3 p3 = (p2 - vec3(0.0, -72.0, 0.0));\n      vec3 color0_1 = union_color_0(normal, p3, 10.0);\n      _r7 = ((vec3(1.0, 1.0, 0.700000) * smoothstep(-72.0, 400.0, p3.y)) + mix(vec3(1.0, 0.250000, 0.0), vec3(1.0, 1.0, 0.0), (-normal.y)));\n    }\n    color = _r7;\n    break;\n  case 1:\n    vec3 _r8; {\n      vec3 p1 = (p - vec3(0.0, -164.0, 0.0));\n      vec3 p2 = (p1 / 0.300000);\n      _r8 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r8;\n    break;\n  case 2:\n    vec3 _r9; {\n      vec3 p1 = (p - vec3(0.0, -200.0, 0.0));\n      vec3 p2 = (p1 / 0.200000);\n      _r9 = union_color_1(p2, normal, occlusion, P, light_intensities, camera_origin);\n    }\n    color = _r9;\n    break;\n  case 3:\n    vec3 _r10; {\n      vec3 p1 = (p - vec3(0.0, -145.0, 0.0));\n      vec3 p2 = (p1 / 0.530000);\n      _r10 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r10;\n    break;\n  case 4:\n    vec3 _r11; {\n      vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n      _r11 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.500000, 0.320000, 0.050000), 0.250000, 4.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.050000, 2.0));\n    }\n    color = _r11;\n    break;\n  case 5:\n    vec3 _r12; {\n      vec3 p1 = (p - vec3(0.0, -150.0, 0.0));\n      _r12 = (blinn_phong(normal, occlusion, P, light_intensities, camera_origin, vec3(0.370000, 0.250000, 0.210000), 1.0, 7.0, 0.200000) + fresnel(normal, P, camera_origin, vec3(0.500000, 0.500000, 1.0), 0.250000, 5.0));\n    }\n    color = _r12;\n    break;\n  }\n  return color;\n}\nvec3 union_color_3(vec3 p, vec3 normal, float occlusion, vec3 P, float t, float light_intensities[1], vec3 camera_origin) {\n  float _r1; {\n    float angle0_1 = 0.349066;\n    float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n    vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n    vec3 scale0_1 = vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0)));\n    vec3 p2 = (p1 / scale0_1);\n    _r1 = (subtract_0(p2, 1.0) * min3(abs(scale0_1)));\n  }\n  float d = _r1;\n  float d2;\n  int surface = 0;\n  vec3 color;\n  d2 = bound_1(t, p, 1.0);\n  if (d2 < d) {\n    d = d2;\n    surface = 1;\n  }\n  switch (surface) {\n  case 0:\n    vec3 _r2; {\n      float angle0_1 = 0.349066;\n      float index0_1 = floor((mod((atan2(p.z, p.x) + (0.500000 * angle0_1)), 6.283185) / angle0_1));\n      vec3 p1 = ((p * rotate_y((index0_1 * angle0_1))) - vec3(0.0, 0.0, 0.0));\n      vec3 p2 = (p1 / vec3(1.0, 1.0, (1.0 * ((mod(index0_1, 2.0) * 2.0) - 1.0))));\n      vec3 p3 = (p2 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (0.500000 * (cos(t) + 1.0))))));\n      vec3 p4 = (p3 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_x((1.0 * (sin((t / 2.0)) * 0.785398)))));\n      vec3 p5 = (p4 - vec3(0.0, (0.0 + (((smoothstep(0.0, 1.0, sin((t * 1.500000))) * 100.0) / 8.0) * mod(index0_1, 2.0))), 0.0));\n      vec3 color1_1 = blinn_phong(normal, occlusion, P, light_intensities, camera_origin, hsv((round((((p5.y / 100.0) - (0.200000 * t)) * 8.0)) / 8.0), 1.0, 1.0), 0.250000, 4.0, 0.200000);\n      vec3 color0_1 = ((color1_1 * (0.0 + (smoothstep(0.0, 0.750000, occlusion) * 1.0))) + fresnel(normal, P, camera_origin, vec3(1.0, 1.0, 1.0), 0.250000, 5.0));\n      _r2 = (color0_1 + ((vec3(0.050000, 0.050000, 0.0) * (1.0 + (smoothstep(0.0, 150.0, distance(p, vec3(0.0, -150.0, 0.0))) * -1.0))) * perlin2(vec2((2.0 * t), 0.0))));\n    }\n    color = _r2;\n    break;\n  case 1:\n    color = union_color_2(p, normal, occlusion, P, t, light_intensities, camera_origin);\n    break;\n  }\n  return color;\n}\nfloat nearest_distance(vec3 p) {\n  float t = iTime;\n  vec3 p1 = (p - vec3(0.0, 81.0, 0.0));\n  vec3 p2 = (p1 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (((sin(t) * 1.500000) + t) * 0.100000)))));\n  return union_10(t, p2);\n}\n\nvec3 calculate_normal(vec3 p) {\n  const vec3 step = vec3(NORMAL_OFFSET, 0.0, 0.0);\n\n  return normalize(vec3(\n    nearest_distance(p + step.xyy) - nearest_distance(p - step.xyy),\n    nearest_distance(p + step.yxy) - nearest_distance(p - step.yxy),\n    nearest_distance(p + step.yyx) - nearest_distance(p - step.yyx)\n  ));\n}\n\nfloat calculate_occlusion(vec3 p, vec3 normal) {\n  const int step_count = 10;\n  const float max_distance = 10.0;\n  const float step_size = max_distance / float(step_count);\n  float baseline = nearest_distance(p);\n  float occlusion = 0.0;\n  vec3 step = normal * step_size;\n  for (int i = 1; i <= step_count; i++) {\n    float expected_distance = baseline + float(i) * step_size;\n    float actual_distance = max(nearest_distance(p + float(i) * step), 0.0);\n    occlusion += actual_distance / expected_distance;\n  }\n  occlusion /= float(step_count);\n  return clamp(occlusion, 0.0, 1.0);\n}\n\nfloat cast_light(vec3 p, vec3 light, float radius) {\n  vec3 direction = normalize(light - p);\n  float light_distance = distance(light, p);\n\n  float light_brightness = 1.0 - (light_distance / radius);\n  if (light_brightness <= 0.0) {\n    return 0.0;\n  }\n\n  float in_light = 1.0;\n  float sharpness = 16.0;\n\n  float last_distance = 1e20;\n  float progress = MINIMUM_HIT_DISTANCE;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    if (progress > light_distance) {\n      return in_light * light_brightness;\n    }\n\n    float distance = nearest_distance(p + progress * direction);\n\n    if (distance < MINIMUM_HIT_DISTANCE) {\n      return 0.0;\n    }\n\n    float intersect_offset = distance * distance / (2.0 * last_distance);\n    float intersect_distance = sqrt(distance * distance - intersect_offset * intersect_offset);\n    if (distance < last_distance) {\n      in_light = min(in_light, sharpness * intersect_distance / max(0.0, progress - intersect_offset));\n    }\n    progress += distance;\n    last_distance = distance;\n  }\n  return 0.0;\n}\n\nvec3 march(vec3 ray_origin, vec3 ray_direction, out int steps) {\n  float distance = 0.0;\n\n  for (steps = 0; steps < MAX_STEPS; steps++) {\n    vec3 p = ray_origin + distance * ray_direction;\n    float nearest = nearest_distance(p);\n    if (nearest < MINIMUM_HIT_DISTANCE || distance > MAXIMUM_TRACE_DISTANCE) {\n      return p + nearest * ray_direction;\n    }\n\n    distance += nearest;\n  }\n  return ray_origin + distance * ray_direction;\n}\n\nvec3 nearest_color(vec3 p, vec3 camera_origin) {\n  float t = iTime;\n  vec3 normal = calculate_normal(p);\n  float occlusion = calculate_occlusion(p, normal);\n  vec3 P = p;\n  float light_intensities[1];\n  light_intensities[0] = cast_light(p + 2.0 * MINIMUM_HIT_DISTANCE * normal, lights[0].position, lights[0].radius);\n  vec3 p1 = (p - vec3(0.0, 81.0, 0.0));\n  vec3 p2 = (p1 * (mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0) * rotate_y((1.0 * (((sin(t) * 1.500000) + t) * 0.100000)))));\n  return union_color_3(p2, normal, occlusion, P, t, light_intensities, camera_origin);\n}\n\nvec3 perspective(float fov, vec2 size, vec2 pos) {\n  vec2 xy = pos - size * 0.5;\n\n  float cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\n  float z = min(size.x, size.y) * 0.5 * cot_half_fov;\n\n  return normalize(vec3(xy, -z));\n}\n\nmat3 rotate_xy(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(\n    c.y, 0.0, -s.y,\n    s.y * s.x, c.x, c.y * s.x,\n    s.y * c.x, -s.x, c.y * c.x\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float gamma = 2.2;\n  vec2 resolution = iResolution.xy;\n  vec2 local_coord = gl_FragCoord.xy;\n\n  vec3 camera_origin = vec3(0.0, 50.0 + 20.0 * sin(iTime * 0.25), 420.0);\n  vec2 rotation = vec2(-0.125, 0.125 - 0.5 * sin(iTime * 0.25));\n  if (iMouse.z > 0.0) {\n    vec2 mouse_offset = (iMouse.xy / resolution) - 0.5;\n    mouse_offset *= vec2(-1.0, 1.0);\n    rotation += mouse_offset;\n  }\n  mat3 camera_matrix = rotate_xy(rotation.yx);\n\n  camera_origin = camera_matrix * camera_origin + vec3(0.0, -32.0, 0.0);\n\n  int view_type = 1;\n\n  vec3 dir = camera_matrix * perspective(45.0, resolution, gl_FragCoord.xy);\n\n  const vec3 fog_color = vec3(0.15);\n\n  int steps;\n  vec3 hit = march(camera_origin, dir, steps);\n\n  vec3 color;\n  float depth = distance(camera_origin, hit);\n  if (depth >= MAXIMUM_TRACE_DISTANCE) {\n    const vec3 light = pow(vec3(69.0, 128.0, 230.0) / vec3(255.0), vec3(gamma));\n    const vec3 dark = pow(vec3(40.0, 60.0, 150.0) / vec3(255.0), vec3(gamma));\n    color = vec3(mix(dark, light, (local_coord.x + local_coord.y) / (resolution.x + resolution.y)));\n  } else {\n    color = nearest_color(hit, camera_origin);\n  }\n\n  fragColor = vec4(pow(color, vec3(1.0 / gamma)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}