{
    "Shader": {
        "info": {
            "date": "1584017062",
            "description": "shader from picsArt",
            "flags": 0,
            "hasliked": 0,
            "id": "3dlcRr",
            "likes": 1,
            "name": "picsArt shader 1",
            "published": 3,
            "tags": [
                "picsart"
            ],
            "usePreview": 0,
            "username": "Valdex",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "#define scaleFactor 1.\n#define textureSize iChannelResolution[0]\n#define type 3.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 vColor = texture(iChannel0, uv);\n    \n    float fXIndex = uv.x*iChannelResolution[0].x;\n    float fYIndex = uv.y*iChannelResolution[0].x;\n    mat3 convolutionMatrix = mat3(0.);\n    if (type == 1.) {\n        \n  \t\tconvolutionMatrix = mat3( 0.045, 0.122, 0.045,\n                                  0.122, 0.332, 0.122,\n  \t\t\t\t\t\t\t\t  0.045, 0.122, 0.045); // gaussian\n  \n    } else if (type == 2.) {\n\n  \t\tconvolutionMatrix = mat3(  -1.0, -1.0, -1.0,\n    \t\t\t\t\t\t\t   -1.0,  9.0, -1.0,\n    \t\t\t\t\t\t\t   -1.0, -1.0, -1.0);  // unsharpen\n\n    } else {\n\n    \tconvolutionMatrix = mat3( -2.0, -1.0,  0.0,\n       \t\t\t\t\t\t\t  -1.0,  1.0,  1.0,\n       \t\t\t\t\t\t\t   0.0,  1.0,  2.0);  //emboss\n        \n    }\n    \n    if( ! ( fYIndex < 1.0 || fYIndex > iChannelResolution[0].y - 1.0 || \n            fXIndex < 1.0 || fXIndex > iChannelResolution[0].x - 1.0 ))\n    {\n    \tfloat redXSum = vColor.r*convolutionMatrix[1][1];\n    \t//float redYSum = 0.0;\n    \n    \tfloat greenXSum = vColor.g*convolutionMatrix[1][1];\n    \t//float greenYSum = 0.0;\n    \n    \tfloat blueXSum = vColor.b*convolutionMatrix[1][1];\n    \t//float blueYSum = 0.0;\n    \t\n    \tfloat fTempX = ( fXIndex  -1.0 + 0.5 ) / iChannelResolution[0].x ;\n        float fTempY = ( fYIndex  -1.0 + 0.5 ) / iChannelResolution[0].y ;\n        vec4 vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][0]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][0]*vTempColor.g;\n        blueXSum = blueXSum +  convolutionMatrix[0][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x;\n        fTempY = ( fYIndex  -scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][2]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][2]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[0][2]*vTempColor.b;\n        \n        fTempX = ( fXIndex -scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex  + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum+convolutionMatrix[1][0]*vTempColor.r;\n        greenXSum = greenXSum+convolutionMatrix[1][0]*vTempColor.g;\n        blueXSum = blueXSum+convolutionMatrix[1][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex  + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum+convolutionMatrix[1][2]*vTempColor.r;\n        greenXSum = greenXSum+convolutionMatrix[1][2]*vTempColor.g;\n        blueXSum = blueXSum+convolutionMatrix[1][2]*vTempColor.b;\n        \n        fTempX = ( fXIndex -scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum +convolutionMatrix[2][0]*vTempColor.r;\n        greenXSum = greenXSum +convolutionMatrix[2][0]*vTempColor.g;\n        blueXSum = blueXSum + +convolutionMatrix[2][0]*vTempColor.b;\n        \n        fTempX = ( fXIndex +scaleFactor + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y ;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n         // X Direction\n        redXSum = redXSum +convolutionMatrix[2][2]*vTempColor.r;\n        greenXSum = greenXSum +convolutionMatrix[2][2]*vTempColor.g;\n        blueXSum = blueXSum +convolutionMatrix[2][2]*vTempColor.b;\n        \n        \n        fTempX = ( fXIndex  + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex -scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        redXSum = redXSum + convolutionMatrix[0][1]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[0][1]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[0][1]*vTempColor.b;\n        \n        fTempX = ( fXIndex  + 0.5 ) / textureSize.x ;\n        fTempY = ( fYIndex +scaleFactor + 0.5 ) / textureSize.y;\n        vTempColor = texture(iChannel0, vec2(fTempX,fTempY));\n        \n        // X Direction\n        \n        redXSum = redXSum + convolutionMatrix[2][1]*vTempColor.r;\n        greenXSum = greenXSum + convolutionMatrix[2][1]*vTempColor.g;\n        blueXSum = blueXSum + convolutionMatrix[2][1]*vTempColor.b;\n        \n        \n        \n        float oneFloat = float(1.0);\n        float zeroFloat = float(0.0);\n        \n        if(redXSum<zeroFloat){\n        \tredXSum = zeroFloat;\n        }\n        \n        if(redXSum>oneFloat){\n        \tredXSum = oneFloat;\n        }\n        \n        if(greenXSum<zeroFloat){\n        \tgreenXSum = zeroFloat;\n        }\n        \n        if(greenXSum>oneFloat){\n        \tgreenXSum = oneFloat;\n        }\n        \n        \n        if(blueXSum<zeroFloat){\n        \tblueXSum = zeroFloat;\n        }\n        \n        if(blueXSum>oneFloat){\n        \tblueXSum = oneFloat;\n        }\n        /*\n        redXSum = 1.0 - redXSum;\n        greenXSum = 1.0-greenXSum;\n        blueXSum = 1.0-blueXSum;\n        \n        float sum = (redXSum+greenXSum+blueXSum)/3.0;*/\n        \n        vColor.r = redXSum;\n        vColor.g = greenXSum;\n        vColor.b = blueXSum;\n        //vColor = vec4((1.0-fRedTotalSum),(1.0-fGreenTotalSum),(1.0-fBlueTotalSum),vColor.a);\n    }\n    else\n    {\n    \tvColor.r=1.0;\n    \tvColor.g = 1.0;\n    \tvColor.b = 1.0;\n    }\n    \n    fragColor = vColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}