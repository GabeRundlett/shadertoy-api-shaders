{
    "Shader": {
        "info": {
            "date": "1583349758",
            "description": "Intro shader for Chaosflux (www.chaosflux.de/en/)",
            "flags": 8,
            "hasliked": 0,
            "id": "ttGXzt",
            "likes": 8,
            "name": "Chaosflux Intro shader",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "sound",
                "bezier",
                "bassdrum",
                "svg",
                "chaosflux"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "\n/*\nTweak audio offset at the beginning of the common tab if video and sound are out of sync\nThe logo is generated with a script from svg (see https://www.shadertoy.com/view/Wtt3Wl)\nMost handwritten code is in common tab.\n*/\n\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tconst int num_its=3;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tfor(int i=ZERO;i<3;i++){\n\t\tt=params[i];\n\t\tfor(int j=ZERO;j<num_its;j++){\n\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t}\n\t\tt=clamp(t,0.,1.);\n\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t}\n\n\treturn d0;\n}\n\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n    \n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n        nor=vec2(nor.y,-nor.x);\n        \n        float sgn;\n        \n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n        else{\n            sgn=-1.;\n        }\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints = 0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n    else{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nfloat c1_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[45] p=vec2[](vec2(-0.105141,0.182258),\n\t                  vec2(-0.11508,0.164798),\n\t                  vec2(-0.11508,0.164798),\n\t                  vec2(-0.0522583,0.12777),\n\t                  vec2(-0.0366835,0.071916),\n\t                  vec2(-0.0232558,0.0237615),\n\t                  vec2(-0.0335432,-0.0292464),\n\t                  vec2(-0.0183582,-0.0897851),\n\t                  vec2(-0.0314756,-0.108016),\n\t                  vec2(-0.0494529,-0.125753),\n\t                  vec2(-0.066798,-0.140289),\n\t                  vec2(-0.0946587,-0.163637),\n\t                  vec2(-0.120175,-0.179013),\n\t                  vec2(-0.120175,-0.179013),\n\t                  vec2(-0.109808,-0.196231),\n\t                  vec2(-0.109808,-0.196231),\n\t                  vec2(-0.0830266,-0.180124),\n\t                  vec2(-0.0538651,-0.155685),\n\t                  vec2(-0.0393691,-0.143537),\n\t                  vec2(-0.0241098,-0.129402),\n\t                  vec2(-0.0111155,-0.113782),\n\t                  vec2(-0.00953226,-0.118148),\n\t                  vec2(-0.00781082,-0.122568),\n\t                  vec2(-0.00589974,-0.127012),\n\t                  vec2(0.0111504,-0.166663),\n\t                  vec2(0.0429379,-0.184876),\n\t                  vec2(0.0695119,-0.192438),\n\t                  vec2(0.0960858,-0.2),\n\t                  vec2(0.118602,-0.197645),\n\t                  vec2(0.118602,-0.197645),\n\t                  vec2(0.116566,-0.177646),\n\t                  vec2(0.116566,-0.177646),\n\t                  vec2(0.0976779,-0.179565),\n\t                  vec2(0.074988,-0.173109),\n\t                  vec2(0.0522982,-0.166652),\n\t                  vec2(0.0269573,-0.152586),\n\t                  vec2(0.0125464,-0.119072),\n\t                  vec2(0.00466514,-0.100628),\n\t                  vec2(-0.000302719,-0.0809023),\n\t                  vec2(-0.00305472,-0.0624878),\n\t                  vec2(-0.0101084,-0.0146491),\n\t                  vec2(-0.00427636,0.0305246),\n\t                  vec2(-0.0173262,0.0773271),\n\t                  vec2(-0.0359264,0.144031),\n\t                  vec2(-0.105141,0.182258));\n\n\tivec2[3] seg=ivec2[](ivec2(0,1),\n\t                     ivec2(13,14),\n\t                     ivec2(29,30));\n\n\tivec4[14] c_bez=ivec4[](ivec4(1,2,3,4),\n\t                        ivec4(4,5,6,7),\n\t                        ivec4(7,8,9,10),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(14,15,16,17),\n\t                        ivec4(17,18,19,20),\n\t                        ivec4(20,21,22,23),\n\t                        ivec4(23,24,25,26),\n\t                        ivec4(26,27,28,29),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,0));\n\n\tif(all(lessThan(uv,vec2(0.118602,0.182258)+border)) && all(greaterThan(uv,vec2(-0.120175,-0.2)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<14;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat c2_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[20] p=vec2[](vec2(0.115786,0.105228),\n\t                  vec2(0.115786,0.105228),\n\t                  vec2(0.0749222,0.0961511),\n\t                  vec2(0.0326449,0.0753585),\n\t                  vec2(-0.00963247,0.0545663),\n\t                  vec2(-0.0555063,0.0214215),\n\t                  vec2(-0.0606167,-0.0293583),\n\t                  vec2(-0.0700874,-0.123468),\n\t                  vec2(-0.0190461,-0.184747),\n\t                  vec2(-0.0190461,-0.184747),\n\t                  vec2(-0.00365474,-0.171851),\n\t                  vec2(-0.00365474,-0.171851),\n\t                  vec2(-0.0492953,-0.117546),\n\t                  vec2(-0.040622,-0.0313615),\n\t                  vec2(-0.0366603,0.00800584),\n\t                  vec2(0.00178575,0.0377826),\n\t                  vec2(0.0415353,0.0573318),\n\t                  vec2(0.0812846,0.0768809),\n\t                  vec2(0.120178,0.0856193),\n\t                  vec2(0.120178,0.0856193));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(19,0));\n\n\tivec4[6] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(3,4,5,6),\n\t                       ivec4(6,7,8,9),\n\t                       ivec4(10,11,12,13),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19));\n\n\tif(all(lessThan(uv,vec2(0.120178,0.105228)+border)) && all(greaterThan(uv,vec2(-0.0700874,-0.184747)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<6;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat f_dis(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[51] p=vec2[](vec2(0.109562,0.2),\n\t                  vec2(0.109562,0.2),\n\t                  vec2(0.037349,0.170164),\n\t                  vec2(0.0173221,0.0971424),\n\t                  vec2(0.00947485,0.0701233),\n\t                  vec2(0.00781763,0.0430998),\n\t                  vec2(0.00790292,0.0164592),\n\t                  vec2(0.00797488,-0.00543141),\n\t                  vec2(0.00806484,-0.0253073),\n\t                  vec2(-0.00108769,-0.0567024),\n\t                  vec2(-0.00608919,-0.0738517),\n\t                  vec2(-0.0187514,-0.092047),\n\t                  vec2(-0.034038,-0.108926),\n\t                  vec2(-0.0445917,-0.120389),\n\t                  vec2(-0.0556361,-0.13091),\n\t                  vec2(-0.0668022,-0.140296),\n\t                  vec2(-0.094663,-0.163644),\n\t                  vec2(-0.120179,-0.17902),\n\t                  vec2(-0.120179,-0.17902),\n\t                  vec2(-0.109812,-0.196239),\n\t                  vec2(-0.109812,-0.196239),\n\t                  vec2(-0.0830308,-0.180131),\n\t                  vec2(-0.0538693,-0.155692),\n\t                  vec2(-0.0442579,-0.147632),\n\t                  vec2(-0.0348368,-0.138945),\n\t                  vec2(-0.026665,-0.130701),\n\t                  vec2(-0.00684664,-0.110669),\n\t                  vec2(0.010864,-0.0874883),\n\t                  vec2(0.0182046,-0.0623181),\n\t                  vec2(0.0280318,-0.0286219),\n\t                  vec2(0.0280435,-0.00538805),\n\t                  vec2(0.0279668,0.0165335),\n\t                  vec2(0.0279309,0.0276838),\n\t                  vec2(0.0278949,0.0385177),\n\t                  vec2(0.0290266,0.0507666),\n\t                  vec2(0.0331576,0.0530595),\n\t                  vec2(0.0373322,0.0552654),\n\t                  vec2(0.0415317,0.0573307),\n\t                  vec2(0.081281,0.0768799),\n\t                  vec2(0.120179,0.0856134),\n\t                  vec2(0.120179,0.0856134),\n\t                  vec2(0.115781,0.105222),\n\t                  vec2(0.115781,0.105222),\n\t                  vec2(0.0750217,0.0961694),\n\t                  vec2(0.0328012,0.0754328),\n\t                  vec2(0.0338771,0.0806009),\n\t                  vec2(0.0351061,0.0859649),\n\t                  vec2(0.0367155,0.0918335),\n\t                  vec2(0.0538191,0.154196),\n\t                  vec2(0.117361,0.181442),\n\t                  vec2(0.117362,0.181442));\n\n\tivec2[3] seg=ivec2[](ivec2(18,19),\n\t                     ivec2(40,41),\n\t                     ivec2(50,0));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(41,42,43,44),\n\t                        ivec4(44,45,46,47),\n\t                        ivec4(47,48,49,50));\n\n\tif(all(lessThan(uv,vec2(0.120179,0.2)+border)) && all(greaterThan(uv,vec2(-0.120179,-0.196239)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*sqrt(dis_sq);\n}\n\nfloat func(float x, float y){\n\n\tx=abs(mod(x,2.)-1.);\n\n\treturn (((-2.*y)*x)+(3.*y))*x*x;\n}\n\nfloat func_derv(float x, float y){\n\n\tx=abs(mod(x,2.)-1.);\n\n\treturn 6.*y*x*(1.-x);\n}\n\nfloat wallpaper_dis(vec2 uv, float wavelen){\n\tuv.y=abs(mod(uv.y,wavelen)-wavelen/2.);\n\n\tfloat dis=1e38;\n\n\tfor(float i=0.;i<4.;i+=1.){\n\n\t\tfloat x=uv.x*2./wavelen;\n\t\tfloat y=wavelen/2.*(.65+i*.05);\n\n\t\tvec2 grad=vec2(2./wavelen*func_derv(x,y),1);\n\n\t\tfloat cur_dis=abs(uv.y-func(x,y))/length(grad);\n\n\t\tdis=min(cur_dis,dis);\n\t}\n\n\treturn dis;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\n\tborder=2./iResolution.y;\n\n\tfloat zoom=1.7;\n\n\tuv*=zoom;\n\tborder*=zoom;\n    \n\tvec3 bg_col=chaosflux_color2;\n    vec3 pattern_col=chaosflux_color3;\n\n\tconst vec3 disk_col=black;\n\tconst vec3 font_col=white;\n\n\tvec3 color=bg_col;\n\n\tfloat dis=1e38;\n    \n    float thickness=.002;\n\tfloat wavelen=.6;\n\n\tfloat disk_alpha1=1.;\n\tfloat disk_alpha2=1.;\n\tfloat disk_alpha3=1.;\n    \n    float t0=iTime-(pattern_start_time+audio_offset+pattern2_start_time);\n    \n    vec2 lb=last_beat(t0);\n\n    float t1=disk_animation(t0);\n    float t2=disk_animation(lb.x);\n    \n    if(t0<smooth_movement_time){\n    \tt1=t2;\n    }\n    \n    vec3 fp=fade_pattern(iTime);\n\n    disk_alpha1=fp.x;\n    disk_alpha2=fp.y;\n    disk_alpha3=fp.z;\n\n    dis=min(dis,wave_pattern(iTime,uv));\n    float fade=1.-smoothstep(-wave_border,wave_border,dis);\n    dis=1e38;\n\n    dis=min(dis,wallpaper_dis(uv,wavelen)-thickness);\n    dis=min(dis,wallpaper_dis(uv.yx,wavelen)-thickness);\n    vec3 pattern_color=mix(pattern_col,color,smoothstep(-border/2.,border/2.,dis));\n    color=mix(pattern_color,color,fade);\n    dis=1e38;\n\n\tvec2 disk_center1=t1*original_disk_center1;\n\tvec2 disk_center2=t1*original_disk_center2;\n\tvec2 disk_center3=t1*original_disk_center3;\n\n    if(t1==0.){\n        float alpha=clamp(disk_alpha1+disk_alpha2+disk_alpha3,0.,1.);\n        \n\t\tdis=min(dis,distance(disk_center1,uv)-disk_radius);\n\t\tcolor=mix(mix(color,disk_col,alpha),color,smoothstep(-border/2.,border/2.,dis));\n\t\tdis=1e38;\n    }\n    else{\n        dis=min(dis,distance(disk_center1,uv)-disk_radius);\n\t\tcolor=mix(mix(color,disk_col,disk_alpha1),color,smoothstep(-border/2.,border/2.,dis));\n\t\tdis=1e38;\n        dis=min(dis,distance(disk_center2,uv)-disk_radius);\n        color=mix(mix(color,disk_col,disk_alpha2),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,distance(disk_center3,uv)-disk_radius);\n        color=mix(mix(color,disk_col,disk_alpha3),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n    }\n    \n    if(t0<rgb_logo_time || !rgb_flicker(t0-rgb_logo_time)){\n    \tdis=min(dis,c1_dis(uv-disk_center1));\n        color=mix(mix(color,font_col,disk_alpha1),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,c2_dis(uv-disk_center2));\n        color=mix(mix(color,font_col,disk_alpha2),color,smoothstep(-border/2.,border/2.,dis));\n        dis=1e38;\n        dis=min(dis,f_dis(uv-disk_center3));\n        color=mix(mix(color,font_col,disk_alpha3),color,smoothstep(-border/2.,border/2.,dis));\n    }\n    else{\n        const vec3[4] colors=vec3[4](blue,green,red,black);\n        \n        for(int i=ZERO;i<4;i++){\n            dis=min(dis,c1_dis(uv+float(-3+2*i)*logo_offset));\n            dis=min(dis,c2_dis(uv+float(-3+2*i)*logo_offset));\n            dis=min(dis,f_dis(uv+float(-3+2*i)*logo_offset));\n            color=mix(colors[i],color,smoothstep(-border/2.,border/2.,dis));\n            dis=1e38;\n        }\n    }\n\n\tfragColor=vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Tweak if image and sound are out of sync\nconst float audio_offset=.5;\n\nfloat border;\n\nconst float eps=.0015;\nconst float eps2=exp2(-14.);\nconst float pi=3.14159265358979;\n\nconst float beat_time_fac=.3;\n\nconst vec3 freqs=vec3(43.6535,55.,65.4064);\n\nconst float pattern_start_time=.5;\nconst float pattern2_start_time=5.;\n\nconst float disk_radius=.275;\n\nconst float rgb_logo_time=15.;\nconst float flicker_dur=.07;\nconst float flicker1=.1;\nconst float flicker2=.3;\nconst float flicker3=1.;\n\nconst float fizzle_dur1=.025;\nconst float fizzle_dur2=.0125;\nconst float fizzle_dur3=.05;\n\nconst vec3 white=vec3(1);\nconst vec3 black=vec3(0);\nconst vec3 red=vec3(1,0,0);\nconst vec3 green=vec3(0,1,0);\nconst vec3 blue=vec3(0,0,1);\n\nconst vec3 chaosflux_color1=vec3(.686274509803922,.905882352941176,.729411764705882);\nconst vec3 chaosflux_color2=vec3(.788235294117647,.3678431372549,.36078431372549);\nconst vec3 chaosflux_color3=vec3(.913725490196078,.87843137254902,.643137254901961);\n\nconst vec2 original_disk_center1=vec2(-1.1,0);\nconst vec2 original_disk_center2=vec2(0);\nconst vec2 original_disk_center3=vec2(1.1,0);\n\nconst vec2 logo_offset=vec2(.005,.0);\n\nconst float wave_speed=2.;\nconst float wave_border=.025;\n\nconst float time_fac=.5;\nconst int max_speed=7;\nconst int speed_fac=2;\n\nconst float dur=4.5;\nconst float begin=9.5;\nconst float fade_time=1.5;\n\nconst float attack_amp=.038;\nconst float attack_time=.17;\nconst float decay_time=.1;\nconst float sustain_amp=.035;\nconst float sustain_time=.1;\nconst float increase_time=.6;\nconst float increase_amp=.073;\nconst float release_time=.05;\n\nconst float attack_param=.8;\nconst float sustain_param=.7;\nconst float increase_param=.9;\n\nconst float detune_width=.025;\nconst float offset_width=.05;\n\nconst float vibrato_depth=.2;\nconst float vibrato_freq=8.;\n\nconst float drum_time=1.;\n\nconst float animation_dur=10.;\n\nconst float drum_time_pow=.7;\n\nconst float drum_exp_fac=1.;\nconst float drum_lin_fac=1.;\nconst float drum_freq_fac=.5;\nconst float drum_filter_fac=1.;\nconst float drum_kick_fac=2.;\nconst float drum_bass_fac=1.;\nconst float drum_amp=.6;\n\nconst float sine_amp=2.5;\n\nconst float smooth_movement_time=8.5;\n\nconst vec2 drum1_pan=vec2(1.,.1);\nconst vec2 drum2_pan=vec2(1.,1.);\nconst vec2 drum3_pan=vec2(.1,1.);\n\n#define ZERO min(0,iFrame)\n\nfloat filtered_triangle(float x, float fac){\n    float val=0.;\n    \n    x*=4.;\n    \n    float old_x=mod(x,4.);\n    \n    x=mod(x,2.);\n    \n    if(x>=1.){\n        x=2.-x;\n    }\n    \n    if(x<fac){\n        val=x;\n    }\n    else if(x<=1.){\n        float tmp=1.-fac;\n        val=fac+sin(mod((x-fac)/tmp*.5*pi,2.*pi))*tmp*2./pi;\n    }\n    \n    if(old_x>2.){\n        val*=-1.;\n    }\n    \n    return val;\n}\n\n//modified from https://www.shadertoy.com/view/llGSzw\nfloat hash(float t)\n{\n    uint n=uint(t*iSampleRate);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash4(float t)\n{\n    uint n=uint(t*iSampleRate);\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec4 k = n * uvec4(n,n*16807U,n*48271U,n*72037U);\n    return vec4( k & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat exp_decay(float t, float decay_time){\n    return exp(log(eps)*t/decay_time);\n}\n\nfloat linear_decay(float t, float duration){\n    return max(0.,1.-max(0.,t)/duration);\n}\n\nfloat linear_attack(float t, float duration){\n    return clamp(t/duration,0.,1.);\n}\n\n//attack, decay, sustain, increase, release\nfloat linear_adsir(float t, float att_amp, float att_time, float dec_time, float sus_amp, float sus_time, float inc_amp, float inc_time, float rel_time){\n    float amp=0.;\n    \n    t=max(0.,t);\n                  \n    if(t<att_time){\n        amp=att_amp*linear_attack(t,att_time);\n    }\n    else if(t<att_time+dec_time){\n        amp=mix(att_amp,sus_amp,linear_attack(t-att_time,dec_time));\n    }\n    else if(t<att_time+dec_time+sus_time){\n        amp=sus_amp;\n    }\n    else if(t<att_time+dec_time+sus_time+inc_time){\n        amp=mix(sus_amp,inc_amp,linear_attack(t-(att_time+dec_time+sus_time),inc_time));\n    }\n    else if(t<att_time+dec_time+sus_time+inc_time+rel_time){\n        amp=mix(inc_amp,0.,linear_attack(t-(att_time+dec_time+sus_time+inc_time),rel_time));\n    }\n \n    return amp;\n}\n\nfloat fizzle(float t, float dur){\n    float amp=.0;\n    if(t>0. && t<dur){\n        amp=.1;\n    }\n    \n    return amp*sin(10.*t*2.*pi)*(.2+max(0.,.8*sin(100.*t*2.*pi)))*(-1.+(hash(t)+hash(t+.001)));\n}\n\nfloat drum(float t, float freq, float beat_t, float speed){\n    //beat_t is the time of the beat\n    //speed is for changing sound according to current rythm speed\n    \n    float cur_drum_time=drum_time/pow(speed,drum_time_pow);\n    \n    float amp_decay_time=drum_exp_fac*drum_time;\n    float lin_amp_decay_time=drum_lin_fac*drum_time;\n    float freq_decay_time=drum_freq_fac*cur_drum_time;\n    float filter_decay_time=drum_filter_fac*cur_drum_time;\n    \n    float kick_freq=drum_kick_fac*freq;\n    float bass_freq=drum_bass_fac*freq;\n    \n    t=max(0.,t-beat_t);\n    \n    float tmp=log(eps)/freq_decay_time;\n    float phase=(exp(tmp*t)-1.)/tmp*(kick_freq-bass_freq)+bass_freq*t;\n    \n    float amp=drum_amp*exp_decay(t,amp_decay_time)*linear_decay(t,lin_amp_decay_time);\n    \n    float filter_val=exp_decay(t,filter_decay_time);\n    \n    return amp*filtered_triangle(phase,filter_val);\n}\n\nfloat sine_tone(float t, float freq, float dur){\n\n    float amp=1.;\n    \n    float param=linear_adsir(t,attack_param,attack_time*dur,decay_time*dur,sustain_param,sustain_time*dur,increase_param,increase_time*dur,release_time*dur);\n    amp*=linear_adsir(t,attack_amp,attack_time*dur,decay_time*dur,sustain_amp,sustain_time*dur,increase_amp,increase_time*dur,release_time*dur);\n    amp*=1.+vibrato_depth*sin(mod(max(t-dur*(attack_time+decay_time+sustain_time),0.)*vibrato_freq*2.*pi,2.*pi));\n    \n    return amp*filtered_triangle(t*freq,param);\n}\n\nfloat fade(float t, float duration){\n    float val=0.;\n    \n    if(t>0. && t<duration){\n        val=1.;\n    }\n    \n    return val;\n}\n\nbool rgb_flicker(float t){\n\tbool show=false;\n    \n    if((t>flicker1 && t<flicker1+flicker_dur) || (t>flicker2 && t<flicker2+flicker_dur) || t>flicker3){\n        show=true;\n    }\n    \n    return show;\n}\n\nfloat disk_animation(float t){\n    return max(1.-1./animation_dur*max(t,0.),0.);\n}\n\nfloat beat_wave(float t, float t0, vec2 uv, vec2 wave_center, float dis){\n    float wave_rad=wave_speed*(t-t0);\n    \n    float dis_abs=abs(dis);\n    float dis_sign=sign(dis);\n    \n    float tmp_dis=1e38;\n    \n    if(t>t0){\n        tmp_dis=distance(uv,wave_center)-wave_rad;\n    }\n    \n    dis_abs=min(dis_abs,abs(tmp_dis));\n    dis_sign*=sign(tmp_dis);\n    \n    return dis_abs*dis_sign;\n}\n\nvec2 drum_pattern1(float t){\n    vec2 val=vec2(0);\n    \n\tval+=drum(t,freqs[1],0.*beat_time_fac,1.)*drum1_pan;\n\tval+=drum(t,freqs[1],1.*beat_time_fac,1.)*drum2_pan;\n\tval+=drum(t,freqs[1],3.*beat_time_fac,1.)*drum3_pan;\n\tval+=drum(t,freqs[0],5.*beat_time_fac,1.)*drum1_pan;\n\tval+=drum(t,freqs[0],7.*beat_time_fac,1.)*drum2_pan;\n\tval+=drum(t,freqs[2],8.*beat_time_fac,1.)*drum3_pan;\n    \n    return val;\n}\n\nvec3 fade_pattern1(float t){\n    vec3 val=vec3(0);\n    \n    val+=fade(t-0.*beat_time_fac,1.*beat_time_fac)*vec3(1,0,0);\n    val+=fade(t-1.*beat_time_fac,2.*beat_time_fac)*vec3(0,1,0);\n    val+=fade(t-3.*beat_time_fac,2.*beat_time_fac)*vec3(0,0,1);\n    val+=fade(t-5.*beat_time_fac,2.*beat_time_fac)*vec3(1,0,0);\n    val+=fade(t-7.*beat_time_fac,1.*beat_time_fac)*vec3(0,1,0);\n    val+=fade(t-8.*beat_time_fac,1.*beat_time_fac)*vec3(0,0,1);\n    \n    return val;\n}\n\nfloat wave_pattern1(float t, vec2 uv){\n    float dis=1e38;\n    \n    dis=beat_wave(t,0.*beat_time_fac,uv,original_disk_center1,dis);\n    dis=beat_wave(t,1.*beat_time_fac,uv,original_disk_center2,dis);\n    dis=beat_wave(t,3.*beat_time_fac,uv,original_disk_center3,dis);\n    dis=beat_wave(t,5.*beat_time_fac,uv,original_disk_center1,dis);\n    dis=beat_wave(t,7.*beat_time_fac,uv,original_disk_center2,dis);\n    dis=beat_wave(t,8.*beat_time_fac,uv,original_disk_center3,dis);\n    \n    return dis;\n}\n\nvec2 last_beat(float t){\n    t=max(0.,t);\n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t);\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    \n    float frac=fract(t);\n    \n    vec2 ret=vec2(0);\n    \n    //point in time of last beat\n    ret.x=(second+floor(frac*3.*speed)/(3.*speed))/time_fac;\n    //\"position\" of last beat\n    ret.y=mod(floor(frac*3.*speed),3.);\n    \n    return ret;\n}\n\nvec2 drum_pattern2(float t){\n    vec2 val=vec2(0);\n    \n    t=max(0.,t);\n    \n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t);\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    float frac=fract(t);\n    \n    int n=int(ceil(drum_time*time_fac*3.*speed));\n    int ind0=int(frac*3.*speed);\n    int ind1=max(0,ind0-n);\n    for(int ind=ind0;ind>=ind1;ind--){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        int type=int(mod(float(ind),3.));\n        \n        vec2 drum_pan;\n        \n        if(type == 0){\n            drum_pan=drum1_pan;\n        }\n        else if(type == 1){\n            drum_pan=drum2_pan;\n        }\n        else if(type == 2){\n            drum_pan=drum3_pan;\n        }\n        \n        drum_pan=mix(vec2(1.),drum_pan,disk_animation(beat));\n\n        val+=drum(t0,freqs[type],beat,speed)*drum_pan;\n    }\n    \n    second-=1.;\n    speed=min(second+1.,float(max_speed))*float(speed_fac);\n    frac=t-second;\n    //n=int(ceil(drum_time*time_fac*3.*speed));\n    n=4;\n    ind0=int(3.*speed-1.);\n    ind1=max(0,ind0-n);\n    \n    for(int ind=ind0;ind>=ind1;ind--){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        int type=int(mod(float(ind),3.));\n\n        vec2 drum_pan;\n        \n        if(type == 0){\n            drum_pan=drum1_pan;\n        }\n        else if(type == 1){\n            drum_pan=drum2_pan;\n        }\n        else if(type == 2){\n            drum_pan=drum3_pan;\n        }\n        \n        drum_pan=mix(vec2(1.),drum_pan,disk_animation(beat));\n        \n        val+=drum(t0,freqs[type],beat,speed)*drum_pan;\n    }\n    \n    float val2=0.;\n\n    float fade_param=linear_attack(t0-begin,fade_time);\n\n    for(int i=1;i<3;i++){\n        for(int j=0;j<3;j++){\n            val2+=sine_amp*sine_tone(t0-(begin+offset_width*hash(92.81+float(i*3+j))),(1.+detune_width*hash(float(i*3+j)))*float(1<<i)*freqs[j],dur);\n        }\n    }\n    \n    val=mix(val,vec2(0),fade_param);\n    \n    float val3=.0;\n    \n    val3+=fizzle(t0-(rgb_logo_time+flicker1),fizzle_dur1);\n    val3+=fizzle(t0-(rgb_logo_time+flicker2),fizzle_dur2);\n    val3+=fizzle(t0-(rgb_logo_time+flicker3),fizzle_dur3);\n    \n    return val+val2+val3;\n}\n\nvec3 fade_pattern2(float t){\n    vec3 val=vec3(0);\n    \n    vec2 lb=last_beat(t);\n    \n    val[int(lb.y)]=1.;\n\t\n    if(t>animation_dur){\n        val=vec3(1);\n    }\n    \n    return val;\n}\n\nfloat wave_pattern2(float t, vec2 uv){\n    float dis=1e38;\n    \n    t=max(0.,t);\n    \n    float t0=t;\n    \n    t*=time_fac;\n    \n    float second=floor(t)-1.;\n    \n    float speed=min(second+1.,float(max_speed))*float(speed_fac);\n    float frac=t-second;\n    \n    int ind0=int(3.*speed-1.);\n    int ind1=0;\n    \n    vec2 wave_center=vec2(0);\n    \n    for(int ind=ind1;ind<=ind0;ind++){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        if(beat < begin+dur*(attack_time+decay_time+sustain_time+increase_time)){\n            int type=int(mod(float(ind),3.));\n\n            float t2=disk_animation(beat);\n\n            if(type==0){\n                wave_center=original_disk_center1*t2;\n            }\n            else if(type==1){\n                wave_center=original_disk_center2*t2;\n            }\n            else if(type==2){\n                wave_center=original_disk_center3*t2;\n            }\n\n            dis=beat_wave(t0,beat,uv,wave_center,dis);\n        }\n    }\n    \n    second+=1.;\n    speed=min(second+1.,float(max_speed))*float(speed_fac);\n    frac=t-second;\n    ind0=int(frac*3.*speed);\n    ind1=0;\n    \n    for(int ind=ind1;ind<=ind0;ind++){\n        float beat=(second+float(ind)/(3.*speed))/time_fac;\n        if(beat < begin+dur*(attack_time+decay_time+sustain_time+increase_time)){\n            int type=int(mod(float(ind),3.));\n\n            float t2=disk_animation(beat);\n\n            if(type==0){\n                wave_center=original_disk_center1*t2;\n            }\n            else if(type==1){\n                wave_center=original_disk_center2*t2;\n            }\n            else if(type==2){\n                wave_center=original_disk_center3*t2;\n            }\n\n            dis=beat_wave(t0,beat,uv,wave_center,dis);\n        }\n    }\n\n    return dis;\n}\n\nvec2 drum_pattern(float t){\n    t-=pattern_start_time;\n    \n    if(t<pattern2_start_time){\n        return drum_pattern1(t);\n    }\n    else{\n        return drum_pattern2(t-pattern2_start_time);\n    }\n}\n\nvec3 fade_pattern(float t){\n    t-=pattern_start_time+audio_offset;\n    \n    if(t<pattern2_start_time){\n        return fade_pattern1(t);\n    }\n    else{\n        return fade_pattern2(t-pattern2_start_time);\n    }\n}\n\nfloat wave_pattern(float t, vec2 uv){\n    t-=pattern_start_time+audio_offset;\n    \n    if(t<pattern2_start_time){\n        return wave_pattern1(t,uv);\n    }\n    else{\n        return wave_pattern2(t-pattern2_start_time,uv);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "vec2 mainSound( in int samp,float time){\n    vec2 val=drum_pattern(time);\n    vec4 hash_val=hash4(time)*2.-1.;\n    val+=eps2*hash_val.xy+eps2*hash_val.zw;\n    return val;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}