{
    "Shader": {
        "info": {
            "date": "1725630736",
            "description": "Normal frame integration\nIntegration of the normal bundle of a raymarched signed distance function\nMouse controls FOV, gamma correction, and some aspects of the ray march",
            "flags": 0,
            "hasliked": 0,
            "id": "XcBfDd",
            "likes": 7,
            "name": "Wiggleract",
            "published": 3,
            "tags": [
                "raymarching",
                "shape"
            ],
            "usePreview": 0,
            "username": "willwombell",
            "viewed": 110
        },
        "renderpass": [
            {
                "code": "// Fork of \"Normal frame integration\" by willwombell. https://shadertoy.com/view/4cSfDt\n// 2024-09-06 13:34:56\n\n#define uSHIFT(x) (0.5 * x + 0.5)\n#define dSHIFT(x) (2.0 * x - 1.0)\n#define PHI 1.618\n\n// Potential field accumulation for a cube\nstruct Camera {\n    vec3 position;\n    vec3 target;\n    float fov;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Hit {\n    float distance;\n    vec3 normal;\n    vec3 potential;\n};\n\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst int MAX_STEPS = 200;\n\nfloat ushift(float x) {return 0.5 * x + 0.5;}\nfloat dshift(float x) {return 2.0 * x - 1.0;}\n\n// Quaternion multiplication\nvec4 qmul(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\n\n// Rotate a vector by a quaternion\nvec3 rotate(vec3 v, vec4 q) {\n    vec4 qv = vec4(v, 0.0);\n    vec4 qInv = vec4(-q.xyz, q.w);\n    return qmul(q, qmul(qv, qInv)).xyz;\n}\n\nfloat sdBoxClassic(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    float p1 = 1.1;\n    float p2 = 1.0;\n    return length(max(q, p1)) + min(max(q.x, max(q.y, q.z)), p2);\n}\n\nfloat sdBall(vec3 p, vec3 b) {\n    float p1 = 17.;\n    return sqrt(pow(length(p/b)-length(b), 2.) + p1);\n}\n\n// SDF for a simplex (tetrahedron)\nfloat sdSimplex(vec3 p, vec3 l) {\n    const float k = sqrt(2.0);\n    p.xy -= min(p.x + p.y, 0.0);\n    p.xz -= min(p.x + p.z, 0.0);\n    p.yz -= min(p.y + p.z, 0.0);\n    return ((p.x + p.y + p.z - k) / sqrt(3.0) + sqrt(1.0/3.0)) * 0.5;\n}\n\n// SDF for an icosahedron\nfloat sdIcosahedron(vec3 p, vec3 l) {\n    const float G = sqrt(5.0) * 0.5 + 0.5;\n    const vec3 n = normalize(vec3(G, 1.0/G, 0.0));\n    float d = 0.0;\n    p = abs(p);\n    d = max(d, dot(p, n));\n    d = max(d, dot(p, n.yzx));\n    d = max(d, dot(p, n.zxy));\n    d = max(d, dot(p, normalize(vec3(1.0))));\n    return d - 1.0;\n}\n\n// SDF for a dodecahedron\nfloat sdDodecahedron(vec3 p, vec3 l) {\n    const float phi = (1.0 + sqrt(5.0)) / 2.0;\n    const vec3 n = normalize(vec3(phi, 1.0, 0.0));\n\n    p = abs(p);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.yzx);\n    float c = dot(p, n.zxy);\n    return (max(max(a, b), c) - n.x) * 0.5;\n}\n\nfloat map(vec3 p, vec4 rotation) {\n    p = rotate(p, rotation);\n    return sdBox(p, vec3(1.0, 2., 3.));\n}\n\n// Potential function\nfloat potential(float map) {\n    //return 1.0 / (map + EPSILON);\n    //return exp(-map);\n    return log(1.+map);\n}\n\nvec3 normal_map(vec3 p, vec4 rotation) {\n    const vec2 e = vec2(EPSILON, 0.0);\n    float center = map(p, rotation);\n    vec3 normal = vec3(\n        map(p + e.xyy, rotation) - center,\n        map(p + e.yxy, rotation) - center,\n        map(p + e.yyx, rotation) - center\n    );\n    return normalize(normal);\n}\n\nvec3 normal_potential(vec3 p, vec4 rotation) {\n    const vec2 e = vec2(EPSILON, 0.0);\n    float center = potential(map(p, rotation));\n    vec3 normal = vec3(\n        potential(map(p + e.xyy, rotation)) - center,\n        potential(map(p + e.yxy, rotation)) - center,\n        potential(map(p + e.yyx, rotation)) - center\n    );\n    return normalize(normal);\n}\n\nHit raymarch(Ray ray, vec4 rotation, vec2 ms) {\n    float dist = 0.0;\n    vec3 normal_integral = vec3(0.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ray.origin + dist * ray.direction;\n        float d = map(p, rotation);\n        \n        normal_integral += normal_potential(p, rotation)/abs(d);\n        \n        dist += abs(d)+ms.y;\n        \n        if (dist > MAX_DIST) {\n            break;\n        }\n        \n    }\n    \n    return Hit(dist, ray.direction, normal_integral);\n}\n\nRay getCameraRay(Camera cam, vec2 uv) {\n    vec3 forward = normalize(cam.target - cam.position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec3 direction = normalize(uv.x * right + uv.y * up + forward / tan(cam.fov * 0.5));\n    \n    return Ray(cam.position, direction);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 ms = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float t = iTime;\n    \n    if (iMouse.xy == vec2(0)) ms = vec2(0);\n    \n    // Camera setup\n    Camera cam;\n    cam.position = vec3(4.0*cos(t), 3.0*sin(t), -5.0)/max(ms.x, 0.1);\n    cam.target = vec3(0.0);\n    cam.fov = exp(ms.x);\n    \n    float angle = t * 0.5;\n    vec3 axis = normalize(vec3(sin(t*0.7), cos(t*0.5), sin(t*0.3)));\n    vec4 rotation = vec4(axis * sin(angle), cos(angle));\n    \n    Ray ray = getCameraRay(cam, uv);\n    Hit hit = raymarch(ray, rotation, ms);\n    \n    vec3 color;\n    vec4 rotor = vec4(cos(t), cos(PHI*t), cos(t/PHI), 1.);\n    \n    color = hit.potential;\n    color = uSHIFT(sin(color*rotate(vec3(2., 3., 5.), rotor)));\n    \n    // Simple gamma correction\n    color = pow(color, vec3(uSHIFT(ms.y)));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}