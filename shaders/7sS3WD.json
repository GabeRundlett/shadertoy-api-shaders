{
    "Shader": {
        "info": {
            "date": "1617403353",
            "description": "for the revision 2021 shader showdown\n\nUPDATE: added a crummy revision logo",
            "flags": 0,
            "hasliked": 0,
            "id": "7sS3WD",
            "likes": 30,
            "name": "Robot Dance",
            "published": 3,
            "tags": [
                "revision",
                "shadershowdown",
                "livecode"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 662
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p) - d;\n  return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat joint(vec3 p, vec3 d) {\n  return min(length(p - vec3(0,0,d.z))-d.y*1.5-.02, box(p,d)-.02);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nfloat r1;\nfloat r2;\nfloat r3;\nfloat r4;\nfloat r5;\nfloat r6;\nfloat arm;\nfloat fl;\nfloat scene(vec3 p) {\n  float dist = joint(p, vec3(.1,.1,.4));\n  fl = p.z+.4;\n  dist = min(dist,fl);\n  p = erot(erot(p,vec3(0,0,1),r2)-vec3(0.,0.,.4), vec3(1,0,0), r1) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p = erot(erot(p,vec3(0,0,1),r4)-vec3(0.,0.,.3), vec3(1,0,0), r3) - vec3(0,0,0.3);\n  dist = min(dist, joint(p, vec3(.1,.1,.3)));\n  p -= vec3(0,0,.32);\n  p = erot(p,vec3(0,0,1),r6);\n  arm = box(p, vec3(.09,.3,.09))-.02;\n  p.y = abs(p.y);\n  p -= vec3(0,.3,.12);\n  p = erot(p-vec3(0,0,-.2), vec3(1,0,0), r5);\n  arm = min(arm, length(p+vec3(0,0,-.1))-.15);\n  arm = min(arm, joint(p-vec3(0,0,.3), vec3(.05,.05,.2)));\n  return min(dist,arm);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a), y = FK(b);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat spring(float x) {\n  return smoothstep(-.1,.1,x) + smoothstep(-.2,.2,x) - smoothstep(-.3,.3,x);\n}\n\nfloat bpm = 130.;\nfloat mayhem(float sd) {\n  float off = hash(sd,sd)*99.;\n  float idx = floor((iTime+off)*bpm/240.+.5);\n  float interp = iTime + off - idx*240./bpm;\n  float start = hash(idx, sd);\n  float end = hash(round(idx+1.), sd);\n  return mix(start, end, spring(interp));\n}\n\nfloat revisionTexture(vec2 p) {\n    return texturee(p*2.5) ? 0.:1.;\n    return step(0., sin(length(p*40.)+atan(p.x,p.y)));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n      r1 = mayhem(12.);\n  r3 = mayhem(32.);\n  r5 = mayhem(72.)*.5+.5;\n  r2 = mayhem(92.);\n  r4 = mayhem(78.);\n  r6 = mayhem(89.);\n  float hs = mayhem(45.);\n  \n  vec3 cam = normalize(vec3(1.+hs*.5+.5,uv));\n  vec3 init = vec3(-5,0,.5+hs*.2);\n  \n  float yrot = .5+mayhem(85.)*.3;\n  float zrot = iTime+mayhem(98.);\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  \n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  for (int i = 0; i<150 && !hit; i++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p += cam*dist;\n    if (distance(p,init)>10.) break;\n  }\n  bool isfl = fl == dist;\n  bool isarm = arm == dist;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = length(sin(r*3.)*.5+.5)/length(3.);\n  spec = pow(spec, 3.)*2. + spec*.2;\n  spec *= fres;\n  vec3 col = vec3(spec);\n  if (isarm) {\n    col += vec3(.8,.3,.1)*length(sin(n*2.)*.3+.7)/sqrt(3.);\n  }\n  if (isfl) {\n    col = vec3(1);\n    if(length(p.xy) < 3.) {\n      if (length(p.xy) < 1.5) {\n        p = erot(p, vec3(0,0,1), mayhem(78.));\n      } else {\n        p = erot(p, vec3(0,0,1), mayhem(99.));\n      }\n      col = vec3(revisionTexture(p.xy/6.));\n    }\n  }\n\n\tfragColor.xyz = smoothstep(0.,1.,sqrt(hit ? col : vec3(1)));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}