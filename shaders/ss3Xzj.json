{
    "Shader": {
        "info": {
            "date": "1633636036",
            "description": "Another Sinclair ZX Spectrum Filter!\nProbably a lot slower than others as this does a more exhaustive search to find which attributes to use for each character cell. Also has some hacky CRT effects.\nTry changing the iChannel0 input in Buffer A.",
            "flags": 32,
            "hasliked": 0,
            "id": "ss3Xzj",
            "likes": 62,
            "name": "ZX Spectrum SCREEN$",
            "published": 3,
            "tags": [
                "retro",
                "spectrum",
                "zx",
                "8bit",
                "sinclair"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 4095
        },
        "renderpass": [
            {
                "code": "// ZX Spectrum SCREEN$\n// by @P_Malin\n//\n// https://www.shadertoy.com/view/ss3Xzj\n// \n// See the webcam / Memix version here:\n//   https://www.shadertoy.com/view/7scXRX\n//\n// Another Sinclair ZX Spectrum Filter!\n// Probably a lot slower than others as this does a more exhaustive search to find which attributes to use for each character cell. Also has some hacky CRT effects.\n// Try changing the iChannel0 input in Buffer A.\n\n// There is a slightly cheaper version of the colour selection code if you `#define SLOW_SEARCH 0` in the Common tab\n\n\n// \"CRT\" Effects\n#define APPLY_BLUR 1\n#define APPLY_INTERFERENCE 1\n#define APPLY_SCANLINES 1\n\nvec4 hash41(float p)\n{\n    // From: Hash without Sine by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);    \n}\n\nvec4 InterferenceSmoothNoise1D( float x )\n{\n    float f0 = floor(x);\n    float fr = fract(x);\n\n    vec4 h0 = hash41( f0 );\n    vec4 h1 = hash41( f0 + 1.0 );\n\n    return h1 * fr + h0 * (1.0 - fr);\n}\n\n\nvec4 InterferenceNoise( vec2 uv )\n{\n    float scanLine = floor(uv.y * resolution.y); \n    float scanPos = scanLine + uv.x;\n\tfloat timeSeed = fract( iTime * 123.78 );\n    \n    return InterferenceSmoothNoise1D( scanPos * 234.5 + timeSeed * 12345.6 );\n}\n\nvec3 SampleImage( vec2 uv, int loadingByteIndex )\n{\n    vec2 pixelCoord = uv * resolution;\n\n    vec3 col = vec3(1);\n\n    col = texelFetch( iChannel0, ivec2(pixelCoord), 0).rgb;    \n    //col = texture( iChannel0, (pixelCoord) / iChannelResolution[0].xy).rgb;\n\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        //col = vec3(intensity0);\n        //col = vec3(0,1,1) * intensity0;\n        //col = intensity0 * mix( vec3(0,1,1), vec3(1,0,0), step(sin(iTime * 1.0),0.0));\n        //col = intensity0 * mix( vec3(0,1,1), vec3(1,0,0), step(sin(uv.x /10.0+uv.y*60.0+iTime * 10.0),0.0));\n        \n        col = vec3(intensity0) * vec3(0,1,1);\n            \n        int loadingByteEnd = (192*256/8+(32*24) + 64);\n            \n        if ( loadingByteIndex < loadingByteEnd )\n        {\n            float t =(uv.y*300.0+uv.x)* 0.4+iTime * 3000.0;\n            float raster = t / 150.0;\n            \n            float barSize = 64.0;\n            float scrollSpeed = 1.0;\n            float blend = step(fract(raster * barSize + iTime * scrollSpeed + sin(iTime * 20.0 + raster * 16.0)), 0.5);            \n            col = mix( vec3(0,0,1), vec3(1,1,0), blend ) * intensity0;\n        }        \n                \n        col = RGBtoYUV( col );\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor.rgb = YUVtoRGB(texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb); return;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    uv = uv - 0.5;\n    \n    float outputAspect = iResolution.x / iResolution.y;\n    float screenAspect = (resolution.x / resolution.y);\n    float aspectAdjust = outputAspect / screenAspect;\n    \n    if ( aspectAdjust > 1.0 )\n    {\n        uv.x *= aspectAdjust;\n    }\n    else\n    {\n        uv.y /= aspectAdjust;\n    }\n    \n    uv *= 1.1;\n    uv = uv + 0.5;\n    \n#if APPLY_INTERFERENCE    \n    vec4 noise = InterferenceNoise( uv );\n    uv.x += noise.w * 0.0015;\n#endif    \n\n    int loadingByteIndex = iFrame * loadSpeed - startDelay;\n    \n    col = SampleImage( uv, loadingByteIndex );\n    \n#if APPLY_BLUR    \n    {\n        float weight = 1.0f;\n        float blurSeparation = 1.5;\n\n        int taps = 6;\n        for( int i=1; i<taps; i++)\n        {\n            float t = float(i) / float(taps-1);\n            float blurWeight = (1.0 - t);\n            blurWeight *= 0.7;\n            col.r += SampleImage( uv + vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).r * blurWeight;\n            col.r += SampleImage( uv - vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).r * blurWeight;\n\n            weight += blurWeight * 2.0;\n        }\n        col.r /= weight;\n    }\n\n    {\n        float weight = 1.0f;\n        float blurSeparation = 2.5;\n\n        int taps = 6;\n        for( int i=1; i<taps; i++)\n        {\n            float t = float(i) / float(taps-1);\n            float blurWeight = (1.0 - t);\n            blurWeight *= 0.7;\n            col.gb += SampleImage( uv + vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).gb * blurWeight;\n            col.gb += SampleImage( uv - vec2(t*blurSeparation/ resolution.x,0.0), loadingByteIndex).gb * blurWeight;\n\n            weight += blurWeight * 2.0;\n        }\n        col.gb /= weight;\n    }\n\n#endif    \n\n#if APPLY_INTERFERENCE    \n    col += (noise.xyz * 1.0 - 0.5) * 0.05;\n#endif    \n\n    col = YUVtoRGB( col );    \n\n#if APPLY_SCANLINES\n    float scanline = 1.0;\n    /*{\n        float a = resolution.y * 3.14 * 2.0;\n        float b = - 3.14 * 0.5;\n        float x = uv.y;\n        scanline = sin(x * a + b);\n    }*/\n    {\n        float a = resolution.y * 3.14 * 2.0;\n        float b = - 3.14 * 0.5;\n        float x = uv.y;\n\n        float delta = length(vec2(dFdx(x),dFdy(x)));\n        float v1 = -cos(a*(x-delta)+b)/a;\n        float v2 = -cos(a*(x+delta)+b)/a;\n        scanline = (v2 - v1) / delta;\n    }\n    \n    scanline = scanline * 0.5 + 0.5;\n    float scanlineIntensity = 0.4;\n    scanline = mix( 1.0, scanline, scanlineIntensity );\n    col = col * col;\n    float ambient = 0.01;\n    col = mix(col, vec3(1.0), ambient);\n    col = col * scanline;        \n    col = sqrt(col);\n#endif    \n    \n    fragColor = vec4(col,1.0);\n        \n    /*\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    uv = uv - 0.5;\n    \n    float outputAspect = iResolution.x / iResolution.y;\n    float screenAspect = (resolution.x / resolution.y);\n    float aspectAdjust = outputAspect / screenAspect;\n    \n    if ( aspectAdjust > 1.0 )\n    {\n        uv.x *= aspectAdjust;\n    }\n    else\n    {\n        uv.y /= aspectAdjust;\n    }\n    \n    uv *= 1.1;\n    uv = uv + 0.5;\n    \n    vec2 pixelCoord = floor(uv * resolution);\n\n    BlockColours blockColours = GetBlockColours( pixelCoord );\n\n    col = GetPixelColour( blockColours, pixelCoord );\n\n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        col = vec3(intensity0) * vec3(0,1,1);\n    }\n\n    float scanline = (sin(uv.y * resolution.y * 3.14 * 2.0) * 0.5 + 0.5);\n    scanline = scanline * 0.5 + 0.5;\n    col = col * scanline;\n\n    //if ( uv.x > 0.5 ) col = currPixelColour;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    */\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //col = col * 0.5;\n    //col = col + 0.1;\n    //col = pow(col, vec3(2.));\n    if ( iMouse.z > 0.0)\n    {\n        col = col * 2.0 * iMouse.x / iResolution.x;\n        col = pow(col, 0.5+ vec3(iMouse.y / iResolution.y));\n    }\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Slower search producing slightly different colours\n#define SLOW_SEARCH 1\n\n\n\nvec2 resolution=vec2(256, 192);\nvec2 blockSize=vec2(8,8);\n\nfloat intensity0 = 0.85;\nfloat intensity1 = 1.0;\n\nconst int loadSpeed = 31; //7;\nint startDelay = 0; //4000;\n\nstruct BlockColours\n{\n    vec3 colourA;\n    vec3 colourB;\n};\n\n\n\nmat4 bayerMatrix = mat4(\n    vec4( 0.0/16.0, 12.0/16.0,  3.0/16.0, 15.0/16.0),\n    vec4( 8.0/16.0,  4.0/16.0, 11.0/16.0,  7.0/16.0),\n    vec4( 2.0/16.0, 14.0/16.0,  1.0/16.0, 13.0/16.0),\n    vec4(10.0/16.0, 06.0/16.0,  9.0/16.0,  5.0/16.0));\n\nfloat GetBayer( vec2 pixelCoord )\n{\n    return bayerMatrix[int(pixelCoord.x)%4][int(pixelCoord.y)%4];\n}\n\n\nfloat Dist2( vec3 a, vec3 b )\n{\n    vec3 ab = b-a;\n    return dot(ab,ab);\n}\n\n\nvec3 RGBtoYUV(vec3 rgb)\n{\n    float y = dot(rgb, vec3(0.255, 0.587, 0.114));\n    float u = 0.492 * (rgb.b - y);\n    float v = 0.877 * (rgb.r - y);\n    return vec3(y,u,v);\n}\n\nvec3 YUVtoRGB(vec3 yuv)\n{\n    float y = yuv.x;\n    float u = yuv.y;\n    float v = yuv.z;\n    float r = y + 1.14 * v;\n    float g = y - 0.395 * u - 0.581 * v;\n    float b = y + 2.033 * u;\n    return vec3(r,g,b);\n}\n\n\nvec3 SamplePixel( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    vec2 uv = pixelCoord / resolution;\n        \n    float sourceAspect = srcResolution.x / srcResolution.y;\n    float dstAspect = resolution.x / resolution.y;\n    \n    float aspectAdjust = dstAspect / sourceAspect;\n    \n    if ( aspectAdjust > 0.0 )\n    {\n        uv.x -= 0.5;\n        uv.x *= aspectAdjust;\n        uv.x += 0.5;\n    }\n    else\n    {\n        uv.y -= 0.5;\n        uv.y /= aspectAdjust;\n        uv.y += 0.5;    \n    }\n    \n    if ( uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0 )\n    {\n        return vec3(intensity0);\n    }\n       \n    \n    return texture(srcImage, uv).rgb;\n}\n\nfloat GetDitherIntensity()\n{\n    float dither = 0.3;\n    \n    //dither = iMouse.x / iResolution.x;\n\n    return dither;\n}\n\nvec3 ApplyDither( vec3 col, float value )\n{\n    float intensity = GetDitherIntensity();\n    \n    //col =  col * (1.0 - intensity) + intensity * value;\n    col =  col + intensity * value - intensity * 0.5;\n    \n    col = clamp( col, vec3(0), vec3(1) );\n    \n    return col;\n}\n\n\n#if SLOW_SEARCH\n\nBlockColours GetBlockColours( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    BlockColours result;\n    \n    float testIntensity = (intensity0 + intensity1) * 0.5;\n\n    vec2 blockOrigin = floor( pixelCoord / blockSize ) * blockSize;\n        \n    float error[8*8];\n    for(int i=0; i<8; i++)\n    {\n        for(int j=0; j<8; j++)\n        {\n            if (i>j)\n            {\n                int index = i+j*8;\n                error[index] = 0.0;\n            }\n        }\n    }\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float hash = GetBayer( samplePixelCoord );\n            pixelColour = ApplyDither(pixelColour, hash);\n                        \n            for(int i=0; i<8; i++)\n            {\n                vec3 testColA = vec3(0);\n                if ( (i & 1) != 0 ) testColA.r = testIntensity;\n                if ( (i & 2) != 0 ) testColA.g = testIntensity;\n                if ( (i & 4) != 0 ) testColA.b = testIntensity; \n                                \n                for(int j=0; j<8; j++)\n                {\n                    if (i>j) \n                    {\n                        vec3 testColB = vec3(0);\n\n                        if ( (j & 1) != 0 ) testColB.r = testIntensity;\n                        if ( (j & 2) != 0 ) testColB.g = testIntensity;\n                        if ( (j & 4) != 0 ) testColB.b = testIntensity;\n\n                        float dist = 0.0;\n                        int bright = 0;\n\n                        float dist1 = Dist2( testColA, pixelColour );\n                        dist = dist1;\n                        \n                        float dist2 = Dist2( testColB, pixelColour );\n                        if ( dist2 < dist1 )\n                        {\n                            dist = dist2;\n                        }\n\n                        error[i+j*8] += dist;\n                    }\n                }\n            }\n        }\n    }        \n\n    float smallestError = 999999.0;\n    int smallestErrorIndex = 0;\n    for(int i=0; i<8; i++)\n    {\n        for(int j=0; j<8; j++)\n        {\n            if (i>j)\n            {\n                int index = i+j*8;\n                if ( error[index] < smallestError )\n                {\n                    smallestError = error[index];\n                    smallestErrorIndex = index;\n                }\n            }\n        }\n    }\n        \n    result.colourA = vec3(0);    \n    if ( (smallestErrorIndex & 1) != 0 ) result.colourA.r = 1.0;\n    if ( (smallestErrorIndex & 2) != 0 ) result.colourA.g = 1.0;\n    if ( (smallestErrorIndex & 4) != 0 ) result.colourA.b = 1.0;\n\n\n    result.colourB = vec3(0);\n    if ( (smallestErrorIndex & 8) != 0 ) result.colourB.r = 1.0;\n    if ( (smallestErrorIndex & 16) != 0 ) result.colourB.g = 1.0;\n    if ( (smallestErrorIndex & 32) != 0 ) result.colourB.b = 1.0;\n    \n    // determine if we should use \"bright\" attribute\n    float scoreA = 0.0;\n    float scoreB = 0.0;\n    \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 samp = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float d1 = Dist2(result.colourA * intensity0, samp);\n            float d2 = Dist2(result.colourB * intensity0, samp);\n            if (d1 < d2) scoreA += d1; else scoreA += d2;\n            \n            float d3 = Dist2(result.colourA * intensity1, samp);\n            float d4 = Dist2(result.colourB * intensity1, samp);\n            if (d3 < d4) scoreB += d3; else scoreB += d4;            \n        }\n    }        \n    \n    float intensity = intensity0;\n    if (scoreA>scoreB) intensity = intensity1; \n    \n    result.colourA *= intensity;\n    result.colourB *= intensity;\n\n    return result;    \n}\n\n#else \n\n// faster but lower quality\nBlockColours GetBlockColours( vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution )\n{\n    BlockColours result;\n    \n    float intensity0 = 0.85;\n    float intensity1 = 1.0;\n    \n    float testIntensity = (intensity0 + intensity1) * 0.5;\n    \n    vec2 blockOrigin = floor( pixelCoord / blockSize ) * blockSize;\n    \n    float freq[8];\n    for(int i=0; i<8; i++)\n        freq[i] = 0.0;\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            float hash = GetBayer( samplePixelCoord );\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n                        \n            pixelColour = ApplyDither( pixelColour, hash);\n            \n            \n            int closestIndex = 0;\n            float closestDist = 999.0;\n            \n            for(int i=0; i<8; i++)\n            {\n                vec3 testCol = vec3(0);\n                \n                if ( (i & 1) != 0 ) testCol.r = testIntensity;\n                if ( (i & 2) != 0 ) testCol.g = testIntensity;\n                if ( (i & 4) != 0 ) testCol.b = testIntensity;                \n                \n                float dist = Dist2( testCol, pixelColour );\n                \n                if ( dist < closestDist )\n                {\n                    closestIndex = i;\n                    closestDist = dist;\n                }\n            }\n            \n            freq[closestIndex] += 1.0;\n        }\n    }\n    \n    float highestFreq = -1.0;\n    int highestIndex = 0;\n    \n    for( int i=0; i<8; i++ )\n    {\n        if ( freq[i] > highestFreq )\n        {\n            highestFreq = freq[i];\n            highestIndex = i;\n            \n        }\n    }\n\n    for(int i=0; i<8; i++)\n        freq[i] = 0.0;\n        \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            float hash = GetBayer( samplePixelCoord );\n            vec3 pixelColour = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            pixelColour = ApplyDither(pixelColour, hash);\n            \n            int closestIndex = 0;\n            float closestDist = 999.0;\n            \n            for(int i=0; i<8; i++)\n            {\n                {\n                    vec3 testCol = vec3(0);\n\n                    if ( (i & 1) != 0 ) testCol.r = testIntensity;\n                    if ( (i & 2) != 0 ) testCol.g = testIntensity;\n                    if ( (i & 4) != 0 ) testCol.b = testIntensity;                \n\n                    float dist = length( testCol - pixelColour );\n\n                    if ( dist < closestDist )\n                    {\n                        closestIndex = i;\n                        closestDist = dist;\n                    }\n                }\n            }\n\n            // ignore pixels that will map to highestIndex\n            if( closestIndex != highestIndex )\n            {            \n                freq[closestIndex] += 1.0;\n            }\n        }\n    }\n    \n    float highestFreq2 = -1.0;\n    int highestIndex2 = 7;\n    \n    for( int i=0; i<8; i++ )\n    {\n        if ( i != highestIndex )\n        {\n            if ( freq[i] > highestFreq2 )\n            {\n                highestFreq2 = freq[i];\n                highestIndex2 = i;\n\n            }\n        }\n    }\n    \n    result.colourA = vec3(0);    \n    if ( (highestIndex & 1) != 0 ) result.colourA.r = 1.0;\n    if ( (highestIndex & 2) != 0 ) result.colourA.g = 1.0;\n    if ( (highestIndex & 4) != 0 ) result.colourA.b = 1.0;\n\n    result.colourB = vec3(0);\n    if ( (highestIndex2 & 1) != 0 ) result.colourB.r = 1.0;\n    if ( (highestIndex2 & 2) != 0 ) result.colourB.g = 1.0;\n    if ( (highestIndex2 & 4) != 0 ) result.colourB.b = 1.0;    \n\n\n    // determine if we should use \"bright\" attribute\n    float scoreA = 0.0;\n    float scoreB = 0.0;\n    \n    for( int y=0; y<int(blockSize.y); y++ )\n    {\n        for( int x=0; x<int(blockSize.x); x++ )\n        {\n            vec2 samplePixelCoord = blockOrigin + vec2(x,y);\n            vec3 samp = SamplePixel( samplePixelCoord, srcImage, srcResolution );\n            \n            float d1 = length(result.colourA * intensity0 - samp);\n            float d2 = length(result.colourB * intensity0 - samp);\n            if (d1 < d2) scoreA += d1; else scoreA += d2;\n            \n            float d3 = length(result.colourA * intensity1 - samp);\n            float d4 = length(result.colourB * intensity1 - samp);\n            if (d3 < d4) scoreB += d3; else scoreB += d4;            \n        }\n    }    \n\n    float intensity = intensity0;\n    if (scoreB < scoreA) intensity = intensity1;\n\n    \n    result.colourA *= intensity;\n    result.colourB *= intensity;\n    \n    return result;\n}\n\n#endif\n\n\nvec3 GetPixelColour( BlockColours blockColours, vec2 pixelCoord, sampler2D srcImage, vec2 srcResolution, int loadingByteIndex )\n{        \n    vec3 pixelColour = SamplePixel(pixelCoord, srcImage, srcResolution );\n    float hash = GetBayer( pixelCoord );\n    pixelColour = ApplyDither( pixelColour, hash );    \n\n    vec3 colA = blockColours.colourA;\n    vec3 colB = blockColours.colourB;\n\n    int attributeByteIndex = (256 * 192/8) + int( floor(pixelCoord.x / 8.) + (24.-floor(pixelCoord.y / 8.)) * (resolution.x / 8.) );\n    \n    if ( attributeByteIndex > loadingByteIndex )\n    {\n        colA = vec3(0);\n        colB = vec3(1) * intensity0;\n    }\n    \n    int pixelY = int(resolution.y) - 1 - int(pixelCoord.y);\n    int pixelYBlock = pixelY / (8*8);\n    int pixelYChar = (pixelY & (8*8-1)) / 8;\n    int pixelYCharRow = (pixelY & (8*8-1)) % 8;\n    int pixelYIndex = pixelYChar + pixelYCharRow * 8 + pixelYBlock * 8*8;\n    \n    int pixelByteIndex = int(pixelCoord.x) / 8 + pixelYIndex * int(resolution.x)/8;\n\n    if (pixelByteIndex > loadingByteIndex)\n    {\n        pixelColour = vec3(1);\n    }\n\n    float dist1 = Dist2( colA, pixelColour );\n    float dist2 = Dist2( colB, pixelColour );\n    if ( dist1 < dist2 )\n    {\n        return colA;\n    }\n    else\n    {                   \n        return colB;\n    }                        \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/resolution.xy;\n    \n    if (uv.x < 0.0 || uv.y < 0.0 || uv.x >= 1.0 || uv.y >= 1.0)\n    {\n        discard;\n    }\n    \n    vec3 col = vec3(1);\n\n    vec2 pixelCoord = floor(uv * resolution);\n\n    BlockColours blockColours = GetBlockColours( pixelCoord, iChannel0, iChannelResolution[0].xy );\n\n    int loadingByteIndex = iFrame * loadSpeed - startDelay;\n\n    col = GetPixelColour( blockColours, pixelCoord, iChannel0, iChannelResolution[0].xy, loadingByteIndex );\n    col = RGBtoYUV( col );\n\n    fragColor = vec4(col,1.0);     \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}