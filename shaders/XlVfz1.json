{
    "Shader": {
        "info": {
            "date": "1541846043",
            "description": "in line 127-133 you can adjust things.\nthe trick is to find the intersecting point of both shapes andfind the normals of that point to both shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlVfz1",
            "likes": 17,
            "name": "crescent shape distance",
            "published": 3,
            "tags": [
                "2d",
                "distance",
                "crescent"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 870
        },
        "renderpass": [
            {
                "code": "#define exact\n\n//circle centers can be anywhere in this\nfloat crescent(vec2 p, vec2 p0, vec2 p1, float r0, float r1, float sign0, float sign1) {\n    \n    p -= p0;\n    p1 -= p0;\n#ifdef exact\n    float d = length(p1);\n    vec2 n = normalize(p1);\n    vec2 nt = vec2(n.y,-n.x);\n    p += -nt*max(dot(p,nt),0.0)*2.0;\n    \n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if (a < r0) {\n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = a*n-b*nt;\n        vec2 q = p-corner;\n\n        vec2 n0 = d*(corner-p1);\n        n0 = vec2(n0.y,-n0.x);\n\n        vec2 n1 = d*corner;\n        n1 = vec2(-n1.y,n1.x);\n\n        if (min(sign0*dot(q,n0),sign1*dot(q,n1)) > 0.0) {\n            return length(q);\n        }\n\t}\n#endif\n    float len = sign0*(length(p)-r0);\n    len = max(len,sign1*(length(p-p1)-r1));\n    return len;\n}\n\n//simplified version by iq\nfloat crescent2(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\nfloat crescent(vec2 p, float r0, float r1, float d, float sign0, float sign1) {\n    \n    //taken from:\n    //https://stackoverflow.com/questions/3349125/circle-circle-intersection-points\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n#ifdef exact\n    if (a < r0) {\n    \tp.y = abs(p.y);\n        \n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = vec2(a,b);\n        vec2 q = p-corner;\n        \n        vec2 n0 = d*(corner-vec2(d,0));\n        n0 = vec2(n0.y,-n0.x);\n        \n        vec2 n1 = d*corner;\n        n1 = vec2(-n1.y,n1.x);\n\t\t\n        //uses dot product to determine which side of the lines the pixel is in\n        if (min(sign0*dot(q,n0),sign1*dot(q,n1)) > 0.0) {\n            return length(q);\n        }\n        \n    }\n#endif\n    \n    return max(sign0*(length(p)-r0),sign1*(length(p-vec2(d,0))-r1));\n}\n\nfloat line( vec2 pa, vec2 ba) \n{\n    float h = max( dot(pa,ba)/dot(ba,ba), 0.0 );\n    return length( pa - ba*h );\n}\n\nfloat visualize(vec2 p, float r0, float r1, float d, float sign0, float sign1) {\n    \n    //taken from:\n    //https://stackoverflow.com/questions/3349125/circle-circle-intersection-points\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    float len = abs(length(p)-r0);\n    len = min(len,abs(length(p-vec2(d,0))-r1));\n    \n    if (a < r0) {\n    \tp.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        vec2 corner = vec2(a,b);\n        vec2 q = p-corner;\n\n        vec2 n0 = normalize((corner-vec2(d,0)));\n        //n0 = vec2(n0.y,-n0.x);\n\n        vec2 n1 = normalize(corner);\n        //n1 = vec2(-n1.y,n1.x);\n\n        len = min(len,abs(line(q,sign1*n0*10.0)));\n        len = min(len,abs(line(q,sign0*n1*10.0)));\n    }\n    \n    return max(0.5-len*iResolution.y/16.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    float t = iTime;\n    float r0 = 0.8;\n    float r1 = 0.6+sin(t*0.8)*0.3;\n    float d = sin(t)*1.2;\n    \n    float sign0 = sign(fract(iTime*0.1)-0.5);\n    float sign1 = sign(fract(iTime*0.05)-0.5);\n    \n    //finding crescent shape distance\n    float len = crescent(uv, r0, r1, d, sign0, sign1);\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n    //this is a bit different, i wanted the border to be resolution independent\n    vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\n\tfragColor = vec4(col*col, 1.0);\n    \n    fragColor += visualize(uv, r0, r1, d, sign0, sign1);\n    \n    //quadtree part\n    /**\n    vec2 p = uv;\n    vec2 fp = floor(p);\n    vec2 lp = p-fp;\n    float size = 1.0;\n    \n    for (int i = 0; i < 5; i++) {\n    \tfloat len = crescent(fp+size*0.5, r0, r1, d, sign0, sign1);\n        if (abs(len) > size*0.5*sqrt(2.0)) break;\n        \n        vec2 q = step(0.5,lp);\n        lp = lp*2.0-q;\n        size *= 0.5;\n        fp += q*size;\n        \n    }\n    lp = abs(lp-0.5);\n    float a = max(1.0-(1.0-max(lp.x,lp.y)*2.0)*size*iResolution.y*0.125,0.0)*0.1;\n    fragColor += vec4(a);\n\t/**/\n    \n    // squareroot for 2.0 gamma\n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}