{
    "Shader": {
        "info": {
            "date": "1459213557",
            "description": "* Click to the first candy and then click to the second to replace it !\n* Make the most points ;)",
            "flags": 96,
            "hasliked": 0,
            "id": "XdtSDH",
            "likes": 165,
            "name": "Candy Crush",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "buffer",
                "candycrush"
            ],
            "usePreview": 1,
            "username": "ciberxtrem",
            "viewed": 14029
        },
        "renderpass": [
            {
                "code": "const float xCells = 10.;\nconst float yCells = 8.;\nconst vec2 cellSize = vec2(0.5);\nconst vec2 gridPos = vec2(6.315, 0.8);\n\nvec4 mCellId    = vec4(0.,    0.,     xCells, yCells);\nvec4 mCellPos   = vec4(0.,    yCells, xCells, yCells);\nvec2 mState     = vec2(0., 2.*yCells);\nvec2 mSelected0 = vec2(1., 2.*yCells);\nvec2 mSelected1 = vec2(2., 2.*yCells);\nvec2 mMouse     = vec2(3., 2.*yCells);\n\nvec4 gState;\nvec2 gUv;\nfloat gT;\n\n//-----------------------------------------------------------------------------------\n//  Font reference:\n//  Dave_Hoskins - https://www.shadertoy.com/view/XdXGRB\n//  original reference claudiocc - http://glslsandbox.com/e#9743.20 \n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n\n#define E_ vec2(1.,1.)\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\nvec2 caret_origin = vec2(3.0, .7);\nvec2 caret;\n\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gT*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\nvec2 r(vec2 pos)\n{\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n//-----------------------------------------------------------------------------------\n\nfloat hash(float x) { return fract(sin(x)*15.4); }\n\nvec4 Load(vec2 memPos, sampler2D sampler, vec2 resolution)\n{\n    return texture(sampler, (memPos+0.5)/resolution, -100.);\n}\n\nfloat dsCell(vec2 p)\n{\n    return length(max(abs(p)-cellSize, 0.)) - 0.075;\n}\n\nfloat dsBox(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b, 0.)) - r;\n}\n\nvec2 dsSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float h = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return vec2( length(p-ab*h), h );\n}\n\n\t\n// polynomial smooth min (k = 0.1) taken from iq;\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat IsSameCell(vec2 a, vec2 b)\n{\n    vec2 dir = b-a;\n    return dot(dir, dir) < 1e-3 ? 1. : 0.;\n}\n\nvec2 Rot(vec2 p, float rad)\n{\n    float c = cos(rad); float s = sin(rad);\n    return vec2(c*p.x-s*p.y, c*p.y+s*p.x);\n}\n\nmat3 RotZ(float rad)\n{\n    float s = sin(rad);\n    float c = cos(rad);\n    return mat3(\n        c,  s, 0.,\n        -s, c,  0.,\n        0., 0., 1.\n    );\n}\n\nvec3 DrawCandy0(vec2 p, vec3 bgColor)\n{\n    float d = length(p)-0.5;\n    float d2 = d;\n    \n    vec3 color = vec3(0.078, 0.2, 0.882);\n    color = mix(color*0.9, color*1.1, smoothstep(-0.2, 0.4, p.x));\n    vec2 q = p; q.y -= -0.1+ cos(1.+p.x*1.)*0.15;\n    d = dsBox(q, vec2(0.45, 0.05), 0.05);\n    d2 = min(d2, d);\n    color = mix(color*1.5, color, smoothstep(0., 2e-2, d)); \n    \n    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(1.8) ).rgb;\n    color *= 1.+cubeTex.r;\n    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.1, 0.2))*vec2(1.2, 2.2))), 0.35) );\n    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.1, -0.2))*vec2(1.2, 2.2))), 0.28) );\n    color = mix(color, vec3(0.), smoothstep(0.0, 1., 1.-exp(-2.5*max(d2+0.2, 0.)) ));\n    return mix(color, bgColor, smoothstep(0., 0.1, d2));\n}\n\nvec3 DrawCandy1(vec2 p, vec3 bgColor)\n{\n    vec2 pos[7];\n    pos[0]=vec2(0., 0.); \n    pos[1]=vec2(-0.23, 0.34); pos[2]=vec2(0.23, 0.34); pos[3]=vec2(0.42, 0.0);\n    pos[4]=vec2(0.23, -0.34); pos[5]=vec2(-0.23, -0.34); pos[6]=vec2(-0.42, 0.0);\n    \n    \n    vec3 color = vec3(0.572, 0.047, 0.752);\n    float d2 = 1.;\n    for(int i=0; i<7;++i)\n    {\n        vec2 q = p-pos[i];\n        float d = length(q)-0.22;\n        \n        vec3 baseColor = vec3(0.572, 0.047, 0.752);\n        vec3 cubeTex = texture(iChannel2, normalize(vec3(q.xy,1.)) *RotZ(1.8) ).rgb;\n        baseColor *= 1.+cubeTex.r*0.25;\n        baseColor += (1.-smoothstep(0., 1., pow(abs(length((q-vec2(-0.05, 0.05))*vec2(1.2, 2.2))), 0.2) ))*1.5;\n        color = mix(baseColor, color, smoothstep(0., 1e-2, d));\n        d2 = smin(d, d2, 0.2);\n    }\n    color = mix(color, vec3(0.), smoothstep(0.0, 1., 1.-exp(-4.5*max(d2+0.1, 0.)) ));\n    return mix(color, bgColor, smoothstep(0., 2e-2, d2));\n}\n\nvec3 DrawCandy2(vec2 p, vec3 bgColor)\n{\n    vec2 q = p-vec2(0., +0.4);\n    vec2 seg = dsSegment(q, vec2(0., 0.0), vec2(0.0, -0.5));\n    float d = seg.x - (0.1+2.0*pow(seg.y*0.1, 0.8)) + (length(p)-0.5)*0.5;\n    vec3 color = vec3(0.733, 0.752, 0.047)*0.8;\n    \n    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(1.8) ).rgb;\n    color *= 1.+cubeTex.r*0.20;\n    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.05, 0.11))*vec2(1.8, 1.2))), 0.2) );\n    color += 1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.05, -0.1))*vec2(1.7, 1.2))), 0.21) );\n    \n    vec3 tmpColor = mix(mix(color*0.5, color, smoothstep(-0.5, 0.4, p.y)), color, smoothstep(0., 1., 2.*pow(abs(d+0.15), 0.4)));\n    color = mix(tmpColor, color, 1.-exp((-5.0*max(d+0.25, 0.))));\n    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));\n    \n    return mix(color, bgColor, smoothstep(0., 2e-2, d));\n}\n\nvec3 DrawCandy3(vec2 p, vec3 bgColor)\n{\n    vec2 q = p-vec2(-0.15, +0.35);\n    q = Rot(q, q.y*0.6);\n    vec2 seg = dsSegment(q, vec2(0., 0.0), vec2(0.0, -0.65));\n    float d = seg.x - 0.25 -seg.y*0.06;\n    vec3 color = vec3(0.752, 0.047, 0.047)*0.8;\n    \n    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;\n    color *= 1.+cubeTex.r*0.30;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.20, 0.35))*vec2(1.8, 1.2))), 0.1) ))*2.9;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.20, -0.3))*vec2(1.7, 1.2))), 0.11) ))*2.5;\n    \n    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.2, 0.))));\n    \n    return mix(color, bgColor, smoothstep(0., 2e-2, d));\n}\n\nvec3 DrawCandy4(vec2 p, vec3 bgColor)\n{\n    vec2 q = p-vec2(-0.0, +0.0);\n    q.x *= 1./(1.+abs(q.y)*0.25);\n    float d = dsBox(q, vec2(0.20, 0.30), 0.25);\n    vec3 color = vec3(0.345, 0.882, 0.254)*0.6;\n    color = mix(color*0.4, color, smoothstep(-0.7, 0.3, p.y));\n    \n    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;\n    color *= 1.+cubeTex.r*0.30;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.15, 0.15))*vec2(0.5, 1.2))), 0.12) ))*2.5;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.25, -0.1))*vec2(0.9, 1.2))), 0.11) ))*2.5;\n    \n    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));\n    \n    return mix(color, bgColor, smoothstep(0., 2e-2, d));\n}\n\n/*vec3 DrawCandy5(vec2 p, vec3 bgColor)\n{\n    vec2 q = p-vec2(-0.0, +0.0);\n    q.x *= 1./(1.+abs(q.y)*0.25);\n    float d = length(q*vec2(1., 0.7)*0.60)- 0.25;\n    vec3 color = vec3(0.968, 0.698, 0.031);\n    color = mix(color, vec3(0.968, 0.698, 0.031)*0.4, texture(iChannel1, p.xy*vec2(3.0, 1.)).r );\n    \n    float d2 = length(q*vec2(1., 0.7)*0.60)- 0.15;\n    color = mix(vec3(0.811, 0.650, 0.247), color, smoothstep(0.0, 1.0, pow(18.*abs(d2), 1.0)));\n    \n    \n    color = mix(color*0.4, color, smoothstep(-1.0, 0.3, p.y));\n    \n    vec3 cubeTex = texture(iChannel2, normalize(vec3(p.xy,1.)) *RotZ(4.8) ).rgb;\n    color *= 1.+cubeTex.r*0.30;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(-0.24, 0.15))*vec2(1.5, 1.0))), 0.12) ))*2.5;\n    color += (1.-smoothstep(0., 1., pow(abs(length((p-vec2(0.15, -0.15))*vec2(0.9, 1.2))), 0.11) ))*2.5;\n    \n    color = mix(color, color*0.0, 1.-exp((-2.5*max(d+0.1, 0.))));\n    \n    return mix(color, bgColor, smoothstep(0., 2e-2, d));\n}\n*/\n\nvec3 DrawCandyExplosion(vec2 p, vec3 candyColor, vec3 bgColor, vec4 candyIdData)\n{\n    float t = (1.-candyIdData.w);\n\n    if(candyIdData.w > 0.99){return candyColor;}\n    for(float i=0.; i<12.;++i)\n    {\n        float size = max(hash(10.-i)*1.5, 0.1);\n        vec2 vel = normalize(vec2(hash(i), hash(5.+6.*i)))*(hash((i+4.)*6.)*2.-1.)*1.5;\n        vec2 pos = vel*pow(t, 0.3);\n        \n        vec2 q = p-pos;\n        candyColor += step(1e-3, t)*candyColor*(1.-smoothstep(0., 1., length(q)/size ));\n    }\n    \n    candyColor = mix(bgColor, candyColor, candyIdData.w);\n    \n    float size = 1.*t;\n    float d = length(p)-size;\n    candyColor += step(1e-3, t)*sin(PI*pow(t, 0.5))*candyColor* (1.-smoothstep(0.2, 1., abs(d)/0.4));\n    return candyColor;\n}\n\nvec3 DrawCandy(vec2 p, vec3 bgColor, vec4 candyIdData)\n{\n    p *= 1.2;\n    vec3 candyColor;\n    if(candyIdData.z < 0.5) { candyColor = DrawCandy0(p, bgColor);}\n    else if(candyIdData.z < 1.5) { candyColor = DrawCandy1(p, bgColor);}\n    else if(candyIdData.z < 2.5) { candyColor = DrawCandy2(p, bgColor);}\n    else if(candyIdData.z < 3.5) { candyColor = DrawCandy3(p, bgColor);}\n    else /*if(candyIdData.z < 4.5)*/ { candyColor = DrawCandy4(p, bgColor);}\n    //else { candyColor  = DrawCandy5(p, bgColor); }\n    \n    candyColor = DrawCandyExplosion(p, candyColor, bgColor, candyIdData);\n    \n    return candyColor;\n}\n\nvec2 GetCellPos(vec2 cellId)\n{\n    return gridPos + cellId*1.2;\n}\n\nfloat LerpEaseOutBounce(float t, float b, float c, float d)\n{\n//  Reference: https://github.com/gdsmith/jquery.easing/blob/master/jquery.easing.js\n    if ((t/=d) < (1./2.75)) {\n        return c*(7.5625*t*t) + b;\n    } else if (t < (2./2.75)) {\n        return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;\n    } else if (t < (2.5/2.75)) {\n        return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;\n    } else {\n        return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;\n    }\n}\n\nvec3 DrawCellBg(vec2 p, vec2 cellId, vec3 bgColor)\n{\n    vec4 selected0 = Load(mSelected0, iChannel0, iChannelResolution[0].xy);\n    vec4 selected1 = Load(mSelected1, iChannel0, iChannelResolution[0].xy);\n    \n    vec3 color = vec3(0.160, 0.333, 0.498);\n    color = mix(color, vec3(0.172, 0.729, 0.188), step(0.5, IsSameCell(selected0.xy, cellId.xy)));\n    color = mix(color, vec3(0.729, 0.325, 0.172), step(0.5, IsSameCell(selected1.xy, cellId.xy)));\n    \n    vec2 q = p-GetCellPos(cellId.xy);\n    float d = dsCell(q);\n    color = mix(color, bgColor, min(0.5+step(0., d), 1.));\n   \n    return color;\n}\n\nvec3 DrawCell(vec2 p, vec2 cellId, vec3 bgColor)\n{\n    vec4 cellIdData = Load(mCellId.xy+cellId, iChannel0, iChannelResolution[0].xy);\n    vec4 cellIdPosData = Load(mCellPos.xy+cellId, iChannel0, iChannelResolution[0].xy);\n    \n    vec2 q = p-cellIdData.xy;\n    return DrawCandy(q, bgColor, cellIdData);\n}\n\nvec3 DrawClouds(vec2 p, vec3 color)\n{\n    // Clouds\n    p = Rot(p, 3.14159);\n    vec2 q = p;\n    vec2 q2 = q;\n    q2.x *= 0.2; q2 *= 2.;\n    q2.y -= 1.2*pow(abs( sin(q2.x*6.)), 0.5)*1.*step(0., q2.y);\n    q2.y += cos(q2.x*4.)*0.2;\n    float d = length(max(abs(q2)-vec2(1., 1.0), 0.))-0.1;\n    d = max(d, -q.y+0.5);\n    \n    q -= vec2(0., 1.0);\n    q2 = q;\n    q2.x *= 0.2; q2 *= 2.;\n    q2.y += 1.3*pow(abs( cos(q2.x*5.5)), 0.5)*1.*step(q2.y, 0.);\n    q2.y -= cos(q2.x*4.)*0.2;\n    float d2 = length(max(abs(q2)-vec2(1., 1.0), 0.))-0.1;\n    d2 = max(d2, q.y+0.5);\n    d = min(d, d2);\n    \n    q2 = q-vec2(1.60, -0.4);\n    d = max(d, min(q2.x,(length(q2)-1.0))  );\n    q2 = q-vec2(-1.60, -0.4);\n    d = max(d, min(-q2.x,(length(q2)-1.0))  );\n    \n    vec3 texColor = texture(iChannel1, vec2(q2.xy)*vec2(0.2, 0.1)).rgb;\n    vec3 cloudColor = mix(vec3(0.866, 0.866, 0.811), vec3(0.607, 0.607, 0.372), smoothstep(0.3, 1.,texColor.r));\n    color = mix(cloudColor, color, smoothstep(0., 0.05, d));\n    \n    // String Hole\n    q2 = q-vec2(0., -1.35);\n    q2.y *= 0.9;\n    d = length(q2)-0.3;\n    d2 = length(q2)-0.15;\n    d = max(d, -d2);\n    color = mix(cloudColor, color, smoothstep(0., 0.05, d));\n    \n    // Hole\n    q2 -= vec2(0., -3.6);\n    vec3 stringColor = mix(vec3(0.505, 0.376, 0.031), vec3(0.807, 0.596, 0.035), abs(q2.x)*20.);\n    d = length(max(abs(q2)-vec2(0.01, 3.5), 0.))-0.03;\n    color = mix(stringColor, color, smoothstep(0., 0.05, d));\n    \n    return color;\n}\n\nvec3 DrawBg(vec2 p)\n{\n    vec3 color = mix(vec3(0.850, 0.882, 0.905), vec3(0.050, 0.439, 0.772), pow(abs(p.y-3.)*0.15, 1.8));\n    \n    // Rainbow\n    vec2 q = p + vec2(0., -10.)*(1.-smoothstep(0., 1., gT-0.8));\n    q -= vec2(2., 5.);\n    q = Rot(q, 0.5);\n    q.x *= 0.8;\n    \n    float d = abs(length(q+vec2(sin(atan(q.y,q.x)*7.)*0.03))-3.1)-1.30;\n    color = mix(vec3(0.803, 0.807, 0.631), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-4.)-0.15;\n    color = mix(vec3(0.854, 0.603, 0.525), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-3.65)-0.15;\n    color = mix(vec3(0.854, 0.847, 0.525), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-3.30)-0.15;\n    color = mix(vec3(0.678, 0.854, 0.525), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-2.95)-0.15;\n    color = mix(vec3(0.525, 0.854, 0.819), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-2.55)-0.15;\n    color = mix(vec3(0.764, 0.525, 0.854), color, smoothstep(0., 0.1, d));\n    d = abs(length(q)-2.16)-0.15;\n    color = mix(vec3(0.443, 0.415, 0.941), color, smoothstep(0., 0.1, d));\n    \n    // Mountains\n    q = p + vec2(0., 10.)*(1.-smoothstep(0., 1.5, gT));\n    vec3 mountainCol = mix(vec3(0.678, 0.768, 0.270), vec3(0.4, 0.592, 0.266), smoothstep(4., 16., q.x));\n    color = mix(mountainCol, color, smoothstep(0., 0.1, (q.y-3.5)+sin(-3.25+q.x*0.5)*3.6*sin(.0+q.x*0.08)*1.+sin(q.x*1.5)*0.15));\n    mountainCol = mix(vec3(0.286, 0.470, 0.231), vec3(0.529, 0.662, 0.376), smoothstep(0., 6., p.x));\n    color = mix(mountainCol, color, smoothstep(0., 0.1, (q.y-1.5)+sin(-1.+q.x*0.17)*3.6+sin(q.x*1.5)*0.1));\n    \n    color = DrawClouds(p-vec2(9.5, 5.5+cos(gT*0.25)*1.) + vec2(0., -10.)*(1.-smoothstep(0., 1.5, gT-1.4)), color);\n    color = DrawClouds(p-vec2(3.0, 6.0+sin(-1.4+gT*0.25)) + vec2(0., -10.)*(1.-smoothstep(0., 1.5, gT-1.9)), color);\n    \n    return color;\n}\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // reference P_Malin - https://www.shadertoy.com/view/4sf3RN\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvec3 DrawUIBox(vec2 q, vec3 color)\n{\n    vec3 scoreCol = vec3(0.890, 0.588, 0.839);\n    scoreCol = mix(scoreCol, scoreCol*1.5, smoothstep(-2., 2., q.x));\n    float d = dsBox(q, vec2(1.0, 0.35), 0.2);\n    color = mix(mix(scoreCol, color, 0.4), color, smoothstep(0., 0.01, d));\n    vec3 frameColor = mix(vec3(0.917, 0.062, 0.768), vec3(0.917, 0.062, 0.768)*0.8, step(0.5, fract(Rot(q*2., -0.7).x)));\n    frameColor += vec3(1.)*pow(max((1.-abs(q.x)), 0.), 2.5)*0.4;\n    frameColor *= exp(-2.8*max(d+0.1, 0.));\n    return mix(frameColor, color, smoothstep(0., 0.01, abs(d)-0.06 ));\n}\n\nvec3 DrawScore(vec2 p, vec3 color)\n{\n    vec2 q = p - vec2(1.8, 1.5) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.45));\n    color = DrawUIBox(q*vec2(0.8, 1.), color);\n    \n    float d = PrintInt(q*3.0-vec2(-4.5, -1.0), gState.z*25.);\n    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;\n    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));\n    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));\n    \n    q -= vec2(-1.2, 0.35); q*=0.25;\n    caret.x = count = 0.;\n    d = S(r(q)); add(); d += C(r(q)); add(); d += O(r(q));  add(); d += R(r(q));  add(); d += E(r(q)); \n    color = mix(color, lettersColor*0.1, smoothstep(0.4, 1.0, d));\n    color *= smoothstep(0., 0.005, length(q-vec2(0.27, 0.))-0.008);\n    color *= smoothstep(0., 0.005, length(q-vec2(0.27, -0.035))-0.008);\n    \n    return color;\n}\n\nvec3 DrawMovements(vec2 p, vec3 color)\n{\n    vec2 q = p - vec2(1.5, 3.0) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.3));\n    color = DrawUIBox(q, color);\n    \n    float d = PrintInt(q*3.0-vec2(-4.0, -1.0), gState.y);\n    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;\n    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));\n    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));\n    \n    q -= vec2(-1.0, 0.35); q*=0.25;\n    caret.x = count = 0.;\n    d = M(r(q)); add(); d += O(r(q));  add(); d += V(r(q));  add(); d += E(r(q));  add(); d += S(r(q)); \n    color = mix(color, lettersColor*0.1, smoothstep(0.4, 1.0, d));\n    color *= smoothstep(0., 0.005, length(q-vec2(0.27, 0.))-0.008);\n    color *= smoothstep(0., 0.005, length(q-vec2(0.27, -0.035))-0.008);\n    \n    return color;\n}\n\nvec3 DrawGoal(vec2 p, vec3 color)\n{\n    vec2 q = p - vec2(1.8, 9.0) + vec2(10., 0.)*(1.-smoothstep(0., 1., gT-3.0));\n    color = DrawUIBox(q*vec2(0.8, 0.8), color);\n    \n    float d = PrintInt(q*3.0-vec2(-4.0, -1.5), gState.w*25.);\n    vec3 lettersColor = vec3(0.188, 0.164, 0.133)*0.2;\n    lettersColor = mix(lettersColor, vec3(0.396, 0.376, 0.345), smoothstep(-0.3, 0.4, q.y));\n    color = mix(lettersColor, color, 1.-smoothstep(-0.0, 0.001, d));\n    \n    q -= vec2(-1.0, 0.35); q*=vec2(0.2, 0.25);\n    caret.x = count = 0.;\n    d = G(r(q)); add(); d += O(r(q));  add(); d += A(r(q));  add(); d += L(r(q));\n    color = mix(color, lettersColor*0.1, smoothstep(0.5, 1.0, d));\n    color *= smoothstep(0., 0.005, length(q-vec2(0.20, 0.))-0.008);\n    color *= smoothstep(0., 0.005, length(q-vec2(0.20, -0.035))-0.008);\n    \n    return color;\n}\n\nvec3 DrawWinLose(vec2 p, vec3 color)\n{\n    if(gState.x < 6.5) { return color; }\n    color *= 0.65;\n    \n    vec2 hGridSize = vec2(xCells, yCells)*1.2;\n    vec2 q = p - gridPos-hGridSize*0.5+0.6;\n    color = DrawUIBox(q*vec2(0.05, 0.7), color);\n    \n    vec3 lettersColor = mix(vec3(0.203, 0.372, 0.917)*0.8, vec3(0.203, 0.372, 0.917), smoothstep(-0.6, 0.4, q.y));\n    lettersColor = mix(lettersColor, mix(vec3(0.788, 0.133, 0.278)*0.8, vec3(0.788, 0.133, 0.278), smoothstep(-0.6, 0.4, q.y)), step(gState.z+0.5, gState.w));\n    \n    caret.x = count = 0.;\n    q *= 1.+sin(gT*4.)*0.1;\n    q -= vec2(-3., 0.);\n    q*= 0.1;\n    \n    caret.x = count = 0.;\n    float d = M(r(q)); add(); d += A(r(q));  add(); d += R(r(q));  add(); d += V(r(q));  add(); d += E(r(q));  add(); d += L(r(q));  add(); d += O(r(q));  add(); d += U(r(q));  add(); d += S(r(q));\n    float dWin = d;\n    caret.x = count = 0.;\n    d = T(r(q)); add(); d += R(r(q));  add(); d += Y(r(q));  space(); d += A(r(q));  add(); d += G(r(q));  add(); d += A(r(q));  add(); d += I(r(q));  add(); d += N(r(q)); // add(); d += S(r(q));\n    float dLose = d;\n    d = mix(dWin, dLose, step(gState.z+0.5, gState.w));\n    color = mix(color, lettersColor, smoothstep(0.5, 1.0, d));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gT = iTime;\n    vec2 uv = 10.*(fragCoord.xy / iResolution.y);\n    gUv = uv;\n    \n    gState = Load(mState, iChannel0, iChannelResolution[0].xy);\n    \n    vec3 color = DrawBg(uv);\n    vec2 cell = floor((uv-gridPos+0.6)/1.2);\n    if(cell.x >= 0.)\n    {\n        vec3 bgColor = DrawCellBg(uv, cell, color);\n        color = mix(color, bgColor, smoothstep(0., 0.5, gT-4.5));\n        color = DrawCell(uv, cell+vec2(-1., 0.), color);\n        for(float y=0.; y<yCells-0.5;++y)\n        {\n            vec2 currCell = vec2(cell.x, y);\n            color = DrawCell(uv, currCell, color);\n        }\n        color = DrawCell(uv, cell+vec2(+1., 0.), color);\n    }\n    \n    color = DrawScore(uv, color);\n    color = DrawMovements(uv, color);\n    color = DrawGoal(uv, color);\n    color = DrawWinLose(uv, color);\n    \n\tfragColor = vec4(pow(color, vec3(1.)),1.0)*smoothstep(0., 1., pow(gT, 0.8));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 2592,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/vol-11/candy-crush-soda-saga-long-loop-two"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Game Logic\n\nconst float xCells = 10.;\nconst float yCells = 8.;\nconst vec2 cellSize = vec2(0.5);\nconst vec2 gridPos = vec2(6.315, 0.8);\n\nfloat gT;\nvec4 mCellId    = vec4(0.,    0.,     xCells, yCells);\nvec4 mCellPos   = vec4(0.,    yCells, xCells, yCells);\nvec2 mState     = vec2(0., 2.*yCells);\nvec2 mSelected0 = vec2(1., 2.*yCells);\nvec2 mSelected1 = vec2(2., 2.*yCells);\nvec2 mMouse     = vec2(3., 2.*yCells);\nvec2 mLerp      = vec2(4., 2.*yCells);\n\nvec2 gFragCoord;\nvec4 gFragColor;\nvec4 gLerp;\n\nfloat hash(float x) { return fract(sin(x)*15.4); }\n\nfloat dsCell(vec2 p)\n{\n    return length(max(abs(p)-cellSize, 0.)) - 0.075;\n}\n\nfloat IsInside(vec2 memPos)\n{\n    vec2 res = abs(gFragCoord -0.5 -memPos) -0.5; return -max(res.x, res.y);\n}\nvoid Save(vec2 memPos, vec4 value)\n{\n    gFragColor = IsInside(memPos) > 0.0 ? value : gFragColor;\n}\n\nfloat IsInside(vec4 memPos)\n{\n    vec2 res = abs(gFragCoord -0.5 -memPos.xy -memPos.zw*0.5) -memPos.zw*0.5 -0.5; return -max(res.x, res.y);\n}\nvoid Save(vec4 memPos, vec4 value)\n{\n    gFragColor = IsInside(memPos) > 0.0 ? value : gFragColor;\n}\n\nvec4 Load(vec2 memPos, sampler2D sampler, vec2 resolution)\n{\n    return texture(sampler, (memPos+0.5)/resolution, -100.);\n}\n\nvec2 GetCellPos(vec2 cellId)\n{\n    return gridPos + cellId*1.2;\n    //return cellId;\n}\n\nfloat IsSameCell(vec2 a, vec2 b)\n{\n    vec2 dir = b-a;\n    return dot(dir, dir) < 1e-3 ? 1. : 0.;\n}\n\nfloat LerpEaseOutBounce(float t, float b, float c, float d)\n{\n    if ((t/=d) < (1./2.75)) {\n\t\t\treturn c*(7.5625*t*t) + b;\n\t\t} else if (t < (2./2.75)) {\n\t\t\treturn c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;\n\t\t} else if (t < (2.5/2.75)) {\n\t\t\treturn c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;\n\t\t} else {\n\t\t\treturn c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;\n\t\t}\n}\n\nvoid DoMove()\n{\n    for(float y=0.; y<yCells-0.5;++y) {\n        for(float x=0.; x<xCells-0.5;++x) {\n            if(IsInside(mCellId.xy+vec2(x, y)) > 0.)\n            {\n                vec4 cellId  = Load(mCellId.xy+vec2(x,y), iChannel0, iChannelResolution[0].xy);\n                vec4 cellPos = Load(mCellPos.xy+vec2(x,y), iChannel0, iChannelResolution[0].xy);\n\n                float t = clamp((gT-cellPos.z)/cellPos.w, 0., 1.);\n                t = mix(smoothstep(0., 1., pow(t, 0.5)), LerpEaseOutBounce(t, 0., 1., 1.), step(0.5, gLerp.z));\n                cellId.xy = mix(cellPos.xy, GetCellPos(vec2(x, y)), t);\n                Save(mCellId, cellId);\n            }\n        }\n    }\n}\n\nvoid Switch(vec2 selected0, vec2 selected1, float duration)\n{\n    vec4 cellId0 = Load(mCellId.xy+selected0.xy, iChannel0, iChannelResolution[0].xy);\n    vec4 cellId1 = Load(mCellId.xy+selected1.xy, iChannel0, iChannelResolution[0].xy);\n\n    if(IsInside(mCellId.xy+selected0.xy) > 0.)\n    {\n        vec4 cellId = cellId1;\n        Save(mCellId, cellId);\n    }\n    if(IsInside(mCellPos.xy+selected0.xy) > 0.)\n    {\n        vec4 cellPos = vec4(cellId1.xy, gT, 0.5);\n        Save(mCellPos, cellPos);\n    }\n\n    if(IsInside(mCellId.xy+selected1.xy) > 0.)\n    {\n        vec4 cellId = cellId0;\n        Save(mCellId, cellId);\n    }\n    if(IsInside(mCellPos.xy+selected1.xy) > 0.)\n    {\n        vec4 cellPos = vec4(cellId0.xy, gT, 0.5);\n        Save(mCellPos, cellPos);\n    }\n}\nvoid DoRefill()\n{\n    vec2 id = floor(gFragCoord);\n    if(gFragCoord.y > yCells) \n    {\n        id -= vec2(0., yCells);\n    }\n    \n    float numCells = 0.;\n    float dy = 0.;\n    for(float y=0.; y<yCells-0.5;++y)\n    {\n        vec2 currId = vec2(id.x, id.y -y);\n        if(currId.y < -0.5) { break; }\n        \n    \tvec4 numCellsData = Load(currId, iChannel2, iChannelResolution[2].xy);\n        float cellToRefill = step(1.5, numCellsData.x);\n        dy += cellToRefill;\n        numCells += cellToRefill;\n    }\n    \n    if(dy < 0.5)\n    {\n        return;\n    }\n    \n    for(float y=1.; y<yCells-0.5;++y)\n    {\n        vec2 currId = vec2(id.x, id.y +y);\n        if(currId.y > yCells-0.5) { break; }\n        if(y -0.5 > dy) { break; }\n        \n        vec4 numCellsData = Load(currId, iChannel2, iChannelResolution[2].xy);\n        dy += step(1.5, numCellsData.x);\n    }\n    \n    float baseDuration = 0.35*dy + 0.35*hash(gT);\n    float delay = id.y*0.045 + mod(id.x, 3.)*0.045;\n\n    vec2 sourceId = id;\n    vec2 targetId = sourceId + vec2(0., dy);\n\n    vec4 cellId = Load(mCellId.xy+targetId, iChannel0, iChannelResolution[0].xy);\n    if(targetId.y > yCells-0.5)\n    {\n        cellId = vec4(GetCellPos(targetId), floor(hash(iTime+2.+(id.x+13.)*(id.y+25.)*18.)*5.), 1.);\n    }\n    vec4 cellPos = vec4(cellId.xy, gT+delay, baseDuration);\n\n    Save(mCellId.xy +  sourceId.xy, cellId);\n    Save(mCellPos.xy + sourceId.xy, cellPos);\n}\n\nvoid DoKill(float blend)\n{\n    vec2 id = floor(gFragCoord);\n    if(gFragCoord.y > yCells) \n    {\n        id -= vec2(0., yCells);\n    }\n    \n    vec4 cellData = Load(id, iChannel2, iChannelResolution[2].xy);\n    float numCells = cellData.x;\n    \n    if(numCells > 1.5)\n    {\n        vec4 cellId   = Load(mCellId.xy+id, iChannel0, iChannelResolution[0].xy);\n        float t = clamp(blend, 0., 1.);\n        cellId.w = mix(1.0, 0.0, smoothstep(0., 1., t));\n        Save(mCellId, cellId);\n    }\n}\n\nvoid CalculateSelectedCells(in vec4 state, in vec4 mouse, inout vec4 selected0, inout vec4 selected1)\n{\n    if(mouse.w > 0.5 && mouse.z < 0.5 && selected0.z > 0.5)\n    {\n        for(float y=0.; y<yCells-0.5;++y) {\n            for(float x=0.; x<xCells-0.5;++x){\n                vec2 cellPos = GetCellPos(vec2(x, y));\n                float d = dsCell(mouse.xy-cellPos.xy);\n                if(d < 0.) \n                { \n                    selected0.xy = mix(vec2(x,y), selected0.xy, step(0.5, selected0.w));\n                    selected1.xy = mix(vec2(x,y), selected1.xy, step(selected0.w, 0.5));\n                    selected0.w += 1.;\n\n                    if(selected0.w > 1.5)\n                    {\n                        vec2 dir = abs(selected1.xy-selected0.xy);\n                        if(dir.x+dir.y > 1.5)\n                        {\n                            selected0 = selected1; selected0.z = 1.0;\n                            selected1 = vec4(-100., -100., 1.0, 0.);\n                            selected0.w = 1.0;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(fragCoord.x > xCells+1. || fragCoord.y > 2.*yCells+1.) return;\n    \n    gT = iTime;\n    gFragCoord = fragCoord;\n    gFragColor = texture(iChannel0, fragCoord/iResolution.xy, -100.);\n    \n    vec4 state   = Load(mState, iChannel0, iChannelResolution[0].xy);\n    vec4 selected0 = Load(mSelected0, iChannel0, iChannelResolution[0].xy);\n    vec4 selected1 = Load(mSelected1, iChannel0, iChannelResolution[0].xy);\n    vec4 mouse = Load(mMouse, iChannel0, iChannelResolution[0].xy);\n    mouse.xy = 10.*(iMouse.xy/iResolution.y);\n    mouse.w = mouse.z;\t// was clicked?\n    mouse.z = iMouse.z;\t// is clicked?\n    gLerp = Load(mLerp, iChannel0, iChannelResolution[0].xy);\n    \n    CalculateSelectedCells(state, mouse, selected0, selected1);\n    \n    if(iFrame == 0) \n    {\n        state = vec4(0.); \n    }\n    if(state.x < 0.5)\n    {   \n        state.z = 0.;\n        state.y = floor(20.+hash(gT+3.)*5.);\n        state.w = 60.+floor(+hash(gT+4.)*200.);\n        selected0 = selected1 = vec4(-100., -100., 0., 0.);\n        mouse = vec4(0.);\n        gLerp = vec4(0., 0., 1., 0.);\n        gLerp.x = gT;\n        \n        float baseDuration = 0.35*yCells + 0.35*hash(gT);\n        //for(float y=0.; y<yCells-0.5;++y) {\n            //for(float x=0.; x<xCells-0.5;++x) {\n                vec2 currCell = floor(fragCoord);\n                float delay = currCell.y*0.045 + mod(currCell.x+xCells*currCell.y+currCell.x, 3.)*0.045 + 4.0*step(float(iFrame), 0.5);\n            \tgLerp.y = max(gLerp.y, baseDuration + delay);\n                \n                //if(IsInside(mCellId.xy+currCell) > 0.)\n                {\n                    vec4 cellId = vec4(GetCellPos(currCell), floor(hash(iTime+2.+(currCell.x+13.)*(currCell.y+25.)*18.)*5.), 1.);\n                    Save(mCellId, cellId);\n                }\n                //if(IsInside(mCellPos.xy+currCell) > 0.)\n                {\n                    vec4 cellPos = vec4(GetCellPos(currCell+vec2(0.,yCells)), vec2(gT+delay, baseDuration));\n                    Save(mCellPos, cellPos);\n                }\n            //}\n        //}\n        \n        state.x = 1.0;\n    }\n    else if(state.x < 1.5) // SettingUp\n    {\n        DoMove();\n        if(gT > gLerp.x + gLerp.y)\n        {\n            state.x = 3.;\n        }\n    }\n    else if(state.x < 2.5) // Idle\n    {\n        selected0.z = 1.; //allow cell selection\n        \n        if(selected0.w > 1.5)\n        {\n            state.x = 3.;\n            state.y--;\n            gLerp = vec4(gT, 0.5, 0., 0.);\n            selected0.z = 0.; // disallow cell selection\n            Switch(selected0.xy, selected1.xy, 1.);\n        }\n\n    }\n    else if(state.x < 3.5) // Switch\n    {\n        DoMove();\n        if(gT > gLerp.x + gLerp.y)\n        {\n            vec4 gridInfo = Load(vec2(0., 0.), iChannel1, iChannelResolution[1].xy);\n            if( gridInfo.x > 1.) // Go to Kill\n            {\n                state.x = 5.;\n                selected0 = selected1 = vec4(-100., -100., 1., 0.);\n                gLerp = vec4(gT, 0.5, 0., 0.);\n            }\n            else // Go to Switch Back\n            {\n                state.x = 4.;\n                gLerp = vec4(gT, 0.5, 0., 0.);\n                Switch(selected0.xy, selected1.xy, 1.);\n                selected0 = selected1 = vec4(-100., -100., 1., 0.);\n            }\n        }\n    }\n    else if(state.x < 4.5) // Switch Back\n    {\n        DoMove();\n        if(gT > gLerp.x + gLerp.y)\n        {\n        \tstate.x = 2.;\n            state.y++;\n        }\n    }\n    else if(state.x < 5.5) // Killing\n    {\n        DoKill((gT-gLerp.x)/gLerp.y);\n        if(gT > gLerp.x + gLerp.y)\n        {\n            DoRefill();\n            vec4 adjacentData = Load(vec2(0., 0.), iChannel1, iChannelResolution[1].xy);\n            float maxDy = adjacentData.w+1.0;\n            float maxDuration = 0.5 + 0.35*maxDy + (yCells+3.)*0.045;\n            \n            gLerp = vec4(gT, maxDuration, 1., 0.);\n        \t\n            // add points\n            for(float y=0.; y<yCells-0.5;++y) {\n                for(float x=0.; x<xCells-0.5;++x) {\n                    vec4 adjacentData = Load(vec2(x, y), iChannel2, iChannelResolution[2].xy);\n                    state.z += step(1.5, adjacentData.x); // add points\n                }\n            }\n            state.x = 6.;\n        }\n    }\n    else if(state.x < 6.5) // Refill\n    {\n        DoMove();\n        if(gT > gLerp.x + gLerp.y)\n        {\n            \n            vec4 gridInfo = Load(vec2(0., 0.), iChannel1, iChannelResolution[1].xy);\n            if( gridInfo.x > 1.) // Go to Kill\n            {\n                state.x = 5.;\n                gLerp = vec4(gT, 0.5, 0., 0.);\n            }\n            else\n            {\n                if(state.y <= 0.)\n                {\n                    gLerp.x = gT;\n                    state.x = 7.;\n                }\n                else\n                {\n                    state.x = 2.;\n                }\n            }\n        }\n    }\n    else if(state.x < 7.5) // Win/Lose\n    {\n        if(gT > gLerp.x + 3.)\n        {\n            state.x = 0.;\n        }\n    }\n\n    Save(mState, state);\n    Save(mSelected0, selected0);\n    Save(mSelected1, selected1);\n    Save(mMouse, mouse);\n    Save(mLerp, gLerp);\n    \n    fragColor = gFragColor;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Every pixel will calculate the number of adjacent cells of same type in Horizontal and Vertical\n\nconst float xCells = 10.;\nconst float yCells = 8.;\nvec4 mCellId    = vec4(0.,    0.,     xCells, yCells);\nvec4 mCellPos   = vec4(0.,    yCells, xCells, yCells);\n\nfloat IsInside(vec2 memPos, in vec2 fragCoord)\n{\n    vec2 res = abs(fragCoord -0.5 -memPos) -0.5; return -max(res.x, res.y);\n}\nvoid Save(vec2 memPos, vec4 value, in vec2 fragCoord, inout vec4 fragColor)\n{\n    fragColor = IsInside(memPos, fragCoord) > 0.0 ? value : fragColor;\n}\nvec4 Load(vec2 memPos, sampler2D sampler, vec2 resolution)\n{\n    return texture(sampler, (memPos+0.5)/resolution, -100.);\n}\n\nfloat FindCells(vec2 myCellId, float myCellType, vec2 dir, inout vec2 hmin, inout vec2 hmax)\n{\n    float numCells = 0.;\n    for(float i=0.; i<8.;++i)\n    {\n        vec2 id = floor(myCellId.xy+dir*i);\n        vec4 currCellData = Load(mCellId.xy+id, iChannel0, iChannelResolution[0].xy);\n        if( min(id.x, id.y) < -0.5 || id.x >= xCells || id.y >= yCells || abs(currCellData.z-myCellType) > 0.5)\n        {\n            break;\n        }\n        numCells++;\n        hmin = min(hmin, id);\n        hmax = max(hmax, id);\n    }\n    return max(numCells-1., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(fragCoord.x > xCells+1. || fragCoord.y > yCells+1.) return;\n    \n    vec2 myCellId = floor(fragCoord);\n    \n    vec4 myCellIdData = Load(mCellId.xy+myCellId, iChannel0, iChannelResolution[0].xy);\n    vec4 myCurrCellIdPos = Load(mCellPos.xy+myCellId, iChannel0, iChannelResolution[0].xy);\n    \n    // Search for same cells in horizontal\n    vec2 hmin = vec2(99., 99.);\n    vec2 hmax = vec2(-99., -99.);\n    float numCellsX = 0.;\n    numCellsX  = FindCells(myCellId, myCellIdData.z, vec2(-1., 0.), hmin, hmax);\n    numCellsX += FindCells(myCellId, myCellIdData.z, vec2(1., 0.), hmin, hmax);\n    numCellsX = sign(max(numCellsX-1.5, 0.));\n    hmin *= numCellsX;\n    hmax *= numCellsX;\n    \n    // Search for same cells in vertical\n    vec2 vmin = vec2(99., 99.);\n    vec2 vmax = vec2(-99., -99.);\n    float numCellsY = 0.;\n    numCellsY  = FindCells(myCellId, myCellIdData.z, vec2(0., -1.), vmin, vmax);\n    numCellsY += FindCells(myCellId, myCellIdData.z, vec2(0., 1.), vmin, vmax);\n    numCellsY = sign(max(numCellsY-1.5, 0.));\n    vmin *= numCellsY;\n    vmax *= numCellsY;\n\n    float ymax = -99.;\n    float ymin = 99.;\n    vec2 hdir = abs(hmax-hmin); \n    float hcells = max(hdir.x, hdir.y);\n    if(hcells > 0.5) { ymin = hmin.y; ymax = hmax.y; }\n    \n    vec2 vdir = abs(vmax-vmin);\n    float vCells = max(vdir.x, vdir.y);\n    if(vCells > 0.5) { ymin = min(ymin, vmin.y); ymax = max(ymax, vmax.y); }\n    \n    fragColor = vec4(hcells+vCells, ymin, ymax, 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Store the cell with the most adjacent cells saved from Buffer B\n\nconst float xCells = 10.;\nconst float yCells = 8.;\n\nfloat IsInside(vec2 memPos, in vec2 fragCoord)\n{\n    vec2 res = abs(fragCoord -0.5 -memPos) -0.5; return -max(res.x, res.y);\n}\nvoid Save(vec2 memPos, vec4 value, in vec2 fragCoord, inout vec4 fragColor)\n{\n    fragColor = IsInside(memPos, fragCoord) > 0.0 ? value : fragColor;\n}\nvec4 Load(vec2 memPos, sampler2D sampler, vec2 resolution)\n{\n    return texture(sampler, (memPos+0.5)/resolution, -100.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(fragCoord.x > 2.0 || fragCoord.y > 2.0) return;\n    \n    float maxDist = 0.;\n    float maxDistY = 0.;\n    float minY = 99.;\n    float maxY = -99.;\n    \n    for(float y=0.; y<yCells-0.5;++y) {\n        for(float x=0.; x<xCells-0.5;++x) \n        {\n\n            vec4 data = Load(vec2(x,y), iChannel1, iChannelResolution[1].xy);\n            float dist = data.x;\n            maxDist = max(maxDist, dist);\n            if(dist > 0.5)\n            {\n               minY = min(minY, data.y); \n               maxY = max(maxY, data.z);\n               maxDistY = max(maxDistY, data.z-data.y);\n            }\n        }\n    }\n    \n    fragColor = vec4(maxDist, minY, maxY, maxDistY);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}