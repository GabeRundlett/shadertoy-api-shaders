{
    "Shader": {
        "info": {
            "date": "1507025540",
            "description": "click for occluding crosshair\n\nfork of multi-sampling crepuscular-ity, dithered via Bayer\nhttps://www.shadertoy.com/view/4dyXWy\n- no buffers (Bayer matrix bitmap is very optional)\n- generalize to be more parametric, maybe?",
            "flags": 0,
            "hasliked": 0,
            "id": "ltsyWl",
            "likes": 110,
            "name": "Simpler dither godrays",
            "published": 3,
            "tags": [
                "shadow",
                "dither",
                "godrays",
                "halftone",
                "eclipse",
                "lightrays",
                "dithering",
                "crepuscular",
                "bayer",
                "differentiation",
                "bufferlessdoubleimagebuffer"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 5247
        },
        "renderpass": [
            {
                "code": "/*\nad 2d crepuscular occlusion dither bayer eclipse\n\nparent : https://www.shadertoy.com/view/4dyXWy\nself   : https://www.shadertoy.com/view/ltsyWl\n\nInstead of reading from a bitmap, this uses one of 2 bayer matrix generators.\nParents bufferA is a subroutine here: BuffA.mainImage() <- BA()\n\n- no buffers (Bayer matrix bitmap is very optional)\n- generalize to be more parametric, maybe?\n*/\n\n//blurriness of borders, sets contour line smoothness\n// Will be scaled by shortest domain of screen resolution\n// [>0.]!! Set to [1.] for ideal 1:1 subbixel smoothness.\n// if (you use dFdx()) do [#define blur >=2.]\n#define blur 1.\n\n#define DITHER\t\t\t//Dithering toggle\n#define QUALITY\t\t2\t//0- low, 1- medium, 2- high\n\n#define DECAY\t\t.974\n#define EXPOSURE\t.24\n#if (QUALITY==2)\n #define SAMPLES\t64\n #define DENSITY\t.97\n #define WEIGHT\t\t.25\n#else\n#if (QUALITY==1)\n #define SAMPLES\t32\n #define DENSITY\t.95\n #define WEIGHT\t\t.25\n#else\n #define SAMPLES\t16\n #define DENSITY\t.93\n #define WEIGHT\t\t.36\n#endif\n#endif\n\n\n//planar zoom.\n#define ViewZoom 3.\n//sub-pixel blur\n#define fsaa 14./min(iResolution.x,iResolution.y)\n//View Frame\n#define fra(u) (u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n//maxiterations for bayer matrix, maximum value is number of bits of your data type?\n//for crepuscular ray dithering [1..3] iterations are enough\n//because it is basically \"noisy scattering\" so  any patterns in it are \"just fine\"\n#define iterBayerMat 1\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n//return bayer matrix (bitwise operands for speed over compatibility)\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{ivec2 p=ivec2(pixelpos);int a=0\n;for(int i=0; i<iterBayerMat; i++\n){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);\n}return float(a)/float(2<<(iterBayerMat*2-1));}\n//https://www.shadertoy.com/view/XtV3RG\n\n//analytic bayer over 2 domains, is unrolled loop of GetBayerFromCoordLevel().\n//but in terms of reusing subroutines, which is faster,while it does not extend as nicely.\nfloat bayer2  (vec2 a){a=floor(a);return fract(dot(a,vec2(.5, a.y*.75)));}\nfloat bayer4  (vec2 a){return bayer2 (  .5*a)*.25    +bayer2(a);}\nfloat bayer8  (vec2 a){return bayer4 (  .5*a)*.25    +bayer2(a);}\nfloat bayer16 (vec2 a){return bayer4 ( .25*a)*.0625  +bayer4(a);}\nfloat bayer32 (vec2 a){return bayer8 ( .25*a)*.0625  +bayer4(a);}\nfloat bayer64 (vec2 a){return bayer8 (.125*a)*.015625+bayer8(a);}\nfloat bayer128(vec2 a){return bayer16(.125*a)*.015625+bayer8(a);}\n#define dither2(p)   (bayer2(  p)-.375      )\n#define dither4(p)   (bayer4(  p)-.46875    )\n#define dither8(p)   (bayer8(  p)-.4921875  )\n#define dither16(p)  (bayer16( p)-.498046875)\n#define dither32(p)  (bayer32( p)-.499511719)\n#define dither64(p)  (bayer64( p)-.49987793 )\n#define dither128(p) (bayer128(p)-.499969482)\n//https://www.shadertoy.com/view/4ssfWM\n\n//3 ways to approach a bayer matrix for dithering (or for loops within permutations)\nfloat iib(vec2 u){\n return dither128(u);//analytic bayer, base2\n return GetBayerFromCoordLevel(u*999.);//iterative bayer \n //optionally: instad just use bitmap of a bayer matrix: (LUT approach)\n //return texture(iChannel1,u/iChannelResolution[1].xy).x;\n}\n\n\n//x is result, yz are position in normalized coords.\n //This is just a quick hack for this shader only.\nvec3 sun( vec2 uv ) {\t\n//o put op inside this function, making p not a parameter of it, because\n    vec2 p=fra(abs(iMouse.zw))*.666;//damnit, the source shader has rather silly frame scaling, this irons it out a bit\n    //but this is a poor overwriting patch\n    //has something t do with averaging over 3 occluders within this function.\n    //this one is special, and far from general.\n    if(iMouse.z<=0.)p=vec2(sin(iTime), sin(iTime*.5)*.5);\n    vec3 res;\n    float di = distance(uv, p);\n    res.x =  di <= .3333 ? sqrt(1. - di*3.) : 0.;\n    res.yz = p;\n    res.y /= (iResolution.x / iResolution.y);\n    res.yz = (res.yz+1.)*.5;\n    return res;}\n\n#define SS blur/min(iResolution.x,iResolution.y)\n\nfloat circle( vec2 p, float r){\n return smoothstep(SS,-SS,length(p)-r);\n return step(length(p)-r,.0);\n    return length(p) < r ? 1. : 0.;//why would you do that?\n}\n\n\n//[buffA of https://www.shadertoy.com/view/4dyXWy ], merged into [Image]\nvec4 BA(in vec2 uv ){  \n    //This buffer calculates occluders and a gaussian glowing blob.\n    //Just see what it returns for any uv input.\n    //It makes sense to buffer this as a matrix (low res 2d frame buffer)\n    // ,because it is being looked up multiple times\n    // With different offsets.\n    //  This is NOT doing that, for no good reason at all \n    //   other than brute force benchmaking a bufferless approach\n    uv=uv*2.-1.;\n    float aspect = iResolution.x / iResolution.y;\n   uv.x *= aspect;\n    vec2 m=iMouse.xy;\n    if(m.x<=0.)m=vec2(iResolution*.1);else m=(m/iResolution.xy)*2.-1.;//set mouse position\n    m.x *= aspect;\n    //above framing is not pretty. but thats not what is demoed here.\n    \n    float occluders=circle(uv-vec2(-.66,0), .366)-circle(uv+vec2(.75,.1),.18);\n    occluders+=circle(uv-vec2(.6,.2),.23);\n    float mouse=smoothstep(SS,-SS,abs(abs(length(uv-m)-.2)-.05)-.02);//double ring\n    //mouse cursor has an occluding crosshair:\n    float mouse2=smoothstep(SS,-SS,abs(uv.x-m.x)-.03);//vertical bar\n          mouse=max(mouse,mouse2);//union\n    //mouse=clamp((mouse-length(uv-m)*2.),.0,1.);//alpha-shade crosshair\n    \n    //transparent disk on the right\n    mouse2=smoothstep(SS,-SS,length(uv-m-vec2(.5,0))-.2);\n    mouse=max(mouse,mouse2*.5);//union\n        \n  // mouse=max(mouse,.0);//optical illusion checker!\n    occluders+=mouse;//-=mouse and you have a \"nightmare moon spitlight\"\n    occluders = min(occluders, 1.);\n    vec3 light=min(sun(uv),1.);\n    float col = max(light.x - occluders, 0.);\n    return vec4(col,occluders,light.yz); //Gross hack to pass light pos as B and A values\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 coord = uv;\n    vec4 ic=BA(uv);\n    vec2 lightpos = ic.zw;   \t\n    float occ = ic.x; //light\n    float obj = ic.y; //objects\n    float dither = iib(fragCoord);\n    vec2 dtc = (coord - lightpos)*(1./float(SAMPLES)*DENSITY);\n    float illumdecay = 1.;\n    \n    for(int i=0; i<SAMPLES; i++)    {\n        coord -= dtc;\n        #ifdef DITHER\n        \tfloat s = BA(coord+(dtc*dither)).x;\n        #else\n            float s = BA(coord).x  ;     \n        #endif\n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n        \n\tfragColor = vec4(vec3(.5,.7,.1)*obj/3.+occ*EXPOSURE,1.0);\n}\n\n\n/*\n//return 16x16 Bayer matrix, without bitwiseOP, most compatible!\n//likely best for old mobile hardware, likely most energy efficient.\n//slowest (kept small for small resolutions)\nfloat B16( vec2 _P ) {\n    vec2    P1 = mod( _P, 2.0 );                    // (P >> 0) & 1\n    vec2    P2 = floor( 0.5 * mod( _P, 4.0 ) );        // (P >> 1) & 1\n    vec2    P4 = floor( 0.25 * mod( _P, 8.0 ) );    // (P >> 2) & 1\n    vec2    P8 = floor( 0.125 * mod( _P, 16.0 ) );    // (P >> 3) & 1\n    return 4.0*(4.0*(4.0*B2(P1) + B2(P2)) + B2(P4)) + B2(P8);\n}//https://www.shadertoy.com/view/4tVSDm\n*/\n\n/*\n//A 64x64 bayer matrix LUT. FAST, static size.\n//best for non-mobile hardware, least energy efficient.\nvoid populatePatternTable(){    \n    pattern[0x00]=   0.; pattern[0x01]= 32.; pattern[0x02]=  8.; pattern[0x03]= 40.; pattern[0x04]=  2.; pattern[0x05]= 34.; pattern[0x06]= 10.; pattern[0x07]= 42.;   \n    pattern[0x08]=  48.; pattern[0x09]= 16.; pattern[0x0a]= 56.; pattern[0x0b]= 24.; pattern[0x0c]= 50.; pattern[0x0d]= 18.; pattern[0x0e]= 58.; pattern[0x0f]= 26.;  \n    pattern[0x10]=  12.; pattern[0x11]= 44.; pattern[0x12]=  4.; pattern[0x13]= 36.; pattern[0x14]= 14.; pattern[0x15]= 46.; pattern[0x16]=  6.; pattern[0x17]= 38.;   \n    pattern[0x10]=  60.; pattern[0x19]= 28.; pattern[0x1a]= 52.; pattern[0x1b]= 20.; pattern[0x1c]= 62.; pattern[0x1d]= 30.; pattern[0x1e]= 54.; pattern[0x1f]= 22.;  \n    pattern[0x20]=   3.; pattern[0x21]= 35.; pattern[0x22]= 11.; pattern[0x23]= 43.; pattern[0x24]=  1.; pattern[0x25]= 33.; pattern[0x26]=  9.; pattern[0x27]= 41.;   \n    pattern[0x20]=  51.; pattern[0x29]= 19.; pattern[0x2a]= 59.; pattern[0x2b]= 27.; pattern[0x2c]= 49.; pattern[0x2d]= 17.; pattern[0x2e]= 57.; pattern[0x2f]= 25.;\n    pattern[0x30]=  15.; pattern[0x31]= 47.; pattern[0x32]=  7.; pattern[0x33]= 39.; pattern[0x34]= 13.; pattern[0x35]= 45.; pattern[0x36]=  5.; pattern[0x37]= 37.;\n    pattern[0x30]=  63.; pattern[0x39]= 31.; pattern[0x3a]= 55.; pattern[0x3b]= 23.; pattern[0x3c]= 61.; pattern[0x3d]= 29.; pattern[0x3e]= 53.; pattern[0x3f]= 21.;\n}//www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT\n//https://www.shadertoy.com/view/MlByzh\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}