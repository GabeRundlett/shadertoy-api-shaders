{
    "Shader": {
        "info": {
            "date": "1501882212",
            "description": "mouse.y sets size of left round bracket\nif(m.y>0) +balloon, is only a subroutine.\n\nmouse.x mixes (\"round sans-serif\", \"90deg sans-serif\")\nm.x=max(m.x,0.); //or else distance gets overestimated.\n\nsans serif, rounded and 90deg cut still make a difference.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsBBWG",
            "likes": 0,
            "name": "left bracket balloon",
            "published": 3,
            "tags": [
                "glyph",
                "sawcos",
                "bracket"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 550
        },
        "renderpass": [
            {
                "code": "//Balloon shape without atan(), dot()/dot() or dot(a,normalize(n)),\n//only rotating points by fullRotation*N/24\n//the only reason i dislike dot()/dot() here is its potential division by 0.\n//but i think i may come to terms with that differently soon.\n\n/*\nthe principle:\n- utilize\n- - https://en.wikipedia.org/wiki/List_of_planar_symmetry_groups\n- - In a quest to increase symmetry for performance and modular shaders.\n- instead of writing a general function, \n- ...to be fed with a lot of parameters set to 0 or 1 to turn them into \"special cases\"\n- ... only write atomic special cases and transformations, \n- ... to construct general functions from.\n- this way general functions can be made into special \"shortcut\" functions more easily.\n- this way special functions can more easily be extended, generalized.\n...\n- Substitute functions with identities to reveal their underlying bisymmetries.\n- - substitute max() to if()then() to mix(step)) to mix(sign()) to sums of sign()\n- - - for details on identities see - https://www.shadertoy.com/view/ldBfzc\n- - because there is often a lot of symmetry performance \"lost\" in if-branches, or max()=-min(-)\n- End up precalculating the specifics of a function, \n- Get a sum that you can easily modify \n- Modify underliing partial simple bisymmetries of the functions \"specifics\"\n- Bisymmetry turns out to be mostly about (mutually exclusive matrices of) Binimials.\n- Using only fullRotation*N/24 , makes it more likely that terms cancel each other out.\n- if (symmetry) 2 symmetric subroutine-values tend to cancel factors out, \n- ... down to abs(a)*abs(a)=1.\n- Your function(s) turns into a \"family of bisymmetrical functions\" \n- ... that are more easily generalized or specialized.\n- ... that are more easily made work-save against undefineds like: \n- ... a=atan(0.,0.)*tan(acos(.0))*log2(0.)*pow(0,0)*a/0.\n\n------------\n\n[envelope]s and [window function]s and [Passband]s are pretty much mean the same to me now.\ni just lack a noun for min||max([window function],[envelope]) that is not [MoDem] or [context]\nhttps://en.wikipedia.org/wiki/Context_(computing)\nhttps://en.wikipedia.org/wiki/Modulation\nFor a lack of a better term, the terms I use are knowinggly fuzzy.\n\nthey come down to y=f(x) that often are only, or especially \n...focused on (inout) ranges [-.5..+.5] to [-3.14..+3.14]\n...while their parameters (like uv or scaling) are any range.\n\n[window function]s \n- tend to have smoother derivatives, nicer Local Lipschitz Constants. they include \n- https://en.wikipedia.org/wiki/Window_function\n[envelope]s tend to be more symmetric and opften less less continuous. they include \n- https://en.wikipedia.org/wiki/Envelope_(waves)\n- where continuity is easily broken due to Fourier Transform (of a square,triangle,seesaw wave)\n-\n- means envelopeD(log(envelopeE())), for lack of a better term.\n- ... where envelopeA()=envelopeB(envelopeC())\n- does not mean \n- https://en.wikipedia.org/wiki/Envelope_(mathematics)\n*/\n\n/*\nnotes to self, for improvement:\nuse #define to take a domain (x,y, z or w) as function parameter \nyour #define basically defines patterns over single domains, \nand their context lies on how these \n#defines are utilized min() mic() smin() swiveled or otherwise transformed.\n\n\nthe comments of\nhttps://www.shadertoy.com/view/MdSfzt\nare all about \n- line breaks in a define\n- using a buffer texxture and a single define to display a string.\nthis is a current process...\n*/\n\n//sharpness of FullScreenAntiAliasing\n#define fsaa 5./iResolution.y\n//maximum view zoom\n#define viewZoom 9.\n\n//3.14=ratio of unitCircleCircumference to diameter=\n#define pi acos(-1.)\n//0.61=golden ratio; phi-1=1/phi,smaller solution\n#define phi (sqrt(5.)*.5-.5)\n//1.61=Golden Ratio; Phi-1=1/Phi,larger  solution\n#define Phi (sqrt(5.)*.5+.5)\n\n//squareroots for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nconst vec4 s2=sqrt(vec4(2,3,5,6));//s6=sqrt(vec4(7,10,11,12));//arrays and matrices are too bulky here.\n\n//modulo tiled grid.\nfloat grid(vec2 u){u=abs(fract(u)-.5);\n u.x=max(max(u.x,u.y),1./8.);u.x=u.x*8.-3.;\n u.x=fract(u.x)/(4.-(floor(u.x+3.)));                   \n u.x*=u.x;return u.x*u.x;}\n\nfloat sawCos(vec2 u){//u*=2.;//sale here, or better outside of this function.\n u.x=fract(u.x);u+=(1.- 2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0., 1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c) with a hint of s, diminishing over c.\n#define sci() mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//use a matrix as if it is a list.\nfloat gm3(mat3 a,int n){return a[n/3][n%3];}\n//return a[int(n/3.)][int(mod(n,3.))];}//float variant\n#define gp(a) gm3(co,a)\n\n\n//m.y sets zoom (makes sense for waveforms)\n//length sets zoom\n//#define scaledot(u) length(m)*u\n//length*length sets zoom, for EXTREME zoom out\n//#define scaledot(u) dot(m,m)*u\n//near main axes, zoom in\n//#define scaledot(u) min(abs(m.x),abs(m.y)   )*u\n//mix of axial distances sets zoom\n//#define scaledot(u) mix(abs(m.x),abs(m.y),.5)*u\n#define scaledot(u) u=min(abs(m.x),abs(m.y))*u\n\n//#define stretch(c,m) v=mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch      ; centric, most commonly used, therefore atomic\n#define mStretch(u,m) .5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus; positive values do not change\n#define mStretchM(u,m) mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u= u+m;return  mStretch(u,m);}\n//stretch plus ; negative values do not change\n#define mStretchP(u,m) mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m) mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n\n//return distance to infinite line segment\n//float ils(vec2 u,vec4 m){if(0.<u.x)return u.y;return length(u);}\n//is not too useful for this shape, just a bit too dirty.\n\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u, vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n//pseudo ellipse, made of 2 circles.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))\n                                 +length(vec2(abs(u.x-1.),u.y));}\n\n/*\n//return distance to (barely more than a) half-donut, bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);   \n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n //if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1)\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y));\n return abs(a-.5*(1.+sign(u.y)));}\n//https://www.shadertoy.com/view/ldSBR3\n\n//return distance to cube, rotated by sqrt(2)*.5\nfloat rotCube3(vec2 u,vec4 m){\n vec2 v=sqrt(vec2(1,3))*.5;    \n float c=abs(dot(vec2(u.x, u.y),v)); \n float d=abs(dot(vec2(u.x,-u.y),v.yx));\n return max(c,d);//return .5*(sign(a-b)*(a-b)+b+a);\n}\n\n/*\n//return distance to cube, rotated by sqrt(2)*.5\nfloat rotCube3s(vec2 u,vec4 m,vec2 v){u=vec2(-u.x,u.y)-v*m.x;\n float c=abs(dot(vec2(u.x, u.y),v));float d=abs(dot(vec2(u.x,-u.y),v.yx));\n return max(c,d);}//return .5*(sign(a-b)*(a-b)+b+a);}\n*/\n\n//bracked with 90deg ends\nfloat bracketN(vec2 u,vec4 m){\n m.x=abs(m.x);u.y=abs(u.y);\n vec2 v=sqrt(vec2(1,3))*.5;\n if(0.>dot(u,v.yx))return abs(length(u)-m.x);//bracket\n else{u=vec2(-u.x,u.y)-v*m.x;vec2 e=abs(vec2(dot(vec2(u.x, u.y),v),dot(vec2(u.x,-u.y),v.yx)));\n  return max(e.x,e.y);}}//with 90deg corners\nfloat bracketCn(vec2 u,vec4 m){//scaling wrapper for bracketN()\n    m.x=abs(m.y)/sqrt(3.);u.x=u.x-m.x*.5;u.y=u.y+sqrt(3.)*.5*m.x;return bracketN(u,m);}\n\n//bracked with rounded ends\nfloat bracketR(vec2 u,vec4 m){m.x=abs(m.x);u.y=abs(u.y);\n vec2 v=sqrt(vec2(1,3))*.5;float b=dot(u,v);\n if(0.>dot(u,v.yx))return abs(length(u)-m.x);//bracket\n return length(vec2(-u.x,u.y)-v*m.x);}//with rounded corners\nfloat bracketCr(vec2 u,vec4 m){//scaling wrapper for bracketR()\n    m.x=abs(m.y)/sqrt(3.);u.x=u.x-m.x*.5;u.y=u.y+sqrt(3.)*.5*m.x;return bracketR(u,m);}\n\n//fake ellipse that is 2 circles, faster and better distance field.\nfloat ellipseFake(vec2 u,vec4 m){\n u=abs(u);\n  if (u.y-sqrt(2.)+.5>u.x){   \n   u.y=mStretch(u.y,1.);\n   return length(u)-1.;\n }return  length(u+vec2(1,0))-1.-sqrt(2.);\n}\nfloat ribbon1(vec2 u,vec4 m){\n u.x=abs(u.x);\n float b=dot(u,-sqrt(vec2(1,3))*.5);\n float a=length(u);\n return max(abs(a-1.)-.1,b);\n}\n\nfloat balloon(vec2 u,vec4 m){\n //return rotCube3(u,m);\n //return bracketC(u,m);\n float b=ellipseFake(u-vec2(0.,2),m);\n float a=ribbon1(vec2(0,-3)-u,m);\n return min(a,b);\n}\n\n/*\n//return distance to sideways.horse-silhouette, optimized for speed.\nfloat silHorse(vec2 u,vec4 m){\n //u-=m.xy;//move by m.xy\n float t=length(halfWorm11(vec2(-u.x-2.5,u.y-4.)))+.5;//tail\n float r=length(vec2(-1.5-u.x,mStretchP(u.y,4. )))+.5;\n float l=length(vec2( 1.5-u.x,mStretchP(u.y,7.5)))+.5;//front\n u.y-=3.5;\n vec2 n=vec2(2.25-u.x,u.y-2.5);\n float h=length(n)-.5;//head\n    n+=vec2(1.3,.7);\n h=min(h,length(n)+.3);\n u.x=mStretch(u.x,1.1);\n float b=length(u)-.2;\n //h=length();\n //vec2 v=abs(u-vec2(.5));\n //return b;\n return min(min(min(h,b),min(l,r)),t);\n return ellipseCheap(u)-1.5;\n return length(u);\n}*/\n\nfloat sum(vec2 a){return a.x+a.y;}\n/*\n//lookup table for https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nvec2 getRealRadical(int a){int b=(a/4)*2;a%=4;\n const mat4 r=mat4(.5*vec4(2,0,1,s2.y),.25*vec4(s2.w+s2.x,s2.w-s2.x,s2.w-s2.x,s2.w+s2.x),\n .5*vec4(s2.y,1,0,2),.5*s2.x*vec4(1,1,0,0));return vec2(r[a][b],r[a][b+1]);}\n\n//return distance to 1/24th rotated axis\nfloat r12(vec2 u){\n //const float s2=sqrt(2.), s6=sqrt(6.);\n //extreme unpoinry: return dot(u,vec2(s6+s2,s6-s2)*.25)\n //might as well just do a look up table matrix over one quater.\n return dot(u.yx,vec2(sum(s2.xw),s2.w-s2.x)*.25);}\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n\nfloat arrow(vec2 u,vec4 m){\n u.y*=sign(u.y);\n //if(u.y>m.x) return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n m.z*=.25;\n m.zw=abs(m.zw);\n //vec2 d=vec2(1,-sqrt(2.))*.5; //12th rotation\n float a=r12(u)-m.z;            //24th rotation\n a=max(a,-u.x);\n u.x=-mStretchM(u.x,m.x);u.y=-mStretchM(u.y,m.y);\n return min(a,length(u)-m.w);}//https://www.shadertoy.com/view/XsBBRd\n\n//glyph \"2\", acrually just 24th rotations, i got tired and halted that project early.\n//project is to get a FAST distance field to \"letter 2\" by rotating halfWorm11()\nfloat g2(vec2 u,vec4 m){\n int t=int(iTime*3.);  \n if(t%24>11){u=-u;}//180deg rotation\n if(t%12>5 ){u=vec2(u.y,-u.x);}//90deg rotation\n t=t%6;//resolve quadrant\n float a=abs(length(u)-1.)-.01;\n vec2 b=getRealRadical(t);\n float c=length(u-b)-.1;\n float d=dot(u,b);\n a=min(a,min(c,d));\n return a;}//https://www.shadertoy.com/view/ldBBRt\n*/\n\n//https://en.wikipedia.org/wiki/Dihedral_group_of_order_6\n//is intentionally bloaty/duped, makes it easier to remove symmetry where it is not needed.\n#define borderW .4\nfloat pmaa(vec2 u,vec4 m){\n //#if (borderW==0.)\n  return min(length(u-m.xy),abs(u.x)+borderW);//show dots and pattern bisymmetry borders.\n// #else\n //  return length(u-m.xy);//show just the dots\n// #endif\n}float d6m(vec2 u,vec4 m){\n m.x=abs(m.x);u.x=abs(u.x);float b=0.;\n //#if (0.==borderW)\n b=abs(u.x)+borderW;//adds upper vertical border.\n //#endif\n float s=sqrt(3.);\n u=u*(mat2(1,s,-s,1)*.5);\n m.xy=m.xy*(mat2(1,s,-s,1)*.5);\n u.x=abs(u.x);m.x=abs(m.x);\n float a=pmaa(u,m);\n u=u*(mat2(1,s,-s,1)*.5);\n m.xy=m.xy*(mat2(1,s,-s,1)*.5);\n u.x=abs(u.x);m.x=abs(m.x);\n float c=pmaa(u,m);\n //return min(a,b)-.1;\n return min(min(a,c),b)-.5;\n //return a-.01;    \n;}\n\n\n//some mouse cursor code, shading the same color space, inverting\nfloat mouseNeg(float c,float m){return sign(c)*min(m,abs(c));}\n//mix c and m where m is a disturbing distance field [m]  as \"mouse pointer\" in field [c]\nfloat mouseDif(float c,float m){//return sign(c)*max(-sign(c)*c,m);//alternative to below\n //return min(c*sign(m),m);//shorter variant of below\n float s=sign(m)*c;m-=s;return s+.5*(m-abs(m));}\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\nvoid mainImage(out vec4 oo, in vec2 u){//calculate color for fragment\n vec4 m=vec4(fr(iMouse.xy),fr(iMouse.zw));u=fr(u);//put vec2(0) in the center of the view, adjust for aspect ratio.\n/*\n m.w=abs(m.w*.5);//scaling mouse input for this one\n if(iMouse.z<0.)/(idling mouse\n m=vec4(sin(iTime*acos(0.))*2.+2.//length.x of handle\n       ,cos(iTime)            +1.//length.y of handle\n       ,sin(iTime)            +4.//size of the tip\n       ,cos(iTime*.61)*.2     +.2//roundness of handle\n       )*3.;\n/**/\n//   else m=fr(iMouse.xy);\n //scaledot(u);scaledot(m);//scale view, depending on m\n //u+=m;m+=m;//move view center away from vec2(0)\n vec3 c;//color composition\n    \n //m.x=clamp(m.x,0.,1.);\n m.x=max(m.x,0.);\n float a=bracketCn(u,m)-.1;\n float b=bracketCr(u,m)-.1;\n //c.r=a;\n c.r=mix(a,b,m.x);\n  if(m.y>0.){\n        c.r=min(c.r,balloon(u,m));\n }\n //c.r=silHorse(u,m)-1.;//distance field to horse shape.\n //c.r=d6m(u,m); //distance to d6m(mouse), 3*mirror symmetry (for hexagons).\n\n //c.r=g2(u,m);//distance to point and plane, rotated by fullRotation*n/24\n //c.r=circleStretch(u,m);//distance field at u, set by parameters m (complicated)\n float d=sin(iTime)*.5+.5;\n float mo=length(u-m.zw);//distance to mouse cursor (for more dynamic fields)\n //float e=length(u-m.zw)-1.;//distance to where mouse was pushed down\n //c.r=min(c.r,e);    \n      \n //c.r=mouseDif(c.r,mo);\n //c.r=mouseNeg(c.r,mo);\n //c.r=mouseDif(mouseNeg(c.r,mo),mo);\n //c.r=mouseNeg(mouseDif(c.r,mo),mo);\n //c.r=mix(mouseDif(c.r,mo),mouseNeg(c.r,mo),.5);\n c.bg=u;//making x-axis green comes naturally\n c=sawCos3(c,.9);//smoothest gradient visualization so far\n c.gb+=vec2(sawCos(length(u),.5)*.003);//show circles around (0,0)\n \n //the color mix below usually looks nice, \n //but hues cyclically bleed into another, causing some optical illusions if one domain is very low\n //it also means if any domain is NaN, it becomes 0.\n if(isnan(c.r))c.r=0.;//projecting NaN to 0.\n if(isnan(c.b))c.b=0.;//projecting NaN to 0.\n if(isnan(c.g))c.g=0.;//projecting NaN to 0.\n c=sqrt(c);//more evenly gamma correcting\n c=max(vec3(0),c);\n oo=vec4( c*.5+c.yzx*.25,0);}\n//#define mainImage(o,u)o=vec4(co(u),1.);\n\n//vector dotproduct with vecN(1) is a faster sum.\n//float sum(float a,float b,float c,float d){return dot(vec4(a,b,c,d),vec4(1.));}\n//float sum(float a,float b,float c){return dot(vec3(a,b,c),vec3(1.));}\n\n/*\n//just some demo y=f(x) functions\nfloat fx(vec2 u,vec2 m){\n float x=u.x;\n float logE = log(x);\n float expE = exp(x);\n float pow3 = (x*1.)*(x*x);\n float pow4 = (x*x )*(x*x);\n mat3 co=mat3(-10,8,-6,5,-6,4,-7,-2,1);//9 coeficients to a polynomial should be enough\n //co=1.co; //reciprocal coeficcients\n //co*=.1;//smaller coefficients\n //float polyn=x*gm3(co,0)-u.y;\n   \n float polyn=x*(gp(0)+x*(x*(gp(1)+x*(x*(gp(2)+x*(x*(gp(3)+x*gp(4)+x*(gp(5)))))))));\n float cosine=cos(x*.1)*10.;//a large amplitude large interval cosine.\n x*=.1;\n float fourier=cos(x*gp(0))\n              +cos(x*gp(1)*2.)\n              +cos(x*gp(2)*3.)\n              +cos(x*gp(3)*5.)\n              +cos(x*gp(4)*7.)\n              +cos(x*gp(5)*13.);//cosines, scaled by primes.\n    \n //return fourier;\n \n //return cosine;\n //return logE; //makes negative blue green, i see no way to cath this NaN\n return fourier+cosine+x*x;\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}