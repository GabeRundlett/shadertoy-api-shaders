{
    "Shader": {
        "info": {
            "date": "1511467214",
            "description": "Buf B feedback loop seeded by Soundcloud Beat Analyzer in Buf A: https://www.shadertoy.com/view/MtXyzS\nswitched the blue to alpha in Buf B and added multilayer reaction-diffusion\nsource in Buf D: https://soundcloud.com/charles-thefirst/work-while-you-talk",
            "flags": 96,
            "hasliked": 0,
            "id": "4llBRM",
            "likes": 27,
            "name": "Bipolar Feedback",
            "published": 3,
            "tags": [
                "milkdrop",
                "turingpattern",
                "bipolar"
            ],
            "usePreview": 1,
            "username": "Flexi",
            "viewed": 4667
        },
        "renderpass": [
            {
                "code": "#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel1, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurSpectrogram(vec2 uv, int level)\n{\n    uv = upper_right(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nfloat border(vec2 domain, float thickness){\n    vec2 uv = fract(domain-vec2(0.5));\n    uv = min(uv,1.-uv)*2.;\n    return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\nvec2 rot90(vec2 uv){\n    return uv.yx*vec2(1,-1);\n}\n\nvec2 wrap_flip(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 mobius(vec2 domain, vec2 zero_pos, vec2 asymptote_pos){\n\treturn complex_div( domain - zero_pos, domain - asymptote_pos);\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad = length(c);\n   float ang = atan(c.y, c.x);\n   return vec2(ang * pi2_inv, rad);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, float fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center);\n   return vec2(polar.x * fins + coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_bipolar(vec2 domain, vec2 northPole, vec2 southPole, float fins, float log_factor, vec2 coord){\n   vec2 help_uv = mobius(domain, northPole, southPole);\n   return uv_polar_logarithmic(help_uv, vec2(0.5), fins, log_factor, coord);\n}\n\nfloat unit_square(vec2 uv){\n\treturn float((uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.));\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat knob(vec2 domain, vec2 aspect, float innerRadius, float outerRadius, float angle){\n    float knob =  sigmoid((circle(domain, aspect, 2./outerRadius) - circle(domain, aspect, 2./innerRadius))/(outerRadius-innerRadius));\n    knob = mix(knob, 1., circle(domain + vec2(sin(angle), cos(angle))*0.4*aspect.yx, aspect, 8./outerRadius));\n    return knob;\n}\n\nfloat spectrum(float domain, int t, int level)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*2./sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv).x;\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level)\n{\n    float val = spectrum(uv.x, 0, level);\n    return (abs(uv.y - val) < thickness/2.) ? (1.-abs(uv.y - val)*2./thickness) : 0.;\n}\n\nvec4 rainbowSpectra(vec2 uv)\n{\n    float thickness = 0.015;\n    vec4 spectra =         vec4(0.25,0,0.5,0)* spectrum2D(uv, thickness, 7);\n    spectra = mix(spectra, vec4(0.5,0,1.,0), spectrum2D(uv, thickness, 6));\n    spectra = mix(spectra, vec4(0,0.5,1,0), spectrum2D(uv, thickness, 5));\n    spectra = mix(spectra, vec4(0,1.,0.5,0), spectrum2D(uv, thickness, 4));\n    spectra = mix(spectra, vec4(1,1,0,0), spectrum2D(uv, thickness, 3));\n    spectra = mix(spectra, vec4(0.6,0.25,0,0), spectrum2D(uv, thickness, 2));\n    spectra = mix(spectra, vec4(0.85,0,0,0), spectrum2D(uv, thickness, 1));\n    spectra = mix(spectra, vec4(1), spectrum2D(uv, thickness, 0));\n    \n    return spectra*unit_square(uv);\n}\n\nfloat bass(){\n    return spectrum(0.125, 0, 4);\n}\n\nfloat mid(){\n    return spectrum(0.5, 0, 4);\n}\n\nfloat treb(){\n    return spectrum(0.875, 0, 4);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    return texture(iChannel3, center);\n}\n\n// <copypasta src=\"https://www.shadertoy.com/view/ltlyRM\">\n\n//from https://stackoverflow.com/questions/35799286\nfloat toLog(float value, float min, float max){\n\tfloat exp = (value-min) / (max-min);\n\treturn min * pow(max/min, exp);\n}\n\nfloat getLevel(float samplePos){\n    // the sound texture is 512x2\n\tint tx = int(samplePos*512.0);\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\treturn texelFetch( iChannel1, ivec2(tx,0), 0 ).x; \n}\n\n// </copypasta>\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec4 prevA = BlurA(uv, 0);\n    vec4 prevB = BlurB(uv, 0);\n    \n    fragColor = vec4(0);\n/*\n    fragColor =  mix(fragColor, vec4(0.1), spectrum2D(uv, 0.05, 0));\n    fragColor =  mix(fragColor, vec4(0.2), spectrum2D(uv, 0.04, 1));\n    fragColor =  mix(fragColor, vec4(0.3), spectrum2D(uv, 0.03, 2));\n    fragColor =  mix(fragColor, vec4(0.6), spectrum2D(uv, 0.02, 3));\n    fragColor =  mix(fragColor, vec4(0.9), spectrum2D(uv, 0.01, 4));\n*/\n\n    vec4 rnd0 = Cell(10);\n    vec4 rnd1 = Cell(11);\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\tvec4 beat_residual = Cell(4);\n    \n    float beat_relative = (beat_residual.w - last_beat_min.w)/(last_beat_max.w - last_beat_min.w);\n\n    float c1 = smoothcircle(uv - aspect.yx*0.5 + rnd1.xy*aspect.yx, aspect, 0.03, 600.);\n    float c2 = smoothcircle(uv - aspect.yx*0.5 + rnd0.xy*aspect.yx, aspect, 0.015, 800.);\n    float c3 = smoothcircle(uv - aspect.yx*0.5 + mix(rnd0.xy, rnd1.xy, beat_relative)*aspect.yx, aspect, 0.005, 1400.);\n    \n    float bassBox = unit_square(0.5 + (uv-vec2(0.125, bass())) * 32. * aspect);\n    float midBox = unit_square(0.5 + (uv-vec2(0.5, mid())) * 32. * aspect);\n    float trebBox = unit_square(0.5 + (uv-vec2(0.875, treb())) * 32. * aspect);\n    /*\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bass_box);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), mid_box);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), treb_box);\n    */\n    vec4 integratedVolume = Cell(12);\n\n    bassBox = unit_square(0.5 + (uv-vec2(0.125, integratedVolume.x)) * 64. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, integratedVolume.y)) * 64. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.875, integratedVolume.z)) * 64. * aspect);\n  \n    vec4 normalizedVolume = Cell(13)*0.2 + 0.75;\n    vec4 fader = Cell(14)*8.;\n    \n    float bassFader = knob(0.5 + (uv-vec2(0.25,0.75))*5., aspect, 0.42, 0.5, fader.x);\n    float midFader = knob(0.5 + (uv-vec2(0.5,0.75))*5., aspect, 0.42, 0.5, fader.y);\n    float trebFader = knob(0.5 + (uv-vec2(0.75,0.75))*5., aspect, 0.42, 0.5, fader.z);\n    \n    float speed = 0.0225;\n    vec2 rotate_uv = rotozoom(uv, -2.*fader.y*speed, 1., aspect);\n\tvec2 bipolar_uv = uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed);\n\tbipolar_uv = wrap_flip(bipolar_uv);\n\n    int n = 1; // #inception\n    \n    for(int i = 1; i < n; i++){\n    \trotate_uv = rotozoom(bipolar_uv, fader.y*speed, 1., vec2(1));\n\t\tbipolar_uv = uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed);\n\t\tbipolar_uv = wrap_flip(bipolar_uv);\n    }\n    \n    vec4 aComplex = BlurA(bipolar_uv, 0);\n    fragColor = mix(fragColor, vec4(1), aComplex);\n\n    vec4 bComplex = BlurB(bipolar_uv, 0);\n\n    fragColor =  mix(fragColor, vec4(1,1,1,0), bComplex.b);\n    fragColor =  mix(fragColor, vec4(0,0,1,0), BlurB(uv, 0).a);\n    fragColor =  mix(fragColor, vec4(1), bComplex);\n    \n    fragColor =  mix(fragColor, vec4(1), c1);\n    fragColor =  mix(fragColor, vec4(1), c2);\n    fragColor =  mix(fragColor, vec4(1), c3);\n    \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n    \n    bassBox = unit_square(0.5 + (uv-vec2(0.25, normalizedVolume.x)) * 128. * aspect);\n    midBox = unit_square(0.5 + (uv-vec2(0.5, normalizedVolume.y)) * 128. * aspect);\n    trebBox = unit_square(0.5 + (uv-vec2(0.75, normalizedVolume.z)) * 128. * aspect);\n\n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassBox);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midBox);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebBox);\n  \n    fragColor =  mix(fragColor, vec4(1.,0.,0,0), bassFader);\n    fragColor =  mix(fragColor, vec4(0.,1.,0,0), midFader);\n    fragColor =  mix(fragColor, vec4(0.,0.,1,0), trebFader);\n    \n\tfragColor =  mix(fragColor, vec4(0,0,1,0), bComplex.a);\n    \n    fragColor = mix(fragColor, vec4(1), rainbowSpectra(uv) * beat_relative);\n\n    // beatdetect development view:\n    fragColor =  mix(fragColor, vec4(1), BlurA(uv, 0));\n\n    // bipolar feedback development view:\n    fragColor =  mix(fragColor, vec4(1.), BlurB(uv, 0)*vec4(1,1,0,0));\n    fragColor =  mix(fragColor, vec4(1.), BlurB(uv, 0).b);\n    \n    // blur level stack\n\t//fragColor =  mix(fragColor, vec4(1), texture(iChannel3, uv));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec2 wrap_flip(vec2 uv){\n    return vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = texture(iChannel3, vec2(7.5 * eighth, 3.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    uv = wrap_flip(uv);\n    \n    if(level <= 0)\n    {\n        return texture(iChannel0, uv);\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nfloat border(vec2 domain, float thickness){\n    vec2 uv = fract(domain-vec2(0.5));\n    uv = min(uv,1.-uv)*2.;\n    return clamp(max(uv.x,uv.y)-1.+thickness,0.,1.)/(thickness);\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat unit_square(vec2 uv){\n\treturn float((uv.x < 1.) && (uv.x > 0.) && (uv.y < 1.) && (uv.y > 0.));\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.125;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nfloat spectrum(float domain, int t, int level)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*3.*sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv).y;\n}\n\nfloat spectrum2D(vec2 uv, float thickness, int level)\n{\n    float val = spectrum(uv.x, 0, level);\n    return (abs(uv.y - val) < thickness/2.) ? (1.-abs(uv.y - val)*2./thickness) : 0.;\n}\n\nvec4 rainbowSpectra(vec2 uv)\n{\n    float thickness = 0.015;\n    vec4 spectra =         vec4(0.25,0,0.5,0)* spectrum2D(uv, thickness, 7);\n    spectra = mix(spectra, vec4(0.5,0,1.,0), spectrum2D(uv, thickness, 6));\n    spectra = mix(spectra, vec4(0,0.5,1,0), spectrum2D(uv, thickness, 5));\n    spectra = mix(spectra, vec4(0,1.,0.5,0), spectrum2D(uv, thickness, 4));\n    spectra = mix(spectra, vec4(1,1,0,0), spectrum2D(uv, thickness, 3));\n    spectra = mix(spectra, vec4(0.6,0.25,0,0), spectrum2D(uv, thickness, 2));\n    spectra = mix(spectra, vec4(0.85,0,0,0), spectrum2D(uv, thickness, 1));\n    spectra = mix(spectra, vec4(1), spectrum2D(uv, thickness, 0));\n    \n    return spectra*unit_square(uv);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n    \n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n    \n    return texture(iChannel3, center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_size = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixel_size;\n    vec4 noise = (texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime))-0.5)*2.;\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    fragColor = BlurA( 0.5 + (uv - 0.5)*1. + pixel_size*vec2(8,0) + vec2(0,iTime*0.0), 0)*0.9995 - 0.0/256.;\n    \n    vec4 v0 = Cell(0);\n    vec4 v1 = Cell(1);\n    vec4 v3 = Cell(3);\n    vec2 uv_v0 =vec2(0.95, v0.w);\n    vec2 uv_v3 =vec2(0.95, v3.w*4. + 0.25);\n    vec4 beat_residual = Cell(4);\n    float energy = (v0.w - v1.w);\n    vec2 uv_v1 =vec2(0.95, energy +0.05);\n    if(uv.x >= 0.95 - 1./256.){\n        fragColor.z = Cell(9).x;\n    }\n    fragColor = mix(fragColor, vec4(0,1,0,0), circle(uv - uv_v0+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,0,0,0), circle(uv - uv_v1+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,1,0), circle(uv - uv_v3+0.5, aspect, 256.));\n\n    vec2 uv_v4 =vec2(0.95, beat_residual.w*0.5);\n    fragColor = mix(fragColor, vec4(0,1,1,0), circle(uv - uv_v4+0.5, aspect, 256.));\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n\n    vec2 uv_lo =vec2(0.95, last_beat_min.w*0.5);\n    vec2 uv_hi =vec2(0.95, last_beat_max.w*0.5);\n\n    fragColor = mix(fragColor, vec4(1,0,1,0), circle(uv - uv_lo+0.5, aspect, 256.));\n    fragColor = mix(fragColor, vec4(1,1,0,0), circle(uv - uv_hi+0.5, aspect, 256.));\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel1, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 GradientB(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurB(uv + vec2(1.,0.)*d, level) - 0.5*BlurB(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurB(uv + vec2(0.,1.)*d, level) - 0.5*BlurB(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 wrap_flip(vec2 uv){\n\treturn vec2(1.)-abs(fract(uv*.5)*2.-1.);\n}\n\nvec2 rot90(vec2 vector){\n    return vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 rotozoom(vec2 uv, float ang, float zoom, vec2 aspect){\n    vec2 rot = vec2(cos(ang), sin(ang))*zoom;    \n    return 0.5 + complex_mul((uv - 0.5)*aspect, rot)/aspect;\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nvec2 mobius(vec2 domain, vec2 zero_pos, vec2 asymptote_pos){\n\treturn complex_div( domain - zero_pos, domain - asymptote_pos);\n}\n\nvec2 uv_polar(vec2 domain, vec2 center){\n   vec2 c = domain - center;\n   float rad = length(c);\n   float ang = atan(c.y, c.x);\n   return vec2(ang * pi2_inv, rad);\n}\n\nvec2 uv_polar_logarithmic(vec2 domain, vec2 center, float fins, float log_factor, vec2 coord){\n   vec2 polar = uv_polar(domain, center);\n   return vec2(polar.x * fins + coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nvec2 uv_bipolar(vec2 domain, vec2 northPole, vec2 southPole, float fins, float log_factor, vec2 coord){\n   vec2 help_uv = mobius(domain, northPole, southPole);\n   return uv_polar_logarithmic(help_uv, vec2(0.5), fins, log_factor, coord);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.125;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n    \n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n    \n    return texture(iChannel3, center);\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = Cell(2);\n    vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\tvec4 prev = BlurB(uv, 0);\n    fragColor = prev;\n    \n    if(iFrame<20)\n    {\n        fragColor = noise;\n        return;\n    }\n    \n    uv = 0.5 + (uv - 0.5)*0.999;\n    vec2 pixelSize = 1./iResolution.xy;\n    vec2 mouseV = mouseDelta();\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 uv_vortex = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    float time = float(iFrame)/60.;\n    vec2 warp = vec2(sin(time*0.1 + uv.x*2. +1.) - sin(time*0.214 + uv.y*2. +1.), sin(time*0.168 + uv.x*2. +1.) - sin(time*0.115 +uv.y*2. +1.))*pixelSize*1.5;\n\n    // Bipolar map\n    fragColor = vec4(0);\n    vec4 fader = Cell(14)*8.;\n    \n    float speed = 0.0225;\n    vec2 rotate_uv = rotozoom(uv, -2.*fader.y*speed, 1., aspect);\n\tvec2 bipolar_uv = uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed);\n\tbipolar_uv = wrap_flip(bipolar_uv);\n    \n    int n = 1; // #inception    \n    for(int i = 0; i < n; i++){\n    \trotate_uv = rotozoom(bipolar_uv, fader.y*speed, 1., vec2(1));\n\t\tbipolar_uv = uv_bipolar(0.5 + (rotate_uv-0.5)*2.33*aspect , vec2(0.5,0.), vec2(0.0,0.5), 2., 0.3, fader.xz*speed);\n\t\tbipolar_uv = wrap_flip(bipolar_uv);\n    }\n    \n    vec4 aComplex = BlurA(bipolar_uv, 0);\n    vec4 bComplex = BlurB(bipolar_uv, 0);\n    vec4 bComplex4 = BlurB(bipolar_uv, 2);\n    \n    fragColor.a = max(0.,aComplex.b - aComplex.r - aComplex.g);\n    \n    fragColor = mix(fragColor, vec4(1), BlurB(bipolar_uv, 0)*0.99 - 0.1);\n    \n    // one-component Turing Patterns\n    vec2 uv_r = uv_vortex + GradientB(uv, pixelSize*8., vec4(-48,0,0,0), 2)*pixelSize;\n    float concentration = mix(prev.r,BlurB(uv_r, 1).r,0.1);\n    concentration += dot(((BlurB(uv_r, 1) - BlurB(uv_r, 5))*0.5 + (noise-0.5) * 8./256. - 0.06), vec4(1,0,0,0));\n    concentration = mix(concentration, 1., bComplex.r*0.33);\n    fragColor.r = concentration;\n    \n    vec2 uv_g = vortex_pair_warp(uv_orig, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n    uv_g += GradientB(uv_g, pixelSize*8., vec4(0,8,0,0), 2)*pixelSize;\n\n    float prev_g = BlurB(uv_g, 0).g;\n    fragColor.g = prev_g + dot(((prev_g*vec4(1) - BlurB(uv_g, 1))*12./256. + (noise-0.5) * 8./256. - 2./256.), vec4(0,2,0,0));\n    \n    fragColor.g *=  1.-bComplex.g;\n    \n    //fragColor.b\n    vec2 uv_b = uv_vortex + warp;\n\tfragColor.b = BlurB(uv_b, 0).b;\n    fragColor.b += dot(((prev.b*vec4(1) - BlurB(uv_b, 1))*32./256. + (noise-0.5) * 8./256. - 0./256.), vec4(0,0,1,0));\n    \n    fragColor.b *= 1.- bComplex.b*0.33;\n\n    //fragColor = noise; // reset\n    \n    // scratch that, override everything\n    //fragColor = vec4(0);\n    \n    // fragColor = BlurA(uv, 0);\n    // fragColor = BlurB(uv_orig, 0); // freeze current frame\n    \n    fragColor = clamp(fragColor, 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// resolution reduction and horizontal blur\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.05;\n    sum += texture(iChannel3, uv2) * 0.09;\n    sum += texture(iChannel3, uv3) * 0.12;\n    sum += texture(iChannel3, uv4) * 0.15;\n    sum += texture(iChannel3, uv5) * 0.16;\n    sum += texture(iChannel3, uv6) * 0.15;\n    sum += texture(iChannel3, uv7) * 0.12;\n    sum += texture(iChannel3, uv8) * 0.09;\n    sum += texture(iChannel3, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// bind in iChannel1 misc\n// https://soundcloud.com/charles-thefirst/work-while-you-talk\n// https://soundcloud.com/gradient-audio/05-boofy-wheel-of-dharma\n// https://soundcloud.com/gradient-audio/10-deafblind-omega-strain\n// https://soundcloud.com/gradient-audio/12-b1t-crunch3r-quantum\n// https://soundcloud.com/jadecicada/beefcake?in=jadecicada/sets/byte-evaders\n// https://soundcloud.com/robot-koch/christian-loeffler-mare-robot-koch-remix-1\n// https://soundcloud.com/psbhq/they-gave-me-a-lamp-plaid-remix\n// https://soundcloud.com/earmilk/rumpistol-kosmik-drops\n// https://soundcloud.com/ottsonic/1-ott-one-day-i-wish-to-have-this-kind-of-time\n// https://soundcloud.com/mindex/mindex-dont-be-jazzmental\n// https://soundcloud.com/charles-thefirst/mercy-falls\n// https://soundcloud.com/kllsmth/give-it-away\n// https://soundcloud.com/shamanic-technology/onix-2009-previously-unreleasedremastered\n\n// vertical blur (second pass)\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            uv1 = upper_left(uv1);\n            uv2 = upper_left(uv2);\n            uv3 = upper_left(uv3);\n            uv4 = upper_left(uv4);\n            uv5 = upper_left(uv5);\n            uv6 = upper_left(uv6);\n            uv7 = upper_left(uv7);\n            uv8 = upper_left(uv8);\n            uv9 = upper_left(uv9);\n        }\n        else\n        {\n            uv1 = lower_left(uv1);\n            uv2 = lower_left(uv2);\n            uv3 = lower_left(uv3);\n            uv4 = lower_left(uv4);\n            uv5 = lower_left(uv5);\n            uv6 = lower_left(uv6);\n            uv7 = lower_left(uv7);\n            uv8 = lower_left(uv8);\n            uv9 = lower_left(uv9);\n        }\n    }\n    else\n    {\n        vec2 uv_s = upper_right(uv*2.)*2.;\n        uv1 = clamp(vec2(uv_s.x, uv_s.y - 4.0*v), 0., 1.);\n        uv2 = clamp(vec2(uv_s.x, uv_s.y - 3.0*v), 0., 1.);\n        uv3 = clamp(vec2(uv_s.x, uv_s.y - 2.0*v), 0., 1.);\n        uv4 = clamp(vec2(uv_s.x, uv_s.y - 1.0*v), 0., 1.);\n        uv5 = clamp(vec2(uv_s.x, uv_s.y + 0.0*v), 0., 1.);\n        uv6 = clamp(vec2(uv_s.x, uv_s.y + 1.0*v), 0., 1.);\n        uv7 = clamp(vec2(uv_s.x, uv_s.y + 2.0*v), 0., 1.);\n        uv8 = clamp(vec2(uv_s.x, uv_s.y + 3.0*v), 0., 1.);\n        uv9 = clamp(vec2(uv_s.x, uv_s.y + 4.0*v), 0., 1.);\n        depth--;\n        uv1 = upper_right(uv1);\n        uv2 = upper_right(uv2);\n        uv3 = upper_right(uv3);\n        uv4 = upper_right(uv4);\n        uv5 = upper_right(uv5);\n        uv6 = upper_right(uv6);\n        uv7 = upper_right(uv7);\n        uv8 = upper_right(uv8);\n        uv9 = upper_right(uv9);\n    }\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n    if(uv.x > 0.5 && uv.y > 0.5)\n    {\n        //return vec4(0);\n        sum += texture(iChannel3, uv1) * 0.05;\n        sum += texture(iChannel3, uv2) * 0.09;\n        sum += texture(iChannel3, uv3) * 0.12;\n        sum += texture(iChannel3, uv4) * 0.15;\n        sum += texture(iChannel3, uv5) * 0.16;\n        sum += texture(iChannel3, uv6) * 0.15;\n        sum += texture(iChannel3, uv7) * 0.12;\n        sum += texture(iChannel3, uv8) * 0.09;\n        sum += texture(iChannel3, uv9) * 0.05;\n    }\n    else\n    {\n        sum += texture(iChannel2, uv1) * 0.05;\n        sum += texture(iChannel2, uv2) * 0.09;\n        sum += texture(iChannel2, uv3) * 0.12;\n        sum += texture(iChannel2, uv4) * 0.15;\n        sum += texture(iChannel2, uv5) * 0.16;\n        sum += texture(iChannel2, uv6) * 0.15;\n        sum += texture(iChannel2, uv7) * 0.12;\n        sum += texture(iChannel2, uv8) * 0.09;\n        sum += texture(iChannel2, uv9) * 0.05;\n    }\n    return sum/0.98; // normalize\n}\n\n// sampling from spectrogram\n\nfloat spectrum(float domain, int t, int level)\n{\n    float sixty_fourth = 1./32.;\n    vec2 uv = vec2(float(t)*3.*sixty_fourth + sixty_fourth, domain);\n    uv = upper_right(uv); level++;\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv).y;\n}\n\nfloat bass(int t){\n    return spectrum(0.125, t, 4);\n}\n\nfloat mid(int t){\n    return spectrum(0.5, t, 4);\n}\n\nfloat treb(int t){\n    return spectrum(0.875, t, 4);\n}\n\nvec4 vol(int t){\n    float lo = bass(t);\n    float mi = mid(t);\n    float hi = treb(t);\n    return vec4(lo, mi, hi, (lo + mi + hi)*0.333);\n}\n\n// Buf D contains an N x N array\nfloat N = 32.;\n\n// in the rectangle region between 2 points\nvec2 p1 = vec2(0.75);\nvec2 p2 = vec2(1.);\n\nvec4 Cell(int index)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    return texture(iChannel3, center);\n}\n\nvoid set_cell(inout vec4 bufD, vec2 uv, int index, vec4 value)\n{    \n    // map the index to the cell in the array\n    float x = mod(float(index), N) / N;\n    float y = floor(float(index) / N) / N;\n\n\n    // compartmentalization\n    vec2 cell_size = (p2 - p1) / N;\n    vec2 center = p1 + cell_size*0.5 + (p2-p1)*vec2(x,y);\n\n    // store\n    if(abs(uv - center).x <= cell_size.x*0.5 && abs(uv - center).y <= cell_size.y*0.5)\n    {\n        bufD = value;\n    }\n}\n\n// <copypasta src=\"https://www.shadertoy.com/view/ltlyRM\">\n\n//from https://stackoverflow.com/questions/35799286\nfloat toLog(float value, float min, float max){\n\tfloat exp = (value-min) / (max-min);\n\treturn min * pow(max/min, exp);\n}\n\nfloat getLevel(float samplePos){\n    // the sound texture is 512x2\n\tint tx = int(samplePos*512.0);\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\treturn texelFetch( iChannel1, ivec2(tx,0), 0 ).x; \n}\n\n// </copypasta>\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_size = 1./iResolution.xy;\n    vec2 uv = fragCoord.xy * pixel_size;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }\n        uv_half = fract(uv_orig*2.);\n\n        if(uv_orig.y > 0.5)\n        {\n            if(uv_half.x < pixel_size.x *128.)\n            {\n                fragColor = texture(iChannel1, uv_half.yx);\n                \n                uv = uv_half.yx;\n                \n                // <copypasta src=\"https://www.shadertoy.com/view/ltlyRM\">\n                \n                //crop bottom and top of range\n                uv.x = mix(0.3,0.7, uv.x);\n\n                //logarithmic sampling\n                float xPos = toLog(uv.x, 0.01, 1.0);\n\n                float fft = getLevel(xPos);\n\n                //boost contrast\n                fft = pow(fft,3.0);\n\n                // </copypasta>\n                \n                fragColor.y = fft*1.333;\n            }else{\n                fragColor = texture(iChannel3, uv_orig - vec2(64.,0.) * pixel_size);\n                //fragColor = vec4(0);\n            }\n        }\n    }\n\n    // \n    vec4 v0 = vol(0);\n    vec4 v1 = vol(1);\n\n    set_cell(fragColor, uv, 0, v0);\n    set_cell(fragColor, uv, 1, v1);\n    set_cell(fragColor, uv, 2, vec4(iMouse.xy * pixel_size, iMouse.zw * pixel_size));\n\n    vec4 v2 = vol(2);\n    vec4 attack = v2 + v0 - 2.*v1;\n    set_cell(fragColor, uv, 3, attack);\n\n    vec4 old_beat_residual = Cell(4);\n    vec4 beat_residual = old_beat_residual*0.975 + max(attack*9., 0.);\n    set_cell(fragColor, uv, 4, beat_residual);\n    set_cell(fragColor, uv, 5, old_beat_residual);\n\n    attack = beat_residual - old_beat_residual;\n    set_cell(fragColor, uv, 6, attack );\n\n    vec4 last_beat_min = Cell(7);\n    vec4 last_beat_max = Cell(8);\n    \n    float frames_since_last_beat = Cell(9).y;\n    bool beat = attack.w*last_beat_min.w > 0.25 || ((last_beat_min.w < 0.01) && attack.w > 0.1) || ((frames_since_last_beat > 500.) && attack.w > 0.15);\n    beat = beat && (frames_since_last_beat > 2.);\n    \n    vec4 noise = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy + fract(vec2(42,56)*iTime));\n\n    if(beat)\n    {\n        set_cell(fragColor, uv, 7, old_beat_residual);\n        set_cell(fragColor, uv, 8, beat_residual);\n        set_cell(fragColor, uv, 11, Cell(10));\n        set_cell(fragColor, uv, 10, noise);\n        frames_since_last_beat = 1.;\n    }\n    else\n    {\n        set_cell(fragColor, uv, 7, min(last_beat_min, beat_residual));\n        set_cell(fragColor, uv, 8, max(last_beat_max, beat_residual));\n        set_cell(fragColor, uv, 10, Cell(10));\n        set_cell(fragColor, uv, 11, Cell(11));\n        frames_since_last_beat += 1.;\n    }\n    set_cell(fragColor, uv, 9, vec4(beat, frames_since_last_beat, 0, 0));\n\n    vec4 integratedVolume = Cell(12);\n    set_cell(fragColor, uv, 12, integratedVolume*0.92 + vol(0)*0.1);\n    \n    float volMin = min(integratedVolume.x, min(integratedVolume.y, integratedVolume.z));\n    float volMax = max(integratedVolume.x, max(integratedVolume.y, integratedVolume.z));\n    \n    vec4 normalizedVolume = (integratedVolume - volMin*vec4(1))/(volMax - volMin);\n    if(volMax - volMin != 0.){\n    \tset_cell(fragColor, uv, 13, normalizedVolume);\n        vec4 fader = Cell(14) - (normalizedVolume-0.5)*1.33*iTimeDelta;\n        set_cell(fragColor, uv, 14, fader);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12639,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/charles-thefirst/work-while-you-talk"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}