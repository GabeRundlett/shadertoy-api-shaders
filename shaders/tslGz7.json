{
    "Shader": {
        "info": {
            "date": "1545636262",
            "description": "No simulation or history used, all instant and pure procedural. It's really a remix of [url=https://www.shadertoy.com/view/XdjXWK]Repelling[/url], but doing the collisions in their own pass and adding motion blur.",
            "flags": 32,
            "hasliked": 0,
            "id": "tslGz7",
            "likes": 124,
            "name": "Stateless Fight",
            "published": 3,
            "tags": [
                "3d",
                "collision",
                "spheres"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 8094
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n#if HW_PERFORMANCE==0\n#define AA 2\n#else\n#define AA 3\n#endif\n\n\n\n// https://iquilezles.org/articles/spherefunctions\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// https://iquilezles.org/articles/spherefunctions\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/filterableprocedurals\nfloat linesTextureGradBox( in float p, in float ddx, in float ddy, int id )\n{\n    float N = 12.0;//float( 2 + 7*((id>>1)&3) );\n\n    float w = max(abs(ddx), abs(ddy)) + 0.01;\n    float a = p + 0.5*w;                        \n    float b = p - 0.5*w;           \n    return 1.0 - (floor(a)+min(fract(a)*N,1.0)-\n                  floor(b)-min(fract(b)*N,1.0))/(N*w);\n}\n\n\n//-------------------------------------------------------------------------------------------\n// scene\n//-------------------------------------------------------------------------------------------\nvec4 getSphere( int id, float t )\n{\n    #if AA>1\n    vec4 s1 = texelFetch( iChannel1, ivec2(id,0), 0 );        \n    vec4 s2 = texelFetch( iChannel1, ivec2(id,1), 0 );\n    return mix( s1, s2, t );\n    #else\n    return texelFetch( iChannel1, ivec2(id,0), 0 );\n    #endif\n}\n\n\nfloat occlusion( in vec3 pos, in vec3 nor, in float mb )\n{\n\tfloat res = 1.0;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n    {\n        vec4 sph = getSphere( i, mb );\n\t    res *= 1.0 - sphOcclusion( pos, nor, sph ); \n    }\n    return res;\t\t\t\t\t  \n}\n\nvec3 trace( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in vec3 col, float mb )\n{\n    float tmin = 1e20;\n    \n    vec4 obj = vec4(0.0);\n\tfloat t  = tmin;\n\tint   id = -1;\n\tfor( int i=0; i<NUMSPHERES; i++ )\n\t{\n\t\tvec4 sph = getSphere(i, mb);\n\t    float h = sphIntersect( ro, rd, sph ); \n\t\tif( h>0.0 && h<t ) \n\t\t{\n\t\t\tt  = h;\n\t\t\tid = i;\n            obj = sph;\n\t\t}\n\t}\n\n    // shade\n    if( id!=-1 )\n    {\n\t\tvec3 pos  = ro + t*rd;\n        vec3 nor = sphNormal( pos, obj );\n        // manual ray differentials\n        vec3 dpdx = t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd);\n        vec3 dpdy = t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd);\n        //vec3 posx = ro + rdx*t*dot(rd,nor)/dot(rdx,nor);\n        //vec3 posy = ro + rdy*t*dot(rd,nor)/dot(rdy,nor);\n        \n        float occ = occlusion( pos, nor, mb );\n        float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // color\n        col = 0.5 + 0.5*cos(float(id)*0.01 + vec3(5.3,4.3,3.3)  + (((id&7)<3)?vec3(0.5,1.0,1.5):vec3(0.0)) );\n        col += fre*0.3 - 0.08;\n        col = clamp(col,0.0,1.0);\n\n        // texture coords, with manual derivatives\n        vec3 dir = normalize(pos);\n        float u    = dot(pos-obj.xyz,dir)*8.0/obj.w;\n        float dudx = dot(       dpdx,dir)*8.0/obj.w;\n        float dudy = dot(       dpdy,dir)*8.0/obj.w;\n        //float ux = dot(posx-obj.xyz,normalize(posx))*8.0/obj.w;\n        //float uy = dot(posy-obj.xyz,normalize(posy))*8.0/obj.w;\n        //float dudx = u - ux;\n        //float dudy = u - uy;\n\n        // texture\n        col *= 0.4 + 0.6*linesTextureGradBox( u, abs(dudx), abs(dudy), id );\n\n        // occlusion\n        col *= occ;\n\n        \n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int j=ZERO; j<AA; j++ )\n    for( int i=ZERO; i<AA; i++ )\n    {\n        // sub-pixel        \n        vec2 of = vec2( float(i), float(j))/float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n        \n        uint hh = uint(i+AA*int(fragCoord.x))*17U +\n                  uint(j+AA*int(fragCoord.y))*127U +\n                  uint(iFrame)*31U;\n        float mb = hash1(hh);\n    #else\n    {\n        // pixel        \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float mb = 0.0;\n    #endif        \n\n        // camera\n        vec3 ro = vec3(0.0,0.0,4.0);\n        vec3 rd = normalize( vec3(p.xy,-2.5) );\n\n\n        // ray differentials\n        vec2 px = p + vec2(2.0,0.0)/iResolution.y;\n        vec2 py = p + vec2(0.0,2.0)/iResolution.y;\n        vec3 rdx = normalize( vec3(px.xy,-2.5) );\n        vec3 rdy = normalize( vec3(py.xy,-2.5) );\n\n        // render\n        vec3 col = vec3(0.15,0.22,0.25);\n        col = trace( ro, rd, rdx, rdy, col, mb );\n\n        // gama\n        col = pow( col, vec3(0.4545) );\n        \n        tot += col;\n    }\n    #if AA>1\n\ttot /= float(AA*AA);\n    #endif\n    \n\n    // color correct\n    tot = 1.1*pow( tot, vec3(1.0,1.3,1.4) );   \n        \n    // vignetting\n    vec2 q = fragCoord / iResolution.xy;\n    tot *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n\n    // dithering\n    //tot += (1.0/255.0)*hash3(uint(fragCoord.x) + 13U*uint(fragCoord.y));\n\n    fragColor = vec4( tot, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NUMPASES 3\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord-0.5);\n    \n    if( p.y>1 || p.x>NUMSPHERES ) return;\n\n    // compute current and previous frame    \n    float time = (iTime - 0.5*float(p.y)/24.0);\n\n    vec4 sphere[NUMSPHERES];\n\n    // animate\n    for( int i=0; i<NUMSPHERES; i++ )\n    {\n        float rad = pow(float(i)/float(NUMSPHERES-1),5.0);\n        vec3  pos = 1.0*cos( 6.2831*hash3(uint(i)*147U) + (1.0-0.7*rad)*time*0.7 );\n        rad = 0.25 + 0.4*rad;\n        sphere[i] = vec4( pos, rad );\n    }\n\n    // repell\n    for( int k=ZERO; k<NUMPASES; k++ )\n    for( int i=ZERO; i<NUMSPHERES; i++ )\n    for( int j=ZERO; j<NUMSPHERES; j++ )\n    {\n        if( i!=j )\n        {\n            vec3  di = sphere[i].xyz - sphere[j].xyz;\n            float rr = sphere[i].w   + sphere[j].w;\n            float di2 = dot(di,di);\n            if( di2 < rr*rr )\n            {\n                float l = sqrt(di2);\n                di = 0.5*di*(1.0-rr/l);\n                sphere[i].xyz -= di;\n                sphere[j].xyz += di;\n            }\n        }\n    }\n    fragColor = sphere[p.x];\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NUMSPHERES 40\n\n\n#define ZERO min(0,iFrame)\n\n\nfloat hash1( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n&0x7fffffffU)/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    uvec3 k = n + uvec3(0,517U,8191U);\n\tk = (k << 13U) ^ n;\n    k = k * (k * k * 15731U + 789221U) + 1376312589U;\n    return 1.0 - vec3(k&0x7fffffffU)/float(0x7fffffff);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}