{
    "Shader": {
        "info": {
            "date": "1473470012",
            "description": "Choose an angle with the mouse and reset the time.\nOne step takes 2 seconds.\n\nThere is also an instantaneous and coloured visualization by [url=https://www.shadertoy.com/user/paniq]paniq[/url]: [url=https://www.shadertoy.com/view/lslXD8]lslXD8[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "ltyGRD",
            "likes": 66,
            "name": "Animated Marching Visualization",
            "published": 3,
            "tags": [
                "raymarching",
                "visualization"
            ],
            "usePreview": 0,
            "username": "lara",
            "viewed": 14331
        },
        "renderpass": [
            {
                "code": "#define T (iTime*.5)\n\n#define P 0.0001 // precision\n#define S 50.    // steps\n#define D 3.     // distance\n\nvec2 _p; float _d = 1e10;\n\nfloat sdBox(vec2 p,vec2 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,p.y),0.);\n}\n\nfloat sdLine(vec2 p,vec2 a,vec2 b)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p);\n}\n\nfloat scene(vec2 p)\n{\n    return min(\n        max(max(length(p-vec2(1,0))-.3,-length(p-vec2(.8,0))+.15),-abs(p.y)+.05),\n        min(\n            sdBox(vec2(p.x,abs(p.y))-vec2(1,.6),vec2(.3,.05)),\n            sdBox(vec2(p.x,abs(p.y))-vec2(1.25,.55),vec2(.05,.05))\n       )\n    );\n}\n\nvec2 getNormal(vec2 p)\n{    \n\tvec2 e = vec2(P,0);\n    return normalize(vec2(scene(p+e.xy)-scene(p-e.xy),scene(p+e.yx)-scene(p-e.yx)));\n}\n\nvoid visualize(vec2 ro, vec2 rd, float t, float d, float i)\n{\n    vec2 n = getNormal(ro+rd*t);\n    \n    float x  = clamp(floor(T)-i,0.,1.);\n    float f1 = x + (1.-x) * fract(T);\n    float f2 = clamp((f1-.75)*16.,0.,1.);\n    float f3 = floor(abs(cos(min(f1*8.,1.)*6.283))+.5);\n    float a  = mix(atan(-n.y,-n.x),atan(rd.y,rd.x),f2);\n\n    // ray line\n    _d = min(_d,sdLine(_p,ro+rd*t,ro+rd*t+vec2(cos(a),sin(a))*d*floor(f3)));\n\n    // step indicator\n    _d = min(_d,length(_p-ro-rd*t)-.015);\n\n    if (i == floor(T))\n    {\n        // circle\n        _d = min(_d,abs(length(_p-ro-rd*t)-clamp(d*f3,0.,1e4)));\n    }\n}\n\nvec4 march(vec2 ro, vec2 rd)\n{\n    float t = 0., s = float(S), d;\n\n    for(float i = 0.; i < S; i++)\n    {\n        d = scene(ro+rd*t);\n\n        if (d < P || t > D || i > floor(T))\n        {\n            s = float(i);\n            break;\n        }\n\n\t\tvisualize(ro,rd,t,d,i);\n        \n        t += d;\n    }\n    \n    return vec4(ro+rd*t,d,s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _p = (2.*fragCoord.xy-iResolution.xy)/iResolution.yy;\n\tvec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.yy;\n    \n    if (iMouse.x < 10. && iMouse.y < 10.) m = vec2(0,.2);\n    \n    vec2 ro = vec2(-1,0);\n    vec2 rd = normalize(m-ro);\n    vec4 h  = march(ro,rd);\n    \n    // camera & scene\n    _d = min(_d,min(min(abs(length(_p-ro)-.05),sdLine(_p,ro,ro+rd*.05)),scene(_p)));\n        \n    // normal arrow\n    if (h.z < P)\n    {\n        vec2 n = getNormal(h.xy);\n        vec2 t = vec2(-n.y,n.x);\n\n        _d = min(_d,sdLine(_p,h.xy,h.xy+n*.1));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1+t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1,h.xy+n*.1-t*.025));\n        _d = min(_d,sdLine(_p,h.xy+n*.1+t*.025,h.xy+n*.125));\n        _d = min(_d,sdLine(_p,h.xy+n*.1-t*.025,h.xy+n*.125));\n    }\n    \n    _d = abs(_d)-1./iResolution.y;\n    \n\tfragColor = vec4(vec3(smoothstep(_d,_d+.005,.005)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}