{
    "Shader": {
        "info": {
            "date": "1464977040",
            "description": "motion experiment",
            "flags": 32,
            "hasliked": 0,
            "id": "lsySzy",
            "likes": 10,
            "name": "Glitch blur",
            "published": 3,
            "tags": [
                "raytracing",
                "blur",
                "glitch"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 910
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  vec2 texDelta = vec2(abs(sin(iTime)*2.0)/iResolution);\n \nfragColor =\n    texture(iChannel0, uv+vec2(0.0, -texDelta.y*3.0))*0.13+\n    texture(iChannel0, uv+vec2(texDelta.x*3.0, -texDelta.y*3.0))*0.13+\n    texture(iChannel0, uv+vec2(-texDelta.x*3.0, -texDelta.y*3.0))*0.13;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NEAR 0.01\n#define FAR 128.\n#define ITER 128\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat4 matRotateX(float rad)\n{\n    return mat4(1,       0,        0,0,\n                0,cos(rad),-sin(rad),0,\n                0,sin(rad), cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n    return mat4( cos(rad),0,-sin(rad),0,\n                0,       1,        0,0,\n                sin(rad),0, cos(rad),0,\n                0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n    return mat4(cos(rad),-sin(rad),0,0,\n                sin(rad), cos(rad),0,0,\n                0,        0,1,0,\n                0,        0,0,1);\n}\n\nmat3 mat3RotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nvec4 combine(vec4 val1, vec4 val2 )\n{\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cubicInOut(float t) {\n    return t < 0.5\n        ? 4.0 * t * t * t\n        : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvec4 map( vec3 pos, mat4 m)\n{\n    vec4 q = vec4(pos+vec3(0,0,-50.0),1.0)*m;\n\n    vec4 newP = (q + vec4( 0.0, 0.0, abs(sin(iTime*0.7)*20.0), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP1 = (q + vec4( 0.0, 0.0, abs(sin(iTime*1.2)*4.0), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP2 = (q + vec4( 0.0, 0.0, abs(sin(iTime*2.3)*5.0), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP3 = (q + vec4( 0.0, 0.0, abs(sin(iTime*1.5)*6.0), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP4 = (q + vec4( 0.0, 0.0, abs(sin(iTime*2.0)*2.5), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP5 = (q + vec4( 0.0, 0.0, abs(sin(iTime*1.7)*3.5), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n    vec4 newP6 = (q + vec4( 0.0, 0.0, abs(sin(iTime*1.1)*7.0), 1.0))*matRotateX(90.0*DEG_TO_RAD);\n\n    vec4 val1 = vec4(vec3(0.5,0.5,0.2),sdCappedCylinder(vec3(mod(newP.x,10.0)-5.0,newP.y,newP.z), vec2(3.0,0.01)));\n    vec4 val2 = vec4(vec3(0.6,0.4,0.0),sdCappedCylinder(vec3(mod(newP1.x,10.0)-5.0,newP1.y,newP1.z+10.0), vec2(3.0,0.01)));\n    vec4 val3 = vec4(vec3(0.7,0.3,0.0),sdCappedCylinder(vec3(mod(newP2.x,10.0)-5.0,newP2.y,newP2.z-10.0), vec2(3.0,0.01)));\n    vec4 val4 = vec4(vec3(0.8,0.2,0.0),sdCappedCylinder(vec3(mod(newP3.x,10.0)-5.0,newP3.y,newP3.z+20.0), vec2(3.0,0.01)));\n    vec4 val5 = vec4(vec3(0.1,0.5,0.0),sdCappedCylinder(vec3(mod(newP4.x,10.0)-5.0,newP4.y,newP4.z-20.0), vec2(3.0,0.01)));\n    vec4 val6 = vec4(vec3(0.1,0.5,0.0),sdCappedCylinder(vec3(mod(newP5.x,10.0)-5.0,newP5.y,newP5.z+30.0), vec2(3.0,0.01)));\n    vec4 val7 = vec4(vec3(0.2,0.5,0.0),sdCappedCylinder(vec3(mod(newP6.x,10.0)-5.0,newP6.y,newP6.z-30.0), vec2(3.0,0.01)));\n    vec4 r0 = combine(val1,val2);\n    vec4 r1 = combine(val3,val4);\n    vec4 r2 = combine(val5,val6);\n    vec4 r3 = combine(val7,r0);\n    vec4 r4 = combine(r1,r2);\n    vec4 r5 = combine(r3,r4);\n\n    return r5;\n}\n\nvec2 rot(vec2 p, float a) {\n    return vec2(\n        cos(a) * p.x - sin(a) * p.y,\n        sin(a) * p.x + cos(a) * p.y);\n}\n\nfloat saw(float x){\n    return abs(fract(x)*2.-1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    position -= .5;\n    \n    float effectActive = mod(iTime,10.0);\n    if(effectActive>5.0 && effectActive<= 10.0)\n    {\n        position.x += (sin((position.x + (iTime * 0.5)) * 3.0) * 0.1) + (sin((position.x + (iTime * 0.2)) * 2.0) * 0.01);\n        position.y += (cos((position.y + (iTime * 0.5)) * 3.0) * 0.1) + (cos((position.y + (iTime * 0.2)) * 2.0) * 0.01);\n    }\n\n    vec3 dir = vec3( position, 1.0 );\n\n    float aspect = iResolution.x / iResolution.y;\n    dir = normalize(vec3(position * vec2(aspect, 1.0), 1.0));\n    dir.yz = rot(dir.yz, 0.2);\n\n    vec3 pos = vec3(0.0, 5.0, 15.0);\n    mat4 m = matRotateZ(iTime*0.3);\n\n    float t = iTime;\n    vec2 gl = floor(2.*cos(5.*t))/3.*step(mod(position.yx-.0525,.125),vec2(.0525));\n    pos.x += mix(mix(gl,gl.xy,floor(5.*saw(-5.*t*0.7))/2.),vec2(0.),floor(-5.*saw(5.*t*0.7))/4.).x;\n\n    vec4 result;\n    int march = 0;\n    for (int i =0; i < ITER; i++)\n    {\n        result = map(pos, m);\n        march = i;\n        if (result.w < NEAR || result.w > FAR) break;\n        pos += result.w * dir;\n    }\n\n    vec3 col = map(pos, m).xyz;\n    vec4 bgCol;\n    bool isThreedObj = false;\n    if ( pos.z> 100. )\n    {\n        // bg\n        col = vec3(0.0);\n    }\n    else\n    {\n        \n        // shade\n        vec3 lightPos = vec3(20.0, 20.0, 20.0 );\n        vec3 light2Pos = normalize( lightPos - pos);\n        vec3 eps = vec3( .1, .01, .0 );\n        vec3 n = vec3( result.w - map( pos - eps.xyy, m ).w,\n                      result.w - map( pos - eps.yxy, m ).w,\n                      result.w - map( pos - eps.yyx, m ).w );\n        n = normalize(n);\n\n        float lambert = max(.0, dot( n, light2Pos));\n        //col *= vec3(lambert);\n        col = vec3(result.xyz);\n        \n        isThreedObj = true;\n    }\n\n    fragColor = vec4( col, 1.0);\n    // cross hatching\n    if(isThreedObj){\n        float lum2 = length(col);\n        float max=length(vec3(1.0,1.0,1.0));\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        fragColor = vec4(col*4.0,1.0);\n\n        if (lum2 < max/7.0*6.0) {\n            if (mod(fragCoord.x + fragCoord.y, 8.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n\n\n        if (lum2 < max/7.0*5.0) {\n            if (mod(fragCoord.x - fragCoord.y, 8.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n        if (lum2 < max/7.0*4.0) {\n            if (mod(fragCoord.x + fragCoord.y, 4.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n\n\n        if (lum2 < max/7.0*3.0) {\n            if (mod(fragCoord.x - fragCoord.y, 4.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n\n        if (lum2 < max/7.0*2.0) {\n            if (mod(fragCoord.x + fragCoord.y, 2.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n\n        if (lum2 < max/7.0*1.0) {\n            if (mod(fragCoord.x - fragCoord.y , 2.0) == 0.0) {\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n                fragColor = vec4(col*0.6,1.0);\n            }\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}