{
    "Shader": {
        "info": {
            "date": "1543715783",
            "description": "AOBench normalized to 1920x1080 with 4x4 supersampling and 256 AO rays per primary.\n\nThis is for comparing with CPUs using an ISPC build at similar settings.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "llKBzd",
            "likes": 3,
            "name": "AOBench comparative",
            "published": 3,
            "tags": [
                "aobench",
                "ao",
                "benchmark"
            ],
            "usePreview": 0,
            "username": "kig",
            "viewed": 770
        },
        "renderpass": [
            {
                "code": "/*\n\tby kioku / System K\n\thttps://www.shadertoy.com/view/ldl3Rn\n\n\t[ Modified to add normalized resolution and supersampling and attempt at a less bandy PRNG. ]\n*/\n/*\n    AOBench normalized to 1920x1080 with 4x4 supersampling and 256 AO rays per primary.\n\n    This is for comparing with CPUs using an ISPC build at similar settings.\n\n\tResults table:\n\n    WebGL\n    -----\n\t0.033s Nvidia RTX 2070\n\t0.1s Nvidia GTX 1050 4GB\n    0.2s Intel Iris Graphics 655\n    0.6s Intel UHD Graphics 630\n    1.8s Snapdragon 835\n    5.2s Snapdragon 820\n\n    ISPC\n    ----\n\t0.6s AMD TR 2950X [16c HT, ~AVX2]\n\t1.2s Dual-Xeon E5-2650 v2 [16c HT, AVX]\n\t1.5s i5-8259U [4c HT, AVX2]\n\t1.6s Xeon E3-1231v3 [4c HT, AVX2]\n\t2.9s i7-3770 [4c HT, AVX]\n\t7.8s i5-3317U [2c HT, AVX]\n\t11s Snapdragon 835 [8c, 4+4c, NEON, aarch64]\n\t15s Exynos 7420 Octa [8c, 4 a53 + 4 a57, NEON, aarch64]\n    19s Snapdragon 820 [4c, 2+2c, NEON, aarch64]\n\t55s Raspberry PI 3B+ [4c a53, NEON, armv7l]\n\t56s AllWinner H5 [4c a53, NEON, aarch64]\n\t100s AllWinner H3 [4c a7, NEON, armv7l]\n\n    FWIW, single-threaded scalar C++ on the fast x86s runs in ~50-60s.\n    Extrapolating that, WASM ~75s, JS 150s+, Workers for ~4-40s runtimes [16c wasm / 4c JS]\n\n*/\n\n// To benchmark, uncomment this. For most representative results, run fullscreen at 1920x1080. Count the cyan bars for fps :P\n// Frame times above are calculated as 1/fps.\n//\n//#define BENCHMARK\n\n// Control benchmark heaviness.\n// Set this to 1.0 or even 0.5 for mobile SoCs.\n// To normalize frame times:\n//   2.0 subsamples - divide fps by 4\n//   1.0 - divide fps by 16\n//   0.5 - divide fps by 64\n//\n#define BENCHMARK_SUBSAMPLES 4.0\n\n// Control demo mode supersampling (SUBSAMPLES * SUBSAMPLES primary rays per pixel)\n#define SUBSAMPLES 2.0\n\n\nmat3 rotationXY( vec2 angle ) {\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n         cy, -sy, 0.0,\n         sy,  cy, 0.0,\n        0.0, 0.0, 1.0\n\t) * mat3(\n        cp, 0.0, -sp,\n        0.0, 1.0, 0.0,\n        sp, 0.0, cp\n    );\n}\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n};\nstruct Plane\n{\n\tvec3 p;\n\tvec3 n;\n};\n\nstruct Intersection\n{\n\tfloat t;\n\tvec3 p;     // hit point\n\tvec3 n;     // normal\n\tint hit;\n};\n\nSphere sphere[3];\nPlane plane;\nfloat aspectRatio = 16.0/9.0;\n\nvoid shpere_intersect(Sphere s, Ray ray, inout Intersection isect)\n{\n\tvec3 rs = ray.org - s.center;\n\tfloat B = dot(rs, ray.dir);\n\tfloat C = dot(rs, rs) - (s.radius * s.radius);\n\tfloat D = B * B - C;\n\n\tif (D > 0.0)\n\t{\n\t\tfloat t = -B - sqrt(D);\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.t = t;\n\t\t\tisect.hit = 1;\n\n\t\t\t// calculate normal.\n\t\t\tisect.p = ray.org + ray.dir * t;\n\t\t\tisect.n = normalize(isect.p - s.center);\n\t\t}\n\t}\n}\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection isect)\n{\n\tfloat d = -dot(pl.p, pl.n);\n\tfloat v = dot(ray.dir, pl.n);\n\n\tif (abs(v) < 1.0e-6) {\n\t\treturn;\n\t} else {\n\t\tfloat t = -(dot(ray.org, pl.n) + d) / v;\n\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.hit = 1;\n\t\t\tisect.t   = t;\n\t\t\tisect.n   = pl.n;\n\t\t\tisect.p = ray.org + t * ray.dir;\n\t\t}\n\t}\n}\n\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n\tfor (int c = 0; c < 3; c++)\n\t{\n\t\tshpere_intersect(sphere[c], r, i);\n\t}\n\tplane_intersect(plane, r, i);\n}\n\n\t\t\nvoid orthoBasis(out vec3 basis[3], vec3 n)\n{\n\tbasis[2] = vec3(n.x, n.y, n.z);\n\tbasis[1] = vec3(0.0, 0.0, 0.0);\n\n\tif ((n.x < 0.6) && (n.x > -0.6))\n\t\tbasis[1].x = 1.0;\n\telse if ((n.y < 0.6) && (n.y > -0.6))\n\t\tbasis[1].y = 1.0;\n\telse if ((n.z < 0.6) && (n.z > -0.6))\n\t\tbasis[1].z = 1.0;\n\telse\n\t\tbasis[1].x = 1.0;\n\n\n\tbasis[0] = cross(basis[1], basis[2]);\n\tbasis[0] = normalize(basis[0]);\n\n\tbasis[1] = cross(basis[2], basis[0]);\n\tbasis[1] = normalize(basis[1]);\n\n}\n\nint seed = 0;\n\nfloat randomn()\n{\n\tseed = int(mod(float(seed)*1364.0+626.0,5209.0));\n\treturn float(seed)/5209.0;\n}\n\n\nfloat hash2(vec2 n) { \n\treturn fract(sin(dot(n, vec2(18.99221414, 15.839399))) * 13454.111388);\n}\n\nvec3 computeAO(inout Intersection isect)\n{\n\tconst int ntheta = 8;\n\tconst int nphi   = 8;\n\tconst float eps  = 0.0001;\n\n\t// Slightly move ray org towards ray dir to avoid numerical problem.\n\tvec3 p = isect.p + eps * isect.n;\n\n\t// Calculate orthogonal basis.\n\t vec3 basis[3];\n\torthoBasis(basis, isect.n);\n\n\tfloat occlusion = 0.0;\n\n\tfor (int j = 0; j < ntheta; j++)\n\t{\n\t\tfor (int i = 0; i < nphi; i++)\n\t\t{\n\t\t\t// Pick a random ray direction with importance sampling.\n\t\t\t// p = cos(theta) / 3.141592\n\t\t\tfloat r = randomn(); //hash2(isect.p.xy+vec2(i,j));\n\t\t\tfloat phi = 2.0 * 3.141592 * hash2(isect.p.xy+vec2(float(i)*9.1,float(j)*9.1));\n\n\t\t\tvec3 ref;\n\t\t\tfloat s, c;\n\t\t\ts = sin(phi);\n\t\t\tc = cos(phi);\n\t\t\tref.x = c * sqrt(1.0 - r);\n\t\t\tref.y = s * sqrt(1.0 - r);\n\t\t\tref.z = sqrt(r);\n\n\t\t\t// local -> global\n\t\t\tvec3 rray;\n\t\t\trray.x = ref.x * basis[0].x + ref.y * basis[1].x + ref.z * basis[2].x;\n\t\t\trray.y = ref.x * basis[0].y + ref.y * basis[1].y + ref.z * basis[2].y;\n\t\t\trray.z = ref.x * basis[0].z + ref.y * basis[1].z + ref.z * basis[2].z;\n\n\t\t\tvec3 raydir = vec3(rray.x, rray.y, rray.z);\n\n\t\t\tRay ray;\n\t\t\tray.org = p;\n\t\t\tray.dir = raydir;\n\t\t\t\n\t\t\tIntersection occIsect;\n\t\t\toccIsect.hit = 0;\n\t\t\toccIsect.t = 1.0e30;\n\t\t\toccIsect.n = occIsect.p = vec3(0);\n\t\t\tIntersect(ray, occIsect);\n\t\t\tocclusion += (occIsect.hit != 0 ? 1.0 : 0.0);\n\t\t}\n\t}\n\n\t// [0.0, 1.0]\n\tocclusion = (float(ntheta * nphi) - occlusion) / float(ntheta * nphi);\n\treturn vec3(occlusion, occlusion, occlusion);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pxMul = vec2(1920, 1080) / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 duv = ((fragCoord.xy+1.0) / iResolution.xy) - uv;\n    fragColor = vec4(0.0);\n    seed = int(mod((fragCoord.x+0.5) * (fragCoord.y*iResolution.y+0.5), 65536.0));\n#ifdef BENCHMARK\n    float subSamples = round(pxMul.x * BENCHMARK_SUBSAMPLES);\n    for (float y = 0.; y < subSamples; y++) {\n        for (float x = 0.; x < subSamples; x++) {\n#else\n    const float subSamples = SUBSAMPLES;\n    for (float y = 0.; y < SUBSAMPLES; y++) {\n        for (float x = 0.; x < SUBSAMPLES; x++) {\n            float dt = iTimeDelta * (x+y*subSamples+randomn()) / (subSamples*subSamples+1.0);\n            float t = iTime - dt;\n\t\t    mat3 rot = rotationXY( vec2( t, cos(t*0.3) * 0.05 ) );\n#endif\n            vec2 fuv = uv + (duv / subSamples * vec2(x,y));\n            \n            vec3 dir = normalize(vec3((fuv-0.5)*2.0*vec2(1.0,1.0/aspectRatio),-1.0));\n            Ray ray;\n#ifdef BENCHMARK\n            ray.org = vec3(0.0);\n            ray.dir = dir;\n#else\n            ray.org = 3.5*vec3(sin(t),0,cos(t)) - vec3(0.0, 0.0, 3.0);\n            ray.dir = normalize(rot * dir);\n#endif\n            Intersection it;\n            it.hit = 0;\n            it.n = vec3(0,0,0);\n            it.p = vec3(0,0,0);\n            it.t = 10000.0;\n\n            sphere[0].center = vec3(-2.0, 0.0, -3.5);\n            sphere[0].radius = 0.5;\n            sphere[1].center = vec3(-0.5, 0.0, -3.0);\n            sphere[1].radius = 0.5;\n            sphere[2].center = vec3(1.0, 0.0, -2.2);\n            sphere[2].radius = 0.5;\n            plane.p = vec3(0,-0.5, 0);\n            plane.n = vec3(0, 1.0, 0);\n            \n            Intersect(ray,it);\n\n            if (it.t < 1e3) {\n\t            fragColor += vec4(computeAO(it),1.0);\n            }\n        }\n    }\n    fragColor /= subSamples * subSamples;\n    if (fragCoord.x < iFrameRate * 10.0 && fragCoord.y < 10.0 && mod(fragCoord.x, 10.0) >= 1.0) {\n        fragColor = vec4(0.4, 1.0, 0.85, 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}