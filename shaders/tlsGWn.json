{
    "Shader": {
        "info": {
            "date": "1556110128",
            "description": "Mouse does stuff\n\nwith each derivative, the graph-color red-shifts ;)\n blue     f(x)=0th derivative\n green   f'(x)=1th derivative\n yellow  f''(x)=2th derivative\n purple  f'''(x)=3th derivative",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsGWn",
            "likes": 1,
            "name": "AD30 (exp(sin(A+X)+X)*B)dX³",
            "published": 3,
            "tags": [
                "filter",
                "gradient",
                "vibrato",
                "ad",
                "phase",
                "automaticdifferentiation",
                "chainrule",
                "productrule",
                "curvaturejerk",
                "curvajerk",
                "drunkfluttershy"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 493
        },
        "renderpass": [
            {
                "code": "\n\n/*\na derivative of a function is the differential of a function\nf'(x)=f (x)dx\n\nf1(x)=f0(x)dx\nf2(x)=f1(x)dx\nf3(x)=f2(x)dx\n\ngreen  line is close to 0,where the blue   line has a hill or valley\nyellow line is close to 0,where the green  line has a hill or valley\npurple line is close to 0,where the yellow line has a hill or valley\nf1(x)==0, where f0(x) has a local maximum or local minimum at [x]\n\n\nthe above holds true where abs is a lowest-level function\nthe above is no longer true where abs() is a higher level function\n\nwith each derivative, the graph-color red-shifts ;)\n violet f0(x)=0th derivative :eg: value per coin of money over time  (focus on a point where this is >0 (,but also decreases))\n blue   f1(x)=1th derivative :eg: inflation/deflation (change of value of money over time) (fosus on a point whree this is <0)\n green  f2(x)=2th derivative :eg: rate at which the purchasing power of money decreases/increases  (acceleration of inflation == moneyValue)\n orange f3(x)=3th derivative :eg: \"the rate of increase of inflation is decreasing\" - Richard Nixxon == \"[orange line && blue line && green line] <0, violet line is barely >0 \"\n\nthis exemplifies the little utility that a 3rd derivative has \n, while without context of lower derivatives\n//the 3rd derivative is usefull to smoothen the line of the 2nd derivative.\n\nhttps://en.wikipedia.org/wiki/Third_derivative\n     jerk == rate at which acceleration changes\ncurvajerk == rate at which curvature    changes\n\n*/\n\n//AD,filter,phase,vibrato,gradient,curvaturejerk,curvajerk,chainrule,productrule,automaticdifferentiation,drunkfluttershy\n\n//child  AD31    : https://www.shadertoy.com/view/3lf3W8  (di() seems to be working fine )\n//self   AD30    : https://www.shadertoy.com/view/tlsGWn  (many fixes ant attempt at di(a/b) )\n//parent AD29    : https://www.shadertoy.com/view/3llGDr  (abs()exp()log())\n//parent AD28    : https://www.shadertoy.com/view/Wts3Wr  (sin())\n//parent AD27    : https://www.shadertoy.com/view/Wll3z7  (only cos() 3rd derivative)\n//parent dx³ base: https://www.shadertoy.com/view/WllGz7  (mostly empty canvas concept)\n//parent AD26    : https://www.shadertoy.com/view/MsffRs  (more complete set, ony 1 derivative)\n//parent AD25    : https://www.shadertoy.com/view/XdXfRl  (more complete set, ony 1 derivative)\n//parent fm-phase: https://www.shadertoy.com/view/tslSR8  (the phase-culpit of fm-synthesis)\n//parent         : all (analytic) [filter]     shaders ,where you can get: https://www.integral-calculator.com/\n//parent         : all (analytic) [softshadow] shaders ???\n//\n//twitter images: https://twitter.com/ollj/status/1121112037000609792\n//twitter odler : https://twitter.com/ollj/status/1120622111767371777\n\n\n/*\nThis shader dares to implement/debug\na [derivatuve arithmetic] set for [automatic differentiation]\nbut it calculates not just one differential as one byproduct\n, but also the 2nd and 3rd derivative as 3 byproducts total\n3 derivatives make sense\n, because trigonometry functions have a loop of 4 or 2 differntials:\n\n//f    (x)=+sin(x)\n//f'   (x)=+cos(x)\n//f''  (x)=-sin(x)\n//f''' (x)=-cos(x)\n//f''''(x)=+sin(x)==f(x)\n\ncore plan here is to use\nhttps://www.integral-calculator.com\nto get ANTI-derivatives as far as needed and possible/practical\nand then get a series of derivatives with [automatic differentiation]\n, from a high enough ANTI-derivative to:\n- use 1 antiderivative for frequency-modulation (analytic phase)\n- use 2 or 3 anditerivatives for a good filter function\n- calculate fast/analytical derivatives is useful for [advanced spheretracking]\n- - think about what you could estimate from a fast+analytic curvature of a distancefield.\n- - this can extend into something like [drunk fluttershy marching]\n  , but it may not just move along the NORMAL/GRADIRNT\n  ,also use [radiusOf/Principal /gaussian curvature] and CURVAJERK\n\nThis uses a lot of structure and monadic #define shorthands\nfrom the CommonTab\n, that construct a [derivative arithmetic] set \n  of [automatic differentiation].\nso just read the commonTab before reading further below:\n*/\n\n#define viewZoom 32.\n#define aA min(r.x,r.y)\n#define Aa (viewZoom/aA)\n#define fra(u)(u-.5*r.xy)*viewZoom/r.y \n\n#define ssaa(a) smoothstep(Aa,-Aa,a)\n\n//target permutations (3rd derivatives are hard to debug)\n//keep this dreidel to debug any vanvas changes\nvec4 sisi(float t){return vec4(\nsin(sin(t)),cos(t)*cos(sin(t)),\n-cos(t)*cos(t)*sin(sin(t))-sin(t)*cos(sin(t)),\n-cos(sin(t))*cos(t)*cos(t)*cos(t)//3rd\n+sin(sin(t))*3.*cos(t)*sin(t)\n-cos(sin(t))*cos(t));}\nvec4 sico(float t){return vec4(\nsin(cos(t)),-sin(t)*cos(cos(t)),\n-sin(t)*sin(t)*sin(cos(t))-cos(t)*cos(cos(t)),\n+cos(cos(t))*sin(t)*sin(t)*sin(t)//3rd\n-sin(cos(t))*3.*cos(t)*sin(t)\n+cos(cos(t))*sin(t));}\nvec4 cosi(float t){return vec4(\ncos(sin(t)),-cos(t)*sin(sin(t)),\nsin(t)*sin(sin(t))-cos(t)*cos(t)*cos(sin(t)),\n+sin(sin(t))*cos(t)*cos(t)*cos(t)//3rd\n+cos(sin(t))*3.*cos(t)*sin(t) \n+sin(sin(t))*cos(t));}\nvec4 coco(float t){return vec4(\ncos(cos(t)),sin(t)*sin(cos(t)),\ncos(t)*sin(cos(t))-sin(t)*sin(t)*cos(cos(t)),\n-sin(cos(t))*sin(t)*sin(t)*sin(t)//3rd\n-cos(cos(t))*3.*cos(t)*sin(t)  \n-sin(cos(t))*sin(t));}\n//above and below should be the same, and so far the dual permutations pass!\n//and i am not testing 3x permutations the same way.\n//example code for automatic differentiation of repeated cos()\nvec4 dsisi(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=si(C);C=si(C);return V3(C);}\nvec4 dsico(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=co(C);C=si(C);return V3(C);}\nvec4 dcosi(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=si(C);C=co(C);return V3(C);}\nvec4 dcoco(float t){d0000 C=D0000(vec4(t,1,0,0))//initial chainRuleSetup\n ;C=co(C);C=co(C);return V3(C);}\n\n//basic mouse inpouts are always followed by ,0,0,0))\nvec4 dtA(float t,vec4 m){\n ;d0000 X=D0000(vec4(t  ,1,0,0))//dt\n ;d0000 A=D0000(vec4(-m.x,0,0,0))\n ;d0000 B=D0000(vec4(m.y,0,0,0))\n ;X=mu(ad(si(ad(X,A)),X),B)\n ;//X=ab(si(X))\n ;//X=ad(ln(ad(X,A)),B)\n ;//X=ln(ex(si(ab(co(X))))) //seems to be fixed, ln()3th derivative seems fine now\n ;//X=co(X)\n ;return V3(X);}\nvec4 dtB(float t,vec4 m){ \n ;d0000 X=D0000(vec4(t,1,0,0))//dt\n ;d0000 A=D0000(vec4(-m.x,0,0,0))\n ;d0000 B=D0000(vec4(m.y,0,0,0))\n ;X=mu(X,B)\n ;X=ad(ex(si(ad(A,X))),X) //seems to be fixed, ln()3th derivative seems fine now\n ;return V3(X);}\n\n//memos:\n//ex(ln(C))=C  //this just debugs ln() AND ex()\n//for where any of them may not be the inverse of the other.\n//C=ex(ln(C)) // if(log(0.)==0.) ex(ln(C))=abs(C)\n//;C=ln(ex(C)) // if(log(0.)==0.) ex(ln(C))=C\n//;C=ex(ln(C)) // if(log(0.)==0.) ex(ln(C))=abs(C)\n\n\n//visualizaing demo:\nvec4 show(float t,vec2 u,vec3 r,vec4 m\n){\n ;t=u.x\n ;//t*=2.     \n ;vec4 c=vec4(0)\n ;c+=dcoco(t)-coco(t)//pass\n ;c+=dsisi(t)-sisi(t)//pass\n ;c+=dcosi(t)-cosi(t)//pass\n ;c+=dsico(t)-sico(t)//pass\n //above 4 lines should add vec4(4), as both functions are identical.\n //uncomment below line to see f(x)=vec4(0)\n ;c=dtB(t,m)//test for show   //pass\n ;//normalizing a 2d gradient is rarely pretty\n ;//;c.xyz=abs(c.xyz-u.y)/(sqrt(1.+c.yzw*c.yzw))-thick.xyz;\n ;//still lacks precision when the next abs(derivative) is small.\n ;//float thick=.4\n ;vec4 thick=vec4(1.9,1.6,1.3,1)*Aa*mix(1.5,9.,-cos(iTime)*.5+.5) //line thickness (normalized by 1 derivative)\n ;vec3 e=sqrt(1.+pow(vec3(thick.yz,c.zw),vec3(1./8.)))//this seems very false\n ;e=vec3(1)\n ;c.xyz=abs(u.y-c.xyz)*e/(sqrt(1.+c.yzw*c.yzw))-thick.xyz;\n  //no analytical 4th derivative, so c.w one sucks a bit\n ;float W=fwidth(u.y-c.w)\n ;//c.w=abs(c.w-u.y)*(sqrt(1.-dFdx(c.w)))/W-thick.w*32.//this is not pretty\n\n ;c.w=mix(\n      smoothstep(Aa*32.,-Aa*32.,(abs(c.w-u.y)*(sqrt(1.-dFdx(c.w)))/W)-thick.w*thick.w*64.)\n     ,smoothstep(Aa,-Aa,abs(c.w-u.y)/(sqrt(1.+W))-thick.w)\n     ,.9)\n ;//i could easiyl get a great c.w by 4tapping it. but i dont want to?\n     \n ;c.xyz=smoothstep(Aa,-Aa,c.xyz)\n ;//rainbow color and alpha-compositing\n ;c*=.9//more transparent\n ;vec4 o=sqrt(7./vec4(3,5,7,13))*.5+.5\n ;o=-.125-.5*vec4(.03,.05,.15,.1)*cos(o*u.x*36.*viewZoom/iResolution.x)\n ;v3 violet =v3(hsv2rgb_cosine15(o.x+.8,1.,2.),c.x)//v3(.5,0 ,1,c.x);\n ;v3 blue   =v3(hsv2rgb_cosine15(o.y+.5,1.,2.),c.y)//v3(0 ,.5,1,c.y);\n ;v3 yellow =v3(hsv2rgb_cosine15(o.z+.2,1.,2.),c.z)//v3(0 ,1 ,0,c.z);\n ;v3 orange =v3(hsv2rgb_cosine15(o.w+.0,1.,2.),c.w)//v3(1 ,.5,0,c.w);\n ;return aOverB(aOverB(violet,blue),aOverB(yellow,orange));\n ;}\n//grid canvas for scale\nfloat grid(vec2 u,vec3 r\n){u=abs(u)\n ;u.x=min(u.x,u.y)-Aa*.02\n ;u.x=ssaa(u.x)\n ;return u.x;}\nfloat canvas(vec2 u,vec3 r\n){return mix(grid(u,r),grid(fract(u-.5)-.5,r),.2);}\n//damn, grid and gamma correction do not cooperate well\n//, i need my tartan weave really?\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec4 m=iMouseZwFix(iMouse,true)\n ;vec3 r=iResolution\n  \n ;//u.x-=(m.z-iResolution.x*.5)//*2. //mouse.x scrolls\n     \n ;u=fra(u)     \n ;//u/=(1.-iResolution.y/m.w)//mouse.w zooms\n ;float iT=iTime-4.\n ;if(m.z<=0.)m.xy=vec2(iT,sin(iT)*.5-1.)*(sqrt(5.)*.5+.5)\n ;else m.xy=fra(m.xy)\n ;//m.zw=fra(m.zw)\n\n ;vec4 c=vec4(0)\n ;c=aOverB(show(iTime,u,r,m),vec4(sat(canvas(u/2.,r)*9.)))\n ;o =vec4(sat(c.xyz*1.1),1)\n ;o.xyz=pow(o.xyz,vec3(2.2))\n ;}\n\n/*\nmemos to self: \n- verb is \"differentiation\", there is no \"c\" glyph in this (except in its french variant)\n- - Babbage planned a [differencial engine] and this the \"c\" is a bad habbit in AD ever since.\n- [radius of curvature] != [gaussian curvature] //2nd derivative\n- - i assume this only gets worse for 3rd derivatives.\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n\n#if (__VERSION__ <300)\n  //glES300 reserves more namespace than previous versions\n  //this also reserves these namespaces in older versions\n  //so you do not unintentionally use cross() in gles100\n  #define cross(a,b) 1.\n  #define inverse(a) 1.\n#endif\n\n//indexing starts at 0\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n\n#define sat(a) clamp(a,0.,1.)\n\nvec3 hsv2rgb_cosine15(float h,float s,float v){\n vec3 hue=.5+.5*cos((3.*h+vec3(0,2,1))*radians(120.0));\n return v*mix(vec3(1),clamp(hue,0.,1.),s);}\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//includes sat() and premultiply:\nv3 aOverB(v3 a,v3 b){a=sat(a);b=sat(b)\n ;a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n\n// AD29_start\n/*\n3rd derivative [Automatic differentiation]\nuses [chain rule] and [product rule]\n, to calculate the derivative of an operation-list opA(opB(x)) as a byproduct\nto up to a 3rd derivative; f'''(x)\n\nso far only defined for y=sin(x) and y=cos(x)\nfirst steps are slow, because debugging a 3rd derivative is non-instant\nwhile there is plenty of space for silly typos and copyPaste errors\nmore complete DA-sets (only 1st derivative) are [DA25],[DA24],[DA23]...\n/**/\n\n//define more [monadic function namespace]\n//to completely replace infix-notation\nv0 ne(v0 a){return -1.*(a);}\nv0 ab(v0 a){return abs(a);}//sign(a)=a/ab(a) \nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nv0 ex(v0 a){return exp(a);} \nv0 e2(v0 a){return exp2(a);} \nv0 ln(v0 a){return log(abs(a));} //semi-worksafe\nv0 l2(v0 a){return log2(abs(a));}//semi-worksafe\nv0 mu(v0 a,v0 b){return a*b;}\nv0 di(v0 a,v0 b){return a/b;}\nv0 su(v0 a,v0 b){return a-b;}\nv0 ad(v0 a,v0 b){return a+b;}\n\n/*\ndefine a structure that implies automatic differentiation:\n-type: [d**  ] <- implies automatic differentiation with at least 1 derivative\n-type: [d*** ] <- implies automatic differentiation with at least 2 derivatives\n-type: [d****] <- implies automatic differentiation with at least 3 derivatives\n*=[0,1,2,3] == number of domains (indexing starts at 0)\nby feeding a different type to the same [monadic function namespace]\n.a accululates 0th derivative\n.b accumulates 1th derivative\n.c accumulates 2th derivative\n.d accumulates 3th derivative\nbut not just over one tomain, but easily up to 3d. (and a bit into 4d)\n*/\n#define ST struct\nST d00{v0 a;v0 b;};ST d000{v0 a;v0 b;v0 c;};ST d0000{v0 a;v0 b;v0 c;v0 d;};\nST d11{v1 a;v1 b;};ST d111{v1 a;v1 b;v1 c;};ST d1111{v1 a;v1 b;v1 c;v0 d;};\nST d22{v2 a;v2 b;};ST d222{v2 a;v2 b;v2 c;};ST d2222{v2 a;v2 b;v2 c;v0 d;};\nST d33{v3 a;v3 b;};ST d333{v3 a;v3 b;v3 c;};ST d3333{v3 a;v3 b;v3 c;v0 d;};\n//restore funtionality (eg: swiveling) by explicit typecast:\nd0000 D0000(v3    a){return d0000(a.x,a.y,a.z,a.w);}\nv3       V3(d0000 a){return    v3(a.a,a.b,a.c,a.d);}\n//v3 D1bcd(d0000 a){return v3(1.,a.b,a.c,a.d);}//for a minifying concept\n\n\n/*\n  chain rule:\n  (f(g(x)))dx = f'(g())*g'()\n\n  product rule (is subroutine of chainRule of higher derivatives than 1st derivative)\n  (f()*g())dx = f'()*g()+f()*g'()\n*/\n\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd0000 AD(d0000 a,vec4 o){float O=a.c*o.x\n ;return D0000(o.xyyy*vec4(1.,a.b,a.c,a.d)\n +vec4(0,0,a.b*vec2(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n//not sure if its ALWAYS that simple\n\n/*\nd0000 AD(d0000 a,vec4 o){return D0000(\n o.x                //0th derivative (function identity)\n,o.y*a.b            //1st dericative (common AD stuff as in [AD26] )\n,o.y*a.c+a.b*o.z*a.b//2nd derivative (product rule of the above is a bit tricky)\n,o.y*a.d-a.b*(2.*a.c*o.x+(a.b*a.b*o.y+a.c*o.x)));}//3rd , recurtion explosion:\n*/\n\n//sin() and cos() derivatives are 4-cyclic.\n//and cos() is offset by 1:\nvec4 siD(float a){return vec4(+si(a),+co(a),-si(a),-co(a));}\n// [automatic differentiation] up to 3rd derivative of sin(a):\nd0000 si(d0000 a){return AD(a,siD(a.a));}\n// [automatic differentiation] up to 3rd derivative of cos(a):\nd0000 co(d0000 a){return AD(a,siD(a.a).yzwx);}\n\n//memo to self, check 2nd derivative in both directions\n\n//2nd derivative seems to be fine\nd0000 ab(d0000 a){return d0000(ab(a.a),sign(a.a)*a.b,sign(a.a)*a.c,sign(a.a)*a.d);}\n//2nd derivative is certainly false for ln()\n\n//ln() 2nd and 3rd derivative imply quotientRule\n//i hope i did this corretcly. last time i did this 15 years ago.\nd0000 ln(d0000 a){return d0000(\n ln(a.a)\n,a.b/a.a\n,(a.c*a.a-a.b*a.b)/(a.a*a.a)\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))\n /(a.a*a.a*a.a*a.a)//the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}\n\n//ex() seems to be fine\nd0000 ex(d0000 a){return d0000(ex(a.a)\n,ex(a.a)*a.b\n,ex(a.a)*a.b*a.b+ex(a.a)*a.c//productRule\n//above implies  https://en.wikipedia.org/wiki/Triple_product_rule\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b\n+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}\n//exp2() is not THAT simple here.\n\n//substraction is trivial, because [differentiation == integration]\nd0000 su(d0000 a,d0000 b){return D0000((V3(a)-V3(b)));}\nd0000 ad(d0000 a,d0000 b){return D0000((V3(a)+V3(b)));}\n\nd0000 mu(d0000 a,d0000 b){return d0000(\n a.a*b.a        //1 product rule  to 1th derivative\n,a.a*b.b+a.b*b.a//2 product rules to 2th derivative\n,a.b*b.b+a.a*b.c\n+a.c*b.a+a.b*b.b//4 product rules to 3th derivative\n,a.c*b.b+a.b*b.c\n+a.b*b.c+a.a*b.d\n+a.d*b.a+a.c*b.b\n+a.c*b.b+a.b*b.c);}    \n\n//this looks promising, after 4 failures.\n//3rd quotientRule is a bit excessive\nd0000 di(d0000 a,d0000 b){return d0000(\n  a.a/b.a\n,(a.b*b.a-a.a*b.b)/(b.a*b.a)//first derivative is [simple quotient rule]\n //2nd derivatibve is the quotient rule of THE ABOVE 1st derivative\n,//2nd derivative is perfeect match with 3rd of ln() so thats a good sign!\n((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n    -2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n    /(b.a*b.a*b.a*b.a) \n,//3rd derivatibve is the quotient rule of THE ABOVE 2nd derivative\n //3rd derivative looks fine, has all the right signs and limits\n //and it nicely normalites the 2nd derivative line\n //its still not crunched and very commented, for debugging.\n((\n//derived dividend ((all whitespace is a püroductRule\n((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a         )\n+(a.c*b.a        +a.b*b.b        -a.b*b.b        -a.a*b.c        )*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b        )\n     +(a.b*b.a        -a.a*b.b        )*(b.b*b.b+b.a*b.c)))\n//times pure divisor\n*(b.a*b.a*b.a*b.a)\n//minus pure dividend\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n    -2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n//times derived divisor\n *4.*(b.b*b.a*b.a*b.a)\n//divided by pure squared divisor\n)/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a)\n//return 4 ddifferential accumulators: 0th to 3th derivative.\n);}\n    \n\n// AD29___end",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}