{
    "Shader": {
        "info": {
            "date": "1635163347",
            "description": "Applying a very simple procedure involving multiple colored square-shaped overlays and basic lighting to produce a greeble-like surface in the style of abstract art.",
            "flags": 0,
            "hasliked": 0,
            "id": "NsKSRz",
            "likes": 72,
            "name": "Abstract Geometric Art Pattern",
            "published": 3,
            "tags": [
                "procedural",
                "voronoi",
                "texture",
                "abstract",
                "art",
                "greeble"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1053
        },
        "renderpass": [
            {
                "code": "/*\n\n    Abstract Geometric Pattern\n    --------------------------\n\n    Applying a very simple procedure involving multiple colored square overlays \n    and basic lighting to produce a greeble-like surface in the style of abstract \n    art... or something to that effect. :)\n    \n    I'd been experimenting with procedural greebled surfaces a while ago, and this \n    was just a byproduct of that. I wouldn't call it a greebled surface per se, but \n    if you mapped it onto a 3D surface, it'd have that feel. Thanks to the basic \n    lighting, it also has a painted feel. On a side note, a lot of wrapped \n    procedural textures you see have usually been highlighted in a similar wrappable \n    unidirectional way.\n    \n    The technique is about as simple as it gets: Combine some offset squares to \n    form a polygon with squared sides. Construct a square grid and render these\n    in each cell. After that, combine a few resultant layers at various frequencies.\n    The method is different, but similar to stacking Voronoi layers.\n    \n    I didn't put a lot of effort into rendering speed, as this is the kind of thing\n    that you should probably prerender into one of the buffers prior to use. By the\n    way, I have a couple of 3D greeble examples that I'll post later.\n    \n    \n    Other examples:\n    // Similar principals, and a nice result. By the way Piyushslayer has\n    // some other really nice examples.\n    Abstract Squircles - piyushslayer \n    https://www.shadertoy.com/view/Wtc3D8\n    \n\n*/\n\n\n// Just the two palattes - Vibrant: 0, Earth: 1.\n#define PALETTE 0\n\n// Base shape -  Square: 0, Diamond: 1., Hexagon: 2, Octagon: 3, Circle: 4.\n#define SHAPE 0\n\n\n// Random rotation, which gives it more of a \"tech\" look.\n//#define RAND_ROT\n\n\n//Thanks to Dave_Hoskins for the fantastic hash functions!\n//https://www.shadertoy.com/view/4djSRW\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    //f = mod(f, GRID_SIZE);\n    // The first line relates to ensuring that icosahedron vertex identification\n    // points snap to the exact same position in order to avoid hash inaccuracies.\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p = p*p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(h)*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- Accumulated noise layers of modulated amplitudes and frequencies.\nfloat fBm(vec2 p){ \n\n    // Layer the noise.\n    float ns = 0., sum = 0., a = 1.;\n    for(int i = 0; i<5; i++){\n    \n        ns += n2D(p)*a;\n        p *= 2.5;\n        sum += a;\n        a /= 1.5;\n    }\n    \n    return ns/sum; // Range: [0, 1].\n}\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n*/\n\n// Shape distance metrics. You could put whatever you feel like here.\nfloat dist(vec2 p, vec2 b){\n \n      \n      #if SHAPE == 0\n      // Square.\n      p = abs(p) - b;\n      return max(p.x, p.y);\n      #elif SHAPE == 1\n      // Diamond.\n      p = abs(p);\n      return (p.x + p.y)*.7071 - mix(b.x, b.y, .5);\n      #elif SHAPE == 2\n      // Hexagon.\n      p = abs(p);\n      return max(p.x*.8660254 + p.y*.5, p.y) - mix(b.x, b.y, .5);\n      #elif SHAPE == 3\n      // Octagon.\n      p = abs(p);\n      return max((p.x + p.y)*.7071, max(p.x, p.y)) - mix(b.x, b.y, .5);\n      #else\n      // Circle.\n      return length(p) - (b.x + b.y)/2.;\n      #endif\n      \n      //p = abs(p) - b;\n      //p = p*.8660254 + p.yx*.5;\n      //return max(p.x, p.y);\n      \n      //p = abs(p)-b;\n      //p = (p + p.yx)*.7071;\n      //return max(p.x, p.y);\n}\n\n\n// The cell shape: This is just a union of four offset shapes, but it could\n// be anything you can dream up. This particular random shape exceeds the\n// boundaries of the cell, so surrounding cells need to be accounted for.\n\nfloat cellShape(vec2 p, vec2 ip){\n    \n    float d = 1e5;\n    \n    for(int i = 0; i<4; i++){\n    \n        // Four random values.\n        float fi = 1./(1. + float(i));\n        vec4 rnd = vec4(hash21(ip + .15*fi), hash21(ip + .23*fi), \n                        hash21(ip + .32*fi), hash21(ip + .41*fi));\n        \n        // Offset position.\n        vec2 q = \n        #ifdef RAND_ROT\n        // Optional random rotation.\n        r2(floor(hash21(ip + .07*fi)*4.)*3.14159265/4.)*\n        #endif\n        p - (rnd.xy - .5)*1.5;\n    \n        // Render a square, diamond, or whatever.\n        //float shape = sBoxS(q, .1 + rnd.zw*.3, min(rnd.z, rnd.w)*.07);\n        float shape = dist(q, .1 + rnd.zw*.3); // Rectangular dimensions.\n        //float shape = dist(q, vec2(.1 + length(rnd.zw)*.2)); // Square.\n        \n        // Take the minimum (union) of all combined shapes.\n        d = min(d, shape);\n    \n    }\n    \n    // Holes... Didn't work. :)\n    //d = abs(d  + .135) - .135;\n    \n    return d; // Return the random distance, or bound.\n    \n}\n\n\n\n// Constructing the grid pattern: Render a random shape in each cell.\nvec4 gridPattern(vec2 p, float sf){\n    \n    const vec2 sc = vec2(1);\n    \n    vec3 col = vec3(1);\n    \n    float alpha = .9;\n    float d = 1e5;\n    \n    // The cell shapes exceed the cell boundaries, which means covering all \n    // surrounding cells that the shape covers. In this case, there are 9.\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n          \n            // Local cell coordinates and cell ID.\n            vec2 cntr = vec2(i, j) - .5;\n            vec2 q = p;\n            vec2 ip = floor(q/sc - cntr) + .5; \n            q -= ip*sc;\n        \n            // Cell shape.\n            float c = cellShape(q, ip);\n            \n            // Using the cell ID to produce some random number.\n            vec2 rnd = vec2(hash21(ip/23.), hash21(ip/113.)) - .5;\n            rnd.y = smoothstep(.985, .997, sin(rnd.y*6.2831 + iTime/2.)*.5 + .5);\n            \n            // Feeding the random cell-ID-based value into IQ's cool palette formula\n            // to produce the shape color.\n            #if PALETTE == 1\n            // Earth tones.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2. + vec3(0, 1, 2)))/3.5;\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol*vec3(1.8, .9, .3), 1.), rnd.y); \n            #else\n            // Vibrant palette.\n            vec3 cellCol = (.5 + .46*cos(rnd.x*6.2831/2.75 + vec3(0, 1, 2) + 2.2));\n            // Blinking highlights.\n            cellCol = mix(cellCol, mix(cellCol, cellCol.xzy, .6), rnd.y); \n            #endif\n            \n            // Greyscale.\n            //cellCol = vec3(dot(cellCol, vec3(.299, .587, .114)))/1.5;\n            \n            // Using the shape distance to produce a bit of shading.\n            float sh = max(.5 - c/.1, 0.)*max(1. - dot(q, q)*.5, 0.)*2.5;\n            \n            // Rendering to the canvas. This is the way I like to do it, but you can\n            // use whatever system you're comfortable with. The following are just some\n            // Photoshop type laters: Shadow, outer edge, shaded color and an inner\n            // edge for decoration.\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(c) - .01))*.5*alpha);\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c) - .01)));\n            col = mix(col, cellCol*sh, (1. - smoothstep(0., sf, c))*alpha);//\n            col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(c + .06) - .005)));\n            \n            // Keeping a copy of the minimum overall distance for the layering routine.\n            d = min(d, c);\n\n        }\n    } \n    \n    // Return the shaded shape color and associated distance.\n    return vec4(col, d);\n    \n}\n\n// Layering the grid pattern above.\nvec3 layeredPattern(vec2 p, vec3 col, float sf){\n    \n\n    // Frequency (associated with scale) and alpha (transparency) values.\n    float freq = 1., alpha = 1.;\n    \n    for(int i=0; i<4; i++){\n    \n        // Random values based on layer count.\n        float fi = 1./(1. + float(i));\n        vec2 rnd = vec2(hash21(vec2(0) + .1*fi), hash21(vec2(0) + .2*fi))*2.;\n        \n        // Render this particular grid layer.\n        \n        // Color and distance value.\n        vec4 gCol = gridPattern((p - rnd)*freq, sf*freq);\n        // Mix a drop shadow, edge and layer color onto the previous layer.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8.*freq, abs(gCol.w) - .01))*.5*alpha);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*freq, abs(gCol.w) - .01))*alpha);\n        col = mix(col, gCol.xyz, (1. - smoothstep(0., sf*freq, gCol.w))/freq*alpha);\n        \n        // Increace the frequency\n        freq *= 1.4;\n        alpha *= .92;\n    }\n    \n    /*\n    // Overlayed diagonal stripe pattern.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = smoothstep(0., sf, pat)*.5 + .65;\n    col *= pat;\n    */\n    \n    return col; // Overall texture value.\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Screen coordinates: They're already in aspect correct form,\n    // so tranlation and scalar resizing is all that is necessary.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Scale and translation.\n    const float sc = 1.5;\n    vec2 p = uv*sc + vec2(1, .25)*iTime/5.;\n    \n    // Coordinate perturbation.\n    p += vec2(n2D(p*24.), n2D(p*24. + 5.))*.004;\n    \n    // Smoothing factor.\n    float sf = sc/iResolution.y;\n    \n    // Background color -- Most of this will be covered with colored shapes.\n    vec3 bg = vec3(.05);\n    \n    // Two layered pattern samples. The second will be used for \n    // highlighting.\n    float sDist = 3./450.;\n    vec3 col = layeredPattern(p, bg, sf);\n    vec3 col2 = layeredPattern(p - normalize(vec2(1, 1))*sDist, bg, sf);\n    \n    // Two bump values. One from each direction.\n    float b = max(dot(col2 - col, vec3(.299, .587, .114)), 0.)/sDist;\n    float b2 = max(dot(col - col2, vec3(.299, .587, .114)), 0.)/sDist;\n    \n    \n    // Applying some subtle fBm noise.\n    float ns = fBm(p*40.)*.8 + .5;\n    col *= ns;\n\n    \n    // Adding the bump highlights.\n    col = col*(vec3(.2, .4, 1)*b*b*.005 + vec3(1, .15, .05)*b2*.04 + .6);\n\n    \n\n    /*\n    // Subtle diagonal pattern overlay. Not used.\n    float pat = (abs(fract((p.x - p.y)*64.) - .5)*2. - .125)/64./2.;\n    pat = .25 + smoothstep(0., sf, pat);\n    col *= pat;\n    */\n \n    /*\n    // Cell borders.\n    vec2 q = abs(fract(p) - .5);\n    float bord = max(q.x, q.y) - .5;\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf*4., abs(bord) - .0025))*.75);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(bord) - .0025)));\n    */\n    \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col*vec3(1, .05, .15), col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n    // Rought gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}