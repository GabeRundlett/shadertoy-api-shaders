{
    "Shader": {
        "info": {
            "date": "1483047589",
            "description": "Algorithm for leading a target (aiming ahead so target can be hit). And some crappy gfx.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGSR1",
            "likes": 11,
            "name": "Leading a target",
            "published": 3,
            "tags": [
                "physics"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 654
        },
        "renderpass": [
            {
                "code": "#define SCALE fwidth(g_uv).x\n\nvec2 g_uv;\n\nfloat drawCircle(vec2 p, float r) { return smoothstep(r, r + SCALE*4., length(g_uv - p)); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 rotate(vec2 point, float angle)\n{\n    return vec2 (point.x * cos(angle) - point.y * sin(angle),  point.y * cos(angle) + point.x * sin(angle));\n}\n\nfloat box2d(vec2 pos, vec2 pivot, float angle, vec2 size,float outline)\n{\n    vec2 uv = rotate(g_uv - pos, -angle)+pivot;\n    return smoothstep(0., outline*SCALE,max(abs(uv.x)-size.x, abs(uv.y)-size.y));\n}\n\n\n////////////////////////////    \n// This shader demonstrates how to intercept a target with a projectile.\n//\n// we can see all the potential shots that can be made at time t as a sphere extending in all directions. \n// this means we can solve the hit position as ray and sphere intersection, where the sphere radius is expanding with time.\n// the ray is the position and the velocity of the target we are attempting to shoot.    \n// \n// parametric equation of a sphere : x^2 + y^2 + z^2 = r^2\n// = x^2 + y^2 + z^2 - r^2 = 0\n// = p^2 - r^2 = 0\n// \n// out of all those positions, we are interested in the ones that intercept our target,\n// which we can describe as initial position and a velocity vector. \n// Equation of ray : o + d*t\n//\n// Center of the gun object is c.\n// To solve the equation at the center we offset by c\n// so the p term becomes o+t*d-c\n// radius r expands with time t\n//\n// p * p - r*t * r*t = 0\n// p = o + d*t - c\n// \n// when p is substituted in with ray equation, p^2-r^2 = 0 becomes\n// (o + D*t - c)^2 - (r*t)^2 = 0\n// \n// expanded:\n// -------------------------\n// o^2+odt-oc+odt+(dt)^2-cdt-co-cdt+c^2\n// \n// rearranged:\n// --------------\n// (dt)^2-(rt)^2+2odt-2cdt-2co+o^2+c^2\n// \n// we want to solve for t to get the interception time. The equation is a polynomial of 2nd degree, and we can apply\n// the quadratic formula to solve for T (https://en.wikipedia.org/wiki/Quadratic_formula).\n// to do that, we need to rearrange a bit to get the coefficents for quadratic equation\n//\n// -b Â± sqrt (b * b - 4 * a * c)\n// -----------------------------------\n//                2*a \n//////////////////////////////\n// solve for a \n// (combining terms that have t^2):\n// -------------------------\n// (td)^2 = t^2*d^2\n// (rt)^2 = r^2*t^2\n// so (t^2*d^2)+(r^2*t^2)\n// = (d^2-r^2) t^2\n// a = d^2-r^2\n//////////////////////////\n// solve for b \n// (combining terms that have t, which are 2odt and -2cdt)\n// = (2od-2cd) t\n// b = 2*(od-cd)\n////////////////////////\n// everything else = c\n// c = -2co+o^2+c^2\n////////////////////////\nfloat timeOfImpact(float S, vec3 C, vec3 O, vec3 D)\n{\n    \n    float a = dot(D, D) - (S * S);\n    float b = 2.0 * (dot(O, D) - dot(C, D));\n    float c = -2. * dot(C, O) + dot(O, O) + dot(C, C);\n    float disc = b * b - 4.0 * a * c;\n    //if the discriminant is negative, cannot hit the target.\n    if (disc < 0.0) return -1.;\n    float d1 =  (-b-sqrt(disc))/(2.*a);\n    float d2 =  (-b+sqrt(disc))/(2.*a);\n    return max(d1, d2);\n}\n\n/////////////////////////////\n//////// Drawing code\n/////////////////////////////\nvoid drawGun(vec2 C, vec2 dir, inout vec4 color)\n{\n    float gun = box2d( C, vec2(-.02,.0), atan(dir.y, dir.x), vec2(.02, .005),3.);\n    gun = min(gun, drawCircle(C-vec2(.0, .0), 0.01));\n\tfloat s=.0;    \n    for (int i = 0; i < 2;++i)\n    {\n    \ts += sin(5.+float(i)*1.15+g_uv.x*float(i+1)*10.)*(1./float(i+1))*.02;\n    }\n    float m = smoothstep(0.0, SCALE*2., g_uv.y+s+.23);\n    gun=min(gun, m);\n\tvec4 gunColor = vec4(vec3(.6, .5 ,.2)*(1.-gun)*.45,1.0);\n    gunColor=mix(gunColor, gunColor*texture(iChannel2, g_uv), .3);\n    color = mix(gunColor, color, gun);\n}\n\nvoid drawBullet(vec2 pos, vec2 dir, float T, float TOI, inout vec4 color)\n{\n    if(T>TOI || T<0.) return;\n    float bullet = box2d(pos, vec2(.0), atan(dir.y, dir.x), vec2(.008, .002),2.);\n    vec4 bcol = vec4(1.0)*(1.-bullet);\n    \n    float smoke = box2d(pos-dir*.02, vec2(.0), atan(dir.y, dir.x), vec2(.015, .005),2.);\n    smoke = clamp(dot(normalize(g_uv-pos), -dir), .0, 1.0); \n    smoke=pow(smoke, 17.0)*(.08/sqrt(length(g_uv-pos)));\n    smoke = smoothstep(.0, .5, smoke*.6);\n    bullet+=smoke;  \n    color = mix(bcol, color, bullet);\n    color = mix(texture(iChannel1, g_uv), color, 1.-smoke);\n}\n\nvoid drawTarget(vec2 TPOS, vec2 D, float T, float TOI, inout vec4 color)\n{\n    if (T > TOI)\n    {\n        // Explosion\n        float target = drawCircle(TPOS, 0.05/( (1.0+(T-TOI)*50.)));\n        float r = texture(iChannel0, floor(T*6.0)/10.+(g_uv-TPOS)*15.).r;\n        vec4 expCl = mix(vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0), r);\n        expCl=mix(expCl,color,clamp(T-TOI, 0.0, 1.));\n        \n        vec4 blastc=vec4(1.0);\n        float d=1./(.05+length(g_uv-TPOS));\n        float bt=1./(.02+(T-TOI));\n        color = mix(expCl, color, target);\n        color += vec4(d*bt)*.005;\n        \n    }\n    else\n    {\n        // plane\n\t\tfloat target = box2d(TPOS, vec2(.0),atan(D.y, D.x),vec2(.017, .0001),2.);\n\t\ttarget = min(target, box2d(TPOS+D*.02, vec2(-.0, .01),atan(D.y, D.x)-.5,vec2(.002, .01),2.));\n\t\ttarget = min(target, box2d(TPOS+D*.02, vec2(-.0, .01),atan(D.y, D.x)+3.55,vec2(.002, .01),2.));\n    \tvec4 tcol = vec4(.2, .6, .4, 1.)*texture(iChannel1, (g_uv-TPOS)*10.);;\n    \tcolor = mix(tcol, color, target);\n    }\n}\n\nvoid drawClouds(inout vec4 color)\n{\n    vec2 uv = g_uv;\n    float t=iTime*.0025;\n    \n    vec4 ncol = texture(iChannel2, g_uv*.2 + vec2(t*1. ,.0)).rrrr*.4;\n    ncol +=     texture(iChannel3, g_uv*.4 + vec2(t*2. , -1.0*t)).rrrr*.5*.5;\n    ncol +=     texture(iChannel2, g_uv*.5 + vec2(t*4. , -2.0*t)).rrrr*.5*.5*.5;\n    \n    ncol*=.7*max(.0, (0.5+g_uv.y));\n    ncol=smoothstep(0.1, .3,ncol);\n\tcolor=mix(color,ncol, ncol.r);\n    color=clamp(color, 0.0, 1.0);\n}\n\nvoid drawBG(inout vec4 color)\n{\n    float s = .0;\n    for (int i = 0; i < 2;++i)\n    {\n    \ts += cos(float(i)*1.15+g_uv.x*float(i+1)*15.)*(1./float(i+1))*.02;\n    }\n \tfloat m = 1.-smoothstep(0.0, SCALE*2., g_uv.y+s+.15);\n    vec4 mcol = vec4(vec3(.6, .7, .4)*m*.5,1.0);\n    mcol = mix(mcol, texture(iChannel2, g_uv*.7), .2);\n    color = mix(mcol, color, 1.-m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragColor = mix(vec4(.3, .4, .6, .0)*1.7, vec4(0.0, .4, .7, .0)*1.1, 0.1+fragCoord.y/iResolution.y);\n    \n    float T = iTime;\n    float S = .35; \t\t\t       // speed of the projectile\n\tvec3 C = vec3(0.0, -0.21, .0); // position of the cannon\n\tvec3 O = vec3(-0.4, 0.0, .0);  // position of the target\n\tvec3 D = vec3(0.3, 0.0, .0);   // velocity of the target\n\n\tg_uv = ((fragCoord.xy / iResolution.xy)-vec2(0.5))*vec2(1.0, iResolution.y/iResolution.x);\n    \n    // some variation on the target velocity\n    const float INTERVAL = 5.; // frequency of scene looping\n    float seed = floor(T/INTERVAL);\n    float rnd=rand(vec2(seed));\n    D.xy=rotate(D.xy, rnd*.5);\n    O.y+=rnd*.1;\n    T=mod(T, INTERVAL);\n    \n    // offsetting the simulation so cannon appears not to shoot immediately.\n    T-=1.5;\n    \n    vec2 TPOS = (O+D*T).xy;\n    float projectile = 999.0;\n    \n    vec2 pd = vec2(.0, 1.0);\n    float TOI = timeOfImpact(S, C, O, D);\n    \n    if (TOI > .0)\n    {\n        // accelerating down if hit\n        if (T > TOI) TPOS += pow((T-TOI),2.)*vec2(.0,-.15);\n        // position of interception\n        vec2 hitP = (O+D*TOI).xy;\n        // direction of projectile\n        pd = normalize(hitP - C.xy).xy;\n    }\n    drawClouds(fragColor);\n    drawBG(fragColor);\n    drawBullet(C.xy+pd*T*S,pd,T,TOI,fragColor);\n    drawGun(C.xy, pd,fragColor);\n    drawTarget(TPOS, D.xy, T, TOI, fragColor);\n    \n    fragColor=mix(fragColor,vec4(.0),smoothstep(0.48,0.52,max(abs(g_uv.x), abs(g_uv.y*iResolution.x/iResolution.y))));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}