{
    "Shader": {
        "info": {
            "date": "1523332261",
            "description": "An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.",
            "flags": 0,
            "hasliked": 0,
            "id": "XdyyDV",
            "likes": 145,
            "name": "Shuto Highway 83",
            "published": 3,
            "tags": [
                "sky",
                "city",
                "japan",
                "highway",
                "airliners",
                "squids",
                "atm",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "blackjero",
            "viewed": 19479
        },
        "renderpass": [
            {
                "code": "// Shuto Highway 83 by Jerome Liard, April 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XdyyDV\n//\n// An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. \n// The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.\n//\n// June 2021 update:\n// - Replaced the code by the original non preprocessed one.\n// - Forced more loops (on 2 gradient evals) seems to have shortern shadertoy compilation by a couple seconds.\n//\n// I tried to go for a Japanese urban look with a mix of modern buildings and traditional tiled houses.\n// Building arrangements within a grid cell use this https://www.shadertoy.com/view/4tXcRl (that's what they were designed for in the first place)\n// But this time they are dda+raytraced instead of ray marched, which lifts limitation on height and perf constraints (no need to evaluate neighbors etc.).\n//\n// Tracing is a nested and composited dda/raytrace/raymarch hybrid;\n//\n//   1) raytrace ground infinite plane and highway drivable surface to reduce sdf melting on streets and highway vanishing point\n//   2) 3d DDA trace a regular grid [traceBuildings()]\n//      for each cell entered\n//         partition the cell with a random split arrangements of 4 bounding boxes, 1 per building (or house)\n//         raytrace all 4 bounding boxes (some calculations can be factorized, so it is not quite as bad as it sounds) [rayMarchCellObjects()]\n//            when we hit a box, ray march a house or a building inside [rayMarchParametricBuilding()]\n//            if there was a hit, calculate its normal and ray march for AO there\n//   3) independently of DDA (except for occlusion early return), ray march highways, street lamps, z=0 ground, and march for AO there too (most of this is culled by buildings)\n//   -> composite all the hits above as we go, early return everywhere we can etc. Note AO is not global (but it's ok enough)\n//   4) trace the scene again for shadows (ouch) and lit\n//\n// Other:\n//\n//   - The sky probe function might be of interest to some (uncomment the test_sky() line to see).\n//     It is a careful manual match of a reference hosek sky probe (see get_sky()) so that we don't have to do atmosphere calculations.\n//     I used a radial gradient curve picking UI (make one in 30 minutes with your favorite imgui), \n//     and found that biexponentials are able to match the r,g,b sky gradients pretty well.\n//   - The distance to curve algorithm (important for the highway and surrounding geom clip planes) might be of interest too, see evalHighway()\n//   - Unhandled divide by zeros occasionally create buggy horizontal lines mid screen, sorry...\n//   - I didn't want to rely on textures too much and was interested in volumetric detail, so it ended up flat-ish look overall\n//   - Building windows use the old trick of tracing a ray past the window, assuming constant floor heights, and return an infinite neon plane on the ceiling. From outside, the infinite neon planes sometimes \"leak\" past real walls, we don't care\n//   - If you look up there are airliners in the sky. \n//     Their silhouette is a pretty close match of and airbus as350 although in the final shader it's just some far away pixel vomit\n//   - No AA so can be a bit flickery... sorry\n//\n/// -------------------------------------------------------- turn stuff on and off\n\n/// trace building bounding boxes only\n///#define DEBUG_BUILDINGS_BOUNDS\n\n/// colorful debug showing the structure of the scene\n///#define DEBUG_COLORING\n\n#define HIGHWAY_CLIP\n#define BUILDINGS\n#define TILE_PERMUTATIONS\n#define ROOF_OBJECTS\n#define TRY_BALANCE_SIZES\n#define OFFICE_NEON\n#define WINDOWS_GROUND_REFLECTION\n#define HIGHWAYS\n#define WIDE_STREETS_LAMPS\n#define HIGHWAY_LAMPS\n#define LCD_PANELS\n#define SHADOWS\n#define AO\n#define HORIZON_HACK\n\n#define STICKY_MOUSE false\n\n/// -------------------------------------------------------- perfs and shader crash raindances\n\n/// this shader worked natively everywhere I tested, \n/// but webgl takes much longer to build and sometimes crashes, hitting seemingly random resource limits or timeouts\n/// there has been cases where I had to force a loop to prevent driver crashes (even natively),\n/// and there has been cases where where fiddling with for loops led to important perf variations\n/// without ability to check the compiler output it is a bit of a raindance contest\n\n/// try bend for loops to our will, this is from Fabrice's excellent page https://shadertoyunofficial.wordpress.com/\n#define FORCE_LOOP +min(0,iFrame)\n\n/// ----\n/// top traceCity loop\n#define FORCE_LOOP_LV0 FORCE_LOOP\n///#define FORCE_LOOP_LV0\n///#define UNROLL_LOOP0\n/// ----\n/// dda cell iteration loop\n/// if not forcing loop here: compiler once crashed on GTX970 (not webgl), malloc fail\n#define FORCE_LOOP_LV1 FORCE_LOOP\n///#define FORCE_LOOP_LV1\n/// ----\n/// per dda cell iteration on 4 buildings\n/// force loop was a little bit slower on radeon 5670 at some point in the past\n#define FORCE_LOOP_LV2 FORCE_LOOP\n///#define FORCE_LOOP_LV2\n/// UNROLL_LOOP2: manual unroll (GTX970 got much slower at some point in the past)\n///#define UNROLL_LOOP2\n/// ----\n/// sd_ParametricBuilding sdf ray march loop\n#define FORCE_LOOP_LV3 FORCE_LOOP\n///#define FORCE_LOOP_LV3\n/// ----\n\n/// ----\n/// ao loop\n#define FORCE_LOOP_AO FORCE_LOOP\n///#define FORCE_LOOP_AO\n/// ----\n\n/// ----\n/// sdf bits loop\n#define FORCE_LOOP_S FORCE_LOOP\n///#define FORCE_LOOP_S\n/// ----\n\n/// ----\n/// airliners loop\n#define FORCE_LOOP_B FORCE_LOOP\n///#define FORCE_LOOP_B\n/// ----\n\n// those defines weren't in the first version of the shader \n// they cut a few seconds of compilation time on shadertoy\n#define FORCE_GRAD_LOOP_BUILDING\n#define FORCE_GRAD_LOOP_SCENE\n\n// -------------------------------------------------------- lib stuff\n\n#define PI 3.141592654\n#define FLT_MAX /* FLT_MAX */1000000. \n#define SQR2 1.414213562\n\n#define RED\tvec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define BLEU_ARDOISE vec3( 0.32, 0.38, 0.47 )\n#define GRIS_ARDOISE vec3( 0.35, 0.36, 0.41 )\n\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\n\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec4 )\n\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n// for rcp_decay, max x with something < 0 to prevent infinity and cull the other side\nfloat rcp_decay( float x ) { return x / ( 1. + x ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }\nfloat exp_bell( float x, float r ) { x *= ( 1. / r ); return exp( -x * x ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nfloat smoothbump( float x, float s1, float e1, float s2, float e2 ) { return smoothstep( s1, e1, x ) * smoothstep( e2, s2, x ); }\nfloat cosbump( float x, float x0, float r ) { return ( 1. + cos( min( abs( ( x - x0 ) / r ), 1. ) * PI ) ) * 0.5; }\n// like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n// band, centered at 0... like smoothstep_c but different semantics\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n// range start,end\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\n// return range -pi,pi\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\n// in soft min don't go too crazy with small values of k\n// those are not real min/max (returned values can exceed input values)\nfloat soft_min2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat soft_max2( float a, float b, float k ) { return -soft_min2( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\nfloat sum( vec3 v ) { return v.x + v.y + v.z; }\n// symmetrize/mirror x around a\nfloat fold( float x, float a ) { return x + 2. * min( 0., a - x ); }\nvec2 fold( vec2 p, vec2 o, vec2 n ) { float a = dot( p - o, n ); return p - 2. * min( a, 0. ) * n; }\n// acos overflow bugs (subtle ot not) are the worse\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\nvec4 safe_acos( vec4 x ) { return acos( clamp( x, vec4(-1.), vec4(1.) ) ); }\n\n/// CLOSEST_POINT_TANGENT_TO_FUNC_21 calculates the distance to a 1d curve\n/// input:\n///  a_p               eval pos\n///  a_func            the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n///                    a_func can be a macro, it seems\n///  a_epsilon         epsilon used for derivative evaluation, must scale roughly with your working dimensions\n///                    else the distance estimation will disolve as your epsilon disappears in floating point additions\n///  a_num_iterations  num iterations - check actual quality of result to set this, often we just use 2\n///  a_t0              the iteraton parameter start value, affects iteration speed a lot\n///                    for a regular 1d function we use a_p.x\n///                    for a polar function start at calc_angle(a_p)\n/// output:\n///  a_ret             the return value is a vec4 where .xy is vector to closest point on curve and .zw the derivative (tangent at the closest point)\n///\n/// - a_func(t) returns vec2(t,your1dfunc(t)) for 1d functions\n/// - a_func(t) returns (yourpolarfunc(x)*unit_vector2(x)) for polar functions\n/// a_func can be a macro\n\n#define CLOSEST_POINT_TANGENT_TO_FUNC_21( a_ret, a_p, a_func, a_epsilon, a_num_iterations ) \\\n{ \\\n\t/* we use this method for distance to curve: http://www.geometrie.tugraz.at/wallner/sproj.pdf */ \\\n\t/* it is a bit different from https://iquilezles.org/articles/distance in that since it is iterative there is a potential quality/perf trade off */ \\\n\tvec2 _p = a_p, _c, _dc; \\\n\tfloat _epsilon = a_epsilon; \\\n\tfloat _t = _p.x; /* t0, could be a parameter if the user knows better */ \\\n\tfor ( int _i = 0; _i < a_num_iterations; ++_i ) { \\\n\t\t_c = a_func( _t ); \\\n\t\t_dc = ( a_func( _t + _epsilon ) - _c ) * ( 1. / _epsilon ); \\\n\t\t_t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); /* simplification of _t += dot( _dc, _q - _c ) / dot( _dc, _dc ); where _q is _p.xy projected on (_c,_dc) line */ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\n// https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin_pol( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n// v is the eval direction, v and axis assumed normalized and cos_v_axis = dot(v,axis)\nfloat spherical_gaussian( float cos_v_axis, float amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, vec3 sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\n\n// https://iquilezles.org/articles/functions\nfloat impulse( float a, float x ) { float ax = a * x; return ax * exp( 1. - ax ); }\nvec2 impulse( vec2 a, vec2 x ) { vec2 ax = a * x; return ax * exp( vec2( 1. ) - ax ); }\n\nfloat biexp2( float x, float a, float b ) { return ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\nvec3 biexp2( vec3 x, vec3 a, vec3 b ) { return ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\n\n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n\tvec3 rgb = clamp( abs( mod( c.x * 6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\n/* grid multiplier range */ \\\n/* bounds b is cell \"0,0\" */ \\\n/* min_xs is pmin offset (in multiples of bounds size) */ \\\n/* max_xs is pmax offset (in multiples of bounds size) */ \\\nbtype mkbounds_unchecked_gx( btype b, type min_xs, type max_xs ) { type s = size( b ); btype ret = b; ret.pmin += s * min_xs; ret.pmax += s * max_xs; return ret; }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\\\n/* return identity in range start,start+len, and repeat mirror elsewhere */\\\ntype repeat_mirror_l( type x, type start, type len ) { return start + repeat_mirror( x - start, len ); }\\\ntype repeat_mirror_e( type x, type start, type end ) { return start + repeat_mirror( x - start, end - start ); }\\\n/* return identity in range start,start+len, and repeat elsewhere */\\\ntype repeat_e( type x, type start, type end ) { return start + repeat( x - start, end - start ); }\\\ntype repeat_b( type x, btype b ) { return b.pmin + repeat( x - b.pmin, b.pmax - b.pmin ); }\\\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n/* function returns 0 at x = half_width */ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); } \\\n/* function returns 0 at x = half_width */ \\\ntype tri_s( type x, type half_width, type half_spacing ) { return half_width - repeat_mirror( x, half_width + half_spacing ); } \\\n/* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ \\\n/* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ \\\n/* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ \\\ntype tri_b( type p, type s0, type e0, type s1, type e1) { type c = s0 + ( e1 + s1 ) * 0.5; return -tri_p( p - c, ( e1 - s1 ) * 0.5, ( e0 - s0 ) * 0.5 ); } \\\n/* same as above but with bounds */ \\\ntype tri_b( type p, btype b0, btype b1) { return tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\n// like smoothband() but repeated, using smoothstep as poor AA\n// - r is the half width of the stripes\n// - raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// - period is the distance between 2 consecutive stripes\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n// variation of stripes where multiple period overlap (stripes not centered on 0)\nfloat stripes2( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x - r, period * 0.5 ) ); }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW using \"integer stepped ranges\" settings\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nfloat hash11( float p ) { vec3 p3  = fract( vec3( p ) * HASHSCALE1 ); p3 += dot( p3, p3.yzx  + 19.19 ); return fract( ( p3.x + p3.y ) * p3.z ); }\nvec3 hash32( vec2 p ) { vec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 ); p3 += dot( p3, p3.yxz  + 19.19 ); return fract( ( p3.xxy  + p3.yzz  ) * p3.zyx ); }\n\n// hopefully stable hash (across gpus and/or webgl) functions, munged from iq's version https://www.shadertoy.com/view/XlXcW\n\nvec4 hash44_( ivec4 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference \n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference \n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\nvec2 hash22_( ivec2 p ) { return hash42_( p ).xy; }\nvec2 hash24_( ivec4 p ) { return hash44_( p ).xy; }\n\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_unit_vector_neg( vec2 p, vec2 cs ) { return vec2( cs.x * p.x + cs.y * p.y, -cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n// theta is the angle with the z axis, range [0,pi]\n// phi is the angle with x vectors on z=0 plane, range [0,2pi]\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { vec2 theta_vec = unit_vector2( theta ); return vec3( theta_vec.y * unit_vector2( phi ), theta_vec.x ); }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy ) { vec3 p = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z; return mkray( p, normalize( p ) ); }\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up ) { vec3 z = normalize( eye - center ); vec3 x = normalize( cross( up, z ) ); vec3 y = cross( z, x ); return mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ); }\n\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : FLT_MAX; }\n\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n\n// customize max of f(x)=0 and f(x)=x in the x in [ -r,r] interval\nfloat curved_max_vfunc_hard_bevel( float x, float r ) { return max( r, abs( x ) ); }\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); if ( x > r ) return x; return her2( x, r ); }\n// rr in 0,1, set < 1 if you want to see a flat bit\n// rr == 1 gives a soft bevel, slightly different shape and a bit more expensive than curved_max_vfunc_weld_quadric\nfloat curved_max_vfunc_round_bevel( float x, float r, float rr )\n{\n\tx = abs( x );\n\tif ( x > r ) return x;\n\tfloat a = rr * r; // make bevel radius relative to r (so rr is a 0,1 value, if you go above 1 yo get a discontinuity at 0)\n\tfloat cr = a * SQR2; // this is the radius of the circle used to make the round bevel\n\tvec2 c = vec2( r - a, r + a ); // center of round bevel is at (r-a,r+a) (on a y=1-x line that emanates from (r,r))\n\treturn c.y - sqrt( cr * cr - pow2( max( 0.0, x - c.x ) ) );\n}\n\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return soft_max2( a, b, k ); }\nfloat opI_hard_bevel( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_hard_bevel( a - c, r ); }\nfloat opI_round_bevel( float a, float b, float r, float rr ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_round_bevel( a - c, r, rr ); }\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_hard_bevel( float a, float b, float r ) { return -opI_hard_bevel( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 ); }\nfloat opS_hard_bevel( float a, float b, float r ) { return opI_hard_bevel( -b, a, r ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n// Band/border operations (extract a band from an sdf)\n// band c-r,c+r\nfloat opB_rc( float d, float r, float c ) { return abs( d - c ) - r; }\n// band -w,0\nfloat opB_inside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, -r ); }\n// band 0,w\nfloat opB_outside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, r ); }\n// band mi,ma\n// should be same as sd_bounds_range(d,mi,ma)\nfloat opB_range( float d, float mi, float ma ) { return opB_rc( d, ( ma - mi ) * 0.5, ( mi + ma ) * 0.5 ); }\n\n// trying many apis to see what sticks.\n\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n\tvec2 h = ( ma - mi ) * 0.5;\n\tp = abs( p - ( mi + ma ) * 0.5 );\n\tvec2 c = h - r;\n\tfloat mask = max( step( c.x, p.x ), step( c.y, p.y ) );\n\treturn mix( -r + max( ( p - c ).x, ( p - c ).y ), length( max( p - c, 0.0 ) ) - r, mask );\n}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n// see sd_bounds_repeat_range_range instead of sd_bounds_repeat_size_margin\nfloat sd_bounds_repeat_size_margin( float p, float size, float margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec2 p, vec2 size, vec2 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec3 p, vec3 size, vec3 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\n// repeat bounds with margin, (mi1,ma1) is included inside (mi,ma)\nfloat sd_bounds_repeat_range_range( float p, float mi, float ma, float mi1, float ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\nfloat sd_bounds_repeat_range_range( vec2 p, vec2 mi, vec2 ma, vec2 mi1, vec2 ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\n\n// https://learnopengl.com/#!PBR/Theory\n// http://graphicrants.blogspot.jp/\n// alpha = roughness*roughness and \"m stands for the microfacet normal... in practice you input the half vector for m\"\n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v / pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\n// I am not going to pretend anything is physically realistic here, but at least try to use standardized functions\n// v = wi\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, float kdiffuse, float kspecular, float roughness )\n{\n\tfloat F0 = 0.08;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; // else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n//\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n//\tfloat F = F_schlick( n_dot_h, F0 ); // can't be right\n\treturn ( ( kdiffuse * albedo * ( 1. / PI )\n\t\t\t   + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\n\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/ , more dark tones friendly than just pow(L,0.45)\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n// returns 0 if v component is zero, rcp else, pass s = sign( v ) (values for s are -1, 0, 1)\nvec3 zrcp( vec3 v, vec3 s ) { s = abs( s ); return s / ( ( s - vec3( 1. ) ) + v ); }\n\n// encapsulate dda iteration a little bit for readability\nstruct DDA3\n{\n\tvec3 start, v; // v = end - start\n\tvec3 s; // sign(v)\n\tvec3 f1; // spacing (as a fraction of v, not distance) between 2 grid lines, to be multiplied by v to get a vector\n\tvec3 f; // segment intersects unit grid at points i = dda.start + ( dda.t[k] + i * dda.t1[k] ) * dda.v\n\tvec3 c; // cell index we entered (coords of bottom left corner)\n\tint done; // iteration end condition\n\tvec3 am; // argmin used during iteration\n\tvec3 p; // which point we entered the cell from, or start, or end\n};\n\n// iterate on p = dda.start + ( dda.end - dda.start ) * dda.alpha such that p intersect canonical dda.a\n// supporting arbitrary cell size is not much more expensive so we do it\nDDA3 dda_init( vec3 a_start, vec3 a_end, vec3 a_size, bool a_finite )\n{\n\tDDA3 dda;\n\tdda.start = a_start;\n\tdda.v = a_end - a_start;\n\tdda.s = sign( dda.v ); // -1, 0, 1\n#if 0\n\tvec3 v_zrcp = zrcp( dda.v, dda.s );\n#else\n\tvec3 v_zrcp = vec3( 1. ) / dda.v; // divide by zero\n#endif\n\tvec3 cell_size_rcp = vec3( 1. ) / a_size;\n\tdda.c = floor( a_start * cell_size_rcp ); // start cell\n\tdda.f = ( ( dda.c + ( dda.s + vec3( 1. ) ) * 0.5 ) * a_size - a_start ) * v_zrcp; // go positive or negative direction, initial fractional t\n\n\t// do this only for dda_step_segment\n\tif ( a_finite ) dda.f = min( vec3( 1. ), dda.f + 1. - abs( dda.s ) ); // if the sign is 0, set t to 1, meaning we are done on this axis\n\n\tdda.f1 = dda.s * v_zrcp * a_size; // per axis grid steping as a fraction of v\n\tdda.done = 0;\n\tdda.am = vec3( 0. );\n\tdda.p = dda.start;\n\treturn dda;\n}\n\n// returns 1,0,0 if x is the min, 0,1,0 if y is the min, 0,0,1 if z is the min (function code is from iq's shader)\n// very good for shader because we don't have to use random access which is sometimes borked in surprising ways\nvec3 argminv( vec3 v ) { return step( v.xyz, v.yxy ) * step( v.xyz, v.zzx ); }\n\n// iterate on all cells intersecting the input segment\n// make sure you called dda_init with a_finite = true\n// dda.done == 1 is the loop exit condition\n//void dda_step_segment( inout DDA3 dda )\n//{\n//\tif ( sum( dda.f ) == 3. ) ++dda.done; // all 1. means we covered v and we should be at the end point\n//\telse\n//\t{\n//\t\tdda.am = argminv( dda.f );\n//\t\tdda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n//\t\tdda.c += dda.am * dda.s;\n//\t\tdda.f = min( dda.f + dda.am * dda.f1, vec3( 1. ) ); // next dda.f\n//\t}\n//}\n\n// iterate forever - if you don't care about iterating exactly the segment length, a bunch of things can be skipped\n// make sure you called dda_init with a_finite = false\nvoid dda_step_infinite( inout DDA3 dda )\n{\n\tdda.am = argminv( dda.f );\n\tdda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n\tdda.c += dda.am * dda.s;\n\tdda.f = dda.f + dda.am * dda.f1; // next dda.f\n}\n\nvec3 dda_point( in DDA3 dda, float f ) { return dda.start + dda.v * f; }\n\n// t0, t1 are t ranges along rays on each dimension, returns (union min, union max) range, ray intersects iff .y > .x\nvec2 intersect_ranges( vec3 t0, vec3 t1 )\n{\n\treturn vec2( maxcomp( vec3( min( t0.x, t1.x ), min( t0.y, t1.y ), min( t0.z, t1.z ) ) ),\n\t\t\t\t mincomp( vec3( max( t0.x, t1.x ), max( t0.y, t1.y ), max( t0.z, t1.z ) ) ) );\n}\n\nstruct Ranges_x4\n{\n\tvec2 rA, rB, rC, rD; // ranges along the ray, for each bound b[i]\n\tbounds3 bA, bB, bC, bD; // we could store bounds2 + height\n};\n\n// factorize and pack a few terms used in raytracing of 4 children bounds\n\nstruct Split4bSetup\n{\n\tvec3 drcp;\n\tfloat dz;\n\tvec3 dmargin;\n\tvec2 dmin, dmax;\n};\n\nSplit4bSetup setup_Split4b( Ray ray, vec2 amin, vec2 amax, vec2 margin )\n{\n\tSplit4bSetup set;\n\tset.drcp = vec3( 1. ) / ray.d; // divide by zero\n\tset.dmin = ( amin - ray.o.xy ) * set.drcp.xy;\n\tset.dmax = ( amax - ray.o.xy ) * set.drcp.xy;\n\tset.dz = ray.o.z * set.drcp.z;\n\tset.dmargin = vec3( margin * set.drcp.xy, 0. );\n\treturn set;\n}\n\n// --------------\n// |   |   | D  |\n// | A | B |----| amix.z\n// |   |   | C  |\n// --------------\n//   amix.x amix.y\n\nvoid trace_Split4b_xxy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xxy ) * set.drcp.xxy; // split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.y, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xxy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.y, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n// -----------------\n// |   |   |   |   |\n// | A | B | C | D |\n// |   |   |   |   |\n// -----------------\n//   amix.x amix.y amix.z\n\nvoid trace_Split4b_xxx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xxx ) * set.drcp.xxx; // split axis described in amix are x,x,x\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xxx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amix.z, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n//        -----------\n//        |  C |    |\n// amix.y |----| D  |\n//        |  A |----| amix.z\n//        |    | B  |\n//        -----------\n//           amix.x\n\nvoid trace_Split4b_xyy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xyy ) * set.drcp.xyy; // split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set_dmix.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set.dmin.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xyy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amix.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amin.x, amix.y, 0. ) + m, vec3( amix.x, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.x, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n\n//  -------------\n//  |   | D |   |\n//  |   |   |   |\n//  | A |---| C | amix.y\n//  |   | B |   |\n//  -------------\n//  amix.x amix.z\n\nvoid trace_Split4b_xyx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n\tvec3 set_dmix = ( amix - ray.o.xyx ) * set.drcp.xyx; // split axis described in amix are x,x,y\n\tret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set_dmix.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rC = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n\tret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\n\nvoid bound_Split4b_xyx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n\tvec3 m = vec3( margin, 0. );\n\tret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n\tret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.z, amix.y, h.y ) - m );\n\tret.bC = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.z ) - m );\n\tret.bD = mkbounds_unchecked( vec3( amix.x, amix.y, 0. ) + m, vec3( amix.z, amax.y, h.w ) - m );\n}\n\n// turn n relative sizes (unit don't matter, only respective sizes do) into n-1 unit size offsets\nvec2 fractions( vec3 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; return vec2( r.x, sum_f_xy ) / sum_f_xyz; }\nvec3 fractions( vec4 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; float sum_f_xyzw = sum_f_xyz + r.w; return vec3( r.x, sum_f_xy, sum_f_xyz ) / sum_f_xyzw; }\n\n// -------------------------------------------------------- shader begin\n\n/// expression is true when shadow has found a hit and is no longer interested in tracing the rest of everything - this helps quite a bit\n#define SHADOW_EARLY_RET(a_t) (shadow_trace&&((a_t)!=FLT_MAX))\n///#define SHADOW_EARLY_RET(a_t) false\n/// tweak this value to minimize grainy artifacts due to distance to highway center line (used for many things, facades, highway objects etc)\n#define CURVE_DISTANCE_EPSILON_OF_DEATH 0.001\n\n/// the number of iterations we need to trace in a dda cell is a bit less than a would be full scene trace,\n/// since we are already close to the surface thanks to the preliminary raytrace\n/// but there is no magic, and if you are standing on a roof top you need more steps to close parallel planes\n/// what we do is we give ebough steps (~70) but early return past a certain distance if there was no hit\n#define DDA_CELL_SDF_MARCH_MAX_ITERATIONS 70\n/// ...which is fine because DDA cell have an intrinsic max trace distance anyway, and we need to use it as it is a big optim (regardless of trace holes when we stand on roof tops)\n/// fun anecdote: I overlooked that *major* optimization and bumped into it by chance during final tuning when trying to fix the roof top coffee break camera :-) \n#define ENABLE_MAX_DDA_TRACE_DISTANCE\n\n#define MAX_DDA_ITER 37\n#define MAX_DDA_TRACE 640. \n#define MAX_HIGHWAY_TRACE 640. \n#define FADE_START 480. \n\n/// dda cell size, each cell is a tile then split into 4 children each containing a building\n#define CELL_SIZE vec3( 8., 8., 100. ) \n/// x = small spacing (back streets), y = large spacing (roads)\n#define CELL_SPACING vec2( 0.47, 1.3 ) \n\n/// TYPE_BUILDING: 0.,1.,2.,3 (=0+tile_child_index)\n/// TYPE_HOUSE: 4.,5.,6.,7 (=4+tile_child_index)\n#define TYPE_HIGHWAY 8.\n#define TYPE_ROAD 9. \n#define TYPE_SKY 10. \n\n#define MAX_BUILDING_HEIGHT 14.3 \n\n#define AO_BEGIN() \\\n\t{ /* ao algo from https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf macrofified to avoid repetition */ \\\n\t\tfloat _delta = 0.1, _a = 0.0, _b = 1.0; \\\n\t\tfor ( int _i = 0; _i < 5 FORCE_LOOP_AO; _i++ ) \\\n\t\t{ \\\n\t\t\tfloat _fi = float( _i ); \\\n\t\t\tfloat _ao_t = _delta * _fi; \\\n\n///\t\t\tfloat d = sd_Object( p + delta * fi * n, 0, _t, _view_ray, ... ); // example\n\n#define AO_END(_ao_result) \\\n\t\t\t_a += ( _ao_t  - d ) * _b; \\\n\t\t\t_b *= 0.5; \\\n\t\t} \\\n\t\t_ao_result = max( 1.0 - 1.2 * _a, 0.0 ); \\\n\t} \\\n\nfloat sd_SurfaceFacade7( vec3 p, float dAll )\n{\n\tdAll -= -0.142857149;\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.649999976, 0.375 ); vec2 _hp1 = vec2( 0.625, 0.300000011 ); vec2 _hw1 = vec2( 0.150000005, 0.074999988 ); vec2 _2hp1_rcp = vec2( 0.800000011, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.171428576, 0. ) );\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.400000005, 0.234999999 ); vec2 _hp2 = vec2( 0.5, 0.300000011 ); vec2 _hw2 = vec2( 0.400000005, 0.015 ); vec2 _2hp2_rcp = vec2( 1, 1.666666626 ); _p2.xy -= _ci2; float _d2 = -tri_p( _p2.y, 0.015, 0.300000011 ); _d2 = opI( _d2, opB_range( p.z, -0.142857149, -0.128571435 ) );\n\tdAll = opS_hard_bevel( dAll, _d1, 0.007805752 );\n\tdAll = opU( dAll, _d2 );\n\treturn dAll;\n}\n\n#define FLOOR_HEIGHT /*FLOOR_HEIGHT*/0.6\n\nfloat sd_SurfaceFacade10( vec3 p, float dAll )\n{\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.570779979, 0.031555999 ); vec2 _hp1 = vec2( 0.569999992, 0.029999999 ); vec2 _hw1 = vec2( 0.560779988, 0.021556001 ); vec2 _2hp1_rcp = vec2( 0.877192974, 16.666667938 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.028571428, 0.100000001 ) );\n\tdAll = opS_hard_bevel( dAll, _d1, 0.003604186 );\n\treturn dAll; // return vec3(dAll,-0.028571428,0.100000001);\n}\n\nvec2 sd_SurfaceFacade0( vec3 p, float dAll )\n{\n\tdAll -= -0.100000001;\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.25, 0.362500011 ); vec2 _hp2 = vec2( 1., 0.300000011 ); vec2 _hw2 = vec2( 0.75, 0.137500002 ); vec2 _2hp2_rcp = vec2( 0.5, 1.666666626 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); _d2 = opI( _d2, opB_range( p.z, -0.200000002, 0. ) );\n\tvec3 _p3 = p; vec2 _ci3 = vec2( -0.75, 0.300000011 ); vec2 _hp3 = vec2( 1., 0.300000011 ); vec2 _hw3 = vec2( 0.112500011, 0.300000011 ); vec2 _2hp3_rcp = vec2( 0.5, 1.666666626 ); _p3.xy -= _ci3; float _d3 = -tri_p( _p3.x, 0.112500011, 1. ); _d3 = opI( _d3, opB_range( p.z, -0.200000002, 0. ) );\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.75, 0.362499982 ); vec2 _hp1 = vec2( 0.25, 0.300000011 ); vec2 _hw1 = vec2( 0.25, 0.147500008 ); vec2 _2hp1_rcp = vec2( 2, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, 0.008236314, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.200000002, -0.19428572 ) );\n\tdAll = opS_hard_bevel( dAll, _d2, 0.007714285 );\n\tdAll = opU_hard_bevel( dAll, _d3, 0.009999996 );\n\tdAll = opU_hard_bevel( dAll, _d1, 0.005900437 );\n\treturn vec2( dAll, p.z + 0.200000002 ); // return vec3(dAll,0,0.200000002);\n}\n\nvec2 sd_SurfaceFacade8( vec3 p, float dAll )\n{\n\tvec3 _p3 = p; vec2 _ci3 = vec2( 0.200000002, 0.685000002 ); vec2 _hp3 = vec2( 0.354999989, 0.459999978 ); vec2 _hw3 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp3_rcp = vec2( 1.408450722, 1.08695662 ); _p3.xy -= _ci3; _p3.xy = -tri_p( _p3.xy, _hw3, _hp3 ); float _d3 = maxcomp( _p3.xy ); _d3 = opI( _d3, opB_range( p.z, -0.057142857, 0.014285714 ) );\n\tvec3 _p1 = p; vec2 _ci1 = vec2( 0.200000002, 0.685000002 ); vec2 _hp1 = vec2( 0.354999989, 0.459999978 ); vec2 _hw1 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp1_rcp = vec2( 1.408450722, 1.08695662 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, 0.002559998, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.071428574, 0. ) );\n\tvec3 _p2 = p; vec2 _ci2 = vec2( 0.287499994, 0.684999942 ); vec2 _hp2 = vec2( 0.354999989, 0.459999978 ); vec2 _hw2 = vec2( 0.057500004, 0.109999984 ); vec2 _2hp2_rcp = vec2( 1.408450722, 1.08695662 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); /*band*/_d2 = opB_rc( _d2, 0.003154247, 0.0 ); _d2 = opI( _d2, opB_range( p.z, -0.085714288, -0.028571428 ) );\n\tdAll = opS_hard_bevel( dAll, _d3, 0.000975659 );\n\tdAll = opU_hard_bevel( dAll, _d1, 0.000975659 );\n\tdAll = opU_hard_bevel( dAll, _d2, 0.000138338 );\n\treturn vec2( dAll, p.z + 0.057142857 ); // return vec3(dAll,-0.085714288,0.014285714);\n}\n\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); x = min( a1 * x, a2 * x - a2 * p ); return x; }\n\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return ( 0.4 * hard_waves( p.y, 0.3, -1.6, 0.19 ) + 0.02 * abs( sin( p.x * 30. ) ) ); }\n\n// build diagonal scopes on the top edges of a bounds b \"extruded\" by h\n// they can be used as support planes for roof surface\n// return value is a 3d point local to those symetrized diagonal plane spaces, that can be used to map the roof surface\n// return value's .z is the distance to plane\n// slope_ctrl controls the steepness of the roof planes, 1. for identity\n// h is height of base house walls\n// b is base/ground 2d scope bounds\n// p is input world pos\n// we don't return a scope because we are mirroring things here, Scope's .b and .dcc would have no sense\nvec3 getRoofLocalX( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n\t// gable roof with tiled surface\n\tfloat hw = ( b.pmax.x - b.pmin.x ) * 0.5; // half width\n\tfloat cx = ( b.pmax.x + b.pmin.x ) * 0.5; // center\n\tfloat h2 = hw * slope_ctrl; // roof height\n\tvec2 v = vec2( abs( p.x - cx ), p.z - ( h + h2 ) );\n\tvec2 yy = normalize( vec2( hw, -h2 ) );\n\treturn vec3( p.y, dot( v, yy ), dot( v, perp( yy ) ) );\n}\n\nvec3 getRoofLocalY( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n\t// gable roof with tiled surface\n\tfloat hw = ( b.pmax.y - b.pmin.y ) * 0.5; // half width\n\tfloat cy = ( b.pmax.y + b.pmin.y ) * 0.5; // center\n\tfloat h2 = hw * slope_ctrl; // roof height\n\tvec2 v = vec2( abs( p.y - cy ), p.z - ( h + h2 ) );\n\tvec2 yy = normalize( vec2( hw, -h2 ) );\n\treturn vec3( p.x, dot( v, yy ), dot( v, perp( yy ) ) );\n}\n\n// rudimentary concept of \"scope\" for facade, roof surfaces etc.\nstruct Scope\n{\n\tvec3 p; // point in scope space, plane at p.z = 0\n\tbounds2 b; // bounds of scope shape, for clipping/shape cast\n\tfloat dcc; // df of scope shape (\"cookie cutter\"), for clipping/shape cast, should be included in .b for consistancy\n\tfloat t; // marching distance, used for error thresholds, \"inflating\" detail etc.\n};\n\nScope getScopeFacadeX( Scope base, float h, int select_side )\n{\n\tScope facade;\n\tfacade.b = mkbounds_unchecked( vec2( base.b.pmin.y, 0.0 ), vec2( base.b.pmax.y, h ) );\n\t// note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n\tif ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.y, base.p.z, abs( base.p.x - center( base.b ).x ) - size( base.b ).x * 0.5 );\n\telse if ( select_side == 1 ) facade.p = vec3( base.p.y, base.p.z, base.p.x - base.b.pmax.x );\n\telse if ( select_side == 2 ) facade.p = vec3( base.p.y, base.p.z, -base.p.x + base.b.pmin.x );\n\tfacade.dcc = sd_bounds( facade.p.xy, facade.b );\n\treturn facade;\n}\n\nScope getScopeFacadeY( Scope base, float h, int select_side )\n{\n\tScope facade;\n\tfacade.b = mkbounds_unchecked( vec2( base.b.pmin.x, 0.0 ), vec2( base.b.pmax.x, h ) );\n\t// note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n\tif ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.x, base.p.z, abs( base.p.y - center( base.b ).y ) - size( base.b ).y * 0.5 );\n\telse if ( select_side == 1 ) facade.p = vec3( base.p.x, base.p.z, base.p.y - base.b.pmax.y );\n\telse if ( select_side == 2 ) facade.p = vec3( base.p.x, base.p.z, -base.p.y + base.b.pmin.y );\n\tfacade.dcc = sd_bounds( facade.p.xy, facade.b );\n\treturn facade;\n}\n\nfloat sd_RoofTopObject2( float dsofar, Scope roof, float h, vec3 rnd )\n{\n\th *= 0.6 + 0.4 * mod( rnd.y, 4. ) * ( 1. / 3.333 );\n\tfloat roof_geom_max_height = 0.025; // a rough but conservative estimate of roof geometry height\n\th = max( 0., h - roof_geom_max_height ); // fixme: hack: make sure h is bounding height instead\n\t// select a small bounds b0 as a fraction of b, that we are going to repeat\n\tbounds2 b0 = mkbounds_unchecked_gx( roof.b, vec2( 0.1, 0.1 ), vec2( -0.7, -0.7 ) );\n\t// select a subgrid, range of b0 we want to keep, store range in b3\n\tvec2 gridsize = vec2( 1. + mod( rnd.x, 4. ), 1. );\n\tbounds2 b3 = mkbounds_unchecked_gx( b0, vec2( 0., 0. ), gridsize - vec2( 1. ) );\n\n//\tif ( dsofar < sd_bounds_range( roof.p, vec3( b3.pmin, 0. ), vec3( b3.pmax, h ) ) || roof.p.z < 0. ) return dsofar; // early return if the roof object is further than dsofar, not necesserarily a win...\n\n\t// inside that select a centered bounds b1\n\tbounds2 b1 = mkbounds_unchecked_gx( b0, vec2( 0.1, 0.1 ), vec2( -0.1, -0.1 ) );\n\tvec3 p2 = roof.p;\n\tp2.xy = repeat_b( p2.xy, b0 ); // remember: b1 must be centered inside b0!\n\n\tScope base = roof;\n\tbase.p = p2;\n\tbase.b = b1;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.dcc = opI( base.dcc, sd_bounds( roof.p.xy, b3 ) ); // only keep b3 area\n\n\t// select a subgrid (clip against)\n\tfloat d = opI( base.p.z - h, base.dcc );\n\td = opI( -base.p.z, d );\n//\td = opI( d, sd_bounds( roof.p.xy, mkbounds_unchecked_gx( b0, vec2( 0, 0 ), vec2( 2, 1 ) ) ) );\n\n\t{\n\t\t// facade\n\t\tScope facade = getScopeFacadeY( base, h, 3 );\n\t\tvec3 p3 = facade.p;\n\t\tp3.xy *= 2.; float d2 = sd_SurfaceFacade10( p3, facade.p.z );\n\t\td = opI( d2, d );\n\t}\n\n\t{\n\t\t// roof small border wall on top of object\n\t\tScope roof2 = base;\n\t\troof2.p.z -= h;\n\t\tfloat small_roof_border = opB_inside( roof2.dcc, 0.01 );\n\t\tsmall_roof_border = opI( small_roof_border, opB_inside( -roof2.p.z, roof_geom_max_height ) );\n\t\td = opU( d, small_roof_border );\n\t}\n\n\treturn opI( d, roof.dcc );\n}\n\nfloat sd_JPBuildingRoofTopWithObjects( float d, Scope roof, float roof_geom_max_height, bool enable_objects, vec3 rnd )\n{\n\t// roof small border wall\n\tfloat dborder = opB_inside( roof.dcc, 0.02 );\n\tdborder = opI( dborder, opB_inside( -roof.p.z, 0.05 ) );\n\t// roof ground tiles, perhaps this should be textured but never mind. we get more detail\n\tfloat tile_size = 0.05;\n\tfloat dtiles = -mincomp( tri_s( roof.p.xy, vec2( tile_size * 0.5 ), vec2( 0.005 ) ) );\n\tdtiles = opI( roof.dcc + 0.05, dtiles ) + roof.t * 0.004; // add t in spacing so we can see it from far away\n\tdtiles = opI_round_bevel( dtiles, opB_range( roof.p.z, -0.001, 0.0025 ), 0.00125, 0.75 );\n\td = opU( d, opU( dtiles, dborder ) );\n\tif ( enable_objects )\n\t{\n\t\t// parametric model for small features on roof\n\t\tScope roof_object_scope = roof;\n\t\tfloat droof_object = FLT_MAX;\n\t\tdroof_object = sd_RoofTopObject2( d, roof_object_scope, roof_geom_max_height, rnd );\n//\t\tdroof_object = opI( droof_object, -roof.p.z ); // cut all the bits below roof object level\n\t\td = opU( d, droof_object );\n\t}\n\treturn d;\n}\n\n#define ROAD_HALFWIDTH (1.)\n#define ROAD_WIDTH (ROAD_HALFWIDTH*2.)\n\n// distance to highway center line requires special care in this shader\nstruct NearestHighwayRetval\n{\n\tvec2 p; // query point\n\tvec2 pr; // query point in y repeat space\n\tfloat d; // distance to center line == length(d2f.xy)\n\tvec4 d2f; // .xy is vector to closest point, .zw is the tangent at closest point\n\tvec2 o_clip, n_clip; // clip plane so we can build clean clip facades for buildings in contact with the highway\n};\n\n// building sdf eval return value\nstruct ParametricBuildingRetval\n{\n\tfloat d, droof; // distance to building and distance to closest roof point for coloring\n\tvec3 windr; // distance to window in .x, windows 2d orientation in .zw (orientation is for better categorizing of pixels)\n};\n\n// modern buildings, most often square but can be clipped by nearby highways\nParametricBuildingRetval sd_Building( float t, vec3 p, bounds2 b, float h, NearestHighwayRetval nh, vec3 rnd )\n{\n\tfloat roof_geom_max_height = 0.3; // a rough but conservative estimate of roof geometry height\n\th -= roof_geom_max_height; // fixme: hack: make sure h is bounding height instead\n\n\t// some building base scope\n\tScope base;\n\tbase.p = p;\n\tbase.b = b;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.t = t;\n\n\tfloat d = -FLT_MAX; // opI( base.p.z - h, base.dcc ) is the base block, if you want to visualize it for debug\n\n\tvec3 windr = vec3( FLT_MAX );\n\n\t{\n\t\t// front facade\n\t\tScope facade = getScopeFacadeX( base, h, 3 );\n\t\tvec2 d1 = sd_SurfaceFacade0( facade.p, facade.p.z );\n\t\td = opI( d1.x, d );\n\t\twindr = vec3( d1.y, vec2( 1., 0. ) );\n\t}\n\n\t{\n\t\t// back facade with flat windows\n\t\tScope facade = getScopeFacadeY( base, h, 3 );\n\t\tfloat d2 = sd_SurfaceFacade7( facade.p, facade.p.z );\n\t\td = opI( d2, d );\n\t}\n\n\t#ifdef HIGHWAY_CLIP\n\tif ( nh.d != FLT_MAX )\n\t{\n\t\t// highway facing facade using nearest highway clip plane\n\t\tfloat d10 = dot( p.xy - nh.o_clip, nh.n_clip ) - ROAD_HALFWIDTH * 1.3;\n\t\tvec3 pr = vec3( dot( p.xy, perp( nh.n_clip ) ), p.z, -d10 ); // pr is the point in 2d facade space\n\t\tvec2 d3 = sd_SurfaceFacade0( pr, pr.z );\n\t\td = opI( d3.x, d );\n\n\t\t// pick this window if it's closest\n\t\twindr = mix( windr, vec3( d3.y, nh.n_clip ), step( abs( d3.y ), abs( windr.x ) ) );\n\t}\n\t#endif\n\n\tfloat droof = d; // save d before we clamped base on h, that will give us a consistent base dcc to build the roof on\n\td = opI( d, base.p.z - h );\n\n\t#ifdef ROOF_OBJECTS\n\t{\n\t\tScope roof = base;\n\t\troof.p.z -= h;\n\t\troof.dcc = droof;\n\t\td = sd_JPBuildingRoofTopWithObjects( d, roof, roof_geom_max_height, true, rnd ); // roof with border + objects on it\n\t}\n\t#endif\n\n\tParametricBuildingRetval ret;\n\tret.d = d;\n\tret.windr = windr;\n\tret.droof = FLT_MAX;\n\treturn ret;\n}\n\n// house with a tiled roof (Kyoto has lots of those, though the roof type is different and here is just a super crude abstracted version)\nParametricBuildingRetval sd_House( vec3 p, float t, bounds2 b, float h, NearestHighwayRetval nh )\n{\n\th -= 1.4; // fixme: hack: make sure h is bounding height instead\n\tvec2 inset = size( b ) * 0.01; // b is conservative, the house must be included inside it\n\tb.pmin += inset; // we want roof to hang over a bit so shrink the base a bit\n\tb.pmax -= inset;\n\t// some building base scope\n\tScope base;\n\tbase.p = p;\n\tbase.b = b;\n\tbase.dcc = sd_bounds( base.p.xy, base.b );\n\tbase.t = t;\n\t// the base block, if you want to visualize it for debug\n//\tfloat d = opI( base.p.z - h, base.dcc );\n\t// highway facing facade clipped using nearest highway clip plane\n\t#ifdef HIGHWAY_CLIP\n\tfloat d10 = nh.d != FLT_MAX ? dot( p.xy - nh.o_clip, nh.n_clip ) - ROAD_HALFWIDTH * 0.6 : FLT_MAX;\n\t#else\n\tfloat d10 = FLT_MAX;\n\t#endif\n\tbase.dcc = opI( -d10, base.dcc  ); // clip the base shape so that we still get a bit of roof hang over\n\n\tParametricBuildingRetval ret;\n\tfloat slope_ctrl = 0.7;\n\t// hip roof with tiled surface\n\tvec3 prfx = getRoofLocalX( p, slope_ctrl, base.b, h );\n\tfloat rfxd = opS( prfx.z - hf_SurfaceRoofTiles( prfx.xy ), prfx.z - ( -0.03 ) );\n\trfxd = opI( base.dcc - 0.15, rfxd ); // vertical cookie cut, wider for roof geom\n\tvec3 prfy = getRoofLocalY( p, slope_ctrl, base.b, h );\n\tfloat rfyd = opS( prfy.z - hf_SurfaceRoofTiles( prfy.xy ), prfy.z - ( -0.03 ) );\n\trfyd = opI( base.dcc - 0.15, rfyd ); // vertical cookie cut, wider for roof geom\n\t// add windows\n\tfloat dbottom = opI( base.dcc, opI( prfx.z, prfy.z ) );\n\tScope wall_s = getScopeFacadeY( base, h, 3 );\n\tvec3 pf = vec3( wall_s.p.xy * 1.0 - vec2( 0., -0.28 ), wall_s.p.z * 2. );\n\tvec2 df8 = sd_SurfaceFacade8( pf, dbottom );\n\tdbottom = opI( wall_s.dcc, df8.x ); // base + window carved in\n\tdbottom = opI( -d10, dbottom  ); // clip the base shape so that we still get a bit of roof hang over\n\tret.windr = vec3( df8.y, vec2( 0., 1. ) );\n\t// hip roof + roof surface\n\tret.droof = opU( opI( rfyd, prfx.z ), opI( rfxd, prfy.z ) ); // just roof surface\n\tret.d = opU( ret.droof, dbottom );\n\t// fill the empty bit under the roof (due to hang hover modeling),\n\t// which is visible when we did a highway clip\n\tfloat dz = ( p.z - h ) / slope_ctrl;\n\tret.d = opU( ret.d, opI( base.dcc + max( dz, 0. ), -dz ) );\n\treturn ret;\n}\n\n// highway curve as seem from above... wanted to do more complicated but stuck to the test curve instead\nvec2 sd_HighwayCurveXY( float x ) { float xt = repeat_mirror_e( x, -20., 20. ); return vec2( x, smoothstep( 0., 15., xt ) * 8. ); }\nvec3 sd_CameraCurveXY( float x ) { return vec3( x, sd_HighwayCurveXY( x ).y, 2.18 ); }\n\n// highways are repeated on y axis\nNearestHighwayRetval evalHighwaySetup( vec2 p )\n{\n\tNearestHighwayRetval hret;\n\thret.p = p.xy;\n\thret.pr = p.xy;\n\thret.pr.y = repeat_e( hret.pr.y, -35., 35. ); // note: mirror repeat wouldn't work\n\treturn hret;\n}\n\n// do the actual distance to highway evaluation\nNearestHighwayRetval evalHighway( vec2 p )\n{\n\tNearestHighwayRetval hret = evalHighwaySetup( p );\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNC_21( ret, hret.pr.xy, sd_HighwayCurveXY, CURVE_DISTANCE_EPSILON_OF_DEATH * p.x, 2 );\n\thret.d = length( ret.xy ); // distance to center line, used in several places so cache\n\thret.d2f = ret;\n\treturn hret;\n}\n\n#define HIGHWAY_HEIGHT 2.\n\n// used for lamp top silhouette\nfloat crochet( float x, float s2, float s1, float a, float b, float ym ) { return max( min( 0., ( -( x - b ) ) * s1 ), ym ) + min( 0., ( x - a ) * s2 ); }\n\n// street lamp object\n// hw is the road half width\n// p2.xy is cross section along u\n// p2.y is already symmetric (distance to center)\nvec2 sd_Lamps( float u, vec2 p2, float hw, float lw, float lamp_height, float period )\n{\n\tvec2 p3 = p2.xy - vec2( hw, lamp_height ); // center to lamp corner\n\tfloat dline = opI( -dot( p3.xy, -V60 ), p3.x ); // lamp line\n\tfloat width = 0.04; // pole width\n\tfloat dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); // slice\n\tdslice = opI( dslice, -p2.y ); // keep upper bit only\n\tfloat dpolebit = opB_outside( dline, 0.015 ); // only keep outside band\n\tdpolebit = opI( dpolebit, -p3.x - lw ); // subtract center bit\n\tfloat shrink = 0.004;\n\tfloat dlampbit = opB_inside( dline - shrink, 0.02 ); // only keep outside band, offset by shrink to ensure lamp geom stays in contact\n\tdlampbit = opI( dlampbit, -p3.x - lw ); // subtract center bit\n\tdlampbit = opI( dlampbit, -p2.y + lamp_height * 1.025 ); // only keep bit the top lamp bit (cut bottom)\n\tdlampbit += shrink; // make lamp geom smaller\n\tfloat d = opU( dpolebit, dlampbit );\n\td = opI( d, dslice - crochet( p3.x, 0.1, 0.75, -0.1, -0.05, -0.01 ) ); // extract a slice, and also make the slice slightly triangular\n\treturn vec2( d, dlampbit );\n}\n\n// there will be SIGN_N-1 signs visible per period (because of clipping in curvy bits)\n#define SIGN_N (3.)\n// pick a periodicity that doesn't expose the dodginess of the sdf in curvy sections\n#define SIGN_PERIOD (2.*20./SIGN_N)\n#define LDC_HEIGHT 0.3\n\n// highway signs (LCD screens)\nvec2 sd_HighwaySigns( float u, vec2 p2, float hw )\n{\n\tu = repeat_mirror_e( u, -20., 20. ); // same repeat as sd_HighwayCurveXY\n\tfloat period = SIGN_PERIOD;\n\tu += period * 0.5;\n\tfloat width = 0.04;\n\tfloat h2 = 1.2; // sign start h\n\tfloat h3 = LDC_HEIGHT; // sign end h\n\tfloat dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); // slice\n\tdslice = opI( dslice, -p2.y ); // keep upper bit only\n\tvec2 p3 = p2.xy - vec2( hw, h2 ); // center to lamp corner\n\tfloat d8 = opB_outside( p3.x, 0.015 ); // only keep outside band\n\td8 = opI( d8, p3.y );\n\td8 = opU( d8, sd_bounds_range( p3, vec2( -hw, 0. ), vec2( 0.05, h3 ) ) );\n\treturn vec2( opI( d8, dslice ), FLT_MAX );\n}\n\n#define HIGHWAY_PAVEMENT_RATIO 0.5\n\n// ray marched city bits, this is global and has nothing to do with the dda\n// return value: .x closest distance, .y closest distance to light emitter material\nvec3 sd_RayMarchedCityBits( vec3 p, int lod )\n{\n\tfloat d = p.z - 0.; // zero ground\n\n\tNearestHighwayRetval hret = evalHighway( p.xy );\n\n\tfloat hw = ROAD_HALFWIDTH; // r1 is the half width\n\tfloat h = HIGHWAY_HEIGHT;\n\n\tvec3 crvp = vec3( hret.d, p.z, ( hret.pr + hret.d2f.xy ).x ); // curve 3d pos\n\n\tfloat d2 = sd_bounds_range( crvp.xy, vec2( 0.0, h - 0.05 ), vec2( hw, h ) ); // highway cross section main block\n\tfloat d3 = sd_bounds_range( crvp.xy, vec2( hw * 0.9, h - 0.01 ), vec2( hw * 1.01, h + 0.2 * 1.4 ) ); // highway cross section border bit\n\td = opU( d, opU_hard_bevel( d3, d2, 0.05 ) );\n\n\t// supporting column\n\tvec2 ppp = vec2( h - p.z, hret.d );\n\tfloat d4 = ppp.y - ( 0.2 + 0.2 * pow( 1. - saturate( ppp.x * 2. ), 4. ) );\n\td4 = opI( -h + p.z, d4 );\n\td4 = opI( d4, sd_bounds_repeat_range_range( crvp.z, 0., 2., 0.5, 0.9 ) ); // subtract space between supporting columns\n\td =  opU( d, d4 );\n\n\tvec2 dlamps = vec2( FLT_MAX );\n\tvec2 dlamps2 = vec2( FLT_MAX );\n\n\t#ifdef HIGHWAY_LAMPS\n\tdlamps = sd_Lamps( crvp.z, vec2( hret.d, p.z - h ), hw, 0.25, 1.2, 3.2 );\n\td = opU( d, dlamps.x );\n\t#endif\n\t// add billboard signs on highways\n\tvec2 dsigns = sd_HighwaySigns( crvp.z, vec2( hret.d, p.z - h ), hw );\n\td = opU( d, dsigns.x );\n\n\t// add ground and pavements\n\tvec3 pp = p;\n\tpp.xy = repeat_mirror_l( p.xy, vec2( 0., 0. ), CELL_SIZE.xy );\n\tvec2 extra = -vec2( 0.15 ); // expand pavement a bit\n\t// for pavement we just repeat a round box with left, bottom side using wide road width and top, right sides using small road width\n\tfloat dpavement = sd_bounds_range_round( pp.xy, CELL_SPACING.yy * 0.5 + extra, CELL_SIZE.xy - CELL_SPACING.xx - extra, 0.075 );\n\tdpavement = opS( dpavement, ( hret.d - ROAD_HALFWIDTH * HIGHWAY_PAVEMENT_RATIO ) ); // empty the bit below the highway... that makes roadmarkings worse\n\tdpavement = opI_hard_bevel( dpavement, pp.z - 0.025, 0.02 ); // hard bevel to create border, clip with pavement top plane\n\td = opU( dpavement, d ); // add pavement\n\n\t#ifdef WIDE_STREETS_LAMPS\n\t// add lamps on wide roads\n\tfloat period = CELL_SIZE.x / 5.;\n\t// offset by peroid/2 to avoid putting lamps on crossing road (so we don't have to mask)\n\tdlamps2 = sd_Lamps( p.y + period * 0.5, vec2( repeat_mirror_l( p.x, 0., CELL_SIZE.x ), p.z )\n\t\t\t\t\t\t, CELL_SPACING.x * 1.3 // go on the pavement a bit\n\t\t\t\t\t\t, 0.08, 0.65, period );\n\td = opU( d, dlamps2.x );\n\t#endif\n\n\treturn vec3( d, opU( dlamps.y, dlamps2.y ), dsigns.x );\n}\n\nvec3 l2g( vec3 v ) { return pow( v, vec3( 1. / 2.22 ) ); }\nvec3 g2l( vec3 v ) { return pow( v, vec3( 2.22 ) ); }\n\nvec3 biexp2( float x, vec4 r, vec4 g, vec4 b ) { return biexp2( x * vec3( r.x, g.x, b.x ), vec3( r.y, g.y, b.y ), vec3( r.z, g.z, b.z ) ) * vec3( r.w, g.w, b.w ); }\n\n// manual match of one of the probes at http://cgg.mff.cuni.cz/projects/SkylightModelling/HosekWilkie_SkylightModel_SIGGRAPH2012_Supplement.pdf\nvec3 get_sky( vec3 v, float sun_cos_theta, float cheat_glow_scale )\n{\n\tvec3 l = vec3( sqrt( 1. - sun_cos_theta * sun_cos_theta ), 0., sun_cos_theta );\n\tfloat theta = safe_acos( v.z ); // in theory we don't need safe on normalized value, in practice you just never know\n#if 0\n\tvec2 u = vec2( 0.5 ) + normalize( v.xy ) * theta / PI;\n\tu = -perp( u ); // sun is on +x axis\n\tvec3 ref = g2l( texture( iChannel0, u ).xyz );\n\tif ( u.x > 0.5 ) return ref; // show reference image we try to match\n//\treturn BLUE;\n#endif\n\tfloat sd = dot( v, l );\n\tvec3 sky_top_color = vec3( 0.0182, 0.040, 0.076 ) * 0.95; // top sky color in linear space\n\tvec3 sky_top = sky_top_color;\n//\treturn ref - sky_top; // show remnant signal to match\n\tfloat x = ( 1. - theta / ( PI * 0.5 ) ) * 0.5;\n\tvec3 sky_radial = biexp2( x, vec4( 7.5, 15., 2., 0.1 ), vec4( 7.5, 10., 1.7, 0.14 ), vec4( 4., 5., 5.5, 0.075 ) ); // south curve\n//\treturn ref - sky_top - sky_radial; // show remnant signal to match\n\t// maching the sun glow is more awkward\n\tvec3 sun_glow = // note: this affects lighting a lot as we sample sun center color for the main light\n\t\tspherical_gaussian( sd, vec3( 0.8, 0.6, 0.3 ) * 1., 27. ) + \n\t\tspherical_gaussian( sd, vec3( 0.8, 0.4, 0.1 ) * 0.3, 8. );\n\tsun_glow *= cheat_glow_scale;\n//\treturn sun_glow;\n//\treturn ref - sky_top - sky_radial - sun_glow; // show remnant signal to match... should be black excepy for sun glow\n\treturn max( vec3( 0. ), ( sky_top + sky_radial + sun_glow ) ) * 1.;\n}\n\n// align sky probe with l direction\nvec3 get_sky( vec3 v, vec3 l, float cheat_glow_scale ) \n{ \n\tif ( l.z != 0. ) v.xy = rotate_with_unit_vector_neg( v.xy, normalize( l.xy ) );\n\treturn get_sky( v, l.z, cheat_glow_scale ); \n}\n\nvec3 test_sky( vec2 fragCoord, vec3 l )\n{\n\tvec2 u = fragCoord.xy / min( iResolution.x, iResolution.y );\n\tfloat theta = length( u - vec2( 0.5 ) ) * PI;\n\tfloat phi = calc_angle( u - vec2( 0.5 ) );\n\tvec3 v = zup_spherical_coords_to_vector( theta, phi );\n\tif ( theta > PI * 0.5 ) return MAGENTA;\n\treturn l2g( get_sky( v, l, 1. ) );\n}\n\n// tentative japanese city building palette\nvec3 get_building_palette( vec2 h )\n{\n\tvec3 ivory = vec3( 1, 0.85, 0.7 ); // c11\n\tvec3 white = vec3( 1., 1., 1. ); // c01\n\tvec3 c = mix( mix( BLEU_ARDOISE, GRIS_ARDOISE * 0.5, h.x ), mix( white, ivory, h.x ), h.y );\n//\tvec3 c = mix( mix( c00, c10, h.x ), mix( c01, c11, h.x ), h.y );\n\treturn c = mix( c, vec3( 0.6, 0.2, 0.2 ), smoothband( h.y - 0.5, 0.045, 0.01 ) * h.x * h.x * h.x ); // add rare reddish colors for occasional red tiles building\n}\n\nstruct NumberArg { float h; vec2 s; float r; float w; float m; };\n\n// only works with 3 and 8 because those are easy :-)\nfloat sd_Number3or8( vec2 p, int num, NumberArg a )\n{\n\ta.s *= 0.5;\n\tp.y = abs( p.y );\n\tfloat d = sd_bounds_range_round( p, vec2( -a.s.x + a.w + a.m, a.w * 0. ), a.s - a.w - a.m, a.r );\n\td = opB_range( d, -a.w, a.w );\n\tif ( num == 3 ) d = opS( d, sd_bounds_range( p, vec2( -a.s.x - a.w, -a.w ), vec2( 0., a.s.y * a.h ) ) );\n\treturn d;\n}\n\n// http://www.airbus.com/aircraft/passenger-aircraft/a350xwb-family/a350-900.html\n// -10,10 -> 64m\n// the silhouette is pretty accurate, modeled on top of blueprint\n// in this shader it just becomes pixel vomit covering a few pixels but I couldn't let go\nfloat sd_airliner_a350( vec2 p )\n{\n\tp.y = abs( p.y ); // vertical symmetry\n\tfloat db1 = p.y - 0.98 * rcp_decay( max( -0.666, -( p.x - 10. ) ) ); // fuselage front\n\tfloat db2 = p.y - 0.98 * rcp_decay( max( -0.666, p.x - -7.8 ) ); // fuselage back\n\tfloat db = opI( db1, db2 ); // fuselage\n\tfloat dw1 = -( curved_max_vfunc_weld_quadric( p.x + 3.85, 0.85 ) * 2.3 - ( 9.7 - p.y ) ); // back wing curve\n\tfloat dw2 = curved_max_vfunc_weld_quadric( p.x + 3.45, 0.85 ) * 1.26 - ( 9.2 - p.y ); // front wing curve\n\tfloat d3 = -( p.x - ( -0.8 ) ); // back wing curve flat bit\n\tdw1 = opU( dw1, d3 );\n\tfloat dw = opI( opI( dw1, dw2 ), -( p.x + 4. ) ); // wing\n\tfloat ds = -( ( smoothstep( -6.5, -9.8, p.x ) ) * 2.55 - p.y ); // stabilizer\n\tds = opI( ds, ( p.x + 6.5 ) );\n\tds = opS( ds, ( p.x + 8.94 + p.y * 0.4 ) ); // final tail bit\n\tfloat dt = opI( p.x + 8., p.y - 0.45 * rcp_decay( max( -0.666, ( p.x - -9.75 ) * 1. ) ) );\n\tds = opU( dt, ds ); // cut garbage\n\tvec2 pe = p - vec2( 1.5, 2.77 ); // engine pos\n\tfloat de = abs( pe.y ) - 0.8 * min( powerful_scurve( pe.x, 0.5, 4. ), powerful_scurve( 1. - ( pe.x - 1. ), 0.1, 4. ) ) + 0.3; // engine\n\treturn opU( de, opU( ds, opU( dw, db ) ) );\n}\n\n#define IS_LAMP 1\n#define IS_SIGN 2\n#define IS_WINDOW 4\n#define IS_ROOF 8\n\n// another blob of stuff, yey\nstruct TraceCityRetval\n{\n\tfloat t; // fixme: t or p. pick one? they might not be consistent\n\tvec3 p, n; // position, normal\n\tfloat ao;\n\tvec2 tile_index; // mostly for debug purpose\n\tfloat split_case; // split case [0,3] for coloring and randomization\n\tfloat sub_id; // children id in the 4 split\n\tint type;\n};\n\n#define is_equal_as_float( type, val ) (((type)!=(val))?0.:1.)\n\nvoid pack_info( inout TraceCityRetval ct, vec2 tile_index, float split_case, float sub_id ) { ct.tile_index = tile_index; ct.split_case = split_case; ct.sub_id = sub_id; }\nvoid pack_info1( inout TraceCityRetval ct, float t, vec3 p, vec3 n, float ao, int type ) { ct.t = t; ct.p = p; ct.n = n; ct.ao = ao; ct.type = type; }\n\n// to easily make a polar coords heart, draw the heart you want, lay out r(theta) in cartesian space, and manual curve match it\nfloat heart( float x ) { x = abs( repeat_e( x, -PI, PI ) ); return exp_decay( x * 1.2 ) * 0.7 + pow( max( x - PI * 0.5, 0. ) / ( PI * 0.5 ), 10. ) * 0.3; }\n\nfloat heart_grid( vec2 sp, vec2 c )\n{\n\tvec3 h = hash32( floor( sp / c ) );\n\tfloat s = 12. - 5. + 10. * h.z;\n\tvec2 sp3 = repeat( sp, c ) - c * 0.2 * h.xy;\n\tvec2 beat = impulse( vec2( 10. ), repeat( vec2( iTime, iTime + 0.08 ), vec2( 1.2 ) ) );\n\tfloat r = length( ( sp3 - c * 0.5 ) / ( 1. + beat * vec2( 0.3, 0.4 ) ) );\n\tfloat l = heart( calc_angle( sp3 - c * 0.5 ) );\n\treturn step( r, l * s );\n}\n\n// ika is japanese for squid\nfloat ika( vec2 p, float anim )\n{\n\tvec2 p2 = p.xy;\n\tp2.y += 0.25;\n\tp2.x = abs( p.x );\n\tfloat d = opI_soft2( dot( p2 - vec2( 0., 1. ), V45 ), -p2.y - 0.1, 6. );\n\td = opI_soft2( d, p2.y - 1., 10. );\n\tfloat a = calc_angle( p.xy );\n\tfloat r = length( p.xy );\n\ta = abs( repeat_e( a, -PI * 0.5, PI * 0.5 ) );\n\tfloat d3 = r - ( 0.3 + spherical_gaussian( cos( a - PI * mix( 0.4, 0.5, anim ) ), 0.8, 40. )\n\t\t\t\t\t + spherical_gaussian( cos( a - PI * mix( 0.1, 0.4, anim ) ), 1.1, 40. ) );\n\td3 = opI_soft2( p2.y, d3, 8. );\n\td = opU( d, d3 );\n\td = opS( d, length( ( p2 - vec2( 0.2 - anim * 0.075, 0.15 ) ) * vec2( 1. + anim * 0.5, 1. ) ) - 0.16 * ( 1. + anim * 0.4 ) ); // eyes\n\treturn d;\n}\n\nfloat ika_grid( vec2 sp, float anim, vec2 c ) { return ika( repeat_e( sp, -c, c ) * 0.1, 1. - anim ); }\n\nfloat star( vec2 p )\n{\n\tvec2 n = normalize( vec2( 1., 0.4 ) ); // slope controls\n\tp.x = abs( p.x );\n\tp = fold( p, vec2( 0. ), vec2( -0.309016994, 0.951056516 ) ); // perp(90-72=18)\n\tp = fold( p, vec2( 0. ), vec2( -0.809016994, 0.587785252 ) ); // perp(90-72/2=54)\n\tvec2 v = p - vec2( 0., 1 );\n\treturn opI( dot( v, n ), dot( v, vec2( -n.x, n.y ) ) );\n}\n\nfloat star_trail( vec2 p, out vec2 uv )\n{\n\tp = rotate_with_angle( p, radians( -25. ) * p.x );\n\tp.y *= exp( p.x * 2. );\n\tp.x *= exp( p.y * 1. );\n\tvec2 pmin = vec2( -0.4, -0.1 );\n\tvec2 pmax = vec2( 0.4, 0.1 );\n\tuv = ( p - pmin ) / ( pmax - pmin );\n\treturn sd_bounds_range( p, pmin, pmax );\n}\n\nvoid surfaceColor( TraceCityRetval ct, inout vec3 albedo, inout vec3 emitter, inout float road_marking_material )\n{\n\tif (  ct.type == IS_ROOF ) albedo = max( vec3( 0. ), contrast( albedo, vec3( 1.75 ) ) ); // enhance disparity of roof colors\n\n\tfloat aa = 0.003; // sorry...\n\tNearestHighwayRetval nh;\n\tfloat is_highway_columns_zone = 0.; // just columns\n\tfloat d_pavement_below_highway = FLT_MAX;\n\tfloat d_highway_columns_zone = FLT_MAX;\n\n\tif ( ( ct.sub_id == TYPE_HIGHWAY ) || ( ct.sub_id == TYPE_ROAD ) )\n\t{\n\t\tnh = evalHighway( ct.p.xy );\n\t\td_pavement_below_highway = nh.d - ROAD_HALFWIDTH * HIGHWAY_PAVEMENT_RATIO;\n\t\td_highway_columns_zone = nh.d - ROAD_HALFWIDTH * 0.25;\n\t\tis_highway_columns_zone = smoothstep_c( -d_highway_columns_zone, 0., 0.005 ); // account for the bevel (mask of road flat bit)\n\t}\n\n\tvec3 road_base_color0 = vec3( 0.5, 0.53, 0.65 );\n\n\tif ( ( ct.sub_id == TYPE_HIGHWAY ) && true )\n\t{\n\t\t// roadmarkings on top of highway\n\n\t\tfloat hd = nh.d - ROAD_HALFWIDTH;\n\t\tfloat highway_road_bit_mask = 1. - smoothstep_c( nh.d, ROAD_HALFWIDTH - 0.2, 0.005 ); // account for the bevel (mask of road flat bit)\n\n\t\tvec2 u = ( nh.pr + nh.d2f.xy ); // works better\n\t\tu.y = nh.d;\n\t\tfloat snhd = nh.d * sign( nh.d2f.y ); // signed distance accross road when we need to distinguish ledft/right\n\n\t\tfloat curvature = smin_pol( abs( nh.d2f.w ) * 1.2, 1., 0.5 );\n\n\t\tfloat diagstripes0 = step( ( ROAD_HALFWIDTH * 0.9 - nh.d ) * sign( nh.d2f.y ), curvature );\n\t\tfloat diagstripes = diagstripes0 * smoothband( snhd, ROAD_HALFWIDTH * 0.1, ROAD_HALFWIDTH * 0.7, 0.005 ); // select road v band, sign( nh.d2f.y ) tells us which side of the road we are on\n\n/// a few aliases - all those operate on floats\n\t\t#define SYMLINES(c,r) ( smoothband( abs( u.y ) - ROAD_WIDTH * c, r, aa ) )\n\t\t#define STRIPES(_k,period,len) ( stripes( u._k, period, len, aa ) )\n\t\t#define STRIPES2(_k,period,len) ( stripes2( u._k, period, len, aa ) )\n\t\t#define DIAGONALSTRIPES(period,len) ( stripes( u.x + hd * sign( nh.d2f.y ) * 1.5, period,len, aa ) )\n\t\t#define DOTTEDLINE(r,period,len) ( smoothband( u.y, r, aa ) * STRIPES2( x, period, len ) )\n\t\t#define ARROWS(center,period,len,width,slope) ( ( stripes2( u.x - fold(snhd, ROAD_WIDTH*(center))*(slope), period,len, aa ) ) * smoothband( snhd- ROAD_WIDTH*(center), (width)*0.5, aa ) )\n\t\t#define ADD( _col, _factor ) albedo_markings = mix( albedo_markings, _col, _factor )\n\n\t\tvec3 road_marking_color_white = vec3( 1. ) * 3.;\n\t\tvec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n\t\tvec3 albedo_markings = vec3( 0. );\n\n\t\tADD( road_marking_color_white, SYMLINES( 0.18, 0.016 ) * STRIPES2( x, 0.4, 0.1 ) * ( 1. - diagstripes ) );\n\t\tADD( mix( road_marking_color_yellow, road_marking_color_white, 1. ), highway_road_bit_mask * STRIPES( y, 0.75, 0.016 ) * ( 1. - diagstripes ) );\n\n\t\t// the wide warning stripes\n\t\tADD( road_marking_color_white, diagstripes * DIAGONALSTRIPES(  0.15 * 1.8, 0.05 ) );\n\t\tADD( road_marking_color_white, ARROWS( -0.28, 0.4 * 16., 0.1 * 12., 0.24, 0.5 ) * ARROWS( -0.28, 0.4, 0.1, 0.24, 0.5 ) * ( 1. - diagstripes ) );\n\n\t\t{\n\t\t\t// highway road marking number\n\t\t\tvec2 np = ( ct.p.xy ); // vec2( u.x, nh.d2f.y );\n\t\t\tnp.x = repeat_e( np.x, -20., 20. );\n\t\t\tnp = ( perp( np ) + vec2( 0.25, 9. ) ) * vec2( 3.5, 0.75 );\n\t\t\tNumberArg args;\n\t\t\targs.h = 0.7;\n\t\t\targs.s = vec2( 1., 2. ) * 0.5;\n\t\t\targs.r = 0.1;\n\t\t\targs.w = 0.045;\n\t\t\targs.m = 0.025;\n\t\t\tfloat dn = sd_Number3or8( np, 8, args );\n\t\t\tdn = opU( dn, sd_Number3or8( np + vec2( -args.s.x * 1., 0. ), 3, args ) );\n\t\t\tif ( sign( nh.d2f.y ) > 0. ) dn = FLT_MAX;\n\t\t\tADD( road_marking_color_yellow, smoothstep( aa, -aa, dn ) );\n\t\t}\n\n\t\t// make sure roadmarkings are only on top highway surface\n\t\tfloat space_filter = step( HIGHWAY_HEIGHT, ct.p.z ) // must be above highway height\n\t\t\t* step( 0., ct.n.z ) // surface must be pointing up\n\t\t\t* step( ct.p.z, HIGHWAY_HEIGHT + 0.5 ); // not higher than highway border walls\n\n\t\t{\n\t\t\tfloat blend = maxcomp( albedo_markings ) * space_filter;\n\t\t\talbedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.70, vec3( 1. ) ), blend );\n\t\t\troad_marking_material = max( road_marking_material, blend );\n\t\t}\n\n\t\t#ifdef LCD_PANELS\n\t\tif ( ct.type == IS_SIGN )\n\t\t{\n\t\t\t// render stuff on LCD panels... shadertoy within shadertoy, hehe\n\t\t\talbedo_markings = vec3( 0. );\n\n\t\t\tfloat h2 = 1.2; // sign start h\n\t\t\tfloat h3 = LDC_HEIGHT; // sign end h\n\n\t\t\tif ( ct.p.z > HIGHWAY_HEIGHT + h2 - 0.0  )\n\t\t\t{\n\t\t\t\tfloat screenpixel = 0.01; // highway panel pizel size, in world size\n\t\t\t\tvec2 gp = ct.p.yz;\n\t\t\t\tgp.x = snhd;\n\t\t\t\tgp.y -= ( HIGHWAY_HEIGHT + h2 ); // make botton line be pixel coord y=0\n\n\t\t\t\tfloat d = sd_bounds_repeat_size_margin( gp, vec2( screenpixel ), vec2( 0.001 ) );\n\t\t\t\tfloat margin = step( d, 0. );\n\n\t\t\t\t// I don't AA properly because I suck, but at least tone the grid down\n\t\t\t\tmargin = mix( margin, 1., ( 1. - exp( -max( ct.t - 6., 0. ) ) * 0.7 ) );\n\n\t\t\t\tvec2 sp = floor( gp / screenpixel ); // screen pixel\n\n\t\t\t\t// bottom margin x top margin x sides component\n\t\t\t\tfloat is_ldc_surface = step( 1., sp.y ) * step( sp.y, floor( LDC_HEIGHT / screenpixel ) - 2. ) * step( 0.5, abs( ct.n.x ) );\n\n\t\t\t\tmargin *= is_ldc_surface;\n\n\t\t\t\tfloat index = floor( u.x / SIGN_PERIOD ); // same repeat as sd_HighwaySigns\n\t\t\t\tindex = mod( index, 4. );\n\n\t\t\t\t#define ADD_EMITTER(c,v) emitter+=(c)*(v)*margin*1.;\n\n\t\t\t\tif ( index == 0.  )\n\t\t\t\t{\n\t\t\t\t\t// airliners\n\t\t\t\t\tvec2 c = vec2( 110., 110. );\n\t\t\t\t\tvec2 sp3 = rotate_with_unit_vector( sp, -V60 ) + vec2( -iTime * 100., 0. );\n\t\t\t\t\tsp3 = repeat( sp3, c );\n\t\t\t\t\tfloat d3 = sd_airliner_a350( ( sp3 - c * 0.5 ) * 0.2 );\n\t\t\t\t\tADD_EMITTER( vec3( 1. ), step( d3, 0. ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 1.  )\n\t\t\t\t{\n\t\t\t\t\t// hearts\n\t\t\t\t\tfloat hg = heart_grid( -perp( sp ) + vec2( sin( iTime * 3. ) * 8., 6. + iTime * 40. ), vec2( 32., 40. ) );\n\t\t\t\t\tADD_EMITTER( vec3( 1., 0., 0. ), hg );\n\t\t\t\t\tfloat hg2 = heart_grid( ( rotate_with_unit_vector( -sp, V45 ) * 2. ) + vec2( -iTime * 18., 6. ), vec2( 30., 30. ) );\n\t\t\t\t\tADD_EMITTER( vec3( 0., 1., 1. ), hg2 * ( 1. - hg ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 2.  )\n\t\t\t\t{\n\t\t\t\t\t// rainbow stars\n\t\t\t\t\tvec2 sp3 = sp;\n\t\t\t\t\tsp3 *= 1.;\n\t\t\t\t\tsp3.y -= 100.;\n\t\t\t\t\tsp3 = rotate_with_angle( sp3, iTime );\n\t\t\t\t\tfloat a = calc_angle( sp3 );\n\t\t\t\t\tfloat r = length( sp3 );\n\t\t\t\t\tfloat r0 = 30.;\n\t\t\t\t\tfloat arclen0 = r0 * 2.; // use a rough sie ratio\n\t\t\t\t\tfloat ri = floor( r / r0 );\n\t\t\t\t\tfloat R = ri * r0;\n\t\t\t\t\tfloat numarc = floor( 2. * PI * R / arclen0 );\n\t\t\t\t\tfloat da = ( 2. * PI / numarc );\n\t\t\t\t\tfloat dai = floor( a / da );\n\t\t\t\t\tvec2 y = unit_vector2( da * ( dai + 0.5 ) );\n\t\t\t\t\tvec2 x = -perp( y );\n\t\t\t\t\tvec2 c = y * ( ri + 0.5 ) * r0;\n\t\t\t\t\tsp3 = vec2( dot( x, sp3 - c ), dot( y, sp3 - c ) );\n\t\t\t\t\tsp3 *= 0.025;\n\t\t\t\t\tsp3.y = -sp3.y;\n\t\t\t\t\tfloat d1 = star( sp3.xy * 3. );\n\t\t\t\t\tvec2 trail_uv;\n\t\t\t\t\tfloat d2 = star_trail( sp3.xy - vec2( -0.6, -0.1 ), trail_uv );\n\t\t\t\t\tvec3 rainbow = hsv2rgb( vec3( trail_uv.y, 1., 1. ) );\n\t\t\t\t\tvec3 c2 = vec3( 0. );\n\t\t\t\t\tif ( d2 < 0. ) c2 = rainbow;\n\t\t\t\t\tif ( d1 < 0. ) c2 = vec3( 1., 1., 0. );\n\t\t\t\t\tADD_EMITTER( c2, max( step( d1, 0. ), step( d2, 0. ) ) );\n\t\t\t\t}\n\t\t\t\telse if ( index == 3.  )\n\t\t\t\t{\n\t\t\t\t\t// 2 layers of swimming squids or something\n\t\t\t\t\tfloat anim1 = ( sin( iTime * 8. ) + 1. ) * 0.5;\n\t\t\t\t\tvec2 sp1 = rotate_with_unit_vector( sp, -V45 ) + vec2( 0., 18. - iTime * 20. + anim1 * 4. );\n\t\t\t\t\tfloat l1 = step( ika_grid( sp1, anim1, vec2( 15., 15. ) ), 0. );\n\t\t\t\t\tADD_EMITTER( vec3( 0., 1., 1. ), l1 );\n\t\t\t\t\tfloat anim2 = ( sin( iTime * 9. ) + 1. ) * 0.5;\n\t\t\t\t\tvec2 sp2 = rotate_with_unit_vector( sp, -V45 ) + vec2( 5., 9. - iTime * 35. + anim1 * 4. );\n\t\t\t\t\tfloat l2 = step( ika_grid( sp2, anim2, vec2( 40., 40. ) ), 0. );\n\t\t\t\t\tADD_EMITTER( vec3( 1., 0., 0. ), l2 * ( 1. - l1 ) );\n\t\t\t\t}\n\n\t\t\t\talbedo = mix( albedo, albedo * 0.3, is_ldc_surface );\n\t\t\t}\n\t\t}\n\t\t#endif\n\t}\n\n\tif ( ( ct.sub_id == TYPE_ROAD ) && true )\n\t{\n\t\t// regular streets road markings\n\t\tNearestHighwayRetval nh = evalHighway( ct.p.xy );\n\t\tvec2 pp = repeat_mirror_l( ct.p.xy, vec2( 0., 0. ), CELL_SIZE.xy ); // road cells\n\t\tvec2 extra = -vec2( 0.15 );\n\t\tvec2 mina = CELL_SPACING.yy * 0.5 + extra;\n\t\tvec2 minb = CELL_SIZE.xy - CELL_SPACING.xx - extra;\n\t\tfloat d1 = sd_bounds_range_round( pp, mina, minb, 0.075 );\n\t\tfloat is_pure_road = step( 0., d1 );\n\t\td1 = opS( d1, d_pavement_below_highway ); // empty the bit below the highway\n\t\tfloat is_road_or_below_highway_road = step( 0., d1 );\n\t\tvec2 is_wide_road = step( pp, mina );\n\t\tvec2 is_small_road = step( minb, pp );\n\t\tfloat is_wide_road_crossing = is_wide_road.x * is_wide_road.y;\n\t\tfloat is_small_road_crossing = is_small_road.x * is_small_road.y;\n\t\tfloat is_small_wide_road_crossing =  min( is_wide_road.x * is_small_road.y + is_wide_road.y * is_small_road.x, 1. );\n\t\tfloat crossing = min( is_small_road_crossing + is_wide_road_crossing + is_small_wide_road_crossing, 1. );\n\t\tvec3 road_marking_color_white = vec3( 1. ) * 2.;\n\t\tvec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n\t\tvec3 albedo_markings = vec3( 0. );\n\t\t// white lines all around\n\t\tADD( road_marking_color_white, smoothband( d1, 0.05, 0.05 + 0.02, aa ) );\n\t\t// wide roads markings\n\t\tADD( road_marking_color_white, smoothband( pp.x, 0.01, aa ) * is_wide_road.x * ( 1. - crossing ) ); //DOTTEDLINE\n\t\tADD( road_marking_color_white, smoothband( pp.y, 0.01, aa ) * is_wide_road.y * ( 1. - crossing ) ); //DOTTEDLINE\n\t\t// small road markings\n\t\tADD( road_marking_color_white, smoothband( pp.x - CELL_SIZE.x, 0.01, aa ) * stripes( pp.y - CELL_SIZE.y, 0.2, 0.05, aa ) * ( 1. - crossing ) ); //DOTTEDLINE\n\t\tADD( road_marking_color_white, smoothband( pp.y - CELL_SIZE.y, 0.01, aa ) * stripes( pp.x - CELL_SIZE.x, 0.2, 0.05, aa ) * ( 1. - crossing ) ); //DOTTEDLINE\n\t\t// yellow strips alongside highway columns\n\t\tADD( road_marking_color_yellow, smoothband( d_highway_columns_zone, 0.05, aa )* ( 1. - is_wide_road.x ) * ( 1. - is_small_road.x ) );\n\n\t\t{\n\t\t\t// pedestrian crossings on large roads\n\t\t\tfloat crossing_width = 0.24;\n\t\t\tfloat dd = 0.5; // where do start crossing from\n\t\t\tvec2 pedestrian_crossingmask = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width ), vec2( aa ) );\n\t\t\tvec2 pedestrian_crossingmask2 = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width * 1.2 ), vec2( aa ) );\n\t\t\tpedestrian_crossingmask *= is_pure_road * ( 1. - is_highway_columns_zone );\n\t\t\tpedestrian_crossingmask2 *= is_pure_road * ( 1. - is_highway_columns_zone );\n\t\t\talbedo_markings *= ( 1. - pedestrian_crossingmask2.x ) * ( 1. - pedestrian_crossingmask2.y );\n\t\t\tADD( road_marking_color_white, stripes( pp.y, 0.1, 0.025, aa ) * pedestrian_crossingmask.x );\n\t\t\tADD( road_marking_color_white, stripes( pp.x, 0.1, 0.025, aa ) * pedestrian_crossingmask.y );\n\t\t}\n\n\t\tfloat blend = maxcomp( albedo_markings ) * is_road_or_below_highway_road * ( 1. - is_highway_columns_zone );\n\t\talbedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.75, vec3( 1. ) ), blend );\n\t\troad_marking_material = max( road_marking_material, blend );\n\t}\n}\n\nvec3 shadeCity( TraceCityRetval ct, vec3 e, vec3 v, vec3 l, float shadow\n\t\t\t\t, float airliner, float a_contrast, vec2 uv, float aspect, float ground_ao )\n{\n\tvec3 col = vec3( 0. );\n\tvec3 emitter = vec3( 0. );\n\n\tfloat is_sky = is_equal_as_float( ct.sub_id, TYPE_SKY );\n\n#ifdef HORIZON_HACK\n\t// hack stretch sky horizon so it matches our trace horizon (means the sun position won't quite match with real sun position)\n\tfloat gamma = -e.z / MAX_DDA_TRACE; //=cos(PI/2.+beta)=sin(beta), beta is the extra angle that goes into the ground\n\tfloat alpha = -1. / ( gamma - 1. );\n\tvec3 v_hacked = vec3( v.xy, 1. + ( v.z - 1. ) * mix( alpha, 1., 0. ) ); // mix control how much hack correction (alpha) we want on horizon\n\tvec3 skycol_view = get_sky( normalize( v_hacked ), l, 0.4 );\n#else\n\tvec3 skycol_view = get_sky( v, l, 0.4 );\n#endif\n//\tif ( ct.t > MAX_DDA_TRACE ) return GREEN;\n\n\t// sun disk\n\tfloat sun0 = dot( l, v );\n\n\tif ( ct.sub_id == TYPE_SKY )\n\t{\n\t\tcol = skycol_view;\n\n\t\t// we don't need to add a disk... let get_sky do it (also we messed with horizon and therefore sun position)\n//\t\tcol += vec3( pow( sun, 20. ) * is_sky * 100. ); // sun disk (not flare/not glow, just the sun disk)\n\n\t\tfloat d_airliners = 1. - pow( max( 0., sun0 ), 8. ); // airliners\n\t\tcol = mix( col, vec3( airliner ) + d_airliners * skycol_view * 2., airliner * 0.5 );\n\n\t\t#ifdef DEBUG_COLORING\n\t\tcol = vec3( 0.0,0.1,0.8 );\n\t\t#endif\n\t}\n\telse\n\t{\n\t\tivec4 ch = ivec4( ct.split_case, ct.sub_id, ct.tile_index );\n\t\tvec3 albedo = get_building_palette( hash24_( ch ) * mix( 1., 0.2, is_equal_as_float( ct.type, IS_ROOF ) ) ); // roof tiles use bottom left part of the 2d palette (ardoise)\n\n\t\tfloat road_marking_material = 0.;\n\t\tsurfaceColor( ct, albedo, emitter, road_marking_material );\n\n\t\t#ifdef DEBUG_COLORING\n\t\tif ( ct.type == IS_WINDOW ) return vec3( 0.7 );\n\t\tif ( ct.type == IS_LAMP ) return vec3( 1., 1., 0. );\n\t\tif ( ct.type == IS_ROOF ) return BLEU_ARDOISE;\n\t\tif ( ct.type == IS_SIGN ) return vec3( 0., 1., 1. );\n\t\treturn mix( albedo, hash44_( ch ).xyz, 0.5 );\n\t\t#endif\n\n\t\tfloat kdiffuse = mix( 0.75, 1., road_marking_material );\n\t\tfloat kspecular = mix( 0.15, 0.8, road_marking_material ) * shadow;\n\t\tfloat roughness = mix( 0.62, 0.1, road_marking_material );\n\n\t\tif ( ct.type == IS_ROOF ) { kspecular = 0.7; roughness = 0.2; }\n\n\t\tfloat Li_sky_color_saturation = 0.65; // how much we blend sky color in\n\n\t\tvec3 skycol_top = get_sky( vec3( 0., 0., 1. ), l, 1. );\n\t\tvec3 skycol_sun = get_sky( l, l, 1. );\n\n\t\tvec3 lr = vec3( -l.xy, l.z ); // sun light reflected from buildings from behind (\"1 bounce\")\n\t\tvec3 l2 = vec3( perp( l.xy ), l.z );\n\t\tvec3 l3 = vec3( -l2.xy, l.z );\n\n\t\tvec3 Li_sky_top = mix( skycol_top, vec3( luminance( skycol_top ) ), Li_sky_color_saturation );\n\n\t\tfloat s2 = mix( 0.8, 1., shadow );\n#if 1\n\t\t// only add ambient on shadows\n\t\tcol += 0.005 * ( 1. - shadow );\n#endif\n#if 1\n\t\t// skydome top light (highlights rooftops, too)\n\t\tcol += s2 * add_light_contrib( albedo, vec3( 0., 0., 1. ), ct.n, -v, Li_sky_top, 5., kdiffuse, kspecular, roughness );\n#endif\n#if 1\n\t\t// a couple of lateral directions, pretend Li_sky_top, this works well for our axis aligned scene...\n\t\tcol += s2 * add_light_contrib( albedo, l2, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n\t\tcol += s2 * add_light_contrib( albedo, l3, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n#endif\n#if 1\n\t\t// sun light reflected by \"buildings from behind\" (1 bounce-ish) tip from iq's https://iquilezles.org/articles/outdoorslighting\n\t\tvec3 Li_sky_sun_back = 0.2 * mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n\t\t// fade the highest positions as they don't get that much reflected light as there are no taller buildings, also that gives a bit of gradient\n\t\tLi_sky_sun_back *= 1. - min( ct.p.z / ( MAX_BUILDING_HEIGHT * 0.8 ), 1. );\n\t\tcol += s2 * add_light_contrib( albedo, lr, ct.n, -v, Li_sky_sun_back, 0.5, kdiffuse, .0, roughness );\n#endif\n#if 1\n\t\t#ifdef AO\n\t\tcol *= ct.ao * ct.ao * ct.ao * mix( ground_ao, 1., exp_decay( ct.p.z * 0.5 ) ); // we add a simple vertical occlusion term in addition to he marched ao\n\t\t#endif\n#endif\n#if 1\n\t\t// direct sun light (post ao!)\n\t\tvec3 Li_sky_sun_front = mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n\t\tcol += shadow * add_light_contrib( albedo, l, ct.n, -v, Li_sky_sun_front, 1., kdiffuse, kspecular, roughness );\n#endif\n//\t\tcol = mix( vec3( 1., 0., 0. ), col, shadow );\n\n\t\tif ( ct.type == IS_WINDOW )\n\t\t{\n\t\t\tvec3 vr = reflect( v, ct.n );\n\n\t\t\t // windows sky reflections, assumes sky fades to black in lower hemisphere\n\t\t\tcol += get_sky( vr, l, 1. ) * mix( 0.5, 1., shadow );\n\n\t\t\t#if 0\n\t\t\t// extra sun disk/glow? (get_sky has no sun disk)\n\t\t\tfloat sun1 = dot( l, vr ); // note: not hemisphere clamped\n\t\t\tcol += skycol_sun * vec3( pow( ( sun1 + 1. )* 0.5, 70. ) )* mix( 0.15,1.f,shadow );\n\t\t\t#endif\n\n\t\t\t// make windows a bit reflective in bottom hemisphere too\n\t\t\t// just reflect a constant \"ground color\", fading with distance\n\t\t\t#ifdef WINDOWS_GROUND_REFLECTION\n\t\t\tif ( v.z < 0. )\n\t\t\t{\n\t\t\t\tfloat wt = plane_trace_z( mkray( e, vr ), 0., 1.e-6 );\n\t\t\t\tif ( wt > 0. && wt != FLT_MAX )\n\t\t\t\t{\n//\t\t\t\t\tcol += RED * exp( -wt * 0.09 ); // red is kind of cool too :-)\n\t\t\t\t\tcol += BLEU_ARDOISE * exp( -wt * 0.09 ) * 0.25; // reflect a city ground color, maybe this gradient could be a function of building height\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\n\t\t\t// upper hemisphere window reflections (sky and office neon)\n\t\t\t#ifdef OFFICE_NEON\n\t\t\tif ( v.z > 0. )\n\t\t\t{\n\t\t\t\t// cheap but efficient neon hack\n\t\t\t\tRay vr = mkray( e, v );\n\t\t\t\tfloat wt = plane_trace_z( vr, ceil( ct.p.z / FLOOR_HEIGHT ) * FLOOR_HEIGHT, 1.e-6 ); // infinite neon plane\n\t\t\t\tif ( wt > 0. && wt != FLT_MAX )\n\t\t\t\t{\n\t\t\t\t\tvec3 wp = vr.o + vr.d * wt;\n\t\t\t\t\tfloat neondepth = dot( ct.p - wp, ct.n );\n\t\t\t\t\tvec2 y = normalize( ct.n.xy );\n\t\t\t\t\tvec2 x = -perp( y );\n\t\t\t\t\tfloat dneon = sd_bounds_repeat_range_range( wp.x * x + wp.y * y, vec2( 0., 0. ), vec2( 0.8, 0.3 ) // neon periodicity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, vec2( 0., 0. ), vec2( 0.34, 0.05 ) ); // neon size\n\t\t\t\t\tcol += step( dneon, 0. ) * exp2( -neondepth * 2.8 );\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\t\t}\n\n\t\tcol += is_equal_as_float( ct.type, IS_LAMP ) * 0.9;\n\t\tcol += emitter;\n\n//\t\tvec3 fog_color = mix( RED, GREEN, pow( ( sun0 + 1. ) * 0.5, mix( 7., 40., shadow ) ) );\n\t\tvec3 fog_color = mix( skycol_top * 1.5, skycol_sun, pow( ( sun0 + 1. ) * 0.5, mix( 7., 5., shadow ) ) ); // skycol_top color is a bit weak so boost it a bit\n\t\tcol += fog_color * 0.55 * exp_decay( ct.t * 0.002 + ct.p.z * 0.007  ); // some kind of inscatter (so we add), along view distance and world height\n\n\t\tcol = mix( col, skycol_view, smoothstep( FADE_START, MAX_DDA_TRACE, ct.t ) ); // fade with background\n\n//\t\tif ( ct.t > FADE_START ) return RED;\n//\t\treturn skycol_view;\n//\t\treturn skycol_top * 8.;\n//\t\treturn skycol_sun;\n//\t\treturn col;\n\t}\n\n\tcol = 3.5 * tonemap_reinhard( col ); // expose\n//\tcol = max( vec3( 0. ), contrast( col, vec3( a_contrast ) ) ); // post process\n\tcol *= .2 + 0.8 * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); // vignette\n\tcol = gamma_correction_itu( col );\n\n//\tif ( v.z < 0. ) col = RED; // view real horizon\n\n\treturn col;\n}\n\n// building heights distribution function\nvec4 icdf( vec4 x ) { return mix( saturate( safe_acos( vec4( 1. ) - 4. * x ) / PI ), (x - vec4( 0.5 )) * 0.1, step( 0.5, x ) ); }\n\nParametricBuildingRetval sd_ParametricBuilding( float t, vec3 p, float building_type, bounds2 b2, float height, NearestHighwayRetval nh, vec3 rnd )\n{\n\tif ( building_type == 0. ) return sd_House( p, t, b2, min( height, HIGHWAY_HEIGHT ), nh );\n\treturn sd_Building( t, p, b2, height, nh, rnd );\n}\n\nstruct ParametricBuildingHit\n{\n\tfloat t;\n\tfloat tile_child_index;\n\tfloat building_type; // 0:house 1:building (could use 0. and 4. instead)\n\tfloat height;\n\tbounds2 b2;\n\tfloat d;\n\tvec3 windr;\n\tfloat is_roof;\n\tRay ray2; // potentially permuted ray\n\tbool permuted;\n\tNearestHighwayRetval nh;\n\tvec3 rnd;\n};\n\nvoid rayMarchParametricBuilding( Ray ray2, bool permuted, vec2 ri, bounds3 bi, float kk, inout ParametricBuildingHit hit, vec2 cell_index )\n{\n\tif ( ri.y <= ri.x || ri.y < 0. ) return; // no hit\n\n\tri.x = max( ri.x, 0. );\n\n\t// warning: if you fiddle with early return here, check what happens to the shadow term!\n\n\tbounds2 b2 = mkbounds_unchecked( bi.pmin.xy, bi.pmax.xy ); // b2 is in maybe permuted space and contains the object\n\n\tvec2 base_size = size( b2 ); // this is the base size with x and y maybe permuted\n\n//\tif ( base_size.x <= 0. || base_size.y <= 0. ) return; // doesn't seem to contribute to the image... and is slower?\n\n\tNearestHighwayRetval nh;\n\n\tnh.d = FLT_MAX; // disable the clip plane\n\n\t#ifdef HIGHWAY_CLIP\n\t#ifdef HIGHWAYS\n\t{\n\t\t// some basic layout intersection tests outside marching loop... tedious block of code\n\n\t\tvec2 b2c = center( b2 );\n\t\tvec2 b2s = base_size; // size( b2 )\n\n\t\tif ( permuted ) // remember: b2 is in permuted space, dont use it in calculations below\n\t\t{\n\t\t\tb2c = b2c.yx; // back to world\n\t\t\tb2s = b2s.yx;\n\t\t}\n\n\t\tnh = evalHighway( b2c );\n\n\t\tnh.o_clip = nh.p + nh.d2f.xy; // closest highway center line point (b2c==nh.p)\n\t\tnh.n_clip = normalize( perp( nh.d2f.zw ) ); // can't use hret2.d2f.xy as it may be null\n\n//\t\tfloat b2cd = dot( b2c - nh.o_clip, nh.n_clip ); // distance to higway center line, signed\n\t\tfloat b2cd = dot( -nh.d2f.xy, nh.n_clip ); // should be same as above, saves a sub (lol)\n\n\t\tnh.n_clip *= sign( b2cd ); // orient the clip normal so we can build a facade (box center is on positive side)\n\n\t\tb2cd = abs( b2cd ); // now we are on the positive side\n\n\t\tfloat ml = length( b2s );\n\n\t\tif ( b2cd > ( ml + ROAD_WIDTH ) * 0.5 ) nh.d = FLT_MAX; // building far away enough regardless of rotation, disable the clip plane\n\t\t#ifdef TRY_BALANCE_SIZES\n\t\telse \n\t\t{\n\t\t\tfloat l = b2s.y; // (fixme: corrected with slope) if we can assume horizonal ish roads\n\t\t\tfloat clipped_l = ( b2cd + l * 0.5 ) - max( b2cd - l * 0.5, ROAD_HALFWIDTH ); // size left after clipping\n\n\t\t\tbase_size = b2s;\n\t\t\tbase_size.y = clipped_l;\n\n\t\t\t// if the building was ultra thin to begin with, clipping is not going to make things any better\n\t\t\t// that filters out some garbage thin buildings\n\t\t\tif ( maxcomp( base_size ) > 10. * mincomp( base_size ) ) return;\n\t\t}\n\t\t#endif\n\n//\t\tnh.d = FLT_MAX; // uncomment to check actual size of building if they weren't clipped\n\n\t\tif ( permuted )\n\t\t{\n\t\t\t// back to permuted space\n\t\t\tnh.p = nh.p.yx;\n\t\t\tnh.pr = nh.pr.yx;\n\t\t\tnh.d2f = nh.d2f.yxwz;\n\t\t\tnh.n_clip = nh.n_clip.yx;\n\t\t\tnh.o_clip = nh.o_clip.yx;\n\t\t}\n\t}\n\t#endif\n\t#endif\n\n\tfloat height = bi.pmax.z; // pmax.z awkward?\n\n\t// make height not bigger than n times the smallest dimension on the 2d base, not that base_size may be permuted, we only care about the min dimension\n\t#ifdef TRY_BALANCE_SIZES\n\theight = min( height, 8. * mincomp( base_size ) );\n\t#endif\n\n\tfloat building_type = height < 3.4 ? 0. : 1.;\n\n\tif ( building_type == 1. ) height = ( 0.5 + floor( height / FLOOR_HEIGHT - 0.5 ) ) * FLOOR_HEIGHT; // make building height a multiple of floor height\n\n\tfloat t = ri.x; // start marching from first hit point\n\n\tvec3 rnd = vec3( cell_index, kk );\n\n\tfor ( int j = 0; j < DDA_CELL_SDF_MARCH_MAX_ITERATIONS FORCE_LOOP_LV3; ++j )\n\t{\n#ifdef ENABLE_MAX_DDA_TRACE_DISTANCE\n\t\t// no need to trace further than max cell size == massive win\n\t\t// we then have to pick a max trace distance, for that cell 2d diagonal size would be a start\n\t\t// but since cell height is higher than max building height, we use max building height instead\n\t\tif ( t - ri.x > MAX_BUILDING_HEIGHT ) break;\n#endif\n\n\t\tvec3 p = ray2.o + t * ray2.d;\n\n\t\tParametricBuildingRetval ddd = sd_ParametricBuilding( t, p, building_type, b2, height, nh, rnd );\n\t\tfloat d = ddd.d;\n\n\t\tif ( abs( d ) <= 0.001 * t )\n\t\t{\n\t\t\tif ( t < hit.t ) // we need to check vs other objects in the cell\n\t\t\t{\n\t\t\t\t// record a few things we need to do extra evals deriving from the final hit\n\t\t\t\thit.t = t;\n\t\t\t\thit.tile_child_index = kk;\n\t\t\t\thit.building_type = building_type;\n\t\t\t\thit.b2 = b2;\n\t\t\t\thit.height = height;\n\t\t\t\thit.d = d;\n\t\t\t\thit.windr = ddd.windr;\n\t\t\t\thit.is_roof = step( abs( d - ddd.droof ), 0.001 );\n\t\t\t\thit.ray2 = ray2;\n\t\t\t\thit.permuted = permuted;\n\t\t\t\thit.nh = nh;\n\t\t\t\thit.rnd = rnd;\n\t\t\t}\n\n\t\t\tbreak; // \"return\" is slower on radeon: 29ms -> 31ms (ancient wip timings)\n\t\t}\n\n\t\tfloat dt = d;\n//\t\tfloat dt = d * TFRAC; // shadows a bit better with this\n//\t\tfloat dt = abs( d ); // *TFRAC // only move forward (see inside of buildings...)\n\n\t\tt += dt;\n//\t\tp += dt * ray2.d; // do not do this, instead increment t and reevaluate p fully (loss of precision else)\n\t}\n}\n\nvoid rayMarchCellObjects( Ray ray2, Ranges_x4 iv, bool permuted, inout ParametricBuildingHit hit, vec2 cell_index, bool shadow_trace )\n{\n#ifdef DEBUG_BUILDINGS_BOUNDS\n\n\t#define BLD_BOX( rX, bX, idval ) \\\n\tif ( iv.rX.y > iv.rX.x && hit.t > iv.rX.x && iv.rX.x > 0. ) \\\n\t{ \\\n\t\thit.t = iv.rX.x; \\\n\t\t/*b4 = iv.bX;*/ \\\n\t\thit.tile_child_index = idval; \\\n\t\thit.ray2 = ray2; \\\n\t\thit.permuted = permuted; \\\n\t}\n\n\tBLD_BOX( rA, bA, 0. )\n\tBLD_BOX( rB, bB, 1. )\n\tBLD_BOX( rC, bC, 2. )\n\tBLD_BOX( rD, bD, 3. )\n\t\n#else\n\t\n#ifndef UNROLL_LOOP2\n/// same cost as manually unroll (stable 29ms, vs 28,29ms for manually unrolled, old wip figures)\n/// would like to also try prevent unroll but...\n\tvec2 ranges[4] = vec2[4]( iv.rA, iv.rB, iv.rC, iv.rD );\n\tbounds3 b4s[4] = bounds3[4]( iv.bA, iv.bB, iv.bC, iv.bD );\n\tfor ( int i = 0; i< ( 4 FORCE_LOOP_LV2 ); ++i )\n\t{\n\t\trayMarchParametricBuilding( ray2, permuted, ranges[i], b4s[i], float( i ), hit, cell_index );\n\t}\n#else\n\t// manual unroll 74ms -> 69ms old radeon :-/ (old wip figures)\n\trayMarchParametricBuilding( ray2, permuted, iv.rA, iv.bA, 0., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rB, iv.bB, 1., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rC, iv.bC, 2., hit, cell_index );\n\tif ( !SHADOW_EARLY_RET( hit.t ) ) rayMarchParametricBuilding( ray2, permuted, iv.rD, iv.bD, 3., hit, cell_index );\n#endif\n\n#endif\n}\n\n// ray march buildings in a cell\nvoid traceBuildings( Ray a_ray, inout TraceCityRetval ct, float split_cells_spacing, bool shadow_trace )\n{\n\tfloat maxh = MAX_BUILDING_HEIGHT;\n\tfloat minh = 2.;\n\n\tfloat rmin = -0.1;\n\tfloat rmax = max( 1., maxh );\n\n\t// we only dda trace the rmin, rmax z range\n\tfloat tbottom = plane_trace_z( a_ray, rmin, 1e-6 );\n\tfloat ttop = plane_trace_z( a_ray, rmax, 1e-6 );\n\n\tvec2 r0 = vec2( 0., MAX_DDA_TRACE );\n\tvec2 r1 = vec2( min( ttop, tbottom ), max( ttop, tbottom ) );\n\tvec2 r2 = vec2( max( r0.x, r1.x ), min( r0.y, r1.y ) ); // intersection of r0 and r1\n\n//\tif ( r2.y <= r2.x ) return; // non sensical per drop if we return...\n\tr2 *= step( r2.x, r2.y ); // ...so instead do a zero length iteration\n\n\tfloat start_t = r2.x; // remember initial jump to return something along a_ray\n\n\tRay ray = mkray( a_ray.o + a_ray.d * start_t, a_ray.d ); // warp to tmin\n\tvec3 ray_end = a_ray.o + a_ray.d * r2.y;\n\n\tDDA3 dda = dda_init( ray.o, ray_end, CELL_SIZE, false );\n\n\t// trace within dda traversed cell\n\tParametricBuildingHit hit;\n\thit.t = FLT_MAX;\n\tfloat split_case = -1.;\n\n\t// dda traverse\n\tfor ( int i = 0; i < ( MAX_DDA_ITER FORCE_LOOP_LV1 )\n\t\t  && dot( dda.p - a_ray.o, dda.p - a_ray.o ) < r2.y * r2.y; ++i )\n\t{\n\t\t// raytrace 4 boxes inside each cell\n\t\tbounds2 b = mkbounds_unchecked( dda.c.xy * CELL_SIZE.xy, ( dda.c.xy + vec2( 1., 1. ) ) * CELL_SIZE.xy ); // cell bounds\n\t\tivec2 index = ivec2( dda.c.xy );\n\t\tvec4 a; a.xy = CELL_SPACING.xy * 0.5; a.zw = a.xy;\n\t\tif ( ( index.x & 1 ) == 0 ) a.xy = a.yx;\n\t\tif ( ( index.y & 1 ) == 0 ) a.zw = a.wz;\n\t\tb.pmin.xy += a.xz; // shrink cell bounds according to street margins (we alternate wide and narrow streets hence logic above)\n\t\tb.pmax.xy -= a.yw;\n\n\t\tvec2 margin = vec2( split_cells_spacing * 0.5 + 0.2 );\n\n\t\tvec2 r55 = hash22_( index ); // split type, permute\n\n\t\tRay ray2 = ray;\n\t\tbool permuted = false;\n\n\t\t#ifdef TILE_PERMUTATIONS\n\t\tif ( r55.y > 0.5 )\n\t\t{\n\t\t\t// random permutations, else default patterns look more or less all aligned\n\t\t\tray2.o.xyz = ray.o.yxz;\n\t\t\tray2.d.xyz = ray.d.yxz;\n\t\t\tb.pmin.xy = b.pmin.yx;\n\t\t\tb.pmax.xy = b.pmax.yx;\n\t\t\tpermuted = true;\n\t\t}\n\t\t#endif\n\n\t\tvec4 r4 = icdf( hash42_( index * 0x8da6b343 ) ); // heights hash\n\t\tvec4 rheights = mix( vec4( minh ), vec4( maxh ), r4 );\n\t\tvec4 r3 = hash42_( index * 0xb68f63e4 ); // split hash\n\t\tvec4 r3_0 = r3;\n\n\t\tr3.xyw = mix( vec3( 1. ), vec3( 5. ), r3.xyw ); // ratio of smallest to largest size\n\t\tr3.xy = fractions( r3.xyw ); // use r3.xyw as relative unit sizes\n\t\tr3.z = mix(  0.2,  0.8, r3.z );\n\n\t\tRanges_x4 iv;\n\n\t\tSplit4bSetup s4su = setup_Split4b( ray2, b.pmin.xy, b.pmax.xy, margin );\n\n\t\t// select a tile split pattern\n\t\tif ( r55.x > 0.75 )\n\t\t{\n\t\t\tbound_Split4b_xxy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights, margin );\n\t\t\ttrace_Split4b_xxy( iv, ray2, s4su, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights );\n\t\t\tsplit_case = 0.;\n\t\t}\n\t\telse if ( r55.x > 0.5 )\n\t\t{\n\t\t\tr3.xyz = fractions( mix( vec4( 2. ), vec4( 3. ), r3_0 ) );\n\n\t\t\tbound_Split4b_xxx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights, margin );\n\t\t\ttrace_Split4b_xxx( iv, ray2, s4su, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights );\n\t\t\tsplit_case = 1.;\n\t\t}\n\t\telse if ( r55.x > 0.25 )\n\t\t{\n\t\t\tbound_Split4b_xyy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights, margin );\n\t\t\ttrace_Split4b_xyy( iv, ray2, s4su, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights );\n\t\t\tsplit_case = 2.;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbound_Split4b_xyx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights, margin );\n\t\t\ttrace_Split4b_xyx( iv, ray2, s4su, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights );\n\t\t\tsplit_case = 3.;\n\t\t}\n\n\t\thit.t = FLT_MAX;\n\t\thit.tile_child_index = -1.; // no hit\n\n\t\trayMarchCellObjects( ray2, iv, permuted, hit, dda.c.xy, shadow_trace );\n\n\t\tif ( hit.t != FLT_MAX ) break; // we have hit, gtfo and fill other extra bits out of the loop\n//\t\tif ( hit.t > ct.t ) return; // fixme: no point in continuing, but we should just set dda end point instead\n\n\t\tdda_step_infinite( dda ); // make sure you set a_finite to false in dda_init when calling this version\n\t}\n\n\tif ( hit.t >= ct.t ) return; // ct.t might be FLT_MAX so >= is important here\n\n\t// we hit a building\n\tct.p = ray.o + hit.t * ray.d;\n\tct.t = start_t + hit.t; // remember that we jumped at start\n\n\tif ( shadow_trace ) return; // we don't need normal, ao, material... gtfo\n\n\t// house type will use type index [0,3], building type will use index [4,7]\n\tpack_info( ct, dda.c.xy, split_case, hit.tile_child_index + hit.building_type * 4. );\n\n\tvec3 p = hit.ray2.o + hit.t * hit.ray2.d;\n\n#ifndef DEBUG_BUILDINGS_BOUNDS\n\t\n\tvec3 h = vec3( 0.01, 0., 0. ); // h.x *= hit.t; // grainy normals tweak\n\n\t#ifdef FORCE_GRAD_LOOP_BUILDING\n\tvec3 dcomp;\n\tfor ( int comp = 0 FORCE_LOOP; comp < 3; ++comp )\n\t{\n\t\tvec3 dp = p;\n\t\tdp[comp] += h.x;\n\t\tdcomp[comp] = sd_ParametricBuilding( hit.t, dp, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;\n\t}\n\tct.n = normalize( dcomp - vec3( hit.d ) );\n\t#else\n\tct.n = normalize( vec3( sd_ParametricBuilding( hit.t, p + h.xyz, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n\t\t\t\t\t\t\tsd_ParametricBuilding( hit.t, p + h.zxy, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n\t\t\t\t\t\t\tsd_ParametricBuilding( hit.t, p + h.yzx, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d )\n\t\t\t\t\t  - hit.d ); // hit.d should be equal to sd_ParametricBuilding( hit.t, p, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d\n\t#endif\n\n\t// do ao in permuted space\n\t#ifdef AO\n\t{\n\t\tRay ao_ray = mkray( p, ct.n );\n\t\tAO_BEGIN()\n\t\t\tfloat d = sd_ParametricBuilding( _ao_t, ao_ray.o + _ao_t * ao_ray.d, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;\n\t\tAO_END( ct.ao )\n\t}\n\t#else\n\tct.ao = 1.;\n\t#endif\n\n\tif ( hit.is_roof > 0. ) ct.type = IS_ROOF;\n\n\tif ( ( abs( hit.d - hit.windr.x ) < 0.001 ) // distance must be close to windows plane, stored in hit.windr.x\n\t\t && ( 0.01 < abs( dot( hit.windr.yz, ct.n.xy ) ) ) // normal must match window orientation\n\t\t // normal must be vertical\n\t\t && ( abs( ct.n.z ) < 0.005 ) ) ct.type = IS_WINDOW;\n\n\tif ( hit.permuted ) ct.n.xy = ct.n.yx;\n\n#endif\n}\n\nTraceCityRetval traceCity( Ray ray, bool shadow_trace )\n{\n\tTraceCityRetval ct;\n\tpack_info1( ct, FLT_MAX, vec3( 0. ), vec3( 0. ), 1., 0 );\n\tpack_info( ct, vec2( 0. ), 0., TYPE_SKY );\n\n\tfloat split_cells_spacing = 0.025;\n\n#if 1\n\t{\n\t\t// raytrace ground to close the horizon, only matters at street level (in bird view buildings occlude everything so it's useless) and traceBuildings needs its own ground for AO\n\t\tfloat t = plane_trace_z( ray, 0., 1e-6 );\n\t\tif ( 0. < t && t < ct.t && t < MAX_DDA_TRACE ) // use a max distance so the infinite plane doesn't extend beyond buildings horizon\n\t\t{\n\t\t\tpack_info1( ct, t, vec3( ( ray.o + t * ray.d ).xy, 0. ), vec3( 0., 0., 1. ), 1., 0 );\n\t\t\tpack_info( ct, vec2( 0. ), 0., TYPE_ROAD );\n\t\t}\n\t}\n#endif\n\n#if 1\n\t#ifdef HIGHWAYS\n\tif ( !SHADOW_EARLY_RET( ct.t ) )\n\t{\n\t\t// assuming highway is at constant height, we can raytrace that too and close a lot of the sdf marching hole at vanishing point\n\t\tfloat t = plane_trace_z( ray, HIGHWAY_HEIGHT, 1e-6 );\n\t\tif ( 0. < t && t < ct.t && t < MAX_HIGHWAY_TRACE )\n\t\t{\n\t\t\tvec3 p = ray.o + t * ray.d; // hit point\n\t\t\tif ( evalHighway( p.xy ).d < ROAD_HALFWIDTH )\n\t\t\t{\n\t\t\t\tpack_info1( ct, t, p, vec3( 0., 0., 1. ), 1., 0 );\n\t\t\t\tpack_info( ct, vec2( 0. ), 0., TYPE_HIGHWAY );\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n#endif\n\n\t#ifdef BUILDINGS\n\tif ( !SHADOW_EARLY_RET( ct.t ) ) traceBuildings( ray, ct, split_cells_spacing, shadow_trace );\n\t#endif\n\n\t#ifdef HIGHWAYS\n\tif ( !SHADOW_EARLY_RET( ct.t ) )\n\t{\n\t\t// ray marched scene component\n\t\tfloat t = 0.;\n\t\tbool hit = false;\n\t\tvec3 p, dd;\n\t\t// narrow fov need 200\n\t\tfor ( int j = 0; j < 110 FORCE_LOOP_S; ++j )\n\t\t{\n\t\t\tp = ray.o + t * ray.d;\n\n\t\t\tdd = sd_RayMarchedCityBits( p, 0 );\n\n\t\t\tbool has_hit = abs( dd.x ) <= 0.001 * t; // no need to trace further than first building hit, or ground hit\n\t\t\tbool too_far = t > MAX_HIGHWAY_TRACE || t > ct.t; // hide glitter artifact in the distance, saves some ms too\n\n\t\t\tif ( has_hit || too_far )\n\t\t\t{\n\t\t\t\thit = has_hit;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tt += dd.x; // *TFRAC\n\t\t}\n\n\t\tif ( t < ct.t && hit )\n\t\t{\n\t\t\tct.p = p;\n\t\t\tct.t = t;\n\n\t\t\tif ( !shadow_trace ) // doubt it makes a difference, anyway shadow only need t\n\t\t\t{\n\t\t\t\tpack_info( ct, vec2( 0. ), 0., p.z < 0.004 * t ? TYPE_ROAD : TYPE_HIGHWAY );\n\n\t\t\t\tvec3 h = vec3( 0.01, 0., 0. );\n\t\t//\t\th.x *= t; // grainy normals tweak => but that inflate pavement edges weirdly\n\n\t\t\t\t#ifdef FORCE_GRAD_LOOP_SCENE\n\t\t\t\tvec3 dcomp;\n\t\t\t\tfor ( int comp = 0 FORCE_LOOP; comp < 3; ++comp )\n\t\t\t\t{\n\t\t\t\t\tvec3 dp = ct.p;\n\t\t\t\t\tdp[comp] += h.x;\n\t\t\t\t\tdcomp[comp] = sd_RayMarchedCityBits( dp, 0 ).x;\n\t\t\t\t}\n\t\t\t\tct.n = normalize( dcomp - vec3(dd.x) );\n\t\t\t\t#else\n\t\t\t\tct.n = normalize( vec3( sd_RayMarchedCityBits( ct.p + h.xyz, 0 ).x,\n\t\t\t\t\t\t\t\t\t\t  sd_RayMarchedCityBits( ct.p + h.zxy, 0 ).x,\n\t\t\t\t\t\t\t\t\t\t  sd_RayMarchedCityBits( ct.p + h.yzx, 0 ).x )\n\t\t\t\t\t\t\t\t\t- dd.x );\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t#ifdef AO\n\t\t\t\t{\n\t\t\t\t\tRay ao_ray = mkray( ct.p, ct.n );\n\t\t\t\t\tAO_BEGIN()\n\t\t\t\t\t\tfloat d = sd_RayMarchedCityBits( ao_ray.o + _ao_t * ao_ray.d, 0 ).x;\n\t\t\t\t\tAO_END( ct.ao )\n\t\t\t\t}\n\t\t\t\t#else \n\t\t\t\tct.ao = 1.;\n\t\t\t\t#endif\n\n\t\t\t\tct.type = 0;\n\n\t\t\t\tif ( abs( dd.y - dd.x ) < 0.0000007 ) ct.type = IS_LAMP;\n\t\t\t\tif ( abs( dd.z - dd.x ) < 0.0000007 ) ct.type = IS_SIGN;\n\t\t\t}\n\t\t}\n\t}\n\t#endif\n\n\tct.ao = min( ct.ao, 1. ); // apparently this goes above 1 and whitens far away pixel... so clamp\n\n\treturn ct;\n}\n\nstruct CameraPosAndTangent { vec3 eye; vec2 tangent; };\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, float look_at_the_abyss )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 || STICKY_MOUSE ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tfloat mm_y = mm.y;\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\n\tif ( mm_y < 0. )\n\t{\n\t\t// very special case camera control for getRoofTopCoffeeBreakCamera\n\t\tvec3 v = camera[2].xyz;\n\t\tv.xy = rotate_with_angle( v.xy, mm.x );\n\t\tcamera[3].xyz += v * mm.y * look_at_the_abyss;\n\t}\n\n\treturn camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\n\nCameraPosAndTangent getDriveCameraPosAndTangent( float t, float lateral_move_amplitude )\n{\n//\tt -= 200. * iSlider0;\n\tfloat x = t * 4.;\n\tfloat e = 1e-2;\n\tvec3 p1 = sd_CameraCurveXY( x );\n\tvec3 p2 = sd_CameraCurveXY( x + e );\n\tvec2 tangent = ( p2.xy - p1.xy ) / e;\n\tCameraPosAndTangent ret;\n\tret.eye = p1;\n\tret.tangent = tangent;\n\tret.eye.xy += lateral_move_amplitude * perp( tangent ) * sin( 2. * PI * t / 5. ) * ROAD_HALFWIDTH * 0.5 * abs( tangent.y );\n\treturn ret;\n}\n\n// we use those for drive camera vibrations\nfloat noise( float x ) { float xi = floor( x ); return mix( hash11( xi ), hash11( xi + 1. ), smoothstep_unchecked( x - xi ) ); }\nfloat noisem11( float x ) { return 2. * ( noise( x ) - 0.5 ); }\nfloat fbm( float x ) { return noisem11( x ) + noisem11( x * 2. ) * 0.5 + noisem11( x * 4. ) * 0.25 + noisem11( x * 8. ) * 0.125; }\n\nCameraRet getDriveCamera( float t )\n{\n\tfloat lateral_move_amplitude = 1.;\n\tCameraPosAndTangent cam0 = getDriveCameraPosAndTangent( t, lateral_move_amplitude );\n\n\tCameraRet cam = init_cam();\n\tcam.eye = cam0.eye;\n\n\t// those 2 evals are for camera acceleration effects and target eval\n\tCameraPosAndTangent camnext1 = getDriveCameraPosAndTangent( t - 1.0, lateral_move_amplitude );\n\tCameraPosAndTangent camnext2 = getDriveCameraPosAndTangent( t + 0.5, lateral_move_amplitude );\n\n\t{\n\t\t// for road vibrations we must be close enough to road surface\n\t\tfloat driving_vibrations = max( smoothbump( HIGHWAY_HEIGHT, 4., cam.eye.z ), smoothbump( 0., 4., cam.eye.z ) );\n\t\tcam.eye.xy += driving_vibrations * perp( cam0.tangent ) * fbm( 100. + t * 0.1 ) * 0.3;\n\t\tcam.eye.z += driving_vibrations * fbm( t ) * 0.015; // road roughness\n\t}\n\n\tcam.roll = ( camnext2.tangent.y - camnext1.tangent.y ) * 0.3; // roll\n\n\tcam.target = camnext2.eye;\n\n\t// drift logic\n\tfloat tr = repeat_e( t, 0., 30. );\n\tcam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( PI * smoothstep( 5., 10., tr ) + // 180 = flying looking backward for a while\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tPI * smoothstep( 15., 20., tr ) ) ); // 360 = back to travel direction\n\treturn cam;\n}\n\nvec3 getStraightFlightCameraPos( float time )\n{\n\ttime += 200.;\n\tvec2 v = unit_vector2( -time * 0.05 );\n\treturn vec3( v * 100. + 50. * log( 1. + time ), 15. );\n}\n\nCameraRet getStraightFlightCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tfloat u = t / duration;\n\tt += 8.;\n\tCameraRet cam = init_cam();\n\tcam.eye = getStraightFlightCameraPos( t );\n\tcam.target = getStraightFlightCameraPos( t + 1. );\n\tcam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( -PI * smoothstep( 1., 0., u ) ) );\n\ttan_half_fovy = 0.5;\n\tcam.pitch = radians( -20. );\n\treturn cam;\n}\n\n// get position of a point that travelled at constant speed a long a log spiral, starting from theta0\nvec2 log_spiral( float d, float theta0, float a, float b )\n{\n//\td( theta ) = integral of a * exp( b * theta ) dtheta = ( exp( b * theta ) - exp( b * theta0 ) ) * a / b;\n\tfloat theta = log( d * ( b / a ) + exp( b * theta0 ) ) / b;\n\treturn a * exp( b * theta ) * unit_vector2( theta );\n}\n\nvec3 getRoofTopCoffeeBreakCameraPos( float u )\n{\n\tvec2 v = log_spiral( (u)*4.3, 0., 1., 1. );\n\tv -= normalize( v ) * 1.;\n\tv.xy *= vec2( 0.51, 0.95 );\n\treturn vec3(v.xy,0.) + vec3(593.983276,-76.936417,8.693137); // add start position\n}\n\n// walk on a roof top and lookup at airliner\nCameraRet getRoofTopCoffeeBreakCamera( float t, inout float tan_half_fovy, float duration, inout float look_at_the_abyss )\n{\n\tCameraRet cam = init_cam();\n\tvec3 start_pos = vec3(593.983276,-76.936417,8.693137);\n\tfloat u = saturate( t / duration );\n\tcam.eye = getRoofTopCoffeeBreakCameraPos( u );\n\tcam.eye.z += ( ( 1. + sin( u * 95. ) ) * 0.5 ) * 0.001; // walk\n\tfloat ra = mix( -radians( 1.5 ), PI * 1.17, smoothstep( 0.2, 1., u ) );\n\tcam.target = cam.eye + vec3( unit_vector2( ra ), 0. );\n\tcam.pitch = smoothbump( u, 0.6, 0.75, 0.82, 1.01 ) * PI * 0.5 * 0.75;\n\tlook_at_the_abyss = 0.2 * smoothstep( 0.8, 0.6, u );\n\treturn cam;\n}\n\n// ( offset x, offset y, angle, time offset )\n//#define LSFC vec4(iSlider2,iSlider3,iSlider4,iSlider5)\n#define LSFC vec4(0.,0.35,0.2214,0.0928)\n\nvec3 getLogSpiralCameraFlyPos( float t, inout float pitch )\n{\n\t#if 0\n\t// old camera, a bit long\n\tfloat dz = exp_bell( t -35.5, 5. );\n\tpitch = radians( -18. );\n\tpitch -= dz * radians( 3.5 );\n\t#else\n\tfloat dz = exp_bell( t -15.5, 5. ) * 0.5;\n\tpitch = radians( -18. );\n\tpitch -= dz * radians( 3.5 );\n\t#endif\n\treturn vec3( vec2( -100. ) + 200. * LSFC.xy, 8.3 )\n\t\t   + vec3( rotate_with_angle( log_spiral( LSFC.w * 200. + t * 1.2, 0.1, 1., 1. )\n\t\t\t\t\t\t\t\t\t  , -LSFC.z * PI * 2. ), dz * 3. );\n}\n\n// fly along a log spiral with constant roll\nCameraRet getLogSpiralCameraFly( float t, inout float tan_half_fovy )\n{\n\tCameraRet cam = init_cam();\n\tcam.eye = getLogSpiralCameraFlyPos( t, cam.pitch );\n\tcam.target = getLogSpiralCameraFlyPos( t + 1., cam.pitch );\n\tcam.roll = radians( 10. );\n\ttan_half_fovy = 0.53;\n\treturn cam;\n}\n\n// goes through p1,p2\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3 )\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tvec3 a1 = -p0 + p2;\n\tvec3 a2 = 2. * p0 - 5. * p1 + 4. * p2 - p3;\n\tvec3 a3 = -p0 + 3. * p1 - 3. * p2 + p3;\n\tpoint = 0.5 * ( ( 2. * p1 ) + a1 * t + a2 * t2 + a3 * t3 );\n\tderivative = 0.5 * ( a1 + a2 * 2. * t + a3 * 3. * t2 ); // whilst we are at it\n}\n\n// goes through p1,p2,p3\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4 )\n{\n\tif ( t < 0.5 ) catmullrom( point, derivative, t * 2., p0, p1, p2, p3 );\n\telse catmullrom( point, derivative, 2. * ( t - 0.5 ), p1, p2, p3, p4 );\n}\n\n//#define UTBSC vec2(iSlider0,iSlider1)\n//#define UTBSC vec2(0.585714,0.35)\n#define UTBSC vec2(0.585714,0.707143) // best\n\nCameraRet getUnderTheBridgeStreetCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tfloat u = saturate( t / duration );\n\tvec3 o = vec3( floor( UTBSC.x * 100. ) * 80. * 2., \n\t\t\t\t   floor( UTBSC.y * 100. ) * CELL_SIZE.y, 0. );\n\tvec3 p0 = o + vec3( -80.457870, -10.903438, 0.591591 );\n\tvec3 p1 = o + vec3( -80.274940, -3.2, 0.517319 );\n\tvec3 p2 = o + vec3( -79.289925, 2.674706, 1.934119 );\n\tvec3 p3 = o + vec3( -74.650077819, 3.327467679, 3.193379163 );\n\tvec3 p4 = o + vec3( -71.289779663, 4.606474399, 3.521366834 );\n\tvec3 derivative;\n\tcatmullrom( cam.eye, derivative, u, p0, p1, p2, p3, p4 );\n\tcam.target = cam.eye + derivative;\n\tcam.pitch = mix( radians( -22. ), 0., u );\n\tcam.roll = mix( radians( 0. ), radians( -8. ), smoothstep( 0.2, 0.8, u ) );\n\treturn cam;\n}\n\n//#define IFC vec3(iSlider0,iSlider1,iSlider2)\n#define IFC vec3(0.6,0.62,0.328)\n\nCameraRet getIsoFlyCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tvec2 travel_dir = normalize( vec2( -1.8, 1.4 ) );\n\tcam.eye = vec3( travel_dir * t * 4., 65. );\n\tcam.eye += vec3( IFC.x * 200., IFC.y * 200., 0. );\n\tcam.target = cam.eye + vec3( perp( travel_dir ), 0. );\n\tcam.pitch = radians( -60. * IFC.z );\n\ttan_half_fovy = 0.1;\n\treturn cam;\n}\n\n// get close to a LCD panel that shows the squid invaders things\nCameraRet getLCDScreenCloseUpCamera( float t, inout float tan_half_fovy, float duration )\n{\n\tCameraRet cam = init_cam();\n\tcam.eye = vec3( -5.514656066, -0.541317582, 2.770161151 );\n\tcam.target = cam.eye + vec3( -1., 0., 0. );\n\tvec3 a = vec3( -6.56, -0.8, 3.3 );\n\tvec3 b = vec3( -6.56, 0.8, 3.3 );\n\tcam.eye.x += 1.5;\n\tcam.eye.z -= 0.5;\n\tfloat u = saturate( t / duration );\n\tvec3 c = mix( a, b, u );\n\tc.x += 0.8;\n\tcam.eye = mix( cam.eye, c - vec3( 0., 0., 0.5 ), u );\n\tcam.target = mix( cam.target, mix( a, b, 0.8 ), pow( u, 2. ) );\n\ttan_half_fovy = mix( 0.47, 0.4, u );\n\treturn cam;\n}\n\nmat4 getCamera( inout float tan_half_fovy, inout float fade, inout float a_contrast, vec3 l, inout float time, inout float ground_ao )\n{\n\tfloat total = 0.;\n\t// per camera time range: array of start, duration (yes I am aware of the syntax that pretends we can have arrays)\n\tvec2 r1 = vec2( total, 41. ); total += r1.y;\n\tvec2 r2 = vec2( total, 20. ); total += r2.y;\n\tvec2 r3 = vec2( total, 20. ); total += r3.y;\n\tvec2 r4 = vec2( total, 8.5 ); total += r4.y;\n\tvec2 r5 = vec2( total, 12. ); total += r5.y;\n\tvec2 r6 = vec2( total,  8. ); total += r6.y;\n\tvec2 r7 = vec2( total, 22. ); total += r7.y;\n\n\ttime = mod( time, total ); // cycle through all cameras\n\n//\tvec2 r = r2; // <= select a specific camera to test here\n//\ttime = r.x + mod( time, r.y );\n//  time = r.x + 1.;\n\n\tfloat tr = 0.7; // fade half durations\n\tfade *= 1. -( max( cosbump( time, 0., tr ), cosbump( time, total, tr )) // those 2 overlap\n\t\t\t\t + cosbump( time, r2.x, tr )+ cosbump( time, r3.x, tr )\n\t\t\t\t + cosbump( time, r4.x, tr )+ cosbump( time, r5.x, tr )\n\t\t\t\t + cosbump( time, r6.x, tr )+ cosbump( time, r7.x, tr ));\n\n\tfloat look_at_the_abyss = 0.;\n\n\tCameraRet cam;\n\n\t     if ( time < r1.x + r1.y ) { time -= r1.x; cam = getDriveCamera( time ); }\n\telse if ( time < r2.x + r2.y ) { time -= r2.x; cam = getLogSpiralCameraFly( time, tan_half_fovy ); ground_ao = 0.7; }\n\telse if ( time < r3.x + r3.y ) { time -= r3.x; cam = getRoofTopCoffeeBreakCamera( time, tan_half_fovy, r3.y, look_at_the_abyss ); ground_ao = 0.375; }\n\telse if ( time < r4.x + r4.y ) { time -= r4.x; cam = getUnderTheBridgeStreetCamera( time, tan_half_fovy, r4.y ); }\n\telse if ( time < r5.x + r5.y ) { time -= r5.x; cam = getStraightFlightCamera( time, tan_half_fovy, r5.y ); ground_ao = 0.7; }\n\telse if ( time < r6.x + r6.y ) { time -= r6.x; cam = getLCDScreenCloseUpCamera( time, tan_half_fovy, r6.y ); }\n\telse                           { time -= r7.x; cam = getIsoFlyCamera( time, tan_half_fovy, r7.y ); ground_ao = 0.375; }\n\n\tmat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy, look_at_the_abyss );\n}\n\n// trace the silhouette of an a350 airliner, alt = 10000 at cruising altitude\nfloat get_airliner( Ray view_ray, float alt, float cruising_speed_fraction, float d, vec2 mv // normalized please\n\t\t\t\t\t, float tan_half_fovy, float time_offset, float direction, float trail_fade, float time )\n{\n//\tcruising_speed_fraction *= 5.; // DEBUG\n\tfloat airliner_cruising_speed = cruising_speed_fraction * ( 950000. / ( 60. * 60. ) ); // m/s\n\tfloat R1 = 5. * alt * tan_half_fovy; // make all trajectory disks roughly same radius from ground\n\tfloat R2 = R1 * 1.4;\n\tfloat fade_time = 1.;\n\tfloat h1 = sqrt( R1 * R1 - d * d );\n\tfloat h2 = sqrt( R2 * R2 - d * d );\n\tvec2 O = vec2( 0., 0 );\n\tvec2 c = O + mv * d;\n\tvec2 travel_direction = perp( mv ) * direction;\n\tfloat looptime = 2. * h2 / airliner_cruising_speed;\n\tfloat rt = mod( time + time_offset, looptime );\n\tfloat u = rt * airliner_cruising_speed;\n\tvec3 plane_pos = vec3( c + travel_direction * ( u - h2 ), alt );\n\tfloat t = plane_trace_z( view_ray, alt, 0. ); // epsilon zero, we don't care it's in the sky\n\tvec3 it = view_ray.o + view_ray.d * t;\n\tfloat dd = length( it.xy );\n\tfloat x = dot( it.xy - plane_pos.xy, -travel_direction ) - 47.;\n\tfloat y = abs( dot( it.xy - plane_pos.xy, perp( travel_direction ) ) );\n\tfloat fade = smoothstep( h2, h1, abs( u - h2 ) );\n\tfloat trail_disk_fade = smoothstep( R2, R1, dd );\n\t// note: y is already symmetrized\n\tfloat trail_half_spacing = 9.;\n\tfloat dc = exp_decay( x * 0.02 );\n\tfloat engine_trail = ( x < 0. ? 0. : smoothstep( 2., -1., abs( y - trail_half_spacing ) - dc * 4. ) )\n\t// trail distance decay\n\t\t* exp( -x * 0.00175 );\n\tfloat trail = engine_trail * fade * trail_disk_fade * trail_fade;\n\tfloat debug = 0.;\n\tvec2 uv = ( it - plane_pos ).xy * ( 20. / 64. ); // plane outline sdf to scale\n\tif ( length( uv ) > 12. ) return debug + trail + 0.; // outside plane sdf's disk\n\treturn debug + trail + fade * smoothstep( 0.1, -0.1, sd_airliner_a350( rotate_with_unit_vector( uv, vec2( travel_direction.x, -travel_direction.y ) ) ) ); // plane\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 u = fragCoord.xy / iResolution.xy;\n\tfragColor.a = 1.;\n\tfloat a_contrast = 1.;\n\tfloat fade = 1.;\n\tfloat ground_ao = 1.; // 1. == no ground ao... a bit of ground ao helps in flight cameras\n\n#if 1\n\tvec3 l = normalize( vec3( 0.8, 0.025, 0.125 ) ); // sun direction\n#else\n// sun is meant to be at a sunset-ish position, looks bad else\n\tvec3 l = zup_spherical_coords_to_vector( PI * 0.5 * (1. - iSlider0), 2. * PI * (iSlider1 - 0.5) ); // sun direction\n#endif\n\n//\tfragColor.rgb = test_sky( fragCoord, l ); return; // contemplate sky probe, for the interested reader\n//\tfragColor.rgb = get_building_palette( fragCoord.xy / min( iResolution.x, iResolution.y ) ); return; // for the curious\n\n\tfloat time = iTime + 20.;\n\n#ifdef EXTRA_3D_CAMERA\n\tfloat tan_half_fovy = iTanHalfFovy;\n\tmat4 camera = mat4( iCamera[0], iCamera[1], iCamera[2], iCamera[3] );\n#else\n\tfloat tan_half_fovy = 0.6; // fovy 61 deg\n\tmat4 camera = getCamera( tan_half_fovy, fade, a_contrast, l, time, ground_ao );\n#endif\n\n\tRay view_ray = get_view_ray( ( u - vec2( 0.5 )) * 2.0, 0.1, aspect, tan_half_fovy );\n\tview_ray = mkray( camera[3].xyz, ( camera * vec4( view_ray.d, 0.0 )).xyz );\n\tview_ray.d.z += 1e-5; // divide by zero quick workaround\n\n#if defined(UNROLL_LOOP0)||!defined(SHADOWS)\n\tTraceCityRetval ct = traceCity( view_ray, false );\n\tfloat shadow = 1.;\n#ifdef SHADOWS\n\tRay sray = mkray( ct.p + ct.n * 0.0025 * ct.t, l );\n\tTraceCityRetval ct_shadow = traceCity( sray, true );\n\tshadow = step( FLT_MAX, ct_shadow.t );\n#endif\n#else\n\t// do view ray and shadow ray in a loop in hope to reduce chance of hitting webgl crashes\n\tRay r = view_ray;\n\tTraceCityRetval ct;\n\tfloat shadow = 1.;\n\tfor ( int i = 0; i < 2 FORCE_LOOP_LV0 ; ++i )\n\t{\n\t\tTraceCityRetval ctr = traceCity( r, i == 1 );\n\t\tr = mkray( ctr.p + ctr.n * 0.0025 * ctr.t, l ); // set shadow ray for second pass\n\t\tif ( i == 0 ) ct = ctr;\n\t\tshadow = step( FLT_MAX, ctr.t ); // only relevant at end of second pass\n\t}\n#endif\n\n#if 0\n\t// raytrace one last thing... only a tiny little thin one (actually, 3 tiny little thin ones)\n\tfloat airliner = 0.;\n\tairliner = max( airliner, get_airliner( view_ray, 1000., 0.3, 2000.,          V45, tan_half_fovy, 15.,  1., 1. , time ) ); // set time to 673 for debug\n\tairliner = max( airliner, get_airliner( view_ray, 5000., 0.8, 500. ,  vec2(1.,0.), tan_half_fovy, 45., -1., 1. , time ) );\n\tairliner = max( airliner, get_airliner( view_ray, 1500., 0.4, 0.   , vec2(-1.,0.), tan_half_fovy, 40., -1., 0.7, time ) );\n#else\n\t// unrolling is cleaner than this horrible mess but I wanted the option to try force a loop\n\tfloat airliner = 0.;\n\tfor ( int i = 0; i < 3 FORCE_LOOP_B; ++i )\n\t{\n\t\tfloat airliner_alt = 1000. + (i == 1 ? 4000. : 0.) + (i == 2 ? 500. : 0.);\n\t\tfloat airliner_cruising_speed_fraction = 0.3 + (i == 1 ? 0.5 : 0.) + (i == 2 ? 0.1 : 0.);\n\t\tfloat airliner_d = float(2-i) * 500. + (i == 0 ? 1000. : 0.);\n\t\tvec2 mv = (i == 0 ? V45 : vec2( 0. )) + (i == 1 ? vec2( 1., 0. ) : vec2( 0. )) + (i == 2 ? vec2( -1., 0. ) : vec2( 0. ));\n\t\tfloat time_offset = 15. + (i == 1 ? 30. : 0.) + (i == 2 ? 25. : 0.);\n\t\tfloat direction = (i == 0 ? 1. : -1.);\n\t\tfloat trail_fade = (i == 2 ? 0.7 : 1.);\n\t\tairliner = max( airliner, get_airliner( view_ray, airliner_alt, airliner_cruising_speed_fraction, airliner_d, mv, tan_half_fovy, time_offset, direction, trail_fade, time ) );\n\t}\n#endif\n\n\tfragColor.rgb = fade * shadeCity( ct, view_ray.o, view_ray.d, l, shadow, airliner, a_contrast, u, aspect, ground_ao );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}