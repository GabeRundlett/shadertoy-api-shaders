{
    "Shader": {
        "info": {
            "date": "1562834328",
            "description": "球，卡通风格渲染",
            "flags": 0,
            "hasliked": 0,
            "id": "WlXSW4",
            "likes": 2,
            "name": "Test3_Cartoonball",
            "published": 3,
            "tags": [],
            "usePreview": 0,
            "username": "Newyang",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "const int MAX_ITER = 100;\nconst float MAX_DIST = 20.0; \nconst float EPSILON = 0.001; \n\nvec3 cameraOrigin = vec3(2.0, 3.0, 2.0);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\n\nvec4 shapeColor = vec4(0.99, 0.5, 1.0, 1.0);\nfloat specularPower = 16.0;\n\n// a sphere is defined as the position and a radius \nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat distfunc(vec3 pos)\n{\n    return sphere(pos, 2.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n    vec3 cameraUp = cross(cameraDir, cameraRight);    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; // rescale screenPos to be from -1 to 1\n    \n    screenPos.x *= iResolution.x / iResolution.y; // now scale it by the aspect ratio\n    \n    // ray from camera position to screen pixel\n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    // The raymarching loop\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n    \n    // trying to find a point of intersection \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n        if (dist < EPSILON || totalDist > MAX_DIST)\n        break; // If you use windows and the shader isn't working properly, change this to continue;\n    \n        dist = distfunc(pos); // Evalulate the distance at the current point\n        totalDist += dist;\n        pos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n    }\n    \n    if(dist < EPSILON) \n    {\n        // calculate lighting\n        \n        // need to find the normal of the surface \n        // using distance, can calculate this by sampling a few points\n        vec2 eps = vec2(0.0, EPSILON);\n        // creating points that are +/- the pos in x/y/z \n        // (since eps.x is 0 and eps.y is actual EPSILON)\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n            distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n            distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)\n        ));\n        \n        \n        vec3 lightPos = vec3(9.0*cos(iTime*3.0),3.0*sin(iTime*3.0),9.0);\n        \n        // the unlit colour\n        vec3 ambientColor = vec3(0.2, 0.0, 0.0);\n        // the lit colour of the shape \n        vec3 diffuseColor = vec3(0.3, 0.3, 0.3);\n        // the reflection highlight\n        vec3 specColor = vec3(1.0, 1.0, 1.0);\n        \n        // light direction is the light position to the vertex position\n        vec3 lightDir = normalize(lightPos - pos);\n        \n        float lambertian = max(dot(lightDir, normal), 0.0);\n        vec3 worldHalfDir = normalize(lightDir + cameraDir);\n        float spec = dot(worldHalfDir,normal);\n        \n        float s = step(0.05,lambertian);\n        float t = step(0.001,0.1*spec);\n        float e = step(0.3,lambertian);\n        float p = step(0.5,lambertian);\n        \n        float specular = 0.3;\n             \n        fragColor = vec4(ambientColor +\n                      s * diffuseColor +\n                      e * vec3(0.1,0.1,0.1) +\n                      p * vec3(0.1,0.1,0.1) +  \n                      p * t * specular * specColor, 1.0);\n    }\n       \n    else \n    {\n        fragColor = vec4(0.3,0.3,0.3,1.0);\n    }\n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}