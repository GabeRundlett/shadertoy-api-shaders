{
    "Shader": {
        "info": {
            "date": "1599446536",
            "description": "An unofficial Shadertoy implementation of a kernel to convolve an image with a kernel using a few passes, and just a few samples at each pass. This was adapted from the GLSL sample code provided at https://www.graphics.rwth-aachen.de/publication/03312/",
            "flags": 32,
            "hasliked": 0,
            "id": "WlSBzc",
            "likes": 4,
            "name": "Sparse Image Convolutions Demo",
            "published": 3,
            "tags": [
                "blur"
            ],
            "usePreview": 0,
            "username": "NBickford",
            "viewed": 1349
        },
        "renderpass": [
            {
                "code": "// Try out some choices of different blurs in the Common tab!\n//\n// This Shadertoy reimplements some of the kernels from the paper\n// \"High-Performance Image Filters via Sparse Approximations\", by\n// Kersten Schuster, Philip Trettner, and Leif Kobbelt.\n// Instead of implementing convolutions by using a sum of\n// separable filters (for instance), this paper shows how to\n// approximate a convolution using a series of small blurs\n// (like a Kawase blur, but only sampling from the lowest mip\n// level), and a nonlinear optimization technique for optimizing\n// these sample locations.\n//\n// Please see the Common tab for more information about these\n// data arrays, and how to choose which blur to use.\n//\n// This Shadertoy was adapted from the implementation in the\n// paper's supplemental material, available at\n// https://www.graphics.rwth-aachen.de/publication/03312/.\n// The original supplemental GLSL code was provided with the\n// following license:\n/*\nMIT License\n\nCopyright (c) 2020 Kersten Schuster, Philip Trettner, https://www.graphics.rwth-aachen.de/sparse-convolution-filters\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n// Blur pass 4; convert from linear space to sRGB.\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(1.43681, 2.54344, 0.216748),\n    vec3(-2.415687, 1.80615, 0.218565),\n    vec3(-2.61698, -1.60458, 0.190348),\n    vec3(0.402895, -2.64168, 0.191997),\n    vec3(2.68614, -0.660522, 0.181597)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(-10.1897, -6.63978, -0.0416478),\n    vec3(1.01261, 12.9293, 0.222653),\n    vec3(-3.02032, -5.57293, -0.0695762),\n    vec3(0.465853, -1.09348, 0.0201693),\n    vec3(12.6032, -7.06434, 0.229691),\n    vec3(-6.09681, 0.0123993, 0.0427806),\n    vec3(5.19344, -6.5085, 0.0807356),\n    vec3(-1.81583, 6.98087, 0.0793452),\n    vec3(-3.31758, -6.03042, 0.117162),\n    vec3(-10.4298, -6.99663, 0.202939),\n    vec3(-7.90574, -3.38485, 0.0311912),\n    vec3(-14.1662, -8.74606, 0.0399237)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-4.04026, 0.621857, 0.0424986),\n    vec3(-3.36541, -1.57338, 0.0940673),\n    vec3(-1.16709, -3.19144, 0.0410433),\n    vec3(0.617172, -2.15564, 0.138944),\n    vec3(2.45193, -2.70028, 0.120259),\n    vec3(3.37716, -0.327347, 0.0247386),\n    vec3(1.73432, 1.18305, 0.112826),\n    vec3(0.461604, 1.7323, 0.120453),\n    vec3(-0.471351, -0.67063, 0.103255),\n    vec3(-1.51033, 2.63167, 0.212972),\n    vec3(-5.95205, -3.55146, -0.0221648),\n    vec3(3.38171, -0.335923, 0.0390691)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(-1.44121, 1.3926, 0.288923),\n    vec3(-0.519235, -1.23553, 0.240054),\n    vec3(1.13891, 0.62907, 0.00623932),\n    vec3(0.585034, 1.79536, 0.149159),\n    vec3(0.130506, 0.702575, 0.11129),\n    vec3(-0.421168, 1.40214, 0.0164664),\n    vec3(-1.16781, 1.46627, 0.0100937),\n    vec3(1.65469, -0.508309, 0.225989),\n    vec3(1.80466, -0.646769, -0.00831556),\n    vec3(0.0328333, -1.15792, -0.00478501),\n    vec3(1.07334, 0.675361, 0.038271),\n    vec3(-1.02273, 0.487464, 0.00798755)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(-3.27394, 2.28318, 0.0839198),\n    vec3(-3.22113, -2.29823, 0.0678272),\n    vec3(-2.52098, -0.275563, 0.146882),\n    vec3(-1.55479, -2.23214, 0.171236),\n    vec3(-0.840715, -3.89265, 0.0508523),\n    vec3(0.507461, -2.26812, 0.0703195),\n    vec3(2.67858, -4.38707, -0.0252949),\n    vec3(3.98227, -0.539806, 0.0661041),\n    vec3(3.38545, 1.43471, 0.162026),\n    vec3(2.47186, 3.24992, 0.140319),\n    vec3(2.00646, 5.21202, 0.045469),\n    vec3(-0.506765, 2.74372, 0.0602144)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(0.822781, -0.513738, 0.302996),\n    vec3(0.047913, 0.0649032, 0.106269),\n    vec3(-0.559089, -1.52573, 0.21958),\n    vec3(0.663466, 1.11877, 0.152037),\n    vec3(-0.69649, -1.44846, 0.0853627),\n    vec3(0.166251, 3.15885, 0.00688147),\n    vec3(-0.790441, 2.56556, 0.0178789),\n    vec3(-0.225663, 2.78177, 0.00121393),\n    vec3(-1.03059, -0.356715, 0.0181373),\n    vec3(-0.703992, -1.44589, 0.0828073),\n    // Extra elements so that all passes can use the same number of samples\n    vec3(0.0, 0.0, 0.0),\n    vec3(0.0, 0.0, 0.0)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(-1.59672, -1.67458, 0.113208),\n    vec3(1.47799, -1.63214, 0.176221),\n    vec3(1.49558, 0.787634, 0.225331),\n    vec3(-0.367021, 1.45392, 0.155453),\n    vec3(-1.35864, 0.40749, 0.0259248),\n    vec3(1.80442, -0.0501602, -0.00582266),\n    vec3(-0.230054, -1.57626, 0.0919024),\n    vec3(1.77735, 0.219959, -0.0335609),\n    vec3(-0.968267, -2.26735, 0.0159569),\n    vec3(-1.51391, 0.420281, 0.125971),\n    vec3(2.82087, 1.15074, 0.0591325),\n    vec3(-1.0905, -1.30001, -0.00238527)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n    \n    // Convert from linear space to sRGB for display\n    fragColor = linearToSRGB(fragColor);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Tiles the stars image across the screen, outputs to linear space.\n// This could also be a cubemap lookup, but most of Shadertoy's cubemaps aren't nearly high-resolution enough.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert from pixel coordinates to UV coordinates\n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    // Slowly zoom, rotate, and pan the image over time\n\t// The goal here is to involve features smaller than a pixel, so that we can observe sources of aliasing.\n    // Zoom\n    {\n        float zoomFactor = exp(0.5f + 0.5f * sin(0.1f * iTime));\n        uv = 0.5f + zoomFactor * (uv - 0.5f);\n    }\n    // Rotate\n    {\n        float angle = iTime * 0.02f;\n        float ca = cos(angle);\n        float sa = sin(angle);\n        uv = vec2(ca * uv.x - sa * uv.y, sa * uv.x + ca * uv.y);\n    }\n    // Pan\n    {\n        float panX = sin(iTime * 0.01f);\n        uv.x += panX;\n    }\n    // Image lookup; convert to linear space\n    fragColor = sRGBToLinear(texture(iChannel0, uv));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// sRGB to linear-space approximation\nvec4 sRGBToLinear(vec4 color){\n    return vec4(pow(color.rgb, vec3(2.2f)), color.a);\n}\n\n// Linear-space to sRGB approximation, inverse of sRGBToLinear for colors with all components positive\nvec4 linearToSRGB(vec4 color){\n    return vec4(pow(color.rgb, vec3(1.0f/2.2f)), color.a);\n}\n\n// SAMPLES and NUMSAMPLES can be any of:\n// gaussianBlur4_5, 5 (a 35-pixel Gaussian blur)\n// gon34_12, 12 (a triangular blur)\n// gon64_12, 12 (a hexagonal blur)\n// dollar4_12, 12 (a dollar-shaped blur)\n// heart4_12, 12 (a heart-shaped blur)\n// circle4_12, 12 (a circular-shaped blur)\n//\n// These arrays were obtained from the original GLSL files using the substitutions\n// \"color += textureLod(uTex, (uv + vec2(\" -> \"vec3(\"\n// \")) / ts, 0).rgb *\" -> \",\"\n// \";\\n\" -> \"),\\n\"\n// Note that the supplemental shaders include more than those shown here, including\n// higher-quality 32-sample-per-pass versions of many of these.\n#define SAMPLES gon34_12\n#define NUMSAMPLES 12",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Blur pass 1\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(-0.536899, 1.71559, 0.190943),\n    vec3(-1.63396, -0.277769, 0.202339),\n    vec3(-0.464825, -1.77054, 0.18752),\n    vec3(1.59937, -1.68088, 0.182522),\n    vec3(1.51572, 0.62634, 0.236254)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(1.70516, -1.68579, 0.104911),\n    vec3(2.04725, -0.799805, 0.129517),\n    vec3(1.49288, 0.559683, 0.114731),\n    vec3(0.511804, 1.77538, 0.118443),\n    vec3(-0.274264, 1.42485, 0.105618),\n    vec3(-1.00633, 0.724252, 0.0637492),\n    vec3(-1.05587, -0.0625124, 0.0948828),\n    vec3(-1.7732, -1.46542, 0.184245),\n    vec3(-0.0125602, -1.41111, 0.11403),\n    vec3(1.94606, -1.17605, -0.0518507),\n    vec3(0.261477, 0.164745, 0.00281854),\n    vec3(2.94477, 2.16834, 0.00627668)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(1.66463, 0.575596, 0.171307),\n    vec3(2.59847, 2.46116, 0.135754),\n    vec3(-0.274838, 1.27159, 0.120061),\n    vec3(0.543628, 2.36866, 0.141742),\n    vec3(-2.10768, 2.16833, 0.0621388),\n    vec3(-0.527432, -0.199986, 0.12739),\n    vec3(-2.65842, 0.537764, 0.110027),\n    vec3(1.40294, -1.29735, 0.0229304),\n    vec3(-2.3235, -0.928571, 0.0321623),\n    vec3(-1.11176, -2.43382, 0.0348939),\n    // Extra elements so that all passes can use the same number of samples.\n    // (A single-kernel implementation might use a different value of\n    // NUMSAMPLES per-pass; these are included here to make the implementation\n    // slightly simpler.)\n    vec3(0.0f, 0.0f, 0.0f),\n    vec3(0.0f, 0.0f, 0.0f)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(6.5186, -10.1901, 0.195821),\n    vec3(10.2192, -3.89199, -0.00296725),\n    vec3(8.29047, 0.0717141, -0.0507564),\n    vec3(7.50711, 10.1734, 0.162271),\n    vec3(3.13649, 15.5857, 0.143106),\n    vec3(-7.58524, 10.1288, 0.164761),\n    vec3(-10.6028, 5.54551, -0.0220465),\n    vec3(-9.41428, -1.35561, -0.0391754),\n    vec3(-9.26954, -9.06272, 0.157142),\n    vec3(-4.41262, -13.7269, 0.133598),\n    vec3(-4.38129, -20.2546, 0.0759993),\n    vec3(2.46962, -15.1735, -0.062585)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(3.65816, -0.381523, 0.155434),\n    vec3(1.69849, 5.25483, 0.0777845),\n    vec3(5.17014, -1.76344, 0.00593576),\n    vec3(-1.341, 4.26359, 0.122496),\n    vec3(-3.73209, 2.40436, 0.0857596),\n    vec3(5.42613, 1.5562, 0.128623),\n    vec3(-1.33212, 0.797307, 0.124572),\n    vec3(-2.85474, -1.57333, 0.0203082),\n    vec3(1.44816, -1.56033, 0.124728),\n    vec3(1.21086, 2.4045, 0.153089),\n    vec3(-0.162764, -2.68914, 0.0120604),\n    vec3(6.28892, 6.68655, -0.0159067)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-0.567121, -2.52652, 0.219092),\n    vec3(2.11451, 3.22905, 0.0242579),\n    vec3(1.56886, -1.13426, 0.127749),\n    vec3(2.17072, 0.808855, 0.101107),\n    vec3(1.60469, -3.49785, 0.0849859),\n    vec3(-0.25896, 2.38741, 0.0920342),\n    vec3(-3.53353, 0.777782, 0.084115),\n    vec3(-0.382732, -0.0834882, 0.0941771),\n    vec3(-2.55186, -1.23522, 0.0883374),\n    vec3(-0.413048, -0.212653, 0.0819732),\n    vec3(1.19929, 0.934426, 0.0241353),\n    vec3(1.2064, 0.947841, 0.00568039)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(3.59982, -9.36765, 0.0817689),\n    vec3(7.72927, -6.42077, 0.0916319),\n    vec3(9.73355, -1.45044, 0.0846194),\n    vec3(9.46391, 3.42274, 0.0714825),\n    vec3(6.70992, 7.27607, 0.088618),\n    vec3(1.83428, 9.79507, 0.0850097),\n    vec3(-3.48193, 9.38542, 0.0839686),\n    vec3(-7.6754, 6.23976, 0.0873239),\n    vec3(-9.51306, 1.44068, 0.0833687),\n    vec3(-9.42275, -3.48246, 0.0721704),\n    vec3(-6.56181, -7.23146, 0.0918506),\n    vec3(-1.91408, -10.2001, 0.0849586)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blur pass 2\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(1.25205, -5.35358, 0.176228),\n    vec3(5.2637, -0.579565, 0.171455),\n    vec3(2.44993, 4.45327, 0.210041),\n    vec3(-3.46991, 3.48145, 0.232004),\n    vec3(-4.36333, -2.40382, 0.211557)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(3.65293, -1.22466, 0.0896532),\n    vec3(2.38677, 1.27728, 0.157198),\n    vec3(-1.999, 2.19298, 0.07476),\n    vec3(0.000836663, 5.36977, 0.132487),\n    vec3(-2.59808, 0.714412, 0.105075),\n    vec3(-4.67753, -3.27138, 0.122933),\n    vec3(-1.32861, -3.32389, 0.0934033),\n    vec3(0.694742, -3.29434, 0.101147),\n    vec3(4.42439, -3.13249, 0.129403),\n    vec3(0.831605, 2.59237, 0.0796497),\n    vec3(-2.35004, -1.32128, 0.00239838),\n    vec3(-2.66117, -4.7948, -0.0302412)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-0.533295, -1.93182, -0.0265649),\n    vec3(-5.39325, -7.50618, 0.121408),\n    vec3(0.755642, -7.43218, 0.146205),\n    vec3(6.33766, -5.64283, 0.101193),\n    vec3(8.90058, 0.463735, 0.122632),\n    vec3(4.68577, 7.91363, 0.133023),\n    vec3(-1.68735, 8.04164, 0.13304),\n    vec3(8.13964, 10.7962, -0.00543929),\n    vec3(-10.6892, -4.5621, 0.0421263),\n    vec3(-9.66638, 0.552825, 0.124039),\n    vec3(-6.96923, 6.5773, 0.0966725),\n    vec3(8.20864, 0.312374, 0.0115968)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(8.18306, -2.82015, 0.126829),\n    vec3(-4.8865, -7.06012, 0.0115041),\n    vec3(2.14423, -8.27259, 0.0953727),\n    vec3(5.62741, -7.37869, 0.110022),\n    vec3(8.22676, -2.59528, 0.00265503),\n    vec3(9.54661, 3.96422, 0.03392),\n    vec3(5.66825, 6.35028, 0.0278248),\n    vec3(-1.35411, 9.94735, 0.0902114),\n    vec3(-4.99265, 9.63192, 0.103152),\n    vec3(-7.24023, 4.53206, 0.135558),\n    vec3(-8.74337, -1.38169, 0.0361024),\n    vec3(11.3964, 9.18145, 0.00310094)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(0.700995, 4.59081, 0.176748),\n    vec3(-2.90993, -4.98834, 0.0241374),\n    vec3(-9.62439, 9.82718, 0.161626),\n    vec3(-13.4597, 4.36941, 0.12912),\n    vec3(-7.45933, -2.51028, 0.175774),\n    vec3(-2.40969, 9.65172, 0.08051),\n    vec3(-0.16622, -9.15847, 0.15876),\n    vec3(5.85776, -4.29121, 0.10937),\n    vec3(8.91624, -6.32051, 0.0377648),\n    vec3(8.09934, -12.4869, 0.0266486),\n    vec3(10.2874, 0.845592, 0.108664),\n    vec3(-2.23857, 9.55102, -0.000425388)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-1.22416, 0.0725762, 0.0787856),\n    vec3(-8.14769, -0.563024, 0.0210209),\n    vec3(-3.79417, -4.40789, 0.0631343),\n    vec3(-8.05458, -3.7453, -0.0283331),\n    vec3(4.25173, -1.34132, 0.0974819),\n    vec3(0.453895, -2.75538, 0.138451),\n    vec3(-2.29387, 2.30927, 0.109067),\n    vec3(5.9059, 1.43775, 0.0501956),\n    vec3(2.89888, 2.57681, 0.0937886),\n    vec3(1.95178, 4.70348, 0.0768983),\n    vec3(-12.434, -3.17118, -0.0230655),\n    vec3(-16.466, 1.73528, 0.0132859)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(-12.8307, -10.6912, 0.107696),\n    vec3(-4.36955, -16.4317, 0.107829),\n    vec3(5.58789, -15.888, 0.108793),\n    vec3(13.6857, -9.25968, 0.112215),\n    vec3(16.7205, 1.15419, 0.111182),\n    vec3(12.5686, 10.5563, 0.108063),\n    vec3(4.12142, 16.2604, 0.108458),\n    vec3(-5.78583, 15.9181, 0.10576),\n    vec3(-13.6766, 9.40867, 0.10071),\n    vec3(-17.099, -1.43724, 0.109447),\n    vec3(-0.24529, -0.059554, -0.134227),\n    vec3(-18.094, 6.47425, 0.0223338)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Blur pass 3\nvec3 gaussianBlur4_5[] = vec3[5](\n    vec3(-3.39663, -2.7284, 0.198133),\n    vec3(1.63335, -3.57948, 0.23848),\n    vec3(4.4046, 0.571102, 0.213638),\n    vec3(0.639859, 4.51865, 0.185342),\n    vec3(-3.73462, 2.40625, 0.162287)\n);\n\nvec3 gon34_12[] = vec3[12](\n    vec3(5.35471, -2.94119, 0.201316),\n    vec3(5.31255, 0.0164711, -0.0311385),\n    vec3(3.84226, -1.798, 0.154307),\n    vec3(-0.0366749, 5.92087, 0.0832701),\n    vec3(-1.39287, 7.64723, 0.269163),\n    vec3(-4.9571, 6.65531, -0.00919251),\n    vec3(-3.50706, -4.23017, -0.0283372),\n    vec3(-7.76777, -3.00107, 0.0359688),\n    vec3(-6.43813, -2.19912, 0.1401),\n    vec3(-1.39586, -2.89033, 0.0498788),\n    vec3(-0.47254, 0.419053, 0.000786616),\n    vec3(-7.78067, -3.00069, 0.0978381)\n);\n\nvec3 gon64_12[] = vec3[12](\n    vec3(-11.4216, -9.42619, 0.0951047),\n    vec3(-4.82981, -15.9463, 0.118886),\n    vec3(6.66657, -16.1113, 0.119641),\n    vec3(12.3225, -9.06993, 0.0918153),\n    vec3(15.9922, -1.33152, 0.103125),\n    vec3(12.652, 6.11127, 0.0972589),\n    vec3(8.1771, 13.1942, 0.102126),\n    vec3(-0.325334, 13.5621, 0.0722747),\n    vec3(-8.00059, 13.0954, 0.0973644),\n    vec3(-12.1185, 5.47399, 0.0973365),\n    vec3(-15.1627, -2.1324, 0.0972181),\n    vec3(0.548823, -1.2205, -0.126258)\n);\n\nvec3 dollar4_12[] = vec3[12](\n    vec3(0.130303, 3.38697, 0.199111),\n    vec3(-1.10735, -2.89459, -0.0252111),\n    vec3(-2.67469, 1.61177, 0.0940697),\n    vec3(-1.50788, -1.51962, 0.0635233),\n    vec3(0.0167133, -0.677603, 0.100761),\n    vec3(-0.539129, -2.62806, 0.107023),\n    vec3(-0.370213, 0.814803, 0.15236),\n    vec3(2.47696, -0.341743, 0.212585),\n    vec3(1.53184, 1.66726, 0.0767999),\n    vec3(3.42228, 2.44445, 0.178488),\n    vec3(2.57359, -2.08544, 0.0940824),\n    vec3(1.34369, 0.649971, -0.00137683)\n);\n\nvec3 heart4_12[] = vec3[12](\n    vec3(-0.687123, -17.6358, 0.119676),\n    vec3(9.77666, -9.20554, 0.0811975),\n    vec3(16.2075, -4.16374, 0.0824521),\n    vec3(21.4838, 4.22734, 0.0439286),\n    vec3(20.783, 13.671, 0.15287),\n    vec3(11.004, 13.5154, -0.0279286),\n    vec3(-3.31496, 12.4149, 0.0602602),\n    vec3(-11.5456, 13.5427, 0.127682),\n    vec3(-19.4614, 3.26591, 0.120687),\n    vec3(-11.6221, -0.800815, -0.119034),\n    vec3(-16.6227, -5.17532, 0.123098),\n    vec3(-5.13828, -15.6544, 0.0179506)\n);\n\nvec3 star4_12[] = vec3[12](\n    vec3(-7.53708, 8.2229, 0.118895),\n    vec3(-16.4322, 8.5273, 0.101418),\n    vec3(-6.45548, -0.466683, 0.115216),\n    vec3(-11.0569, -13.8238, 0.118329),\n    vec3(-2.54908, -7.83096, 0.120828),\n    vec3(-1.55015, -14.4138, -0.00914695),\n    vec3(13.0091, -15.9051, 0.0668323),\n    vec3(8.19357, -8.65804, 0.126573),\n    vec3(6.15756, 1.51916, 0.137528),\n    vec3(15.8677, 7.99373, 0.135305),\n    vec3(-0.000730786, 20.5796, 0.119454),\n    vec3(3.08351, 10.7196, 0.129684)\n);\n\nvec3 circle4_12[] = vec3[12](\n    vec3(0.636954, 3.41463, 0.111319),\n    vec3(-2.30042, 2.40711, 0.0444438),\n    vec3(-3.52362, 0.696351, 0.106329),\n    vec3(-2.28476, -1.50314, 0.132982),\n    vec3(-0.348131, -3.5531, 0.138401),\n    vec3(2.28939, -2.52018, 0.0915953),\n    vec3(3.61064, -0.511144, 0.100257),\n    vec3(2.39312, 1.42992, 0.172995),\n    vec3(-0.192222, 5.13839, 0.0350061),\n    vec3(-2.46748, 2.48324, 0.055471),\n    vec3(-0.213747, 5.16418, 0.0206963),\n    vec3(-1.84128, -0.155258, 0.0338473)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0f);\n    for(int i = 0; i < NUMSAMPLES; i++){\n        // Flip sample coordinates vertically so that they match OpenGL's coordinate system\n        fragColor += SAMPLES[i].z * textureLod(iChannel0, (fragCoord + vec2(1,-1) * SAMPLES[i].xy)/iChannelResolution[0].xy, 0.0f);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}