{
    "Shader": {
        "info": {
            "date": "1576810868",
            "description": "don't ask. it was very silly.\n\nwatch the stream highlight here: https://www.twitch.tv/videos/523838443",
            "flags": 0,
            "hasliked": 0,
            "id": "3lcGR2",
            "likes": 2,
            "name": "Twitch: PS1 Singularity Jorts",
            "published": 3,
            "tags": [
                "denim",
                "livecode",
                "twitchstream",
                "jorts"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 446
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a-b), 0.)/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat skeleton(vec3 p) {\n  float thighgap = 1.2;\n  float l1 = linedist(p, vec3(0,thighgap,-1), vec3(0,thighgap,1))-1.;\n  float l2 = linedist(p, vec3(0,-thighgap,-1), vec3(0,-thighgap,1))-1.;\n  float waist = linedist(p, vec3(0,-1,1), vec3(0,1,1))-1.1;\n  return smin(waist, min(l1,l2), 0.2);\n}\n\nfloat loop(vec3 p, vec2 b) {\n  float c = length(p.xz*vec2(1.5,1))-b.x;\n  return 0.5*(length(vec2(c,p.y))-b.y);\n}\n\nfloat crungy = 0.;\nfloat scene(vec3 p) {\n  //the singularity\n  if (fract(iTime/15.) > 0.9) {\n  p.x += sin(p.y*4.+iTime*6.)*0.1;\n  p.y += sin(p.z*4.+iTime*6.)*0.1;\n  }\n  float skel = skeleton(p);\n  float l = min(loop(p-vec3(-1.15,-1,1.1), vec2(0.2,0.05)), loop(p-vec3(-1.15,1,1.1), vec2(0.2,0.05)));\n  float jort = linedist(vec2(skel, p.z), vec2(0,1.3),vec2(0,-1.3))-0.05;\n  crungy = l < jort ? 1. : 0.;\n  return min(l,jort);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.01);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid erot(inout vec3 p, vec3 ax, float ro) {\n  p = mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat diffuse(vec3 n, vec3 l) {\n  return max(dot(n, l), 0.);\n}\n\nfloat spec(vec3 n, vec3 c, vec3 l, float k) {\n  //TODO;\n  vec3 r = reflect(c, n);\n  return pow(max(dot(r, l), 0.), k);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat noise(vec2 p) {\n  vec2 id = floor(p);\n  vec2 co = fract(p);\n  return mix(mix(hash(id),hash(id+vec2(1,0)),co.x),mix(hash(id+vec2(0,1)),hash(id+vec2(1,1)),co.x), co.y)*0.5+0.5;\n}\n\nvec2 rot(vec2 p, float ro) {\n  return mat2(cos(ro),-sin(ro),sin(ro),cos(ro))*p;\n}\n\nfloat maze(vec2 p) {\n  vec2 id = floor(p);\n  vec2 co = fract(p)-0.5;\n  co.y *= sign(hash(id));\n  return abs(abs(co.x+co.y)-0.5)/sqrt(2.);\n}\n\nfloat perlin(vec2 p) {\n  float avg = 0.;\n  float acc = 0.;\n  for (int i = 0; i < 6; i++) {\n    vec2 off = vec2(hash(vec2(float(i), cos(float(i)))),hash(vec2(float(i)+1., cos(float(i)+2.))));\n    float r = acos(-1.)*hash(vec2(float(i*i), cos(float(i)+4.)));\n    avg += noise(rot(p,r)*float(i+1)+off*20.);\n    acc += 1.;\n  }\n  return avg/acc;\n}\n\nvec3 denim(vec2 tex) {\n  float horiz = perlin(tex*vec2(1,90));\n  float vert = perlin(tex*vec2(90,1));\n  float fray = max(smoothstep(-1.1,-1.2,tex.y),crungy);\n  vec3 d = pow(mix(vec3(0.25,0.5,0.7),vec3(1),fray),vec3(2.5))*mix(horiz,vert,fray*0.5+0.5)*mix(0.2,1.5,perlin(rot(tex,0.2)*0.7));\n  float fade = max(cos(iTime+tex.x*0.05)*3.-2.,0.);\n  return mix(d, vec3(0,1,0), fade*smoothstep(0.05,0.,maze(tex*4.)));\n}\n\nvec3 shade(vec3 n, vec3 p, vec3 cam) {\n  vec3 col = mix(denim(p.yz), denim(p.xz), n.y*n.y);\n  n += col*0.1; // alkama's suggestion :3\n  \n  float diff = diffuse(n, vec3(1,0,0)) + diffuse(n, normalize(vec3(-1,1,0))) + diffuse(n, normalize(vec3(-1,0,0)))*0.5 + diffuse(n, normalize(vec3(1,-2,1)))*0.25;\n  float specex = max(mix(4.,0.5,col.b*1.2-0.2),0.);\n  float spec = spec(n, cam, vec3(1,0,0), specex) + spec(n, cam, normalize(vec3(-1,1,0)), specex);\n  return col*diff/4. + spec*0.015;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(-5,0,0);\n  \n  erot(init, vec3(0,0,1), sin(iTime)*0.4);\n  erot(cam, vec3(0,0,1), sin(iTime)*0.4);\n  erot(init, vec3(0,1,0), cos(iTime)*0.4);\n  erot(cam, vec3(0,1,0), cos(iTime)*0.4);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 200; i++) {\n    float dist = scene(p);\n    if (abs(dist) < 0.001) { hit = true; break; }\n    if (distance(p,init) > 100.) break;\n    p += dist*cam;\n  }\n  vec3 n = norm(p);\n  if (hit) {\n    fragColor.xyz = sqrt(shade(n, p, cam));\n  } else {\n    crungy = 0.;\n    fragColor.xyz = sqrt(denim(uv*2.));\n  }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}