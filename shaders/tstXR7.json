{
    "Shader": {
        "info": {
            "date": "1571713684",
            "description": "[url]https://twitter.com/C010011012/status/1270521006235377666[/url]\n[url]https://www.reddit.com/r/perfectloops/comments/h01vcj/aoc_impossible_cube_wave/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tstXR7",
            "likes": 9,
            "name": "Affine Space / Automorphism",
            "published": 3,
            "tags": [
                "voxel",
                "penrose",
                "swirledseries"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "\n\n\n///*\n// Current code for: Affine Space / Automorphism\n// Date: 2020 5/28 (idea/started before then around 5/7)\n// Description: [url]https://twitter.com/C010011012/status/1270521006235377666[/url]\n// [url]https://www.reddit.com/r/perfectloops/comments/h01vcj/aoc_impossible_cube_wave/[/url]\n// Tags: voxel, penrose, swirledseries\n\n\n//\n// TODO:\n// - wave start slow from left come faster\n// - distributed/sharp shadows\n// - interpolate cubes' normals slightly to that of spheres w/same center\n// - to help w shading specular maps look nicer\n\n\n// â†“ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459\n#define TAU (2.*PI)\n\n#define arg mod(float(iFrame)/60./4., 1.)\n\n\n\n// sky box\n// #define sund vec3(cos(TAU*arg), 1., -sin(TAU*arg))\n#define sund normalize(vec3(.4, .5, -1.))\n\nvec3 sky_map (vec3 p, vec3 d) {\n    // return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    // return vec3(.5, .8, .9);\n    float cloudamt2 = 0.;\n    vec2 g = vec2(p.x-p.y, -p.z-p.y);\n    g *= .08;\n    cloudamt2 += .7*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt2 += .3*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt2 = pow(cloudamt2, 1.);\n    return clamp(vec3(.5, .8, .9)*.2+cloudamt2, 0., 1.);\n    // return vec3(.3, .5, .9)+vec3(1.)*cloudamt2;\n    // return texture(iChannel2, d).rgb;\n    float dimness = .5+.5*cos(d.y*PI);\n    \n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    //vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    float sunamt = clamp(dot(d, sund), 0., 1.);\n    float sunglow = pow(sunamt, 1.)*.2;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n    // SKY_COLOR *= 1.-sunhalo;\n    // SKY_COLOR += vec3(1., .9, .6)*sunhalo;\n    SKY_COLOR += vec3(1., 1., 1.)*sunglow*2.;\n    \tdimness = mix(dimness, 1., sunglow);\n    \t// dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return SKY_COLOR*pow(dimness, .05);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(.0+.8*texture(iChannel0, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel0, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.));\n    \n    }\n\n}\n\n\n\n\n\n\n// intersections have a normal and then a distance\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// intersect plane\n#define inter_plane_short(p, d, c, n) ( dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) ( dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    //inter_plane1 = inter_plane_short(p, d, c, -n);\n    //if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n    //    return inter_plane1;\n    //}\n    return inter_sky;\n}\n\n\nfloat h (vec2 p) {\n    float amt = clamp(arg*10.-max(p.x+9., 0.)*0.4, 0., 1.);\n    //float amt = clamp(arg*10.-max(\n    //    length(vec2(p.x-1., -p.y-1.0))*3./2.,\n    //    0.\n    //)*0.5, 0., 1.);\n    amt = -amt*(amt-1.)*1.0+amt;\n    return -amt*2.;\n}\n\n// intersect custom SDF\n// #define SDF(p) (length(p)-2.)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-.3, 0.))-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-.4, 0.))-.07)\n#define SDF(p) (length(vec3(\\\n    max(abs((p).x-.5)-.4, 0.),\\\n    max(((p).y-.5)-.4, 0.),\\\n    max(abs((p).z-.5)-.4, 0.)\\\n))-.07)\n\n#define inf vec2(1e-3, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<200; ++i) {\n        SDFp = SDF(p);\n        if (abs(p.x-.5) > 1. || abs(p.z-.5) > 1. || SDFp > 4.) {\n            break;\n        }\n        else if (abs(SDFp) < 1e-3) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+inf.xyy),\n                    SDF(p+inf.yxy),\n                    SDF(p+inf.yyx)\n                )),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.9;\n    }\n    return inter_sky;\n}\n\n\n\n\nvec4 inter_pillars (vec3 p, vec3 d) {\n    vec4 inter_closest;\n    vec4 inter_current;\n    vec3 camp = p;\n    for (int jumps=0; jumps<10; ++jumps) {\n        vec4 inter_solid1 = inter_SDF(vec3(fract(p.x), p.y+h(floor(p.xz)), fract(p.z)), d);\n        //vec4 inter_solid1 = inter_SDF(p, d);\n        if (inter_solid1.w < inter_sky.w) {\n            // hits sdf - portals will not be hit\n            inter_solid1.w += length(p-camp);\n            return inter_solid1;\n        }\n        // check 4 \"panes\" / portals\n        inter_closest = inter_sky;\n        inter_current = inter_plane(p, d, floor(p)+vec3(1., 0., 0.), normalize(vec3(-1., 0., 0.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 1.), normalize(vec3(0., 0., -1.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 0.), normalize(vec3(1., 0., 0.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        inter_current = inter_plane(p, d, floor(p)+vec3(0., 0., 0.), normalize(vec3(0., 0., 1.)) );\n        if (inter_current.w < inter_closest.w) {\n            inter_closest = inter_current;\n        }\n        p += d*inter_closest.w;\n        p += d*1e-3;\n    }\n    return inter_sky;\n}\n\n\n\n\n// main image - camera/initial raycast, setting pixel color\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 retina = vec3(0.);\n    #define numsamples 1.\n    vec4 randy;\n    for (float samplei=0.; samplei<numsamples; ++samplei) {\n        randy = texture(iChannel1, vec2(\n            samplei/256.+fragCoord.x/256., float(iFrame)/256.+fragCoord.y/256.\n        )).rgba;\n        // -1 to 1 in y, proportional in x\n        vec2 screen = (\n            -iResolution.xy/2.\n            +fragCoord+randy.rg\n        )/iResolution.y*2.;\n        \n        // camera\n        vec3 camp = vec3(screen.xy*4., -20.);\n        vec3 camd = normalize(vec3(0., 0., 1.));\n        \n        // float ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n        #define ph atan(1./sqrt(2.))\n        mat2 zenith = mat2(\n            cos(ph), cos(PI*.5+ph),\n            sin(ph), sin(PI*.5+ph)\n        );\n        camp.yz *= zenith;\n        camd.yz *= zenith;\n        \n        // float th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n        #define th (PI*.25)\n        mat2 azimuth = mat2(\n            cos(th), cos(PI*.5+th),\n            sin(th), sin(PI*.5+th)\n        );\n        camp.xz *= azimuth;\n        camd.xz *= azimuth;\n        \n        camd = normalize(camd);\n        \n        \n        // space skipping\n        vec4 skp = inter_plane(camp, camd, vec3(0., 4., 0.), normalize(vec3(0., 1., 0.)) );\n        if (skp.w < inter_sky.w && skp.w > 0.) {\n            camp += camd*skp.w;\n        }\n        \n        \n        \n        // raytracing\n        vec3 finalCol = vec3(0.);\n        float shiny = 1.;\n        vec3 p = camp;\n        vec3 d = camd;\n        \n        for (int bounces=0; bounces<32; ++bounces) {\n            \n            if (shiny < .1) {\n                break;\n            }\n            \n            vec4 inter_closest = inter_sky;\n            // for (var i in scene... inter_current = scene[i]) {\n                vec4 inter_current = inter_pillars(p, d);\n                if (inter_current.w < inter_closest.w) {\n                    inter_closest = inter_current;\n                }\n            //}\n            \n            if (dot(d, normalize(vec3(0., 1., 0.))) > 0. && p.y > 5.) {\n                // far enough from floor and angled away from such that\n                // ray will garunteed hit sky\n                // finalCol += vec3(1., 0., 0.)*shiny;\n                // shiny *= 0.;\n                break;\n            }\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - stop reflection/refraction loop\n                break;\n            }\n            else {\n                // hits object\n                p += d*inter_closest.w;\n                \n                float czk = mod(floor(p.x)+floor(p.z), 2.);\n                \n                // shadows\n                vec4 shado = inter_pillars(p+sund*2e-3, sund);\n                //vec4 shado = inter_sky;\n                if (shado.w < inter_sky.w) {\n                    #define shininess .6\n                    finalCol += shiny*shininess*vec3(0.);\n                    shiny *= 1.-shininess;\n                    #undef shininess\n                }\n                \n                if (czk < .5){\n                    // have normal and distance to closest itnersection\n                    // reflect, refract, texture, etc.\n                    #define shininess .5\n                    vec3 TEXp = vec3(1.)*mod(floor(p.x*7.)+floor(p.z*7.), 2.);\n                    TEXp = vec3(0.);\n                    //TEXp.rg = vec2(\n                    //    mod((p.x-p.y)*.025, 1.),\n                    //    mod((-p.z-p.y)*.025, 1.)\n                    //)*4.;\n                    finalCol += TEXp*shiny*shininess;\n                    shiny *= 1.-shininess;\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                    #undef shininess\n                }\n                else {\n                    \n                    #define shininess .5\n                    // also .2\n                    vec3 TEXp = abs(inter_closest.xyz);\n                    TEXp.rgb  = vec3(\n                        min(min(TEXp.r, TEXp.g), TEXp.b),\n                        TEXp.r,\n                        max(max(TEXp.r, TEXp.g), TEXp.b)\n                    );\n                    //TEXp = vec3(.0, .2, .6);\n                    TEXp = vec3(0., .7, .7);\n                    finalCol += TEXp*shiny*shininess;\n                    shiny *= 1.-shininess;\n                    d = reflect(d, inter_closest.xyz);\n                    p += d*1e-3;\n                    #undef shininess\n                }\n                \n            }\n        }\n        \n        if (shiny == 1.) {\n            // never hit object - real sky color\n            finalCol += shiny*vec3(0., 1., 100./255.);\n            shiny *= 0.;\n        }\n        // add sky color to final reflection/refraction\n        // finalCol += (vec3(0., 0., 100./255.))*shiny;\n        finalCol += sky_map(p, d)*shiny;\n        retina += finalCol;\n    }\n    fragColor = vec4(retina/numsamples, 1.);\n}\n\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\n// Old Code for: raymarched reflections!\n// Date: 2019 10/22 (around then)\n// Tags: raymarching\n// Description: Coded by me from scratch, with refrence and\n// inspiration from Shanes shader and CodeParade's video, as well as\n// TheArtOfCode's raymarching tutorial\n\n\n// MADE ENTIRELY FROM ME BY SCRATCH FROM TJE START\n// I ONLY COPIED THE FOV USED IN TheArtOfCodes Ray/Sphere intersection tutorial\n// and technique described in this super awesome video by\n// CodeParade https://www.youtube.com/watch?v=svLzmFuSBhk\n\n// \"i swear im trying so hard but my raytracers reflections were\n//  glitching and i couldnt figure out the phong lighting model ;(\"\n// - me before i made THIS\n\n// some help from\n// https://www.shadertoy.com/view/4dt3zn\n// https://www.youtube.com/watch?v=svLzmFuSBhk\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\nconst int LightSourceT_point = 0;\nconst int LightSourceT_ray = 1;\n\nstruct LightSource {\n    int type; \n    vec3 p;\n    vec3 col;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat SDF(vec3 p) {\n    float boxrad = 3.;\n    p = mod(p, boxrad)-boxrad/2.;\n    return sqrt(p.x*p.x/8.+p.y*p.y*2.+p.z*p.z/8.)-.5;\n    // return length(p)-1.5;\n    // return length(p-vec3(1, 1, 2))-1.;\n}\n\nvec3 reflekt(vec3 p) {\n    float inf = 1e-3;\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+inf, p.y, p.z)),\n            SDF(vec3(p.x, p.y+inf, p.z)),\n            SDF(vec3(p.x, p.y, p.z+inf))\n        )-\n        vec3(SDF(p))\n    );\n}\n\nvec3 colour(vec3 p, LightSource[3] lights) {\n    vec3 light = vec3(0., 0., 0.);\n    for (int i=0; i<lights.length(); ++i) {\n        vec3 dir = vec3(0.);\n        if (lights[i].type == LightSourceT_point) {\n            dir = normalize(lights[i].p-p);\n        }\n        else if (lights[i].type == LightSourceT_ray) {\n        \tdir = normalize(lights[i].p);\n        }\n        light.x += dot(dir, reflekt(p))*lights[i].col.x;\n        light.y += dot(dir, reflekt(p))*lights[i].col.y;\n        light.z += dot(dir, reflekt(p))*lights[i].col.z;\n    }\n    light = clamp(light, 0., 1.);\n    return vec3(light);\n}\n\nvec3 march(Ray ray) {\n    LightSource[3] lights;\n    lights[0] = LightSource(LightSourceT_ray, normalize(vec3(1, 2, 0)), vec3(1., 0., 0.));\n    lights[1] = LightSource(LightSourceT_ray, normalize(vec3(2, 0, 0)), vec3(0., 1., 1.));\n    vec3 col = vec3(0.);\n    float rcount = 0.;\n    float rindex = .35;\n    float rmax = 6.;\n    int dmax = 108;\n    for (int i=0; i<dmax && rcount<rmax; ++i) {\n        float DE = SDF(ray.origin);\n        if (DE <= 1e-2) {\n            vec3 col2 = colour(ray.origin, lights);\n            if (rcount == rmax-1.) {\n                col2 = vec3(0., 0., 100./255.);\n            }\n            ray.direction = reflect(ray.direction, reflekt(ray.origin));\n        \tray.origin = ray.origin + ray.direction*1e-2;\n            if (true) {\n                float rindex2 = pow(rindex, rcount);\n                // col2 = vec3(0);\n                col = col*(1.-rindex2)+col2*rindex2;\n                // col = col2;\n\t\t\t}\n            ++rcount;\n        }\n        // if it diverges to far return te background color\n        if (i == dmax-1 && rcount > 0.) {\n            float rindex2 = pow(rindex, rcount);\n            vec3 col2 = vec3(0., 0., 100./255.);\n            col = col*(1.-rindex2)+col2*rindex2;\n        }\n        ray.origin = ray.origin + ray.direction*DE;\n    }\n    if (rcount > 0.) {\n        return col;\n    }\n    return vec3(0., 0., 100./255.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x*2.;\n    vec3 dir = vec3(uv.x, uv.y, 1.);\n    float mag = sqrt(dir.z*dir.z+dir.x*dir.x);\n    float ang = atan(dir.z, dir.x)+(iMouse.x+150.-iResolution.x/2.)/90.;\n    dir = vec3(cos(ang)*mag, dir.y, sin(ang)*mag);\n    float pi = 3.1415926535897;\n    Ray ray = Ray(vec3(0.-(iTime+sin(iTime))/pi*2.*2., 0., 0.), normalize(dir));\n    \n    vec3 retina = march(ray);\n\n    // Output to screen\n    fragColor = vec4(retina, 1.0);\n}\n/**/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}