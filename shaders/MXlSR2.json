{
    "Shader": {
        "info": {
            "date": "1709740312",
            "description": "Normal Mapping Shadow effect implementation. Cast shadow using just normal map and no height data.",
            "flags": 32,
            "hasliked": 0,
            "id": "MXlSR2",
            "likes": 7,
            "name": "Normal Mapping Shadows (test)",
            "published": 3,
            "tags": [
                "shadow",
                "normalmap",
                "normal",
                "nms"
            ],
            "usePreview": 1,
            "username": "yyf1994",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "// Fork of \"Normal Mapping Shadows (NMS)\" by BorisVorontsov. https://shadertoy.com/view/7lBBR3\n// 2024-03-06 15:51:32\n\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Normal Mapping Shadow (NMS)\n// Based on paper http://enbdev.com/doc_normalmappingshadows.htm\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define iSampleCount\t\t\t15\n#define SampleCount\t\t\t\t(float(iSampleCount))\n#define HeightScale\t\t\t\t4.5\n#define ShadowHardness\t\t\t2.0\n#define ShadowLength\t\t\t0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3\tlightposition = vec3(0.0, 0.0, 0.1);\n\tvec3\tplaneposition = vec3(fragCoord.xy / iResolution.y, 0.0);\n\n\tvec2\tcursorposition = iMouse.xy / iResolution.y;\n\tlightposition.xy = cursorposition;\n\tif (iMouse.z <= 0.0)\n\t{\n\t\tlightposition.x = (0.5);\n\t\tlightposition.y = (0.5);\n\t}\n\n\tfloat\tsamplecount = SampleCount;\n\tfloat\tinvsamplecount = 1.0 / samplecount;\n\n\tfloat\thardness = ShadowHardness;\n\n\tvec3\tlightdir = lightposition - planeposition;\n\n\tvec2\tdir = lightdir.xy  ;\n\n\tlightdir = normalize(lightdir.xyz);\n\n\tvec2\tuv = fract(fragCoord.xy / iResolution.y);\n\tvec3\tnormal = texture(iChannel0, uv).xyz;\n\tnormal = normal * 2.0 - 1.0;\n\n\t//lighting with flat normals (from vertex or depth generated)\n\tfloat\tlighting = clamp(dot(lightdir, normal), 0.0, 1.0);\n\n\tfloat\tstep = invsamplecount * ShadowLength;\n\n\t//randomization\n\tvec2\tnoise = fract(fragCoord.xy * 0.5);\n\tnoise.x = (noise.x*0.5 + noise.y)*(1.0/1.5 - 0.25);\n\n\tfloat\tpos = step * noise.x;\n\n\t//do not compute on back faces/pixels //disabled cause while() not supported in Shadertoy\n\t//pos = (-lighting >= 0.0) ? 1.001 : pos;\n\n\tfloat\tslope = -lighting;\n\tfloat\tmaxslope = 0.0;\n\tfloat\tshadow = 0.0;\n\tfor (int i=0; i<1; i++)\n\t{\n\t\tvec3\ttmpNormal = texture(iChannel0, uv + dir * pos).xyz;\n\t\ttmpNormal = tmpNormal * 2.0 - 1.0;\n\n\t\tfloat\ttmpLighting = dot(lightdir, tmpNormal);\n\n\t\tfloat\tshadowed = -tmpLighting;\n\n\t\t//for g-buffer normals of deferred render insert here depth comparison to occlude objects, abstract code example:\n\t\t//vec2\tcropminmax = clamp(1.0 - (depth - tmpDepth) * vec2(4000.0, -600.0), 0.0, 1.0);\n\t\t//cropminmax.x = cropminmax.x * cropminmax.y;\n\t\t//shadowed *= cropminmax.x;\n\n\t\tslope += shadowed;\n\n\t\t//if (slope > 0.0) //cheap, but not correct, suitable for hard shadow with early exit\n\t\tif (slope > maxslope) //more suitable for calculating soft shadows by distance or/and angle\n\t\t{\n\t\t\tshadow += hardness * (1.0-pos);\n\t\t}\n\t\tmaxslope = max(maxslope, slope);\n\n\t\tpos += step;\n\t}\n\n\tshadow = clamp(1.0 - shadow * invsamplecount, 0.0, 1.0);\n\n\t//disable shadow on click\n\t//if (iMouse.w > 0.0) shadow = 1.0;\n\n\t//coloring\n\tvec3\tambientcolor = vec3(0.15, 0.4, 0.6) * 0.7;\n\tvec3\tlightcolor = vec3(1.0, 0.7, 0.3) * 1.2;\n\tfloat\tao = clamp(normal.z, 0.0, 1.0);\n\t fragColor.xyz =  lighting * lightcolor;\n    //v1\n\t//fragColor.xyz+= ambientcolor * (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5);\n    //v2\n\tfragColor.xyz+= ambientcolor;\n\tfragColor.xyz*= (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5); //kinda diffuse\n\tfragColor.w = 1.0;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Prepass generates normal map from picture\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define invNormalMapScale\t\t5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv;\n\tvec2\toffset;\n\tvec3\tnormal;\n\tvec3\theight;\n\toffset = 1.0 / iResolution.xy;\n\tuv = fract(fragCoord.xy / iResolution.xy);\n\theight.x = texture(iChannel0, uv).x;\n\theight.y = texture(iChannel0, uv + vec2(offset.x, 0.0)).x;\n\theight.z = texture(iChannel0, uv + vec2(0.0, offset.y)).x;\n\tnormal.xy = (height.x - height.yz);\n\tnormal.xy /= offset;\n\tnormal.z = invNormalMapScale;\n\tnormal = normalize(normal);\n\tnormal = normal * 0.5 + 0.5;\n\tfragColor = vec4(normal, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}