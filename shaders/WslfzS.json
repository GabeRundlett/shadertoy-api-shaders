{
    "Shader": {
        "info": {
            "date": "1588957951",
            "description": "'Old skool' CRT monitor developed using raymarching.\n(Still getting the hang of occlusion and shadows...)",
            "flags": 2,
            "hasliked": 0,
            "id": "WslfzS",
            "likes": 10,
            "name": "Raymarched CRT",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "crt",
                "webcam"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 543
        },
        "renderpass": [
            {
                "code": "float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\n// Smooth noise generator.\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f); // smoothstep with no clamp.\n    \n    return mix(a, b, f.x) +\n           (c - a) * f.y * (1.0 - f.x) +\n           (d - b) * f.x * f.y;\n}\n\nmat2 rot(float ang) {\n\tfloat c = cos(ang);\n    float s = sin(ang);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdIntersect(float d1, float d2) { return max(d1, d2); }\n\nfloat sdFrame(vec3 p) {\n    float ang = 0.2;\n    \n    vec3 q = p;\n    q.y = abs(q.y);\n    \n    float tb = length((q.yz * rot(-ang)).x - 1.0);\n\n    q = p;\n    q.x = abs(q.x);\n    float lr = length((q.xz * rot(-ang)).x - 1.0);\n    \n    float d = smin(lr, tb, 0.05); // Smooth corners.\n    float dp = length(p.z) - 0.75; // Clip frame front/back.\n    \n    float surface = noise((p.xy + p.yz) * 60.0);\n    return sdIntersect(d, dp) - surface * 0.001;\n}\n\nfloat length6( vec3 p ) { p=p*p*p; p=p*p; return pow(p.x+p.y+p.z,1.0/6.0); }\n\nfloat sdScreen(vec3 p) {\n    float d = length(p) - 1.1;\n    float d2 = length6(p) - 1.1;\n\n    float surface = noise((p.xy + p.yz) * 200.0);\n    return mix(d, d2, 0.8) - surface * 0.0001;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdFrame(p);\n    float d2 = sdScreen(p);\n    return d1 < d2 ? vec2(d1, 0.5) : vec2(d2, 1.5);\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks community! I didn't fancy deriving this...\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.0);\n        n += e * map(p + 0.0005 * e).x;\n    }\n    \n    return normalize(n);\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin, float fuzziness) {\n    float s = 1.0;\n    \n    vec3 rayDir = normalize(lightOrigin - origin);\n    float d = 1.0;\n    while (d < 20.0 && s > 0.0) {\n        float distToObj = map(origin + rayDir * d).x;\n        s = min(s, 0.5 + 0.5 * distToObj / (fuzziness * d));\n        d += clamp(distToObj, 0.2, 1.0);\n    }\n    \n    return smoothstep(0.0, 1.0, s);\n}\n\nfloat calcOcclusion(vec3 origin, vec3 n, float unu) {\n    float occ = 0.0;\n    float d = 0.01;\n    for (int i = 1; i < 5; i++) {\n        float h = map(origin + n * d).x;\n        occ += d - h;\n        d += 0.15;\n    }\n    \n    return 1.0 - clamp(occ * 0.5, 0.0, 1.0);\n}\n\nfloat calcSpec(vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l - rd);\n    return pow(max(dot(h, n), 0.0), 100.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0); // z = -3.0\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 lightPos = normalize(vec3(5.0, 10.0, -10.0));\n    \n    float d = 0.01;\n    vec2 hit;\n    vec3 p;\n    for(float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        vec2 dist = map(p);\n        if (abs(dist.x) < 0.001 * d) {\n\t\t\thit = dist;\n            break;\n        }\n        if (d > 8.0)\n            break;// todo - limit max dist\n        \n        d += dist.x;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (hit.y > 0.0) {\n        vec3 n = calcNormal(p);\n        float mainLight = clamp(dot(n, lightPos), 0.2, 1.0);\n\t\tfloat occ = calcOcclusion(p, n, 0.5);\n        vec3 rearLight = vec3(0.1, 1.0, 0.1) * clamp(dot(n, vec3(0.0, 0.0, -1.0)), 0.0, 1.0);\n            \n        if (hit.y > 1.0) {\n            // Hit screen.\n            vec2 t = uv * 0.85;\n            t.x *= mix(1.0, 2.0, pow(abs(t.x) / 0.5, 5.0));\n            vec3 tex = texture(iChannel0, t + 0.5).rgb;\n            float lum = 0.2126 * tex.r + 0.7152 * tex.g + 0.0722 * tex.b;\n            float scanline = 0.3 + 0.7 * floor(mod(t.y * iResolution.y * 0.3 / cos(p.x * 0.5), 2.0));\n            col = vec3(0.1, 1.0, 0.1) * pow(lum * 2.0, 1.7) * pow(mainLight, 3.0) * scanline;\n        } else {\n            // Hit frame.\n\t        col = vec3(mainLight);\n            col *= calcShadow(p + 0.01 * d, lightPos, 1.0);\n\t        col += rearLight;\n        }\n        \n        col *= pow(occ, 2.0);\n        col += calcSpec(rd, n, lightPos) * 0.3;\n    }\n    \n    fragColor = vec4(pow(col , vec3(0.4545)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}