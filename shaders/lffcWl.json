{
    "Shader": {
        "info": {
            "date": "1721759491",
            "description": "Game of Life inspired hexagonal automaton.\n\nRuleset definition and explanation in Common Tab.\n\nSimulation grid is true hexagonal, edges connect top to bottom, bottom left to top right, and bottom right to top left.",
            "flags": 32,
            "hasliked": 0,
            "id": "lffcWl",
            "likes": 6,
            "name": "Hexagonal Life",
            "published": 3,
            "tags": [
                "2d",
                "life",
                "hex",
                "cellularautomaton"
            ],
            "usePreview": 0,
            "username": "draradech",
            "viewed": 126
        },
        "renderpass": [
            {
                "code": "// \"Hexagonal Life\" by Draradech - 2024\n// License CC BY-NC-SA 4.0\n//\n// HexDist and HexCoords based on https://www.shadertoy.com/view/3sSGWt\n\n#define SR3 1.732\n#define HSR3 0.866\n\nfloat HexDist(vec2 p)\n{\n\tp = abs(p);\n    float dh = dot(p, normalize(vec2(1, SR3)));\n    float dx = p.x;\n    return max(dx, dh);\n}\n\nvec4 HexCoords(vec2 uv)\n{\n\tvec2 r = vec2(1, SR3);\n    vec2 h = r * .5;\n    \n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n    \n    vec2 guv = dot(a, a) < dot(b, b) ? a : b;\n    \n    float phi = atan(guv.x, guv.y);\n    float d = .5 - HexDist(guv);\n    vec2 id = uv - guv;\n    float row = floor(id.y / HSR3 + .5);\n    float col = floor(id.x - .5 * row + .5);\n    return vec4(d, phi, col, row);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = mix(vec3(.1,.05,.3), vec3(.05,.1,.3), (uv + 1. / 2.).y);\n\n    uv *= N;\n    vec4 hex = HexCoords(uv);\n    vec2 pos = hex.wz;\n    float d = hex.x;\n    \n    if (validPos(pos))\n    {\n        float cell = smoothstep(0., .05, d - .05);\n        float v = valueFetch(pos, iChannel0);\n        if (v == 0.) col = mix(col, vec3(.2, .2, .3), cell);\n        else col = mix(col, mix(vec3(.05, .7, .7), vec3(.6, .05, .6), v / (adult_age)), cell);\n    }\n    \n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nRuleset:\n\n- Empty cells with exactly two adult neighbors become a new child.\n- Cells with more than 2 adult neighbors or more than 3 neighbors in general die to overcrowding.\n- Cells with no neighbors die to loneliness.\n- Children grow each step, a child of age 5 becomes an adult.\n*/\n\n#define adult_age 5.\n#define parents_required 2.\n#define allow_more_parents false\n#define overcrowd_adult 2.\n#define overcrowd_all 3.\n#define lonely_limit 1.\n\n// ruleset dies eventually - uncomment this to add children randomly to keep it going\n//#define cheat_probability .0005\n\n// grid radius\n#define N 20.\n\n// slow simulation down by this factor\n#define SLOWDOWN 5\n\n\n\nbool validPos(vec2 pos)\n{\n    return pos.x > -N && pos.y > -N && pos.x < N && pos.y < N && pos.x + pos.y > -N && pos.x + pos.y < N;\n}\n\nint invalidWhy(vec2 pos)\n{\n    int reason = 0;\n    \n         if (pos.y <= -N && !(pos.x + pos.y <= -N)) reason = 1;\n    else if (pos.x >= N) reason = 2;\n    else if (pos.x + pos.y >= N) reason = 3;\n    else if (pos.y >= N) reason = 4;\n    else if (pos.x <= -N) reason = 5;\n    else if (pos.x + pos.y <= -N) reason = 6;\n    return reason;\n}\n\nfloat valueFetch(vec2 pos, sampler2D s)\n{\n    if (!validPos(pos))\n    {\n        int reason = invalidWhy(pos);\n        if (reason == 1) { pos.x -= N;             pos.y += (2. * N - 1.); }\n        if (reason == 2) { pos.x -= (2. * N - 1.); pos.y += (N - 1.);      }\n        if (reason == 3) { pos.x -= (N - 1.);      pos.y -= N;             }\n        if (reason == 4) { pos.x += N;             pos.y -= (2. * N - 1.); }\n        if (reason == 5) { pos.x += (2. * N - 1.); pos.y -= (N - 1.);      }\n        if (reason == 6) { pos.x += (N - 1.);      pos.y += N;             }\n    }\n    return texelFetch(s, ivec2(pos + vec2(N - 1.)), 0).x;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float hash(float v)\n{\n    return fract(sin(v) * 5897.);\n}\n\nfloat frand(vec2 c)\n{\n    return hash(c.x + 983. * hash(c.y + 911. * hash(iDate.w)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = fragCoord - vec2(N -.5);\n\n    if (!validPos(pos))\n    {\n        discard;\n        return;\n    }\n    \n    if (iFrame == 0)\n    {\n        fragColor = vec4(floor((adult_age + 1.) * pow(frand(pos + vec2(123, 321)), 0.5) * step(0.8, frand(pos))));\n        return;\n    }\n    \n    if (iFrame % SLOWDOWN != 0)\n    {\n        fragColor = vec4(valueFetch(pos, iChannel0));\n        return;\n    }\n    \n    float self = valueFetch(pos, iChannel0);\n\n    #ifdef cheat_probability\n    if (self == 0. && frand(pos) < cheat_probability) self = 1.;\n    #endif\n    \n    float n = 0.;\n    float ad = 0.;\n    for (float dx = -1.; dx <= 1.; dx++)\n    {\n        for (float dy = -1.; dy <= 1.; dy++)\n        {\n            if (dx == dy) continue; // self or not neighbour\n            float v = valueFetch(vec2(pos.x + dx, pos.y + dy), iChannel0);\n            if (v == adult_age) {n++; ad++;}\n            else if (v > 0.) {n++;}\n        }\n    }\n    \n    if (self == 0. && (ad == parents_required || (allow_more_parents && ad > parents_required))) self = 1.; // new child\n    else if (ad > overcrowd_adult || n > overcrowd_all) self = 0.; // overcrowded\n    else if (n < lonely_limit) self = 0.; // lonely\n    else if (self > 0.) self = min(adult_age, self + 1.); // grow\n    \n    fragColor = vec4(self);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}