{
    "Shader": {
        "info": {
            "date": "1432379559",
            "description": "Just to show off to some friends what could be done with 2D shaders, with some simple code to start having things on your screen...\nI'm aware that it's ugly :)\nMade on GlSlSandbox here :\nhttp://glslsandbox.com/e#24464.1",
            "flags": 0,
            "hasliked": 0,
            "id": "MlBGWK",
            "likes": 9,
            "name": "Beware your eyes ",
            "published": 3,
            "tags": [
                "2d",
                "ugly",
                "spiral"
            ],
            "usePreview": 0,
            "username": "ManuManu",
            "viewed": 3630
        },
        "renderpass": [
            {
                "code": "\n\n\nfloat rand( vec2 p )\n{\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat noise(vec2 _v, vec2 _freq)\n{\n\tfloat fl1 = rand(floor(_v * _freq));\n\tfloat fl2 = rand(floor(_v * _freq) + vec2(1.0, 0.0));\n\tfloat fl3 = rand(floor(_v * _freq) + vec2(0.0, 1.0));\n\tfloat fl4 = rand(floor(_v * _freq) + vec2(1.0, 1.0));\n\tvec2 fr = fract(_v * _freq);\n\n\t// linear interpolate\n\tfloat r1 = mix(fl1, fl2, fr.x);\n\tfloat r2 = mix(fl3, fl4, fr.x);\n\treturn mix(r1, r2, fr.y);\n}\n\nfloat perlin_noise(vec2 _pos, float _freq_start, float _amp_start, float _amp_ratio)\n{\n\tfloat freq = _freq_start;\n\tfloat amp = _amp_start;\n\tfloat pn = noise(_pos, vec2(freq, freq)) * amp;\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tfreq *= 2.0;\n\t\tamp *= _amp_ratio;\n\t\tpn += (noise(_pos, vec2(freq, freq)) * 2.0 - 1.0) * amp;\n\t}\n\treturn pn;\n}\n\n\n// disk :\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tvec3 col = vec3( .1, .9, .1 );\n\tif ( length( uv ) < .5 ) col = vec3( .9, .1, .1 );\n\tfragColor = vec4(col, 1.);\n}//*/\n/*\n\n// diamonds\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( length(sin(20.*uv + sin(iTime)))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(length(40.0*uv))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin( (-9. + .0*cos(iTime))*iTime + length(40.*uv))), 1.);\n}//*/\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(iTime + length(40.*uv))), 1.);\n\n\tgl_FragColor = vec4(vec3( sin(cos(time) + length(40.*uv))), 1.);\n}\n//*/\n/*\n// repeating quarter of circles :\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\n\tfragColor = vec4(vec3( sin(cos(iTime) + length(40.*mod(3.*uv, 1.)))), 1.);\n}//*/\n/*\n// cool error :\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(cos(iTime) + length(40.*mod(3.*abs(uv), 1.)))), 1.);\n}//*/\n//repeating circles :\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfragColor = vec4(vec3( sin(cos(iTime) +  length(40.*(mod(3.*uv, 1.)-.5)))), 1.);\n}//*/\n// combining everything : \nfloat Mylength(vec2 pos)\n{\n\treturn max(abs(pos.x), abs(pos.y));\n}\n\n// Spiral\n//#define F(x) (log(x))\n//#define F(x) (x <= 0.1 ? 10.*x : log(x))\n//#define F(x) 0.5*x\n#define F(x) (x)\n//#define F(x) pow(x,1.414213562373095)\n//#define F(x) pow(x,2.0)\n//#define F(x) pow(x,10.0)\n//#define F(x) pow(x,42.0)\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6./PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*F(r)+iTime+a);\n\t\n\tfloat val = float(twist > .5);\n\tfragColor = vec4(vec3( val ), 1.);\n}\n//*/\n\n//*\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv -=.5;\n\t//uv.x += sin(iTime)*.005*cos( 80.*uv.y + 10.*iTime);\n\t//uv.x += cos(uv.x * .5*sin(2.*iTime));\n\t//uv.y += cos(uv.y * cos(iTime));\n\tuv.x *= iResolution.x/ iResolution.y;\n\n\tfloat val1 = sin(cos(3.*iTime) +  length(40.*(mod(3.*uv, 1.)-.5)));\n\tfloat val2 = sin(cos(5.*iTime) +  Mylength(40.*(mod(4.*uv, 1.)-.5)));\n\tfloat val3 = length(sin(20.*uv)+sin(10.*iTime));\n\n\tconst float PI = 3.14159265358979323846264;\n\tfloat a = atan(uv.x, uv.y ) * 6./PI;\n\tfloat r = length(uv);\n\tfloat twist = fract(-4.*r+iTime+a);\n\tfloat val = float(twist > .5);\n\t\n\tvec3 finalColor1 = vec3( val1 * val2+val3, val1+val2, val2-val1 );\n\tvec3 finalColor2 = vec3( (val1 + val2+val3)/3., (val1-val2)/2., val2*val1/2. );\n\t//vec3 finalColor2 = vec3(sin(50.*uv.y - 10.*iTime));\n\t\n\tvec3 FinalColor= mix( finalColor1, finalColor2, val) ;\n    //vec3 FinalColor = finalColor1;\n    FinalColor -= perlin_noise( uv, 10., 2., .5 );\n\tfragColor = vec4(FinalColor, 1.);\n}\n//*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}