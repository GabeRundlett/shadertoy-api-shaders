{
    "Shader": {
        "info": {
            "date": "1553679162",
            "description": "Scattering trajectories (medium-range attraction, short-range repulsion)",
            "flags": 32,
            "hasliked": 0,
            "id": "wsjSW1",
            "likes": 21,
            "name": "Particle Scattering",
            "published": 3,
            "tags": [
                "collision",
                "dynamics",
                "trajectory"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 628
        },
        "renderpass": [
            {
                "code": "// \"Particle Scattering\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nvec3 HsvToRgb (vec3 c);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\n\n#define MAX_PART  20\n\nvec3 ltDir, qHit;\nfloat dstFar;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q, vec3 (1., 1., 0.01));\n  DMINQ (1);\n  d = max (PrBoxAn2Df (q.xy, vec2 (1.025), 0.05), abs (q.z) - 0.05);\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, bLen;\n  int nPart;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      if (vn.z < -0.99) {\n        nPart = int (Loadv4 (ivec2 (2 * MAX_PART, 0)).x);\n        bLen = Loadv4 (ivec2 (2 * MAX_PART, 0)).y;\n        col = LoadTx (0.5 * qHit.xy + 0.5).rgb;\n        for (int n = 0; n < MAX_PART; n ++) {\n          if (n == nPart) break;\n          col = mix (HsvToRgb (vec3 (float (n) / float (nPart), 1., 1.)), col,\n             smoothstep (0.02, 0.03, length (Loadv4 (ivec2 (2 * n, 0)).xy / (0.5 * bLen) - qHit.xy)));\n        }\n      }\n    } else if (idObj == 2) col = vec3 (0.5, 0.3, 0.1);\n    col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n  } else {\n    col = vec3 (0.6, 0.6, 1.) * (0.2 + 0.2 * (rd.y + 1.) * (rd.y + 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -6.);\n  dstFar = 20.;\n  ltDir = vuMat * normalize (vec3 (0., 0.1, -1.));\n  rd = vuMat * normalize (vec3 (uv, 5.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Particle Scattering\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2);\nfloat LineDist (vec2 p, vec2 v1, vec2 v2);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define MAX_PART  20\n\nconst int nPart = 16, nSiteF = 5;\nvec2 rSiteF[nSiteF];\nfloat tCur, bLen;\nconst float pi = 3.14159;\n\nvec4 Step (vec4 q)\n{\n  // wall potl: 4 (1/r^12 - 1/r^6)  force: 48 (1/r^12 - 0.5/r^6) r/r^2\n  // site potl: 32 (1/r^8 - 1/r^4)  force: 256 (1/r^8 - 0.5/r^4) r/r^2\n  vec2 r, rv, f, dr;\n  float rCutC, rCutA, rrCutA, rr, rri, rri2, rri3, dt;\n  rCutC = pow (2., 1./6.);\n  rCutA = 6.;\n  rrCutA = rCutA * rCutA;\n  dt = 0.01;\n  r = q.xy;\n  rv = q.zw;\n  f = vec2 (0.);\n  for (int j = 0; j < nSiteF; j ++) {\n    dr = r - rSiteF[j];\n    rr = dot (dr, dr);\n    if (rr < rrCutA) {\n      rri = 1. / rr;\n      rri2 = rri * rri;\n      f += 256. * rri2 * (rri2 - 0.5) * rri * dr;\n    }\n  }\n  dr = 0.5 * (bLen + rCutC) - abs (r);\n  if (dr.x < rCutC) {\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x -= 48. * rri3 * (rri3 - 0.5) * rri * dr.x * sign (r.x);\n  }\n  if (dr.y < rCutC) {\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y -= 48. * rri3 * (rri3 - 0.5) * rri * dr.y * sign (r.y);\n  }\n  f += 0.01 * (4. - length (rv)) * normalize (rv);\n  rv += dt * f;\n  r += dt * rv;\n  return vec4 (r, rv);\n}\n\nvec4 Init (int mId)\n{\n  vec2 r, rv;\n  float a;\n  a = (float (mId) + 0.5) * 2. * pi / float (nPart);\n  r = 0.4 * bLen * vec2 (sin (a), cos (a));\n  a = 2. * pi * Hashff (float (mId) + 13. + tCur);\n  rv = 4. * vec2 (cos (a), sin (a));\n  return vec4 (r, rv);\n}\n\nvoid SetSites ()\n{\n  float a;\n  for (int j = 0; j < nSiteF; j ++) {\n    a = (float (j) + 0.5) * 2. * pi / float (nSiteF);\n    rSiteF[j] = 0.3 * bLen * vec2 (sin (a), cos (a));\n  }\n}\n\nvec4 ShowScene (vec2 uv, vec4 col)\n{\n  vec2 p, r, rp;\n  float s;\n  col = mix (col, vec4 (0.1), 0.002);\n  p = bLen * (uv - 0.5);\n  for (int n = 0; n < nPart; n ++) {\n    r = Loadv4 (ivec2 (2 * n, 0)).xy;\n    rp = Loadv4 (ivec2 (2 * n + 1, 0)).xy;\n    s = SegDist (p, rp, r);\n    if (s < 0.07) col = vec4 (HsvToRgb (vec3 (float (n) / float (nPart), 1., 1.)) *\n       (1. - 0.5 * smoothstep (0.04, 0.07, LineDist (p, rp, r))), 1.);\n  }\n  for (int j = 0; j < nSiteF; j ++)\n     col = mix (vec4 (0.8), col, smoothstep (0.6, 0.8, length (p - rSiteF[j])));\n  return col;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec2 uvtx;\n  ivec2 iFrag;\n  int mId;\n  bool doInit;\n  tCur = iTime;\n  uvtx = fragCoord / txSize;\n  iFrag = ivec2 (fragCoord);\n  doInit = (iFrame <= 5);\n  bLen = 16.;\n  SetSites ();\n  if (Loadv4 (ivec2 (2 * MAX_PART, 0)).z != txSize.x) doInit = true;\n  fragColor = doInit ? vec4 (0.1) : ShowScene (uvtx, LoadTx (uvtx));\n  if (iFrag.y == 0 && (iFrag.x < 2 * nPart || iFrag.x == 2 * MAX_PART)) {\n    if (iFrag.x < 2 * nPart) {\n      mId = iFrag.x / 2;\n      if (doInit) {\n        stDat = Init (mId);\n        if (iFrag.x == 2 * mId + 1) stDat = vec4 (stDat.xy, 0., 0.);\n      } else {\n        stDat = Loadv4 (ivec2 (2 * mId, 0));\n        if (iFrag.x == 2 * mId) stDat = Step (stDat);\n        else stDat = vec4 (stDat.xy, 0., 0.);\n      }\n    } else {\n      stDat = vec4 (float (nPart), bLen, txSize);\n    }\n    Savev4 (iFrag, stDat, fragColor, fragCoord);\n  }\n}\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2)\n{\n  vec2 a, b;\n  float s;\n  a = p - v1;\n  b = v2 - v1;\n  s = length (b);\n  b = (s > 0.) ? b / s : vec2 (0.);\n  return length (a - clamp (dot (a, b), 0., s) * b);\n}\n\nfloat LineDist (vec2 p, vec2 v1, vec2 v2)\n{\n  vec2 a, b;\n  float s;\n  a = p - v1;\n  b = v2 - v1;\n  s = length (b);\n  b = (s > 0.) ? b / s : vec2 (0.);\n  return length (a - dot (a, b) * b);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vec2 (idVar) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Particle Scattering\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2);\nfloat LineDist (vec2 p, vec2 v1, vec2 v2);\nvec3 HsvToRgb (vec3 c);\nfloat Hashff (float p);\nvec4 LoadTx (vec2 uv);\nvec4 Loadv4 (ivec2 idVar);\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define MAX_PART  20\n\nconst int nPart = 16, nSiteF = 5;\nvec2 rSiteF[nSiteF];\nfloat tCur, bLen;\nconst float pi = 3.14159;\n\nvec4 Step (vec4 q)\n{\n  // wall potl: 4 (1/r^12 - 1/r^6)  force: 48 (1/r^12 - 0.5/r^6) r/r^2\n  // site potl: 32 (1/r^8 - 1/r^4)  force: 256 (1/r^8 - 0.5/r^4) r/r^2\n  vec2 r, rv, f, dr;\n  float rCutC, rCutA, rrCutA, rr, rri, rri2, rri3, dt;\n  rCutC = pow (2., 1./6.);\n  rCutA = 6.;\n  rrCutA = rCutA * rCutA;\n  dt = 0.01;\n  r = q.xy;\n  rv = q.zw;\n  f = vec2 (0.);\n  for (int j = 0; j < nSiteF; j ++) {\n    dr = r - rSiteF[j];\n    rr = dot (dr, dr);\n    if (rr < rrCutA) {\n      rri = 1. / rr;\n      rri2 = rri * rri;\n      f += 256. * rri2 * (rri2 - 0.5) * rri * dr;\n    }\n  }\n  dr = 0.5 * (bLen + rCutC) - abs (r);\n  if (dr.x < rCutC) {\n    rri = 1. / (dr.x * dr.x);\n    rri3 = rri * rri * rri;\n    f.x -= 48. * rri3 * (rri3 - 0.5) * rri * dr.x * sign (r.x);\n  }\n  if (dr.y < rCutC) {\n    rri = 1. / (dr.y * dr.y);\n    rri3 = rri * rri * rri;\n    f.y -= 48. * rri3 * (rri3 - 0.5) * rri * dr.y * sign (r.y);\n  }\n  f += 0.01 * (4. - length (rv)) * normalize (rv);\n  rv += dt * f;\n  r += dt * rv;\n  return vec4 (r, rv);\n}\n\nvec4 Init (int mId)\n{\n  vec2 r, rv;\n  float a;\n  a = (float (mId) + 0.5) * 2. * pi / float (nPart);\n  r = 0.4 * bLen * vec2 (sin (a), cos (a));\n  a = 2. * pi * Hashff (float (mId) + 13. + tCur);\n  rv = 4. * vec2 (cos (a), sin (a));\n  return vec4 (r, rv);\n}\n\nvoid SetSites ()\n{\n  float a;\n  for (int j = 0; j < nSiteF; j ++) {\n    a = (float (j) + 0.5) * 2. * pi / float (nSiteF);\n    rSiteF[j] = 0.3 * bLen * vec2 (sin (a), cos (a));\n  }\n}\n\nvec4 ShowScene (vec2 uv, vec4 col)\n{\n  vec2 p, r, rp;\n  float s;\n  col = mix (col, vec4 (0.1), 0.002);\n  p = bLen * (uv - 0.5);\n  for (int n = 0; n < nPart; n ++) {\n    r = Loadv4 (ivec2 (2 * n, 0)).xy;\n    rp = Loadv4 (ivec2 (2 * n + 1, 0)).xy;\n    s = SegDist (p, rp, r);\n    if (s < 0.07) col = vec4 (HsvToRgb (vec3 (float (n) / float (nPart), 1., 1.)) *\n       (1. - 0.5 * smoothstep (0.04, 0.07, LineDist (p, rp, r))), 1.);\n  }\n  for (int j = 0; j < nSiteF; j ++)\n     col = mix (vec4 (0.8), col, smoothstep (0.6, 0.8, length (p - rSiteF[j])));\n  return col;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec2 uvtx;\n  ivec2 iFrag;\n  int mId;\n  bool doInit;\n  tCur = iTime;\n  uvtx = fragCoord / txSize;\n  iFrag = ivec2 (fragCoord);\n  doInit = (iFrame <= 5);\n  bLen = 16.;\n  SetSites ();\n  if (Loadv4 (ivec2 (2 * MAX_PART, 0)).z != txSize.x) doInit = true;\n  fragColor = doInit ? vec4 (0.1) : ShowScene (uvtx, LoadTx (uvtx));\n  if (iFrag.y == 0 && (iFrag.x < 2 * nPart || iFrag.x == 2 * MAX_PART)) {\n    if (iFrag.x < 2 * nPart) {\n      mId = iFrag.x / 2;\n      if (doInit) {\n        stDat = Init (mId);\n        if (iFrag.x == 2 * mId + 1) stDat = vec4 (stDat.xy, 0., 0.);\n      } else {\n        stDat = Loadv4 (ivec2 (2 * mId, 0));\n        if (iFrag.x == 2 * mId) stDat = Step (stDat);\n        else stDat = vec4 (stDat.xy, 0., 0.);\n      }\n    } else {\n      stDat = vec4 (float (nPart), bLen, txSize);\n    }\n    Savev4 (iFrag, stDat, fragColor, fragCoord);\n  }\n}\n\nfloat SegDist (vec2 p, vec2 v1, vec2 v2)\n{\n  vec2 a, b;\n  float s;\n  a = p - v1;\n  b = v2 - v1;\n  s = length (b);\n  b = (s > 0.) ? b / s : vec2 (0.);\n  return length (a - clamp (dot (a, b), 0., s) * b);\n}\n\nfloat LineDist (vec2 p, vec2 v1, vec2 v2)\n{\n  vec2 a, b;\n  float s;\n  a = p - v1;\n  b = v2 - v1;\n  s = length (b);\n  b = (s > 0.) ? b / s : vec2 (0.);\n  return length (a - dot (a, b) * b);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 LoadTx (vec2 uv)\n{\n  return texture (txBuf, uv);\n}\n\nvec4 Loadv4 (ivec2 idVar)\n{\n  return texture (txBuf, (vec2 (idVar) + 0.5) / txSize);\n}\n\nvoid Savev4 (ivec2 idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  d = abs (fCoord - vec2 (idVar) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}