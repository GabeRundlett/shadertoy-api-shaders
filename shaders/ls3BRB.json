{
    "Shader": {
        "info": {
            "date": "1525682084",
            "description": "raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "ls3BRB",
            "likes": 3,
            "name": "raymarching_testing_00",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "PhuHUYNH",
            "viewed": 475
        },
        "renderpass": [
            {
                "code": "#define COL 0\n#define TEST_INTERACTION 1\n\n\n//#define _time iTime\n#define _time 15.0\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdPlanXZ( vec3 p)\n{\n    return p.y;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 c = vec3 (-3., -2., 0.);\n    vec2 res = vec2(sdPlanXZ(p -vec3(0., -2.5, 0.)), -.1);    \n    \n    //return vec2(sdSphere(p - vec3(0., 0., 0.), 1.55),.7);\n    res = opU(vec2(sdSphere(p - vec3(0., 0., 0.), 1.55),.7), \n              vec2(sdSphere(p - vec3(3. * sin(_time * .5), 0., 3. * cos(_time *.5)), .5),.2));\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    //Light setup\n\tvec3 light = vec3(10.0 * sin(_time / 10.), 7.0, cos(_time / 10.) * 10.0);\n    \n\t//U = (-1.0 + 2.0*U.xy / iResolution.xy) * \n\t\t//vec2(iResolution.x/iResolution.y, 1.0);\n    U =  ( 2. * U - iResolution.xy) / iResolution.y; \n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(U, 1.0));\n\t\n    O = vec4(0.); // Sky color\n\n    //float t = 0.0;\n    float t = 2.*fract(4e4*sin(4e4*dot(U,vec2(1,17.7))));\n    \n    const int maxSteps = 64;\n    float epsilon = 0.005;\n    const float tmax = 20.;\n    vec2 res = vec2 (.0, -.5);\n    vec3 p = vec3(.0);\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        p = ro + rd * t;\n        res = map(p); // Distance to sphere of radius 0.5\n        if(res.x < epsilon || t > tmax)\n        {\n            break;\n        }\n        O.w ++;\n\n        t += res.x;\n    }\n    \n    if (t <= tmax)\n    {\n        vec3 nor = calcNormal( p );\n        vec3 ref = reflect( rd, nor );\n        float dif = max(0.0, dot(nor, normalize(light - p))); //diffuse.\n        if (res.y == -.1)\n        {\n            O.xyz = vec3(.3, .3, .3) * dif + vec3(0.2, 0.1, 0.2);\n        }\n        else \n            O.xyz = vec3(.5, .5, .5) * dif + vec3(0.1, 0.1, 0.1);\n    }\n   \n    // comment if you want save image :-)\n    //if ( iMouse.z>0. || length(iMouse.xy)<10. && mod(_time * 4.,2.)<1.) \n    //{ O *= 2.; return; }\n    \n    //O.w = U.x;\n    //O.w = clamp(O.w,0., 1.);\n#if 1    \n#if COL\n    float n = O.w *= 7.*epsilon;\n   \n    O = .6 - .6 * sin( 6. * O.w + .2 + vec4(0,2.1,-2.1,0)  );\n    O /= ceil(n);\n#else\n# if 0\n    if (O.w < 10.) { O=vec4(1,0,0,0); return;}\n    if (O.w < 16.) { O=vec4(0,1,0,0); return;}\n    if (O.w ==64.) { O=vec4(0,0,1,0); return;}\n# else\n    O = O.wwww / 70.;  \n   \n    if (O.w > 1.) O = vec4(1,0,0,0);\n    if (O.w < 0.) O = vec4(0,0,1,0);\n# endif\n#endif\n#endif //#TEST_INTERACTION\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}