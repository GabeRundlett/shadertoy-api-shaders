{
    "Shader": {
        "info": {
            "date": "1540302922",
            "description": "Lunchtime hacked version of that motion illusion image.\nSorry, I don't know the original source.\nUpdate: perhaps by Yurii Perepadia https://www.instagram.com/p/BqVQ1fjBF2E/ or @BeauDeeley  ",
            "flags": 0,
            "hasliked": 0,
            "id": "4ldBR2",
            "likes": 59,
            "name": "Motion Illusion",
            "published": 3,
            "tags": [
                "illusion",
                "motion"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 2255
        },
        "renderpass": [
            {
                "code": "// Motion Illusion - @P_Malin\n// https://www.shadertoy.com/view/4ldBR2\n\n// Lunchtime hacked version of that motion illusion image.\n// Sorry, I don't know the original source.\n// Update: perhaps by Yurii Perepadia https://www.instagram.com/p/BqVQ1fjBF2E/ or @BeauDeeley \n// https://stock.adobe.com/fr/images/optical-motion-illusion-illustration-a-sphere-are-rotation-around-of-a-moving-hyperboloid-abstract-fantasy-in-a-surreal-style/131366127?fbclid=IwAR1sFHeKn93GoVRJrhmOYQTmCPr8Gi_Rwu2ZuKIeYIg9Uz2B\n\n// Code loosely based on https://www.shadertoy.com/view/XsdcDr\n\n#define HEX_PATTERN 1\n\n#define ENABLE_AA 1\n\n#define REVERSE_DIRECTION 0\n\n\nfloat MAX_DIST = 1000.0;\n\n#define PI 3.141592654\n#define TAU  (PI * 2.0)\n\nvec2 GetWindowCoord( const in vec2 vUV )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\n\treturn vWindow;\t\n}\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\t\t\t\t\t\t  \n    float fPersp = 3.0;\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fPersp);\n\n\treturn vDir;\n}\n\nvec4 Scene_SphereA( vec3 vPos )\n{\n    float xPos = -0.5;\n    //flost xPos = -0.5 * sin(iTime)\n    vec3 vSphereDomain = vPos - vec3( xPos, 0.0, 2.0 );\n    float fSphereRadius = 0.4;\n    float fSphereDist = length( vSphereDomain ) - fSphereRadius;\n    vec3 vSphereDir = vSphereDomain / fSphereRadius;\n    //vec2 vSphereUV = vec2( vSphereDir.y, atan( vSphereDir.z, vSphereDir.x )) * 2.0;\n    // Sphere UV code from \twj\n    vec2 vSphereUV = vec2(acos(vSphereDir.y / length(vSphereDir)), atan( vSphereDir.z, vSphereDir.x ))*2.0 ;\n    vec4 vSphereResult = vec4( fSphereDist, vSphereUV, 2.0 );    \n    \n    return vSphereResult;\n}\n\nvec4 Scene_Pillar( vec3 vPos )\n{\n    float fPillarRadius = 1.0 - cos( vPos.y * 2.0 );\n    fPillarRadius = 0.4 + fPillarRadius * fPillarRadius * 0.5;\n    vec2 vPillarOffset = vPos.xz - vec2(0.0, 3.0);\n    float fPillarDist = length( vPillarOffset ) - fPillarRadius;\n    vec2 vPillarUV = vec2( vPos.y * 4.0, 2.5 * atan( vPillarOffset.y, vPillarOffset.x ) );\n    vec4 vPillarResult = vec4( fPillarDist, vPillarUV, 1.0 );\n    \n    return vPillarResult;\n}\n\nvec4 Scene_GetDistance( vec3 vPos )\n{\n\tvec4 vResult = vec4( MAX_DIST, 0.0, 0.0, 0.0 );\n\n    vec2 vWallUV = vec2(vPos.y, -vPos.x) * 1.5;\n    vec4 vWallResult = vec4( -vPos.z + 5.0, vWallUV, 0.0 );\n    \n    if ( vWallResult.x < vResult.x )\n    {\n        vResult = vWallResult;\n    }\n\n\tvec4 vPillarResult = Scene_Pillar( vPos );\n    \n    if ( vPillarResult.x < vResult.x )\n    {\n        vResult = vPillarResult;\n    }\n    \n\tvec4 vSphereResult = Scene_SphereA( vPos );\n    \n    if ( vSphereResult.x < vResult.x )\n    {\n        vResult = vSphereResult;\n    }\n\n    return vResult;\n}\n\nvec3 Scene_GetNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).x * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).x * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).x * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).x * e.yyy;\n    \n    return normalize( vNormal );\n}   \n\nvec4 Scene_Trace( vec3 vRayOrigin, vec3 vRayDir, float minDist, float maxDist )\n{\t\n    vec4 vResult = vec4(0);\n    \n\tfloat t = minDist;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tvResult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(vResult.x) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n\t        t = maxDist;\n            break;\n        }               \n        \n        t += vResult.x;\n\t}\n    \n    vResult.x = t;\n    \n    return vResult;\n}    \n\n\n#if HEX_PATTERN\n\n// Returns vec4( distance to edge, distance to centre, vec2( hexagon co-ordinate ) )\n// hexagon co-ordinate integer part is hexagon I.D.\n// hexagon co-ordinate fractional part is uv within the hexagon\nvec4 Hexagon( vec2 pos ) \n{\n    vec2 vScale = vec2( 1.0, sqrt(3.0) );\n    \n    vec2 p = pos * vScale;\n      \n    // :\n    // :\n    // o--+--+--+--+--+--o\n    // |  : /:  |  :\\ :  |\n    // |  :/ :  |  : \\:  |\n    // +--+--+--o--+--+--+\n    // |  :\\ :  |  : /:  |\n    // |  : \\:  |  :/ :  |\n    // o--+--+--+--+--+--o - - - - \n    \n    vec2 f = fract( p );\n    \n    vec2 index = floor( p );\n    index.x *= 2.0;\n    \n    vec2 c;    \n    \n    vec2 t = abs( f - vec2(0.5, 0.5) );\n\n    // get hexagon center and index\n    \n    // (6.0, 2.0) = dimensions of repeating grid above\n    if ( t.x * 6.0 < -t.y * 2.0 + 2.0 )\n    {\n        c = vec2(0.5);        \n    }\n    else\n    {\n        if ( f.x > 0.5 )\n        {\n            c.x = 1.0; \n\n            index.x += 1.0;\n        }\n        else\n        {\n            index.x -= 1.0;\n            c.x = 0.0;\n        }\n        \n        if ( f.y > 0.5 )\n        {\n            c.y = 1.0;            \n            index.y += 1.0;\n        }\n        else\n        {\n            c.y = 0.0;\n        }\n    }\n            \n    vec2 offset = (f - c) / vScale;\n    float d = length( offset );\n    \n    vec2 vDir[3] = vec2[3]( \n        vec2(  0.0, \t\t\t\t1.0 ), \n        vec2( -sqrt(3.0) / 2.0,\t1.0 / 2.0 ),\n        vec2(  sqrt(3.0) / 2.0,\t1.0 / 2.0 ) );    \n    \n    float s = 10000.0;\n    \n    for ( int i=0; i<3; i++ )\n    {\n        float d = 1.0 - abs( dot( offset, vDir[i] ) ) * 2.0 * sqrt(3.0);\n        s = min( s, d );\n    }\n    \n    vec2 vUV = index + offset * 1.5 + 0.5;\n    \n    return vec4(s, d, vUV );\n}\n\n\nvec3 HexPattern( vec2 vUV, vec3 colInner, vec3 colEdge )\n{\n    // uncomment to actually scroll :P\n    //vUV.y -= iTime * 0.01;\n    \n    vec4 hex = Hexagon( vUV );\n    \n    float edgeShade = step( fract(hex.w), 0.5 );\n\n    vec3 col = colInner; \n    col = mix( col, vec3(edgeShade), step(hex.x, 0.3) ); // black / white edge\n    col = mix( col, colEdge, step(hex.x, 0.15) ); ; // Yellow Surround\n        \n    return col;\n}\n\n\n#endif\n\n\n\nvec3 MotionTextureGradient( float f )\n{\n#if 0\n    vec3 cols[] = vec3[](\n        vec3(1,0,0),\n        vec3(1,0,1),\n        vec3(0.95,0,1) * 0.75\n        );\n\n    f *= float( cols.length() );    \n\n    int c1 = int( floor(f) ) % cols.length();\n    int c2 = (c1 + 1) % cols.length();\n    float b = clamp( f - float(c1), 0.0, 1.0 );\n    \n    //b = smoothstep(0.0,1.0,b);\n    return mix( cols[c1], cols[c2], b );    \n#else    \n    vec3 vColA = vec3( 253, 27, 32 ) / 255.0;\n\tvec3 vColB = vec3( 198, 48, 249 ) / 255.0;\n    \n    //vec3 vColA = vec3(1,1,0);\n    //vec3 vColB = vec3(1,.1,0);\n        \n    float fCol = sin(f * TAU) * 0.5 + 0.5;\n    float fLum = sin((f + 0.25) * TAU) * 0.5 + 0.5;\n        \n    float fLumA = 0.9;\n    float fLumB = 1.0;\n\n    return mix( vColA, vColB, fCol ) * mix( fLumA, fLumB, fLum );\n#endif    \n}\n\nvec3 MotionTexture( vec2 vUV, float obj )\n{\n#if HEX_PATTERN\n    \n    \n    vec3 innerCol = vec3(1.0);\n\n    if ( obj < 0.5 )\n    {\n        innerCol = vec3(70, 30, 123) / 255.;\n    }\n    else\n    if ( obj < 1.5 )\n    {\n        innerCol = vec3(113, 36, 132) / 255.;\n    }\n    else\n    if ( obj < 2.5 )\n    {\n        innerCol = vec3(133, 39, 76) / 255.;\n    }\n    \n    return HexPattern( vUV * 1.0 + 0.1, innerCol, vec3(198, 161, 57) / 255. );\n#else\n    float x = fract( vUV.x );\n\n    float fOffset = floor( x * 2.0 ) / 2.0;\n    float y = fract( vUV.y + fOffset );\n    \n\treturn MotionTextureGradient( y );\n#endif    \n}\n\nvec3 GetSceneColour( const in vec3 vRayOrigin,  const in vec3 vRayDir )\n{\n    float theta = atan(vRayDir.x, vRayDir.y);\n    vec4 vScene = Scene_Trace( vRayOrigin, vRayDir, 0.0, MAX_DIST );\n    float fDist = vScene.x;\n\tvec3 vPos = vRayOrigin + vRayDir * fDist;\n\t\n    vec3 vNormal = Scene_GetNormal( vPos );\n    vec2 vUV = vScene.yz; \n    \n    \n    if ( fDist > 350.0 )\n    {\n        vUV = vec2(0);\n    }   \n\n#if REVERSE_DIRECTION\n    vUV.y = 1.0 - vUV.y;\n#endif    \n    \n    vec3 vTex = MotionTexture(vUV + 0.25, vScene.w );\n    \n    vTex = vTex * vTex;\n    \n    \n    \n    vec3 vResult = vTex;\n    \n    // Hacked darkening\n    if ( vScene.w == 0.0 )\n    {\n        // darken back wall\n        vResult *= 1.0 - (0.6 / (0.2 + Scene_Pillar( vPos ).x));\n        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));\n        vResult *= 0.8;\n    }\n    \n    if ( vScene.w == 1.0 )\n    {\n        // darken pillar\n        vResult *= 1.0 - (0.43 / (0.25 + Scene_SphereA( vPos ).x));\n        vResult *= max(0.0, -vNormal.z) * 0.8 + 0.2;\n        vResult *= 1.5;\n    }\n\n    if ( vScene.w == 2.0 )\n    {\n        \n        vResult *= max(0.0, -vNormal.z);\n    }\n\n    \n    vResult *= 1.5;\n\n    return sqrt(vResult);\n}\n\nvoid mainImageNoAA( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n\n\tvec3 vCameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 10.0);\n    \n\tvec3 vRayOrigin = vCameraPos;\n\tvec3 vRayDir = GetCameraRayDir( GetWindowCoord(vUV), vCameraPos, vCameraTarget );\n\t\n\tvec3 vResult = GetSceneColour(vRayOrigin, vRayDir);\n    \t    \n\tfragColor = vec4(vResult, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if ENABLE_AA\n    fragColor = vec4(0);\n    float count = 0.0;\n\n    float AA_Size = 4.0;\n    \n    for ( float aaY = 0.; aaY < AA_Size; aaY++ )\n    {\n        for ( float aaX = 0.; aaX < AA_Size; aaX++ )\n        {\n            vec4 vSample;\n            mainImageNoAA( vSample, fragCoord + vec2(aaX, aaY) / AA_Size );\n            \n            fragColor += vSample;\n        \tcount += 1.0;\n        }\t\n    }\n    \n    fragColor /= count;\n#else    \n    mainImageNoAA(fragColor, fragCoord);\n#endif\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}