{
    "Shader": {
        "info": {
            "date": "1501343324",
            "description": "mouse.x does things.\nmouse.y is locked, other mouse.y are a bit nonsensical. unlock mouse.y in line 78\n\nthere are simpler ways to skew a cosine with another cosine.\nbut i wanted a non-fourier approach.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sSfR3",
            "likes": 0,
            "name": "smooth triangle B ",
            "published": 3,
            "tags": [
                "triangle",
                "curve",
                "smoothstep",
                "cosine",
                "hull",
                "sawcos"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "/*\ni achieved the minimum of what i wanted here,\na smoothened slantable triangle wave, \nas alternative (and nonsensically more general) calculation to\nhttps://www.shadertoy.com/view/Ms2BzV\n\nthis shader tries to decompose sawCos()\ninto 2 core elements:\nsawCosB()=sss2(dat());\n*/\n\n#define aa 10./iResolution.y\n//view zoom\n#define viewZoom 4.\n//view scaling\n#define fr(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n#define mainImage(o,u)o=vec4(co(u),1.);\n\n\nfloat stretch(float a,float b){\n b=clamp(b,0.,1.);\n if(a<b)return a/b;\n return a/b;\n}\n/*\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;float k=dot(m,u.yx);return k;}\nfloat lineN(vec2 u,vec2 m){return line(u,normalize(m));}\n\nfloat lsa(vec2 u,vec2 m){return abs(line(u,m));}\nfloat lsaN(vec2 u,vec2 m){return abs(line(u,normalize(m)));}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat ils(float c,vec2 u,vec2 m){\n //return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\nfloat ilsN(float c,vec2 u,vec2 m){return ils(c,u,normalize(m));}\n*/\n\n/*\n//return line-line intersecion \n float gLLxX2( vec2 A, vec2 B, vec2 C, vec2 D ){\n    vec2 b=B-A;vec2 d=D-C;vec2 c=C-A;\n    float t =(c.x*d.y-c.y*d.x)/(b.x*d.y-b.y*d.x);\n    return A.x+t*b.x;}\n//second life wiki geometric collection\n*/\n\n//return projection of x, set by m within vec2(0) and vec2(1);\nfloat dat3(vec2 u,vec2 m){\n return length(u-m)-1.;\n //return pow(u.x,m.x/m.y);\n //m=clamp(m,0.,1.);//should not be needed, can make debugging simpler.\n //if(abs(m.x-.5)>=.5&&u.x<0.)return m.y;//should not be needed, cosmetic case handling\n //2 upper corners are still unhandled.\n //this assumes a statig m input that is not too high!\n //out-of-bounds behavior should be irrelevant due to fract, even outside this function.\n //u.x=clamp(u.x,0.,1.);//keep out of bounds flattened and defined. evades some corner cases.\n //m=fract(m);//nicely excludes 2 undefined border cases. and m.x=1 is truncated to 0.\n //if(u.x>=m.x)return(m.y-1.)/(m.x-1.)*(u.x-(m.y-m.x)/(m.y-1.));;\n //return u.x*m.y/m.x;\n}\n//above is new project\n\n\n//return projection of x, set by m within vec2(0) and vec2(1);\n//this is a bit like a cheap approximation for; return pow(u.x,m.x/m.y);\nfloat dat2(vec2 u,vec2 m){\n //return pow(u.x,m.x/m.y);//what this curve is a bit like\n //m=clamp(m,0.,1.);//should not be needed, can make debugging simpler.\n //if(abs(m.x-.5)>=.5&&u.x<0.)return m.y;//should not be needed, cosmetic case handling\n //2 upper corners are still unhandled.\n //this assumes a statig m input that is not too high!\n //out-of-bounds behavior should be irrelevant due to fract, even outside this function.\n //u.x=clamp(u.x,0.,1.);//keep out of bounds flattened and defined. evades some corner cases.\n m=fract(m);//nicely excludes 2 undefined border cases. and m.x=1 is truncated to 0.\n if(u.x>=m.x)return(m.y-1.)/(m.x-1.)*(u.x-(m.y-m.x)/(m.y-1.));;\n return u.x*m.y/m.x;}\n//above is general case of special case below where m=.5;\nfloat dat(vec2 u,vec2 m){m=fract(m);\n if(u.x>=m.x)return(-.5)/(m.x-1.)*(u.x-(.5-m.x)/-.5);\n return u.x*.5/m.x;}\n\n//float sss(float a){return cos(clamp(a,0.,acos(-1.)));}//*.5+.5;\nfloat sss2(float a){return cos(clamp(a,-1.,1.)*acos(-1.))*.5+.5;}//*.5+.5;\n\n/*\nfloat ssc(float a){\n a=clamp(a,0.,1.);\n return cos(a);\n}\nfloat map(vec2 u, vec2 m){\n return ssc(u.x)-u.y;\n return smoothstep(aa,-aa,abs(length(u-m))-1.);\n return 0.;\n}*/\n\n// uv to color is the new \"main\"\nvec3 co(vec2 u){\n vec2 m=fr(iMouse.xy);u=fr(u);\n vec3 c;\n //u.x=fract(u.x);\n //m.y=.5;//this makes the most sense i think, but remove it to play with it!\n          c.g=dat3(u,m); \n c.r=sss2((c.g      )*2.-1.)-u.y;\n //c.g-=u.y;\n c.g=smoothstep(aa,-aa,abs(c.g)-.01);\n \n c.r=smoothstep(aa,-aa,c.r);\n c.b=fract(u.x)*fract(u.y)*.5;\n return c*.5+c.yzz*.5;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}