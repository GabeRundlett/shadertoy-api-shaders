{
    "Shader": {
        "info": {
            "date": "1466428225",
            "description": "Mod of [url]https://www.shadertoy.com/view/4sKXWG[/url]\nEnjoy :D\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MsKSDG",
            "likes": 14,
            "name": "KaliTrace+Light",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "lighting",
                "kaliset",
                "trippy"
            ],
            "usePreview": 0,
            "username": "bergi",
            "viewed": 1084
        },
        "renderpass": [
            {
                "code": "/** KaliTrace+Light\n\thttps://www.shadertoy.com/view/MsKSDG\n\n\t(cc) 2016, stefan berke\n\n\tMore or less the same as \t\n\thttps://www.shadertoy.com/view/4sKXWG\n\t\n\tAdded implicit lighting and light-reflection\n\tand some parameter morphing\n\n*/\n\n\n// minimum distance to axis-aligned planes in kali-space\n// uses eiffie's mod (/p.w) https://www.shadertoy.com/view/XtlGRj\n// to keep the result close to a true distance function\nvec3 kali_set(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        d = min(d, p.xyz/p.w);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n// same thing as above but also gathers\n// distance to light 'bulbs' \nvec4 light;\nvec3 kali_set_with_light(in vec3 pos, in vec3 param)\n{\n    vec4 p = vec4(pos, 1.);\n    vec3 d = vec3(100.);\n    for (int i=0; i<9; ++i)\n    {\n        p = abs(p) / dot(p.xyz,p.xyz);\n        vec3 s = p.xyz/p.w;\n        d = min(d, s);\n        if (i == 3)\n            light = vec4(.5+.5*sin(pos.xzx*vec3(8,9,19)), \n                         length(s.xz)-0.003);\n        p.xyz -= param;\n    }\n    return d;\n}\n\n\n// scene distance\nfloat DE(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\n// scene distant with light gathering\nfloat DE_with_light(in vec3 p, in vec3 param)\n{\n    // floor and ceiling\n    float d = min(p.y, -p.y+.2);\n\n    // displaced by kaliset\n\td -= kali_set_with_light(p*vec3(1,2,1), param).x;\n    \n    return d;\n}\n\nvec3 DE_norm(in vec3 p, in vec3 param)\n{\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(\n        DE(p+e.xyy, param) - DE(p-e.xyy, param),\n        DE(p+e.yxy, param) - DE(p-e.yxy, param),\n        DE(p+e.yyx, param) - DE(p-e.yyx, param)));\n}\n\n\nconst float max_t = 1.;\n\n// common sphere tracing\n// note the check against abs(d) to get closer to surface\n// in case of overstepping\nvec3 light_accum;\nfloat trace(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    light_accum = vec3(0.);\n    float t = 0.001, d = max_t;\n    for (int i=0; i<50; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE_with_light(p, param);\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        // light accumulation is after break\n        // (we are not so much interested in the light's surfaces)\n        light_accum += (.2+.4*light.xyz) * max(0., .3 - 6.*light.w) / 3.;\n        d = min(d, light.w*.5); // extra fudge for light bulbs\n        t += d * .5; // fudge for kali geometry\n    }\n    return t;\n}\n\n// common ambient occlusion\nfloat traceAO(in vec3 ro, in vec3 rd, in vec3 param)\n{\n    float a = 0., t = 0.01;\n    for (int i=0; i<5; ++i)\n    {\n        float d = DE(ro+t*rd, param);\n        a += d / t;\n        t += d;\n    }\n    return min(1., a / 5.);\n}\n\n// environment map, \n// background is drawn from kaliset\nvec3 skyColor(in vec3 ro, in vec3 rd)\n{\n    //vec3 par = vec3(0.075, 0.565, .03);\n    vec3 par = vec3(1.2, 1.01, .71);\n    \n    vec3 c = kali_set(rd*2., par);\n    c = vec3(.9*c.x,.7,1.)*pow(vec3(c.x),vec3(.7,.5,.5));\n\tc *= .6;\n    \n    // some quick tracing of reflected lights\n    vec3 lc = vec3(0.);\n    float t = 0.001, d = max_t;\n    for (int i=0; i<15; ++i)\n    {\n        vec3 p = ro + rd * t;\n        d = DE_with_light(p, vec3(1.));\n        if (abs(d) <= 0.0001 || t >= max_t)\n            break;\n        lc += light.xyz * max(0., .4 - 9.*light.w);\n        d = min(d, light.w);\n        t += d; // no fudging, artifacts are okay here\n    }\n    c += .7*min(vec3(1.), lc / (max_t - t));\n\n    return clamp(c, 0., 1.);\n}\n\n// trace and color\nvec3 rayColor(in vec3 ro, in vec3 rd, in float ti)\n{\n    // magic params for kali-set\n    vec3 par1 = vec3(1.,.7+.6*sin(ti/39.),1.),\t\t// scene geometry \n         par2 = vec3(.63, .55, .73);\t\t\t// normal/bump map\n    \n    float t = trace(ro, rd, par1);\n\n    vec3 p = ro + t * rd;\n    float d = DE(p, par1);\n    \n    vec3 col = vec3(0.);\n\n    // did ray hit?\n    if (d < 0.03) \n    // note, we always find a surface in this scene except for rays parallel to the \n\t// two enclosing planes. The 0.03 is quite large, just to remove the blackness\n    // close to edges\n    {\n        // surface normal\n        vec3 n = DE_norm(p, par1);\n        // normal displacement\n        n = normalize(n + min(p.y+0.05,.02)*DE_norm(p+.1*n, par2));\n        n = normalize(n + 0.04*DE_norm(sin(p*30.+n*10.), par2)); // micro-bumps\n        // reflected ray\n        vec3 rrd = reflect(rd,n);\n\t\t// normal towards light\n        vec3 ln = normalize(vec3(0.7,0.2,0) - p);\n\t\t// 1. - occlusion\n        float ao = traceAO(p, n, par1);\n        // surface color\n        vec3 surf = .1*mix(vec3(1,1.4,1), vec3(3,3,3), ao);\n\n        // lighting\n        surf += .25 * ao * max(0., dot(n, ln));\n        float d = max(0., dot(rrd, ln));\n        surf += ao * (.5 * d + .7 * pow(d, 8.));\n\n        // environment map\n        surf += ao * skyColor(ro+0.01*n, rrd);\n    \n        // distance fog\n    \tcol = surf * (1.-t / max_t);\n    }\n    \n    col += light_accum;\n    \n    return col;\n}\n\n// camera path\nvec3 path(in float ti)\n{\n    ti /= 7.;\n    vec3 p = vec3(sin(ti)*.5+.5, \n                  .07+.06*sin(ti*3.16), \n                  -.5*cos(ti));\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 suv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n        \n    float ti = iTime+99.;\n    \n    vec3 ro = path(ti);\n    vec3 look = path(ti+1.+.5*sin(ti/2.3))+vec3(0,.02+.03*sin(ti/5.3),0);\n    float turn = sin(ti/6.1); \n        \n    // lazily copied from Shane\n    // (except the hacky turn param)\n    float FOV = 1.6; // FOV - Field of view.\n    vec3 fwd = normalize(look-ro);\n    vec3 rgt = normalize(vec3(fwd.z, turn, -fwd.x));\n    vec3 up = cross(fwd, rgt);\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    \n    \n    //vec3 col = kali_set(vec3(uv, 0.), vec3(1.));\n    vec3 col = rayColor(ro, rd, ti);\n    \n    \n    col *= pow(1.-dot(suv-.5,suv-.5)/.5, .6);\n    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}