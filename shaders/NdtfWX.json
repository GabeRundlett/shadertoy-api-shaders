{
    "Shader": {
        "info": {
            "date": "1657330002",
            "description": "So I was scrolling through the \"old new\" list, and I saw Shane's beautiful zoomer... Perfect occasion to check the performance of shell tiling vs. loop-based recursive geometry! Result for me is a 4x speedup, based on the plugin in fullscreen mode.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdtfWX",
            "likes": 21,
            "name": "Optimization of Shane's 3D Zoom",
            "published": 3,
            "tags": [
                "3d",
                "zoom",
                "infinite",
                "shell"
            ],
            "usePreview": 0,
            "username": "dracusa",
            "viewed": 506
        },
        "renderpass": [
            {
                "code": "/*\n    This is a fork of Shane's \"Infinite 3D Zoom\":\n    https://www.shadertoy.com/view/sljfDD\n\n    The purpose of the fork is to test \"shell tiling\" as an optimization for\n    infinite/recursive scenes. The original 16x loop in the map function has\n    been replaced with a single lookup, now the same geometry is only\n    calculated 2x per map call.\n\n    Imagine the scene is composed of onion layers with a given thickness,\n    aka shells in geometry. Now, check how far we are from (0,0,0), deduce\n    which shell we're in, and calculate the SDF for this shell \"tile\", with\n    its own zoom level. Tragically, this breaks the overall SDF because of\n    hard discontinuities at the edges between shells. This is worked around\n    by combining with the SDF of one adjacent shell tile.\n    \n    This optimization is a logical continuation of the series I did a\n    couple of years ago: https://www.osar.fr/notes/logspherical/\n    The technique used here is actually simpler and faster than the stuff\n    described in the article, all the trigonometry is removed.\n\n    You might notice the scene looks a bit different, this is because shell\n    tiling requires reformulating the layout in different terms. It could\n    be made more similar to the original but I'm not sure how much.\n    \n    Comments below are from Shane's original shader, except those prefixed\n    with \"dracusa edit\" to show where I made changes, mostly around lines\n    150-215. I tried to keep the original level of commentage.\n*/\n\n/*\n\n    Infinite 3D Zoom\n    ----------------\n\n\tThis is just a dressed up version of a basic cube zooming animation.\n    The animation portion was pretty straight forward, so took no time at\n    all. However, I spent way too long dressing it up to a stage where I\n    was only mildy satisfied with the result. The original had a nicer \n    reflective pass, but I couldn't afford to use it... You can't win them \n    all, but if you like drab brown-looking one pass scenes, then you'll \n    love this. :D Oh well, post and move on, as they say. :)\n    \n    For those not familiar with the infinite zoom illusion, it's a pretty\n    simple concept: In the 2D sense, you produce a miniscule object then \n    expand its size to some maximum before snapping it back to its original\n    minimum size (the fract funciton does that). On its own, it's not very\n    illusory, however, if you do the same with multiple objects at various \n    stages in the expansion process, your mind gets tricked into believing \n    that a camera is zooming toward the central object -- In reality, the \n    camera is effectively stationary. This particular example is just a 3D \n    extension on the aforementioned with various tweaks.\n    \n    Anyway, there are better zoom examples than this on Shadertoy, so if\n    that kind of thing interests you, search \"infinite zoom\" or something \n    along those lines. I have some 2D zooming animations that I might post\n    at a later date.\n    \n    \n\n\tOther examples:\n    \n    // You can't list zoom examples without referencing this.\n    // It's everywhere these days.\n    Infinite KIFS Zoom - andyalias\n    https://www.shadertoy.com/view/4sS3WV\n    \n    // Golden spiral zoom. Typical simple and stylish example\n    // by IQ.\n    Golden Ratio and Spiral - iq\n    https://www.shadertoy.com/view/fslyW4\n    \n    // One of many of KilledByAPixel's really nice zoom examples.\n    Infinity Matrix - KilledByAPixel\n    https://www.shadertoy.com/view/Md2fRR\n    \n    // Fabrice has a few examples. This is his most recent. \n    infinite zoom in rolling squares - FabriceNeyret2 \n    https://www.shadertoy.com/view/fl2Bzm\n    \n    // Awesome example -- Requires a strong GPU.\n    Bloom [skull] - tdhooper\n    https://www.shadertoy.com/view/WdScDG\n    \n    // Oldschool bump mapped zoom effect, written years ago.\n    Quasi Infinite Zoom Voronoi  - Shane\n\thttps://www.shadertoy.com/view/XlBXWw \n\n*/\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    //vec2 w = vec2( sdf, abs(pz) - h );\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .005;\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\nfloat gS;\nmat2 gR;\n\n\n// dracusa edit: pick a density and get its inverse and exp.\n// this determines how tight together the shells are.\nconst float dens = 1.25;\nconst float idens = 1./dens;\nconst float stepZoom = exp(idens);\n\n// dracusa edit: how much each shell tile is rotated\nconst float twist = .25;\n\n// dracusa edit: this defines a single shell tile\nvoid shell(vec3 p, float shellN, inout float distOut){\n    // how much scaling is applied to this shell tile.\n    float tileScale = exp(shellN*idens);\n\tp /= tileScale;\n    // constant scale to fit the original geometry into the shape of the\n    // shell as closely as possible, minimizing SDF breakage.\n    float s = .6;\n    // below is the content of Shane's loop from the original\n    // Infinite 3D Zoom:\n\n    // Adding linear XY rotation for a bit of extra visual interest. \n    // You can leave it out, if you'd prefer the boxes to look more static.\n    mat2 r = rot2(shellN*twist); \n\n    // Rotate the XY plane.\n    vec2 q = p.xy*r;\n\n    // Rounded box.\n    float box = sBoxS(q, vec2(s), .2*s*1.);\n    // Circular box option... Otherwise known as a circle. :D\n    // You'd need to make changes to the bump and texturing functions.\n    //float box = length(q) - s; \n\n    // Extrude -- Inner and outer with separation\n    float sep = .6 / (1. + 18. * tileScale);\n    float di = opExtrusion(box+.0*s, p.z - s, .25 - sep*0.4);\n    float di2 = opExtrusion(abs(box + .04*s) - .04*s, p.z - s, 0.25 + sep);\n    //di2 += smoothstep(0., .5, cos(box*80./s + .0))*.01*s;\n    di = min(di, di2);\n\n\t// dracusa edit: compensate for this tile's scaling.\n    // Optionally shorten the rays to work around dicontinuities.\n\tdi *= tileScale*.99;\n\n    // Record the minimum extruded box distance.\n    if(di<distOut){\n        distOut = di;\n        gR = r;\n        gS = tileScale*s;\n    }\n}\n\n// dracusa edit: this function is rewritten\nfloat map(in vec3 p)\n{\n    // which shell are we in?\n    float rho = log(length(p)) - iTime*.6;\n    float shellN = floor(rho*dens) + (iTime*.6)*dens;\n\t\n\t// Get distance to geometry in this and adjacent shell\n    float d = 1e5;\n\tshell(p, shellN, d);\n\tshell(p, shellN+1., d);\n\treturn d;\n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... \n    // Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .85;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n///////\n\n#define STATIC\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) {  \n     \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    \n    #ifdef STATIC\n    return fract(vec2(262144, 32768)*n); \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime/2.)*.5 + .5; \n    #endif\n}\n\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n\n/*\n// IQ's polynomial-based smooth minimum function.\nvec3 smin( vec3 a, vec3 b, float k ){\n\n    vec3 h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// The is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n\nfloat vAng;\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\nvec3 Voronoi(in vec2 p){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n#if 1\n    // Slower, but handles big numbers better.\n    vec2 n = floor(p);\n    p -= n;\n    vec2 h = step(.5, p) - 1.5;\n    n += h; p -= h;\n#else\n    vec2 n = floor(p - 1.);\n    p -= n;\n#endif\n    \n    \n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., md2, lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n    \n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n\t\tif( d<md ){\n            \n            md2 = md;\n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec2(i, j) + n; // Record the cell ID also.\n            \n            vAng = atan(o.y, o.x);\n        }\n        else if(d<md2) {\n            md2 = d; \n            \n            \n        }\n       \n    }\n\t}\n    \n\n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n\tfor( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o-mo, o-mo)>.00001 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot( 0.5*(o+mo), normalize(o-mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            //lMd = smin(lMd, lnDist, .1); \n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            lMd = sminExp(lMd, lnDist, 15.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n            \n        }\n\n    }\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    // thanks dad\n    return max(vec3(lMd, lMd2, md2 - md), 0.);\n}\n//////\n\n // Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n    // Applying a Voronoi pattern.\n    // Globals from the map function.\n    float svS = gS; // Texture sizing factor.\n    mat2 svR = gR; // Rotation matrix.\n\n    p.xy *= svR/svS;\n    n.xy *= svR;\n\n    float s = svS;\n    p.z -= s*.9;\n\n    float c = 0.;\n\n    vec3 v = Voronoi(p.xy*8.);\n\n    float vor = v.y;\n\n    // Ignore the borders.\n    float sq = sBoxS(p.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n    if(n.z<-.25 && sq<.0) {\n    \n        c = vor;\n    }\n\n    return c*svS;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, -0.9, -1); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.03*cos(iTime/2.)*0., .18, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1, .5, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 0.9; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera for extra motion sickness. :)\n\trd.xy *= rot2( sin(iTime/2.)/16. );\n\trd.xz *= rot2( sin(iTime)/32. );\n\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n  \n    // Global scaling and rotation matrix.\n    float svS = gS;\n    mat2 svR = gR;\n    \n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        vec3 sn0 = sn; // Normal with no bump.\n        \n        sn = doBumpMap(sp, sn, .5);///(1. + t/FAR*1.)\n        \n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n         \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 5.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring.   \n            \n        // Coordinatges.\n        vec3 txP = sp;\n        vec3 txN = sn;\n\n        // XY rotation and scaling.\n        txP.xy *= svR/svS;\n        txN.xy *= svR;\n\n        //txP.xy -= hash22(vec2(svS.w, svS.w*57.));\n        float s = pow(svS, 1.);\n        txP.z -= s;// - hash21(vec2(svS.w, svS.w*113.));//See distance function.\n\n\n\n        // Texture.\n        vec3 tx = tex3D(iChannel0, txP, txN);\n        texCol = .05 + tx*1.5;\n\n        // Alternative coloring.\n        //texCol = mix(texCol, vec3(dot(texCol, vec3(.299, .587, .114))), mod(svS.w, 2.)*.35);\n        // No texture.\n        //texCol = vec3(.6);\n\n\n\n        // Voronoi pattern.\n        vec3 v = Voronoi(txP.xy*vec2(8));\n\n        float vor = v.y;\n        float sq = sBoxS(txP.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n        if(sn0.z<-.5 && sq<.0) {\n\n            // Greyscale toning.\n            vec3 svCol = texCol;\n            float gr = dot(texCol, vec3(.299, .587, .114));\n            texCol = mix(texCol, vec3(gr), .15);\n\n            // Color application.\n            //vec3 iCol = (.5 + .45*cos(6.2831*svS.w/8. + vec3(0, 1, 2)*1.))*3.;\n            vec3 iCol = vec3(2);\n            vec3 iCol2 = (iCol + vec3(.1))*2.;\n            texCol = mix(texCol*iCol, texCol*.25, 1. - smoothstep(0., .1, vor - .2));\n            texCol = mix(texCol, svCol*iCol2, 1. - smoothstep(0., .04, abs(vor - .2 + .03) - .03));\n            texCol = mix(texCol, svCol*iCol2*0., 1. - smoothstep(0., .04, abs(vor) - .01));\n\n       }\n       else {\n\n           // Darker borders.\n           texCol *= .5;\n           // Lightening the edges.\n           if(sn0.z<-.25){\n               texCol = mix(texCol, texCol*3., 1. - smoothstep(0., .005, -(abs(sq - .04) - .03)));\n           }\n       }\n \n\n       \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .2 + vec3(.5, .7, 1)*spec*sh*1.);\n        \n        // Fake Fresnel reflections.\n        vec3 refl = reflect(rd, sn);\n        vec3 refTex = texture(iChannel1, refl).xyz; refTex *= refTex;\n        col = mix(col, (col + .25)*refTex*(sh + .2)*4., mix(.05, .35, fre));//*refTex*sh;\n    \n\n        // Shading.\n        col *= ao*atten;\n    \n        // dracusa edit: fig leaf in the middle\n        col = mix(col, vec3(.1,.03,.03), 1.-smoothstep(-.01, .03, length(sp)));\n       \n\t\n\t}\n    \n    // Background fog.\n    col = mix(col, vec3(.025, .015, .01), smoothstep(0., .99, t/FAR));\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}