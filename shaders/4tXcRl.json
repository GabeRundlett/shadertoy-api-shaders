{
    "Shader": {
        "info": {
            "date": "1505881974",
            "description": "Manual unroll of so called shape grammar split (for \"man made\" tech detail) applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\nMouse to look around (2 camera paths) ",
            "flags": 0,
            "hasliked": 0,
            "id": "4tXcRl",
            "likes": 116,
            "name": "Simple Greeble - Split4",
            "published": 3,
            "tags": [
                "tech",
                "tiles",
                "greeble",
                "split",
                "laserbeam",
                "deathstar",
                "trench",
                "shapegrammar",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "blackjero",
            "viewed": 20519
        },
        "renderpass": [
            {
                "code": "// Simple Greeble - Split4 by Jerome Liard, August 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/4tXcRl\n\n// Manual unroll of so called shape grammar split (for \"man made\" tech detail)\n// applied to a rough procedural reconstruction of the first few seconds of the death star trench sequence.\n// Mouse to look around (2 camera paths)\n\n// I was initially working on split/subdivided tiles for something else,\n// but as it started to look familiar I pushed in the fan art direction.\n//\n// The tiles use several hardcoded quad split variants (all resulting in 4 children),\n// and we recurse down 1 level on a couple of them (max 10 leaves).\n//\n// I find the lack of motion blur disturbing, but time was spent on other futile things instead.\n\n#if 1\n#define TIME_OFFSET 0.0\n#define CAM2_TIME_OFFSET 0.0\n#else\n#define TIME_OFFSET 54.0\n#define CAM2_TIME_OFFSET 7.0\n#endif\n#define CAMERA_REPEAT\n// tile eval count (x1 x2 x4 (max)... to deal with cell boundaries), the more evals the less artifacts but it also depend on a ton of other things - use 1 or 2 really\n#define NUM_TILE_EVALS 1\n// warp first iteration with raytracing to reduce trace iteration count, affects lighting a bit\n#define RAYTRACE_FIRST_MARCH_DISTANCE\n// small trace optim that creates color disparity as a side effect (a bug promoted into a feature)\n#define RAYMARCH_WITH_LOD\n// allow proper shadows close to us, expensive and doesn't contribute that much... disable\n//#define TRACED_SHADOW\n// do the main cast shadow analytically\n#define ANALYTICAL_SHADOW\n// worry not, it's not screenspace\n#define AO\n// color tiles (debug)\n//#define COLOR_TILES\n#define STARFIELD\n#define SUN\n// scene type\n//#define PRIMITIVES\n#define SORT_OF_MOON\n#define LASERS\n// max marching iterations\n#define MAX_ITERATIONS 140\n// tweak for perfs vs quality etc\n#define DBREAK 0.00125\n#define TMAX 200.0\n#define TFRAC 0.5\n\n// threshold distance used by RAYMARCH_WITH_LOD and RAYTRACE_FIRST_MARCH_DISTANCE\n#define ROUGH_SHELL_D 0.45\n\n#define FLYING_SPEED 10.0\n#define TRENCH_DEPTH 4.8\n#define TRENCH_HALF_WIDTH 2.0\n\nfloat PI = 3.141592654;\n\n#ifndef FLT_MAX\n#define FLT_MAX 1000000.0\n#endif\n\nvec3 RED\t = vec3( 1, 0, 0 );\nvec3 GREEN\t = vec3( 0, 1, 0 );\nvec3 BLACK\t = vec3( 0, 0, 0 );\n\nvec2 xset( vec2 p, float v ) { return vec2( v, p.y );}\nvec2 yset( vec2 p, float v ) { return vec2( p.x, v );}\nvec3 xset( vec3 p, float v ) { return vec3( v, p.y, p.z );}\nvec3 yset( vec3 p, float v ) { return vec3( p.x, v, p.z );}\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\n\n#define IMPL_SATURATE(type) type saturate( type x ) { return clamp( x, type(0.0), type(1.0) ); }\nIMPL_SATURATE( float )\nIMPL_SATURATE( vec2 )\nIMPL_SATURATE( vec3 )\nIMPL_SATURATE( vec4 )\n\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec2 smoothstep_unchecked( vec2 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nvec3 smoothstep_unchecked( vec3 x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\n// cubicstep is a generic smoothstep where you can set in and out slopes\n// slope at x=0 is df0\n// slope at x=1 is df1\n// smoothstep_unchecked(x) == cubicstep(x,0,0)\nfloat cubicstep( float x, float df0, float df1 ) { float b = 3.0 - df1 - 2.0 * df0; float a = 1.0 - df0 - b; return ( ( a * x + b ) * x + df0 ) * x; }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nfloat pow4( float x ) { x *= x; x *= x; return x; }\nvec4 pow2( vec4 x ) { return x * x; }\nvec4 pow4( vec4 x ) { x *= x; x *= x; return x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nfloat box( float x ) { return abs( x ) < 1.0 ? 1.0 : 0.0; }\nvec3 chrominance( vec3 c ) { return c / max( c.r, max( c.g, c.b ) ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\n\n// project this on line (O,d), d is assumed to be unit length for project_on_line1\n// project_on_liney: d = 0,1,0\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_liney( type P, type O ) { O.y += ( P - O ).y; return O; } /* d = vec3(0,1,0) */\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n#define DECL_BOUNDS( btype, type, booltype ) \\\nstruct btype { type pmin; type pmax; }; \\\n/* min,max constructor*/ \\\nbtype mkbounds_unchecked( type amin, type amax ) { btype ret; ret.pmin = amin; ret.pmax = amax; return ret; } \\\n/*btype mkbounds_unchecked_invalid() { btype ret; ret.pmin = FLT_MAX; ret.pmax = -FLT_MAX; return ret; }*/ \\\ntype size( btype b ) { return b.pmax - b.pmin; } \\\ntype center( btype b ) { return 0.5 * ( b.pmax + b.pmin ); } \\\ntype closest( btype b, type p ) { return min( max( p, b.pmin ), b.pmax ); } \\\nbool inside( btype b, type p ) { return all_( /*booltype*/( p == closest( b, p ) ) ); }\n\nbool all_( bool value ) { return value; } // not defined in glsl, apparently + can't use same name else some compilers barf\nbool all_( bvec2 value ) { return all( value ); }\nbool all_( bvec3 value ) { return all( value ); }\n\nDECL_BOUNDS( bounds1, float, bool )\nDECL_BOUNDS( bounds2, vec2, bvec2 )\nDECL_BOUNDS( bounds3, vec3, bvec3 )\n\nbounds3 mkbounds_unchecked( bounds2 b, float height )\n{\n\tbounds3 ret;\n\tret.pmin = vec3( b.pmin.xy, 0 );\n\tret.pmax = vec3( b.pmax.xy, height );\n\treturn ret;\n}\nbounds2 xy( bounds3 b ) { return mkbounds_unchecked( b.pmin.xy, b.pmax.xy  ); }\nbounds2 xy( bounds2 b ) { return b; }\n\n#define REPEAT_FUNCTIONS( type, btype ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float, bounds1 )\nREPEAT_FUNCTIONS( vec2, bounds2 )\nREPEAT_FUNCTIONS( vec3, bounds3 )\n\n#define TRI_FUNCTIONS(type,btype) \\\n/* y=1-x on 0,1, output 0,1 */ \\\ntype tri0( type x ) { return abs( fract( x * 0.5 ) - type(0.5) ) * 2.0; } \\\n/* function returns 0 at x = half_width */ \\\ntype tri_p( type x, type half_width, type half_period )\t{ return half_width - repeat_mirror( x, half_period ); }\n\nTRI_FUNCTIONS( float, bounds1 )\nTRI_FUNCTIONS( vec2, bounds2 )\nTRI_FUNCTIONS( vec3, bounds3 )\n\nfloat spaced_tri( float x, float period, float half_width ) { period *= 0.5; x /= period; return max( 0.0, 1.0 + ( tri0( x ) - 1.0 ) * ( period / half_width ) ); }\nfloat spaced_bumps( float x, float s, float r ) { return smoothstep_unchecked( spaced_tri( x, s, r ) ); }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE3 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195, 444.129)\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21( float p )\n{\n\tvec3 p3 = fract( vec3( p ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx  ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yzx  + 19.19 );\n\treturn fract( ( p3.xx  + p3.yz  ) * p3.zy  );\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32( vec2 p )\n{\n\tvec3 p3 = fract( vec3( p.xyx ) * HASHSCALE3 );\n\tp3 += dot( p3, p3.yxz  + 19.19 );\n\treturn fract( ( p3.xxy  + p3.yzz  ) * p3.zyx );\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42( vec2 p )\n{\n\tvec4 p4 = fract( vec4( p.xyxy  ) * HASHSCALE4 );\n\tp4 += dot( p4, p4.wzxy  + 19.19 );\n\treturn fract( ( p4.xxyz + p4.yzzw ) * p4.zywx );\n\n}\n\nvec2 V30 = vec2( 0.866025403, 0.5 );\nvec2 V45 = vec2( 0.707106781, 0.707106781 );\n\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\nvec3 zup_spherical_coords_to_vector( float theta, float phi )\n{\n\tvec2 theta_vec = unit_vector2( theta );\n\tvec2 phi_vec = unit_vector2( phi );\n\treturn vec3( theta_vec.y * phi_vec, theta_vec.x );\n}\n\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\n\nmat4 yup_spherical_offset( float theta, float phi )\n{\n\tvec3 y = yup_spherical_coords_to_vector( theta, phi );\n\tvec3 z = yup_spherical_coords_to_vector( theta + PI * 0.5, phi );\n\tvec3 x = cross( y, z );\n\treturn mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\n\n// debug visualization\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\n\nstruct Ray { vec3 o; vec3 d; };\n\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy )\n{\n\tRay view_ray;\n\tview_ray.o = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z;\n\tview_ray.d = normalize( view_ray.o );\n\treturn view_ray;\n}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up )\n{\n\tvec3 z = normalize( eye - center );\n    vec3 x = normalize( cross( up, z ) );\n\treturn mat4( vec4( x, 0.0 ), vec4( cross( z, x ), 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) );\n}\n\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n\nstruct Plane2 { vec2 base; vec2 normal; };\nstruct Plane { vec3 base; vec3 normal; };\n\nPlane2 mkplane2( vec2 base, vec2 normal ) { Plane2 plane; plane.base = base; plane.normal = normal; return plane; }\nPlane mkplane( vec3 base, vec3 normal ) { Plane plane; plane.base = base; plane.normal = normal; return plane; }\n\n// a few tediously hardcoded subdivisions that generates 4 children\n\n#define SPLIT4_BOUNDS\n\nstruct Split4\n{\n#ifdef SPLIT4_BOUNDS\n\tbounds2 b00;\n\tbounds2 b01;\n\tbounds2 b10;\n\tbounds2 b11;\n#endif\n\tvec4 d;\n};\n\nvec4 get_distances( vec2 p, Split4 split )\n{\n#if 1\n\treturn split.d;\n#else\n// should be same result\n\tvec4 d;\n\td.x = sd_bounds_range( p, split.b00.pmin, split.b00.pmax );\n\td.y = sd_bounds_range( p, split.b01.pmin, split.b01.pmax );\n\td.z = sd_bounds_range( p, split.b10.pmin, split.b10.pmax );\n\td.w = sd_bounds_range( p, split.b11.pmin, split.b11.pmax );\n\treturn d;\n#endif\n}\n\nSplit4 sd_Split_b_xxx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//  -------------------------\n//  |     |\t    |     |     |\n//  | b00 | b01 | b10 | b11 |\n//  |     |\t    |     |     |\n//  -------------------------\n//     x10     x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat x10 = mix( mi.x, x0, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n\tx10 += dx;\n\tx11 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x10 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.x - x10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyy( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//     ---------------\n//     | \t  |      |\n//     | b01  |  b11 |\n// y10 | -----|      |\n//     | \t  |------| y11\n//     | b00  |  b10 |\n//     ---------------\n//            x0\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat y11 = mix( mi.y, ma.y, s.z );\n\n#if 1\n// diagonal features\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), yset( ma, y11 ) );\n\tsplit.b11 = mkbounds_unchecked( vec2( x0, y11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.y - y11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\nSplit4 sd_Split_b_xyx( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n// \t   ------------------\n//     | b01 |     |    |\n// y10 | ----| b10 | b11|\n//     | b00 |     |    |\n// \t   ------------------\n// \t        x0    x11\n\n\tfloat x0 = mix( mi.x, ma.x, s.x );\n\n#if 0\n// diagonal features (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx0 += dx;\n#endif\n\n\tfloat y10 = mix( mi.y, ma.y, s.y );\n\tfloat x11 = mix( x0, ma.x, s.z );\n\n#if 0\n// diagonal feature (a bit too much)\n\tfloat dx = linearstep( 0.4, 0.6, ( p.y - mi.y ) / ( ma.y - mi.y ) ) * ( ma.x - mi.x ) * 0.15;\n\tx11 += dx;\n#endif\n\n\t//\n\tSplit4 split;\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, vec2( x0, y10 ) );\n\tsplit.b01 = mkbounds_unchecked( yset( mi, y10 ), xset( ma, x0 ) );\n\tsplit.b10 = mkbounds_unchecked( xset( mi, x0 ), xset( ma, x11 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x11 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat a = p.x - x0;\n\tfloat d0 = opI( a, d );\n\tfloat d1 = opI( -a, d );\n\tfloat b = p.y - y10;\n\tsplit.d.x = opI( d0, b );\n\tsplit.d.y = opI( d0, -b );\n\tfloat c = p.x - x11;\n\tsplit.d.z = opI( d1, c );\n\tsplit.d.w = opI( d1, -c );\n\t//\n\treturn split;\n}\n\n// that one can't be expressed as a 2 levels split, but as an incomplete level 3 (we only store 4 bounds)\nSplit4 sd_Split_b_H( vec2 p, vec2 mi, vec2 ma, vec3 s )\n{\n//   --------------------\n//   |     |  b10 |     |\n//   |     |\t  |     |\n//   | b00 |------| b11 | y20\n//   |     |\t  |     |\n//   |     |  b01 |     |\n//   --------------------\n//         x0    x10\n\n\t// note: we sort s.x and s.z, it make this function easier to use\n\tfloat x0 = mix( mi.x, ma.x, min( s.x, s.z ) );\n\tfloat y20 = mix( mi.y, ma.y, s.y );\n\tfloat x10 = mix( x0, ma.x, max( s.x, s.z ) );\n\tSplit4 split;\n\t//\n#ifdef SPLIT4_BOUNDS\n\tsplit.b00 = mkbounds_unchecked( mi, xset( ma, x0 ) );\n\tsplit.b01 = mkbounds_unchecked( xset( mi, x0 ), vec2( x10, y20 ) );\n\tsplit.b10 = mkbounds_unchecked( vec2( x0, y20 ), xset( ma, x10 ) );\n\tsplit.b11 = mkbounds_unchecked( xset( mi, x10 ), ma );\n#endif\n\t//\n\tfloat d = sd_bounds_range( p, mi, ma );\n\tfloat d0 = opI( p.x - x0, d );\n\tfloat d1 = opI( -p.x + x0, d );\n\tfloat d20 = opI( p.x - x10, d1 );\n\tfloat d21 = opI( -p.x + x10, d1 );\n\tsplit.d.x = opI( d0, p.x - x0 );\n\tsplit.d.y = opI( d20, -p.y + y20 );\n\tsplit.d.z = opI( d20, p.y - y20 );\n\tsplit.d.w = opI( d21, -p.x + x10 );\n\t//\n\treturn split;\n}\n\nstruct TechTilesArgs\n{\n\tvec4 height0, height10, height11;\n\tvec3 size0, size10, size11; //relative\n\tbool sub10, sub11; // recurse or not\n};\n\n// d stores 4 df for 4 boxes, h stored boxes height\nfloat getDist4( float z, vec4 d, vec4 h )\n{\n\tvec4 v = vec4( z ) - h;\n\treturn opU( opU( opI( v.x, d.x ), opI( v.y, d.y ) ),\n\t\t\t\topU( opI( v.z, d.z ), opI( v.w, d.w ) ) );\n}\n\n// 4 scopes output + recurse 2 of them\nfloat sd_TechTilesTestsSub( vec3 p, int lod, float t, TechTilesArgs args, float e )\n{\n\tvec4 d = vec4( FLT_MAX );\n\tvec4 heights = args.height0;\n\n//\tSplit4 b = sd_Split_b_xxx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_xyy( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\tSplit4 b = sd_Split_b_xyx( p.xy, vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n//\tSplit4 b = sd_Split_b_H( p.xy,vec2( 0, 0 ), vec2( 1, 1 ), args.size0 );\n\n\td = get_distances( p.xy, b ) + e;\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub10 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xyy( p.xy, b.b01.pmin, b.b01.pmax, args.size10 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.y = getDist4( p.z, d2, args.height10 );\n\t\theights = max( heights, args.height10 );\n\t}\n#endif\n\n#ifdef SPLIT4_BOUNDS\n\tif ( args.sub11 )\n\t{\n\t\t// do one more level\n\t\tSplit4 b2 = sd_Split_b_xxx( p.xy, b.b11.pmin, b.b11.pmax, args.size11 );\n\t\tvec4 d2 = get_distances( p.xy, b2 ) + e;\n\t\td.w = getDist4( p.z, d2, args.height11 );\n\t\theights = max( heights, args.height11 );\n\t}\n#endif\n\n\treturn getDist4( p.z, d, heights );\n}\n\nstruct TechTilesArgs0\n{\n\tfloat hmin;\n\tfloat hmax;\n\tfloat hdetail; // the height of sub detail\n};\n\nfloat sd_TechTilesTestsSub0( vec3 p, int lod, float t, Ray ray, vec2 index, TechTilesArgs0 targs )\n{\n\tfloat d = FLT_MAX;\n\n//\td = opI( p.z - 1.0, sd_bounds_range( p.xy, vec2( 0, 0 ), vec2( 1, 1 ) ) );\n//\treturn d;\n\n\tfloat e0 = 0.0125 * 2.0;\n\tfloat e = e0 + t * 0.001; // else e becomes 0 as far as tracing is concerned... increases cost\n\n\tTechTilesArgs args;\n\n\tvec4 ha = hash42( index );\n\tvec4 hb = hash42( index + 100.0 );\n\n\tfloat rnd_type_and_rotation = ha.w;\n\tvec3 size0_hash = ha.xyz;\n\tvec4 height0_hash = hb;\n\n\targs.sub10 = rnd_type_and_rotation < 0.6;\n\targs.sub11 = rnd_type_and_rotation < 0.3;\n\n\tfloat rota = fract( rnd_type_and_rotation * 3.0 );\n\tif ( rota < 0.25 ) p.xy = p.yx;\n\telse if ( rota < 0.5 ) p.xy = vec2( 1.0 - p.y, p.x );\n\n\tfloat m1 = 0.15;\n\targs.size0 = m1 + ( 1.0 - m1 * 2.0 ) * size0_hash; // hash32 expensive\n\n\targs.size10 = vec3( 0.25, 0.5, 0.75 );\n\targs.height10 = vec4( 1.0 );\n//\targs.height10 = hash42( index + 80.0 ) * 0.25; // don't hash all... leave splits is interesting too\n\n\targs.size11 = vec3( 0.25, 0.5, 0.5 );\n\targs.height11 = vec4( 1.0 );\n//\targs.height11 = hash42( index + 85.0 ) * 0.25;\n\n\targs.height0 = mix( vec4( targs.hmin ), vec4( targs.hmax ), height0_hash );\n\n\targs.height10 = args.height0 + targs.hdetail * args.height10;\n\targs.height11 = args.height0 + targs.hdetail * args.height11;\n\n\td = sd_TechTilesTestsSub( p, lod, t, args, e );\n\n\t// bevel\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( -V45.x, 0, V45.y ) ) );\n\td = opI( d, dot( p - vec3( 0, 0, 0.1 ), vec3( 0, -V30.x, V30.y ) ) );\n\n\treturn d;\n}\n\n// feature max height will be hscale*2\nfloat sd_TechTiles( vec3 p, int lod, float t, Ray ray, TechTilesArgs0 targs, float e )\n{\n#if ( NUM_TILE_EVALS == 2 )\n\n\t// we do 2 evals in alternate checker patterns, \"only\" x2 cost and relatively clean\n\t// it still has corner cases (ha..ha..) but help in some situations\n\n\tfloat d = FLT_MAX;\n\n\tvec2 index0 = floor( p.xy );\n\tvec2 indexi = index0;\n\tfloat m = mod( indexi.x + indexi.y, 2.0 );\n\n\tvec2 dd;\n\n\tfor ( int k = 0; k < 2; k += 1 )\n\t{\n\t\tvec3 p2 = p;\n\t\tvec2 index = index0;\n\t\tp2.xy = p.xy - index;\n\n\t\tif ( m == float( k ) )\n\t\t{\n\t\t\tvec2 offset = vec2( 0.0 );\n\t\t\tvec2 rp2 = p2.xy - 0.5;\n\t\t\tif ( abs( rp2.y ) > abs( rp2.x ) ) offset.y += rp2.y > 0.0 ? 1.0 : -1.0;\n\t\t\telse offset.x += rp2.x > 0.0 ? 1.0 : -1.0;\n\t\t\tindex += offset;\n\t\t\tp2.xy -= offset;\n\t\t}\n\n\t\tfloat ddd = sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs );\n#if 0\n\t\tdd[k] = ddd; // gpu hangs on desktop (GTX 970)\n#else\n\t\tif ( k == 0 ) dd.x = ddd;\n\t\telse  dd.y = ddd;\n#endif\n\n//\t\td = ddd; // compiler bug? doesn't work on laptop...\n\t}\n\n\td = opU( dd.x, dd.y );\n\n#else\n\n\tvec3 p2 = p;\n\tvec2 index = floor( p.xy );\n\tp2.xy = p.xy - index;\n\treturn sd_TechTilesTestsSub0( p2, lod, t, ray, index, targs  ); // only 1 eval\n\n#endif\n\n}\n\nfloat sd_DeathStarTrench( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d = FLT_MAX;\n\tfloat hw = TRENCH_HALF_WIDTH;\n\n#ifdef RAYMARCH_WITH_LOD\n\td = opU( d, p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, -p.x + TRENCH_HALF_WIDTH );\n\td = opU( d, p.z + TRENCH_DEPTH );\n\td = opI( d, p.z );\n\tif ( abs( d ) > ROUGH_SHELL_D ) return d;\n#endif\n\n\tTechTilesArgs0 targs;\n\ttargs.hmin = 0.025;\n\ttargs.hmax = 0.30;\n\ttargs.hdetail = 0.05;\n\n\t// tiles for vertical walls\n\tTechTilesArgs0 targs_walls;\n\ttargs_walls.hmin = 0.01;\n\ttargs_walls.hmax = 0.22;\n\ttargs_walls.hdetail = 0.05;\n\n#if 1\n\t// the shallow trench rows perpendicular to the main one\n\tif ( mod( floor( p.y ), 7.0 ) == 0.0 )\n\t{\n\t\ttargs.hmax *= 0.3;\n\t\ttargs.hmin *= 0.3;\n\t\ttargs_walls.hmax *= 0.3;\n\t\ttargs_walls.hmin *= 0.3;\n\t}\n#endif\n\n\tfloat h03 = 0.0; // surface trench clamp control\n\tfloat h00 = ( targs.hmax + targs.hdetail ); // wall tile top clamp control\n\tfloat h0 = h00;\n\tfloat h1 = ( targs_walls.hmax + targs_walls.hdetail );\n\n\t// inflate more for tracing\n\th0 *= 2.0;\n\th1 *= 2.0;\n\n\tbounds2 bsides = mkbounds_unchecked( vec2( hw - h1, -TRENCH_DEPTH ), vec2( hw, h0 ) );\n\tbounds2 trench_xz = mkbounds_unchecked( vec2( -hw, -TRENCH_DEPTH ), vec2( hw, 10 ) );\n\n\tfloat e = 0.15; // 51%\n//\tfloat e = 0.25; // 75%\n\n\tbool top_layer = ( p.z > 0.0 ) && ( p.z < h0 );\n\tbool bottom_layer = ( p.z < -TRENCH_DEPTH + h0 );\n\n\tbool top_layer2 = top_layer && ( abs( p.x ) > hw - h03 );\n\tbool bottom_layer2 = bottom_layer && ( abs( p.x ) <= hw );\n\n\tfloat hoffset = top_layer2 ? 0.0 : -TRENCH_DEPTH;\n\n\ttargs.hmin += hoffset;\n\ttargs.hmax += hoffset;\n\n\t{\n\t\tfloat d1 = sd_TechTiles( p, lod, t, ray, targs, e );\n\t\td = opS( p.z, sd_bounds( p.xz, trench_xz ) );\n\n\t\tif ( top_layer2 || bottom_layer2 ) d = opU( d, d1 );\n\t}\n\n\tif ( inside( bsides, xset( p.xz, abs( p.x ) ) ) ) // perf culling\n\t{\n\t\tvec3 p2 = p.yzx;\n\t\tp2.z = abs( p2.z );\n\t\tp2.z -= hw;\n\t\tp2.z = -p2.z;\n\t\tp2.xy *= 2.0;\n\n\t\tfloat d1 = opI( p.z - TRENCH_DEPTH, sd_TechTiles( p2, lod, t, ray, targs_walls, e ) );\n\t\td1 = opI( d1, p.z - h00 * 0.45 ); // clamp top\n\t\td = opU( d1, d );\n\t}\n\n\treturn d;\n}\n\nfloat sindecay( float x, vec3 args ) { return exp( -args.x * x ) * sin( x * args.y ) * args.z; }\nfloat sindecay_derivative( float x, vec3 args ) { return ( args.y * cos( args.y * x ) - args.x * sin( args.y * x ) ) * exp( -args.x * x ) * args.z; }\n\n// function used in overshoot steps, d is the derivative of the curve at x=0, only x>0 bit is used\nfloat overshoot( float x, vec3 args, float df0 )\n{\n\tif ( x > 1.0 ) return 1.0 - sindecay( x - 1.0, args );\n\treturn cubicstep( x, df0, -sindecay_derivative( 0.0, args ) );\n}\n\n// first test, with an anticipation bump\nfloat overshootstep1( float x, vec3 args )\n{\n\tfloat df0 = 6.0;\n\tfloat s = 0.5;\n\tif ( x > 0.0 ) return 1.0 - ( 1.0 - overshoot( x, args, df0 ) ) * s;\n\treturn 1.0 - ( 1.0 + ( 1.0 - cubicstep( max( x, -1.0 ) + 1.0, 0.0, df0 ) ) ) * s;\n}\n\n// dive_step_expin_a from y0+1.0 to 0.0\n// df0 is the derivative at x=0 if we don't scale by 1/(1+y0)\n// the real derivative at 0 is a/(a+df0)\n// a controls the rate of ease in exp dive\n// same as dive_step_expin_y0( x, df0, df0/a )\nfloat overshootstep2( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : -( 1.0 - exp( x * a ) ) * y0; // look there is a smiley in that calculation\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\n// like overshootstep2 but from -inf to 1 instead of 0 to 1 (steep turn)\nfloat overshootstep3( float x, float df0, float a, vec3 args )\n{\n\tfloat y0 = df0 / a; // calculate y0 such that the derivative at x=0 becomes df0\n\tfloat y = x > 0.0 ? overshoot( x, args, df0 ) : 1.0 - exp( -df0 * x );\n\treturn ( y + y0 ) / ( 1.0 + y0 ); // the step goes from y0 to 1, normalize so it is 0 to 1\n}\n\nfloat oversteer( float x, float a, float b, float x0 ) { return exp( -pow2( x ) * 3.0 ) - exp( -pow2( x - x0 ) * 3.0 ) * 0.5; }\n\nstruct CameraRet { vec3 eye; float roll; float pitch; vec4 debug_color; float exposure; };\n\nCameraRet init_cam()\n{\n\tCameraRet cam;\n\tcam.pitch = 0.0;\n\tcam.roll = 0.0;\n\tcam.exposure = 1.0;\n\tcam.debug_color = vec4( 0.0 );\n\treturn cam;\n}\n\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy )\n{\n\tfloat mouse_ctrl = 1.0;\n\tvec2 mm_offset = vec2( 0.0, pitch );\n\tvec2 mm = vec2( 0.0, 0.0 );\n\n#ifndef EXTRA_3D_CAMERA\n\tif ( iMouse.z > 0.0 )\n\t\tmm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n#endif\n\n\tmm.x = -mm.x;\n\tmm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n\tmm *= PI * tan_half_fovy * mouse_ctrl;\n\tmm += mm_offset;\n\treturn camera * yup_spherical_offset( mm.y, mm.x );\n}\n\n// awkwardly reproduce a camera path similar to the one in the movie\nCameraRet get_camera1_movie_dive_path( float t )\n{\n\tCameraRet cam = init_cam();\n\n\t// approach curves\n\n\t// turn curve\n\tfloat x = overshootstep3( t * 0.55 - 1.4, 2.2, 6.0, vec3( 1.1, 3.0, 0.5 ) ) - 1.0;\n\n\t// descent curve\n\tfloat zz = 1.0 - overshootstep2( t * 1.0 - 2.0, 0.8, 4.0, vec3( 1.0, 1.0, 0.4 ) );\n\tfloat z = -TRENCH_DEPTH * 0.75 + zz * 5.0;\n\n\tcam.eye = vec3( -x, t * FLYING_SPEED, z );\n\n\tfloat pp = ( 1.0 - smoothstep( 0.0, 2.4, t ) );\n\tcam.pitch = -PI * 0.18 * pp;\n//\tcam.debug_color = vec4( GREEN.rgb, pp * 0.5 );\n\n\tfloat rr = oversteer( ( t - 2.7 ), 0.3, 0.3, 1.0 );\n\tcam.roll -= -rr * PI * 0.2;\n//\tcam.debug_color = vec4( RED.rgb, rr*0.5 );\n\n\tcam.eye.z += 0.2 * sin( t * 2.0 );\n\n\tcam.eye.x += ( 0.4 * TRENCH_HALF_WIDTH * sin( t * 1.0 ) ); // left right amplitude\n//\tcam.roll -= 0.2 * cos( t * 1.0 + 0.25 ); // steering roll (anticipates, derivative)\n\tcam.roll += 0.05 * sin( t * 2.0 ); // noise roll\n\n\t// occasional jumps\n\tcam.eye.z += ( 1.0 - ( 1.0 + cos( PI * spaced_tri( t * 0.2, 4.0, 0.5 ) ) ) * 0.5 ) * 7.0;\n\n\tcam.exposure = mix( 0.57*7., 0.18*7., smoothstep( -1.0, 2.0, cam.eye.z ) );\n\treturn cam;\n}\n\nmat4 get_camera1_movie_dive( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera1_movie_dive_path( t + 0.05 ).eye;\n\tCameraRet cam = get_camera1_movie_dive_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch, tan_half_fovy );\n}\n\nCameraRet get_camera2_path( float t )\n{\n\tt *= 0.4; // slow down\n\tCameraRet cam = init_cam();\n\tcam.exposure = 0.35*7.;\n\tcam.roll -= cos( t + 0.25 ) * 0.175;\n\tcam.pitch -= PI * 0.2;\n\tfloat xpos_max = 2.5;\n\tfloat ypos = t * FLYING_SPEED;\n\txpos_max += ( 1.0 + sin( t * 0.05 ) * 0.5 ) * 2.0;\n\tcam.eye = vec3( xpos_max * sin( t ), ypos, 2.75 );\n\treturn cam;\n}\n\nmat4 get_camera2( mat4 camera, float tan_half_fovy, float t, inout vec4 debug_color, inout float exposure )\n{\n\tvec3 center = get_camera2_path( t + 0.02 ).eye;\n\tCameraRet cam = get_camera2_path( t );\n\tvec3 eye = cam.eye;\n\tvec3 up = vec3( 0, 0, 1 );\n\tup.xz = rotate_with_angle( up.xz, cam.roll );\n\tcamera = lookat( eye, center, up );\n\texposure = cam.exposure;\n\tdebug_color = cam.debug_color;\n\treturn look_around_mouse_control( camera, cam.pitch - PI * 0.08, tan_half_fovy );\n}\n\n// plane base 0,0,pz plane normal 0,0,nz\nvec2 intersect_plane2_nz( Ray ray, float pz, float nz )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.z * nz;\n\tfloat d = ( ray.o.z - pz ) * nz;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// plane base 0,0,px plane normal 0,0,nx\nvec2 intersect_plane2_nx( Ray ray, float px, float nx )\n{\n\tfloat epsilon = 1e-4;\n\tfloat vdotn = ray.d.x * nx;\n\tfloat d = ( ray.o.x - px ) * nx;\n\tfloat t = ( abs( vdotn ) <= epsilon ? FLT_MAX : -d / vdotn );\n\treturn vec2( t, d );\n}\n\n// turn t (result of intersect_plane* functions) into a negative space range\nvec2 mm3( vec2 t ) { return t.y * t.x > 0.0 ? vec2( t.x, FLT_MAX ) : vec2( -FLT_MAX, t.x ); }\n\n// intersect 2 negative space ranges, assume convex\nvec2 mm4( vec2 a, vec2 b ) { return vec2( max( a.x, b.x ), min( a.y, b.y ) ); }\n\n// raytrace to get a better first march distance\nfloat warpTrace( Ray ray )\n{\n\tvec2 t0 = intersect_plane2_nz( ray, ROUGH_SHELL_D, 1.0 );\n\tvec2 t1 = intersect_plane2_nx( ray, -TRENCH_HALF_WIDTH + ROUGH_SHELL_D, 1.0 );\n\tvec2 t2 = intersect_plane2_nx( ray, TRENCH_HALF_WIDTH - ROUGH_SHELL_D, -1.0 );\n\tvec2 t3 = intersect_plane2_nz( ray, -TRENCH_DEPTH + ROUGH_SHELL_D, 1.0 );\n\tfloat d = opU( opU( opI( t0.y, t1.y ), opI( t0.y, t2.y ) ), t3.y );\n\tif ( d < 0.0 ) return 0.0; // we are inside... do nothing and gtfo\n\tvec2 r0 = mm3( t0 );\n\tvec2 r01 = mm4( r0, mm3( t1 ) );\n\tvec2 r02 = mm4( r0, mm3( t2 ) );\n\tvec3 dd = vec3( FLT_MAX );\n\tif ( r01.x != FLT_MAX && r01.y > r01.x && r01.x > 0.0 ) dd.x = r01.x;\n\tif ( r02.x != FLT_MAX && r02.y > r02.x && r02.x > 0.0 ) dd.y = r02.x;\n\tif ( t3.x != FLT_MAX && t3.x > 0.0 ) dd.z = t3.x;\n\treturn mincomp( dd );\n}\n\nfloat sd_Scene( vec3 p, int lod, float t, Ray ray )\n{\n\tfloat d1 = FLT_MAX;\n\tfloat d2 = FLT_MAX;\n#ifdef PRIMITIVES\n// was for simple check lighting (need disable shadow hacks)\n\td1 = opU( sd_bounds_range( p, -vec3( 1. ), vec3( 1. ) ), length( p - vec3( 0., 3., 0. ) ) - 1. );\n#endif\n#ifdef SORT_OF_MOON\n\td2 = sd_DeathStarTrench( p, lod, t, ray );\n#endif\n\treturn opU( d1, d2 );\n}\n\nstruct TraceOutput\n{\n\tfloat t; // ray travel distance\n\tfloat num_iterations;\n\tfloat dist; // \"hit\" point distance to surface\n\tfloat shadow;\n};\n\nvec3 sd_SceneGrad( vec3 p, int lod, TraceOutput to, Ray ray )\n{\n\t// if p is far away the epsilon will vanish in the addition and normal calculation will be broken\n\t// this was to keep the gradient working even at large-ish distances...\n//\tvec3 h = max( vec3( 0.006 ), abs( p ) * 1e-6 );\n\tvec3 h = vec3( 0.001 );\n\tvec3 n = normalize( vec3( sd_Scene( p + vec3( h.x, 0.0, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, h.y, 0.0 ), lod, to.t, ray ),\n\t\t\t\t\t\t\t  sd_Scene( p + vec3( 0.0, 0.0, h.z ), lod, to.t, ray ) ) - to.dist ); // to.dist == sd_Scene( p, lod, to.t, ray ), our last eval \n\t// if the normal is backfacing, our point p is likely behind an occluded object (a thin object or an edge we accidentally traced through)\n\t// this creates distracting salt noise that makes certain lighting components unstable (fresnel)\n\t// if we care the simplest hack to do that attenuates the artifacts in our scene is to negate\n\treturn dot( n, ray.d ) > 0.0 ? -n : n;\n}\n\nTraceOutput traceScene( Ray ray, int lod, float shadow_sharpness, float tmax, bool warp_trace, float max_iterations )\n{\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.num_iterations = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n#ifdef RAYTRACE_FIRST_MARCH_DISTANCE\n\tif ( warp_trace ) { to.t += warpTrace( ray ); if ( to.t == FLT_MAX ) return to; } // jump close to first hit\n#endif\n\n\tfor ( int i = 0; i < MAX_ITERATIONS; ++i )\n\t{\n\t\tfloat d = sd_Scene( ray.o + to.t * ray.d, lod, to.t, ray );\n\t\tto.dist = d;\n\t\tif ( ( abs( to.dist ) <= DBREAK * to.t ) || to.t > tmax ) break;\n\t\tto.shadow = min( to.shadow, shadow_sharpness * to.dist / to.t ); // iq's awesome trick https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\tto.t += to.dist * TFRAC;\n\t\tto.num_iterations += 1.0;\n\t\tif ( to.num_iterations >= max_iterations ) break;\n\t}\n\n\tto.shadow = max( 0.0, to.shadow ); // fixes some artifacts\n\treturn to;\n}\n\nfloat star_glare( float x, float e, float c ) { return exp2( -pow( x, e ) * c ); }\n\n// black body color adapted from Fabrice Neyret's https://www.shadertoy.com/view/4tdGWM\n// T absolute temperature (K), m1 is a 0,1 param that controls output scale\nvec3 black_body( float T, float m1 )\n{\n\tfloat m = .01 + 5. * m1;\n\tvec3 f = vec3( 1. ) + 0.5 * vec3( 0., 1., 2. );\n\tfloat Trcp = 1. / T;\n\treturn ( 10. / m * ( f * f * f ) ) / ( exp( ( 19e+3 * f * Trcp ) ) - 1. );  // Planck law\n}\n\n// assumes x 0,1 maps to 24e+2, 30e+3\n#define FF 24.\n// vaguely use this distribution there https://en.wikipedia.org/wiki/Stellar_classification\nfloat Tprob2( float x ) { return exp( -x * FF ); }\nfloat Tprob2_int( float x ) { return -exp( -x * FF ) * ( 1.0 / FF ); }\nfloat Tprob2_int_inv( float x ) { return -log( -x * FF ) * ( 1.0 / FF ); }\n#if 0\nfloat cdf( float x ) { return Tprob2_int( x ) - Tprob2_int( 0. );}\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + Tprob2_int( 0. ) ); }\n#else\nfloat cdf( float x ) { return Tprob2_int( x ) - ( -1. / FF ); } // hardcode the function\nfloat cdf_inv( float x ) { return Tprob2_int_inv( x + ( -1. / FF ) ); }\n#endif\n\nvec3 star_color( float x ) { return black_body( mix( 24e+2, 30e+3, x ), 1. ); }\n\n#ifdef STARFIELD\n// stars are clamped on their cell borders (we don't bother iterating neighbours)\nvec3 starfield( vec3 viewvec )\n{\n\tvec2 num = vec2( 1.0, 2.0 ) * 250.0;\n\tfloat theta = acos( viewvec.z );\n\tfloat phi = calc_angle( viewvec.xy );\n\tif ( phi < 0.0 ) phi += 2.0 * PI;\n\tvec2 sc = vec2( theta, phi );\n\tvec2 scd = vec2( 1.0, 2.0 ) * PI / num;\n\tvec2 sci = floor( sc / scd ); // if ( mod( sci.x + sci.y, 2.0 ) == 1.0 ) return RED;\n\tvec2 scf = ( sc - sci * scd ) / scd; //\treturn vec3( scf, 0.0 ); // view cells\n//\tvec4 r = vec4(0.5); // aligned stars\n\tvec4 r = hash42( sci ); //\treturn vec3( r ); // color cell by hash\n\tvec2 scc = ( ( sci + 0.5 ) * scd ); // cell center\n\tvec2 r2 = hash22( sci ); //\treturn vec3( r2.y ); // debug // x: discard probability, y: color distribution uniform input\n\tif ( r2.x > sin( scc.x ) ) return BLACK; // randomly decimate in sin theta fashion for something uniform-ish\n//\tif ( r2.x > sin( scc.x ) ) return RED; // visualize the decimation\n\tvec2 sc2 = ( ( sci + r.xy ) * scd ); // cell center\n\tvec3 v = zup_spherical_coords_to_vector( sc2.x, sc2.y ); // return v;\n\tv = normalize( v ); // we also need to renormalize already normal vector here else broken on GTX1060 laptop\n\tfloat c = 1.0 - dot( v, viewvec ); // return vec3( 1.0 - smoothstep( 0.0, 1.0, c ) ); // debug: show the full disks (max glow radius) // 0->2\n\tvec3 col = star_color( cdf_inv( r2.y * cdf( 1. ) ) ); // return vec3( chrominance( col ) );\n#if 1\n\tc *= 1e+6;\n\tcol = mix( col, vec3( maxcomp( col ) ), 0.5 ); // after all those efforts we lerp towards monotone... :-]\n\treturn star_glare( c * 0.0095, 0.8, 80.0 ) * col * 1.5; // fixme: make the radius resolution/fovy dependent \n//\treturn star_glare( c * 0.01, mix( 0.4, 0.8, r.w ), mix( 30.0, 60.0, r.z ) ) * col * 120.; // manual glow;\n#else\n// with larger glares and plausible star colors it starts to look like space photos a bit (maybe)\n\tc *= 6e+4;\n\treturn star_glare( c, mix( 0.3, 0.8, r.w ), mix( 3.0, 6.0, r.z ) ) * col * 80.; // manual glow;\n#endif\n}\n#endif\n\nvoid build_onb( vec3 z, vec3 x0, out vec3 x, out vec3 y ) { y = normalize( cross( x0, z ) ); x = normalize( cross( z, y ) ); }\n\nvec3 sunval( float sun_dp, vec2 p, vec3 sun_color, vec3 sun_color_c )\n{\n\tfloat r = ( ( -sun_dp + 1. ) * 0.5 ) * 300.0;\n\tfloat f = 0.;\n#if 1\n// flares\n\tfloat a = calc_angle( p );\n\tfloat da = 2.0 * PI / 6.0;\n\tfloat a0 = floor( a * ( 1.0 / da ) ) * da;\n\tvec2 va0 = perp( unit_vector2( a0 ) );\n\tvec2 va1 = -perp( unit_vector2( a0 + da ) );\n\tvec2 d = vec2( dot( va0, p ), dot( va1, p ) );\n\tfloat f0 = opU( d.x, d.y );\n\tf = f0 * 8.;\n\tf += 1.0 - exp( -r * 0.01 ) * 0.85;\n\tf = 1. / ( 0.01 + f * 50. );\n\tf *= 0.125;\n#endif\n\treturn 2. * sun_color * star_glare( max( 0.0, r - 0.17 ) * 0.075, 0.35, 24.0 ) + f * sun_color_c;\n}\n\n// I used a bit of pbr reference to see what happens (don't worry it all deteriorates into sad hacks pretty quickly)\n// https://learnopengl.com/#!PBR/Theory\n// http://graphicrants.blogspot.jp/\n// alpha = roughness * roughness\nfloat D_blinn_phong( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return pow( m_dot_n, ( 2. / alpha_sqr ) - 2. ) / ( PI * alpha_sqr ); }\nfloat D_beckmann( float m_dot_n, float alpha )\n{\n\tfloat alpha_sqr = alpha * alpha;\n\tfloat m_dot_n_sqr = m_dot_n * m_dot_n;\n\treturn exp( ( m_dot_n_sqr - 1. ) / ( alpha_sqr * m_dot_n_sqr ) ) / ( PI * alpha_sqr * m_dot_n_sqr * m_dot_n_sqr );\n}\n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( PI * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_implicit( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v; }\nfloat G_neumann( float n_dot_l, float n_dot_v ) { return n_dot_l * n_dot_v / max( n_dot_l, n_dot_v ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v / pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, float Li, float dwi, float kdiffuse, float kspecular )\n{\n\tfloat F0 = 0.08;\n\tfloat roughness = 0.25;\n\tfloat alpha = roughness * roughness;\n\tvec3 h = normalize( l + v );\n\tfloat eps = 1e-4; // else divides by zero\n\tfloat n_dot_l = max( eps, dot( n, l ) );\n\tfloat n_dot_v = max( eps, dot( n, v ) );\n\tfloat n_dot_h = max( eps, dot( n, h ) );\n\tfloat v_dot_h = max( eps, dot( h, v ) );\n\tfloat l_dot_h = max( eps, dot( l, h ) );\n\n//\tfloat D = D_blinn_phong( n_dot_h, alpha ); // https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\n//\tfloat D = D_beckmann( n_dot_h, alpha );\n\tfloat D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n\n//\tfloat G = G_implicit( n_dot_l, n_dot_v );\n\tfloat G = G_neumann( n_dot_l, n_dot_v );\n//\tfloat G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n\n//\tfloat F = F_none( n_dot_v, F0 );\n\tfloat F = F_schlick( n_dot_v, F0 );\n\n\treturn  ( ( kdiffuse * albedo * ( 1.0 / PI ) + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n\n//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\nfloat penumbra_sun( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 1.9 ); } // darker/narrower\n//float penumbra_sun( float x ) { x = max( -x, 0.0 ); return exp2( -x * iSlider0 * 10. ); } // brighter/wider\nfloat penumbra_bounce( float x ) { x = max( x, 0.0 ); return 1.0 - exp2( -x * 0.2 ); } // darker/narrower\n//float penumbra_bounce( float x ) { x = max( x, 0.0 ); return x = exp2( -x * 1.4 ); } // brighter/wider\n\n// e = eye pos, v = vader vector, p = lit point, n = normal, l = sun direction\nvec3 shade( in vec3 e, in vec3 v, mat4 cam, in vec3 p, in vec3 n, vec3 l\n\t\t\t, float traced_shadow, float sun_shadow, float first_bounce\n\t\t\t, TraceOutput to, float ao, float exposure, vec2 uv )\n{\n\tvec3 col = vec3( 0. );\n\tbool sky = to.t > TMAX;\n\n//\treturn sky ? BLACK : ( vec3( 1.0 ) + n ) * 0.5; // normal debug color\n//\treturn vec3( 1.0 - exp( -to.t * 0.15 ) ); // distance to hit point\n//\treturn viridis_quintic( to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) ) ); // visualize the number of iterations\n//\treturn viridis_quintic( to.dist / ( DBREAK * to.t ) );\n//\treturn viridis_quintic( to.dist );\n//\treturn viridis_quintic( ao );\n\n\tvec3 sun_color = black_body( 19000.0, 0.8 );\n\tvec3 sun_color_c = chrominance( sun_color );\n\tvec3 albedo = vec3( 0.85, 0.85, 1 );\n#ifdef COLOR_TILES\n\talbedo = mix( vec3( 0.2 ), vec3( 1.0 ), hash32( floor( p.xy ) ) );\n#endif\n\n\tif ( !sky )\n\t{\n\t\tfloat iter = to.num_iterations * ( 1.0 / float( MAX_ITERATIONS ) );\n\t\tfloat fog_start = 30.0;\n\t\tfloat fog = exp2( -max( to.t - fog_start, 0.0 ) * 0.02 ); // this is mostly to fade the horizon\n\t\tfloat ao_z = 1.0 - saturate( abs( p.z * ( 1.0 / TRENCH_DEPTH ) ) ); // vertical occlusion\n\t\tfloat kdiffuse = 0.75;\n\t\tfloat kspecular = 1.0;\n\t\tfloat sunI = 2.2;\n\t\tfloat kambient = 0.005;\n\t\tfloat shadow = min( traced_shadow, sun_shadow );\n\n//\t\treturn vec3( shadow );\n//\t\tn = normalize( n + 0.07 * l ); // soften a bit\n#if 1\n // main sun light\n\t\tcol += add_light_contrib( albedo, l, n, -v\n\t\t\t\t\t\t\t\t  , sunI * mix( 0.0, 1., ao_z ) * mix( 0., 1., shadow )\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// dummy secondary source\n\t\tvec3 l2 = normalize( vec3( 5, -5.5, 10 ) );\n\t\tcol += add_light_contrib( albedo, l2, n, -v\n\t\t\t\t\t\t\t\t  , 0.34 * mix( 0.08, 1., ao_z ) * ao\n\t\t\t\t\t\t\t\t  , 1.\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z ); // modulate specular to reduce sparkles\n#endif\n#if 1\n// first bounce\n\t\tcol += add_light_contrib( albedo, reflect( l, vec3( -1., 0., 0. ) ), n, -v\n\t\t\t\t\t\t\t\t  , first_bounce\n\t\t\t\t\t\t\t\t  , 0.05\n\t\t\t\t\t\t\t\t  , kdiffuse\n\t\t\t\t\t\t\t\t  , kspecular * shadow * ao_z );\n#endif\n#if 1\n// ambient\n\t\tcol += PI * vec3( kambient * ao_z * ao );\n#endif\n#if 1\n// random crap\n\t\tcol *= fog * ao * ao * ( 1. - iter * 0.7 );\n#endif\n\t}\n\telse\n\t{\n\t\tcol = vec3( 0. );\n\n#ifdef SUN\n\t\tvec3 sx, sy;\n\t\tbuild_onb( l, cam[0].xyz, sx, sy ); // we want the flares to be viewspaceish\n\t\tcol += sunval( dot( l, v ), vec2( dot( v, sx ), dot( v, sy ) ), sun_color, sun_color_c );\n#endif\n\n#ifdef STARFIELD\n\t\tcol += starfield( v );\n#endif\n\t}\n\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.015 ) ) );\n\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); \n\tcol *= vignette;\n\n\tcol = gamma_correction_itu( col );\n//\tcol = gamma_correction( col );\n\n\treturn col;\n}\n\n// black -> green -> white gradient\nvec3 laser_heatmap( float u ) { float r = 0.5; vec3 c = vec3( smoothbump( r * float( 2.0 ), r, u ) ); c.g += smoothbump( r * float( 1.0 ), r, u ); return c; }\n\n#define LASER_LEN 1.5\n#define LASER_LEN_RCP (1.0/(LASER_LEN))\n#define LASER_SPEED (60.0)\n// spawn at player + that\n#define LASER_SPAWN_DISTANCE (40.0)\n#define LASER_PERIOD (LASER_SPAWN_DISTANCE*2.0/(FLYING_SPEED+LASER_SPEED))\n\n// for lasers capsules...\nvec2 sphere_trace( vec2 O, vec2 d, float radius, vec2 C )\n{\n\tfloat tp = dot( C - O, d ); // P = project C on line (O,d)\n\tvec2 P = O + d * tp;\n\tfloat h_sqr = lensqr( P - C );\n\tfloat radius_sqr = radius * radius;\n\tif ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ); // ray missed the sphere\n//\tbool start_inside = lensqr( O - C ) <= radius_sqr; // start inside the sphere?\n\tfloat dt = sqrt( radius_sqr - h_sqr ); // distance from P to In (near hit) and If (far hit)\n//\tif ( start_inside )\treturn vec2(FLT_MAX,tp+dt);\t// order In->O->If // record only far hit If\n//\tif ( tp < 0.0 )\treturn vec2(FLT_MAX,FLT_MAX); // order In->If->O // O is outside the sphere and beyhond If, no hit\n\treturn vec2( tp - dt, tp + dt ); // record 2 hits In, If\n}\n\n// laser code is total bloat, we raytrace infinite cylinders and integrate something\n// volumetric along a fixed number of steps between the 2 intersections, when they exist\nvec3 lasers( Ray view_ray, float hs, float time, float t0 )\n{\n\tfloat fade = 1.0 - smoothstep( -TRENCH_DEPTH * 0.05, 0.0, view_ray.o.z );\n\tfloat pos = FLYING_SPEED * time; // camera pos\n\tfloat laser_period = LASER_PERIOD * FLYING_SPEED;\n\tfloat offset = hs * 5.0;\n\tfloat nth = floor( ( pos - offset ) / laser_period );\n\tfloat y0 = offset + nth * laser_period + LASER_SPAWN_DISTANCE;\n\tfloat yy_t = ( pos - ( offset + nth * laser_period ) ) * ( 1.0 / FLYING_SPEED );\n\tfloat laser_pos = y0 - yy_t * LASER_SPEED;\n\tvec2 orig = hash21( nth * hs );\n\tfloat w2 = TRENCH_HALF_WIDTH * 0.8;\n\torig = mix( vec2( -w2, -TRENCH_DEPTH * 0.9 ), vec2( w2, -TRENCH_DEPTH * 0.3 ), orig );\n\tfloat r = 0.085;\n\tvec3 color = BLACK;\n\n\t//todo: case when we are inside the laser\n\tfloat vzx1len = length( view_ray.d.zx );\n\tvec2 vzx1 = view_ray.d.zx / vzx1len;\n\tvec2 st = sphere_trace( view_ray.o.zx, vzx1, r, vec3( orig.x, 0, orig.y ).zx );\n\tif ( st.x == FLT_MAX || // no hit\n\t\t st.y < 0.0 ) // hitting behind the camera\n\t\t\t\t\t  // we don't intersect the laser cylinder, gtfo\n\t\treturn color;\n\n\tvec3 cacc = vec3( 0.0);\n\tfloat aacc = 0.0;\n\n\tfloat vzx1len_rcp = 1.0 / vzx1len;\n\tfloat t00 = st.x * vzx1len_rcp;\n\tfloat t11 = st.y * vzx1len_rcp;\n\n#define LASER_ITER 20.0\n\tfor ( float i = 0.0; i <= LASER_ITER; i += 1.0 )\n\t{\n\t\tfloat x = i * ( 1.0 / LASER_ITER );\n\t\tfloat t = t00 + ( t11 - t00 ) * cubicstep(  x, 2.5, 2.5 ); // smaller steps near the center to better capture the gradient\n\t\tvec3 p = view_ray.o + t * view_ray.d;\n\t\tvec3 vzx = p - project_on_liney( p, vec3( orig.x, 0, orig.y ) );\n\t\tvec3 pl = p;\n\t\tpl.y -= laser_pos; // local\n\t\tfloat ri = length( vzx );\n\t\tif ( pl.y > LASER_LEN - r ) ri = length( pl - vec3( orig.x, LASER_LEN - r, orig.y ) );\n\t\telse if ( pl.y < -LASER_LEN + r ) ri = length( pl - vec3( orig.x, -LASER_LEN + r, orig.y ) );\n\t\tfloat ddx = 1.0 - saturate( ri * ( 1.0 / r ) );\n\t\tfloat xxx = pl.y * LASER_LEN_RCP;\n\t\tddx *= box( xxx ) * fade;\n\t\tvec3 emission = laser_heatmap( ddx ) * 0.2;\n\t\tfloat opacity = saturate( ddx * 0.1 );\n\t\tcacc += ( 1.0 - aacc ) * emission;\n\t\taacc += ( 1.0 - aacc ) * opacity; // http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch39.html\n\t}\n\n\tcolor = cacc;\n\tcolor = cacc * aacc;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4( 0., 0., 0., 1 );\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n//\tfragColor.xyz = star_color( uv.x ).xyz; return;\n//\tfragColor.xyz = laser_heatmap( uv.x ); return;\n\n\tfloat tan_half_fovy = 0.6;\n\tfloat znear = 0.1;\n\tvec4 debug_color = vec4( 1.0, 1.0, 1.0, 0.0 );\n\tfloat time = iTime + TIME_OFFSET;\n\tfloat fade = 1.0;\n\tfloat exposure = 1.0;\n\tmat4 camera;\n\n#ifdef EXTRA_3D_CAMERA\n\tcamera[0] = iCamera[0];\n\tcamera[1] = iCamera[1];\n\tcamera[2] = iCamera[2];\n\tcamera[3] = iCamera[3];\n\ttan_half_fovy = iTanHalfFovy;\n\texposure = iExposure;\n#else\n\t{\n\t\tfloat time_slice = 30.0;\n#ifdef CAMERA_REPEAT\n\t\tfloat camera_select = mod( floor( time / time_slice ), 2.0 );\n\t\tfloat time_slice_r = 0.25;\n\t\tfade = 1.0 - min( spaced_bumps( time, time_slice, time_slice_r ), 1.0 - box( time / time_slice_r ) );\n\t\ttime = mod( time, time_slice );\n#else\n\t\tfloat camera_select = 0.0;\n#endif\n\t\tif ( camera_select == 0.0 ) camera = get_camera1_movie_dive( camera, tan_half_fovy, time, debug_color, exposure );\n\t\telse camera = get_camera2( camera, tan_half_fovy, time + CAM2_TIME_OFFSET, debug_color, exposure );\n\t}\n#endif\n\n\tRay view_ray = get_view_ray( ( uv - vec2( 0.5 ) ) * 2.0, znear, aspect, tan_half_fovy );\n\n\tview_ray.o = camera[3].xyz;\n\tview_ray.d = ( camera * vec4( view_ray.d, 0.0 ) ).xyz;\n\tview_ray.d = normalize( view_ray.d ); // have to renormalize this already normalized (yey!) vector here else lasers are broken (only on laptop GTX1060)\n\n\tTraceOutput to = traceScene( view_ray, 0, 15.0, TMAX, true, float( MAX_ITERATIONS ) );\n\n\tvec3 l = normalize( vec3( -8, 0, 5.2 ) ); // careful with z, long shadows make the tracing slower\n\tvec3 p = view_ray.o + to.t * view_ray.d;\n\tvec3 n = sd_SceneGrad( p, 0, to, view_ray );\n\n\tfloat ao = 1.0;\n\n#ifdef AO\n\t{\n\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n\t\tfloat delta = 0.1;\n\t\tfloat a = 0.0;\n\t\tfloat b = 1.0;\n\t\tfor ( int i = 0; i < 5; i++ )\n\t\t{\n//\t\t\tif ( to.t > 30 ) break;\n\t\t\tfloat fi = float( i );\n\t\t\tfloat d = sd_Scene( p + delta * fi * n, 0, to.t, view_ray );\n\t\t\ta += ( delta * fi  - d ) * b;\n\t\t\tb *= 0.5;\n\t\t}\n\t\tao = saturate( 1.0 - 1.2 * a );\n\t\t// note: had to lower DBREAK inorder to avoid ugly patterns when far away from surface\n\t}\n#endif\n\n\tbool sky = to.t > TMAX;\n\n\tfloat sun_shadow = 1.0; // shadow\n\tfloat first_bounce = 0.0; // first light bounce (illuminates the bottom left corner)\n\tfloat traced_shadow = 1.0;\n\n\tif ( !sky )\n\t{\n#ifdef TRACED_SHADOW\n\t\tfloat expensive_shadow_dist = 40.0;\n\t\tif ( to.t < expensive_shadow_dist )\n\t\t{\n\t\t\tRay sray;\n\t\t\tsray.o = p + n * 0.1 * 1.0;\n\t\t\tsray.d = l;\n\n\t\t\tTraceOutput tos = traceScene( sray, 0, 15.0, 10.0, false, 20.0 );\n\t\t\ttraced_shadow = tos.shadow;\n\t\t\ttraced_shadow += smoothstep( expensive_shadow_dist - 2.0, expensive_shadow_dist, to.t );\n\t\t\ttraced_shadow = saturate( traced_shadow );\n\t\t}\n#endif\n\t\tvec2 l2 = normalize( l.xz );\n\t\tvec2 l2r = reflect( l2, vec2( -1, 0 ) );\n\t\tfloat so = 0.0; // shadow plane offset from z=0\n\t\tPlane2 pl1 = mkplane2( vec2( -TRENCH_HALF_WIDTH, so ), -perp( l2 ) );\n\t\tPlane2 pl2 = mkplane2( vec2( TRENCH_HALF_WIDTH, so ), -perp( l2r ) );\n\t\tPlane2 pl3 = pl2;\n\t\tpl3.normal = -pl3.normal;\n\t\tpl3.base.y += ( l2.y / l2.x ) * 2.0 * TRENCH_HALF_WIDTH;\n\n\t\tif ( ( abs( p.x ) < TRENCH_HALF_WIDTH ) && ( p.z < so ) )\n\t\t{\n#ifdef ANALYTICAL_SHADOW\n\t\t\tsun_shadow = penumbra_sun( dot( p.xz - pl1.base, pl1.normal ) );\n#endif\n\t\t\tfirst_bounce = penumbra_bounce( min( dot( p.xz - pl2.base, pl2.normal ),\n\t\t\t\t\t\t\t\t\t\t\t\t dot( p.xz - pl3.base, pl3.normal ) ) );\n\n\t\t\tfirst_bounce *= step( p.x, TRENCH_HALF_WIDTH - 0.5 ) * step( p.z, 0.0 );\n\t\t}\n\t}\n\n\tfragColor.rgb = shade( view_ray.o, view_ray.d, camera, p, n, l\n\t\t\t\t\t\t   , traced_shadow, sun_shadow, first_bounce, to, ao, exposure, uv );\n#ifdef LASERS\n\tfragColor.rgb += lasers( view_ray, 0.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, 1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -1.0, time, to.t );\n\tfragColor.rgb += lasers( view_ray, -0.5, time, to.t );\n\tfragColor.rgb += lasers( view_ray, +0.5, time, to.t );\n#endif\n\tfragColor.rgb *= fade;\n\tfragColor.rgb = mix( fragColor.rgb, debug_color.rgb, debug_color.a );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}