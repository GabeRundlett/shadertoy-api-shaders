{
    "Shader": {
        "info": {
            "date": "1574770857",
            "description": "WIP. Marching random paths to approximate light propagation. Use WASD and mouse to move. L - place light\n",
            "flags": 48,
            "hasliked": 0,
            "id": "tdGSRd",
            "likes": 9,
            "name": "Path marching experimental",
            "published": 3,
            "tags": [
                "ray",
                "fast",
                "pathtracing",
                "marcher"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 509
        },
        "renderpass": [
            {
                "code": "// Fork of \"Path marching - sky illumination\" by None. https://shadertoy.com/view/-1\n// 2019-11-26 00:05:56\n\n/// USE WASD TO MOVE AROUND\n\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat sdist(vec3 a, vec3 b, float r)\n{\n    vec3 d = a-b;\n    return dot(d,d)/(sqr(r)+1e-6);\n}\n\n//estimate the radius you need to blur\n#define sample_blur 15.\nfloat estim_variance(vec2 pos)\n{\n    float var = 0.;\n    float norm = 0.;\n    for(float i = 0.; i < 4.; i++)\n    {\n        float lod = i;\n        norm += sqr(lod);\n        var += max(0.5*log2(max(sample_blur/(texture(iChannel2, pos, lod).w+0.01),1.)),0.)*sqr(lod);\n    }\n    return var/norm; //return log2radius \n}\n\n#define GOLDEN_ANGLE 2.39996\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n#define ITERATIONS 300.\n\nvec3 denoise(vec2 pos)\n{\n    vec4 this_ill = texture(iChannel2, pos, 7.);\n    vec3 this_col = texture(iChannel3, pos).xyz;\n    vec4 this_pos = texture(iChannel0, pos);\n    \n    float radius = clamp(80./(sqr(this_ill.w)+0.02), 0., 6.);\n    float lod = max(log2(radius/sqrt(ITERATIONS)+1.),0.);\n    \n    //the blur sphere radius in world space;\n    float world_radius = radius*this_pos.w*LOD*20.;\n    \n    //accumulated illumination\n    vec3 acc = vec3(0);\n    float div = 0.0;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(ITERATIONS));\n    \n    //radial bilater blur\n\tfor (float j = 0.; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle = rot * vangle;\n        \n        vec2 lpos = pos + (r-1.) * vangle;\n        \n        if(lpos.x > 0. && lpos.y > 0. && lpos.x < 1. && lpos.y < 1.)\n        {\n            float k = exp(-sdist(this_pos.xyz,texture(iChannel0, lpos, 0.).xyz, world_radius));\n        \n            //extract the illumination from the color\n            vec3 col = texture(iChannel2, lpos, lod).xyz/texture(iChannel3, lpos, 0.).xyz; \n\n            acc += col * k;\n            div += k;\n        }\n\t}\n    \n    //apply the estimated illumination to this point\n\treturn this_col.xyz * acc / div;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord/iResolution.xy;\n   \n    vec4 c = texture(iChannel2, pos, 0.);\n    vec3 col = c.xyz;//vec3(estim_variance(pos));//denoise(pos);//\n    \n    #ifdef AUTOEXPOSURE\n    \tfloat exposure = 2.3*pow(abs(length(texture(iChannel2, pos, log2(max(iResolution.x, iResolution.y))).xyz)),-1./2.2);\n    #else\n    \tfloat exposure = 80.;\n    #endif\n    \n    //tonemapping\n    fragColor.xyz = 1. - exp(-exposure*pow(abs(col),vec3(1./2.2)));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define FOV 3.\n\n#define MAX_STEPS 128.\n#define MAX_DIST 256.\n#define LOD max(0.004,2./iResolution.x)\n#define CAMERA_SPEED 5./60.\n#define MOUSE_SENSITIVITY 0.15/60.\n\n#define SPP 1.\n#define AVG 0.999\n#define MAX_BOUNCE 3.\n#define AUTOEXPOSURE\n#define reflection 0.3\n\n#define N 5.\n\n#define MOUSE_INDX 0\n#define ANGLE_INDX 1\n#define POS_INDX   2\n#define VEL_INDX   3\n#define LIGHT_INDX 4\n#define FRACTAL_ITER 12.\n\n#define overrelax 1.25\n/*\n //Building bridges\nconst float iFracScale = 1.8093;\nconst float iFracAng1 = -3.165;\nconst float iFracAng2 = -3.209477;\nconst vec3 iFracShift = vec3(-1.0939, -0.43495, -3.1113);\nconst vec3 iFracCol = vec3(5.00, 5.99, 0.1);\n*/\n\n//Mega citadel\nconst float iFracScale = 1.4731;\nconst float iFracAng1 = 0.;\nconst float iFracAng2 = 0.;\nconst vec3 iFracShift = vec3(-10.4, 3.28, -1.90);\nconst vec3 iFracCol = vec3(1.f, 1.f, 1.f);\n\n\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvec3 hash33(vec3 p)\n{\n    return fract(13406.456*sin(p.xyz)*sin(p.zxy));\n}\n\nfloat noise(float t, float seed) {\n    float i = floor(t), f = fract(t);\n    float u = 0.5 - cos(3.14159*f)*0.5;\n    return mix(hash11(i + seed),  hash11(i + 1. + seed), u);\n}\n\nfloat perlin(float t, float seed)\n{\n    float r = 0.f;\n    float f = 1.f;\n    float a = 1.f;\n    for(float i = 0.; i < 5.; i++)\n    {\n        r += noise(f*t, f+seed)*a;\n        f *= 1.4;\n        a *= 0.6;\n    }\n    return r;\n}\n\nvec3 lim_mod(vec3 p, vec3 s)\n{\n    vec3 lim =  mod(p,s) - s*0.5;\n    if(p.z > 1.)\n    {\n        lim.z = p.z - 1.;\n    }\n    return lim;\n}\n\n\nmat3 getCamera(vec2 angles)\n{\n   mat3 theta_rot = mat3(1,   0,              0,\n                          0,   cos(angles.y),  sin(angles.y),\n                          0,  -sin(angles.y),  cos(angles.y)); \n        \n   mat3 phi_rot = mat3(cos(angles.x),   sin(angles.x), 0.,\n        \t\t       -sin(angles.x),   cos(angles.x), 0.,\n        \t\t        0.,              0.,            1.); \n        \n   return theta_rot*phi_rot;\n}\n\nvec3 getRay(vec2 angles, vec2 pos)\n{\n    mat3 camera = getCamera(angles);\n    return normalize(transpose(camera)*vec3(FOV*pos.x, 1., FOV*pos.y));\n}\n\nfloat hash(float p)\n{  \n    return hash11(p);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec2 res;\n    res.x = hash(dot(p, vec2(1.,sqrt(2.))));\n    res.y = hash(res.x);\n    return res;\n}\n\nvec2 hash21(float p)\n{\n    vec2 res;\n    res.x = hash(p);\n    res.y = hash(res.x);\n    return res;\n}\n\nvec3 hash31(float x)\n{\n    vec3 res;\n    res.x = hash(x);\n    res.y = hash(x+1.);\n    res.z = hash(x+2.);\n    return res;\n}\n\n\nvec3 perlin31 (float p)\n{\n   float pi = floor(p);\n   float pf = p - pi;\n   return hash31(pi)*(1.-pf) +\n          hash31(pi + 1.)*pf; \n}\n\nvec3 perlin31(float p, float n)\n{\n    float frq = 1., amp = 1., norm = 0.;\n    vec3 res = vec3(0.);\n    for(float i = 0.; i < n; i++)\n    {\n        res += amp*perlin31(frq*p);\n        norm += amp;\n        frq *= 2.;\n       // amp *= 1;\n    }\n    return res/norm;\n}\n\n\nvec2 perlin(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 a = vec2(0.,1.);\n   return hash22(pi+a.xx)*(1.-pf.x)*(1.-pf.y) +\n          hash22(pi+a.xy)*(1.-pf.x)*pf.y +\n          hash22(pi+a.yx)*pf.x*(1.-pf.y) +\n          hash22(pi+a.yy)*pf.x*pf.y;   \n}\n\nfloat singrid(vec2 p, float angle)\n{\n    return 0.5*(sin(cos(angle)*p.x + sin(angle)*p.y)*sin(-sin(angle)*p.x + cos(angle)*p.y) + 1.);\n}\n\n//technically this is not a blue noise, but a single freqency noise, the spectrum should look like a gaussian peak around a frequency\nfloat blue(vec2 p, float seed)\n{ \n    seed = 100.*hash(seed);\n    vec2 shift = 20.*hash21(seed);\n    p += shift;\n    vec2 pnoise = perlin(p*0.25+seed);\n    \n    //bilinear interpolation between sin grids\n    return singrid(p,0.)*(pnoise.x*pnoise.y+(1.-pnoise.x)*(1.-pnoise.y)) +\n           singrid(p,3.14159*0.33*2.)*(1.-pnoise.x)*pnoise.y +\n           singrid(p,3.14159*0.66*2.)*(1.-pnoise.y)*pnoise.x;\n}\n\nvec3 blue3(vec2 p, float seed)\n{\n    vec3 res;\n    res.x = blue(p, sin(seed));\n    res.y = blue(p, sin(2.*seed));\n    res.z = blue(p, sin(3.*seed));\n    return res;\n}\n\nfloat qntz(float x, float d)\n{\n    return round(x/d)*d;\n}\n\n\nvec4 sdPlane( vec3 p )\n{\n\treturn vec4(vec3(0.25,0.25,0.25) + mod(round(p.x)+round(p.y),2.)*vec3(0.5,0.5,0.5),p.z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 sdSponge(vec3 p)\n{\n   p.xyz = p.xyz - 2.44*round(clamp(p.xyz/2.44, -2., 0.));\n    \n   float d = sdBox(p,vec3(1.0));\n   vec3 res = vec3( d, 1.0, 0.0 );\n\n   float s = 1.0;\n   for( int m=0; m<5; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec3( d, 0.2*da*db*dc, (1.0+float(m))/4.0 );\n      }\n   }\n   return res;\n}\n\nfloat light_map(vec3 p, float time)\n{\n    float sd = sdSphere(p - vec3(-10.*cos(0.0*time),-10.*cos(0.0*time), 5.), 1.);\n    //sd = min(sd, sdSphere(p - vec3(5.*cos(0.8*iTime+3.14),5.*sin(0.8*iTime+3.14), 2.), 0.5));\n    return sd;\n}\n\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvoid mengerFold(inout vec3 z) {\n\tfloat a = smin(z.x - z.y, 0.0, 0.2);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n}\n\n\nvoid rotX(inout vec3 z, float s, float c) {\n\tz.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\nvoid rotY(inout vec3 z, float s, float c) {\n\tz.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\nvoid rotZ(inout vec3 z, float s, float c) {\n\tz.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\nvoid rotX(inout vec3 z, float a) {\n\trotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n\trotY(z, sin(a), cos(a));\n}\nvoid rotZ(inout vec3 z, float a) {\n\trotZ(z, sin(a), cos(a));\n}\n\nconst float s1 = sin(iFracAng1);\nconst float c1 = cos(iFracAng1), s2 = sin(iFracAng2), c2 = cos(iFracAng2);\n\nconst vec2 cell = vec2(30,30);\nvec4 sdFractal(vec3 p)\n{\n    p.xz = p.xz+cell*0.5;\n    vec2 cell_i = round(p.xz);\n    p.xz = mod(p.xz, cell) -  cell*0.5;\n    vec3 dp = iFracShift;\n    float scale = 1.;\n    vec3 orbit =  vec3(0.);\n    vec3 col = vec3(0.);\n    float norm = 0.;\n\tfor (float i = 0.; i < FRACTAL_ITER; i++) \n    {\n\t\tp = abs(p);\n\t\trotZ(p, s1, c1);\n\t\tmengerFold(p);\n\t\trotX(p, s2, c2);\n        scale *= iFracScale;\n\t\tp = p*iFracScale + dp;\n    \torbit = max(orbit, sin(p*iFracCol));\n\t}\n\treturn vec4(clamp(1.-0.8*orbit,0.,1.),sdBox(p, vec3(6.0))/scale);\n}\n\nvec4 opU(vec4 a, vec4 b)\n{\n    return (a.w<b.w)?a:b;\n}\n\nvec4 map(vec3 p)\n{\n    vec4 sd = opU(sdFractal(p.xzy - vec3(14,0,0)), sdPlane(p));\n    return sd;\n}\n\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*map( pos + e.xyy ).w + \n  \t\t\t  e.wwzz*map( pos + e.yyx ).w + \n\t\t\t  e.wzwz*map( pos + e.yxy ).w + \n              e.zzzz*map( pos + e.xxx ).w )/vec4(e.xxx, 1.);\n}\n\n//calculate the normal using an already evaluated distance in one point\nvec3 calcNormal(in vec3 pos, in float h)\n{\n    vec4 e = vec4(0.0005,-0.0005, 1., -1);\n    pos = pos - e.xxx;\n    return normalize(e.zww*map( pos + e.xyy ).w + \n  \t\t\t \t\t e.wwz*map( pos + e.yyx ).w + \n\t\t\t  \t\t e.wzw*map( pos + e.yxy ).w + \n              \t\t e.zzz*h );\n}\n\nvec4 trace(vec3 p, vec3 ray, inout float t, inout float i, float angle)\n{\n    float h = 0., prev_h = 0., td = 0.;\n    float omega = overrelax;\n    for(; (t < MAX_DIST) && (i < MAX_STEPS);  i++)\n    {\n        h = map(p + td*ray).w;\n        \n        if(prev_h*omega>=abs(h)+abs(prev_h)) //if overtepped\n        {\n            td += (1.-omega)*prev_h; // step back to the safe distance\n            h = prev_h;\n            omega = 1.;//(omega - 1.)*0.5 + 1.;\n        }\n        else\n        {\n            if(h < (t+td)*angle)\n            {\n                t += td;\n                return vec4(p + td*ray, h);\n            }\n            td += h*omega; //continue marching\n           \t\n            prev_h = h;\n        }\n    }\n    t+=td;\n    return vec4(p + td*ray, h);\n}\n\n\n//Keyboard constants\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/// UTILITY\n///\n/// Using the GPU as the CPU here, pretty inefficient I guess\n\nbool isKeyPressed(int KEY)\n{\n\treturn texelFetch( iChannel3, ivec2(KEY,0), 0 ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n    \n    if(fragCoord.x <= N && fragCoord.y <= 1.)\n    {\n        //instruction\n        int I = int(fragCoord.x); \n        fragColor = texelFetch(iChannel0,  ivec2(I,0), 0);\n        vec4 mouse = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0);\n        vec2 mousespeed = texelFetch(iChannel0,  ivec2(MOUSE_INDX,0), 0).xy;\n        vec4 angles = texelFetch(iChannel0,  ivec2(ANGLE_INDX,0), 0);\n        mat3 camera = transpose(getCamera(angles.xy));\n        vec4 posit = texelFetch(iChannel0,  ivec2(POS_INDX,0), 0);\n        vec4 vel = texelFetch(iChannel0,  ivec2(VEL_INDX,0), 0);\n\n        vec4 norm = calcGrad(posit.xyz);\n        norm.xyz = norm.xyz/(length(norm.xyz) + 0.0001);\n        switch(I)\n        {\n        case MOUSE_INDX:  //mouse speed calculation \n            if(length(iMouse.zw - iMouse.xy) > 10.)\n  \t\t    {\n   \t\t\t\tfragColor.xy = iMouse.xy - fragColor.zw; // mouse delta\n                if(iFrame < 1)\n                {\n                    fragColor.xy = vec2(0.);\n                }\n            }\n            else\n            {\n\t\t\t\tfragColor.xy = vec2(0.); // mouse delta\n            }\n    \t\tfragColor.zw = iMouse.xy; // mouse pos\n            break;\n            \n        case ANGLE_INDX:  //angle computation\n           \n   \t\t\tfragColor.xy = fragColor.xy + fragColor.zw*MOUSE_SENSITIVITY; // angle delta\n            fragColor.y = clamp(fragColor.y, -PI*0.5, PI*0.5);\n    \t\tfragColor.zw += vec2(1,-1)*mouse.xy; // mouse pos\n            fragColor.zw *= 0.8;\n            break;\n            \n        case POS_INDX:  //position\n          \n            float DX = length(vel.xyz*CAMERA_SPEED)+0.0001;\n            float MAXDX = map(fragColor.xyz + vel.xyz*CAMERA_SPEED).w + norm.w;\n            if(DX > MAXDX)\n                vel *= 0.25;\n            fragColor.xyz += vel.xyz*CAMERA_SPEED;\n   \t\t\tfragColor.w = vel.w;\n            if(iFrame < 1)\n            {\n                fragColor.xyz = vec3(12,-5,10.5);\n            }\n           \n            break;\n         case VEL_INDX:  //velocity\n          \n            fragColor.w++;\n            if(length(mousespeed) >0. || isKeyPressed(KEY_Z))\n            {\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_UP) || isKeyPressed(KEY_W))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[1]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_DOWN) || isKeyPressed(KEY_S))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[1]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_RIGHT) || isKeyPressed(KEY_D))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz += camera[0]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            if(isKeyPressed(KEY_LEFT) || isKeyPressed(KEY_A))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz -= camera[0]*CAMERA_SPEED;\n                fragColor.w = 0.;\n            }\n            fragColor.xyz *= 0.8; //slowing down\n            \n            //fractal collision detection, removing the normal velocity component \n          \tfragColor.xyz += norm.xyz*max(dot(fragColor.xyz, -norm.xyz),0.)*exp(-max(norm.w,0.)/0.04);\n            break;\n          case LIGHT_INDX:  //light\n            if(isKeyPressed(KEY_L))\n   \t   \t\t{\n   \t\t\t\tfragColor.xyz = posit.xyz;\n                fragColor.w = .08;\n            }\n            if(iFrame < 1)\n            {\n                fragColor = vec4(12.5,-4,10.5, 0.25);\n            }\n            break; \n        }   \n    } else discard;\n    \n   \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// PATH MARCHING\nvec4 light_sphere;\nvec4 light( in vec3 pos )\n{\n    vec4 e = vec4(0.0005,-0.0005, 0.25, -0.25);\n    return   (e.zwwz*light_map( pos + e.xyy , iTime) + \n  \t\t\t  e.wwzz*light_map( pos + e.yyx , iTime) + \n\t\t\t  e.wzwz*light_map( pos + e.yxy , iTime) + \n              e.zzzz*light_map( pos + e.xxx , iTime) )/vec4(e.xxx, 1.);\n}\n\n\nvec3 light_distr(vec3 p)\n{\n    return vec3(1,1,1) * (4.*step(-light_sphere.w, -length(p - light_sphere.xyz)));\n}\n\nvec3 sky(vec3 ray)\n{\n    return 0.005*texture(iChannel1, ray.xzy).xyz;//vec3(0.08,0.3,1.0)*sqrt(1.-0.95*ray.z*ray.z);\n}\n\n\nvec3 path_march(vec3 p, vec3 ray, float angle, float seed)\n{\n    vec3 fincol = vec3(1.), finill = vec3(0.);\n    float i = 0., t = 0.; //full number of iterations\n    for(float b = 0.; (b < MAX_BOUNCE) && (i < MAX_STEPS); b++)\n    {\n        //march next ray\n        vec4 res = trace(p, ray, t, i, angle);\n         \n        if(t > MAX_DIST || (i >= MAX_STEPS && res.w > 5.*angle*t))\n        {\n            finill += sky(ray);\n            break;\n        }\n        \n        /// Surface interaction\n        vec3 norm = calcNormal(res.xyz, res.w);    \n        //discontinuity correction\n        p = res.xyz - (res.w - 2.*angle*t)*norm;\n        \n        vec3 refl = reflect(ray, norm);\n        vec3 rand = 2.*hash31(seed+b)-1.;\n        //random diffusion, random distr already samples cos(theta) closely\n        ray = normalize(refl*reflection + norm*(1.-reflection) + (1.-reflection)*rand);\n\n        //color and illuminaition\n        vec4 colp = map(p);\n        fincol = fincol*clamp(colp.xyz,0.,1.);\n        //add fractal glow\n        finill += 5.*light_distr(p);\n        finill += vec3(1.)*exp(-300.*clamp(pow(abs(length(colp.xyz-vec3(0.2,0.2,0.8))),2.),0.,1.));\n        finill += vec3(0.6)*exp(-300.*clamp(pow(abs(length(colp.xyz-vec3(0.3,0.8,0.3))),2.),0.,1.));\n        angle *= 1.25;\n    }\n    \n    return fincol*finill;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized centered pixel coordinates \n    vec2 pos = (fragCoord - iResolution.xy*0.5)/max(iResolution.x,iResolution.y);\n    \n    vec2 angles = texelFetch(iChannel3,  ivec2(ANGLE_INDX,0), 0).xy;\n        \n \tvec3 ray = getRay(angles, pos);\n    vec4 p = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n    \n    light_sphere = texelFetch(iChannel3,  ivec2(LIGHT_INDX,0), 0);\n    light_sphere.xyz += 0.*light_sphere.w*vec3(sin(iTime), cos(iTime), 0.);\n    \n    fragColor = vec4(0.);\n\n    for(float i = 0.; i <SPP; i++)\n    {\n        vec3 rand = 2.*blue3(2.*fragCoord, iTime+i) - 1.;\n        //quantize the noise which is used for the seed to get higher correlation between pixels in one frame \n        fragColor.xyz += path_march(p.xyz, ray+0.5*LOD*rand, LOD, qntz(rand.x,0.005)+hash(iTime));\n    }\n    \n    fragColor.xyz /= SPP;\n\n    vec4 posit = texelFetch(iChannel3,  ivec2(POS_INDX,0), 0);\n   \n    vec4 prev = texture(iChannel0, fragCoord/iResolution.xy);\n\n    float avg = (posit.w>1.)?AVG*tanh(posit.w*sqrt(1.-AVG)):0.25;\n    fragColor.xyz = avg*prev.xyz + (1.- avg)*fragColor.xyz;\n    fragColor.w = posit.w;\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}