{
    "Shader": {
        "info": {
            "date": "1483694655",
            "description": "Based on hornet's noise experiments ( https://www.shadertoy.com/view/4ssXRX )\nLeft: 8-tap gaussian'ish noise (by central limit)\nRight: 1-tap gausisan noise (by inverting cumulated distribution function)",
            "flags": 0,
            "hasliked": 0,
            "id": "MlVSzw",
            "likes": 31,
            "name": "Single sample gaussian noise",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "gaussian",
                "rnd",
                "rand",
                "errorfunction"
            ],
            "usePreview": 0,
            "username": "stubbe",
            "viewed": 3144
        },
        "renderpass": [
            {
                "code": "// Based on hornet's 'noise distributions' shader (https://www.shadertoy.com/view/4ssXRX)\n\n// An experiment in the viability of generating gaussian noise directly from a single\n// uniform noise sample.\n\n// Intuitively, it is clear that if we bend or warp the output of a uniform noise then we are\n// also changing the distribution of that noise. In general, uniform noise can be shaped into\n// a specific distribution by mapping it though its corresponding inverted\n// cumulative probability distribution function.\n\n// It is well known that the anti-derivative of the gaussian function is the error function.\n// The error function unfortunately doesn't have a closed form expression. To get around this, a variant\n// of Sergei Winitzki's highly accurate approximation is used instead.\n// In practice, a simpler approximation would probably be satisfactory.\n\n// It is unclear if this has any practical use :)\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\nconst float PI = 3.1415926535;\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat _trunc( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\nconst float ALPHA = 0.14;\nconst float INV_ALPHA = 1.0 / ALPHA;\nconst float K = 2.0 / (PI * ALPHA);\n\nfloat inv_error_function(float x)\n{\n\tfloat y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\n\nfloat gaussian_rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat x = nrand( n + 0.07*t );\n    \n\treturn inv_error_function(x*2.0-1.0)*0.15 + 0.5;\n}\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( _trunc(t,NUM_BUCKETS_F), _trunc(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = n8rand( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = gaussian_rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < .5 )\n\t{\n\t\to = n8rand( uv );\n        idx = 1;\n        uvrange = vec2( 0.0, 0.5 );\n\t}\n\telse\n\t{\n\t\to = gaussian_rand( uv );\n        idx = 2;\n        uvrange = vec2( 0.5, 1.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 0.5) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}