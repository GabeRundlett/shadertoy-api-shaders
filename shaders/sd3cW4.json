{
    "Shader": {
        "info": {
            "date": "1653957068",
            "description": "Glass / Refractive surface - moving textured wall behind glass.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "sd3cW4",
            "likes": 28,
            "name": "Glass Walls",
            "published": 3,
            "tags": [
                "raymarching",
                "refraction",
                "glass"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 549
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Beveled Glass 5/23/22 @byt3_m3chanic\n    \n    Just some glass with a refractive surface - animated textured wall behind.\n    AA makes it pretty - but can be slow on lower end machines.\n    \n    big thank you to, and a little bit of help from:\n    @blackle, @tdhooper, @iq, @Drakyen\n    \n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI2     6.28318530718\n#define PI      3.14159265359\n\n// AA Setting - comment out to disable\n#define AA 2\n\nfloat time;\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*43758.5453); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ return .45+.4*cos( PI2*t*vec3(.95,.97,.88)*vec3(0.110,0.584,0.949) ); }\n\n\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box( vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//global\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat radius = 1.25;\n     \nconst vec2 scaler =vec2(6.);\nfloat pattern(vec3 pt){\n    vec3 hp = pt;\n    vec2 uv   = hp.xy;\n\n    vec2 grid = fract(uv.xy*scaler)-.5;\n    vec2 id   = floor(uv.xy*scaler);\n    float hs = hash21(id);\n\n    if(hs>.5) grid.x*=-1.;\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.075;\n\n    if(hs>.82){\n     circle = abs(length(gx.x)-.5)-.075;\n     circle = min(circle,abs(length(gx.y)-.5)-.075);\n    }\n    \n    float px = 45.5/R.x;\n    circle=abs(abs(circle)-.08)-.01;\n    circle=smoothstep(-px,.175-px,circle);\n\n    float h = mix(.0, .1,circle);\n    return clamp(h*.1,.0,.1);\n}\n\nmat2 spin;\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.xy*=spin;\n    \n    vec3 q = p-vec3(.2*sin(T*.1),.2*cos(T*.0981),1);\n    vec3 r = p+vec3(0,0,7);\n\n    float hmp = pattern(q);\n    q.z+=.085*sin(T*.45+q.x*3.7);\n\n    float glass = abs(q.z)-hmp;\n\n    if(glass<res.x) {\n        res = vec2(glass,2.);\n        hit=q;\n    }    \n\n    float background = box(r,vec3(12.,8.,.1));\n    if(background<res.x) {\n        res = vec2(background,3.);\n        hit=r;\n    }    \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 h = vec3(.0005);\n    \n    if(m==3.) {\n        vec2 uv = hitPoint.xy*.075;\n        uv.x+=T*.05;\n        \n        float scale = 10.;\n        vec2 id = floor(uv*scale);\n        uv = fract(uv*scale)-.5;\n\n        float hs = hash21(id);\n        vec3 hue = 0.5 + 0.5*cos(hs+vec3(0,1,2)-id.xyx*.2);\n         \n        if(hs>.55) {\n            scale*=.75;\n            id   = floor(uv*2.);\n            uv = fract(uv*2.)-.5;\n            hue *= 0.5 + 0.5*cos(id.x+vec3(0,1,2)+id.y);\n        }\n    \n        h =vec3(0);\n\n        float px = 1.5*scale/R.x;\n        float d = box(uv,vec2((fract(hs*3.1)>.9)?.3:.325))-(.015*scale);\n        if(fract(hs*3.1)>.9) d=abs(d)-.05;\n        d = smoothstep(px,-px,d);\n\n        h = mix (h,hue,d);\n    }\n    \n    \n    return h*pow(h, vec3(1.25))*2.5;\n}\n\nvec3 renderAll( vec2 uv){    \n\n    vec3 C=vec3(.0);\n    vec3 ro = vec3(0,0,1.45),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? .0 : -(M.y/R.y * .05 - .025) * PI;\n    float y = M.xy == vec2(0) ? .0 :  (M.x/R.x * .05 - .025) * PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.;\n    float iv= 1.;\n    float bnc = 5.;\n    float alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<110;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = i<32?ray.x*.85:ray.x;\n        float m = ray.y;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n            bnc--;\n            hitPoint=hit;\n\n            alpha*=d;\n            \n            C+=shade(p,rd,d,m,n)*atten;\n            if(m==3.)break;\n            atten *= .7;\n            p += rd*.001;\n            k = sign(map(p).x);\n            \n            vec3 rf=refract(rd,n,iv > 0. ? 1./1.2 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.001;\n   \n            if(bnc<1.) break;\n        }  \n        if(distance(p,rd)>100.) { break; }\n       \n    }\n\n   return clamp(C,vec3(0),vec3(1));\n}\n\nfloat vmul(vec2 v) {return v.x * v.y;}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    \n    float mTime = iTime;\n    time = mTime;    \n    spin = rot(.5*sin(T*.2));\n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    // set AA above renderFull\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderAll(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}