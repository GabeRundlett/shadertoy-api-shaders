{
    "Shader": {
        "info": {
            "date": "1699524749",
            "description": "the symmetry mat3 algorithm form shane's Refractive Poly",
            "flags": 0,
            "hasliked": 0,
            "id": "Dtcyzl",
            "likes": 12,
            "name": "fractal symmetry sponge",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "generative",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "chenxianming",
            "viewed": 911
        },
        "renderpass": [
            {
                "code": "#define I iResolution\n#define PI 3.1415926\n#define rot( r ) mat2(cos(r), sin(r), -sin(r), cos(r) )\n#define v( a ) clamp(a , 0., 1. )\n#define T( s ) fract( iTime * s ) * PI * 4.\n\n// shane's Refractive Poly\n// https://www.shadertoy.com/view/DtjSWh\nconst float PHI = (1. + sqrt(5.))/2.; // 1.618\nconst float J = (PHI - 1.)/2.; // .309016994375\nconst float K = PHI/2.; // J + .5\nconst mat3 R0 = mat3(.5,  -K,   J,  K,  J, -.5,  J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5,  J, .5,   K, .5 , -K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K, .5, -K,  -J,  K ,  J, .5);\n\nvec3 repNormal(vec3 p){ \n    p *= .9;\n    p = R0*abs(p);\n\n    p = R1*abs(p);\n    //p.xz *= rot( -T( .0125 ) );\n    p = R2*abs(p);\n    p.yz *= rot( -T( .025 ) );\n    return abs(p) - .1;  \n}\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float c) {\n    return -smin(-a, -b, c);\n}\n\n#define ax( a, b ) smin( a, b, .1 )\n\nfloat sp( vec3 p ){\n    \n    float c = 5.;\n    \n    for( float i = 0.; i < c; i++ ){\n        p.xz = abs( p.xz );\n        p.xy *= rot( i / c );\n        p.x = abs( p.x );\n        p.xz *= rot( i /c * .5 );\n        p.yz = abs( p.yz );\n        p.yz *= rot( i /c * .5 );\n    }\n\n    return max(\n        max( abs( p.x ) - .4, abs( p.y ) - .4 ),\n        abs( p.z ) - .004\n    );\n}\n\nfloat st( vec3 p ){\n    p.xz *= rot( T( .025 ) );\n    // return sp( p );\n    \n\tfloat s=0.3;\n\tfor(float i=0.;i<3.;i++){\n\t\tp=abs(p)-s;\n\t\tp.xz *= rot( i / 3. );\n\t\ts=s/2.5;\n\t}\n    \n    return max(\n        -sp( p ),\n        length( p ) - .35\n    );\n}\n\n\nfloat calcCore( vec3 p ){\n    p.y -= .1;\n\n    p.xz *= rot( T( .05 ) );\n    p.yz *= rot( -T( .05 ) );\n    \n    p = repNormal( p );\n\n    float d = max(\n        max( abs( p.y ) - .2, abs( p.z ) - .2 ),\n        abs( p.x ) - .09\n    );\n    \n    d = max(\n        d,\n        -st( p * 2.1 )\n    );\n    \n    \n    return d;\n}\n    \n\nfloat df( vec3 p ){\n    \n    vec3 p2 = p;\n    \n    return calcCore( p );\n}\n\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nvec3 l2(in vec3 b) {\n  vec2 a = vec2(1, -2) * 2.;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nfloat g( vec3 a, vec3 p ){\n    return v( dot( a, l(p) ) );\n}\n\nfloat S( vec3 p, vec3 ca, vec3 r, float q ){\n    return v( pow( dot( l( p ), normalize( normalize( ca ) - r ) ), q ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nfloat bgFractal(vec2 u ){\n    float s = .2;\n    // u *= rot( iTime );\n    for( float i = 0.; i < 20.; i++ ){\n        u=abs(u)-.1;\n        u.y = abs( u.y ) - .1 * s;\n        u*=rot( i/3.1415 + ( .6 - cos( iTime * .25 ) * .2 ) );\n        u.x = sin( abs( u.x ) - .01 );\n        s *= 1.1;\n    }\n    \n    float p = abs( length( u ) ) - .1;\n    \n    p = smoothstep( 0.01, p, 0.019 );\n    p = dot( p, p );\n    return p;\n}\n\nvec3 hsl2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0,1.0);\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n// some where but for desgin\nvec3 colorCir( vec2 p ){\n    // Position normalised into (-1, 0, 1)\n    vec2 d = 1.0 - (p * 2.0);\n    \n    // Distance from screen center\n    float dist = sqrt((d.x*d.x) + (d.y*d.y));\n    \n    // Rotation\n    float r = acos(d.x / dist);\n    // r += T( .025 );\n    if (d.y < 0.0) { r = PI-(r + PI); } // Sort out the bottom half (y=-1)\n\n    // From radians (0 - 2_PI) to hue (0 - 1)\n    float hue = ((r / PI) / 2.0);\n    \n    // Into color\n    return hsl2rgb( vec3(hue, 1.0, 0.5));\n}\n\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float A = min( I.x, I.y );\n    vec2 u = ( V * 2. - I.xy ) / A;\n    \n    vec3 c, p, o = vec3( 0., 0., -1.5 ), r = vec3( u * .4, 1. );\n    c += .05;\n    c += smoothstep( 0.5, .0, ( u.y / 2. + .5 ) + .2 );\n\n    c += \n    (bgFractal( u ) * colorCir( u ) * .3 * ( 1. - smoothstep( 0., 1.5, length(u)-.01 ) ) ) * ( 1. - smoothstep( 1., .3, ( u.y / 2. + .5 ) + .2 ) );\n    \n    float t, d, i;\n    for( ; i < 64.; i++ ){\n        p = o + r * t,\n        d = df( p ),\n        t += d;\n        if( t < .64 || abs( d ) < 1e-3 )\n            break ;\n    }\n\n    \n    if( d < 1e-3 ){\n        \n          vec3 p2 = p;\n\n            p2 = repNormal( p2 );\n            \n            vec3 n = l( p );\n            float rc = g( vec3( .0, 1.1, -.1 ), p );\n\n            // c += rc * .1;\n            \n            vec3 rr = reflect(l(p), r);\n\n            \n            //c += rr * .1;\n            float amb = dot(n, vec3(1.0, 1.0, -1.6));\n            \n            c = vec3( .1 );\n            \n            c += S( p, n, r, 5. ) * .1;\n            //c +=  rr.x * .1;\n\n            float ss = calcSoftshadow( p, vec3( -.5, 1.1, -1. ), 0.1, .5, 0 ) * rc;\n            c += ss ;\n            \n            c = sqrt( c );\n            c += p2 * .4;\n            c = v( c );\n    }\n    \n    \n    p = vec3( 0 );\n    i = 0.,\n    d = 0.,\n    t = 0.;\n    \n    for( ; i < 24.; i++ )\n        p = o + r * t,\n        p.y *= -1.,\n        //p.x -= .05,\n        p.y -= .77,\n        d = df( p ),\n        t += d;\n    if( d < 1e-3 ){\n        vec3 p2 = repNormal( p );\n        vec3 rr = reflect(l(p), c);\n        /*\n        c += vec3( p2.x, p2.y, p2.z / 2. + .5 ) * .1 +\n            (.5 + .35 * cos(o + p.xyx * 2. + vec3(1, 5, 2))) * .05;\n        c += rr * .1;\n        */\n        c -= rr.r * .1 - p2 * .1;\n    }\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}