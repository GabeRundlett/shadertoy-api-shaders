{
    "Shader": {
        "info": {
            "date": "1599510459",
            "description": "This is fully procedural so you can modify it on the fly. I found using the baked volume cuts render time in half but then it's not procedural... Tell me if you know of any faster noise algorithms.",
            "flags": 32,
            "hasliked": 0,
            "id": "wt2fDD",
            "likes": 7,
            "name": "Greyscale fBm Emission Nebula",
            "published": 3,
            "tags": [
                "procedural",
                "raymarch",
                "dither",
                "volumetric",
                "raymarcher",
                "nebula"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 614
        },
        "renderpass": [
            {
                "code": "// ^^^ Everthing is up here in Buffer A ^^^\n// It is seperate so you can press the button on the bottom of the editor to export a 32-Bit Float OpenEXR!\n\n// Zi7ar21's Volumetric Raymarcher --- September 1st, 2020 --- Updated December 12th, 2020\n// I Deem You Allowed to Use My Code Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/wt2fDD\n// Fork of \"My Nebula\" by Zi7ar21. https://shadertoy.com/view/ttfBDN [August 2nd 2020 00:53:15]\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n\n// Camera's FOV\n#define FOV 1.0\n\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 16\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 4.0\n\n// fBm Number of Octaves (Detail)\n#define NUM_OCTAVES 6\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.25\n\n// If you march less rays, the nebula will appear darker. Bump this up to make it brighter again,\n// Beware there will be more noise\n#define DENSITY 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n//#define ROTATION_MATRIX\n\n// Oof ugly mess below watch out lol\n\n#ifdef ROTATION_MATRIX\n    // Dumb rotation matrix hecking Michael0884 begged me to add lol\n    float xrot = 0.0;\n    float yrot = 0.0;\n    float zrot = 0.0;\n    // Camera Orientation\n    vec3 xdir = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\n    vec3 ydir = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),\n                     cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\n    vec3 zdir = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),\n                     sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n#endif\n#ifndef ROTATION_MATRIX\n    // Camera Orientation\n    vec3 xdir = vec3(1.0,0.0,0.0);\n    vec3 ydir = vec3(0.0,1.0,0.0);\n    vec3 zdir = vec3(0.0,0.0,1.0);\n#endif\n\n// ##### NOISE #####\n// I don't remember where I got this, but it is not mine lol\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}\nvec4 perm(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n\n// Convert Noise to 3D\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p-a;\n    d = d*d*(3.0-2.0*d);\n    vec4 b = a.xxyy+vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy+b.zzww);\n    vec4 c = k2+a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c+1.0);\n    vec4 o1 = fract(k3*(1.0/41.0));\n    vec4 o2 = fract(k4*(1.0/41.0));\n    vec4 o3 = o2*d.z + o1*(1.0-d.z);\n    vec2 o4 = o3.yw*d.x+o3.xz*(1.0-d.x);\n    return o4.y*d.y+o4.x*(1.0-d.y);\n}\n\n// fBm Noise\nfloat fbm(vec3 x){\n    // Initialize Value\n    float v = 0.0;\n    // Amount to Contribute Next Iteration\n    float a = 0.5;\n    // Loop Octaves\n    for (int i = 0; i < NUM_OCTAVES; ++i){\n        // Add Noise based on Octave\n        v += a * noise(x);\n        // Scale Coordinates by 2 for Next Octave\n        x = x * 2.0;\n        // Set Next Octave\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat nebulanoise(vec3 raypos){\n    float density = max(0.0, ((fbm(raypos)*1.5)-0.125)-distance(raypos, vec3(0.0)));\n    return density;\n}\n\n// ##### RAYMARCHING #####\n\n// For Dithering\nfloat hash13(vec3 p3){\n    p3  = fract(p3*0.1031);\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    float density = 0.0;\n    vec3 raypos = camerapos+(raydir*((hash13(vec3(coord, iFrame))-0.5)*STEP_SIZE*2.0));\n    vec3 raydirmod = raydir*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos += raydirmod;\n        density += nebulanoise(raypos)*DENSITY;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return density;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Position\n    vec3 camerapos = vec3(0.0, 0.0, -2.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    // Ray Direction\n    vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    \n    // Raymarch\n    float raymarched = raymarch(camerapos, raydir, fragCoord);\n\n    // Pixel Color\n    vec3 col = vec3(pow(raymarched, 1.0/2.2));\n\n    // Output to Screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}