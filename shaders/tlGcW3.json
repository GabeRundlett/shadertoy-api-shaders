{
    "Shader": {
        "info": {
            "date": "1611853426",
            "description": "reupload - see comments in code",
            "flags": 0,
            "hasliked": 0,
            "id": "tlGcW3",
            "likes": 19,
            "name": "Fluffy's Breakfast",
            "published": 3,
            "tags": [
                "socconetracing"
            ],
            "usePreview": 0,
            "username": "eiffie",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "// fluffy's breakfast by eiffie\n// Still re-uploading from having this done to me nonconsentually... \n// https://pubs.acs.org/doi/10.1021/nn5020616\n// ...high frequency subconscious messages, quiet effective when combined with torture\n// ...the method is actually derived from witchcraft which uses lodestone powder\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// using massive DoF to march around this little guy's furry butt\n\nconst float focalDistance=1.0,aperature=0.07,fudgeFactor=0.9;\n\n#define size iResolution\n#define time iTime\n\n//handy routines from iq\nfloat smin(float a,float b,float k){return -log(exp(-k*a)+exp(-k*b))/k;}//negative k gives int and dif\nfloat Ellipsoid(vec3 z, vec4 r){float f=length(z*r.xyz);return f*(f-r.w)/length(z*r.xyz*r.xyz);}\nfloat Segment(vec3 p, vec3 p0, vec3 p1, float r){vec3 v=p1-p0;v*=clamp(dot(p-p0,v)/dot(v,v),0.0,1.0);return distance(p-p0,v)-r;}\nfloat Cone(in vec3 z, vec2 r){return max(abs(z.y)-r.y,(length(z.xz)-r.x*clamp(r.y-abs(z.y),0.0,r.y))/(1.0+r.x/r.y));}\nvec4 seg4( vec3 pa, vec3 ba )//iq's tube returning nearest point and distance along segment\n{//same as tube except it lets you shape the result with dot(j.xyz,rt) and j.w\n float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n return vec4(pa - ba*h,h);\n}\n// See https://iquilezles.org/articles/morenoise for a proper version :)\nfloat hash(float n) {return fract(sin(n) * 43758.5453123);}\nfloat noyz(vec2 x) {//simple version\n vec2 p=floor(x),f=fract(x),u=f*f*(3.0-2.0*f);\n const float tw=117.0;\n float n=p.x+p.y*tw,a=hash(n),b=hash(n+1.0),c=hash(n+tw),d=hash(n+tw+1.0);\n return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\nfloat fbm(vec2 p) {return 0.5*noyz(p)+0.3*noyz(p*2.3)+0.2*noyz(p*3.7);}\n\nfloat RCyl(in vec3 z, vec3 r){return length(max(vec2(abs(z.z)-r.y,length(z.xy)-r.x),0.0))-r.z;}\n\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}// i got this from knighty and/or darkbeam\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat headbob,tailwag;\nfloat DE(in vec3 p)\n{\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));//dog bowl\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);//smooth difference to scoop out bowl\n float dF=z.y;  //floor\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0)); //body\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));//create tail segment\n j.z-=sin(j.w*3.1416)*0.1;//add a curve to the tail\n float d2=length(j.xyz); //tail distance\n vec2 uv=vec2(atan(p.z,p.x),p.y); //basic fur pattern\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing fur direction for tail\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02))); //ears\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));//changing fur direction for ears\n d2=min(d2,d3);\n float h=fbm(uv*25.0); \n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07))); //feet\n d=(smin(d2,d,8.0)-h*0.2)*0.5; //smooth together and add fur\n return min(d,min(dB,dF)); //return closest object\n}\nvec3 mcol;\nfloat CE(vec3 p){//same for coloring\n vec3 z=p+vec3(0.0,1.2,2.5);\n float dB=Cone(z,vec2(0.75,1.5));\n dB=smin(dB,-length(z+vec3(0.0,-1.215,0.0))+1.08,-64.0);\n float dF=z.y;\n float d=Ellipsoid(p,vec4(1.4,1.4,1.0,1.0));\n vec4 j=seg4(p+vec3(0.0,-0.58,-1.0),vec3(tailwag,0.68,0.0));\n j.z-=sin(j.w*3.1416)*0.1;\n float d2=length(j.xyz);\n vec2 uv=vec2(atan(p.z,p.x),p.y);\n p.x=abs(p.x);\n uv.xy=mix(vec2(uv.x+(p.y-0.32)*tailwag*1.3,p.y+d2*3.3),uv.xy,smoothstep(0.0,0.25,d2));//changing the direction for ears\n float d3=min(d2,RCyl(p+vec3(-0.4,headbob,1.35),vec3(0.15,0.0,0.02)));\n uv.y=mix(p.y+d3*3.3,uv.y,smoothstep(0.0,0.51,d3));\n d2=min(d2,d3);\n float h=fbm(uv*25.0);\n p.z=abs(p.z);\n d2=min(d2,Ellipsoid(p+vec3(-0.45,0.78,-0.63),vec4(2.0,1.0,2.0,0.07)));\n float d1=(smin(d2,d,8.0)-h*0.2)*0.5;\n d=min(d1,min(dB,dF));\n if(abs(d-dB)<0.001)mcol+=vec3(0.9,0.9,0.2);\n else if(abs(d-dF)<0.001){mcol+=vec3(1.0,0.4+noyz(z.xz*vec2(50.0,1.0))*0.4,0.4)*(0.4+0.6*clamp(d1*3.0,0.0,1.0));}\n else mcol+=vec3(0.7,0.5,0.3)*h+vec3(-p.y*0.5);\n return d;\n}\n\nfloat pixelSize;\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n return max(abs(focalDistance-t)*aperature,pixelSize*t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n fw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n pixelSize=1.0/size.y;\n headbob=-0.6+abs(sin(time*9.0)*sin(time*3.5))*0.1;\n tailwag=sin(time*14.0)*0.1;\n vec3 ro=vec3(-1.5,0.15,2.75)+vec3(cos(time),sin(time*0.7)*0.5,sin(time))*0.25;\n vec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n vec3 L=normalize(ro+vec3(0.5,2.5,0.5));\n vec4 col=vec4(0.0);//color accumulator\n float t=0.0;//distance traveled\n for(int i=1;i<48;i++){//march loop\n  if(col.w>0.9 || t>7.0)continue;//bail if we hit a surface or go out of bounds\n  float rCoC=CircleOfConfusion(t);//calc the radius of CoC\n  float d=DE(ro)+0.25*rCoC;\n  if(d<rCoC){//if we are inside add its contribution\n   vec3 p=ro;//-rd*abs(d-rCoC);//back up to border of CoC\n   mcol=vec3(0.0);//clear the color trap, collecting color samples with normal deltas\n   vec2 v=vec2(rCoC*0.5,0.0);//use normal deltas based on CoC radius\n   vec3 N=normalize(vec3(-CE(p-v.xyy)+CE(p+v.xyy),-CE(p-v.yxy)+CE(p+v.yxy),-CE(p-v.yyx)+CE(p+v.yyx)));\n   //if(dot(N,rd)<0.0){//doesn't seem to matter??\n    vec3 scol=mcol*0.1666*(0.7+0.3*dot(N,L));//do some fast light calcs (you can forget about shadow casting, too expensive)\n    scol+=pow(max(0.0,dot(reflect(rd,N),L)),8.0)*vec3(1.0,0.5,0.0);\n    float alpha=fudgeFactor*(1.0-col.w)*linstep(-rCoC,rCoC,-d);//calculate the mix like cloud density\n    col+=vec4(scol*alpha,alpha);//blend in the new color\n   //}\n  }\n  d=abs(fudgeFactor*d*(0.7+0.2*rand(fragCoord.xy*vec2(i))));//add in noise to reduce banding and create fuzz\n  ro+=d*rd;//march\n  t+=d;\n }//mix in background color\n vec3 scol=mix(vec3(0.025,0.1,0.05)+rd*0.025,vec3(0.1,0.2,0.3)+rd*0.1,smoothstep(-0.1,0.1,rd.y));\n col.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\n fragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}