{
    "Shader": {
        "info": {
            "date": "1508232314",
            "description": "fork of \nhttps://www.shadertoy.com/view/Xt23zG\nimproved compatibility\n\nproof of concept of multisampling tessellations",
            "flags": 0,
            "hasliked": 0,
            "id": "4tjcWR",
            "likes": 6,
            "name": " kerning neighborhood #DF4 b",
            "published": 3,
            "tags": [
                "tesselation",
                "overlapping",
                "halfspace",
                "kerning",
                "kerning"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 935
        },
        "renderpass": [
            {
                "code": "//mod 3d seamless overlapping tile proof of concept tomkh 2017-09\n//self  : https://www.shadertoy.com/view/4tjcWR\n//parent: https://www.shadertoy.com/view/Xt23zG\n// was for tomkh's educational purposes\n// Extended from tomkh's previous attempt: llSGRy\n// tomkh@2015\n\n//there was not much to optimize\n//biggest change was to not use global array of mat3\n//i did not want to touch the camera and all its rotations\n//a lot is overly explicit, not wwong, just harder to edit.\n\n//this one failed at implementing AO\n\n#define doMouseLook\n//rotations in this are overly explicit, therefore camera sucks\n\n#define SCENE 3\n//   0 = centered bboxes\n//   1 = centered decorated bboxes\n//   2 = non-centered bboxes\n//   3 = non-centered decorated\n\n#define OVERLAP_SCENE 2\n//   0 = coins\n//   1 = pipes\n//   2 = tori\n//   To show nothing just comment out OVERLAP.\n\n\n// Enable to debug distance field:\n#define DEBUG_MODE 1\n//   0 = no debug\n//   1 = show DF plane\n//   2 = show all DF slices\n\n\n// Enable to test overlap (must be less than 0.5):\n#define OVERLAP 0.1\n\n#define floor_plane -5.\n\n// Enable experimental AO (bad, broken,shitty)\n//#define TEST_AO\n\n\n#define VIEW_DIST 1\n//   0 = short distance\n//   1 = middle\n//   2 = far\n\n#if VIEW_DIST == 0\n\tconst int ray_steps = 160;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 20.0;\n\tconst float cam_tilt = -.2;\n#elif VIEW_DIST == 1\n\tconst int ray_steps = 80;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 30.0;\n\tconst float cam_tilt = -.4;\n#else\n\tconst int ray_steps = 80;\n\tconst float dist_max = 200.0;\n\tconst float fog_start = 100.0;\n\tconst float fog_density = 0.02;\n\tconst float cam_dist = 80.0;\n\tconst float cam_tilt = -.4;\n#endif\n\n\n// Tile space:\n#define tSpace 2.\n\n//mat3 tori_rot[2];\n\n// P-----+-----Q\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// R-----+-----S\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A,B,C,D are our tile centers.\n// We have to assume max/min height.\n// We call \"frame\", a bounding area of everything outside PQRS (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles: A,B,C,D\n//   (possibly with early-out optimization with rough distance estimation)\n//   and we bound it additionally to distance to PQRS frame.\n//\n//comment by ollj, above is neat, has its uses\n//, is likely smarter if you want to mix 2 adjacent tiles\n//, but i know a better way;\n//a 2d quater tile is (within) 4 larger offset tiles, all seamless.\n// just 4x sample 4 exclusive tesselations with offset.\n//, whos cotners are onm the lines or centers of other tesselations.\n//gives a cleaner gradient.\n\nfloat dist2frame(vec3 p, float b)\n#ifdef OVERLAP\n{p=vec3(tSpace*(1.-OVERLAP)-abs(p.xz),max(0.,abs(p.y)-b));\n#else\n{p=vec3(tSpace-abs(p.xz),max(0.,abs(p.y)-b));\n#endif\n return length(vec2(min(p.x,p.y),p.z));\n}\n\n//lib.shapes\nfloat dBox2(vec3 p,vec3 b)//rounded box\n{return length(vec3(max(vec3(0),abs(p)-b)));}\n\nfloat dPipe(vec3 p,float r,float h)\n{r=length(p.xz)-r\n;h=max(.0,abs(p.y)-h)\n;return length(vec2(r,h));}\n\nfloat dCyl(vec3 p, float r, float h)\n{r=max(.0,length(p.xz)-r)\n;h=max(.0,abs(p.y)-h)\n;return length(vec2(r,h));}\n \n vec3 sc3(float a){return vec3(cos(a),0,sin(a));}  \n//evaluate tile contnent\nfloat gt(vec3 p, vec3 q,vec2 d,mat3 tr0,mat3 tr1)\n{q.xz+=d\n;p.xz-=(d-.5)*tSpace\n;float a,t=iTime*.25,s=sin(q.x+t)*sin(q.z+t*.33);\n#ifdef OVERLAP\n ;float r=tSpace*(.5 + OVERLAP);\n #if OVERLAP_SCENE == 0\n  ;a=dCyl(vec3(p.x,p.y-s*.25,p.z),r-.25,.0)-.25;\n #elif OVERLAP_SCENE == 1\n  ;a=dPipe(vec3(p.x,p.y-s*2.0,p.z),r-.25,1.75)-.25;\n #else\n  ;mat3 m=(mod(q.x*.17 + q.z*.71,2.0)<1.0) ? tr0:tr1;\n  ;a=dPipe(vec3(p.x,p.y-s*3.0,p.z)*m,r-.25,.0)-.25;\n #endif\n#else\n ;a=1e32;\n#endif\n#if SCENE>=2\n  ;s=4.-abs(s)*3.9;\n  ;vec3 u=p+sc3((q.x+q.z)*3.+t*1.11)*.5;\n  ;a=min(a,dBox2(u,vec3(.25,s,.25))-.025);\n #if SCENE==3\n  //;if (dist > .3) return dist - .1; // simple early-out optimziation\n  ;a=min(a,dBox2(u-vec3(0,s*.3,0),vec3(.25,0,.25))-.1)\n  ;a=min(a,dBox2(u-vec3(0,s*.6,0),vec3(.25,0,.25))-.1)\n #endif\n#else\n ;s=4.-abs(s)*3.8;\n ;float u=.2+abs(cos(q.x+t*.5)*cos(q.z+t*.66))*.7;\n ;a=min(a,dBox2(p,vec3(u,s,u))-.025);\n #if SCENE == 1\n  //;if (dist > .2) return dist - .1; // simple early-out optimziation\n  ;a=min(a,dBox2(p,vec3(u+.1,s-.1,  .1))-.025);\n  ;a=min(a,dBox2(p,vec3(  .1,s-.1,u+.1))-.025);\n #endif\n#endif\n;return a;}\n \nfloat gd(vec3 p,mat3 a,mat3 b)\n{vec3 c=vec3(floor(p.xz/tSpace),.0).xzy;//tile address\n;p=vec3((fract(p.xz/tSpace)-.5)*tSpace,p.y).xzy//logal coord\n;float r=dist2frame(p,4.25)\n;r=min(r,gt(p,c,vec2(0  ),a,b));\n;r=min(r,gt(p,c,vec2(1,0),a,b));\n;r=min(r,gt(p,c,vec2(0,1),a,b));\n;r=min(r,gt(p,c,vec2(1  ),a,b));\n;r=min(r,abs(p.y-floor_plane));\n;return r;}\n\nvec3 get_normal(vec3 p,mat3 a,mat3 b){const vec2 e=vec2(1e-3,0)\n;return normalize(vec3(gd(p+e.xyy,a,b)-gd(p-e.xyy,a,b)\n,gd(p+e.yxy,a,b)-gd(p-e.yxy,a,b),gd(p+e.yyx,a,b)-gd(p-e.yyx,a,b)));}\n\n// TODO: implement better AO\nfloat get_ao(vec3 u,vec3 n,mat3 tr0,mat3 tr1){\n#ifdef TEST_AO\n;u+=n*.1;\n;float d=gd(u,tr0,tr1),l=.0\n;d=d*d;l+=d\n;for(int i=0;i<3;i++){u+=n*d;d=gd(u,tr0,tr1);d=d*d;l+=d;}\n;return clamp(0.0,1.0,l*1.5);}\n#else\nreturn 1.;}\n#endif\n\n//this one gor convoluted.\nvec3 trace(vec3 u, vec3 t,mat3 tr0,mat3 tr1){\n#if DEBUG_MODE != 2\n;float l,d;\n;const float e=.001;\n;vec3 p=u\n;for(int k=0; k<ray_steps; ++k\n){d=gd(p,tr0,tr1)\n ;if(d<e||d>d)break\n ;p+=d*t\n ;l+=d\n;}\n //;vec3 s=normalize(vec3(.1,1.0,-.3));\n;float m=(iMouse.x/iResolution.x-.5)+1.\n,cShad=.0,cSpec=.0;\n;vec3 s=normalize(vec3(cos(m),2.,-sin(m)))\n,cDiff=vec3(1)\n,n=get_normal(p,tr0,tr1)\n;if(d<e\n){if(p.y<floor_plane+e*2.\n ){float d=(u.y-floor_plane)/-t.y\n  ;vec3 hit=u+t*d\n  ;float p=mod(floor(hit.x/tSpace)+floor(hit.z/tSpace),2.)//pattern\n  ;cDiff=mix(vec3(.6,.4,.6),vec3(.6,.6,.8),p)\n ;}\n ;cShad=max(0.,dot(n, s))//;cShad=(1.-d/e)*dot(n,s);\n *get_ao(p,n,tr0,tr1)\n ;cSpec=max(0.0,dot(n, m - n*dot(n,s)*2.))\n ;cSpec=pow(cSpec,32.0)*.25\n;}\n;vec3 a=mix(vec3(0,.1,.3),vec3(1,1,.9),cShad)*cDiff+vec3(1)*cSpec;\n// Test ray with cut_plane:\n#if DEBUG_MODE == 1\n;float mm=(iMouse.y/iResolution.y-.1)*8.\n;mm=max(0.,mm)\n;if(t.y*sign(u.y-mm)<.0\n){float d=(u.y-mm)/-t.y\n ;if(d<l\n ){vec3 h=u+t*d\n  ;h.x=gd(h,tr0,tr1)\n  ;vec3 b=mix(vec3(.2,.4,.6),vec3(.2,.2,.4),fract(h.x*5.0));//distant color\n  ;b*=1./(max(.0,h.x)+.001);//;b=min(vec3(1),b);\n  ;a=mix(a,b,.25)\n  ;l=d;}}\n#endif\n;a=mix(vec3(.8),a,1./exp(max(.0,l-fog_start)*fog_density));//fog\n#else\n;vec3 a=vec3(0,.1,.3)\n;for(float i=4.;i>=.0;i-=.1//i used to be called \"cutPlane\"\n){if(t.y*sign(u.y-i)<.0\n ){float d=(u.y-i)/-t.y\n  ,h=gd(u+t*d,tr0,tr1)\n  ;vec3 b=.1*mix(vec3(2,4,6),vec3(2,2,4),fract(h*5.0));//distant color\n  ;b*=1./(max(.0,h)+.05)\n  ;a+=b*.02*i*.25;}}\n#endif\n;return a;}\n\n\n//axisAngleTomat2\nmat3 aatm(float a,vec3 r){float c=cos(a)\n;vec3 t=(1.-c)*r,u=sin(a)*r;return mat3\n(t.x*r.x+c  ,t.x*r.y+u.z,t.x*r.z-u.y\n,t.x*r.y-u.z,t.y*r.y+c  ,t.y*r.z+u.x\n,t.x*r.z+u.y,t.y*r.z-u.x,t.z*r.z+c );}\n\nvoid mainImage( out vec4 o, in vec2 u )\n{u=(u.xy-iResolution.xy*0.5)/iResolution.x\n;float t = iTime*.25\n#ifdef doMouseLook\n;float a=iMouse.x/iResolution.x * 2.-1.\n#else\n;float a=-.2\n#endif\n;a+=cos(t)*.05;\n;float c=cos(a),s=sin(a)\n;vec3 p=vec3(-cam_dist*s,0,-cam_dist*c)\n;vec3 n = normalize(vec3(u,1))\n;n=vec3(n.x*c+n.z*s,n.y,-n.x*s+n.z*c)\n#ifdef doMouseLook\n //;a=iMouse.y/iResolution.y*2.+sin(t*(2./3.))*.2-2.\n#endif\n;a=cam_tilt;\n;c=cos(a);\n;s=sin(a);\n;p=vec3(p.x,p.y*c+p.z*s,-p.y*s+p.z*c);\n;n=vec3(n.x,n.y*c+n.z*s,-n.y*s+n.z*c);\n;mat3 tr0,tr1;\n#if defined(OVERLAP) && OVERLAP_SCENE == 2\n ;tr0=aatm(t   ,normalize(vec3(.5,.2, .3)));\n ;tr1=aatm(t+2.,normalize(vec3(.3,.7,-.2)));\n#endif\n;o=vec4(trace(p,n,tr0,tr1),1);}\n\n\n\n/*\n[halfspace tapping] link collection (v3) (may only be correlated, not even using the method, but SHOULD use the method)\n//\nsawblade serrated disk inversion  \nhttps://www.shadertoy.com/view/4t3fz7\nparent of the above is below\nhttps://www.shadertoy.com/view/XtSczV\n//\nwhich contains links to\ni tried to make this a sawblade\n, and noticed that i would need an insideout rounded box gradient for this: \nhttps://www.shadertoy.com/view/4t3fz7 \n//\nwe need a label for this [overlapping tile/slice] [typesetting] [CircleOfConfusion] \nstuff first time i see it in polar coordinates: \nprevious instances where linear or square lattice (and often only partially overlappin CoC's) \nhttps://www.shadertoy.com/view/4tjcWR\nhttps://www.shadertoy.com/view/MlscWn \n//\nI suggest [halfspace tapping]\n, where CoC implies bokeh, this generalizes it to \"overlapping of dark areas with lit areas\" \nthat may even not overlap completely (or at not overlap at all) :\ntoon clouds (very similar to / MlscWn ):\nhttps://www.shadertoy.com/view/4t23RR\nhttps://www.shadertoy.com/view/MltyR7 \nhttps://www.shadertoy.com/view/ltVcWt\nconcept of a non-monoispaced tree structure (branching a dualGlpyhString into 2 non monospaced sub-glyphs, branchless tree element)\nhttps://www.shadertoy.com/view/ltVcWt\n//\nolder and simpler [halfspace] shaders, closer to \nhttps://www.shadertoy.com/view/Md2cWK\nmodulo-gears:\nhttps://www.shadertoy.com/view/Msl3Rn\npavement:\nhttps://www.shadertoy.com/view/XsKXz3\npolar grid motion does 3-tap, and wopuld be great for half-space overlap:\nhttps://www.shadertoy.com/view/XtcfRH\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}