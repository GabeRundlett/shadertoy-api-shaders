{
    "Shader": {
        "info": {
            "date": "1591227070",
            "description": "in principle the same as https://www.shadertoy.com/view/WsjBDt but distorted in any dimension i could get my psychedelic hands on. readability is destoyed, performance sucks and graphics glitch a lot - i guess my work is done :D",
            "flags": 0,
            "hasliked": 0,
            "id": "WlXcRr",
            "likes": 7,
            "name": "Going Psych On 2nd Try",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "smoothoperators"
            ],
            "usePreview": 0,
            "username": "pnoqable",
            "viewed": 451
        },
        "renderpass": [
            {
                "code": "// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.001;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_ellipsoid( vec3 pos, vec3 r ) {\n    float k0 = length( pos / r );\n    float k1 = length( pos / ( r * r ) );\n    return k0 * ( k0 - 1.0 ) / k1;\n}\n\nfloat dist_cylinder( vec3 pos, float h, float r ) {\n    vec2 d = abs( vec2( length( pos.xy ), pos.z ) ) - vec2( r, h );\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat dist_torus( vec3 pos, vec2 t ) {\n    vec2 q = vec2( length( pos.xy ) - t.x, pos.z );\n    return length( q ) - t.y;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k * h * ( 1.0 - h );\n}\n\nfloat smoothSubtract( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 + d1 ) / k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) +  k * h * ( 1.0 - h );\n}\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5 * ( d2 - d1 ) / k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k * h * ( 1.0 - h );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n    \n    {\n        float arc = atan( pos.y, pos.x );\n        float len = length( pos.xy );\n        arc += 0.1 * len / ( 5. - pos.z ) * sin( 0.3 * iTime + 0.001 * pos.z );\n        arc -= 0.01 * floor( ( pos.z + 2. ) / ( 8. + 2. * cos( 0.1 * iTime ) ) );\n        pos.x = len * cos( arc );\n        pos.y = len * sin( arc );\n    }\n    \n    vec2 tile = vec2( 7., 8. ) + vec2( 0.02, 0.1 ) * pos.xy * vec2( sin( 0.2 * iTime ), cos( 0.2 * iTime ) );\n    \n    float edge = 0.5 - 0.499 * cos( dot( pos, vec3( 0.02, 0.01, -0.03 ) ) + 0.7 * iTime );\n\t\n    if( pos.z <= 0.1 ) {\n        pos.x += floor( pos.z / 10. + 0.2 ) * 0.5 * sin( iTime );\n        pos.z = mod( pos.z + 2., 8. + 2. * cos( 0.1 * iTime ) ) - 2.;\n    }\n    \n    pos.xy = mod( pos.xy + 0.5 * tile, tile ) - 0.5 * tile;\n    \n\tfloat sphere = dist_sphere( pos, 1. );\n    float ellipsoid = dist_ellipsoid( pos, vec3( .6, .6, 1.1 ) );\n    float cylinder = dist_cylinder( pos, 0.0, 2.2 ) - 0.1 * edge;\n    float torus = dist_torus( pos, vec2( 1.6, 0.3 ) );\n    \n    float result = sphere;\n    result = smoothUnion( cylinder, result, edge );\n    result = smoothSubtract( ellipsoid, result, edge );\n    result = smoothUnion( torus, result, edge );\n\n    return result;\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 3.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.6, 0.5, 0.6 + 0.1 * cos( 2. * iTime + 0.01 * v.z ) );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -10.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.1, 0.1, 0.1 - 0.1 * sin( iTime + 0.1 * v.y - 0.07 * v.x ) );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\t\n\t// light 2\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, -20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.1 + 0.1 * sin( iTime + .7 * v.x - 0.3 * v.y ), 0.0, 0.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n        \n        final += light_color * ( diffuse + specular );\n\t}\n\n\treturn 2. * final * final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( 0., 0., 0., 1. );\n    \n    int antiAlias = 1;\n    \n    for( int offX = 0; offX < antiAlias; offX++ )\n    for( int offY = 0; offY < antiAlias; offY++ )\n    {\n        vec2 offset = vec2( float( offX ), float( offY ) ) / vec2( antiAlias ) - 0.5;\n        \n        // default ray dir\n        vec3 dir = ray_dir( 90. + 50. * cos( 0.2 * iTime ), iResolution.xy, fragCoord.xy + offset );\n\n        // default ray origin\n        vec3 eye = vec3( 0.0, 0.0, 3.3 + 3.2 * sin( 0.1 * iTime ) );\n\n        // rotate camera\n        mat3 rot = rotationXY( 0.11 * vec2( cos( -0.1 * iTime ), sin( 0.2 * iTime ) ) );\n        dir = rot * dir;\n        eye = rot * eye;\n\n        // ray marching\n        float depth = ray_marching( eye, dir, 0.0, clip_far );\n        \n        // shading\n        if ( depth < clip_far ) {\n            vec3 pos = eye + dir * depth;\n            vec3 n = gradient( pos );\n            fragColor.xyz += shading( pos, n, eye );\n        }\n    }\n    fragColor.xyz /= float( antiAlias * antiAlias );\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}