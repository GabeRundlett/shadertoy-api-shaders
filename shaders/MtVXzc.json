{
    "Shader": {
        "info": {
            "date": "1485349362",
            "description": "A simple ray marcher with phong ligting.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtVXzc",
            "likes": 1,
            "name": "Basic Raymarcher",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "hexointed",
            "viewed": 709
        },
        "renderpass": [
            {
                "code": "float epsilon = 0.001;\n\nfloat scene(vec3, inout int);\nbool march (out vec3, in vec3, in vec3, inout int);\nvec3 calc_gradient(in vec3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPosition = vec3(0.0, 0.0, -3.0);\n    vec3 cameraFocalPoint = cameraPosition - vec3(0.0, 0.0, 1.0);\n    cameraPosition.xy += (fragCoord.xy - iResolution.xy/2.0) / iResolution.xx;\n\n    vec3 hitPosition;\n    int id = 1;\n    \n    bool hit = march(hitPosition, cameraPosition, cameraPosition - cameraFocalPoint, id);\n    \n    if(id == 0)\n    \tfragColor = vec4 (1.0, 1.0, 1.0, 1.0);\n    if(id == 1)\n        fragColor = vec4 (1.0, 0.0, 0.0, 1.0);\n    \n    if(!hit) {\n        fragColor*=0.0;\n        return;\n    }\n    \n    vec3 normal = normalize(calc_gradient(hitPosition));\n    vec3 light = vec3(2.0 * sin(iTime), 2.0 * cos(iTime), 0.0);\n    vec3 lm = normalize(light - hitPosition);\n    vec3 rm = normalize(2.0 * dot(lm, normal) * normal - lm);\n    vec3 v = normalize(cameraPosition - hitPosition);\n    \n    fragColor.xyz *= vec3(0.2, 0.2, 0.2) +\n        0.3 * dot(lm, normal) +\n        0.4 * pow(clamp(dot(rm, v),0.0,1.0), 4.0);\n}\n\nvec3 calc_gradient(vec3 p) {\n    vec3 delta = vec3(epsilon, 0.0, 0.0);\n    int id;\n \treturn normalize(vec3 (\n        (scene(p + delta.xyz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.yxz,id) - scene(p,id))/ epsilon, \n        (scene(p + delta.zyx,id) - scene(p,id))/ epsilon\n   \t));\n    \n}\n\nbool march(out vec3 endPosition, in vec3 startPosition, in vec3 direction, inout int id) {\n    \n    vec3 mdir = normalize(direction);\n    endPosition = startPosition;\n    \n    for(int i = 0; i < 400; i++) {\n        float distance = scene(endPosition,id);\n        \n        if(distance < epsilon)\n            return true;\n        \n        if(distance > 1000.0)\n            return false;\n        \n        endPosition += distance * mdir;\n    }\n    \n    return false;\n    \n}\n\nfloat scene (vec3 p, inout int id) {\n\tfloat s1 = sqrt(p.x*p.x + p.y*p.y + (p.z - 2.0)*(p.z - 2.0)) - 0.5;\n    float s2 = length(p - vec3(2.0 * sin(-iTime), cos(iTime), 0.0)) - 0.2;\n    \n    if(s1 < s2) id = 0;\n    else id = 1;\n    \n    return min(s1,s2);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}