{
    "Shader": {
        "info": {
            "date": "1610191318",
            "description": "strave= ESDF             +TG (=up down)   \nrotate= arrows/mouse +WR(roll)\nplaceLight = P+L\n\nvolumetricScattering & TemporalReprojection of\nhttps://www.shadertoy.com/view/wttyDX\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs",
            "flags": 48,
            "hasliked": 0,
            "id": "wl3yDs",
            "likes": 8,
            "name": "Reproject Volumetric quaternion",
            "published": 3,
            "tags": [
                "fractal",
                "cloud",
                "globalillumination",
                "volumetric",
                "pathtracing",
                "importance",
                "pcg",
                "quaternioncamera",
                "crepustularity",
                "warpspeed",
                "reproject"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "//Volumetric fractal explorer \n\n//Features:\n//Multiple light sources(importance sampled)\n//Anisotripic scattering\n//Multibounce scattering\n//Approximate volumetric reprojection for temporal denoising\nvoid mainImage(out vec4 c,vec2 p\n){c=texture(iChannel0,p/iR.xy)\n ;c=1.07*tanh(pow(c/c.w,vec4(.6)))//this gamma correction is important\n ;}\n \n//MIT License\n//Copyright 2020 Mykhailo Moroz\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:\n//The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//assume as \"Do whatever you want\" License",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//2 volumetric lights with temporal reprojection (scatters in air+clouds)\n//press P or L to place a light at camera position (then fly away from it)\n\n//#define LOW_QUALITY\n\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 16\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 8\n    //potato mode\n    //#define TRACE_STEPS 3\n    #define MAX_DIST 10.0\n#else\n    #define MAX_STEPS 40\n    #define SCALING 0.1\n    #define DITHER 0.5\n    #define TRACE_STEPS 50\n    #define MAX_DIST 100.0\n#endif\n\nconst float FOV=1.\n,LUMINOUSITY     =80.\n,ABSORPSION      =sat(.999)\n,TAA             =sat(.97)//temporal Antialiasing factor (multiplies by the 2 below)\n,TAAMA           =sat(.85)//reprojection ammount\n,TAAMS           =sat(.01)//reprojection smoothness\n,ANISOTROPY      =.3//temporal Anisotropy denoise\n,AMBIENT_FOG     =max(0.001,abs(0.1))//0.001 improves performace\n;\n\nfloat density(//must not be <2. for the mandelbulb\n){return  mix(200.,3.,cos(iTime*.3)*.5+.5)\n ;return  16.;}\n\nfloat min_step(){return 1.25/density();}\n\n//cloud sharpness\n#define sharpness .0001\n\n//light positions\nvec3 lpos1,lpos2;\n\n//subroutine for bicubic texture\n//from https://www.shadertoy.com/view/XsSXDy\nvec4 powers(float x){return vec4(x*x*x,x*x,x,1.0);}\nconst vec4 ca=vec4( 3,-5, 0,2)/2.;\nconst vec4 cb=vec4(-1, 5,-8,4)/2.;\nvec4 spline(float x,vec4 a,vec4 b,vec4 c,vec4 d\n){return a*dot(cb,powers(1.+x))\n        +b*dot(ca,powers(   x))\n        +c*dot(ca,powers(1.-x))\n        +d*dot(cb,powers(2.-x));}\n//We could expand the powers and build a matrix instead (twice as many coefficients\n//would need to be stored,but it could be faster.\n\n#define SAM(a,b) texture(tex,(i+vec2(float(a),float(b))+.5)/r,-99.)\nvec4 textureBicubic(sampler2D tex,vec2 t\n){//return texture(tex,t)//skip override\n ;vec2 r=vec2(textureSize(tex,0))\n ;vec2 p=r*t-.5\n ;vec2 f=fract(p)\n ;vec2 i=floor(p)\n ;return spline(f.y,spline(f.x,SAM(-1,-1),SAM(0,-1),SAM(1,-1),SAM(2,-1))\n                   ,spline(f.x,SAM(-1,0),SAM(0,0),SAM(1,0),SAM(2,0))\n                   ,spline(f.x,SAM(-1,1),SAM(0,1),SAM(1,1),SAM(2,1))\n                   ,spline(f.x,SAM(-1,2),SAM(0,2),SAM(1,2),SAM(2,2)));}\n\n//blue noise\nvec4 rand4blue(){return texelFetch(iChannel1,shift2(),0);}\n\nvec4 mandelbulb_fog(vec3 p,float K\n){vec4 d=dfo(p)\n ;return vec4(density()*ma0(1.-d.yzw)*smoothstep(K,0.,d.x),d.x);}\n\nvec4 box_fog(vec3 p,vec3 b,float k\n){vec3 refl=normalize(vec3(0.4,0.6,0.9))\n ;float sc=1.0\n ;for(int i=0;i < 6;i++\n ){refl.xy=rot(1.6)*refl.xy\n  ;p-=2.*max(dot(refl,p),0.)*refl\n  ;refl.yz=rot(2.1)*refl.yz\n  ;p+=0.015*sin(10.*dot(refl,p)+sin(p.x*p.y));}\n ;float sdf=sdBox(p,b)/sc\n ;return vec4(density()*(vec3(.3,.6,.9)*+(.5+.5*sin(40.*vec3(.392,.580,1.000)*p.x)))*smoothstep(k,-k,sdf),sdf);}\n\nvec4 fogDens(vec3 p\n){vec4 box=mandelbulb_fog(p,sharpness)//box_fog(p,vec3(0.7,0.3,0.2),sharpness);\n ;float shells=min(MAX_DIST+0.6-length(p),min(distance(p,lpos1),distance(p,lpos2))) //light source and background\n ;return vec4(box.xyz+vec3(0.141,0.439,1.000)*AMBIENT_FOG,min(box.w,shells));}\n\nvec4 choose_light(vec3 p,float r\n){float t1=distance(lpos1,p)\n ;float t2=distance(lpos2,p)\n ;float prob=t1/(t1+t2)\n ;return (r>prob)?vec4(lpos1,prob):vec4(lpos2,1.-prob);}\n\n//trace a multibounce light path to the lights\nvec3 trace(vec3 ro,vec3 id,float dither\n){//acc opacity\n ;vec3 k=vec3(1)\n ;float step_size\n ;float td =0.\n ;float pdf=1.\n ;vec2 r=rand2()\n ;vec4 l=choose_light(ro,r.x)    //sample light importance \n ;pdf*=l.w\n ;vec3 rd=id\n ;float dist=MAX_DIST\n ;int ss=(r.y < 0.5)?(TRACE_STEPS/3):0//scatter samples \n ;int i=0\n ;for(;i < TRACE_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*dither)*max(rho.w,max(max(min_step(),SCALING*td),5e-5*length(rho)))\n  ;vec3 absorption=exp(-step_size*rho.xyz*ABSORPSION)\n  ;k *=absorption//acc\n  ;rd=(i < ss)?normalize(mix(rd,udir(),1.-exp(-step_size*length(rho.xyz)*(1.-ANISOTROPY)))):rd//scatter\n  ;if(i ==ss//shoot shadow ray\n  ){vec3 prd=rd\n   ;dist=distance(l.xyz,ro)+2e-2\n   ;rd=(l.xyz-ro)/dist\n   ;pdf*=4.*pi*dist*dist //light distance pdf\n   ;pdf/=HenyeyGreenstein(ANISOTROPY,dot(prd,rd));}\n  ;if(length(k) < 0.07 || distance(ro,vec3(0))>2.0 || td>dist) break\n  ;ro+=rd*step_size\n  ;td+=step_size;}\n  ;return float(i>=ss)*LUMINOUSITY*k*smoothstep(.068,.07,length(k))/pdf;}\n\n//return previous screenspace address to be returned\n//use previous camera matrix and camera position to reproject a point onto previos frame\nvec2 reproject(vec3 p){\n #if (camType==0) \n ;mat3 cam=getCam(get(camA0p).xy)//camA0p stores jaw and roll\n #else \n ;mat3 cam=q2m(get(camA0p))//stores quaternion\n #endif\n ;vec3 s=inverse(cam)*normalize(p)\n ;return vec2(s.yz*iR.y/(FOV*s.x)+.5*iR.xy);}\n\n#define FieldOfView 2.5\nv22 getRay(vec2 u//uU is not normalized\n){u=(u-iR.xy*.5)/iR.y\n ;mat4 ct=q2m(get(camA0),get(camP0).xyz)\n ;mat3 m=m42Rot(ct)\n ;vec3 rd=normalize(m*vec3(0,0,1)   //up\n                   +(m*vec3(1,0,0)*u.x//right+forward...\n                   +m*vec3(0,1,0)*u.y)*pi/FieldOfView)\n ;return v22(ct[3].xyz,rd);}\n\nvoid mainImage( out vec4 c,in vec2 p\n){rng_initialize(p,iFrame)\n #if (camType==0)  \n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;mat3 cam=getCam(get(camA0).xy)\n ;vec3 campos=get(camP0).xyz\n ;vec3 ro=campos\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n #else\n ;vec3 campos=get(camP0).xyz\n ;vec3 ro=campos\n  /*\n ;mat3 cam=getCam(iChannel3)\n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n ;rd=vq2v(rd,get(camA0))//bad slow fix, rotate ray by quaternion\n ;rd=normalize(rd)\n ;//abofe is different from below (above fails to reproject properly)\n */\n ;vec4 q=get(camA0)\n ;mat3 cam=q2m(q)\n ;vec2 uv=(p-0.5*iResolution.xy)/iResolution.y\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))\n #endif\n ;lpos1=get(li0P0).xyz\n ;lpos2=get(li1P0).xyz\n ;vec4 brand=rand4blue()\n ;float dither=brand.x\n ;vec3 k=vec3(1)//acc opacity\n ;vec3 col=vec3(0)//acc light to camera\n ;int L=0    //main camera ray\n ;float step_size\n ;float td=0.\n ;vec4 maxl_p=vec4(0)\n ;int i=0\n ;for(;i<MAX_STEPS;i++\n ){vec4 rho=fogDens(ro)\n  ;step_size=(1.0-DITHER*dither)*max(rho.w,max(max(min_step(),SCALING*td),2e-5*length(rho)))\n  ;vec3 absorption=exp(-ABSORPSION*step_size*rho.xyz)\n  ;vec2 ldis=vec2(distance(lpos1,ro),distance(lpos2,ro))\n  ;vec3 scattering=k.xyz*(1.-absorption.xyz)\n  ;col+=vec3(LUMINOUSITY/10.)*k.xyz*(step(ldis.x,LIGHT_RADIUS)+step(ldis.y,LIGHT_RADIUS))\n  ;if(((rho.z>1.0)||rho.z>.005 && i%4 ==0)\n  ){vec3 incoming=trace(ro,rd,brand.z)\n   ;float pdf=(rho.z>0.005 && rho.z<1.)?0.25:1.\n   ;col+=scattering*incoming/pdf;}\n  ;k*=absorption//acc\n  ;td+=step_size\n  ;ro+=step_size*rd\n  ;float ls=length(scattering)\n  ;maxl_p=(ls>maxl_p.w)?vec4(ro,ls):maxl_p\n  ;if(length(k) < 0.2 || distance(ro,vec3(0))>MAX_DIST) break;}\n ;if(i >=MAX_STEPS && length(k)>1.05) maxl_p.xyz=ro\n ;//col=vec3(distance(maxl_p.xyz,campos)/3.)//monochrome distance overwrite\n ;vec3 prev=get(camP0p).xyz\n ;//pcam_pos.xyz=vq2v(pcam_pos.xyz,get(camA0)) //testing this\n ;//maxl_p.xyz=vq2v(maxl_p.xyz,get(camA0)) //testing this\n ;vec2 r=reproject(prev-maxl_p.xyz)/iR.xy\n ;c=vec4(col,1)+textureBicubic(iChannel0,r)\n               *TAA*mix(1.,TAAMA,smoothstep(0.,TAAMS,length(prev-campos)))//accumulation movement\n               *mu(step(abs(r-vec2(.5)),vec2(.5)))//accumulation outside prev frame\n \n ;if(iFrame < 2) c=vec4(col,1);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Camera Controller (quaternion 2023-04) //only more comments where added\n//a normalize(quaternion) was replaced by qn(quaternion), skipping 1 sqrt()\n//this sqrt() of normalize() can be skipped IFF the lengtht-of-the-vector is close to 1.\n//stores position,movement,angle,angularVelocity of a camera.\n//also contains the non-quaternion camera controller (toggle is in commontab)\n\n//stores the 2 positions of 2 re-sapwnable point-lights (P+L keys)\n//DUPLICATE stores previous-frame-camera-position for Temporal Reprojection\n//DUPLICATE previous-frame-camera-angle           for Temporal Reprojection\n//the above 2 are a lazy+inefficient merge in favor of compatibility\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular\n\n//constant code (read keys and read buffered pixels)\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\n\n//drag used by 2 different fragments (diminishing speeds)\n//the noRoll-camera-buffer does not differentiate between angular-drag and linear-drag\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n#if (camType==0) \nvec4 cp0( //set camera position\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0(//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz\n ;if(PHYSICS_RADIUS>-99.){\n  ;float d=PHYSICS_RADIUS-df(r.xyz)\n  ;if (d>0.)r.xyz+=normal(r)*d //optional collision\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(//set camera movement direction (first derivative of camera position over time)\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else\nvec4 cp1(//returns camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //set camera angle\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else\nvec4 ca0(//return camera angle (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n ;return qn(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n#endif\n\n#if (camType==0) \nvec4 ca1(//return camera angular velocity (first derivative of camera rotation over time)\n//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//the reprojection shader /wl3yDs also lets you change the position of 2 point-lights\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n\n\n//it is important to only calculate things, that are needed for the buffering pixel.\n//the top-level-functions below focus on what point needs to be calculated.\n//this also minimizes for what pixels need to be READ, which is the SLOWEST-function.\nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}//position + movement\n ;         if(u==camP1)return cp1();return ca1();}//rotation + angularVelocity\n\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous CAMERA position for Temporal Reprojection\n ;if(u==camA0p)return get(camA0)//memorize previous CAMERA angle    for Temporal Reprojection\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))//position of point-light-A\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))//position of point-light-B\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//--- Start of Camera Controller (quaternion 2023-04) \n//only more comments where added and 1 normalize() replaced by qn()\n\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam] in terms of\n//- noRoll is NOT a quaternion camera, and could gimbal-lock, IF it could roll.\n//- does not allow for roll (and thus it never gimbal)-locks\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//- angular drag and linear drag use the same subroutine, but 2 different scaling-factors\n//- - but [noRoll] is faster and simpler to use, (for sets, where you walk on flat-ground)\n\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera rotation of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;\n//camera starting position\nconst vec4 posStart=vec4(-1.5,1.5,0,1);\n\n#if (camType==0) \n #define CAMERA_SPEED .05\n //todo, make linear+angular drag of the quaternuion-camera scaleable here\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n const float\n  //set PHYSICS_RADIUS to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=-100.\n ,LIN_ACCE=.5//linear accelleration\n ,ANG_ACCE=2.//angular accelleration\n ,LIN_DRAG=1.//linear drag\n ,ANG_DRAG=2.//angular drag\n;\n#endif\n//#endif\n\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n\n//-- end of Start of Camera Controller (quaternion 2022-02)\n\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n//subroutines of   https://www.shadertoy.com/view/XlVyDK\n#define le(a) sqrt(dd(a))\n#define co(a) cos(a)\n#define si(a) sin(a)\n//real and imaginary parts for polar z\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),le(a));}\nvec2 p2c(vec2 a){return vec2(co(a.x),si(a.x))*a.y;}\nfloat real(vec2 z){return p2c(z).x;return z.s*co(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*si(z.t);}\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\n\nvec3 repeat(vec3 u){//return u;\n ;vec3 v=pmod(u,vec3(2.8));return u\n ;}\n\n//- distance Field\n\n//mandelbulb fractal\nvec3 pq(vec2 a){return vec3(a.x*a.x,a.x*a.y,a.y*a.y);}\nfloat pow7(float a){float b=a*a;float c=b*b;return a*b*c;}\n//mandelbulb.core \n//o.x=distance, o.yzw are for orbittrap memory\n//w.xyz=uv    ,w.w=dd(uv)\nvoid mandelCore(inout vec4 o,inout vec4 w,vec3 u\n){o.x=8.*sqrt(pow7(w.w))*o.x+1.\n ;vec3 w2=w.xyz*w.xyz,w4=w2*w2\n ,e=vec3(ad(w2.xz)\n        ,ad(w4)-6.*dot(w2.zx,w2.yy)+2.*mu(w2.xy)\n        ,su(w2.zxy))\n ;w.xyz=u+vec3( 64.*mu(w.xyz)*su(w2.xz)*ad(pq(w2.xz)*vec3(1,-6,1))\n              ,-16.*w2.y*mu(e.xzz)+e.y*e.y\n              ,-8.*w.y*(dd(w4.xz)+mu(w2.xz)*(-28.*w4.x+70.*mu(w2.xz)-28.*w4.z)))\n              *(vec3(0,1,0)+vec3(1,0,1)*e.z*e.y*inversesqrt(pow7(e.x)))\n ;w.w=dd(w.xyz);}\nvec4 mandelBulbO(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;o.x=0.25*log(w.w)*sqrt(w.w)/o.x;return o;}\nfloat mandelBulb(vec3 u//return distance.x,orbittrap.yzw\n){vec4 w=vec4(u,dd(u)),o=vec4(1)\n ;for(int i=0;i<5;i++\n ){if(w.w>1.2)break\n  ;mandelCore(o,w,u)\n  ;o.yzw=min(abs(w.xyz)*1.2,o.yzw);}\n ;return 0.25*log(w.w)*sqrt(w.w)/o.x;}\n//the only difference is return type, dfo returns more debug params.\nfloat df (vec3 u){u=repeat(u);return mandelBulb (u);}\nvec4  dfo(vec3 u){u=repeat(u);return mandelBulbO(u);}\n\nvec3 normal(in vec3 p //4-tap derivative3D (laziest approach)\n){vec2 e=vec2(-1,1)*.001\n ;return normalize(e.yxx*df(p+e.yxx)+e.xxy*df(p+e.xxy)\n                  +e.xyx*df(p+e.xyx)+e.yyy*df(p+e.yyy));}\n\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix accumulating rounding errors.\n//return normalize(q) or the FAST approximation qn() are unnecessary, as long as lenght(q) is close to 1.\n//how often you do this is up to you.\n//\n//assuming length(q) is already close to 1, for normalize(q) we can skip the sqrt() within normalize(x)=x/sqrt(dot(x,x)) to qnorm(x)=x/dot(x,x)\n//for quaternion-normalization x=x/dot(x,x) is estimated well enough by (.5*(3.-dot(x,x))*x), even skipping the division\n//and quite often a rounding-error does not occur, and the vector is lenght(x)==1, where we only need a dot(x,x)\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n// quaternion & vectors\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//alternatively, a more-subroutine-using-approach is  \n//q2q(q2q(aa2q()))) as in  https://www.shadertoy.com/view/DdXXzN\n//or you convert all to matrices and multiply matrixes.\n//\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//above takes 3 params, below only takes 2 params (roll==0 ?)\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-this type of conversion function \n //...ports poorly between any 2 shaders due to handedness-of-coordinate systems\n //... and due to (local) POLAR scalars+offsets\n //... and due to order-of-yaw-pitch-roll (non commutativity of rotations in 3d)\n\n\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n//---end__ quaternion\n\n\n\n\n//damn, this is a fisheye cam that is just as complex.\n//in short i fail\n\n//getRayDir() lookAtCamera is 3* normalize(cross()), it seems to be a lazy and slow camera.\n//quatrernion alternatives exist:\n//https://www.shadertoy.com/view/wl3yDs\n//commontab has quaternion functions:\nvec3 getCam(vec3 ro, vec3 lookAt, vec2 uv\n){/*\n ;vec3 f = normalize(lookAt - ro)\n ,r = normalize(cross(vec3(0, 1, 0), f))\n ;return normalize(f + r * uv.x + cross(f, r) * uv.y);/**/\n ;\n ;vec4 quatUv=eYPR2q(vec3(uv,0.).zxy)//fragCoord.xy/iResolution*2.-1.) //uv.y not scaled by AspectRatio?\n ;lookAt=normalize(lookAt-ro)\n ;vec3 rayDirection=qv2v(quatUv,lookAt)*vec3(1,-1,1)\n ;return rayDirection;}\n /**/\n\nmat3 getCam(vec2 a// phi.x,theta.y\n){vec3 x_dir=vec3(cos(a.x)*sin(a.y),sin(a.x)*sin(a.y),cos(a.y))\n ;vec3 y_dir=normalize(cross(x_dir,vec3(0,0,1)))\n ;vec3 z_dir=normalize(cross(x_dir,y_dir))\n ;return mat3(x_dir,y_dir,z_dir);}\n\nmat3 getCam(sampler2D s//buffer is a quaternion\n){return q2m(get2(camA0,s));}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}