{
    "Shader": {
        "info": {
            "date": "1507575514",
            "description": "mouse does things\n\nfork of \nhttps://www.shadertoy.com/view/XsfGR7\n\nnot as amazing but useful in its simplicity. see inscatter()",
            "flags": 0,
            "hasliked": 0,
            "id": "XlSyRD",
            "likes": 3,
            "name": "omni-directional v-scat",
            "published": 3,
            "tags": [
                "light",
                "volumetric",
                "fog",
                "godrays",
                "simplex",
                "scattering",
                "crepuscularity"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 884
        },
        "renderpass": [
            {
                "code": "//self  : https://www.shadertoy.com/view/XlSyRD\n//parent: https://www.shadertoy.com/view/XsfGR7\n/* \n\nreference:\nhttps://www.shadertoy.com/view/Mdl3Rr\n*/\n\n#define LIGHT_ANIMATION\n//#define LOW_QUALITY\t\t// uncomment this if this shader runs too slow on your PC\n//#define ULTRA_QUALITY \t// uncomment this if you have a really fast GPU :-)\n#define SMOKE\t\t\t\t// comment this if you think the smoke effect is too annoying\n\n#define gAnimTime iTime*.5\n\nfloat h11(float n){return fract(sin(n)*43758.5453);}\nfloat simplex(in vec3 x){\n;vec3 p=floor(x),f=fract(x)\n;f=f*f*(3.-2.*f)\n;float n=p.x+p.y*57.+113.*p.z\n;return mix(mix(mix(h11(n),h11(n+1.),f.x),\n                mix(h11(n+ 57.), h11(n+ 58.),f.x),f.y),\n            mix(mix(h11(n+113.), h11(n+114.),f.x),\n                mix(h11(n+170.), h11(n+171.),f.x),f.y),f.z);}\n\nfloat udRoundBox(vec3 p,vec3 b){return length(max(abs(p)-b,.0));}\n// n or p must be normalized\nfloat sdPlane(vec3 p,vec4 n){return dot(p,n.xyz)+n.w;}\n\nfloat scene( in vec3 p){\n;vec4 plane=vec4(0,1,0,0); \n;vec4 boxd1=vec4(.5, 4.,.5,.25); \n;vec4 boxp1=vec4(0,4.,0,0);\n;boxd1.xyz -= boxd1.w;\t\n;vec4 boxd2=vec4(3,.5,.5,.25 );\n;vec4 boxp2=vec4(0,4.,0,0 );\n;boxd2.xyz -= boxd2.w\t\n;float d=99999.\n;d=min(d,udRoundBox(p-boxp1.xyz,boxd1.xyz)-boxd1.w)\n;d=min(d,udRoundBox(p-boxp2.xyz,boxd2.xyz)-boxd2.w)\n;d=min(d,sdPlane(p,plane))\n;return d;}\n\nvec3 sceneNormal(vec3 p){vec2 e= vec2(.001,0)\n;return normalize(vec3(scene(p+e.xyy)-scene(p-e.xyy )\n,scene(p+e.yxy)-scene(p-e.yxy),scene(p+e.yyx)-scene(p-e.yyx )));}\n\n#define iterRm 16.\n\n//RayOrigin,Rayditection,iterations,HirPosition,normal\nvec3 raymarch(vec3 u,vec3 t, float j,out vec3 h, out vec3 n){\n;const float e=.0001;h=u\n;for (float i=.0;i<j;i++){float d=scene(u)\n ;if (d<e){h=u;return sceneNormal(u);}u+=d*t;}return n;}\n\n#ifdef LOW_QUALITY\n #define  INSCATTER_STEPS 24.\n#else\n #ifdef ULTRA_QUALITY\n  #define INSCATTER_STEPS 64.\n #else\n  #define INSCATTER_STEPS 48.\n #endif\n#endif\n\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,.0,1.)\n\n/*\nfloat raySphereIntersect( in vec3 u, in vec3 t, in vec4 sph )\n{u=u-sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera\n;float b=2.*dot(u,t),c=dd(u)-sph.w*sph.w,h=b*b-4.*c\n;return mix(-1e4,-b-sqrt(h)*.5,sign(h));}\n*/\n\n//this is the core function for crepusularity rays\n//and it does 24 df iterations without a break condition\n//[u]=cameraPosition\n//[t]=CameraRayDirection\n//[l]=LichtPosition.xyz LicgtIntensity.z (10 is fine)\n//[s]=noise feed, scales noise, vec3(fragCoord.xy,iTime) is fine\n//[d]=screentracedepth; scale factor, (12. is fine)\nvec3 inscatter(vec3 u,vec3 t, in vec4 l, in vec3 s, in float d ){\n;vec3 tt = normalize( t );\n//below line seems absurd or sub par efficient, is removed:\n//;if(raySphereIntersect(u,tt,light)< -9999.)return vec3(.0);\n;float a=.0,iss =1./INSCATTER_STEPS;vec3 h,n=vec3(0),p=u,dp=tt*iss*d\n;p+=dp*simplex(s)*1.5;for(float i=0.;i<INSCATTER_STEPS;++i){\n ;p+=dp;vec3 t=l.xyz-p;float lt=length(t),b=.0;t/=8.\n ;if(raymarch(u,t,16.,h,n)==vec3(0)){\n  ;float falloff=1.-pow(sat(lt/l.w),.125);b+=falloff;\t\n  #ifdef SMOKE\n  ;b+=falloff*simplex(1.25*(p+vec3(gAnimTime,0,0)))*0.375\n  #endif\n;}a+=b;}return vec3(a*iss*8.);}\n\n//u,t are ray from lightsource to surface, a,b are minmax,k is softneess\nfloat softshadow(vec3 u,vec3 t,float a,float b,float k){\n;float d=a;a=1.0;for(int i=0;i<128;++i ){\n ;float h=scene(u+t*t);if(h<.001 )return 0.\n ;a=min(a,k*h/d);t+=h;if(d>b)break;}return a;}\n\nvoid mainImage(out vec4 o, in vec2 fragCoord){\n;vec2 ndcXY =  + 2.0 * fragCoord.xy / iResolution.xy-1.0;\n;vec2 m =iMouse.xy*2./ iResolution.xy-1.0;\n;float aspectRatio = iResolution.x / iResolution.y;\n;vec3 u=vec3(0,3,5);\n;vec3 t=vec3(ndcXY * vec2( aspectRatio, 1.0 ), -1.0 );\n;vec4 lightWs=vec4( 0,4.5,-4,10);\n;if(iMouse.z<=0.)lightWs.xy+=vec2(sin(gAnimTime),cos(gAnimTime))*2.;\nelse lightWs.xy=m*9.;\n;vec3 p;//becomes intersection point.\n;vec3 n=vec3(0)//becomes surface notmal to test for intersection\n;if(raymarch(u,t, 128., p,n )!=vec3(0)){\n //f=... simple fog works becaue the light emmitter normal is==.z\n //a more general case must calculte some intersection here?\n ;float f=sat((p.z-t.z+20.)*.2);\n ;o.rgb=vec3(.125*f*f);\n}\n// apply scattering of the\n;o.rgb+=inscatter( u,t, lightWs, vec3(fragCoord.xy,iTime),12.);\n;o.r=smoothstep( 0.,1.,o.r )\n;o.g=smoothstep( 0.,1.,o.g-1.)\n;o.b=smoothstep(-1.,1.,o.b-1.)\n;o.a=1.;\n;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}