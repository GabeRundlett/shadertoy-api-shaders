{
    "Shader": {
        "info": {
            "date": "1666829971",
            "description": "another cone collision. this was a very nice exercise.\nand now, i can finally do something else !!",
            "flags": 0,
            "hasliked": 0,
            "id": "mssGWj",
            "likes": 7,
            "name": "cone - box intersection",
            "published": 3,
            "tags": [
                "cone"
            ],
            "usePreview": 0,
            "username": "sympou",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "#define coneWidth .25\n\n#define camPos vec2(0.1,0.2)\n#define lineWidth 2.\n\n#define boxDims    vec2(0.1,0.1)\n#define boxOffset0 vec2(0.5,0.5)\n\n// 30/11/22 : just for fun, implementation of a method to avoid conditionals,\n// inspired by https://theorangeduck.com/page/avoiding-shader-conditionals\n// for the following macro, when n > 0, it returns a, else it returns b\n#define comp(n,a,b) (b-a) * max(sign(n),0.) + a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //rendered color\n    vec3 col = vec3(1.);\n    \n    //distance between pixel and outlines\n    float d = 99999.;\n\n    //distances between ro and the two collisions points\n    vec2 t2 = vec2(0.);\n    \n    \n    ////finding the distances/////\n\n    //initial values    \n    vec2 p = fragCoord;\n    vec2 m = iMouse.xy;\n\n    if ( m == vec2(0) ) m = vec2(0.5,0.5+cos(iTime)*0.1) * iResolution.xy;\n\n    vec2 ro = camPos * iResolution.xy;\n    vec2 boxSize = boxDims * iResolution.xy;\n    vec2 boxOffset = boxOffset0 * iResolution.xy;\n\n\n    ///////// cone - box intersection ///////\n    \n    // there might be a simpler solution !\n\n\n    //direction between mouse and origin\n    vec2 rd  = normalize(m - ro);\n    \n    \n    //t = distance cone - line for each of the 4 faces\n    vec2 ro2 = ro - boxOffset;\n    vec4 t = vec4( (  boxSize - ro2) / (rd - coneWidth),\n                   (- boxSize - ro2) / (rd + coneWidth)).xzyw;\n    \n    //t.xy = ( ro2.x < 0. || t.x < 0. && t.y > 0. ) ? t.yx : t.xy;\n    //t.zw = ( ro2.y < 0. || t.z < 0. && t.w > 0. ) ? t.wz : t.zw;\n    t = comp( min(max(t.xz,-t.yw),ro2).xxyy, t.yxwz, t);\n    \n    vec2 edgeDist = abs(ro2) - boxSize;\n    vec4 mima = vec4(min(t.x,t.z),max(t.x,t.z),min(t.y,t.w),max(t.y,t.w));\n    \n    //where is ro in relation to the box ?\n    if (edgeDist.x>0. && edgeDist.y>0.) {\n        //corner zone\n        \n        //t2.x = (mima.x < 0.) ? 0.     : mima.y;\n        //t2.y = (mima.z < 0.) ? mima.w : mima.z;\n        t2 = comp(mima.xz, vec2(0.,mima.w), mima.yz);\n        \n    } else if (edgeDist.x>0. || edgeDist.y>0.) {\n        //near a face\n        \n        //t  = ( edgeDist.x < edgeDist.y ) ? t : t.zwxy;\n        //t2 = vec2( t.z, (t.x<0.) ? t.w : min(t.x,t.w));\n        t  = comp(edgeDist.x-edgeDist.y, t, t.zwxy);\n        t2 = vec2( t.z, comp(t.x, t.w, min(t.x,t.w)) );\n        \n    } else {\n        //inside\n        \n        //t2 = vec2( 0., (mima.x < 0.) ?  mima.y : mima.x);\n        t2 = vec2( 0., comp(mima.x, mima.y, mima.x) );\n\n    }\n        \n    //t2 = (t2.x>t2.y) ? vec2(0.) : t2;\n    t2 = comp(t2.y-t2.x,0.,t2);\n    \n    //if the obtained point is in the \"corner zone\",\n    //we compute a collision with one of the corners,\n    //using a simplified version of\n    //https://www.shadertoy.com/view/NtGfzt\n    vec2 hit1 = ro2 + rd * t2.x;\n    vec2 hit2 = ro2 + rd * t2.y;\n    vec2 edgeDist1 = abs(hit1) - boxSize;\n    vec2 edgeDist2 = abs(hit2) - boxSize;\n    float cw2 = 1. - coneWidth*coneWidth;\n    \n    if (edgeDist1.x>0. && edgeDist1.y>0.) {\n        vec2 sr = boxSize * sign(hit1) - ro2;\n        float b = dot( sr, rd );\n        float c = dot( sr, sr ) * cw2;\n        float h = sqrt(b*b - c);\n        t2.x = (b - h) / cw2;\n    }\n\n    if (edgeDist2.x>0. && edgeDist2.y>0.) {\n        vec2 sr = boxSize * sign(hit2) - ro2;\n        float b = dot( sr, rd );\n        float c = dot( sr, sr ) * cw2;\n        float h = sqrt(b*b - c);\n        t2.y = (b + h) / cw2;\n    }\n    \n    /////////////////////\n \n \n    //drawing the starting point\n    d = min(d, circleFillDist(p, ro, 2.5));\n    \n    //drawing the box\n    d = min(d, circleFillDist(p, boxOffset, 2.5));\n    d = min(d, boxDist(p-boxOffset, boxSize));\n\n    //drawing the edges of the cone\n    vec2 offset = vec2(rd.y,-rd.x) * coneWidth / sqrt(cw2);\n    d = min(d, segLineDist(p, ro, ro + rd + offset));\n    d = min(d, segLineDist(p, ro, ro + rd - offset));\n\n    //drawing the two resulting circles\n    if ( t2.x > 0. ) {\n        d = min(d, circleDist(p, ro + rd * t2.x, coneWidth * t2.x));\n        d = min(d, circleFillDist(p, ro + rd * t2.x, 2.5));\n    }\n    if ( t2.y > 0. ) {\n        d = min(d, circleDist(p, ro + rd * t2.y, coneWidth * t2.y));\n        d = min(d, circleFillDist(p, ro + rd * t2.y, 2.5));\n    }\n \n    //distance to color\n    d = smoothLine( d / lineWidth );\n    col = min(col, vec3( d ) );\n \n    //showing \"hidden\" line\n    float d2 = segLineDist(p, ro, ro + rd);\n\n    d2 = smoothLine( d2 / lineWidth );\n    col = min(col, vec3( mix(d2,1.,0.85) ) );\n \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float circleDist(vec2 pos, vec2 pt, float radius) {\n    return abs(length(pos-pt) - radius);\n}\nfloat circleFillDist(vec2 pos, vec2 pt, float radius) {\n    return max(length(pos-pt) - radius, 0.);\n}\nfloat segLineDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = max( dot(pa,ba) / dot(ba,ba), 0.0);\n    return length( pa - ba*h );\n}\nfloat segDist(vec2 pos, vec2 a, vec2 b) {\n    vec2 pa = pos-a, ba = b-a;\n    float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\n    return length( pa - ba*h );\n}\nfloat boxDist(vec2 pos, vec2 b) {\n    vec2 d = abs(pos)-b;\n    return abs(length(max(d,0.0)) + min(max(d.x,d.y),0.0));\n}\nfloat smoothLine( in float x) {\n    float t = clamp(x , 0.0, 1.0);\n    return t * t * (3.0 - 2.0 * t);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}