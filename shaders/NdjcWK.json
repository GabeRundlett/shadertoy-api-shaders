{
    "Shader": {
        "info": {
            "date": "1670866606",
            "description": "LOD ~ Levels of detail, prototype on simple terrain with basic lighting and fog.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdjcWK",
            "likes": 5,
            "name": "Lvls of Detail",
            "published": 3,
            "tags": [
                "raymarch",
                "lod"
            ],
            "usePreview": 1,
            "username": "Dirk",
            "viewed": 287
        },
        "renderpass": [
            {
                "code": "vec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n\nfloat getNoise( in vec3 pos, float t ){\n\n\n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n\t\n\tfloat f = 0.0;\n\t\n    uv *= 16.0;\n        \n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\t\n\tif( t<12.0 )\n\t{\n\t\tf *= 0.9000*noise( uv ); uv = m*uv;\n\t}\n    if( t<6.0)\t\n\t{\n\t\tf -= 0.6000*noise( uv ); uv = m*uv;\n\t}\n    if( t<4.0)\t\n\t{\n\t\tf += 0.3000*noise( uv ); uv = m*uv;\n\t}\n    if( t<3.0)\t\n\t{\n\t\tf -= 0.2000*noise( uv ); uv = m*uv;\n\t}\n    if( t<2.5)\t\n\t{\n\t\tf += 0.1000*noise( uv ); uv = m*uv;\n\t}\n    if( t<2.0)\t\n\t{\n\t\tf -= 0.0500*noise( uv ); uv = m*uv;\n\t}\n    if( t<1.5)\t\n\t{\n\t\tf += 0.0100*noise( uv ); uv = m*uv;\n\t\tf -= 0.0050*noise( uv ); uv = m*uv;\n\t}\n    if( t<1.0)\t\n\t{\n\t\tf += 0.0001*noise( uv ); uv = m*uv;\n\t}\n    \n\n\treturn 0.3 + 0.7*f;\n}\n\n\n\n\n\n\nfloat map( in vec3 pos, float t ){\n\n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n\n    float d = length(pos) - 0.0;\n    \n    float d2 = pos.y+noise(uv)*0.5 - ( -0.25 - 0.03*getNoise(pos,t) );\n\n    return min(d,d2);\n\n}\n\nvec3 calcNormal( in vec3 pos, float t ){\n\n    vec2 e = vec2( 0.001, 0.0 );\n\n    return normalize(vec3(map(pos+e.xyy,t)-map(pos-e.xyy,t),\n                          map(pos+e.yxy,t)-map(pos-e.yxy,t),\n                          map(pos+e.yyx,t)-map(pos-e.yyx,t)));\n\n}\n\nfloat castRay( in vec3 ro, vec3 rd ){\n\n    float t = 0.0;\n\n    for( int i=0; i<60; i++ ){\n        \n        vec3 pos = ro + rd*t;\n        float h = map(pos,t); \n        \n        if(h<0.001)break;\n        t += h;\n        if(t>12.0)break;\n    }\n    if(t>12.0) t=-1.0;\n    \n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y; //center screen\n    \n    float an = 10.0*iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(0.5*sin(an),castRay(vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0))*0.5, 0.5*cos(an)); //Camera Location\n    \n    vec3 ta = vec3(0.0,0.0,0.0);\n    \n    vec3 ww = normalize( ta- ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu,ww) );\n    \n\n    vec3 rd = normalize( p.x*uu + p.y*vv + ww ); //Camera Direction\n    \n    vec3  col = vec3(0.3,0.5,0.8) - 0.7*rd.y;\t\t\t\t//Sky Color\n    col = mix( col,vec3(0.8,0.8,0.7), exp(-10.0*rd.y));\t\t//Sky Color 2 + Gradient Mixture\n    \n    float t = castRay(ro,rd);\n\n    if( t>0.0 ){\n        vec3 pos = ro + rd*t;\n        vec3 nor = calcNormal(pos,t);\n\n        vec3 mate = vec3(0.18);\t\n         \tmate = vec3(0.0,0.5,0.0);\n            float f = 1.0-getNoise(pos,t);\n            mate += vec3(0.2,0.5,0.4)*nor;\n\t\n    \n\tvec2 uv = pos.xz*0.2 + iTime*0.05;\n       \n        vec3 light_dir = normalize( vec3(0.8,0.4,0.1) );\n        float light_dif = clamp( dot(nor,light_dir),0.0,1.0);\n        float light_sha = step( castRay( pos+nor*0.001, light_dir ), 0.0 );\n        \n        if(t<3.0){\n            light_sha = step( castRay( pos+nor*0.001, light_dir ), 0.0 );\n        }else{\n            light_sha = 1.0;\n        }\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.2,1.0,0.2)), 0.0, 1.0);\n        \n        vec3 light_col = vec3( 0.2,0.4,0.3 );\n        vec3 sky_col = vec3(0.0,0.1,0.3);\n        \n        vec3 fog = vec3(0.03,0.1,0.05);\n              \n        \n        col  = mix(light_col*light_dif*light_sha,fog*0.5,t-3.0);\n        col += sky_col*sky_dif;\n        col += mate*vec3(0.0,pos.y*1.2,0.1)*0.1;\n    }\n\n    fragColor = vec4(col,(0.0));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}