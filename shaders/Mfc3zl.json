{
    "Shader": {
        "info": {
            "date": "1712012424",
            "description": "Generates a blurred rounded rectangle using distance field approximation. Adapted from Raph Levien's blog: https://raphlinus.github.io/graphics/2020/04/21/blurred-rounded-rects.html",
            "flags": 0,
            "hasliked": 0,
            "id": "Mfc3zl",
            "likes": 3,
            "name": "Blurred Rounded Rectangle",
            "published": 3,
            "tags": [
                "procedural",
                "sdf",
                "blur",
                "rectangle",
                "distance",
                "field",
                "shape",
                "rounded",
                "blurred"
            ],
            "usePreview": 0,
            "username": "jclb",
            "viewed": 123
        },
        "renderpass": [
            {
                "code": "// Adapted from Raph Levien's blog: https://raphlinus.github.io/graphics/2020/04/21/blurred-rounded-rects.html\n\n// Compute the error function.\nfloat compute_erf7(float x) {\n    x *= 1.12837916709551257389615890312154517; //2 / sqrt(PI)\n    float xx = x * x;\n    x += (0.24295 + (0.03395 + 0.0104 * xx) * xx) * (x * xx);\n    return x / sqrt(1.0 + x * x);\n}\n\n// Generate a blurred rounded rectangle using distance field approximation.\nfloat blurredRoundedRectangle(vec2 uv, float w, float h, float r, float s) {\n    // To avoid divide by 0; potentially should be a bigger number for antialiasing.\n    s = max(0.001, s);\n    float s_inv = 1. / s;\n\n    float min_edge = min(w, h);\n    float rmax = 0.5 * min_edge;\n    float r0 = min(length(vec2(r, s * 1.15)), rmax);\n    float r1 = min(length(vec2(r, s * 2.0)), rmax);\n\n    float exponent = 2.0 * r1 / r0;\n    float recip_exponent = 1. / exponent;\n\n    // Pull in long end (make less eccentric).\n    float delta = 1.25 * s * (exp(-(0.5 * s_inv * w) * (0.5 * s_inv * w)) - exp(-(0.5 * s_inv * h) * (0.5 * s_inv * h)));\n    w = w + min(delta, 0.0);\n    h = h - max(delta, 0.0);\n    \n    float scale = 0.5 * compute_erf7(s_inv * 0.5 * (max(w, h) - 0.5 * r));\n\n    vec2 xy0 = abs(uv) - (vec2(w,h) * 0.5 - r1);\n    vec2 xy1 = max(xy0, 0.);\n\n    float d_pos = pow(pow(xy1.x, exponent) + pow(xy1.y, exponent), recip_exponent);\n    float d_neg = min(0., max(xy0.x, xy0.y));\n\n    float d = d_pos + d_neg - r1;\n    float z = scale * (compute_erf7(s_inv * (min_edge + d)) - compute_erf7(s_inv * d));\n    \n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 rectSize = vec2(0.5, 0.5);\n\n    float radius = 0.1;\n    float blur = pow(sin(iTime * 2.) * 0.5 + 0.5, 2.0);\n    \n    // Center UVs\n    uv -= 0.5;    \n    \n    // Adjust aspect ratio.\n    uv.x *= aspectRatio;\n    rectSize.x *= aspectRatio;\n    \n    float shape = blurredRoundedRectangle(uv, rectSize.x, rectSize.y, radius, blur);\n    // Output to screen\n    fragColor = vec4(shape, shape, shape, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}