{
    "Shader": {
        "info": {
            "date": "1712575352",
            "description": "Comparing different corner shapes to achieve rounded boxes. Only the Cosine and the Cubic produce C2 continuous surfaces, which you can see by a smooth lighting transition. See [url]https://iquilezles.org/articles/roundedboxes/[/url] for information.",
            "flags": 0,
            "hasliked": 0,
            "id": "4fyGz1",
            "likes": 31,
            "name": "Rounded boxes comparison 3D",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "squircle",
                "superellipse",
                "roundedbox",
                "roundedbox"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1048
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Comparing different corner shapes to achieve rounded boxes\n// (motivated by https://www.shadertoy.com/view/lcyGRz). Here\n// I show a Circle, Parabola, Cosine and Cubic corner shapes.\n// Skipped hyperbola in this example, it doesn't help really.\n// But Superellipse is given for convenience even though it's\n// not a rounded box.\n//\n// Note how only the Cosine and the Cubic produce C2 continuous\n// surfaces (and the Superellipse), whilc the Circle and Parabola\n// do not.\n//\n// See https://www.shadertoy.com/view/4cG3R1 for a 2D version.\n\n// 0: persp angled camera\n// 1: ortho aligned camera\n#define CAMERA 0\n\nconst float kT = 6.28318531;\n\nfloat sdCornerCircle( in vec2 uv )\n{\n    return length(uv-vec2(0.0,-1.0)) - sqrt(2.0);\n}\n\nfloat sdCornerParabola( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/ws3GD7\n    float y = (0.5 + uv.y)*(2.0/3.0);\n    float h = uv.x*uv.x + y*y*y;\n    float w = pow( uv.x + sqrt(abs(h)), 1.0/3.0 );\n    float x = w - y/w;\n    vec2  q = vec2(x,0.5*(1.0-x*x));\n    return length(uv-q)*sign(uv.y-q.y);\n}\n\nfloat sdCornerCosine( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/3t23WG\n    uv *= (kT/4.0);\n\n    float ta = 0.0, tb = kT/4.0;\n    for( int i=0; i<8; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float y = t-uv.x+sin(t)*(uv.y-cos(t));\n        if( y<0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,cos(ta)), qb = vec2(tb,cos(tb));\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di), 0.0, 1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y) * (4.0/kT);\n}\n\nfloat sdCornerCubic( in vec2 uv )\n{\n    float ta = 0.0, tb = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float c = (t*t*(t-3.0)+2.0)/3.0;\n        float dc = t*(t-2.0);\n        float y = (uv.x-t) + (uv.y-c)*dc;\n        if( y>0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,(ta*ta*(ta-3.0)+2.0)/3.0);\n    vec2  qb = vec2(tb,(tb*tb*(tb-3.0)+2.0)/3.0);\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di),0.0,1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y);\n}\n\nfloat sdRoundBox(in vec2 p, in vec2 b, in vec4 r, int type)\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\n    // box coordinates\n    vec2 q = abs(p)-b+r.x;\n    \n    // distance to sides\n    if( min(q.x,q.y)<0.0 ) return max(q.x,q.y)-r.x;\n\n    // rotate 45 degrees, offset by r and scale by r*sqrt(0.5)\n    // to canonical corner coordinates\n    vec2 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n\n    // compute distance to corner shape\n    float d;\n         if( type==0 ) d = sdCornerCircle( uv );\n    else if( type==1 ) d = sdCornerParabola( uv );\n    else if( type==2 ) d = sdCornerCosine( uv );\n    else if( type==3 ) d = sdCornerCubic( uv );\n    // undo scale\n    return d * r.x*sqrt(0.5);\n}\n\n// note this approximation is really bad, do not use in production\nfloat approx_sdSquircle(vec2 p, vec2 s, float n)\n{\n    p = abs(p);\n    float w = pow(p.x/s.x,n) + pow(p.y/s.y,n);\n    float b = 2.0*n-2.0;\n    float a = 1.0-1.0/n;\n    float c = 2.0*n;\n    return (w-pow(w,a)) * inversesqrt( pow(p.x,b)/pow(s.x,c) + pow(p.y,b)/pow(s.y,c) );\n}\n\n// https://www.shadertoy.com/view/4lyfzw\nfloat extrude( in float d, float z, in float h ) \n{\n    vec2 q = vec2(d,abs(z)-h);\n    float ma = min(q.x,q.y);\n    float di = max(q.x,q.y);\n    return min(di,0.0) + length(max(q,0.0));\n}\n\nfloat map( in vec3 p, int type )\n{\n    // 2d shape\n    vec2 b = vec2(0.9,0.5);\n    vec4 r = vec4(0.3);\n    float d;\n    if( type<4 )\n    {\n        // normalize radii, usually NOT needed, here just for demo purposes\n        #if 1\n        const float kNorm[4] = float[4]( sqrt(2.0)-1.0, 1.0/2.0, 4.0/kT, 2.0/3.0 );\n        r = r*kNorm[type]/kNorm[0]; \n        #endif\n        d = sdRoundBox( p.xz, b, r, type );\n    }\n    else\n    {\n        d = approx_sdSquircle(p.xz,b,6.0);\n    }\n\n    // extrude\n    #if CAMERA==0\n    const float ex = 0.35;\n    #else\n    const float ex = 1.0;\n    #endif\n    return extrude( d, p.y, ex );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, int type )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, type ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, type ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, type ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, type ) );\n}\n\nfloat print( in float sdf, inout vec2 p, in int str[12])\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nfloat shapeName( int type, in vec2 q )\n{\n    float text = 1e20;\n          if( type==0 )  text = print(text,q,int[12](67,105,114, 99,108,101,  0,  0,  0,  0,  0,  0));\n    else  if( type==1 )  text = print(text,q,int[12](80, 97,114, 97, 98,111,108, 97,  0,  0,  0,  0));\n    else  if( type==2 )  text = print(text,q,int[12](67,111,115,105,110,101,  0,  0,  0,  0,  0,  0));\n    else  if( type==3 )  text = print(text,q,int[12](67,117, 98,105, 99,  0,  0,  0,  0,  0,  0,  0));\n    else/*if( type==4 )*/text = print(text,q,int[12](83,117,112,101,114,101,108,108,105,112,115,101));\n    return text;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if CAMERA==0\n    int type = int( iTime/2.0 ) % 5;\n    // camera movement\t\n\tfloat an = 1.0;//0.5*(iTime-10.0);\n\tvec3 ro = 3.0*vec3( 1.0*sin(an), 0.3, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    #else\n    float py = fragCoord.y/iResolution.y;\n    int type = int( floor(5.0*py) );\n    #endif\n\n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        #if CAMERA==0\n        vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n        #else\n        vec3 ro = vec3( p*0.75, 3.0 );\n        vec3 rd = vec3( 0.0, 0.0, -1.0 );\n        #endif\n\n        // raymarch from t=2 to t=5\n        const float tmin = 2.0;\n        const float tmax = 5.0;\n        float t = tmin;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos, type);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, type);\n\n            // material\n            vec3 mate = vec3(0.25); //vec3 mate = (0.5+0.5*nor.xyz)*(0.5+0.5*nor.zxy);\n            #if CAMERA==0\n            const float ks = 0.5;\n            #else\n            const float ks = 0.5;\n            #endif\n            \n            // ambient light\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = mate*vec3(0.2,0.3,0.4)*amb;\n            // key light\n            vec3 lig = normalize(vec3(1.0,0.3,0.2));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n            col += mate*vec3(0.85,0.75,0.65)*dif;\n            col += ks*pow(spe,8.0)*dif;\n        }\n\n        // gamma (before accumulation/filtering)\n        col = pow( col, vec3(0.4545) );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    // grid lines\n    #if CAMERA==1\n    tot *= 1.0-smoothstep(0.95,1.0,abs(2.0*fract(py*5.0)-1.0));\n    #endif\n    \n    // draw text\n    {\n        vec2 p = fragCoord/iResolution.y;\n    \n        #if CAMERA==0\n        const float text_scale = 0.075;\n        vec2 q = (p-vec2(0.05,0.05))/text_scale;\n        float text = shapeName( type, q );\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n        #else\n        const float text_scale = 0.05;\n        p.y -= 0.35/5.0;\n        vec2 q = (p-vec2(0.6,floor(py*5.0)/5.0))/text_scale;\n        \n        float text = shapeName( type, q );\n        tot = mix(tot,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n        #endif\n    }\n\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}