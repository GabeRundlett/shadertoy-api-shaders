{
    "Shader": {
        "info": {
            "date": "1611655460",
            "description": "Using implicit bezier curves, not signed distance fields.\n\nBased on:\nLOOP, Charles; BLINN, Jim. Resolution independent curve rendering using programmable graphics hardware.\nIn: ACM SIGGRAPH 2005 Papers. 2005. S. 1000-1009.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtycWG",
            "likes": 4,
            "name": "Antialiased Bezier Fill (no SDF)",
            "published": 3,
            "tags": [
                "2d",
                "bezier"
            ],
            "usePreview": 0,
            "username": "Lichtso",
            "viewed": 459
        },
        "renderpass": [
            {
                "code": "vec3 cartesian_to_barycentric_2d(in vec2[3] t, in vec2 p) {\n    vec2 t1t2 = t[1]-t[2];\n    vec2 t2t0 = t[2]-t[0];\n    vec2 pt2 = p-t[2];\n    float determ = -dot(vec2(t1t2.y, -t1t2.x), t2t0);\n    float a = dot(vec2(t1t2.y, -t1t2.x), pt2)/determ;\n    float b = dot(vec2(t2t0.y, -t2t0.x), pt2)/determ;\n    return vec3(a, b, 1.0-a-b);\n}\n\nvec2 barycentric_to_cartesian_2d(in vec2[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nvec3 barycentric_to_cartesian_3d(in vec3[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nvec4 barycentric_to_cartesian_4d(in vec4[3] t, in vec3 p) {\n    return t[0]*p[0] + t[1]*p[1] + t[2]*p[2];\n}\n\nfloat quadratic_bezier(in vec2 weights) {\n    float value = weights.x*weights.x - weights.y;\n    vec2 weights_dx = dFdx(weights);\n    vec2 weights_dy = dFdy(weights);\n    vec2 derivative = mat2(\n        weights_dx.x, weights_dy.x,\n        weights_dx.y, weights_dy.y\n    ) * vec2(\n        2.0*weights.x,\n        -1.0\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat rational_quadratic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        2.0*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat cubic_bezier(in vec3 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z;\n    vec3 weights_dx = dFdx(weights);\n    vec3 weights_dy = dFdy(weights);\n    vec3 derivative = mat3(\n        weights_dx.x, weights_dy.x, 0.0,\n        weights_dx.y, weights_dy.y, 0.0,\n        weights_dx.z, weights_dy.z, 0.0\n    ) * vec3(\n        3.0*weights.x*weights.x,\n        -weights.z,\n        -weights.y\n    );\n    return 0.5 - value/length(derivative);\n}\n\nfloat rational_cubic_bezier(in vec4 weights) {\n    float value = weights.x*weights.x*weights.x - weights.y*weights.z*weights.w;\n    vec4 weights_dx = dFdx(weights);\n    vec4 weights_dy = dFdy(weights);\n    vec4 derivative = mat4(\n        weights_dx.x, weights_dy.x, 0.0, 0.0,\n        weights_dx.y, weights_dy.y, 0.0, 0.0,\n        weights_dx.z, weights_dy.z, 0.0, 0.0,\n        weights_dx.w, weights_dy.w, 0.0, 0.0\n    ) * vec4(\n        3.0*weights.x*weights.x,\n        -(weights.z*weights.w),\n        -(weights.y*weights.w),\n        -(weights.y*weights.z)\n    );\n    return 0.5 - value/length(derivative);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 triangle[] = vec2[](\n        vec2(600.0, 10.0),\n        iMouse.xy,\n        vec2(sin(iTime)*500.0+600.0, cos(iTime)*300.0+400.0)\n    );\n    vec3 weights[] = vec3[](\n        vec3(0.0, 0.0, 1.0),\n        vec3(0.5*sqrt(2.0), 0.0, sqrt(2.0)),\n        vec3(1.0, 1.0, 1.0)\n    );\n    vec3 bary = cartesian_to_barycentric_2d(triangle, fragCoord);\n    if(bary.x < -0.1 || bary.y < 0.0 || bary.z < -0.1) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        vec3 w = barycentric_to_cartesian_3d(weights, bary);\n        float alpha = rational_quadratic_bezier(w);\n        fragColor = vec4(vec3(clamp(alpha, 0.0, 1.0)), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}