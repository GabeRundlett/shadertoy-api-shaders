{
    "Shader": {
        "info": {
            "date": "1626553740",
            "description": "Pathtracing",
            "flags": 32,
            "hasliked": 0,
            "id": "slfXDH",
            "likes": 1,
            "name": "Floled's Pathtracing",
            "published": 3,
            "tags": [
                "bruh"
            ],
            "usePreview": 0,
            "username": "Floled",
            "viewed": 220
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, uv);\n    vec3 col = data.xyz / data.w; \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define skyboxVisible true\n#define INFINITY 1e9\n#define PI 3.1415926\n#define NUM_SAMPLES 16\n#define NUM_BOUNCES 4\n\nvec2 _Pixel;\nfloat _Seed = 0.0;\nfloat rand() {\n    float result = sin(_Seed / 100.0 * dot(_Pixel * cos(iTime * 53.35342), vec2(12.9898f, 78.233f))) * 43758.5453;\n    _Seed += 1.0;\n    return fract(result);\n}\nfloat rand2(vec2 v) {\n    float result = fract(sin(fract(iTime + v.x + v.y) * 54538.4375 * dot(v, vec2(12.9898, 78.233))) * 43758.5453);\n    return result;\n}\nfloat sdot(vec3 x, vec3 y) {\n    return clamp(dot(x, y), 0.0, 1.0);\n}\nvec3 randPointOnSphere(vec2 seed) {\n    vec2 uv = vec2(fract(rand2(seed)), fract(rand2(seed * 59.24234)));\n    float theta = 2.0 * PI * uv.x;\n    float psi = acos(2.0 * uv.y - 1.0);\n    float x = cos(theta) * sin(psi);\n    float y = sin(theta) * sin(psi);\n    float z = cos(psi);\n    return vec3(x, y, z);\n}\nfloat smoothnessToPhongAlpha(float s)\n{\n    return pow(1000.0, s * s);\n}\nfloat energy(vec3 color)\n{\n    return (color.x + color.y + color.z) / 3.0;\n}\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int materialID;\n};\nstruct Box {\n    vec3 size;\n    vec3 pos;\n    int materialID;\n};\nstruct AABB {\n    vec3 min;\n    vec3 max;\n    vec3 pos;\n};\nstruct Plane {\n    float y;\n    vec3 normal;\n    int materialID;\n};\nstruct Material {\n    vec3 color;\n    bool emission;\n    float intensity;\n    float ior;\n};\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    vec3 energy;\n};\nstruct HitInfo {\n    vec3 pos;\n    vec3 direction;\n    vec3 normal;\n    float distance;\n    int materialID;\n};\nMaterial materials[4] = Material[4](\n    Material(vec3(0.5, 0.6, 0.8), false, 0.0, 1.0),\n    Material(vec3(0.7, 0.9, 0.5), false, 0.0, 1.0),\n    Material(vec3(1.0, 0.7, 0.8), false, 0.0, 1.0),\n    Material(vec3(1.0, 1.0, 1.0), true, 5.0, 1.0)\n);\nPlane plane = Plane(-1.0, vec3(0.0, 1.0, 0.0), 0);\nconst int numSpheres = 1;\nconst int numBoxes = 17;\nSphere spheres[numSpheres] = Sphere[numSpheres](\n    Sphere(vec3(0., 5.15, 0.), 1., 1)\n);\nBox boxes[numBoxes] = Box[numBoxes](\n    Box(vec3(.15, 2., .15), vec3(2., 2., 2.), 2),\n    Box(vec3(.15, 2., .15), vec3(-2., 2., 2.), 2),\n    Box(vec3(.15, 2., .15), vec3(-2., 2., -2.), 2),\n    Box(vec3(.15, 2., .15), vec3(2., 2., -2.), 2),\n    Box(vec3(2.15, .15, 2.15), vec3(0., 4., 0.), 2),\n    Box(vec3(.15, 1., .15), vec3(3.5, 1., 1.), 2),\n    Box(vec3(.15, 1., .15), vec3(1.5, 1., 1.), 2),\n    Box(vec3(.15, 1., .15), vec3(1.5, 1., -1.), 2),\n    Box(vec3(.15, 1., .15), vec3(3.5, 1., -1.), 2),\n    Box(vec3(1.15, .15, 1.15), vec3(2.5, 2., 0.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, 0.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, -.5), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, .5), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, 1.), 2),\n    Box(vec3(.15, 1.5, .15), vec3(3.5, 3.5, -1.), 2),\n    Box(vec3(.15, .15, 1.15), vec3(3.5, 5., 0.), 2),\n    Box(vec3(5.0, .001, 5.0), vec3(0., 9.0, 0.), 3)\n);\n\nbool intersectAABB(in Ray ray, in AABB box, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.direction;\n\tvec3 t_1 = (box.min - ray.origin);\n\tvec3 t_2 = (box.max - ray.origin);\n    t_1 += box.pos;\n    t_2 += box.pos;\n    t_1 *= div;\n    t_2 *= div;\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\nvoid intersectBox(Ray ray, inout HitInfo rayHit, int boxID)\n{\n    Box box = boxes[boxID];\n    AABB boxAABB = AABB(-box.size, box.size, box.pos);\n\tfloat t_min = 0.0;\n\tfloat t_max = INFINITY;\n\tif(intersectAABB(ray, boxAABB, t_min, t_max)) {\n        if (t_min < rayHit.distance) {\n            vec3 p = ray.origin + ray.direction * t_min;\n            p -= box.pos;\n            p /= box.size;\n            if(abs(p.x) > abs(p.y)) {\n                if(abs(p.x) > abs(p.z)) {\n                    rayHit.normal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n                }\n                else {\n                    rayHit.normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n                }\n            }\n            else if(abs(p.y) > abs(p.z)) {\n                rayHit.normal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n            }\n            else {\n                rayHit.normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n            }\n            rayHit.distance = t_min;\n            rayHit.pos = ray.origin + ray.direction * t_min;\n            rayHit.materialID = box.materialID;\n        }\n\t}\n}\nvoid intersectSphere(Ray ray, inout HitInfo rayHit, int sphereID)\n{\n    Sphere sphere = spheres[sphereID];\n    vec3 d = ray.origin - sphere.pos;\n    float p1 = -dot(ray.direction, d);\n    float p2sqr = p1 * p1 - dot(d, d) + sphere.radius * sphere.radius;\n    if (p2sqr < 0.0)\n        return;\n    float p2 = sqrt(p2sqr);\n    float t = p1 - p2 > 0.0 ? p1 - p2 : p1 + p2;\n    if (t > 0.0 && t < rayHit.distance)\n    {\n        if (t < rayHit.distance) {\n            rayHit.distance = t;\n            rayHit.pos = ray.origin + ray.direction * t;\n            rayHit.normal = normalize(rayHit.pos - sphere.pos);\n            rayHit.materialID = sphere.materialID;\n        }\n    }\n}\nvoid intersectGroundPlane(Ray ray, inout HitInfo rayHit) {\n    float t = -ray.origin.y / ray.direction.y;\n    if (t > 0.0 && t < rayHit.distance)\n    {\n        rayHit.distance = t;\n        rayHit.pos = ray.origin + t * ray.direction;\n        rayHit.normal = plane.normal;\n        rayHit.materialID = plane.materialID;\n    }\n}\nHitInfo trace(Ray ray) {\n    HitInfo rayHit = HitInfo(vec3(0.), ray.direction, vec3(0.), INFINITY, 0);\n    intersectGroundPlane(ray, rayHit);\n    for (int i = 0; i < numSpheres; i++) {\n        intersectSphere(ray, rayHit, i);\n    }\n    for (int i = 0; i < numBoxes; i++) {\n        intersectBox(ray, rayHit, i);\n    }\n    return rayHit;\n}\nvec3 shade(inout Ray ray, HitInfo hitInfo) {\n    vec3 pos = hitInfo.pos;\n    vec3 dir = normalize(hitInfo.direction);\n    vec3 normal = normalize(hitInfo.normal);\n    if (hitInfo.distance < INFINITY) {\n        Material material = materials[hitInfo.materialID];\n        vec3 diffuse = material.color;\n        ray.origin = pos + normal * 0.001;\n        vec3 reflectionAngle = reflect(ray.direction, normal);\n        float alpha = smoothnessToPhongAlpha(material.smoothness);\n        vec3 rand = randPointOnSphere(dir.xy / iResolution.xy);\n        ray.direction = rand * sign(dot(normal, rand));\n        vec3 specular = vec3(1.0) * (alpha + 2.0) * pow(sdot(ray.direction, reflectionAngle), alpha);\n        if (material.emission) {\n            ray.energy *= material.intensity;\n            return material.color;\n        }\n        if (material.metallic) {\n            ray.energy *= specular;\n            return vec3(0.0);\n        }\n        ray.energy *= mix(diffuse, specular, fresnel);\n        return vec3(0.0);\n    } else {\n        ray.energy *= 0.0;\n        return skyboxVisible ? texture(iChannel1, dir).xyz : vec3(0.0);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    _Pixel = fragCoord;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 translatedUV = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    translatedUV /= 1.7;\n    \n    vec4 data = texture(iChannel0, uv);\n    if (iMouse.z > 0.0 || iMouse.w > 0.0) data = vec4(0.0);\n    \n    vec3 camUp = vec3(0, 1, 0);\n\tvec3 camLookat = vec3(0, 2, 0);\n\n    float mx = iMouse.x / iResolution.x * PI * 2.0 - 0.7;\n\tfloat my = -iMouse.y / iResolution.y * 1.45 + 1.55;\n\tvec3 camPos = vec3(cos(my) * cos(mx), sin(my), cos(my) * sin(mx)) * (18.2);\n\n    if ((dot(iMouse.xy, vec2(1.0)) <= 8.0)) camPos = vec3(12.0, 5.0, 6.0);\n\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + translatedUV.x * sideNorm * (iResolution.x/iResolution.y) + translatedUV.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n    \n    float aspectRatio = iResolution.y / iResolution.x;\n    for (int i = 0; i < NUM_SAMPLES; i++) {\n        float offset = rand2(vec2(float(i) + iTime, float(i) * iTime)) / iResolution.x;\n        vec3 rayDirection = rayVec + offset;\n        rayDirection = normalize(rayDirection);\n        vec3 color;\n        Ray ray = Ray(camPos, rayDirection, vec3(1.0, 1.0, 1.0));\n        for (int j = 0; j < NUM_BOUNCES; j++) {\n            HitInfo tracedRay = trace(ray);\n            color += ray.energy * shade(ray, tracedRay);\n            if (ray.energy == vec3(0.0))\n                break;\n        }\n        data += vec4(color, 1.0);\n    }\n    fragColor = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}