{
    "Shader": {
        "info": {
            "date": "1468713581",
            "description": "rotational speed - 45 rpm - you see what you hear\n(you might have to reset for video and sound to be in sync).\nmove the mouse for changing view\nmusic: john carpenters movie theme song - assault on precinct 13",
            "flags": 40,
            "hasliked": 0,
            "id": "Xt33Wn",
            "likes": 34,
            "name": "[SH16B] 45 rpm",
            "published": 3,
            "tags": [
                "sound",
                "sh16b",
                "record"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 2150
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// [SH16B] 45 rpm - my entry to the contest\n\n//--------------------------------------------------------------------------\n// record\n//--------------------------------------------------------------------------\n\n//#define SHOW_CAR\n\n// same as in Sound-Tab\n// john carpenters epic movie theme song \"assault on precinct 13\"\n\n#define T 2.7\n#define HT 1.059463094\n#define A4 (440.)\n#define B4 (440.*HT*HT)\n#define C4 (440.*HT*HT*HT)\n#define D4 (440.*HT*HT*HT*HT*HT)\n#define E4 (440.*HT*HT*HT*HT*HT*HT*HT)\n#define F4 (440.*HT*HT*HT*HT*HT*HT*HT*HT)\n#define G4 (440.*HT*HT*HT*HT*HT*HT*HT*HT*HT*HT)\n\n#define A0 (A4/16.)\n#define B0 (B4/16.)\n#define C0 (C4/16.)\n#define D0 (D4/16.)\n#define E0 (E4/16.)\n#define F0 (F4/16.)\n#define G0 (G4/16.)\n\n#define A1 (A4/8.)\n#define B1 (B4/8.)\n#define C1 (C4/8.)\n#define D1 (D4/8.)\n#define E1 (E4/8.)\n#define F1 (F4/8.)\n#define G1 (G4/8.)\n\n#define A2 (A4/4.)\n#define B2 (B4/4.)\n#define C2 (C4/4.)\n#define D2 (D4/4.)\n#define E2 (E4/4.)\n#define F2 (F4/4.)\n#define G2 (G4/4.)\n\n#define A3 (A4/2.)\n#define B3 (B4/2.)\n#define C3 (C4/2.)\n#define D3 (D4/2.)\n#define E3 (E4/2.)\n#define F3 (F4/2.)\n#define G3 (G4/2.)\n\n#define A5 (A4*2.)\n#define B5 (B4*2.)\n#define C5 (C4*2.)\n#define D5 (D4*2.)\n#define E5 (E4*2.)\n#define F5 (F4*2.)\n#define G5 (G4*2.)\n\nfloat rand(float x){\n    //return 2.0*(texture(iChannel0,vec2(x*44000.0+0.5,0.5)/iChannelResolution[0].xy).x-0.5);\n    return fract(sin(mod(x*10.0,10.0)*12.9898)*43758.5453)*2.0-1.0;\n}\n\nvec2 boing(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 1.0*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.6*sin(6.2831*(1.975*f*t+ph))\n                    +0.3*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*(exp(-8.0*t)+0.1*exp(-t*3.0)),-1.,1.)\n    );\n}\n\nvec2 brumm(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 0.6*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.8*sin(6.2831*(1.975*f*t+ph))\n                    +0.4*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*exp(-1.0*t),-1.,1.)\n    );\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvec2 bbbbb(float f1, float f2, float t)\n{\n    // X       X       X       X\n    // a _ a a c a\n    return \n    \t  boing(f1,t-T*0./16.,.0)*fermi((t-T*2./16.)/0.01)\n        + boing(f1,t-T*2./16.,.0)*fermi((t-T*3./16.)/0.01)\n        + boing(f1,t-T*3./16.,.0)*fermi((t-T*4./16.)/0.01)\n        + boing(f2,t-T*4./16.,.4)*fermi((t-T*5./16.)/0.01)\n        + boing(f1,t-T*5./16.,.0);\n}\n\nvec2 tich(float f,float t)\n{\n    float c=0.;\n    float a=0.;\n    for( int i=-512; i<512; i++ )\n    { \n        float t2=float(i)/44000.0;\n        float w=float(128)/44000.0;\n        w=1.0/f;\n        float s=exp(-t2*t2/w/w)*t2/w;\n        //a+=rand(t-t2)*cos(-6.2831*f*(t-t2))*s; c+=s; \n        a+=rand(t-t2)*s; c+=s*s;\n    }\n    a/=sqrt(c);\n    //a=rand(t);\n    a*=(0.5+0.5*sin(2300.*t))*(0.8+0.2*sin(800.*t))*exp(-25.0*mod(t,T/16.));\n    return 1.0*vec2(clamp(a,-1.0,1.0));\n}\n\nvec2 bumm(float f,float t)\n{\n    if(t<0.0) return vec2(0.);\n    return 2.0*vec2(sin(6.2831*f*t)*exp(-18.0*t));\n}\n\nfloat feep(float f1, float f2,float t)\n{\n \tfloat a=clamp(sin(f1*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n \treturn clamp(a*exp(0.5*t-4.0)*(fermi((t-T*3.5)/T/0.15)),-1.0,1.0);\n}\n\n// iq's polynomial smooth min function\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat feep2Map(float t)\n{\n    return smin(t,0.689*(t-T*(3.5+0.05))+T*(3.5-0.05),0.3);\n}\n\nfloat chordMaj(float f, float oct, float t) // FIXME: not really a major chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nfloat chordMin(float f, float oct, float t) // FIXME: not really a minor chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    if(t<0.) return vec2(0.);\n    //t+=T*4.*3.0;\n    vec2 boingLine = \n         bbbbb(A1,C1,mod(t-T*0.,T*4.))\n        +bbbbb(C1,E1,mod(t-T*1.,T*4.))\n        +bbbbb(G0,G0,mod(t-T*2.,T*4.))\n        +bbbbb(A1,C1,mod(t-T*3.,T*4.));\n    if(t<T*4.) boingLine=vec2(0);\n    vec2 tichLine = tich(20000.0*sin(3.435346/T*6.2831*t),mod(t,T*4.0));\n    //tichLine*=dot(tichLine,tichLine);\n    //return tichLine*0.2;\n    vec2 bummLine = \n         bumm(50.,mod(t-T/8.*0.,T))\n        +bumm(50.,mod(t-T/8.*1.,T))\n        +bumm(70.,mod(t-T/8.*2.,T))\n        +bumm(50.,mod(t-T/8.*4.,T));\n    vec2 brummLine = vec2(\n         brumm(A1,mod(t-T*0.,T*4.),0.)\n        +brumm(C1,mod(t-T*1.,T*4.),0.)\n        +brumm(G0,mod(t-T*2.,T*4.),0.)\n        +brumm(A1,mod(t-T*3.,T*4.),0.)\n        );\n    if(t<T*4.*3.0) brummLine=vec2(0);\n    vec2 feepLine = vec2(feep(8100.,0.0,mod(t,T*4.)));\n    //return feepLine;\n    if(t<T*4.*3.0) feepLine=vec2(0);\n    if(t>T*4.*4.0) feepLine=vec2(0);\n    vec2 feepLine2 = vec2(feep(8100.,0.0,feep2Map(mod(t,T*4.))));\n    //return feepLine2;\n    if(t<T*4.*4.0) feepLine2=vec2(0);\n    if(t>T*4.*5.0) feepLine2=vec2(0);\n    vec2 chordLine = vec2(\n         chordMin(A0,5.,mod(t-T*0.,T*4.))\n        +chordMaj(C0,5.,mod(t-T*1.,T*4.))\n        +chordMaj(G0,4.,mod(t-T*2.,T*4.))\n        +chordMin(A0,5.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*5.0) chordLine=vec2(0);\n    if(t>T*4.*7.0) chordLine=vec2(0);\n    vec2 chordLine2 = vec2(\n         chordMin(A0,6.,mod(t-T*0.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*1.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*2.,T*4.))\n        +chordMaj(G0,5.,mod(t-T*2.5,T*4.))\n        +chordMin(A0,6.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*7.0) chordLine2=vec2(0);\n    if(t>T*4.*9.5) chordLine2=vec2(0);\n    if(t>T*4.*9.0) boingLine=vec2(0);\n    if(t>T*4.*10.0) brummLine=vec2(0);\n    if(t>T*4.*11.0) tichLine=vec2(0);\n    if(t>T*4.*11.0) bummLine=vec2(0);\n    //if(t>T*4.*10.0) brummLine=vec2(0);\n    //return chordLine2;\n    return (\n         boingLine*.2\n        +tichLine *.12\n        +bummLine *.6\n        +brummLine*.2\n        +feepLine *.3\n        +feepLine2 *.3\n        +chordLine *.12\n        +chordLine2 *.12 )*0.5\n        ;\n}\n\n//--------------------------------------------------------------------------\n//  record\n//--------------------------------------------------------------------------\n\n#define LPRadius .0875\n#define HoleR .019\n#define Umin 45.0\n#define PlayTime 4.\n#define PlayWidth .04\n#define PI2 6.28318530717959\n#define Blank .005\n#define ZEier 0.006\n#define Thick .001\n#define Sticker 0.044\n#define Arm 0.15\n#define SongEndS 121.\n\n// deprecated - raymaching the spiral directly is too slow :(\nfloat distSpiral(vec3 pos)\n{\n    float R=LPRadius-.007;\n    float w=.1;\n    float d=PlayWidth/(Umin*PlayTime);\n    float h=pos.z;\n    float x=(R-length(pos.xy))/d;\n    float phi=atan(pos.y,pos.x)/PI2;\n    float xr=floor(x+phi+.5)-phi;\n    x=(x-xr+mainSound(0,xr/Umin*60.).x*0.3)*d;\n    return sqrt(h*h+x*x)-d*.3;\n}\n\nfloat distCyl(vec3 pos, float R, float H)\n{\n   \tvec2 d = abs(vec2(length(pos.xy),pos.z)) - vec2(R,H);\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0)); \n}\n\nfloat distCyl2(vec3 pos, vec3 p1, vec3 p2, float r)\n{\n    float d=dot(pos-p1,p2-p1)/dot(p2-p1,p2-p1);\n    float dist;\n    if(d>0. && d<1.)\n    {\n    \tvec3 c=cross(pos-p1,p1-p2);\n    \tdist = length(c)/length(p1-p2);\n    }\n    else if(d<=0.) dist = length(pos-p1);\n    else dist = length(pos-p2);\n  \treturn dist-r;\n}\n\nfloat distCone( vec3 pos, float r, float h )\n{\n    return (r*length(pos.xy)+h*pos.z)/sqrt(r*r+h*h);\n}\n\nvec3 rotateZ(vec3 pos, float phi)\n{\n    mat2 m=mat2(cos(phi),sin(phi),-sin(phi),cos(phi));\n    return vec3(m*pos.xy,pos.z);\n}\n\nvec3 rotatePos(vec3 pos)\n{\n    float phi = PI2*iTime*Umin/60.;\n    //phi = iMouse.x*0.01;\n    if(iTime>SongEndS+4.)\n        phi = PI2*(SongEndS+4.)*Umin/60.+PI2*(1.0-exp(-iTime+SongEndS+4.))*Umin/60.;\n    return rotateZ(pos,phi);\n}\n\nvec3 getNeedlePos()\n{\n    float d=PlayWidth/(Umin*PlayTime);\n    vec3 npos;\n    npos.x=LPRadius-Blank-iTime*Umin/60.*d;\n    float xEnd=LPRadius-Blank-SongEndS*Umin/60.*d;\n    if(iTime>SongEndS) npos.x = xEnd-(iTime-SongEndS)*Umin/60.*0.02;\n    npos.x=max(Sticker+.003,npos.x);\n    npos.y=Arm-sqrt(Arm*Arm-(npos.x-0.05)*(npos.x-0.05));\n    float phi=2.*iTime*Umin/60.*PI2;\n    if(iTime>SongEndS+4.) phi=2.*(SongEndS+4.)*Umin/60.*PI2+2.*(1.-exp(-iTime+SongEndS+4.))*Umin/60.*PI2;\n    npos.z=-ZEier*sin(phi)*length(npos.xy);\n    return npos;\n}\n    \n// smoothed minimum - copied from iq's site (https://iquilezles.org/articles/smin)\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// some distance primitives - from iq's site (https://iquilezles.org/articles/smin)\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat getDistanceBoxS(vec3 rpos, vec3 size)\n{\n    vec3 di = abs(rpos) - size;\n    return min( maxcomp(di), length(max(di,0.0)) );\n}\n\nfloat getDistanceBoxRounded( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat getDistanceTorusS(vec3 rpos,float r1,float r2)\n{\n    vec3 ptor = normalize(vec3(rpos.xy,0))*r1;\n    return length(rpos-ptor)-r2;\n}\n\nfloat getDistanceSphereS(vec3 pos, float r)\n{\n    return length(pos)-r;\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v );\n}\n\n#define WheelFR vec3( 0.8, 1.2,-0.1)\n#define WheelFL vec3(-0.8, 1.2,-0.1)\n#define WheelBR vec3( 0.8,-1.2,-0.1)\n#define WheelBL vec3(-0.8,-1.2,-0.1)\n#define WheelRadius 0.45\n#define ObjBoundRadius 3.5\n\nfloat distCar(vec3 pos, float steeringAngle)\n{\n    //return vec4(length(pos)-ObjBoundRadius*0.5,0,0,0);\n    if(dot(pos,pos)>ObjBoundRadius*ObjBoundRadius) return length(pos)-ObjBoundRadius*0.5;\n    float dist = 100000.0;\n    vec4 q = vec4(0,sin(steeringAngle*0.5),0,cos(steeringAngle*0.5));\n    dist = min(dist, getDistanceBoxRounded(pos-vec3(0.0, 0.0,0.3),vec3(0.8-0.1, 1.8-0.1,0.35-0.1),0.1));\n    dist = smin2(dist, getDistanceBoxRounded(pos-vec3(0.0,-0.5,0.7),vec3(0.75-0.15,1.1-0.15,0.5-0.15),0.15),10.0);\n    dist = max(dist, -getDistanceSphereS((pos-WheelFL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelFR).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBL).yzx,WheelRadius*1.2));\n    dist = max(dist, -getDistanceSphereS((pos-WheelBR).yzx,WheelRadius*1.2));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFR).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS(transformVecByQuat((pos-WheelFL).yzx,q),WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBR).yzx,WheelRadius-0.15,0.15));\n    dist = min(dist, getDistanceTorusS((pos-WheelBL).yzx,WheelRadius-0.15,0.15));\n    return dist;\n}\n\nfloat getDistance(vec3 pos)\n{\n    vec3 npos=getNeedlePos();\n    float d=distCone((pos-npos)*vec3(1,1,-1),0.02,0.003);\n    d=max(d,pos.z-npos.z-0.004);\n#ifndef SHOW_CAR\n    d=min(d,distCyl2(pos,npos+vec3(0,0,0.01),vec3(0.05,Arm,0.01),0.003));\n    d=min(d,distCyl(pos-npos-vec3(0,0,0.0065),0.002,0.0015));\n#else\n    d=min(d,distCar((pos-npos-vec3(0,0,0.001))*400.,-0.2)/400.);\n#endif\n    float d2;\n    pos=rotatePos(pos);\n    float ph2=atan(pos.y,pos.x);\n    pos.z+=ZEier*sin(2.*ph2)*length(pos.xy);\n    d2= max( distCyl(pos-vec3(0,0,-.5*Thick),LPRadius,.5*Thick),\n        \t   -distCyl(pos-vec3(0),HoleR,.1));\n    d=min(d,d2);\n    return d;\n}\n\nvec3 getGrad(vec3 pos, float delta)\n{\n    vec3 eps=vec3(delta,0,0);\n    return vec3 (\n                 getDistance( pos+eps.xyy )-getDistance( pos-eps.xyy ),\n                 getDistance( pos+eps.yxy )-getDistance( pos-eps.yxy ),\n                 getDistance( pos+eps.yyx )-getDistance( pos-eps.yyx )\n                );\n}\n\nfloat getTimeOnDisc(vec2 pos)\n{\n\tfloat d=PlayWidth/(Umin*PlayTime);\n\treturn (-atan(pos.y,pos.x)/PI2+floor((LPRadius-Blank-length(pos.xy))/d+.5))*60./Umin;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir, out vec3 rpos, out vec3 rdir, out float rstr, vec3 defCol)\n{\n    rdir=vec3(0,0,1); rstr=0.; rpos=pos;\n    vec3 eye=pos;\n    float eps=1.e-7; // 1 micrometer\n    float d=0.;\n    float dd=0.;\n    for(int i=0;i<1050;i++)\n    {\n        dd=getDistance(pos+d*dir);\n        d+=0.7*dd;\n        if(dd<eps) break;\n        if(d>1.3) break;\n    }\n    if(dd>eps) \n    {\n        return defCol;\n    }\n    pos+=d*dir;\n    vec3 n=normalize(getGrad(pos,eps));\n    vec3 opos=pos;\n    pos=rotatePos(pos);\n    d=PlayWidth/(Umin*PlayTime);\n    \n    float lpos=length(pos.xy);\n    \n    float t=getTimeOnDisc(pos.xy);\n\n    float fr=fract(-atan(opos.y,opos.x)/PI2+(LPRadius-Blank-length(opos.xy))/d+.5);\n    \n    float songMask=1.;\n    if(lpos>LPRadius-Blank) songMask=0.;\n    if(lpos<0.063) songMask=0.;\n    if(pos.z<0.001)\n    \tn.xy+=3.*max(.8-abs(fr-.5)*2.,0.)*normalize(opos.xy)*(.1*songMask+mainSound(0,t).x);\n\n    n=normalize(n);\n    vec3 diffCol=vec3(0.0);\n    vec3 light = vec3(-2.6,2.1,2.)*10.1;\n    light = vec3(0.3,0.3,1)*10.1;\n    float diff=max(dot(n,normalize(light-opos)),0.5);\n    float spec=max(dot(normalize(reflect(opos-eye,n)),normalize(light-opos)),0.);\n    float shin=0.;\n    if( lpos>Sticker+.003 && lpos<0.063 ) \n    {\n        if(abs(lpos-(Sticker+.003-atan(pos.y,pos.x)*0.002))<.0001)\n        \tn=normalize(n+2.0*vec3(opos.xy,0));\n        if(abs(lpos-(Sticker+.003-(atan(pos.y,pos.x)-PI2)*0.002))<.0001)\n        \tn=normalize(n+2.0*vec3(opos.xy,0));\n        if(abs(lpos-(Sticker+.003))<.0001)\n        \tn=normalize(n+2.0*vec3(opos.xy,0));\n    }\n    if( lpos<Sticker && lpos>HoleR+.0001 )         \n    {\n        diffCol=0.3*texture(iChannel0, pos.xy/0.06+vec2(0.5)).xyz;\n        diffCol=texture(iChannel3, (pos.xy/0.09+vec2(0.5))*vec2(100.)/iChannelResolution[3].xy).xyz;\n    \tspec=pow(spec,2.)*.5;\n        shin=0.3;\n        if(lpos>Sticker-0.0003) n=normalize(n+5.0*vec3(opos.xy,0));\n    }\n    else\n    {\n    \tspec=pow(spec,16.);\n        shin=1.0;\n    }\n    float fresnel=1.0-max(.0,dot(normalize(eye-opos),n));\n    fresnel=pow(fresnel,4.);\n    fresnel=0.94*fresnel+0.06;\n    \n    vec3 col= diffCol*diff+0.4*spec;\n    \n    rpos=opos;\n    rdir=reflect(dir,n);\n    rstr=fresnel;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=iTime;\n    vec3 fwd   = normalize(vec3(-1.,.3,-1.0));\n\tvec3 pos = getNeedlePos()*vec3(1,1,0.95)+vec3(0,-0.007,0);\n    fwd=rotateZ(fwd,iMouse.x/iResolution.x+.02);\n    pos=rotateZ(pos,iMouse.x/iResolution.x+.02);\n    float zoomOut=0.005+t*t/230./230.;\n    zoomOut=min(0.23,zoomOut);\n    zoomOut+=0.25*iMouse.y/iResolution.y*iMouse.y/iResolution.y;\n    if(iFrame<5 && iResolution.x<300.) \n    {\n        zoomOut=.15;\n        //fwd=normalize(vec3(-1,2.,-1.));\n    }\n    pos=mix(pos,vec3(0),zoomOut/0.35)-fwd*zoomOut;\n    vec3 right = normalize(vec3(fwd.yx*vec2(1,-1),0));\n    vec3 up    = cross(right,fwd);\n    float x = (fragCoord-.5*iResolution.xy).x/iResolution.x;\n    float y = (fragCoord-.5*iResolution.xy).y/iResolution.x;\n    float z = 1.0;\n    vec3 dir = normalize(right*x+up*y+fwd*z);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rdir,rpos;\n    float rstr;\n    vec3 rdir2,rpos2;\n    float rstr2;\n\tvec3 defCol = vec3(0.6,0.57,0.54);\n    vec3 col = raymarch(pos,dir,rpos,rdir,rstr,defCol);\n    if(rstr>0.0001) \n\t{\n\t    vec3 defCol = mix(\n              texture(iChannel1,rdir.xzy*vec3(1,-1,-1),0.).xyz*3.,\n        \t  texture(iChannel2,rdir.xzy*vec3(1,-1,-1),0.).xyz*2.,\n        \t  clamp(dot(pos,pos)/0.3/0.3,0.,1.)\n    \t\t);\n\t    col+=rstr*raymarch(rpos+rdir*.00001,rdir,rpos2,rdir2,rstr2,defCol);\n        rdir=rdir2;\n        rpos=rpos2;\n        rstr=rstr2;\n    }\n    vec2 c=2.*(fragCoord.xy-.5*iResolution.xy)/iResolution.xy;\n\tfloat vign= cos(0.75*length(c));\n    vign*=0.5+0.5*(1.-pow(c.x*c.x,16.))*(1.-pow(c.y*c.y,16.));\n    fragColor.xyz = col*vec3(vign);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// [SH16B] 45 rpm - my entry to the contest\n\n//--------------------------------------------------------------------------\n// sound\n//--------------------------------------------------------------------------\n\n// john carpenters epic movie theme song \"assault on precinct 13\"\n\n#define T 2.7\n#define HT 1.059463094\n#define A4 (440.)\n#define B4 (440.*HT*HT)\n#define C4 (440.*HT*HT*HT)\n#define D4 (440.*HT*HT*HT*HT*HT)\n#define E4 (440.*HT*HT*HT*HT*HT*HT*HT)\n#define F4 (440.*HT*HT*HT*HT*HT*HT*HT*HT)\n#define G4 (440.*HT*HT*HT*HT*HT*HT*HT*HT*HT*HT)\n\n#define A0 (A4/16.)\n#define B0 (B4/16.)\n#define C0 (C4/16.)\n#define D0 (D4/16.)\n#define E0 (E4/16.)\n#define F0 (F4/16.)\n#define G0 (G4/16.)\n\n#define A1 (A4/8.)\n#define B1 (B4/8.)\n#define C1 (C4/8.)\n#define D1 (D4/8.)\n#define E1 (E4/8.)\n#define F1 (F4/8.)\n#define G1 (G4/8.)\n\n#define A2 (A4/4.)\n#define B2 (B4/4.)\n#define C2 (C4/4.)\n#define D2 (D4/4.)\n#define E2 (E4/4.)\n#define F2 (F4/4.)\n#define G2 (G4/4.)\n\n#define A3 (A4/2.)\n#define B3 (B4/2.)\n#define C3 (C4/2.)\n#define D3 (D4/2.)\n#define E3 (E4/2.)\n#define F3 (F4/2.)\n#define G3 (G4/2.)\n\n#define A5 (A4*2.)\n#define B5 (B4*2.)\n#define C5 (C4*2.)\n#define D5 (D4*2.)\n#define E5 (E4*2.)\n#define F5 (F4*2.)\n#define G5 (G4*2.)\n\nfloat rand(float x){\n    //return 2.0*(texture(iChannel0,vec2(x*44000.0+0.5,0.5)/iChannelResolution[0].xy).x-0.5);\n    return fract(sin(mod(x*10.0,10.0)*12.9898)*43758.5453)*2.0-1.0;\n}\n\nvec2 boing(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 1.0*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.6*sin(6.2831*(1.975*f*t+ph))\n                    +0.3*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*(exp(-8.0*t)+0.1*exp(-t*3.0)),-1.,1.)\n    );\n}\n\nvec2 brumm(float f, float t, float ph)\n{\n    if(t<0.0) return vec2(0.);\n\tfloat a = 50.0*( 0.6*sin(6.2831*(1.0  *f*t+ph))\n\t                +0.8*sin(6.2831*(1.975*f*t+ph))\n                    +0.4*sin(6.2831*(4.0  *f*t+ph))\n                   );\n\n    return vec2(\n        clamp(a*exp(-1.0*t),-1.,1.)\n    );\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(x));\n}\n\nvec2 bbbbb(float f1, float f2, float t)\n{\n    // X       X       X       X\n    // a _ a a c a\n    return \n    \t  boing(f1,t-T*0./16.,.0)*fermi((t-T*2./16.)/0.01)\n        + boing(f1,t-T*2./16.,.0)*fermi((t-T*3./16.)/0.01)\n        + boing(f1,t-T*3./16.,.0)*fermi((t-T*4./16.)/0.01)\n        + boing(f2,t-T*4./16.,.4)*fermi((t-T*5./16.)/0.01)\n        + boing(f1,t-T*5./16.,.0);\n}\n\nvec2 tich(float f,float t)\n{\n    float c=0.;\n    float a=0.;\n    for( int i=-512; i<512; i++ )\n    { \n        float t2=float(i)/44000.0;\n        float w=float(128)/44000.0;\n        w=1.0/f;\n        float s=exp(-t2*t2/w/w)*t2/w;\n        //a+=rand(t-t2)*cos(-6.2831*f*(t-t2))*s; c+=s; \n        a+=rand(t-t2)*s; c+=s*s;\n    }\n    a/=sqrt(c);\n    //a=rand(t);\n    a*=(0.5+0.5*sin(2300.*t))*(0.8+0.2*sin(800.*t))*exp(-25.0*mod(t,T/16.));\n    return 1.0*vec2(clamp(a,-1.0,1.0));\n}\n\nvec2 bumm(float f,float t)\n{\n    if(t<0.0) return vec2(0.);\n    return 2.0*vec2(sin(6.2831*f*t)*exp(-18.0*t));\n}\n\nfloat feep(float f1, float f2,float t)\n{\n \tfloat a=clamp(sin(f1*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n \treturn clamp(a*exp(0.5*t-4.0)*(fermi((t-T*3.5)/T/0.15)),-1.0,1.0);\n}\n\n// iq's polynomial smooth min function\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat feep2Map(float t)\n{\n    return smin(t,0.689*(t-T*(3.5+0.05))+T*(3.5-0.05),0.3);\n}\n\nfloat chordMaj(float f, float oct, float t) // FIXME: not really a major chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nfloat chordMin(float f, float oct, float t) // FIXME: not really a minor chord yet\n{\n    f*=6.2831*pow(2.0,oct);\n    float a=(sin(f*t)+sin(3./2.*f*t)+sin(5./4.*f*t))+0.15*rand(t);\n \ta=clamp(sin(f*t+1.5*sin(35.0*t)+8.0*sin(6.0*t))*2.0+0.15*rand(t),-1.0,1.0);\n    //a=clamp(a*0.3,-1.0,1.0);\n    return a*exp(-t/3.0);\n}\n\nvec2 mainSound( in int samp, float t )\n{\n    if(t<0.) return vec2(0.);\n    //t+=T*4.*3.0;\n    vec2 boingLine = \n         bbbbb(A1,C1,mod(t-T*0.,T*4.))\n        +bbbbb(C1,E1,mod(t-T*1.,T*4.))\n        +bbbbb(G0,G0,mod(t-T*2.,T*4.))\n        +bbbbb(A1,C1,mod(t-T*3.,T*4.));\n    if(t<T*4.) boingLine=vec2(0);\n    vec2 tichLine = tich(20000.0*sin(3.435346/T*6.2831*t),mod(t,T*4.0));\n    //tichLine*=dot(tichLine,tichLine);\n    //return tichLine*0.2;\n    vec2 bummLine = \n         bumm(50.,mod(t-T/8.*0.,T))\n        +bumm(50.,mod(t-T/8.*1.,T))\n        +bumm(70.,mod(t-T/8.*2.,T))\n        +bumm(50.,mod(t-T/8.*4.,T));\n    vec2 brummLine = vec2(\n         brumm(A1,mod(t-T*0.,T*4.),0.)\n        +brumm(C1,mod(t-T*1.,T*4.),0.)\n        +brumm(G0,mod(t-T*2.,T*4.),0.)\n        +brumm(A1,mod(t-T*3.,T*4.),0.)\n        );\n    if(t<T*4.*3.0) brummLine=vec2(0);\n    vec2 feepLine = vec2(feep(8100.,0.0,mod(t,T*4.)));\n    //return feepLine;\n    if(t<T*4.*3.0) feepLine=vec2(0);\n    if(t>T*4.*4.0) feepLine=vec2(0);\n    vec2 feepLine2 = vec2(feep(8100.,0.0,feep2Map(mod(t,T*4.))));\n    //return feepLine2;\n    if(t<T*4.*4.0) feepLine2=vec2(0);\n    if(t>T*4.*5.0) feepLine2=vec2(0);\n    vec2 chordLine = vec2(\n         chordMin(A0,5.,mod(t-T*0.,T*4.))\n        +chordMaj(C0,5.,mod(t-T*1.,T*4.))\n        +chordMaj(G0,4.,mod(t-T*2.,T*4.))\n        +chordMin(A0,5.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*5.0) chordLine=vec2(0);\n    if(t>T*4.*7.0) chordLine=vec2(0);\n    vec2 chordLine2 = vec2(\n         chordMin(A0,6.,mod(t-T*0.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*1.,T*4.))\n        +chordMaj(A0,6.,mod(t-T*2.,T*4.))\n        +chordMaj(G0,5.,mod(t-T*2.5,T*4.))\n        +chordMin(A0,6.,mod(t-T*3.,T*4.))\n    );\n    if(t<T*4.*7.0) chordLine2=vec2(0);\n    if(t>T*4.*9.5) chordLine2=vec2(0);\n    if(t>T*4.*9.0) boingLine=vec2(0);\n    if(t>T*4.*10.0) brummLine=vec2(0);\n    if(t>T*4.*11.0) tichLine=vec2(0);\n    if(t>T*4.*11.0) bummLine=vec2(0);\n    //if(t>T*4.*10.0) brummLine=vec2(0);\n    //return chordLine2;\n    return (\n         boingLine*.2\n        +tichLine *.12\n        +bummLine *.6\n        +brummLine*.2\n        +feepLine *.3\n        +feepLine2 *.3\n        +chordLine *.12\n        +chordLine2 *.12 )*0.5\n        ;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 38
                    }
                ],
                "type": "sound"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// [SH16B] 45 rpm - my entry to the contest\n\n//--------------------------------------------------------------------------\n// Record Title-Sticker\n//--------------------------------------------------------------------------\n\n\nint getDigitMask(int d)\n{\n    if(d==0x0) return 0x00EAAAE;\n    if(d==0x1) return 0x004C444;\n    if(d==0x2) return 0x00E2E8E;\n    if(d==0x3) return 0x00E2E2E;\n    if(d==0x4) return 0x00AAE22;\n    if(d==0x5) return 0x00E8E2E;\n    if(d==0x6) return 0x00E8EAE;\n    if(d==0x7) return 0x00E2222;\n    if(d==0x8) return 0x00EAEAE;\n    if(d==0x9) return 0x00EAE2E;\n    if(d==0xa) return 0x004AAEA;\n    if(d==0xb) return 0x00CACAC;\n    if(d==0xc) return 0x0068886;\n    if(d==0xd) return 0x00CAAAC;\n    if(d==0xe) return 0x00E8C8E;\n    if(d==0xf) return 0x00E8C88;\n    return -1;\n}\n\n\n#define O_ 0x10\n#define I_ 0x11\n#define Z_ 0x12\n#define M_ 0x13\n#define H_ 0x14\n#define S_ 0x15\n#define G_ 0x16\n#define L_ 0x17\n#define X_ 0x18\n#define Q_ 0x19\n#define A_ 0x1A\n#define B_ 0x1B\n#define C_ 0x1C\n#define D_ 0x1D\n#define E_ 0x1E\n#define F_ 0x1F\n#define J_ 0x21\n#define N_ 0x22\n#define W_ 0x23\n#define K_ 0x24\n#define U_ 0x25\n#define P_ 0x26\n#define V_ 0x27\n#define T_ 0x28\n#define Y_ 0x29\n#define R_ 0x2A\n#define dot_ 0x30\n#define dot2_ 0x31\n#define space_ 0x32\n#define minus_ 0x33\n\nint getLetterMask(int d)\n{\n    if(d==O_) return 0x004AAA4; // O\n    if(d==I_) return 0x00E444E; // I\n    if(d==Z_) return 0x00E248E; // Z\n    if(d==M_) return 0x00AEEAA; // M\n    if(d==H_) return 0x00AAEAA; // H\n    if(d==S_) return 0x00E8E2E; // S\n    if(d==G_) return 0x00E8AAE; // G\n    if(d==L_) return 0x008888E; // L\n    if(d==X_) return 0x00EAEAE; // X\n    if(d==Q_) return 0x004AAA6; // q\n    if(d==A_) return 0x004AAEA; // A\n    if(d==B_) return 0x00CACAC; // B\n    if(d==C_) return 0x0068886; // C\n    if(d==D_) return 0x00CAAAC; // D\n    if(d==E_) return 0x00E8C8E; // E\n    if(d==F_) return 0x00E8C88; // F\n    if(d==J_) return 0x00E222C; // J\n    if(d==N_) return 0x00CAAAA; // N\n    if(d==W_) return 0x00AAEEA; // W\n    if(d==K_) return 0x00AACAA; // K\n    if(d==U_) return 0x00AAAAE; // U\n    if(d==P_) return 0x00CAAC8; // P\n    if(d==V_) return 0x00AAAA4; // V\n    if(d==T_) return 0x00E4444; // T\n    if(d==Y_) return 0x00AAE44; // Y\n    if(d==R_) return 0x00CAACA; // R\n    if(d==dot_) return 0x0000004; // .\n    if(d==dot2_) return 0x0004004; // :\n    if(d==space_) return 0x0000000; // _\n    if(d==minus_) return 0x0000E00; // _\n    return getDigitMask(d);\n}\n\n\nvoid drawLetter(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getLetterMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nvoid drawText(mat4 str, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    for(int i=0;i<4;i++)\n    {\n        bool breakIt=false;\n        for(int j=0;j<4;j++)\n        {\n            if(int(str[i][j])<0) { breakIt=true; break; }\n            drawLetter(int(str[i][j]),pos+size*vec2(4.0*float(i*4+j),0),size,fragColor,fragCoord);\n        }\n        if(breakIt) break;\n    }\n}\n\nvoid drawDigit(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord)\n{\n    int m = getDigitMask(n);\n    int j=int((fragCoord-pos).y/size);\n    int i=int((fragCoord-pos).x/size);\n    if(i>=0 && i<4 && j>=0 && j<6)\n        //if(((m>>(4*j-i))&1)==1) fragColor=vec4(1);\n        if(int(mod(float(m)/pow(2.0,float(4*j-i)),2.0))==1) fragColor=vec4(1);\n}\n\nint getDigit(int n, int d)\n{\n    return int(mod(float(n)/pow(10.0,float(d)),10.0));\n}\n\nint getDigitF(float f, int d)\n{\n    if(d<0) return int(mod(f/pow(0.1,float(-d)),10.0));\n    return int(mod(f/pow(10.0,float(d)),10.0));\n}\n\nvoid drawInt(int n, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    for(int i=0;i<100;i++) { if(n2-1>=n) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        if(i==dn) break;\n        drawDigit(getDigit(n,dn-1-i), pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\n\nvoid drawFloat(float f, int dotnum, vec2 pos, float size, inout vec4 fragColor, vec2 fragCoord )\n{\n    int n2 = 10;\n    int dn=0;\n    if(f<0.0) { f=-f; drawLetter(minus_, pos, size, fragColor, fragCoord); pos+=vec2(4.0*size,0); }\n    for(int i=0;i<100;i++) { if(float(n2-1)>=f) {dn=i+1; break;} n2*=10; }\n    for(int i=0;i<100;i++)\n    {\n        int d;\n        if      (i<dn)  d=getDigitF(f,dn-1-i);\n        else if (i==dn) d=dot_;\n        else if (i>dn)  d=getDigitF(f,dn-1-i+1);\n        if(i==dn+dotnum+1) break;\n        drawLetter(d, pos, size, fragColor, fragCoord );\n        pos+=vec2(4.0*size,0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col;\n    vec2 coord;\n    coord = fragCoord;\n    col=vec4(0.3,0,0,0);\n    if(fragCoord.x>100. || fragCoord.y>100.) discard;\n    drawText(mat4(F_,L_,O_,C_, K_,A_,R_,O_, O_,-1,0,0, 0,0,0,0),           vec2(32., 82.), 1., col,coord);\n    drawText(mat4(V_,I_,R_,T_, U_,A_,L_,space_, R_,E_,C_,O_, R_,D_,S_,-1), vec2(18., 74.), 1., col,coord);\n    drawText(mat4(A_,S_,S_,A_, U_,L_,T_,space_, O_,N_,-1,0, 0,0,0,0),      vec2(28., 19.), 1., col,coord);\n    drawText(mat4(P_,R_,E_,C_, I_,N_,C_,T_,space_,1,3,-1, 0,0,0,0),        vec2(26., 11.), 1., col,coord);\n\n    if(fragCoord.x>100. || fragCoord.y>100.) col=vec4(0.5);\n \n    //fragColor = vec4(0.0,0.0,1.0,1.0);\n    fragColor=col;\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}