{
    "Shader": {
        "info": {
            "date": "1712955681",
            "description": "restoring \"Solution-Limited Aggregation\" stb shader ( was 47 likes )",
            "flags": 48,
            "hasliked": 0,
            "id": "4cy3zV",
            "likes": 26,
            "name": "[stb] Solution-Limited Aggregati",
            "published": 3,
            "tags": [
                "stb"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "/*\n    Solution-Limited Aggregation\n    Dec. 2017 stb\n    License: Do what you want with my code: it's free :)\n\n\tThis technique probably has an actual name, but oh well.\n\n    Buf A: where the real work is done\n    Image (this file): post processing\n\n\tThe premise: there is a crystal seed and a \"chemical\" solution. When the solution\n\tcomes into contact with the seed, the seed will grow and the solution will diminish in\n\ta (somewhat) proportionate manner. The solution diffuses over time (it's blurred), and\n\tmay have noise added.\n\n\tMore comments in Buf A. Try out some of the suggestions for different effects!\n\n\tUpdate 1: Changed iTime to iFrame in Buffer A. Should work much better with a higher\n\tnumber of paint calls (e.g. using a Chrome extension or a java hack).\n*/\n\n#define res iResolution.xy\n\nfloat map(vec2 p) {\n    return 2. * texture(iChannel0, p).r;\n}\n\nvec3 getNorm(vec2 p) {\n    vec3 acc = vec3(-1., 0., 1.);\n    return\n        normalize(\n            vec3(\n                map(p+acc.zy/res) - map(p+acc.xy/res),\n            \tmap(p+acc.yz/res) - map(p+acc.yx/res),\n            \tacc.z\n\t\t\t)\n\t\t);\n}\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 uv = fc.xy / res;\n    vec3 asp = vec3(1., res.y/res.x, 1.);\n    \n    vec3 norm = getNorm(uv);\n    vec3 p = vec3(uv, 0.);\n    vec3 light = vec3(iMouse.xy/res, -.25);\n    \n    float diff = clamp(dot(normalize(asp*(p-light)), norm), 0., 1.);\n    \n    vec3 ref = reflect(vec3(p.xy-.5, 1.), norm);\n    float spec = pow(clamp(dot(normalize(ref), normalize(asp*(light-p))), 0., 1.), 4.);\n    \n    float f = map(uv);\n    \n    float mask = clamp(smoothstep(0., .3, f), 0.5, 1.);\n    \n    f = .1 * f; // ambient\n    f += .35 * pow(diff, 2.) * mask; // diffuse\n    f += .75 * spec * mask; // specular highlight\n    \n    fo = vec4(f+vec3(0., texture(iChannel0, uv).g, 0.), 1.);\n    \n    // view only the channels\n    //fo = vec4(texture(iChannel0, uv).rg, 0., 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool keyPressed(float k) {\n    return (texture(iChannel3, vec2(k, .2)).r>0.);\n}\n\n#define tx(o) texture(iChannel0, fract(uv+o/res))\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n    vec2 res = iResolution.xy, uv = fc / res;\n    \n    float C, S;\n    \n    // first frame crystal and solution values\n    if(iFrame==0 || keyPressed(82.5/256.)) {\n        C = floor(fc)==floor(res/2.) ? 1. : 0.;\n\t\tS = .25;\n    }\n    \n    // simulation\n    else {\n        \n        vec3 o = vec3(-1., 0., 1.);\n        \n        // this texture array makes it easier to play with different scenarios\n        vec4 t[9];\n        t[0] = tx(o.yy); // center\n        t[1] = tx(o.xy); t[2] = tx(o.zy); t[3] = tx(o.yx); t[4] = tx(o.yz); // cardinals\n        t[5] = tx(o.xx); t[6] = tx(o.xz); t[7] = tx(o.zx); t[8] = tx(o.zz); // diagonals\n        \n        // ya\n        vec4 blur = .25*t[0] + .125*(t[1]+t[2]+t[3]+t[4]) + .0625*(t[5]+t[6]+t[7]+t[8]);\n        \n        // initial crystal & solution values for this frame\n        C = t[0].r;\n        S = blur.y;\n        \n        // uncomment one of the following if() statements\n        //if(true) { // use strict method\n        //if(false) { // use freeform method\n        if(hash12(uv+float(iFrame))>.5) { // noise-based hybrid between strict and freeform\n            \n            // Strict Method\n            \n            // assigning a few things for different tests\n            float\n                xmx = max(t[1].r, t[2].r),\n                ymx = max(t[3].r, t[4].r),\n                cmx = max(max(t[5].r, t[6].r), max(t[7].r, t[8].r)),\n                mx;\n\n            // uncomment one of the following mx assignments\n            //mx = max(xmx, ymx); // cardinal growth\n            mx = max(max(xmx, ymx), cmx); // diagonal growth\n            //mx = max(max(xmx, ymx), .75*cmx); // cardinal/diagonal hybrid\n            //mx = max(xmx, mix(ymx, cmx, .5)); // happy accident: 6-fold symmetry (best when noise is used somewhere)\n            \n        \tC += .7 * S * (mx-.0875);\n        \tS -= .345 * S * mx;\n            \n        }\n        else {\n            \n            // Freeform Method (evaluates all directions [more or less] equally)\n            \n            for(int i=1;i<9;i++) {\n                C += (t[i].x-.05) * t[0].y / 4. / (i<5 ? 1. : sqrt(2.));\n                S -= (t[i].x) * t[0].y / 9. / 1.5 / (i<5 ? 1. : sqrt(2.));\n            }\n            \n        }\n        \n        // noisiness of solution (remove for \"pure\" crystals)\n        S += .25 * S * (.5-hash12(uv+float(iFrame)*.01));\n        \n        // so things don't get out of hand...\n        C = clamp(C, 0., 1.);\n        S = clamp(S, 0., 1.);\n        \n        // suspend sim on mouse click to allow inspection when paused\n        if(iMouse.z>0.) { C = t[0].r; S = t[0].g; }\n        \n        // add seeds by holding 's' and clicking mouse\n        if(keyPressed(83.5/256.) && floor(fc)==floor(iMouse.zw)) C = 1.;\n        \n    }\n    \n    fo = vec4(C, S, 0., 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}