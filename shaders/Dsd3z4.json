{
    "Shader": {
        "info": {
            "date": "1677159389",
            "description": "Pappus's Theorem, together with associated cubic curve. Use mouse to drag red points.",
            "flags": 48,
            "hasliked": 0,
            "id": "Dsd3z4",
            "likes": 25,
            "name": "Pappus's Theorem",
            "published": 3,
            "tags": [
                "curves"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "///////////////////////////////////////////////////////////////////////\n//\n// Pappus's Theorem, mla, 2023\n//\n// Given points ABCDEF, ABC, DEF collinear, the intersections\n// X = AE.BD, Y = AF.CD, Z = BF.CE are also collinear.\n//\n// There are many proofs of this fundamental relation\n// in projective geometry. A nice one uses Bezout's\n// theorem - two cubics (which might consist of three\n// lines) have exactly nine points of intersection, and\n// the Cayley-Bacharach theorem tells us that the cubics\n// passing through eight given points also pass through\n// a ninth point.\n//\n// Thick curve is a cubic through the nine points of the configuration,\n// which is defined by the five red points which are draggable.\n//\n// Use mouse to select a point for the cubic to pass through (click\n// on left edge to go back to animation).\n//\n///////////////////////////////////////////////////////////////////////\n\n// Evaluate (L.p)(M.p)(N.p) for columns L,M,N of C, ie. the cubic\n// curve consisting of the lines L,M and N.\nfloat eval(vec3 p, mat3 C) {\n  p *= C; // Transpose multiplication = dot product with columns\n  return p.x*p.y*p.z;\n}\n\n// Evaluate cubic LMN + kPQR at p, with k chosen so the\n// curve passes through q.\nfloat cubic(vec3 p, vec3 q, mat3 C, mat3 D) {\n  float k = -eval(q,C)/eval(q,D);\n  return eval(p,C) + k*eval(p,D);\n}\n\n// Distance from projective line\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p.xy/p.z,q.xy/q.z);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    setscale();\n    vec3 p = vec3(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y,1);\n    vec4 tex = texture(iChannel0,0.25*p.xy);\n    float lwidth = 0.005*(0.5+0.5*length(tex.rgb));\n    float px = 1.2*scale*2.0/iResolution.y;\n    vec3 A = vec3(getselection(0),1);\n    vec3 B = vec3(getselection(1),1);\n    vec3 D = vec3(getselection(2),1);\n    vec3 E = vec3(getselection(3),1);\n    vec3 Y = vec3(getselection(4),1);\n    vec3 AB = cross(A,B);\n    vec3 DE = cross(D,E);\n    vec3 AE = cross(A,E);\n    vec3 BD = cross(B,D);\n    vec3 AY = cross(A,Y);\n    vec3 DY = cross(D,Y);\n    vec3 C = cross(AB,DY);\n    vec3 F = cross(DE,AY);\n    vec3 X = cross(AE,BD);\n    vec3 BF = cross(B,F);\n    vec3 CE = cross(C,E);\n    vec3 Z = cross(BF,CE);\n    vec3 XZ = cross(X,Z);\n    vec3 q = vec3(defaultselection(),1);\n    if (q.xy == vec2(0)) q = vec3(2.0*vec2(cos(0.1*PI*iTime),sin(0.1*PI*iTime)),1);\n    float d = cubic(p,q,mat3(AB,DE,XZ),mat3(BD,CE,AY));\n    d *= px/length(vec2(dFdx(d),dFdy(d)));\n    float t = d;\n    vec3 col = vec3(1,1,0.5);\n    col *= 0.75+0.25*tex.rgb;\n    //col *= 0.9+0.1*cos(100.0*t);\n    col = mix(vec3(0),col,smoothstep(0.0,px,abs(d)-4.0*lwidth));\n    if (true) {\n      float d = 1e8;\n      vec3 lcol = vec3(0);\n      // 9 lines split up into 3 cubics of 3 lines each.\n      // By construction, each cubic passes through 8 points\n      // of the configuration, and so each pass through the 9th.\n      d = min(d,line(p,AB));\n      d = min(d,line(p,DE));\n      d = min(d,line(p,XZ));\n      \n      d = min(d,line(p,AE));\n      d = min(d,line(p,BF));\n      d = min(d,line(p,DY));\n\n      d = min(d,line(p,BD));\n      d = min(d,line(p,CE));\n      d = min(d,line(p,AY));\n      col = mix(lcol,col,smoothstep(0.0,px,d-1.0*lwidth));\n    }\n    if (true){\n      float d = 1e8;\n      vec3 pcol = vec3(1,0,0);\n      d = min(d,point(p,A));\n      d = min(d,point(p,B));\n      d = min(d,point(p,D));\n      d = min(d,point(p,E));\n      d = min(d,point(p,Y));\n      float d0 = d;\n      d = min(d,point(p,C));\n      d = min(d,point(p,F));\n      d = min(d,point(p,X));\n      d = min(d,point(p,Z));\n      //d = min(d,point(p,q));\n      if (d < d0) pcol = vec3(0);\n      if (key(CHAR_C)) {\n        d0 = d;\n        d = min(d,point(p,q));\n        if (d < d0) pcol = vec3(0.5);\n      }\n      col = mix(pcol,col,smoothstep(0.0,px,abs(d-0.06)-1.0*lwidth));\n    }\n    col = pow(col,vec3(0.4545));\n    if (alert) col.r = 1.0;\n    fragColor = vec4(col, 1.0);;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 t, vec2 uv) {\n  setscale();\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  if (iFrame == 0) {\n    t = vec4(0);\n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  } else if (j == 1) {\n    if (i == 0 && iMouse.z != 0.0) t.xy = iMouse.xy;\n    if (i == 1 && iMouse.z == 0.0) t.xy = iMouse.xy;\n  } else if (j == 2 && key(i)) {\n    // Record mouse position when key pressed\n    t = vec4(iMouse.xy,0,iTime);\n  } else if (j == 3) {\n      // Cell 0 holds currently selected item, 0 = no selection\n    if (i == 0) {\n      if (t.x == 0.0 && iMouse.z > 0.0) {\n        vec2 mouse = map(iMouse.xy);\n        // No selection, but mouse now down\n        t.x = -1.0;\n        for (int i = nselections; i >= 1; i--) {\n          // Select topmost item (assume drawn 1..N)\n          vec2 p = texelFetch(iChannel2,ivec2(i,3),0).xy; // Get current state\n          if (distance(mouse,p) < scale*0.05) {\n            t.x = float(i);\n            break;\n          }\n        }\n      } else if (t.x != 0.0 && iMouse.z <= 0.0) {\n        // Clear selection if mouse up.\n        t.x = 0.0;\n      }\n      if (t.x <= 0.0 && iMouse.z > 0.0) t.zw = iMouse.x < 20.0 ? vec2(0) : map(iMouse.xy);\n    } else if (iFrame == 0 || t.w != 1234.0) {\n      t.xy = initselection(i-1); // Current coordinates\n      t.w = 1234.0;\n    } else {\n      vec4 t0 = texelFetch(iChannel2,ivec2(0,3),0); // Get current state\n      if (int(t0.x) == i && iMouse.z > 0.0) {\n        // If currently selected, copy mouse position\n        t.xy = map(iMouse.xy);\n      }\n    }\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store((key),0).x))\n#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\n#define map(screenpos) (scale*(2.0*(screenpos)-iResolution.xy)/iResolution.y)\n#define getselection(i) (texelFetch(iChannel2,ivec2((i)+1,3),0).xy)\n//#define getselected() (texelFetch(iChannel2,ivec2(0,3),0))\n#define defaultselection() (texelFetch(iChannel2,ivec2(0,3),0).zw)\n#define setscale() (scale *= exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP))))\n\nfloat scale = 2.0;\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nconst int nselections = 5;\nvec2 initselection(int i) {\n  if (i == 0) return vec2(-2,1.3);\n  if (i == 1) return vec2(0,1);\n  if (i == 2) return vec2(-2,-1.5);\n  if (i == 3) return vec2(0,-1);\n  if (i == 4) return vec2(0.25,0);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nconst int KEY_ALT = 18;\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}