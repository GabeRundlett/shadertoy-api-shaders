{
    "Shader": {
        "info": {
            "date": "1676052529",
            "description": "Compute the Lyapunov Exponents for each point, corresponding to a initial condition of the pendulum",
            "flags": 32,
            "hasliked": 0,
            "id": "dtSSWW",
            "likes": 0,
            "name": "Lyapunov Exponents for Double Pe",
            "published": 3,
            "tags": [
                "math"
            ],
            "usePreview": 0,
            "username": "epsil0n",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 col = texture(iChannel0, uv);\n\n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "precision highp float;\n\nfloat epsi = 0.001;\nfloat step = 0.001;\n\nfloat m1 = 1.;\nfloat m2 = 1.;\nfloat l1 = 1.;\nfloat l2 = 1.;\nfloat mu = 2.;\nfloat g = 9.81;\nfloat PI = 3.14155926535893972384;\n\nfloat random (vec2 st) {\n\treturn fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat ddTheta1(float Theta1, float Theta2, float dTheta1, float dTheta2){\n\treturn (g*(sin(Theta2)*cos(Theta1-Theta2)-mu*sin(Theta1))-(l2*dTheta2*dTheta2+l1*dTheta1*dTheta1*cos(Theta1-Theta2))*sin(Theta1-Theta2))/(l1*(mu-cos(Theta1-Theta2)*cos(Theta1-Theta2)));\n}\n\nfloat ddTheta2(float Theta1, float Theta2, float dTheta1, float dTheta2){\n\treturn (mu*g*(sin(Theta1)*cos(Theta1-Theta2)-sin(Theta2))+(mu*l1*dTheta1*dTheta1+l2*dTheta2*dTheta2*cos(Theta1-Theta2))*sin(Theta1-Theta2))/(l2*(mu-cos(Theta1-Theta2)*cos(Theta1-Theta2)));\n}\n\nfloat map(float x, float in_min, float in_max, float out_min, float out_max)\n{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float maxiter = map(float(iFrame), 0., 900., 0., 5000.) ;\n\tvec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n\n\n\n\tfloat x0 = map(uv.x, -1.5 * 16./9., 1.5 * 16./9., -PI, PI);\n\tfloat y0 = map(uv.y, -1.5, 1.5, -PI, PI);\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tvec2 r = vec2(1., 0.);\n\tfloat iteration = 0.;\n\tfloat xtemp = 0.0;\n\n\n\tfloat a0, b0, c0, d0;\n\tfloat a1, b1, c1, d1;\n\n\tfloat theta1_pend1, theta2_pend1;\n\tfloat dTheta1_pend1, dTheta2_pend1;\n\n\tfloat theta1_pend2, theta2_pend2;\n\tfloat dTheta1_pend2, dTheta2_pend2;\n\n\tfloat l_theta1, l_theta2;\n\n\tfloat maxLyap = 0.;\n\tfloat minLyap = 1e10;\n\n\tfloat dx, dy, dInit;\n\n\tdTheta1_pend1 = 0.;\n\tdTheta2_pend1 = 0.;\n\tdTheta1_pend2 = 0.;\n\tdTheta2_pend2 = 0.;\n\ttheta1_pend1 = map(x0, -2., 2., 0., 2. * PI);\n\ttheta2_pend1 = map(y0, -2., 2., 0., 2. * PI);\n\ttheta1_pend2 = theta1_pend1 + 0.1;\n\ttheta2_pend2 = theta2_pend1 + 0.1;\n\n\tdx = theta1_pend1 - theta1_pend2;\n\tdy = theta2_pend1 - theta2_pend2;\n\n\tdInit = sqrt(dx * dx + dy * dy);\n    \n\n\tfor (float iter = 0.; iter < maxiter; iter++){\n\t\t//First pendulum\n\t\ta0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1,        dTheta2_pend1);\n\t\ta1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1,        dTheta2_pend1);\n\t\tb0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + a0/2., dTheta2_pend1 + a1/2.);\n\t\tb1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + a0/2., dTheta2_pend1 + a1/2.);\n\t\tc0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + b0/2., dTheta2_pend1 + b1/2.);\n\t\tc1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + b0/2., dTheta2_pend1 + b1/2.);\n\t\td0 = step * ddTheta1(theta1_pend1, theta2_pend1, dTheta1_pend1 + c0,   dTheta2_pend1 + c1);\n\t\td1 = step * ddTheta2(theta1_pend1, theta2_pend1, dTheta1_pend1 + c0,   dTheta2_pend1 + c1);\n\n\t\tdTheta1_pend1 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\tdTheta2_pend1 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\ta0 = step *  dTheta1_pend1;\n\t\ta1 = step *  dTheta2_pend1;\n\t\tb0 = step * (dTheta1_pend1 + a0/2.);\n\t\tb1 = step * (dTheta2_pend1 + a1/2.);\n\t\tc0 = step * (dTheta1_pend1 + b0/2.);\n\t\tc1 = step * (dTheta2_pend1 + b1/2.);\n\t\td0 = step * (dTheta1_pend1 + c0);\n\t\td1 = step * (dTheta2_pend1 + c1);\n\n\t\ttheta1_pend1 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\ttheta2_pend1 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\t//Second pendulum\n\t\ta0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2,        dTheta2_pend2);\n\t\ta1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2,        dTheta2_pend2);\n\t\tb0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + a0/2., dTheta2_pend2 + a1/2.);\n\t\tb1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + a0/2., dTheta2_pend2 + a1/2.);\n\t\tc0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + b0/2., dTheta2_pend2 + b1/2.);\n\t\tc1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + b0/2., dTheta2_pend2 + b1/2.);\n\t\td0 = step * ddTheta1(theta1_pend2, theta2_pend2, dTheta1_pend2 + c0,   dTheta2_pend2 + c1);\n\t\td1 = step * ddTheta2(theta1_pend2, theta2_pend2, dTheta1_pend2 + c0,   dTheta2_pend2 + c1);\n\n\t\tdTheta1_pend2 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\tdTheta2_pend2 += (a1 + b1*2. + c1*2. + d1)/6.;\n\n\t\ta0 = step *  dTheta1_pend2;\n\t\ta1 = step *  dTheta2_pend2;\n\t\tb0 = step * (dTheta1_pend2 + a0/2.);\n\t\tb1 = step * (dTheta2_pend2 + a1/2.);\n\t\tc0 = step * (dTheta1_pend2 + b0/2.);\n\t\tc1 = step * (dTheta2_pend2 + b1/2.);\n\t\td0 = step * (dTheta1_pend2 + c0);\n\t\td1 = step * (dTheta2_pend2 + c1);\n\n\t\ttheta1_pend2 += (a0 + b0*2. + c0*2. + d0)/6.;\n\t\ttheta2_pend2 += (a1 + b1*2. + c1*2. + d1)/6.;\n\t}\n\n\tdx = theta1_pend1 - theta1_pend2;\n\tdy = theta2_pend1 - theta2_pend2;\n\tfloat v = 1./(maxiter) * log(sqrt(dx * dx + dy * dy)/dInit) * 64.;\n\tfragColor = vec4(v, v, v, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}