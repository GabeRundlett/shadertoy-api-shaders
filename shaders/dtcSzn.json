{
    "Shader": {
        "info": {
            "date": "1684939924",
            "description": "my first honeycomb truchet tiling",
            "flags": 0,
            "hasliked": 0,
            "id": "dtcSzn",
            "likes": 13,
            "name": "honeycomb truchet tiling",
            "published": 3,
            "tags": [
                "truchet",
                "honeycomb"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 178
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2023 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.1415926583;\n\nconst vec4 COLOR0 = vec4(0.1, 1.0, 0.2, 1.0);\nconst vec4 COLOR1 = vec4(1.0, 0.5, 0.0, 1.0);\n\nfloat d2 (vec2 x, vec2 y) { x -= y; return dot(x, x); }\nvoid honeycomb(inout vec2 u, out vec2 id) {\n    const mat2 M = mat2(2, 0, 1, sqrt(3.0)) / 2.0;\n    const vec2 A = M[0], B = M[1], O = A.yy;\n\n    id = floor(inverse(M) * u);\n    vec2 v = u - M * id;\n    float a = d2(v, O), b = d2(v, A), c = d2(v, B),\n    d = d2(v, A + B), e = min(min(min(a, b), c), d);\n    id += e == a ? O : e == b ? A : e == c ? A.yx : A.xx;\n    u = u - M * id;\n}\n\nfloat sdLine(vec2 p, vec2 a, vec2 b) {\n    vec2 x = p - a, y = b - a;\n    return length(x - clamp(dot(x, y) / dot(y, y), 0., 1.) * y);\n}\n\nvec2 vertex(int i) {\n    float t = float(i) * PI / 3.0;\n    return vec2(-sin(t), cos(t)) / sqrt(3.0);\n}\n\nfloat tile0(in vec2 U) {\n    float dist = abs(length(U - vertex(0)) - sqrt(3.0) / 6.0);\n    dist = min(dist, sdLine(U, (vertex(1) + vertex(2)) / 2.0, (vertex(4) + vertex(5)) / 2.0));\n    dist = min(dist, abs(length(U - vertex(3)) - sqrt(3.0) / 6.0));\n    return dist - sqrt(3.0) / 18.0;\n}\n\nfloat tile1(in vec2 U) {\n    float dist = 100.0;\n    for (int i = 0; i < 6; i++)\n        dist = min(dist, length(U - vertex(i)));\n    return sqrt(3.0) / 9.0 - dist;\n}\n\nfloat tile2(in vec2 U) {\n    float dist = length(U - (vertex(1) + vertex(2)) / 2.0);\n    dist = min(dist, length(U - (vertex(4) + vertex(5)) / 2.0));\n    dist = min(dist, abs(length(U - vertex(1) - vertex(2)) - sqrt(3.0) / 2.0));\n    dist = min(dist, abs(length(U - vertex(4) - vertex(5)) - sqrt(3.0) / 2.0));\n    return dist - sqrt(3.0) / 18.0;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n    U = U * 7.0 / iResolution.y + iDate.w * 0.5;\n    vec2 id;\n    honeycomb(U, id);\n\n    vec2 rand = hash22(id);\n    mat2 rot = mat2(-1, sqrt(3.0), -sqrt(3.0), -1) / 2.0;\n    if (rand.x < 1.0 / 3.0) U = rot * U;\n    if (rand.x < 2.0 / 3.0) U = rot * U;\n\n    float dist;\n    switch (int(rand.y * 3.0)) {\n        case 0: dist = tile0(U); break;\n        case 1: dist = tile1(U); break;\n        case 2: dist = tile2(U); break;\n    }\n    float d = 6.0 / iResolution.y;\n    float x = smoothstep(-d, d, dist);\n    O = mix(COLOR0, COLOR1, x);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hash without Sine https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}