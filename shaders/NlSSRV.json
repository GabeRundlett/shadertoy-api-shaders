{
    "Shader": {
        "info": {
            "date": "1628169465",
            "description": "Staff generator using noise and cellular automata, in the DawnBringer32 color palette.\n\nThe code is sloppy in places so if you have any improvements, I'd love to hear them.\n\nYou can see more staffs here:\nhttps://snoopethduckduck.itch.io/staff-maker\n",
            "flags": 32,
            "hasliked": 0,
            "id": "NlSSRV",
            "likes": 38,
            "name": "Procedural Staffs",
            "published": 3,
            "tags": [
                "generative"
            ],
            "usePreview": 0,
            "username": "SnoopethDuckDuck",
            "viewed": 845
        },
        "renderpass": [
            {
                "code": "\n// very messy!\nvec3 colorMap( int index, float v ) {\n    vec3[14] arr;\n    if (index == 0)\n        arr = vec3[] ( \n                // brown\n                vec3(69, 40, 60),\n                vec3(102, 57, 49),\n                vec3(102, 57, 49),\n                vec3(102, 57, 49),\n                vec3(143, 86, 59),\n                vec3(143, 86, 59),\n                vec3(143, 86, 59),\n                vec3(180, 123, 80),\n                vec3(180, 123, 80),\n                vec3(180, 123, 80),\n                // orange\n                vec3(223, 113, 38),\n                vec3(255, 182, 45),\n                vec3(255, 182, 45),\n                vec3(251, 242, 54)\n                );\n    else\n        arr = vec3[] ( \n                // dark blue\n                vec3(50,60,57),\n                vec3(63,63,116),\n                vec3(63,63,116),\n                vec3(63,63,116),\n                vec3(48,96,130),\n                vec3(48,96,130),\n                vec3(48,96,130),\n                vec3(91,110,225),\n                vec3(91,110,225),\n                vec3(91,110,225),\n                // light blue\n                vec3(99,155,255),\n                vec3(95,205,228),\n                vec3(213,219,252),\n                vec3(255)\n                );\n                \n    return arr[ min(14, int(14. * v)) ] / 255.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale factor to enlarge image by\n    float sf = dim.y / (iResolution.y - 64.);\n\n    // scale and centre image to screen\n    vec2 coord = ceil( sf * fragCoord + vec2(0., sf * (32. * cos(iTime)-4.)) ) ;\n    coord -= ceil(sf * 0.5 * iResolution.xy - 0.5 * dim);\n\n    float A = texelFetch( iChannel0,  ivec2(coord) , 0 ).x;\n    float B = texelFetch( iChannel1,  ivec2(coord) , 0 ).x;\n     \n    float t = 100. * B;\n\n    // fill white bits with color\n    if ( A == 1. ) {\n\n        // cos with high frequency t generates linework\n        float v = 0.5 * (1. + cos(pi * (t + 1.)));  \n    \n        // shade top lighter, bottom darker\n        v = min(1., v * (0.6 + 0.9 * coord.y / dim.y));\n\n        // shade left side darker\n        v = (coord.x <= 0.5 * dim.x - 1.) ? max(0., v - 3. / 14.) : v;\n        \n        int index = int(floor(float(iFrame) / float(reset))) % 2;\n        fragColor = vec4(colorMap(index, v), 1.);\n    }\n\n    // fill background\n    else if ( A == 0. ) {\n        vec2 uv = fragCoord / iResolution.y; \n        uv = mod(1.5 * uv + vec2(0.05 * iTime), 1.);\n        if ((uv.x > 0.5 && uv.y > 0.5) || (uv.x < 0.5 && uv.y < 0.5))\n            fragColor = vec4(48., 96., 130., 255.) / 255.;\n        else\n            fragColor = vec4(91., 110., 225., 255.) / 255.;\n        // float d = length(fragCoord / iResolution.xy - 0.5);\n        // fragColor *= 0.8 + 0.4 * (1. - d);\n    }\n    \n    // re-color outline\n    else \n        fragColor = vec4(34., 32., 52., 255.) / 255.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// IDEA:\n// instead of doing things frame by frame, use 2 buffers that read off each other,\n// each has a counter, so you can go A -> B -> A -> B etc. a fixed number of times\n// should be able to instantly generate sprites this way (hopefully)\n\nfloat random ( vec2 st ) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat Cell( in vec2 p )\n{\n    if (p.x <= dim.x && p.y <= dim.y)\n        return texelFetch(iChannel0, ivec2(p), 0 ).x;    \n    return 0.;\n}\n\nfloat CA ( vec2 px, float e ) {\n    float k = Cell(px+vec2(-1,-1)) + 1.5 * Cell(px+vec2(0,-1)) + Cell(px+vec2(1,-1))\n            + 1.5 * Cell(px+vec2(-1, 0))                 + 1.5 * Cell(px+vec2(1, 0))\n            + Cell(px+vec2(-1, 1)) + 1.5 * Cell(px+vec2(0, 1)) + Cell(px+vec2(1, 1));\n    \n    if ( e == 1. && k < 4.5 )\n        e = 0.;\n    else if ( e == 0. && k > 6. )\n        e = 1.;      \n        \n    return e;\n}\n\nfloat sumNeighbours ( vec2 px ) {\n    return Cell(px+vec2(0, -1)) + Cell(px+vec2(-1, 0)) +\n           Cell(px+vec2(0, 1))  + Cell(px+vec2(1, 0));\n}\n\nfloat prodNeighbours ( vec2 px ) {\n    return (Cell(px+vec2(0, -1)) + Cell(px+vec2(0, 1))) * \n           (Cell(px+vec2(-1, 0)) + Cell(px+vec2(1, 0)));\n}\n\nbool hasWhiteNeighbour ( vec2 px ) {   \n    return sumNeighbours(px) > 0.;\n}\n\nbool isInteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && prodNeighbours(px) >= 2.25;     \n}\n\nbool isExteriorCorner ( vec2 px, float e ) {\n    return e == 0.5 && sumNeighbours(px) == 1.;\n}\n\nbool isBlackOutlined( vec2 px, float e ) {\n    return e == 0. && sumNeighbours(px) == 2.;\n}\n\nbool wasInDiagCorner( vec2 px, float e ) {\n    // this shouldn't work but somehow it does\n    return e == 1. && prodNeighbours(px) < 2.; \n}\n\nbool isIsolated ( vec2 px ) {\n    return sumNeighbours(px) == 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n   // ivec2 px = ivec2( fragCoord );\n    vec2 px = coord;\n   \n    float e = Cell(px);\n    \n    // reset staff after a number of frames\n    int frame = iFrame % reset;\n      \n    // initial state - generate noise\n    if ( frame == 0 && coord.x <= dim.x && coord.y <= dim.y ) {\n        \n        float f = coord.y / dim.y;\n       \n        // distance from centre\n        float d = abs(0.5 * dim.x - coord.x);\n                \n        // generate noise ( more 1's at the top )\n        e = step(0.5 - (0.1 + 0.1 * random(vec2(iTime))) * (2. * f - 1.),\n                 random(vec2(d , coord.y) + iTime));\n                 \n        // centre cells are 1. ( insert a \"pole\" ) \n        // ( maybe cut out the side values? )\n        e = max(e, step(d, 1.));\n        \n        // cut off edges, so outline will work\n        e *= step(coord.x, dim.x - 2.) * step(2., coord.x) * \n             step(coord.y, dim.y - 2.) * step(2., coord.y);        \n    }\n    \n    // run cellular automata on noise\n    else if ( frame < 10 )\n        e = CA(px, e);    \n    \n    // re-insert centre cells so a \"pole\" definitely exists (lower half only)\n    else if ( frame < 11 ) {\n        e = min(1., \n            e + step(coord.y, 0.5 * dim.y) \n            * step(2., coord.y) \n            * max(e, step(abs(0.5 * dim.x - coord.x), 1.)));\n    } \n    \n    // generate outline\n    else if ( frame < 12 )\n        e = (e == 0. && hasWhiteNeighbour(px)) ? .5 : e;\n    \n    // remove interior outlines + interior (axis-aligned) corners\n    else if ( frame < 17 )\n        e = (isInteriorCorner(px, e) || isBlackOutlined(px, e)) ? 1. : e;\n    \n    // remove exterior (diagonal) corner outlines\n    else if ( frame < 18 )\n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // turn newly exposed bits into outlines\n    else if ( frame < 19)\n        e = wasInDiagCorner(px, e) ? 0.5 : e;\n    \n    // remove any corners formed from deleting diagonal corners\n    else if ( frame < 20 ) \n        e = isExteriorCorner(px, e) ? 0. : e;\n    \n    // one more for good luck ( remove pixels without any neighbours )\n    else if ( frame < 21 ) \n        e = isIsolated(px) ? 0. : e;\n        \n  fragColor = vec4(e);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ( Most of this code was stolen from iq somewhere )\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\n// generate mirrored noise\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    // uncomment iTime for a cool look\n    vec2 uv = vec2(abs(coord.x - 0.5 * dim.x), coord.y)\n            + 20. * floor(float(iFrame) / float(reset));// + iTime;\n \n\tfloat f = 0.0;\n\t\n\tuv *= 0.01;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf =  0.5000 * noise( uv ); uv = m*uv;\n    f += 0.2500 * noise( uv ); uv = m*uv;\n\tf += 0.1250 * noise( uv ); uv = m*uv;\n\tf += 0.0625 * noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5 * f;\n\n    fragColor = vec4(f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// dimensions of sprite - has to be less than screen dimensions\nconst vec2 dim = vec2(24, 80);\n\n// number of frames each sprite lasts for\nconst int reset = 120;\n\n// pie, the food we all know and love\nconst float pi = 3.14159;\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}