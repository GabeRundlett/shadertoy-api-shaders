{
    "Shader": {
        "info": {
            "date": "1500755117",
            "description": "This is a visualization of the SDF of geometry after transforming into the polar (radius, angle) domain.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdjBWm",
            "likes": 3,
            "name": "Polar SDF Visualization",
            "published": 3,
            "tags": [
                "sdf",
                "polar",
                "visulization"
            ],
            "usePreview": 0,
            "username": "culdevu",
            "viewed": 720
        },
        "renderpass": [
            {
                "code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tVisualization of a polar domain transformation of a 2D SDF.\n\n\tThe color coding is as follows:\n\t\t\n\t\twhite-blue: the shape in we're measuring the distance to\n\t\tblack lines: unit distance lines as defined below\n\t\torange curve: the set of all points that are the same distance from the shape as \n\t\t\tthe computed \"closest point in polar space\" is in the polar norm.\n\t\tred circle: the ring of all points of the above distance in the euclidean norm\n\n\tThe area coloring is described below next to the #define statement that toggles it\n\t\n\tDuring domain transformations while Sphere Tracing, you have to be careful that the\n\tdistances that you march don't violate the Lipschitz condition. More specifically, \n\tthe distances that you march can't be larger than the true distance minimum distance\n\tto the transformed object you're tracing. If they are, you risk glitchy looking models\n\tdue to rays \"jumping through\" the geometry you've defined.\n\n\tIf you transform into the space of polar coords (radius, angle) and try to apply your\n\tregular your normal SDFs to it, you want to know how far to step given the polar distance.\n\tSurprisingly, the answer is just to step the amount returned, and this is a visualization\n\tof why. The idea is that for pretty much all radii/angles, the angle measurement contributes\n\tmore euclidean distance than the radius does. This means that the closest possible distance\n\tthat the object could be is right \"above\" or \"below\" the point in polar coords.\n\n\tPlay around with it, it's kinda cool. The moral of this visualization is: keep the points\n\tyou're tracing away from the origin if you use this sort of transformation.\n\n*/\n\n// Red background is bad, blue is okay, but suboptimal. The more blue, the less optimal it is.\n// Set to 0 to turn it off.\n#define OPTIMAL_VISUALIZATION 1\n\n#define PI 3.14159\n\nvec2 screenToWorld(vec2 coord)\n{\n    return 7.5 * (2.0 * coord / iResolution.y - vec2(iResolution.x / iResolution.y, 1.0));\n}\n\n// shoutouts to the amazing tool at\n//   http://dev.thi.ng/gradients/\n// for generating these color palettes\nvec3 color(float t)\n{\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n    \n    vec3 ret = a + b * cos(2.0 * 3.14159 * (c * t + d));\n    return clamp(ret, 0.0, 1.0);\n}\n\nfloat absCircular(float t)\n{\n    float a = floor(t + 0.5);\n    return mod(abs(a - t), 1.0);\n}\n\nvec2 toPolar(vec2 p)\n{\n    return vec2(length(p), atan(p.y, p.x));\n}\n\n//-----------------------------------------------------------\n// SDF functions\n//-----------------------------------------------------------\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat fMyDisk(vec2 p, float w, float h)\n{\n    // this doesn't actually work all that well :P\n    float R = (w*w + h*h)/2.;\n    float l = length(vec2(0, R - h) + p) - R;\n    return l;\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat map(vec2 p)\n{\n    vec2 polP = toPolar(p);\n    \n    float f = 800.;\n    f = min(f, fBox2(vec2(polP.x - 4., polP.y - PI/3.), vec2(1., PI/4.)) );\n    //f = min(f, fBox2(vec2(polP.x - 6., polP.y + PI/8.), vec2(3., PI/16.)) );\n    //f = min(f, fMyDisk(vec2(polP.x - 4., polP.y - PI/4.), PI/8., 1.) );\n    //f = min(f, fBox2(vec2(p.x - 4., p.y + 2.5), vec2(1., 2.5)) );\n    \n    return f;\n}\nvec2 mapGradient(vec2 p)\n{\n    vec2 eps = vec2( 0.001, 0.0 );\n    vec2 ret;\n    ret.x = map(p + eps.xy) - map(p - eps.xy);\n    ret.y = map(p + eps.yx) - map(p - eps.yx);\n    return ret / (2. *eps.x);\n}\n\n//-----------------------------------------------------------\n// Rendering\n//-----------------------------------------------------------\nfloat func(float x, float y)\n{\n    vec2 m = screenToWorld(iMouse.xy);\n    vec2 polMouse = toPolar(m);\n    \n    vec2 polPt = toPolar(vec2(x, y));\n    \n    float R = map(m);\n    \n    return (R - length(polMouse - polPt));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = screenToWorld(iMouse.xy);\n    vec2 p = screenToWorld(fragCoord);\n    \n    vec3 final = vec3(0,0,0);\n    \n    // draw the background\n    final = color(0.3);\n    \n#if OPTIMAL_VISUALIZATION\n    float grad = length(mapGradient(p));\n    if (grad > 1.01)\n        final = mix(vec3(1,0,0), final, 0.7);\n    if (grad < 0.99)\n        final = mix(vec3(0,0,1), final, grad * 0.5 + 0.25);\n#endif\n    \n    // dark blue lines between to denote the units\n    final = mix(color(0.1), final, smoothstep(0.0, 0.03, absCircular(p.x)));\n    final = mix(color(0.1), final, smoothstep(0.0, 0.03, absCircular(p.y)));\n    \n    // main axes\n    final = mix(color(0.0), final, pow(smoothstep(0.0, 0.05, abs(p.x)), 3.0));\n    final = mix(color(0.0), final, pow(smoothstep(0.0, 0.05, abs(p.y)), 3.0));\n    \n    // Draw the actual stuff that everyone wants to see now\n    float fDist = map(p);\n    \n    // draw the object and the unit distance lines\n    if (fDist < 0.)\n        final = color(0.4);\n    final = mix(vec3(0.1), final, smoothstep(0.0, 0.05, absCircular(fDist)));\n    \n    // draw the minimum polar distance circle (measured in euclidean distance)\n    fDist = map(m);\n    if (abs(length(p - m) - fDist) < 0.05)\n        final = color(0.9);\n    \n    // draw the set of all points that are the same distance as the minimum polar distance\n    vec2 polMouse = toPolar(m);\n    vec2 polP = toPolar(p);\n    \n    float z = fDist - length(polMouse - polP);\n    final = mix(color(0.8), final, pow(smoothstep(0.0, 0.12, abs(z)), 1.0));\n    \n    fragColor = vec4(final,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}