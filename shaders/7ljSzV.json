{
    "Shader": {
        "info": {
            "date": "1628154568",
            "description": "mouse control\n",
            "flags": 0,
            "hasliked": 0,
            "id": "7ljSzV",
            "likes": 17,
            "name": "paper cut 2",
            "published": 3,
            "tags": [
                "short",
                "golf"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )             // rotation                  \nvec3 M;\n\nfloat map( vec3 q ) {\n    q.yz *= rot( .5+6.*M.y),                                 // rotations\n    q.xz *= rot( 2.-6.*M.x);\n    float t = 9.,s, a;\n // t = min(t,  abs(q.y)-.1 ),                               // floor alone\n    vec2 P = q.xz, Q;\n    P += .5*sin(P.yx/2.) + 2.*cos(P.yx/8.),                  // surface map\n    Q = mod(P+4.,8.)-4., \n    P = floor((P+4.)/8.),\n    s = mod(P.x,2.) < 1. ? Q.x-3. : Q.x+3., // try mod(P.x+P.y // flip direction. -3. for border continuity\n    P = abs(Q),\n // t = max(t, 3.-max(P.x,P.y) ),                            // square hole alone\n    a = length(q)/8.+iTime,\n    q.y -= max(P.x,P.y)<3. ? .6*s*sin(a) : 0.,\n // max(P.x,P.y)<3. && P.x > 3.*abs(cos(a)) ? t=1. : // preserve flip length\n                   t = min(t,  abs(q.y)-.05 );\n    return t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,a; //, Z=0.;\n    vec2  P;\n    vec3  R = iResolution, // e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),         // ray direction\n          p = 90./R, q;                                      // marching point along ray \n      //  M =  iMouse.xyz/R -.5,\n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(8,4,0)/1e2*cos(iTime+vec3(0,11,0));\n     \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        t=9.,\n        t = min(t, map(p)),\n        t = min(t, map(p+.5*t*D)),                           // to handle discontinuities\n        p += .5*t*D; // , Z+=t;                              // step forward = dist to obj          \n\n // O = vec4(1.6-Z/200.); return;                   // depth buffer\n    O = 1.5*(1.-O);\n // O = 2.*exp(-2.*O);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}