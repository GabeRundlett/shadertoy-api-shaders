{
    "Shader": {
        "info": {
            "date": "1381824467",
            "description": "TAB: 1 vs many. \n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\n\nstar proj = fraction of sensor pixel.\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \nAnd bright stars saturate filters.",
            "flags": 16,
            "hasliked": 0,
            "id": "XdsGWs",
            "likes": 97,
            "name": "Star PSF",
            "published": 3,
            "tags": [
                "astrophysics",
                "optics",
                "blackbody",
                "fourier",
                "planck",
                "psf"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 18024
        },
        "renderpass": [
            {
                "code": "// #### realistic display of star in Hubble images ################\n//                            Fabrice NEYRET 15 oct 2013\n// toggles:\n//    T:      tune (R)GB  vs   Planck spectrum(T)\n//    SPACE:  tune 1GB  vs RG1\n\n// see also https://www.shadertoy.com/view/Xty3zc\n//          https://www.shadertoy.com/view/tlc3zM\n\n#define NB_STARS 200\n#define PERS 1          // perspective\n\n#define SCALE 40.\nconst float star_luminosity = 1e3;\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\n#define PI 3.1415927\nvec2 FragCoord, R;\n\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\nfloat F(float x) \n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\nfloat IntPlanck(float T,float lambda1,float lambda0) \n{\n\tconst float A=1.1, B=1./1.05;\n\tfloat C0 = 0.014387770, C=C0/(B*T);\n\tT = 1.; // normalised spectrum better for display :-)\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\n}\n\n// --- Planck black body color I.spectrum(Temp) -----------------------\nvec3 Planck(float T) {\n\treturn vec3(\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\n\t\t)*1e-14;\n}\n\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \nvec3 draw_star(vec2 pos, float I) {\n\t// star out of screen\n    const float margin = .2;\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\n\t\n\tpos -= FragCoord.xy/iResolution.y; \n\t\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\n\tfloat d = length(pos)*SCALE;\n\t\n\tvec3 col, spectrum = I*star_color;\n#if 1\n\tcol = spectrum/(d*d*d);\n#else\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\n#endif\n\t\n// 2ndary mirror handles signature (assuming handles are long ellipses)\n\td = length(pos*vec2(50.,.5))*SCALE;\n\tcol += spectrum/(d*d*d);\n\td = length(pos*vec2(.5,50.))*SCALE;\n\tcol += spectrum/(d*d*d);\n\n\treturn col;\n}\n\n// --- utility functions ----------------------------------\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \n\nbool key_toggle(float ascii) { \n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \n}\n\n// --- GUI: mouse tuning ----------------------------------\nvec3 userInterface() {\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\n\tvec3 col=vec3(0.); float d;\n\tvec4 mouse = iMouse/iResolution.y;\n\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\n\t\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\n\t\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\n\tif (d<.02) col = vec3(0.,0.,1.);\n\t\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\n\t{   // ---  Plank Spectrum mode ---\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\n\t\tstar_color = Planck(T);\n\t\t// star_luminosity = pow(T,4.);\n\t} \n\telse \n\t{   // --- RGB mode ---\n\t\tstar_color.gb = mouse.xy*star_luminosity; \n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\n\t}\n\t\n\t// display the 3-filters analyzor at bottom\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\n\t\tif (uv.y<-.402) col=  vec3(\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\n\t\t)*star_color/star_luminosity;\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\n\t}\n\t\n\treturn col;\n}\n\n\n// --- main -----------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col;\n\tFragCoord = fragCoord;\n    R = iResolution.xy;\n    float t = iTime;\n    \n\t// --- tunings (color and display mode)\n\tcol = userInterface(); \n\t\n\t// --- camera\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\n\tfloat c=cos(a),s=sin(a);\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\n\t\n\t// --- display stars \n\tif(key_toggle(9.)) // 'TAB' key\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\n\telse \n\t{\n\t\t// background\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\n\t\tfloat bg = texture(iChannel1,uv).r;\n\t\tcol += .5*exp(-7.*bg);\n\n\t\t// do stars\n\t\tfor (int i=0; i<NB_STARS; i++) {\n\t\t\t// random position, intensity(=surf), temperature(->color)\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\n\t\t\tstar_color = Planck(40000.*exp(-3.*rnd(6*i+5)));\n\n\t\t\t// project to screen coords\n\t\t\tpos = pos-cam;\n\t\t\tpos.xy = m*pos.xy;\n#if PERS // perspective\n\t\t\tpos.xy /= pos.z;\n#endif\n\t\t\tif (pos.z>0.)\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\n\t\t}\n\t}\n\n\t\n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}