{
    "Shader": {
        "info": {
            "date": "1556906375",
            "description": "I'm not a big fan of the sonic the hedgehog, but something I wanted to create like this anyway.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtX3z2",
            "likes": 9,
            "name": "Flying Sonic's head",
            "published": 3,
            "tags": [
                "raymerching"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 478
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// Edge detection code from:https://www.shadertoy.com/view/MsSGD1\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define hash(h) fract(sin(h) * 43758.5453123)\n#define EDGE_WIDTH 0.045\n#define PI 3.14159265359\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-0.08;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) {\n        return val1;\n    }\n    return val2;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nvec3 sonicFaceTex(vec3 p) {\n    vec2 uv = p.xy;\n    vec3 col = vec3(0.0,0.0,1.0);\n    float eyeL = length(uv+vec2(-0.17,0.0))-0.1;\n    float eyeL2 = length(uv+vec2(-0.14,0.03))-0.09;\n    float eyeL3 = length(uv+vec2(-0.11,0.05))-0.08;\n    float eyeL4 = length(uv+vec2(-0.08,0.06))-0.07;\n    float eyeL5 = length(uv+vec2(-0.05,0.07))-0.06;\n    float eyeL6 = length(uv+vec2(-0.02,0.08))-0.04;\n    float eyeL7 = length(uv+vec2(0.00,0.08))-0.03;\n    float mouth = length(uv+vec2(-0.2,0.17))-0.025;\n    float mouth2 = length(uv+vec2(-0.17,0.18))-0.035;\n    float mouth3 = length(uv+vec2(-0.14,0.19))-0.04;\n    float mouth4 = length(uv+vec2(-0.11,0.2))-0.045;\n    float mouth5 = length(uv+vec2(-0.08,0.2))-0.05;\n    float mouth6 = length(uv+vec2(-0.05,0.2))-0.05;\n    float mouth7 = length(uv+vec2(-0.02,0.2))-0.05;\n    float nose = length(uv+vec2(0.00,0.16))-0.02;\n    \n    uv.y*=0.6;\n    float eyeball = dot(uv+vec2(-0.17,-0.01),uv+vec2(-0.17,-0.01))*20.0;\n    uv = p.xy;\n    float eyeball2 = dot(uv+vec2(-0.17,-0.03),uv+vec2(-0.17,-0.03))*50.0;\n    uv.y*=0.6;\n    float eyeball3 = dot(uv+vec2(-0.17,-0.01),uv+vec2(-0.17,-0.01))*10.0;\n    \n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL2) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL3) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL4) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL5) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL6) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeL7) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth2) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth3) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth4) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth5) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth6) );\n    col = mix( col, vec3(1.0,0.8,0.2), 1.0-smoothstep(0.01,0.015,mouth7) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,nose) );\n    col = mix( col, vec3(0.2,1.0,0.2), 1.0-smoothstep(0.01,0.015,eyeball3) );\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.01,0.015,eyeball) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.01,0.015,eyeball2) );\n    \n\n    col = (p.z>0.01)? col:vec3(0.0,0.0,1.0);\n    \n    return col;\n}\n\nvec4 sdSonic(vec3 p) {\n    vec3 uv = p;\n    float sonicD = sdRoundCone((p+vec3(0.0,0.15,0.0))*matRotateX(radians(120.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.45);\n    float sonicD2 = sdRoundCone((p+vec3(0.0,0.0,0.0))*matRotateX(radians(90.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.5);\n    float sonicD3 = sdRoundCone((p+vec3(0.0,-0.15,0.0))*matRotateX(radians(70.0+sin(iTime*6.0)*20.0)),0.15,0.03,0.3);\n    float sonicF = length(p+vec3(0.0,0.0,-0.15))-0.35;\n    p.x = abs(p.x);\n    float ears = sdRoundCone((p+vec3(-0.2,-0.17,-0.2))*matRotateZ(radians(20.0)),0.1,0.02,0.2);\n\n    float sonicD4 = sdRoundCone((p+vec3(-0.2,-0.1,0.0))*matRotateX(radians(70.0+sin(iTime*5.9993)*20.0))*matRotateZ(radians(30.0)),0.15,0.03,0.5);\n    float sonicD5 = sdRoundCone((p+vec3(-0.2,0.1,0.0))*matRotateX(radians(120.0+sin(iTime*5.9993)*20.0))*matRotateZ(radians(30.0)),0.15,0.03,0.5);\n    \n    uv.x = abs(uv.x);\n    vec4 sonic = vec4(sonicFaceTex(uv),min(min(min(min(min(min(sonicD,sonicD2),sonicD3),sonicF),ears),sonicD4),sonicD5));\n\treturn sonic;\n}\n\nvec3 floorTex(vec2 uv) {\n    \n    vec3 colA = vec3(0.9,0.6,0.0);\n    vec3 colB = vec3(0.8,0.4,0.0);\n    vec3 col = vec3(mix(colA,colB,mod((floor(uv.x*5.0) + floor(uv.y*5.0))*0.5, 2.0)));\n    \n    float w = 0.7;\n    col = (uv.x>=-w && uv.x< w)? vec3(0.6,0.9,0.6):col;\n    \n    return col;\n}\n\nvec4 map(vec3 p){    \n    vec3 pref = p;\n    vec2 uv = p.xy;\n    \n    vec3 spPos = vec3(0.0);\n   \n    float sdist = 2.1;\n    float srotVal = radians((iTime*60.0));\n\tfloat sy = spPos.y+cos(srotVal)*(sdist);\n    float sz = spPos.z+sin(srotVal)*(sdist);\n    \n\tfloat sdeg = (atan(sy,sz)*180.0/PI);\n    vec3 sonicPos = (p+vec3(0.0,sy,sz))*matRotateX(radians(45.0+sdeg));\n    vec4 sonic = sdSonic(sonicPos);\n    vec4 sp = vec4(floorTex(uv),length((p+spPos))-1.5);\n    \n    float numCoin = 10.0;\n    float deg = 360.0/numCoin;\n    vec4 coin = vec4(1.0,1.0,0.0,1.0);\n    \n    float coinD = 8.0;\n    for(float i = 0.0; i<numCoin; i+=1.0) {\n        float rotVal = radians(i*deg);\n        mat3 m = matRotateX(rotVal);\n        mat3 mrot = matRotateZ(rotVal*iTime*0.3);\n        float cdist = 1.9;\n        float y = spPos.y+cos(rotVal)*(cdist);\n        float z = spPos.z+sin(rotVal)*(cdist);\n        vec3 coinPos = (p+vec3(spPos.x,z,y))*m*mrot;\n        coinD = min(coinD,sdTorus(coinPos,vec2(0.15,0.03)));\n        coin = vec4(1.0,1.0,0.0,coinD);\n    }\n    \n    return combine(combine(sp,coin),sonic);\n}\n\nvec3 normalMap(vec3 p){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n        map(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n        map(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n    ));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = map(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\n// from simon green and others\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 4;\n    const float delta = 0.15;\n\n    float a = 0.0;\n    float weight = 4.;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).w);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = p;\n    \n    float time = iTime*2.0;\n    \n    vec3 ro = vec3( 2.5*cos(0.1*time + 6.0), 3.5, 2.5*sin(0.1*time + 6.0) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t, dist;\n    float lastDistEval = 1e10;\n    float edge = 0.0;\n    t = 0.0;\n    vec3 distPos = ro+rd;\n    vec4 distCl = vec4(0.0);\n    for(int i = 0; i < 64; i++){\n        distCl = map(distPos);\n        dist = distCl.w;\n        t += dist;\n        distPos = ro+rd*t;\n        \n        if (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n        }\n        if (dist < lastDistEval) lastDistEval = dist;\n        if(dist < 0.01 || dist > 30.0) break;\n    }\n\n    vec3 color;\n    float shadow = 1.0;\n    if(dist < 1.0){\n        // lighting\n        vec3 lightDir = vec3(0.0, 1.0, 0.0);\n        vec3 light = normalize(lightDir + vec3(0.5, 0.0, 0.9));\n        vec3 normal = normalMap(distPos);\n\n        // difuse color\n        float diffuse = clamp(dot(light, normal), 0.5, 1.0);\n        float lambert = max(.0, dot( normal, light));\n        \n        // ambient occlusion\n        float ao = ambientOcclusion(distPos,normal);\n        \n        // shadow\n        shadow = shadowMap(distPos + normal * 0.001, light);\n\n        // result\n        color += vec3(lambert);\n        color = ao*diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n        \n    }else{\n        color =.94*max(mix(vec3(0.5,1.1,1.2)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n    }\n\n    // rendering result\n    float brightness = 1.;\n    vec3 dst = (color * max(0.8, shadow))*brightness;\n    \n    // add edge detection result\n    dst = mix(dst,vec3(0.0,0.0,0.3),edge);\n   \n    \n    fragColor = vec4(dst, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}