{
    "Shader": {
        "info": {
            "date": "1540958965",
            "description": "Pretty much a modification to Klems' shader [url]https://www.shadertoy.com/view/XlcfRs[/url]. Make AA 1 in line 7 if it renders too slow for you",
            "flags": 0,
            "hasliked": 0,
            "id": "lltBWB",
            "likes": 187,
            "name": "Planet Fall",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "distancefield",
                "sdf"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 14838
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2018 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n// Pretty much a modification to Klems' shader (https://www.shadertoy.com/view/XlcfRs)\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // Change AA to 1 if it renders too slow for you\n#endif\n\n//#define INTERACTIVE\n\nmat3 makeBase( in vec3 w )\n{\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    return mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 w);\n}\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/intersectors\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in float rad )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( in vec3 p, in float b, in float r )\n{\n    float h = clamp( p.z/b, 0.0, 1.0 );\n    return length( p - vec3(0.0,0.0,b)*h ) - r;//*(0.2+1.6*h);\n}\n\n// modified Keinert et al's inverse Spherical Fibonacci Mapping\nvec4 inverseSF( in vec3 p, const in float n )\n{\n    const float PI = 3.14159265359;\n\tconst float PHI = 1.61803398875;\n\n    float phi = min(atan(p.y,p.x),PI);\n    float k   = max(floor(log(n*PI*sqrt(5.0)*(1.-p.z*p.z))/log(PHI+1.)),2.0);\n    float Fk  = pow(PHI,k)/sqrt(5.0);\n    vec2  F   = vec2(round(Fk),round(Fk*PHI));\n    vec2  G   = PI*(fract((F+1.0)*PHI)-(PHI-1.0));    \n    \n    mat2 iB = mat2(F.y,-F.x,G.y,-G.x)/(F.y*G.x-F.x*G.y);\n    vec2 c = floor(iB*0.5*vec2(phi,n*p.z-n+1.0));\n\n    float ma = 0.0;\n    vec4 res = vec4(0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2(s&1,s>>1);\n        float i = dot(F,uv+c);\n        float phi = 2.0*PI*fract(i*PHI);\n        float cT = 1.0 - (2.0*i+1.0)/n;\n        float sT = sqrt(1.0-cT*cT);\n        vec3 q = vec3(cos(phi)*sT, sin(phi)*sT,cT);\n        float a = dot(p,q);\n        if (a > ma)\n        {\n            ma = a;\n            res.xyz = q;\n            res.w = i;\n        }\n    }\n    return res;\n}\n\nfloat map( in vec3 p, out vec4 color, const in bool doColor )\n{\n    float lp = length(p);\n    float dmin = lp-1.0;\n    {\n    vec3 w = p/lp;\n    vec4 fibo = inverseSF(w, 700.0);\n    float hh = 1.0 - smoothstep(0.05,0.1,length(fibo.xyz-w));\n    dmin -= 0.07*hh;\n    color = vec4(0.05,0.1,0.1,1.0)*hh * (1.0+0.5*sin(fibo.w*111.1));\n    }\n    \n    \n    float s = 1.0;\n    \n    #ifdef INTERACTIVE\n  //float tt = mod(iTime,5.0);\n    float tt = 4.0*iMouse.x/iResolution.x;\n    vec3  fp = smoothstep(0.0,1.0,tt-vec3(0,1,2));\n    #endif\n    \n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i)/float(3-1);\n        \n        vec4 f = inverseSF(normalize(p), 65.0 + h*75.0);\n        \n        // snap\n        p -= f.xyz;\n\n        // orient to surface\n        p = p*makeBase(f.xyz);\n\n        // scale\n        float scale = 6.6 + 2.0*sin(111.0*f.w);\n        p *= scale;\n        p.xy *= 1.2;\n        \n        //translate\n        p.z -= 3.0 - length(p.xy)*0.6*sin(f.w*212.1);\n            \n        // measure distance\n        s *= scale;\n        #ifdef INTERACTIVE\n        float d = sdCapsule( p+vec3(0,0,6), 6.0*fp[i], mix(-40.0,0.42*fp[i],smoothstep(0.0,0.1,fp[i])) );\n        #else\n        float d = sdCapsule( p, -6.0, 0.42 );\n        #endif\n        d /= s;\n\n        if( d<dmin )\n        {\n            if( doColor )\n            {\n                color.w *= smoothstep(0.0, 5.0/s, dmin-d);\n\n                if( i==0 ) \n                {\n                    color.xyz = vec3(0.425,0.36,0.1)*1.1;  // fall\n                  //color.xyz = vec3(0.4,0.8,0.1);         // summer\n                  //color.xyz = vec3(0.4,0.4,0.8);         // winter\n                }\n\n                color.zyx += 0.3*(1.0-sqrt(h))*sin(f.w*1111.0+vec3(0.0,1.0,2.0));\n                color.xyz = max(color.xyz,0.0);\n            }\n            dmin = d;\n        }\n        else\n        {\n          color.w *= 0.4*(0.1 + 0.9*smoothstep(0.0, 1.0/s, d-dmin));\n        }\n    }\n    \n    return dmin;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float ep )\n{\n    vec4 kk;\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, kk, false ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, kk, false ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, kk, false ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, kk, false ) );\n#else\n    // prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep, kk, false);\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    vec2 bound = sphIntersect( ro, rd, 2.1 );\n    tmin = max(tmin,bound.x);\n    tmax = min(tmax,bound.y);\n    \n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n    \tvec4 kk;\n\t\tfloat h = map( ro + rd*t, kk, false );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat raycast(in vec3 ro, in vec3 rd, in float tmin, in float tmax  )\n{\n    vec4 kk;\n    float t = tmin;\n\tfor( int i=0; i<512; i++ )\n    {\n\t\tvec3 p = ro + t*rd;\n        float h = map(p,kk,false);\n\t\tif( abs(h)<(0.15*t/iResolution.x) ) break;\n\t\tt += h*0.5;\n        if( t>tmax ) return -1.0;;\n\t}\n    //if( t>tmax ) t=-1.0;\n\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an = (iTime-10.0)*0.05;\n    \n    // camera\t\n    vec3 ro = vec3( 4.5*sin(an), 0.0, 4.5*cos(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world rotation\n    mat3 ca = makeBase( normalize(ta-ro) );\n\n    // render    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.2) );\n    \n        // background\n        vec3 col = vec3(0.1,0.14,0.18) + 0.1*rd.y;\n\n        // bounding volume\n        vec2 bound = sphIntersect( ro, rd, 2.1 );\n\t\tif( bound.x>0.0 )\n        {\n        // raycast\n        float t = raycast(ro, rd, bound.x, bound.y );\n        if( t>0.0 )\n        {\n            // local geometry            \n            vec3 pos = ro + t*rd;\n        \tvec3 nor = calcNormal(pos, 0.01);\n            vec3 upp = normalize(pos);\n            \n            // color and occlusion\n            vec4 mate; map(pos, mate, true);\n            \n            // lighting            \n            col = vec3(0.0);\n        \n            // key ligh\n            {\n                // dif\n                vec3 lig = normalize(vec3(1.0,0.0,0.7));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                float sha = calcSoftshadow( pos+0.0001*nor, lig, 0.0001, 2.0, 6.0 );\n                col += mate.xyz*dif*vec3(1.8,0.6,0.5)*1.1*vec3(sha,sha*0.3+0.7*sha*sha,sha*sha);\n\t\t\t\t// spec\n                vec3 hal = normalize(lig-rd);\n                float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n                float fre = clamp( dot(-rd,lig), 0.0, 1.0 );\n                fre = 0.2 + 0.8*pow(fre,5.0);\n                spe *= spe;\n                spe *= spe;\n                spe *= spe;\n                col += 1.0*(0.25+0.75*mate.x)*spe*dif*sha*fre;\n            }\n\n            // back light\n           \t{\n                vec3 lig = normalize(vec3(-1.0,0.0,0.0));\n                float dif = clamp(0.5+0.5*dot(nor,lig),0.0,1.0);\n                col += mate.rgb*dif*vec3(1.2,0.9,0.6)*0.2*mate.w;\n            }\n\n            // dome light\n            {\n                float dif = clamp(0.3+0.7*dot(nor,upp),0.0,1.0);\n                #if 0\n                dif *= 0.05 + 0.95*calcSoftshadow( pos+0.0001*nor, upp, 0.0001, 1.0, 1.0 );\n                col += mate.xyz*dif*5.0*vec3(0.1,0.1,0.3)*mate.w;\n                #else\n                col += mate.xyz*dif*3.0*vec3(0.1,0.1,0.3)*mate.w*(0.2+0.8*mate.w);\n                #endif\n            }\n            \n            // fake sss\n            {\n                float fre = clamp(1.0+dot(rd,nor),0.0,1.0);\n                col += 0.3*vec3(1.0,0.3,0.2)*mate.xyz*mate.xyz*fre*fre*mate.w;\n            }\n            \n            // grade/sss\n            {\n            \tcol = 2.0*pow( col, vec3(0.7,0.85,1.0) );\n            }\n            \n            // exposure control\n            col *= 0.7 + 0.3*smoothstep(0.0,25.0,abs(iTime-31.0));\n            \n            // display fake occlusion\n            //col = mate.www;\n        }\n        }\n    \n \n        // gamma\n        col = pow( col, vec3(0.4545) );\n    \n        tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // vignetting\n \tvec2 q = fragCoord/iResolution.xy;\n    tot *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n    \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}