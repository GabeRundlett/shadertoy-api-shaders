{
    "Shader": {
        "info": {
            "date": "1485128919",
            "description": "This is an experiment in using raymarching to design a simple scene with nice lighting. It is supposed to look like a farmers field as you drive by.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlKXzK",
            "likes": 9,
            "name": "Foggy Snow Field",
            "published": 3,
            "tags": [
                "raymarching",
                "field",
                "snow"
            ],
            "usePreview": 0,
            "username": "clayjohn",
            "viewed": 929
        },
        "renderpass": [
            {
                "code": "/* \nI wanted to practice designing scenes use SDF and raymarching so I threw this together over \nthe last few days to see what I could come up with. its just a simple plane for the\nground and some normal mapping. Lots of code is borrowed or adapted from other\nshaders here on the site.\n\nMost heavily used:\nhttps://www.shadertoy.com/view/MtdSRn\nhttps://www.shadertoy.com/view/Xds3zN\n*/\n\n\nfloat hash(vec2 p) {\n  p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x) {\n  vec2 p = floor(x);\n  vec2 f = fract(x);\n  f = f*f*f*((6.0*f-15.0)*f+10.0);\n  vec2 a = vec2(0.0, 1.0);\n  float h = mix(mix(hash(p+a.xx), hash(p+a.yx), f.x), \n                mix(hash(p+a.xy), hash(p+a.yy), f.x), f.y);\n\n  return h;\n}\n\nfloat groundDetail(vec2 x) {\n  float h = 0.0;\n  float a = 0.5;\n  float p = 1.0;\n  h = smoothstep(0.5, 1.0, noise(x*0.05))*2.0;\n  for (int i = 0;i < 3;i++) {\n    h+= noise(x*p)*abs(a);\n    p*=2.0;\n    a*=-0.5;\n  }\n\n  return h+cos(x.y*0.5)+sin((x.x+x.y)*0.4);\n}\n\n//sdPrimitives borrowed from iqs raymarching primitives\n//https://www.shadertoy.com/view/Xds3zN\n//and from https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n//from iq's smin article\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 postPos(vec3 p) {\n  return mod(p, vec3(2.0, 0.0, 0.0))-(vec3(1.0, 0.25, 2.0));\n}\n\nfloat groundDistance(vec3 p) {\n  float bfact =0.3;\n  vec3 post = postPos(p+vec3(0.05, 0.25, 0.0));\n  return smin( p.y, length(post)-0.01, bfact );\n}\n\nfloat postDistance(vec3 p) {\n  float dist1 = sdCylinder(postPos(p), vec2(0.035, 0.25));\n\n  return dist1;\n}\n\nfloat wireDistance(vec3 p) {\n  float h = -abs(cos(p.x*3.14159/2.0))*0.05-0.07;\n  float d = 1.0;\n  for (int i=0;i<3;i++) {\n    h+= sin(p.x+float(i)*17.49)*0.03;\n  d = min(sdCapsule(postPos(p), vec3(-2.0, h+float(i)*0.1, .0), vec3(2.0, h+float(i)*0.1, .0), 0.002), d);\n  }\n  return d;\n}\n\n// Distance to ground, posts, and wire\nvec2 map(vec3 p) { \n  vec2 d = opU( vec2(groundDistance(p), 1.0), \n             vec2(postDistance(p), 2.0)) ; \n  d = opU(d, vec2(wireDistance(p), 3.0));\n  return d;\n}\n\nfloat detail(vec3 p) { \n    return (p.y - groundDetail(p.xz*32.0)*0.002); \n}\n\n//normal functions adapted from Shane\n//https://www.shadertoy.com/view/MtdSRn\nvec3 normalMap(in vec3 p){\n  \n    vec2 e = vec2(-1., 1.)*.001;  \n    \n\tfloat d1 = detail(p + e.yxx), d2 = detail(p + e.xxy);\n\tfloat d3 = detail(p + e.xyx), d4 = detail(p + e.yyy); \n    \n    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );\n\treturn n1;   \n}\n\nvec3 normal(in vec3 p){\n  \n    vec2 e = vec2(-1., 1.)*.001;  \n    \n\tfloat d1 = map(p + e.yxx).x, d2 = map(p + e.xxy).x;\n\tfloat d3 = map(p + e.xyx).x, d4 = map(p + e.yyy).x; \n    \n    vec3 n1 = normalize(e.yxx*d1 + e.xxy*d2 + e.xyx*d3 + e.yyy*d4 );\n\treturn n1;   \n}\n\n//adapted from iq's raymarching primitives\n//https://www.shadertoy.com/view/Xds3zN\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, h*54.0 );\n        t += clamp( h, 0.001, 0.1 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return smoothstep(0.05, 0.2, res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime;\n    \n    //uncomment to move camera and look around\n  vec2 m = vec2(0.5);//(2.0*(iMouse.xy-(iResolution.xy*0.5)));\n  // Unit direction ray.\n  vec3 rd = normalize(vec3(fragCoord.xy - iResolution.y*.5+m, iResolution.y));\n  \n  // most of the main ray marching block is borrowed from Shane\n  //https://www.shadertoy.com/view/MtdSRn\n  vec3 ro = vec3(time*.4, .5, .2);\n  vec2 d = vec2(0.0);\n  float t = 0.0;\n  for(int i=0; i<32; i++) {\n\td = map(ro + rd*t); \n    \n    if(abs(d.x)<.001*(t*.125 + 1.) || t>10.) break; \n    \n    t += d.x;\n  }\n  //location of intersection\n  vec3 sp = ro + rd*t;\n  // light direction  \n  vec3 ld = normalize(vec3(-0.276, cos(time)*0.35+0.3, 0.613));  \n  //color of the sun\n  vec3 sun = mix(vec3(1.0, .9, 0.7), vec3(1.0, 1.0, 0.95), ld.y);\n  //fog color, runs from white to color of sky\n  // then mixs in the sunset color based on height of sun\n  vec3 fog = mix(vec3(1.0), vec3(.65, .77, .98), smoothstep(0.0, 0.5, rd.y));\n  vec3 sunset = mix(vec3(1.04, 0.9, 0.7), vec3(1.04, .95, .87), smoothstep(0.0, 0.2, ld.y+(rd.y)));\n  \n  fog = mix(fog, sunset, smoothstep(.8, .99, pow(dot(rd, ld), 0.6*rd.y+ld.y*2.0)));\n\n  //sky color with sun mixed in\n  vec3 sky = mix(vec3(.65, .77, .98), sun, smoothstep(.98,1.0, pow(dot(rd, ld), 4.0)));\n\n  //checks type of material intersected with and applys lighting based on that\n  vec3 col;\n  //snow\n  if (d.y<1.9) {\n  vec3 n = mix(normalMap(sp), vec3(0., 1., 0.), smoothstep(3.0, 6.0, t));\n    \n  float dif = max(dot(ld, n), 0.0);\n  float spe = pow(max(dot(reflect(rd, n), ld), 0.), 32.)*0.6;\n\n  dif *= shadow(sp, ld, 0.02, 2.0);\n  col = sun*sun*spe+mix(sunset, vec3(0.9, 0.9, 1.0), ld.y*2.0)*dif;\n  } else if (d.y<2.5) { //posts\n    vec3 n = normal(sp);\n    \n    float dif = max(dot(ld, n), 0.0); \n    \n    col = mix(sunset*sunset, vec3(0.5, 0.3, 0.05), ld.y*2.0)*dif;\n  } else if (d.y>2.5) { //wire\n   \tvec3 n = normal(sp);\n    \n    float dif = max(dot(ld, n), 0.0); \n    float spe = pow(max(dot(reflect(rd, n), ld), 0.), 4.)*0.5;\n    \n    col = sun*sun*spe+mix(sunset*sunset, vec3(0.7), ld.y*2.0)*dif;\n  }\n  //mix the ground with the sky based on distance\n  col = mix(col, sky, smoothstep(5.95, 6.0, t*ld.y));\n  //mix the fog in overtop of everything else\n  vec3 c = mix(col, fog*fog, smoothstep(0.0, 1.5, t*0.2));\n\n  fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}