{
    "Shader": {
        "info": {
            "date": "1695051510",
            "description": "Hooo... Ho-hoooo!!\n\nFullscreen recommended.\n\nPress and hold mouse for quicker animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdtcR4",
            "likes": 12,
            "name": "OWL",
            "published": 3,
            "tags": [
                "2d",
                "cute",
                "cartoon",
                "painting",
                "heart",
                "vector",
                "animal",
                "owl"
            ],
            "usePreview": 0,
            "username": "misol101",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "// Eperimenting with 2d drawing in shaders\n\n// Long live the OWL!!\n\n// misol101 2023\n\nconst float PI = 3.1416;\nconst float flyMod = 25.9;\n\nvoid eye(inout vec3 col, vec2 uv, bool isLeft, vec2 move, float pupilSize) {\n    vec2 eyePos = vec2(0.21 * (isLeft? 1. : -1.), 0.22);\n    vec3 eyeCol = vec3(0.99, 0.54, 0.03);\n    const float eyeSize = 0.15;\n\n    float centDist = length(uv - eyePos);\n    eyeCol *= 1. - smoothstep(eyeSize-0.02, eyeSize-0.015, centDist); // black outline\n    eyeCol = mix(col, eyeCol, 1. - smoothstep(eyeSize-0.006, eyeSize, centDist)); // AA\n    float centDistP = length(uv+move - eyePos);\n    eyeCol *= smoothstep(eyeSize*(pupilSize-0.03), eyeSize*pupilSize, centDistP); // pupil\n\n    // Twinkles\n    const float HLSize = 0.04, HLSize2 = 0.028;\n    vec2 eyeHLPos = eyePos + vec2(-0.045, 0.045) - move * 0.8;\n    vec2 eyeHLPos2 = eyeHLPos + vec2(-0.029, 0.029);\n\n    float HLDist = length(uv - eyeHLPos); // big twinkle\n    if (HLDist < HLSize)\n        eyeCol = mix(eyeCol, vec3(1.), 1. - smoothstep(HLSize-0.02, HLSize-0.016, HLDist));\n\n    HLDist = length(uv - eyeHLPos2);     // small twinkle\n    if (HLDist < HLSize2)\n        eyeCol = mix(eyeCol, vec3(1.), 1. - smoothstep(HLSize2-0.02, HLSize2-0.016, HLDist));\n\n    col = (centDist < eyeSize) ? eyeCol : col;\n}\n\nvoid lid(inout vec3 col, vec2 uv, bool isLeft, float progress) {\n    vec2 lidPos = vec2(0.21 * (isLeft? 1. : -1.), 0.18);\n    vec3 lidCol = vec3(0.73, 0.44, 0.33)*2.5;\n    const vec2 lidSize = vec2(0.15, 0.2);\n\n    vec2 centDist = abs(uv - lidPos);\n    col = (centDist.x < lidSize.x && centDist.y > lidSize.y*progress && centDist.y < lidSize.y) ? lidCol : col;\n}\n\nvoid brow(inout vec3 col, vec2 uv, bool isLeft, float frown) {\n    vec2 browPos = vec2(0.21 * (isLeft? 1. : -1.), 0.315);\n    vec3 browCol = vec3(0., 0., 0.);\n    const float browSize = 0.18;\n    uv.y += abs(uv.x-browPos.x)*frown;\n\n    float ydist = (uv.y - browPos.y)*1.5;\n    float centDist = length(vec2(uv.x - browPos.x, ydist ));\n    browCol *= 1. - smoothstep(browSize-0.035, browSize-0.015, centDist);\n    browCol = mix(col, browCol, 1. - smoothstep(browSize-0.009, browSize, centDist)); // AA*3\n    browCol = mix(col, browCol, 1.-smoothstep(browSize-0.026, browSize-0.035, centDist));\n    browCol = mix(col, browCol, smoothstep(0.11, 0.115, ydist));\n\n    col = (centDist < browSize && centDist > browSize - 0.035 && ydist > 0.09) ? browCol : col;\n}\n\nvoid beak(inout vec3 col, vec2 uv) {\n    vec2 beakPos = vec2(0.0, 0.04);\n    float beakW = 0.068;\n    vec3 beakCol = vec3(0.97, 0.67, 0.12);\n\n    float beakHLw = -0.0015;\n\n    float beakHLx = (uv.x - beakPos.x);\n    float tlt = beakHLw + 0.004 + (beakPos.y -uv.y)*0.3;\n    if (beakHLx < beakHLw && beakHLx > tlt)\n        beakCol = mix(beakCol, vec3(1.), max(0.,1.0-beakHLw/(tlt*0.3)*1.));\n\n    float beakLW = abs(uv.x - beakPos.x) / beakW;\n\n    float breakPosY = beakPos.y + 0.065;\n    beakW -= max(uv.y, 0.1) - breakPosY;\n    if (uv.y < breakPosY)\n        beakW -= 0.35 * (breakPosY - uv.y);\n    \n    float beakX = abs(uv.x - beakPos.x) / beakW;\n\n    float rel = beakX/beakLW;\n    beakCol *= 1. - smoothstep(1.-0.39*rel, 1.-0.3*rel, beakX); // outline\n    beakCol = mix(col, beakCol, 1. - smoothstep(1.-0.1*rel, 1.-0.05*rel, beakX)); // AA\n\n    col = (beakX < 1.0) ? beakCol : col;\n}\n\nvoid face(inout vec3 col, vec2 uv, bool isLeft, vec3 faceCol, float faceSize, bool outline, float faceY) {\n    float sideMul = isLeft? 1. : -1.;\n    vec2 facePos = vec2(0.21 * sideMul, faceY);\n\n    float centDist = length(uv - facePos);\n\n    if (uv.y > facePos.y) {\n        float ls = (uv.x*sideMul + facePos.x*(sideMul*-1.) - faceSize) * 0.27;\n        faceSize -= ls * (uv.y - facePos.y)*2.;\n    }\n\n    if (outline)\n        faceCol *= 1. - smoothstep(faceSize-0.02, faceSize-0.015, centDist); // outline\n    faceCol = mix(col, faceCol, 1. - smoothstep(faceSize-0.006, faceSize, centDist)); // AA\n\n    col = (centDist < faceSize && uv.x * sideMul > 0.) ? faceCol : col;\n}\n\nvoid body(inout vec3 col, vec2 uv, bool isLeft, vec3 bodyCol, float bodySize, bool outline, float stretchMul) {\n    float sideMul = isLeft? 1. : -1.;\n    vec2 bodyPos = vec2(0.21 * sideMul, -0.09);\n\n    float centDist = length(uv - bodyPos);\n\n    float ls = (uv.x*sideMul + bodyPos.x*(sideMul*-1.) - bodySize) * 0.23;\n    bodySize -= ls * abs(uv.y - bodyPos.y)*stretchMul;\n\n    if (outline)\n        bodyCol *= 1. - smoothstep(bodySize-0.02, bodySize-0.015, centDist); // outline\n    bodyCol = mix(col, bodyCol, 1. - smoothstep(bodySize-0.006, bodySize, centDist)); // AA\n\n    col = (centDist < bodySize && uv.x * sideMul > 0.) ? bodyCol : col;\n}\n\nvoid claw(inout vec3 col, vec2 uv, vec2 clawPos, float clawSize, float clawH, vec3 clawCol, float tilt, bool isLeft, bool outline) {\n    float sideMul = isLeft? 1. : -1.;\n    clawPos.x *= sideMul;\n\n    uv.x += (uv.y-clawPos.y) * tilt;\n    float centDist = length(vec2((uv.x - clawPos.x)*clawH, uv.y - clawPos.y));\n    \n    if (outline)\n        clawCol *= 1. - smoothstep(clawSize-0.025, clawSize-0.02, centDist); // outline\n    clawCol = mix(col, clawCol, 1. - smoothstep(clawSize-0.006, clawSize, centDist)); // AA\n\n    col = (centDist < clawSize && uv.x * sideMul > 0.) ? clawCol : col;\n}\n\nvoid wing(inout vec3 col, vec2 uv, vec2 wingPos, float wingSize, float wingH, vec3 wingCol, float tilt, bool isLeft, bool outline, float rot) {\n    float sideMul = isLeft? 1. : -1.; \n    wingPos.x *= sideMul;\n\n    uv.x += (uv.y-wingPos.y) * tilt;\n    float centDist = length(vec2((uv.x - wingPos.x)*wingH + 0.07*cos( rot+atan(uv.y,uv.x*sideMul)*25.), uv.y - wingPos.y));\n\n    if (outline)\n        wingCol *= 1. - smoothstep(wingSize-0.03, wingSize-0.025, centDist); // outline\n    wingCol = mix(col, wingCol, 1. - smoothstep(wingSize-6./iResolution.y, wingSize, centDist)); // AA\n\n    col = (centDist < wingSize && uv.x * sideMul > 0.) ? wingCol : col;\n}\n\n// from https://www.shadertoy.com/view/lsKSWR by Ippokratis\nfloat vignette(vec2 FC, float extent, float intensity) {\n\tvec2 uv = FC.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * intensity;\n    return pow(vig, extent);\n}\n\n// from https://www.shadertoy.com/view/XsfGRn by iq\nvoid heart(inout vec3 col, vec2 uv, vec2 hpos, float scale, vec3 hcol, bool anim, float time) {\n    vec2 p = (uv - hpos) / scale;\n\t\n    if (anim) {\n        float tt = mod(time,1.5)/1.5;\n        float ss = pow(tt,.2)*0.5 + 0.5;\n        ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n        p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n    }\n\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h);\n    \n    col = mix( col, hcol, max(0.,smoothstep( -0.02, 0.02, d-r+0.15) -0.4 ));\n}\n\nfloat hash1(float n) {\n    return fract(sin(n)*138.5453123);\n}\n\nvoid animSingle(inout float result, float time, float startTime, float endTime, bool neg) {\n    result = step(time, endTime)*step(startTime, time) * // time > startTime && time < endTime\n       (neg ? -1. : 1.) * (time-startTime) / (endTime-startTime); \n}\n\nvoid animate(float speed, out float eyeMove, out float browMove, out float headMove, out float clawMove, out float clawMove2, out float pupilSize, out float pupilSize2, out float blinkL, out float blinkR, out float flyMove) {\n    float iT = iTime * speed;\n    float time = mod(iT, 14.);\n\n    animSingle(eyeMove, time, 0.3, 4.3, false);\n    animSingle(eyeMove, time, 10.3, 13.3, true);\n\n    animSingle(browMove, time, 1.3, 4.3, false);\n    animSingle(browMove, time, 6.3, 8.3, true);\n\n    animSingle(headMove, time, 1.3, 6.3, false);\n    animSingle(headMove, time, 9.3, 10.8, true);\n\n    float ctime = mod(iT, 12.);\n    animSingle(clawMove, ctime, 1.3, 2.7, true);\n    animSingle(clawMove2, ctime, 6.3, 7.4, true);\n\n    float ptime = mod(iT, 32.); \n    animSingle(pupilSize, ptime, 20.3, 25.4, true);\n    animSingle(pupilSize2, ptime, 5.2, 8.2, true);\n    \n    float btime = mod(iT, 15.);\n    float blink = 0.4 * speed;\n    if ((int(floor(iT / 15.)) % 4) == 2)\n        animSingle(blinkL, btime, 4.3, 4.3+blink, true);\n    animSingle(blinkL, btime, 14.3, 14.3+blink, true);\n    animSingle(blinkR, btime, 14.3, 14.3+blink, true);\n\n    float ftime = mod(iT, flyMod); \n    animSingle(flyMove, ftime, flyMod-14., flyMod-0.1, false);\n}\n\nvoid mainImage( out vec4 O, in vec2 FC ) {\n    // don't ask... :)\n    vec2 uv = (FC*1.35)/iResolution.y - 0.67;\n    uv.y += 0.03;\n    uv.x += (1. - iResolution.x/iResolution.y) * 0.67;\n\n\tvec3 col = mix( vec3(1.0,0.8,0.3), vec3(0.58, 0.99, 0.99), sqrt(uv.y+0.67) );\n\n    // hearts\n    const vec3 hcol = vec3(0.3,0.8,0.7);\n    for (float j = 0.; j < 6.; j++) {\n        vec2 hpos = vec2(-0.9 + mod((j-1.) * 0.9,2.4) + sin(iTime+0.4*j)*0.1, 1.0 - mod(hash1(j)*1.5 + iTime*(0.3+hash1(j)*0.3), 1.8));\n        if (length(hpos-uv) < 0.4)\n            heart(col, uv, hpos, 0.2 + hash1(j)*0.1, hcol, true, iTime + .7*j);\n    }\n    vec3 bgcol = col;\n    \n    // entrance on start\n    //uv/=0.5 + min(0.5, smoothstep(0.0, 2.0, iTime) ); uv.y += sin(-PI*0.5-max(0.,1.-iTime/1.)*(PI-0.5)) * ((max(0.,1.-iTime))*2.8);\n    \n    // animate\n    float speed = 1., em = 0., bm=0., hm=0., cm=0., cm2=0., ps=0., ps2=0., bL=0., bR=0., fm=0.;\n    if (iMouse.z > 0.) {\n        speed = 3.0;\n    }\n    animate(speed, em, bm, hm, cm, cm2, ps, ps2, bL, bR, fm);\n\n    float fmS = pow(smoothstep(0.,1.,fm), 0.9);\n    if ((int(iTime/flyMod)-1) % 3 == 0)\n        uv *= 1. - sin(iTime * 1.5) * (sin(fm*PI*2.) * 0.22); // scale while flying\n    uv.x += sin(PI * 6. * fmS) * 0.2 * (mod(floor(iTime*speed / flyMod)+1.,2.)*2.-1.); // flying x\n    uv.y += sin(iTime * 1.5) * (0.005 + sin(fmS*PI) * 0.02); // flying y\n\n    float tilt = 0.15;\n    if (uv.y < 0.15 && abs(uv.x) < 0.8) {\n        // wings\n        vec3 wingCol = vec3(0.73, 0.44, 0.031);\n        vec2 wingPos = vec2(0.41, -0.16);\n        float flyMove = PI * 2. * fmS * 12.;\n        wing(col, uv, wingPos, 0.3, 0.95, wingCol, tilt, true, true, 1.93+sin(iTime*speed + flyMove));\n        wing(col, uv, wingPos, 0.3, 0.95, wingCol, -tilt, false, true, -1.23+sin(iTime*speed*0.9 + flyMove));\n        //bgcol = col; // don't shadow wings\n\n        // body\n        vec3 bodyCol = vec3(0.73, 0.44, 0.03);\n        body(col, uv, false, bodyCol, 0.34, true, 2.);\n        body(col, uv, true, bodyCol, 0.34, true, 2.);\n\n        bodyCol = vec3(0.73, 0.44, 0.33)*2.5;\n        body(col, uv, false, bodyCol, 0.24, false, 4.);\n        body(col, uv, true, bodyCol, 0.24, false, 4.);\n    }\n\n    if (uv.y > -0.25 && abs(uv.x) < 0.6) {\n        float headMove = sin(hm * PI * 1.2)*0.2*(1.-abs(hm)) * abs(hm);\n        uv.x += headMove;\n\n        // face shadow\n        vec3 faceShCol = vec3(0., 0., 0.0), coltemp=col;\n        float faceY = 0.125;\n        face(coltemp, uv, false, faceShCol, 0.34, false, faceY);\n        face(coltemp, uv, true, faceShCol, 0.34, false, faceY);\n        if (col != bgcol)\n            col = mix(col, coltemp, 0.33);\n\n        // face\n        faceY = 0.2;\n        vec3 faceCol = vec3(0.73, 0.44, 0.03);\n        face(col, uv, false, faceCol, 0.34, true, faceY);\n        face(col, uv, true, faceCol, 0.34, true, faceY);\n\n        faceCol = vec3(0.73, 0.44, 0.33)*2.5;\n        face(col, uv, false, faceCol, 0.268, false, faceY);\n        face(col, uv, true, faceCol, 0.268, false, faceY);\n\n        // eyes\n        float pupilSize = 0.7 + max(-1.559,sin(ps*PI*1.)*0.65) + max(-0.11,sin(ps2*PI*1.)*0.15);\n        vec2 eyeMove = vec2( max(-0.159,sin(em*PI*1.)*0.04), sin(em*PI)*0.011);\n        eye(col, uv, false, eyeMove, pupilSize);\n        eye(col, uv, true, eyeMove, pupilSize);\n\n        lid(col, uv, true, cos(bL*PI*2.)*0.5+0.5);\n        lid(col, uv, false, cos(bR*PI*2.)*0.5+0.5);\n\n        beak(col, uv);\n\n        // brows\n        float browMove = -sin(bm*PI*1.)*0.3;\n        brow(col, uv, false, browMove);\n        brow(col, uv, true, browMove);\n\n        uv.x -= headMove;\n    }\n\n    // claws\n    vec3 clawCol = vec3(1., 0.54, 0.03);\n    vec2 clawPos = vec2(0.21, -0.495);\n    tilt = 0.25;\n    \n    if(abs(clawPos.y-uv.y) < 0.1 && abs(uv.x) < 0.25) {\n        vec2 clawMove = vec2( sin(cm * PI * 1.1)*0.15*(1.-abs(cm)) * abs(cm), sin(cm*PI)*0.005);\n        vec2 clawMove2 = vec2( sin(cm2*PI)*0.005, sin(cm2 * PI * 1.5)*0.15*(1.-abs(cm2)) * abs(cm2));\n        for (float i = 0.; i<3.; i++) {\n            claw(col, uv+clawMove*(i+0.2)*0.25, clawPos, 0.07, 1.75, clawCol*0.7, tilt, true, true);\n            claw(col, uv+clawMove*(i+0.2)*0.25, clawPos+vec2(0.,0.008), 0.045, 1.75, clawCol, tilt, true, false);\n\n            claw(col, uv+clawMove2*(0.15+i*0.2)*1.35, clawPos, 0.07, 1.75, clawCol*0.7, -tilt, false, true);\n            claw(col, uv+clawMove2*(0.15+i*0.2)*1.35, clawPos+vec2(0.,0.008), 0.045, 1.75, clawCol, -tilt, false, false);\n            clawPos += vec2(-0.06, -0.01);\n            tilt -= 0.09;\n        }\n    }\n\n    // post processing\n    float vig = 1.;\n    vig = vignette(FC, 0.08, 75.0);\n\n    O = vec4(col*vig,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 19,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}