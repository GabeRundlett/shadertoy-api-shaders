{
    "Shader": {
        "info": {
            "date": "1705312784",
            "description": "rotateLines",
            "flags": 0,
            "hasliked": 0,
            "id": "4ffSDM",
            "likes": 2,
            "name": "rotateLines",
            "published": 3,
            "tags": [
                "rotatelines"
            ],
            "usePreview": 0,
            "username": "kenshin",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 100\n#define MIN_DIST  .0001\n#define MAX_DIST  100.\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nmat2 rotate2D(float radian)\n{\n    float c = cos(radian);\n    float s = sin(radian);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdOctahedrone( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdScene(vec3 p)\n{\n    p.z += iTime * .5;\n    p.xy = fract(p.xy) -.5;\n    p.z = mod(p.z, .2) - .1;\n    float o1 = sdSphere(p, .13);   \n    return o1;\n}\n\nfloat rayMarching(vec3 ro, vec3 rd)\n{\n    float totalDist = .0;\n    int i = 0;\n    for(i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + totalDist * rd;\n        p.xy *= rotate2D(totalDist * .15);\n        \n        float ds = sdScene(p);\n        totalDist += ds;\n        if(totalDist > MAX_DIST || ds < MIN_DIST) break;\n    }\n    return totalDist;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec3 n = vec3(sdScene(p));\n    vec2 offset = vec2(.001, .0);\n    n = n - vec3(\n     sdScene(p - offset.xyy),\n     sdScene(p - offset.yxy),\n     sdScene(p - offset.yyx)\n    );\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //mouse\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    //rotate Camera\n    mat2 rotY = rotate2D(mouse.x * 2.);\n    mat2 rotX = rotate2D(mouse.y * 2.);\n    vec3 ro = vec3(0, 0, -3.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    ro.xz = rotY * ro.xz;\n    ro.yz = rotX * ro.yz;\n    rd.xz = rotY * rd.xz;\n    rd.yz = rotX * rd.yz; \n    float d = rayMarching(ro, rd);\n    vec3 col = vec3(.0);\n    \n        //palette(d, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 0.5), vec3(0.80, 0.90, 0.30))\n    col += palette(d * 0.08 + iTime * 0.05, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));\n    col = pow(col, vec3(2.2));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}