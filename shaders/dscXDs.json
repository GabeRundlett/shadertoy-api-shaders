{
    "Shader": {
        "info": {
            "date": "1680564380",
            "description": "fractalssss\n\n#define MOUSE_ROTATE in Buffer A.\n#define SOBEL in Image for screenspace sobel filter.",
            "flags": 32,
            "hasliked": 0,
            "id": "dscXDs",
            "likes": 2,
            "name": "mandelbulb-pathtraced",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "graygoose",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "//#define SOBEL\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef SOBEL\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n#else\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n#endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//#define MOUSE_ROTATE\n\n#define MAX_ITERATIONS 128\n#define BAILOUT 64.0\n#define POWER 8.0\n#define MINIMUM_RADIUS 0.1\n#define ITERATIONS_BEFORE_ESCAPE 256.0\n\n#define MAX_RAY_STEPS 128\n#define MAX_RAY_DIST 10.0\n#define MIN_RAY_DIST 0.001\n\n#define NORMAL_EPS 0.00001\n\n\n        \nvec4 fractal(vec3 z, mat3 rot) {\n    vec3 c = z;\n    float r = 0.0;\n    float dr = 1.0;\n    float trap = 0.0;\n\n\n    z *= rot;\n        \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        r = length(c);\n        if (r > BAILOUT) break;\n        \n        float theta = acos(c.z / r);\n        float phi = atan(c.y, c.x);\n        float p = POWER * theta;\n        float cp = cos(p);\n        float sp = sin(p);\n        float cp2 = cos(POWER * phi);\n        float sp2 = sin(POWER * phi);\n        \n        vec3 dz = vec3(\n            sp * cp2,\n            sp * sp2,\n            cp);\n        c = pow(r, POWER) * dz + z;\n        dr = POWER * pow(r, POWER - 1.0) * dr + 1.0;\n        \n        if (float(i) > ITERATIONS_BEFORE_ESCAPE) {\n            trap += log(r);\n        }\n    }\n    \n    float dist = 0.5 * log(r) * r / dr;\n    return vec4(c, dist);\n}\n\nvec3 estimateNormal(vec3 p, mat3 rot) {\n    const vec3 dx = vec3(NORMAL_EPS, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, NORMAL_EPS, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, NORMAL_EPS);\n    \n    return normalize(vec3(\n        fractal(p + dx, rot).w - fractal(p - dx, rot).w,\n        fractal(p + dy, rot).w - fractal(p - dy, rot).w,\n        fractal(p + dz, rot).w - fractal(p - dz, rot).w)\n    );\n}\n\n\nfloat traceRay(vec3 ro, vec3 rd, out vec3 hit, out vec3 normal, mat3 rot) {\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < MAX_RAY_STEPS; i++) {\n        hit = ro + rd * t;\n        d = (fractal(hit, rot)).w;\n        if (d < MIN_RAY_DIST) {\n            normal = estimateNormal(hit, rot);\n            return t;\n        }\n        t += d;\n        if (t > MAX_RAY_DIST) break;\n    }\n    return -1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    vec3 ro = vec3(0.0, 0.0, 1.6);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n\n#ifdef MOUSE_ROTATE\n    vec2 mouse = iMouse.xy / iResolution.xy; \n    float theta = mouse.x * 10.0;\n#else\n    float theta = iTime * 0.1;\n#endif\n\n    mat3 rot = mat3(\n        vec3(cos(theta), 0.0, sin(theta)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(theta), 0.0, cos(theta)));\n\n    vec3 hit, normal;\n    float t = traceRay(ro * rot, rd * rot, hit, normal, rot);\n\n    if (t > 0.0) {\n        vec3 color = vec3(0.0);\n        vec3 lightDir = normalize(vec3(-1.0, 1.0, -1.0));  \n\n        vec3 viewDir = normalize(-hit);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        float specular = pow(max(dot(reflectDir, viewDir), 0.0), 32.0);\n        color += vec3(0.102,0.373,0.706) * diffuse;\n        color += vec3(1.0) * specular;\n        fragColor = vec4(color, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*vec4 Sample(vec2 uv)\n{\n    return texelFetch(iChannel0, ivec2(uv * iResolution.xy), 0);\n}\n\nvec4 average(vec2 uv)\n{\n    vec4 O = (\n        Sample(uv + vec2(0, 1)) +\n        Sample(uv + vec2(1, 0)) +\n        Sample(uv + vec2(1, 1))\n    ) * .33333;\n    O += Sample(uv);\n    O *= 0.5;\n    return O;\n}*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = sobel(fragCoord.xy, iChannel0, iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SOBEL_EDGE_COLOR vec4(0.929,0.200,0.231,.15)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.25, 0.95, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}