{
    "Shader": {
        "info": {
            "date": "1559038322",
            "description": "pbr brdf ",
            "flags": 0,
            "hasliked": 0,
            "id": "3lSGWz",
            "likes": 2,
            "name": "PBR RenderMode",
            "published": 3,
            "tags": [
                "pbrbrdf"
            ],
            "usePreview": 0,
            "username": "littlebird",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "\n\n#define GAMMA 2.2\n#ifdef LOC_SHADER\nuniform vec2 iResolution;\nuniform float iTime;\nuniform sampler2D tex_ao;\nuniform sampler2D tex_basecolor;\nuniform sampler2D tex_metallic;\nuniform sampler2D tex_normal;\nuniform sampler2D tex_roughness;\nuniform sampler2D tex_specular;\nuniform sampler2D tex_height;\n\nuniform samplerCube skybox;\nuniform vec3 iCameraPos;\nuniform vec3 iCameraDir;\nuniform vec3 iCameraUp;\nout vec4 FragColor;\n#else \n#define skybox iChannel0\n#define tex_basecolor iChannel1\n#endif\n\n#define PI 3.1415926\n#define float3 vec3\n\nfloat rand(float p){return fract(sin(p) * 43758.5453123);}\nfloat rand (in vec2 p) { return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123); }\nfloat rcp(float a){\n    return 1.0/a;\n}\n\n//随机数生成\n//返回 [0.0f, 1.0f) 的随机数\nfloat rand(float x, float y){\n    return fract(cos(x * (12.9898) + y * (4.1414)) * 43758.5453);\n}\n\nfloat rndSeed = 1.;//iRandSeed;\nfloat rand(){\n    return rand(rand(gl_FragCoord.x, gl_FragCoord.y), rndSeed++);\n}\n\nvec3 rand(vec3 p){\n \tconst vec3 k = vec3( 3.1415926, 2.71828,6.62607015);\n \tp = p*k + p.yzx;\n \treturn -1.0 + 2.0*fract( 2.0 * k * fract( p.x*p.y*(p.x+p.y)) );\n}\n\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    vec3 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    //随机梯度\n    vec3 g1 = rand(i+vec3(0.0,0.0,0.0));\n    vec3 g2 = rand(i+vec3(1.0,0.0,0.0));\n    vec3 g3 = rand(i+vec3(0.0,1.0,0.0));\n    vec3 g4 = rand(i+vec3(1.0,1.0,0.0));\n    vec3 g5 = rand(i+vec3(0.0,0.0,1.0));\n    vec3 g6 = rand(i+vec3(1.0,0.0,1.0));\n    vec3 g7 = rand(i+vec3(0.0,1.0,1.0));\n    vec3 g8 = rand(i+vec3(1.0,1.0,1.0));\n    \n    //方向向量\n    vec3 d1 = f - vec3(0.0,0.0,0.0);\n    vec3 d2 = f - vec3(1.0,0.0,0.0);\n    vec3 d3 = f - vec3(0.0,1.0,0.0);\n    vec3 d4 = f - vec3(1.0,1.0,0.0);\n    vec3 d5 = f - vec3(0.0,0.0,1.0);\n    vec3 d6 = f - vec3(1.0,0.0,1.0);\n    vec3 d7 = f - vec3(0.0,1.0,1.0);\n    vec3 d8 = f - vec3(1.0,1.0,1.0);\n    \n    //点积求权重\n    float n1 = dot(g1, d1);\n    float n2 = dot(g2, d2);\n    float n3 = dot(g3, d3);\n    float n4 = dot(g4, d4);\n    float n5 = dot(g5, d5);\n    float n6 = dot(g6, d6);\n    float n7 = dot(g7, d7);\n    float n8 = dot(g8, d8);\n    \n    //加权求和\n    float a = mix(n1,n2,u.x);\n    float b = mix(n3,n4,u.x);\n    float c1 = mix(a,b,u.y);\n    a = mix(n5,n6,u.x);\n    b = mix(n7,n8,u.x);\n    float c2 = mix(a,b,u.y);\n    float c = mix(c1,c2,u.z);\n    \n    \n    return c;\n}\n\nfloat fbm(vec3 p){\n p *= 2.0; //这里调整频率\n float f = 0.;\n f += 1.0 * abs(noise(p)); p=2.*p;\n f += 0.5 * abs(noise(p)); p=2.*p;\n f += 0.25 * abs(noise(p)); p=2.*p;\n f += 0.125 * abs(noise(p)); p=2.*p;\n f += 0.0625 * noise(p); p=2.*p;\n return f;\n}\n\n\n#define MAT_TYPE_SOLID 1\n#define MAT_TYPE_PBR   2\n#define MAT_TYPE_TEX   3\nstruct Mat{int type; vec3 col; float roughness; float metalness; float ao; vec3 F0;};\nstruct Hit{ float t; vec3 p; vec3 n; Mat mat; vec2 uv; };\nstruct Light{vec3 o; vec3 col;};\nstruct Sphere{ vec3 o; float r; Mat mat; };\nstruct Ray { vec3 o, d; }; \nstruct Camera{\n    vec3 pos, dir, up, right;\n    vec3 ll_corner, horizontal, vertical;};\n\nSphere sphere;\nCamera camera;\nLight lights[4];\n\n\nvoid BuildCamera(vec3 pos, vec3 dir, vec3 up, float hfov, float aspect){\n    camera.pos = pos;\n    camera.dir = normalize(dir);\n    camera.up = normalize(up);\n    camera.right = cross(camera.dir, camera.up);\n    camera.up = cross(camera.right, camera.dir);\n    \n    vec3 center = camera.pos + camera.dir;\n    float h = tan(hfov/180.0*PI) * 2.0;\n    float w = h * aspect;\n    \n    camera.horizontal = w * camera.right;\n    camera.vertical = h * camera.up;\n    camera.ll_corner = center - 0.5 * camera.horizontal - 0.5 * camera.vertical;\n}\n\nRay BuildRay(vec2 fragCoord){\n    vec2 uv = fragCoord / vec2(iResolution.x, iResolution.y);\n    vec3 position = camera.pos;\n    return Ray(position, camera.ll_corner + uv.x*camera.horizontal + uv.y*camera.vertical - position);\n}\n\nvec2 GetShpereUV(vec3 p, vec3 n){\n    float u = atan(n.x, n.z) / (2.*PI) + 0.5;\n    float v = n.y * 0.5 + 0.5;\n    return vec2(u,v);\n\n/*  float phi = atan(p.z, p.x);\n    float theta = asin(p.y);\n    vec2 uv;\n    uv.x = (phi + PI)/(2.*PI);\n    uv.y = (theta + PI/2.) / PI;\n    return uv;*/\n}\n\nbool Intersect(Sphere s, Ray r, inout Hit ht){\n    vec3 so = s.o;\n    vec3 oc = r.o - so;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(r.d, oc);\n    float c = dot(oc, oc) - s.r * s.r;\n    float delt = b * b - 4.0 * a * c;\n    float t = ht.t;\n    if(delt > 0.0) {\n        float t = 0.;\n        t = (-b - sqrt(delt)) / (2.0 * a);\n        if(t < 0.001){\n            t = (-b + sqrt(delt)) / (2.0 * a);\n        }\n        if(t > 0.001 && t < ht.t){\n            ht.t = t;\n            ht.p = r.o + ht.t * r.d;\n            ht.mat = s.mat;\n            ht.n = normalize(ht.p - so);\n            ht.uv = GetShpereUV(ht.p, ht.n);\n            return true;\n        }\n    }\n    \n    return false;\n}\n\n//漫反射模型\nfloat3 Diffuse_Lambert( float3 DiffuseColor )\n{\n\treturn DiffuseColor * (1. / PI);\n}\n\n//高光\nfloat NDF_DistributionGGX(float noh, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float noh2 = noh*noh;\n\n    float nom   = a2;\n    float denom = (noh2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\n    return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0\n}\n\nfloat G_SchlickGGX(float nov, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float nom   = nov;\n    float denom = nov * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat G_Smith(float nov, float nol, float roughness)\n{\n    return G_SchlickGGX(nov, roughness) * G_SchlickGGX(nol, roughness);\n}\n\nfloat saturate(float x){\n    if(x < 0.) return 0.;\n    if(x > 1.) return 1.;\n}\n\nvec3 F_Schlick(float hov, vec3 F0)\n{\n    //float Fc = pow( 1. - hov , 5.0);// 1 sub, 3 mul\n\t//return clamp(50.0 * F0.g, 0., 1.) * Fc + (1 - Fc) * F0;\n    return F0 + (1.0 - F0) * pow(1.0 - hov, 5.0);\n}\n/////////////\nvec3 CalcLight(Ray r, Hit ht, Light lt){\n    vec3 col = vec3(0);\n    vec3 n = normalize(ht.n);          //法线\n    vec3 v = normalize(r.o - ht.p);    //观察方向\n    vec3 l = normalize(lt.o - ht.p);   //光线方向\n    vec3 h = normalize(v+l);           //中间向量\n\tfloat nov = max(dot(n,v), 0.);\n    float nol = max(dot(n,l),0.);\n    float noh = max(dot(n,h), 0.);\n    float hov = max(dot(h,v), 0.);\n\n    vec3 F0 = ht.mat.F0;\n\tF0 = mix(F0, ht.mat.col, ht.mat.metalness);\n    \n    //辐射强度,按照距离衰减\n    float dis = length(lt.o - ht.p);\n    float attenuation = 1.0 / (dis * dis);\n    vec3 radiance = lt.col * attenuation * nol;\n    \n    //漫反射\n    vec3 diff = Diffuse_Lambert(ht.mat.col);\n\n    //高光\n\tfloat D = NDF_DistributionGGX(noh, ht.mat.roughness);\n    float G = G_Smith(nov,nol,ht.mat.roughness);\n\tvec3 F  = F_Schlick(hov, F0);\n    vec3 specular = (D*G*F) / (4.0*nov*nol+0.001);\n    \n    //brdf\n    vec3 Ks = F;\n    vec3 Kd = vec3(1.) - Ks;\n    Kd *= 1.0 - ht.mat.metalness;\n    vec3 brdf = Kd * diff + specular;\n\n    return brdf * radiance;\n}\n\n//copy from https://www.shadertoy.com/view/XtyyDh\nvec4 quat(vec3 axis, float angle) { return vec4(axis*sin(angle*0.5), cos(angle*0.5)); }\nvec4 quat_i() { return vec4(0,0,0,1); }\nvec4 quat_conj(vec4 q) { return vec4(-q.xyz,q.w); }\nvec4 quat_mul(vec4 a, vec4 b) { return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz)); }\nvec3 quat_mul(vec4 q, vec3 v) { return v-2.0*cross(cross(q.xyz,v)-q.w*v,q.xyz); }\n\n\n//http://www.cmap.polytechnique.fr/~peyre/cours/x2005signal/hdr_photographic.pdf\nfloat3 ReinhardToneMapping(float3 color, float adapted_lum) \n{\n    const float MIDDLE_GREY = 1.;\n    color *= MIDDLE_GREY / adapted_lum;\n    return color / (1.0f + color);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nfloat3 ACESToneMapping(float3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n\n\tcolor *= adapted_lum;\n\treturn clamp((color * (A * color + B)) / (color * (C * color + D) + E), vec3(0.), vec3(1.));\n}\n\nvec3 CalcLights(Ray r, Hit ht){\n    vec3 col = vec3(0);\n\n    //计算所有光源\n    Light lt = Light(vec3(3,3,3), vec3(100,100,100));\n    lt.o = quat_mul(quat(normalize(vec3(0,1,0)),iTime), lt.o);\n\n    \n    col += CalcLight(r, ht, lights[0]);\n    //col += CalcLight(r, ht, Light(vec3(-5,1,5), vec3(100,0,0)));\n    //col += CalcLight(r, ht, Light(vec3(-5,-3,1), vec3(0,100,100)));\n    //col += CalcLight(r, ht, Light(vec3(-3,-1,-5), vec3(0,100,0)));\n    //col += CalcLight(r, ht, Light(vec3(-1,3,-3), vec3(40,100,100)));\n\n    //叠加环境光，后续用IBL\n    vec3 ambient = vec3(0.01) * ht.mat.col * ht.mat.ao;\n    col = ambient+ col;\n    \n    //hdr tonemapping\n    col = ACESToneMapping(col, 1.0);\n\n    //gamma correct\n    col = pow(col, vec3(1.0/GAMMA)); \n    return col;\n}\n\nvec3 GetNormalFromMap(sampler2D normalMap, vec3 Normal, vec3 WorldPos, vec2 TexCoords)\n{\n    vec3 tangentNormal = texture(normalMap, TexCoords).xyz * 2.0 - 1.0;\n\n    vec3 Q1  = dFdx(WorldPos);\n    vec3 Q2  = dFdy(WorldPos);\n    vec2 st1 = dFdx(TexCoords);\n    vec2 st2 = dFdy(TexCoords);\n\n    vec3 N   = normalize(Normal);\n    vec3 T  = normalize(Q1*st2.t - Q2*st1.t);\n    vec3 B  = -normalize(cross(N, T));\n    mat3 TBN = mat3(T, B, N);\n\n    return normalize(TBN * tangentNormal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Set Camera\n    #ifdef LOC_SHADER\n \tBuildCamera(iCameraPos, iCameraDir, iCameraUp, 45.0, iResolution.x/iResolution.y);\n    #else\n    vec3 pos = vec3(0,3,4);//quat_mul(quat(normalize(vec3(0,1,0)),iTime), vec3(0,0,5));\n    BuildCamera(pos, vec3(0,0,-1) - pos, vec3(0,1,0), 45.0, iResolution.x/iResolution.y);\n    #endif\n    \n    //Set Main Light\n    lights[0].o = vec3(4,4,4);\n    lights[0].col = vec3(100,100,100);\n    lights[0].o = quat_mul(quat(normalize(vec3(0,1,0)),iTime), lights[0].o);\n    \n    Sphere spheres[3];\n    //球1，从外部材质获得属性\n    spheres[0].o = vec3(-2,0,-2);\n    spheres[0].r = 1.0;\n    spheres[0].mat.type = MAT_TYPE_TEX;\n    spheres[0].mat.col = vec3(1);\n    spheres[0].mat.F0 = vec3(0.04);\n    \n    //球2，使用设置的pbr属性\n    spheres[1].o = vec3(2,0,-2);\n    spheres[1].r = 1.0;\n    spheres[1].mat.type = MAT_TYPE_PBR;\n    spheres[1].mat.col = vec3(1,1,0);\n    spheres[1].mat.metalness = 0.2;\n    spheres[1].mat.roughness = 0.8;\n    spheres[1].mat.F0 = vec3(0.04);\n\n    //球3，显示光源\n    spheres[2].o = lights[0].o;\n    spheres[2].r = 0.5;\n    spheres[2].mat.type = MAT_TYPE_SOLID;\n    spheres[2].mat.col = lights[0].col;\n    spheres[2].mat.F0 = vec3(0.04);\n    spheres[2].mat.ao = 0.;\n\n    vec3 col = vec3(0);\n    \n    Hit ht;\n    const float MAX_DIS = 99999999.;\n    ht.t = MAX_DIS;\n    const int samplerCount = 1;\n    for(int i = 0; i < samplerCount; i++){\n        Ray ray = BuildRay(fragCoord + vec2(rand(), rand()));\n        Intersect(spheres[0], ray, ht);\n        Intersect(spheres[1], ray, ht);\n        Intersect(spheres[2], ray, ht);\n        if(ht.t == MAX_DIS){\n            col += vec3(0);//texture(skybox, ray.d).xyz;\n        }\n        else {\n            if(ht.mat.type == MAT_TYPE_TEX){\n                #ifdef LOC_SHADER\n                ht.mat.roughness = texture(tex_roughness, ht.uv).r;\n                ht.mat.metalness = texture(tex_metallic, ht.uv).r;\n                //ht.mat.F0 = texture(tex_specular, ht.uv).xyz;\n                ht.mat.col = pow(texture(tex_basecolor, ht.uv).xyz, vec3(GAMMA));\n                ht.mat.ao = texture(tex_ao, ht.uv).r;\n                ht.n = GetNormalFromMap(tex_normal, ht.n, ht.p, ht.uv);\n                #else\n                ht.mat.col = texture(tex_basecolor, ht.uv).xyz * 1.;\n                ht.mat.roughness = fbm(ht.p);\n                ht.mat.metalness = 1. - fbm(ht.p);\n                ht.mat.ao = 0.0;\n                #endif\n\n                col += CalcLights(ray, ht);\n            }\n            else if(ht.mat.type == MAT_TYPE_PBR){\n                ht.mat.roughness = fbm(ht.p);\n                ht.mat.metalness = 1. - fbm(ht.p);\n                col += CalcLights(ray, ht);\n            }\n            else if(ht.mat.type == MAT_TYPE_SOLID){\n                col += ht.mat.col;\n            }\n        }\n    }\n\n    col /= float(samplerCount);\n    fragColor = vec4(col,1.0);\n}\n\n#ifdef LOC_SHADER\nvoid main(){\n    mainImage(FragColor, gl_FragCoord.xy);\n}\n#endif\n\n//https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n//https://freepbr.com/materials/rock-infused-with-copper-pbr-material/\n//http://artisaverb.info/PBT.html\n//https://www.cnblogs.com/timlly/p/10631718.html#lambert1760%E5%B9%B4\n//https://zhuanlan.zhihu.com/p/34473064\n//https://zhuanlan.zhihu.com/p/33464301\n//https://zhuanlan.zhihu.com/p/21983679\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}