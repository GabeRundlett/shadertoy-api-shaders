{
    "Shader": {
        "info": {
            "date": "1564409958",
            "description": "RayMarching Cloud Learning\n学习后，来个中文的注释把，希望能帮到小伙伴",
            "flags": 0,
            "hasliked": 0,
            "id": "tdfXDr",
            "likes": 2,
            "name": "RayMarchingCloudLearning",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "bluedrop",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "//Ref: https://www.shadertoy.com/view/WdXGRj\n//------------------------------------------------------------------------------------------------------------------\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000 *noise( p ); p = m*p*2.02;\n    f += 0.2500 *noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n\n//TODO： 多个形状\n//云形状\nfloat map(vec3 pos)\n{\n    vec3 p = pos - vec3(0., 0.5, 1.)*iTime;  //静态云的浮动\n    float f = fbm(p);\n    vec3 p1 = vec3(-1. + sin(iTime), .0, cos(iTime)*1.);\n    vec3 p2 = vec3(0., 0., 0.);\n    vec3 scale1 = vec3(.1, 1., .1);\n    vec3 scale2 = vec3(.6, 1., .6);\n\n    float s = 1.0-length(pos*scale1-p1) + f*2.2;    \n    float s2 = 1.0-length(pos*scale2-p2) + f*6.2;\n    //s += s2;\n    return clamp(s2, 0., 1.);\n}\n\n\n//光线步进主逻辑\n#define MAX_STEPS 48\n    //整个体积区域的范围\n#define VOLUME_LENGTH 15.\n    //阴影步进距离\n#define SHADOW_STEPS 8\n#define SHADOW_LENGTH 2.\n//小技巧，随机化来隐藏步进线导致的割裂\nfloat jitter;\n\nvec4 RayMarching(vec3 origin, vec3 ray){\n    float density = 0.0;\n    vec3 pos = origin;\n    float step_length = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(.0, -2.0, .0));  //光源\n    \n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    for(int i=0; i <MAX_STEPS; ++i){\n        \n        float d = map(pos);        //与场景中最近物体的距离\n        if(d > 0.001)\n        {\n            float shadow = 0.0;\n            vec3 spos = pos + light * jitter * shadowStepLength;\n            \n            for(int j = 0; j<SHADOW_STEPS; ++j)\n            {\n                spos += light * shadowStepLength;\n                float s_sample = map(spos);\n                shadow += s_sample;\n            }\n            density = clamp((d / float(MAX_STEPS))*20.0, 0.0, 1.0);\n            //density = clamp(d, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            sum.rbg += vec3(density * s) * vec3(1.1, 0.9, .5)* sum.a;    //阴影采样 + 阴影色彩\n            sum.a *= 1.0-density;\n            \n            //sum.rgb += exp(-map(pos)) * density * sum.a;  //透射\n            \n            sum.rgb += exp(-map(pos + vec3(0,0.25,0.0)) * .2) * density * vec3(0.15, 0.45, 1.1) * sum.a; //透射+色彩修正\n        }\n        pos += ray*step_length;         //当前步进的位置\n    }\n    return sum;\n}\n\n\n//设置摄像机\nmat3 camera(vec3 origin, vec3 target, float up)\n{\n    vec3 dir = normalize(target-origin);\n    vec3 world_up = vec3(sin(up), cos(up), 0.0);\n    vec3 dir_side = normalize(cross(dir, world_up));\n    vec3 dir_up = normalize(cross(dir_side,dir));\n    return mat3(dir_side, dir_up, dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = 2.*(fragCoord -.5*iResolution.xy) / iResolution.y;\n    vec2 mouse = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    jitter = hash(uv.x + uv.y * 57.0 + iTime);\n    //设置摄像机\n    vec3 origin = vec3(8., 5., 0.);  \n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 ray = camera(origin, target, 0.0) * rd;\n    //光线步进\n    vec4 col = RayMarching(origin, ray);\n    \n    //背景\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), uv.y + 0.75) * (col.a);\n    float sundot = clamp(dot(ray,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n    result = pow(result, vec3(1.0/2.2));\n    fragColor = vec4(result, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}