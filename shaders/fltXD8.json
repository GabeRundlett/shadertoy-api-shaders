{
    "Shader": {
        "info": {
            "date": "1639295492",
            "description": "Every few seconds, a new palette is generated (using some simple colour harmony principles) and visualised with some randomly-placed shapes. Occasionally it even produces something aesthetically pleasing!",
            "flags": 0,
            "hasliked": 0,
            "id": "fltXD8",
            "likes": 12,
            "name": "Colour Studies",
            "published": 3,
            "tags": [
                "procedural",
                "color",
                "palette",
                "generative",
                "lab",
                "colour",
                "colorspace",
                "geometric",
                "colourspace",
                "harmony",
                "oklab"
            ],
            "usePreview": 0,
            "username": "davidar",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "// 2021 David A Roberts <https://davidar.io>\n\n#define PI 3.14\n#define mx(a,b,v) mix(a, b, smoothstep(-texel, texel, v))\n\n#define U(lo,hi) (float(lo) + (float(hi) - float(lo)) * hash12(vec2(seed, nonce++)))\n#define RC palette[int(U(0,6))]\n#define RB palette[int(U(0,3))]\n#define RA palette[int(U(2,6))]\n\n#define mix22(i) mix(hash22(vec2(seed, -i)), hash22(vec2(seed, -float(i) - 0.5)), t)\n#define mix12(i) mix(hash12(vec2(seed, -i)), hash12(vec2(seed, -float(i) - 0.5)), t)\n\n#define C1 mx(RA, RB, length(uv - mix22(1)) - 0.1-0.4*mix12(2))\n#define C2 mx(RC, RA, length(uv - mix22(3)) - (0.1+0.4*mix12(4))*(0.25+0.5*mix12(6)))\n#define C3 mx(RA, C1, length(uv - mix22(7)) - 0.1-0.4*mix12(8))\n#define C  mx(C2, C3, length(uv - mix22(3)) - 0.1-0.4*mix12(4))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float texel = 1. / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv.x -= (iResolution.x / iResolution.y - 1.) / 2.;\n    \n    float seed = floor(iTime/2.);\n    float t = 0.4 + 0.1 * fract(iTime/2.);\n    \n    float q = 2.*PI*hash12(vec2(seed,1)) - 1.2; // base hue\n    float qo = q + ceil(3. * hash12(vec2(seed,2))) * PI/2.; // accent hue\n    vec2 ab1 = 0.25 * vec2(cos(q), sin(q));\n    vec2 ab1x = 0.2 * vec2(ab1.y, -ab1.x);\n    vec2 ab2 = 0.25 * vec2(cos(qo), sin(qo));\n    \n    vec3 palette[6] = vec3[](\n        // medium base\n        linear_srgb_from_oklab(vec3(0.40 * (hash12(vec2(seed,6))) + 0.10, ab1 * sqrt(hash12(vec2(seed,3))) + (hash12(vec2(seed,11)) * 2. - 1.) * ab1x)),\n        // light base\n        linear_srgb_from_oklab(vec3(0.50 * (hash12(vec2(seed,7))) + 0.50, ab1 * sqrt(hash12(vec2(seed,4))) + (hash12(vec2(seed,12)) * 2. - 1.) * ab1x)),\n        // dark base\n        linear_srgb_from_oklab(vec3(0.15 * (hash12(vec2(seed,12))) + 0.10, ab1 * sqrt(hash12(vec2(seed,5))) + (hash12(vec2(seed,13)) * 2. - 1.) * ab1x)),\n        // off-white\n        linear_srgb_from_oklab(vec3(0.95, ab1/9.)),\n        // mix of base and accent\n        linear_srgb_from_oklab(vec3(0.50 * (hash12(vec2(seed,10))) + 0.50, mix(ab1, ab2, 0.33))),\n        // accent\n        linear_srgb_from_oklab(vec3(0.50 + 0.30 * (hash12(vec2(seed,11))), ab2)));\n    \n    int nonce = 20;\n\n    float x1 = mix(U(0.5,1.5), U(0.5,1.5), t);\n    float x0 = mix(U(0.1,x1-0.1), U(0.1,x1-0.1), t);\n    float x2 = mix(U(x1+0.1,1.9), U(x1+0.1,1.9), t);\n    float y1 = mix(U(-0.5,0.5), U(-0.5,0.5), t);\n    float y0 = mix(U(-0.9,y1-0.1), U(-0.9,y1-0.1), t);\n    float y2 = mix(U(y1+0.1,0.9), U(y1+0.1,0.9), t);\n\n    vec3 col = mx(\n        mx(\n            mx(\n                mx(C, C, uv.x - uv.y - y0),\n                mx(C, C, uv.x - uv.y - y0),\n                uv.x - uv.y - y1),\n            mx(\n                mx(C, C, uv.x - uv.y - y2),\n                mx(C, C, uv.x - uv.y - y2),\n                uv.x - uv.y - y1),\n            uv.x + uv.y - x0),\n        mx(\n            mx(\n                mx(C, C, uv.x - uv.y - y0),\n                mx(C, C, uv.x - uv.y - y0),\n                uv.x - uv.y - y1),\n            mx(\n                mx(C, C, uv.x - uv.y - y2),\n                mx(C, C, uv.x - uv.y - y2),\n                uv.x - uv.y - y1),\n            uv.x + uv.y - x2),\n        uv.x + uv.y - x1);\n\n    fragColor = vec4(srgb_from_linear_srgb(col), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////\n//\n// Visualizing Bj√∂rn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n// https://www.shadertoy.com/view/WtccD7\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}