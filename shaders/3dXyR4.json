{
    "Shader": {
        "info": {
            "date": "1584204044",
            "description": "One more day.",
            "flags": 0,
            "hasliked": 0,
            "id": "3dXyR4",
            "likes": 3,
            "name": "#693 - Daily Experiments",
            "published": 3,
            "tags": [
                "2d",
                "experiment",
                "daily",
                "everyday"
            ],
            "usePreview": 0,
            "username": "sixclones",
            "viewed": 199
        },
        "renderpass": [
            {
                "code": "/* Code by Sixclones\n\nMy boilerplate: https://www.shadertoy.com/view/wdsyzH */\n\n// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)` */\nfloat map01(float n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\nvec2 map01(vec2 n, float start2, float stop2) {\n  return (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n/* rotate uv\nuv - uv to rotate\na - angle of the rotation\n\ninspired by Patricio Gonzalez Vivo (but in fact you find this everywhere)\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rotate.glsl\n*/\nvec2 rotate2d(vec2 uv, float a) {\n  uv = mat2(cos(a), -sin(a), sin(a), cos(a)) * uv;\n  return uv;\n}\n\n/* function to draw filled sdf\nx - sdf to draw\ns - size\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/fill.glsl */\nfloat fill(float x, float s) {\n  return 1.0 - step(s, x);\n}\n\n/* function to draw stroke\nx - sdf to draw\ns - size of the draw\nw - width of the stroke\np - precision of the stroke\n\ninspired by Pixel Spirit Deck `stroke` function by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/stroke.glsl */\nfloat stroke(float x, float s, float w, float p) {\n  return clamp(\n    S(x - 0.5 * w - p, x - 0.5 * w + p, s) * S(x + 0.5 * w + p, x + 0.5 * w - p, s),\n    0.0, 1.0\n  );\n}\n\n/* compute a rect signed distance field\nuv - uv of the screen\ns - size of the rect\n\nfrom Pixel Spirit Deck by Patricio Gonzalez Vivo\nhttps://github.com/patriciogonzalezvivo/PixelSpiritDeck/blob/master/lib/rectSDF.glsl */\nfloat rectSDF(vec2 uv, vec2 s) {\n  return max(abs(uv.x / s.s), abs(uv.y / s.y));\n}\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n  \tvec3 color = vec3(0.95);\n\n  \t// VIGNETTE\n  \tcolor -= S(0.55, 1.5, length(uv0));\n\n  \t// MASK\n    // compute the sdf of a rect\n  \tfloat rect = rectSDF(rotate2d(uv0, QP), vec2(0.5));\n    \n    // get a filled rect\n  \tfloat rectf = fill(rect, 0.65);\n    // color -= rectf; // uncomment to see the result of a fill\n\n    \n  \t// WAVES + MOIRÃ‰ = MAGIC\n    /* split between left & right, a more simple writing is `mix(-ht, ht, step(0.0, uv0.y))`\n\tthe step is done on 0.0 because uv0 goes from -1.0 to 1.0\n\tfinally the split is rotated\n    */\n  \tfloat timer = mix(\n    \t-ht, ht,\n    \tstep(0.0, rotate2d(uv0, -ht + cos(ht + QP * uv.y)).x)\n  \t);\n    \n    /* amplitude of the waves */\n  \tfloat amp = map01(cos(t + TP * uv.x), 0.1, 0.75);\n    \n    /* waves are computed with a sinus combined with lot of offsets and cos/sin */\n  \tfloat waves = amp * sin(t + 5.0 * TP * uv.x + 2.5 * P * uv.y\n    \t+ P * cos(-t + 5.0 * TP * uv.x * pow(uv.y, uv.x))\n\t\t+ pow(cos(timer + P * uv.y), uv.x)\n  \t);\n    \n    // subtle offset\n  \tfloat offset = t + uv.x;\n\n  \t// STRIPES\n    /* number of stripes */\n  \tfloat ns = 30.0;\n    \n    /* passing this to a cos/sin will give you stripes\n\tthis could have been done with `fract(ns * uv.y)` */\n  \tfloat _stripes = ns * TP * uv.y;\n    \n    /* compute static + animated stripes and */\n  \tvec2 stripes = map01(vec2(\n    \tcos(_stripes),\n    \tcos(_stripes + waves + offset)\n  \t), 0.0, 1.0);\n\n  \t// DRAWING PARAMS\n    /* normally size of the draw but with stripes if more like the position\n\twith 0.5 I assure that the stripe is in the middle of the render\n\t(not clear comment, I admit, sorry)\n\t*/\n    float s = 0.5;\n  \tfloat w = 0.2; // width of strokes\n  \tfloat p = 50.0 / iResolution.x; // precision of strokes to avoid aliasing\n\n    // RENDER\n    // we create a mask by multiplying the addition of the stripes (static + animated) to the rect filled\n    color -= rectf * (stroke(stripes.x, s, w, p) + stroke(stripes.y, s, w, p));\n\n  \tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}