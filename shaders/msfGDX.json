{
    "Shader": {
        "info": {
            "date": "1666893223",
            "description": "Simple starfield using multiple octaves of noise being cycled and scaled over time, combined with star shimmer and a small amount of nebulosity in the background.\n\nIt's all a massive hack, but I was after a calm starfield to keep my gpu warm.",
            "flags": 0,
            "hasliked": 0,
            "id": "msfGDX",
            "likes": 13,
            "name": "Starfield from noise octaves",
            "published": 3,
            "tags": [
                "noise",
                "starfield"
            ],
            "usePreview": 0,
            "username": "CaffeinePwrdAl",
            "viewed": 561
        },
        "renderpass": [
            {
                "code": "//#define USE_SIMPLE_NOISE\n\n/* ------------------------------------------------------------------------ */\n/*\n    Gradient Noise - https://www.shadertoy.com/view/XdXGW8\n*/\n/* ------------------------------------------------------------------------ */\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if defined(USE_SIMPLE_NOISE)\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n/* ------------------------------------------------------------------------ */\n\nvec3 saturate(vec3 c)\n{\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat saturate(float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\n/* ------------------------------------------------------------------------ */\n\nconst float cycle_len_s = 20.0;\nfloat fade_time = 7.0;\nfloat max_scale_pow = 3.0;\nfloat max_scale = 3.0;\n\nfloat speed_adjust = 1.0;\nfloat global_time = 0.0;\n\nvec2 screen_uv = vec2(0.0);\n\n/* ------------------------------------------------------------------------ */\n\nvec3 stars(vec2 uv, float seed)\n{\n    const float threshold = 0.6;\n    float stars = noise(uv + vec2(seed, seed));\n    \n#if defined(USE_SIMPLE_NOISE)\n    stars *= 1.25;\n#endif\n        \n    vec3 col = vec3(stars) - threshold;\n    col *= (1.0/(1.0 - threshold));\n    return saturate(col);\n}\n\nvec2 stars_uv(vec2 fragCoord, float scale)\n{\n    vec2 uv = screen_uv - vec2(0.5);\n    uv *= iResolution.xy * 0.25;\n    uv /= scale;\n    return uv;\n}\n\nfloat star_fade(float age)\n{\n    float fade_out = 1.0 - smoothstep(cycle_len_s - fade_time, cycle_len_s, age);\n    float fade_in = smoothstep(0.0, fade_time, age);\n    return fade_in * fade_out;\n}\n\nvec3 star_field_octave(float start_age, vec2 fragCoord, float seed)\n{\n    // Draws a plane of stars that fades in, increases in size giving\n    // the impression of movement towards the viewer, and fades out at\n    // the end. Each plane cycles from back-to-front in a loop\n#if 0\n    float fade, scale;\n    if (start_age >= 0.0)\n    {\n        float cycle_time = mod(global_time + start_age, cycle_len_s);\n        float t = (cycle_time / cycle_len_s);\n        fade = star_fade(cycle_time);\n        scale = 1.0 + pow(t, max_scale_pow) * max_scale;\n    }\n    else\n    {\n        fade = 1.0;\n        scale = 1.0;\n    }\n#else\n    \n    float cycle_time = mod(global_time + start_age, cycle_len_s);\n    float t = (cycle_time / cycle_len_s);\n    \n    float fade = star_fade(cycle_time);\n    float scale = 1.0 + pow(t, max_scale_pow) * max_scale;\n    \n    fade = (start_age < 0.0)?(1.0):(fade);\n    scale = (start_age < 0.0)?(1.0):(scale);\n#endif\n\n    vec2 uv = stars_uv(fragCoord, scale);\n    vec3 col = fade * stars(uv, seed);\n    \n    return col;\n}\n\nfloat star_shimmer()\n{\n    // Intersecting noise to modulate the stars but be random enough\n    // that your eye doesn't quite see the scrolling of the pattern\n    vec2 uv = screen_uv;\n    float shimmer_speed = iTime * 2.0;\n    float octave_a = abs(noise(vec2(23.0, 19.0) * uv + vec2(shimmer_speed)));\n    float octave_b = abs(noise(vec2(27.0, -29.0) * uv + vec2(shimmer_speed)));\n    return 0.5 + 0.5 * saturate(octave_a + octave_b);\n}\n\nvec2 rotate2d(vec2 v, float r)\n{\n    float cos_r = cos(r);\n    float sin_r = sin(r);\n    mat2 m = mat2(cos_r, -sin_r, sin_r, cos_r);\n    return v * m;\n}\n\nvec4 nebula()\n{\n    vec2 uv = screen_uv;\n    \n    float debug_rot = 0.2f;\n    vec2 uv_r = rotate2d(uv, global_time * 0.0125 * debug_rot);\n    vec2 uv_g = rotate2d(uv, global_time * -0.00625 * debug_rot);\n    vec2 uv_b = uv;\n    \n    uv_r += vec2(-1.0, 1.0) * vec2(global_time * 0.05 * debug_rot);\n    uv_g += vec2(1.0, 1.0) * vec2(global_time * 0.03 * debug_rot);\n    uv_b += vec2(1.0, -1.0) * (global_time * 0.01 * debug_rot);\n    \n    vec4 neb = vec4(0.0);\n    \n    // Red and green are two independent combinations of multi-octave noise \n    float r = 1.3 * (noise(vec2(192.0) + uv_r * 3.2))\n            + 0.5 * (noise(vec2(1123.0) + uv_r * 5.7))\n            //+ 0.1 * (noise(vec2(173.0) + uv_b * 35.7))\n            + 0.1 * (noise(vec2(173.0) + uv_r * 125.7));\n    \n    float g = 1.1 * (noise(vec2(17.0) + uv_g * 2.3))\n            + 0.6 * (noise(vec2(41.0) + uv_r * 5.2))\n            //+ 0.2 * (noise(vec2(97.0) + uv_g * 19.4))\n            + 0.1 * (noise(vec2(137.0) + uv_g * 65.7));\n    \n    neb.r = saturate(r * 0.5);\n    neb.g = saturate(g * 0.5);\n    \n    // Blue occurs as a noise plane within the green and red areas of nebula\n    neb.b = 1.0 * noise(vec2(179.0) + uv_b * 3.2)\n          //+ 0.4 * noise(vec2(242.0) + uv_b * 17.0)\n          + 0.1 * noise(vec2(342.0) + uv_b * 45.0);\n    neb.b = saturate(2.0 * (neb.r + 0.8*neb.g) * neb.b);\n    \n    // Add a bit of b in r/g\n    neb.g += 0.1 * neb.b;\n    neb.r += 0.2 * neb.b;\n    \n    neb.r += 0.2 * neb.g;\n    \n    // Interstellar dust\n    neb.a = 0.1 * neb.r + 0.2 * neb.g + 0.1 * neb.b;\n    neb.a += saturate(0.25 + 0.75 * noise(vec2(457.0) + uv * 3.12));\n    \n    return neb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate some initial globals\n    screen_uv = fragCoord / iResolution.xy;\n    global_time = iTime * speed_adjust;\n    \n    // Offset the 4 planes of stars by 1/4 cycle length\n    float age_offset = cycle_len_s * 0.25;\n    \n    float shimmer = star_shimmer();\n    vec4 neb = nebula();\n    \n    vec3 col = vec3(0.0)\n        + 0.2 * neb.rgb\n        + neb.a * star_field_octave(-1.0, fragCoord, 265.0) * shimmer;\n        \n    vec3 stars = vec3(0.0) \n        + star_field_octave(0.0 * age_offset, fragCoord, 42.0)\n        + star_field_octave(1.0 * age_offset, fragCoord, 93.0)\n        + star_field_octave(2.0 * age_offset, fragCoord, 137.0)\n        + star_field_octave(3.0 * age_offset, fragCoord, 17.0)\n        ;\n    stars *= shimmer;   \n    col += stars;\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}