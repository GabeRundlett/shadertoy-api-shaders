{
    "Shader": {
        "info": {
            "date": "1629992019",
            "description": "A very basic raymarching thingie.\nClickdrag mouse to rotate camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "sddGW7",
            "likes": 3,
            "name": "pali raymarching 1",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "pali6",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "vec3 camPos = vec3(0, 0, 0);\nvec3 camDir = vec3(0, 0, -1);\nvec3 camUp = vec3(0, 450. / 800., 0);\nfloat camF = 0.5;\nfloat rtStep = 0.4;\nfloat rtlStep = 0.025;\nfloat rtglStep = 0.3;\nconst int maxSteps = 32;\nconst int maxlSteps = 32;\nconst int maxglSteps = 32;\n\nfloat time;\n\nvec3 lightPos = vec3(4, 3, -1);\n\nvec3 INVALID = vec3(1e10, 1e20, -1e30);\n\nfloat smin(float a, float b)\n{\n    return (a + b - log(exp(a - b) + exp(b - a))) / 2.;\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 rayDir(vec2 uv)\n{\n    vec3 camRight = normalize(cross(camDir, camUp));\n    return normalize(camDir * camF + (uv.y - 0.5) * 2. * camUp + (uv.x - 0.5) * 2. * camRight);\n}\n\nvec3 orbit(vec3 normal, float dist, float speed, float offset)\n{\n    vec3 v1 = normalize(cross(normal, vec3(0.42, 0.1, -0.1)));\n    vec3 v2 = normalize(cross(normal, v1));\n    return dist * (v1 * cos(time * speed + offset) + v2 * sin(time * speed + offset));\n}\n\nfloat scene(vec3 pos)\n{\n    vec3 ballCenter = vec3(0, 0, -5);\n    float ballRadius = 2.;\n    float result =  distance(pos, ballCenter) - ballRadius + sin(pos.y * 5. + time) / 3. * cos(time * 0.2);\n    vec3 ballCenter2 = ballCenter + orbit(vec3(0, 1, 0), 3., 1., 0.);\n    result = smin(result, distance(pos, ballCenter2) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 12, 0), 2.7, 1.7, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-4, 2, 5), 2.7, 1.8, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(8, 7, -8), 2.7, 1.9, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-14, -5, -1), 2.7, 2.0, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(1, 12, 0), 2.7, 0.8, 0.8)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-7, -5, 8), 2.6, 1.7, 0.1)) - 0.3);\n    result = smin(result, distance(pos, ballCenter + orbit(vec3(-1, 1, 22), 2.5, 1.2, 0.2)) - 0.3);\n    result = smin(result, distance(pos, ballCenter2 + orbit(vec3(0.1, -0.5, -1), 0.8, -0.41, -0.2)) - 0.15);\n    /*\n    result -= (dot(pos - ballCenter, normalize(vec3(1, 3, 7)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(-7, 2, 1)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(2, -1, 0.3)))) * 0.1;\n    result -= (dot(pos - ballCenter, normalize(vec3(4, 3, -1)))) * 0.1;\n    */\n    // result += 1./distance(pos, vec3(-2, -2, -7));\n    result = 2. - abs(result - 2.);\n    result = smin(result, length((pos - ballCenter).xz) - 0.3);\n    return result;\n}\n\nvec3 sceneNormal(vec3 pos)\n{\n    float d = 0.001;\n    float base = scene(pos);\n    return normalize(vec3(\n        scene(pos + vec3(d, 0, 0)) - base,\n        scene(pos + vec3(0, d, 0)) - base,\n        scene(pos + vec3(0, 0, d)) - base\n    ));\n}\n\nvec4 rt(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float retVal = 0.;\n    float stp = rtStep;\n    for(int i = 0; i < maxSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0.001)\n        {\n            retVal = 1.;\n        }\n        if(sign(val * lastVal) == -1.)\n            stp /= 2.;\n        lastVal = val;\n        rayPos += rayDir * stp * sign(val);\n    }\n    return vec4(rayPos, 1.);\n}\n\nvec4 rtl(vec3 rayPos, vec3 rayDir, float maxDist)\n{\n    float lastVal = 0.;\n    float tot = 0.;\n    for(int i = 0; i < maxlSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(maxDist <= 0.1 || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            rayPos -= rtStep * rayDir * a;\n            return vec4(rayPos, tot);\n        }\n        if(val <= 0.001)\n            tot += rtlStep * (-val);\n        lastVal = val;\n        float step = rtlStep;\n        maxDist -= length(rayDir) * step;\n        rayPos += rayDir * step;\n    }\n    return vec4(rayPos, tot);\n}\n\nfloat rtgl(vec3 rayPos, vec3 rayDir)\n{\n    float lastVal = 0.;\n    float result = 0.;\n    for(int i = 0; i < maxglSteps; i++)\n    {\n        float val = scene(rayPos);\n        if(val < 0. || val > 40.)\n        {\n            float a = -val / (lastVal - val);\n            // val = (lastVal + val) / 2.;\n            //result += rtStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * a;\n            return result;\n        }\n        //if(lastVal > 0.1 && val < 0.09)\n        //    result += rtStep * val * 3.;\n        result += rtglStep * smoothstep(0.1, 0.2, val) * (1. - smoothstep(0.2, 0.3, val)) * val * val;\n        // result += min(10., 1. / pow(val, 2.2) * smoothstep(0., 1., (val - 0.05) / 0.1)) * rtStep;\n        rayPos += rayDir * rtglStep * val;\n        lastVal = val;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    lightPos = vec3(3., 3.*sin(iTime), -1. + cos(iTime));\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    camPos = vec3(cos(mousePos.x * 3.14 * 2.), -(mousePos.y - 0.5) * 1.5, sin(mousePos.x * 3.14 * 2.)) * 4.5 + vec3(0, 0, -5);\n    camDir = normalize(vec3(0, 0, -5) - camPos);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    \n    vec4 hitInfo = rt(camPos, rayDir(uv));\n    vec3 hit = hitInfo.xyz;\n    if(hitInfo.w != 0.)\n    {\n        vec4 lightHitInfo = rtl(lightPos, hit - lightPos, distance(hit, lightPos));\n        vec3 lightHit = lightHitInfo.xyz;\n        col = mix(vec3(1, 0.1, 0.2), vec3(0.4, 0.4, 0.2), distance(hit, vec3(0, 0, -5)) / 6.);\n        /*if(distance(hit, vec3(0, 0, -5)) > 4.)\n            col = vec3(0.4, 0.25, 0.2);\n        else\n            col = vec3(1, 0.1, 0.2);// * (1.-abs(dot(rayDir(uv), sceneNormal(hit))));\n        */\n        float light = 0.1;\n        light += 4. / distance(lightHit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)) * (1. / (1. + lightHitInfo.w * 100.)));\n        // light += 4. / distance(hit, lightPos) * max(0., dot(sceneNormal(hit), -normalize(hit - lightPos)));\n        col *= light;\n        // col -= vec3(1.-light, 1.-light, 1.-light);\n    }\n    else\n    {\n        col = vec3(0, 0, 0); //texture(iChannel0, hit.xy / 5.0 - vec2(1, 1)).xyz;\n    }\n    col.b += rtgl(camPos, rayDir(uv)) * 5.;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}