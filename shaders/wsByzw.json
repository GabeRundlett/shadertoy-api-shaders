{
    "Shader": {
        "info": {
            "date": "1586657482",
            "description": "3D fractal -> http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nhsv2rgb -> https://www.shadertoy.com/view/MsS3Wc",
            "flags": 0,
            "hasliked": 0,
            "id": "wsByzw",
            "likes": 6,
            "name": "Mandelbulb_rainbow",
            "published": 3,
            "tags": [
                "fractal",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "elle",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "vec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nbool backgr = false;\n\nfloat distanceEstimate(vec3 p)\n{\n    float bailout = 2.0;\n\tfloat dSphere = -distSphere(p, 12.0);\t\n\tvec3 v = p;\n\tfloat r = 0.0;\n\tfloat dr = 1.0;\n\tfloat power = abs(cos(iTime * 0.02)) * 10.0 + 2.0;\n\tfor(float n = 0.0; n <= 8.0; n++)\n\t{\n\t\tr = length(v);\n\t\tif(r > bailout)\n            break;\n        // convert to polar coordinate\n\t\tfloat theta = acos(v.z / r);\n\t\tfloat phi = atan(v.y, v.x);\n\t\tdr = pow(r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat vr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tv = vr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        \n        v += p;\n\t}\n\tfloat dFractal = 0.50 * log(r) * r / dr;\t\n\tbackgr = dSphere < dFractal ? true : false;\n\treturn (min(dFractal, dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);\n    vec3 ro = rotate(vec3(0.0, 0.0, 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.0, 0.3, 0.77), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.8, 0.9, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(backgr == true)\n\t{ \n        color = vec3(0.3, 0.8, 1.0) * (0.5 - 0.4 * uv.x);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n\tvec3 norm = getNormal(ro, dist);\n\tmaterial = hsv2rgb(vec3(dot(ro, ro) - 0.27, 1.2, 1.0));\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 5.0);\n    float ambient = 0.22;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 0.9;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 1.8;\n \tcolor = (lightColor * (ambient + diff + spec) * material);  \n\tcolor = pow(color, lightColor); \n\tvec2 fd = (6.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    color *= 1.0 - length(fd) * 0.07;\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}