{
    "Shader": {
        "info": {
            "date": "1619200325",
            "description": "a small 2D tron game:\nthe rules are simples:\n - survive the longer\n - you die if cross the wall of any player or ou go out of bound\n\ncommandes:\nblue player: arrow key\nred player: a,d or q,d\n\npress space to restart",
            "flags": 112,
            "hasliked": 0,
            "id": "fdsXDB",
            "likes": 11,
            "name": "Tron  (2 player game)",
            "published": 3,
            "tags": [
                "game",
                "tron",
                "bloom"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 964
        },
        "renderpass": [
            {
                "code": "/*\na small 2D tron game,\n\nthe rules are simples:\n - survive the longest\n - you die if cross the wall of any player or ou go out of bound\n\ncommandes:\n *blue player: arrow key\n *red player: a,d or q,d\n\npress 'space' to restart\n\nhave fun and leave a like ;)\n*/\n\n\n//apply bloom effect\nfloat normpdf(in float x)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j));\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel2, (fragCoord.xy+vec2(0.0, float(i))) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n    \n    vec3 col =  texture(iChannel0, uv).xyz + final_colour/(Z)*1.6;\n    \n    //vigniettage\n    col *= 0.2 + 0.8*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.4 );\n    \n    //debug mode\n    //col += 0.5*texture(iChannel1, uv*0.1).rgb;\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//game variables\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool onVar(vec2 coord){\n    return (inBox(currentCoord, vec4(coord, 1., 1.)));\n}\n\nbool keyPress(int key){\n    return (texture(iChannel1, vec2(float(key)/255.0, 0.5)).x == 1.0);\n}\nvoid initVars(){\n    if (onVar(_endGame)) outValue = vec4(0.0);\n    if (onVar(_p1)) outValue = vec4(-0.5, -0.1, 1.0, 0.0);\n    if (onVar(vec2(0.0, wall1))) outValue = vec4(-0.5, -0.1, 1.0, 0.0);\n    if (onVar(_p2)) outValue = vec4(0.5, 0.1, -1.0, 0.0);\n    if (onVar(vec2(0.0, wall2))) outValue = vec4(0.5, 0.1, 1.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    currentCoord = fragCoord;\n    outValue = vec4(0.0);\n    bool endGame = (load(_endGame).x == 1.0);\n    if(iFrame == 0 || (endGame && keyPress(32))){\n        initVars();\n    }else{   \n        bool pressD = keyPress(D);\n        bool pressA = keyPress(A);\n        bool pressQ = keyPress(Q);\n        bool pressLeft = keyPress(LEFTARROW);\n        bool pressRight = keyPress(RIGHTARROW);\n        // car mouvement and reaction to inputs\n        if(onVar(_p1)){\n            vec4 p1 = load(_p1);\n            if (!endGame){\n                p1.xy += p1.zw * carSpeed * iTimeDelta;\n\n                if(pressD){\n                    p1.zw = mat2x2(0.0, -1.0,\n                                   1.0,  0.0)*p1.zw;\n                }\n                if(pressA || pressQ){ // for ZQSD or WASD\n                    p1.zw = mat2x2(0.0, 1.0,\n                                  -1.0, 0.0)*p1.zw;\n            }}\n            outValue = p1;\n        }\n        if(onVar(_p2)){\n            vec4 p2 = load(_p2);\n            if (!endGame){\n                p2.xy += p2.zw * carSpeed * iTimeDelta;\n\n                if(pressRight){\n                    p2.zw = mat2x2(0.0, -1.0,\n                                   1.0,  0.0)*p2.zw;\n                }\n                if(pressLeft){ // for ZQSD or WASD\n                    p2.zw = mat2x2(0.0, 1.0,\n                                  -1.0, 0.0)*p2.zw;\n                }}\n            outValue = p2;\n        }\n        \n        //check if the game should end\n        if(onVar(_endGameTime)){\n            if(!endGame){\n                outValue = vec4(iTime, 0.0, 0.0, 0.0);\n            }else{\n                outValue = load(_endGameTime);\n            }\n        }\n        if(onVar(_endGame)){\n            vec4 gameResult = vec4(0.0);\n            if(endGame){\n                gameResult = load(_endGame);\n            }else{\n            \n                //first car\n                vec4 p1 = load(_p1);\n                vec4 p2 = load(_p2);\n                \n                vec2 lastPos = p2.xy;\n                for(int i = 0; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall2)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p1.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xy += vec2(touch);\n                    lastPos = wp.xy;\n                }\n                lastPos = load(vec2(2, wall1)).xy;\n                for(int i = 3; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall1)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p1.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xy += vec2(touch);\n                    lastPos = wp.xy;\n                }\n                \n\n                //second car\n                lastPos = p1.xy;\n                for(int i = 0; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall1)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p2.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xz = vec2(touch);\n                    lastPos = wp.xy;\n                }\n                lastPos = load(vec2(2, wall2)).xy;\n                for(int i = 3; i < 256; i++){\n                    vec3 wp = load(vec2(i, wall2)).xyz;\n                    if(wp.z < 0.9 || gameResult.x > 0.5) break; \n                    vec2 dxy = max(abs(p2.xy - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n                    float touch = 1.0 - step(0.0, sqrt(dot(dxy,dxy)) - 0.5*carWidth);\n                    gameResult.xz = vec2(touch);\n                    lastPos = wp.xy;\n                }\n                //check if a car goes outside the screen\n                vec2 pointTop = vec2(iResolution.x/iResolution.y, 1.0);\n                vec2 off1 = abs(p1.xy) - pointTop;\n                gameResult.xy += step(0.0, max(off1.x, off1.y));\n                vec2 off2 = abs(p2.xy) - pointTop;\n                gameResult.xz += step(0.0, max(off2.x, off2.y));\n                if(gameResult.x > 1.5){ //both dead -> random winner\n                    float r =  fract(sin((iTime + iDate.w*0.1)*100.0)*100.0); // poor random\n                    if(r < 0.5){gameResult.y = 0.0;\n                    }else{      gameResult.z = 0.0;}\n                }\n                gameResult.x = min(gameResult.x, 1.0);\n                \n            }\n            outValue = gameResult;\n        }\n        // storage of new walls if the car turn\n        if(wall1 <= currentCoord.y && currentCoord.y < wall1+1.0){\n            if(pressA || pressQ || pressD){\n                vec4 p1 = load(_p1);\n                if (currentCoord.x < 1.0){\n                    outValue = vec4(p1.x, p1.y, 1.0, 0.0);\n                }else{\n                    outValue = load(currentCoord - vec2(1.0, 0.0));\n                }\n            }else{\n                outValue = load(currentCoord);\n            }\n        }\n        if(wall2 <= currentCoord.y && currentCoord.y < wall2+1.0){\n            if(pressLeft || pressRight){\n                vec4 p2 = load(_p2);\n                if (currentCoord.x < 1.0){\n                    outValue = vec4(p2.x, p2.y, 1.0, 0.0);\n                }else{\n                    outValue = load(currentCoord - vec2(1.0, 0.0));\n                }\n            }else{\n                outValue = load(currentCoord);\n            }\n        }\n    }\n    fragColor = outValue;\n}\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float text(float looser, vec2 uv){\n    if(uv.y > 0.5){//color of the winner \"BLUE\" or \"RED\"\n        uv.y = 2.0*(uv.y-0.5);\n        if(looser < 0.5){//red loose\n            int letterID = int(floor(uv.x*4.0));\n            uv.x = fract(uv.x*4.0);\n            uv = uv*0.8 + 0.1;\n            vec2 co;\n            if(letterID == 0)co = vec2(2.0, 11.0);\n            if(letterID == 1)co = vec2(12.0, 11.0);\n            if(letterID == 2)co = vec2(5.0, 10.0);\n            if(letterID == 3)co = vec2(5.0, 11.0);\n            return texture(iChannel1, (co + uv)/16.0).x;\n        }else{\n            int letterID = int(floor(uv.x*3.0));\n            uv.x = fract(uv.x*3.0);\n            uv = uv*0.8 + 0.1;\n            vec2 co;\n            if(letterID == 0)co = vec2(2.0, 10.0);\n            if(letterID == 1)co = vec2(5.0, 11.0);\n            if(letterID == 2)co = vec2(4.0, 11.0);\n            return texture(iChannel1, (co + uv)/16.0).x;\n        }\n    }else{// \"WIN\"\n        uv.y*=2.0;\n        int letterID = int(floor(uv.x*3.0));\n        uv.x = fract(uv.x*3.0);\n        uv = uv*0.8 + 0.1;\n        vec2 co;\n        if(letterID == 0)co = vec2(7.0, 10.0);\n        if(letterID == 1)co = vec2(9.0, 11.0);\n        if(letterID == 2)co = vec2(14.0, 11.0);\n        return texture(iChannel1, (co + uv)/16.0).x;\n    }\n}\n// game scene\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y; \n    vec3 col = vec3(0.05, 0.0, 0.1)*2.0; //background\n    \n    //first car\n    vec4 p1 = load(_p1);\n    vec2 lastPos = p1.xy;\n    float p1Wall = 0.0;\n    for(int i = 0; i < 256; i++){\n        vec3 wp = load(vec2(i, wall1)).xyz;\n        if(wp.z < 0.9) break; \n        vec2 dxy = max(abs(uv - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n        p1Wall = max(1.0 - smoothstep(0.0, 0.001, sqrt(dot(dxy,dxy)) - 0.00001), p1Wall);\n        lastPos = wp.xy;\n    }\n    col += vec3(1.0, 0.6, 0.3) * p1Wall;\n    vec2 duvp1 = abs(uv - p1.xy);\n    float carWeight = smoothstep(0.0, carWidth*0.2, carWidth - max(duvp1.x, duvp1.y));\n    col = mix(col, vec3(1.0, 0.6, 0.3)*3.0, carWeight);\n    \n    //second car\n    vec4 p2 = load(_p2);\n    lastPos = p2.xy;\n    float p2Wall = 0.0;\n    for(int i = 0; i < 256; i++){\n        vec3 wp = load(vec2(i, wall2)).xyz;\n        if(wp.z < 0.9) break; \n        vec2 dxy = max(abs(uv - 0.5*(lastPos + wp.xy)) - (wallWidth + abs(lastPos - wp.xy))*0.5, vec2(0.0));\n        p2Wall = max(1.0 - smoothstep(0.0, 0.001, sqrt(dot(dxy,dxy)) - 0.00001), p2Wall);\n        lastPos = wp.xy;\n    }\n    col += vec3(0.3, 0.6, 1.0) * p2Wall;\n    vec2 duvp2 = abs(uv - p2.xy);\n    carWeight = smoothstep(0.0, carWidth*0.2, carWidth - max(duvp2.x, duvp2.y));\n    col = mix(col, vec3(0.3, 0.6, 1.0)*3.0, carWeight);\n    \n    //death annim\n    vec4 endGame = load(_endGame);\n    if(endGame.x > 0.9){\n        vec3 dead; //0=red   1=blue\n        if(endGame.y > 0.9)dead = vec3(load(_p1).xy, 0.0);\n        if(endGame.z > 0.9)dead = vec3(load(_p2).xy, 1.0);\n        float t = iTime - load(_endGameTime).x;\n        float t2 = pow(max(0.0, t), 5.0)*0.3;\n        float c = smoothstep(0.0, 0.01,length(uv - dead.xy)-t2); \n        col = mix(col, vec3(1.0), 0.2*(1.0-c));\n        c *= smoothstep(0.0, 0.01,-length(uv - dead.xy)+t2+0.05);\n        col = mix(col, vec3(1.0), c);\n        \n        //winner announcement\n        float t3 = max(t-2.0, 0.0);\n        float k3 = 1.0/(1.0+exp(-3.0*t3 + 2.0));\n        col = mix(col, vec3(0.0), 0.8*k3);\n        \n        vec2 pointTop = vec2(iResolution.x/iResolution.y, 1.0)*0.75;\n        vec2 off1 = abs(uv) - pointTop;\n        k3 = max(0.0, k3-0.2)*2.5;\n        k3 *= 1.0-step(0.0, max(off1.x, off1.y));\n        vec3 textColor = mix(vec3(0.3, 0.6, 1.0), vec3(1.0, 0.6, 0.3), dead.z);\n        \n        col = mix(col, textColor, smoothstep(0.5, 0.51, text(dead.z, fragCoord/iResolution.xy*1.5-0.25))*k3);\n\n    }\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 26841,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/algoritmos666/tron-legacy-soundtrack-ost-03"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define wallWidth 0.027\n#define carWidth 0.03\n#define carSpeed 0.4\n\n//keys\n#define Q 81\n#define A 65\n#define D 68\n#define LEFTARROW 37\n#define RIGHTARROW 39\n\n//bloom\n#define mSize 31\n#define sigma 6.0\n\n//variables management from https://www.shadertoy.com/view/wsByWV\n//shared variables (in buffer A)\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.0\n#define wall1 1.0\n#define wall2 2.0\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy))\n\nvar(_p1, 0, varRow); // p.x, p.y, v.x, v.y\nvar(_p2, 1, varRow);\nvar(_endGame, 2, varRow); // x:the game end, y:p1 loose, z:p2 loose\nvar(_endGameTime, 3, varRow);  //time in the end for death animations\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//apply bloom effect\nconst float brightnessMin = 0.6;\n\nfloat brightPassFilter(vec3 color){\n    return step(brightnessMin, dot(color, vec3(0.333, 0.333, 0.333)));\n}\n\nfloat normpdf(in float x){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j));\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel0, (fragCoord.xy+vec2(float(i),0.0)) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c*brightPassFilter(c);\n  \n    }\n\n\n    fragColor = vec4(final_colour/(Z), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}