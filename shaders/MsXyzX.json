{
    "Shader": {
        "info": {
            "date": "1489075284",
            "description": "learning text font, made alternative \"out of bounds\" checks, non branching.\n\nturned into a performance test on branchless coding.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsXyzX",
            "likes": 6,
            "name": "text lines rows alternative",
            "published": 3,
            "tags": [
                "text",
                "lines",
                "branchless",
                "columns"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 804
        },
        "renderpass": [
            {
                "code": "//learning to use the sdf text font on //https://www.shadertoy.com/view/ltcXzs\n//first step is arranging it to lines and rows, scaling nicely\n//while being movable (by mouse)\n//also made an alternative to \"out of bounds\" check.\n\n//modifiable constants:\n#define lines 10\n#define rows  26\n#define size  (sin(iTime)*.1+.4)\n//spacing between characters:\n#define spacing vec2(.7,1.)\n\n//remove the line below to no longer cycle glyph positions\n#define cycle\n\n#ifdef cycle\n  #define cyc int(iTime*2.)\n#else\n  #define cyc 1\n#endif\n//end of modifiables:\n\n//alias to make branching conditionals be calculated as non branching:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//ifb(a,b,c) ::is idenfical to:: if(a<0.){return b;}else{return c;} ::but branchless:\n//because: //step(a,b);//if (a<b)return 0.; return 1.; (for each element of a vevtor)\n//branchless code -> longer pipelines on newer hardware -> likely better performance.\n//branchless code -> +1add +1mult, even slower on older hardware.\n//branchless code -> b & c are both calculated and substracted.\n//this can cause extra calculations and more rounding errors. \n//as only one distance between b and c really matters.\n//but it more likely increses performance when used within an often used sibroutine.\n//::end of \"on making code branchless\"\n\n//return distance to square, center at [0:0], corners are at [+-.5:+-.5]\nfloat isOutside(vec2 p){\n //p.x*=2.;//scaling to rectangle\n float offsetXY=.5;//diagonally offset the squares center away from [0:0].\n vec2 d=abs(p-offsetXY)-.5;return max(d.x,d.y);}\n\n//making \"out of bounds\" check branchless:\nfloat isInside2(vec2 p){\n  return step(isOutside(p),0.);//fastest, less sub()s than ifb(isInside(p),1.,0.)\n  //return ifb(isOutside(p),0.,1.);//faster\n  //if (isOutside(p)>0.)return 0.;return 1.;//fast\n  //if (p.x<0.||p.x>1.||p.y<0.||p.y>1.)return 0.;return 1.;//slower\n}\n\n//to my 2011 hardware, branchless subroutines are a few fps faster,\n//as every unpredictable branch costs roughly +1fps for every 300 repeats.\n//\n//Higher routines that use less-branching subroutines \n//can still perform faster with a branching shortcut,\n//that may skip a texture read,\n//based on a result from a branchless calculation\n//doubling that +1fps boost to almost +3fps per branch being repeated 300 times.\n//\n//bottom line; \n//the more a function is used as subroutine, \n//the more brnanchless it should be.\n//and the more subroutines a function uses, \n//the more sense can unpredictable shortcut branches make.\n//\n//this shader is defaulted to THAT and performs with 50 fps, \n//the other way around, branching subroutines being used \n//in a branchless fashion, is as low as 40 fps.\n\n// --- access to the image of ascii code c\nvec4 char(vec2 p, int C){\n  float t=isInside2(p);\n  if(t==0.)return vec4(0);return \n  //return t* //more branchless alternative to above line\n  //\n  //early exit contition performs faster on branchless isInside2\n  //and slower on branching (|| || ||) isinside2()\n     \n  //texture(iChannel0,p/16.+fract(vec2(C,15-C/16)/16.));\n  //textureLod(iChannel0,p/16.+fract(vec2(C,15-C/16)/16.),log2(length(fwidth(p/16.*iResolution.xy))));\n  textureGrad(iChannel0,p/16.+fract(vec2(C,15-C/16)/16.),dFdx(p/16.),dFdy(p/16.));\n    // possible variants: (but better separated in an upper function) \n    //     - inout pos and include pos.x -= .5 + linefeed mechanism\n    //     - flag for bold and italic \n}\n\nvoid mainImage( out vec4 r, in vec2 i ){\n  //p.xyzw stores fragment.xy in p.xy and mouse,xy in p.zw:\n  //saves some identical mults, as we scale mouse and fragment pos equally.\n  vec4 p=vec4(i.xy,iMouse.xy)/iResolution.xyxy;\n  p.yw*=iResolution.y/iResolution.x;\n  p*=10./size;\n  vec2 m=p.zw;//duped vec2 for convenience\n  if (m==vec2(0))m=vec2(.5);//for case of nouse being off screen.\n  //needed for screenshot in shadertoy, otherwise nearly useless.\n  \n  //double loop places glyphs in 2d array:\n  vec2 q=p.xy-m+vec2(.6);\n  vec2 s=q;\n  int c=64;\n    for(int i=0;i<lines;i++){\n      s.x=q.x;\n      for(int j=0;j<rows;j++){\n        r+=char(s,c+i*rows+j+cyc).x;\n        s.x-=spacing.x;\n      }\n    s.y+=spacing.y;\n  }    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}