{
    "Shader": {
        "info": {
            "date": "1619279179",
            "description": "FabriceNeyret2 created a great shader that used isolines. I was confused about what was going on and spent some time trying to understand the logic. Then I saved my working.",
            "flags": 0,
            "hasliked": 0,
            "id": "7ssSWj",
            "likes": 5,
            "name": "Isolines Explained",
            "published": 3,
            "tags": [
                "isolines",
                "isoline"
            ],
            "usePreview": 0,
            "username": "jointstockact1860",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n/*\n\n FabriceNeyret2 threw out a shader - https://www.shadertoy.com/view/ssXXWN - that\n draws isolines. No explanation is provided. I found a reference -\n https://iquilezles.org/articles/distance - in a different shader\n (https://www.shadertoy.com/view/Ms2XWc) to explain what was happening and spent a\n few hours ( :'[ ) understanding the technique.\n\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float target;\n    \n    // f is the function we want to plot. In this case, the example will be sin(x)\n    // A little scaling is done so the function range is [0, 1] and can be displayed\n    // without getting clamped to [0, 1] by OpenGL.\n    float f = sin(uv.x * 4. * PI) * 0.5 + 0.5;\n    \n    if (uv.y > .75) \n        // Show function value\n        fragColor = vec4(f);\n    else if (uv.y > .5)\n        // Show - effectively - |df/dx| the gradient of f at x in change per pixel.\n        // This value should be ~= 0 because pixels are small vs the scale of the\n        // function. What we call 0 -> 4 pi is probably a couple of hundred pixels.\n        fragColor = vec4(fwidth(f));\n    else if (uv.y > 0.25)\n        // Now we start to introduce the lines. Gonna draw isolines when f == 0.3.\n        // Why 0.3? Well if I didn't pick any number then there would be no lines.\n        \n        // This plot indicated, using red, the difference between the value of f\n        // and the target where the isoline should go. We want the line roughly\n        // in the blackest part of the band.\n        \n        // I draw lines manually in blue to show where the isolines will go. This \n        // looks ok in this shader, but if the function was less regular this \n        // wouldn't draw a line. There'd be a blotch if I pick a value where the\n        // function stayed at 0.3 with a low gradient. sin(x) doesn't do that at \n        // 0.3. It does do that at, say, 0.03. If you change the constant and\n        // see the lines blur :/\n        target = 0.3,\n        fragColor = vec4(abs(fract(f)-target), 0, abs(f - target) <= 0.01, 0); \n    else\n        // Ok so we'll fix that blotching and force a line to be drawn.\n        \n        // 1) Imagine the line in the image displayed where f == 0.3 (which we \n        //    can't use directly because, eg, maybe f != 0.3 for any fragment \n        //    as values jumps in discrete steps and may go from soemthing like\n        //    0.29899 to 0.30001 - missing f == 0.3.\n        // 2) Consider instead the distance !e! from the line to the current\n        //    pixel. Following the reference, we start with Taylor's \n        //    approximation and realise it can all be simplified  & approximated \n        //    to:\n        //\n        //    f + gradient(of f) * !e! = 0.3\n        //\n        //    and our reference further explains that the *number of pixels* between \n        //    the current fragment and the line roughly obey the relation:\n        //\n        //    #pixels >= |0.3 - f| / |gradient(of f)|\n        //    \n        // 3) Now we can cheat. If we use that as a colour, 0 pixels is black. >1\n        //    pixels is white. So if we use that as a colour directly we get lines.\n        \n        //    I don't know how intentional it is but *if* the function is flat, ie \n        //    there is an area where f == 0.3, then fwidth will obviously be 0 and\n        //    0/0 is plotted as white in OpenGL - so no line. Excellent.\n        fragColor = vec4(abs(fract(f) - 0.3)/fwidth(f));\n        //fragColor = vec4(0/0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}