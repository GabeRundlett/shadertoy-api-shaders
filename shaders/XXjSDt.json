{
    "Shader": {
        "info": {
            "date": "1711312411",
            "description": "Ver 0.1 of my Minecraft-Terrain-Shader, which includes block shifting problem as camera rotates.\nExplanation and further comments in code section.",
            "flags": 0,
            "hasliked": 0,
            "id": "XXjSDt",
            "likes": 1,
            "name": "SOLVED voxel shader shifting",
            "published": 3,
            "tags": [
                "3d",
                "learningshaders"
            ],
            "usePreview": 0,
            "username": "bananabajanana",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "/****SOLVED: block-shifting in voxel engine****\n*\n*  I am a new shader-programmer (or just 'shader'? not sure)\n*  and in my adventure to learn this craft, I decided to start\n*  with a shader immitating Minecraft terrain generation. To\n*  do this, all I'll need is a voxel 3d engine, and Perlin \n*  noise, which is why I thought it would be a good beginner\n*  project.\n*\n*  As I started making the voxel engine, I encountered a bug\n*  where blocks seemed to shift as I looked around. You can\n*  see this for yourself by enabling the legacy code, and\n*  looking around (dragging the mouse across the screen). And\n*  so, after trying to bugfix for a long time I uploaded my\n*  code and asked for help.\n*\n*  Thank you so much to @spalmer who pointed out the problem\n*  and you can see their comment bellow or look at the 'fixed\n*  code' line and explenation here. In addition, thank you\n*  @FabriceNeyret2, @ocb, and @chronos for your suggestions,\n*  I will probably take a look at your examples and implement\n*  your suggestions in future versions.\n*\n*  As I keep working on my shader, I'll do it in a different\n*  file and keep this as a lesson to others who might encounter\n*  similar problems, or for nostalgia's sake. \n*  :)\n*/\n\n#define MAX_DIST 30.\n#define MAX_STEPS 100\nfloat rayMarch(vec3 ro, vec3 rd) {\n    // The probelem seemed to be with the Sign object.\n    // The way I interpreted it was the 'beams direction', which is why\n    // I decided to make each coordinate 1/-1 (because we need to somehow\n    // signal which direction we are looking), but in our calculation of\n    // dt we calculate the diff between current tile to current position\n    // tileP - p, which already has a certain direction! (this is due to\n    // considering the 'tileP' a certain corner of the block, and not an\n    // arbitrary one). And this reason is why the sign needs to be one\n    // sided! i.e. if we go 'up' we need to fix the direction by subtracting\n    // 1 but if we go 'down' we need to keep it as is (adding 0). Which is\n    // why the fix is to keep dirSign values 0/-1 instead of 1/-1\n    vec3 dirSign = vec3(rd.x > 0. ? 1 : -1, rd.y > 0. ? 1 : -1, rd.z > 0. ? 1 : -1);\n    vec3 p = ro;\n    vec3 tileP = floor(p);\n    float t = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        // legacy code:\n        vec3 dt = ((tileP + dirSign) - p) / rd;\n        // fixed code:\n        // vec3 dt = ((tileP + max(dirSign, 0.)) - p) / rd;\n        float progress = 0.;\n        vec3 dTile = vec3(0.);\n        float cortemp = 0.;\n        if(dt.x < dt.y && dt.x < dt.z) {\n            progress = dt.x;\n            dTile.x = dirSign.x;\n        }\n        else if(dt.y < dt.z) {\n            progress = dt.y;\n            dTile.y = dirSign.y;\n            \n        }\n        else {\n            progress = dt.z;\n            dTile.z = dirSign.z;\n        }\n        \n        t += progress;\n        tileP += dTile;\n        p += rd * progress;\n        if(sin(tileP.x) + sin(tileP.z) > tileP.y) break;\n    }\n    \n    return t * 0.01;\n}\n\nmat2 rotationMat(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 rotationDirection(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= rotationMat(-m.y+.4);\n    ro.xz *= rotationMat(-m.x*6.2831);\n    vec3 rd = rotationDirection(uv, ro, vec3(0,0,0), .7);\n    \n    float d = rayMarch(ro, rd);\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        col = vec3(d);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}