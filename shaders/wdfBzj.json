{
    "Shader": {
        "info": {
            "date": "1588598365",
            "description": "reference images: [url]https://www.google.com/search?q=zaku+head&tbm=isch[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wdfBzj",
            "likes": 7,
            "name": "MS-06 ZAKU",
            "published": 3,
            "tags": [
                "reproduction",
                "zaku"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 359
        },
        "renderpass": [
            {
                "code": "// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 80.\n#define SURF_DIST .002\n#define EDGE_WIDTH 0.015\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat edge;\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// ventilator pipe based on the sdLink distance function\n// Notice that the following function is not reusable code.\nfloat sdVentilator( vec3 p, float le, float r1, float r2 )\n{\n    p.x*=0.9;\n    vec3 prevP = p;\n    vec3 q = vec3( p.x, p.y, max(abs(p.z)-le,0.0) );\n    vec2 p2 = vec2(length(q.xz)-r1,q.y);\n\n    float d = length(p2) - r2;\n\tfloat d2 = length(p2) - (r2*0.8);\n    \n    float space = 0.05;\n    p.z = mod(p.z,0.38)-0.19;\n    float b = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n\tfloat b2 = sdBox(p,vec3(1.5,0.3,0.9));\n    b = max(b2,b);\n    \n    p*= matRotateY(radians(52.0));\n    float b3 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b3);\n\n    p*= matRotateY(radians(70.0));\n\tfloat b4 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b4);\n    \n    p*= matRotateY(radians(-52.0));\n    float b5 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b5);\n\n    p*= matRotateY(radians(-70.0));\n\tfloat b6 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b6);\n    \n    \n    vec3 p3 = p-vec3(0.0,0.02,1.15);\n    p3*= matRotateZ(radians(90.0));\n    float d3 = sdCappedCylinder(p3,0.2,0.33);\n    \n    return min(min(d2,d3),max(-b,d))*0.6;\n}\n\nfloat headBack(vec3 p) {\n    float size = 1.5;\n    float thickness = 0.35;\n    vec4 a1 = vec4(0.0,size,1.6,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,0.85); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.15); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.15); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat sdHead(vec3 p) {\n    vec3 prevP = p;\n    p.x*=1.15;\n    float d =  length(p)-1.0;\n    d = max(-(p.y+0.3),d);\n    float d2 = sdBox(p-vec3(0.0,0.3,1.0),vec3(1.5,0.2,0.5));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p*=matRotateX(radians(-110.0));\n    p.y-=1.25;\n    p.z+=1.35;\n    float sc = mix(0.7,3.0,smoothstep(-1.0,1.0,p.y));\n    vec3 p2 = p-vec3(0.0,-0.25,1.2);\n    p2.x*=sc;\n    \n    d2 = sdBox(p2,vec3(0.6,0.46,.15));\n    d = smin(d,d2,0.3);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.85;\n    d2 = sdBox(p-vec3(0.0,0.34,0.15),vec3(0.15,0.15,0.15));\n    d = max(-d2,d);\n    p = prevP;\n    p*=matRotateX(radians(-18.0));\n    d2 = sdBox(p-vec3(0.0,0.1,1.5),vec3(0.2,0.1,0.1));\n    d = max(-d2,d);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    p.x-=0.15;\n    \n    d2 = headBack(p-vec3(0.0,-0.04,-1.08));\n    d = smin(d,d2,0.1);\n    \n    return d*0.6;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.0;\n    \n    p*=matRotateX(radians(-10.0));\n    float v = sdVentilator(p-vec3(0.0,1.2+y,-0.2),0.3,0.9,0.15);\n    p = prevP;\n\tfloat h = sdHead(p-vec3(0.0,1.1+y,0.0));\n    \n    float d = min(v,h);\n    vec4 res = vec4(vec3(0.4,0.5,0.4),d);\n        \n    vec3 eyeEmitPos = vec3(sin(iTime*2.0)*0.2,1.43+y,0.56);\n    vec3 eyePos = p-eyeEmitPos;\n    eyePos *= matRotateX(radians(90.0));\n    vec3 ecol = emitColor(p,eyeEmitPos, vec3(1.0,0.5,0.8),0.0001,0.9,3.0);\n    d = sdCappedCylinder(eyePos,0.15,0.02);\n    vec4 eye = vec4(vec3(0.7,0.0,0.0)+ecol,d);\n    \n    vec4 model = combine(res,eye);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 zionLogo(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    p.y*=0.95;\n    float d = length(p)-0.2;\n    p.x*=1.2;\n    float d2 = length(p)-0.18;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    p.x -= 0.15;\n    d2 = sdTriangle(p, vec2(0.22,0.05), vec2(0.03,-0.02), vec2(0.0,-0.155));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,0.35), vec2(0.03,-0.2), vec2(0.0,0.0), vec2(0.0,-0.3));\n    d = min(d,d2);\n    p = prevP;\n    \n    d2 = sdBox(p-vec2(0.0,-0.15),vec2(0.012,0.25));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.35), vec2(0.05,0.00), vec2(0.00,-0.03), vec2(0.0,-0.14));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,-0.1), vec2(0.1,0.05), vec2(0.0,0.0), vec2(0.0,-0.05));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.27), vec2(0.45,0.2), vec2(0.0,0.0), vec2(0.15,-0.03));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,0.02), vec2(0.3,0.2), vec2(0.0,0.0), vec2(0.0,-0.06));\n    d = min(d,d2);\n    p = prevP;\n    \n    col = mix(col,bcol,S(d,-0.002));\n    return col;\n}\n\nvec3 serialNumber(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    \n    //　０\n    vec2 p0 = p-vec2(-0.1,0.0);\n    float d = sdBox(p0,vec2(0.1,0.15));\n    float d2 = sdBox(p0,vec2(0.05,0.1));\n    d = max(-d2,d);\n    d2 = sdBox(p0,vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    // 6\n    vec2 p1 = p-vec2(0.1,0.0);\n    d2 = sdBox(p1-vec2(-0.05,0.0),vec2(0.025,0.15));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.025,-0.06),vec2(0.075,0.09));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.015,-0.06),vec2(0.04,0.04));\n    d = max(-d2,d);\n    d2 = sdBox(p1-vec2(0.035,0.125),vec2(0.065,0.025));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(-0.02,0.0),vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 animationLine(vec2 p, vec3 col, float dir) {\n    p.x+=iTime*0.1*dir;\n    p.x = mod(p.x,0.02)-0.01;\n    p*=Rot(radians(45.0*dir));\n    float d = sdBox(p,vec2(0.001,0.05));\n\tcol = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3.5, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0));\n    ro.xz *= Rot(radians((sin(t*0.2)*80.0)+180.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1.1,0), 1.);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col =.84*max(mix(vec3(1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n        \n        uv*=2.0;\n        col = zionLogo(uv-vec2(1.05,0.5),col,vec3(0.7,0.1,0.1));\n        uv = prevUV;\n        uv*=1.5;\n        col = serialNumber(uv-vec2(-0.9,-0.45),col,vec3(0.95));\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),edge);\n    \n    // overlay contents\n    uv = prevUV;\n    col = animationLine(uv-vec2(0.0,-0.49),col,1.0);\n    col = animationLine(uv-vec2(0.0,0.49),col,-1.0);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}