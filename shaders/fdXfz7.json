{
    "Shader": {
        "info": {
            "date": "1644593984",
            "description": "I made this on accident, i was trying to make spheres inside a ball using voronoi. ",
            "flags": 0,
            "hasliked": 0,
            "id": "fdXfz7",
            "likes": 28,
            "name": "Glow Ball",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "voronoi",
                "mouse",
                "animation",
                "ball"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 571
        },
        "renderpass": [
            {
                "code": "float t;\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat vorinoi(in vec3 p) { //3d vorinoi\n    p.z += t;\n\tvec3 gv = floor(p);\n    vec3 f = fract(p);\n    float d = 1.0; //starting distance\n    for (int x = -1; x <= 1; x += 1) {\n        for (int y = -1; y <= 1; y += 1) {\n            for (int z = -1; z <= 1; z += 1) {\n            \tvec3 pp = vec3(x, y, z);\n                vec3 p = gv-pp;\n                vec3 of = (sin(hash33(p)+(t+10.)*hash33(p*0.5))-0.5)*0.5; //animated 3d cells\n                \n                d = min(d, length(pp+of+f));\n            }\n        }\n    }\n    return d;\n}\nfloat sdf(in vec3 p) { //signed distance function - vorinoi inside a sphere\n    float v = (vorinoi(p*5.))-0.3;\n\treturn max(length(p)-1., v/5.);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    //ray marching with low step counts looks great !\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 10; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p);\n        d0 += d;\n        if (d < 0.001 || d0 > 100.) break;\n    }\n    return vec3(mix(pow(p, vec3(2., 4.0, 2)), vec3(0), clamp((d0-1.8), 0.0, 1.0)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t = iTime;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = vec2(t*0.2, 1.5);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*2.3;\n    vec3 rd = getRay(-normalize(ro), uv);\n    \n    //render\n    vec3 color = getColor(ro, rd);\n    fragColor = vec4(color, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}