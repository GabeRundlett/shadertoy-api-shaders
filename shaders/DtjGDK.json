{
    "Shader": {
        "info": {
            "date": "1673948499",
            "description": "Looping version of Fabrice's original:\n\nbase -1+i  allows to represent the whole complex plane as a binary number set.\n[url]https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "DtjGDK",
            "likes": 17,
            "name": "Base -1+i  Twindragon Loop",
            "published": 3,
            "tags": [
                "binary",
                "fractals",
                "loop",
                "complex",
                "twindragon",
                "arithmetics"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "// Base -1+i Twindragon Loop, mla, 2023.\n// Original: https://www.shadertoy.com/view/dtj3Wy by @FabriceNeyret2\n\n// base -1+i  allows to represent the whole complex plane as a binary number set.\n// TwinDragon of order n = all positions that can be represented with n bits.\n// cf https://en.wikipedia.org/wiki/Complex-base_system#Base_%E2%88%921_%C2%B1_i\n\n// Replaced complex div with a matrix multiplication - other matrices\n// are possible, though the ones I've tried have been rather ugly (and\n// break the looping).\n//\n// There is a relation between the magic numbers NCOLS and LOOP, but I'm\n// not sure what it is. Some interesting sample values shown.\n//\n// Loop goes faster (on Intel anyway) with explicit counter & bound.\n\nvoid mainImage(out vec4 O, vec2 I) {\n  int AA = 2, NBITS = 80;\n  int NCOLS = 8, LOOP = NCOLS/2;\n  //NCOLS = 2, LOOP = 4;\n  //NCOLS = 4, LOOP = 4;\n  //NCOLS = 16, LOOP = NCOLS/2;\n  //NCOLS = 3, LOOP = NCOLS*4;\n  //NCOLS = 5, LOOP = NCOLS*4;\n  mat2 A = 0.5*mat2(-1,-1,1,-1); // NB: det(a) = 0.5 < 1\n  vec3 basecol = vec3(1,1,0.5);\n  I -= 0.5*iResolution.xy; // Centering\n  O = vec4(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 p = I + vec2(i,j)/float(AA);\n      p *= rotate(0.1*iTime); // Rotate a little\n      p *= exp2(mod(-0.75*iTime,float(LOOP))); // Exponential zoom\n      int i = 0;\n      for (i = 0; i < NBITS; i++) {\n        assert(i < NBITS-1);\n        p = floor(A*p); // Integral division by -1+i\n        if (p == vec2(0)) break;\n      }\n      O.rgb += float(i%NCOLS)/float(NCOLS-1)*basecol;\n      //O.rgb += h2rgb(float(i%NCOLS)/float(NCOLS));\n    }\n  }\n  O /= float(AA*AA);\n  O = pow(O,vec4(0.4545));\n  if (alert) O.r = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nmat2 rotate(float t) {\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}