{
    "Shader": {
        "info": {
            "date": "1517866694",
            "description": "Renders four black circles. \nThe two of circles on the bottom use smoothstep function instead of step function to detect the transition of the edges.\nTwo circle in a diagonal line use subpixel rendering.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dccz8",
            "likes": 10,
            "name": "Circles with subpixel rendering",
            "published": 3,
            "tags": [
                "circle",
                "antialiasing",
                "subpixel"
            ],
            "usePreview": 0,
            "username": "stlsnk",
            "viewed": 1289
        },
        "renderpass": [
            {
                "code": "/*\nAnti-aliasing of circles\n\nno smoothing | nothing\n-------------+--------------\nno subpixel  | smooth+subpix\n\n*/\n\n#define PIXEL (2.0/iResolution.y)\n#define RADIUS (0.5 - 3.*PIXEL)\n\nvec3 simpleDist( in vec2 pos ) {\n    return vec3(distance(vec2(0.5, 0.5), pos));\n}\n// RGB subpixel calculation\nvec3 subpixDist( in vec2 pos ) {\n    vec2 posL = pos + vec2(PIXEL / -3., 0.); // LEFT\n    float dL = distance(vec2(0.5, 0.5), posL);\n    vec2 posM = pos + vec2( 0., 0.); // MIDDLE\n    float dM = distance(vec2(0.5, 0.5), posM);\n    vec2 posR = pos + vec2(PIXEL / +3., 0.); // RIGHT\n    float dR = distance(vec2(0.5, 0.5), posR);\n    return vec3(dL, dM, dR); // Red: Left, G: Middle, G: Right\n}\n\n// Top-right, no smooth, no subpix\nvec3 circ1( in vec2 pos ) \n{\n    return vec3(step(RADIUS, simpleDist(pos)));\n}\n// Bottom-left, smooth, no subpix\nvec3 circ2( in vec2 pos ) \n{\n    return vec3(smoothstep(RADIUS-PIXEL, RADIUS+PIXEL, simpleDist(pos)));\n}\n// Top-left, no smooth, subpix\nvec3 circ3( in vec2 pos)\n{\n    return vec3(step(RADIUS, subpixDist(pos)));\n}\n// Bottom-right, smooth, subpix\nvec3 circ4( in vec2 pos)\n{\n    return vec3(smoothstep(RADIUS-PIXEL, RADIUS+PIXEL, subpixDist(pos)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv.y will go from -1.0 to +1.0, and the aspect ration will be correct.\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n    if(uv.x >= 0. && uv.y >= 0.) { // Top-right corner\n        fragColor = vec4(circ1(uv+vec2(0., 0.)), 1.0);\n    }\n    else if(uv.x < 0. && uv.y < 0.) { // Bottom-left corner\n        fragColor = vec4(circ2(uv+vec2(1., 1.)), 1.0);\n    }\n    else if(uv.x < 0. && uv.y >= 0.) { // Top-left corner\n        fragColor = vec4(circ3(uv+vec2(1., 0.)), 1.0);\n    }\n    else if(uv.x >= 0. && uv.y < 0.) { // Bottom-right corner\n        fragColor = vec4(circ4(uv+vec2(0., 1.)), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}