{
    "Shader": {
        "info": {
            "date": "1571266966",
            "description": "Following on from my [url=https://www.shadertoy.com/view/Wdd3Rl]cone-traced AO[/url], I wanted a cheaper AO solution for using in general scenes. This one samples the SDF at points distributed on a hemisphere and at a logarithmic range of distances.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsVGDc",
            "likes": 27,
            "name": "Blurred SDF AO",
            "published": 3,
            "tags": [
                "sdf",
                "lighting",
                "ao",
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1103
        },
        "renderpass": [
            {
                "code": "#define AO_SAMPLES 50\n\n// comment/uncomment these to turn different effects on/off\n//#define LIGHTS\n#define AMBIENT_LIGHT\n//#define COLOURISE_AMBIENT\n\n// hide the errors of low sample counts by varying them per-pixel\n//#define DITHER\n\nconst float phi = 1.6180339887498948;\nconst float tau = 6.2831853071795865;\n\nuvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\nuvec3 quasi3 = uvec3( 3518319155, 2882110345, 2360945575 );\n\nfloat sdf( vec3 p )\n{\n    return\n        min(min(min(min(min(\n        \tmax(max(max(\n                length(p)-1.,\n                .3 - length((p-vec3(.5,0,0)).xz)),\n                .3 - length((p-vec3(-.25,0,-.5)).xz)),\n                dot(p,normalize(vec3(-1,0,-2)))-.4 + .003*sin(p.y*100.)\n            ),\n            max(max(\n                length(p-vec3(0,-.5,1.2))-.5,\n                .45-length(p-vec3(0,-.5,1.2))),\n                dot(p-vec3(0,-.5,1.2),normalize(vec3(1,2,-3)))\n            )),\n            length(p-vec3(0,-.5,1.2))-.3),\n\t\t\tmax(\n                length(p.xz)-.5,\n                p.y+.9\n            )),\n            max(\n                length((p-vec3(-.25,0,-.5)).xz) - .22,\n                dot(p,normalize(vec3(-1,4,-2)))-.95\n            )),\n            p.y + 1.\n        );\n}\n\n\nfloat OcclusionTrace( vec3 pos, vec3 target, float rpert )\n{\n    // higher quality setting, better for direct lights\n    const int maxSteps = 150; const float stepSize = .5;\n    \n    vec3 toTarget = target-pos;\n    float end = length(toTarget);\n    vec3 ray = toTarget/end;\n    float t = .05;\n    float visibility = 1.;\n    for ( int i=0; i < maxSteps; i++ )\n    {\n        float h = sdf( ray*t+pos );\n        if ( t >= end ) break;\n        float r = rpert*t;\n        visibility = min( visibility, smoothstep( -r, r, h ) );\n        if ( visibility <= 0. ) break;\n        t += (h+r) * stepSize;\n    }\n\treturn visibility;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 _fragCoord )\n{\n    uint seed = uint(_fragCoord.x)*quasi2.x\n        \t\t+ uint(_fragCoord.y)*quasi2.y;\n#ifndef DITHER\n    seed = 0x80000000u;\n#endif\n    vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n    vec2 fragCoord = _fragCoord + jitter;\n    \n    vec3 ray = vec3( (fragCoord-iResolution.xy*.5)/sqrt(iResolution.x*iResolution.y), 2 );\n    \n    vec3 camPos = vec3( 0, 0, -8. );\n    vec2 a = vec2(.3,iTime*.3);//-1.5);//\n    vec2 d = vec2(-1,1);\n    camPos.yz = camPos.yz*cos(a.x) + camPos.zy*d.xy*sin(a.x);\n    camPos.zx = camPos.zx*cos(a.y) + camPos.xz*d.xy*sin(a.y);\n    \n    vec3 camTarget = vec3(0);\n    \n    vec3 camK = normalize(camTarget - camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize( ray );\n    \n    float t = 0.;\n    for ( int i=0; i < 200; i++ )\n    {\n        float h = sdf(ray*t + camPos);\n        t += h;\n        if ( h < .001 )\n        {\n            break;\n        }\n    }\n    \n    vec3 pos = ray*t+camPos;\n    \n    d *= .001;\n    vec3 normal =\n        normalize(\n            sdf(pos+d.xxx)*d.xxx +\n            sdf(pos+d.yyx)*d.yyx +\n            sdf(pos+d.yxy)*d.yxy +\n            sdf(pos+d.xyy)*d.xyy\n        );\n    \n    struct Light\n    {\n        vec3 pos;\n        vec3 col;\n    };\n    \n    Light lights[] = Light[]\n        (\n            //Light( vec3(4,8,-6), vec3(50) ),\n            //Light( vec3(.7,-.7,0), vec3(5,0,0) ) // shows multiple bugs with the shadow tech - all fixed by increasing loop limit on shadow test!\n            /*Light( vec3(4,8,-6), vec3(50,0,0) ),\n            Light( vec3(4,8,-5), vec3(0,50,0) ),\n            Light( vec3(4,8,-4), vec3(0,0,50) )*/\n            Light( vec3(.5,0,2), vec3(0,1,0) ),\n            Light( vec3(2,-.5,.5), vec3(1,.3,0) ),\n            Light( vec3(1,.5,-1.2), vec3(1,0,0) ),\n            Light( vec3(-.25,-.5,-1), vec3(1,0,.7)*.2 ),\n            Light( vec3(-1,1,.5), vec3(0,.2,1)*2. )\n        );\n    \n    fragColour.rgb = vec3(0);\n    \n    for ( int i=0; i < lights.length(); i++ )\n    {\n        vec3 toLight = lights[i].pos - pos;\n        float lightStrength = max(0.,dot(normal,normalize(toLight)));\n        lightStrength /= dot(toLight,toLight);\n        lightStrength *= OcclusionTrace( pos, lights[i].pos, .05 );\n#ifdef LIGHTS\n    \tfragColour.rgb += lights[i].col*lightStrength;\n#endif\n    }\n    \n    \n    \n    // sample SDF at various points to give a blurred version of scene, and divide by expected value if we're flat\n    // i.e. it's both a blur and a bunch of actual samples\n//    float ao = min(0.,sdf( pos+normal*.3 )/.3)+1.;\n    \n    vec3 ambient = vec3(0);\n    float weightSum = 0.;\n    for ( int i=0; i < AO_SAMPLES; i++ )\n    {\n        vec3 rand = vec3(quasi3*(uint(i)+seed))/exp2(32.);\n        \n        // distribute randomly on hemisphere\n        // n.b. I adapted this technique from somewhere but can't recall where\n        // uniformly distribute on unit cylinder about z\n        vec3 tap = vec3( cos(rand.x*tau), sin(rand.x*tau), rand.y*2.-1. );\n        // project radially inward onto sphere - this gives uniform distribution of samples\n        tap.xy *= sqrt(1.-tap.z*tap.z);\n        // project perpendicular to normal onto a curved-cone pointing along normal\n        float sdn = dot(tap,normal);\n        float l = .5+.5*sdn;\n        // ignore the height along the cone - so we get a disc (perpendicular to normal)\n        // curve the cone (sqrt) so distribution is uniform on disc\n        tap = normalize(tap-sdn*normal)*sqrt(l); // there's a faster way to do that normalize\n        // project along normal onto hemisphere\n        tap += normal*sqrt(1.-l);\n        \n        // randomize the distance of the sample\n        float dist = rand.z;//(float(i)+float(seed)/exp2(32.))/float(AO_SAMPLES);//\n        tap *= exp2( mix( -5., 3., dist ) ); // interesting how this trades big vs small details\n        \n//I want this to be a min AND an average, hmm...\n/*yeah, I want it to approximate occlusion in this direction, and min with other samples that approximate in this direction\nbut add to ones in other directions\nand I want to do that without paying attention to direction\n=> ignore the direction and just average the samples\nor, have a factor for how much to treat the samples as exclusive\nwhat about something logarithmic, so it sort of works like a min and an add?\n\npreferably fading confidence of samples with distance, so close ones definitely occlude, more distant ones nudge the average by less\nn.b. could do 2D rand and start close\n*/\n//        float aotap = clamp( sdf( pos+tap )/dot(tap,normal) + 1., .001, 1. );\n        //ao = min( ao, aotap );\n//        ao += log2(aotap) * 2.*(1.-dist);\n        \n\t\t// take full occlusion as the norm, then add on points which defy that\n\n        float weight = 1.;\n        float ao = clamp( sdf( pos+tap )/dot(tap,normal),\n                        0., // pushing this below 0 darkens shadows\n                        1.3 // amp them up if they're very positive! - this gives a fake drybrushing effect that I quite like\n                       );\n\n#ifdef COLOURISE_AMBIENT\n\t    vec3 ambientColour = mix( vec3(1,.3,0), vec3(0,.3,1), normalize(tap).x*.5+.5 );\n#else\n    \tvec3 ambientColour = vec3(.7);\n#endif\n        \n        ambient += ao*ambientColour;\n\n        weightSum += weight;\n    }\n    ambient /= weightSum;\n    \n    \n    \n#ifdef AMBIENT_LIGHT\n    fragColour.rgb += ambient;\n#endif\n\n    fragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    \n//    fragColour.rgb = sin(fragColour.rgb*6.-1.+iTime*.3)*.5+.5; // AWESOME\n    \n    fragColour.a = 1.;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}