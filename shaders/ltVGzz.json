{
    "Shader": {
        "info": {
            "date": "1472939076",
            "description": "This is the basis for another shader I am working on.\nThe skeleton is based on female proportions.\n\nAlready running quite low on fps unfortunately.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltVGzz",
            "likes": 22,
            "name": "Rigging Template",
            "published": 3,
            "tags": [
                "template",
                "rigging"
            ],
            "usePreview": 0,
            "username": "lara",
            "viewed": 1265
        },
        "renderpass": [
            {
                "code": "#define SHADOW\n#define AMBIENT_OCCLUSION\n\n#define T iTime\n#define PI 3.141592653\n#define TAU (PI*2.)\n#define D2R (PI/180.)\n\n#define P 0.001  // Precision\n#define D 20.    // Max distance\n#define S 256     // Marching steps\n#define R 1.     // Marching substeps\n#define K 32.    // Shadow softness\n#define A 4.     // AO steps\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,s,-s,c);}\nvoid rotX(inout vec3 p,vec3 o,mat2 m){p-=o;p.yz*=m;p+=o;}\nvoid rotY(inout vec3 p,vec3 o,mat2 m){p-=o;p.xz*=m;p+=o;}\nvoid rotZ(inout vec3 p,vec3 o,mat2 m){p-=o;p.xy*=m;p+=o;}\n\nstruct RotRange\n{\n    vec2 x,y,z;\n};\n\n/* =============== */\n/* === Rigging === */\n/* =============== */\n\n// joint position (based on: http://image.shutterstock.com/z/stock-vector-female-body-from-three-angles-276920123.jpg)\nvec3 _p_head      = vec3(   0, 1300, 0) / 1400.;\nvec3 _p_shoulderL = vec3(-126, 1150, 0) / 1400.;\nvec3 _p_shoulderR = vec3( 126, 1150, 0) / 1400.;\nvec3 _p_elbowL    = vec3(-143,  915, 0) / 1400.;\nvec3 _p_elbowR    = vec3( 143,  915, 0) / 1400.;\nvec3 _p_wristL    = vec3(-143,  680, 0) / 1400.;\nvec3 _p_wristR    = vec3( 143,  680, 0) / 1400.;\nvec3 _p_chest     = vec3(   0, 1045, 0) / 1400.;\nvec3 _p_pelvis    = vec3(   0,  750, 0) / 1400.;\nvec3 _p_legL      = vec3( -75,  750, 0) / 1400.;\nvec3 _p_legR      = vec3(  75,  750, 0) / 1400.;\nvec3 _p_kneeL     = vec3( -60,  400, 0) / 1400.;\nvec3 _p_kneeR     = vec3(  60,  400, 0) / 1400.;\nvec3 _p_footL     = vec3( -50,    0, 0) / 1400.;\nvec3 _p_footR     = vec3(  50,    0, 0) / 1400.;\n\n// joint rotation angle restraints\nconst RotRange _rr_shoulder = RotRange(vec2( -45, 165)*D2R, vec2( -90, 180)*D2R, vec2(  10, 120)*D2R);\nconst RotRange _rr_chest    = RotRange(vec2(   0,   0)*D2R, vec2( -45,  45)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_leg      = RotRange(vec2( -45, 160)*D2R, vec2(   0,   0)*D2R, vec2(   0,  90)*D2R);\nconst RotRange _rr_pelvis   = RotRange(vec2( -10, 160)*D2R, vec2( -20,  20)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_elbow    = RotRange(vec2(   0, 170)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_wrist    = RotRange(vec2(   0,   0)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\nconst RotRange _rr_knee     = RotRange(vec2(-130,   0)*D2R, vec2(   0,   0)*D2R, vec2(   0,   0)*D2R);\n\n// joint rotation angles\nvec3 _r_shoulderL = vec3(0,0,0);\nvec3 _r_shoulderR = vec3(0,0,0);\nvec3 _r_chest     = vec3(0,0,0);\nvec3 _r_legL      = vec3(0,0,0);\nvec3 _r_legR      = vec3(0,0,0);\nvec3 _r_pelvis    = vec3(0,0,0);\nvec3 _r_elbowL    = vec3(0,0,0);\nvec3 _r_elbowR    = vec3(0,0,0);\nvec3 _r_wristL    = vec3(0,0,0);\nvec3 _r_wristR    = vec3(0,0,0);\nvec3 _r_kneeL     = vec3(0,0,0);\nvec3 _r_kneeR     = vec3(0,0,0);\n\nvec3 _ground = vec3(0);\n\nvoid waveHands()\n{\n     _r_shoulderL.y = -PI/3.;\n     _r_shoulderL.z = _rr_shoulder.z.x + (sin(T*4.)+1.)/2. * (_rr_shoulder.z.y - _rr_shoulder.z.x);\n\n     _r_shoulderR.y = -PI/3.;\n     _r_shoulderR.z = _rr_shoulder.z.x + (sin(T*4.)+1.)/2. * (_rr_shoulder.z.y - _rr_shoulder.z.x);\n    \n     _r_elbowL.x = (sin(T*4.)+1.)/2.*PI/4.;\n     _r_elbowR.x = (sin(T*4.)+1.)/2.*PI/4.;\n}\n\nvoid doCrazyStuff()\n{\n    _r_shoulderL = sin(vec3(T/01.,T/01.*2.,T/01.*3.)) * PI;\n    _r_shoulderR = sin(vec3(T/02.,T/02.*2.,T/02.*3.)) * PI;\n    _r_chest     = sin(vec3(T/03.,T/03.*2.,T/03.*3.)) * PI;\n    _r_legL      = sin(vec3(T/04.,T/04.*2.,T/04.*3.)) * PI;\n    _r_legR      = sin(vec3(T/05.,T/05.*2.,T/05.*3.)) * PI;\n    _r_pelvis    = sin(vec3(T/06.,T/06.*2.,T/06.*3.)) * PI;\n    _r_elbowL    = sin(vec3(T/07.,T/07.*2.,T/07.*3.)) * PI;\n    _r_elbowR    = sin(vec3(T/08.,T/08.*2.,T/08.*3.)) * PI;\n    _r_wristL    = sin(vec3(T/09.,T/09.*2.,T/09.*3.)) * PI;\n    _r_wristR    = sin(vec3(T/10.,T/10.*2.,T/10.*3.)) * PI;\n    _r_kneeL     = sin(vec3(T/11.,T/11.*2.,T/11.*3.)) * PI;\n    _r_kneeR     = sin(vec3(T/12.,T/12.*2.,T/12.*3.)) * PI;\n}\n\nvoid walk(float s)\n{\n    float t1 = (sin(T*s)+1.)/2.;\n    float t2 = (sin(T*s-TAU/3.5)+1.)/2.;\n    \n    float t3 = (sin(T*s+PI)+1.)/2.;\n    float t4 = (sin(T*s+PI-TAU/3.5)+1.)/2.;\n    \n    _r_legL.x  = t1 * _rr_leg.x.x/2. + (1.-t1) * _rr_leg.x.y/5.;\n    _r_kneeL.x = t2 * _rr_knee.x.x/2.;\n    \n    _r_legR.x  = t3 * _rr_leg.x.x/2. + (1.-t3) * _rr_leg.x.y/5.;\n    _r_kneeR.x = t4 * _rr_knee.x.x/2.;\n    \n    _r_shoulderL.x = t3 * _rr_shoulder.x.x/4. + (1.-t3) * _rr_shoulder.x.y/8.;\n    _r_shoulderR.x = t1 * _rr_shoulder.x.x/4. + (1.-t1) * _rr_shoulder.x.y/8.;\n    \n    _r_elbowL.x = t4 * _rr_elbow.x.y/8.;\n    _r_elbowR.x = t2 * _rr_elbow.x.y/8.;\n    \n    _r_pelvis.y = (_rr_pelvis.y.x + t1 * _rr_pelvis.y.y * 2.) / 2.;\n    _r_chest.y  = (_rr_chest.y.x + t3 * _rr_chest.y.y * 2.) / 4.;\n    \n    _r_pelvis.x = -PI/128.;\n    \n    _ground.z = T*s/8.;\n}\n\nvoid rig()\n{    \n    mat2 m;\n    \n    // Legs (x-axis-rotation)\n    rotX(_p_kneeL,_p_legL,m=rot(-clamp(_r_legL.x,_rr_leg.x.x,_rr_leg.x.y)));\n    rotX(_p_footL,_p_legL,m);\n    rotX(_p_footL,_p_kneeL,rot(-clamp(_r_kneeL.x,_rr_knee.x.x,_rr_knee.x.y)));\n    \n    rotX(_p_kneeR,_p_legR,m=rot(-clamp(_r_legR.x,_rr_leg.x.x,_rr_leg.x.y)));\n    rotX(_p_footR,_p_legR,m);\n    rotX(_p_footR,_p_kneeR,rot(-clamp(_r_kneeR.x,_rr_knee.x.x,_rr_knee.x.y)));\n    \n    // Arms (x-axis-rotation)\n    rotX(_p_elbowL,_p_shoulderL,m=rot(-clamp(_r_shoulderL.x,_rr_shoulder.x.x,_rr_shoulder.x.y)));\n    rotX(_p_wristL,_p_shoulderL,m);\n    rotX(_p_wristL,_p_elbowL,rot(-clamp(_r_elbowL.x,_rr_elbow.x.x,_rr_elbow.x.y)));\n    \n    rotX(_p_elbowR,_p_shoulderR,m=rot(-clamp(_r_shoulderR.x,_rr_shoulder.x.x,_rr_shoulder.x.y)));\n    rotX(_p_wristR,_p_shoulderR,m);\n    rotX(_p_wristR,_p_elbowR,rot(-clamp(_r_elbowR.x,_rr_elbow.x.x,_rr_elbow.x.y)));\n    \n    // Arms (y-axis-rotation)\n    rotY(_p_elbowL,_p_shoulderL,m=rot(-clamp(_r_shoulderL.y,_rr_shoulder.y.x,_rr_shoulder.y.y)));\n    rotY(_p_wristL,_p_shoulderL,m);\n    rotY(_p_wristL,_p_elbowL,rot(-clamp(_r_elbowL.y,_rr_elbow.y.x,_rr_elbow.x.y)));\n    \n    rotY(_p_elbowR,_p_shoulderR,m=rot(clamp(_r_shoulderR.y,_rr_shoulder.y.x,_rr_shoulder.y.y)));\n    rotY(_p_wristR,_p_shoulderR,m);\n    rotY(_p_wristR,_p_elbowR,rot(clamp(_r_elbowR.y,_rr_elbow.y.x,_rr_elbow.x.y)));\n    \n    // Legs (z-axis-rotation)\n    rotZ(_p_kneeL,_p_legL,m=rot(clamp(_r_legL.z,_rr_leg.z.x,_rr_leg.z.y)));\n    rotZ(_p_footL,_p_legL,m);\n    // rotX(_p_footL,_p_kneeL,rot(clamp(_r_kneeL.x,_rr_knee.x,_rr_knee.y)));\n    \n    rotZ(_p_kneeR,_p_legR,m=rot(-clamp(_r_legR.z,_rr_leg.z.x,_rr_leg.z.y)));\n    rotZ(_p_footR,_p_legR,m);\n    // rotX(_p_footL,_p_kneeL,rot(-clamp(_r_kneeL.x,_rr_knee.x,_rr_knee.y)));\n    \n    // Arms (z-axis-rotation)\n    rotZ(_p_elbowL,_p_shoulderL,m=rot(clamp(_r_shoulderL.z,_rr_shoulder.z.x,_rr_shoulder.z.y)));\n    rotZ(_p_wristL,_p_shoulderL,m);\n    // rotZ(_p_wristL,_p_elbowL,rot(clamp(_r_elbowL.z,_rr_elbow.z,_rr_elbow.w)));\n    \n    rotZ(_p_elbowR,_p_shoulderR,m=rot(-clamp(_r_shoulderR.z,_rr_shoulder.z.x,_rr_shoulder.z.y)));\n    rotZ(_p_wristR,_p_shoulderR,m);\n    // rotZ(_p_wristR,_p_elbowR,rot(-clamp(_r_elbowR.z,_rr_elbow.z.x,_rr_elbow.z.y)));\n\n    // Pelvis (x-axis-rotation)\n    rotX(_p_head,_p_pelvis,m=rot(clamp(_r_pelvis.x,_rr_pelvis.x.x,_rr_pelvis.x.y)));\n    rotX(_p_shoulderL,_p_pelvis,m);\n    rotX(_p_elbowL,_p_pelvis,m);\n    rotX(_p_wristL,_p_pelvis,m);\n    rotX(_p_shoulderR,_p_pelvis,m);\n    rotX(_p_elbowR,_p_pelvis,m);\n    rotX(_p_wristR,_p_pelvis,m);\n    \n    // Pelvis (y-axis-rotation)\n    rotY(_p_legL,_p_pelvis,m=rot(clamp(_r_pelvis.y,_rr_pelvis.y.x,_rr_pelvis.y.y)));\n    rotY(_p_kneeL,_p_pelvis,m);\n    rotY(_p_footL,_p_pelvis,m);\n    rotY(_p_legR,_p_pelvis,m);\n    rotY(_p_kneeR,_p_pelvis,m);\n    rotY(_p_footR,_p_pelvis,m);\n\n    // Chest (y-axis-rotation)\n    rotY(_p_head,_p_chest,m=rot(clamp(_r_chest.y,_rr_chest.y.x,_rr_chest.y.y)));\n    rotY(_p_shoulderL,_p_chest,m);\n    rotY(_p_elbowL,_p_chest,m);\n    rotY(_p_wristL,_p_chest,m);\n    rotY(_p_shoulderR,_p_chest,m);\n    rotY(_p_elbowR,_p_chest,m);\n    rotY(_p_wristR,_p_chest,m);\n}\n\n/* ======================== */\n/* === Marching Globals === */\n/* ======================== */\n\nstruct Hit {\n\tvec3 p;\n\tfloat t;\n\tfloat d;\n\tfloat s;\n};\n\nstruct Ray {\n\tvec3 o;\n\tvec3 d;\n}, _ray;\n\nstruct Cam {\n\tvec3 p;\n\tvec3 t;\n    vec3 u;\n    float f;\n}, _cam;\n\nvec2 _uv;\nconst int _num_objects = 3;\nfloat _d, _obj[_num_objects];\n\nint _ignore = -1;\n\nbool _ambientOccMarch = false;\nbool _shadowMarch = false;\nbool _normalMarch = false;\n\n/* ================= */\n/* === Utilities === */\n/* ================= */\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEll(vec3 p,vec3 r){return (length(p/r)-1.)*min(min(r.x,r.y),r.z);}\nfloat udBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+r,0.))-r;}\nfloat sdBox(vec3 p,vec3 s,float r){vec3 d = abs(p)-s+r;return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.))-r;}\n\nfloat sdLine(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a, ap = p-a;\n    return length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-r;\n}\n\nfloat sdCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap,ab)/dot(ab,ab),0.,1.);\n    return length(ap-ab*t)-mix(r1,r2,t);\n}\n\nfloat patternCheckered(vec2 p)\n{\n    return mod(floor(p.x)+mod(floor(p.y),2.),2.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/* ============ */\n/* === Scene=== */\n/* ============ */\n\nfloat sdJoints(vec3 p, float r)\n{\n    float d = 1e10;\n    \n    d = min(d,length(p-_p_head)-r*2.);\n    d = min(d,length(p-_p_shoulderL)-r);\n    d = min(d,length(p-_p_shoulderR)-r);\n    d = min(d,length(p-_p_elbowL)-r);\n    d = min(d,length(p-_p_elbowR)-r);\n    d = min(d,length(p-_p_wristL)-r);\n    d = min(d,length(p-_p_wristR)-r);\n    d = min(d,length(p-_p_legL)-r);\n    d = min(d,length(p-_p_legR)-r);\n    d = min(d,length(p-_p_kneeL)-r);\n    d = min(d,length(p-_p_kneeR)-r);\n    d = min(d,length(p-_p_footL)-r);\n    d = min(d,length(p-_p_footR)-r);\n    \n    return d;\n}\n\nfloat sdFrame(vec3 p, float r)\n{\n    float d = 1e10;\n    \n    d = min(d,sdLine(p,_p_shoulderL,_p_shoulderR,r));\n    //d = min(d,sdLine(p,_p_legL,_p_legR,r));\n    \n    d = min(d,sdLine(p,_p_shoulderL,_p_elbowL,r));\n    //d = min(d,sdLine(p,_p_shoulderL,_p_legL,r));\n    d = min(d,sdLine(p,_p_elbowL,_p_wristL,r));\n    d = min(d,sdLine(p,_p_legL,_p_kneeL,r));\n    d = min(d,sdLine(p,_p_kneeL,_p_footL,r));\n     \n    d = min(d,sdLine(p,_p_shoulderR,_p_elbowR,r));\n    //d = min(d,sdLine(p,_p_shoulderR,_p_legR,r));\n    d = min(d,sdLine(p,_p_elbowR,_p_wristR,r));\n    d = min(d,sdLine(p,_p_legR,_p_kneeR,r));\n    d = min(d,sdLine(p,_p_kneeR,_p_footR,r));\n    \n    return d;\n}\n\nfloat sdBody(vec3 p)\n{\n    float d = 1e10;\n\n    d = min(d,sdCone(p,_p_shoulderL,_p_elbowL,.03,.025));\n    d = min(d,sdCone(p,_p_elbowL,_p_wristL,.025,.02));\n    \n    d = min(d,sdCone(p,_p_shoulderR,_p_elbowR,.03,.027));\n    d = min(d,sdCone(p,_p_elbowR,_p_wristR,.027,.02));\n    \n    d = min(d,sdCone(p,_p_legL,_p_kneeL,.05,.03));\n    d = min(d,sdCone(p,_p_kneeL,_p_footL,.03,.025));\n    d = min(d,sdCone(p,_p_legR,_p_kneeR,.05,.03));\n    d = min(d,sdCone(p,_p_kneeR,_p_footR,.03,.025));\n    \n    return d;\n}\n\nfloat scene(vec3 p)\n{\n\tvec3 q, s; float d = 1e10;\n\n    // Floor\n\td = sdBox(p*vec3(1,1,0)+vec3(0,1.1,0),vec3(.2,.1,0),.01);\n    _obj[0] = d; d = 1e10;\n    \n    if (_ambientOccMarch == true) _obj[0] = 1e10;\n    \n    p.y += 1.;\n\n    _obj[1] = min(sdFrame(p,0.01),sdJoints(p,.025));\n    _obj[2] = mod(floor(T*.25),2.) == 0. ? 1e10 : sdBody(p);\n\n\tfor(int i = 0; i < _num_objects; i++)\n\t{\n\t\t//if (_ignore == i) continue;\n\t\td = min(d,_obj[i]);\n\t}\n\n\t_d = d;\n\n\treturn d;\n}\n\n/* ================ */\n/* === Marching === */\n/* ================ */\n\nRay lookAt(Cam c, vec2 uv)\n{\n\tvec3 d = normalize(c.t - c.p);\n\tvec3 r = normalize(cross(d,c.u));\n\tvec3 u = cross(r,d);\n\n\treturn Ray(c.p*c.f, normalize(uv.x*r + uv.y*u + d*c.f));\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0., d, s;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(p = r.o + r.d*t);\n\n\t\tif (d < P || t > D)\n\t\t{\n\t\t\ts = float(i);\n\t\t\tbreak;\n\t\t}\n\n\t\tt += d/R;\n\t}\n\n\treturn Hit(p, t, d, s);\n}\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n\tvec2 e = vec2(P,0.);\n\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\n/* =============== */\n/* === Shading === */\n/* =============== */\n\nfloat getShadow(vec3 light, vec3 origin)\n{\n\t_shadowMarch = true;\n\n\tvec3 d = normalize(light - origin);\n\tfloat t = 0.;\n\tfloat maxt = length(light - origin)-.1;\n\tfloat s = 1.0;\n    \n    const int n = S/4;\n\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfloat d = scene(origin + d * t);\n\t\tif (t > maxt || t > D) { break; }\n\t\tt += d; s = min(s,d/t*K);\n\t}\n\n\treturn s;\n}\n\nfloat getAmbientOcclusion(Hit h) \n{\n    _ambientOccMarch = true;\n    \n    float t = 0., a = 0.;\n    \n\tfor(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.2);\n        t += d;\n    }\n\n\treturn clamp(t/A*20.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n\tif (h.d > P) { return vec3(_uv.y-h.s/float(S)*2.); }\n\n\tvec3 col = vec3(0);\n\tvec3 n = getNormal(h.p);\n    vec3 light = vec3(0,5,0);\n\n\tfloat diff = max(dot(n, normalize(light-h.p)),.1);\n\tfloat spec = pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.),100.);\n\tfloat dist = clamp(10./exp(length(h.p-light)*.3),0.,1.);\n    \n    if (_d == _obj[0])\n    {\n        vec2 c = h.p.xz;\n        if (abs(n.x) > .9) c = h.p.yz;\n        else if (abs(n.z) > .9) c = h.p.xy;\n            \n        c.y -= _ground.z;\n\t\tcol = vec3(1) - texture(iChannel0,c*.2).r * .3;\n    }\n    else if(_d == _obj[1])\n    {\n\t\tcol = vec3(1,0,0);\n    }\n    else if(_d == _obj[2])\n    {\n\t\tcol = vec3(1);\n    }\n    \n    #ifdef SHADOW\n    col *= max(getShadow(light,h.p),.5);\n    #endif\n    \n    #ifdef AMBIENT_OCCLUSION\n  \tcol *= getAmbientOcclusion(h);\n    #endif\n\n    return mix(vec3(_uv.y-h.s/float(S)*2.),col*1.5,dist);\n}\n\n/* ============ */\n/* === Main === */\n/* ============ */\n\nfloat hash21(vec2 p)\n{\n    return fract(sin(dot(p, vec2(50159.91193,49681.51239))) * 73943.1699);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvm = iMouse.xy/iResolution.xy;\n    if (iMouse.x < 10. && iMouse.y < 10.) { uvm = vec2(.5+T*.025,.5); }\n    \n    _cam = Cam(vec3(.5,.5,-1), vec3(0,-.2,0),vec3(0,1,0),2.);\n    _cam.p.yz *= rot((uvm.y*.25+.5)*PI + PI/1.8);\n    _cam.p.xz *= rot(uvm.x*TAU - PI/4.);\n    \n    _uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.xx;\n    _ray = lookAt(_cam,_uv);\n    \n    //doCrazyStuff();\n    \n    if(cos(T*.5)<0.)\n    waveHands();\n    else\n    walk(4.);\n    \n    rig();\n    \n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.5;\n\tfragColor = vec4(getColor(march(_ray))*f,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}