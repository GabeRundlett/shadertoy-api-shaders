{
    "Shader": {
        "info": {
            "date": "1519145169",
            "description": "An interactive cake with no occlusions for the year ahead!\nCake base forked from s23b's [url]https://www.shadertoy.com/view/4tKXzm[/url]\nCandlestick forked from P_Malin's [url]https://www.shadertoy.com/view/Xss3DH[/url]\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ldccW7",
            "likes": 2,
            "name": "Birthday Cake for Dr. Varshney",
            "published": 3,
            "tags": [
                "raymarching",
                "birthday",
                "cake"
            ],
            "usePreview": 0,
            "username": "starea",
            "viewed": 531
        },
        "renderpass": [
            {
                "code": "#define SPEED .1\n#define FOV 3.\n#define SLICES 12.\n#define CAKE_POS .15\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 50.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 20.\n#define LIGHT_COLOR vec3(1.,.5,.3)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 4; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// repeat space along an axis\nfloat tRepeat1(inout float p, float r) {\n    float id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// rectangle distance\nfloat sdRect(vec2 p, vec2 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, p.y), 0.) + length(max(p, 0.));\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// cylinder distance r - radius, l - height\nfloat sdCylinder(vec3 p, float r, float l) {\n    p.xy = vec2(abs(p.y) - l, length(p.xz) - r);\n    return min(max(p.x, p.y), 0.) + length(max(p.xy, 0.));\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// the icing on the cake\nfloat sdIcingOnTheCake(vec3 p) {\n    \n    // twist\n    tRotate(p.xz, p.y * 3.);\n    \n    // add an infinite box\n    float d = sdRect(p.xz, vec2(.4));\n    \n    // add another box, rotated by 45 degrees, smoothly\n    tRotate(p.xz, PI / 4.);\n    d = opSU(d, sdRect(p.xz, vec2(.4)), .1);\n    \n    // add a slope\n    d += p.y + .2;\n    \n    // divide the distance, because by now it has been ruined, then intersect smoothly with a sphere\n    d = -opSU(-d * .5, -sdSphere(p, .5), .1);\n    return d;\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    vec3 q = p;\n    \n    // rounded cylinder for the cake\n    float r = .02;\n    float d = sdCylinder(p, .5 - r, .2 -r) - r;\n    \n    // blend in the icing\n    tFan(q.xz, SLICES);\n\td = opSU(d, sdIcingOnTheCake((q - vec3(.4, .3, 0)) * 5.) / 5., .04);\n\t//d = opSU(d, sdIcingOnTheCake((q - vec3(.4, .3, 0)) * 2.) / 5., .01);\n    \n    // cut the cake\n    tRotate(p.xz, PI / SLICES);\n    float slice = p.z;\n    float a = fract((floor(iTime * SPEED * SLICES)) / SLICES - .5) * PI * 2.;\n   // a = PI * 0.5 / 8.0 * 2.0;\n    tRotate(p.xz, a);\n    slice = (a < PI) ? opU(slice, p.z) : opI(slice, p.z);\n    return opS(d, slice);\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = map(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 q = p;\n    q.y += .05;\n    tRepeat1(q.y, .095);\n    vec3 t = mix(fbm(fbm(p * 10.) + p * 10.) * vec3(.5) + vec3(.5),\n                fbm(p * 100.) * vec3(.5, .0, .0),1. - \n                saturate((opI(sdCylinder(p, .5, .175),sdCylinder(q, .48, .035)) + (fbm(p * 100.)- .5) * .02 ) * 100.));\n    return saturate(t);\n}\n\n// texture used for bump mapping\nfloat bumpTexture(vec3 p) {\n    vec3 q = p;\n    q.y += .05;\n    tRepeat1(q.y, .095);\n    float t = mix(fbm(fbm(p * 20.) + p * 10.) * .5 + .25,\n                fbm(p * 100.), 1. - \n                saturate((opI(sdCylinder(p, .5, .175),sdCylinder(q, .48, .035)) + (fbm(p * 100.)- .5) * .02 ) * 100.));\n    return saturate(t);\n}\n\n// bump mapping from Shane\nvec3 doBumpMap(vec3 p, vec3 nor, float bumpfactor) {\n    \n    vec2 e = vec2(.0001, 0);\n    float ref = bumpTexture(p);                 \n    vec3 grad = vec3(bumpTexture(p - e.xyy) - ref,\n                     bumpTexture(p - e.yxy) - ref,\n                     bumpTexture(p - e.yyx) - ref) / e.x;\n             \n    grad -= nor * dot(nor, grad);          \n                      \n    return normalize(nor + grad * bumpfactor);\n\t\n}\n\n#ifdef LOW_QUALITY\n\n\t#define kRaymarchMaxIter 32\n\t#define kMaxIter 3\n\t#define kShadowIter 8\n\n#else\n\n\t#define kRaymarchMaxIter 128\n\t#define kMaxIter 4\n\t#define kShadowIter 16\n\n#endif \n\n//#define ENABLE_MIRROR\n\n//#define BURN_DOWN\n\nfloat fSceneIntensity = 0.5;\n\nvec3 vFlameLightColour = vec3(1.0, 0.5, 0.1) * 10.0;\nvec3 vFlameColour1 = vec3(1.0, 0.5, 0.1);\nvec3 vFlameColour2 = vec3(1.0, 0.05, 0.01);\n\nvec3 GetFlameWander()\n{\n    vec3 vFlameWander = vec3(0.0, 0.0, 0.0);\n\n\tvFlameWander.x = sin(iTime * 20.0);\n\tvFlameWander.z = sin(iTime * 10.0) * 2.0;\n\n    return vFlameWander;\t\n}\n\nfloat fWaxExtinction = 5.0;\n\nfloat kExposure = 3.5;\n\nvec3 vCandlestickPos = vec3(0.0, 0.0, 0.0);\n\n#ifndef BURN_DOWN\n\tfloat fCandleTop = max(0.0, 0.1);\n#else\n\tfloat fCandleTop = max(2.2, 1.0 - iTime * 0.005);\n#endif\n\nvec3 GetLightPos()\n{\n    return vCandlestickPos + vec3(0.0, fCandleTop + 0.35, 0.0) - GetFlameWander() * 0.01;\n}\n\n#define kMaterialWood   0.0\n#define kMaterialGold \t1.0\n#define kMaterialWax \t2.0\n#define kMaterialWick\t3.0\n#define kMaterialChrome\t4.0\n#define kMaterialPaper\t5.0\n\nvec2 GetDistanceCandlestick( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\n\tfloat fTop = 2.0;\n\tfloat fBottom = 0.0;\n\t\n\tfloat fOutside = -1.0;\n\t\n\tfloat fDist = vProfilePos.x;\t\n\tfloat fVerticalPos = vProfilePos.y;\n\t\n\tif(fVerticalPos > fTop)\n\t{\n\t\tfVerticalPos = fTop;\n\t\tfOutside = 1.0;\n\t}\n\n\tif(fVerticalPos < fBottom)\n\t{\n\t\tfVerticalPos = fBottom;\t\t\n\t\tfOutside = 1.0;\n\t}\n\n\tfloat t = fVerticalPos;\n\tfloat a = 3.14 * 2.0;\n\tfloat b = 0.15;\n\tfloat fHorizontalPos = 0.4 + sin(t * a) * b;\n\tfloat fHorizontalPosDelta = (cos(t * a) * a * b) / a;\n\t\n\tfloat fHorizontalDist = vProfilePos.x - fHorizontalPos;\n\t\n\tif(fOutside > 0.0)\n\t{\n\t\tvec2 vClosest = vec2(min(fHorizontalPos, vProfilePos.x), fVerticalPos);\n\t\t\n\t\tfDist = length(vClosest - vProfilePos);\t\t\n\t}\n\telse\n\t{\n\t\t\n\t\tif(fHorizontalDist > 0.0)\n\t\t{\n\t\t\tfOutside = 1.0;\n\t\t}\n\n\t\tif(fOutside < 0.0)\n\t\t{\t\t\n\t\t\tfloat fTopDist = fTop - fVerticalPos;\n\t\t\tfloat fBottomDist = fVerticalPos - fBottom;\n\t\t\tfDist = min(fTopDist, fBottomDist);\n\t\t\tfDist = min(fDist, -fHorizontalDist);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfDist = fHorizontalDist / sqrt(1.0 + fHorizontalPosDelta * fHorizontalPosDelta);\t\n\t\t}\n\t}\n\t\n\tfloat fBevel = 0.1;\n\tfloat fStickDistance = fOutside * fDist -fBevel;\n\t\n\tfloat fBaseTop = 0.1;\n\tfloat fBaseRadius = 1.0;\n\tvec2 vBaseClosest = vProfilePos;\n\tvBaseClosest.y = min(vBaseClosest.y, fBaseTop);\n\tvBaseClosest.x = min(vBaseClosest.x, fBaseRadius);\n\n\tfloat fBaseDistance = length(vProfilePos - vBaseClosest) - fBevel;\n\t\n\treturn vec2( min(fStickDistance, fBaseDistance), kMaterialGold);\n}\n\n\nfloat GetDistanceWaxTop( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\n\tfloat fCurve = 1.0;\n\t\n\treturn vProfilePos.y - fCandleTop - vProfilePos.x * vProfilePos.x * fCurve;\t\n}\n\nvec2 GetDistanceCandle( const in vec3 vPos )\n{\n\tvec2 vProfilePos = vec2( length(vPos.xz), vPos.y );\n\t\n\tfloat fDistance = vProfilePos.x - 0.15;\n\t\t\n\tfloat fDistanceTop = sdCylinder(vPos, 0.15, 0.2);\n        \n    //GetDistanceWaxTop(vPos);\n\t\n\tif (fDistanceTop > fDistance)\n\t{\n\t\tfDistance = fDistanceTop;\n\t}\n\t\n\treturn vec2(fDistance, kMaterialWax);\n}\n\nvec2 GetSceneDistance( vec3 vPos )\n{    \n\tvec3 vCandlestickLocalPos = vPos - vCandlestickPos;\t\n\n\tvec2 vResult = vec2(1.0, -1.0);\n\t\n\tvec2 vCandle = GetDistanceCandle(vCandlestickLocalPos);\n\tif(vCandle.x < vResult.x)\n\t{\n\t\tvResult = vCandle;\n\t}\n\n\treturn vResult;\n}\n\n\nvec2 Raycast( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tvec2 d = vec2(0.0, -1.0);\n\tfloat t = 0.01;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\n\t\td = GetSceneDistance(vOrigin + vDir * t);\n\t\tif(abs(d.x) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.x;\n\t\tif(t > 100.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn vec2(t, d.y);\n}\n\n\nvec3 GetSceneNormal( const in vec3 vPos )\n{\n    const float fDelta = 0.001;\n\n    vec3 vOffset1 = vec3( fDelta, -fDelta, -fDelta);\n    vec3 vOffset2 = vec3(-fDelta, -fDelta,  fDelta);\n    vec3 vOffset3 = vec3(-fDelta,  fDelta, -fDelta);\n    vec3 vOffset4 = vec3( fDelta,  fDelta,  fDelta);\n\n    float f1 = GetSceneDistance( vPos + vOffset1 ).x;\n    float f2 = GetSceneDistance( vPos + vOffset2 ).x;\n    float f3 = GetSceneDistance( vPos + vOffset3 ).x;\n    float f4 = GetSceneDistance( vPos + vOffset4 ).x;\n\n    vec3 vNormal = vOffset1 * f1 + vOffset2 * f2 + vOffset3 * f3 + vOffset4 * f4;\n\n    return normalize( vNormal );\n}\n\n\nvec3 GetFlameIntensity( const in vec3 vOrigin, const in vec3 vDir, const in float fDistance )\n{\n\tvec3 vFlamePos = vec3(0.0, fCandleTop + 0.25, 0.0) + vCandlestickPos;\n\tvec3 vToFlame = vFlamePos - vOrigin;\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = clamp(fClosestDot, 0.0, fDistance);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - vFlamePos;\n\t\n\tvClosestToFlame.xz *= (vClosestToFlame.y + 1.0) * 1.5;\n\tvClosestToFlame.y *= 0.5;\n\tvClosestToFlame *= 8.0;\n\n\tfloat fSwayAmount = (1.0 + vClosestToFlame.y ) * 0.05;\n\tvClosestToFlame += GetFlameWander() * fSwayAmount;\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = smoothstep(1.0, 0.5, fClosestDist) * 2.0;\n\t\t\t\n\tfloat fHeightFade = (vClosestToFlame.y * 0.5 + 0.5);\n\tfBrightness *= clamp(dot(vClosestToFlame.xz, vClosestToFlame.xz) + fHeightFade, 0.0, 1.0);\n\n\treturn mix(vFlameColour1 * 32.0, vFlameColour2, 1.0 - fBrightness) * fBrightness;\n}\nvec3 GetFlareIntensity( const in vec3 vOrigin, const in vec3 vDir )\n{\n\tvec3 vToFlame = GetLightPos() - vOrigin;\n\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = max(fClosestDot, 0.0);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - GetLightPos();\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = (1.0 / (fClosestDist + 1.0));\t\n\n\treturn vFlameColour1 * pow(fBrightness, 5.0);\n}\nfloat GetAmbientOcclusion( const in vec3 vPos, const in vec3 vNormal)\n{\t\n\tfloat fAmbientOcclusion = 0.0;\n\t\n\tfloat fStep = 0.1;\n\tfloat fDist = 0.0;\n\tfor(int i=0; i<=5; i++)\n\t{\n\t\tfDist += fStep;\n\t\t\n\t\tvec2 vSceneDist = GetSceneDistance(vPos + vNormal * fDist);\n\t\t\n\t\tfloat fAmount = (fDist - vSceneDist.x);\n\t\t\n\t\tfAmbientOcclusion += max(0.0, fAmount * fDist );                                  \n\t}\n\t\n\treturn max(1.0 - fAmbientOcclusion, 0.0);\n}\n\n\nvec3 SampleDiffuse( const in vec3 vDir )\n{\n\tvec3 vSample = texture(iChannel1, vDir, 0.0).rgb;\n\tvSample = vSample * vSample;\n\t\n\t// hack bright spots out of blurred environment\n\tfloat fMag = length(vSample);\t\n\tvSample = mix(vSample, vec3(0.15, 0.06, 0.03), smoothstep(0.1, 0.25, fMag));\n\t\n\treturn vSample * fSceneIntensity;\n}\n\n\n\nvec2 GetDistanceSphere( const in vec3 vPos )\n{\n\tfloat fDistance = length(vPos - vec3(1.3, 0.75, 1.0)) - 0.75;\n\n\treturn vec2(fDistance, kMaterialChrome);\n}\nvec3 RotateX( const in vec3 vPos, const in float s, const in float c )\n{\n\tvec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n\n\treturn vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float s, const in float c )\n{\n\tvec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n\n\treturn vResult;\n}\n\nfloat GetDistanceBox( const in vec3 vPos, const in vec3 vDimension )\n{\n\tvec3 vDist = abs(vPos) - vDimension;\n  \tfloat fDistance =  min(max(vDist.x,max(vDist.y,vDist.z)),0.0) + length(max(vDist,0.0));\n\n\treturn fDistance;\t\n}\nfloat g_PaperRotSin = sin(-0.1);\nfloat g_PaperRotCos = cos(-0.1);\n\nvec2 GetDistanceShadowCasters( const in vec3 vPos )\n{\n\tvec2 vResult = vec2(1000.0, -1.0);\n\n\tvec3 vCandlestickLocalPos = vPos - vCandlestickPos;\t\n\n\tvec2 vCandlestick = GetDistanceCandlestick(vCandlestickLocalPos);\n\tif(vCandlestick.x < vResult.x)\n\t{\n\t\tvResult = vCandlestick;\n\t}\n\t\n\tvec2 vSphere = GetDistanceSphere(vPos);\n\tif(vSphere.x < vResult.x)\n\t{\n\t\tvResult = vSphere;\n\t}\n\t\n\t\n\tvec3 vPapereLocalPos = RotateY(vPos, g_PaperRotSin, g_PaperRotCos);\n\t\n\t#ifdef ENABLE_MIRROR\n\t\n\tvec3 vMirrorLocalPos = vPos - vec3(0.0, 0.0, 3.5);\n\tvMirrorLocalPos = RotateY(vMirrorLocalPos, g_MirrorRotSin, g_MirrorRotCos);\n\t\n\tvec2 vMirrorStand = GetDistanceMirrorStand(vMirrorLocalPos);\n\tif(vMirrorStand.x < vResult.x)\n\t{\n\t\tvResult = vMirrorStand;\n\t}\n\t\n\t\n\tvec3 vMirrorPaneLocalPos = vMirrorLocalPos - vec3(0.0, 2.7, 0.0);\t\n\tvMirrorPaneLocalPos = RotateX(vMirrorPaneLocalPos, g_MirrorTiltSin, g_MirrorTiltCos);\n\t\n\tvec2 vMirror = GetDistanceMirror(vMirrorPaneLocalPos);\n\tif(vMirror.x < vResult.x)\n\t{\n\t\tvResult = vMirror;\n\t}\n\t#endif\t\n\n\treturn vResult;\n}\n\n\nfloat RaycastShadow( const in vec3 vOrigin, const in vec3 vDir, const in float k )\n{\n\tfloat fShadow = 1.0;\n\tfloat t = 0.01;\n\tfloat fDelta = 1.0 / float(kShadowIter);\n\tfor(int i=0; i<kShadowIter; i++)\n\t{\n\t\tfloat d = GetDistanceShadowCasters(vOrigin + vDir * t).x;\n\t\t\n\t\tfShadow = min( fShadow, k * d / t );\n\t\t\n\t\tt = t + fDelta;\n\t}\n\t\n\treturn clamp(fShadow, 0.0, 1.0);\n}\n\n\nvoid TraceRay( inout vec3 vOrigin, inout vec3 vDir, out vec3 vColour, inout vec3 vRemaining )\n{\t\n    vec3 vLightPos = GetLightPos();\n\tvec2 vHit = Raycast(vOrigin, vDir);\n\t\n\tvec3 vHitPos = vOrigin + vDir * vHit.x;\n\tvec3 vHitNormal = GetSceneNormal(vHitPos);\n\t\n\tvec3 vAlbedo = vec3(0.0);\n\tvec3 vSpecR0 = vec3(0.0);\n\tfloat fSmoothness = 0.0;\n\n\tvec3 vEmissive = vec3(0.0);\n\tvec3 vGlow = GetFlameIntensity(vOrigin, vDir, vHit.x);\n\n\tif(vHit.x > 20.0)\n\t{\n\t\tvColour = vGlow + GetFlareIntensity(vOrigin, vDir);\n\t\tvColour *= vRemaining;\n\t\tvOrigin = vHitPos;\n\t}\n\telse\n\t{\n\t\tfloat fAmbientOcclusion = GetAmbientOcclusion(vHitPos, vHitNormal);\n\t\n\t\tif(vHit.y <= kMaterialWax)\n\t\t{\n\t\t\tvAlbedo = vec3(0.9);\n\t\t\tvSpecR0 = vec3(0.01);\n\t\t\t\n\t\t\tfloat fDistanceThroughWax = GetDistanceWaxTop(vHitPos - vCandlestickPos - GetFlameWander() * 0.025);\n\t\t\tvEmissive = vFlameLightColour * (exp(fWaxExtinction * fDistanceThroughWax));\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialWick)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.01);\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialChrome)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.3);\n\t\t\tvSpecR0 = vec3(0.85);\n\t\t\tfSmoothness = 1.0;\n\t\t}\n\t\telse\n\t\tif(vHit.y <= kMaterialPaper)\t\t\t\n\t\t{\n\t\t\tvAlbedo = vec3(0.9);\n\t\t\tvSpecR0 = vec3(0.0);\n\t\t\tfSmoothness = 0.0;\n\t\t}\n\n\t\t\t\t\n\t\tvec3 vDiffuseLight = SampleDiffuse(vHitNormal) * fAmbientOcclusion;\n\t\t\t\n\t\tvec3 vToLight = vLightPos - vHitPos;\n\t\tfloat fDistToLight = length(vToLight);\n\t\tvec3 vNormToLight = normalize(vToLight);\n\t\t\n\t\tfloat fDot = clamp(dot(vNormToLight, vHitNormal), 0.0, 1.0);\n\t\t\n\t\tfloat fShadow = RaycastShadow(vHitPos, vToLight, 1.0);\n\t\n\t\t// Fake shadow from candle\n\t\tfShadow *= smoothstep(0.4, 0.6, length(vToLight.xz) / max(vToLight.y, 0.01));\n\n\t\tfShadow = mix(0.1 + 0.15 * fAmbientOcclusion, 1.0, fShadow);\n\t\n\t\tvec3 vLightIntensity = vFlameLightColour * fDot * fShadow;\n\t\tvLightIntensity /= fDistToLight * fDistToLight;\n\t\tvDiffuseLight += vLightIntensity;\n\t\t\n\t\tvec3 vReflectDir = normalize(reflect(vDir, vHitNormal));\n\t\t\n\t\tvec3 vHalf = normalize(vReflectDir + -vDir);\n\t\tfloat fFresnelDot = clamp(1.0 - dot(vHalf, -vDir), 0.0, 1.0);\t\n\t\tfloat fFresnel = pow(fFresnelDot, 5.0);\n\t\t\t\t\n\t\tvec3 vReflectFraction = vSpecR0 + (vec3(1.0) - vSpecR0) * fFresnel * fSmoothness;\n\t\n\t\tvColour = (vDiffuseLight * vAlbedo + vEmissive) * (vec3(1.0) - vReflectFraction);\n\t\tvColour += GetFlareIntensity(vOrigin, vDir);\n\t\tvColour += vGlow;\n\t\tvColour *= vRemaining;\n\t\tvRemaining *= vReflectFraction;\n\t\tvOrigin = vHitPos;\n\t\tvDir = vReflectDir;\n\t}\n\t\n}\n\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 2.;\n    \n    // set up camera position\n    vec3 ro =  vec3(0, 0, -2);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // light is relative to the camera\n    vec3 light = ro + vec3(-.6, .1, -.1);\n    \n    vec2 rot = vec2(0);\n    if (iMouse.z > 0.) {\n    \t// rotate the scene using the mouse\n        rot = -mouse;\n    } else {\n        // otherwise rotate constantly as time passes\n        \n        rot = vec2(-iTime * SPEED * PI + .3, .5);\n        //rot = -mouse;\n    }\n    \n    tRotate(rd.yz, rot.y);\n    tRotate(rd.xz, rot.x);\n    tRotate(light.yz, rot.y);\n    tRotate(light.xz, rot.x);\n    tRotate(ro.yz, rot.y);\n    tRotate(ro.xz, rot.x);\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    normal = doBumpMap( p, normal, .01);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light);\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 4.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal) * .5 + .5;\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR);\n    \n    // fog\n    vec4 fogColor = vec4(vec3(0,.01,.014) * (2. - length(uv)), 1.);\n    fragColor = mix(fragColor, fogColor, saturate(dist * dist * .05));\n    \n    // if we passed the cake, then apply a dark glow, this makes the cake pop out\n    if (length(p) > .6) \n        fragColor *= saturate(1. - sqrt(steps / float(MAX_STEPS)) * 1.5);\n    \n    vec3 outsideCake = fragColor.rgb;\n    \n\tvec3 vRemaining = vec3(1.0);\n    vec3 vColour = vec3(0.0);\n\tTraceRay(ro, rd, vColour, vRemaining);\n    \n    vColour = pow(vColour, vec3(2.2));\n\tfragColor.rgb = mix(fragColor.rgb, vColour, 0.1);\n    \n    vColour = Tonemap(vColour);\n    \n    //fragColor.rgb = Tonemap(fragColor.rgb);\n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n    \t\t\n    \n    //\n    vec2 V = fragCoord.xy / iResolution.xy;\n    float edgeEffect = pow( 32.0 * V.y * V.x * (1.0 - V.y) * (1.0 - V.x), 0.15 );\n    \n    if (length(outsideCake.rgb) < 0.2 || edgeEffect < 0.1) {\n    \tfragColor = mix(texture(iChannel0, rd), fragColor, length(fragColor) * 0.5);     \n    }\n    fragColor = fragColor * edgeEffect;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}