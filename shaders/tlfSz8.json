{
    "Shader": {
        "info": {
            "date": "1562014335",
            "description": "Colored version of Box Loop 3:\nhttps://www.shadertoy.com/view/tlsSzr",
            "flags": 0,
            "hasliked": 0,
            "id": "tlfSz8",
            "likes": 4,
            "name": "Box Loop 3 (colored)",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "distance",
                "manhattan"
            ],
            "usePreview": 0,
            "username": "mlkn",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "// https://www.shadertoy.com/view/MslGD8 - basic voronoi\n// https://www.shadertoy.com/view/llG3zy - voronoi edge dist\n// https://www.shadertoy.com/view/Mtyczw - manhattan edge dist\n// https://www.shadertoy.com/view/MstGRr - 2d box distance\n\n#define BOX_SIZE 0.4\n#define LOOP_PERIOD 2.7\n\n#define M_PI 3.14159265\n#define EPSILON .00001\n\nfloat invert = 1.0;\nfloat cycle = 0.0;\nfloat edgeCut = 0.03;\nfloat panicTerm = 0.1;\nfloat metricsTerm = 0.0;\nfloat finalSpread = 1.0;\nfloat t = 0.0;\n\nfloat rot = 0.0;\nfloat nextBoxRot = 0.0;\nfloat scale = 1.0;\nfloat nextBoxScale = 1.0;\n\nvec2 hash( vec2 p )\n{\n    p = vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    vec2 result = fract(sin(p)*18.5453);\n    return 0.5 + panicTerm*sin(t * t * t * 15.0 + cycle + 6.2831*result);\n}\n\nfloat dist_minkowski(vec2 a, vec2 b, float p) {\n    // manhattan: return abs(a.x - b.x) + abs(a.y - b.y);\n    return pow(pow(abs(a.x - b.x),p) + pow(abs(a.y - b.y),p),1.0/p);\n}\n\nvec2 square_test(vec2 a, vec2 b){\n    return sqrt((a - b) * (a - b));\n}\n\nfloat vec_max(vec2 a){\n    return max(abs(a.x), abs(a.y));\n}\n\nfloat edge_dist_manhattan(vec2 center_a, vec2 center_b, vec2 p){\n\t\n    int max_comp, min_comp;\n    vec2 max_base, min_base, split_dir;\n    float dist;\n\n    vec2 center_max = max(center_a, center_b);\n    vec2 center_min = min(center_a, center_b);\n    vec2 square = square_test(center_max, center_min);\n\n    if(vec_max(square) == square.x){\n        max_comp = 0;\n    }else{\n        max_comp = 1;\n    }\n    min_comp = (max_comp + 1) % 2;\n    \n    vec2 split_pos_a, split_pos_b;\n    float u = square[min_comp] / 2.;\n    \n    float mid = (center_max[max_comp] + center_min[max_comp]) / 2.;\n    \n    split_pos_a = center_min;\n    split_pos_a[max_comp] = mid + u;\n\n    split_pos_b = center_max;\n    split_pos_b[max_comp] = mid - u;\n\n    max_base = max(split_pos_a, split_pos_b);\n    min_base = min(split_pos_a, split_pos_b);\n\n    split_dir = split_pos_b - split_pos_a;\n    vec2 split_dir_test = normalize(center_a - center_b);\n    \n    vec2 split_origin = max_base;\n    vec2 split_tip = min_base;\n    if(abs(dot(normalize(split_dir), split_dir_test)) < abs(dot(normalize(min_base - max_base), split_dir_test))){\n        split_dir = min_base - max_base;\n        split_origin = split_pos_a;\n        split_tip = split_pos_b;\n    }\n\n    if(square[min_comp] <= 1e-4){\n        split_dir = vec2(0.);\n        split_dir[max_comp] = 1.;\n    }\n\n    vec2 midp = (min_base + max_base) / 2.;\n    vec2 dir = p - midp;\n    dist = dot(dir, normalize(split_dir));\n\n    vec2 new_pos = p - normalize(split_dir) * dist;\n\n    if(length(midp - new_pos) > length(split_dir) / 2.){\n        vec2 nearest_sample;\n        vec2 split_o_p = new_pos - split_origin;\n        vec2 split_t_p = new_pos - split_tip;\n\n        if(vec_max(split_o_p) < vec_max(split_t_p)){\n            nearest_sample = split_origin;\n        }else{\n            nearest_sample = split_tip;\n        }\n                \n        vec2 n = vec2(0.);\n        n[max_comp] = 1.;\n        \n        vec2 ro = normalize(split_dir);\n        float d = dot(p - nearest_sample, n) / dot(ro, n);\n        dist = d;\n    }\n\n   return abs(dist);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 closestPoint;\n    float id;\n\n    float minDist = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash(n + cell);\n        \n        vec2 r = cell - f + point;\n        float dist = dist_minkowski(r,vec2(0,0), metricsTerm + 1.0);\n\n        if( dist < minDist )\n        {\n            minDist = dist;\n            closestPoint = r;\n            id = point.x + point.y;\n        }\n    }\n\n    // second pass: distance to borders\n    minDist = 6.66;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 point = hash(n + cell);\n\n\t\tvec2 r = cell - f + point;\n\n        if( dot(closestPoint-r,closestPoint-r) > EPSILON ) // skip the same cell\n        {\n            float curDist = mix(\n                edge_dist_manhattan(f - closestPoint, f - r, f),\n                dot(0.5*(closestPoint+r), normalize(r-closestPoint)),\n                step(0.03, metricsTerm));\n            minDist = min( minDist, curDist );\n        }\n    }\n\n    return vec4( minDist, closestPoint, id );\n}\n\nfloat box_dist(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nvec2 rotate_around(vec2 p, vec2 c, float angle) {\n\tvec2 t = p - c;\n    vec2 rot = vec2(\n        cos(angle) * t.x - sin(angle) * t.y,\n        sin(angle) * t.x + cos(angle) * t.y\n    );\n\treturn c + rot;\n}\n\nvec3 findVal(vec2 myFragCoord)\n{\n    vec2 p = myFragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    p.x *= aspectRatio;\n    vec2 center = vec2(0.5 * aspectRatio, 0.5);\n    \n    vec2 rotatedP = rotate_around(p, center, rot);\n    vec2 c = (rotatedP - center) * scale;\n    \n    vec2 rotatedP2 = rotate_around(p, center, nextBoxRot);\n    vec2 nextBoxC = (rotatedP2 - center) * nextBoxScale;\n    float nextBoxDist = box_dist(nextBoxC, vec2(BOX_SIZE), 0.0);\n    \n    float d = smoothstep(0.0, 0.002, box_dist(c, vec2(BOX_SIZE), 0.0));\n\n    vec4 voro = voronoi((p - center) * mix(4.0, finalSpread, max(t - 0.5, 0.0)*2.0));\n\n    vec3 col = 0.5 + 0.5*cos(vec3(voro.w, voro.w * 0.5, voro.w*0.3)*6.2831 );\n    \n    col = mix(col, vec3(0.0,0.0,1.0), d);\n    float voronoiEdge = smoothstep(edgeCut-0.01,edgeCut, voro.x);\n    float val = min(voronoiEdge * (1.0 - d)\n                    + smoothstep(0.001, 0.01, nextBoxDist), 1.0);\n    val = val * invert - min(invert, 0.0);\n    if (invert < 0.0)\n    {\n        vec3 startCol = 0.5 + 0.5*cos(vec3(1.0, 0.5, 0.3)*6.2831 );\n        float tt= max((t-0.6)/ 0.4,0.0);\n        col = mix(col, startCol, pow(tt, 0.5) * (1.0 - voronoiEdge));\n    }\n    return vec3(val) * col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{   \n    t = mod(iTime, LOOP_PERIOD) / LOOP_PERIOD;\n    cycle = float(int(iTime / LOOP_PERIOD));\n    if (mod(cycle, 2.0) < 1.0) invert = -1.0;\n\n    panicTerm = min(max(t - 0.1, 0.01) * 0.4, 0.3);\n\tmetricsTerm = smoothstep(0.45, 0.55, 1.0 - t);\n    finalSpread = 15.0 - invert * 7.0;\n\n    edgeCut = min(t * 0.05, 0.05) + 3.3 * pow(max((t - 0.7)/0.7, 0.0), 2.0);\n    \n    rot = max(min((t - 0.5) * 2.05, 1.0), 0.0);\n    nextBoxRot = -pow(rot, 0.3) * M_PI * 0.5 * invert;\n    rot = rot*rot*rot* M_PI / 2.0 * invert;  \n\n    scale = 1.0 + max(t-0.5, 0.0) * 5.0;\n    nextBoxScale = max((t - 0.5), 0.0) / 0.5;\n    \n    fragColor.rgb = findVal(fragCoord.xy);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}