{
    "Shader": {
        "info": {
            "date": "1534362082",
            "description": "An algorithm that finds the minimum of a 2d QEF in 3 gradient decent steps. ",
            "flags": 0,
            "hasliked": 0,
            "id": "MtccWf",
            "likes": 5,
            "name": "QEF Minimization 2D",
            "published": 3,
            "tags": [
                "optimization",
                "qef",
                "minimization"
            ],
            "usePreview": 0,
            "username": "TinyTexel",
            "viewed": 326
        },
        "renderpass": [
            {
                "code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n// QEF Minimization 2D\n\n/*\nAn algorithm that finds the minimum of a 2d QEF in 3 gradient decent steps. \n\n\nn-dimensional QEF minimization:\n\nPerforming gradient decent with optimal step width in order to find the minimum \nof a 2d QEF results in a search path of which the vertices form a zigzag pattern.\nLooking closely it becomes apparent that all even and odd numbered vertices\nlie, respectively, on two lines that intersect the minimum of the QEF.\n\nBased on this observation we can deduce a much more effient approach to minimize the 2d QEF:\nLet P0 denote the starting point and P1 and P2 the first two vertices produced by the gradient decent.\nPerforming a single gradient decent step with optimal step width starting from P0 and going in \nthe direction of P2 yields the exact minimization solution.\n\nThe generalization to n-dimensions is not obvious, but here is how I think it works:\n\nPn: denotes the n-th point (i.e. vertex) along the search path\nRn: denotes the minimization result in n-dimensions\n->: denotes a gradient decent step with optimal step width\n    either in the direction of the gradient (-> Grad)\n    or in the direction of another point (-> Px)\n\n0D:\n    P0\n    R0 = P0\n\n1D (minimum of a parabola):\n    P1 = P0 -> Grad\n    R1 = P1\n\n2D (the case shown here):\n    P1 = P0 -> Grad\n     P2 = P1 -> Grad\n     P3 = P0 -> P2\n    R2 = P3\n\n3D:\n    P1 = P0 -> Grad\n     P2 = P1 -> Grad\n     P3 = P0 -> P2\n      P4 = P3 -> Grad\n      P5 = P1 -> P4\n    R3 = P5\n\nnD(???):\n    Rn := R(n-2) -> (R(n-1) -> Grad)\n\nI have tested the 3d case (just a couple examples by hand, though) \nbut not the generalization to higher dimensions.\n\n3d case (very messy wip): https://www.shadertoy.com/view/wtsSD4\n*/\n\n// commend out to use gradient decent with optimal step width:\n    #define USE_OPTIMIZED_ALGORITHM\n\n\n\nvoid QEFfromPlane(float c, vec2 n, out float A, out vec2 B, out vec3 C)\n{\n    C = n.xyx * n.xyy;\n    B = -c * n;\n    A =  c * c;    \n}\n\nvoid Eval(inout vec3 col, vec2 tex, vec2 pos, bool useMousePos)\n{\n    // start pos for the seach process\n    if(!useMousePos)\n    pos = vec2(1.7, 0.0);\n    \n    float time = iTime;\n    //pos += vec2(cos(time), sin(time)) * 0.5;\n\n\n    // 3 test planes/lines (could be arbitrarily many)\n    float p0c = 0.5;\n    vec2  p0n = CosSin(0.3 * Pi);      \n    \n    float p1c = 0.25;\n    vec2  p1n = CosSin(0.4 * Pi);      \n\n    float p2c = 0.75;\n    vec2  p2n = CosSin(0.41 * Pi);            \n\n\n    // compute QEF coefficients\n    float pA = 0.0; vec2 pB = vec2(0.0); vec3 pC = vec3(0.0);\n\n    float p0A; vec2 p0B; vec3 p0C;   \n    QEFfromPlane(p0c, p0n, p0A, p0B, p0C);\n    \n    float p1A; vec2 p1B; vec3 p1C;   \n    QEFfromPlane(p1c, p1n, p1A, p1B, p1C);\n    \n    float p2A; vec2 p2B; vec3 p2C;   \n    QEFfromPlane(p2c, p2n, p2A, p2B, p2C);\n    \n    pA += p0A; pB += p0B; pC += p0C;\n    pA += p1A; pB += p1B; pC += p1C;\n    pA += p2A; pB += p2B; pC += p2C;\n\n\n    // draw iso lines of QEF\n    {\n      #if 1\n        // eval QEF from coefficients\n        float v = pA + dot(pB * 2.0, tex.xy) + dot(pC * vec3(1.0, 1.0, 2.0), tex.xyx * tex.xyy);\n      #else\n        // eval QEF from plane equations\n        float v = 0.0;\n        v += Pow2(dot(tex, p0n) - p0c);\n        v += Pow2(dot(tex, p1n) - p1c);\n        v += Pow2(dot(tex, p2n) - p2c);\n      #endif\n      \n        col = vec3(IsoLines(v * 64.0));\n    }\n    \n    \n    // draw point at reference solution (magenta)\n    vec2 solP = Minimize2dQEF_Reference(pos, pB, pC);\n    col = mix(col, vec3(1.0, 0.05, 1.0), Dot(tex.xy, solP, 0.015));  \n\n    // draw thick line from start to solution for reference (light blue)\n    col = mix(col, vec3(0.0, 0.5, 1.0), 0.5*Line2(tex.xy, pos, solP, 0.006)); \n\n#ifdef USE_OPTIMIZED_ALGORITHM\n    vec2 pos2 = pos;\n    for(uint i = 0u; i < 3u; ++i)\n    {\n        vec2 pos2t = pos2;\n    \n        vec2 grad = vec2(dot(pos2, pC.xz), \n                         dot(pos2, pC.zy)) + pB;\n    \n        vec2 grad0 = grad;\n        \n        if(i == 2u)\n        {\n            // step from P0 towards P2\n            grad = pos - pos2;\n        }\n        \n        //float n = dot(grad, pB) + dot(pos2.xyxy * grad.xyyx, pC.xyzz);\n        float n = dot(grad, grad0);\n        float m = dot(grad.xyx * grad.xyy, pC * vec3(1.0, 1.0, 2.0));\n        \n        // optimal step width\n        float t = max(0.0, n / m);\n        \n        pos2 -= grad * t;       \n        \n        // draw search path segment and vertex (blue)\n        col = mix(col, vec3(0.0, 0.05, 1.0), Line2(tex.xy, pos2t, pos2, 0.002)); \n        col = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos2, 0.005));\n    }\n#else\n    vec2 pos2 = pos;\n    for(uint i = 0u; i < 128u; ++i)\n    {\n        vec2 pos2t = pos2;\n    \n        vec2 grad = vec2(dot(pos2, pC.xz), \n                         dot(pos2, pC.zy)) + pB;\n\n      #if 1\n        //float n = dot(grad, pB) + dot(pos2.xyxy * grad.xyyx, pC.xyzz);\n        float n = dot(grad, grad);\n        float m = dot(grad.xyx * grad.xyy, pC * vec3(1.0, 1.0, 2.0));\n        \n        // optimal step width\n        float t = max(0.0, n / m);\n        \n        pos2 -= grad * t;       \n      #else\n        // constant step width\n        pos2 -= grad * 0.6;\n      #endif\n        \n        // draw search path segment and vertex (blue)\n        col = mix(col, vec3(0.0, 0.05, 1.0), Line2(tex.xy, pos2t, pos2, 0.002)); \n        col = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos2, 0.005));\n    }\n#endif    \n\n    // draw result (yellow)\n    col = mix(col, vec3(1.0, 1.0, 0.0), Dot(tex.xy, pos2, 0.004));\n\n    // draw lines (green)\n    col = mix(col, vec3(0.0, 1.0, 0.0), Plane(tex.xy, p0c, p0n, 1.0)); \n    col = mix(col, vec3(0.4, 1.0, 0.0), Plane(tex.xy, p1c, p1n, 1.0)); \n    col = mix(col, vec3(0.0, 1.0, 0.4), Plane(tex.xy, p2c, p2n, 1.0)); \n    \n    // draw start point\n    col = mix(col, vec3(0.0, 0.05, 1.0), Dot(tex.xy, pos, 0.01));\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n    tex *= 0.25+0.0375;\n    \n    vec2 pos = iMouse.xy;\n    pos -= iResolution.xy * 0.125;\n    pos /= iResolution.xx * 0.125;\n    pos *= 0.25+0.0375;\n    \n    bool useMousePos = iMouse.x > 16.0 && iMouse.y > 16.0;\n    \n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    col = vec3(1.0);\n    Eval(col, tex, pos, useMousePos);\n\n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define Frame float(iFrame)\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat SqrLen(vec2 v) { return dot(v, v); }\nfloat SqrLen(vec3 v) { return dot(v, v); }\n\nvec2 CosSin(float ang) { return vec2(cos(ang), sin(ang)); }\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\nfloat Graph(float f)\n{\n    return clamp01(1.0 - (abs(rescale(f)))); \n}\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Line(vec2 sp, vec2 lp, vec2 ld, float lt)\n{\n    float v = abs(dot(sp - lp, vec2(-ld.y, ld.x))) - lt;\n        \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;    \n}\n\nfloat Line(vec2 sp, vec2 lp, vec2 ld, float ll, float lt)\n{\n\tfloat l0 = Line(sp, lp, ld, lt);\n\tfloat l1 = Line(sp, lp, vec2(-ld.y, ld.x), ll);\n    \n    return l0 * l1;    \n}\n\nfloat Line2(vec2 sp, vec2 lp0, vec2 lp1, float lt)\n{    \n    vec2 vec0 = sp - lp0;\n    \n    vec2 vec = lp1 - lp0;\n    \n    vec2 lp = lp0 + vec * clamp(dot(sp - lp0, vec / SqrLen(vec)), 0.0, 1.0);\n    \n    float v = length(sp - lp) - lt;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;  \n}\n\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n\nfloat Circle(vec2 sp, vec2 cp, float cr, float ct)\n{\n    float v = length(sp - cp) - cr;\n\n    v = abs(v) - ct;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v, 0.0, 1.0);\n    \n    return v;\n}\n\nfloat Plane(vec2 sp, float pc, vec2 pn, float th)\n{\n    float v = dot(sp, pn) - pc;\n        \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(abs(v) - th, 0.0, 1.0);\n    \n    return v;    \n}\n\n\nfloat IsoLines(float v)\n{\n   return 1.0 - Graph(sin(v));\n}\n\n\nvec2 Minimize2dQEF_Reference(vec2 pos, vec2 pB, vec3 pC)\n{\n    float a = pC.x;\n    float b = pC.z;       \n    float c = pC.z;\n    float d = pC.y;\n\n    mat2x2 A;\n    A[0] = vec2(a, b);\n    A[1] = vec2(c, d);  \n\n    float T = a + d;\n    float D = a * d - b * c;\n\n    float rcpDet = 1.0 / D;\n\n    float L0 = sqrt(max(0.0, T*T*0.25 - D));\n    float L1 = T*0.5 + L0;\n    float L2 = T*0.5 - L0;\n\n    mat2x2 Q;      \n    Q[0] = vec2(L1 - d,    b  ); \n    Q[1] = vec2(   c  , L2 - a);\n\n    mat2x2 Qi;\n    {\n        float a = Q[0].x;\n        float b = Q[0].y;\n        float c = Q[1].x;\n        float d = Q[1].y;\n\n        float Det = a * d - b * c;\n\n        float rcpDet = abs(Det) < 0.0001 ? 1.0 : 1.0 / Det;\n\n        Qi[0] = rcpDet * vec2( d,-b);\n        Qi[1] = rcpDet * vec2(-c, a);      \n    }\n\n    float eps = 0.001;\n    float rcpMaxL = 1.0 / max(L1, L2);\n\n    float rcpL1 = L1 * rcpMaxL > eps ? 1.0 / L1 : 0.0;\n    float rcpL2 = L2 * rcpMaxL > eps ? 1.0 / L2 : 0.0;\n\n    mat2x2 Li;\n    Li[0] = vec2(rcpL1, 0.0);\n    Li[1] = vec2(0.0, rcpL2);\n\n    mat2x2 Ai = Q * Li * Qi;           \n\n    //return Ai * -pB;\n    return pos + Ai * (-pB - A * pos);\n}\n    ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}