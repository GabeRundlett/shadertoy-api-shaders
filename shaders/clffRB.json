{
    "Shader": {
        "info": {
            "date": "1693076833",
            "description": "prints numbers to the screen without using textures or large lookup tables. intended for debugging.",
            "flags": 0,
            "hasliked": 0,
            "id": "clffRB",
            "likes": 7,
            "name": "print numbers, code-only (cc0)",
            "published": 3,
            "tags": [
                "tutorial",
                "text",
                "presentation",
                "gui"
            ],
            "usePreview": 0,
            "username": "wareya",
            "viewed": 770
        },
        "renderpass": [
            {
                "code": "// GLSL code for rendering numbers without using any textures or global arrays, using a tiny bitmap font\n// for debugging!\n// public domain. use under the creative commons zero license (any version)\n// warning: the float-to-decimal conversion logic is \"incorrect\" and can only give around around four or five decimal places of floating point decision\n// warning: the integer part of the printed floats is limited to the size of a signed 32-bit integer\n\n\nconst int _print_number_max_float_digits = 5;\nconst int _print_number_scale = 2;\nconst int _print_number_stretch_x = 1;\nconst int _print_number_stretch_y = 1;\n\nfloat num_bit(int num, int x, int y)\n{\n    if (x < 0 || y < 0 || x >= 3 || y >= 5)\n        return 0.0;\n    \n    int bit = (1) << (x + 3*y);\n    \n    // godot users: change int[](...) to {...}\n    //int array[] = int[](0x01C0, 0x2000, 0x7B6F, 0x749A, 0x73E7, 0x79E7, 0x49ED, 0x79CF, 0x7BCF, 0x4927, 0x7BEF, 0x79EF);\n    // or: (has an offset '1' and '.' glyphs, so it's \"stretchable\")\n    int array[] = int[](0x01C0, 0x4000, 0x7B6F, 0x4924, 0x73E7, 0x79E7, 0x49ED, 0x79CF, 0x7BCF, 0x4927, 0x7BEF, 0x79EF);\n    \n    int mask = 0;\n    if (num >= -2 && num <= 9)\n        mask = array[num+2];\n    \n    if ((mask & bit) > 0)\n        return 1.0;\n    return 0.0;\n}\n\nivec2 char_size()\n{\n    return ivec2(4 + _print_number_stretch_x, 6 + _print_number_stretch_y*2) * _print_number_scale;\n}\n\nint number_width(float num)\n{\n    int int_digits = 1;\n    int num2 = int(num);\n    while(num2 >= 10)\n    {\n        int_digits += 1;\n        num2 /= 10;\n    }\n    \n    return (int_digits + _print_number_max_float_digits + 1)*(4 + _print_number_stretch_x);\n}\nvec4 get_number(ivec2 px, float num)\n{\n    if (px.y < 0 || px.x < 0)\n        return vec4(0.0);\n    \n    px /= _print_number_scale;\n    \n    int y_mid = 2+_print_number_stretch_y;\n    int y_end = 4+_print_number_stretch_y*2;\n    \n    if (px.y == 0)\n        px.y = 0;\n    else if (px.y > 0 && px.y < y_mid)\n        px.y = 1;\n    else if (px.y == y_mid)\n        px.y = 2;\n    else if (px.y > y_mid && px.y < y_end)\n        px.y = 3;\n    else if (px.y == y_end)\n        px.y = 4;\n    else\n        return vec4(0.0);\n    \n    int x_end = 2+_print_number_stretch_x;\n    \n    int _x = px.x % (4 + _print_number_stretch_x);\n    int which_digit = px.x / (4 + _print_number_stretch_x);\n    \n    if (_x == 0)\n        px.x = 0;\n    else if (_x > 0 && _x < x_end)\n        px.x = 1;\n    else if (_x == x_end)\n        px.x = 2;\n    else\n        return vec4(0.0);\n    \n    int int_digits = 1;\n    int num2 = abs(int(num));\n    while(num2 >= 10)\n    {\n        int_digits += 1;\n        num2 /= 10;\n    }\n    \n    if (which_digit - int_digits > _print_number_max_float_digits)\n        return vec4(0.0);\n    \n    int digit = -1;\n    \n    if (num < 0.0)\n    {\n        if (which_digit == 0)\n            digit = -2;\n        which_digit -= 1;\n    }\n    \n    if (which_digit >= 0 && which_digit < int_digits)\n    {\n        which_digit = int_digits - which_digit - 1;\n        digit = abs(int(num));\n        for(int i = 0; i < which_digit; i += 1)\n            digit /= 10;\n        digit = (digit % 10 + 10) % 10;\n    }\n    else if (which_digit > int_digits)\n    {\n        which_digit = which_digit - int_digits;\n        float factor = 1.0;\n        for(int i = 0; i < which_digit; i += 1)\n            factor *= 10.0;\n        \n        int num3 = int(mod(abs(fract(num)) * factor, 10.0));\n        \n        digit = int(num3) % 10;\n    }\n    \n    ivec2 digit_px = ivec2(((px.x % 4) + 4) % 4, (((px.y % 6) + 6) % 6));\n    \n    return vec4(num_bit(digit, digit_px.x, digit_px.y));\n}\n\nvec4 print_number(ivec2 px, float num, vec4 in_color, vec4 text_color)\n{\n    vec4 out_color = get_number(px, num) * text_color;\n    return mix(in_color, out_color, out_color.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0.0),1.0);\n    \n    ivec2 px = ivec2(fragCoord.x, iResolution.y - fragCoord.y);\n    \n    px.x -= 5;\n    px.y -= 5;\n    \n    fragColor = print_number(px, 3.14159, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n    \n    fragColor = print_number(px, 135798624.0, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n    \n    fragColor = print_number(px, iTime, fragColor, vec4(1.0));\n    px.y -= char_size().y;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}