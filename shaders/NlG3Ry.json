{
    "Shader": {
        "info": {
            "date": "1637849594",
            "description": "Axes moves randomly and smoothly.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlG3Ry",
            "likes": 12,
            "name": "Random Rotate Cube",
            "published": 3,
            "tags": [
                "rotation"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2021 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\n#if HW_PERFORMANCE!=0\n// If defined, activate anti-aliasing, level: 2 or 3\n#define AA 2\n#endif\n\n\nconst float AXIS_VELO = 1.0 / PI;\nconst float ROTATE_MEAN_VELO = PI / 2.0;\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Random unit vector\n// https://qiita.com/aa_debdeb/items/e416ae8a018692fc07eb\nvec3 randomAxis(vec2 gen) {\n    vec2 uv = hash22(gen);\n    float z = 2.0 * uv.x - 1.0;\n    float t = 2.0 * PI * uv.y;\n    return vec3(\n        sqrt(1.0 - z * z) * cos(t),\n        sqrt(1.0 - z * z) * sin(t),\n        z\n    );\n}\n\n// B-spline basis function\nvec3 bspbasis(float t) {\n    return vec3 (\n        (1.0 - t) * (1.0 - t) * 0.5,\n        ((t + 1.0) * (1.0 - t) + t * (2.0 - t)) * 0.5,\n        t * t * 0.5\n    );\n}\n\n// smooth moving unit vector\nvec3 movingAxis(float t, float gen) {\n    t *= AXIS_VELO;\n    vec3 axis0 = randomAxis(vec2(floor(t - 2.0), gen));\n    vec3 axis1 = randomAxis(vec2(floor(t - 1.0), gen));\n    vec3 axis2 = randomAxis(vec2(floor(t), gen));\n    t = fract(t);\n    vec3 b = bspbasis(t);\n    return normalize(axis0 * b.x + axis1 * b.y + axis2 * b.z);\n}\n\n// cellwise SDF\nfloat cellDist(in vec3 p, in vec3 q, in float t) {\n    vec3 fq = floor(q);\n    float gen = fq.x + fq.y * sqrt(2.0) + fq.z * sqrt(5.0);\n    float exists = hash11(gen + 1.8649);\n    if (exists < 0.8) return 0.5;\n    vec3 disp = 0.1 * hash33(fq);\n    p = fract(q) + p - q - 0.5 - disp;\n    vec3 axis = movingAxis(t, gen);\n    float theta = hash11(gen + 0.9286);\n    theta = 2.0 * ROTATE_MEAN_VELO * theta * t;\n    p = rot(axis, theta) * p;\n    return sdRoundBox(p, vec3(0.15), 0.025);\n}\n\n// SDF\nfloat sDist(in vec3 p, in vec3 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p + dist * dir) != floor(p)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 p, in vec3 dir, in float t) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(\n        cellDist(p+h.xyy, p, t) - cellDist(p-h.xyy, p, t),\n        cellDist(p+h.yxy, p, t) - cellDist(p-h.yxy, p, t),\n        cellDist(p+h.yyx, p, t) - cellDist(p-h.yyx, p, t)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 theta = vec2(0.15, 0.25) * iTime;\n    theta.y = sin(theta.y) * 0.7;\n    Camera camera = newCamera(\n        vec3(sin(iTime * 0.1) * 0.1, -iTime * 0.5, cos(iTime * 0.1) * 0.1),\n        vec3(cos(theta.x) * cos(theta.y), sin(theta.y), sin(theta.x) * cos(theta.y)),\n        //vec3(0),\n        //vec3(0, 0, 1),\n        vec3(0, 1, 0),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    vec3 p = ray.origin;\n    for (int _i = 0; _i < 100; _i++) {\n        float dist = sDist(p, ray.direction, iTime);\n        float rDist2 = dot(p - ray.origin, p - ray.origin);\n        if (dist < 0.00001 || rDist2 > 144.0) break;\n        p += dist * ray.direction;\n    }\n\n    vec3 col = vec3(0.9, 0.8, 0.9);\n    float dist = length(p - ray.origin);\n    if (dist < FAR) {\n        vec3 normal = calcNormal(p, ray.direction, iTime);\n        float c = -dot(ray.direction, normal);\n        c = clamp(c, 0.0, 1.0);\n        float k = smoothstep(0.0, 1.0, dist / FAR);\n        k *= k;\n        vec3 mat = hash33(floor(p) + 1.23);\n        col = (1.0 - k) * c * mat + k * col;\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.2) {\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.141592653;\n\nstruct Camera {\n    vec3 position;\n    vec3 direction;\n    vec3 up_direction; // not require dot(direction, up_direction) == 0\n    float fov;\n    float aspect; // x / y\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nCamera newCamera(vec3 position, vec3 direction, vec3 up_direction, float fov, float aspect) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\n// perspective camera ray, uv = fragCoord / iResolution.xy\n// cf: https://qiita.com/aa_debdeb/items/301dfc54788f1219b554\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float radian = camera.fov;\n    float h = tan(radian * 0.5);\n    float w = h * camera.aspect;\n    vec3 right = normalize(cross(camera.direction, camera.up_direction));\n    vec3 up = normalize(cross(right, camera.direction));\n    vec3 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n\n// Rodrigues' rotation formula\nmat3 rot(vec3 axis, float angle) {\n    return mat3(\n        axis[0] * axis[0] * (1.0 - cos(angle)) + cos(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) + axis[2] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) - axis[1] * sin(angle),\n        axis[0] * axis[1] * (1.0 - cos(angle)) - axis[2] * sin(angle),\n        axis[1] * axis[1] * (1.0 - cos(angle)) + cos(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) + axis[0] * sin(angle),\n        axis[0] * axis[2] * (1.0 - cos(angle)) + axis[1] * sin(angle),\n        axis[1] * axis[2] * (1.0 - cos(angle)) - axis[0] * sin(angle),\n        axis[2] * axis[2] * (1.0 - cos(angle)) + cos(angle)\n    );\n}\n\n/* ------------------------------------------------------ */\n// Hash without Sine https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}