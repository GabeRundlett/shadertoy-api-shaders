{
    "Shader": {
        "info": {
            "date": "1550593204",
            "description": "Traveling into a vortex of metal",
            "flags": 0,
            "hasliked": 0,
            "id": "wssXzr",
            "likes": 16,
            "name": "Metal Vortex",
            "published": 3,
            "tags": [
                "raymarching",
                "backwardscap",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "BackwardsCap",
            "viewed": 27480
        },
        "renderpass": [
            {
                "code": "#define SURF_DIST 0.001\n#define MAX_STEPS 256\n#define MAX_STEPS_REF 32\n#define MAX_STEPS_SHAD 16\n#define AA 2\n\nint mat;\nvec3 ref = vec3(0.);\n\nvec2 rotate(vec2 a, float d){\n    float s  = sin(d);\n    float c = cos(d);\n    \n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c);\n}\n\nfloat noise(vec3 p){\n    \n    return fract(sin(dot(p,vec3(41932.238945,12398.5387294,18924.178293)))*123890.12893);\n    \n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    \n    vec3 d = abs(p)-b;\n    \n    return max(max(d.x,d.y),d.z);\n    \n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    \n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nvec3 opTwist(in vec3 p , float k)\n{\n   \n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    \n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexScrew( vec3 p, vec2 h , float t)\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(opTwist(p,t));\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    \n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cog(vec3 p, vec3 tp ){\n    \n    float d = 1e10;\n    \n     vec3 bp = p+vec3(0,0,0);\n    bp.xy=rotate(bp.xy,sin(-iTime-tp.z*.05-p.x*.01)*10.);\n    \n    \n    float base = sdHexPrism(bp,vec2(2.,.2));\n    \n    d=min(d,base);\n    \n\n    bp.zy=rotate(bp.zy,1.5);\n    float base2 = sdHexScrew(bp,vec2(.95,1),2.0);\n    \n    d=max(d,-base2);\n\n    return d;\n\n}\n\n\nfloat map(vec3 p){\n    vec3 tp =p;\n    p.xy = rotate(p.xy,p.z*.02);\n    vec3 cell = vec3(5,40.5,21.5);\n    p=mod(p,cell)-cell*.5;    \n    \n    vec3 cp = p;\n    \n    \n    float s = sin(iTime+tp.z*.05)*10.;\n    \n    cp.z+=s;\n    \n    float d = 1e10;\n    \n\tfloat cog = cog(cp,tp);\n   \td=min(d,cog);\n\n    p.zy=rotate(p.zy,1.57);\n    float screw = sdHexScrew(p,vec2(.85,11.),2.0);\n    d=min(d,screw);\n    \n\n    \n    //assigning our material based on our distance value\n    if(d==cog){\n     \tmat=1;   \n    }\n\telse if(d==screw){\n        mat=3;\n    }\n    return d;\n}\n\n\nvec3 calcNormal(vec3 p){\n    \n    vec2 e =vec2(.01,0.);\n    \n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n    \n}\n\nvec4 trace(in vec3 ro, in vec3 rd){\n    float t = 0.;\n    vec3 col = vec3(0.9);\n    float k = 0.;\n    \n    for(int i=0;i<MAX_STEPS;++i){\n        k=map(ro+rd*t);\n        t+=k*.5;\n        if(abs(k)<SURF_DIST){\n           \n            \n            if(mat==1)\n                col = vec3(0.5);\n            else if(mat==3)\n                col=vec3(.8);\n                else if(mat==2){\n                    col=vec3(1.0);\n                }\n\t\t\t\n            //col*=light;\n                \n\t\t\tbreak;\n        }\n    }\n    \n    \n    return vec4(t,col);\n    \n}\n\nvec4 traceRef(in vec3 ro, in vec3 rd, float start, float end){\n    \n    float t=0.;\n    vec3 col = vec3(0.9);\n    float k = 0.;\n    \n    for(int i=0;i<MAX_STEPS_REF;++i){\n        \n        k = map(ro+rd*t);\n        t+=k*.25;\n        if(k<SURF_DIST){\n            float light = dot(calcNormal(ro+rd*t),normalize(vec3(.1*10.,3.,-5)))*2.;\n            \n            if(mat==1)\n                col = vec3(0.5);\n            else if(mat==3)\n                col=vec3(.9);\n\t\t\t\n            //col*=light;\n            break;\n        }\n        \n        \n        \n    }\n    return vec4(t,col);\n}\n\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 0.0;\n   float w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i * 0.2; // 1.0/AO_SAMPLES\n      r += w * (d0 - map(p + n * d0));\n      w *= 0.5;\n   }\n   return 1.0-clamp(r,0.0,1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n    \n    float shade = 1.0;\n    \n    float d = start;\n    \n    float stepDist = end/float(MAX_STEPS_SHAD);\n    \n    for(int i=0;i<MAX_STEPS_SHAD;i++){\n        //set the end to the distance from the light to surface point\n        //to avoid hitting a surface that shouldn't be lit\n        float h = map(ro+rd*d);\n        shade = min(shade, k*h/d);\n        \n        //alternatively could be +=h, +=min(h,0.1), +=stepDist...\n        d+=min(h,d/2.);\n        \n        if(h<SURF_DIST||d>end)break;\n    }\n    \n    \n    return min(max(shade,0.)+0.3,1.0);\n    \n}\n\nvec3 lighting(vec3 sp, vec3 camPos, int reflectionPass){\n    \n    vec3 col = vec3(0.);\n    \n    vec3 n = calcNormal(sp);\n    \n    vec3 objCol = vec3(0.5);\n    \n    //lighting stuff\n    //light pos\n    vec3 lp = vec3(sin(iTime)*50.,cos(iTime)*50.,0.+iTime*10.);//cos(iTime));\n    \n    //light direction and color\n    vec3 ld = lp - sp;\n    //subtly change color\n    vec3 lcolor = vec3(1.*sin(iTime*.2),1.*cos(iTime*.2),1.)/3.+vec3(1.);\n    \n    //falloff of our light\n    float len = length(ld);\n    \n    ld/=len; //normalize light-to-surface vector\n    float lightAtten= clamp((0.5*len*len),0.,1.);//clamp between 0 and 1\n    \n    //reflect our light at the position using the normal at sp\n    ref = reflect(-ld,n);\n    \n    //only do shadows when we aren't doing reflections\n    float shadowcol = 1.0;\n    if(reflectionPass==0)shadowcol = softShadow(sp,ld,0.005*2.0,len,32.0);\n    \n    float ao = .5+.5*calculateAO(sp,n);\n    float ambient = .05;\n    float specPow = 8.0;\n    float diff = max(0.0,dot(n,ld));//diffuse value\n    float spec = max(0.0,dot(ref,normalize(camPos-sp)));\n    spec = pow(spec,specPow);//ramp up sepcular value for some shinyness\n    \n    col += (objCol*(diff+ambient)+spec*0.5)*lcolor*lightAtten*shadowcol*ao;\n    \n    return col;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float depth = 0.;\n    vec3 tot = vec3(0.0);\n    for(int ii=0;ii<AA;ii++){\n        for(int jj=0;jj<AA;jj++){\n            \n            vec2 offset = vec2(float(ii),float(jj))/float(AA);\n\n            vec2 uv = ((fragCoord+offset)-.5*iResolution.xy)/iResolution.y;\n\n            float t =iTime*10.;\n\n\n            vec3 cam = vec3(0,0,-10.+t);\n            vec3 dir = normalize(vec3(uv,1));\n\n            //    dir.xy=rotate(dir.xy,-iTime/10.);\n\n            vec4 d =trace(cam,dir);\n\n            vec3 p =cam+dir*d.x;\n\n            vec3 n = calcNormal(p);\n\n\n\n            vec4 r=traceRef(p,reflect(dir,n),0.01*5.0,32.0);\n\n            vec3 l = lighting(p,cam,0);\n\n            depth=r.x;\n            \n            vec3 rsp = p+ref*r.x;\n            \n            \n\n            vec3 col = (lighting(rsp,p,1)*.05+l)/clamp((d.x*.015),1.,10.);//d.yzw\n            //vignette\n            col *= 1.-dot(uv,uv)*.75;\n\n\t\t\ttot+=col;\n        }\n    }\n    tot/=float(AA*AA);\n    fragColor.rgb = tot;\n    fragColor.a = depth;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}