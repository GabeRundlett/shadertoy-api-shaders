{
    "Shader": {
        "info": {
            "date": "1510057197",
            "description": "Folly (architectural) with spiral stairways (in a pond filled with Voronoi stones); mouse enabled.",
            "flags": 0,
            "hasliked": 0,
            "id": "ll2cDG",
            "likes": 27,
            "name": "White Folly",
            "published": 3,
            "tags": [
                "voronoi",
                "refraction",
                "symmetry",
                "architecture",
                "stairs"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1008
        },
        "renderpass": [
            {
                "code": "// \"White Folly\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\n\nvec3 sunDir, qHit;\nfloat dstFar, tCur, tWav;\nint idObj;\nbool inWat;\nconst int idStr = 1, idBal = 2, idPlat = 3, idBalc = 4, idPil = 5, idWl = 6, idFlr = 7;\n\nfloat ObjDfS (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, db, s, a;\n  q = p;\n  q.xz = abs (Rot2D (q.xz, pi)) - 6.5;\n  db = PrBox2Df (q.xz, vec2 (4.));\n  q.xz += 6.5;\n  q.xz = Rot2D (q.xz, 0.75 * pi);\n  q.x += 4.;\n  a = (length (q.xz) > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = vec2 (24. * a, length (q.xz) - 6.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  s = mod (q.x, sqrt (0.5));\n  d = max (0.3 * max (q.y - min (s, sqrt (0.5) - s), max (-0.1 - q.y, abs (q.z) - 1.5)),\n     abs (p.y) - 3.5);\n  d = max (d, db);\n  if (d < dMin) { dMin = d;  idObj = idStr; }\n  q.xy -= vec2 (1.5, 1.4);\n  q.z = abs (q.z) - 1.43;\n  d = PrBoxDf (q, vec3 (4.7, 0.07, 0.07));\n  q.x = 0.5 * mod (96. * a + 0.5, 1.) - 0.35;\n  q.y += 0.7;\n  d = min (d,  PrCylDf (q.xzy, 0.05, 0.7));\n  d = max (0.3 * d, db);\n  if (d < dMin) { dMin = d;  idObj = idBal; }\n  return dMin;\n}\n\n/*\n  This function is called twice, for the two orientations of the horizontal \n  walkway. Could be replaced by a single call, with orientation dependent on \n  position along ray path; this is faster (good) but there are visual artifacts for \n  certain view directions (bad). Artifacts can be removed by using cells in the \n  vertical direction (good), but this is slower (bad).\n*/\n\nfloat ObjDfB (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  d = max (PrBoxDf (q, vec3 (10.35, 0.26, 2.85)),\n    - max (length (vec2 (mod (q.x + 2., 4.) - 2., q.z)) - 1.5, 0.3 - abs (q.z)));\n  if (d < dMin) { dMin = d;  idObj = idPlat;  qHit = q; }\n  q = p;  q.y -= 2.05;  q.z = abs (q.z) - 2.45;\n  d = PrBoxDf (q, vec3 (7.45, 0.08, 0.07));\n  q.x = mod (q.x + 0.25, 0.5) - 0.25;\n  q.y += 0.95;\n  d = min (d, max (PrCylDf (q.xzy, 0.06, 0.9), abs (p.x) - 7.45));\n  q = p;  q.y -= 1.06;  q.x = abs (q.x) - 10.23;  q.y -= 0.95;\n  d = min (d, PrBoxDf (q, vec3 (0.07, 0.08, 2.5)));\n  q.y += 0.95;  q.z = mod (q.z + 0.25, 0.5) - 0.25;\n  d = min (d, max (PrCylDf (q.xzy, 0.06, 0.9), abs (p.z) - 2.45));\n  if (d < dMin) { dMin = d;  idObj = idBalc; }\n  q = p;  q.xz = abs (q.xz) - vec2 (8.8, 2.4);  q.x = abs (q.x) - 1.45;  q.y -= 1.3;\n  d = PrCylDf (q.xzy, 0.2, 1.05);\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  p.y -= 3.;\n  if (! inWat) {\n    dMin = ObjDfS (p, dMin);\n    q = p;  q.y -= 3.25;\n    dMin = ObjDfB (q, dMin);\n    q = p;  q.y -= -3.25;  q.xz = vec2 (- q.z, q.x);\n    dMin = ObjDfB (q, dMin);\n    q = p;  q.y -= 9.;\n    d = max (PrBoxDf (q, vec3 (2.5, 0.15, 2.5)),\n       - max (length (q.xz) - 1., max (0.1 - abs (q.x), 0.1 - abs (q.z))));\n    if (d < dMin) { dMin = d;  idObj = idPlat;  qHit = q; }\n  }\n  q = p;  q.xz = abs (q.xz) - 1.8;  q.y -= 1.;\n  d = PrCylDf (q.xzy, 0.2, 8.);\n  if (d < dMin) { dMin = d;  idObj = idPil;  qHit = q; }\n  q = p;  q.y -= -5.2;\n  d = PrCylAnDf (q.xzy, 20., 0.3, 2.3);\n  if (d < dMin) { dMin = d;  idObj = idWl; }\n  q = p;  q.y -= -7.4;\n  d = PrCylDf (q.xzy, 20., 0.01);\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d, eps;\n  eps = 0.001;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  if (rd.y >= 0.) col = mix (vec3 (0.1, 0.2, 0.4), vec3 (1.), 0.1 + 0.8 * rd.y);\n  else {\n    ro -= ((ro.y + 0.5) / rd.y) * rd;\n    col = mix (0.7 * mix (vec3 (0.3, 0.4, 0.1), vec3 (0.4, 0.5, 0.2), Fbm2 (ro.xz)) *\n         (1. - 0.15 * Noisefv2 (330. * ro.xz)), vec3 (0.18, 0.28, 0.48), pow (1. + rd.y, 5.));\n  }\n  return col;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 t;\n  float wFreq, wAmp, ht;\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t = tWav * vec2 (1., -1.);\n    t4 = (p.xyxy + t.xxyy) * wFreq;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    ht += wAmp * dot (pow (1. - sqrt (v4.xz * v4.yw), vec2 (8.)), vec2 (1.));\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec3 vn;\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  vn.xz = 3. * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx)));\n  vn.y = e.x;\n  return normalize (vn);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, vnw, row, rdw, col;\n  float dstObj, dstWat, s, a, sh;\n  bool isRefl;\n  HexVorInit ();\n  inWat = false;\n  isRefl = false;\n  tWav = 0.3 * tCur;\n  dstObj = ObjRay (ro, rd);\n  dstWat = - (ro.y + 0.6) / rd.y;\n  if (dstWat < min (dstObj, dstFar) && length ((ro + dstWat * rd).xz) < 20.) {\n    ro += dstWat * rd;\n    row = ro;\n    rdw = rd;\n    vnw = WaveNf (1.5 * ro, dstWat);;\n    rd = refract (rd, vnw, 1./1.333);\n    ro += 0.01 * rd;\n    inWat = true;\n    dstObj = ObjRay (ro, rd);\n    inWat = false;\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    if (ro.y < -0.5 && length (ro.xz) > 20.3) col = BgCol (ro, rd);\n    else {\n      vn = ObjNf (ro);\n      if (idObj == idStr) {\n        col = vec3 (0.95, 0.95, 1.);\n      } else if (idObj == idBal || idObj == idBalc) {\n        col = vec3 (0.8, 0.8, 1.);\n      } else if (idObj == idPlat) {\n        col = vec3 (1.);\n        if (vn.y > 0.99) {\n          if (ro.y > 7.5) s = mod (3. * length (qHit.xz), 1.);\n          else s = mod (3. * qHit.x, 1.);\n          col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, s);\n        } else if (abs (vn.y) < 0.01) {\n          s = mod (8. * ro.y, 1.);\n          col *= 0.8 + 0.2 * SmoothBump (0.1, 0.9, 0.03, s);\n        }\n        vn = VaryNf (100. * ro, vn, 0.2); \n      } else if (idObj == idPil) {\n        if (abs (vn.y) < 0.01) {\n          a = (length (qHit.xz) > 0.) ? atan (qHit.z, - qHit.x) / pi : 0.;\n          s = mod (3. * qHit.y + a, 1.);\n          vn.y = 0.2 * (1. - SmoothBump (0.2, 0.8, 0.1, s)) * sign (s - 0.5);\n          vn.xz *= sqrt (1. - vn.y * vn.y);\n        }\n        col = vec3 (0.9, 0.9, 0.3);\n      } else if (idObj == idWl) {\n        a = (length (ro.xz) > 0.) ? atan (ro.z, - ro.x) / pi : 0.;\n        col = vec3 (0.6, 0.4, 0.3) * (0.5 +\n           0.5 * SmoothBump (0.05, 0.95, 0.02, mod (64. * a, 1.))) *\n           (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (ro.y + 0.5, 1.)));\n        vn = VaryNf (20. * ro, vn, 1.);   \n      } else if (idObj == idFlr) {\n        vc = HexVor (ro.xz);\n        vn.xz = - 0.7 * vc.yz;\n        vn = normalize (vn);\n        s = mod (10. * vc.w, 1.);\n        col = HsvToRgb (vec3 (0.1 + 0.3 * step (2. * s, 1.) + 0.1 * mod (5. * s, 1.),\n           0.5 + 0.5 * mod (17. * s, 1.), 0.7 + 0.3 * mod (12. * s, 1.))) *\n           (0.6 + 0.4 * smoothstep (0., 0.2, vc.x)) * (1. - 0.2 * Noisefv2 (128. * ro.xz));\n      }\n      sh = 0.4 + 0.6 * ObjSShadow (ro, sunDir);\n      col = col * (0.2 + sh * max (dot (sunDir, vn), 0.) +\n         0.1 * max (dot (- sunDir.xz, vn.xz), 0.)) +\n         0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    }\n  } else {\n    if (isRefl) sh = ObjSShadow (row, sunDir);\n    col = BgCol (ro, rd);\n  }\n  if (isRefl) {\n    col = mix (0.9 * col, vec3 (1., 1., 0.9), sh *\n       pow (max (0., dot (sunDir, reflect (rdw, vnw))), 64.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  dstFar = 120.;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += 1. * pi * mPtr.y;\n  } else {\n    az -= 0.1 * tCur;\n    el -= 0.1 * pi * cos (0.03 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 7. - 2. * cos (az);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 1., -70.);\n  sunDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nvec2 gVec[7], hVec[7];\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);  \n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;  \n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}