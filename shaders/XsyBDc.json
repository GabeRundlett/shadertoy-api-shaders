{
    "Shader": {
        "info": {
            "date": "1530725751",
            "description": "WIP\n\nBlends between the solutions of the vanilla Apollonius problem using a contact angle \"theta\" as parameter, i.e. the angle at which the solution circle intersects the original circles. \n\nThe smallest circle can be placed by clicking. ",
            "flags": 0,
            "hasliked": 0,
            "id": "XsyBDc",
            "likes": 10,
            "name": "Problem of Apollonius, extended",
            "published": 3,
            "tags": [
                "circles",
                "math",
                "intersection",
                "geometry",
                "tangent",
                "split",
                "apollonius",
                "generalization"
            ],
            "usePreview": 0,
            "username": "mv",
            "viewed": 823
        },
        "renderpass": [
            {
                "code": "/*\n\tGeneralization of: https://www.shadertoy.com/view/XsKBWV\n\n\n\tThe Problem of Apollonius is a famous geometry problem from antiquity, \n    named after Apollonius of Perga. It can be stated as \n\n\t\t\"Given three circles, find a fourth circle that is simultaneously \n\t\t tangent to the other circles.\" \n\n\tThe problem is equivalent to finding the the simultaneous solution of \n    three quadratic equations:\n\n\t\t(x - x_1)² + (y - y_1)² = (r - s_1*r_1)²\n\t\t(x - x_2)² + (y - y_2)² = (r - s_2*r_2)²\n\t\t(x - x_3)² + (y - y_3)² = (r - s_3*r_3)²\n\n\tfor some combination of signs s_1, s_2 and s_3. \n\n\t---\n\n\tThis is a generalization that is able to blend between the solutions \n\tto the original problem formulation. Instead of the solution circles \n\tbeing tangent to the original circles, they intersect all the circles\n\tat some angle \"theta\" between 0 and 180 degrees.\n\n\tTurns out that this problem can be solved by replacing the original\n\t3 circles with up to 6 (pairs of which are contained within the \n\toriginal circles) \"equivalent circles\" (explanation pending) for which \n\twe can pick any 3 and solve the original Apollonius problem. \n\n\tWhen theta = 0 the blue and orange circles overlap. \n\tWhen theta = 180 the blue and purple circles overlap.\n\tWhen theta = 80 the orange and purple circles overlap.\n\t\n\t---\n\t\n\tColor legend:\n\n\t\tRed and blue: original Apollonius solutions using original circles\n\t\tGreen: \"equivalent circles\"\n\t\tPurple and orange: Apollonius solutions using equivalent circles.\n\n\t---\n\t\n\tDeactivate the EXTRAS macro to remove the lines and points.\n\tDeactivate the ANIMATE macro to pick a constant theta (or pause). \n\tChange the position of the first (smallest) circle by left clicking.\n\n\t--- \n\n\tSome observations:\n\n\t\t- The equivalent circles collapses onto the original circles for\n\t\t  theta = 0 degrees and theta = 180 degrees.\n\n\t\t- The equivalent circles collapses to a single point for \n\t\t  theta = 90 degrees. \n\n\t\t- There is a symmetry with respect to the change of variables \n\t\t  theta -> 180 - theta\n\n\t\t- The centers of the solutions (orange and purple dots) move \n\t\t  monotonically in a straight line between the centers of the \n\t\t  original centers (blue and red dots)\n\n\t---\n\n\tSome caveats: \n\n\t\t1. The solutions fails when any of the black circles overlap,\n\t\t   resulting in a solid color for the entire window (most likely).\n\n\t\t2. It gets a bit unstable near theta = 0 or 180 degrees due to \n\t\t   floating point precision. \n\n*/\n\n#define SWAP(T, x, y) do { T tmp; tmp = x; x = y; y = tmp; } while(false)\n\n#define BLACK vec3(0.0)\n#define WHITE vec3(1.0)\n#define GRAY vec3(0.9)\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 0.7, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define PURPLE vec3(1.0, 0.0, 1.0)\n#define ORANGE vec3(1.0, 0.6, 0.0)\n\n//#define EXTRAS\n#define ANIMATE\n#define PI 3.14159265359\n\n// declarations\nfloat perpdot(vec2 u, vec2 v);\n\nfloat sdDisk(vec2 p, float r);\nfloat sdCircle(vec2 p, float r, float t);\nfloat sdLine(vec2 p0, vec2 p1, vec2 p2);\n\nvec3 compose(vec3 old, vec3 col, float d);\nfloat animate(float x);\n\nstruct ApolloniusSolution {\n \tvec2 p1, p2;\n    float r1, r2;\n};\n    \nstruct EquivalentCircles {\n\tvec2 p1, p2;\n    float r1, r2;\n};\n\nApolloniusSolution solveApollonius(vec2 P1,  vec2 P2,  vec2 P3, \n                                   float s1, float s2, float s3, \n                                   float R1, float R2, float R3);\n\nEquivalentCircles findEquivalentCircles(vec2 P1, vec2 P2,\n                                        float R1, float R2,\n                                        float theta);\n\n\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    /// constants\n    vec2 C1 = vec2(-0.45, -0.55);\n    vec2 C2 = vec2( 0.5, -0.55);\n    vec2 C3 = vec2( 0.0,  0.55);\n    \n    if (iMouse.zw != vec2(0.0, 0.0)){\n     \tC1 = 1.2*(2.0 * iMouse.xy - iResolution.xy)/iResolution.yy;   \n    }\n    \n    float R1 = 0.3;\n    float R2 = 0.4;\n    float R3 = 0.5;\n\n    // animate contact angle\n#ifdef ANIMATE\n    float theta = PI*(0.01 + 0.98*animate(0.25*iTime));\n#else\n    float theta = PI*60.0/180.0;\n#endif\n    \n    /// position normalized, scaled and aspect ratio corrected\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/iResolution.yy;\n    uv *= 1.2;\n    \n    /// Calculations\n    // base apollonius circles\n    ApolloniusSolution sol0 = solveApollonius(C1, C2, C3, \n                                              1.0, 1.0, 1.0, \n                                              R1, R2, R3);\n    \n    // \"equivalent circles\" for each circle-circle pair\n    EquivalentCircles c12 = findEquivalentCircles(C1, C2, R1, R2, theta);\n    EquivalentCircles c13 = findEquivalentCircles(C1, C3, R1, R3, theta);\n    EquivalentCircles c23 = findEquivalentCircles(C2, C3, R2, R3, theta);\n    \n    // apollonius circles using the equivalent circles\n    ApolloniusSolution sol = solveApollonius(c12.p1, c12.p2, c13.p1, 1.0, 1.0, 1.0, c12.r1, c12.r2, c13.r1);\n    if (theta > 3.1415/2.0) {\n        SWAP(vec2, sol.p1, sol.p2);\n        SWAP(float, sol.r1, sol.r2);\n    }\n    \n    /// coloring\n    // background color\n    vec3 col = WHITE;\n    \n#ifdef EXTRAS\n    // show extra info: \n    //\n    // \t   - lines connecting the centers of each black circle\n    //     - points for each circle center\n    //\n    \n    // symmetry lines for each circle-circle pair\n    col = compose(col, GRAY, abs(sdLine(uv, c12.p1, c12.p2)) - 0.01); \n    col = compose(col, GRAY, abs(sdLine(uv, c13.p1, c13.p2)) - 0.01); \n    col = compose(col, GRAY, abs(sdLine(uv, c23.p1, c23.p2)) - 0.01); \n\n\t// Center of all circles\n    col = compose(col, BLACK, sdDisk(uv - C1, 0.01));\n    col = compose(col, BLACK, sdDisk(uv - C2, 0.01));\n    col = compose(col, BLACK, sdDisk(uv - C3, 0.01));\n    \n    col = compose(col, RED,  sdDisk(uv - sol0.p1, 0.01)); \n    col = compose(col, BLUE, sdDisk(uv - sol0.p2, 0.01)); \n\t\n    col = compose(col, GREEN, sdDisk(uv - c12.p1, 0.01)); \n    col = compose(col, GREEN, sdDisk(uv - c12.p2, 0.01)); \n    col = compose(col, GREEN, sdDisk(uv - c13.p1, 0.01)); \n    col = compose(col, GREEN, sdDisk(uv - c13.p2, 0.01)); \n    col = compose(col, GREEN, sdDisk(uv - c23.p1, 0.01)); \n    col = compose(col, GREEN, sdDisk(uv - c23.p2, 0.01));\n    \n    col = compose(col, PURPLE, sdDisk(uv - sol.p1,  0.01)); \n    col = compose(col, ORANGE, sdDisk(uv - sol.p2,  0.01)); \n#endif    \n    \n    // base circles\n    col = compose(col, BLACK, sdCircle(uv - C1, R1, 0.01));\n    col = compose(col, BLACK, sdCircle(uv - C2, R2, 0.01));\n    col = compose(col, BLACK, sdCircle(uv - C3, R3, 0.01));\n\n    // base apollonius solution\n    // blue: externally tangent to all circles\n    // red:  internally tangent to all circles\n    col = compose(col, RED,  sdCircle(uv - sol0.p1, abs(sol0.r1), 0.01)); \n    col = compose(col, BLUE, sdCircle(uv - sol0.p2, abs(sol0.r2), 0.01)); \n\n    // \"equivalent circles\"\n    col = compose(col, GREEN, sdCircle(uv - c12.p1, abs(c12.r1), 0.005)); \n    col = compose(col, GREEN, sdCircle(uv - c12.p2, abs(c12.r2), 0.005)); \n    col = compose(col, GREEN, sdCircle(uv - c13.p1, abs(c13.r1), 0.005)); \n    col = compose(col, GREEN, sdCircle(uv - c13.p2, abs(c13.r2), 0.005)); \n    col = compose(col, GREEN, sdCircle(uv - c23.p1, abs(c23.r1), 0.005)); \n    col = compose(col, GREEN, sdCircle(uv - c23.p2, abs(c23.r2), 0.005)); \n    \n    // apollonius circles using equivalent circles\n    col = compose(col, PURPLE, sdCircle(uv - sol.p1, abs(sol.r1), 0.005)); \n    col = compose(col, ORANGE, sdCircle(uv - sol.p2, abs(sol.r2), 0.005));     \n\n    fragColor = vec4(col,1.0);\n}\n\n\n//\nfloat sdDisk(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(vec2 p, float r, float t) {\n    return abs(length(p) - r) - t;\n}\n\nfloat sdLine(vec2 p0, vec2 p1, vec2 p2) {\n    return (perpdot(p1-p2, p0) + perpdot(p2, p1))/length(p2-p1);\n}\n\nvec3 compose(vec3 old, vec3 col, float d) {\n    float w = 1.5*fwidth(d);\n    float s = smoothstep(-w/2.0, w/2.0, d);\n    return old*s + col*(1.0 - s);\n}\n\nfloat animate(float x) {\n    // slows down at 0.0, 0.5 and 1.0 in an oscillatory fashion\n    // for every integer value, \n    // see http://folk.ntnu.no/mortevas/Figure_1-3.png\n    \n\tx = mod(x, 4.0);\n    float y = 0.5 - 0.5*cos(PI*x);\n    \n    if (x > 1.0 && x < 3.0) {\n     \ty = 2.0 - y;   \n    }\n    \n    return 0.5*y;\n}\n\n\nfloat perpdot(vec2 u, vec2 v) {\n \treturn u.x*v.y - u.y*v.x;   \n}\n\nApolloniusSolution solveApollonius(in vec2 P1,  in vec2 P2,  in vec2 P3, \n                     in float s1, in float s2, in float s3, \n                     in float R1, in float R2, in float R3) {\n    // see https://www.sharelatex.com/read/mxqspwvsbhny\n    \n    // NOTE: optimized by shifting one of the points to the origin\n    P1 = P1 - P3;\n    P2 = P2 - P3;\n    \n    float A1 = (dot(P1, P1) - R1*R1 + R3*R3)/2.0;\n    float A2 = (dot(P2, P2) - R2*R2 + R3*R3)/2.0;\n    \n    float B1 = (s1*R1 - s3*R3);\n    float B2 = (s2*R2 - s3*R3);\n    \n    float D = perpdot(P1, P2);\n    \n    float M = (A1*P2.y - A2*P1.y)/D;\n    float N = (B1*P2.y - B2*P1.y)/D;\n    float P = (-A1*P2.x + A2*P1.x)/D;\n    float Q = (-B1*P2.x + B2*P1.x)/D;\n    \n    float a = N*N + Q*Q - 1.0;\n    float b = 2.0*(M*N + P*Q + s3*R3);\n    float c = M*M + P*P - R3*R3;\n    \n    // WARNING: Complex solutions?    \n    ApolloniusSolution sol;\n    sol.r1 = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n    sol.r2 = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n    \n    sol.p1 = P3 + vec2(M+N*sol.r1, P + Q*sol.r1);\n    sol.p2 = P3 + vec2(M+N*sol.r2, P + Q*sol.r2);\n    \n    return sol;\n}\n\nEquivalentCircles findEquivalentCircles(vec2 P1, vec2 P2,\n                                        float R1, float R2,\n                                        float theta) {\n    // magic\n    float d = length(P1 - P2);\n    \n    float A = R1*R1;\n    float B = 2.0*R1*cos(theta);\n    float C = (d*d + R1*R1 - R2*R2)/(2.0*d);\n    float D = (R1 - R2)*cos(theta)/d;\n    \n    float a = D*D - 1.0;\n    float b = 2.0*C*D - B;\n    float c = C*C - A;\n    \n    float R  = (-b + sqrt(b*b - 4.0*a*c))/(2.0*a);\n    float R_ = (-b - sqrt(b*b - 4.0*a*c))/(2.0*a);\n    \n    EquivalentCircles circles;\n    \n    circles.r1 = abs(-(C + D*R) + abs(R) + (C + D*R_) - abs(R_))/2.0;\n    circles.r2 = abs(-(C + D*R) - abs(R) + (C + D*R_) + abs(R_))/2.0;\n    \n    circles.p1 = P1 + (P2 - P1)/d * abs(-(C + D*R) + abs(R) - (C + D*R_) + abs(R_))/2.0;\n    circles.p2 = P1 + (P2 - P1)/d * abs(-(C + D*R) - abs(R) - (C + D*R_) - abs(R_))/2.0;\n       \n    return circles;\n     \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}