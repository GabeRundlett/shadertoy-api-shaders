{
    "Shader": {
        "info": {
            "date": "1720144476",
            "description": "Background color should change every year.\nMonths on the left.\nDays on the right.\nClock is a clock.",
            "flags": 0,
            "hasliked": 0,
            "id": "XXGXzK",
            "likes": 2,
            "name": "iDate (API Test)",
            "published": 3,
            "tags": [
                "apitesting"
            ],
            "usePreview": 0,
            "username": "brisingre",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "float yearSpeed = 1.41421356237;\nfloat borderWidth = 4.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float year = iDate.x;\n    float month = iDate.y;\n    float day = iDate.z;\n    float time = iDate.w;\n    \n    float yearPoint = year * yearSpeed;\n    vec3 yearColor = palette(yearPoint, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.10, 0.20));\n\n    \n    \n    float tint = 0.0;\n    \n    \n    float monthSquareHeight = (iResolution.y - (borderWidth * 13.0)) / 12.0;\n    float monthTotalSize = monthSquareHeight + borderWidth;\n    \n    if(fragCoord.x < monthTotalSize + borderWidth)\n    {\n        vec2 monthCoord = mod(fragCoord, monthTotalSize);\n        float monthY = fragCoord.y / monthTotalSize;\n        if(monthCoord.x < borderWidth || monthCoord.y < borderWidth)\n        {\n            tint = 0.5;\n        }\n        else\n        {\n            if(month + 1.0 >= monthY)\n                tint = floor(monthY + 1.0) / 13.0;\n            else\n                tint = 0.0;\n        }\n    }\n    \n    \n    float daySquareHeight = (iResolution.y - (borderWidth * 6.0)) / 5.0;\n    float dayTotalSize = daySquareHeight + borderWidth;\n    float rightX = iResolution.x - fragCoord.x;\n    \n    if(rightX < 7.0 * dayTotalSize + borderWidth)\n    {\n        \n        vec2 dayCoord = mod(vec2(rightX, fragCoord.y), dayTotalSize);\n        \n        float row = fragCoord.y / dayTotalSize;\n        float col = rightX/dayTotalSize;\n        \n        float monthRows = floor(day/7.0);\n        float monthCol = 7.0 - mod(day, 7.0);\n        if(dayCoord.x < borderWidth || dayCoord.y < borderWidth)\n        {\n            tint = 0.5;\n        }\n        else\n        {\n            if(monthRows > row)\n                tint = floor(row + 1.0)/7.0;\n            else\n                if(monthRows == floor(row) && monthCol < col)\n                    tint = floor(row + 1.0)/7.0;\n                 \n        }\n    }\n    \n    float timeRemaining = time;\n    float hours = floor(timeRemaining / 3600.0);\n    timeRemaining -= hours * 3600.0;\n    \n    float mins = floor(timeRemaining / 60.0);\n    timeRemaining -= mins * 60.0;\n    float secs = timeRemaining;\n    \n    \n    \n    float clockTint = 0.0;\n    \n    vec2 center = iResolution.xy/2.0;\n    float clockFaceRadius = min(iResolution.x, iResolution.y)/2.0 - 100.0;\n    float clockDist = distance(fragCoord, center);\n    float clockBackground = step(clockDist, clockFaceRadius);\n    float clockBackground2 = step(clockDist, clockFaceRadius - borderWidth);\n    \n    \n    \n    clockTint += (clockBackground - clockBackground2) * 0.2;\n    \n    \n    float hoursAngle = (hours/12.0) * PI * 2.0;\n    vec2 hoursPoint = center + vec2(sin(hoursAngle), cos(hoursAngle)) * (clockFaceRadius - 100.0);\n    float hoursSD = sdSegment(fragCoord, center, hoursPoint);\n    float hoursHand = step(hoursSD, borderWidth * 4.0) * 0.6;\n    \n    clockTint += hoursHand;\n    \n    \n    float minutesAngle = (mins/60.0) * PI * 2.0;\n    vec2 minutesPoint = center + vec2(sin(minutesAngle), cos(minutesAngle)) * (clockFaceRadius - 50.0);\n    float minutesSD = sdSegment(fragCoord, center, minutesPoint);\n    float minutesHand = step(minutesSD, borderWidth * 2.0) * 0.6;\n    \n    clockTint += minutesHand;\n    \n    \n    \n    float secondsAngle = (secs/60.0) * PI * 2.0;\n    vec2 secondsPoint = center + vec2(sin(secondsAngle), cos(secondsAngle)) * (clockFaceRadius - 15.0);\n    float secondsSD = sdSegment(fragCoord, center, secondsPoint);\n    float secondsHand = step(secondsSD, borderWidth * 1.0) * 0.6;\n    \n    clockTint += secondsHand;\n    \n    \n    tint += clockTint;\n    \n    \n\n    // Output to screen\n    fragColor = vec4(mix(yearColor, vec3(1.0, 1.0, 1.0), tint),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n//https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat PI = 3.14159265;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}