{
    "Shader": {
        "info": {
            "date": "1720459810",
            "description": "copypast  https://glslsandbox.com/e#90779.0  https://www.shadertoy.com/view/43KSWy https://www.shadertoy.com/view/DlycWR",
            "flags": 0,
            "hasliked": 0,
            "id": "MXVSDG",
            "likes": 2,
            "name": "fractal # 213",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 83
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(10,23,21))*12.5+.5)\n\nprecision highp float;\n\n#define time iTime\n\nuniform vec2 mouse;\n\n\nint fISequencer(void){\n\n\nfloat nTime =.1*time;\nvec4 VMouse =vec4((mouse -0.5) *2.0, 0, 0);\n\tint iCycle =100, iTimePerSQ =5;\n\tint iSQ =int(floor(mod(nTime, float(iCycle)) /float(iTimePerSQ)));\n\treturn iSQ;\n}\n\nfloat fNGoverner(void){\n\nfloat nTime =.1*time;\nvec4 VMouse =vec4((mouse -0.5) *2.0, 0, 0);\n\tint iCycle =120;\n\tfloat nGV =mod(nTime, float(iCycle)) /float(iCycle);\n\treturn nGV;\n}\n\nint iCounter;\nint fICounter(void){\n\treturn iCounter++;\n}\n\nvec4 fVLissajous(float nLJ){\n\tvec4 VCycle =vec4(19,17,13,11);\n\tVCycle *=VCycle.x +VCycle.y +VCycle.z +VCycle.w;\n\tVCycle *=acos(-1.0) *2.0;\n\tvec4 VLS =sin(VCycle *nLJ);\n\treturn VLS;\n}\n\nfloat fNRandom(float nIN){\n\tvec4 VSeed =fract(sqrt(vec4(2,3,5,7)));\n\tfloat nRandom =fract(sin(VSeed.x *nIN +VSeed.y));\n\treturn nRandom;\n}\n\nfloat fNRandom(vec2 V2IN){\n\tvec4 VSeed =fract(sqrt(vec4(2,3,5,7)));\n\tfloat nRandom =fract(sin(dot(VSeed.xy, V2IN) +VSeed.z));\n\treturn nRandom;\n}\n\nfloat fNRandom(vec3 V3IN){\n\tvec4 VSeed =fract(sqrt(vec4(2,3,5,7)));\n\tfloat nRandom =fract(sin(dot(VSeed.xyz, V3IN) +VSeed.w));\n\treturn nRandom;\n}\n\nfloat fNRandom(vec4 VIN){\n\tvec4 VSeed =fract(sqrt(vec4(2,3,5,7)));\n\tfloat nRandom =fract(sin(dot(VSeed, VIN)));\n\treturn nRandom;\n}\n\nfloat fNFractal(vec2 V2N, vec2 V2C){\n\tint iT;\n\tfor(int I =0; I <100; I++){\n\t\tif(V2N.x >10.0)\tbreak;\n\t\tV2N =vec2(V2N.x *V2N.x -V2N.y *V2N.y +V2C.x, 2.0 *V2N.x *V2N.y +V2C.y);\n\t\tiT++;\n\t}\n\treturn float(iT);\n}\n\nvec4 fVColor(vec4 VP){\n\tvec4 VC =vec4(1);\n\n\n\n\t{\n\t\tfloat nC;\n\t\tint iSQ =fISequencer();\n\n          // \tuncomment to mix them\t\n\t\t\n\t//\tnC +=sin(VP.x) *sin(VP.y) *sin(VP.w);\n\t\t\n\t\t\n\t\t\n\t\n\t\t\n\t\t\n\t\tnC +=atan(VP.x, VP.y) +length(VP.xy) -VP.w;\n\t\tnC +=atan(VP.x, VP.y) +length(VP.xy) *sin(VP.w);\n\t//\tnC +=(VP.x +sin(VP.y *2.0 +VP.w)) *(VP.y +sin(VP.x *2.0 +VP.w));\n\t//\tnC +=atan(VP.x +0.5, VP.y) *atan(VP.x -0.5, VP.y) +VP.w;\n\t\tnC +=log(abs(VP.x)) +log(abs(VP.y)) +VP.w;\n\t//\tnC +=tan(VP.x) +tan(VP.y) +VP.w;\n\t//\tnC +=sin(atan(VP.x, VP.y) *3.0 +VP.w) +length(VP.xy) -VP.w;\n\t//\tnC +=length(VP.xy -fVLissajous(VP.w *1e-4).xy);\n\t\tnC +=fNRandom(floor(VP.xy *16.0)) +VP.w;\n\t\tnC +=fNFractal(VP.xy, sin(vec2(2,3) *VP.w));\n\t\tnC +=fNFractal(sin(vec2(2,3) *VP.w), VP.xy);\t\n\t\t\n\n\t\tnC =sin(nC *16.0);\n\t\tVC.rgb =vec3(1) *step(nC, 0.0);\n\t}\n\treturn VC;\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.315, 0.426, 0.537);\n\n    return a + b*sin( 6.28318*(c*t+d) );\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec2 uv = C/iResolution.xy-0.5;\n uv*=5.5;\n   uv=abs(uv);\n    uv=(uv.x<uv.y)?uv.xy:uv.yx;\n    float t=iTime;\n    uv*=mat2(cos(t),sin(t),-sin(t),cos(t));\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).xyz;\n \n\tvec4 VColor =vec4(1), VP =vec4(uv, iTime, time);\nvec2 fragCoord = C;\n\n    vec2 uv0 = uv;\n\n    // 判断当前像素所在的象限\n    bool topLeft = (fragCoord.x < iResolution.x / 2.0) && (fragCoord.y >= iResolution.y / 2.0);\n    bool topRight = (fragCoord.x >= iResolution.x / 2.0) && (fragCoord.y >= iResolution.y / 2.0);\n    bool bottomLeft = (fragCoord.x < iResolution.x / 2.0) && (fragCoord.y < iResolution.y / 2.0);\n    bool bottomRight = (fragCoord.x >= iResolution.x / 2.0) && (fragCoord.y < iResolution.y / 2.0);\n\n    // 旋转角度和方向\n    float angle = iTime * 0.5;\n    if (topRight || bottomLeft) {\n        angle = -angle;\n    }\n\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n\n    // 旋转矩阵应用到UV坐标\n    uv = vec2(\n        uv0.x * cosA - uv0.y * sinA,\n        uv0.x * sinA + uv0.y * cosA\n    );\n\n    vec3 finalColor = vec3(0.0);\n\n    for (float i = 0.0; i < 8.0; i++) {\n        uv = fract(uv * 1.5) - 0.5;\n\n        float d = length(uv) * exp(-length(uv0));\n\n        vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);\n\n        d = cos(d * 8.0 + iTime) / 8.0;\n        d = abs(d);\n\n        d = pow(0.001 / d, 1.0);\n\n        finalColor += col * d;\n    }\n\tVColor =fVColor(VP);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        \n        float per=fNFractal(VColor.xy, (vec2(2,3) *VColor.w)); ;\n        per +=fNRandom(floor(VColor.xy *16.0)) +VColor.w;\n      per+=log(abs(VP.x)) +log(abs(VColor.y)) +VColor.w;\n        a=50.;\n        p=mod(p-a,a*2.)-a;\n        p.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        p.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        p.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n        s=3.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n         \n            p.x<p.z?p=p.zyx*VColor.xyw:p;\n            p.z<p.y?p=p.xzy*VColor.xyw:p;\n             p.z<p.y?p=p.xzy*finalColor:p;\n            s*=e=1.4+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+1.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*per;\n         }\n         g+=e=length(p.yz)/s;\n          \n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}