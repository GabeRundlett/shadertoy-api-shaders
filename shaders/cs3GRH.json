{
    "Shader": {
        "info": {
            "date": "1677175542",
            "description": "White Rabbit",
            "flags": 96,
            "hasliked": 0,
            "id": "cs3GRH",
            "likes": 7,
            "name": "White Rabbit",
            "published": 3,
            "tags": [
                "raymarch",
                "voxels",
                "sdf",
                "white",
                "trace",
                "unpack",
                "hierarchy",
                "jfa",
                "rabbit",
                "spheremarch",
                "bitstream"
            ],
            "usePreview": 1,
            "username": "toomuchvoltage",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "/***********************************************************\n\n   This is a follow up to https://www.shadertoy.com/view/dlBGRc\n   This time around, I'm decoding and jump flooding the voxels into a channel and sphere marching via reading from the channel.\n   Created using Shadertoy-utils by yours truly :) : https://github.com/toomuchvoltage/shadertoy-utils\n   SDFs and the simplex noise are belong to iq: https://www.shadertoy.com/view/Msf3WH\n                                            https://iquilezles.org/articles/distfunctions/\n   Additionally you should read iq's rather old write up on SDF hierarchies as it boxes the bunny:\n   https://iquilezles.org/articles/sdfbounding/\n   The white noise for the plains is from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n   The song is Jefferson Airplane - White Rabbit, a staple of 70's counter-culture\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z) * 2.0 - 1.0;\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fBm (in vec2 uv)\n{\n    float f = 0.0;\n    uv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    return (f + 1.0) * 0.5;\n}\n\nfloat warp (vec2 uv, float time)\n{\n    return fBm (vec2 (fBm(uv) + time * 0.1, fBm(uv.yx) - time * 0.1));\n}\n\nvec3 lsd (vec2 uv, float time)\n{\n    uv -= vec2 (0.5);\n    uv = abs(uv);\n    uv = (mat2 (cos(time * 0.1), sin(time * 0.1), -sin(time * 0.1), cos(time * 0.1))) * uv;\n    return (0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4))) * warp (uv, time);\n}\n\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfGrid0(vec3 p)\n{\n    p = floor (p * 4.0) * 0.25;\n    if ( clamp (p, grid0Min, grid0Max - vec3 (0.25)) != p ) return 0.25;\n\n    float pzBlock = (p.z - grid0Min.z) * 4.0;\n    uint diffZ = uint (pzBlock * 0.0625);\n    uint xBase = uint ((p.x - grid0Min.x) * 4.0);\n    uint yBase = uint ((p.y - grid0Min.y) * 4.0);\n    yBase += diffZ * uint (grid0Range.y * 4.0);\n    uint pickChannelBits = uint (pzBlock) % 16u;\n    uint pickedUint;\n    vec4 readTexel = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n    switch (pickChannelBits / 4u)\n    {\n        case 0u:\n            pickedUint = floatBitsToUint (readTexel.x);\n            break;\n        case 1u:\n            pickedUint = floatBitsToUint (readTexel.y);\n            break;\n        case 2u:\n            pickedUint = floatBitsToUint (readTexel.z);\n            break;\n        case 3u:\n            pickedUint = floatBitsToUint (readTexel.a);\n            break;\n    }\n\n    uint fetchShift = (24u - ((pickChannelBits % 4u) * 8u));\n    uint readDistance = ((pickedUint & (0x000000FFu << fetchShift)) >> fetchShift);\n\n    return float(readDistance) * 0.1;\n}\n\nfloat scene(vec3 p)\n{\n    p.xz *= 0.125;\n    vec2 q = mod(p.xz, M_PI * 2.0);\n    vec2 q2 = mod(p.xz, M_PI);\n    vec2 p2 = floor (p.xz / (M_PI * 2.0));\n    float height = hash12(p2 * 100.0) * 2.5;\n    float sin_q_x = sin(q.x);\n    float sin_q_y = sin(q.y);\n    float sign1 = sign (q.x - M_PI);\n    float sign2 = sign (q.y - M_PI);\n    float plainsHeight = 2.0 - sign1 * sign2 * height;\n    vec3 translation = vec3 (M_PI * 0.5, plainsHeight, M_PI * 0.5);\n    vec3 boxP = vec3 (q2.x, p.y, q2.y) - translation;\n    float box = sdBox (boxP, vec3 (grid0Range.x * 0.5 * 0.125, grid0Range.y * 0.5, grid0Range.z * 0.5 * 0.125));\n    if ( box < 0.5 )\n    {\n        boxP.x *= 8.0;\n        boxP.z *= 8.0;\n        box = sdfGrid0 (boxP);\n    }\n    float plains = p.y + 3.0 + sin_q_x * sin_q_y * height;\n    return min(box, plains);\n}\n\nfloat sceneAccurate(vec3 p)\n{\n    p.xz *= 0.125;\n    vec2 q = mod(p.xz, M_PI * 2.0);\n    vec2 q2 = mod(p.xz, M_PI);\n    vec2 p2 = floor (p.xz / (M_PI * 2.0));\n    float height = hash12(p2 * 100.0) * 2.5;\n    float sin_q_x = sin(q.x);\n    float sin_q_y = sin(q.y);\n    float sign1 = sign (q.x - M_PI);\n    float sign2 = sign (q.y - M_PI);\n    float plainsHeight = 2.0 - sign1 * sign2 * height;\n    vec3 translation = vec3 (M_PI * 0.5, plainsHeight, M_PI * 0.5);\n    vec3 boxP = vec3 (q2.x, p.y, q2.y) - translation;\n    float box = sdBox (boxP, vec3 (grid0Range.x * 0.5 * 0.125, grid0Range.y * 0.5, grid0Range.z * 0.5 * 0.125));\n    if ( box < 0.25 )\n    {\n        boxP.x *= 8.0;\n        boxP.z *= 8.0;\n        \n        vec3 mixAmt = mod (fract (boxP), 0.25) * 4.0;\n        \n        float grid000 = sdfGrid0 (boxP);\n        float grid001 = sdfGrid0 (boxP + vec3 (0.0, 0.0, 0.25));\n        float grid010 = sdfGrid0 (boxP + vec3 (0.0, 0.25, 0.0));\n        float grid011 = sdfGrid0 (boxP + vec3 (0.0, 0.25, 0.25));\n        float grid100 = sdfGrid0 (boxP + vec3 (0.25, 0.0, 0.0));\n        float grid101 = sdfGrid0 (boxP + vec3 (0.25, 0.0, 0.25));\n        float grid110 = sdfGrid0 (boxP + vec3 (0.25, 0.25, 0.0));\n        float grid111 = sdfGrid0 (boxP + vec3 (0.25));\n        float gridEval = mix (\n                            mix (mix (grid000, grid001, mixAmt.z), mix (grid010, grid011, mixAmt.z), mixAmt.y),\n                            mix (mix (grid100, grid101, mixAmt.z), mix (grid110, grid111, mixAmt.z), mixAmt.y),\n                            mixAmt.x);\n        box = min (0.25, gridEval);\n    }\n    else\n        box = 0.25;\n    float plains = p.y + 3.0 + sin_q_x * sin_q_y * height;\n    return min(box, plains);\n}\n\nvec3 sceneNormal (vec3 p)\n{\n    float dx = sceneAccurate(vec3 (p.x + 0.01, p.y, p.z)) - sceneAccurate(vec3 (p.x - 0.01, p.y, p.z));\n    float dy = sceneAccurate(vec3 (p.x, p.y + 0.01, p.z)) - sceneAccurate(vec3 (p.x, p.y - 0.01, p.z));\n    float dz = sceneAccurate(vec3 (p.x, p.y, p.z + 0.01)) - sceneAccurate(vec3 (p.x, p.y, p.z - 0.01));\n    return normalize (vec3 (dx, dy, dz) + vec3 (0.0001));\n}\n\nvec2 toSpherical(vec3 inpVec)\n{\n\tvec3 inpVecOnXZ = normalize (vec3(inpVec.x, 0.0, inpVec.z));\n\tfloat phi = acos(inpVecOnXZ.x);\n\tif (inpVecOnXZ.z < 0.0) phi = 2.0 * M_PI - phi;\n\tfloat theta = acos(inpVec.y);\n\treturn vec2(phi * (1.0/(2.0 * M_PI)), theta * (1.0/M_PI));\n}\n\nvec3 probeLSD (vec3 sampleDir, float curTime)\n{\n    vec2 sph = toSpherical(sampleDir);\n    sph -= vec2 (0.5);\n    sph = abs(sph);\n    return (0.5 + 0.5*cos(curTime+sph.xyx+vec3(0,2,4)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fetchUV = fragCoord.xy / iResolution.xy;\n    vec2 uvDenorm =(fetchUV - vec2 (0.5)) * 2.0;\n    float curTime = iTime;\n    vec3 curEye = vec3 (curTime * 5.0, 8.0, curTime * 5.0);\n    vec3 curLook = normalize (vec3 (0.0, 0.0, 1.0));\n    vec3 curSide = normalize (cross (vec3 (0.0, 1.0, 0.0), curLook));\n    vec3 curUp = cross (curLook, curSide) * (iResolution.y / iResolution.x);\n    vec3 curDir = normalize (curLook + curSide * uvDenorm.x + curUp * uvDenorm.y);\n    vec3 curPos = curEye + curDir;\n    \n    vec3 bgColor = lsd(fetchUV, curTime);\n    bgColor = clamp (bgColor, vec3 (0.0), vec3 (1.0));\n    bgColor = pow (bgColor, vec3 (2.2));\n    \n    float distTravelled = 1.0;\n    for (int i = 0; i != 300; i++)\n    {\n        float r = scene(curPos);\n        if (abs(r) < 0.01f) {\n            vec3 diffVec = curPos - curEye;\n            float distToEye = dot(diffVec, diffVec);\n            vec3 curNorm = sceneNormal(curPos);\n            vec3 whiteColor = clamp (vec3 (distToEye * 0.001), vec3 (0.0), vec3(1.0));\n            whiteColor = vec3 (1.0);\n            float AOTerm = 0.0;\n            AOTerm += max (sceneAccurate (curPos + 0.1 * curNorm), 0.0);\n            AOTerm += max (sceneAccurate (curPos + 0.2 * curNorm), 0.0) * 0.5;\n            AOTerm += max (sceneAccurate (curPos + 0.3 * curNorm), 0.0) * 0.3333;\n            AOTerm += max (sceneAccurate (curPos + 0.4 * curNorm), 0.0) * 0.25;\n            AOTerm += max (sceneAccurate (curPos + 0.5 * curNorm), 0.0) * 0.2;\n            AOTerm += max (sceneAccurate (curPos + 0.6 * curNorm), 0.0) * 0.16666666;\n            AOTerm += max (sceneAccurate (curPos + 0.7 * curNorm), 0.0) * 0.14;\n            AOTerm += max (sceneAccurate (curPos + 0.8 * curNorm), 0.0) * 0.125;\n            AOTerm += max (sceneAccurate (curPos + 0.9 * curNorm), 0.0) * 0.1111111;\n            whiteColor *= clamp (AOTerm, 0.3, 1.0);\n            whiteColor *= clamp (probeLSD(curNorm, curTime), vec3 (0.3), vec3 (1.0));\n            \n            if ( distToEye > 2000.0 ) bgColor = mix (bgColor, whiteColor, (7000.0 - distToEye) / 5000.0);\n            else bgColor = whiteColor;\n            fragColor = vec4 (pow (bgColor, vec3 (1.0/2.2)), 1.0);\n            return;\n        }\n        curPos += curDir * r;\n        distTravelled += r;\n        if (distTravelled > sqrt(7000.0)) break;\n    }\n\n    fragColor = vec4(pow (bgColor, vec3 (1.0/2.2)),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 32452,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/anarchyjournal/jefferson-airplane-white"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/***********************************************************\n\n   This is a follow up to https://www.shadertoy.com/view/dlBGRc\n   This time around, I'm decoding and jump flooding the voxels into a channel and sphere marching via reading from the channel.\n   Created using Shadertoy-utils by yours truly :) : https://github.com/toomuchvoltage/shadertoy-utils\n   SDFs and the simplex noise are belong to iq: https://www.shadertoy.com/view/Msf3WH\n                                            https://iquilezles.org/articles/distfunctions/\n   Additionally you should read iq's rather old write up on SDF hierarchies as it boxes the bunny:\n   https://iquilezles.org/articles/sdfbounding/\n   The white noise for the plains is from Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n   The song is Jefferson Airplane - White Rabbit, a staple of 70's counter-culture\n\n   Covered under the MIT license:\n\n   Copyright (c) 2023 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\nuint countSetBits(uint n)\n{\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nuint countSetBitsBefore(uint n, uint comp)\n{\n    uint beforeMask = comp ^ (comp - 1u); // See: https://realtimecollisiondetection.net/blog/?p=78\n    n &= (~beforeMask);\n\tuint count = 0u;\n\twhile (n != 0u) {\n\t\tcount += (n & 1u);\n\t\tn >>= 1u;\n\t}\n\treturn count;\n}\n\nconst vec3 grid0Min = vec3 (-5.00, -5.00, -5.00);\nconst vec3 grid0Max = vec3 (5.00, 5.00, 5.00);\nconst vec3 grid0Range = grid0Max - grid0Min;\nuint svoObject0[480] = uint[](128u,2210513095u,3479298144u,1206382640u,2955944416u,2948644703u,3759157328u,4287565583u,3759675512u,2139587772u,802340674u,3188982804u,141045714u,2138838076u,868254667u,3286638110u,504914401u,2400088239u,4111435140u,25231882u,717225475u,1058011896u,3229678206u,2130212960u,2131742716u,1009857343u,2275802654u,3097205408u,547535824u,2192417534u,3288236371u,3896412222u,505289727u,4279177016u,4043288476u,2021159043u,2386045908u,708321408u,3052425285u,4261731647u,2600436334u,1905893279u,4231802947u,3476757529u,3877378112u,1105215936u,34434u,4289098691u,3288284978u,4058111969u,1368453360u,4030781552u,2018533408u,540094515u,863606808u,301587464u,2349928471u,3958414079u,1086318151u,2701128451u,61471098u,2156002367u,62979548u,3180696977u,2123695444u,358083563u,1106362448u,272611232u,1587628053u,2095138053u,3746421117u,802705685u,17108991u,944109840u,2236852288u,1090600768u,3208819995u,1789041304u,2577271807u,4244787370u,4078985120u,265989392u,626174633u,277056386u,2952430954u,532654112u,573780048u,4286382072u,404256888u,2308730983u,4027342703u,3436158974u,2146558435u,2551187007u,867382067u,865704345u,2576993484u,3704409341u,3258775938u,3176781832u,2297956543u,3808397308u,71073779u,4062383231u,4001299939u,3858923261u,4294504910u,2281914348u,3370546118u,1063543298u,537132546u,4261943487u,4271477196u,4224646856u,3292938240u,272650234u,4016187103u,4133678343u,4080218316u,3476239359u,3120287513u,2441110503u,4294757583u,4090285104u,553641598u,4193511022u,2294243840u,2818752010u,1848374463u,3254062863u,2127319104u,2682678906u,2545967183u,3435708155u,4231000385u,432095607u,285339157u,284091511u,1148523596u,1145953754u,626850341u,3632174440u,359142741u,1118551722u,2863275440u,1521198420u,1252047863u,717509418u,3288667447u,1947428677u,3120952896u,1094996991u,1600391359u,1428034056u,16427093u,542637738u,1119939523u,3764511729u,4050662903u,4002366143u,130351256u,410541068u,1010581182u,515774602u,737923627u,3004883152u,1509530008u,2144597893u,4231843327u,3263414787u,1106579704u,410548344u,2084322364u,809377310u,403708943u,235416312u,1731735602u,3482858001u,3677724u,166411u,4256956382u,4232957900u,3451073271u,1986419065u,4052775731u,858829601u,2441190596u,1288490207u,4268161167u,1449650319u,1009265720u,1162105604u,4116665695u,4114841579u,3926179344u,2856591392u,4126637728u,938539692u,67170282u,357892821u,39127072u,1874417153u,2105410472u,717184855u,1470217045u,1428347733u,571195218u,3158670264u,1079326545u,1072002912u,1604612128u,680036493u,3712343713u,1440621329u,286263846u,1713861618u,4144182067u,4169136513u,2174327168u,4026721826u,601629663u,4084412932u,4208664577u,85018111u,2945462233u,4110471175u,4286675613u,3793592382u,2151743801u,2155977084u,4169173120u,717083454u,3154037963u,3003960254u,1637456281u,2670775436u,3436157319u,3060164556u,4088607539u,3996247560u,434274295u,717079091u,1787128459u,4164421880u,257162247u,3278619619u,3275833600u,1052572127u,3781082648u,2693315316u,341137392u,804388289u,3519082624u,262318170u,99517628u,787753794u,2906981461u,83750360u,653103197u,2554865794u,2750130721u,3876522510u,4117868073u,2155911579u,2880295434u,2916137919u,2831494024u,3577881349u,871633902u,1738041274u,1731343139u,848857241u,2564676733u,3808693497u,2974916321u,7540787u,858995097u,2417596816u,2155881986u,645005824u,359751649u,823902198u,1639497159u,4292310531u,2818932589u,830078335u,4294246389u,2635153856u,44739310u,552586956u,3186548104u,3860437401u,2582842572u,3436181894u,1718085244u,3274912563u,1047109219u,3059754667u,2113579688u,4146775159u,684012417u,3185398955u,1420475220u,1414874165u,1363219957u,1079339767u,2102744389u,1413815632u,366826968u,357914485u,1467193481u,2592717738u,2732401341u,179015024u,2411672478u,568205431u,1362022673u,785458779u,1717003460u,1103939548u,3809811491u,1440483938u,1646683955u,926936271u,2579996262u,1741474824u,4002152450u,570564978u,863502128u,3493413888u,2855251616u,2050484286u,536879654u,1648291565u,3366878410u,2925648319u,3882300403u,858915737u,2583200137u,3426431964u,4243502958u,2724621994u,3903335624u,2343400104u,1463636000u,2157835338u,2847797764u,1512267499u,1587762346u,335902077u,1410509800u,3755666049u,706029661u,2170508670u,33166762u,948444056u,2595470683u,3041042603u,2297890824u,4151451042u,998733074u,3977315069u,306673526u,1145324621u,4248974685u,3405070562u,40265331u,785182542u,4186334822u,1727842172u,3471343616u,499u,1357113102u,284424167u,3884189752u,4056380211u,590590777u,2156501401u,2631716047u,993058526u,2107101574u,3707808442u,4203227235u,3812451259u,3256942850u,2677709668u,163029666u,4196412085u,4155116048u,2868572290u,2947481239u,3356977160u,747284398u,2726734856u,2864641032u,547417086u,2776108975u,2852240829u,1153389611u,3716223248u,270268584u,2943355891u,4228260522u,5584208u,272098427u,2272765032u,462565435u,3287848969u,4194171908u,1308099677u,4087566845u,290458114u,118698865u,59898265u,2172700672u,11u,2290648947u,3208630076u,3234740275u,2678056550u,1712855483u,860142112u,3450012993u,1138225127u,337383764u,3791279575u,3244245119u,3059112932u,67235856u,2941298647u,2231728215u,4161258114u,3286278176u,2431680288u,4289712893u,41780485u,8213547u,3492795408u,635461281u,4272287920u,2968533048u,947420220u,1072201707u,4095726655u,1363230741u,218369513u,2112387719u,2919545868u,3158299634u,1040326207u,4192304903u,125730528u,4034981951u,1078985600u,2180641853u,1069596736u,4229930976u,1616934975u,941621248u,0u,2282245244u,4039911032u,2036729363u,187826218u,3170083338u,418434846u,1045493886u,2123921535u,3912681479u,2865489930u,36173420u,2302931796u,3205692963u,4193787455u,2575403127u,4160876624u,4030787824u,2021154816u,0u,0u);\n\nuint readBitsSVO0 (uint bitLoc, uint numBits) {\n    uint wordLoc = bitLoc / 32u;\n    uint leftToRead = (32u - (bitLoc % 32u));\n    if (numBits <= leftToRead) {\n        uint shiftToMask = leftToRead - numBits;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - numBits);\n        masker <<= shiftToMask;\n        uint value = (svoObject0[wordLoc] & masker);\n        value >>= shiftToMask;\n        return value;\n    } else {\n        uint bottomBits = numBits - leftToRead;\n        uint masker = 0xFFFFFFFFu;\n        masker >>= uint(32u - leftToRead);\n        uint topNum = (svoObject0[wordLoc] & masker);\n        uint bottomMasker = 0xFFFFFFFFu;\n        uint bottomShifter = uint(32u - bottomBits);\n        bottomMasker <<= bottomShifter;\n        uint value = (svoObject0[wordLoc + 1u] & bottomMasker);\n        uint bottomNum = (value >> bottomShifter);\n        return ((topNum << bottomBits) | bottomNum);\n    }\n}\n\nbool readLeafSVO0 (vec3 samplePos) {\n    if ( any(lessThan(samplePos, grid0Min)) || any(greaterThan(samplePos, grid0Max)) ) return false;\n    uvec3 topBrickPos = uvec3 (samplePos - grid0Min);\n    uint topBrickId = topBrickPos.z + topBrickPos.y * uint(grid0Range.x) + topBrickPos.x * uint(grid0Range.y) * uint(grid0Range.z);\n    uint streamReadPos = 0u;\n    for (int i = 0; i < int(topBrickId); i++) {\n        uint isOcc = readBitsSVO0 (streamReadPos, 1u);\n        streamReadPos += 1u;\n        if (isOcc == 1u) {\n            uint countMidBricks = countSetBits (readBitsSVO0 (streamReadPos, 8u));\n            streamReadPos += (8u + countMidBricks * 8u);\n        }\n    }\n    uint topBrick = readBitsSVO0 (streamReadPos, 1u);\n    if (topBrick == 0u) return false;\n    streamReadPos += 1u;\n    uint midBricks = readBitsSVO0 (streamReadPos, 8u);\n    streamReadPos += 8u;\n    vec3 topBrickMinCorner = grid0Min + vec3 (topBrickPos);\n    vec3 sampleRelativeToTopBrick = fract (samplePos);\n    uint checkMidBrickBit = 0x80u;\n    vec3 sampleRelativeToMidBrick = sampleRelativeToTopBrick;\n    vec3 midBrickPos = vec3 (0.0);\n    if ( sampleRelativeToTopBrick.x > 0.5 ) {\n        sampleRelativeToMidBrick.x -= 0.5;\n        midBrickPos.x = 0.5;\n        checkMidBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToTopBrick.y > 0.5 ) {\n        sampleRelativeToMidBrick.y -= 0.5;\n        midBrickPos.y = 0.5;\n        checkMidBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToTopBrick.z > 0.5 ) {\n        sampleRelativeToMidBrick.z -= 0.5;\n        midBrickPos.z = 0.5;\n        checkMidBrickBit >>= 1u;\n    }\n    if ( (midBricks & checkMidBrickBit) == 0u ) return false;\n    uint skipMidBricks = countSetBitsBefore (midBricks, checkMidBrickBit);\n    streamReadPos += (8u * skipMidBricks);\n    uint finalMidBrick = readBitsSVO0 (streamReadPos, 8u);\n    uint checkVoxelBrickBit = 0x80u;\n    if ( sampleRelativeToMidBrick.x > 0.25 ) {\n        checkVoxelBrickBit >>= 4u;\n    }\n    if ( sampleRelativeToMidBrick.y > 0.25 ) {\n        checkVoxelBrickBit >>= 2u;\n    }\n    if ( sampleRelativeToMidBrick.z > 0.25 ) {\n        checkVoxelBrickBit >>= 1u;\n    }\n    if ( (checkVoxelBrickBit & finalMidBrick) != 0u ) return true;\n    return false;\n}\n\nvoid decodeAndJFA_SVO0( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 pixCoord = uvec2 (fragCoord - vec2 (0.5));\n    const uint tilingSide = uint (floor (sqrt(grid0Range.z))) + 1u;\n\n    int log2N = int(ceil(log2(max (max(grid0Range.x * 4.0, grid0Range.y * 4.0), grid0Range.z * 4.0))));\n    float offsetPower = float (log2N - (iFrame-1) - 1);\n    bool isInJFAResolution = all (lessThan (pixCoord,uvec2 (uint(grid0Range.x), uint(grid0Range.y)) * 4u * tilingSide));\n    float zRange = ceil (grid0Range.z * 4.0 * 0.0625);\n    bool isInJFACompactionResolution = all (lessThan (pixCoord, uvec2 (uint(grid0Range.x * 4.0), uint(grid0Range.y * 4.0 * zRange))));\n\n    if ( iFrame == 0 && isInJFAResolution ) {\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = (float (pixCoord.y / uint(grid0Range.y * 4.0)) * float(tilingSide) + float (pixCoord.x / uint(grid0Range.x * 4.0))) * 4.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        if ( baseCoord.z >= grid0Max.z )\n        {\n            fragColor = vec4 (uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u), uintBitsToFloat(0u));\n            return ;\n        }\n        uint writeR = 0u, writeG = 0u, writeB = 0u, writeA = 0u;\n        vec3 pos1 = baseCoord + vec3 (0, 0, 0);\n        vec3 pos2 = baseCoord + vec3 (0, 0, 0.25);\n        vec3 pos3 = baseCoord + vec3 (0, 0, 0.5);\n        vec3 pos4 = baseCoord + vec3 (0, 0, 0.75);\n        bool occupancy1 = readLeafSVO0 (pos1 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy2 = readLeafSVO0 (pos2 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy3 = readLeafSVO0 (pos3 + vec3 (0.001, -0.001, 0.001));\n        bool occupancy4 = readLeafSVO0 (pos4 + vec3 (0.001, -0.001, 0.001));\n        if ( occupancy1 )\n        {\n            pos1 *= 4.0;\n            pos1 += vec3(uint(grid0Range * 4.0)/2u);\n            writeR = 0xFF000000u;\n            writeR |= (uint(pos1.x) << 16);\n            writeR |= (uint(pos1.y) << 8);\n            writeR |= uint(pos1.z);\n        }\n        if ( occupancy2 )\n        {\n            pos2 *= 4.0;\n            pos2 += vec3(uint(grid0Range * 4.0)/2u);\n            writeG = 0xFF000000u;\n            writeG |= (uint(pos2.x) << 16);\n            writeG |= (uint(pos2.y) << 8);\n            writeG |= uint(pos2.z);\n        }\n        if ( occupancy3 )\n        {\n            pos3 *= 4.0;\n            pos3 += vec3(uint(grid0Range * 4.0)/2u);\n            writeB = 0xFF000000u;\n            writeB |= (uint(pos3.x) << 16);\n            writeB |= (uint(pos3.y) << 8);\n            writeB |= uint(pos3.z);\n        }\n        if ( occupancy4 )\n        {\n            pos4 *= 4.0;\n            pos4 += vec3(uint(grid0Range * 4.0)/2u);\n            writeA = 0xFF000000u;\n            writeA |= (uint(pos4.x) << 16);\n            writeA |= (uint(pos4.y) << 8);\n            writeA |= uint(pos4.z);\n        }\n        fragColor = vec4 (uintBitsToFloat(writeR), uintBitsToFloat(writeG), uintBitsToFloat(writeB), uintBitsToFloat(writeA));\n    } else if ( iFrame > 0 && offsetPower >= 0.0 && isInJFAResolution ) {\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = (float (pixCoord.y / uint(grid0Range.y * 4.0)) * float(tilingSide) + float (pixCoord.x / uint(grid0Range.x * 4.0))) * 4.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        if ( baseCoord.z >= grid0Max.z )\n        {\n            fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n            return ;\n        }\n\n        vec4 fragmentRead = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n        uint baseR = floatBitsToUint(fragmentRead.x);\n        uint baseG = floatBitsToUint(fragmentRead.y);\n        uint baseB = floatBitsToUint(fragmentRead.z);\n        uint baseA = floatBitsToUint(fragmentRead.a);\n        float offsetAmt = pow (2.0, offsetPower);\n        for (int zBrick = 0; zBrick != 4; zBrick++)\n        {\n            vec3 curCoord = baseCoord + vec3 (0, 0, float(zBrick) * 0.25);\n\n            float minDist = 100000.0;\n            uvec3 minCoord = uvec3 (0);\n            bool foundMinCoord = false;\n            for (int i = -1; i != 2; i++)\n                for (int j = -1; j != 2; j++)\n                    for (int k = -1; k != 2; k++)\n                    {\n                        vec3 sampleLoc = curCoord + vec3(i, j, k) * 0.25 * offsetAmt; \n\n                        if ( sampleLoc.x < grid0Min.x || sampleLoc.x >= grid0Max.x ) continue;\n                        if ( sampleLoc.y < grid0Min.y || sampleLoc.y >= grid0Max.y ) continue;\n                        if ( sampleLoc.z < grid0Min.z || sampleLoc.z >= grid0Max.z ) continue;\n\n                        float diffZ = sampleLoc.z - grid0Min.z;\n                        float fractionalZ = fract(diffZ);\n                        uint topLevelZ = uint(diffZ);\n                        uint xBase = (topLevelZ % tilingSide) * 4u * uint(grid0Range.x);\n                        uint yBase = (topLevelZ / tilingSide) * 4u * uint(grid0Range.y);\n                        xBase += uint ((sampleLoc.x - grid0Min.x) * 4.0);\n                        yBase += uint ((sampleLoc.y - grid0Min.y) * 4.0);\n\n                        vec4 readFrag = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n                        uint readUint;\n                        if ( fractionalZ == 0.0 ) readUint = floatBitsToUint (readFrag.x);\n                        else if ( fractionalZ == 0.25 ) readUint = floatBitsToUint (readFrag.y);\n                        else if ( fractionalZ == 0.5 ) readUint = floatBitsToUint (readFrag.z);\n                        else readUint = floatBitsToUint (readFrag.a);\n\n                        uint readR = ((readUint & 0x00FF0000u) >> 16);\n                        uint readG = ((readUint & 0x0000FF00u) >> 8);\n                        uint readB = (readUint  & 0x000000FFu);\n                        vec3 sampledCoord = (vec3 (readR, readG, readB) - vec3(uint(grid0Range * 4.0)/2u)) * 0.25;\n\n                        float sampledDist = length (sampledCoord - curCoord);\n\n                        if ( readUint != 0u && sampledDist < minDist)\n                        {\n                           minDist = sampledDist;\n                           minCoord = uvec3 (readR, readG, readB);\n                           foundMinCoord = true;\n                        }\n                    }\n\n            if ( !foundMinCoord ) continue;\n            if ( zBrick == 0 )\n            {\n                baseR = 0xFF000000u;\n                baseR |= (minCoord.x << 16);\n                baseR |= (minCoord.y << 8);\n                baseR |= minCoord.z;\n            }\n            else if ( zBrick == 1 )\n            {\n                baseG = 0xFF000000u;\n                baseG |= (minCoord.x << 16);\n                baseG |= (minCoord.y << 8);\n                baseG |= minCoord.z;\n            }\n            else if ( zBrick == 2 )\n            {\n                baseB = 0xFF000000u;\n                baseB |= (minCoord.x << 16);\n                baseB |= (minCoord.y << 8);\n                baseB |= minCoord.z;\n            }\n            else\n            {\n                baseA = 0xFF000000u;\n                baseA |= (minCoord.x << 16);\n                baseA |= (minCoord.y << 8);\n                baseA |= minCoord.z;\n            }\n        }\n\n        fragColor = vec4 (uintBitsToFloat(baseR), uintBitsToFloat(baseG), uintBitsToFloat(baseB), uintBitsToFloat(baseA));\n    } else if ( iFrame > 0 && offsetPower == -1.0 ) {\n        if ( !isInJFACompactionResolution )\n        {\n            fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n            return ;\n        }\n        vec3 baseCoord;\n        baseCoord.x = float (pixCoord.x % uint(grid0Range.x * 4.0)) - float(uint(grid0Range.x * 4.0)/2u);\n        baseCoord.y = float (pixCoord.y % uint(grid0Range.y * 4.0)) - float(uint(grid0Range.y * 4.0)/2u);\n        baseCoord.z = float (pixCoord.y / uint(grid0Range.y * 4.0)) * 16.0 - float(uint(grid0Range.z * 4.0)/2u);\n        baseCoord *= 0.25;\n        uint writeR = 0u, writeG = 0u, writeB = 0u, writeA = 0u;\n        for (int i = 0; i != 16; i++)\n        {\n            vec3 sampleLoc = baseCoord + vec3 (0, 0, float(i) * 0.25);\n\n            if ( sampleLoc.x < grid0Min.x || sampleLoc.x >= grid0Max.x ) continue;\n            if ( sampleLoc.y < grid0Min.y || sampleLoc.y >= grid0Max.y ) continue;\n            if ( sampleLoc.z < grid0Min.z || sampleLoc.z >= grid0Max.z ) continue;\n\n            float diffZ = sampleLoc.z - grid0Min.z;\n            float fractionalZ = fract(diffZ);\n            uint topLevelZ = uint(diffZ);\n            uint xBase = (topLevelZ % tilingSide) * 4u * uint(grid0Range.x);\n            uint yBase = (topLevelZ / tilingSide) * 4u * uint(grid0Range.y);\n            xBase += uint ((sampleLoc.x - grid0Min.x) * 4.0);\n            yBase += uint ((sampleLoc.y - grid0Min.y) * 4.0);\n\n            vec4 readFrag = texelFetch (iChannel0, ivec2(xBase, yBase), 0);\n            uint readUint;\n            if ( fractionalZ == 0.0 ) readUint = floatBitsToUint (readFrag.x);\n            else if ( fractionalZ == 0.25 ) readUint = floatBitsToUint (readFrag.y);\n            else if ( fractionalZ == 0.5 ) readUint = floatBitsToUint (readFrag.z);\n            else readUint = floatBitsToUint (readFrag.a);\n\n            uint readR = ((readUint & 0x00FF0000u) >> 16);\n            uint readG = ((readUint & 0x0000FF00u) >> 8);\n            uint readB = (readUint  & 0x000000FFu);\n            vec3 sampledCoord = (vec3 (readR, readG, readB) - vec3(uint(grid0Range * 4.0)/2u)) * 0.25;\n\n            float sampledDist = clamp (floor (length (sampledCoord - sampleLoc) * 10.0), 0.0, 255.0);\n            int channelSelect = i / 4;\n            int shiftAmount = 24 - ((i % 4) * 8);\n            switch (channelSelect)\n            {\n                case 0:\n                    writeR |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 1:\n                    writeG |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 2:\n                    writeB |= (uint(sampledDist) << shiftAmount);\n                    break;\n                case 3:\n                    writeA |= (uint(sampledDist) << shiftAmount);\n                    break;\n            }\n        }\n        fragColor = vec4 (uintBitsToFloat(writeR), uintBitsToFloat(writeG), uintBitsToFloat(writeB), uintBitsToFloat(writeA));\n    } else\n        fragColor = texelFetch (iChannel0, ivec2(fragCoord - vec2 (0.5)), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    decodeAndJFA_SVO0 (fragColor, fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}