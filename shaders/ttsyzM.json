{
    "Shader": {
        "info": {
            "date": "1592849222",
            "description": "Game Console-powered webcam.\nIntended for video meetings using iq's MemixApp.\nThanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!",
            "flags": 2,
            "hasliked": 0,
            "id": "ttsyzM",
            "likes": 21,
            "name": "Game Console Chat",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarch",
                "retro",
                "gameboy",
                "webcam"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 1277
        },
        "renderpass": [
            {
                "code": "// Game Console-powered webcam.\n// Intended for video meetings using iq's MemixApp.\n// Thanks to Evvvvil (Glow Broski!), Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat glow = 0.0;\nfloat pathGlow = 0.0;\nfloat terrainGlow = 0.0;\n\n#define gt (mod(iTime, 10.0))\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n  p.x -= clamp(p.x, 0.0, h);\n  return length(p) - r;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec4 min4(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec3 sdScreen(vec3 p, vec3 box) {\n    box *= vec3(0.85, 0.45, 0.05);\n    p += vec3(0.0, -0.8, 0.27);\n    return vec3(sdBox(p, box) - 0.025, p.x / box.x * 0.5, p.y / box.y * 0.5);\n}\n\nfloat sdButton(vec3 p) {\n    float d = sdCylinder(p, 0.08, 0.08) - 0.05;\n    float r = 2.0;\n    return smin(d, -sdSphere(p + vec3(0.0, 0.0, r + 0.1), r), -0.05);\n}\n\nfloat sdControls(vec3 p) {\n    // D-pad\n    vec3 pp = p + vec3(0.55, 0.45, 0.37);\n    vec3 dpad = vec3(0.1, 0.3, 0.1);\n    float d = min(sdBox(pp, dpad), sdBox(pp, dpad.yxz));\n    float r = 2.0;\n    d = smin(d, -sdSphere(pp + vec3(0.0, 0.0, r), r), -0.05);\n    r = 0.17;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, r * 0.9), r));\n    \n    // Fire buttons.\n    d = min(d, sdButton(p + vec3(-0.32, 0.5, 0.3)));\n    d = min(d, sdButton(p + vec3(-0.7, 0.35, 0.3)));\n\n    // Start/select.\n    p += vec3(0.0, 1.15, 0.34);\n    p.x = abs(p.x) - 0.12;\n    d = min(d, sdCapsule(p, 0.2, 0.06));\n    \n    return d;\n}\n\nvec4 sdCase(vec3 p) {\n    const float height = 3.4;\n    \n    p.yz *= rot(sin(fract(iTime * 0.1) * 6.283) * 0.1);\n    p.xz *= rot(sin(fract(iTime * 0.2) * 6.283) * 0.2);\n    \n    // Front base.\n    vec3 pp = p;\n    pp.z += pp.z < 0.0 ? (abs(0.5 + 0.5 * cos(pp.y * 0.7)) - 1.0) * max(0.0, (-pp.y - 1.3) / height * 2.0) : 0.0;\n    \n    float edgeIndent = sin(3.14159 * smoothstep(-0.10, -0.04, pp.z)) * 0.005;\n    vec3 box = vec3(1.0, height / 2.0, 0.2);\n    float d = sdBox(pp, box - vec3(edgeIndent, edgeIndent, 0.0)) - 0.1;\n    \n    // P1 P2\n    pp = p + vec3(0.00, 0.99, 0.37);\n    d = max(d, -sdSphere(pp + vec3(0.22, 0.0, 0.0), 0.08));\n    pp.x = abs(pp.x - 0.22) - 0.06;\n    d = max(d, -sdSphere(pp + vec3(0.0, 0.0, 0.0), 0.08));\n\n#if 0\n    // Rear bump.\n    d = smin(d, sdBox(p - vec3(0.0, -0.3, 0.4), box * vec3(0.90, 0.7, 0.2)) - 0.05, 0.2);\n#endif\n    \n    // Power light.\n    float power = sdSphere(p - vec3(-0.75, 1.4, -0.3), 0.03);\n    glow += 0.01 / (0.01 + power * power * 400.0);\n    \n    // Screen indent.\n    return min4(min4(min4(vec4(d, 1.5, 0.0, 0.0), vec4(sdScreen(p, box), 2.5).xwyz), vec4(power, 3.5, 0.0, 0.0)), vec4(sdControls(p), 4.5, 0.0, 0.0));\n}\n\nvec2 sdTraveller(vec3 p) {\n    p.z = mod(p.z + gt * 40.0, 50.0) - 25.0;\n    \n    float open = abs(sin(gt * 4.0));\n    \n    vec3 pp = p;\n    pp.yz *= rot(open);\n    float bodyTop = max(sdSphere(pp, 1.3), -pp.y);\n    \n    pp.yz += vec2(-0.6, 1.0);\n    pp.x = abs(pp.x) - 0.6;\n    float eyes = sdSphere(pp, 0.2);\n    \n    p.yz *= rot(-open);\n    float bodyBottom = max(sdSphere(p, 1.3), p.y);\n    \n    float body = min(bodyTop, bodyBottom);\n   \n    return min2(vec2(body, 6.0), vec2(eyes, 4.0));\n}\n\nvec2 sdRoad(vec3 p) {\n    p.x += 8.0;\n    p.xz *= rot(-0.75 + sin(p.z * 0.1) * 0.06);\n    \n    p.y += sin(p.z * 0.1);\n\n    // Road.\n    p.y += 4.0;\n    \n    vec3 pp = p;\n    pp.x = abs(pp.x) - 2.0;\n    float d1 = length(pp.xy) - 0.3;\n    \n    // Traveller.\n    p.z -= 10.0;\n    p.y -= 1.0;\n    vec2 d2 = sdTraveller(p);\n    \n    // Glow.\n    pathGlow += 0.1 / (0.1 + d1 * d1 * 5.0);\n    \n    return min2(vec2(d1, 5.0), d2);\n}\n\nvec2 sdTerrain(vec3 p) {\n    p.y += 5.0;\n    p.z += iTime;\n    \n    p.xz = mod(p.xz, 5.0) - 2.5;\n\n    float d = min(length(p.xy), length(p.yz));\n    \n    terrainGlow += 0.001 / (0.001 + d * d * 5.0);\n    \n    return vec2(d, 3.5);\n}\n\nvec4 map(vec3 p) {\n    return min4(min4(sdCase(p), vec4(sdRoad(p), 0.0, 0.0)), vec4(sdTerrain(p), 0.0, 0.0));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0;\n    float d = 0.01;\n    for (int i = 0; i < 5; i++) {\n        h = map(p + rd * d).x;\n        minH = abs(h / d);\n        if (minH < 0.01)\n            return 0.0;\n        d += h;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.08;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getWebCam(vec2 uv) {\n    if (iTime < 5.0) return vec3(0.01);\n    if (iTime < 6.0) return vec3(0.03);\n    \n    ivec2 t = textureSize(iChannel0, 0);\n    float ar = float(t.y) / float(-t.x);\n    \n    const vec2 res = vec2(160.0, 144.0) * 0.4;\n    uv = floor(uv * res) / res;\n    \n    vec3 col = texture(iChannel0, (uv * vec2(ar, 1.0) + vec2(0.5))).rgb;\n    col = floor(col * 12.0) / 12.0;\n    \n    return mix(vec3(0.03), col, clamp(iTime - 7.0, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    // Raymarch.\n    vec3 ro = vec3(0.0, 1.0, -4.0);\n    vec3 rd = getRayDir(ro, vec3(0.0, 0.2, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    float steps;\n    vec2 puv;\n    for (steps = 0.0; steps < 55.0; steps++) {\n        p = ro + rd * d;\n        vec4 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            hit = int(h.y);\n            puv = h.zw;\n            break;\n        }\n\n        d += h.x;\n    }\n\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(3.0, 3.0, -10.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        vec3 skyCol = vec3(0.05);\n        float occ = calcOcc(p, n, 20.0);\n        float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n        float mainLight = max(0.0, dot(n, lightToPoint));\n        float backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1;\n        vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Case\n            mat = vec3(0.1, 0.8, 0.15);\n        } else if (hit == 2) {\n            // Screen.\n            vec2 uv = (puv - vec2(0.0, 0.05)) * 1.4;\n            mat = abs(uv.x) < 0.5 && abs(uv.y) < 0.5 ? getWebCam(uv) : vec3(0.0);\n            \n            if (puv.y < -0.36 && puv.y > -0.45) {\n                puv.x = (puv.x - 0.45) * 15.0 - puv.y * 8.0;\n                if (puv.x > 0.0 && puv.x < 3.0)\n                {\n                    switch(int(puv.x)) {\n                        case 0: mat = vec3(1.0, 0.0, 0.0); break;\n                        case 1: mat = vec3(0.0, 1.0, 0.0); break;\n                        case 2: mat = vec3(0.0, 0.0, 1.0); break;\n                    }\n                }\n            }\n        } else if (hit == 3) {\n            // Power light.\n            mat = vec3(0.1);\n        } else if (hit == 4) {\n            // Controls.\n            mat = vec3(0.1);\n        } else if (hit == 5) {\n            // Road.\n            mat = vec3(0.7);\n        } else if (hit == 6) {\n            // Traveller.\n            mat = vec3(0.7, 0.7, 0.1) * 2.0;\n        }\n        \n        col = (mainLight + (spe + backLight) * occ) * lightCol;\n        col += skyLight * occ;\n        col = mix(col * mat, vec3(0.0), fog);\n    }\n    \n    // Glow.\n    if (iTime < 5.0) glow = 0.0;\n    col += (glow + terrainGlow) * vec3(0.7, 0.1, 0.1);\n    col += pathGlow * vec3(0.1, 0.1, 0.8);\n\n    // Output to screen\n    col = pow(vignette(col, fragCoord), vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}