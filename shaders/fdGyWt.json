{
    "Shader": {
        "info": {
            "date": "1655769772",
            "description": "GLSL port of old version of XXHash32\n\nAlso includes a high-quality random float generator",
            "flags": 0,
            "hasliked": 0,
            "id": "fdGyWt",
            "likes": 1,
            "name": "XXHash32",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "hash"
            ],
            "usePreview": 0,
            "username": "AshenFlowersFalling",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(random(vec3(fragCoord, float(iFrame))));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define USE_MAX 1  // use \"max\" as the comparison, otherwise use \"min\"\n#define QUANTIZE 0 // quantise initial noise to 8-bits?\n\n#define INIT_FRAMES 1\n\n#define R2 19\n\n#define SIGMA 1.41421356237\n#define M_PI 3.14159265359\n\n// high-quality hash, modified version of old version of XXHash32 from https://github.com/Cyan4973/xxHash (BSD license)\n\nstruct vec5\n{\n\tfloat v[5];\n};\nstruct uvec5\n{\n\tuint v[5];\n};\nstruct vec6\n{\n\tfloat v[6];\n};\nstruct uvec6\n{\n\tuint v[6];\n};\n\nuvec6 touvec6(uvec5 x) { uvec6 x6;    x6.v[0] = x.v[0]; x6.v[1] = x.v[1]; x6.v[2] = x.v[2]; x6.v[3] = x.v[3]; x6.v[4] = x.v[4]; x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec4 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = x.w;    x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec3 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = x.z;    x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uvec2 x) { uvec6 x6;    x6.v[0] = x.x;    x6.v[1] = x.y;    x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\nuvec6 touvec6(uint  x) { uvec6 x6;    x6.v[0] = x;      x6.v[1] = uint(0);x6.v[2] = uint(0);x6.v[3] = uint(0);x6.v[4] = uint(0);x6.v[5] = uint(0);    return x6;}\n\n#define PRIME32_1\t2654435761U\n#define PRIME32_2\t2246822519U\n#define PRIME32_3\t3266489917U\n#define PRIME32_4\t668265263U\n#define PRIME32_5\t374761393U\n\nuint rotl32(uint x, int shift)\n{\n\treturn (x << shift) | (x >> (32 - shift));\n}\nvoid XXH32_InitV(inout uint v[4], uint seed)\n{\n    v[0] = seed + PRIME32_1 + PRIME32_2;\n    v[1] = seed + PRIME32_2;\n    v[2] = seed + uint(0);\n    v[3] = seed - PRIME32_1;\n}\nvoid XXH32_Inner(const uint p[4], inout uint v[4])\n{\n    v[0] += p[0] * PRIME32_2;\n    v[0] = rotl32(v[0], 13);\n    v[0] *= PRIME32_1;\n\n    v[1] += p[1] * PRIME32_2;\n    v[1] = rotl32(v[1], 13);\n    v[1] *= PRIME32_1;\n\n    v[2] += p[2] * PRIME32_2;\n    v[2] = rotl32(v[2], 13);\n    v[2] *= PRIME32_1;\n\n    v[3] += p[3] * PRIME32_2;\n    v[3] = rotl32(v[3], 13);\n    v[3] *= PRIME32_1;\n}\n\nuint XXHash32_32(uint input_s[8])\n{\n    uint h32;\n\tuint v[4];\n\n\tXXH32_InitV(v, uint(0));\n\n\tXXH32_Inner(uint[4](input_s[0], input_s[1], input_s[2], input_s[3]), v);\n    XXH32_Inner(uint[4](input_s[4], input_s[5], input_s[6], input_s[7]), v);\n\n    h32 = rotl32(v[0], 1) + rotl32(v[1], 7) + rotl32(v[2], 12) + rotl32(v[3], 18);\n\n    h32 += uint(32);\n\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n\n    return h32;\n}\n\nuint hash(uvec6 x, uint seed) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(seed));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec4 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec3 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uvec2 x, uint seed) { return hash(touvec6(x), seed);}\nuint hash(uint x, uint seed)  { return hash(touvec6(x), seed);}\nuint hash(uvec6 x) \n{\n    uint inputs[8] = uint[8](x.v[0], x.v[1], x.v[2], x.v[3], x.v[4], x.v[5], uint(0), uint(0));\n    \n    return XXHash32_32(inputs);\n}\nuint hash(uvec5 x) { return hash(touvec6(x));}\nuint hash(uvec4 x) { return hash(touvec6(x));}\nuint hash(uvec3 x) { return hash(touvec6(x));}\nuint hash(uvec2 x) { return hash(touvec6(x));}\nuint hash(uint x)  { return hash(touvec6(x));}\n\nuint lzcnt(uint x)\n{\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    \n    uint c;\n    \n    x = x - ((x >> 1) & uint(0x55555555));                    \n    x = (x & uint(0x33333333)) + ((x >> 2) & uint(0x33333333));\n    c = ((x + (x >> 4) & uint(0xF0F0F0F)) * uint(0x1010101)) >> 24;\n\n    return uint(32) - c;\n}\n\n// random float that uses the full range from [0, 1)\n\nfloat floatrandhq(uvec6 x) \n{\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint mantissabits = uint(23);\n    const uint exponentbits = uint(8);\n    const uint hashbits     = uint(32);\n    const uint hashbitslg2  = uint(5);\n    uint current;\n    uint cnt;\n    uint pw2;    \n    // ceil((2^(ebits - 1) - 2) / 2^hashbits)\n    uint maxrec = (uint(1 << (exponentbits - uint(1))) - uint(2) + hashbits - uint(1)) >> hashbitslg2;\n    uint m;\n    uint i;\n    \n    current = hash(x, uint(0));\n    cnt = lzcnt(current);\n    pw2 = cnt;\n\n    for (i = uint(1); (i < maxrec) && (cnt == hashbits); i++)\n    {\n        current = hash(x, i +  uint(1));\n        cnt = lzcnt(current);\n        pw2 += cnt;\n    }\n    \n    // if less than 23 bits left, we need to generate a new hash to fill the mantissa\n    if ((int(hashbits) - int(cnt) - 1) < int(mantissabits))\n        current = hash(x, i +  uint(1));\n    \n    if (pw2 < uint(1 << (exponentbits - uint(1))) - uint(2))\n        m = (uint(1 << (exponentbits - uint(1))) - uint(2) - pw2) << mantissabits;\n    else // subnormal\n        m = uint(0);\n        \n    m |= ieeeMantissa & current;\n    \n    return uintBitsToFloat( m );\n}\n\nuvec5 floatBitsToUint2(vec5 v)\n{\n    uvec5 u;\n\n    u.v[0] = floatBitsToUint(v.v[0]);\n    u.v[1] = floatBitsToUint(v.v[1]);\n    u.v[2] = floatBitsToUint(v.v[2]);\n    u.v[3] = floatBitsToUint(v.v[3]);\n    u.v[4] = floatBitsToUint(v.v[4]);\n\n    return u;\n}\n\nfloat random( float x ) { return floatrandhq(touvec6(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatrandhq(touvec6(floatBitsToUint(v))); }\nfloat random( vec5  v ) { return floatrandhq(touvec6(floatBitsToUint2(v))); }\nfloat random( vec6  v ) \n{ \n    return floatrandhq(\n            uvec6(uint[6](\n                floatBitsToUint(v.v[0]),\n                floatBitsToUint(v.v[1]),\n                floatBitsToUint(v.v[2]),\n                floatBitsToUint(v.v[3]),\n                floatBitsToUint(v.v[4]),\n                floatBitsToUint(v.v[5])\n                ))\n        );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}