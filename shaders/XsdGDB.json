{
    "Shader": {
        "info": {
            "date": "1461506544",
            "description": "Motion Blurred version of [url=https://www.shadertoy.com/view/4ljGRh][NV15] Tiny Cutting Planet[/url]\n",
            "flags": 32,
            "hasliked": 0,
            "id": "XsdGDB",
            "likes": 9,
            "name": "Tiny Planet Motion Blur",
            "published": 3,
            "tags": [
                "blur",
                "planet",
                "motion",
                "tiny"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 928
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by Stephane Cuillerdier - @Aiekick/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n/* Motion Blurred version of https://www.shadertoy.com/view/4ljGRh\nthis planet was initially the reason for what i have start to use shaders, for generate image for games\nand this is due to that, i was comming on shadertoy, this is what i have discovered the glsl and the Ray marching techs and over,\nand get hooked by shader world :)\n\nso the modeling of this is a little bit weird by moment ( for the coloring) , but it is what i discovered after many experiments\nthe first experiment is here : https://www.shadertoy.com/view/ldSXWd\ni tried to understand the Ray marching and how i could do coloring, so i have used analyse by mouse via \nGLSL Number Printing of @P_Malin to extract the distance information\n\n*/\n\n//Uni\nvec2 screen ;\nfloat time;\n\nfloat PI = 3.14159;\n\n// Ground Vars\nvec2 NoiseVar = vec2(950.,800.);\n\n// Time Speed +> Morphing, PlanetRotate, Sky\nvec3 tSpeed = vec3(0.8, 0.3, 1.5);\n\n// Offset +> planetSectionoffset, GroundThickness, Displace Range\nvec3 Offset = vec3(2.1, .05, 1.);\n\n//Radius +> Water, Planet, Kernel, CutterRoundBoxCorner\nvec4 Radius = vec4(3.02, 3., 2.25, 0.1);\n\n//Range Stratum +> STONE, SNOW, SAND_WATER_OFFSET\nvec3 Range = vec3(.2, .4, .015);\n\n// temperature +> KERNEL, MANTLE0, MANTLE1\nvec3 Temp = vec3(2200.,2200.,400.);\n\n// COLORS\nvec3 WATER_COLOR = vec3(0., 0., 1.);\nvec3 GROUND_COLOR = vec3(0., .7, 0.);\nvec3 STONE_COLOR = vec3(.5, .46, .4);\nvec3 SNOW_COLOR = vec3(1., 1., 1.);\nvec3 SAND_COLOR = vec3(1., .9, .45);\n\nvec3 MASK_GROUND_COLOR = vec3(0.5, 0., 0.);\nvec3 MASK_MANTLE_COLOR = vec3(0., 0.5, 0.);\nvec3 MASK_KERNEL_COLOR = vec3(0., 0., 0.5);\n\n/////////////////////////////////////////////////////\nfloat dstepf = 0.;\n\nvec2 pRot = vec2(0.); // Planet Rotation\n\n// rxy = rot xy for planet, kernel and water\n// rcxy = rot xy for cutter\nmat3 rxy, rcxy;\n\nfloat random(float p) {return fract(sin(p)*NoiseVar.x);}\nfloat noise(vec2 p) {return random(p.x + p.y*NoiseVar.y);}\nvec2 sw(vec2 p) {return vec2( floor(p.x) , floor(p.y) );}\nvec2 se(vec2 p) {return vec2( ceil(p.x)  , floor(p.y) );}\nvec2 nw(vec2 p) {return vec2( floor(p.x) , ceil(p.y)  );}\nvec2 ne(vec2 p) {return vec2( ceil(p.x)  , ceil(p.y)  );}\nfloat snoise(vec2 p) {\n  \tvec2 inter = smoothstep(0., 1., fract(p));\n  \tfloat s = mix(noise(sw(p)), noise(se(p)), inter.x);\n  \tfloat n = mix(noise(nw(p)), noise(ne(p)), inter.x);\n  \treturn mix(s, n, inter.y);\n}\n\nvec3 blackbody(float Temp){\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\nfloat owater(vec3 p){\n    return length(p)-Radius.x;\n}\nfloat oplanet( vec3 p ){\n   \tp *= rxy;\n  \tfloat d1 = length(p)-Radius.y;\n  \tfloat d2 = snoise(p.yx)*snoise(p.zy)*snoise(p.zx)*Offset.z; // displacement\n    float ud = d1-d2;\n    return ud<=Radius.x?ud+0.05:ud-0.05;// on creuse pour marquer la flotte\n}\nfloat okernel( vec3 p ){\n    return length(p*rxy)-Radius.z;\n}\nfloat ocutter( vec3 p ){\n    vec3 q = p*rcxy+Offset.x;\n    float dB = length(max(abs(q+1.35)-2.5,0.0))-Radius.w;\n    float dS = length(q+.5)-2.5;\n    return mix(dB, dS, sin(time*tSpeed.x)/2.+.5);\n}\nfloat map(vec3 p){   \n    dstepf += 0.005;\n    return smin(max(-ocutter(p), min(owater(p), oplanet(p))), okernel(p), 0.05);\n}\n\n// normal calc based on nimitz shader https://www.shadertoy.com/view/4sSSW3\nvec3 getNormal(const in vec3 p, float rmPrec){  \n    vec2 e = vec2(-1., 1.)*rmPrec;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );\n}\n\n// sky from iapafoto shader => https://www.shadertoy.com/view/Xtl3zM\nvec3 getSky(float offTime, vec3 size, sampler2D cloudTex, vec2 uv){\n    //stereo dir\n    float t = 3.+offTime*.08;\n    float ct = cos(t);\n    float st = sin(t);\n\tfloat m = .55;\n    uv = (uv * 2. * m - m)*3.;\n    uv.x *= size.x/size.y;\n    uv *= mat2(ct,st,-st,ct);\n\tvec3 rd = normalize(vec3(2.*uv.x,dot(uv,uv)-1.,2.*uv.y));\n\tvec3 col = 2.5*vec3(0.18,0.33,0.45) - rd.y*1.5;\n    col *= 0.9;\n\tvec2 cuv = rd.xz*(1000.0)/rd.y;\n    float cc = 1.;\n    float cc0 = texture( cloudTex, 0.00015*cuv +0.1+ 0.0043*offTime ).x;\n    float cc1 = 0.35*texture( cloudTex, 0.00015*2.0*cuv + 0.0043*.5*offTime ).x;\n    cc = 0.65*cc1 + cc0;\n    cc = smoothstep( 0.3, 1.0, cc0 );\n  \tcol = mix( col, vec3(0.95), 0.9*cc );\n    col = .35+.65*col;  // less background sky => higlight the Ball\n   \treturn col;}\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cu, vec3 cv)\n{\n\tvec3 rov = normalize(cv-ro);\n    vec3 u =  normalize(cross(cu, rov));\n    vec3 v =  normalize(cross(rov, u));\n    vec3 rd = normalize(rov + u*uv.x + v*uv.y);\n    return rd;\n}\n\nvoid mainImage( out vec4 fr, in vec2 g )\n{\n    screen = iResolution.xy;\n\t\n    time = iTime;\n    \n   \tvec2 si = iResolution.xy;\n   \t\n    vec3 col = vec3(0.);\n    float b = 0.1;\n       \n    float a = 1.; // alpha\n    \n    float rmPrec = 5e-4; // RM Precision\n\tfloat Zero = 1e-6;\n   \n    pRot -= time*tSpeed.y;\n\trxy = getRotXMat(pRot.x)*getRotYMat(pRot.y);\n  \trcxy = getRotZMat(PI)*getRotXMat(-PI/5.)*getRotYMat(PI/4.);\n    \n    //Camera init\n    float ca = PI; // angle z\n    float ce = 0.; // elevation\n    float cd = 5.; // distance to origin axis\n    vec3 cu=vec3(0,1,0);//Change camere up vector here\n    vec3 cv=vec3(0,0,0); //Change camere view here\n    vec2 uv = (g+g-si)/min(si.x, si.y);\n    vec3 ro = vec3(-sin(ca)*cd, ce, cos(ca)*cd); //\n    vec3 rd = cam(uv, ro, cu, cv);\n    \n  \t//Raymarching\n    vec2 RMPrec = vec2(1., .7); \n    vec2 DPrec = vec2(.0001, 10.); \n\tvec3 p = vec3(0.);\n  \tfloat s=DPrec.x;\n    float f=0.;\n    float iterUsed = 0.;\n    for(int i=0;i<40;i++) \n  \t{\n        iterUsed++;\n    \tif (s<DPrec.x||f>DPrec.y) break;\n    \tp = ro + rd * f;\n        s = map(p)*(s>DPrec.x?RMPrec.x:RMPrec.y);\n        f+=abs(s);\n  \t}\n    \n\tvec3 c = vec3(0.);\n\t\n    if (f<DPrec.y)\n    {\n     \tvec3 n = getNormal(p,1./iterUsed);\n     \tvec3 np = normalize(p);\n\n      \tb += dot(n,np)*0.8;\n   \n      \tfloat d = length(p);\n       \tfloat range_ratio = (d-Radius.y); \n       \tfloat planet = oplanet(p);\n       \tfloat water = owater(p);\n\n      \t// CUTTER\n      \tfloat kernel = okernel(p);\n      \tfloat cutter = ocutter(p); \n\n        c = GROUND_COLOR;\n        if ( cutter <= Zero) // cut coloring\n        { \n         \tif ( water <= Zero && planet >= Zero ) c = WATER_COLOR;\n           \tif ( planet <= Zero && planet >= -Offset.y ) c = GROUND_COLOR;\n         \telse\n          \t{\n      \t\t\tc = blackbody(Temp.z); // limit between volumes\n     \t\t\tif ( d <= Radius.y ) // mantle\n        \t\t{\n           \t\t\tfloat ratio = (d-Radius.z)/(Radius.y - Radius.z);\n             \t\tc = blackbody(mix(Temp.y, Temp.z, ratio));\n          \t\t}\n        \t}   \n        \tif ( kernel <= 1e-4) { c = blackbody(Temp.x);  } // kernel\n\t\t}    \n\n       \tif ( water <= rmPrec && planet > Zero ) c = WATER_COLOR;\n       \telse if ( water <= Range.z && water > Zero && planet > Zero ) c = SAND_COLOR;\n        else if ( planet >= Zero ) c = GROUND_COLOR;\n\n      \tif ( range_ratio >= Range.x && planet >= -Offset.y*(1.-Range.x/range_ratio)*8. ) c = STONE_COLOR;\n        if ( range_ratio >= Range.y && planet >= -Offset.y*(1.-Range.y/range_ratio)*5. ) c = SNOW_COLOR;\n            \n      \tif (cutter>Zero) \n      \t{\n       \t\tvec3 rayReflect = reflect(ro, n);\n      \t\tvec3 cube = texture(iChannel2, rayReflect).rgb;  \n        \tcol = mix(col, b*c+cube/b+pow(b,15.0)*(1.-f*.01), 0.5);\n      \t}\n       \telse \n      \t{\n       \t\tb += 0.1;\n       \t\tcol = mix(col, (b*c+pow(b,8.0))*(1.0-f*.01), 1.0);\n     \t}\n    }\n    else // draw sky and weird light ray\n    { \n        vec3 sky = getSky(time*tSpeed.z, iResolution, iChannel3, g.xy / screen);\n        // weird light\n        float t1 = 0.5*sin(time*tSpeed.z)+0.5;\n        vec3 uvv = vec3(uv,t1*uv.y)*-1.;\n        col = mix(col, sky, 1.25); \n    }    \n\n    col += dstepf;\n    \n    vec4 buf = texture(iChannel0, g/si);\n    \n    fr = vec4(col, 1.) * 0.3 + buf * 0.7;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}