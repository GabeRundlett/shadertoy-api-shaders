{
    "Shader": {
        "info": {
            "date": "1583484836",
            "description": "saibapankg",
            "flags": 32,
            "hasliked": 0,
            "id": "3lKSz3",
            "likes": 26,
            "name": "glitch: cyberpunk text",
            "published": 3,
            "tags": [
                "text"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 1208
        },
        "renderpass": [
            {
                "code": "vec4 shampain_glitch( vec2 p, float GLITCH, float rndx )\n{\n    vec2 ssuv = p.xy;\n    p *= iResolution.xy;\n    \n    float in_time = mod(iTime,40.0);\n    \n    //fragColor = texture( iChannel3, ssuv ); return;\n    \n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = p.xy / iResolution.xy;\n    //uv.y = 1.0 - uv.y;\n\t\n\tfloat time = mod( in_time, 32.0); // + modelmat[0].x + modelmat[0].z;\n        \n\tfloat gnm = sat( GLITCH );\n\tfloat rnd0 = rand( mytrunc( vec2(time, time), 6.0 ) );\n\tfloat r0 = sat((1.0-gnm)*0.7 + rnd0);\n\tfloat rnd1 = rand( vec2(mytrunc( uv.x, 10.0*r0 ), time) ); //horz\n\t//float r1 = 1.0f - sat( (1.0f-gnm)*0.5f + rnd1 );\n\tfloat r1 = 0.5 - 0.5 * gnm + rnd1;\n\tr1 = 1.0 - max( 0.0, ((r1<1.0) ? r1 : 0.9999999) ); //note: weird ass bug on old drivers\n\tfloat rnd2 = rand( vec2(mytrunc( uv.y, 40.0*r1 ), time) ); //vert\n\tfloat r2 = sat( rnd2 );\n\n\tfloat rnd3 = rand( vec2(mytrunc( uv.y, 10.0*r0 ), time) );\n\tfloat r3 = (1.0-sat(rnd3+0.8)) - 0.1;\n\n\tfloat pxrnd = rand( uv + time );\n\n\tfloat ofs = 0.05 * r2 * GLITCH * ( rnd0 > 0.5 ? 1.0 : -1.0 );\n\tofs += 0.5 * pxrnd * ofs;\n\n\tuv.y += 0.1 * r3 * GLITCH;\n\n    const int NUM_SAMPLES = 10;\n    const float RCP_NUM_SAMPLES_F = 1.0 / float(NUM_SAMPLES);\n    \n\tvec4 sum = vec4(0.0);\n\tvec3 wsum = vec3(0.0);\n\tfor( int i=0; i<NUM_SAMPLES; ++i )\n\t{\n\t\tfloat t = float(i) * RCP_NUM_SAMPLES_F;\n\t\tuv.x = sat( uv.x + ofs * t );\n\t\tvec4 samplecol = texture( iChannel3, uv, -10.0 );\n        if (rndx > 0.7 && rndx < 0.75 )\n            samplecol = (2.0-2.0*samplecol) * vec4( 0.1, 0.2*rnd1, 0.5*rnd1, 1.0 );\n\t\tvec3 s = spectrum_offset_rgb( t );\n\t\tsamplecol.rgb = samplecol.rgb * s;\n\t\tsum += samplecol;\n\t\twsum += s;\n\t}\n\tsum.rgb /= wsum;\n\tsum.a *= RCP_NUM_SAMPLES_F;\n\n    //fragColor = vec4( sum.bbb, 1.0 ); return;\n    \n    vec4 outcol;\n    \n\toutcol.a = sum.a;\n\toutcol.rgb = sum.rgb; // * outcol0.a;\n    \n    return outcol;\n}\n\n//#define CANCELLED 1\n\nvec2 calc_glitch_uv( vec2 ssuv, out float rnd0, out float GLITCH )\n{\n    float in_time = mod(iTime, 40.0 );\n\n\n    #ifndef CANCELLED\n    //TODO: some minor glitch in base...\n    GLITCH = max( 0.1, 10.0 - in_time*in_time );\n\n    if ( in_time > 30.0 )\n        GLITCH = clamp( in_time-20.0, 0.0, 20.0 );\n    #else\n    GLITCH = 0.4;\n    \n    #endif //CANCELLED\n    \n    float GLITCHs = clamp( GLITCH, 0.0, 1.0);\n    \n    //DBG\n    //GLITCH = 0.1;\n\n    if ( iMouse.z > 0.5 )\n    \tGLITCH = 0.05 + 20.0 * iMouse.x / iResolution.x;\n\n    \n    float time = mytrunc( in_time, 10.0 );\n    float ftime = fract( time );\n    \n    float rndt = hashf( uint(1337.0*ftime) );\n    \n    #ifdef CANCELLED\n    GLITCH = 1.0 - clamp( 2.0*hashf(mytrunc(in_time,1.0)*1227.0), 0.0, 1.0);\n    #endif\n    \n    float sign0 = -1.0 + 2.0 * step( rndt, 0.5 );\n    vec2 uv0 = mytrunc( ssuv, vec2(64.0) );\n    float seed0 = uv0.y + sign0*3.0/32.0*(1.0+uv0.x)*uv0.y;\n    seed0 = mytrunc( seed0, 16.0 );\n\n    rnd0 = hashf( seed0 + fract(0.39*time) );\n    float rnd1 = hashf( rnd0 );\n\n    float rnd0v = rnd0;\n    rnd0 = mix( 0.0, rnd0, GLITCH );\n    \n    float maxofs = 5.0 / iChannelResolution[0].x;\n    float mask = step(0.98, rnd0);\n    vec2 uv1 = ssuv;\n\n    //note: offset-glitch\n    uv1 += maxofs * mask;\n\n    //invert sometimes\n    if(rnd0v>(1.0-0.03*GLITCHs))\n        uv1 = 1.0 - uv1;\n    \n    if (rnd0v>0.1 && rnd0v<(0.1+0.05*GLITCHs) )\n    \tuv1 *= mix( 1.0, 1.5, GLITCH );\n    \n    if (rnd0v>0.5 && rnd0v<0.5+0.05*GLITCHs)\n    \tuv1 *= mix( 1.0, 0.5, GLITCH );\n    \n    return uv1;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy; \n    \n    //fragColor = texture( iChannel0, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel1, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel2, fragCoord.xy / iResolution.xy ); return;\n    //fragColor = texture( iChannel3, fragCoord.xy / iResolution.xy ); return;\n\n    //TODO:\n    {\n        vec2 target_uv = uv43_from_fragcoord( fragCoord.xy, iResolution.xy );\n        if ( target_uv.x > 1.0 )\n        {\n            fragColor = vec4(0,0,0,1); return;\n        }\n        //fragColor = vec4( target_uv, 0, 1); return;\n    }\n\n    float rnd0, GLITCH;\n    vec2 uv1 = calc_glitch_uv( ssuv, rnd0, GLITCH );\n    \n\tfragColor = shampain_glitch( uv1, mix( 0.0, rnd0*rnd0, sat(GLITCH-0.2) ), rnd0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uint texw = 16u;\nconst uint texh = 16u;\n\nvec2 idx_to_ofs( uint idx )\n{\n    return vec2( float(idx % texw)/float(texw), float(idx/texw)/float(texh) );\n}\n\n#define _A (11*16+1)\n#define _B (11*16+2)\n#define _C (11*16+3)\n#define _D (11*16+4)\n#define _E (11*16+5)\n#define _F (11*16+6)\n#define _G (11*16+7)\n#define _H (11*16+8)\n#define _I (11*16+9)\n#define _J (11*16+10)\n#define _K (11*16+11)\n#define _L (11*16+12)\n#define _M (11*16+13)\n#define _N (11*16+14)\n#define _O (11*16+15)\n#define _P (10*16+0)\n#define _Q (10*16+1)\n#define _R (10*16+2)\n#define _S (10*16+3)\n#define _T (10*16+4)\n#define _U (10*16+5)\n#define _V (10*16+6)\n#define _W (10*16+7)\n#define _X (10*16+8)\n#define _Y (10*16+9)\n#define _Z (10*16+10)\n\n// #define _s = star\n#define _h (13*16+3)\n// #define _c = colon\n\n#define __ (16*5+13)\n\n#define _0 (16*12+0)\n#define _1 (16*12+1)\n#define _2 (16*12+2)\n#define _3 (16*12+3)\n#define _4 (16*12+4)\n#define _5 (16*12+5)\n#define _6 (16*12+6)\n#define _7 (16*12+7)\n#define _8 (16*12+8)\n#define _9 (16*12+9)\n\n// C Y B E R P U N K\n// E R R O R\n\nuint map_idx( int screen_idx, float time )\n{\n    //return uint(screen_idx);\n    \n    int luterr[40*30] = int[](\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,__,_A,_N,__,_E,_X,_C,_E,_P,_T,_I,_O,_N,__,_O,_C,_C,_U,_R,_R,_E,_D,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,_C,_P,_U,__,__,__,__,_T,_Y,_R,_E,_L,_L,_C,_O,_R,_E,_2,_0,_2,_0,__,__,__,__,__,__,__,\n        __,_E,_X,_C,_E,_P,_T,_I,_O,_N,__,_T,_Y,_P,_E,__,__,__,__,_P,_R,_E,_F,_E,_T,_C,_H,__,_A,_B,_O,_R,_T,__,__,__,__,__,__,__,\n        __,__,__,_F,_A,_U,_L,_T,__,_S,_T,_A,_T,_U,_S,__,__,__,__,_D,_E,_B,_U,_G,__,_E,_V,_E,_N,_T,__,__,__,__,__,__,__,__,__,__,\n        _C,_U,_R,_R,_E,_N,_T,__,_P,_R,_O,_C,_E,_S,_S,__,__,__,__,_F,_S,__,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,__,\n        _R,_0,__,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_2,_0,_0,__,__,__,_R,_1,__,__,__,__,__,__,__,_1,_F,_F,_8,_2,_5,_8,_0,__,__,\n        _R,_2,__,__,__,__,__,__,__,__,_0,_0,_1,_5,_0,_A,_A,_0,__,__,__,_R,_3,__,__,__,__,__,__,__,_0,_0,_6,_4,_2,_5,_9,_8,__,__,\n        _R,_4,__,__,__,__,__,__,__,__,_1,_F,_F,_8,_2,_4,_8,_0,__,__,__,_R,_5,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        _R,_6,__,__,__,__,__,__,__,__,_F,_F,_F,_7,_B,_B,_5,_C,__,__,__,_R,_7,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_2,__,__,\n        _R,_8,__,__,__,__,__,__,__,__,_0,_0,_0,_0,_0,_0,_2,_4,__,__,__,_S,_P,__,__,__,__,__,__,__,_F,_F,_4,_0,_F,_C,_B,_0,__,__,\n        _L,_R,__,__,__,__,__,__,__,__,_F,_F,_F,_2,_3,_B,_4,_C,__,__,__,_P,_C,__,__,__,__,__,__,__,_D,_E,_A,_D,_B,_E,_E,_F,__,__,\n        _C,_P,_S,_R,__,__,__,__,__,__,_8,_0,_0,_0,_0,_1,_1,_3,__,__,__,_F,_P,_E,_X,_C,__,__,__,__,_0,_0,_0,_0,_0,_0,_0,_0,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _S,_T,_A,_C,_K,_D,_U,_M,_P,__,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_B,_0,__,__,_D,_8,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_B,_8,__,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,_9,_C,__,_0,_1,__,_F,_2,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_C,_0,__,__,_F,_F,__,_6,_F,__,_0,_0,__,_0,_4,__,_4,_C,__,_C,_1,__,_F,_9,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_C,_8,__,__,_C,_4,__,_F,_C,__,_4,_0,__,_0,_0,__,_1,_8,__,_5,_C,__,_F,_7,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_D,_0,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,_F,_D,__,_4,_0,__,_F,_F,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_D,_8,__,__,_4,_C,__,_5,_C,__,_F,_7,__,_E,_E,__,_8,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_E,_0,__,__,_0,_0,__,_7,_0,__,_0,_0,__,_2,_E,__,_0,_A,__,_4,_0,__,_D,_5,__,_E,_E,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_E,_8,__,__,_F,_8,__,_B,_0,__,_1,_8,__,_F,_F,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_F,_0,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_F,_F,__,_0,_0,__,_0,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_C,_F,_8,__,__,_0,_0,__,_0,_0,__,_0,_0,__,_1,_F,__,_4,_C,__,_1,_0,__,_0,_0,__,_0,_0,__,__,__,__,__,\n        _h,__,_F,_F,_4,_0,_F,_D,_0,_0,__,__,_0,_1,__,_0,_0,__,_0,_0,__,_0,_0,__,_1,_C,__,_5,_C,__,_F,_7,__,_F,_F,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__\n    );\n    \n    int lut[40*30] = int[](\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __\n    );\n\n\t//note: https://www.dafont.com/5x5.font\n    int lut_cancelled[40*30] = int[] (\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K,__, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        __,__,__,__,__,__,__,__,__,__,_h,_h,__,__,_h,_h,_h,__,_h,_h,__,__,_h,_h,_h,__,_h,__,_h,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,_h,__,_h,__,_h,__,_h,__,_h,__,__,_h,__,__,_h,__,_h,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,_h,__,__,_h,__,_h,__,_h,_h,__,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,__,__,_h,_h,_h,__,_h,__,_h,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,_h,__,__,__,_h,__,_h,__,_h,__,_h,__,__,_h,__,__,__,_h,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n    \t__,__,_h,_h,_h,__,_h,_h,_h,__,_h,__,__,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,__,__,__,_h,__,__,__,_h,_h,_h,__,_h,_h,_h,__,__,\n    \t__,__,_h,__,__,__,_h,__,_h,__,_h,_h,__,_h,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,_h,__,\n    \t__,__,_h,__,__,__,_h,__,_h,__,_h,__,_h,_h,__,_h,__,__,__,_h,_h,__,__,_h,__,__,__,_h,__,__,__,_h,_h,__,__,_h,__,__,_h,__,\n    \t__,__,_h,__,__,__,_h,_h,_h,__,_h,__,_h,_h,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,__,_h,__,__,_h,__,\n    \t__,__,_h,_h,_h,__,_h,__,_h,__,_h,__,__,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,_h,_h,_h,__,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        _h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,_h,__,\n        __,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        \n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,        \n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __,\n        _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __, _C,_Y,_B,_E,_R,_P,_U,_N,_K, __\n    );\n        \n    int ii = screen_idx % (40*30);\n    uint i0 = uint( luterr[ ii ] );\n    uint i1 = uint( lut[ ii ] );\n\t//uint i2 = uint( lut_cancelled[ii] ); return i2;\n    \n    float t0 = clamp( time-30.0 + 0.25*float(screen_idx)/(40.0*30.0), 0.0, 1.0 );\n    uint idx = uint( mix( float(i0), float(i1), t0 ) );\n    \n    float t1 = clamp( time-32.0 + 0.25*float(screen_idx)/(40.0*30.0), 0.0, 1.0 );\n    idx = uint( mix( float(idx), float(__), t1 ) );\n    \n    return idx;\n}\n\nvec4 render_text( vec2 ssuv, vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n\n    float in_time = mod( iTime, 40.0 );\n\n    const uint w = 40u;\n    const uint h = 30u;\n    int idx = int( ssuv.x * float(w) ) + int(w) * int((1.0-ssuv.y)*float(h));\n    //fragColor = vec4( vec3(idx)/float(w*h), 1.0); return;\n    \n    vec2 luv = fract( ssuv * vec2(w,h) );\n    luv = luv / vec2(texw, texh);\n\n    float frq = 10.0 + 5.0 * hashf( uint(idx) );\n    \n    uint rnd_idx_u = hash( uint(idx) + hash( uint(idx) + uint(float(iFrame+1000)/frq)) );\n    float rnd_idx = toFloat( rnd_idx_u );\n    \n    float rnd_t = hashf( uint(1337.0*in_time) );\n    \n    float timeScale = 0.5;\n    uint rnd = hash( uint(idx) + uint( timeScale * in_time ) );\n    float rndf = toFloat( rnd );\n    \n    uint scl = texw*texh;\n    uint letteridx = map_idx(idx, in_time);\n    \n    float time_total_s = 20.0;\n    float time_per_idx_s = float(w*h) / time_total_s;\n    const float speed = 175.0;\n    float time = (in_time+0.75)*speed;\n\n    //int curidx = int(time) % int(w*h);\n    int curidx = min( int(time), int(w*h + 80u) );\n    float curidx_t = float(curidx) * time_per_idx_s;\n    \n    float idx_t = float(idx) * time_per_idx_s;\n\n    float dt = curidx_t - idx_t;\n    \n    float glitchmask = dt / (80.0*time_per_idx_s);\n    \n    glitchmask = min( glitchmask, 0.995 );\n    \n    float glitch = step( glitchmask, rnd_idx );\n\n    float m_visible = (dt>-0.5) ? 1.0 : 0.0;\n    \n    if ( glitch > 0.5 )\n    {\n        letteridx = hash( uint(idx*1337) + uint(iFrame/2) ) % (w*h);\n        \n        m_visible += step(rnd_idx, 0.001);\n    }\n    \n    vec2 ofs = idx_to_ofs( letteridx );\n\n    vec3 s = textureLod( iChannel0, ofs + luv, 0.0 ).rgb;\n    float txtmask = remap( s.x, 0.0, 0.8, 1.0, 0.0 );\n    \n    float v = txtmask;\n    \n    float p0 = 0.0;\n    {\n        const float PI = 3.1415926435;\n        const float waves = 44.0;\n        const int NUM_ITER = 8;\n        //note: approx square-wave\n        for ( int i=1; i<NUM_ITER; i+=2 )\n             p0 += (float(i)/float(NUM_ITER)) * sin(float(i)*PI * (waves*ssuv.y) );\n        p0 = remap( p0, 0.0, 1.0, 0.6, 1.0 );\n    }\n    \n    v = 1.0 - v;\n    v = min( v, p0 );\n    \n    if ( dt <= 3.5 && dt > -0.1 )\n    {\n        v = 1.0 - v * mix( 0.1, 1.0, rnd_t );\n        v *= 2.0;\n    }\n    \n    v *= m_visible;\n\n    vec4 c = vec4( vec3(v), 1.0 );\n\n    //note: feedback\n    if ( iFrame > 0 )\n    {\n        vec4 prev = texture( iChannel1, fragCoord.xy/iResolution.xy );\n        c = mix( c, prev, 0.5 );\n    }\n\n    \n    fragColor = c;\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4( fragCoord/iResolution.xy, 0, 1.0); return;\n\n    vec2 target_uv = uv43_from_fragcoord( fragCoord.xy, iResolution.xy );\n    if ( target_uv.x > 1.0 )\n    {\n        fragColor = vec4(0,0,0,1); return;\n    }\n\n    vec2 ssuv = target_uv; //fragCoord/iResolution.xy;\n \n    fragColor = render_text( ssuv, fragCoord );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//note: from https://www.shadertoy.com/view/WttXWX , bias: 0.020888578919738908 = minimal theoretic limit\nuint hash(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat toFloat( uint x )\n{\n    return float(x) / 4294967296.0;\n    //return uintBitsToFloat(x) / 4294967296.0;\n}\nfloat hashf( uint x )\n{\n    return toFloat( hash( x ) );\n}\n\nfloat hashf( float x )\n{\n    return hashf( floatBitsToUint( x ) );\n}\n\nfloat remap( float x, float imn, float imx, float omn, float omx )\n{\n    return omn + (omx-omn)*clamp(x-imn, 0.0, 1.0) / (imx-imn);\n}\n\nvec2 uv43_from_fragcoord( vec2 fc, vec2 res )\n{\n    //float ss_aspect = res.x / res.y;\n    const float target_aspect = 4.0/3.0;\n    vec2 target_res = vec2( res.y * target_aspect, res.y );\n    vec2 target_uv = fc.xy / target_res;\n\n    return target_uv;\n}\n\nfloat mytrunc( float x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\nvec2 mytrunc( vec2 x, float num_levels )\n{\n\treturn floor(x*num_levels) / num_levels;\n}\n\nvec2 mytrunc( vec2 x, vec2 num_levels )\n{\n\treturn floor(x*num_levels+0.5) / num_levels;\n}\n\n\n//note: input [0;1]\nvec3 spectrum_offset_rgb( float t )\n{\n    float t0 = 3.0 * t - 1.5;\n\treturn clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);\n}\n\nfloat sat( float t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nvec2 sat( vec2 t ) {\n\treturn clamp( t, 0.0, 1.0 );\n}\n\n//remaps inteval [a;b] to [0;1]\nfloat remap  ( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\n//note: /\\ t=[0;0.5;1], y=[0;1;0]\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\n//note: [0;1]\nfloat rand( vec2 n ) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n//note: [-1;1]\nfloat srand( vec2 n ) {\n\treturn rand(n) * 2.0 - 1.0;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1337*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 2.0 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(0,blurdist_px);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel0, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n \n    //note: feedback\n    if ( iFrame > 0 )\n    {\n        vec3 prev = texture( iChannel1, ssuv ).rgb;\n        sumc = mix( sumc, prev, 0.9 );\n    }\n\n    \n    fragColor = vec4(sumc, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//TODO: should probably also downsample...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1337*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 50.0; //0.5 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(0,blurdist_px);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel0, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n    \n    \n    fragColor = vec4(sumc, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ssuv = fragCoord.xy / iResolution.xy;\n        \n    float rnd = hashf( uint(1227*iFrame) + uint(fragCoord.y) + hash(uint(fragCoord.x)) );\n    \n    const int NUM_SAMPLES = 8;\n    float blurdist_px = 100.0; //0.5 * float( textureSize(iChannel0, 0).y );\n    vec2 blurdir_px = vec2(blurdist_px, 0);\n    vec2 stepvec_px = blurdir_px / float(NUM_SAMPLES);\n    \n    //TODO: convert to normalized\n    vec2 p = fragCoord.xy;\n    p -= 0.5 * blurdir_px;\n    p += blurdir_px * rnd / float(NUM_SAMPLES);\n    \n    vec3 sumc = vec3(0.0);\n    float sumw = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        vec2 uv = p / iResolution.xy;\n        float w = 1.0;\n    \tsumc += w * texture( iChannel2, uv ).rgb; //TODO: black if outside\n        sumw += w;\n        p += stepvec_px;\n    }\n    sumc /= sumw;\n\n    vec3 s = sumc;\n\n    vec3 sA = texture( iChannel0, ssuv).rgb;\n    vec3 sB = texture( iChannel1, ssuv).rgb;\n    \n    s = sA + sB + sumc;\n\n    \n    fragColor = vec4(s, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}