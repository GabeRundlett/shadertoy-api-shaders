{
    "Shader": {
        "info": {
            "date": "1609188360",
            "description": "This is a modified version of Shane's [url=https://www.shadertoy.com/view/MlG3zh]\"Canyon Pass\"[/url] shader, using an [url=https://www.shadertoy.com/view/XdycWy]\"accelerated raymarching\"[/url] technique to improve the framerate.",
            "flags": 32,
            "hasliked": 0,
            "id": "tt3yWM",
            "likes": 10,
            "name": "Canyon pass (fast version)",
            "published": 3,
            "tags": [
                "raymarching",
                "bump",
                "rock",
                "canyon",
                "frost",
                "moss"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "/*\n\n\tCanyon Pass\n\t-----------\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up.\n#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic-picture focus-adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*2.5;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 3.5 + dot(op, vec3(.222))*.3; // Ground plane, slightly perturbed.\n \n    p += (op - .25)*.3; // Adding some triangular perturbation.\n   \n\tp = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.01; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.0, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.25) accum += (.25-abs(h))/24.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.0, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel1, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.0, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0, 0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-10, 20, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\t//float t = trace(camPos, rd);\n    vec4 depthmap = depth_map(fragCoord);\n    float t = length(depthmap.xyz-camPos);\n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n        //vec4 depthmap = depth_map(fragCoord);\n    \t// Surface position and surface normal.\n\t    vec3 sp = depthmap.xyz;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = depthmap.w;\n        \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.007);\n    \t\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n        \n        // Ambient light, due to light bouncing around the the canyon.\n\t    float ambience = 0.35*ao + fre*fre*.25;\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n\n        // Tones down the pinkish limestone\\granite color.\n        //texCol *= mix(vec3(.7, 1, 1.3), vec3(1), snNoBump.y*.5 + .5);\n        \n        #ifdef MOSS\n        // Some quickly improvised moss.\n        texCol = texCol*mix(vec3(1), vec3(.5, 1.5, 1.5), abs(snNoBump));\n        texCol = texCol*mix(vec3(1), vec3(.6, 1, .5), pow(abs(sn.y), 4.));\n        #else\n        // Adding in the white frost. A bit on the cheap side, but it's a subtle effect.\n        // As you can see, it's improvised, but from a physical perspective, you want the frost to accumulate\n        // on the flatter surfaces, hence the \"sn.y\" factor. There's some Fresnel thrown in as well to give\n        // it a tiny bit of sparkle.\n        texCol = mix(texCol, vec3(.35, .55, 1)*(texCol*.5+.5)*vec3(2), ((snNoBump.y*.5 + sn.y*.5)*.5+.5)*pow(abs(sn.y), 4.)*texCol.r*fre*4.);\n        #endif      \n\n        \n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);// + vec3(.2, .5, 1)*spec;\n        \n        // A bit of accumulated glow.\n        sceneCol += texCol*((sn.y)*.5+.5)*min(vec3(1, 1.15, 1.5)*accum, 1.);  \n     \n        \n        // Adding a touch of Fresnel for a bit of glow.\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 4.)*.5;\n        \n        \n        // Faux environmental mapping. Adds a bit more ambience.        \n        vec3 sn2 = snNoBump*.5 + sn*.5;\n        vec3 ref = reflect(rd, sn2);//\n        vec3 em = envMap(ref/2., sn2);\n        ref = refract(rd, sn2, 1./1.31);\n        vec3 em2 = envMap(ref/8., sn2);\n        //sceneCol += ((sn.y)*.25+.75)*sceneCol*(em + em2);\n        sceneCol += sceneCol*2.*(sn.y*.25+.75)*mix(em2, em, pow(fre, 4.));\n\n\n\t    // Shading. Adding some ambient occlusion to the shadow for some fake global lighting.\n        sceneCol *= atten*min(shading + ao*.35, 1.)*ao;\n\t   \n\t\n\t}\n    \n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(.6, .8, 1.2)*(rd.y*.5 + .5);\n    #ifdef MOSS\n    fog *= vec3(1, 1.25, 1.5);\n    #else\n    #ifdef HOT\n    fog *= 4.;\n    #endif\n    #endif\n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n    \n    \n    //sceneCol *= vec3(.5, .75, 1.5); // Nighttime vibe.\n    #ifndef MOSS\n    #ifdef HOT\n    float gr = dot(sceneCol, vec3(.299, .587, .114)); // Grayscale.\n    // A tiny portion of the original color blended with a very basic fire palette.\n    sceneCol = sceneCol*.1 + pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16));\n    // Alternative artsy look. Comment out the line above first.\n    //sceneCol = mix(sceneCol, pow(min(vec3(1.5, 1, 1)*gr*1.2, 1.), vec3(1, 3, 16)), -uv.y + .5);\n    #endif\n    #endif\n    \n    // Subtle, bluish vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneCol = mix(vec3(0, .1, 1), sceneCol, pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.15 + .85);\n    \n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n\tCanyon Pass\n\t-----------\n\n\tCombining some cheap distance field functions with some functional and texture-based bump \n\tmapping to carve out a rocky canyon-like passageway.\n\n\tThere's nothing overly exciting about this example. I was trying to create a reasonably\n    convincing looking rocky setting using cheap methods.\n\n\tI added in some light frosting, mainly to break the monotony of the single colored rock.\n\tThere's a mossy option below, for anyone interested. Visually speaking, I find the moss more\n\tinteresting, but I thought the frost showed the rock formations a little better. Besides,\n\tI'd like to put together a more dedicated greenery example later.\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Extra settings. Use one or the other. The MOSS setting overrides the HOT setting.\n// Mossy setting. Better, if you want more color to liven things up.\n#define MOSS \n// Hot setting. It represents 2 minutes of post processing work, so it's definitely nothing to excited about. :)\n//#define HOT\n\n// Coyote's snippet to provide a virtual reality element. Really freaky. It gives the scene \n// physical depth, but you have to do that magic-picture focus-adjusting thing with your eyes.\n//#define THREE_D \n\n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    //vec3 col = mix(vec3(.7, 1, 1.3), vec3(1), n.y*.5 + .5);\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);//*col;\n}\n\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n\n// 3D cellular tile function.\nfloat cellTile(in vec3 p){\n   \n    vec4 d; \n    \n    // Plot four objects.\n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    d.xy = min(d.xz, d.yw);\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    return  min(d.x, d.y)*2.5;\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n// https://www.shadertoy.com/view/4ts3z2\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){\n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n\n// A fake noise looking sinusoial field - flanked by a ground plane and some walls with\n// some triangular-based perturbation mixed in. Cheap, but reasonably effective.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z); // Wrap the passage around\n    \n    vec3 w = p; // Saving the position prior to mutation.\n    \n    vec3 op = tri(p*.4*3. + tri(p.zxy*.4*3.)); // Triangle perturbation.\n   \n    \n    float ground = p.y + 3.5 + dot(op, vec3(.222))*.3; // Ground plane, slightly perturbed.\n \n    p += (op - .25)*.3; // Adding some triangular perturbation.\n   \n\tp = cos(p*.315*1.41 + sin(p.zxy*.875*1.27)); // Applying the sinusoidal field (the rocky bit).\n    \n    float canyon = (length(p) - 1.05)*.95 - (w.x*w.x)*.01; // Spherize and add the canyon walls.\n    \n    return min(ground, canyon);\n\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    //return (cellTile(p/1.5))*.66 + (cellTile(p*2./1.5))*.34;\n    \n    return cellTile(p/1.5);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\nfloat accum;\n\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n    \n    accum = 0.;\n\n    float t = 0.0, h;\n    for(int i = 0; i < 160; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*(t*.25 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h;//*.7;\n        \n        if(abs(h)<0.25) accum += (.25-abs(h))/24.;///(1.+t);//.0005/abs(h);\n        //if(abs(h)<0.25)accum += (.25-abs(h))*vec3(3, 2, 1)/4.*n3D((ro+rd*t)*16. - vec3(0, 0, 1)*iTime*1.);\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n/*\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO2( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n*/\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 p, in vec3 n){\n\t\n    float sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.001, -0.001); \n    return normalize(e.xyy*map(p + e.xyy) + e.yyx*map(p + e.yyx) + e.yxy*map(p + e.yxy) + e.xxx*map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.0, 1.0); \n}\n\n//////\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// Anyway, the idea is very simple. Obtain the reflected (or refracted) ray at the surface \n// hit point, then index into a repeat texture in some way. It can be pretty convincing \n// (in an abstract way) and facilitates environment mapping without the need for a cube map, \n// or a reflective pass.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\n\nvec3 envMap(vec3 rd, vec3 n){\n    \n    return tex3D(iChannel0, rd, n);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    \n    #ifdef THREE_D\n    float sg = sign(fragCoord.x - .5*iResolution.x);\n    uv.x -= sg*.25*iResolution.x/iResolution.y;\n    #endif\n\t\n\t// Camera Setup.\n    vec3 camPos = vec3(0.0, 0.0, iTime*4.); // Camera position, doubling as the ray origin.\n\n\tvec3 lookAt = camPos + vec3(0, 0, 0.25);  // \"Look At\" position.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(-10, 20, -20);\n\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n    \n    \n    #ifdef THREE_D\n    camPos.x -= sg*.15; lookAt.x -= sg*.15; lightPos.x -= sg*.15;\n    #endif\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333;//PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls. I use them as a debugging device, but they can be used to look around. \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/\n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);   \n    \n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        \n        \n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(sp, sn, .5);\n        \n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, .1);//(-sign(sn.y)*.15+.85)*\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos - sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n        fragColor = vec4(sp,shading);\n\t\n\t}\n    \n\t}\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define image_scale 4.0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}