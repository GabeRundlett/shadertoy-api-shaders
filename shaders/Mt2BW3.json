{
    "Shader": {
        "info": {
            "date": "1517431567",
            "description": "Needs more bloom! Also, may be a little bit too slow.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mt2BW3",
            "likes": 2,
            "name": "Night City ",
            "published": 3,
            "tags": [
                "city"
            ],
            "usePreview": 0,
            "username": "AlexM",
            "viewed": 711
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragTexCoord = fragCoord / iResolution.xy;\n    vec4 frag1 = texture(iChannel1, fragTexCoord);\n    vec4 frag2 = texture(iChannel0, fragTexCoord);\n    fragColor = vec4(frag1.xyz+frag2.xyz*0.8, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.141592653589793f \n\n#define MAXT 140.0f\n\n//const float MAXT = 100.0f;\nconst float WORMHOLE_EPS = 0.01;\nconst float STARS_EPS = 0.0001;\n\nconst float FOGHEIGHT = -0.501; // background fog height. \nconst float FOGFADEHEIGHT = 0.20; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.061, 0.2, 0.196);\nconst float FOGDENSITY = 0.010; \nconst float FOGEXP = 3.00; \nconst vec3  SKYCOLOR = vec3(0.082, 0.149, 0.137);\nconst float LUM_THRESHOLD = 0.27;\n\nconst float BLOCK_CHANCE = 0.95;\nconst vec3 BLOCK_SCALE = vec3(7.0, 0.0, 7.0);\n\nconst vec3 WINDOW_COL1 = vec3(0.862, 0.874, 0.427);\nconst vec3 WINDOW_COL2 = vec3(0.709, 0.874, 0.486);\nconst vec3 WINDOW_OFF_COL = vec3(0.176, 0.164, 0.121);\nconst vec3 GROUND_COL = vec3(0.105, 0.098, 0.074);\nconst vec3 BUILDING_ROOF_COL = vec3(0.125, 0.098, 0.074);\nconst vec3 BUILDING_FRAME_COL = vec3(0.2);\nconst vec3 BLOCK_FRAME_COL = vec3(0.1);\nconst vec3 WATER_COL = vec3(0.137, 0.113, 0.023);\nconst vec3 ROAD_COL1 = vec3(0.941, 0.964, 0.452);\nconst vec3 ROAD_COL2 = vec3(0.976, 0.894, 0.662);\n\nstruct TraceResult {\n    bool hit;\n    float rayt;\n    vec3 color; \n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in float n) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n    vec3 u = x*x*(3.0-2.0*x);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(fg, 0.0, 1.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,vec3(0.0)));\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) - n.w;\n}\n\nfloat sdCylinder( vec3 p, vec3 c ) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat csgAdd(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat csgSubtract(float d1, float d2) {\n    return max(-d1,d2);\n}\n\nfloat csgIntersect(float d1, float d2) {\n    return max(d1,d2);\n}\n\n// Stol... borrowed from hg_sdf (http://mercury.sexy/hg_sdf/)\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c  = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat fbm(vec3 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitude * noise(p*frequency);\n        p *= 2.0;\n        amplitude *= 0.2;\n        frequency *= 1.9;\n    }\n    return value;\n}\n\nvec4 building(vec3 p, vec3 cell, float n1) {\n    vec3 pm = p;\n    vec3 bs = vec3(0.5, ceil((random(cell.x*8201.0) + random(cell.z*4123.0) )* 9.0 + 4.0), 0.5);\n    bs += vec3(BLOCK_SCALE.x, 0., BLOCK_SCALE.z)*0.25;\n    bs.y = (random(cell.xz*233.00) < BLOCK_CHANCE) ? bs.y : 0.0; // will current cell contain the building?\n\n    float a = sdBox(p, bs);\n    float b = sdBox(p, bs+vec3(-0.15, (bs.y==0.0)?0.0:0.5, -0.15));\n    float g = csgAdd(a, b);\n\n    vec3 q = mod(p*bs, 1.0);\n    vec3 scale = bs*vec3(0.5,0.25,0.5);\n    float occ = clamp(random(cell.xz), 0.60,0.70); // occupancy of the building in the cell.\n    occ = step(occ,noise(floor(p*scale)+iTime*random(cell.x*cell.z)*0.02));  //state of the building window\n\n    vec3 window_col = (random(cell.x*cell.z*3433.0)< 0.5) ? WINDOW_COL1 : WINDOW_COL2; \n    vec3 color = (occ == 0.0) ? WINDOW_OFF_COL : window_col + n1*0.5;\n\n    // window frames\n    color = (q.x < 0.1 || q.x > 0.9) && (q.z < 0.1 || q.z > 0.9) ? BUILDING_FRAME_COL : color;\n    color = abs(pm.y-bs.y)<0.01 ? WINDOW_OFF_COL : color; // don't want windows on the top of the building to bleed through.\n    color = g == b ? BUILDING_ROOF_COL : color;\n    color = bs.y == 0.0 ? GROUND_COL : color;\n    return vec4(color, csgAdd(a,b));\n}\n\n\nvec4 map(vec3 p) {\n    float n = noise(p+iTime*2.5);\n\n    vec3 pb = p;\n\tvec3 pc = p;\n    vec3 pr = p - BLOCK_SCALE*0.5;\n    vec3 ph = p - BLOCK_SCALE*3.0;\n\n    vec3 cell = pMod3(pb, BLOCK_SCALE);\n\tpMod3(pc, BLOCK_SCALE*6.0);\n    pMod3(pr, BLOCK_SCALE*1.0);\n    pMod3(ph, BLOCK_SCALE*6.0);\n\n    float road_n = sdCylinder(pr.xzy, vec3(+0.0,0.0,0.25));\n    float road_w = sdCylinder(pr.zxy, vec3(+0.0,0.0,0.25));\n    float hwy_n  = sdCylinder(ph.xzy, vec3(+0.0,0.0,0.5));\n    float hwy_w  = sdCylinder(ph.zxy, vec3(+0.0,0.0,0.5));\n    float canal_ns = sdBox(pc,vec3(BLOCK_SCALE.z*200.0, 1000.0, BLOCK_SCALE.z*0.5-0.25));\n    float canal_we = sdBox(pc,vec3(BLOCK_SCALE.x*0.5-0.25, 1000.0, BLOCK_SCALE.x*200.0));\n    vec4 _building = building(pb, cell, n);\n    float ground = sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0));\n    float water  = sdPlane(p, vec4(0.0, 1.0, 0.0, -2.0)) + fbm(p*0.25+iTime*0.15)*0.1;\n\n    float dst = csgAdd(1.0, _building.w);\n#if 0\n    // bounding box for the building. Need this to prevent overstepping due to variable \n    // size of buildings. Disable it as no bounding box works well for girrent camera position and is twice as fast... :).\n    float bb = -sdBox(pm, vec3(BLOCK_SCALE.x, 90000.0, BLOCK_SCALE.z)*0.501)*5.0;\n    dst = csgAdd(bb, dst);\n#endif\n    dst = csgAdd(ground, dst);\n    dst = csgAdd(road_n, dst);\n    dst = csgAdd(road_w, dst);\n    dst = csgSubtract(canal_ns, dst);\n\tdst = csgSubtract(canal_we, dst);\n\n    hwy_n = csgIntersect(hwy_n, canal_ns);\n    hwy_w = csgIntersect(hwy_w, canal_we);\n    dst = csgAdd(hwy_n, dst);\n    dst = csgAdd(hwy_w, dst);\n    dst = csgAdd(water, dst);\n\n    vec3 color = GROUND_COL; \n    color = (dst == _building.w) ? _building.xyz : color;\n    \n    if (dst == road_n || dst == road_w || dst == hwy_n || dst == hwy_w) {\n        float dir = (dst == road_n || dst == hwy_n)? p.z : p.x; \n        color = ROAD_COL1 + sin(dir * 2.0 + iTime * 0.25) * ROAD_COL2 + n;\n    }\n\n    color = (dst == -canal_ns || dst == -canal_we) ? BLOCK_FRAME_COL : color;\n    color = (dst == water) ? WATER_COL : color;\n\n    return vec4(color, dst);\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0, vec3(0.0));\n    float t = 0.02;\n    float tmax = MAXT; \n\n    for (; t < MAXT; ) {\n        vec3 rp = ro + rd * t;\n        vec4 tr = map(rp);\n        if (tr.w<0.0010) {\n            traceResult = TraceResult(true, t, tr.xyz);\n            break;\n        }\n        t += tr.w;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy).w-map(p-eps.xyy).w;\n    float y = map(p+eps.yxy).w-map(p-eps.yxy).w;\n    float z = map(p+eps.yyx).w-map(p-eps.yyx).w;\n    return normalize(vec3(x,y,z));\n}\n\nfloat fog(float dist) {\n    return  1.0 - 1.0/exp(pow(dist*FOGDENSITY, FOGEXP));\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat calcPixelBrightness(vec3 color) {\n    const vec3 luminance = vec3(0.2126, 0.7152, 0.0722);\n    return dot(color, luminance) > LUM_THRESHOLD ? 1.0 : 0.0; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord/iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd=rotateX(-0.8+iMouse.y*0.00025)*rd;\n    rd=rotateY(0.9-iMouse.x*0.00025)*rd;\n    rd = normalize(rd);\n\n    vec3 ro = iTime * 0.9 * normalize(vec3(-1.0, 0.0, 1.0));\n    ro.y = 50.0;\n\n    vec3 color = sky(ro, rd);\n    TraceResult traceResult = trace(ro, rd);\n    if (traceResult.hit) {\n        color =  traceResult.color;\n        vec3 rp = ro+traceResult.rayt*rd;\n        vec3 n = calcNormal(rp);\n        if (traceResult.color == WATER_COL) {\n            vec3 rrd = reflect(rd, n);\n            TraceResult reflTraceResult = trace(rp, rrd);\n            color = reflTraceResult.hit ? color + reflTraceResult.color : color + sky(rp, rrd);\n        }\n        color = mix(color, FOGCOLOR, fog(traceResult.rayt));\n    }\n\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, calcPixelBrightness(color)); \n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float blur_size = 0.00024;\nfloat weights[5] = float[](0.72508352, 0.19117, 0.155965, 0.2292, 0.18771);\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec2 texel_size = 1.0/iResolution.xy;\n    \n    vec2 fragTexCoord = fragCoord / iResolution.xy;\n\n    vec4 fragment = texture(iChannel0,  fragTexCoord);\n    vec3 color = fragment.xyz * weights[0] * fragment.w; \n\n    vec2 dir = vec2(blur_size, 0.0);\n\n    for (int i = 1; i < 5; i++) {\n        vec4 frag1 = texture(iChannel0, fragTexCoord+dir*float(i));\n        vec4 frag2 = texture(iChannel0, fragTexCoord-dir*float(i));\n\n        color += frag1.xyz * weights[i] * frag1.w;\n        color += frag2.xyz * weights[i] * frag2.w;\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const float blur_size = 0.00024;\nfloat weights[5] = float[](0.72508352, 0.19117, 0.155965, 0.2292, 0.18771);\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   \n    vec2 texel_size = 1.0/iResolution.xy;\n    \n    vec2 fragTexCoord = fragCoord / iResolution.xy;\n\n    vec4 fragment = texture(iChannel0,  fragTexCoord);\n    vec3 color = fragment.xyz * weights[0] * fragment.w; \n\n    vec2 dir = vec2(0.0, blur_size);\n\n    for (int i = 1; i < 5; i++) {\n        vec4 frag1 = texture(iChannel0, fragTexCoord+dir*float(i));\n        vec4 frag2 = texture(iChannel0, fragTexCoord-dir*float(i));\n\n        color += frag1.xyz * weights[i] * frag1.w;\n        color += frag2.xyz * weights[i] * frag2.w;\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}