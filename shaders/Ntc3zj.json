{
    "Shader": {
        "info": {
            "date": "1636340209",
            "description": "It is not world tessellation day today (2021 November 7th). I am releasing the code on shadertoy because I am bored.\n[url]https://twitter.com/C010011012/status/1405775912277188608[/url]\n[url]https://www.instagram.com/p/CQQHrwgjtaU/[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "Ntc3zj",
            "likes": 4,
            "name": "#WorldTessellationDay 2021",
            "published": 3,
            "tags": [
                "tessellation"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 248
        },
        "renderpass": [
            {
                "code": "// Current Code For: #WorldTessellationDay 2021\n// Date: 2021 June 17th\n// Tags: tessellation\n// Description: https://twitter.com/C010011012/status/1405775912277188608\n// https://www.instagram.com/p/CQQHrwgjtaU/\n\n\n// â†“ i know more\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307\n// 816406286 208998628034 8253421170679821480865132823066470938446095505\n#define TAU 6.2831853071795864\n\n// frequency in THz\n#define freqr 430.\n#define freqg 545.\n#define freqb 660.\n\n// samples per frame - each output frame = spf sample-frames blended together equally\n//#define spf 1.\n//const float spf = 30.*1.;\nconst float spf = 1.*1.;\n\n#define iFramef floor(float(iFrame) /spf)\n#define iFramem   mod(float(iFrame), spf)\n\n#define arg mod(  iFramef  /30./1., 1.)\n\n// frameblending version\n//#define arg mod(  float(iFrame)/spf  /30./1., 1.)\n\n// for testing porpoises - will blend all the animations frames\n// e.g. if the animation is a rotating cube the output should look like a blurry cylinder\n// try set spf=3 or 4 and pausing the animation to see how all frames blended equally\n//#define arg ( iFramem/spf )\n\n//\n// sky map\n//\n\n//#define inter_sky vec4(vec3(0.), 1e9)\nconst vec4 inter_sky = vec4(vec3(0.), 1e9);\nfloat sky_map (in float freq, in vec3 d) {\n    #if 0\n    vec3 col = texture(iChannel2, d).rgb;\n    #elif 1\n        vec3 col = vec3(1.);\n        col = vec3(0.);\n    #elif 0\n    vec3 col = vec3(.7, 1., 1.);\n    #else\n    vec3 col = vec3(0., 0., 100./255.);\n    #endif\n    //\n    if (freq == freqr) {\n        return col.r;\n    }\n    else if (freq == freqg) {\n        return col.g;\n    }\n    else if (freq == freqb) {\n        return col.b;\n    }\n}\n\n\n\n\n//\n// intersect primitive shapes\n//\nvec4 inter_sphere (vec3 p, vec3 d, float r) {\n\tfloat bsign = length(p) > r ? -1. : 1.;\n\tvec3 bar = -p;\n\tfloat h = length(bar);\n\tfloat a = h*dot(normalize(bar), d);\n\tfloat o = sqrt(h*h-a*a);\n\tif (dot(d, bar) > 0. && o <= r) {\n\t\tfloat bevel = sqrt(r*r-o*o);\n\t\tvec3 hitp = p+d*(a+bsign*bevel);\n\t\treturn vec4(\n\t\t\tnormalize(hitp)*-bsign,\n\t\t\ta+bsign*bevel\n\t\t);\n\t}\n\treturn inter_sky;\n}\n// plane - one liner lol\n// #define SDF_plane(p, n) ( dot(normalize(p), n)*length(p) )\nfloat SDF_plane (vec3 p, vec3 n) { return dot(normalize(p), n)*length(p); }\n#define inter_plane_short(p, d, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, n) (\\\n//dot(n, d) > 1e-6 ? dot(-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n//\n// SDF\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.48), 0.) )-.015)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n#define inf vec2(1e-4, 0.)\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // test\n    //return inter_sphere(p, d, 1.);\n    //\n    // camp is unmodified p\n    vec3 camp = p;\n    //\n    #if 0\n    // space skip to sphere (.5, .5, .5) r=1.8 (causes bug)\n    vec4 temp;\n    temp = inter_sphere(p-vec3(.5), d, 1.8);\n    if (temp.w >= inter_sky.w) {\n        return inter_sky;\n    }\n    else {\n        if (length(p-vec3(.5)) > 1.8) {\n            p += d*temp.w;\n        }\n    }\n    //return temp;\n    #endif\n    //\n    //\n    float SDFp;\n    //for (int i=0; i<111222; ++i) {\n    //for (int i=0; i<11222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        //if (abs(SDFp) < 1e-1) {\n        if (abs(SDFp) < 5e-4) {\n            return vec4(\n                normalize(\\\n                    vec3(\n                        SDF(p+inf.xyy),\n                        SDF(p+inf.yxy),\n                        SDF(p+inf.yyx)\n                    )-SDFp\n                )*sign(SDFp),\n                length(p-camp)\n            );\n        }\n        p += d*abs(SDFp)*.5;\n        //p += d*abs(SDFp)*.99;\n        //p += d*abs(SDFp);\n        //if (abs(SDFp) > 10.) {\n        // sqrt(3) ~ 1.732\n        if (abs(SDFp) > 1.8) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 16., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1., 10., 6.));\n    //pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p-pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p-pane1c, d, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p-pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        blockhere = qf.x*0.+qf.y*10.+qf.z*10. <= 0.;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\n\n\n\n\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    // mouse pos normalized -1 to 1 y aspect ratio x\n    //\n    vec2 maus = (iMouse.xy-iResolution.xy/2.)/(iResolution.y/2.);\n    //\n    //\n    // view rotation matrices\n    //\n    //#define phi clamp(maus.y*3., -1., 1.)*PI*.5\n    #define phi -atan(1./sqrt(2.) )\n    mat2 zenith = transpose(\n        mat2(\n            cos(phi), cos(PI*.5+phi),\n            sin(phi), sin(PI*.5+phi)\n        )\n    );\n    //#define theta maus.x*TAU\n    #define theta -PI*.75\n    mat2 azimuth = transpose(\n        mat2(\n            cos(theta), cos(PI*.5+theta),\n            sin(theta), sin(PI*.5+theta)\n        )\n    );\n    //\n    //\n    // multisampling loop\n    //\n    fragColor = vec4(0., 0., 0., 1.);\n    // spw - width of multisample grid\n    // spp - number of random jitter/monte carlo integration per sub-pixel thing\n    #define spw 1.\n    #define spp 1.\n    float freq, ox, oy; vec3 rand;\n    //\n    #define numsamples spw*spw*spp\n    for (float samplei=0.; samplei<3.*numsamples; ++samplei) {\n        float samplei2 = samplei;\n        if (mod(samplei, 3.) == 0.) {\n            freq = freqr;\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            freq = freqg;\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            freq = freqb;\n        }\n        samplei2 = floor(samplei2/3.);\n        ox = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        oy = mod(samplei2, spw);\n        samplei2 = floor(samplei2/spw);\n        samplei2 += (float(iFrame)+fragCoord.x)*numsamples;\n        rand = vec3(\n            fract(\n                sin(\n                    mod(\n                        samplei2*1.234567890123,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*10.110010101,\n                        TAU\n                    )\n                )\n            ),\n            fract(\n                sin(\n                    mod(\n                        samplei2*222.222222222,\n                        TAU\n                    )\n                )\n            )\n        );\n        #if 1\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.);\n        #else\n        vec2 screen = (\n            fragCoord.xy+vec2(ox+rand.r, oy+rand.g)/spw-iResolution.xy/2.\n        )/(iResolution.x/2.)*vec2(1., -1.);\n        #endif\n        //\n        //\n        float retina = 0.;\n        float absorb = 1.;\n        //\n        #if 0\n        // perspective\n        vec3 p = vec3(screen.x, screen.y, 0.);\n        vec3 d = normalize(p-vec3(0., 0., -1.));\n        //vec3 p = vec3(0.);\n        //vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n        #else\n        // orthogonal\n        vec3 p = vec3(screen.x, screen.y, 0.)*4.*(sqrt(2.)/2.);///cos(30.*PI/180.);\n        vec3 d = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        p += vec3(0., 0., -12.);\n        //\n        p.zy = zenith*p.zy;\n        d.zy = zenith*d.zy;\n        p.zx = azimuth*p.zx;\n        d.zx = azimuth*d.zx;\n        //\n        d = normalize(d);\n        //p += vec3(0., 2., 0.);\n        //p -= d*20.;\n        //\n        //\n        //\n        //#define numbounces 50.\n        #define numbounces 3.\n        for (float bounces=0.; bounces<numbounces; ++bounces) {\n        //for (float bounces=0.; bounces<1.; ++bounces) {\n            //\n            if (absorb <= .1) {\n                break;\n            }\n            //\n            float samplei3 = bounces;\n            samplei3 += (float(iFrame)+fragCoord.x)*numbounces;\n            //\n            vec3 rand2 = vec3(\n                fract(\n                    sin(\n                        mod(\n                            samplei3*1.234567890123,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*10.110010101,\n                            TAU\n                        )\n                    )\n                ),\n                fract(\n                    sin(\n                        mod(\n                            samplei3*222.222222222,\n                            TAU\n                        )\n                    )\n                )\n            );\n            //\n            vec4 inter_closest = inter_sky;\n            vec4 inter_current;\n            float inter_id;\n            //\n            //#define sphc vec3(cos(arg*TAU), 2.+sin(arg*TAU), 0.)\n            #define tempc vec3(0., 6., 0.)\n            #define tempr 1.\n            //inter_current = inter_sphere(p-tempc, d, tempr);\n            inter_current = inter_sky;\n            //inter_current = inter_SDF(p, d);\n            //inter_current = inter_sky;\n            vec3 tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 1.;\n                 if (length(p-tempc)-tempr < 0.) {\n                //if (SDF(p) < 0.) {\n                    // p is inside sphere - p hits inner shell\n                    inter_id *= -1.;\n                }\n            }\n            #undef tempc\n            #undef tempn\n            //\n            #define tempc vec3(0., -1.1, 0.)\n            #define tempn normalize(vec3(0., 1., 0.))\n            //inter_current = inter_plane(p-tempc, d, tempn );\n            inter_current = inter_minecraft(p, d);\n            tempp = p+d*inter_current.w;\n            if (inter_current.w < inter_closest.w) {\n                inter_closest = inter_current;\n                inter_id = 2.;\n                //inter_id = blocktyp(floor(tempp))+1.;\n                //inter_id *= sign(SDF_plane(p-tempc, tempn ));\n                inter_id *= sign( SDF(fract(tempp)) );\n            }\n            #undef tempc\n            #undef tempn\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // too far - hits sky\n                break;\n            }\n            else {\n                p += d*inter_closest.w;\n                //\n                //\n                //\n                //\n                //if (abs(inter_id) == 1.) {}\n                //if (abs(inter_id) == 2.) {\n                if (abs(inter_id) == 1.) {\n                    // hits sphere\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    TEXp = vec3(1.);\n                    #if 0\n                    #define temp 1.\n                    TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 1\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #endif\n                    //\n                    // environment light\n                    //\n                    if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    else if (abs(inter_id) == 4.) {\n                        d = reflect(d, inter_closest.xyz);\n                    }\n                    #if 0\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 1\n                    // specular refraction\n                    // air 1.0\n                    // water 1.333\n                    // glass 1.458\n                    // diamond 2.417\n                    float eta = 1.01;\n                    eta = 10.7;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n                else if (abs(inter_id) != 1.) {\n                    //\n                    // hits plane\n                    //\n                    //implement brdf\n                    //implement different inter_id based on blocktyp(floor(p))\n                    //\n                    // Texture\n                    //\n                    vec3 TEXp = .5*abs(inter_closest.xyz);\n                    //TEXp = .5+.5*inter_closest.xyz;\n                    //TEXp = vec3(1.);\n                    TEXp = mix(vec3(0., 1., 1.), vec3(0., 0., 1.), fract(p).y)*.5;\n                    if (abs(fract(p).y-.5) > .48) {\n                        TEXp = vec3(.0, .0, .0);\n                    }\n                    else if (abs(fract(p).x-.5) > .48) {\n                        TEXp = vec3(.0, .9, .9);\n                    }\n                    else {\n                        TEXp = vec3(.0, .7, .7);\n                    }\n                    if (abs(fract(p).y-.5) < .48) {\n                        TEXp = mix(TEXp, vec3(0., 0., .9), fract(p.y));\n                    }\n                    else {\n                        /*TEXp += .2*pow(.5+.5*sin( (p.x*4.+\n                            (.5+.5*sin(p.z*TAU))\n                        )*TAU ), 4.);*/\n                        #if 1\n                        #define temp 1.\n                        //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                        if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                            TEXp += .25;\n                        }\n                        #endif\n                    }\n                    //\n                    #if 0\n                    #define temp 1.\n                    //TEXp *= mod(floor(p.x*temp+.001)+floor(p.y*temp+.001)+floor(p.z*temp+.001), 2.);\n                    if (mod(floor(p.x*temp+.001)+floor(p.y*temp*0.+.001), 2.) > 0.) {\n                        TEXp *= .5;\n                    }\n                    #endif\n                    //\n                    // absorbed/emitted light\n                    //\n                    #if 0\n                    if (freq == freqr) {\n                        absorb *= TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        absorb *= TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        absorb *= TEXp.b;\n                    }\n                    #else\n                    \n                    if (freq == freqr) {\n                        retina += absorb*TEXp.r;\n                    }\n                    else if (freq == freqg) {\n                        retina += absorb*TEXp.g;\n                    }\n                    else if (freq == freqb) {\n                        retina += absorb*TEXp.b;\n                    }\n                    //absorb *= 0.;\n                    #endif\n                    //\n                    // environment light\n                    //\n                    absorb *= .4;\n                    //if (abs(inter_id) == 2.) {\n                        //absorb *= 0.;\n                    //}\n                    //else if (abs(inter_id) == 3.) {\n                        d = reflect(d, inter_closest.xyz);\n                    //}\n                    /*#if 1\n                    // specular reflection\n                    d = reflect(d, inter_closest.xyz);\n                    #elif 0\n                    // specular refraction\n                    float eta = 1.01;\n                    if (inter_id > 0.) {\n                        // inside SDF - moving from obj to air\n                        eta = 1./eta;\n                    }\n                    //inter_closest.xyz = normalize(inter_closest.xyz);\n                    //d = normalize(d);\n                    d = refract(d, inter_closest.xyz, eta);\n                    //d = unrefract(d, inter_closest.xyz, eta);\n                    #elif 0\n                    // diffuse reflection\n                    #endif\n                    */\n                    //\n                    // advance ray\n                    //\n                    p += d*1e-2;\n                    //\n                    // that's all\n                    //\n                }\n            }\n            //\n        }\n        //\n        retina += absorb*sky_map(freq, d);\n        if (mod(samplei, 3.) == 0.) {\n            fragColor.rgb += retina*vec3(1., 0., 0.);\n        }\n        else if (mod(samplei, 3.) == 1.) {\n            fragColor.rgb += retina*vec3(0., 1., 0.);\n        }\n        else if (mod(samplei, 3.) == 2.) {\n            fragColor.rgb += retina*vec3(0., 0., 1.);\n        }\n    }\n    fragColor.rgb /= 1.*spw*spw*spp;\n    //\n    // blend with past n frames\n    //\n}\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}