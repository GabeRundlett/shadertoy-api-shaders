{
    "Shader": {
        "info": {
            "date": "1701484732",
            "description": "Ran out of time to clean artifacts, add AO and other things.",
            "flags": 0,
            "hasliked": 0,
            "id": "DldfRs",
            "likes": 11,
            "name": "[live] Inercia 2023 shader jam",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "smin"
            ],
            "usePreview": 0,
            "username": "w23",
            "viewed": 222
        },
        "renderpass": [
            {
                "code": "float t, tt;\nconst vec3 e=vec3(0.,1.,.001);\nfloat ha(float f){return fract(sin(f)*26374.236);}\nfloat ha(vec2 v){return ha(dot(v,vec2(17.5326,57.3224)));}\nfloat no(vec2 v){vec2 V=floor(v);v-=V;v*=v*(3.-2.*v);\n  return mix(\n    mix(ha(V+e.xx), ha(V+e.xy), v.y),\n    mix(ha(V+e.yx), ha(V+e.yy), v.y), v.x);\n}\n#define rm(a) mat2(cos(a),sin(a),-sin(a),cos(a))\nfloat vmax(vec2 v){return max(v.x,v.y);}\n#define box(p,s) vmax(abs(p)-(s))\n#define PT(t,p) (floor(t)+pow(fract(t),p))\n#define PTN(t,p) (floor(t)+1.-pow(1.-fract(t),p))\n\nfloat h(vec2 p){\n  //float ht=\n  float d =\n    sin(6.28*no(p)+PT(tt/4.,2.))*.4;\n  d -= .5*no(p*.45-2.*e.yx*PTN(tt/2.,2.));\n  return d;\n}\n\nfloat smin(float a,float b,float k){\n  float h=max(0.,1.-abs(b-a)/k);\n  return min(a,b)-h*h*k/4.;\n}\n\nfloat w(vec3 p) {\n  float d = abs(p.y - h(p.xz)) - .02;\n  d*=.5;\n  //d = min(d, length(p)-1.);\n  \n  float sc=1.;\n  vec2 C=floor(p.xz*sc),cc=fract(p.xz*sc)-.5;\n  vec3 pc=vec3(cc,p.y).xzy;\n  float r=.05+.2*ha(C);\n  float pt=PT(tt,3.);\n  pc.y-=.5-.3*sin(ha(C+.2)*6.283+pt*2.);\n  pc.x+=.6*(ha(C+.3)-.5);\n  pc.z+=.6*(ha(C+.4)-.5);\n  d=smin(d,(length(pc)-r)*.3,.3);\n  d=max(d,box(p.xz,4.));\n  return d;\n}\nvec3 no(vec3 p){\n  return normalize(w(p)-vec3(\n    w(p-e.zxx),\n    w(p-e.xzx),\n    w(p-e.xxz)\n  ));\n}\n\nfloat tr(vec3 ro,vec3 rd,float l,float L){\n  for(float i=0.;i<200.;++i){\n    float d=w(ro+rd*l);l+=d;\n    if(d<l*.001||l>L)break;\n  }\n  return l;\n}\n\n\n// LOL COPYPASTE THANKS IQ!!11cos(0.)\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 pal(float t){\n  return palette(t,\n    vec3(.5),\n    vec3(.5),\n    vec3(2.,.8,.3),\n    vec3(.5,.25,.2));\n}\n\nfloat ao(vec3 p,vec3 n,float N,float L){\n  float k=0.;\n  for (float i=0.;i<N;i++){\n    float l=(i+1.)*L/N;\n    float d=w(p+n*l)*3.;\n    k+=step(l,d);\n  }\n  return k/N;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy-.5);\n    uv.x *=iResolution.x/iResolution.y;\n    t=iTime;\n    tt=t*140./60.;\n\n\t//vec2 uv = vec2(gl_FragCoord.x / v2Resolution.x, gl_FragCoord.y / v2Resolution.y);\n\t//uv -= 0.5;\n\t//uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n  \n  vec3 C=vec3(0.),ro=vec3(0.,0.,10.),rd=normalize(vec3(uv,-1.5));\n  mat2 X=rm(.5),Y=rm(.6+t*.2);\n  rd.yz*=X;ro.yz*=X;\n  rd.xz*=Y;ro.xz*=Y;\n  float L=20.,l=tr(ro,rd,0.,L);\n  \n  if (l<L){\n    vec3 p=ro+rd*l,n=no(p);\n    vec3 sd=normalize(vec3(.3,.5,.1));\n    float pp=floor(p.y*30./1.5)/30.;\n    pp+=.2*ha(pp*3.);\n    vec3 m=pal(pp);\n    C=m*vec3(.03);//*ao(p,n,5.,1.);\n    float sh=step(5.,tr(p,sd,.05,5.));\n    C+=m*max(0.,dot(n,sd))*.7*sh;\n    C+=m*pow(max(0.,dot(n,normalize(n+sd))), 150.)*.7*sh;\n  }else{\n    C=vec3(.6,.8,.9);\n  }\n  \n  C*=smoothstep(1.,.5,length(uv));\n\n\tfragColor = vec4(sqrt(C),0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}