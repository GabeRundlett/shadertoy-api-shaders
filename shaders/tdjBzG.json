{
    "Shader": {
        "info": {
            "date": "1590335183",
            "description": "This shader computes the signed distance function of an arbitrary designed border via the reinitialization function of the so called Level Set Method. Description in Buffer B.\n\nPress space to see the initial map, which defines interior and exterior.\n\n",
            "flags": 48,
            "hasliked": 0,
            "id": "tdjBzG",
            "likes": 5,
            "name": "2d Distance by Level Set Method",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "distance"
            ],
            "usePreview": 0,
            "username": "poke53281",
            "viewed": 546
        },
        "renderpass": [
            {
                "code": "const int KEY_SPACE  = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (texelFetch( iChannel2, ivec2(KEY_SPACE, 0),0 ).x > 0.) {\n    \tfragColor = vec4(texture(iChannel1, uv).r + 1. * 0.5, 0., 0., 1.);\n    } else {\n        vec4 c = texture(iChannel0, uv);\n    \n        if (abs(c.r) < 1.) {\n            fragColor = vec4(1);\n        } else\n        if (c.r < 0.0) {\n            fragColor = vec4(min(-c.r*0.03, 1.), 0., 0. ,1);\n        } else\n        {\n            fragColor = vec4(0., 0., min(c.r*0.03, 1.), 1);\n        }  \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// This buffer contains just the scene and is initialized at the beginning\n// values are either 1 or -1 and define either the interior and outerior.\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nvec4 InitScene(in vec2 fragCoord){\n    vec2 time = vec2(iTime * 923.213456123, -iTime * 995.84367);\n\treturn vec4( fbm(fragCoord*0.01 + time)<0.?-1.:1., 0., 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 1) {\n        vec2 step = 1. / iResolution.xy;\n        // The algorithm seems more stable when the borders are averaged.\n        fragColor = vec4(0);\n        fragColor += InitScene(fragCoord + step*vec2(-1., -1.));\n        fragColor += InitScene(fragCoord + step*vec2( 0., -1.));\n        fragColor += InitScene(fragCoord + step*vec2(-1., -1.));\n        fragColor += InitScene(fragCoord + step*vec2( 0., -0.));\n        fragColor += InitScene(fragCoord + step*vec2( 1., -0.));\n        fragColor += InitScene(fragCoord + step*vec2(-1., -0.));\n        fragColor += InitScene(fragCoord + step*vec2( 0.,  1.));\n        fragColor += InitScene(fragCoord + step*vec2( 1.,  1.));\n        fragColor += InitScene(fragCoord + step*vec2( 1.,  1.));\n        fragColor /= 9.;\n        return;\n    }\n\n    // just copy input to output. \n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// A signed distance function P(x,y), satisfied the condition \n//\n// |grad P| = 1 \n//\n// or  \n//\n// L = |grad P| - 1 = 0\n//\n// This code solves the so called level set method reinitialization \n// equation \n//\n// dP/dt = - P0 * L\n//\n// with P0(x,y) containing the initial shapes. \n// The solution converges and is in a steady state when L = 0.\n//\n// To stabilize the algorithm, you have to use high order discretization schemes \n// such as WENO (https://en.wikipedia.org/wiki/WENO_methods) and\n// upwind schemes (https://en.wikipedia.org/wiki/Upwind_scheme)\n\n#define timestep 0.2\n\n#define getSign(uv)  texture(iChannel1, uv).r\n#define fetchDistance(x) texture(iChannel0, uv + step * x).r\n\n// fifth order WENO discretization or ordinary first order discretization\n#define WENO\n\n\nfloat upwind(float grad_left, float grad_right, float sign0) {\n    if ((grad_left*sign0 < -grad_right*sign0) && (grad_right*sign0 < 0.)) {\n\t    return grad_right;\n    } else \n    if ((grad_left*sign0 > 0.) && (grad_right*sign0 > -grad_left*sign0)) {\n        return grad_left;\n    }\n    return 0.;\n}\n\n// calculates the gradient using the WENO scheme\nfloat weno_gradient(\n    float Psinnn, \n    float Psinn, \n    float Psin, \n    float Psi, \n    float Psip, \n    float Psipp, \n    float Psippp,\n    float dx, bool positive)\n{\n    const float e = 1e-6;\n    float q1, q2, q3, q4, q5, is1, is2, is3, a1, a2, a3, w1, w2, w3;\n    if (positive)\n    {\n        q1 =  (Psippp-Psipp)/dx;\n        q2 =  (Psipp-Psip)/dx;\n        q3 =  (Psip-Psi)/dx;\n        q4 =  (Psi-Psin)/dx;\n        q5 =  (Psin-Psinn)/dx;\n    } else\n    {\n        q1 =  (Psinn-Psinnn)/dx;\n        q2 =  (Psin-Psinn)/dx;\n        q3 =  (Psi-Psin)/dx;\n        q4 =  (Psip-Psi)/dx;\n        q5 =  (Psipp-Psip)/dx;\n    }\n    \n    is1 = 13./12.*(q1-2.*q2+q3)*(q1-2.*q2+q3)+0.25*(q1-4.*q2+3.*q3)*(q1-4.*q2+3.*q3);\n    is2 = 13./12.*(q2-2.*q3+q4)*(q2-2.*q3+q4)+0.25*(q2-q4)*(q2-q4);\n    is3 = 13./12.*(q3-2.*q4+q5)*(q3-2.*q4+q5)+0.25*(3.*q3-4.*q4+q5)*(3.*q3-4.*q4+q5);\n    a1 = 0.1/((e+is1)*(e+is1));\n    a2 = 0.6/((e+is2)*(e+is2));\n    a3 = 0.3/((e+is3)*(e+is3));\n    w1 = a1/(a1+a2+a3);\n    w2 = a2/(a1+a2+a3);\n    w3 = a3/(a1+a2+a3);\n    return  w1*(q1/3.-7.*q2/6.+11.*q3/6.)+w2*(-q2/6.+5.*q3/6.+q4/3.)+w3*(q3/3.+5.*q4/6.-q5/6.);\n}\n\n\n// calculates gradient of the distance map\nvec2 gradient(vec2 uv, float sign0) {\n    vec2 step = 1. / iResolution.xy;\n    \n    float c   = fetchDistance(vec2( 0.,  0.));\n    float eee = fetchDistance(vec2( 3.,  0.));\n    float ee  = fetchDistance(vec2( 2.,  0.));\n    float e   = fetchDistance(vec2( 1.,  0.));\n    float w   = fetchDistance(vec2(-1.,  0.));\n    float ww  = fetchDistance(vec2(-2.,  0.));\n    float www = fetchDistance(vec2(-3.,  0.));\n    float nnn = fetchDistance(vec2( 0.,  3.));\n    float nn  = fetchDistance(vec2( 0.,  2.));\n    float n   = fetchDistance(vec2( 0.,  1.));\n    float s   = fetchDistance(vec2( 0., -1.));\n    float ss  = fetchDistance(vec2( 0., -2.));\n    float sss = fetchDistance(vec2( 0., -3.));\n\n    // using cellwidth and cellheight = 1\n#ifdef WENO \n    float gradxp = weno_gradient(www,ww,w,c,e,ee,eee, 1., true);\n    float gradxm = weno_gradient(www,ww,w,c,e,ee,eee, 1., false);\n    float gradyp = weno_gradient(nnn,nn,n,c,s,ss,sss, 1., true);\n    float gradym = weno_gradient(nnn,nn,n,c,s,ss,sss, 1., false);\n#else\n    float gradxp = (e-c); \n    float gradxm = (c-w);\n    float gradyp = (n-c);\n    float gradym = (c-s);\n#endif\n    \n    // choose the right gradient to stabilize\n    vec2 grad = vec2(upwind(gradxm, gradxp, sign0), \n                     upwind(gradym, gradyp, sign0));\n    \n    return grad;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float sign0 = getSign(uv);\n    \n    // reset signed distance function\n    if (iFrame < 1) {\n        fragColor = vec4(sign0);\n        return;\n    }\n    \n    float L = length(gradient(uv, sign0)) - 1.;\n    \n    // Two step Adams-Bashforth time integration\n    // r contains old value and g the previous right hand side.\n    float dPdt = -sign0*L;\n    vec4 old_distance = texture(iChannel0, uv);\n    float new_distance = old_distance.r + timestep * (3./2.*dPdt - 1./2.*old_distance.g);\n    \n    fragColor = vec4(new_distance, dPdt, 0., 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}