{
    "Shader": {
        "info": {
            "date": "1478017513",
            "description": "Sine wave superposition for simple water wave synthesis with a predefined velocity (e.g. wind direction and speed).",
            "flags": 0,
            "hasliked": 0,
            "id": "Xt3XzH",
            "likes": 26,
            "name": "Sine wave superposition",
            "published": 3,
            "tags": [
                "water",
                "sinewaves"
            ],
            "usePreview": 0,
            "username": "drivenbynostalgia",
            "viewed": 1718
        },
        "renderpass": [
            {
                "code": "// A simple implementation of sine waves along a given, unnormalized velocity\n\nconst float TAU = 6.2831852;\nconst float PI = 0.5 * TAU; // This is a political statement\n\nconst float octaves = 8.0;\nconst vec2 globalVelocity = vec2(6.0, 8.0);\n\n// Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    const float HASHSCALE1 = .1031;\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat getAmplitude(float octave)\n{\n    return 1.0 / pow(2.0, octave);\n}\n\nfloat getWavelength(float octave)\n{\n\tconst float maximumWavelength = 50.0;\n    \n    float wavelength = TAU * maximumWavelength / pow(2.0, octave);\n\n    // Make it aperiodic with a random factor\n    wavelength *= 0.75 + 0.5 * hash11(1.337 * octave);\n    \n    return wavelength;\n}\n\nfloat getSpeed(float octave)\n{\n    const float speedScaleFactor = 2.0;\n    \n    // Smallest waves travel twice as fast as given velocity,\n    // largest waves travel half as fast\n    const vec2 speedRange = vec2(2.0, 0.5);\n    \n    // Map octave to speed range\n    float speed = speedScaleFactor * mix(speedRange.x, speedRange.y, octave / (max(1.0, octaves - 1.0)));\n    \n    // Add some randomness\n    speed *= 0.5 + hash11(1.337 * octave);\n    \n    return speed;\n}\n\nfloat getHeight(vec2 position, vec2 velocity)\n{\n    float magnitude = length(velocity);\n    vec2 direction = (magnitude > 1e-5) ? velocity / magnitude : vec2(0.0);\n\n    float height = 0.0;\n    \n    for (float octave = 0.0; octave < octaves; octave += 1.0)\n    {\n        float amplitude = getAmplitude(octave);\n        float wavelength = getWavelength(octave);\n        float speed = magnitude * getSpeed(octave);\n        float frequency = TAU / wavelength;\n        float randomPhaseOffset = hash11(1.337 * octave) * TAU;\n        float phase = speed * frequency + randomPhaseOffset;\n        float theta = dot(-direction, position);\n    \n        height += amplitude * sin(theta * frequency + iTime * phase);\n    }\n    \n    return height;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (uv.x < 0.5)\n    {    \n\t\tfragColor = vec4(vec3(0.25 * getHeight(fragCoord, globalVelocity) + 0.5), 1.0);\n    }\n    else\n    {\n        vec2 velocity = vec2(length(globalVelocity), 0.0);\n        float height = getHeight(vec2(fragCoord.x, 0.0), velocity);\n        float scaledHeight = (0.25 * height + 3.0) / 6.0;\n\n        float plot = 1.0 - pow(1.0 - distance(uv.y, scaledHeight), 500.0);\n        \n        fragColor = vec4(vec3(plot), 1.0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}