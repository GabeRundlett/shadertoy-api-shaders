{
    "Shader": {
        "info": {
            "date": "1673749189",
            "description": "5000 particle-balls in a rotating cube, rendered via voronoi tracking with 200 local light sources + shadows.\n\n*mouse to control cube rotation* \n*click-drag-release to \"throw\" cube*\n*space to resume automatic rotation*\n*shift to disable occlusion*",
            "flags": 48,
            "hasliked": 0,
            "id": "mt23R3",
            "likes": 65,
            "name": "Local Light Source Ball Pit",
            "published": 3,
            "tags": [
                "3d",
                "simulation",
                "shadow",
                "particles",
                "dynamics",
                "lights",
                "soft",
                "physics",
                "deferred"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 978
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  5000 particles lit by 200 local light sources. This is very nearly the same particle\n//  sim as its predecessor, just with new lighting.\n//\n//    SSAO Rotating Ball Pit            https://shadertoy.com/view/cl23Ww\n//\n//  Deferred rendering can do more than just screen space ambient occlusion! It's good\n//  for rendering lots of lights as well. I've done that before in other shaders like\n//\n//    Arctic Fireflies                  https://shadertoy.com/view/cssSRs\n//    Sparks on Swiss Cheese Mountain   https://shadertoy.com/view/7tyyW1\n//    Spark Volcano 2                   https://shadertoy.com/view/7lKczD\n//\n//  The new thing in this shader is screen-space shadows. Press shift to disable to see\n//  the difference. I'm doing a DDA-type traversal of the screen between each light\n//  source and each rendered pixel, looking for depth that should occlude some or all of\n//  the light. This results in passable soft shadows that can be cast quite a distance.\n//\n//  Buffer A simulates particles and tracks particle neighbors in 3D\n//  Buffer B computes nearest particles to each screen pixel\n//  Buffer C renders G buffer\n//  Buffer D computes nearest lights to each screen pixel\n//  Image performs lighting and occlusion\n//\n//  Update 1/15/23: fixed normals on two walls, doubled light sources\n// ---------------------------------------------------------------------------------------\n\n// decode color from G buffer material\nvec3 materialColor(float c)\n{\n    if (c <= 1.) return mix(vec3(1), vec3(.5), c); // color between 0 and 1 is the box\n    switch(int(c / float(LIGHT_RATIO)) % 2)\n    {\n        case 0: return vec3(.5);\n        case 1: return vec3(1);\n    }\n}\n\n// decode emissivity from G buffer material\nvec3 materialEmis(float c)\n{\n    if ((int(c) % LIGHT_RATIO) != 2) return vec3(0);\n    switch(int(c / float(LIGHT_RATIO)) % 3)\n    {\n        case 0: return vec3(1,.5,.1);\n        case 1: return vec3(1,.3,1);\n        case 2: return vec3(0,1,.5);\n    }\n}\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvec2 intersectXY(ivec2 xy, vec2 from, vec2 dir) { return (vec2(xy) - from) / dir; }\nfloat sum(vec2 x) { return x.x + x.y; }\n\nfloat occluded(fxParticle light, vec2 fragCoord, float t, mat4 w2c)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 lc = (w2c * vec4(light.pos,1.0)).xyz;\n    lc.xy = ((lc.xy / lc.z) * iResolution.y + iResolution.xy) * .5;\n    \n    // account for particle size \n    t += PARTICLE_SIZE;\n    \n    // get the depth at light source\n    fxGBufferPixel lp = fxUnpackGBuffer(texture(iChannel1, (lc.xy) / iResolution.xy));\n    \n    // compute the gradient of t\n    float tDelta = (lp.t - t) / length(fragCoord - lc.xy);\n    \n    // don't bother searching past some distance, light will be very dim anyway\n    if (distance(lc.xy, fragCoord) > 500.) return 1.;\n\n    // setup traversal\n    vec2 rayDir = lc.xy - fragCoord;\n    vec2 cur = fragCoord;\n\tivec2 mapPos = ivec2(floor(fragCoord));\n\tivec2 finalMapPos = ivec2(floor(lc.xy));\n\tvec2 deltaDist = abs(length(rayDir) / rayDir);\n    ivec2 rayStep = ivec2(sign(rayDir));\n    vec2 fixup = sign(rayDir) * 0.5 + 0.5;\n\tvec2 sideDist = (sign(rayDir) * (vec2(mapPos) - fragCoord) + fixup) * deltaDist; \n\t\n    float occ = 0.;\n\n    const int MAX_RAY_STEPS = 64;\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n\t\tif (mapPos == finalMapPos)\n        {\n            break;\n        }\n        \n        bvec2 mask = lessThanEqual(sideDist.xy, sideDist.yx);\n\n        vec2 ts = intersectXY(mapPos + ivec2(fixup), fragCoord, rayDir);\n        vec2 next = fragCoord + rayDir * sum(vec2(mask) * ts);\n        \n        fxGBufferPixel pix = fxUnpackGBuffer(texelFetch(iChannel1, mapPos, 0));\n        \n        // compute curent t\n        t += length(cur - next) * tDelta;\n\n        // add up occlusion\n        occ += t - pix.t;\n        \n        // go to the next pixel\n        cur = next;\n\t\tsideDist += vec2(mask) * deltaDist;\n\t\tmapPos += ivec2(vec2(mask)) * rayStep;\n\t}\n\n    return 1. - clamp(occ, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxGBufferPixel pix = fxUnpackGBuffer(texture(iChannel1, fragCoord/iResolution.xy));\n    \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n    \n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    if (pix.t >= FAR_CLIP)\n    {\n        // background\n        fragColor = vec4(.2);\n    }\n    else\n    {\n        // ssao model inspired by SSAO (basic) by iq: https://www.shadertoy.com/view/Ms23Wm\n        // sample neighbor pixels\n        mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n        mat4 w2c = inverse(c2w);\n\n        vec3 pixelPos = cameraPos + rayDir * pix.t;\n        //vec3 lightColor = vec3(0);\n        vec3 pixel = materialEmis(pix.m);\n        \n        // lighting\n        ivec4 old = fxGetClosestLights( ivec2(fragCoord) );\n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            fxParticle light = fxGetParticle(id);\n            \n            float occ = occluded(light, fragCoord, pix.t, w2c);\n            if (keyDown(KEY_SHIFT)) occ = 1.;\n            \n            //renderParticle(id, data, cameraPos, rayDir, pix);\n            vec3 lightDelta = light.pos - pixelPos;\n            vec3 lightColor = .5 * materialEmis(float(id + 2)) / pow(length2(lightDelta), .8);\n            \n            float nDotL = max(dot(pix.n, normalize(lightDelta)), .0);\n            float dif = occ * (nDotL * nDotL * .05 + .001) + .002;\n            pixel += (lightColor * dif + .01) * materialColor(pix.m);\n        }\n\n        fragColor.xyz = pixel;\n    }\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;   //vec2(1.0)- uv.yx; -> 1.-u.yx; Thanks FabriceNeyret \n    float vig = uv.x*uv.y * 5.; // multiply with sth for intensity\n    vig = sqrt(vig); // change pow for modifying the extend of the  vignette\n    fragColor *= vig;\n\n    fragColor.xyz = pow(ACESFilm(fragColor.xyz), vec3(1./2.2));\n    fragColor.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// constants\nconst float PI = 3.141592653589793;\nconst float PARTICLE_SIZE = .03;\nconst float FAR_CLIP = 1e6;\nconst int LIGHT_RATIO = 25;\n\n// PARTICLES\n\n// returns the ids of the four closest particles from the input\nivec4 fxGetClosestImpl(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestImpl(iChannel1, X)\n#define fxGetClosestLights(X) fxGetClosestImpl(iChannel2, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS 4\n#define VEL 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n// returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromID(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\nstruct fxParticle\n{\n    vec3 pos;\n    vec3 vel;\n    ivec4 nbs[4];\n};\n\n// get the particle corresponding to the id\nfxParticle fxGetParticleImpl(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, POS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromID(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.nbs[0] = ivec4(particleData0);\n    particle.nbs[1] = ivec4(particleData1);\n    particle.nbs[2] = ivec4(particleData2);\n    particle.nbs[3] = ivec4(particleData3);\n    particle.pos = particleData4.xyz;\n    particle.vel = particleData5.xyz;\n    \n    return particle;\n}\n\n#define fxGetParticle(X) fxGetParticleImpl(iChannel0, int(iResolution.x), X)\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.nbs[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.nbs[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.nbs[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.nbs[3]);\n    case POS:  \n        return vec4(p.pos, 0);\n    case VEL:  \n        return vec4(p.vel, 0);\n    }\n}\n\nvec4 fxGetParticleDataImpl(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromID(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataImpl(iChannel0, int(iResolution.x), X, Y)\n\n// global variables, initialized via computeMaxParticles\nconst int IDEAL_MAX_PARTICLES = 5000;\nint MAX_PARTICLES = IDEAL_MAX_PARTICLES; // how many particles, total\n\n// computes the real number of particles that we can simulate in case our buffer isn't big enough\nvoid computeMaxParticles(vec3 res)\n{\n    MAX_PARTICLES = IDEAL_MAX_PARTICLES;\n    MAX_PARTICLES = min(MAX_PARTICLES, int(res.x * res.y) / NUM_PARTICLE_DATA_TYPES);\n}\n\n// CAMERA\n\nvoid fxCalcCamera(out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(0, -.5, 0);\n    cameraPos\t = vec3(0, 1, 1);\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n}\n\nmat4 fxCalcCameraMat(vec3 resolution, vec3 cameraLeft, vec3 cameraUp, vec3 cameraFwd, vec3 cameraPos)\n{\n    return mat4(vec4(-0.5 * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n}\n\nvec3 fxCalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\n// PERSISTENT STATE\n\nstruct fxState\n{\n    vec2 boxRot;\n    vec2 boxVel;\n    vec2 lastMouse;\n    float resolution;\n    bool autoRotate;\n};\n\nvoid fxInitStateImpl(inout fxState state, vec3 iResolution)\n{\n    state.boxRot = vec2(0);\n    state.boxVel = vec2(0);\n    state.lastMouse = vec2(0);\n    state.resolution = -iResolution.x * iResolution.y;\n    state.autoRotate = true;\n}\n\n#define fxInitState(state) fxGetStateImpl(state, iResolution)\n\nfxState fxGetStateImpl(sampler2D sampler, int iFrame, vec3 iResolution)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0, 0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    \n    fxState state;\n    state.boxRot = data0.xy;\n    state.boxVel = data0.zw;\n    state.lastMouse = data1.xy;\n    state.resolution = data1.z;\n    state.autoRotate = data1.w != 0.;\n    \n    if (iFrame == 0 || abs(state.resolution) != iResolution.x * iResolution.y)\n        fxInitStateImpl(state, iResolution);\n        \n    return state;\n}\n\n#define fxGetState() fxGetStateImpl(iChannel1, iFrame, iResolution)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0, 0))\n        return vec4(state.boxRot, state.boxVel);\n    else\n        return vec4(state.lastMouse, state.resolution, state.autoRotate ? 1. : 0.);\n}\n\n// PHYSICS BOUNDARY SCENE\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// compute a matrix from the boxRot euler angles\nmat4 boxMat(vec2 boxRot)\n{\n    const float ROTATE_SPEED = .2;\n    vec2 scA = vec2(sin(boxRot.x * ROTATE_SPEED), cos(boxRot.x * ROTATE_SPEED));\n    vec2 scB = vec2(sin(boxRot.y * ROTATE_SPEED), cos(boxRot.y * ROTATE_SPEED));\n    vec2 scC = vec2(sin(.001 * ROTATE_SPEED), cos(.001 * ROTATE_SPEED));\n    mat4 matA = mat4(scA.y, -scA.x, 0, 0, scA.x, scA.y, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    mat4 matB = mat4(scB.y, 0, scB.x, 0, 0, 1, 0, 0, -scB.x, 0, scB.y, 0, 0, 0, 0, 1);\n    mat4 matC = mat4(0, scC.y, -scC.x, 0, 1, 0, 0, 0, 0, scC.x, scC.y, 0, 0, 0, 0, 1);\n    \n    return matA * matB * matC;\n}\n\nvoid rotateBox(inout vec3 p, vec2 boxRot)\n{\n    p = (vec4(p, 1) * boxMat(boxRot)).xyz;\n}\n\nfloat scene(vec3 p, fxState state)\n{\n    rotateBox(p, state.boxRot);\n    return -sdBox(p - vec3(0, 0, 0), vec3(1, 1, 1));\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 p, fxState state)\n{\n    const vec2 e = vec2(1.0,-1.0)*0.000005773;\n    return normalize( e.xyy*scene(p + e.xyy, state) + \n\t\t\t\t\t  e.yyx*scene(p + e.yyx, state) + \n\t\t\t\t\t  e.yxy*scene(p + e.yxy, state) + \n\t\t\t\t\t  e.xxx*scene(p + e.xxx, state) );\n}\n\n// G BUFFER\n\n// note there are five dwords here...c is stored where the normal z would usually be, and the normal z is reconstructed\nstruct fxGBufferPixel\n{\n    vec3 n;  // normal\n    float t; // scene depth (not actually z depth)\n    float m; // material\n};\n\nvec4 fxPackGBuffer(fxGBufferPixel pix)\n{\n    // material is tucked away in where the normal's z is, so record the sign there\n    return vec4(pix.n.xy, pix.m * sign(pix.n.z), pix.t);\n}\n\nfxGBufferPixel fxUnpackGBuffer(vec4 fragColor)\n{\n    fxGBufferPixel pix;\n    pix.n.xy = fragColor.xy;\n    \n    // reconstruct the z component of the normal\n    pix.n.z = sqrt(max(0., 1. - (pix.n.x * pix.n.x + pix.n.y * pix.n.y))) * sign(fragColor.z);\n    \n    pix.m = abs(fragColor.z);\n    pix.t = fragColor.w;\n    return pix;\n}\n\n// MISC\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_)\n{\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nfloat length2(vec2 v) { return dot(v, v); }\nfloat length2(vec3 v) { return dot(v, v); }\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Particle update\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0,-.0005,0);\n\nvoid particleStep(inout fxParticle p, fxState state, vec2 fragCoord)\n{\n    if (iFrame == 0 || state.resolution < 0.)\n    {\n        // init\n        vec3 h = hash3( uvec3(fragCoord, iFrame) );\n\n        p.pos = h * 2. - 1.;\n        p.vel = vec3(0);\n        \n        return;\n    }\n\n    // particle update\n    p.vel *= .995; // damping\n    const float MAX_SPEED = .025; // clamping\n    if (length(p.vel) > MAX_SPEED)\n    {\n        p.vel = normalize(p.vel) * MAX_SPEED;\n    }\n    p.vel += GRAVITY;\n\n    for (int iter = 0; iter < 3; ++iter)\n    {\n        // collide with neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                fxParticle nb = fxGetParticle(nid);\n\n                if (nb.pos.y < p.pos.y && // only react to particles below us (stability hack)\n                    distance(nb.pos, p.pos) < PARTICLE_SIZE * 2.)\n                {\n                    vec3 dir = normalize(p.pos - nb.pos);\n\n                    // position correction\n                    p.pos = mix(p.pos, nb.pos + dir * PARTICLE_SIZE * 2., .05);\n\n                    // clip velocity (stability hack, should be relative velocity)\n                    p.vel -= dot(p.vel, dir) * dir;\n                }\n            }\n        }\n\n        // collide with boundary\n        float boundary = scene(p.pos, state);\n        if (boundary < PARTICLE_SIZE)\n        {\n            vec3 normal = sceneNormal(p.pos, state);\n\n            // position correction\n            p.pos += normal * (PARTICLE_SIZE - boundary);\n\n            // clip velocity\n            vec3 boxVel = .01*cross(p.pos, vec3(-state.boxVel.y, 0, state.boxVel.x));\n            p.vel -= min(0., dot(p.vel - boxVel, normal)) * normal;\n        }\n    }\n\n    p.pos += p.vel; // integrate\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id == currentId || any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int dataType, int currentId, int searchId, in fxParticle myParticle)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myParticle.pos;\n    \n    int dir = int(2.*(atan(dx.z, dx.x)+PI)/PI); \n    if(dir != dataType) return; //not in this quadrant\n\n    float t = length2(dx);\n    \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\nvec4 neighborUpdate(fxParticle p, fxState state, int dataType, ivec2 ifc, int id)\n{\n    // nearest neighbors tracking\n    // each particle tracks its 16 closest neighbors, 4 in each xz quadrant\n    // dataType determines which quadrant we are computing\n    ivec4 bestIds = ivec4(-1);\n    vec4 bestDists = vec4(1e6);\n\n    if (iFrame > 0 && state.resolution > 0.)\n    {\n        // consider existing neighbors\n        for (int i = 0; i < 4; ++i)\n        {\n            for (int j = 0; j < 4; ++j)\n            {\n                int nid = p.nbs[i][j];\n                if (nid < 0) break;\n                sort0(bestIds, bestDists, dataType, id, nid, p);\n\n                // randomly consider one of the neighbors' neighbors\n                int h = int(hash(uvec4(ifc.x * i, ifc.y * int(iResolution.x), iFrame, j)).x);\n                int dir = h % 4;\n                ivec4 nbsNbs = ivec4(fxGetParticleData(nid, dir));\n                for (int y = 0; y < 4; ++y)\n                {\n                    int nbNid = nbsNbs[y];\n                    if (nbNid < 0) break;\n                    sort0(bestIds, bestDists, dataType, id, nbNid, p);\n                }\n            }\n        }\n\n        // random search\n        int searchIterations = 10;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int h = int(hash(uvec4(ifc.x, ifc.y * int(iResolution.x), iFrame, k)).x);\n            int hi = h % MAX_PARTICLES;\n            sort0(bestIds, bestDists, dataType, id, hi, p);\n        }\n    }\n    \n    return vec4(bestIds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    int index = ifc.x + ifc.y * int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES; // which particle is this\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES; // which field of this particle are we working on\n    computeMaxParticles(iResolution);\n    if(id>=MAX_PARTICLES) return;\n\n    fxState state = fxGetState();\n    fxParticle p = fxGetParticle(id);\n    \n    if (dataType < POS)\n    {\n        fragColor = neighborUpdate(p, state, dataType, ifc, id);\n        return;\n    }\n    \n    particleStep(p, state, fragCoord);\n    fragColor = fxSaveParticle(p, dataType);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi particle tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id < 0) return FAR_CLIP;\n    \n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    \n    // throw away particles too far away\n    vec2 delta = screenPos.xy-fragCoord;\n    if (length2(delta) > (PARTICLE_SIZE * PARTICLE_SIZE * 2.0)) return 1e6;\n    \n    // favor particles in the front\n    return length2(delta) + screenPos.z * .01;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            state.autoRotate = false;\n            \n            if (iMouse.w < 0.)\n            {\n                vec2 delta = 3. * (iMouse.xy - state.lastMouse) / iResolution.y;;\n                state.boxVel = delta;\n            }\n            \n            state.lastMouse = iMouse.xy;\n        }\n        else if (state.autoRotate)\n        {\n            state.boxVel = mix(state.boxVel, vec2(-.01), .01);\n        }\n        \n        state.boxVel = clamp(state.boxVel, -.1, .1);\n        \n        if (keyDown(KEY_SPACE)) state.autoRotate = true;\n        \n        state.boxRot += state.boxVel;\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosest(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0)\n            {\n                float dis2 = distance2Particle(nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 31u;\n        uint searchCount = 48u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosest( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 5 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % MAX_PARTICLES;\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n        }\n    }\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// G buffer render\n// ---------------------------------------------------------------------------------------\n\n// https://iquilezles.org/articles/spherefunctions/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// draw one ball\nvoid renderParticle(int id, fxParticle p, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    float t = sphIntersect(ro, rd, vec4(p.pos, PARTICLE_SIZE));\n    if (t > 0. && t < pix.t)\n    {\n        vec3 hitPos = ro + rd * t;\n        vec3 normal = normalize(hitPos - p.pos);\n\n        pix.n = normal;\n        pix.m = float(id + 2); // materials 0...1 are for box\n        pix.t = t;\n    }\n}\n\n// Derived from iq, but DO NOT COPY FROM HERE (modified to return interior results):\n// https://iquilezles.org/articles/boxfunctions/\n// Calcs intersection and exit distances, normal, face and UVs\n// row is the ray origin in world space\n// rdw is the ray direction in world space\n// txx is the world-to-box transformation\n// txi is the box-to-world transformation\n// ro and rd are in world space\n// rad is the half-length of the box\n//\n// oT contains the entry and exit points\n// oN is the normal in world space\n// oU contains the UVs at the intersection point\nbool boxIntersect( in vec3 row, in vec3 rdw, in mat4 txx, in mat4 txi, in vec3 rad,\n                   out vec2 oT, out vec3 oN, out vec2 oU ) \n{\t\t\t\t \n    // convert from world to box space\n    vec3 rd = (txx*vec4(rdw,0.0)).xyz;\n    vec3 ro = (txx*vec4(row,1.0)).xyz;\n\n    // ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 s = vec3((rd.x<0.0)?1.0:-1.0,\n                  (rd.y<0.0)?1.0:-1.0,\n                  (rd.z<0.0)?1.0:-1.0);\n    vec3 t1 = m*(-ro + s*rad);\n    vec3 t2 = m*(-ro - s*rad);\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF < 0.0) return false;\n\n    // compute normal (in world space), face and UV\n    if( t2.x<t2.y && t2.x<t2.z ) { oN=txi[0].xyz*s.x; oU=ro.yz+rd.yz*t2.x; }\n    else if( t2.y<t2.z   )       { oN=txi[1].xyz*s.y; oU=ro.zx+rd.zx*t2.y; }\n    else                         { oN=txi[2].xyz*s.z; oU=ro.xy+rd.xy*t2.z; }\n\n    oT = vec2(tN,tF);\n    \n    return true;\n}\n\nfloat boxDist(vec2 a, vec2 b) { return max(abs(a.x - b.x), abs(a.y - b.y)); }\n\n// generates a checkerboard pattern\n// aa allows reduction of aliasing at steep angles\nfloat checker(vec2 p, float aa)\n{\n    vec2 m = mod(p, vec2(2.));\n    float sd = min(boxDist(vec2(.5, 1.5), m), boxDist(vec2(1.5, .5), m));\n    return smoothstep(-aa, aa, .5 - sd) * .5 + .5;\n}\n\n// draws an inside-out antialiased checkered box\nvoid drawBox(fxState state, vec3 ro, vec3 rd, inout fxGBufferPixel pix)\n{\n    vec2 t, uv;\n    vec3 n;\n    mat4 m = boxMat(state.boxRot);\n    if (boxIntersect(ro, rd, inverse(m), m, vec3(1), t, n, uv))\n    {\n        float x = 1.2 + dot(n, rd);\n        float aa = x * 20./iResolution.y;\n        float ch = checker(uv * 4.25 - .5, aa);\n        \n        pix.n = n;\n        pix.t = t.y;\n        pix.m = ch;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n   \n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = fxCalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\n    fxGBufferPixel pix;\n    pix.t = FAR_CLIP;\n    \n    // render box\n    drawBox(state, cameraPos, rayDir, pix);\n\n    // render particles\n    ivec4 old = fxGetClosest( ivec2(fragCoord) );      \n    for (int j = 0; j < 4; j++)\n    {\n        int id = old[j];\n        if (id < 0) break;\n        fxParticle data = fxGetParticle(id);\n        renderParticle(id, data, cameraPos, rayDir, pix);\n    }\n    \n    fragColor = fxPackGBuffer(pix);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Voronoi light tracking buffer\n// ---------------------------------------------------------------------------------------\n\n// Originally derived, many shaders ago, from:\n// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord, mat4 w2cNew)\n{\n    if(id < 0) return FAR_CLIP;\n    if ((id % LIGHT_RATIO) != 0) return 1e6; // Don't allow particles that are not lights\n    // compute screen space position\n    vec3 worldPos = fxGetParticleData(id, POS).xyz;\n    vec3 screenPos = (w2cNew * vec4(worldPos,1.0)).xyz;\n    screenPos.xy = screenPos.xy / screenPos.z;\n    \n    // throw away particles too far away\n    vec2 delta = screenPos.xy-fragCoord;\n    //if (length2(delta) > (PARTICLE_SIZE * PARTICLE_SIZE * 10.0)) return 1e6;\n    \n    // favor particles in the front\n    return length2(delta) + screenPos.z * .1;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n   \tivec2 ifc = ivec2(fragCoord);\n    computeMaxParticles(iResolution);\n    fxState state = fxGetState();\n    if(ifc == ivec2(0) || ifc == ivec2(1, 0))\n    {\n        // update persistent state\n        state.resolution = abs(state.resolution);\n        \n        if (iMouse.z > 0.)\n        {\n            state.autoRotate = false;\n            \n            if (iMouse.w < 0.)\n            {\n                vec2 delta = 3. * (iMouse.xy - state.lastMouse) / iResolution.y;;\n                state.boxVel = delta;\n            }\n            \n            state.lastMouse = iMouse.xy;\n        }\n        else if (state.autoRotate)\n        {\n            state.boxVel = mix(state.boxVel, vec2(-.01), .01);\n        }\n        \n        state.boxVel = clamp(state.boxVel, -.1, .1);\n        \n        if (keyDown(KEY_SPACE)) state.autoRotate = true;\n        \n        state.boxRot += state.boxVel;\n        \n        fragColor = fxPutState(state, ifc);\n        return;\n    }\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    fxCalcCamera(cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2w = fxCalcCameraMat(iResolution, cameraLeft, cameraUp, cameraFwd, cameraPos);\n    mat4 w2c = inverse(c2w);\n\n    // in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    // in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    if (iFrame > 0)\n    {\n        ivec4 old = fxGetClosestLights(ifc);      \n        for (int j = 0; j < 4; j++)\n        {\n            int id = old[j];\n            if (id < 0) break;\n            float dis2 = distance2Particle(id, p, w2c);\n            insertion_sort( new, dis, id, dis2 );\n\n            // randomly check one of the physics neighbors of the particle, it's likely to be of interest\n            ivec4 h = ivec4(hash(uvec4(ifc.x, ifc.y * 3, iFrame, j)));\n            ivec4 nbs = ivec4(fxGetParticleData(id, h.x % 4));\n            int nid = nbs[h.y % 4];\n\n            if (nid >= 0 && (nid + 1) % LIGHT_RATIO == 0)\n            {\n                float dis2 = distance2Particle(nid, p, w2c);\n                insertion_sort( new, dis, nid, dis2 );\n            }\n        }\n\n        // search nearby voronoi cells for particles that should move into our cell\n        uint searchRange = 8u;\n        uint searchCount = 48u;\n\n        for(uint i=0u; i<searchCount; ++i)\n        {\n            uvec4 h0 = hash(uvec4(fragCoord, iFrame, i) * i);\n            ivec4 old = fxGetClosestLights( ifc + ivec2( h0.xy % searchRange - searchRange / 2u) );      \n\n            for (int j = 0; j < 1; j++)\n            {\n                int id = old[j];\n                if (id < 0) break;\n                float dis2 = distance2Particle(id, p, w2c);\n                insertion_sort( new, dis, id, dis2 );\n            }        \n        }\n\n        // random searching to kick start the process\n        int searchIterations = iFrame < 2 ? 20 : 5;\n        for(int k = 0; k < searchIterations; k++)\n        {\n            int id = (int(hash(uvec4(ifc.x, ifc.y * 3, iFrame, k)).x) % (MAX_PARTICLES / LIGHT_RATIO)) * LIGHT_RATIO; // search only lights\n            insertion_sort(new, dis, id, distance2Particle(id, p, w2c));\n        }\n    }\n    \n    fragColor = vec4(new);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}