{
    "Shader": {
        "info": {
            "date": "1712833447",
            "description": "Super POI with filter kernel options Expects texture packed as following: r:normal_x, g:normal_z, b: [5 bytes: height][3 bytes: material id], a:ao",
            "flags": 0,
            "hasliked": 0,
            "id": "Mcy3zz",
            "likes": 1,
            "name": "Fork SuperPOI P Udobnyj 614",
            "published": 3,
            "tags": [
                "test"
            ],
            "usePreview": 0,
            "username": "Udobnyj",
            "viewed": 109
        },
        "renderpass": [
            {
                "code": "//=========================\n// Material definitions\n//=========================\n\nconst vec3 nonPoiColor = vec3(0.4,0.3,0.1);\nconst vec3 nonPoiColorNight = vec3(0.2,0.2,0.3);\n\nconst vec3 backgroundColorTop = vec3(0.6, 0.7, 0.9);\nconst vec3 backgroundColorBottom = vec3(0.9, 0.9, 0.9);\n\nconst vec3 backgroundColorTopNight = vec3(0.05, 0.1, 0.2);\nconst vec3 backgroundColorBottomNight = vec3(0.3, 0.2, 0.7);\n\nconst vec3 groundGlowNight = vec3(0.5,0.5,1.0);\n\n// Day materials\n\nvec3 colorWindow = vec3(120./255., 180./255., 250./255. );\nvec3 colorWall = vec3(220./255., 220./255., 165./255. );\nvec3 colorRoof = vec3(120.0/255.0, 110.0/255.0, 100.0/255.0);\nvec3 colorSign = vec3(255.0/255.0, 255.0/255.0, 50.0/255.0);\nvec3 colorDoor = vec3(250.0/255.0, 250.0/255.0, 230.0/255.0);\n\n// Night materials\n\nconst vec3 colorWindowNight = vec3(0.9,0.9,0.8);\nconst vec3 colorWallNight = vec3(0.5,0.5,0.5);\nconst vec3 colorRoofNight = vec3(80.0/255.0, 70.0/255.0, 60.0/255.0);\nconst vec3 colorSignNight = vec3(255.0/255.0, 255.0/255.0, 50.0/255.0);\nconst vec3 colorDoorNight = vec3(250.0/255.0, 250.0/255.0, 230.0/255.0);\n\n//=========================\n// Material ID constants\n//=========================\n\nconst float idBgr = 0.; \nconst float idWall = 1.;\nconst float idWindow = 2.;\nconst float idRoof = 3.;\nconst float idSign = 4.;\nconst float idDoor = 5.;\n\n//=========================\n// Configuration parameters\n//=========================\n\nconst float fixedDayNightInterpolant = 0.3;\nconst float fixedLightAngle = 1.0;\n\nfloat selectDayNightInterpolant(float dynValue){\n    return dynValue;\n    //return fixedDayNightInterpolant;\n}\n\nfloat selectLightAngleInterpolant(float dynValue){\n    return dynValue;\n    //return fixedLightAngle;\n}\n\n//=========================\n// Texture parameters\n//=========================\n\nconst float g_textureSize = 512.; // Input texture size\nconst float g_renderSize = 256.;  // Pixel size of output uv range\n\n//=========================\n// Functions\n//=========================\n\nvec3 screenBlend(vec3 Cs, vec3 Cd){\n    return Cs+Cd-Cs*Cd;\n}\n\n// Function to check if two colors are similar within a margin of error\nbool isColorSimilar(vec3 color1, vec3 color2, float margin) {\n    vec3 diff = abs(color1 - color2); // Absolute difference between the colors\n    return (diff.r <= margin/255.0 && diff.g <= margin/255.0 && diff.b <= margin/255.0);\n}\n\nbool isValueSimilar(float value1, float value2, float margin) {\n    float diff = abs(value1 - value2); // Absolute difference between the colors\n    return (diff <= margin);\n}\n\n\nvec3 computeNormal(float nxr, float nzg){\n    float nx = -1.0 + 2.0 * nxr;\n    float nz = -1.0 + 2.0 * nzg;\n    if(abs(nx) < 0.01 && abs(nz) < 0.01){\n        return vec3(0.0, 1.0, 0.0);\n    }\n    float ny = sqrt(clamp(1. - nx*nx - nz*nz, 0.,1.)); \n    return normalize(vec3(nx,ny,nz));\n}\n\n\nfloat getDim(){\n    return g_renderSize;\n    //float dim = 512.;\n    float maxDim = iResolution.y * 0.9;\n    //float maxDim = 512.;\n    float dimChangeSpeed = 0.1;\n    float dim = (0.1 + abs( 0.9 * cos(dimChangeSpeed * iTime))) * maxDim;\n    \n    dim = (iMouse.x / iResolution.x) * maxDim;\n\n    \n    return dim;\n}\n\nvec2 getPoiUv(vec2 uvIn){\n    float dim = getDim();\n    float Lu = dim / iResolution.x;\n    float Lv = dim / iResolution.y;\n    vec2 L = vec2(Lu,Lv);\n    \n    float hu = 0.0;\n    float hv = 0.0;\n\n    if(Lu < 1.0)\n        hu = (1.0 - Lu)* 0.5;\n    if(Lv < 1.0)\n        hv = (1.0 - Lv)* 0.5;\n        \n    vec2 huv2 = vec2(hu,hv);\n    \n    vec2 uv = uvIn;\n    \n    uv = (uvIn - huv2) / L;\n    return uv;\n}\n\nbool isOutsidePoi(vec2 uvIn, vec2 uv){\n    float dim = getDim();\n\n    float Lu = dim / iResolution.x;\n    float Lv = dim / iResolution.y;\n    \n    vec2 pixCoord = uvIn * iResolution.xy;\n    \n    float rad = dim / 2.;\n    float rad2 = rad * rad;\n    vec2 cntr = 0.5 * iResolution.xy;\n    \n    vec2 dist = pixCoord - cntr;\n    if(dot(dist,dist) > rad2)\n        return true;\n    \n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nfloat lambertLight(vec3 normal){\n    float lightDirSpeed = 0.5;\n    float lightZ = iMouse.y / iResolution.y;\n    \n    lightZ = selectDayNightInterpolant(lightZ);\n    \n    float lightXYLen = sqrt(clamp(1.0 - lightZ * lightZ,0., 1.));\n    //vec3 lightDir = normalize(vec3(cos(lightDirSpeed * iTime), sin( lightDirSpeed * iTime), -1.0));\n    float lightDirValue = lightDirSpeed * iTime;\n    \n    lightDirValue = selectLightAngleInterpolant(lightDirValue);\n    \n    vec3 lightDir = normalize(vec3(cos(lightDirValue) * lightXYLen, sin( lightDirValue) * lightXYLen, -lightZ));\n    float intensity = abs(dot(normal, lightDir));\n    return intensity;\n}\n\n// Function to determine the color based on the mat.png texture\nvec3 computeColorNight(vec2 uvIn, vec2 uv) {    \n    if(isOutsidePoi(uvIn, uv)){\n        return nonPoiColorNight;\n    }\n\n    vec3 backgroundColor = mix(backgroundColorBottomNight, backgroundColorTopNight, uv.y);\n    \n    vec4 sharedSample = texture(iChannel0, uv);\n    vec3 finalColor;   \n    float matsample = sharedSample.b;\n    float matdiscrete = matsample * 255.;\n    \n    int materialValue = int(matdiscrete) & 7; // 7 is 0000 0111 in binary\n    float mv = float(materialValue);\n    int heightValue = int(matdiscrete) >> 3;\n\n    float heightFloat = float(heightValue)/63.;\n    \n    float aosample = sharedSample.a;\n    vec3 normal = computeNormal(sharedSample.r, sharedSample.g);\n    \n    float intensity = lambertLight(normal);\n\n    float idBgr = 0.; \n    float idWall = 1.;\n    float idWindow = 2.;\n    float idRoof = 3.;\n    float idSign = 4.;\n    float idDoor = 5.;\n    \n    float margin = 0.0; // Margin of error for id\n\n    float emissiveFactor = 0.0;\n\n    // Check mat.png alpha\n    if (mv == 0.0) {\n        finalColor = backgroundColor;\n        //finalColor = vec3(1.0,0.0,0.0);\n    } else {\n        // Select color based on mat.png RGB value with a margin of error\n        if (isValueSimilar(mv, idWindow, margin)) {\n            finalColor = colorWindowNight;\n            emissiveFactor = 1.0;\n            //return finalColor;\n        } else if (isValueSimilar(mv, idWall, margin)) {\n            finalColor = colorWallNight;\n        } else if (isValueSimilar(mv, idRoof, margin)) {\n            finalColor = colorRoofNight;\n        } else if (isValueSimilar(mv, idSign, margin)) {\n            finalColor = colorSignNight;\n            emissiveFactor = 1.0;\n        } else if (isValueSimilar(mv, idDoor, margin)) {\n            finalColor = colorDoorNight;\n            emissiveFactor = 1.0;\n        } else {\n            // Default color or other logic for unmatched colors\n            finalColor = vec3(1.0,1.0,.10); // White or any other default\n        }\n        //return finalColor;\n        // Apply ambient occlusion effect\n\n        vec3 finalLit = finalColor;\n        finalLit *= aosample;\n        finalLit *= intensity;\n        \n        finalColor = mix(finalLit, finalColor, emissiveFactor);\n        \n        //Add height based ground glow\n        vec3 groundDark =  vec3(0.0,0.0,0.0);\n        vec3 groundLight =  vec3(0.5,0.5,1.0);\n        vec3 downglow = mix(groundLight, groundDark, clamp(10. * heightFloat,0.0,1.0));\n        \n        finalColor = mix(screenBlend(finalColor, downglow), finalColor, emissiveFactor);\n       \n    }\n\n    return finalColor;\n} // Night ends\n\n\n// Function to determine the color based on the mat.png texture\nvec3 computeColorDay(vec2 uvIn, vec2 uv) {\n    \n    if(isOutsidePoi(uvIn, uv)){\n        return nonPoiColor;\n    }\n\n    vec3 backgroundColor = mix(backgroundColorBottom, backgroundColorTop, uv.y);\n    \n    vec4 sharedSample = texture(iChannel0, uv);\n    vec3 finalColor;   \n    float matsample = sharedSample.b;\n    \n    float matdiscrete = matsample * 255.;\n    \n    int materialValue = int(matdiscrete) & 7; // 7 is 0000 0111 in binary\n    float mv = float(materialValue);\n    int heightValue = int(matdiscrete) >> 3;\n\n    float heightFloat = float(heightValue)/63.;\n    \n    float aosample = sharedSample.a;\n    vec3 normal = computeNormal(sharedSample.r, sharedSample.g);\n    \n    float intensity = lambertLight(normal);\n   \n    float margin = 0.0; // Margin of error for id\n    float emissiveFactor = 0.0;\n    // Check mat.png alpha\n    if (mv == 0.0) {\n        finalColor = backgroundColor;\n        //finalColor = vec3(1.0,0.0,0.0);\n    } else {\n        // Select color based on mat.png RGB value with a margin of error\n        if (isValueSimilar(mv, idWindow, margin)) {\n            finalColor = colorWindow;\n            emissiveFactor = 0.7;\n        } else if (isValueSimilar(mv, idWall, margin)) {\n            finalColor = colorWall;\n        } else if (isValueSimilar(mv, idRoof, margin)) {\n            finalColor = colorRoof;\n        } else if (isValueSimilar(mv, idSign, margin)) {\n            finalColor = colorSign;\n        } else if (isValueSimilar(mv, idDoor, margin)) {\n            finalColor = colorDoor;\n        } else {\n            // Default color or other logic for unmatched colors\n            finalColor = vec3(1.0,1.0,.10); // White or any other default\n        }\n        // Apply ambient occlusion effect\n        \n        vec3 finalLit = finalColor;\n        finalLit *= aosample;\n        finalLit *= intensity;\n        \n        finalColor = mix(finalLit, finalColor, emissiveFactor);\n    }\n\n    return finalColor;\n} // end day color\n\nvec3 getColorForUV(vec2 uvIn, vec2 uv)\n{\n    float nigthLimit = 0.20;\n    float daynight = iMouse.y / iResolution.y;\n    daynight = selectDayNightInterpolant(daynight);\n    if(daynight < nigthLimit)\n    {\n        float mixVal = clamp(1.0 - 1.5 * (daynight/nigthLimit),0.,1.);\n        vec3 col = mix(computeColorDay(uvIn, uv), computeColorNight(uvIn, uv), mixVal);\n        return col;\n    }\n    else\n    {\n        vec3 col = computeColorDay(uvIn, uv);\n        return col;\n    }\n}\n\nvec3 sampleColors(vec2 fragCoord)\n{\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 uv = getPoiUv(uvIn);\n    return getColorForUV(uvIn,uv);\n}\n\n\n\nvec4 bilinearSample4(vec2 fragCoord) {\n\tvec2 res = vec2(g_textureSize);\n\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 uv = getPoiUv(uvIn);\t\t\t\t\n\n    vec2 st = uv * res - 0.5;\n\n    vec2 iuv = floor( st );\n    vec2 fuv = fract( st );\n\n    vec3 a = getColorForUV(uvIn, (iuv+vec2(0.5,0.5))/res );\n    vec3 b = getColorForUV(uvIn, (iuv+vec2(1.5,0.5))/res );\n    vec3 c = getColorForUV(uvIn, (iuv+vec2(0.5,1.5))/res );\n    vec3 d = getColorForUV(uvIn, (iuv+vec2(1.5,1.5))/res );\n\n    return vec4(mix(\n        mix( a, b, fuv.x),\n        mix( c, d, fuv.x), fuv.y\n    ), 1.0);\n}\n\n\nvec4 boxBlur(vec2 fragCoord, int radius) {\n\tvec2 texSize = vec2(g_textureSize);\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 uv =  getPoiUv(uvIn); \n    vec3 sum = vec3(0.0);\n    int count = 0;\n    for (int dx = -radius; dx <= radius; dx++) {\n        for (int dy = -radius; dy <= radius; dy++) {\n            vec2 offset = vec2(dx, dy) / texSize;\n            uvIn = (fragCoord + offset) / iResolution.xy;\n            sum += getColorForUV(uvIn, uv + offset);\n            count++;\n        }\n    }\n    sum = sum / float(count);\n    return vec4(sum, 1.0);\n}\n\nvec4 gaussianBlur(vec2 fragCoord, int radius) {\n    vec2 texSize = vec2(g_textureSize);\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 uv =  getPoiUv(uvIn); \n    float sigma = float(radius) / 3.0;\n    float twoSigmaSquare = 2.0 * sigma * sigma;\n    float sigmaRoot = sqrt(twoSigmaSquare * 3.14159265);\n    vec3 sum = vec3(0.0);\n    float weightSum = 0.0;\n    float sizeOfRenderedAreaInPixels = getDim();\n    \n    //float pixelOffset = dimscale / texSize;\n    \n    for (int dx = -radius; dx <= radius; dx++) {\n        for (int dy = -radius; dy <= radius; dy++) {\n            //vec2 offset = vec2(dx, dy) / (sizeOfRenderedAreaInPixels );\n            vec2 offset = vec2(dx, dy) / (texSize );\n            float ef = float(dx * dx + dy * dy);\n            float weight = exp(-ef / twoSigmaSquare) / sigmaRoot;\n            sum += getColorForUV(uvIn, uv + offset) * weight;\n            weightSum += weight;\n        }\n    }\n    sum = sum / weightSum;\n    return vec4(sum,1.0);\n}\n\nfloat sinc(float x) {\n    if (x == 0.0) {\n        return 1.0;\n    }\n    float pix = 3.14159265 * x;\n    return sin(pix) / pix;\n}\n\n// Lanczos function, using sinc\nfloat lanczos(float x, float a) {\n    if (x > -a && x < a) {\n        return sinc(x) * sinc(x / a);\n    }\n    return 0.0;\n}\n\nvec4 lanczosSample(vec2 fragCoord, int a, float kerScale) {\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 texSize = vec2(g_textureSize);\n    vec4 sum = vec4(0.0);\n    vec2 uv = getPoiUv(uvIn);\n    float weightSum = 0.0;\n\n    // Convert UV to correspond to the original texture size\n    vec2 coord = uv * texSize;\n    kerScale  = 1./kerScale;\n    // Lanczos resampling\n    for (int i = -a + 1; i < a; ++i) {\n        for (int j = -a + 1; j < a; ++j) {\n            float xWeight = lanczos(kerScale * (float(i) - fract(coord.x)), float(a));\n            float yWeight = lanczos(kerScale * (float(j) - fract(coord.y)), float(a));\n            float weight = xWeight * yWeight;\n            \n            vec2 offset = vec2(float(i) - fract(coord.x), float(j) - fract(coord.y)) / texSize;\n            //vec4 sample = texture(textureSampler, uv + offset);\n            vec4 weightedSample = weight * vec4(getColorForUV(uvIn, uv + offset), 1.0);\n\n            sum += weightedSample;\n            weightSum += weight;\n        }\n    }\n\n    return sum / weightSum;\n}\n\nvec4 getLanczosSample(vec2 fragCoord){\n    return lanczosSample(fragCoord, 4,4.);\n}\n\nvec4 getBoxBlurConstSampleEven(vec2 fragCoord) {\n    int a = 4; \n    float kerScale = 1.0;\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 texSize = vec2(g_textureSize);\n    vec4 sum = vec4(0.0);\n    vec2 uv = getPoiUv(uvIn);\n    float weightSum = 0.0;\n\n    // Convert UV to correspond to the original texture size\n    vec2 coord = uv * texSize;\n    // Resampling\n    vec2 offsetInPixelsOrig = vec2(-1.5, -1.5);\n    \n    for (int i = 0; i < 4; ++i) {\n        for (int j = 0; j < 4; ++j) {\n            //float xWeight = lanczos(kerScale * (float(i) - fract(coord.x)), float(a));\n            //float yWeight = lanczos(kerScale * (float(j) - fract(coord.y)), float(a));\n            //float weight = xWeight * yWeight;\n            \n            float weight = 1.0;\n            vec2 offsetInPixels = offsetInPixelsOrig + vec2(float(i), float(j));\n            //vec2 offset = vec2(float(i) - fract(coord.x), float(j) - fract(coord.y)) / texSize;\n            vec2 offset = offsetInPixels / texSize;\n            //vec4 sample = texture(textureSampler, uv + offset);\n            vec4 weightedSample = weight * vec4(getColorForUV(uvIn, uv + offset), 1.0);\n\n            sum += weightedSample;\n            weightSum += weight;\n        }\n    }\n\n    return sum / weightSum;\n}\n\n\nvec4 getSingleSample(vec2 fragCoord){\n    vec2 uvIn = fragCoord / iResolution.xy;\n    vec2 uv = getPoiUv(uvIn);\t\t\t\t\n\n    return vec4(getColorForUV(uvIn, uv), 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragColor = getSingleSample(fragCoord);\n    fragColor = bilinearSample4(fragCoord);\n\n    //fragColor = getLanczosSample(fragCoord);\n    //fragColor = getBoxBlurConstSampleEven(fragCoord);\n    \n    //vec4 c1 = getLanczosSample(fragCoord);\n    //vec4 c2 = getBoxBlurConstSampleEven(fragCoord);\n    //fragColor = 10. * abs(c1 - c2);\n\n    //vec4 c1 = getSingleSample(fragCoord);\n    //vec4 c2 = bilinearSample4(fragCoord);\n    //fragColor = abs(c1 - c2);\n    \n    //fragColor = boxBlur(fragCoord, 2);\n    //fragColor = boxBlurConst(fragCoord, 4);\n    //fragColor = gaussianBlur(fragCoord, 2);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}