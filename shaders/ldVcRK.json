{
    "Shader": {
        "info": {
            "date": "1522936874",
            "description": "Continue playing with folding and lattice.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldVcRK",
            "likes": 9,
            "name": "CrystalCave",
            "published": 3,
            "tags": [
                "reflection",
                "tunnel",
                "folding",
                "lattice"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 812
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Continue playing with folding lattice\n\n#define PI 3.14159265\n\nvec3 path(float p)\n{\n\treturn vec3(sin(p*0.05)*cos(p*0.05)*18., 0.,0.);\n}\n\n// folding from gaz: https://www.shadertoy.com/view/4tX3DS\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    // change iteration to see different variations\n    for(int i = 0; i < 2; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nvec3 tri(vec3 p)\n{\n    return abs(fract(p)-0.5);\n}\n\nfloat tri_surf(vec3 p)\n{\n    return dot(tri(p*0.5+tri(p*0.25)), vec3(0.6666));\n}\n\nint mateid=0;\n\nfloat map(vec3 p)\n{\n    mateid=0;\n    \n    p-=path(p.z);\n    \n    vec3 q=p;\n    \n    p.z*=0.6;\n    p=vec3(rot(0.07*p.z)*p.xy, p.z);\n    p.xy=fold(p.xy,PI/3.);\n    vec3 p1=mod(p,2.5)-1.25;\n\t\n    float ts=0.5-tri_surf(p*7.);\n    // variation of BCC lattice from paniq: https://www.shadertoy.com/view/llfGRj\n    vec3 o=abs(p1); \n    o-=(o.x*1.95+o.y+o.z)*0.33333;\n    float d0=max(o.x,max(o.y,o.z))-0.03+0.05*ts;\n    \n    // another layer\n\tvec3 p2=mod(p-vec3(4.2,0.,0),2.5)-1.25;\n    o = abs(p2); \n    o-=(o.x*1.8+o.y+o.z)*0.33333;\n    float d4=max(o.x,max(o.y,o.z))-0.01+0.05*ts;\n    if(d4<d0)\n    {\n        d0=d4;\n        mateid=2;\n    }\n    \n    float d1=length(q.xy)-1.+0.2*ts;\n    d0=max(d0,-d1);\n   \n    float d2=abs(q.y+1.1+0.02*texture(iChannel1,0.1*q.xz).x);\n    if(d2<d0) mateid=1;\n    \n    d0=min(d0,d2);    \n\n    return d0;\n}\n\nvec3 get_normal(vec3 p)\n{ \n    vec3 e=vec3(0.003,0.0,0.0); \n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy), \n                          map(p+e.yxy)-map(p-e.yxy), \n                          map(p+e.yyx)-map(p-e.yyx))); \n} \n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t=0.01;\n    float d=map(ro+t*rd);\n    for(int i=0;i<128;++i)\n    {\n        if(abs(d)<0.001||t>100.)\n            continue;\n        t+=d;\n        d=map(ro+t*rd);\n    }\n    if(t>100.)t=-1.;\n    return t;\n}\n\nvec3 hash13(float n)\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// curvature from iq: https://www.shadertoy.com/view/MsXGzM\nfloat curvature(vec3 p, vec3 n)\n{\n    float acc=0.0;\n    for(int i=0;i<4;i++)\n    {\n        vec3 aopos=normalize(hash13(float(i)*213.47));\n        aopos=aopos-dot(n,aopos)*n;\n        aopos=p+aopos*0.03;\n        float dd=clamp(map(aopos)*100.0, 0.0, 1.0 );\n        acc+=dd;\n    }\n    return smoothstep(0.2, 1.0, acc/4.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd, float dist)\n{\n    float res=1.0;\n    float t=0.05;\n    float h;\n    \n    for(int i=0;i<12;i++)\n    {\n        if(t>dist) continue;\n        h=map(ro+rd*t);\n        res = min(6.0*h/t, res);\n        t+=h;\n    }\n    return max(res, 0.0);\n}                                                           \n\n// density from aiekick: https://www.shadertoy.com/view/lljyWm\nfloat density(vec3 p, float ms) \n{\n\tvec3 n = get_normal(p); \n\treturn map(p-n*ms)/ms;\n}\n\n// env mapping from Shane: https://www.shadertoy.com/view/4ttGDH\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\nvec3 env_map(vec3 rd, vec3 n)\n{\n    vec3 col = texcube(iChannel1, rd, n).xyz;\n    return smoothstep(0., 1., col);\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord.xy/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(0.,0.,-iTime*2.);\n    vec3 ta=ro+vec3(0,0,-1.);\n    \n    vec3 lp0=ro+vec3(0,-0.6,-3.);\n    \n    ro+=path(ro.z);\n    ta+=path(ta.z);\n\tlp0+=path(lp0.z);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0,1,0)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(mat3(r,u,f)*vec3(p.xy,PI/2.));\n    vec3 col=vec3(0.6,0.8,1.1);\n\n    float t=intersect(ro,rd);\n    if(t>-0.5)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 n=get_normal(pos);\n        \n        vec3 mate=2.*vec3(.9,0.3,.9);\n        float cur = curvature(pos, n);\n        \n        mate+=cur*vec3(1.);\n        if(mateid==1)\n        {\n        \tvec3 tex=texture(iChannel1,0.5*pos.xz).xyz;\n            mate=1.*vec3(.6*tex.x,.8*tex.x,1.*tex.x);\n        }\n        else if(mateid>1)\n        {\n            mate=2.*vec3(1.2,.85,.2);\n        }\n                \n        vec3 ld0=lp0-pos;\n        float ldist=length(ld0);\n        ld0/=ldist;\n        vec3 lc0=vec3(1.2,0.8,0.5);\n        \n        float sha=shadow(pos+0.01*n, ld0, ldist);\n        float dif=max(0.,dot(n,ld0))*sha;\n        float bac=max(0.,dot(n,-ld0));\n        float amb=max(0.,dot(n,vec3(0,1,0)))*max(0.,(pos.y+1.));\n        float spe=pow(clamp(dot(ld0, reflect(rd, n)), 0.0, 1.0), 16.0);\n        float fre=clamp(1.0+dot(rd,n), .0, 1.); \n        \n        float sca=1.-density(pos,0.2);\n \n        vec3 Lo=(2.5*dif*lc0+\n                 5.*spe*vec3(1.)*sha+\n                 pow(fre,8.)*vec3(1.1))/(ldist);\n        Lo+=.5*amb*vec3(0.5,0.8,1.);    \n        Lo+=0.3*bac*lc0;\n        \n        vec3 refl=env_map(reflect(rd,n), n);\n        vec3 refr=env_map(refract(rd,n,1./1.35), n);\n\n        if(mateid==2)\n        \tLo+=vec3(1.2,0.6,0.2)*sca*0.25;\n        if(mateid==0)\n        \tLo+=vec3(0.2,0.6,1.2)*sca*0.25*sha;\n        Lo+=mix(refr,refl,pow(fre, 5.));\n        \n        col=mate*Lo*0.2;\n    }\n\n    col=mix(col, .6*vec3(2.3,0.6,1.1), 1.0-exp(-0.0034*t*t) );\n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));    \n    col=pow(col,vec3(0.95,.9,0.85));\n    col*=pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n    fragColor.xyz=col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}