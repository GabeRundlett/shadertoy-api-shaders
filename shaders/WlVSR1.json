{
    "Shader": {
        "info": {
            "date": "1582511972",
            "description": "Practice timeline control",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVSR1",
            "likes": 6,
            "name": "Marching of Boxes",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "nodo",
            "viewed": 430
        },
        "renderpass": [
            {
                "code": "precision highp float;\n\nconst float pi = acos(-1.);\nfloat sum = 0.0;\nfloat modid;\n\n///parameter\nfloat ss;\nfloat distotion;\nfloat diff;\nfloat speed;\nfloat proliferation;\nfloat scanning;\nfloat ly;\nvec3 ro, target;\nfloat fov;\nfloat concentrationline;\nfloat waveintensity;\n///\n\nmat2 rot(float t){\n    float s = sin(t),c = cos(t);\n    return mat2(c,s,-s,c);\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*pi/2.0 : atan(y, x);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\n\nfloat tl(float val, float offset, float range)\n{\n    float im = sum + offset;\n    float ix = im + range;\n    sum += offset + range;\n    return clamp((val - im) / (ix - im), 0.0, 1.0);\n}\n\nfloat eio(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nvoid timeline(float time){\n    \n\tfloat t = 0.0;\n\n    speed = 50.0;\n\n    \n    t = tl(time,1.0,1.0);\n    ly = mix(0.0,50.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    diff = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,0.5,1.0);\n    proliferation = mix(28.0,0.0,eio(t));\n    waveintensity = mix(0.0,10.0,eio(t));\n    \n    t = tl(time,0.5,4.0);\n    ro.x += sin(-2.0*pi*t)*70.0;\n    ro.z += sin(1.0*pi*t)*140.0;\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(1.0,3.0,eio(t));\n    concentrationline = mix(0.0,1.0,eio(t));\n    \n    t = tl(time,1.0,0.5);\n    fov = mix(fov,1.0,eio(t));\n    concentrationline = mix(concentrationline,0.0,eio(t));\n\n    t = tl(time,1.0,1.0);\n    diff = mix(diff,0.0,eio(t));\n\tproliferation = mix(proliferation,28.0,eio(t));\n\tly = mix(ly,0.0,eio(t));\n    waveintensity = mix(waveintensity,0.0,eio(t));\n\n\n   \n    \n    ro.z  += iTime*speed;\n    target = vec3(0.0,0.0,60.0+iTime*speed);\n}\n\n\n\nfloat map(vec3 p){\n\n    if(abs(p.z-iTime*speed-70.0) < 30.0 - proliferation && abs(p.x) < 30.0 - proliferation){\n        modid = floor(((p.x)/3.0))*floor(((p.z)/3.0));\n\t\tp.y -= 35.*diff - texture(iChannel0,vec2(modid/100.0)).r*70.0*diff;\n\t\tp.xz = mod(p.xz,3.0) - 1.5;\n    }  \n    \n    return sdBox(p,vec3(2.0));\n}\n\n//https://qiita.com/edo_m18/items/37d8773a5295bc6aba3d\nfloat hexDist(vec2 p)\n{\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    \n    return max(c, p.x);\n}\n\nvec4 hex2d(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - r * 0.5, r) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    vec2 id = gv - uv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    \n    return vec4(x, y, id);\n}\n\nfloat wallmap(vec3 p){   \n    p = -abs(p);\n    p.y += 250.5;\n    return sdPlane(p, vec4(0, 1, 0, 1));\n}\n\n\nvec4 tracewall(vec3 ro,vec3 rd){\n    vec3 rPos = ro;\n    float depth=0.0;\n    vec3 col = vec3(.0);\n    float d;\n    \n\tfor(int i = 0 ; i < 99;i++){\n        d = wallmap(rPos);\n        if(d < 0.001){\n            col = vec3(float(i)/9.0);\n            col = vec3(0.1-hex2d(rPos.xz*0.02).g);\n            col *= exp(col.r*5.0)*5.0;\n            \n            break;\n     \t} \n        \n        depth += d;\n        rPos = ro + rd * depth;\n    }\n    \n    \n    float time = iTime * 2.5;\n    float wavy = pow(sin(length(rPos.xz - target.xz)*0.004 - time), 5.0) + 0.1;\n    //waveintensity = 10.0;\n    wavy *= waveintensity;\n    \n    col = vec3(col *wavy)*vec3(0.0,0.6,0.3);\n    \n    return vec4(col,depth);\n }\n\n\nvec3 getNormal(vec3 p){\n    float d = 0.01;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    timeline(mod(iTime,17.0));\n    \n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n\n    \n    mat3 c = camera(ro, target, 0.0);\n    vec3 rd = c * normalize(vec3(uv, fov));\n    \n\n    vec3 lightPos = target;\n    vec3 lightPos2 = target;\n    vec3 lightPos3 = target;\n    \n    \n    vec3 an = vec3(0.0,ly,0.0);\n    an.xy *= rot(iTime*2.0);\n\n    lightPos2 += an;\n    lightPos3 -= an;\n  \n\n    vec3 col = vec3(0.0);\n    vec3 rPos = ro;\n    float depth = 0.0;\n    float mat;\n    float l2min = 99.0;\n    float l3min = 99.0;\n\n    for(int i = 0 ; i < 225;i++){\n        mat = map(rPos);\n        \n        if(mat < 0.001){\n            col = vec3(1.0-float(i)/250.);\n            break;\n        }\n        \n        if(depth > 500.0){\n            depth = 400.0;\n            break;\n        }\n        \n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        depth += min(min((step(0.0,rd.x)-fract(rPos.x))/rd.x, (step(0.0,rd.z)-fract(rPos.z))/rd.z)+0.01,mat);\n        rPos = ro + rd * depth;\n        \n        l2min = min(l2min,length(lightPos2 - rPos)/3.5);\n        l3min = min(l3min,length(lightPos3 - rPos)/3.5);\n\n    }\n    \n    l2min *= step(0.5,l2min);\n    l3min *= step(0.5,l3min);\n\n    vec4 backcol = tracewall(ro,rd);\n    \n    vec3 n = getNormal(rPos);\n    vec3 r = normalize(reflect(rd,n));\n        \n    ///light1\n    vec3 lv = lightPos - rPos;\n    vec3 ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a = max(1.0-(length(lv)/20.5),0.0)*1.5;\n    float d = max(dot(ld,n),0.);\n    float s = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    ///light2\n    lv = lightPos2 - rPos;\n    ld = normalize(lv);\n    //ld = normalize(vec3(0.2,0.6,0.3));\n\n    float a2 = max(1.0-(length(lv)/25.5),0.0)*3.5;\n    float d2 = max(dot(ld,n),0.);\n    float s2 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc2 = vec3(a2+d2+s2)*vec3(1.0,0.0,0.0);\n    \n    \n    ///light3\n    lv = lightPos3 - rPos;\n    ld = normalize(lv);\n\n    float a3 = max(1.0-(length(lv)/25.5),0.0)*1.5;\n    float d3 = max(dot(ld,n),0.);\n    float s3 = pow(max(dot(ld,r),0.), 30.0) * a;\n    \n    vec3 lc3 = vec3(a3+d3+s3)*vec3(0.0,1.0,0.0);\n  \n    \n    \n    float _Threshold = 0.1;\n    vec3 glow = max(abs(dot(rd, n)-_Threshold), 0.0)*vec3(0.1,0.5,0.6);\n    vec3 grid = vec3(step(2.9,mod(rPos,3.0)));\n    float k = 10.;\n    vec3 gridd = max(grid.x,max(grid.y,grid.z))*vec3(0.1,0.5,0.8);\n        \n    col = vec3(d+s+a)+lc2+lc3;\n\n    col *= glow;\n    gridd *= exp(k*sin(length(rPos)))/exp(k);\n    col += 5.0*gridd;\n        \n    depth *= 10.0;\n    \n    vec3 bgc = vec3(0.0,0.3,0.3);\n    //bgc = vec3(1.0);\n    if(depth > 1000.){\n        col = vec3(bgc);\n    }\n    \n    \n    //https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\n    float f = exp2Fog(backcol.a, 0.0014);\n    //backcol.rgb = mix(vec3(0.2,0.5,0.8), backcol.rgb, f);\n    backcol.rgb = mix(bgc, backcol.rgb, f);\n\n\n    if(depth > backcol.a){\n        col = backcol.rgb;\n    }\n    //  col = backcol.rgb;\n    col += max((1.0 - l2min)*vec3(1.0,0.0,0.0),0.0);\n    col += max((1.0 - l3min)*vec3(0.0,0.0,1.0),0.0);\n\n    \n    //ネガポジ反転//\n    //col = vec3(1.0) - col;\n    \n    \n    // zoom line  http://sayachang-bot.hateblo.jp/entry/2019/02/09/200303    \n    float t = length(uv)*0.07 - 0.05;\n    \n    float rr = length(uv);\n    rr = 0.8 * rr - 0.8;\n\n    a = atan2(uv.y, uv.x);\n    a = abs(cos(70. * a) + sin(30. * a));\n\n    d = a - rr;\n    float nn = smoothstep(0.1, 0.4, clamp(d, 0.0, 1.0));\n    \n    col += max((.5 - nn)*t*concentrationline,0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}