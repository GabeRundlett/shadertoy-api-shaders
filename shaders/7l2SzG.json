{
    "Shader": {
        "info": {
            "date": "1627981283",
            "description": "This was my first polar integration excercise (probably not a good choice). To set the anchor point, click, hold, then release on the anchor point.",
            "flags": 32,
            "hasliked": 0,
            "id": "7l2SzG",
            "likes": 14,
            "name": "Flower - Moment of Inertia",
            "published": 3,
            "tags": [
                "2d",
                "flower",
                "physics",
                "inertia",
                "momentofinertia"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 204
        },
        "renderpass": [
            {
                "code": "// See https://www.desmos.com/calculator/yci98meozk\n\n// SDFs\nvec3 dMul(in vec3 f, in vec3 g) { return vec3(f.x * g.x, f.y * g.x + f.x * g.y, f.z * g.x + 2.0 * f.y * g.y + f.x * g.z); }\nvec3 dCos(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(co, -si * f.y, -co * f.y * f.y - si * f.z); }\nvec3 dSin(in vec3 f) { float co = cos(f.x), si = sin(f.x); return vec3(si,  co * f.y, -si * f.y * f.y + co * f.z); }\nfloat sdFlower(in vec2 p, in float c, in float a, in float f) {\n    float ang = mod(atan(p.y, p.x) + PI / f, 2.0 * PI / f) - PI / f;\n    p = vec2(cos(ang), sin(ang)) * length(p);\n    p.y = abs(p.y);\n\n    float t = 0.5 * PI / f;\n    if (p.x < c - a && a < 0.5 * c) t *= 1.5;\n    if (p.x > c + a) t = f < 4.0 ? 0.25 : 0.1;\n\n    for (int n=0; n < 10; n++) {\n        vec3 r = vec3(c, 0.0, 0.0) + a * dCos(f * vec3(t, 1.0, 0.0));\n        vec3 dx = dMul(dCos(vec3(t, 1.0, 0.0)), r) - vec3(p.x, 0.0, 0.0);\n        vec3 dy = dMul(dSin(vec3(t, 1.0, 0.0)), r) - vec3(p.y, 0.0, 0.0);\n        vec3 dist = dMul(dx, dx) + dMul(dy, dy);\n        t -= dist.y / dist.z;\n    }\n\n    float r = c + a * cos(f * ang);\n    return length(p - vec2(cos(t), sin(t)) * (c + a * cos(f * t))) * sign(dot(p, p) - r * r);\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n    float co = cos(ang), si = sin(ang);\n    mat2 rot = mat2(co, si, -si, co);\n\n    vec2 flowerUv = rot * (uv - AXIS) + AXIS;\n    float flower = sdFlower(flowerUv, RADIUS, AMP, FREQ);\n\n    drawSDF(flower, vec3(1.0, 0.0, 0.0));\n    if (dot(flowerUv, flowerUv) > 0.1) drawSDF(abs(flower), vec3(1.0, 0.8, 0.0)); // Conditional to avoid artifact in the middle\n    drawSDF(length(uv - AXIS) - 0.05, vec3(1.0, 0.8, 0.0));\n\n    float aspect = iResolution.x / iResolution.y;\n    color = digitIn(color, vec3(1.0), uv * 0.25 + vec2(0.45 * aspect, 0.45), 100.0, flowerInertia(RADIUS, AMP, FREQ, AXIS));\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants\n#define PI 3.14159265359\n\n// Flower settings (AMP and FREQ control petals)\n#define RADIUS 1.0\n#define AMP 0.5\n#define FREQ 5.0\n#define AXIS (ivec2(iMouse.xy) == ivec2(0) ? vec2(-1.0, 0.6) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 4.0)\n#define DENSITY 0.1\n\n// Simulation settings\n#define FRICTION 0.98\n#define GRAVITY 0.2\n\n// cross3D(vec3(a.x, a.y, 0), vec3(b.x, b.y, 0))\n// Since the x and y components of the result are always zero\n// The z component is the only one of interest\nfloat cross2D(in vec2 a, in vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\n\n// Centroid of a flower shape\nvec2 flowerCentroid(in float c, in float a, in float f) {\n    return a / (4.0 * PI) * vec2(sin((1.0 - f) * 2.0 * PI) / (1.0 - f) + sin((1.0 + f) * 2.0 * PI) / (1.0 + f), (1.0 - cos((1.0 - f) * 2.0 * PI)) / (1.0 - f) + (1.0 - cos((1.0 + f) * 2.0 * PI)) / (1.0 + f));\n}\n\n// Mass of a flower shape\nfloat flowerMass(in float c, in float a, in float f, in float density) {\n    float c2 = c * c, a2 = a * a;\n    return ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * density;\n}\n\n/*\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c,  a2 = a  * a;\n    float c3 = c2 * c,  a3 = a2 * a;\n    float c4 = c2 * c2, a4 = a2 * a2;\n\n    float I = (8.0 * c4 + 24.0 * c2 * a2 + 3.0 * a4) * PI / 16.0 + ((4.0 * c3 * a + 3.0 * c * a3) / 4.0 * sin(2.0 * f * PI) + (6.0 * c2 * a2 + a4) / 16.0 * sin(4.0 * f * PI) + c * a3 / 12.0 * sin(6.0 * f * PI) + a4 / 128.0 * sin(8.0 * f * PI)) / f;\n    I -= ((c2 * a + a3 / 4.0) * (       sin((1.0 - f) * 2.0 * PI)  / (1.0 - f) +        sin((1.0 + f) * 2.0 * PI)  / (1.0 + f)) + c * a2 / 2.0 * (       sin((1.0 - 2.0 * f) * 2.0 * PI)  / (1.0 - 2.0 * f) +        sin((1.0 + 2.0 * f) * 2.0 * PI)  / (1.0 + 2.0 * f)) + a3 / 12.0 * (       sin((1.0 - 3.0 * f) * 2.0 * PI)  / (1.0 - 3.0 * f) +        sin((1.0 + 3.0 * f) * 2.0 * PI)  / (1.0 + 3.0 * f))) * p.x;\n    I -= ((c2 * a + a3 / 4.0) * ((1.0 - cos((1.0 - f) * 2.0 * PI)) / (1.0 - f) + (1.0 - cos((1.0 + f) * 2.0 * PI)) / (1.0 + f)) + c * a2 / 2.0 * ((1.0 - cos((1.0 - 2.0 * f) * 2.0 * PI)) / (1.0 - 2.0 * f) + (1.0 - cos((1.0 + 2.0 * f) * 2.0 * PI)) / (1.0 + 2.0 * f)) + a3 / 12.0 * ((1.0 - cos((1.0 - 3.0 * f) * 2.0 * PI)) / (1.0 - 3.0 * f) + (1.0 - cos((1.0 + 3.0 * f) * 2.0 * PI)) / (1.0 + 3.0 * f))) * p.y;\n    I += ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * dot(p, p);\n\n    return I;\n}\n*/\n\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c, a2 = a  * a;\n    float c3 = c2 * c, a3 = a2 * a;\n    float c4 = c3 * c, a4 = a3 * a;\n\n    float I = (8.0 * c4 + 24.0 * c2 * a2 + 3.0 * a4) * PI / 16.0 + ((4.0 * c3 * a + 3.0 * c * a3) / 4.0 * sin(2.0 * f * PI) + (6.0 * c2 * a2 + a4) / 16.0 * sin(4.0 * f * PI) + c * a3 / 12.0 * sin(6.0 * f * PI) + a4 / 128.0 * sin(8.0 * f * PI)) / f;\n    I -= ((2.0 * c2 * a + a3 / 2.0) * f / (f * f - 1.0) * sin(2.0 * f * PI) + 2.0 * c * a2 * f / (4.0 * f * f - 1.0) * sin(4.0 * f * PI) + a3 / 6.0 * f / (9.0 * f * f - 1.0) * sin(6.0 * f * PI)) * p.x;\n    I -= ((2.0 * c2 * a + a3 / 2.0) / (1.0 - f * f) * (1.0 - cos(2.0 * f * PI)) + c * a2 / (1.0 - 4.0 * f * f) * (1.0 - cos(4.0 * f * PI)) + a3 / 6.0 / (1.0 - 9.0 * f * f) * (1.0 - cos(6.0 * f * PI))) * p.y;\n    I += ((c2 + a2 / 2.0) * PI + (c * a * sin(2.0 * f * PI) + a2 / 8.0 * sin(4.0 * f * PI)) / f) * dot(p, p);\n\n    return I;\n}\n\n// SPECIAL CASE OF INTEGER FREQUENCY (no weird half petals and whatnot)\n/*\nvec2 flowerCentroid(in float c, in float a, in float f) {\n    return vec2(0.0, 0.0);\n}\n\n// Mass of a flower shape\nfloat flowerMass(in float c, in float a, in float f, in float density) {\n    return (c * c + a * a / 2.0) * PI * density;\n}\n\n// Moment of inertia of a flower shape about axis p\nfloat flowerInertia(in float c, in float a, in float f, in vec2 p) {\n    float c2 = c  * c, a2 = a  * a;\n    float I = (8.0 * c2 * c2 + 24.0 * c2 * a2 + 3.0 * a2 * a2) * PI / 16.0;\n    I += (c2 + a2 / 2.0) * PI * dot(p, p);\n    return I;\n}*/\n\n        /////////////////////////////////////////////////////////////////\n       //                                                            ////\n      //  \"little debugging font\"                                   // //\n     //                                                            //  //\n    //  This utility uses a small bitmapped font (3x5) to render  //   //\n   //  floats, primarily intended for debugging. The code can    //    //\n  //  be copy/pasta'd into the Common tab as needed.            //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //                                       //  //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2021                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n\nconst int CHARACTERS[14] = int[14](31599, 9362, 31183, 31207, 23524, 29671, 29679, 30994, 31727, 31719, 1488, 448, 2, 3640);\n\nfloat digitIsOn(in int digit, in vec2 id) {   \n    if (id.x < 0.0 || id.y < 0.0 || id.x > 2.0 || id.y > 4.0 ) return 0.0;\n    return floor(mod(float(CHARACTERS[int(digit)]) / pow(2.0, id.x + id.y * 3.0), 2.0));\n}\n\nfloat digitSign(in float v, in vec2 id) {\n    return digitIsOn(10 - int((sign(v) - 1.0) * 0.5), id);\n}\n\nint digitCount(in float v) {\n    return int(floor(log(max(v, 1.0) ) / log(10.0)));\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v, in int decimalPlaces) {\n    vec2 id = floor(uv * scale);\n\n    if (0.0 < digitSign(v, id)) return 1.0;\n    v = abs(v);\n\n    int digits = digitCount(v);\n    float power = pow(10.0, float(digits));\n    \n    float offset = floor(0.1 * scale);\n    id.x -= offset;\n\n    float n;\n    for (int i = 0; i < 33; i++, id.x -= offset, v -= power * n, power /= 10.0) {\n        n = floor(v / power);\n        if (0.0 < digitIsOn(int(n), id)) return 1.0;   \n        if (i == digits) {\n            id.x -= offset;\n            if (0.0 < digitIsOn(int(12), id)) return 1.0;\n        }\n\n        if (i >= digits + decimalPlaces) return 0.0;\n    }\n\n    return 0.0;\n}\n\nfloat digitFirst(in vec2 uv, in float scale, in float v) {\n    return digitFirst(uv, scale, v, 3);\n}\n\nvec3 digitIn(in vec3 color, in vec3 toMix, in vec2 uv, in float scale, in float v) {\n    float f = digitFirst(uv, scale, v);\n    return mix(color, toMix, f);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(0.0, 0.0, 0.0, 0.0);\n    addr -= 0.5;\n    ivec2 iAddr = ivec2(addr);\n    if (iFrame > 0 && iAddr == ivec2(0) && iMouse.z < 0.5) {\n        data = texelFetch(iChannel0, ivec2(0), 0);\n\n        float ang = texelFetch(iChannel0, ivec2(0), 0).x;\n        float co = cos(ang), si = sin(ang);\n        mat2 rot = mat2(co, si, -si, co);\n\n        vec2 centerOfMass = (flowerCentroid(RADIUS, AMP, FREQ) - AXIS) * rot;\n\n        vec2 force = vec2(0.0, -flowerMass(RADIUS, AMP, FREQ, DENSITY) * GRAVITY);\n        float torque = cross2D(-centerOfMass, force);\n\n        data.y += torque / flowerInertia(RADIUS, AMP, FREQ, AXIS);\n        data.y *= FRICTION;\n        data.x += data.y;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}