{
    "Shader": {
        "info": {
            "date": "1520594105",
            "description": "A dried out river bank with some evening scenery. Mouse to look around. Kind of continuation on my previous flow experiment https://www.shadertoy.com/view/4dtyWM",
            "flags": 0,
            "hasliked": 0,
            "id": "4styzj",
            "likes": 50,
            "name": "FlowingRiver",
            "published": 3,
            "tags": [
                "water",
                "grass",
                "flow",
                "river",
                "trees"
            ],
            "usePreview": 1,
            "username": "kuvkar",
            "viewed": 3653
        },
        "renderpass": [
            {
                "code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nconst float waterY = .0;\n// light\nconst vec3 ld = normalize(vec3(0.0, 2.1, 14.0));\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat water(vec2 uv) {\n    uv += noise(uv * .8);        \n    vec2 wv = 1.0-abs(sin(uv));\n    return (wv.x + wv.y) * .5;\n}\nfloat getCurve(in vec3 rp)\n{\n    float x = sin(rp.z * .1) * 2.4 + sin(rp.z * .22) * 1.;\n    x -= sin(rp.z * .02 - .0) * 21.5;\n    return x;\n}\n\nfloat shoreLine(vec3 rp)\n{\n    return abs(getCurve(rp) + rp.x);\n}\n\n\nfloat river(vec2 uv)\n{\n    float s = 0.;\n    const float levels = 4.;\n    mat2 r;\n    r[0] = vec2(0.4, 0.4);\n    r[1] = vec2(-0.24, 0.27);\n    for (float i = 1.; i < (levels + 1.); i = i + 1.)\n    {\n        uv *= r;\n        s += water(uv * i * 2.);\n    }\n    s /= (levels + 1.);\n    return s;\n}\n\n\nfloat mapEdge(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float edgeL = -1.;\n    float difx = 1.-abs(rp.x);\n    return difx;\n}\n\nfloat mapBottom(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float bottom = -.6;\n    float ax = abs(rp.x);\n    bottom += smoothstep(1., 10., ax);\n    bottom += (0.5 + 0.5 * noise(rp.xz * .3)) * .5;\n    float hill = smoothstep(65., 80., ax);\n    bottom += hill * 15.;\n    bottom += hill * sin(rp.z * .1) * 2.;\n    bottom += hill * sin(rp.z * .15) * 1.;\n    return bottom; \n}\n\nfloat mapHeightHQ(in vec3 rp)\n{\n    float bottom = mapBottom(rp);\n    float limit = smoothstep(45., 80., abs(rp.x)) * 3.;\n    bottom -= (0.4 * smoothstep(0.2, 0.5, noise(rp.xz * .13))) * limit;\n    bottom += (0.3 * smoothstep(0.1, 0.5, noise(rp.xz * .33))) * limit;\n    return rp.y - bottom;\n}\n\nfloat mapHeightLQ(in vec3 rp)\n{\n    return rp.y - mapBottom(rp);\n}\n\n\nvec3 grad(in vec3 rp, float bump)\n{\n    float hc = mapHeightHQ(rp);\n    vec2 off = vec2(1.1, 0.0);\n    float hh = mapHeightHQ(rp + off.xyy);\n    float hv = mapHeightHQ(rp + off.yyx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\n\nvec3 seagrad(in vec2 uv, float bump, float t)\n{\n    uv *= 14.;\n    float hc = river(uv);\n    vec2 off = vec2(3./t, 0.0);\n    float hh = river(uv + off);\n    float hv = river(uv + off.yx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nvec3 texgrad(in sampler2D tex, in vec2 uv, float bump)\n{\n    float hc = dot(texture(tex, uv).rgb, vec3(.33));\n    vec2 off = vec2(0.002, 0.0);\n    float hh = dot(texture(tex, uv + off).rgb, vec3(.33));\n    float hv = dot(texture(tex, uv + off.yx).rgb, vec3(.33));\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 0.)); \n    vec3 v = normalize(vec3(0., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nbool trace(inout vec3 rp, in vec3 rd)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec3 prevp = rp;\n    \n    // rough height map tracing\n    for (int i = 0; i < 350; ++i)\n    {\n        float dify = mapHeightLQ(rp);\n        if(dify < 0.)\n        {\n            hit = true;\n            break;\n        }\n        prevp = rp;\n        rp += rd * max(0.15, dify);\n        if(dot(ro - rp, ro - rp) > 150000.) break;\n    }\n\n    // detailed height map tracing\n    if(hit)\n    {\n        hit = false;\n        for (int i = 0; i < 25; ++i)\n        {\n            float dify = mapHeightHQ(rp);\n            if(dify < 0.)\n            {\n                hit = true;\n                break;\n            }\n            prevp = rp;\n            rp += rd * max(0.1, dify * (1.0 + log2(1.0 + length(ro - rp) * 1.5)));\n\t        if(dot(ro - rp, ro - rp) > 150000.) break;\n        }\n    }\n   \n    // binary search the surface\n    if(hit)\n    {\n        vec3 insidep = rp;\n        vec3 outsidep = prevp;\n        float cursor = 0.5;\n        \n        for (int i = 1; i < 20; ++i)\n        {\n        \trp = mix(outsidep, insidep, cursor);\n            float dist = mapHeightHQ(rp);\n            cursor += pow(0.5, float(i + 1)) * sign(dist);\n        }\n        \n    }\n    \n    return hit;\n    \n}\n \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.0, 1.0, 0.0)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\nvec4 colorSurface(in vec3 rp, in vec3 rd)\n{\n    vec4 color = vec4(0.);\n    \n    vec2 uv = rp.xz * .05;\n    color  = pow(texture(iChannel1, uv), vec4(2.2));\n    vec3 g = texgrad(iChannel1, uv, .2);\n    color.rgb *= 0.4 + 1.7 * max(0.0, dot(g, ld));\n    \n    float toEdge = smoothstep(-9., -2., mapEdge(rp * 1.1) + noise(rp.zx * 2.5));\n    color *= mix(1.0, toEdge, 0.7);\n    vec3 worldg = grad(rp, 1.2);\n    \n    float limit = smoothstep(25.0, 50.0, abs(mapEdge(rp)));\n    color += vec4(.01, .02, .0, 1.) * worldg.y * limit;\n    color += vec4(.01, .02, .0, 1.) * abs(worldg.x) * limit;\n    color.a = 1.;\n    return color;\n}\n\nvec2 flowGrad(in vec3 rp)\n{\n    vec3 off = vec3(.02, 0.0, 0.0);\n\t\n    float dc = mapEdge(rp);\n    float dh = mapEdge(rp + off);\n    float dv = mapEdge(rp + off.yyx);\n    \n    return -vec2(dh - dc, dv - dc);\n    \n}\n\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 2.0;\n    if(mixval > 1.0) mixval = 2.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .5, 1.0);\n    return mixval;\n}\n\nvec4 getTrees(in vec3 rd)\n{\n    float an = atan(rd.z, rd.x);\n    \n    vec4 trees = vec4(.0);\n    const float layers = 5.0;\n    float alpha = 0.0;\n    \n    for (float i = 1.; i <= layers; i = i + 1.0)\n    {\n        float offset = an * 2. + i * .5;\n        float colA =   texture(iChannel0, vec2(offset, offset)).r;\n        \n        float yp = (0.5 + 0.5 * sin(i + an * .5)) * .005;\n        yp += (0.5 + 0.5 * sin(i * 2. + an * 5.)) * .025;\n        yp -= .1 * cos(an * .1);\n        yp += rd.y;\n        \n        float layerH = max(0., .2- (i * .05));\n\t    colA *= smoothstep(layerH, layerH - .1, yp);\n        colA = smoothstep(.33, .37, colA);\n        float a = an * .05 + i * .01;\n        mat2 rm; rm[0] = vec2(cos(a), -sin(a)); rm[1] = vec2(sin(a), cos(a));\n        vec4 texCol = texture(iChannel2, (vec2(offset, yp * .4) * rm) * 4.) * colA;\n        texCol = smoothstep(-.6, 1.0, texCol);\n        texCol.rgb *= pow((1. / layers) * i, 1.0);\n        texCol.rgb *= vec3(0.25 , 0.3, 0.15) * .5;\n        \n        trees.rgb = texCol.rgb * colA + (1.0 - colA) * trees.rgb;\n        trees.a = clamp(trees.a + colA, 0.0, 1.0);\n    }\n    return trees;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(.5)) * vec2(1.0, iResolution.y / iResolution.x);\n    vec2 im = 1.5 * ((iMouse.xy / iResolution.xy) - vec2(0.5));\n    \n    vec3 rp = vec3(-.0, 17.5, -10.);\n    if(iMouse.z < 0. || iMouse.xy == vec2(0.))\n    {\n        im.xy = vec2(.11, .551);\n        rp.z += sin(iTime * .2);\n        rp.y += sin(iTime * .5);\n        rp.x += cos(iTime * .5);\n    }\n    \n\t// camera    \n    vec3 rd = normalize(vec3(uv, .4));\n    vec3 _rp = rp;\n    rp = roty(im.x * 5.) * rp;\n    rp.y = (rotx(im.y * 1.5) * _rp).y;\n    \n    \n    vec3 ro = rp;\n    rd = lookat(rp, vec3(.0, 4.0, 5.0)) * rd;\n    \n    \n    \n    // ground \n    bool hit = trace(rp, rd);\n    _rp = rp;\n    \n    if(hit) \n    {\n        fragColor = colorSurface(rp, rd);\n    }\n    \n    // water\n    if(rp.y < waterY && mapEdge(rp) > -30.)\n    {\n        vec3 n = vec3(0.0, 1.0, 0.0);\n        float t = (waterY - dot(ro, n))/dot(n, rd);\n        if(t > 0.)\n        {\n            vec3 p = ro+rd*t;\n            \n            float T = 4.;\n            \n            // texture offsets for advection\n            float cycle = mod(iTime, T)/T;\n            float o1, o2 = 0.;\n            float mv = getMixValue(cycle, o1, o2);\n            float dist = smoothstep(6., 1., shoreLine(p));\n            \n            // flow vec \n            vec2 sideFlow = (flowGrad(p))  * 3.;\n            float h = mapHeightLQ(p);\n            \n            vec2 flowFwd = flowGrad(vec3(shoreLine(vec3(0.0, 0.0, rp.z)), 0., rp.z)).yx * 3.;\n            float mixval = dist;//smoothstep(-5., 0., dist);\n            vec2 flow = mix(sideFlow, flowFwd, mixval);\n            \n            // normal\n            float speed = 50.;\n            vec2 scale = vec2(.35, .4);\n            float bmp = 0.1;\n            vec3 g1 = seagrad(scale * p.xz + flow * o1 * speed, bmp, t);\n            vec3 g2 = seagrad(scale * p.xz + flow * o2 * speed, bmp, t);\n            \n            vec3 g3 = seagrad(scale * p.xz + vec2(.1, .2) + flow * o1 * speed * .4, bmp, t);\n            vec3 g4 = seagrad(scale * p.xz + vec2(.3, .2) + flow * o2 * speed * .4, bmp, t);\n            \n\t\t\tvec3 gm = mix(g2, g1, mv);\n            gm += mix(g4, g3, mv);\n            gm = normalize(gm);\n            \n            // diffuse\n            vec4 blue = vec4(0., 69., 129., 0.) / 255.;\n            float wd = dot(gm, ld);\n            wd = max(0.0, wd);\n            float wrp = 0.5;\n            wd = (wd+wrp)/(1.+wrp);\n            vec4 difcol = blue;\n            \n            // spec\n            vec3 H = normalize(-rd + ld);\n            float specd = dot(H, gm);\n            specd = max(0.0, specd);\n            float sd = pow(max(0.0, specd), 58.0) * 1.;\n            \n            // fres\n            float fres = 1.-max(0., dot(-rd,gm));\n            vec4 lightblue = vec4(151./255., 203./255., 220./255., 0.);\n            vec4 orange = vec4(.7, .3, 0.1, 0.0);\n            fres = pow(fres, 2.)* 1.;\n            \n            // combined\n            vec4 frescol = fres*orange;\n            vec4 surfcol = frescol * .4 + difcol * wd * 0.2;\n            \n            vec3 refr = normalize(refract(rd, gm, .7));\n            \n            bool hit = trace(p, refr);\n            vec4 bottomColor = colorSurface(p,refr);\n            float mx = 1.-smoothstep(-.1, 2., -refr.y);\n            fragColor = mix(bottomColor, surfcol, mx);\n            fragColor +=vec4(sd);\n            \n            float foam = smoothstep(0.1, -0.5, h + noise(rp.xz * .15) * .2);//smoothstep(0.5, -1.4, mixval);\n            fragColor += foam * texture(iChannel2, .5 * p.xz + sideFlow * o1 * speed).rrrr;\n            fragColor += foam * texture(iChannel2, .5 * p.xz + sideFlow * o2 * speed).rrrr;\n            \n            fragColor.a = 1.;\n        }\n    }\n    else if(hit)\n    {\n        // grass\n        float toEdge = smoothstep(10.0, 7.0, shoreLine(_rp) + noise(_rp.xz) * 1.5);\n        toEdge += smoothstep(17.0, 87.0, shoreLine(_rp));\n        float H = .1;\n        vec3 rstp = rd/-rd.y;\n        rp -= rstp * H;\n        float STP = .002;\n        \n        bool hitGrass =false;\n        float i = 0.;\n        for (i = 0.0; i < H; i = i + STP)\n        {\n            vec4 tcl = texture(iChannel3, rp.xz * .6);\n            float D = .4 - i;\n            D += toEdge;\n            D += abs(noise(rp.xz * .015)) * .5;\n            if(D < tcl.g)\n            {\n                \n                hitGrass = true;\n                break;\n            }\n            rp += rstp * STP;\n        }\n        \n        if(hitGrass)\n        {\n            vec4 grassLow = vec4(0.08, 0.05, 0.0, 1.0);\n            vec4 grassHi = vec4(0.1, 0.1, 0.0, 1.0);\n            float depth = clamp(pow(1.0 - (i/H), 4.), 0.0, 1.0);\n            vec4 grassCol= mix(grassLow, grassHi, depth);\n            grassCol += texture(iChannel1, rp.xz * .05)*.25 * mix(1.0, depth, .4);\n            grassCol *= texture(iChannel1, rp.xz * .01).g;\n            fragColor =  grassCol;\n        }\n        \n        fragColor.a = 1.;\n        \n        vec3 g = grad(_rp, 1.2);\n        float d = max(0.0, dot(g, normalize(vec3(0.0, 1.0, 1.0)))) * 2. ;\n        float wrap = .4;\n        d = (d + wrap)/(1.0 + wrap);\n        fragColor.rgb *= d;\n        \n    }\n\n    \n    vec3 skyLow = vec3(.6, 0.7, 0.8);\n    vec3 skyHi = vec3(.6, 0.3, 0.5);\n    vec3 skyRed = vec3(6., .3, 0.);\n    vec3 sky = mix(skyLow, skyHi, rd.y);\n    vec3 skyYellow = vec3(1.0, 1.0, .5);\n    \n    float a = sin((atan(rd.z, rd.x) + 3.14159265) * .5);\n    vec2 sun = vec2(a, rd.y * 1.5);\n\tsky = mix(skyRed, sky, smoothstep(0.0, 1.5, length(sun)));\n\tsky = mix(skyYellow, sky, smoothstep(0.0, .7, length(sun)));\n    \n    \n    if(length(_rp)>400.)fragColor=vec4(.0);\n    \n    fragColor.rgb *= .2 + .8 * smoothstep(-22.0, 0.0, _rp.x + sin(_rp.z * 0.5));\n    fragColor.rgb *= 1.0 + .7 * smoothstep(4.0, 50.0, _rp.x + sin(_rp.z * .2));\n    \n    fragColor = mix(getTrees(rd), fragColor, fragColor.a);\n    fragColor.rgb = mix(fragColor.rgb, sky, 1.-fragColor.a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}