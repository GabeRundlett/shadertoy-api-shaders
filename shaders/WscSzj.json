{
    "Shader": {
        "info": {
            "date": "1572310532",
            "description": "sdf functions from iq: http://iquilezles.org/articles/distfunctions/distfunctions.htm\nshading formula from original paper: https://users.cs.northwestern.edu/~ago820/SIG98/gooch98.pdf\n",
            "flags": 0,
            "hasliked": 0,
            "id": "WscSzj",
            "likes": 3,
            "name": "Atom_gooch",
            "published": 3,
            "tags": [
                "goochshading"
            ],
            "usePreview": 0,
            "username": "zxxuan1001",
            "viewed": 433
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.0001;\nconst float PI = 3.1415926;\nconst float MAX_DIST = 100.0;\nconst int MAX_STEPS = 60;\nconst vec3 GREEN = vec3(125.0, 245.0, 217.0)/255.0;\nconst vec3 YELLOW = vec3(0.2, 0.2, 0.0);\nconst vec3 PINK = vec3(255.0, 94.0, 186.0)/255.0;\n\nstruct Material {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shiness;\n};\n\n#define AA 1\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nvec2 intersectSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > dist1.x? dist0 : dist1;\n}\n\nvec2 unionSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x < dist1.x? dist0 : dist1;\n}\n\nvec2 diffSDF(vec2 dist0, vec2 dist1) {\n    return dist0.x > -dist1.x? dist0 : vec2(-dist1.x, dist1.y);\n}\n\nvec3 rotX(vec3 p, float d) {\n    mat4 rotM= mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, cos(d), -sin(d), 0.0, \n                    0.0, sin(d), cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\nvec3 rotY(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), 0.0, sin(d), 0.0, \n                    0.0, 1.0, 0.0, 0.0,\n                    -sin(d), 0.0, cos(d), 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 rotZ(vec3 p, float d) {\n    mat4 rotM= mat4(cos(d), -sin(d), 0.0, 0.0, \n                    sin(d), cos(d), 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0, \n                    0.0, 0.0, 0.0, 1.0);\n    return vec3(rotM * vec4(p, 1.0));\n}\n\nvec3 doTranslate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nvec2 sceneSDF(vec3 p) {\n    float deg = 90.0;\n    float sr = 2.0;\n    float lr = 2.0;\n    float SR = 1.8;\n    float LR = 1.5;\n    float spheres[12];\n    float vTime = iTime;\n    \n    float id = 1.0;\n    for (int i = 0; i < 4; i ++) {\n        float dx = SR * cos(90.0 * id * PI / 180.0);\n        float dz = SR * sin(90.0 * id * PI / 180.0);\n        vec3 v = vec3(p.x + dx, p.y, p.z + dz);\n        spheres[i] = sphereSDF(v, sr);\n        id += 1.0;\n    }\n    spheres[4] = sphereSDF(vec3(p.x, p.y + LR, p.z), lr);\n    spheres[5] = sphereSDF(vec3(p.x, p.y - LR, p.z), lr);\n    \n    \n    \n    float torus[3];\n    float t_ry = 0.1;\n    float t_rxl = 16.0;\n    float t_rxs = 12.0;\n    float alpha0 = vTime;\n    float alpha1 = vTime + 90.0 * PI / 180.0;\n    torus[0] = sdTorus( rotX(p, alpha0), vec2(t_rxl, t_ry) );\n    torus[1] = sdTorus( rotZ(p, alpha0), vec2(t_rxs, t_ry) );\n    torus[2] = sdTorus( rotZ(p, alpha1), vec2(t_rxs, t_ry) );\n    \n    float ssr = 0.3;\n    spheres[6] = sphereSDF(vec3(p.x, p.y - t_rxl * sin(alpha0), p.z + t_rxl * cos(alpha0)), ssr);\n    spheres[7] = sphereSDF(vec3(p.x, p.y + t_rxl * sin(alpha0), p.z - t_rxl * cos(alpha0)), ssr);\n    spheres[8] = sphereSDF(vec3(p.x - t_rxl, p.y, p.z), ssr);\n    spheres[9] = sphereSDF(vec3(p.x + t_rxl, p.y, p.z), ssr);\n    \n    spheres[10] = sphereSDF(vec3(p.x - t_rxs * cos(alpha0), p.y - t_rxs* sin(alpha0), p.z), ssr);\n    spheres[11] = sphereSDF(vec3(p.x - t_rxs * cos(alpha1), p.y - t_rxs* sin(alpha1), p.z), ssr);\n    \n    float objId = 0.0;\n    //horizontal spheres\n    vec2 combined = unionSDF(vec2(spheres[0], objId), vec2(spheres[1], objId));\n    combined = unionSDF(combined, vec2(spheres[2], objId));\n    combined = unionSDF(combined, vec2(spheres[3], objId));\n    \n    //lower sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[4], objId));\n    \n    //upper sphere\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[5], objId));\n    \n    //small spheres\n    objId++;\n    combined = unionSDF(combined, vec2(spheres[6], objId));\n    combined = unionSDF(combined, vec2(spheres[7], objId));\n    combined = unionSDF(combined, vec2(spheres[8], objId));\n    combined = unionSDF(combined, vec2(spheres[9], objId));\n    combined = unionSDF(combined, vec2(spheres[10], objId));\n    combined = unionSDF(combined, vec2(spheres[11], objId));\n    \n    //large tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[0], objId));\n    \n    //small tortus\n    objId++;\n    combined = unionSDF(combined, vec2(torus[1], objId));\n    combined = unionSDF(combined, vec2(torus[2], objId));\n    \n  \n    \n   return combined;\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd) {\n    float tmax = MAX_DIST;\n    float t = 0.0;\n    vec2 result = vec2(-1.0);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        vec2 res = sceneSDF(p);\n        if (res.x < EPSILON || t > tmax) break;\n       \n        t += res.x;\n        result.x = t;\n        result.y = res.y;\n    }\n    \n    if (t > tmax) result.x = tmax;\n    return result;\n}\n\nvec3 getNormal(vec3 p) {\n    float x = sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x;\n    float y = sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x;\n    float z = sceneSDF(vec3(p.x, p.y, p.z + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x;\n    return normalize(vec3(x, y, z));\n}\n\nvec3 shading(vec3 p, vec3 ro, vec3 rd, Material mat) {\n    vec3 col = vec3(0.0);\n    vec3 nor = getNormal(p);\n    //light needs to be perpendicular to gaze direction\n    vec3 lightDir = -vec3(0.2, 0.8, 0.6); \n    vec3 viewDir = normalize(rd);\n    vec3 ref = normalize(reflect(-lightDir, nor));\n    vec3 surf = mat.diffuse;//vec3(0.8, 0.5, 0.4);\n    vec3 warm = vec3(0.3, 0.3, 0.0) + 0.25 * surf;\n    vec3 cool = vec3(0.0, 0.0, 0.55) + 0.25 * surf;\n    float dotLN =dot(lightDir, nor);\n    float k = (1.0 + dotLN) / 2.0;\n    vec3 gc = k * cool + (1.0 - k) * warm;\n    float spe = pow(max( dot( viewDir, ref ), 0.0 ), mat.shiness);\n    \n    col = spe + (1.0-spe)*gc;\n    return col;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 background(vec2 p) {\n    return 0.8*mix(vec3(0.0,0.3,0.4), vec3(0.4,0.5,0.6), p.y + 0.5);\n}\n\nvec3 render(in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy/iResolution.xy;\n  uv -= 0.5;\n    \n  uv.x *= iResolution.x/iResolution.y;\n  vec2 mo = iMouse.xy/iResolution.xy - 0.5;\n  \n  vec3 ro = vec3 (cos(iTime) * 10.0 + 10.0, 3.0, sin(iTime) * 10.0 + 20.0);\n  vec3 ta = vec3 (0.0, 0.0, -1.0);\n  mat3 cam = getCamera(ro, ta, 0.0);\n  \n  vec3 rd = normalize(cam * vec3(uv, 1.0));\n  vec2 h = rayMarching(ro, rd);\n \n  vec3 col = vec3(0.0);\n  \n  if (h.x < MAX_DIST) {\n    \n    vec3 p = ro + rd * h.x;\n        \n    Material mat;\n    //chrome\n    mat.ambient = vec3(0.1);\n    mat.diffuse = vec3(0.4);\n    mat.specular = vec3(0.674597);\n    mat.shiness = 32.0;\n    \n    if (h.y == 1.0 || h.y == 2.0) {\n      //pink\n      mat.ambient = PINK;\n      mat.diffuse = PINK;\n      mat.specular = PINK;\n    } else if (h.y == 0.0) {\n      //gold\n      mat.ambient = vec3(0.24725, 0.1995, 0.0745);\n      mat.diffuse = vec3(0.75164, 0.60648, 0.12648);\n      mat.specular = vec3(0.628281, 0.555802, 0.366065);\n      mat.shiness = 8.0;\n    } \n    col += shading(p, ro, rd, mat); \n    \n  } else {\n      col = background(uv);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n#if AA > 1\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < float(AA); aaY++)\n    {\n        for (float aaX = 0.0; aaX < float(AA); aaX++)\n        {\n            col += render(fragCoord + vec2(aaX, aaY) / float(AA));\n            count += 1.0;\n        }\n    }\n    col /= count;\n#else\n    col += render(fragCoord);\n#endif\n    \n    col = pow( col, vec3(1.0/2.2) );\n     \n    vec2 p = fragCoord/iResolution.xy ;\n    col *= 0.2 + 0.8 * pow(32.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.2);\n    \n    fragColor = vec4 (col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}