{
    "Shader": {
        "info": {
            "date": "1673648462",
            "description": "if we have a resolution r and a pixel p\nthe index of a pixel  of a given point can be calculated with \np.x + p.y*r.x \n",
            "flags": 0,
            "hasliked": 0,
            "id": "dt23R3",
            "likes": 2,
            "name": "pixel index",
            "published": 3,
            "tags": [
                "pixelindex"
            ],
            "usePreview": 0,
            "username": "jonasfrey",
            "viewed": 211
        },
        "renderpass": [
            {
                "code": "vec2 _0 = vec2(0.,12.);\nvec2 _1 = vec2(1.,12.);\nvec2 _2 = vec2(2.,12.);\nvec2 _3 = vec2(3.,12.);\nvec2 _4 = vec2(4.,12.);\nvec2 _5 = vec2(5.,12.);\nvec2 _6 = vec2(6.,12.);\nvec2 _7 = vec2(7.,12.);\nvec2 _8 = vec2(8.,12.);\nvec2 _9 = vec2(9.,12.);\nvec2 _cln = vec2(10.,12.);\nvec2 _scln = vec2(11.,12.);\n\n\nint f_n_numofdigits(float n)\n{\n    //log10(x) = log(x) / log(10) = (1 / log(10)) * log(x)\n    if(abs(n) == 0.){\n        return 1;\n    }\n    if(abs(n) == 10.){\n        return 2;\n    }\n    return int(floor((1. / log(10.)) * log(n) +1.));\n    \n} \nint f_n_digit(int number, int n_index) {  \n    int n_numofdigits = f_n_numofdigits(float(number));\n    n_index = (n_numofdigits-1) - n_index;\n   return int((floor(float(number)/pow(10.0,float(n_index))))) % 10; \n} \n\nvec4 f_o_col_char(vec2 o_trn_fc_nor, vec2 o_char){\n    \n    vec2 o_scl_chars = vec2(16.);\n    vec2 o = (o_trn_fc_nor.xy/o_scl_chars.xy)+vec2(1./16.)*o_char;\n    vec4 o_col = texture(iChannel0, o);\n    return o_col;\n}\nvec4 f_o_col_num(vec2 o_trn_fc_nor, int n){\n    \n\n    vec2 o_p_start = vec2(0.,12.);\n\n    float n_numofdigits = float(f_n_numofdigits(float(n)));\n    \n    vec2 o = o_trn_fc_nor * vec2(n_numofdigits, 1.);\n    \n    float n_idx_digit = floor(o_trn_fc_nor.x / (1. / n_numofdigits));\n    \n    int n_digit = f_n_digit(int(n), int(n_idx_digit));\n    \n    return f_o_col_char(fract(o), o_p_start+vec2(float(n_digit), 0.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o_tres  = vec2(16,16);//target resolution\n    vec2 o_scl_tres = o_tres / iResolution.xy;\n    vec2 o_ires = iResolution.xy * o_scl_tres;\n    vec2 o_fc = fragCoord.xy * o_scl_tres.xy;\n\n    float n_idx_fc = (floor(o_fc.x) + floor(o_fc.y)*floor(o_tres.x));// index\n    float n_idx_fc_nor = n_idx_fc / floor(o_tres.x*o_tres.y);\n    \n    float n_ratio_1to_iresx = 1./ o_ires.x;//we can make a lowres AA\n    float n_ratio_1to_iresolutionx = 1./ iResolution.x;//we need the real resolution for AA\n    //needed for anti aliasing ?\n    \n    vec2 o_trn_fc_nor = o_fc.xy / o_ires.xy;\n    vec2 o_trn_mo_nor = iMouse.xy / iResolution.xy;\n    \n    float n_ratio_x_to_y = iResolution.x / iResolution.y; \n    \n    vec2 o_trn_fc_nor_offset = (o_trn_fc_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    vec2 o_trn_mo_nor_offset = (o_trn_mo_nor - vec2(0.5))*vec2(n_ratio_x_to_y, 1.);\n    \n    vec2 o_fcfract = fract(o_fc);\n    float n_dist_border_x = abs(o_fcfract.x-0.5);\n    float n_dist_border_y = abs(o_fcfract.y-0.5);\n    float n_dist_border = max(n_dist_border_x,n_dist_border_y);\n    float n_size = 0.5 - (1./o_tres.x)*0.5;\n    float n_aa = n_ratio_1to_iresolutionx*20.;\n    n_dist_border = smoothstep(n_size, n_size+n_aa, n_dist_border);\n    \n       \n    vec4 o_col = texture(iChannel0, o_fc);\n    \n    o_col = f_o_col_num(fract(o_fc), int(n_idx_fc));\n\n    o_col = o_col.xxxx;\n    o_col += n_dist_border;\n    \n    float b_oddf = float(mod((n_idx_fc),2.) == 0.);\n    float b_oddt = 1.-b_oddf;\n    float n_invf = 1.*n_idx_fc_nor;\n    float n_invt = 1.- n_invf;\n    o_col = \n        o_col * vec4(n_invf*b_oddf+n_invt*b_oddt, 0.5, n_invf*b_oddt+n_invt*b_oddf ,  1.);\n\n    fragColor = vec4(o_col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}