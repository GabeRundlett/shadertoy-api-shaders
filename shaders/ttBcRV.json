{
    "Shader": {
        "info": {
            "date": "1594818145",
            "description": "License CC0: Flying through glowing stars\nThe result of playing around trying to improve an old shader",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBcRV",
            "likes": 18,
            "name": "Flying through glowing stars",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 682
        },
        "renderpass": [
            {
                "code": "// License CC0: Flying through glowing stars\n//  The result of playing around trying to improve an old shader\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec3 co) {\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nfloat starn(vec2 p, float r, int n, float m) {\n  // From IQ: https://www.shadertoy.com/view/3tSGDy\n  // https://iquilezles.org/articles/distfunctions2d\n  \n  // Minor tweak to use SABS over abs to smooth inner corners\n  // SABS: https://www.shadertoy.com/view/Ws2SDK\n\n  // next 4 lines can be precomputed for a given shape\n  float an = 3.141593/float(n);\n  float en = 3.141593/m;  // m is between 2 and n\n  vec2  acs = vec2(cos(an),sin(an));\n  vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n  float bn = mod(atan(p.x,p.y),2.0*an) - an;\n  p = length(p)*vec2(cos(bn),SABS(sin(bn), 0.15));\n  p -= r*acs;\n  p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n  return length(p)*sign(p.x);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  vec3 xyz = mix(back.xyz*back.w, front.xyz, front.w);\n  float w = mix(back.w, 1.0, front.w);\n  return vec4(xyz, w);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 planeCol(vec3 ro, vec3 rd, float n, vec3 pp) {\n  const float s = 0.5;\n  \n  vec2 p = pp.xy;\n  float z = pp.z;\n  vec2 dpy = dFdy(p);\n  float aa = length(dpy);\n\n  p -= (1.0+5.0*(pp.z - ro.z))*offset(z).xy;\n  \n  p *= s;\n  float r = hash(vec3(floor(p+0.5), n));\n  p = fract(p+0.5)-0.5;\n  rot(p, ((TAU*r+n)*0.25));\n  float d = starn(p, 0.20, 3 + 2*int(3.0*r), 3.0);\n  d -= 0.06;\n  d/=s;\n  \n  float ds = -d+0.03;\n  vec3 cols = hsv2rgb(vec3(337.0/360.0+0.1*sin(n*0.3), 0.8, 0.54+0.2*sin(n*0.3)));\n  float ts = 1.0 - smoothstep(-aa, 0.0, ds);\n  vec4 cs =  vec4(cols, ts*0.93);\n\n  float db = abs(d) - (0.06);\n  db = abs(db) - 0.03;\n  db = abs(db) - 0.00;\n  db = max(db, -d+0.03);\n    vec3 colb = vec3(1.0, 0.7, 0.5);\n  float tb = exp(-(db)*30.0*(1.0 - 10.0*aa));\n  vec4 cb = vec4(1.5*colb, tb);\n\n  vec4 ct = alphaBlend(cs, cb);\n\n  return ct;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.0-tanh(length(p)))*ww);\n  \n  vec4 col = vec4(vec3(0.0), 1.0);\n\n  const float planeDist = 1.0;\n  const int furthest = 6;\n  const int fadeFrom = furthest-3;\n\n  float nz = floor(ro.z / planeDist);\n\n  for (int i = furthest; i >= 1; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n      \n      vec4 pcol = planeCol(ro, rd, nz+float(i), pp);\n      float fadeIn = 1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), pp.z-ro.z);\n      pcol.xyz *= sqrt(fadeIn);\n  \n      col = alphaBlend(col, pcol);\n    }\n  }\n  \n  return col.xyz*col.w;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME*0.65;\n  \n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+1.5*ddro, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  \n  const float fadeIn = 2.0;\n    \n  return col*smoothstep(0.0, fadeIn, TIME);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}