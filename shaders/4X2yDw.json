{
    "Shader": {
        "info": {
            "date": "1727311573",
            "description": "mouse,  click \n\nWhen the mouse is on the right side, a small red ball will appear.",
            "flags": 0,
            "hasliked": 0,
            "id": "4X2yDw",
            "likes": 14,
            "name": "botanical garden",
            "published": 3,
            "tags": [
                "mouse",
                "tree",
                "keyboard",
                "garden",
                "brunch"
            ],
            "usePreview": 0,
            "username": "shadertoyjiang",
            "viewed": 143
        },
        "renderpass": [
            {
                "code": "\n// mouse \n\n// 20240923\n\n#define MUL 5.       // MUL >= 0\n#define Shadow 1     // 0 or 1\n//#define ind ((0.-(iy-1.)*M*2.)/(1.-M*2.)+ix+1.)\n#define time (iTime*2.)\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n#define PI 3.1415926\n//#define iTime 50.4\n\nvec3 dir;\nvec4 clr;\nint obj;\nfloat dist,bord;\n\n\nfloat smin(float d1, float d2, float k)\n{\n        float h =clamp(.5 + .5 *(d2-d1)/k,0.,1.);\n        return mix(d2, d1, h)-k*h*(1.-h);\n}\n\n\nfloat intersect(vec2 o, float r,vec2 dir){\n        vec2 c=vec2(0);\n        vec2 l = c - o;\n        float s = dot(l,dir); // dir.xz\n        float l2 = dot(l,l), r2=r*r;\n        if(s<0. && l2>r2)return -1.;\n        float m2 = l2 - s*s;\n        if(m2>r2)return -1.;\n        float q = sqrt(r2-m2),t;\n        if(l2>r2)t=s-q;\n        else     t=s+q;\n        return t;\n}\n\n//float rnd0(float seed){\n//        return fract(sin(seed*234.567+13.222)*143.219)-.5;\n//}\n\nvec4 rnd4(float p)\n{//  https://www.shadertoy.com/view/4djSRW - Dave_Hoskins\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nfloat rnd1(float p){\n        return rnd4(p+1.2345).y;\n}\n\nfloat tree(vec3 p, float ind){\n    float sz=.86+ .8*rnd1(ind+.2);\n    p*=sz;\n        float s =1., mn = 999., g=.62+.04*rnd1(ind+.4), mk=mn,\n              r,h,d,sn;\n        \n        vec3 n = vec3(0,1,0);\n        n.xy = n.xy * rot(-(PI/2.-.5)+rnd1(ind+.56)*6.);\n        //n.xy = n.yx*vec2(-1,1); //n=normalize(n);\n        //n=-n;\n        \n        for(int i=0;i<8;i++){\n                r = length(p.xz)-.05;\n                h = abs(p.y-.6)-.6;\n            if(i==7)h = abs(p.y-2.6)-2.6;\n                d = max(r,h);\n                mn = smin(mn, d * s, .01);//, .03);\n                mk = min(mk, dot(p,n)*s);\n                mk = min(mk, dot(p,n*vec3(-1,1,1))*s);\n                mk=min(mk,mn);\n                p.y -= 1.;\n                sn = sign(p.x);\n            // \n            if(rnd1(ind+3.3+float(i))<.3)p.y+=.4,p=p/.985,s=s*.985;               \n            if(rnd1(ind+3.3)<.5)p.y+=.4,p=p/.985,s=s*.985;\n                p.x = abs(p.x);\n                p.xy = p.xy*rot(-.5*rnd1(ind+.23)-.1);//+-\n                p.xz = p.xz*rot(-4.*sn-1.8*rnd1(ind)*sn);//iMouse.y/iResolution.y*6.28*sn);\n                p = p / g;\n                s = s * g;\n        }\n        return mn/sz;\n}\n\n\n\n\nfloat keyboard(vec3 p){   \n        float size=1. ;//\n        p*=size;\n        vec2 u = p.xz;\n        const float N=1.;\n        float M =float(MUL),\n              au =  atan(u.y, u.x)/TAU , \n              ru = length(u)*N,   \n              iy = round(ru),   \n              ofs = (rnd1(iy+5.)-.5)*time*3.,  \n              ix = round(au * iy*M + ofs);\n        \n        if( ix == round(-.5 * iy*M + ofs) )ix==round(.5 * iy*M + ofs); \n        \n\n        float a = (ix -ofs)/M/iy*TAU;\n        vec2 ni = vec2(-sin(a), cos(a));\n        //if(iy>.1)ix=mod(ix+iy*4.,iy*2.);\n        //if(iy<.2)ix=0.;\n        \n        \n        float ind=0.;\n        if(iy>0.5)ind+=iy*(iy-1.)/2.*M+mod(ix+iy*M,iy*M)+1.;\n        \n        \n        \n        \n        \n        //float nvg = step(0., dot(ni, dir.xz))*2.-1.;\n        float agl = .5/M/iy*TAU;\n        \n        \n        \n        bord = 1e8;dist = 1e8;\n        // 还是笨办法保险，知道还耗71149\n        vec2 nrt = rot(-agl)*ni;\n        float t = - dot(u, nrt) *length(dir)/dot(dir, vec3(nrt, 0).xzy);\n        if(t>0.)bord = min(bord, t); //=?\n        nrt  = rot(agl)*ni;\n        t = - dot(u, nrt) *length(dir)/dot(dir, vec3(nrt, 0).xzy);\n        if(t>0.)bord = min(bord, t); //=?\n        \n        \n        \n        // 求解与内外圆弧边界的距离 bord\n        float k = length(dir.xz);\n        k = length(dir)/k;//(k*k);\n        vec2 nmz = normalize(dir.xz);\n        t = intersect(u, (iy + .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);        \n        t = intersect(u, (iy - .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);\n        bord = min(bord, 555.5) + .01*size;   // c>l\n        \n        // 求解各真实物面距离 dist\n        float d1,d2,d3,d4,d5,d6,w = .001, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, nrt)+w+r;\n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        // \n        float h = rnd1(ind)*clamp(1.5*sin(time*(1.+rnd1(ind+6.))),-1.,1.);\n        d4 = abs(p.y-h)-.6;   // 与配合可产生其它背景     \n        ////float d6 ;//= tree(p-vec2(ni.y,0,-ni.x)*iy-vec3(0,h+1.2,0));\n        clr = vec4(.8,.5,.2,1)*.5+(rnd4(ind+.1)+.02)*1.5;       \n        if(ind<.5)clr=vec4(99,55,0,0);\n        dist = length(max(vec4(d1,d2,d3,d4),0.))-r;//2117\n        obj=0;\n        if((iMouse.x<iResolution.x*.52 || iTime<3.)  &&\n           (mod(ind+18., 27.)<.5  ) ){\n              d5 = length(p - vec3(ni.y*iy, abs(-h)+1.6+.45, -ni.x*iy))-.4;       \n              if(d5<dist){\n                    obj=1, \n                    clr = vec4(2,.5,.2,1)*(rnd4(ind+23.)+.2);   \n                    \n              }\n              dist=min(dist, d5);\n           }\n           else if(mod(ind+.1,6.)<3.2){ // 3.2\n              d6 = tree(p-vec3(ni.y,0,-ni.x)*iy-vec3(0,h+.6,0), ind);      \n              if(d6<dist && ind>.1){\n                  clr=mix(vec4(.5,.2,0,1),vec4(2,6,1,1),(p.y-h-.6)*.2)  +rnd1(ind+.4)-.3 + max (p.y-h-.6-1.5, 0.)  ;\n                  dist=smin(dist,d6,.1);\n              }\n           }\n        //}\n        \n        \n        if(iTime>2.1 && floor(abs(iTime-72.)*2.5) < ind)dist=1e8;\n        \n        \n        return max(min(dist, bord)/size,p.y/size-5.);\n}\n\n// rot dir ?\nfloat map(vec3 p)\n{\n        float t = time; // 2.54\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,3,0));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd  )\n{// https://www.shadertoy.com/view/lsKcDD - iq\n\tfloat res = 1.0;\n    float t = .0001;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    int technique=1;\n    float tmax=5., w=.1;\n    int j=0;\n    for( int i=0; i<32; i++ )\n    {   j++;\n\t\tfloat h = map( ro + rd*t );\n        \n        float dm = max(dist,.001);\n        \n        if( technique==0 )\n        {\n        \tres = min( res, dm/(w*t) );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = dm*dm/(2.0*ph);\n            float d = sqrt(dm*dm-y*y);\n            res = min( res, d/(w*max(0.0,t-y)) );\n            ph = dm;\n        }\n       \n        t += h;//min(max(h,0.001),.5);\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    //if(j>32)return 0.;\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{        \n        O = vec4(0.35);\n        clr=vec4(1);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,       \n             m = 1. * (iMouse.xy*2. - R) / R.y; \n        vec3 o = vec3(0, 0, -9),                \n             r = normalize(vec3(u+vec2(0,-.5), 1.5)),        \n             e = vec3(0, 1e-3, 0),             \n             p,n,                                 \n             s = normalize(vec3(-1,2,-3));      \n        dir=r;\n        float yy=abs( keyboard(vec3(u.x,0,u.y-.0)*5.));\n        //if(yy>=.02)yy*=9.;\n        O += vec4(.5)*exp(-80.*yy); // backcolor\n        //if(r.y>0.0)return;\n        float d,t,f,g,c ;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)break;\n                /*{\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        \n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; \n                        \n                        if(obj==1)O = vec4(c)*clr;\n                        else      O = vec4(c*g)*clr; // 亲\n                        \n                        #if Shadow==1\n                        //vec4 cclr=clr;int cobj=obj;\n                        vec3 rf;//=reflect(r,n);\n                        rf=normalize(s*100.-p);\n                        dir=rf;\n                        float shd=calcSoftshadow(p-r*.02,rf);\n                        //clr=cclr;obj=cobj;\n                        \n                        \n                        if(iMouse.x<iResolution.x*1.6 )   O   *= (shd+.02)*.5;\n                        #endif\n                        \n                        O = pow(O, vec4(.8));\n                        return;\n                }*/\n                t += d  ;\n        }\n        \n        // Thanks IQ for the improvement suggestion\n        if (d < .01) {\n                n = normalize(vec3(map(p + e.yxx), map(p + e), map(p + e.xxy)) - d);\n                f = .5 + .5 * dot(n, s);\n                g = max(dot(n, s), 0.);\n                c = 1. + pow(f, 200.) - f * .3;\n                if (obj == 1) O = vec4(c) * clr;\n                else O = vec4(c * g) * clr; // 亲\n                #if Shadow == 1\n                //vec4 cclr=clr;int cobj=obj;\n                vec3 rf; //=reflect(r,n);\n                rf = normalize(s * 100. - p);\n                dir = rf;\n                float shd = calcSoftshadow(p - r * .02, rf);\n                //clr=cclr;obj=cobj;\n                if (iMouse.x < iResolution.x * 1.6) O *= (shd + .02) * .5;\n                #endif\n                O = pow(O, vec4(.8));\n                return;\n        }            \n}\n \n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}