{
    "Shader": {
        "info": {
            "date": "1498310337",
            "description": "A 3D simplex Truchet pattern - inspired by Mattz's octahedral and tetrahedral \"Rainbow Spaghetti\" example.",
            "flags": 0,
            "hasliked": 0,
            "id": "XsffWj",
            "likes": 155,
            "name": "Simplex Truchet Tubing",
            "published": 3,
            "tags": [
                "torus",
                "random",
                "simplex",
                "truchet",
                "pattern",
                "tube"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 8326
        },
        "renderpass": [
            {
                "code": "/*\n\tSimplex Truchet Tubing\n\t----------------------\n\n\tThis was inspired by Mattz's \"Rainbow Sphaghetti\" example, which I've always admired\n\tfor both its aesthetics and mathematical content. However, this version was constructed\n\tvia a more direct simplex grid approach. In fact, I made it a point not to look at \n\tMattz's code too deeply in the hope that I might bring something new to the table... \n\tNot sure if I did, but here it is anyway. :)\n\n\tThe idea is very simple: Break space into a simplex grid, which is just a bunch of \n\tpacked regular tetrahedrons. Each tetrahedron has four faces, so run a tube from one\n\tface center to another face center, then do the same with the remaining two faces - \n\tIf you require a visual reference, look up cubic Truchet tiles, then picture one with\n\ttetrahedrons instead of cubes. The result is a grid space full of double-tubed \n\ttetrahedral Truchet blocks which can each be randomly oriented to produce a Truchet \n\tpattern.\n\n\tRunning a straight tube, or even a Bezier curve, from one tetrahedral face center to \n\tthe next is almost trivial, but threading tori through them was slighly more tricky. \n\tEach had to be centered on the correct central edge, then aligned accordingly. The code \n\tto do that turned out to be reasonably simple, but I had to make a lot of really stupid \n\tmistakes to get there. :)\n\n\tAnyway, for anyone interested, the relevant code is contained in the distance function;\n\tThe rest is window dressing. I also have a much, much more simplistic version using \n\tstraight tubes that I'll put up pretty soon which should be much easier to absorb. With\n\ta bit of trial and error, I've also managed to produce an animated version, so I'll\n\tput that up too.\n\t\n\n\tBy the way, I really rushed in the comments, but I'll tidy them up later.\n    \n\n    // Relevant examples:\n\n    // Truchet pattern using an octahedral and tetrahedral setup.\n    rainbow sphagetti - Mattz\n    https://www.shadertoy.com/view/lsjGRV\n\n\t// Classic cubic Truchet pattern. Easier to understand.\n\tTwisted Tubes - Shane\n\thttps://www.shadertoy.com/view/lsc3DH\n \n\n*/\n\n\n#define FAR 20. // Maximum ray distance. Analogous to the far plane.\n\n//#define NO_BOLTS // Bland, but faster, plus it allows you to see the pattern better.\n\n\n// Scene object ID. Either the bolts (0) or the tube itself (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    //return vec2(0); // Straight path override.\n   \n    // Curvy path.\n    float a = sin(t * 0.22);\n    float b = cos(t * 0.28);\n    return vec2(a*2. -b*.75, b*.85 + a*.75);\n\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    //p -= vec3(path(p.z), 0.);\n     \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat hash31(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7.31, 157.47, 113.93)));    \n    return fract(n); // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n    //return transpose(mat3(vec3(1. - n.x*n.x*a, b, -n.x), vec3(b, 1. - n.y*n.y*a , -n.y), n));\n                 \n}\n\n// Torus function, with the standard large radius and smaller cross-sectional radius. With just a \n// standard torus shape, this would be a very simple algorithm, but just to make it a little more\n// interesting, I spaced some bolts around the tori segments, so that added a few more lines.\nvec2 tor(vec3 p, float rad, float rad2){\n    \n    // \"p\" has been passed in as \"p - p0,\" where \"p0\" is the central torus axial point. \n  \n    #ifndef NO_BOLTS\n    // Bolts. Standard object repetition around a torus.\n    vec3 q = p;\n    q.xy = rot2(-3.14159/12.)*q.xy; // Rotating the bolts to avoid seam lines.\n    // Animation: I'd love to include this but there are some boundary issues that I'll have\n    // to compensate for first. It's on the list though.\n    //q.xy = rot2(iTime/2.)*q.xy;\n\n    float a = atan(q.y, q.x); // Polar angle of \"q.xy\" coordinate.\n    \n    // Partitioning the the torus into centered cells - \"oNum\" in all.\n    const float oNum = 6.; // Six objects in all.\n    float ia = floor(a/6.2831853*oNum);\n    ia = (ia + .5)/oNum*6.2831853; \n    \n    // Converting the cell coordinates to polar positions. \"X\" now represents the radial\n    // distance, and \"Y\" repesents the radial distance.\n    q.xy = rot2(ia)*q.xy; \n    \n    q.x -= rad; // Edging the object out to the distance of the outer radius.\n    \n    // Drawing some hexagon bolts at the postion.\n    q = abs(q);\n    float sh = max(max(q.x*.866025 + q.z*.5, q.z) - rad2 - .0125, q.y - .045);\n    sh = max(sh, -q.y + .01); // Taking out the center to make it look like two bolts.\n    #endif               \n    \n    #ifndef NO_BOLTS\n    // The torus itself. Without the bolts, the following would be all you need:\n    \n    // Sweeping a circle \"rad\" units about the center point. \n    p.xy = vec2(length(p.xy) - rad, p.z);\n   \n    // Producing the inner circle and adding some tiny ribbing (\"cos\" term) to emulate a thread.\n    float tor = length(p.xy) - rad2 + cos(a*180.)*.0002;\n    \n    // Hexagonal cross section. Cool, but I have to deal with segment alignment first.\n    ////p.xy = rot2(a)*p.xy;\n    //p = abs(p);\n    //float tor = max(p.x, p.y) - rad2;// + cos(a*180.)*.0002;\n\n    \n    // Returning the torus value and the shape (bolt) value seperately (for ID purposes), but\n    // they'll be combined afterward.\n    \n    return vec2(tor, sh);\n    #else\n    float a = atan(p.y, p.x);\n    p.xy = vec2(length(p.xy) - rad, p.z);\n    float tor = length(p.xy) - rad2 + cos(a*180.)*.0002;\n    return vec2(tor, 1e8);\n    #endif\n    \n}\n\n\n// Breaking space into a 3D simplex grid (packed tetrahedra), constructing tetrahedral Truchet tiles,\n// then randomly rotating them to form a 3D simplex Truchet pattern.\nfloat simplexTruchet(in vec3 p)\n{\n    \n    // Breaking space into tetrahedra and obtaining the four verticies. The folowing three code lines\n    // are pretty standard, and are used for all kinds of things, including 3D simplex noise. In this\n    // case though, we're constructing tetrahedral Truchet tiles.\n    \n    // Skewing the cubic grid, then determining relative fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)));  p -= i - dot(i, vec3(1./6.)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of \n    // the intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    \n    // Using the above to produce the four vertices for the tetrahedron.\n    vec3 p0 = vec3(0), p1 = i1 - 1./6., p2 = i2 - 1./3., p3 = vec3(.5);\n\n    \n    \n    // Using the verticies to produce a unit random value for the tetrahedron, which in turn is used \n    // to determine its rotation.\n    float rnd = hash31(i*57.31 + i1*41.57 + i2*27.93);\n    \n    // This is a cheap way (there might be cheaper, though) to rotate the tetrahedron. Basically, we're\n    // rotating the vertices themselves, depending on the random number generated.\n    vec3 t0 = p1, t1 = p2, t2 = p3, t3 = p0;\n    if (rnd > .66){ t0 = p2, t1 = p3; t2 = p0; t3 = p1; }\n    else if (rnd > .33){ t0 = p3, t1 = p0; t2 = p1; t3 = p2; } \n    \n\n    \n    // Threading two torus segments through each pair of faces on the tetrahedron.\n    \n    // Used to hold the distance field values for the tori segments and the bolts.\n    // v.xy holds the first torus and bolt values, and v.zw hold the same for the second torus.\n    vec4 v;\n    \n    // Axial point of the torus segment, and the normal from which the orthonormal bais is derived.\n    vec3 q, bn; \n \n    \n    // I remember reasoning that the outer torus radius had to be this factor (sqrt(6)/8), but I \n    // can't for the life of me remember why. A lot of tetrahedral lengths involve root six. I \n    // think it's equal to the tetrahedral circumradius... I'm not happy with that explanation either, \n    // so I'll provide a proper explanation later. :D Either way, it's the only value that fits.\n    float rad = .306186218; // Equal to sqrt(6)/8.\n    float rad2 = .025; // The smaller cross-sectional torus radius.\n\n\n    // Positioning the center of each torus at the corresponding edge mid-point, then aligning with\n    // the direction of the edge running through the midpoint. One of the ways to align an object is to\n    // determine a face normal, construct an orthonormal basis from it, then multiply the object by it\n    // relative to its position. On a side note, orientation could probably be achieved with a few \n    // matrix rotations instead, which may or may not be cheaper, so I'll look into it later.\n    \n    // First torus. Centered on the line between verticies t0 and t1, and aligned to the face that\n    // the edge runs through.\n    bn = (t0 - t1)*1.1547005; // Equivalent to normalize(t0 - t1);\n    q = basis(bn)*(p - mix(t0, t1, .5)); // Applying Nimitz's basis formula to the point to realign it.\n    v.xy = tor(q, rad, rad2); // Obtain the first torus distance.\n\n    // Second torus. Centered on the line between verticies t2 and t3, and aligned to the face that\n    // the edge runs through.\n    bn = (t2 - t3)*1.1547005; // Equivalent to normalize(t2 - t3);\n    q = basis(bn)*(p - mix(t2, t3, .5)); // Applying Nimitz's basis formula to the point to realign it.\n    v.zw = tor(q, rad, rad2); // Obtain the second torus distance.\n\n    // Determine the minium torus value, v.x, and the minimum bolt value, v.y.\n    v.xy = min(v.xy, v.zw);\n    \n \n    // Object ID. It's either the ribbed torus itself or a bolt.\n    objID = step(v.x, v.y);\n\n    // Return the minimum surface point.\n    return min(v.x, v.y);\n    \n    \n}\n\n// The main distance field function. In this case, it's just calling the \n// simplex Truchet object.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z).xy; // Perturb the object around the camera path.\n    \n\n    float ns = simplexTruchet(p); // The Truchet object.\n    \n    // If a field function adheres to Lipschitz conditions, then no ray shortening is\n    // necessary, but this one seems to require just a touch. I've tried to use the highest \n    // shortening factor possible.\n    return ns*.9;\n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 bumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;//.001*(t*.125 + 1.)\n        \n        t += d; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(2./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    vec3 tx = tex3D(iChannel0, p, n);\n    tx = smoothstep(.05, .5, tx);\n\n    // Shading the steel tubes sepia grey and giving the bolts a splash\n    // of color, just to break up the monotony a bit.\n    if(svObjID>.5) tx *= vec3(1.25, 1., .8); // Steel tubes.\n    else tx *= vec3(.9, .6, .3); // Bolts.\n    \n    return tx; // Return the texture.\n    \n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. It's fake, obviously, but gives a bit of a shiny\n// reflected-pass vibe.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    // Pass the reflected vector into the object color function.\n    vec3 tx = getObjectColor(rd, sn);\n    return smoothstep(.15, .75, tx);\n \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n         // Surface position.\n   \t\t vec3 sp = ro + rd*t;\n        \n        // Edge and curvature variables. Passed to the normal functions.\n        float edge = 0., crv = 1.;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        vec3 sn = getNormal(sp, edge, crv);\n        //vec3 sn = getNormal(sp);\n        vec3 svSn = sn; // Save the unbumped normal.\n\n        // Texture-based bump mapping.\n        // Contorting the texture coordinates to match the contorted scene.\n        sn = bumpMap(iChannel0, sp*2., sn, .01);\n        \n        // Less bumped normal for the fake environment mapping. Sometimes, I prefer it.\n        svSn = mix(sn, svSn, .75); \n\n\n        // Shading. Shadows, ambient occlusion, etc.\n        float sh = softShadow(sp + sn*.00125, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calculateAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 2./(1. + lDist*0.125 + lDist*lDist*0.25);\n\n        // Diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        diff = (pow(diff, 2.)*.66 + pow(diff, 4.)*.34)*2.; // Ramping up the diffuse.\n        // Specular term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        // Fresnel term.\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.        \n        vec3 objCol = getObjectColor(sp*2., sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .5*ao + fres*fres*.25) + vec3(1, .97, .92)*spec*2.;\n        //sceneCol += fres*fres*vec3(.2, .6, 1)*.5;\n        \n        sceneCol += eMap(reflect(rd, svSn)/2., svSn)*.75;\n        \n        // Edges and curvature.\n        //sceneCol *= clamp(crv, 0., 1.);\n        //sceneCol += (sceneCol*.75 + .25)*edge;\n        sceneCol *= 1. - edge*.9;\n        \n\n        // APPLYING SHADOWS\n    \tsceneCol *= sh;  \n        \n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fogCol = vec3(0);//vec3(.7, .8, 1.)*(rd.y*.5 + .5)*2.5;\n    sceneCol = mix(sceneCol, fogCol, smoothstep(0., .75, t/FAR)); // exp(-.002*t*t), etc.\n\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, .375);\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25 ));\n\n    \n    // Raymarching.\n    // Obtain the scene distance.    \n    float t = trace(ro, rd);\n\n    svObjID = objID; // Save the ID.\n    \n    // Coloring.\n    // Retrieving the color at the hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    \n    // Postprocessing.\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n\n    // Clamping the scene color, roughly gamma correcting, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}