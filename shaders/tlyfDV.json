{
    "Shader": {
        "info": {
            "date": "1615063068",
            "description": "Another 'Shining' corridor scene, this time playing with a recursive camera path - A first for me, and fun to make!",
            "flags": 0,
            "hasliked": 0,
            "id": "tlyfDV",
            "likes": 44,
            "name": "pow(The Shining, 2.0)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "recursion",
                "horror",
                "movie",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "dean_the_coder",
            "viewed": 9998
        },
        "renderpass": [
            {
                "code": "// 'pow(The Shining, 2.0)' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/tlyfDV\n//\n// Another 'Shining' corridor scene, this time playing\n// with a recursive camera path - A first for me, and\n// fun to make!\n//\n// My previous Shining scene here:\n//   https://www.shadertoy.com/view/3stBDf\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane,\n// Blackle and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 20.0\n#define MAX_STEPS\t\t 64.0\n#define SHADOW_STEPS\t 30.0\n#define MAX_SHADOW_DIST  20.0\n\n#define Z0 min(iTime, 0.)\n#define sat(x) clamp(x, 0., 1.)\n#define S(x) smoothstep(0., 1., x)\n\nfloat g = 0.0, // Glow.\n      bld = 1.0; // Blood.\n\n#define AA    // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d, id;\n\tvec3 uv;\n};\n\n// Thnx Dave_Hoskins - https://www.shadertoy.com/view/4djSRW\n#define HASH    p = fract(p * .1031); p *= p + 3.3456; return fract(p * (p + p));\nfloat hash11(float p) { HASH }\nvec2 hash22(vec2 p) { HASH }\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 3.3456);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash44(vec4 p) { HASH }\n\nfloat n31(vec3 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(hash44(h), hash44(h + s.x), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n21(vec2 p) {\n    // Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tconst vec3 s = vec3(7, 157, 0);\n\tvec2 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\n\tvec2 h = s.zy + dot(ip, s.xy);\n\th = mix(hash22(h), hash22(h + s.x), p.x);\n\n\treturn mix(h.x, h.y, p.y);\n}\n\nvoid minH(inout Hit a, Hit b) {\n\tif (b.d < a.d) a = b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdHex(vec2 p, float r) {\n\tp = abs(p);\n\treturn -step(max(dot(p, normalize(vec2(1, 1.73))), p.x), r);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nvec3 rayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat deco(vec2 p) {\n    p.xy = fract(p.xy * rot(-2.36) * 1.5);\n    return step(0.5, fract(min(p.x, p.y) * 4.0));\n}\n\nvoid splat(vec2 p, out float i, out float o) {\n\ti = max(0., -sign(sdHex(p, 1.)));\n\to = max(0., sign(sdHex(p, 2.)) - sign(sdHex(p, 3.)));\n}\n\n// Carpet texture.\nvec3 carpet(vec2 p) {\n\tp.x = mod(p.x, 7.) - 3.5;\n\tp.y = mod(p.y, 10.) - 10.;\n\n\tfloat i, o, i2, o2,\n\tc = (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y)));\n\n\tp.x = abs(p.x) - 3.5;\n\n\tc += (1. - step(.5, abs(p.x))) * (1. - step(2., abs(p.y + 2.)));\n\n\tvec2 op = p;\n\n\tp.y = abs(p.y + 5.) - 5.;\n\tsplat(p, i2, o2);\n\n\top.x = mod(p.x, 7.) - 3.5;\n\top.y += 3.8;\n\tsplat(op, i, o);\n\n\ti = sign(i + i2);\n\to = sign(o + o2) * (1. - c);\n\n\treturn vec3(1, .01, .01) * i +\n\t\t   vec3(1, .1, .01) * o +\n\t\t   vec3(.05, .01, .01) * (1. - i - o);\n}\n\n#define GROUND_ID  1.\n#define WALL_ID    2.\n#define CANVAS_ID  3.\n#define FRAME_ID   4.\n#define LIGHT_ID   5.\n#define WOOD_ID    6.\n\n#define FRAME_P    vec3(2.5, 2.7, -0.12)\n#define RO         vec3(-7, 2.4, -3)\n#define LA         vec3(10, 2.4, -3)\n#define LIGHTP     vec3(3.4, 3.5, -2.6)\n\nHit map(vec3 p) {\n\tHit h = Hit(abs(p.y), GROUND_ID, p);\n    \n    float d = length(p - LIGHTP - vec3(0,1.5,0)) - 0.4;\n    minH(h, Hit(d, LIGHT_ID, p));\n    g += 0.002 / (0.001 + d * d);\n    \n    // Wallz.\n    d = min(sdBox(p - vec3(0,2.2,0), vec3(5, 3, 0.1)), -sdBox(p - vec3(0,2.4,0) - vec3(0,0,4), vec3(10, 2.5, 9.5)));\n    minH(h, Hit(min(d, max(abs(p.x) - 0.15, -sdBox(p + vec3(0,0,2.8), vec3(1, 4.5, 2.6)))), WALL_ID, p));\n\n    // Skirting.\n    d = min(sdBox(p - vec3(0, 0, 0), vec3(5, .38, 0.15)), sdBox(p - vec3(0, 0, -5.6), vec3(10, .38, 0.15)));\n    d = min(d, min(d, sdBox(p - vec3(10, 0, -5.6), vec3(.15, .38, 9))));\n    vec3 mp = p; mp.z = abs(mp.z + 2.8) - 2.65;\n    minH(h, Hit(min(d, sdBox(mp, vec3(.2, .38, .1))), WOOD_ID, p));\n\n    // Picture frame.\n    p -= FRAME_P;\n    vec3 cs = vec3(0.885, 0.5, 0.01);\n    minH(h, Hit(sdBox(p, cs), CANVAS_ID, p));\n    minH(h, Hit(max(sdBox(p, cs + 0.1), -sdBox(p, cs + vec3(0,0,1))), FRAME_ID, p));\n\n\treturn h;\n}\n\nvec3 N(vec3 p, float t) {\n\tfloat h = t * 0.4;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 ld) {\n\t// Thanks iq.\n\tfloat s = 1., t = .1;\n\tfor (float i = Z0; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(t * ld + p).d;\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn sat(s);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(h * n + p).d / h; }\n\n/**********************************************************************************/\n\nvec3 vig(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 rd, float d, Hit h) {\n    float s = 0.0, gg = g;\n\tvec3 ld = normalize(LIGHTP - p), n = N(p, d), c = vec3(0);\n         \n    if (h.id == WALL_ID) {\n        n = normalize(n + n31(h.uv * vec3(3.7, 1.7, 2.7)) * 0.08);\n        if (p.x < 9.99)\n            c = vec3(0.4);\n        else {\n            s = deco(p.zy);\n            c = (0.1 + 0.2 * s) * vec3(0.05, 0.15, 0.1);\n        }\n    } else if (h.id == GROUND_ID)\n        c = carpet(h.uv.zx * 3.5) * ((n21(p.xz * 85.0) - 0.5) * 0.4 + 0.6);\n    else if (h.id == FRAME_ID)\n        c = vec3(0.01);\n    else if (h.id == WOOD_ID)\n        c = 0.02 * mix(vec3(1.7, 1, .5), vec3(.8, .5, .3), vec3(hash11(hash31(p.yxz * vec3(0, 1, 30)))));\n    \n    if (bld > 0.0)\n        c = mix(vec3(.6,0.01,0.02), vec3(dot(c, vec3(.2, .72, .08))), sat((p.y * .5 + .5) * n31(p) / (0.1 + n31(p * vec3(9, 2, 9)))));\n\n\t// Primary light.\n\tfloat l1 = sat(.1 + .9 * dot(ld, n))\n               * (0.6 + 0.4 * shadow(p, ld)),\n\n\t// Secondary(/bounce) light.\n\tl2 = sat(.1 + .9 * dot(ld * vec3(-1, 0, -1), n)) * .3\n\n    // Specular.\n\t     + pow(sat(dot(rd, reflect(ld, n))), 10.0 + s * 10.0) * (0.6 + s),\n\n\t// Combine into final color.\n\tlig = l1 + l2 * mix(ao(p, n, .2), ao(p, n, 0.5), .3);\n    g = gg;\n\treturn lig * c * mix(vec3(2, 1.8, 1.7), vec3(0.2, 0.18, 0.13), bld);\n}\n\nvec3 march(vec3 p, vec3 rd) {\n\tfloat d = .0;\n    vec3 ro = p;\n    g = 0.0;\n\tHit h;\n\tfor (float i = Z0; i < MAX_STEPS; i++) {\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST) {\n            if (h.id != CANVAS_ID) break;\n            bld = 1.0 - bld; // Toggle the blood.\n            p = RO;\n            g = d = 0.0;\n            rd = rayDir(RO, LA, h.uv.xy);\n            continue;\n        }\n\n        d += h.d;\n        if (d > MAX_DIST)\n            return vec3(0);\n\n        p += h.d * rd; // No hit, so keep marching.\n\t}\n\n\treturn g + lights(p, rd, d, h);\n}\n\nfloat h21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t// Camera.\n    float t = fract(iTime * 0.2);\n    bld = floor(mod(iTime / 5.0, 2.0));\n\tvec3 ro = mix(RO, vec3(FRAME_P.x, RO.yz), t);\n    \n    t *= .88056;\n    vec3 fp = FRAME_P + vec3(0, .1, 0);\n    vec3 lookAt = mix(LA, fp + vec3(0, -.1, 0.1), S(t * 1.5));\n\n    ro = mix(ro, fp, smoothstep(0.7, 1.0, t));\n\n    vec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = march(ro, rayDir(ro, lookAt, uv));\n\n#ifdef AA\n    if (fwidth(col.r) > 0.1) {\n        for (float dx = Z0; dx <= 1.; dx++)\n            for (float dy = Z0; dy <= 1.; dy++)\n                col += march(ro, rayDir(ro, lookAt, uv + (vec2(dx, dy) - 0.5) / iResolution.xy));\n        col /= 5.;\n    }\n#endif\n\n    col = pow(max(vec3(0), col) * sat(iTime), vec3(.45));\n    col += (h21(fc) - 0.5) * (0.02 + 0.04 * bld);\n\n\t// Output to screen.\n\tfragColor = vec4(vig(col, fc), 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}