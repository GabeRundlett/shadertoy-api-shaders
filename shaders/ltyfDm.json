{
    "Shader": {
        "info": {
            "date": "1542848855",
            "description": "Finally started learning ray marched shadows and AO. I learned most of it from Iq's website and a handful of Shane's shaders. I learned how to use it from https://www.shadertoy.com/view/4dt3zn His comments are really useful.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltyfDm",
            "likes": 26,
            "name": "Shadowland",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "sdf",
                "shadows",
                "occlusion",
                "ambient"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 1019
        },
        "renderpass": [
            {
                "code": "\n// LOOKS BEST IN FULLSCREEN\n\n// raymarching defines\n#define FAR 100.0\n#define DISTANCE_BIAS 0.75\n#define EPSILON 0.0001\n\n\n\n// part of the edge detection which I learned here by nimitz: https://www.shadertoy.com/view/4s2XRd\n// I had a similar approach before, but this method looks better.\n#define EDGE_SIZE 0.022\n#define SMOOTH 0.02\n#define SIZE 0.9\n\n// sdf subtraction from Iq's website\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\n// normalized mouse coords\nvec2 m(){\n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n\treturn m;\n}\n\n// Noise and rand found everywhere on shadertoy\nfloat rand(vec2 n){ \n\treturn fract(sin(dot(n, vec2(17.12037, 5.71713))) * 12345.6789);\n}\n\nfloat noise(vec2 n){\n\tvec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b + d.xx), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat map(vec3 rp)\n{\n    // sphere pos\n    vec3 pos = rp - vec3(1.0, -1.0, 0.0); \n    \n    pos.z -= 0.035;\n    \n    // movements\n    pos.x += iTime * 0.5;\n    pos.y -= m().y*8.0;\n    pos.x -= m().x*8.0;\n    \n    // repeat coordinates\n    pos = mod(pos, vec3(2))-0.5 * vec3(2);\n    \n    // Endless filled space that starts in front of the camera \n    float res = 2.00001 - rp.z;\n    \n    // subtract from the space using spheres\n    res = opSub(length(pos) - 1.33, res);\n   \n    return res;\n}\n\n// Got this from one of Shane's shaders. So fun to play with\nfloat softShadow(vec3 ro, vec3 lp, float k)\n{\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = (lp-ro); \n\n    float shade = 1.;\n    float dist = .005;    \n    float end = max(length(rd), 0.001);\n\n    \n    rd /= end;\n\n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n       \n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); \n       \n        dist += clamp(h, .02, .2);\n        \n       \n        if (h<0.0 || dist > end) break; \n       \n    }\n\n   \n    return min(max(shade, 0.) + 0.03, 1.0); \n}\n\n\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Directly from Iq's site: https://iquilezles.org/articles/distfunctions\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1. );    \n}\n\n\n\n\n    \n \n// A mixture of techniques here that Iv'e seen used by Iq and Shane\nvec3 color(vec3 ro, vec3 rd, vec3 norm, vec3 lp, float t, float md)\n{\n    \n    \n    vec3 p = ro + rd * t; // hit location\n    \n    // Lighting\n    vec3 ld = lp-ro;\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    float atten = 2.0 / (1.0 + lDist*0.2 + lDist*lDist*0.1); // light attenuation \n    ld /= lDist;\n    \n    \n    float diff = max(dot(norm, ld), 0.0); // diffuse\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 12.0); // specular\n    \n    float occ = calcAO( ro + rd, norm )*1.0; // get AO \n    \n    float amb = clamp( 0.5 + 0.5 * norm.y, 0.0, 1.0 ); // ambient\n    float fre = pow( clamp(1.0 + dot(norm,rd),0.0,1.0), 2.0 ); // fresnel\n    // \n    \n    \n    \n    vec3 lf = vec3(0.0); // light color\n    \n    // adding all the light terms\n    lf += 1.0 * amb * vec3(0.5,0.5,0.5) * occ;\n    lf += 2.0 * fre * vec3(0.7,0.5,0.0) * occ;\n    lf += diff + 0.5;\n    \n    // moving the hit location with the geometry. Im sure I'll figure out a better way\n    p.x += iTime;  \n    p.y -= m().y*16.0;\n    p.x -= m().x*16.0;\n        \n    float nn = noise(p.xy*5.0); // some noise\n    \n    // pink blue pattern\n    vec3 col = vec3(sin(nn*10.0), cos(nn * 10.0), 1.0) * 0.9;\n    \n    // simply colors the scene yellow if the z normal if below a threshold. quick and easy\n    // but probably not sustainable \n    if(norm.x != 0.0 && p.z < 4.1)\n        col = vec3(1.0, 1.0, 0.0);\n           \n    // apply lighting to main color \n    col *= lf;\n    \n    // some additional lighting / coloring \n    col  = (col*(diff + 0.7) + vec3(1.0, 0.6, 0.5)*spec*0.2);\n    \n    // apply attenuation\n    col *= atten;\n    \n    // adds a little more detail to texture\n    col *= clamp(noise(p.xy*52.0), 0.3, 1.0) * 1.4;\n    col *= 0.8;\n    return col;\n    \n}\n\n\n\nvec2 trace(vec3 ro, vec3 rd)\n{\n    float t = 0.0; // total distance\n    float d = 0.0; // distance to nearest object\n    \n    float md = 999.0; \n    \n    float h = EPSILON; \n  \n    vec2 dd = vec2(0.,10000.);\n    \n    bool stp = false;\n    \n    for (int i = 0; i < 64; i++) \n    {\n        d = map(ro + rd*t); // get distance to nearest object\n        \n        if(abs(d)<EPSILON || t > FAR) {break;} // hit object or went too far\n        \n        \n        // Part of the edge detection. Basically checks if we are within the set edge bounds \n        // of the object the ray is passing\n        if (stp == false) \n        {\n            md = min(md,d); // get current minimum distance\n            \n            if (h < EDGE_SIZE && h < d && i > 0)\n            {\n                stp = true;\n                dd.y = dd.x;\n            }\n        }\n        \n         h = d;\n        \n        t += d * DISTANCE_BIAS;\n        \n    }\n    \n    if (stp) md = smoothstep(EDGE_SIZE-SMOOTH, EDGE_SIZE+SIZE, md);\n    else md = 1.0;\n    \n    return vec2(t, md );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n \n    vec3 ro = vec3(0.0, 0.0, 0.0); \n \n    // fish eyed ray direction vector because this thing isnt a sphere haha fooled you\n     vec3 rd = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.35));\n    \n   \n    // light position. Fun to play with. bottom one looks pretty cool because the light goes\n    // in the ball\n    vec3 lp = ro + vec3(0.8, 0.7, 0.0);\n    //vec3 lp = ro + vec3(1.0, 0.7, sin(iTime) * 3.0);\n    \n    // Distance to scene object and minimum distance \n    //to an object if nothing was hit\n    vec2 t = trace(ro, rd); \n    \t\t\t\t\t\t\n    // set the ray origin location to the hit location\n    ro += rd * t.x; \n    \n    // normals of hit object\n    vec3 norm = getNormal(ro); \n    \n    // shadows\n    float sh = softShadow(ro, lp, 120.); \n    \n    // color the scene...except for fog and\n    // edge outline which happens below\n    vec3 col = color(ro, rd, norm, lp, t.x, t.y); \n    \t\t\t\t\t\t\t\t\t\t\t\t\n    \n    vec3 fogCol = vec3(0.0, 0.0, 0.0);\n    \n    col *= sh; // apply shadows to scene\n        \n   \n    col *= mix(t.y,1.0, smoothstep(44.0,45.0,t.x)); // apply the edge outline\n    \n    col = mix( col, vec3(0), 1.0 - exp( -0.0036*t.x*t.x*t.x )); // some fog\n    \n   \n    fragColor = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}