{
    "Shader": {
        "info": {
            "date": "1687043467",
            "description": "purple-blue liquid gradient",
            "flags": 0,
            "hasliked": 0,
            "id": "dsXyzf",
            "likes": 21,
            "name": "purple-blue liquid gradient",
            "published": 3,
            "tags": [
                "gradient",
                "liquid"
            ],
            "usePreview": 0,
            "username": "fouad",
            "viewed": 1751
        },
        "renderpass": [
            {
                "code": "/*\n\tThank you to \"MartinRGB\" for the core elements from:\n    https://www.shadertoy.com/view/DttSRB\n*/\n\n#define time iTime\n\nconst float arrow_density = 4.5;\nconst float arrow_length = .45;\n\nconst int iterationTime1 = 20;\nconst int iterationTime2 = 20;\nconst int vector_field_mode = 0;\nconst float scale = 6.;\n\nconst float velocity_x = 0.1;\nconst float velocity_y = 0.2;\n\nconst float mode_2_speed = 2.5;\nconst float mode_1_detail = 200.;\nconst float mode_1_twist = 50.;\n\nconst bool isArraw = true;\n\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\n\n\nfloat f(in vec2 p)\n{\n    return sin(p.x+sin(p.y+time*velocity_x)) * sin(p.y*p.x*0.1+time*velocity_y);\n}\n\n\nstruct Field {\n    vec2 vel;\n    vec2 pos;\n};\n\n//---------------Field to visualize defined here-----------------\n\nField field(in vec2 p,in int mode)\n{\n    Field field;\n    if(mode == 0){\n    \tvec2 ep = vec2(0.05,0.);\n        vec2 rz= vec2(0);\n        //# centered grid sampling\n        for( int i=0; i<iterationTime1; i++ )\n        {\n            float t0 = f(p);\n            float t1 = f(p + ep.xy);\n            float t2 = f(p + ep.yx);\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n            vec2 t = vec2(-g.y,g.x);\n            \n            //# need update 'p' for next iteration,but give it some change.\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\n            p.x = p.x + sin( time*mode_2_speed/10.)/10.;\n            p.y = p.y + cos(time*mode_2_speed/10.)/10.;\n            rz= g; \n        }\n        field.vel = rz;\n        return field;\n    }\n    \n    if(mode == 1){\n        vec2 ep = vec2(0.05,0.);\n        vec2 rz= vec2(0);\n        //# centered grid sampling\n        for( int i=0; i<iterationTime1; i++ )\n        {\n            float t0 = f(p);\n            float t1 = f(p + ep.xy);\n            float t2 = f(p + ep.yx);\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\n            vec2 t = vec2(-g.y,g.x);\n\n            //# need update 'p' for next iteration,but give it some change.\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\n            p.x = p.x + sin( time*mode_2_speed/10.)/10.;\n            p.y = p.y + cos(time*mode_2_speed/10.)/10.;\n            rz= g;\n        }\n        \n        field.vel = rz;\n        // add curved effect into curved mesh\n        for(int i=1; i<iterationTime2; i++){\n            //# try comment these 2 lines,will give more edge effect\n            p.x+=0.3/float(i)*sin(float(i)*3.*p.y+time*mode_2_speed) + 0.5;\n            p.y+=0.3/float(i)*cos(float(i)*3.*p.x + time*mode_2_speed) + 0.5;\n        }\n        field.pos = p;\n        return field;\n    }\n    \n    return field;\n}\n//---------------------------------------------------------------\n\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h)*20.*arrow_density;\n}\n\nfloat fieldviz(in vec2 p,in int mode)\n{\n    vec2 ip = floor(p*arrow_density)/arrow_density + .5/arrow_density;   \n    vec2 t = field(ip,mode).vel;\n    float m = min(0.1,pow(length(t),0.5)*(arrow_length/arrow_density));\n    vec2 b = normalize(t)*m;\n    float rz = segm(p, ip, ip+b);\n    vec2 prp = (vec2(-b.y,b.x));\n    rz = min(rz,segm(p, ip+b, ip+b*0.65+prp*0.3));\n    return clamp(min(rz,segm(p, ip+b, ip+b*0.65-prp*0.3)),0.,1.);\n}\n\n\nvec3 getRGB(in Field fld,in int mode){\n\n    if(mode == 0){\n        vec2 p = fld.vel;\n        vec3 origCol = vec3(p * 0.5 + 0.5, 1.5);\n        return origCol;\n    }\n    \n    if(mode == 1){\n        vec2 p = fld.pos;\n        float r=cos(p.x+p.y+1.)*.5+.5;\n        float g=sin(p.x+p.y+1.)*.5+.5;\n        float b=(sin(p.x+p.y)+cos(p.x+p.y))*.3+.5;\n        vec3 col = sin(vec3(-.3,0.1,0.5)+p.x-p.y)*0.65+0.35;\n        return vec3(r,g,b);\n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy-0.5 ;\n\tp.x *= iResolution.x/iResolution.y;\n    p *= scale;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col;\n    float fviz;\n    \n    int vector_mode = 0;\n    Field fld = field(p,vector_mode);\n    col = getRGB(fld,vector_mode) * 0.85;    \n\tfragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265359\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n#define barWidth 0.002\n#define slideValY 0.5\n//(cos(iTime)+1.)/2.\n#define slideValX 0.5\n//(sin(iTime/2.)+1.)/2.\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n//#define HASHSCALE1 443.8975\n//#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n        vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}