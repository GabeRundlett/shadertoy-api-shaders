{
    "Shader": {
        "info": {
            "date": "1682365968",
            "description": "Circle, with equal parts. This is sort of a puzzle where you have to find a way to divide a circle into equal parts ( parts of equal shape % rotation and translation. ) AND at least one part musn't touch the center of a circle ( so no pizza slicing... ) ",
            "flags": 0,
            "hasliked": 0,
            "id": "cldGD8",
            "likes": 3,
            "name": "Circle arc equal split",
            "published": 3,
            "tags": [
                "circle",
                "puzzle",
                "equalsplit"
            ],
            "usePreview": 0,
            "username": "branc116",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "//©️branc116\n#define pi 3.1415926535\n#define AA 0\n\nmat3x4 clamp34(mat3x4 m34, float f, float t) {\n    return mat3x4(clamp(m34[0], f, t), clamp(m34[1], f, t), clamp(m34[2], f, t));\n}\n\nvec2 trans_rot(vec2 x, vec2 trans, float rot) {\n    return (x * mat2(cos(rot), sin(rot), sin(-rot), cos(rot))) + trans;\n}\n\nvec2 rot(vec2 x, float rot) {\n    return x * mat2(cos(rot), sin(rot), sin(-rot), cos(rot));\n}\n\nfloat smooth_in(float from, float to, float x, float eps) {\n    return smoothstep(from - eps, from + eps, x) - smoothstep(to - eps, to + eps, x);  \n}\n\nvec3 smooth_eq(float value, float x, float eps) {\n    float l = smoothstep(value - eps, value, x);\n    float u = smoothstep(value, value + eps, x);\n    return vec3(l - u, l, u);\n}\n\nvec2 circ(vec2 x) {\n    vec3 edge = smooth_eq(1., length(x), 2./iResolution.y);\n    float inside = 1. - edge.y;\n    return vec2(edge.x, inside);\n}\n\nvec2 cone(vec2 x, float from_rad, float to_rad) {\n    float angle = atan(x.y, x.x);\n    float is_in = smooth_in(min(from_rad, to_rad), max(from_rad, to_rad), angle, 2./iResolution.y);\n    return vec2(is_in, is_in);\n}\n\nvec3 circ_arc(vec2 x, float segment, float size) {\n    float size_angle = size*2.*pi;\n    float start_angle = size_angle * segment;\n    vec2 ci = circ(x);\n    vec2 co = cone(x, start_angle, start_angle + size_angle);\n    return vec3(ci.x * co.x, ci.y, co.y);\n}\n\nvec3 middle_segment(vec2 x) {\n    vec2 middle_arc = trans_rot(x, vec2(-1. - cos(2.5*pi/3.), -sin(2.5*pi/3.)), 0.);\n    return circ_arc((middle_arc + vec2(0., 1.0)), .5, 1./6.);\n}\n\nvec3 map(vec2 frag) {\n    float zoom = 2. + sin(iTime);\n    vec2 uv = frag/iResolution.yy*zoom - zoom/2.*vec2(iResolution.x/iResolution.y, 1.0);\n    uv = rot(uv, -iTime);\n\n    vec3 col = vec3(0.);\n    col.r += circ(uv).x;\n    mat3x4 count = mat3x4(0.0);\n    for (int i = 0; i < 6; ++i) {\n        vec3 a = circ_arc(trans_rot(uv, vec2(-1.0, 0.0), float(i)*pi/3.), 2., 1./6.);\n        vec3 b = middle_segment(rot(uv, float(i)*pi/3.));\n        col.b += a.x;\n        col.b += b.x;\n        //don't question this 3 lines!\n        count[i/2][(i*2)%4] += a.y - b.y;\n        count[i/2][(i*2)%4 + 1] += (-2. + b.y + a.y + a.z);\n        count[(i + 1)/2%3][(3 + i*2)%4] -= a.y;\n    }\n    bool inn = length(uv) < 1.0;\n    count = clamp34(count, 0., 1.);\n    for (int i = 0; i < 12; ++i) {\n        col += inn ? vec3(\n            count[i/4][i%4]/float(((1 + 1*i) % 6) + 1),\n            count[i/4][i%4]/float(((2 + 3*i) % 12) + 1),\n            count[i/4][i%4]/float(((6 + 5*i) % 12) + 1)) : vec3(0.); \n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 col = vec3(0.);\n    float aa_diff = 2./(float(AA)*2.0 + 1.);\n    int aa_count = (AA*2+1)*(AA*2+1);\n    for (int x = -AA; x <= AA; ++x) {\n        for (int y = -AA; y <= AA; ++y) {\n            col += map(fragCoord + (vec2(x, y)*aa_diff));\n        }\n    }\n    fragColor = vec4(col/float(aa_count), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}