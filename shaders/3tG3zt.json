{
    "Shader": {
        "info": {
            "date": "1579571531",
            "description": "No pressure solve! More voronoi particle tracking!\n[url]JAVASCRIPT: H=location.host;E=(H?window:opener).Effect;P=E.prototype;if(!E.P)E.P=P.Paint;P.Paint=function(...A){for(i=0;i<8;i++)E.P.apply(this,A);};if(!H)close();[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "3tG3zt",
            "likes": 13,
            "name": "Pure Vorofluid",
            "published": 3,
            "tags": [
                "particles",
                "what"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 503
        },
        "renderpass": [
            {
                "code": "// Fork of \"Wavy beams\" by michael0884. https://shadertoy.com/view/3tK3Dm\n// 2020-01-21 00:52:31\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tvec4 particle = texel(ch0, pos);\n    float distr = gauss(pos - particle.xy, prad);\n    vec4 flow = 0.5*texel(ch1, pos);\n    fragColor = vec4(cos(particle.zwz*vec3(5.2,2.6,1.0)), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//voronoi particle tracking \n\nfloat border(vec2 a)\n{\n    return min(minn(a), minn(size - a));\n}\n\nvec3 minv(vec3 a, vec3 b)\n{\n    return (a.z>b.z)?b:a;\n}\n\nvec3 borderF(vec2 a)\n{\n    return minv(minv(minv(vec3(1.,0.,a.x),vec3(0.,1.,a.y)),vec3(-1.,0.,size.x - a.x)),vec3(0.,-1.,size.y - a.y));\n}\n\nbool inside(vec2 a)\n{\n    if(border(a) > 1.) return true;\n    return false;\n}\n\n//loop the vector\nvec2 loop_d(vec2 pos)\n{\n\treturn mod(pos + size*0.5, size) - size*0.5;\n}\n\n//loop the space\nvec2 loop(vec2 pos)\n{\n\treturn mod(pos, size);\n}\n\n\nvoid Check(inout vec4 U, vec2 pos, vec2 dx)\n{\n    vec4 Unb = texel(ch0, loop(pos+dx));\n    //check if the stored neighbouring particle is closer to this position \n    if(length(loop_d(Unb.xy - pos)) < length(loop_d(U.xy - pos)))\n    {\n        U = Unb; //copy the particle info\n    }\n}\n\nvoid CheckRadius(inout vec4 U, vec2 pos, float r)\n{\n    Check(U, pos, vec2(-r,0));\n    Check(U, pos, vec2(r,0));\n    Check(U, pos, vec2(0,-r));\n    Check(U, pos, vec2(0,r));\n}\n\n#define rad 2\nvec2 computeforce(vec4 pr)\n{\n    vec2 F = vec2(0);\n    for(int i = -rad; i <= rad; i++)\n        for(int j = -rad; j <= rad; j++)\n        {\n            if(i != 0 && j != 0)\n            {\n                //neighbor particle\n                vec2 cell = pr.xy+vec2(i,j);\n                vec4 nb = texel(ch0, cell);\n                if(maxx(abs(nb.xy - cell))<0.5) //if neighbor is inside its cell then count force (to exclude repeated evals)\n                {\n                    vec2 dv = nb.zw - pr.zw; //velocity difference\n                    vec2 dr = nb.xy - pr.xy; //position vector\n                    vec2 tanv = dot(dv,dr)*dr/(dot(dr,dr) + 1e-3); //tangental velocity\n                    F += 1.*tanv*exp(-0.1*dot(dr,dr)) + 1.3*dr*exp(-2.*dot(dr,dr));\n                }\n            }\n        }\n    vec3 borderval = borderF(pr.xy);\n    F += 0.2*borderval.xy*exp(-borderval.z);\n    return F;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    vec2 muv = iMouse.xy/size;\n   \n    //this pixel value\n    U = texel(ch0, pos);\n    \n    //check neighbours \n    CheckRadius(U, pos, 1.);\n    CheckRadius(U, pos, 2.);\n    CheckRadius(U, pos, 3.);\n    CheckRadius(U, pos, 4.);\n    CheckRadius(U, pos, 5.);\n   \n    U.xy = loop(U.xy);\n    \n    // particle cloning \n    if(length(U.xy - pos) > 3.)\n    \tU = vec4(pos, 0.95*U.zw);\n\n\t//update the particle    \n    U.zw = U.zw + dt*computeforce(U);\n    U.xy += dt*U.zw;\n    \n    U.xy = loop(U.xy);\n    \n    \n    if(iFrame < 1 || (iMouse.z > 0. && length(iMouse.xy - pos) < 30.) || (maxx(abs(size.xy*0.5 - pos)) < 50.))\n    {\n        U.xy = vec2(pdens*round(pos.x/pdens),pdens*round(pos.y/pdens));\n        U.zw = 10.*(hash22(U.xy) - 0.5);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//simulation variables\n#define dt 0.3\n#define prad 1.\n\n\n#define pdens 2.\n//definitions\n#define size iResolution.xy\n#define pixel(a, p) texture(a, p/vec2(textureSize(a,0)))\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define PI 3.14159265\n\n//hash functions\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n//functions\nfloat gauss(vec2 x, float r)\n{\n    return exp(-pow(length(x)/r,2.));\n}\n   \n\n//a rainbow colormap from Matlab\nfloat interpolate(float val, float y0, float x0, float y1, float x1) \n{\n    return (val-x0)*(y1-y0)/(x1-x0) + y0;\n}\n\nfloat base(float val) \n{\n    if ( val <= -0.75 ) return 0.0;\n    else if ( val <= -0.25 ) return interpolate( val, 0.0, -0.75, 1.0, -0.25 );\n    else if ( val <= 0.25 ) return 1.0;\n    else if ( val <= 0.75 ) return interpolate( val, 1.0, 0.25, 0.0, 0.75 );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n//Laplacian operator\nvec4 Laplace(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return texel(ch, p+dx.xy)+texel(ch, p+dx.yx)+texel(ch, p+dx.zy)+texel(ch, p+dx.yz)-4.*texel(ch, p);\n}\n\n//Gradient\nvec2 Grad(sampler2D ch, vec2 p)\n{\n    vec3 dx = vec3(-1,0.,1);\n    return vec2(length(texel(ch, p+dx.zy)),length(texel(ch, p+dx.yz))) - length(texel(ch, p));\n}\n\n\nfloat angle_between(vec2 a,vec2 b)\n{\n    return atan(a.x*b.y-a.y*b.x,dot(a,b));\n}\n\nfloat minn(vec2 a)\n{\n    return min(a.x, a.y);\n}\n\nfloat maxx(vec2 a)\n{\n    return max(a.x, a.y);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}