{
    "Shader": {
        "info": {
            "date": "1414855634",
            "description": "2D Effect library of code snippets\nSeparately on github in a gists: https://gist.github.com/caiwan/0261ed2d42467d29eddb",
            "flags": 0,
            "hasliked": 0,
            "id": "ldSXzt",
            "likes": 3,
            "name": "2d fx collection",
            "published": 3,
            "tags": [
                "codesnippets"
            ],
            "usePreview": 0,
            "username": "caiwan",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\n/** \n\t*** EFFEKTGYUJTEMENY ***\n\tMindent egy sorba, hogy ne zavarjon\n*/\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** KALEIDOSCOPE ***\nvec2 kaleidoscope( vec2 uv, float n, float bias ) { float angle = PI / n; float r = length( uv ); float a = atan( uv.y, uv.x ) / angle; a = mix( fract( a ), 1.0 - fract( a ), mod( floor( a ), 2.0 ) ) * angle; return vec2( cos( a ), sin( a ) ) * r;}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** PERLIN ZAJ ***\n/// 2D random\nvec2 random2(vec2 c) { float j = 4906.0*sin(dot(c,vec2(169.7, 5.8))); vec2 r; r.x = fract(512.0*j); j *= .125; r.y = fract(512.0*j);return r-0.5;}\n\n/// 1D random / hash\nfloat hash(float f){ return fract(56546.235423 * sin(f*235345.345345));}\n\nconst float F2 =  0.3660254;\nconst float G2 = -0.2113249;\n\n/// simplex 2D zaj; perlin zaj egy frekvenciajahoz tartozo ertekek\nfloat simplex2d(vec2 p){vec2 s = floor(p + (p.x+p.y)*F2),x = p - s - (s.x+s.y)*G2; float e = step(0.0, x.x-x.y); vec2 i1 = vec2(e, 1.0-e),  x1 = x - i1 - G2, x2 = x - 1.0 - 2.0*G2; vec3 w, d; w.x = dot(x, x); w.y = dot(x1, x1); w.z = dot(x2, x2); w = max(0.5 - w, 0.0); d.x = dot(random2(s + 0.0), x); d.y = dot(random2(s +  i1), x1); d.z = dot(random2(s + 1.0), x2); w *= w; w *= w; d *= w; return dot(d, vec3(70.0));}\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** COLOR TRANSFORMATION ***\n//http://beesbuzz.biz/code/hsv_color_transforms.php\n\nvec3 rgb2yiq(vec3 color){return color * mat3(0.299,0.587,0.114,0.596,-0.274,-0.321,0.211,-0.523,0.311);}\nvec3 yiq2rgb(vec3 color){return color * mat3(1.,0.956,0.621,1,-0.272,-0.647,1.,-1.107,1.705);}\n\n// Direkt HSV transzformacio \nvec3 hsvTransform(vec3 color, vec3 hsv){float  _h = hsv.x, _s = hsv.y, _v = hsv.y; float  VSU = _v*_s*cos(_h*PI/180.), VSW = _v*_s*sin(_h*PI/180.), rr = (.299*_v+.701*VSU+.168*VSW)*color.x + (.587*_v-.587*VSU+.330*VSW)*color.y + (.114*_v-.114*VSU-.497*VSW)*color.z, gg = (.299*_v-.299*VSU-.328*VSW)*color.x + (.587*_v+.413*VSU+.035*VSW)*color.y + (.114*_v-.114*VSU+.292*VSW)*color.z, bb = (.299*_v-.300*VSU+1.25*VSW)*color.x + (.587*_v-.588*VSU-1.05*VSW)*color.y + (.114*_v+.886*VSU-.203*VSW)*color.z; return vec3(rr,gg,bb); }\n\nvec3 convertRGB4quant(vec3 color){ vec3 out0 = mod(color,1./16.); return out0;}\nvec3 convertRGB4(vec3 color){return color-convertRGB4quant(color);}\n\nvec3 convertRGB443quant(vec3 color){ vec3 out0 = mod(color,1./16.); out0.b = mod(color.b, 1./8.); return out0;}\nvec3 convertRGB443(vec3 color){return color-convertRGB443quant(color);}\n\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); rgb = rgb*rgb*(3.0-2.0*rgb); return c.z * mix( vec3(1.0), rgb, c.y);}\nvec3 hsv2rgb_trigonometric( in vec3 c ){vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);return c.z * mix( vec3(1.0), rgb, c.y);}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** TUNNEL ***\nvec3 tunnel_uvw(vec2 pos){ float u = length(pos); return vec3 (u, atan(pos.y, pos.x), 1.0/u);}\nvec3 tunnel_coord(vec2 p, float frekv, float radius, mat4 mat){\n    vec3 o = mat[3].xzy, d = normalize(mat[2].xyz*radius + mat[0].xyz*p.x + mat[1].xyz*p.y);\n    float D=1./(d.y*d.y+d.z*d.z), a=(o.y*d.y+o.z*d.z)*D, b=(o.y*o.y+o.z*o.z-36.)*D, t=-a-sqrt(a*a-b); o+=t*d;// t = sqrt(a*a-b);\n    return vec3(o.x, atan(o.y,o.z)*(frekv/PI), t);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** TRANSZFORMACIOK ***\nvec2 sincos( float x ){return vec2(sin(x), cos(x));}\nvec2 rotate2d(vec2 uv, float phi){vec2 t = sincos(phi); return vec2(uv.x*t.y-uv.y*t.x, uv.x*t.x+uv.y*t.y);}\nvec3 rotate3d(vec3 p, vec3 v, float phi){ v = normalize(v); vec2 t = sincos(-phi); float s = t.x, c = t.y, x =-v.x, y =-v.y, z =-v.z; mat4 M = mat4(x*x*(1.-c)+c,x*y*(1.-c)-z*s,x*z*(1.-c)+y*s,0.,y*x*(1.-c)+z*s,y*y*(1.-c)+c,y*z*(1.-c)-x*s,0.,z*x*(1.-c)-y*s,z*y*(1.-c)+x*s,z*z*(1.-c)+c,0.,0.,0.,0.,1.);return (vec4(p,1.)*M).xyz;}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** 2D TEXTURA FX ***\nfloat checker(vec2 p){ return mod(floor(p.x)+floor(p.y), 2.);}\nfloat stripe(float p, float h){return (abs(1.-mod(p,2.)) < h) ? 1. : 0.;}\nfloat gradient(float p){return abs(1.-mod(p,2.));}\n\nfloat IsGridLine(vec2 fragCoord, float rows)\n{\n    float sizeOfSquares = iResolution.y / rows;\n\tvec2 vPixelsPerGridSquare = vec2(sizeOfSquares, sizeOfSquares);\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\treturn fIsGridLine;\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/// *** DEMOS ***\n/**\n************************************************\nFustscroll\nPerlin noise + scroll fel\n************************************************\n*/\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float k = (1.-uv.y);\n\tvec2 sh;\n    sh.x = (uv.x - .5) * (k/3.);\n    sh.y = -iTime * .5 - k*k*k;\n    \n    // + ide jon nulla sebesseggel a backbuffer eltolva\n    float a = simplex2d(2.*uv + 3.*sh);\n    float b = simplex2d(4.*uv + 9.*sh) / 4.;\n    float c = simplex2d(8.*uv + 13.*sh) / 8.;\n    float d = simplex2d(16.*uv + 21.*sh)/ 16.;\n    float e = simplex2d(32.*uv + 27.*sh)/ 32.;\n    \n    // + itt kell kivonni a backbufferbol\n    float f = .5 + a + b + c + d + e + .45*uv.y;\n    \n    fragColor.rgb = vec3(1.-(f*f));\n    fragColor.a = 1.;\n\n}\n#endif\n\n/************************************************\nFustscroll 2\nBased on https://www.shadertoy.com/view/Xsl3zN\n************************************************\n*/\n#if 1\n\nfloat fbm(vec2 n){\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\ttotal += simplex2d(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float k = (1.-uv.y);\n\tvec2 sh;\n    sh.x = (uv.x - .5) * (k/3.);\n    sh.y = -iTime * .5 - k*k*k;\n       \n    float t = iTime*.2; // let globally control the time\n\tfloat q = fbm(uv+t * 0.1);\n    vec2 r = vec2(fbm(uv + q+ t * 0.7 - uv.x - uv.y), fbm(uv + q -t * 0.4));\n\t\n    fragColor.rgb = hsv2rgb_smooth(vec3(.6, .9, 1.) - .5*vec3(.2*sin(r.x), r.x, r.y));\n    fragColor.a = 1.;\n    \n}\n#endif\n\n/**\n************************************************\nGLICCS 1\n************************************************\n*/\n\n/**\n\tMegbasz-effekt\n\tTY Pasy, finom volt.\n\t@param uv koordinata\n\t@param color bemeno szin\n\t@return megbaszott szin\n*/\n\nvec4 megbasz(vec2 uv, vec4 color);\n\n#define ITERATIONS 16\n\n/**\n\tVizszintes eltolas + HSV eltolas random\n\tv1\n\t@param uv texturakoordinata\n\t@param shift szegmens y-eltolasa\n\t@param seed random seed\n\t@param speed random valtas sebessege\n\t@param segment segmens meret\n\t@return HSV transform (xyz) es vizszintes eltolas (w)\n*/\nvec4 distort(vec2 uv, float shift, float seed, float speed, float segment){\n\tvec4 transform = vec4(0.,2.,1.,0.);\n\tif (seed>0.){\n\t\tfloat \tf = hash(sin(uv.y)), dir, s, p, v, t = speed * iTime;\n\t\t\n\t\tv = hash(ceil(segment*uv.y));\n\t\tdir = hash(seed*v)>.5?-1.:1.;\n\t\tp = hash(fract(v + .0005*floor(t) ) );\n\t\ts = fract(seed*uv.y+dir*shift); \n\t\t\n\t\tif(s-v>0.1)\n\t\t\ttransform = vec4(\n\t\t\t\t360. *hash(v*v*p*p),\t\t\t\t// H\n\t\t\t\t.1 + 2.* hash(seed*sin(v*v*p*p)),\t// S\n\t\t\t\t.1 + 2.* hash(seed*cos(v*v*p*p)),\t// V\n\t\t\t\tdir*(.1 * v * p));\t\t\t\t\t// X-shift\n\t\telse if (s-v<-0.175)\n\t\t\ttransform = vec4(\n\t\t\t\t180. *v*v*p*p,\t\t\t\t\t\t// H\n\t\t\t\t.1 + 2.* hash(sin(v*v*p*p)),\t\t// S\n\t\t\t\t.1 + 2.* hash(cos(v*v*p*p)),\t\t// V\n\t\t\t\tdir*(.1 * v * p) + p*uv.x);\t\t\t// X-shift\n\t}\n\treturn transform;\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\t\n\tvec4 trans;\n\tfor (int i=0; i<ITERATIONS; i++){\n\t\ttrans += distort(uv, .5*iTime + float(i), 2., 10., 1.+float(i)) / float(ITERATIONS);\n\t}\n\t\n\tvec4 color = texture(iChannel0, uv + .02 * vec2(trans.w,0));\n\tfloat f = .5+.5*rgb2hsv(color.rgb).x;\n\t\n\tcolor.rgb = hsvTransform(color.rgb, trans.rgb);\n\t\n    fragColor = megbasz(uv, color);\n}\n\n#endif \n\n\n/**\n************************************************\nTUNNEL\n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ( fragCoord.xy / iResolution.y);\n\tfloat ar = (iResolution.x / iResolution.y); \n    uv = uv-vec2(ar*.5,.5);\n    \n    float time = iTime;\n    \n    // ----\n\tvec3 eltolas = vec3(-5.*time, .05*sin(2.*time), .05*cos(2.*time));\n    vec3 nezet   = vec3(10., .5-.05*sin(time), 0);\n    vec3 irany   = vec3(0,.05*cos(time),.05*sin(time));\n    \n    vec3 cp=eltolas, ct=cp+nezet,\t// cp = szem, ct = center\n        cd=normalize(ct-cp),  /*nezet irany*/\n        cr=normalize(cross(cd,irany)), /*nezet 'elfordulas';*/\n        cu=cross(cr,cd);\t/*up vektor*/\n\n    mat4 m = mat4( vec4(cr, 0.), vec4(cu, 0.), vec4(cd, 0.), vec4(eltolas, 1.));\n    // ----\n    \n\tvec3 tunnel_pos = tunnel_coord(uv, 5., 1.5, m);\n    \n    float a = (stripe(tunnel_pos.y-.3, .15) + stripe(tunnel_pos.y-.5, .25) + stripe(tunnel_pos.y-.4, .2)) * .333;\n    float b = (stripe(tunnel_pos.y+.3, .15) + stripe(tunnel_pos.y+.5, .25) + stripe(tunnel_pos.y+.4, .2)) * .333;\n    \n    float z = -tunnel_pos.z*.051 - 1.; z=z/(z+1.); clamp(z,0.,1.);\n    \n    vec3 ca0 = mix(vec3(.082,.110,.388), vec3(.243,.275,.573), z);\n    vec3 ca1 = mix(vec3(.541,.565,.784), vec3(.541,.565,.784), z);\n    \n\tvec3 cb0 = mix(vec3(  1.,.847,.639), vec3( 1. ,.949,.639), z);\n    vec3 cb1 = mix(vec3(.561,.345,.051), vec3(.561,.490,.051), z);\n    \n    vec3 color = mix(cb0, cb1, b); if (a>b) color = mix(ca0, ca1, a);\n    \n    //color = vec3(a+b) * .5;\n    \n    fragColor = vec4(color,1.);\n}\n#endif\n\n/**\n************************************************\nRGB 4 es RGB 443 konverter + gerimotor\n************************************************\n*/\n\nvec3 gerimotor(vec2 uv){ return texture(iChannel0, uv-mod(uv,1./vec2(128,64))).rgb; }\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfragColor.rgb = convertRGB443(gerimotor(uv)).rgb;\n\tfragColor.a = 1.;\n\t\t\n}\n#endif\n\n/**\n************************************************\nMEGBASZ TV CSIK\n************************************************\n*/\n\nvec4 megbasz(vec2 uv, vec4 color) \n{ \n\t//fragColor = texture(texture, gl_TexCoord[0].st); \n    vec4 res = color;\n\tfloat x      = uv.s * iResolution.x; \n\tfloat y      = uv.t * iResolution.y; \n\tfloat modx2  = mod(x,       2.0); \n\tfloat mody3  = mod(y,       3.0); \n\tfloat mody13 = mod(y - 1.0, 3.0); \n\tfloat mody23 = mod(y - 2.0, 3.0); \n\tif (modx2 < 1.0 && mody3  < 1.0 ) res *= vec4(1.0,0.0,0.0,1.0);  \n\tif (modx2 > 1.0 && mody3  < 1.0 ) res *= vec4(0.0,1.0,0.0,1.0); \n\tif (modx2 < 1.0 && mody13 < 1.0 ) res *= vec4(0.0,0.0,1.0,1.0);  \n\tif (modx2 > 1.0 && mody13 < 1.0 ) res *= vec4(1.0,0.0,0.0,1.0); \n\tif (modx2 < 1.0 && mody23 < 1.0 ) res *= vec4(0.0,1.0,0.0,1.0);  \n\tif (modx2 > 1.0 && mody23 < 1.0 ) res *= vec4(0.0,0.0,1.0,1.0);\n    \n    return res;\n} \n\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\t\n    vec4 color = texture(iChannel0, uv );\n    \n\tfragColor = megbasz(uv,color);\n}\n#endif \n\n/**\n************************************************\nlofasz szinatmenet meg baszo gululo geci fasszal\n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    uv = rotate2d(uv, iTime);\n    \n    vec3 c00 = vec3(180., 231., 251.) / 255.; //#b4e7fb\n    vec3 c01 = vec3(157., 172., 216.) / 255.; //#9dacd8\n    vec3 c02 = vec3(049., 130., 163.) / 255.; //#3182a3\n    vec3 c03 = vec3(119., 126., 198.) / 255.; //#777ebd\n    \n    vec3 cv = mix(c00, c01, length(uv-vec2(0.,1.)));\n    vec3 ch = mix(c02, c03, uv.x);\n    \n    vec3 color = mix(ch, cv, dot(uv, vec2(-1.,1.)));\n    \n    fragColor = vec4(color,1.0);\n}\n#endif\n\n/**\n************************************************\nHSV Transzform proba \n************************************************\n*/\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = (uv-.5)*2.;\n    vec2 duv = vec2(1./256.); vec3 yiq;\n    \n    yiq = vec3(cos(iTime), uv); vec3 colorM = yiq2rgb(yiq);\n\n    yiq = vec3(cos(iTime), uv+vec2( 0., 1.)*duv); vec3 colorU = convertRGB443quant(yiq2rgb(yiq));\n    yiq = vec3(cos(iTime), uv+vec2( 0.,-1.)*duv); vec3 colorD = convertRGB443quant(yiq2rgb(yiq));\n    \n    //yiq = vec3(cos(iTime), uv+vec2( 1., 1.)*duv); vec3 colorUL = convertRGB443quant(yiq2rgb(yiq));\n    //yiq = vec3(cos(iTime), uv+vec2( 1.,-1.)*duv); vec3 colorDL = convertRGB443quant(yiq2rgb(yiq));\n    \n\t//yiq = vec3(cos(iTime), uv+vec2(-1., 1.)*duv); vec3 colorUR = convertRGB443quant(yiq2rgb(yiq));\n    //yiq = vec3(cos(iTime), uv+vec2(-1.,-1.)*duv); vec3 colorDR = convertRGB443quant(yiq2rgb(yiq));\n    \n\tyiq = vec3(cos(iTime), uv+vec2( 1., 0.)*duv); vec3 colorL = convertRGB443quant(yiq2rgb(yiq));\n    yiq = vec3(cos(iTime), uv+vec2(-1., 0.)*duv); vec3 colorR = convertRGB443quant(yiq2rgb(yiq));\n    \n    //vec3 color = convertRGB443(colorM + (colorU + colorD + colorL + colorR + colorUR + colorDR + colorUL + colorDL) / 16.);\n    vec3 color = convertRGB443(\n        colorM + \n        /*(7./16.)* */colorU + \n        /*(3./16.)* */colorD + \n        /*(5./16.)* */colorL + \n        /*(1./16.)* */colorR);\n    \n    /** */\n    // mind a negy siknyegyedre visszaadja az UV-t jol\n    // erre itt vigyazni kell, mert ertekes cucc \n    #if 0\n    vec3 color = vec3(abs(uv), dot(uv+.5,normalize(vec2(1.,1.))));\n    #endif\n    /** */\n    fragColor = vec4(color,1.0);\n}\n#endif \n\n\n/**\n************************************************\nLSD\n************************************************\n*/\n\nfloat varazslat(vec2 position, float time){\n\tfloat color = 0.0;\n\tfloat t = 2.*time;\n\tcolor += sin(position.x*cos(t/10.0)*20.0 )+cos(position.x*cos(t/15.)*10.0 );\n\tcolor += sin(position.y*sin(t/ 5.0)*15.0 )+cos(position.x*sin(t/25.)*20.0 );\n\tcolor += sin(position.x*sin(t/10.0)*  .2 )+sin(position.y*sin(t/35.)*10.);\n\tcolor *= sin(t/10.)*.5;\n\t\n\treturn color;\n}\n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    uv = (uv-.5)*2.;\n   \n    vec3 vlsd = vec3(0,1,0);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    \n    vec2 \n        v0 = .75 * sincos(.3457 * iTime + .3423) - simplex2d(uv * .917),\n        v1 = .75 * sincos(.7435 * iTime + .4565) - simplex2d(uv * .521), \n        v2 = .75 * sincos(.5345 * iTime + .3434) - simplex2d(uv * .759);\n    \n    vec3 color = vec3(dot(uv-v0, vlsd.xy),dot(uv-v1, vlsd.yz),dot(uv-v2, vlsd.zx));\n    \n    color = yiq2rgb(color);\n    \n    color *= 1.- .25* vec3(\n    \tvarazslat(uv *.25, iTime + .5),\n        varazslat(uv * .7, iTime + .2),\n        varazslat(uv * .4, iTime + .7)\n    );\n    \n    fragColor = vec4(color,1.0);\n}\n#endif \n\n#if 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n    uv = (uv-.5)*2.;\n   \n    vec3 vlsd = vec3(0,1,0);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    vlsd = rotate3d(vlsd, vec3(1.,1.,0.), iTime);\n    \n    vec2 \n        v0 = .75 * sincos(.3457 * iTime + .3423) - simplex2d(uv * .917),\n        v1 = .75 * sincos(.7435 * iTime + .4565) - simplex2d(uv * .521), \n        v2 = .75 * sincos(.5345 * iTime + .3434) - simplex2d(uv * .759);\n    \n    vec3 color = vec3(dot(uv-v0, vlsd.xy),dot(uv-v1, vlsd.yz),dot(uv-v2, vlsd.zx));\n    \n    color *= .2 + 2.5*vec3(\n    \t(16.*simplex2d(uv+v0) + 8.*simplex2d((uv+v0)*2.) + 4.*simplex2d((uv+v0)*4.) + 2.*simplex2d((uv+v0)*8.) + simplex2d((v0+uv)*16.))/32.,\n        (16.*simplex2d(uv+v1) + 8.*simplex2d((uv+v1)*2.) + 4.*simplex2d((uv+v1)*4.) + 2.*simplex2d((uv+v1)*8.) + simplex2d((v1+uv)*16.))/32.,\n        (16.*simplex2d(uv+v2) + 8.*simplex2d((uv+v2)*2.) + 4.*simplex2d((uv+v2)*4.) + 2.*simplex2d((uv+v2)*8.) + simplex2d((v2+uv)*16.))/32.\n    );\n    \n    color = yiq2rgb(color);\n    /*\n    color *= 1.- .25* vec3(\n    \tvarazslat(uv *.25, iTime + .5),\n        varazslat(uv * .7, iTime + .2),\n        varazslat(uv * .4, iTime + .7)\n    );\n    */\n    //fragColor = vec4(convertRGB443(color),1.0);\n    fragColor = vec4(color, 1.0);\n}\n#endif \n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}