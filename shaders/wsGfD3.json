{
    "Shader": {
        "info": {
            "date": "1608339062",
            "description": "An infinite variety of ornate spherical Truchet tilings.\n\nMouse rotates, click in lower left to restore auto-rotation. See comments at top of image code for keys.",
            "flags": 48,
            "hasliked": 0,
            "id": "wsGfD3",
            "likes": 90,
            "name": "heavy metal squiggle orb",
            "published": 3,
            "tags": [
                "raymarched",
                "truchet",
                "tiling",
                "spherical",
                "polyhedron",
                "wythoff"
            ],
            "usePreview": 1,
            "username": "mattz",
            "viewed": 2803
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// \"heavy metal squiggle orb\" by mattz\n// License https://creativecommons.org/licenses/by/4.0/\n//\n// An infinite variety of ornate spherical Truchet tilings.\n//\n// Demo automatically cycles through a \"playlist\" of 16 polyhedra.\n//\n// Use the mouse to rotate the orb or click in the lower-left corner\n// to restore automatic rotation.\n//\n// KEYS: (these break out of demo mode):\n//\n//   A/S prev/next in playlist\n//\n//   Q/W change symmetry (tetrahedral/octahedral/icosahedral)\n//   E/R modify vertex location (7 possibilities)\n//   T/Y modify random seed (2^16 possibilities!)\n//\n// To return to demo mode, press D (won't do anything if paused)\n//\n// See https://en.wikipedia.org/wiki/Uniform_polyhedron#Summary_tables\n// for all possibile polyhedra (note this shader doesn't implement the\n// snub variants).\n//\n// Background: I had a lot of fun writing \"rainbow noodle orbs\" \n// (https://www.shadertoy.com/view/tsVBDW) but the woven Truchet\n// tiling in that shader was too slow to raymarch. \n//\n// By using only single spherical arcs (torus segments) for each\n// connection within a tile, and by exploiting symmetries within\n// each tile, I was able to make things fast enough to raymarch \n// while still maintaining some really interesting diversity of\n// appearances.\n//\n//////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float TOL = 1e-5;\n\nivec3 setup = ivec3(3, 0, 0);\nfloat decorate = 1.0;\n\n#define MAX_POLYGON 10\n\n//////////////////////////////////////////////////////////////////////\n// inverse linear interpolation\n\nfloat unlerp(float lo, float hi, float x) {\n    return clamp((x-lo)/(hi-lo), 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/XlGcRh \n// original by Dave Hoskins\n\nvec3 hashwithoutsine31(float p) {\n   vec3 p3 = fract(vec3(p,p,p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rotate about arbitrary axis/angle\n\nmat3 rotate(in vec3 k, in float t) {\n    \n    if (abs(t) < TOL) {\n        return mat3(1.);\n    }\n    \n    mat3 K = mat3(0, k.z, -k.y,\n                  -k.z, 0, k.x,\n                  k.y, -k.x, 0);\n                  \n    return mat3(1.) + (mat3(sin(t)) + (1. - cos(t))*K)*K;\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// Wythoff construction\n\nivec3 construct(in vec3 p, \n                out vec3 face_normal, out vec3 v_cur,\n                out float poly_edge_dist, out int nface) {\n               \n    //////////////////////////////////////////////////\n    // step 1: construct Schwarz triangle with vertex\n    // at (0, 0, 1) and along x=0 and y=0 planes\n    //\n    // this is a (P, Q, R) triangle with Q=3 and R=2\n    //\n    //  Q=3 *--__\n    //      |    ^^--__\n    /// R=2 *----------* P = 3, 4, or 5\n    //\n    // where p=3, 4, or 5\n   \n    int degree = setup.x;\n    int spoint = setup.y;\n    \n    float tp = PI / float(degree);\n    float cp = cos(tp);\n    \n    vec3 lp = vec3(1, 0, 0);\n    vec3 lq = vec3(0, 1, 0);\n\n    vec3 lr = vec3(-0.5, -cp, sqrt(0.75 - cp*cp));\n    \n    mat3 tri_edges = mat3(lp, lq, lr);\n    \n    vec3 vP = normalize(cross(lq, lr));\n    vec3 vR = vec3(0, 0, 1);\n    vec3 vQ = normalize(cross(lr, lp));\n    \n    mat3 tri_verts = mat3(vP, vQ, vec3(0, 0, 1));\n\n    //////////////////////////////////////////////////\n    // step 2: mirror point into triangle\n    \n    mat3 M = mat3(1.);\n    \n    mat3 Mr = mat3(1.) - 2.*outerProduct(lr, lr);\n\n    for (int i=0; i<5; ++i) {\n        if (p.x < 0.) { p.x = -p.x; M[0] = -M[0]; }\n        if (p.y < 0.) { p.y = -p.y; M[1] = -M[1]; }\n        if (dot(p, lr) < 0.) { p = reflect(p, lr); M *= Mr; }\n    }\n        \n    //////////////////////////////////////////////////\n    // step 3: polygon construction\n\n    ivec3 npoly = ivec3(0);\n    \n    vec3 poly_vertex;\n        \n    if (spoint == 0) {\n        // polygon vertex at degree-P triangle vertex, so all triangles\n        poly_vertex = vP;\n        npoly = ivec3(0, 1, 0);\n    } else if (spoint == 1) {\n        // polygon vertex at degree-3 triangle vertex, so all P-gons\n        poly_vertex = vQ;\n        npoly = ivec3(1, 0, 0);\n    } else if (spoint == 2) {\n        // polygon vertex at degree-2 triangle vertex, so alternation of triangles and P-gons\n        poly_vertex = vR;\n        npoly = ivec3(1, 1, 0);\n    } else if (spoint == 3) {\n        // polygon vertex at bisector of degree-P angle, alternation of 2P and triangles\n        poly_vertex = normalize(cross(lp, lq - lr));\n        npoly = ivec3(2, 1, 0);\n    } else if (spoint == 4) {\n        // polygon vertex at bisector of degree-Q angle, alternation of hexagons and P-gons\n        poly_vertex = normalize(cross(lq, lr - lp));\n        npoly = ivec3(1, 2, 0);\n    } else if (spoint == 5) {\n        // polygon vertex at bisector of degree-2 angle, alternation of triangles, P-gons, squares\n        poly_vertex = normalize(cross(lr, lp - lq));\n        npoly = ivec3(1, 1, 2);\n    } else {\n        // polygon vertex at circumcenter\n        poly_vertex = normalize(cross(lp - lq, lq - lr));\n        npoly = ivec3(2, 2, 2);\n    }\n    \n    mat3 poly_edges = mat3(normalize(cross(poly_vertex, lp)),\n                           normalize(cross(poly_vertex, lq)),\n                           normalize(cross(poly_vertex, lr)));\n        \n    poly_edge_dist = 1e5;\n    \n    vec3 pe = p * poly_edges;\n    bool is_even = true;\n    \n    ivec3 npolys = ivec3(degree, 3, 2) * npoly;\n    \n    v_cur = M * poly_vertex;\n\n    for (int vidx=0; vidx<3; ++vidx) {\n        \n        if (npoly[vidx] >= 0) {\n        \n            int idx0 = (vidx + 1) % 3;\n            int idx1 = (vidx + 2) % 3;\n                    \n            float d0 = pe[idx0];\n            float d1 = pe[idx1];\n            \n            if (d0 <= 0. && d1 >= 0.) {\n            \n                d0 = -d0;\n            \n                if (d0 < d1) {\n                    poly_edge_dist = d0;\n                } else {\n                    poly_edge_dist = d1;\n                }\n                \n                face_normal = M*tri_verts[vidx];\n                nface = npolys[vidx];\n                                \n            }\n            \n        }\n    }\n    \n    return npolys;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// squared distance from point p to a circle perpendicular to vector n \n// passing thru point p0\n\nfloat dcircle2(vec3 p, vec3 n, vec3 p0) {\n\n    float k = dot(p0, n);\n    \n    vec3 c = k*n;\n    \n    p -= c;\n    p0 -= c;\n    \n    float z = dot(p, n);\n    \n    vec3 xy = p - z*n;\n    \n    vec3 pc = normalize(xy)*length(p0);\n    \n    vec3 q = p - pc;\n    \n    return dot(q, q);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// distance function\n\nvec2 map(in vec3 p) {\n\n\n    p = rotate(vec3(0.18549298, 0.58241682, 0.79144362), 0.5) * p;\n\n    // phases for animation\n    float crack_visibility = smoothstep(0.0, 0.45, decorate);\n    float torus_visibility = smoothstep(0.55, 1.0, decorate);\n    \n    ////////////////////////////////////////////////////////////\n    // Wythoff construction\n\n    float extra = float(setup.z);\n    \n    vec3 face_normal, v_cur;\n    float poly_edge_dist;\n    int nface;\n    \n    ivec3 npolys = construct(p, \n                             face_normal, v_cur,\n                             poly_edge_dist, nface);\n                             \n    ////////////////////////////////////////////////////////////\n    // Compute the canonical index of the current polygon \n    // vertex from 0 ... nface - 1\n    \n    vec3 r0 = vec3(0.7027036, 0.68125974, 0.56301879);\n    vec3 r1 = vec3(0.65254045, 0.98167042, 0.49662301);\n    \n    float dr0 = abs(dot(face_normal, r0));\n    float dr1 = abs(dot(face_normal, r1));\n    \n    vec3 rando_dir = dr0 < dr1 ? r0 : r1;\n    \n    vec3 basis_u = normalize(cross(rando_dir, face_normal));\n    vec3 basis_v = cross(face_normal, basis_u);\n    \n    vec2 uv = (vec2(dot(v_cur, basis_u), dot(v_cur, basis_v)));\n\n    float rot_angle = 0.5 + 0.5*atan(uv.y, uv.x)/PI;\n    float fnface = float(nface);\n    \n    float idx = floor(rot_angle*fnface);\n\n    ////////////////////////////////////////////////////////////\n    // Now set up to do compute the torus distances\n    \n    // Rotation by angle increment\n    float dtheta = 2.*PI/fnface;    \n    mat3 R = rotate(face_normal, dtheta);\n    \n    // Get second-closest vertex\n    vec3 v_next = dot(p, cross(v_cur, face_normal)) < 0. ? R*v_cur : v_cur*R;\n\n    // Figure out whether we're doing one or two nodes per\n    // polygon edge (note odd-numbered polygons like triangles\n    // and pentagons require this)\n    bool use_midpoint = (npolys % 2 == ivec3(0)) && setup.xy != ivec2(4, 1);\n\n    // Compute torus minor radius\n    float kwidth = use_midpoint ? 0.16 : 0.07;\n    float torus_r0 = kwidth*acos(dot(v_cur, v_next));    \n\n    // Fraction to sink torii down into sphere\n    float sink_by = 1.0 - mix(1.01*torus_r0, 0.25*torus_r0, torus_visibility);\n        \n    // Random vector per face\n    face_normal = normalize(face_normal);\n    vec3 rface = hashwithoutsine31(floor(64.*dot(face_normal, rando_dir) + extra + 0.5));\n    \n    // Choose a random integer rotation for symmetric tiles\n    float ioffs = floor(rface.z * fnface);\n\n    // We need to keep nodes closer together if there are triangles\n    // or squares in this tiling\n    bool any34 = any(equal(npolys, ivec3(3))) || any(equal(npolys, ivec3(4)));\n\n    // How close together to put two nodes on same edge \n    // (closeness = 1 means midpoint of edge)\n    float closeness = use_midpoint ?  1.0 : any34 ? 0.65 : 0.55;\n\n    ////////////////////////////////////////////////////////////\n    // Time to compute the torus distances!\n    \n    float d_torus = 1e5;\n    \n    if (rface.x < 0.75) {\n\n        // Bilaterally symmetric cell - expensive distance \n        // query to multiple torii\n\n        // Canonical polygon vertex 0 and vertex 1 \n        vec3 p0 = rotate(face_normal, (ioffs - idx)*dtheta) * v_cur;\n        vec3 p1 = R*p0;\n\n        // Nodes along canonical edge\n        vec3 n0 = sink_by*normalize(p0 + closeness*p1);\n        vec3 n1 = sink_by*normalize(closeness*p0 + p1);\n\n        // Polygon edge\n        vec3 polygon_edge = cross(p0, p1);\n        \n        // Choose centerline for bilateral symmetry.\n        // No big difference for odd polygons but\n        // two distinct looks for even polygons.\n        \n        vec3 pc;\n                        \n        if ((!use_midpoint && rface.y < 0.45)) {\n            // arc centers distributed along\n            // line passing thru edge midpoint\n            pc = p0 + p1;\n        } else {\n            // arc centers distributed along\n            // line passing thru vertex\n            pc = p0;\n        }\n\n        vec3 center_line = cross(pc, face_normal);\n        vec3 lateral_line = cross(center_line, face_normal);\n                \n        int cnt = nface / 2 + 1;\n        \n        // We may be able to take advantage of extra symmetry\n        // so make a copy of current point to do so\n        vec3 p_torus = p;\n\n        if (nface % 2 == 0) {\n            if (dot(p_torus, lateral_line) > 0.) { \n                p_torus = reflect(p_torus, normalize(lateral_line)); \n            }\n            cnt = nface / 4 + 1;\n        }\n        \n        for (int i=0; i<MAX_POLYGON; ++i) {\n\n            if (i >= cnt) { break; }\n\n            vec3 ctr = normalize(cross(polygon_edge, center_line));\n\n            d_torus = min(d_torus, dcircle2(p_torus, ctr, n0));\n\n            if (!use_midpoint) {\n                d_torus = min(d_torus, dcircle2(p_torus, ctr, n1));\n            }\n\n            n0 = R*n0;\n            n1 = R*n1;\n\n            polygon_edge = R*polygon_edge;\n\n        }\n\n    } else {\n    \n        // Radially symmetric cell\n\n        // Nodal point is between cur vertex and next vertex\n        vec3 v_node = normalize(v_cur + closeness*v_next);\n        \n        vec3 ctr;\n            \n        if (use_midpoint) {\n\n            // Center torus on previous or current vertex?\n            if (mod(idx, 2.0) == step(rface.y, 0.5)) {\n                ctr = v_cur;\n            } else {\n                ctr = v_next;\n            }\n            \n        } else {\n        \n            float p_vertex = (nface == 3 ? 0.5 : 0.95);\n        \n            // Vertex-centered or edge-centered torus?\n            if (rface.y < p_vertex) {\n                ctr = v_cur;\n            } else {\n                ctr = normalize(v_cur + v_next);\n            }\n\n        }\n    \n        // Compute distance\n        d_torus = dcircle2(p, ctr, sink_by*v_node);\n    \n    }\n    \n    // We postponed some sqrt calls when computing torus distances\n    d_torus = sqrt(d_torus) - torus_r0;\n    \n    ////////////////////////////////////////////////////////////\n    // Do final distance & material computation\n    \n    float crack_size = mix(-2e-3, 0.18*torus_r0, crack_visibility);\n\n    float d_sphere = length(p) - 1.0;\n\n    float d_uncracked = min(d_torus, d_sphere);    \n    \n    float d_crack = poly_edge_dist - crack_size;\n    \n    float d_crack_subtracted = max(d_uncracked, -d_crack);\n    \n    float d_eroded = d_uncracked + max(1.5*crack_size, 0.);\n    \n    float material = step(d_torus, d_sphere) + 1.0;\n    if (d_crack < 1e-3) { material = 0.0; }\n    \n    float d_final = min(d_crack_subtracted, d_eroded);\n    \n    return vec2(d_final, material);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's distance marcher\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n\n    const float precis = 0.002;   \n    \n    float h = 2.0*precis;\n\n    float t = tmin;\n    float m = -1.0;\n    \n    const int rayiter = 50;\n    \n    vec3 color;\n\n    for( int i=0; i<rayiter; i++ ) {\n\n        if( abs(h)<precis||t>tmax ) { break; }\n        \n        t += h;\n        \n        vec2 res = map( ro+rd*t );\n\n        h = res.x;\n        m = res.y;\n        \n    }    \n\n    if (t > tmax) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// IQ's normal calculation. \n\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 q;\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// From IQ: https://www.shadertoy.com/view/ldX3R8\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 3;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 2.0;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - map(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// Rendering function\n\nvec3 shade( in vec3 ro, in vec3 rd, mat3 rot, float tmin, float tmax){\n\n    vec2 tm = castRay(ro, rd, tmin, tmax);        \n    \n    mat3 rtex = rot * rotate(vec3(1, 0, 0), 0.25);\n\n    if (tm.y < 0.0) {\n\n        return texture(iChannel1, rd*rtex).xyz;\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        vec3 color = vec3(1);\n        \n        vec3 rray = reflect(-ro, n);\n\n        vec3 scolor = (tm.y == 2. ? vec3(1, 0.8, 0.65) : vec3(1));\n        \n        float sstrength = 0.5;\n        float sexp = 20.0;\n        \n        if (tm.y == 2.) {\n            color = scolor;\n            scolor *= texture(iChannel2, rray*rtex).xyz * mix(scolor, vec3(1), 0.75);\n            sstrength = 0.95;\n        } else {\n            color = vec3(0.1);\n            scolor = texture(iChannel1, rray*rtex).xyz;\n            if (tm.y == 0.) {\n                color *= 0.5;\n                sstrength = 0.05;\n            }\n\n        }\n        \n        //color = scolor = vec3(1);\n        \n        pos -= n * map(pos).x;\n        \n        vec3 L = normalize(vec3(-0.25, 1.0, 1.0));\n        L = rot*L;\n\n        vec3 diffamb = (0.7*clamp(dot(n, L), 0.0, 1.0) + 0.3) * color;\n\n        return mix(diffamb, scolor, sstrength) * ambientOcclusion(pos, n);\n\n    }\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// do the things\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // distance from camera to sphere centers\n    const float cdist = 6.0;\n    \n    // center-relative fragment coordinates\n    vec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n        \n    // focal length in pixels\n    float f = 0.45/iResolution.y;\n    \n    // approx size of orb in pixels\n    float xlim = 1.1/(cdist*f);\n\n    // fetch state from previous render pass\n    vec4 cur_state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 next_state = texelFetch(iChannel0, ivec2(1, 0), 0);\n    \n    // handle interpolating between states\n    float which = 0.0;\n    \n    // are we transitioning?\n    if (next_state.x != 0.0) {\n\n        // at which = 0, cur_state, which = 1, next_state\n        which = unlerp(cur_state.w, next_state.w, iTime);\n\n        // stagger state transition by screen x coord\n        float delta = clamp(-uv.x/xlim, -1.0, 1.0);\n\n        // bigger k means smaller transition band\n        float k = 0.2; \n        \n        // minimum transition band size\n        const float gutter = 0.01;\n        \n        // which is always between 0 and 1\n        which = unlerp(k, 1.0-k, which + k*delta);\n        \n        // remove sphere decorations when which near 0.5\n        decorate = unlerp(gutter, 1.0, 2.0*abs(fract(which)-0.5));\n        \n        if (cur_state.xy == next_state.xy) {\n            decorate = 0.5*decorate + 0.5;\n        }\n        \n\n    }\n\n    // get vertex degree, triangle point, random seed for this fragment\n    setup = ivec3(which <= 0.5 ? cur_state.xyz : next_state.xyz);\n        \n    // error checking\n    if (setup.x < 3 || setup.x > 5 || setup.y < 0 || setup.y > 6) {\n        fragColor = vec4(1, 0, 0, 0);\n        return;\n    }\n\n    // set up rotation vector    \n    float t = iTime;\n    vec2 theta;\n        \n    theta.y = 2.*PI*t/6.0;\n    theta.x = 0.35*PI*sin(2.*PI*t/15.0);\n       \n    if (max(iMouse.x, iMouse.y) > 0.1*iResolution.y) { \n        theta.x = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        theta.y = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n    }\n    \n    // ray origin and direction\n    vec3 rd = normalize(vec3(f*uv, -1));\n    vec3 ro = vec3(0, 0, cdist);\n    \n    // handle orb rotation\n    mat3 R = rotate(vec3(0, 1, 0), theta.y)*rotate(vec3(1, 0, 0), theta.x);\n \n    // trace scene\n    vec3 color = shade(R*ro, R*rd, R, cdist-1.2, cdist+1.2);        \n\n    // \"gamma correct\" :P\n    color = pow(color, vec3(0.7));\n\n    fragColor = vec4(color, 1);\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////\n// this buffer just manages state and keypresses\n//\n// state is stored in a feedback render texture with just \n// four texels\n//\n//   0,0: cur_setup.xyz,    transition start time\n//   1,0: next_setup.xyz,   transition end time\n//   2,0: queued_setup.xyz  pending\n//   3,0: prev_time, cur_time, !animating, idx\n//\n\n//////////////////////////////////////////////////////////////////////\n// vertex degree and point location for spherical polyhedra\n\n#define UNIQUE_SETUPS 16\n\nconst ivec2 playlist[UNIQUE_SETUPS] = ivec2[UNIQUE_SETUPS](\n\n    ivec2(5, 4), // S **** 5.6.6     truncated icosahedron\n    ivec2(3, 2), // L **   3.3.3.3   octahedron\n    ivec2(4, 6), // M **** 4.6.8     truncated cuboctahedron\n    ivec2(5, 5), // S ***  3.4.5.4   rhombicosidodecahedron\n    ivec2(3, 0), // L **   3.3.3     tetrahedron    \n    ivec2(5, 6), // M **** 4.6.10    truncated icosidodecahedron\n    ivec2(3, 6), // L ***  4.6.6     truncated octahedron \n    ivec2(5, 2), // S ***  3.5.3.5   icosidodecahedron\n    ivec2(4, 1), // L **   4.4.4     cube\n    ivec2(5, 0), // M ***  3.3.3.3.3 icosahedron\n    ivec2(4, 3), // S *    3.8.8     truncated cube\n    ivec2(4, 5), // M ***  3.4.4.4   rhombicuboctahedron\n    ivec2(5, 3), // S **   3.10.10   truncated dodecahedron\n    ivec2(3, 5), // M ***  3.4.3.4   cuboctahedron \n    ivec2(5, 1), // M ***  5.5.5     dodecahedron\n    ivec2(3, 3)  // M *    3.6.6     truncated tetrahedron\n\n);\n\n// time to transition between settings\nconst float transition_duration = 1.25;\n\n// how long to show each orb for\nconst float demo_example_duration = (60.0 / float(UNIQUE_SETUPS));\n\n// detect key press - https://www.shadertoy.com/view/4dGyDm useful\n// to debug key codes\nbool key_press(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x != 0.;\n}\n\n// handle state \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    ivec2 fc = ivec2(fragCoord);\n       \n    // ignore everything outside our storage area\n    if (fc.x > 3 || fc.y > 0) { return; }\n\n    // get all four texels\n    vec4 cur_setup = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 next_setup = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec4 queued_setup = texelFetch(iChannel0, ivec2(2,0), 0);\n    vec4 time = texelFetch(iChannel0, ivec2(3,0), 0);\n    \n    // pause detection, see https://www.shadertoy.com/view/XdtyWB\n    bool is_paused = (iFrame != 0 && time.x == iTime);\n    \n    // initialize\n    if (iFrame == 0 || cur_setup.x == 0.) {\n        cur_setup = vec4(vec2(playlist[0]), 2.0, iTime);\n        next_setup = vec4(0);\n        queued_setup = vec4(0);\n        time = vec4(0, 0, demo_example_duration, 0);\n    }\n\n    // handle modification of setup by keyboard or demo\n    vec3 modified_setup = (queued_setup.x != 0. ? queued_setup.xyz :\n                           next_setup.x != 0. ? next_setup.xyz : cur_setup.xyz);\n                           \n\n    // we will reset the demo if kbd hit\n    float reset_demo = 1.0;\n    \n    bool changed = false;\n    bool reset_w = false;\n    \n    // handle keyboard\n    if (key_press(81)) {\n        modified_setup.x = 3.0 + mod(modified_setup.x + 2.0, 3.0);\n        changed = reset_w = true;\n    } else if (key_press(87)) {\n        modified_setup.x = 3.0 + mod(modified_setup.x + 1.0, 3.0);\n        changed = reset_w = true;\n    } else if (key_press(69)) {\n        modified_setup.y = mod(modified_setup.y + 6.0, 7.0);\n        changed = reset_w = true;\n    } else if (key_press(82)) {\n        modified_setup.y = mod(modified_setup.y + 1.0, 7.0);\n        changed = reset_w = true;\n    } else if (key_press(84)) {\n        modified_setup.z = mod(modified_setup.z + 65535., 65536.);\n        changed = true;\n    } else if (key_press(89)) {\n        modified_setup.z = mod(modified_setup.z + 1., 65536.);\n        changed = true;\n    } else if (key_press(65)) {\n        time.w = mod(time.w + float(UNIQUE_SETUPS) - 1.0, float(UNIQUE_SETUPS));\n        modified_setup.xy = vec2(playlist[int(time.w)]);\n        changed = true;\n    } else if (key_press(83)) {\n        time.w = mod(time.w + 1.0, float(UNIQUE_SETUPS));\n        modified_setup.xy = vec2(playlist[int(time.w)]);\n        changed = true;    \n    } else if (key_press(68)) { \n        // turn on demo mode\n        time.z = iTime + demo_example_duration;\n    } else if (time.z >= 0.) {\n        float demo_transition_time = time.z - transition_duration;\n        if (iTime > demo_transition_time) {\n            // time to change the demo example\n            time.w = mod(time.w + 1.0, float(UNIQUE_SETUPS));\n            cur_setup.w = demo_transition_time;\n            next_setup = cur_setup;\n            next_setup.xy = vec2(playlist[int(time.w)]);\n            if (time.w == 0.) {\n                next_setup.z = mod(next_setup.z + 1., 65536.);\n            }\n            next_setup.w = time.z;\n            queued_setup = vec4(0);\n            time.z += demo_example_duration;\n        }\n    }\n    \n    // match to playlist entry or seek to start\n    if (reset_w) {\n        time.w = 0.0;\n        ivec2 s = ivec2(modified_setup.xy);\n        for (int i=0; i<UNIQUE_SETUPS; ++i) {\n            if (playlist[i] == s) {\n                time.w = float(i);\n                break;\n            }\n        }\n    }\n    \n    if (changed) {\n\n        if (next_setup.x != 0.) {\n            queued_setup.xyz = modified_setup;\n        } else {\n            cur_setup.w = iTime;\n            next_setup = vec4(modified_setup, iTime + transition_duration);\n        }\n\n        time.z = -1.0;\n\n    }\n    \n    // if next setup pendinfg\n    if (next_setup.x != 0.) {\n    \n        // if paused change over immediately\n        if (is_paused) {\n            if (queued_setup.x != 0.) {\n                cur_setup = queued_setup;\n                next_setup = vec4(0);\n                queued_setup = vec4(0);\n            } else {\n                cur_setup = next_setup;\n                next_setup = vec4(0);\n            }\n        } else if (next_setup.w < iTime) {\n            // not paused, change over when necessary\n            cur_setup = next_setup;\n            if (queued_setup.x != 0.) { \n                // we have a buffered transition\n                cur_setup.w = iTime;\n                next_setup = vec4(queued_setup.xyz, iTime + transition_duration);\n                queued_setup = vec4(0);\n            } else {\n                next_setup = vec4(0);\n            }\n        }\n        \n    }\n\n    // store state\n    if (fc == ivec2(0, 0)) {\n        fragColor = cur_setup;\n    } else if (fc == ivec2(1, 0)) { \n        fragColor = next_setup;\n    } else if (fc == ivec2(2, 0)) {\n        fragColor = queued_setup;\n    } else { \n        time.x = time.y;\n        time.y = iTime;\n        fragColor = time;\n    }\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}