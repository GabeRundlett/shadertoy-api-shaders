{
    "Shader": {
        "info": {
            "date": "1630480754",
            "description": "This animation shows the connection between Poncelet's triangle and degree 3 Blaschke product.\n\nSee the book  \"Finding Ellipses: What Blaschke Products, Poncelet's Theorem,  and the Numerical Range Know about Each Other\".",
            "flags": 0,
            "hasliked": 0,
            "id": "fst3Rl",
            "likes": 15,
            "name": "Poncelet-Blaschke triangle",
            "published": 3,
            "tags": [
                "2d",
                "complex",
                "geometry",
                "blaschke",
                "poncelet"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 451
        },
        "renderpass": [
            {
                "code": "/*\n    Poncelet's triangle and degree 3 Blaschke product.\n\nA Blaschke product B(z) of degree n is an mapping of the unit disc D to itself and has the form\n\nB(z) = \\prod_{i=1}^n (z - a_i) / (1 - conjugate(a_i)*z) where a_i, i=1,2,...,n are all in D.\n\nB(z) preserves ∂D. Further more, for each point P on ∂D, there are n preimages\nz1, ..., zn on ∂D such that B(z1) = ... = B(zn) = P.\n\nNow fix n=3, and let a, b be complex numbers in D. For simplicity we choose a, b\nboth are reals and a is always the origin. Let\n\nB(z) = z * (z-a)/(1-a*z) * (z-b)/(1-b*z)\n\nSo B(z) is a Blaschke product of degree 3 and it has zeros at 0, a, b.\n\nThen for each point P on ∂D, the preimages z1, z2, z3 form an inscribed triagle\nABC of D, interestingly, ABC is also the circumscribe triangle of an ellipse\nwith foci at a and b:\n\n|z - a| + |z - b| = |1 - conjugate(a)*b|.\n\nIn the animtion P is colored yellow, z1, z2, z3 are colored pink.\n\nTo show that I'm not cheating, I choosed a, b and draw the ellipse using the\nexpression as above, then solve the cubic equation B(z) = P for P moving along\nthe circle and draw the triangle ABC. You can see the triangle does circumscribe\nthe ellipse!\n\nThis result generalizes to Blaschke product of degree n, the curve that the n-gon\ncircumscribes is a Poncelet curve.\n\n*/\n#define PI 3.141592653\n\nvec3 rotHue(vec3 p, float a) {\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n              mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n              mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\n\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 p) {\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\nvec2 ccubrt(vec2 z) {\n    float r = length(z);\n    r = pow(r, 1./3.);\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 3.0), sin(angle / 3.0));\n}\n\nvec2 cpow2(vec2 z) {\n    return cmul(z, z);\n}\n\nvec2 cpow3(vec2 z) {\n    return cmul(z, cmul(z, z));\n}\n\nvoid solveCubic(float b, vec2 k, inout vec2 z1, inout vec2 z2, inout vec2 z3) {\n    vec2 t1 = vec2(2.*b*b*b, 0) - 9.*b*b*k;\n    vec2 t2 = cpow2(t1 + 27.*k);\n    vec2 t3 = 3.*b*k - vec2(b*b, 0);\n    vec2 t4 = 4.*cpow3(t3);\n    vec2 s1 = ccubrt(csqrt(t4 + t2) + 27.*k + t1);\n    vec2 s2 = cdiv(t3, s1);\n    z1 = 0.264566842 * s1 - 0.41997368 * s2 + vec2(b/3.,0.);\n    z2 = cmul(vec2(-0.132283421, 0.2291216), s1) + cmul(vec2(0.209998684, 0.36371), s2) + vec2(b/3., 0);\n    z3 = cmul(vec2(-0.132283421, -0.2291216), s1) + cmul(vec2(0.209998684, -0.36371), s2) + vec2(b/3., 0);\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\nvec3 cubehelix(vec3 c) {\n    vec2 sc = vec2(sin(c.x), cos(c.x));\n    return c.z * (1.0 + c.y * (1.0 - c.z) * (\n        sc.x * vec3(0.14861, 0.29227, -1.97294) +\n        sc.y * vec3(1.78277, -0.90649, 0.0)\n        ));\n}\n\nvec3 rainbow(float t) {\n    return cubehelix(vec3(\n        2. * PI * t - 1.74533,\n        (0.25 * cos(2. * PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n        ));\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, in vec2 ab ) {\n    p -= cen;\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 1.1;\n\n    mat2 foci;\n    float b = sin(iTime) * 0.3 + 0.6;\n    // for a fixed ellipse, you can see each point on the unit cicle is a Poncelet point.\n    //float b = 0.6;\n    foci[0] = vec2(0);\n    foci[1] = vec2(b, 0);\n\n    vec2 k = vec2(cos(iTime), sin(iTime));\n    vec2 A, B, C;\n    solveCubic(b, k, A, B, C);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n    float dcirc = length(p) - 1.;\n\n    vec2 cen = vec2(b*0.5, 0);\n    vec2 ab = vec2(0.5, sqrt(1.-b*b)/2.);\n    float dellipse = sdEllipse(p, cen, ab);\n    float dfoci = min(length(p), length(p - foci[1])) - 0.04;\n\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2);\n    col = rotHue(col, sgn + 5.);\n    const float numlines = 30.;\n    for (float i=0.; i<numlines; i+=1.0) {\n        vec2 Q = vec2(cos(i/numlines*2.*PI), sin(i/numlines*2.*PI));\n        vec2 z1, z2, z3;\n        solveCubic(b, Q, z1, z2, z3);\n        float ds = dseg(p, z1, z2);\n        ds = min(ds, dseg(p, z2, z3));\n        ds = min(ds, dseg(p, z3, z1));\n        col = mix(col, rainbow(i/numlines), 1.-smoothstep(0., 0.003+2.*sf, ds));\n    }\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dcirc)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    mat4x2 verts; verts[0] = A; verts[1] = B; verts[2] = C, verts[3] = k;\n    float lw = 0.02;\n    for (int i=0; i<4; i++) {\n        float dv = length(p - verts[i]) - .08;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        if (i < 3)\n            col = mix(col, vec3(1, .5, .8), 1. - smoothstep(0., sf, dv + lw*1.6));\n        else\n            col = mix(col, vec3(1, 1., .2), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .08 - lw));\n    }\n    for (int i=0; i<2; i++) {\n        float dv = length(p - foci[i]) - .06;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .065 - lw));\n    }\n\n    col *= 1.25 - 0.4*length(p);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}