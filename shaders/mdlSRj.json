{
    "Shader": {
        "info": {
            "date": "1669227194",
            "description": "Supersaw unison effect, similar to Serum",
            "flags": 8,
            "hasliked": 0,
            "id": "mdlSRj",
            "likes": 6,
            "name": "Supersaw Unison Experiment",
            "published": 3,
            "tags": [
                "sound",
                "music",
                "audio",
                "synthesis",
                "synth",
                "saw",
                "song",
                "sawtooth",
                "gpusound",
                "supersaw",
                "chords",
                "unison"
            ],
            "usePreview": 0,
            "username": "MysteryPancake",
            "viewed": 277
        },
        "renderpass": [
            {
                "code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n\tfragColor = vec4(fragCoord / iResolution.xy, 0.5 + mod(iTime, 0.5), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415926;\n\n// 1D hash, from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) {\n\tp = fract(p * 0.1031);\n\tp *= p + 33.33;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2((note - 69.0) / 12.0);\n}\n\n// For sawtooth synth\nfloat saw(float freq, float time, float phase) {\n\treturn fract(phase + freq * time) * 2.0 - 1.0;\n}\n\n// For kick drum (808?)\nfloat drum(float freq, float time) {\n\treturn sin(freq * time * PI) * exp(-4.0 * time);\n}\n\n// For snares and hi-hats\nvec2 noise(float time, float fade) {\n\treturn (vec2(hash(time * 512.0), hash(time * 1024.0)) - 0.5) * exp(-fade * time);\n}\n\nvec2 mainSound(int samp, float time) {\n    \n    // MIDI notes to play\n\tfloat a = 49.0;\n\tfloat b = 53.0;\n\tfloat c = 56.0;\n\tfloat d = 60.0;\n\tfloat e = 68.0;\n    float f = 75.0;\n    \n    // Hi-hat rhythm divisions per beat\n\tfloat rhythm = 4.0;\n    \n    // Base note for the drum (808?)\n\tfloat drumNote = 34.0;\n\t\n    // Swap notes every 2 beats\n\tif (fract(time / 4.0) > 0.5) {\n\t\ta += 2.0;\n\t\tb += 3.0;\n\t\tc += 2.0;\n\t\td += 3.0;\n\t\te += 7.0;\n        f += 4.0;\n\t\tdrumNote += 2.0;\n\t\trhythm -= 1.0;\n\t}\n\t\n\tfloat[] notes = float[] (noteFreq(a), noteFreq(b), noteFreq(c), noteFreq(d), noteFreq(e), noteFreq(f));\n\t\n    // Unison spread, notes to place around each note\n\tconst float spread = 4.0;\n    \n    // Detune factor in Hertz\n    const float detune = 0.3;\n    \n\tvec2 result = vec2(0.0);\n\t\n    // Apply unison effect to each note\n\tfor (int i = 0; i < notes.length(); i++) {\n    \n\t\t// Place notes around center frequency\n\t\tfor (float j = -spread; j <= spread; j++) {\n\t\t\tfloat frequency = notes[i] + j * detune;\n\t\t\tresult.x += saw(frequency, time, hash(2.0 * j));\n\t\t\tresult.y += saw(frequency, time, hash(2.0 * j + 1.0));\n\t\t}\n\t}\n    \n    // Prevent volume clipping\n\tresult /= float(notes.length()) * spread;\n    \n    // Sidechain to sine wave\n    result *= abs(sin(time * PI * 2.0));\n    \n    // Distort drum by making it 2x louder, then clamp to hard clip it\n\tresult += clamp(drum(noteFreq(drumNote), fract(time * 2.0)) * 2.0, -0.9, 0.9);\n    \n    // Add snare every 2 drums\n\tresult += noise(fract(time + 0.5), 5.0) * 0.6;\n    \n    // Add hi-hats depending on rhythm division\n\tresult += noise(fract(time * rhythm), 7.0) * 0.5;\n    \n\treturn result;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}