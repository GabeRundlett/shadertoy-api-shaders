{
    "Shader": {
        "info": {
            "date": "1716487777",
            "description": "Press `X` to enable free movement (then WASD / arrowkeys to move, mouse to look around, space to fly, shift to fly down)",
            "flags": 48,
            "hasliked": 0,
            "id": "4XcGzN",
            "likes": 10,
            "name": "Another voxel world",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "voxels",
                "rays",
                "tracing",
                "fps"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "// At the top of the \"Common\" tab are some\n// settings you can play around with.\n// Such as render distance, world bounds etc.\n\n// Press `X` to enable free movement (Must click on the screen first)\n// Once in free movement, you can control the camera using WASD or arrow-keys.\n// Fly up with space, and down with shift.\n// Look around with the mouse :)\n\n\n#define R iResolution\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc.xy/R.xy;\n    \n    col = texture(iChannel0, uv).xyz;\n    \n    o = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\n\n\n\n#define R iResolution\n#define T (iTime)\n#define ZERO min(iFrame, 0)\n\n\n//#define L normalize(vec3(3, 1.5, -3))\n#define LC vec3(0.97, 0.89, 0.79)\n#define IOR 1.333\n\nvec3 forEachLight(in Light light, in vec3 ro, in vec3 rd, inout Data data, in vec3 F0, in vec3 diffuse) {\n  vec3 N = data.n;\n  vec3 spec = vec3(data.vox.m.spec);\n  vec3 pos = data.p;\n  vec3 viewdir = rd;\n\n  float rough = data.vox.m.rough;\n  float metallic = data.vox.m.metallic;\n\n  vec3 L = getLightDir(light, pos);\n  vec3 att = getLightAtt(light, pos, N);\n  vec3 H = normalize(L + viewdir);\n  vec3 reflectDir = reflect(-L, N);\n\n\n  float NdotL = max(dot(N, L), 0.0);\n  float NdotH = clamp(dot(N, H), 0.0, 1.0);\n  float HdotV = clamp(dot(H, viewdir),0.0, 1.0);\n  float VdotR = max(dot(viewdir, reflectDir), 0.0);\n  float VdotL = max(dot(viewdir, L), 0.0);\n  float NdotV = dot(N, rd);\n\n\n  float NDF = DistributionGGX(N, H, rough);\n  float G = GeometrySmith(N, viewdir, L, rough);\n  vec3 F = fresnelSchlickRoughness(NdotV, F0, rough);\n\n  vec3 nominator = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, viewdir), 0.0) * max(dot(N, L), 0.0);\n  vec3 specular = nominator / (denominator + DIV_EPS);\n  \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - metallic;\t  \n  \n  vec3 col = (kD * diffuse / M_PI + specular) * (att);\n  \n  Data shadowData = NEW_DATA;\n  if (data.skip != BLOCK_TYPE_WATER && NdotL > 0.0 &&\n      grid_traverse(iChannel3, data.p, normalize(0.5*data.n+L), 1.0, ivec3(MAP_BOUNDS), shadowData, MAX_LOOP)) {\n    float sd = clamp(distance(data.p, shadowData.p), AMBIENT, 1.0);\n    col *= max(0.45 * sd, AMBIENT*3.);\n  }\n  \n\n  \n\n  return max(col, vec3(0.0));\n}\n\nvec3 grassTexture(vec2 uv, vec3 n, inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    if (n.y > 0.0) {\n        vec3 k = texture(iChannel0, uv*rot(float(data.voxel_index.x*10+data.voxel_index.z))).xyz;\n        col = vec3(0.5, 0.8, 0.05);\n        col = col * abs(k.x*2.0-1.0);\n        col += col*4.*max(0.0, 1.0 - 3.*length(col));\n        col /= (1.0 + col);\n\n    } else {\n        vec3 k = texture(iChannel0, 0.15*uv*rot(float(data.voxel_index.x*10+data.voxel_index.z))).xyz;\n        col = vec3(0.25, 0.15, 0.05) * k;\n    }\n    \n    return col;\n}\n\nvec3 stoneTexture(vec2 uv, vec3 n, inout Data data) {\n    vec3 col = vec3(0.0);\n    \n    vec3 k1 = texture(iChannel0, uv).xyz;\n    vec3 k2 = texture(iChannel1, 0.5*uv*rot(float(data.voxel_index.x*10+data.voxel_index.z))).xyz;\n\n    vec3 k = ((k1+k2) / M_PI);\n    col += k;\n    col *= vec3(0.52, 0.48, 0.56);\n    col /= (1.0 + col);\n    \n    return col;\n}\n\nvec2 ripples(vec2 c) {\n    float j = noise(c.xy*0.25, 3.3123123)*2.0-1.0;\n    float j2 = noise(c.yx*0.5, 77.438835)*2.0-1.0;\n    \n    vec2 coord = vec2(j2*cos(iTime+j2)+c.x+sin(iTime+j), j2*sin(iTime+j2)+c.y+cos(iTime+j))*0.25;\n    \n    coord = mix(-0.5 + coord + 0.5 * vec2(j, j2), coord, 0.25);\n    \n    return coord;\n\n}\n\nvec3 rayCast(vec3 ro, vec3 rd, inout Data data, int max_loop, in Light light) {\n    data.hit = false;\n    vec3 col = vec3(0.0);\n    \n    \n\n    if (grid_traverse(iChannel3, ro, rd, 1.0, ivec3(MAP_BOUNDS), data, max_loop)) {\n        data.hit = true;\n        vec3 n = data.n;\n        vec3 p = data.p;\n        vec3 p2 = data.p - vec3(data.voxel_index);\n        vec2 c = mix(mix(p.xz, p.yz, abs(dot(n, vec3(1, 0, 0)))), p.xy, abs(dot(n, vec3(0, 0, 1))));\n        vec2 c2 = mix(mix(p2.xz, p2.yz, abs(dot(n, vec3(1, 0, 0)))), p2.xy, abs(dot(n, vec3(0, 0, 1))));\n        vec3 diffuse = vec3(0.0);\n        \n        switch (data.vox.type) {\n            case BLOCK_TYPE_STONE: diffuse = stoneTexture(c2, n, data); break;\n            case BLOCK_TYPE_WATER: {\n              diffuse = (texture(iChannel0, ripples(c)).xyz);\n            // col += diffuse;\n              data.n = normalize(data.n + 0.09*(-0.25+(diffuse*2.0-1.0)));\n            } break;\n            case BLOCK_TYPE_GRASS: {\n              diffuse = grassTexture(c2, n, data);\n            }; break;\n        }\n        vec3 F0 = mix(vec3(0.04), diffuse, data.vox.m.metallic);\n        col += forEachLight(light, ro, rd, data, F0, diffuse);\n    } else {\n        vec3 blue = vec3(0.02, 0.34, 0.79);\n        float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n        \n        col += pow(blue, vec3(1.0 + 2.0*dotup));\n    }\n    \n    \n    vec3 L = getLightDir(light, ro);\n    float depth = distance(ro+rd, data.p)/float(MAX_LOOP);\n    float VdotL = max(0.0, dot(rd, L));\n    col += LC*pow(VdotL, 6.)*smoothstep(0.0, 0.25, depth);\n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc.xy - 0.5 * R.xy) / R.y;\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv, 0.5));\n    \n    \n    \n    vec3 move = texelFetch(iChannel2, ivec2(0), 0).xyz;\n    vec3 mouse = texelFetch(iChannel2, ivec2(1, 0), 0).xyz;\n    \n    rd.yz *= rot(mouse.y);\n    rd.xz *= rot(mouse.x);\n    ro = move;\n    \n    \n    Light light = Light(\n        LIGHT_AMBIENT,\n        4.0,\n        normalize(vec3(3, 1.5, -3)),\n        vec3(0.0),\n        vec3(0.97, 0.89, 0.79)\n    );\n\n    \n    Data data = NEW_DATA;\n    col += rayCast(ro, rd, data, MAX_LOOP, light);\n    \n    if (data.vox.type == BLOCK_TYPE_WATER) {\n        {\n            Data refractData = NEW_DATA;\n            refractData.skip = data.vox.type;\n            vec3 enterRo = data.p;\n            vec3 enterRd = refract(rd, data.n, 1.0/IOR);\n\n            //col /= M_PI;\n            col += rayCast(enterRo, enterRd, refractData, MAX_LOOP/2, light);\n            \n            float dd = distance(refractData.p-ro, data.p-ro)/float(MAX_LOOP);//refractData.hit ? (refractData.d/float(MAX_LOOP)) : 1.0;\n            col /= (1.0 + TAU*smoothstep(0.0, 0.09, dd)*vec3(0.6, 0.25, 0.12));\n            col = mix(col, col*smoothstep(0.15, 0.0, dd), clamp(col.r*10., 0.0, 1.0));\n            \n        }\n        \n        {\n           \n            Data reflectData = NEW_DATA;\n            reflectData.skip = BLOCK_TYPE_WATER;\n            vec3 enterRo = data.p;\n            vec3 enterRd = reflect(rd, data.n);\n            float NdotV = dot(data.n, enterRd);\n            vec3 F0 = mix(vec3(0.04), vec3(col), data.vox.m.metallic);\n            vec3 F = fresnelSchlickRoughness(NdotV, F0, data.vox.m.rough);\n            vec3 world = vec3(0.0);\n            if (length(F) > 0.025) {\n                world = rayCast(enterRo, enterRd, reflectData, MAX_LOOP, light);\n            }\n            vec3 invF = max(vec3(0.0), 1.0 - F);\n            col /= max(vec3(1.0), 1.0 + (invF*invF*invF*invF));\n\n            float irough = max(0.0, 1.0 - data.vox.m.rough);\n            col += M_PI*(F+F*(irough*irough))*compute_indirect(data,  enterRd, F0, world);\n            \n        }\n        \n        col *= 2.;\n    }\n    \n    \n    \n    col += col*luma(col);\n    col += col*luma(col);\n    col += col*col;\n    col = aces(col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    o = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define R iResolution\n#define ZERO min(iFrame, 0)\n\n\nvec3 thash(vec2 p, float seed) {\n    return textureLod(iChannel0, ((p  + seed) / 256.0), 0.0).xyz;\n}\n\nvec3 tnoise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(thash(id+vec2(0,0),s),thash(id+vec2(1,0),s),lv.x),\n             mix(thash(id+vec2(0,1),s),thash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nvec3 tnoise(vec2 p, float s, float freq, float warp, const in int oct) {\n  vec3 n = vec3(0.0);\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = min(iFrame, 0); i < oct; i++) {\n    n += amp*tnoise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n.x*6.28), cos(n.y*6.28));\n\n  }\n  return n / div;\n}\n\nvoid mainImage(out vec4 o, in vec2 fc)\n{\n    ivec2 co = ivec2(fc);\n    vec3 last = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    ivec2 last_res = ivec2(last.xy);\n    ivec2 res = ivec2(iResolution.xy);\n    vec3 col = texelFetch(iChannel1, co, 0).xyz;\n    vec2 uv = round((fc.xy/iResolution.xy)*MAP_BOUNDS)/MAP_BOUNDS;\n    \n    \n    if (co.x <= 0 && co.y <= 0) {\n        col = vec3(res.xy, 1.0);\n    } else {\n        if (iFrame <= 1 || res != last_res) {\n            col = vec3(0.0);\n            col += noise(uv, MAP_SEED, 4., 0.001, 4);\n        }\n    }\n    \n    o = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////// settings\n\n// Change to get a different world\n#define MAP_SEED 85623423418.9413503\n\n\n// Maximum terrain height\n#define MAP_HEIGHT 96.0\n\n// Anything below this number becomes water\n#define WATER_LEVEL 38\n\n// The map is basically a 3D box, \n// these are the boundaries\n#define MAP_BOUNDS 300.\n#define CENTER (vec3(MAP_BOUNDS*0.5))\n\n// render distance\n#define MAX_LOOP 200\n\n///////////////////////////\n\n#ifndef HW_PERFORMANCE\n#define iFrame 0\n#define iResolution vec2(640)\n#endif\n\n#define M_PI 3.1415\n#define TAU (M_PI*2.0)\n\n\nstruct AABB {\n  vec3 min;\n  vec3 max;\n};\n\nmat2 rot(float a) {\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\nvec3 ssign(vec3 p, float k) { return vec3(ssign(p.x, k), ssign(p.y, k), ssign(p.z, k)); }\n\nvec3 cubenormal(vec3 v) {\n  vec3 s = sign(v);\n  vec3 a = abs(v);\n\n  return mix(mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n               mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n               step(a.z, a.y));\n}\n\nbool AABBIntersection(vec3 ro, vec3 rd, AABB aabb, out vec3 point,\n                      out vec3 normal, out float tNear, out float tFar) {\n  vec3 boxMin = min(aabb.min, aabb.max);\n  vec3 boxMax = max(aabb.min, aabb.max);\n  vec3 tMin = (boxMin - ro) / rd;\n  vec3 tMax = (boxMax - ro) / rd;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  tNear = max(max(t1.x, t1.y), t1.z);\n  tFar = min(min(t2.x, t2.y), t2.z);\n  point = ro + rd * tNear;\n  vec3 center = (aabb.min + aabb.max) / 2.;\n  vec3 halfextent = aabb.max - center;\n  vec3 relpos = point - center;\n  normal = cubenormal(relpos / halfextent);\n  return (!(tNear > tFar));\n}\n\n\nfloat hash(vec2 ip, float seed) {\n  uvec2 p = floatBitsToUint(ip); uint s = floatBitsToUint(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash(id+vec2(0,0),s),hash(id+vec2(1,0),s),lv.x),\n             mix(hash(id+vec2(0,1),s),hash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec2 p, float s, float freq, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = min(iFrame, 0); i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n\n  }\n  return n / div;\n}\n\nvec3 hash3(vec3 ip, float seed) {\n  uvec3 p = floatBitsToUint(ip); uint s = floatBitsToUint(seed); uvec3 k = ~p + ~s;\n  p.x ^= p.z; p.x ^= p.x << 17U;\n  p.x ^= p.x >> 13U; p.x ^= p.x << 5U;\n  p.x *= 5013U;\n  p.y ^= p.x; p.y ^= p.y << 17U;\n  p.y ^= p.y >> 13U; p.y ^= p.y << 5U;\n  p.y *= 1013U;\n  p.z ^= p.y; p.z ^= p.z << 17U;\n  p.z ^= p.z >> 13U; p.z ^= p.z << 5U;\n  p.z *= 3013U;\n  return vec3(p) / float(0xFFFFFFFFU);\n}\n\nvec3 noise3(vec3 p, float s) {\n  p += 3.3828714;\n  vec3 id = floor(p); vec3 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(mix(hash3(id+vec3(0,0,0),s),hash3(id+vec3(1,0,0),s),lv.x),\n                 mix(hash3(id+vec3(0,1,0),s),hash3(id+vec3(1,1,0),s),lv.x),lv.y),\n             mix(mix(hash3(id+vec3(0,0,1),s),hash3(id+vec3(1,0,1),s),lv.x),\n                 mix(hash3(id+vec3(0,1,1),s),hash3(id+vec3(1,1,1),s),lv.x),lv.y),lv.z);\n}\n\n\n#define MAX_VALUE 9999.0\n#define INF MAX_VALUE\n\n\n#define BLOCK_TYPE_AIR 0\n#define BLOCK_TYPE_STONE 1\n#define BLOCK_TYPE_WATER 2\n#define BLOCK_TYPE_GRASS 3\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 0.0, 0.0)\n\nstruct Voxel {\n  int type;\n  int h;\n  vec3 data;\n  Material m;\n};\n\n#define NEW_VOXEL Voxel(0, 0, vec3(0.0), NEW_MATERIAL)\n\n\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  ivec3 voxel_index;\n  int skip;\n  Voxel vox;\n  bool hit;\n  \n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), INF, ivec3(-1), -1, NEW_VOXEL, false)\n\nVoxel get_voxel(sampler2D sampler, ivec3 voxel_index, int skip) {\n  Voxel v = Voxel(BLOCK_TYPE_AIR, 0, vec3(0.0), NEW_MATERIAL);\n  vec3 data = textureLod(sampler, ((vec2(voxel_index.xz)+MAP_BOUNDS)/MAP_BOUNDS), 0.).xyz;\n  v.data = data;\n  \n  int Y = voxel_index.y;\n  \n  int h = 1 + int(round(data.x * data.x * (3.0 - 2.0 * data.x) * MAP_HEIGHT));\n  v.h = h;\n  \n  if (Y <= WATER_LEVEL && skip != BLOCK_TYPE_WATER) {\n      v.type = BLOCK_TYPE_WATER;\n      v.m.rough = 0.6;\n      v.m.metallic = 0.5;\n      v.m.spec = 0.1;\n      return v;\n  }\n  if (Y >= h) {\n      v.type = BLOCK_TYPE_AIR;\n      return v;\n  }\n  \n  if (Y >= 0 && (skip != BLOCK_TYPE_WATER ? true : Y < WATER_LEVEL)) {\n      v.type = BLOCK_TYPE_STONE;\n      \n      if (Y >= h-1 && Y > WATER_LEVEL) {\n          v.type = BLOCK_TYPE_GRASS;\n      }\n  }\n  \n  return v;\n}\n\nbool grid_traverse(sampler2D sampler, vec3 ro, vec3 rd, float cell_size,\n                   ivec3 boundz, inout Data data, int max_loop) {\n                   \n  vec3 ray_end = ro+rd*0.5*float(boundz.z);\n  \n  ivec3 final_voxel =\n      ivec3(int(floor(ray_end[0] / cell_size)), int(floor(ray_end[1] / cell_size)),\n            int(floor(ray_end[2] / cell_size)));\n  ivec3 current_voxel =\n      ivec3(int(floor(ro[0] / cell_size)), int(floor(ro[1] / cell_size)),\n            int(floor(ro[2] / cell_size)));\n\n  vec3 stp = vec3(\n    float((rd[0] >= 0.) ? 1.0 : -1.0),\n    float((rd[1] >= 0.) ? 1.0 : -1.0),\n    float((rd[2] >= 0.) ? 1.0 : -1.0)\n  );\n\n  float next_bound_x =\n      float((float(current_voxel[0]) + stp.x) * cell_size);\n  float next_bound_y =\n      float((float(current_voxel[1]) + stp.y) * cell_size);\n  float next_bound_z =\n      float((float(current_voxel[2]) + stp.z) * cell_size);\n\n  if (stp.x < 0.)\n    next_bound_x += cell_size;\n  if (stp.y < 0.)\n    next_bound_y += cell_size;\n  if (stp.z < 0.)\n    next_bound_z += cell_size;\n\n  float tMaxX =\n      (rd[0] != 0.) ? (next_bound_x - ro[0]) / rd[0] : MAX_VALUE;\n  float tMaxY =\n      (rd[1] != 0.) ? (next_bound_y - ro[1]) / rd[1] : MAX_VALUE;\n  float tMaxZ =\n      (rd[2] != 0.) ? (next_bound_z - ro[2]) / rd[2] : MAX_VALUE;\n\n  float tDeltaX = (rd[0] != 0.) ? cell_size / rd[0] * stp.x : MAX_VALUE;\n  float tDeltaY = (rd[1] != 0.) ? cell_size / rd[1] * stp.y : MAX_VALUE;\n  float tDeltaZ = (rd[2] != 0.) ? cell_size / rd[2] * stp.z : MAX_VALUE;\n\n  for (int i = min(iFrame, 0); i < max_loop; i++) {\n    if (tMaxX < tMaxY) {\n      if (tMaxX < tMaxZ) {\n        current_voxel[0] += int(ceil(stp.x));\n        tMaxX += tDeltaX;\n      } else {\n        current_voxel[2] += int(ceil(stp.z));\n        tMaxZ += tDeltaZ;\n      }\n    } else {\n      if (tMaxY < tMaxZ) {\n        current_voxel[1] += int(ceil(stp.y));\n        tMaxY += tDeltaY;\n      } else {\n        current_voxel[2] += int(ceil(stp.z));\n        tMaxZ += tDeltaZ;\n      }\n    }\n\n    ivec3 voxel_index = abs(current_voxel) % boundz;\n    Voxel vox = get_voxel(sampler, voxel_index, data.skip);\n    AABB bounds = AABB(vec3(0.0), vec3(0.0));\n    bounds.min = vec3(voxel_index.x, voxel_index.y, voxel_index.z);\n    bounds.max = bounds.min + (vec3(cell_size, cell_size, cell_size));\n\n    vec3 nextPoint = vec3(0.0);\n    vec3 nextNormal = vec3(0.0);\n    float nextDist = INF;\n    float tnear = 0.0;\n    float tfar = 9999.;\n    \n    \n\n    if (vox.type != data.skip && vox.type != BLOCK_TYPE_AIR && current_voxel.z < boundz.z && current_voxel.x < boundz.x &&\n        current_voxel.y < boundz.y && current_voxel.z >= 0 &&\n        current_voxel.x >= 0 && current_voxel.y >= 0 &&\n        AABBIntersection(ro, rd, bounds, nextPoint, nextNormal, tnear, tfar)) {\n        \n      \n      data.p = nextPoint;\n      data.n = nextNormal;\n      data.d = distance(ro+rd, nextPoint);\n      \n      data.voxel_index = voxel_index;\n      data.vox = vox;\n      return true;\n    }\n    \n    if (current_voxel == final_voxel || voxel_index == final_voxel) return false;\n  }\n  return false;\n}\n\n///////////////////\n\n\n\n#define AMBIENT 0.05\n\n#define DIV_EPS 0.0003\n\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a = roughness*roughness;\n  float a2 = a*a;\n  float NdotH = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n  float nom   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = M_PI * denom * denom;\n  return nom / (DIV_EPS+denom);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k) {\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / (DIV_EPS+denom);\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx1 = GeometrySchlickGGX(NdotV, k);\n  float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n  return ggx1 * ggx2;\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\nvec3 compute_indirect(in Data data, in vec3 rd, in vec3 F0, in vec3 world) {\n  vec3 refViewDir = reflect(rd, data.n);\n  float ndotv = max(dot(data.n, rd), 0.0);\n  float rough = data.vox.m.rough;\n  vec3 envBRDF = EnvBRDFApprox(vec3(data.vox.m.spec), rough*rough, ndotv);\n  vec3 env = (envBRDF * world) / (1.0 + rough);\n  return env;\n}\n\n#define LIGHT_POINT 0\n#define LIGHT_AMBIENT 1\n#define LIGHT_DIR 2\n\nstruct Light {\n  int type;\n  float strength;\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n};\n\nvec3 getLightDir(in Light light, in vec3 p) {\n  return light.type == LIGHT_AMBIENT ? normalize(light.position) :\n         light.type == LIGHT_POINT ? normalize(light.position - p) :\n         normalize(light.direction);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(n, L));\n\n  switch (light.type) {\n      case LIGHT_AMBIENT: return light.color * light.strength * NdotL; break;\n      case LIGHT_POINT: return light.color * NdotL * (\n          pow(light.strength, 2.0) / (DIV_EPS + pow(distance(light.position, p), 2.0))\n      ); break;\n      case LIGHT_DIR: return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\n          normalize(light.position - p),\n          L\n      )); break;\n  }\n  \n  return vec3(0.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define R iResolution\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key, 0), 0).x > 0.0;\n}\n\nvoid intersect(vec3 vel, vec3 offset, vec3 n, inout vec3 p) {\n    n = normalize(n);\n    vec3 vix = floor(p - offset);// + vec3(0.5);\n    ivec3 idx = ivec3(vix);\n    Voxel vox1 = get_voxel(iChannel2, idx, -1);\n\n    if (vox1.type != BLOCK_TYPE_AIR) {\n        float dp = max(0.0, dot(vel, n));\n        p -= n*dp;\n    }\n    \n}\n\n\nstruct AutoPilot {\n    vec3 pos;\n    vec3 q;\n};\n\n\nvec3 getNextPos(float t) {\n    vec3 startPos = vec3(MAP_BOUNDS/2., MAP_HEIGHT-16., MAP_BOUNDS/2.);\n    vec3 sway = vec3(cos(t), 0 , sin(t));\n    vec3 dir = vec3(sin(t+sway.x), 0, cos(t+sway.z));\n    return vec3(\n        startPos.x,\n        MAP_HEIGHT-mix(1.0, 50.0, 0.5+0.5*sin(-4.13123+t+2.5)),\n        startPos.z) + dir * mix(8.0, 64.0, 0.5+0.5*cos(t+3.2));\n}\n\nAutoPilot getAutoPilot() {\n    AutoPilot pilot = AutoPilot(vec3(0.0), vec3(0.0));\n    \n    float t = iTime*0.5;\n    float transTime = 0.99999999;\n    float frame = 0.0;\n\n    vec3 q = vec3(0, 0, 0);\n\n    vec3 pos = getNextPos(t);\n    vec3 pos2 = getNextPos(t+2.*iTimeDelta+0.001);\n    vec3 dir = normalize(vec3(pos2.x, 0.00003, pos2.z) - vec3(pos.x, 0, pos.z));\n\n\n    pilot.pos = pos;\n    \n    Voxel vox = get_voxel(iChannel2, ivec3(pilot.pos) - ivec3(0, 4, 0), -1);\n    \n    if (vox.type != BLOCK_TYPE_AIR) {\n        pilot.pos.y = max(pilot.pos.y, float(vox.h)+4.0);\n    }\n    \n   \n   // dir = normalize(dir);\n    float a  = (atan(dir.x, dir.z));// - radians(-90.);\n    q.y = a;\n    q.x = -0.25 + 0.25 * cos(iTime+3.9);\n//    pilot.pos = pos;\n    pilot.q = q.yxz;\n    return pilot;\n}\n\nvec4 keyboard(in vec2 fc, bool reset) {\n    vec4 p4 = texelFetch(iChannel1, ivec2(0), 0);\n    vec3 p = p4.xyz;\n    vec3 m = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n\n    float W = float(keypress(87) || keypress(38));\n    float A = float(keypress(65) || keypress(37));\n    float S = float(keypress(83) || keypress(40));\n    float D = float(keypress(68) || keypress(39));\n    float SPACE = float(keypress(32));\n    float SHIFT = float(keypress(16));\n    float X = float(texelFetch(iChannel0, ivec2(88, 0), 0).x > 0.0);\n    \n    float dt = iTimeDelta;\n    float k = 6.0;\n    \n    vec3 dir = vec3(0.0);\n    \n    if (iFrame <= 1 || reset) {\n        float ry = iResolution.x / iResolution.y;\n        vec3 map_center = floor(CENTER);\n        p = vec3(map_center.x+0.5, MAP_HEIGHT, map_center.z+0.5);\n    }\n    \n    else if (p4.w > 0.001 && iFrame > 1) {\n        dir += vec3(0, 0, 1)  * k * dt * W;\n        dir += vec3(-1, 0, 0) * k * dt * A;\n        dir += vec3(0, 0, -1) * k * dt * S;\n        dir += vec3(1, 0,  0) * k * dt * D;\n        dir += vec3(0, 1, 0)  * k * dt * (SPACE - SHIFT);\n        dir += vec3(0, -1, 0) * k * dt * 0.9 * float(SPACE <= 0.0);   \n        dir.xz *= rot(m.x);\n        p += dir;\n    } else {\n        AutoPilot pilot = getAutoPilot();\n        p = pilot.pos;\n    }\n    \n    \n\n    \n    \n    float oo = 0.5;\n    float ks = 1.;\n    \n    intersect(dir, vec3(0, 1, 0), vec3(0, -1, 0), p);\n    intersect(dir, ks*vec3(-0.5, 1, 0), vec3(1, 0, 0), p);\n    intersect(dir, ks*vec3(0.5, 1, 0), vec3(-1, 0, 0), p);\n    intersect(dir, ks*vec3(0.0, 1, -0.5), vec3(0, 0, 1), p);\n    intersect(dir, ks*vec3(0, 1, 0.5), vec3(0, 0, -1), p);\n  \n    return vec4(p, max(p4.w, X));\n}\n\n\nvec3 mouse(in vec2 fc, bool reset) {\n    vec4 p4 = texelFetch(iChannel1, ivec2(0), 0);\n    vec4 m = vec4((iMouse.xy - 0.5 * R.xy) / R.y, iMouse.zw);\n    vec3 p = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n\n    float k = float(iMouse.z > 0.001) * 4.0;\n    float dt = iTimeDelta;\n    \n    if (iFrame <= 1 || reset) {\n        k = 1.0;\n        m.x = 0.0;\n        m.y = 0.0;\n        dt = 1.0;\n        \n    }\n    if (p4.w < 0.001 || iFrame <= 1) {\n        AutoPilot pilot = getAutoPilot();\n        k = 1.0;\n        float a =  0.0;//atan(pilot.dir.z, pilot.dir.x)-radians(-90.);\n        //m.y = a;\n        dt = 1.0;\n        p = pilot.q;\n        //m = vec4(0.0);\n    } else {\n        p += m.xyy * k * dt;\n    }\n    \n    \n    \n    return p;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 fc )\n{\n    ivec2 iv = ivec2(fc);\n    \n    bool reset = false;//bool(res != last_res);\n\n    if (iv.x <= 0 && iv.y <= 0) {\n        o = keyboard(fc, reset);\n    } else if (iv.x == 1 && iv.y == 0) {\n        o = vec4(mouse(fc, reset), 1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}