{
    "Shader": {
        "info": {
            "date": "1671456596",
            "description": "Attaching a common spiral pattern to the triangle cells of a subdivided icosahedron.",
            "flags": 32,
            "hasliked": 0,
            "id": "cllGzr",
            "likes": 91,
            "name": "Icosahedron Triangle Pattern",
            "published": 3,
            "tags": [
                "triangle",
                "spiral",
                "pattern",
                "icosahedron",
                "spherical",
                "polyhedron"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1119
        },
        "renderpass": [
            {
                "code": "/*\n\n    Icosahedron Triangle Pattern\n    ----------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Icosahedron Triangle Pattern\n    ----------------------------\n    \n    Applying a common spiral pattern to the triangle cells of a subdivided \n    icosahedron. Attaching a suitable grid to a sphere, then rendering a \n    pattern into the cells is not what I'd call a common excercise amongst\n    the graphics crowd, but there are still plenty of examples out there. \n    There are examples on Shadertoy too, but far fewer than I would have \n    expected.\n    \n    I can understand why, since rendering to surfaces other than a plane \n    might seem a little daunting at first. However, the process is exactly \n    the same; You're simply rendering objects to a surface using familiar \n    rendering calls that involve line and shape distances, etc. For example, \n    a line between point A and B is just that, regardless of the surface \n    involved. Three line distance calls between triangle vertices will \n    result in a triangle, etc. Partitioning space into some kind of grid\n    is a little different in the sense that a plane is flat and goes on \n    forever, whereas a sphere is curved and wraps around on itself, but the \n    process still involves obtaining local cell coordinates, cell vertices, \n    etc, then using them to place objects within the cell.\n    \n    Writing spherical lines, spherical partitioning algorithms, etc, can be \n    simple or painful, but once they're done, you simply have to use them \n    however you see fit. The possibilities are endless.\n    \n    Admittedly, there's probably a little too much information in this \n    particular shader to sift through. However, if you're new to this and \n    would like to make a start, begin with rendering some line borders and \n    vertex points to the square or triangle cells of a sphere, then take \n    it from there.\n    \n    Anyway, as mentioned, this is just one of countless spherical grid \n    patterns possible. I'll post a few more in due course.   \n\n    \n\n\tRelated examples:\n\n    \n    // A really nice triangle spiral feedback example. It takes a little \n    // while to build up to the good stuff, but it's worth it. :) \n    [phreax] creation process - phreax\n    https://www.shadertoy.com/view/Dd2SWV\n    \n    // Looking at this example reminded me that I had several spiral\n    // polygon examples that I hadn't bothered finishing, so I finished\n    // one. :)\n    Nest of Polygons II - mla\n    https://www.shadertoy.com/view/cs2XWy\n    \n    // TDHooper's examples are all really popular. This one is \n    // simply, but elegantly rendered. \n    Icosahedron twist - tdhooper\n    https://www.shadertoy.com/view/Mtc3RX\n    \n    \n*/\n \n\n// Max ray distance.\n#define FAR 20.\n\n\n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 1\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// IQ's vec3 to float hash.\nfloat hash31(in vec3 p){\n    return fract(sin(dot(p, vec3(91.537, 151.761, 72.453)))*435758.5453);\n}\n\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n\n    p.xy *= rot2(-3.14159/12.);\n    p.xz *= rot2(-iTime/8.); \n\n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\nvec3 gVal;\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Flat plane back wall.\n    float wall = -p.z + 2.5;// - (length(p) - .5)*.1;\n    \n\n    // Perturbing the back wall with some cheap sinusoidal layers. You could leave the \n    // wall flat, but this will reflect light in a more interesting way.\n    vec3 pp = p*2. + vec3(0, 0, iTime/2.);\n    float pOffs = dot((sin(pp - cos(pp.yzx*2.2/2.4)*1.57)), vec3(.1));\n    pOffs = mix(pOffs, dot((sin(pp*2. - cos(pp.yzx*2.2/2.4*2.)*1.57)), vec3(.1)), .333);\n    wall -= pOffs;\n    \n    // Rotate the sphere.\n    vec3 qq = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(qq) - .5;\n    \n \n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n    \n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = min(iFrame, 0); i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = min(0, iFrame); i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n} \n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n//#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define PI TAU*.5 // To avoid numerical wrapping problems... Sigh! :)\n#define PHI  1.6180339887498948482// (1. + sqrt(5.))/2.\n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n// Direction vector.\nvec3 dir;\n//int sID, cID;\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout mat3x3 gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = 0; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the lattitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : -1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n    \n   \n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n/*    \n    cID = int(floor(ax/TAU*5.));\n    \n    dir = vec3(1);\n    if(id == 1 || id == 2) dir *= -1.;\n    if(id == 0 || id == 2) dir.x *= -1.;\n    \n    sID = id;\n*/    \n    \n    return q;\n}\n\n \n/*\n// Sphere line distance between A and B.\nfloat sphereLineCapABDist(vec3 p, vec3 a, vec3 b, float rad){\n     \n     p = normalize(p); // Normalize p.\n     float ln = dot(p, cross(a, b))/length(a - b);\n     \n     vec3 perpA = a + cross(b - a, a);\n     vec3 perpB = b + cross(a - b, b);\n     float endA = dot(p, cross(perpA, a))/length(perpA - a);\n     float endB = dot(p, cross(perpB, b))/length(perpB - b);\n     \n     \n     return max(max(ln, endA), endB);\n      \n}\n*/\n\n// Sphere line distance.\nfloat sphereLineDist(vec3 p, vec3 a, vec3 b, float rad){\n     \n     p = normalize(p); // Normalize p. // Set radius: p /= rad; \n     return dot(p, cross(a, b))/length(a - b);\n\n}\n\n//////////\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.85);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .5, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .7; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    //rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.25, 0.))));\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    \n    vec3 svVal = gVal;\n    \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 12.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n        \n\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n             // Smoothing factor.\n            float sf = .003; \n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            mat3x3 v, vID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, vID, rad);\n    \n            v[0] = sphericalToWorld(vID[0]);//vec3(0, rad, 0);\n            v[1] = sphericalToWorld(vID[1]);\n            v[2] = sphericalToWorld(vID[2]);\n            \n            \n            \n            // Edge mid points, edge tangents and exit and entry points.\n            mat3x3 vE;\n             \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            \n            mat3x3 VNgbr2;\n            \n            float midTri = 0.;\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = 0; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                    //dir = -dir;\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                \n                    // Neighboring v2 point is the original point.\n                    VNgbr2 = v;\n                    \n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                     //if(i==1){\n                    // if(sID%2==1) dir = -dir;\n                    // else dir *= vec3(1, -1, 1);\n                     //}\n                     midTri = 1.;\n                     \n                     \n                }\n               \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n                \n                \n            }\n            #endif\n            /////  \n            \n           \n            \n  \n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = v[0] + v[1] + v[2];\n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize(id)*rad;\n            \n             \n            // Rendering the triangle spirals... The rushed logic needs some tidying up,\n            // but it works, so it'll do. You could almost ignore my approach and devise \n            // your own one. I've taken a brute force approach because I wanted an \n            // accumulated shadow effect, but a polar coordinate method would be faster. \n            mat3x3 pp, vv = v;\n            float per = 0.; \n            #if SCHEME == 0\n            const int N = 24; // More triangles, if there is no subdivision.\n            #else\n            const int N = 12; // Fewer triangles for smaller subdivided cells.\n            #endif\n            const float fN = float(N);\n            float lf = 1./fN;\n            \n            // Render a few layered spiraling triangles.\n            for(int j = 0; j<N; j++){//3\n                \n                \n                // The vertices. They're contracted and rotated each iteration.\n                pp[0] = mix(vv[0], vv[1], per);\n                pp[1] = mix(vv[1], vv[2], per);\n                pp[2] = mix(vv[2], vv[0], per); \n                \n                // Three line distances between vertices, which, not surprisingly,\n                // combine to form a triangle.\n                float pLn = sphereLineDist(lq, pp[0], pp[1], rad);\n                pLn = max(pLn, sphereLineDist(lq, pp[1], pp[2], rad));\n                pLn = max(pLn, sphereLineDist(lq, pp[2], pp[0], rad));\n                \n                // Triangle shade. It gets brighter each iteration, but you\n                // can do whatever you want.\n                float sh = pow(float(j)/(fN - 1.), 1.5)*.975 + .025;\n                \n                // Triangle color.\n                vec3 tCol = vec3(min(sh*2.5, 1.));\n                //vec3 tCol = (.5 + .45*cos(6.2831*sqrt(sh)/1. + vec3(0, 1, 2))); // Colors.\n                \n                // The colored moving triangle.\n                float rndJ = mod(floor(iTime*7. + hash31(ctr+.08)*(fN*3.)), fN*3. - 1.) + 1.;\n                if(j == int(rndJ)) tCol = (tCol*.5 + .5)*vec3(3, .6, .4)*2.;//vec3(.8, 1, .3);\n                \n                tCol = mix(tCol, tCol.xzy, -sn.x);\n                \n                // Darkening the central triangle.\n                if(j==N-1){\n                    tCol = vec3(.15);\n                    texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, pLn + .015));\n                }\n                \n                \n                //tCol = vec3(.35); // Debug.\n                \n                // Shadow facotr, line width and transparency.\n                #if SCHEME < 2\n                const float shF = 12.;\n                const float lw = .005;\n                const float alpha = .35;\n                #else\n                const float shF = 6.;\n                const float lw = .004;\n                const float alpha = .25;\n                #endif\n                \n                // Rendering the triangle layers.\n                texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*shF, pLn))*alpha);\n                texCol = mix(texCol, tCol*.05, 1. - smoothstep(0., sf, pLn));\n                texCol = mix(texCol, tCol, 1. - smoothstep(0., sf, pLn + lw));\n\n                \n                //if(j==N-1) texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, pLn + .01));\n                 \n                // Edge contraction distance factor.\n                lf *= 1.125;//1.125/*(cos(iTime/1.)*.25 + 1.);\n                \n                // Set the new vertices to the adusted values.\n                vv = pp;\n                \n                // Edge contraction.\n                per = lf;\n                //per = lf*(cos(iTime/2.)*.5 + .75);\n                //per = lf*.55;\n            }\n            \n \n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z) - .012;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert - .005))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert - .005));\n            texCol = mix(texCol, vec3(.1), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .007));\n            \n            // Extra global coloring.\n            texCol *= vec3(.85, 1, 1.1); // Blueish tinge.\n \n            \n        }\n        else if(objID==1){ \n        \n            //  Back wall.\n \n            \n            // Texture coordinates.\n            vec3 txP = sp;\n            txP.xy = rot2(3.14159/12.)*txP.xy + vec2(iTime/8., 0.);\n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            mat3x2 v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id + (vID[0] + vID[1] + vID[2])/3.;\n            \n            \n            // Smoothing factor.\n            float sf = .003*2.;\n            const float ew = .01;\n           \n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            //\n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n            \n   \n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = tri<.5? p*vec2(1, -1) : p;\n             \n            // Triangle.\n            float tr = getTri(q, scale*.57735);\n            \n            // Triangle shade and color.\n            float sh = pow(floor(hash21(p4.zw + .1)*11.999)/11., 1.5)*.025 + .025;\n            vec3 tCol = vec3(sh)*vec3(.9, 1, 1.1); \n            vec3 eCol = tCol;\n           \n            // Intial background triangle color.\n            texCol = vec3(0);\n            \n            // Triangle rendering.\n            #if 1\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, tr + ew)));\n            #else\n            texCol = mix(texCol, eCol*1.25, (1. - smoothstep(0., sf, tr + ew)));\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, tr + .02 + ew)));\n            texCol = mix(texCol, tCol, (1. - smoothstep(0., sf, tr + .02 + ew*2.)));\n            #endif\n             \n\n            // Vertex coloring.\n            vec3 vCol = vec3(hash21(vertID + .1)*.075 + .025);\n            vCol *= vec3(.9, 1, 1.1);\n             \n            // Blinking glowing vertices.\n            vec3 lCol2 = (vCol*.5 + .5)*vec3(3, .6, .4)/2.;//vec3(.8, 1, .3);\n            lCol2 = mix(lCol2, lCol2.xzy, -sp.x/2.);\n            float glow = smoothstep(.97, .99, sin(6.2831*hash21(vertID + .2) + iTime/4.));\n            vCol = mix(vCol, lCol2, glow);    \n            \n            // Vertex rendering.\n            float vw = .04;\n            vert -= vw;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert))*.35);\n            texCol = mix(texCol, texCol + vCol, (1. - smoothstep(0., sf*8., vert))*.05);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vCol, 1. - smoothstep(0., sf, vert + .01));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + vw - .01));\n            \n            // Adding some extra global coloring.\n            texCol *= vec3(.9, 1, 1.1)*vec3(.85, 1, 1.1);\n  \n        }\n\n      \n        //texCol *= vec3(.8, 1.2, 2.75); // More blue.\n        \n        \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n        \n        // Specular reflection.\n        vec3 hv = normalize(ld - rd); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        if(objID==0) ref.xz = rot2(-iTime/3./2.)*ref.xz;\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx;\n        refTx = (texCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        float rf = objID == 1? .5 : 1.;\n        //\n        // Adding the specular reflection and glow for the inner light.\n        texCol += texCol*spRef*mix(refTx, refTx.zyx, rd.y*0.)*rf*4.;\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .8, .5)*spec*freS*sh*16. + vec3(.2, .4, 1)*fre*sh*0.);\n \n        // Ambient occlusion and light attenuation.\n        col *= ao*atten;\n        \n\t\n\t}\n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(col, 0.), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//////////////////////\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./9.;//1.333;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = (vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    \n    p.y = p.y + r/k; // This one has been reversed.\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n    \n    \n    \n}\n/////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}