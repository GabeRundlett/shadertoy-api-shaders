{
    "Shader": {
        "info": {
            "date": "1706742825",
            "description": "raymarch",
            "flags": 0,
            "hasliked": 0,
            "id": "sdGBR3",
            "likes": 1,
            "name": "foam bubble",
            "published": 3,
            "tags": [
                "raymarch"
            ],
            "usePreview": 0,
            "username": "rogo1965",
            "viewed": 155
        },
        "renderpass": [
            {
                "code": "#define M_NONE -1.0\n#define M_NOISE 1.0\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n#define OCTAVES 4\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100.0);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MAX_DIST = 150.0;\nconst float EPSILON = 0.002;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)-2.0;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opSmI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmU( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nmat3 rotateY(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, 0, s),\n        \t\t\tvec3(0, 1, 0),\n        \t\t\tvec3(-s, 0, c)\t);\n}\n\nmat3 rotateX(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(1, 0, 0),\n        \t\t\tvec3(0, c, -s),\n        \t\t\tvec3(0, s, c)\t);\n}\n\nmat3 rotateZ(float t) {\n    float c = cos(t);float s = sin(t);\n\treturn mat3(\tvec3(c, -s, 0),\n        \t\t\tvec3(s, c, 0),\n        \t\t\tvec3(0, 0, 1)\t);\n}\n\nfloat sceneSDF(vec3 sP) {\n    float d=MAX_DIST;\n    vec3 sPTorus = sP*rotateX(iTime*1.2);\n    vec3 sPT1 = (sP*rotateY(iTime)+vec3(0.2))*rotateX(-iTime*0.1);\n\tfloat torus = sdTorus(sPTorus+0.2*noise(vec3(sP.x*3.0+iTime*4.0,sP.y*2.0,sP.z)),vec2(0.5,1.2+0.2*noise(sP*2.5)));\n    float fff = sdTorus(sPT1,vec2(0.4,0.2+0.2*noise(sP*4.0+iTime*3.0)));\n    return opSmU(torus,fff,0.13);\n}\n\nfloat[4] shortestDistanceToSurface(vec3 eye, vec3 marchingDirection) {\n    float depth[4];\n    float dd=0.0;\n    int layer=0;\n    float side=1.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = side*(sceneSDF(eye + dd * marchingDirection));\n        dd += dist;\n        if (dist<EPSILON) {\n            depth[layer]=dd;\n            dd+=10.0*EPSILON;\n            side*=-1.;\n\t\t\tlayer++;\n        }else if(dist>MAX_DIST){\n            for(int l=layer;l<4-layer;l++){\n                depth[l]=0.0;\n            }\n\t\t\treturn depth;\n            break;\n        }\n        \n    }\n    return depth;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 eN(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat AO(vec3 p,vec3 n){\n    float ao =0.0;\n    float d;\n    for(int i=1;i<=2;i++){\n        d=3.0*float(i);\n        ao+=max(0.0,(d-sceneSDF(p+n*d))/d);\n    }\n    return ao;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    float sdf[] = shortestDistanceToSurface(eye, dir);\n    if(sdf[0]>MAX_DIST){\n        fragColor = vec4(color, 1.0);\n        return;\n    }\n    for(int i=3;i>=0;i--){\n        float dist = sdf[i];\n        if(sdf[i]!=0.0){\n            vec3 p = eye + dist * dir;\n            vec3 N = eN(p);\n            float occ = 1.0-AO(p,N);\n            vec4 synmedia = vec4(0.5);\n            vec3 ref = reflect(dir,N);\n            ref=(synmedia.xyz+0.5*( abs(sin( (N+1.0)*3.1415926*vec3(1.0,1.0,1.0) )) ) )*(1.0*occ-0.0);\n\n            float blendingN =1.0-smoothstep(0.0,0.7,length(N*dir));\n            color=(1.0-blendingN)*(0.6*color+0.1*ref)+ref*blendingN;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}