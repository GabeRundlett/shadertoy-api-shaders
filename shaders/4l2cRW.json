{
    "Shader": {
        "info": {
            "date": "1508138409",
            "description": "Also known as a \"Cone Sphere\", this is essentially a capsule with two different radii at each end.  It has a few nice properties (it's the convex hull of two spheres and a subsection of a cone).  Not optimized, but branchless and extensible to an SDF.",
            "flags": 0,
            "hasliked": 0,
            "id": "4l2cRW",
            "likes": 14,
            "name": "BiCapsule",
            "published": 3,
            "tags": [
                "sdf",
                "sphere",
                "cone",
                "function",
                "capsule",
                "tangent",
                "bicapsule"
            ],
            "usePreview": 0,
            "username": "zalo",
            "viewed": 1822
        },
        "renderpass": [
            {
                "code": "#define MAX_ITERATIONS 128\n#define MIN_DISTANCE .001\n#define NEAR_PLANE    1.\n#define FAR_PLANE    5.\n\nvec3 closestPointToBiCapsule(vec3 pos, vec3 a, vec3 b, float r1, float r2) {\n    //Standard line segment closest point\n    vec3 ba = b - a; float baMagnitude = length(ba);\n    float alpha = (dot(pos - a, ba) / dot(ba, ba));\n    vec3 capsuleSegmentPos = mix(a, b, alpha);\n    \n    //Calculate the offset along segment according to the slope of the bicapsule\n    float pointSphereRadius = r1 - r2; //This collapses the problem into finding the tangent angle for a point/sphere\n    float exsecantLength = ((baMagnitude / abs(pointSphereRadius)) - 1.0) * baMagnitude;\n    float tangentAngle =  acos(1.0 / (exsecantLength + 1.0)); //This is also known as the \"arcexsecant\" function\n    float tangentOffset = length(capsuleSegmentPos - pos) / tan(tangentAngle); //This is adjacent / tan(theta) = opposite\n    tangentOffset *= sign(pointSphereRadius); //Allows it to handle r2 > r1 as well\n    \n    //And back to classic capsule closest point (with lerped radii)\n    float clampedOffsetAlpha = clamp(alpha - tangentOffset, 0.0, 1.0);\n    vec3 bicapsuleSegmentPos = mix(a, b, clampedOffsetAlpha); float bicapsuleRadius = mix(r1, r2, clampedOffsetAlpha);\n  \treturn bicapsuleSegmentPos + (normalize(pos - bicapsuleSegmentPos) * bicapsuleRadius);\n}\n\n\nvec3 offsetToSurface(vec3 pos) {\n    vec3 a = vec3(-0.5, 0.0, 2.0);\n    vec3 b = vec3(0.5 + (sin(iTime)*0.5), (cos(iTime)*0.5), 2.0);\n\n    vec3 closestPoint = closestPointToBiCapsule(pos, a, b, (sin(iTime*3.0)*0.3)+0.3, 0.2);\n    return closestPoint - pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 rayDir = vec3( uv.x - 0.5, (uv.y - 0.5) * iResolution.y / iResolution.x, 0.5 );\n    vec3 toSurfaceOffset;\n    \n    float depth = NEAR_PLANE; float curDist = MIN_DISTANCE; int i;\n\tfor(int i = 0; i < MAX_ITERATIONS; i++) {\n        depth += curDist;\n        toSurfaceOffset = offsetToSurface(rayDir * depth);\n    \tcurDist = length(toSurfaceOffset);\n        \n        if (curDist <= MIN_DISTANCE || depth > FAR_PLANE)\n            break;\n\t}\n\n    if(depth < FAR_PLANE){\n\t\tfragColor = vec4(clamp(dot(vec3(1.0, 1.0, -1.0), -toSurfaceOffset/curDist)*0.5,0.0,1.0)+0.1);\n    }else{\n        fragColor = vec4(0);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}