{
    "Shader": {
        "info": {
            "date": "1589142109",
            "description": "a failed experiment in mapping SDFs using circle inversion. I thought that because circle inversion preserves circles, then we could map a signed distance in the same way. unfortunately, it only works locally",
            "flags": 0,
            "hasliked": 0,
            "id": "tdfBW2",
            "likes": 10,
            "name": "Experiment: Circle Inversion",
            "published": 3,
            "tags": [
                "experiment",
                "inversion",
                "failed"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 616
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a, b-a)/dot(b-a,b-a);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nvec2 proj(vec2 p) {\n    return p/dot(p,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nmat2 rot(float ro) {\n    float c = cos(ro);\n    float s = sin(ro);\n    return mat2(c,-s,s,c);\n}\n\nfloat scene2(vec2 p) {\n    p = rot(iTime)*(p-vec2(0.4,0.));\n    float ln = linedist(p, vec2(0.,.1), vec2(0.,-.1))-0.05;\n    float bx = box(p, vec2(.1));\n    return mix(ln, bx, smoothstep(-.2,.2,sin(iTime*0.5)));\n}\n\nfloat scene(vec2 p) {\n    vec2 p2 = proj(p);\n    float d = scene2(p2);\n    //since the centre of a circle doesn't map to the centre of its image,\n    //we need to iteratively update our estimate with the correct centre\n    for (int i = 0; i < 10; i++) {\n        //get the projected circle's centre\n    \tp2 = (proj(p-normalize(p)*d) + proj(p+normalize(p)*d))/2.;\n    \td = scene2(p2);\n        d = d/(dot(p2,p2)-d*d);\n    \td = clamp(d, -1.,1.); //if I don't clamp here, the distance estimate goes wild\n    }\n    return d;\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(clamp(log(abs(d)+1.0)*1.5, 0.0, 1.0));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    if (d > 0.0) {\n        //red tint\n        color *= vec3(1.0,0.56,0.4);\n    } else {\n        //blue tint\n        color *= vec3(0.4,0.9,1.0);\n        \n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.;\n    mouse*=3.;\n    uv.x += 1.8;\n    mouse.x += 1.8;\n\n    float mousedist = scene(mouse);\n    vec3 col = shadeDistance(scene(uv));\n    vec3 col2 = shadeDistance(scene2(uv));\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        col *= smoothstep(-pixelsize, pixelsize, distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n\n    if (length(uv)>1.) {\n    \tfragColor = vec4(col,1.0);\n    } else {\n    \tfragColor = vec4(col2,1.0);\n    }\n    fragColor *= smoothstep(0.005, .015, abs(length(uv)-1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}