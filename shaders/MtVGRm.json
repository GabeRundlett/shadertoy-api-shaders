{
    "Shader": {
        "info": {
            "date": "1473950366",
            "description": "mouse position zooms;\nupper half has more grainy noise.\n\nhas differences between using iChannel0 [upper half] and noisergba() [lower half], but how?\nand how https://www.shadertoy.com/view/XsG3Dc# factorizes overlays?\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MtVGRm",
            "likes": 4,
            "name": "wood noise",
            "published": 3,
            "tags": [
                "wood",
                "plank"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 832
        },
        "renderpass": [
            {
                "code": "//minor extension on https://www.shadertoy.com/view/XsG3Dc#\n//optionally working without iChannel0\n// basically draw contours of a height field.\n// making a realistic texture is not easy!\n\nconst float knobStrength = 2.0;\n#define pixelsPerPlank (100.*iResolution.x*.5/iMouse.x+5.)\n#define linesPerPlank (2.*iResolution.y/iMouse.y+1.)\nconst float verticalScale = 6.0;\nconst float lineStrength = 0.8;\nconst float plankLength = 6.0;\n\n//bad substitute for iChannel5 rgba noise that may scale a bit better but is more repetitive\nvec4 noisergba(vec2 uv){\n uv -=floor(uv/289.0)*289.;\n uv +=vec2(223.35734, 550.56781);\n //uv *=uv;\n float xy = uv.x * uv.y;    \n return vec4(sin(fract(xy*.000000064)),\n             sin(fract(xy*.000000543)),\n             sin(fract(xy*.000000192)),\n             sin(fract(xy*.000000423)));}\n\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n    vec2 ip = floor(p); vec2 u = fract(p);u=u*u*(3.0-2.0*u);\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res;\n}\n\nfloat noisetex(in vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tf = f*f*(3.-2.*f);    \n    if(x.y/iResolution.y<.5){\n        float a =  noisergba((p+f+.5)/256.).y;\n        return a*8.;}\n//replaces\n\treturn texture( iChannel0, (p + f + 0.5)/256.0, -100.0 ).x;\n    \n}\n\nfloat height(in vec2 a) {\n    a = a*vec2(1.0, 1.0/verticalScale);\n    return linesPerPlank * (knobStrength*noise(a) + a.x);\n}\n\n// make the lines constant width\n// https://iquilezles.org/articles/distance\nvec2 grad(in vec2 x) {\n\tvec2 h = vec2(0.05, 0.0);\n\treturn vec2(height(x+h.xy) - height(x-h.xy),\n                height(x+h.yx) - height(x-h.yx))/(2.0*h.x);\n}\n\nvec4 composit(in vec4 top, in vec4 bottom) {\n    return vec4(mix(top.xyz, bottom.xyz, 1.0-top.a), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //animation\n    //fragCoord.y += iTime * 10.;\n    \n    vec2 pixel = fragCoord / pixelsPerPlank;\n    float plank = floor(pixel.x); // unique per plank\n    float start = 15.0 * rand(vec2(plank));\n    float item = floor(pixel.y/plankLength + start);\n    \n    vec3 woodLine = vec3(90., 45., 18.)/255.;\n    vec2 plankPixel = pixel + vec2(124., 11.) * plank;\n    float value = height(plankPixel + item);\n    vec2 gradient = grad(plankPixel + item);\n    float linePos = 1.0 - smoothstep(0.0, 0.08, fract(value)/length(gradient));\n    float line = floor(value); // unique per line\n    float lineWeight = mix(1.0, 0.4+rand(vec2(line,plank)), 0.8);\n    \n    \n    float lineGrain = smoothstep(-0.2, 0.9, noisetex(fragCoord));\n    \n    vec3 woodBase = vec3(144., 91., 49.)/255.;\n    float darkness = mix(1.0, 0.5+rand(vec2(plank, item)), 0.2);\n    //float grain = mix(1.0, 0.5 + 0.7*noisetex(fragCoord+vec2(12.5,12.5)), 0.1);\n    \n    float plankGapY = step(0.0, fract(pixel.x)) * (1.0-step(0.02, fract(pixel.x)));\n    float plankGapX = step(0.0, fract(pixel.y/plankLength+start)) * (1.0-step(0.02/plankLength, fract(pixel.y/plankLength+start)));\n   \n    // final images\n    vec4 planks = vec4(0.1, 0.1, 0.1, max(plankGapY, plankGapX));\n    vec4 lines = vec4(woodLine, lineStrength*lineWeight*lineGrain*linePos);\n    vec4 wood = vec4(woodBase*darkness, 1.0);\n    \n    fragColor = composit(planks, composit(lines, wood));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}