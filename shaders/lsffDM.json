{
    "Shader": {
        "info": {
            "date": "1496383188",
            "description": "3-voice arpeggio with Mouse input; \n\nleft one swaps between Major and Minor;\n\nI thought of a rather simple way to represent chords or ascending and descending melodies.\n\nThis simple constrained approach, only solves for 3 dots. generalization pending.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsffDM",
            "likes": 19,
            "name": "3 voice harmony arpeggio chord",
            "published": 3,
            "tags": [
                "starguitar",
                "irrationalstride",
                "arpshepardtone",
                "ditherhairlinequantize",
                "chromaticscalecordtartanweave"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1369
        },
        "renderpass": [
            {
                "code": "//this one only does 3 points per inverval. \n//it is a primitive PRECURSOR to its general [*stride] solution.\n\n//thee voice harmony minor major chorr (old)\n//self https://www.shadertoy.com/view/lsffDM \n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n\n/*\nI thought of a rather simple way to represent longer chords, \nascending and descending melodies.\n\nthis is the simple more constrained approach, only 3 dots.\nsolve a special case BEFORE trying a general case!\n\nThe reason why tesselation of music pitches works is\n...because we fail do distinguish hiigher resolutions of pitches.\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n\n/*\na problem suupoptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\n\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\n\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n\n//red circle radius\n#define radius 1.\n//blur of all the lines\n#define blur .05\n#define zoom 9.\n\n//return distance of [u] to line srgment from [a] to [b]\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(blur,-blur,abs(r-1.)-blur);}\n\n//[u]FragmentPos, [m]=start [n]=end\nvec3 tripplet(vec2 u, vec2 m, vec2 n){\n float d=length(m-u),e=length(n-u),f=length(n+m-u*2.)*.5;\n //[f] is in between [d] and [e]\n //d=red circle around 2 points:\n d=min(min(d,e),f);\n d=smoothstep(blur,-blur,abs(d-radius)-blur);\n //t=geen square tiles\n float t=0.;\n if(all(equal(flc(m),flc(u))))t+=.3;\n if(all(equal(flc(n),flc(u))))t+=.3;\n if(all(equal(flc(n+(m-n)*.5),flc(u))))t+=.3;\n //l=blue line segment\n float l=Segment(u,m,n);         \n l=smoothstep(blur,-blur,abs(l-radius*.2)-blur); \n return vec3(d,t,l);}\n\n#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U)*zoom;               \n vec2 m=frame(abs(iMouse.zw))*zoom;//start of holding mouse\n vec2 n=frame(iMouse.xy)*zoom;//current mouse pos held\n vec2 o=vec2(0);//an offset to use screenspace a bit better\n if(iMouse.z<=0.){n=vec2(.0);o=vec2(2,0);\n  m=vec2(sin(iTime),cos(iTime))*zoom*.4;}\n vec3 user=tripplet(u-o,m,n);//set by mouse in45.));\n //minor over time, loop trough minor and major chord.\n vec3 MinMaj=tripplet(u,vec2(-4.,-3.),vec2(-4.,2.+sin(iTime*3.)*.4));                             \n vec3 c=max(user,MinMaj);//max()_overlap\n //c=user+MinMaj;//alernative overwrite\n c+=grid(u)*.2;//add greyscale grid)            \n //c=clamp(c,0.,1.);//saturate()\n O=vec4(c,1.);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}