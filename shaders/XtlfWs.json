{
    "Shader": {
        "info": {
            "date": "1514068720",
            "description": "Alternates between grid and party! Probably nothing new -- traverse a uniform 3D grid while analytically raytracing objects in grid cells. Practicing to make a better shader later on.",
            "flags": 0,
            "hasliked": 0,
            "id": "XtlfWs",
            "likes": 23,
            "name": "party grid 3d",
            "published": 3,
            "tags": [
                "3d",
                "grid",
                "raytrace",
                "march"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 1063
        },
        "renderpass": [
            {
                "code": "/* party grid 3d, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n*/\n\n\nconst float farval = 10000.0;\nconst vec4 miss = vec4(vec3(0.0), farval);\nconst float rad = 0.25;\n\n#define INT_FORLOOPS\n\nconst float nbox = 7.0;\n\n#ifdef INT_FORLOOPS\n#define LOOPTYPE int\n#define LOOP0 0\nconst int rsteps = 3*int(nbox);\n#else\n#define LOOPTYPE float\n#define LOOP0 0.\nconst float rsteps = 3.*nbox;\n#endif\n\nconst float linewidth = 0.04;\nconst float kfog = -1.2/nbox;\n\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\n// Dave Hoskins' hash without sine https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// RGB from hue\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n// rotate about x-axis \nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n// rotate about y-axis \nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n// ray-sphere intersection\nvec4 sphere(in vec3 o, in vec3 d, in vec3 ctr, in float r) {\n\t\n    vec3 oc = o - ctr;\n    \n    float a = dot(d, d);\n    float b = 2.0*dot(oc, d);\n    float c = dot(oc, oc) - r*r;\n        \n    float D = b*b - 4.0*a*c;\n    \n    if (D > 0.0) {\n        \n        float sqrtD = sqrt(D);\n        \n        float t = 0.5 * ( -b - sqrtD ) / a;\n        \n        if (t >= 0.0) {\n            vec3 n = normalize( oc + t*d );\n            return vec4(n, t);\t\n        }\n        \n    }\n    \n    return miss;\n\t\t\n}\n\n// minimum of vector\nfloat min3(vec3 a) {\n\treturn min(a.x, min(a.y, a.z));\n}\n\n// max of vector\nfloat max3(vec3 a) {\n\treturn max(a.x, max(a.y, a.z));\n}\n\n// median of vector\nfloat median3(vec3 x) {\n    return dot(x, vec3(1)) - min3(x) - max3(x);\n}\n\n// ray-box intersection\nfloat box(vec3 ro, vec3 rd, vec3 b) {\n\t\n\tvec3 rdi = 1.0/rd;\t\n\t\t\n\tvec3 t1 = (-b - ro)*rdi;\n\tvec3 t2 = ( b - ro)*rdi;\n\t\n\tvec3 tmin = min(t1, t2);\n\tvec3 tmax = max(t1, t2);\n    \n    float ta = max3(tmin);\n    float tb = min3(tmax);\n\t\n\tif (ta <= tb) {\n\t\treturn ta;\n\t} else {\n\t\treturn farval;\n\t}\n\n}\n\n// select whichever basis edge minimizes time to hit\nvec3 bselect(vec3 k, vec3 d, vec3 b1, vec3 b2) {\n\treturn (abs(dot(k,b1)*dot(d,b2)) < abs(dot(k,b2)*dot(d,b1))) ? b1 : b2;\n}\n\n// for stepping through cube lattice\nfloat stepcube(in vec3 p, in vec3 d) {\n\t\n\t// g is half-integer coords from p in the direction of d\n\tvec3 g = floor(p+vec3(0.5))-vec3(0.5) + step(vec3(0.0), d);\n\n\t// k is the vector from p to the corner in direction d\n\tvec3 k = g-p;\n\t\n\t// select the basis vector representing the first to intersect\t\n\tvec3 b = bselect(k, d, \n\t\t\t\t\t bselect(k, d, vec3(1.0, 0.0, 0.0), \n\t\t\t\t\t \t\t\t   vec3(0.0, 1.0, 0.0)), \n\t\t\t\t\t\t           vec3(0.0, 0.0, 1.0));\n\t\n\t// compute the distance along the ray to the nearest cube edge\n\treturn dot(k,b) / dot(d, b);\n\t\n}\n\n// point in box?\nbool inbox(vec3 c, float tol) {\n    float cmin = min(c.x, min(c.y, c.z));\n    float cmax = max(c.x, max(c.y, c.z));\n    return cmin >= -tol && cmax < nbox + tol;\n}\n\n// fog blocking\nfloat fog(vec3 x) {\n    float l = length(x);\n    l = max(0.0, l-nbox);\n    return exp(kfog*l);\n}\n\n// ray trace\nvec3 shade(in vec3 ro, in vec3 rd) {\n    \n    // raytrace against bounding box\n    float curw = box(ro, rd, 0.5*vec3(nbox+linewidth));\n    if (curw == farval) {\n        return vec3(0);\n    }\n    \n    const float t_trans = 2.0;\n    const float t_phase = 5.0;\n    \n    float mtime = mod(iTime+t_trans, 2.0*t_phase);\n    float xtime = mod(mtime, t_phase);\n\n    float party = smoothstep(0.0, t_trans, xtime);\n    if (mtime < t_phase) {\n        party = 1.0 - party;\n    }\n        \n\t// added to cube step\n\tconst float eps = 0.001;\n\t\n    // center box grid\n    ro += 0.5*nbox - 0.5;\n    \n    // pixel color\n\tvec3 color = vec3(0.0);\n    \n    // grid coverage\n    float grid = 0.0;\n    \n    // pixel ray distance\n    float rw = farval;\n\n    // march along ray thru grid\n\tfor (LOOPTYPE i=LOOPTYPE(0); i<rsteps; ++i) {\n        \n        // point in grid\n        vec3 p = ro + curw * rd;\n\n        // check if point inside box for grid rendering\n        if (inbox(p+0.5, 0.5*linewidth)) {\n            \n            // xyz displacement from center of cell\n            vec3 dctr = p - floor(p + 0.5);\n\n            // xyz displacement from face\n            vec3 dface = abs(0.5 - abs(dctr));\n\n            // get median coordinate of face displacement\n            float emid = median3(dface);\n\n\t\t\t// grid line\n            float gbrt = smoothstep(linewidth, 0.0, emid) * fog(p-ro);\n\t\t\tgrid = max(grid, (1.0-party)*gbrt);\n\n        }\n\n        // base cell \n        vec3 cbase = floor(p);\n\n        // for each neighbor in 2x2x2 neighborhood\n        for (LOOPTYPE j=LOOPTYPE(0); j<LOOPTYPE(8); ++j) {\n\n#ifdef INT_FORLOOPS\n            vec3 joffs = vec3(ivec3(j/4, (j%4)/2, j%2));\n#else\n            // offset to neighbor\n            vec3 joffs = vec3(floor(j/4.0), floor(mod(j, 4.0)/2.0), mod(j, 2.0));\n#endif\n\n            // center of cell\n            vec3 ctr = cbase + joffs;\n\n            // if center in box\n            if (inbox(ctr, 0.0)) {\n\n                // raytrace to sphere in cell\n                \n                vec3 h1 = hash33(ctr);\n                vec3 r = 0.5*party*0.5*cos((h1+0.05)*4.0*iTime + 2.0);\n\n                float srad = mix(0.1, rad * (0.5 + h1.z), party);\n                \n                vec4 s = sphere(ro, rd, ctr + r, srad);\n                \n                // if in front of current hit\n                if (s.w < rw) {\n                    \n                    vec3 c = 0.5*hue(h1.x) + 0.5;\n                    \n                    vec3 n = s.xyz;\n                    \n                    vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * c;\n                    vec3 R = 2.0*n*dot(n,L)-L;\n                    \n                    float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n                    \n                    color = diffamb + spec;\n                    color *= fog(s.w*rd);\n                    \n                    rw = s.w;\n                    \n                }\n\n            } // center in box\n\n        } // for each neighbor\n        \n        curw += stepcube(p, rd) + eps;\n        \n\t} // for each step along ray\n\t\n    // mix sphere color and grid color\n\treturn max(color, vec3(grid));\n\t\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n   \n    const vec3 tgt = vec3(0.0, 0.0, 0.0);\n    const vec3 cpos = vec3(0.0, 0.0, 1.8*nbox);\n    const vec3 up = vec3(0, 1, 0);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float thetay = 0.1235*iTime;\n    float thetax = 0.75 * smoothstep(0.0, 5.0, iTime);\n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * -5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * 10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotY(thetay)*rotX(thetax); \n    L = Rview*L;\n\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = shade(ro, rd);\n\t\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}