{
    "Shader": {
        "info": {
            "date": "1541134956",
            "description": "rotate with arrow keys and WASD\nthis is a slice of a 4-dimensional fractal.  It has 4 degrees of freedom, so the arrow keys and WASD all rotate in separate directions through R4.\nIt is composed of all the 2d julia sets stacked in two further dimensions.",
            "flags": 48,
            "hasliked": 0,
            "id": "MtcBzs",
            "likes": 3,
            "name": "4d julia set",
            "published": 3,
            "tags": [
                "juliaset",
                "4d",
                "trippy",
                "mandelbrotset"
            ],
            "usePreview": 0,
            "username": "loveless_savage",
            "viewed": 747
        },
        "renderpass": [
            {
                "code": "//access different parts of buffer A\n#define A_RE vec2(0.2,0.2)\n#define A_SP vec2(0.4,0.4)\n#define A_TX vec2(0.4,0.8)\n#define A_TY vec2(0.8,0.4)\n#define A_TZ vec2(0.8,0.8)\n\n//resolution of each test\n#define RESOL 40\n\n//square a 2D vector as a complex value\nvec2 csq(vec2 z){\n    return vec2( z.x*z.x-z.y*z.y , 2.0*z.x*z.y );\n}\n\n//given the 4D Julia set coordinates, test for divergence with a certain resolution\nint runTest(vec2 zi, vec2 c, int resol){\n    vec2 z = zi;\n\n    for(int i=0;i<resol;i++){\n        //escape? return the loop number\n        if( length(z)>2.0 ) return i;\n        //iterate again\n        z = csq(z) + c;\n    }\n    //never escaped? return the max possible value\n    return resol;\n}\n//different grouping of data values, but the same function\nint runTest(vec4 pos, int resol){\n    return runTest(pos.xy,pos.zw,resol);\n}\n\n\n//calculate the color of the model given a depth\nvec4 modelColor(float dep){\n        if(dep==1.0) return vec4(0.0);\n\n        float temp[3] = float[3](0.0,0.0,0.0);\n        float depmod = mod(dep,0.2);\n    \n        int depnum = int((dep-depmod)*5.0);\n    \n        if((depnum&1)>0) depmod = 0.2-depmod;\n    \n        temp[(4-depnum) % 3]=5.0*depmod;\n    \n        depnum += 1;\n        depnum >>= 1;\n    \n        temp[depnum]=1.0;\n    \n        return vec4(temp[0],temp[1],temp[2],1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //should I redraw?\n    //bool reDraw = texture(iChannel0, A_RE).x > 0.0;\n    \n    //pixel resolution- how much to change with each step\n    float pixres = 4.0/min(iResolution.x,iResolution.y);\n    \n    //normalized coordinates- -2 to 2 but square\n    vec2 coord = fragCoord - 0.5*iResolution.xy;\n    coord *= pixres;\n    \n    //expand coordinates into the 4th dimension\n    vec4 pos = coord.x*texture(iChannel1, A_TX ) + coord.y*texture(iChannel1, A_TY );\n    //orthagonal vector into relative z dimension\n    //vec4 tz =  pixres *texture(iChannel1, A_TZ );\n    \n    //run the test and grab the escape time factor\n    float dep = float(runTest(pos,RESOL))/float(RESOL);\n    \n    //pick out the right color for the point\n    fragColor = modelColor(dep);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//access different parts of buffer A\n#define A_RE vec2(0.2,0.2)\n#define A_SP vec2(0.4,0.4)\n#define A_TX vec2(0.4,0.8)\n#define A_TY vec2(0.8,0.4)\n#define A_TZ vec2(0.8,0.8)\n\n//key values to search for\nconst int keyNums[8] = int[8](39,37,38,40,87,83,68,65);\n\n\n//rotate a 2D vector by some angle\nvec2 rotate(vec2 inp, float angi){\n        float ang = atan(inp.y, inp.x);\n        ang += angi;\n        vec2 adj = vec2( cos(ang),sin(ang) );\n        return adj * length(inp);\n}\n\n//spin a 4D vector around 4 select axes listed in the parameters\nvec4 spin(vec4 inp, vec4 ang){\n        vec4 temp = vec4(rotate(inp.xz,ang.x),rotate(inp.yw,ang.y));\n        temp = vec4(rotate(temp.zy,ang.z),rotate(temp.xw,ang.w));\n        return temp.zyxw;\n}\n\n//how fast to rotate\n#define RVEL 0.02\n\n\n//Buffer A- Keyboard interaction and accumulative memory\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        float mov[4]=float[4](0.0,0.0,0.0,0.0);\n        vec4 pos = texture(iChannel1,A_SP);\n\n        //keyboard listener- positive motion takes priority\n        for(int i=0;i<4;i++){\n                if(texelFetch( iChannel0, ivec2(keyNums[i*2],0), 0 ).x>0.0){\n                        mov[i] = 1.0;\n                }else if(texelFetch( iChannel0, ivec2(keyNums[i*2+1],0), 0 ).x>0.0){\n                        mov[i] =-1.0;\n                }\n        }\n        vec4 vel = vec4(mov[0],mov[1],mov[2],mov[3]) * RVEL;\n        pos += vel;\n    \n\n        //is the model turning during this frame? or has the model changed resolution?\n        if(uv.x+uv.y < 0.6){\n                fragColor = vec4(0.0,iResolution.xy,0.0);\n                if( mov[0]+mov[1]*2.0+mov[2]*4.0+mov[3]*8.0 !=0.0){\n                        fragColor.x = 1.0;\n                }\n                vec2 pResolution = texture(iChannel1,A_RE).yz;\n                if( min(pResolution.x,pResolution.y) != min(iResolution.x,iResolution.y) ){\n                        fragColor.x = 1.0;\n                }\n        //spin amounts\n        }else if(uv.x<0.6 && uv.y<0.6){\n                fragColor = pos;\n        //transformed x-axis\n        }else if(uv.x<0.6){\n                fragColor = spin(vec4(1.0,0.0,0.0,0.0),pos);\n        //transformed y-axis\n        }else if(uv.y<0.6){\n                fragColor = spin(vec4(0.0,1.0,0.0,0.0),pos);\n        //transformed depth (z-)axis\n        }else{\n                fragColor = spin(vec4(0.0,0.0,1.0,0.0),pos);\n        }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}