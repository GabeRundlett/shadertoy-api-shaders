{
    "Shader": {
        "info": {
            "date": "1460566194",
            "description": "Creation of implicit surfaces using sphere tracing and flat shading",
            "flags": 0,
            "hasliked": 0,
            "id": "MsdXzj",
            "likes": 1,
            "name": "Implicit-CG-UD",
            "published": 3,
            "tags": [
                "implicit"
            ],
            "usePreview": 0,
            "username": "lesolorzanov",
            "viewed": 763
        },
        "renderpass": [
            {
                "code": "// Blobs\n// Based on Eric Galin's work\n \nconst int Steps = 200;\nconst float Epsilon = 0.05; // Marching epsilon\n \nconst float lipshietz = 8.5;\nconst float depthMax = 20.0;\n\nconst float near = 10.0;\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n \nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n \nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n \n \n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n \n// Primitive functions\n \n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n \n// Segment skeleton\n// p : point\n// a,b  : extremity of the segment\n// e : energy associated to skeleton\n// R : radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e,float R)\n{\n  vec3 v = b - a;\n  vec3 w = p - a;\n\n  float c1 = dot(w,v);\n  if ( c1 <= 0.0 )\n    return e*falloff(length(p-a),R);\n\n  float c2 = dot(v,v);\n  if ( c2 <= c1 )\n      return e*falloff(length(p-b),R);\n\n  float t = c1 / c2;\n  vec3 Pb = a + t * v;\n    \n  return e*falloff(length(p-Pb),R);\n}\n\n\n\n// Potential field\n// p : point\nfloat object(vec3 p)\n{         \n  p.z=-p.z;\n  float v = -0.5;\n    float ks=0.0;\n    \n  //jaja creyeron que se iban a robar mi formula XD\n    \n    bool wave=false;\n   //3.0*sin(iTime)\n    \n    float pi=3.14159265359;\n    //float dx=-9.5*sin(iTime), dy=-1.5*sin(iTime), dz=5.0*sin(iTime);\n    float dx=-9.0, dy=-1.5,dz=5.0;\n    float x=0.0,y=-1.0,z=1.0,speed=1.0,near=3.5,ds=1.0,dr=0.5;\n    \n    if(wave){\n        v+=segment(p, vec3(2.5+dx,1.0-dy*sin(iTime),1.0+dz), vec3(2.5+dx,4.0-dy*sin(iTime),1.0+dz), 1.0,1.0);\n        v+=segment(p, vec3(1.0+dx,4.0-dy*sin(iTime),1.0+dz), vec3(4.0+dx,4.0-dy*sin(iTime),1.0+dz), 1.0,1.0);\n       \t\n    }else{    \n        //ks+= pow( point(p, vec3(0.0,1,0),1.0,2.0) , power ) ;\n       \n        v+=point(p, vec3(0.0,1.0,0),1.0,2.0);\n    }\n  return v;\n}\n \n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n \n// Trace ray using sphere tracing\n// a : ray origin\n// u : ray direction\nvec3 Trace(vec3 a, vec3 u, out bool hit)\n{\n  hit = false;\n  float temp = 0.0;\n  float depth = 0.0;\n  vec3 p = a;\n  \n  for(int i=0; i<Steps; i++)\n  {\n    if (!hit) {\n      float v = object(p);\n      if (v > 0.0) {\n        hit = true;\n      }\n      //p += Epsilon*u;\n      temp = max(Epsilon, abs(v/lipshietz));\n      depth += temp;\n      if(depth > depthMax)\n      {\n         return p;\n      }\n      p+=temp*u;\n    }\n  }\n  return p;\n}\n \n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n  //return vec3(0.0,0.2,0.5);\n}\n \n// Lighting\n// p : point,\n// n : normal at point\nvec3 shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  vec3 lightColor = vec3(0.5*sin(iTime)+0.5, 0.5*sin(iTime-1.05)+0.5, 0.5*sin(iTime-2.1)+0.5);\n \n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l))+0.4;\n \n  c += diff*lightColor;\n \n  return c;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n \n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -5.0));\n  vec3 ro = vec3(0.0, 1.2, 20.0);\n \n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  //float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n \n  // Trace ray\n  bool hit;\n  vec3 pos = Trace(ro + rd*near, rd, hit);\n \n  // Shade background\n  vec3 rgb = background(rd);\n \n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n    // Shade\n    rgb = shade(pos, n);\n  }\n \n  fragColor=vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}