{
    "Shader": {
        "info": {
            "date": "1480094449",
            "description": "some code used from Mercury's hg_sdf http://mercury.sexy/hg_sdf/\niq's base raymarch code + 2d and 3d noise \nterrain from https://www.shadertoy.com/view/MsB3WR",
            "flags": 0,
            "hasliked": 0,
            "id": "lltXW7",
            "likes": 1,
            "name": "strange zone 01",
            "published": 3,
            "tags": [
                "zone"
            ],
            "usePreview": 0,
            "username": "macbooktall",
            "viewed": 3314
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\nreturn dot(p, n) + distanceFromOrigin;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\nfloat halfsize = size*0.5;\nfloat c = floor((p + halfsize)/size);\np = mod(p+halfsize, size) - halfsize;\nif (c > stop) { //yes, this might not be the best thing numerically.\np += size*(c - stop);\nc = stop;\n}\nif (c <start) {\np += size*(c - start);\nc = start;\n}\nreturn c;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\nfloat angle = 2.*PI/repetitions;\nfloat a = atan(p.y, p.x) + angle/2.;\nfloat r = length(p);\nfloat c = floor(a/angle);\na = mod(a,angle) - angle/2.;\np = vec2(cos(a), sin(a))*r;\n// For an odd number of repetitions, fix cell index of the cell in -x direction\n// (cell index would be e.g. -5 and 5 in the two halves of the cell):\nif (abs(c) >= (repetitions/2.)) c = abs(c);\nreturn c;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\n\nfloat sdPlane(vec3 p){ \n return p.y;   \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTerrain( vec3 p )\n{\n    if (p.z < 1.) return p.y;\n \tfloat pz = min(1.,p.z*.8);\n    vec2 pos = p.xz;\n\tfloat w = noise(pos*.2)*(mix(2.,3.,pz*.6));\n\tfloat f = .0;\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tf += w * noise(pos);\n       \tw = -w * .2;\n\t\tpos = rotate2D * pos;\n\t}\n\treturn p.y - mix(0., f, pz);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nfloat sdCylinderTube( vec3 p, vec2 h )\n{    \n    float rep = 32.;\n    float n = h.y*1.01/10.;\n    float ri = pModPolar(p.xy, rep);\n    float zi = pModInterval1(p.z, n*2., -5., 5.);\n    p.x -= h.x*0.3;\n    float s = h.x/rep;\n    float box = sdBox(p, vec3(s*(hash(ri*30. + zi*20.)+.1)*1.8, s, n));\n\t \n    return box;\n}\n\n//----------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\nreturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d1);\n}\n\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nfloat roomWidth = .5;\n\nfloat map(vec3 pos, inout float id) {\n\n    vec3 p = pos;\n    p.y += roomWidth*.8;\n    vec2 ground = vec2(sdTerrain(p), 1.0);\n    p.y -= roomWidth*.3;\n    vec2 water = vec2(sdPlane(p), 2.0);\n    \n    float box = 100.;\n\tvec2 moon = vec2(sdSphere(p-vec3(0.75,0.,18.), roomWidth*19.), 4.0);    \n    p += vec3(-0.,-0.0,-1.9);\n\n    box = opU(box,sdCylinderTube(p, vec2(roomWidth*2., roomWidth*3.1)));   \n    \n    p.x += .25;\n    p.z -= .25;\n    for (int i = 0; i <3; i++) // i <3 gemma\n    {\n        float h = hash(float(i*4+10))*roomWidth*1.+roomWidth*.9;\n        p.xz = rotate(p.xz, h*5.);\n\n        box = opU(box,sdBox(p, vec3(roomWidth*.12 + h*0.4*roomWidth, roomWidth +h*1.5, roomWidth*.3+ (1.-h)*0.4*roomWidth)));   \n    }\n   \n    vec2 shape = vec2(box, 3.0);\n    \n    vec2 dist = opU(ground, water);\n\tdist = opU(dist, moon);\n    \n    dist = opU(dist, shape);\n\tid = dist.y;\n    return dist.x;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, inout float id, inout vec3 pos )\n{\n    float tmin = 0.0;\n    float tmax = 40.;\n    \n    float t = tmin;\n    vec3 intersection = ro;\n    for( int i=0; i<40; i++ )\n    {\n        intersection = ro+rd*t;\n    \tfloat res = map( intersection, id );\n        if(  t>tmax ) break;\n        t += res;\n    }\n\n    if( t>tmax ) id=-1.0;\n    pos = intersection;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    float id = 0.;\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n   (map(pos+eps.xyy,id)) - (map(pos-eps.xyy,id)),\n   (map(pos+eps.yxy,id)) - (map(pos-eps.yxy,id)),\n   (map(pos+eps.yyx,id)) - (map(pos-eps.yyx, id)) );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float id = 0.;\n        float dd = map( aopos, id );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nfloat fog(vec3 ro, vec3 rd, float off) {\n    float tmin = 0.0;\n    float tmax = 30.;\n   \t\n    float t = tmin;\n    float sum = 0.;\n \n    for( int i=0; i<30; i++ )\n    {\n    \tvec3 pos = ro+rd*t;\n        pos.x += off;\n        float v = smoothstep(0.,1.,noise(pos*.8));\n        if (t>tmax) break;\n        sum += v * .045;\n        t += .05 + v;\n   \t}\n    \n    return sum;\n}\n\nvec3 ripple(vec3 nor, float off, float d, vec3 rd) {\n \t\n    nor.x += noise(vec2(d*40.+20., rd.x*10.)+off)*0.025;\n    nor.x -= noise(vec2(d+100., rd.x*2.+20.)+off)*0.015;    \n\n    nor.z += noise(vec2(d*0.1+20., rd.x*10.)+off)*0.01;\n\n    return nor;\n}\n    \nvec3 render( in vec3 ro, in vec3 rd )\n{\n    float t = 0.;\n    float refIntensity = 0.;\n    float tt = mod(iTime, 3.14159);\n \tfloat id = 0.;\n    vec3 intersection = vec3(0.);\n    float res = castRay(ro,rd, id, intersection);\n\n    if( id == 2.0 ) {\n        refIntensity = res*0.35;\n        vec3 nor = vec3(0., 1., 0.);\n    \tnor = mix(ripple(nor, tt, 0.1, rd), ripple(nor, tt-3.14159, 0.1, rd), tt/3.14159);\n        rd = reflect(rd, nor);\n        ro = intersection;\n        ro.y += 0.01;\n        res = castRay(ro,rd, id, intersection);\n    }\n \n    t = res;\n\n    vec3 pos = intersection;\n    vec3 nor = calcNormal( pos );\n    float occ = calcAO( pos, nor );\n    vec3 col = cos(0.1 + vec3(0.,0.25,0.2) + t*0.2)*occ*1.1;\n    col = mix(col, vec3(1.), refIntensity);\n   \n    col = mix( col, mix(vec3(0.,0.5,0.5), vec3(1.), refIntensity), max(1.0-exp( -0.1*t ),clamp(t*0.01,0.,1.)) );\n    col = pow(col,vec3(.6));\n    \n    col.r -= mix(fog(ro, rd, tt), fog(ro, rd, tt-3.14159), tt/3.14159);\n  \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\nvec3 cw = normalize(ta-ro);\nvec3 cp = vec3(sin(cr), cos(cr),0.0);\nvec3 cu = normalize( cross(cw,cp) );\nvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    \n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 ro = vec3(-1., 0.1, -1.);\n  \tvec3 ta = ro+vec3(0.35,-0.0,1.);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 rd = ca * normalize(vec3(p.xy,2. + sin(iTime*2.)*0.025));\n    vec3 col = 1.-render( ro, rd );\n\tfragColor=vec4( col, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}