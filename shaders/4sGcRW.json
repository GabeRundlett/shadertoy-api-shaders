{
    "Shader": {
        "info": {
            "date": "1522786372",
            "description": "Shows sampling within a footprint of a given size (e.g. when supersampling for aa, or (re-)sampling a texture)\n(sorry, everything is a bit hardcoded to square texture here for the illustration)",
            "flags": 0,
            "hasliked": 0,
            "id": "4sGcRW",
            "likes": 23,
            "name": "filtering: resampling kernels",
            "published": 3,
            "tags": [
                "blur",
                "filtering",
                "kernel",
                "gauss",
                "lanczos",
                "mitchell",
                "sinc",
                "reconstruction"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 1926
        },
        "renderpass": [
            {
                "code": "//note: started out with http://www.pbrt.org/chapters/pbrt_chapter7.pdf\n//      code also at https://github.com/mmp/pbrt-v3/tree/master/src/filters\n//\n//note: see also https://mynameismjp.wordpress.com/2012/10/28/msaa-resolve-filters/\n//               https://github.com/TheRealMJP/MSAAFilter/blob/master/MSAAFilter/Resolve.hlsl\n//\n// other implementations:\n// https://www.shadertoy.com/view/MllSzX - Bicubic Texture Filtering by demofox\n// https://www.shadertoy.com/view/lsG3D1 - advection filter comparison by sebbbi\n\n\n#define VIS_FILTER_KERNEL\n#define VIS_FILTER_GRAPH\n\n//#define SRGB_CONVERSION\n\n//#define SIEMENS_PATTERN\n\n//#define USE_RADIUS_VERSIONS\n\n//#define FULLRES\n\nfloat Gaussian( float x )\n{\n\tconst float alpha = 4.0;\n\tconst float expv = exp(-alpha); //note: radius = 1.0\n    return max(0.0, (exp(-alpha * x * x) - expv));\n    //return max(0.0, (exp(-alpha * x * x) - expv) / (1.0-expv)); //note: normalisation-factor to always get f(0)=1\n}\nfloat FilterGaussian(vec2 p, vec2 radius )\n{\n    p /= radius; //TODO: fails at radius0\n    \n    #if defined( USE_RADIUS_VERSIONS )\n    return Gaussian( length(p) );\n    #else\n\treturn Gaussian(p.x) * Gaussian(p.y);\n    #endif\n    \n}\n\n//note: range [-2;2]\n//note: not normalized\nfloat Mitchell1D(float x)\n{\n    //const float B = 0.0; //Catmull-Rom?\n\tconst float B = 1.0/3.0; //Mitchell\n\tconst float C = 0.5 * (1.0-B);\n\tx = abs( 2.0 * x );\n    if ( x > 2.0 )\n        return 0.0;\n\tif (x > 1.0)\n\t\treturn ((-B - 6.0*C) * x*x*x + (6.0*B + 30.0*C) * x*x + (-12.0*B - 48.0*C) * x + (8.0*B + 24.0*C)) * (1.0/6.0);\n\telse\n\t\treturn ((12.0 - 9.0*B - 6.0*C) * x*x*x + (-18.0 + 12.0*B + 6.0*C) * x*x + (6.0 - 2.0*B)) * (1.0/6.0);\n}\nfloat FilterMitchell(vec2 p, vec2 r)\n{\n    p /= r; //TODO: fails at radius0\n    #if defined( USE_RADIUS_VERSIONS )\n    return Mitchell1D( length(p) ); //note: radius version...\n    #else\n    return Mitchell1D(p.x) * Mitchell1D(p.y);\n    #endif\n}\n\nfloat Sinc(float x)\n{\n    const float PI = 3.14159265;\n    x = abs(x);\n    if ( x < 1e-5)\n        return 1.0;\n    return sin(PI*x) / (PI*x);\n}\nfloat WindowedSinc( float x )\n{\n    const float tau = 2.0;\n    x = abs(x);\n\tif ( x > 2.0 ) //note: was x>radius, 2.0 is filtersize\n        return 0.0;\n\tfloat lanczos = Sinc( x / tau );\n\treturn Sinc(x) * lanczos;\n}\nfloat FilterLanczosSinc( vec2 p, vec2 dummy_r )\n{\n    #if defined( USE_RADIUS_VERSIONS )\n    return WindowedSinc( length(p) );\n    #else\n    return WindowedSinc( p.x ) * WindowedSinc( p.y );\n\t#endif\n}\n\n// TODO\n/*\n// FSR1\n//lanczos approximation. Input is x*x and must be <= 4.\nfloat Lanczos2ApproxSqNoClamp(float x2)\n{\n    float a = (2.0f / 5.0f) * x2 -1;\n    float b = (1.0f / 4.0f) * x2 -1;\n    return ((25.0f / 16.0f) * a * a - (25.0f / 16.0f 1)) * (b * b);\n}\n*/\n\n\nfloat FilterCubic( vec2 p, vec2 radius )\n{\n    p /= radius; //TODO: fails at radius0\n    return smoothstep( 1.0, 0.0, length(p) );\n}\nfloat FilterTriangle(vec2 p, vec2 radius)\n{\n    p /= radius; //TODO: fails at radius0\n    return clamp(1.0f - length(p), 0.0, 1.0);\n}\n\n\nconst int IDX_GAUSS = 0;\nconst int IDX_MITCHELL = 1;\nconst int IDX_LANCZOSSINC = 2;\nfloat get_filter_size( int idx )\n{\n    if ( idx == IDX_GAUSS )\n    \treturn 1.0; //note: 1.25 matches the 2px filters reasonably\n    else if ( idx == IDX_MITCHELL )\n    \treturn 2.0;\n    else if ( idx == IDX_LANCZOSSINC )\n    \treturn 2.0;\n    else\n        return 1.0;\n}\nfloat calc_weight( vec2 p, vec2 r, int idx )\n{\n    //return FilterTriangle( p, r );\n    //return FilterCubic( p, 1.25*r );\n    \n    if ( idx == IDX_GAUSS )\n    \treturn FilterGaussian( p, r );\n    else if ( idx == IDX_MITCHELL )\n    \treturn FilterMitchell( p, r );\n    else if ( idx == IDX_LANCZOSSINC )\n    \treturn FilterLanczosSinc( p / r * 2.0, r );\n    else\n        return 1.0;\n}\n\n\n#ifdef SRGB_CONVERSION\nvec3 lin2srgb( vec3 c ) { return pow( c, vec3(1.0/2.4) ); }\nvec3 srgb2lin( vec3 c ) { return pow( c, vec3(2.4) ); }\nvec4 lin2srgb( vec4 c ) { return vec4( lin2srgb(c.rgb), c.a ); }\nvec4 srgb2lin( vec4 c ) { return vec4( srgb2lin(c.rgb), c.a ); }\n#else\nvec3 lin2srgb( vec3 c ) { return c; }\nvec3 srgb2lin( vec3 c ) { return c; }\nvec4 lin2srgb( vec4 c ) { return c; }\nvec4 srgb2lin( vec4 c ) { return c; }\n#endif\n\nfloat dbgp( vec2 p, vec2 uv )\n{\n    float pdist = length(p-uv);\n    return clamp( (pdist - 0.0025 ) / (0.005-0.0025), 0.0, 1.0 );\n}\n\nvec4 weight2col( float w )\n{\n    vec4 wcol = mix( vec4(0,0,1,1), vec4(0,1,0,1), w );\n\n    if ( w < 0.0 )\n        wcol = vec4(1,0,0,1);\n\n    return wcol;\n}\n\n//note: siemens star\nfloat pattern_siemens( vec2 p )\n{\n    #if defined( FULLRES )\n    vec2 ctrvec = vec2( p - vec2(0.225, 0.5 ) ); //note: centered\n    #else\n    vec2 ctrvec = vec2( p - vec2(0.05, 0.3 ) );\n    #endif\n    \n    float ctrvec_len = length( ctrvec );\n    ctrvec /= ctrvec_len;\n    \n\tfloat angle = acos( ctrvec.x );\n    if ( sign(ctrvec.y) < 0.0 )\n        angle = 6.283185307 - angle;\n\n    float its = step( 0.0, sin(100.0*angle));\n    //its *= step( ctrvec_len, 0.5 ); //bound to circle\n    \n    return its;\n}\nfloat pattern_circular( vec2 p )\n{\n    #if defined( FULLRES )\n    vec2 ctr = vec2( vec2(0.225, 0.5 ) ); //note: centered\n    #else\n    vec2 ctr = vec2( vec2(0.05, 0.3 ) );\n    #endif\n\n    float d = length( p - ctr );\n    return 0.5 + 0.5 * cos(35.0*3.14*d);\n}\nfloat pattern( vec2 p )\n{\n    return pattern_siemens( p );\n    //return pattern_circular( p );\n}\n\n\n\nstruct blurout\n{\n    vec4 outcol;\n    vec4 dbgcol;\n};  \nblurout blur( sampler2D smpl, vec2 uv, vec2 p, float filtersiz_nm_ch0, vec2 ch0siz, int idx )\n{\n    float filtersiz = get_filter_size( idx );\n\n    vec2 pq = (floor( p*ch0siz ) + vec2(0.5,0.5) ) / ch0siz;\n    \n    blurout ret;\n    ret.dbgcol = vec4(0);\n    vec4 bb_nm = vec4( pq - vec2(filtersiz_nm_ch0),\n                       pq + vec2(filtersiz_nm_ch0));\n    vec4 bb_px_q = vec4( floor( bb_nm.xy * ch0siz.xy ),\n                          ceil( bb_nm.zw * ch0siz.xy ) );\n    vec4 bb_nm_q = bb_px_q / ch0siz.xyxy;\n    ivec2 bb_px_siz = ivec2( bb_px_q.zw - bb_px_q.xy );\n\n    vec4 sumc = vec4(0.0);\n    float sumw = 0.0;\n    for ( int y=0; y<bb_px_siz.y; ++y )\n    {\n        for ( int x=0; x<bb_px_siz.x; ++x )\n        {\n            vec2 xy_f = (vec2(x,y)+vec2(0.5))/vec2(bb_px_siz);\n            vec2 sp = bb_nm_q.xy + (bb_nm_q.zw-bb_nm_q.xy)*xy_f;\n\n            float w = calc_weight( sp-p, vec2(filtersiz_nm_ch0), idx );\n            \n            #if defined( SIEMENS_PATTERN )\n            sumc += w*srgb2lin( vec4(pattern(sp)) );\n            #else\n            sumc += w*srgb2lin(textureLod( iChannel0, sp, 0.0 ));\n            //sumc += w*srgb2lin(texelFetch( iChannel0, ivec2(sp*ch0siz), 0 )); //TODO: explicit clamp-to-edge\n            #endif\n            \n            sumw += w;\n\n            ret.dbgcol = mix( weight2col(w), ret.dbgcol, dbgp(sp, uv) );\n        }\n    }\n\n    ret.outcol = sumc / sumw;\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if defined( FULLRES )\n    vec2 c = iResolution.xx/iChannelResolution[0].xx; //note: fullres\n    #else\n    vec2 c = vec2(1.0);\n    #endif\n    \n    vec2 ch0siz = c * iChannelResolution[0].xy; //TODO: input RT and cutout from that\n    \n    vec2 ssuv = fragCoord/iResolution.xy;\n    \n    vec2 uv = fragCoord/iResolution.yy;\n    uv.x = mod( uv.x, 0.25 * iResolution.x/iResolution.y );\n    \n    int BLURINDEX = int( ssuv.x * 4.0) - 1;\n    float filtersiz = get_filter_size( BLURINDEX );\n\n    //note: radius\n    const float MIN_BLUR_SIZ_PX = 1.0;\n\tconst float MAX_BLUR_SIZ_PX = 5.0;\n\n    float footprintsiz_t = clamp(0.5 + 0.6 * sin(iTime), 0.0, 1.0);\n    float footprintsiz_px = mix( MIN_BLUR_SIZ_PX, MAX_BLUR_SIZ_PX, footprintsiz_t );\n    float footprintsiz_nm_ch0 = footprintsiz_px / ch0siz.y;\n    \n    if ( ssuv.x < 0.25 )\n    {\n        #if defined( SIEMENS_PATTERN )\n        fragColor = srgb2lin( vec4(pattern(uv)));\n        #else\n        fragColor = vec4(srgb2lin(texture(iChannel0, uv, -10.0 )).rrr,1);\n        #endif\n    }\n    else\n    {\n        vec2 uv_q = (floor( uv * ch0siz ) + vec2(0.5) ) / ch0siz;\n\t    blurout blurout = blur( iChannel0, uv, uv_q, footprintsiz_nm_ch0 * filtersiz, ch0siz, BLURINDEX );\n        fragColor = vec4( blurout.outcol.rrr, 1.0 );\n    }\n\n\n    //note: sampling visualisation\n    {\n        vec2 mousepos = iMouse.xy;\n        mousepos.x = mod( mousepos.x, iResolution.x/4.0 );\n        vec2 p = (iMouse.z>0.5) ? mousepos/iResolution.yy*ch0siz.xy : vec2( 11.5, 29.5 );\n        p /= ch0siz;\n\n        blurout dbgout = blur( iChannel0, uv, p, footprintsiz_nm_ch0*filtersiz, ch0siz, BLURINDEX );\n\n        //note: show dbg-sampled color\n        //if ( uv.y > 0.95 )\n        //    fragColor = dbgout.outcol.rrrr;\n\n        #if defined( VIS_FILTER_KERNEL )\n        fragColor = mix( fragColor, dbgout.dbgcol, dbgout.dbgcol.a );\n        \n        float pdist = length(p-uv);\n\n        //note: circle1\n        float cdist = pdist - footprintsiz_nm_ch0;\n        float itsc = clamp( abs(cdist) / 0.0025, 0.0, 1.0 );\n        fragColor = mix( vec4(1,1,0,0), fragColor, itsc );\n        \n        //note: circle2\n        cdist = pdist - 2.0 * footprintsiz_nm_ch0;\n        itsc = clamp( abs(cdist) / 0.0025, 0.0, 1.0 );\n        fragColor = mix( vec4(1,0.9,0,0), fragColor, itsc );\n        #endif //VIS_FILTER_KERNEL\n\n        \n        #if defined( VIS_FILTER_GRAPH )\n        if ( ssuv.y < 0.2 )\n        {\n            vec2 luv = vec2( fract(4.0 * ssuv.x), ssuv.y / 0.2 );\n            luv.x = luv.x * 5.0 - 2.5;\n            luv.y = luv.y * 1.3 - 0.2;\n\n            float f = calc_weight( vec2(luv.x, 0.0), vec2(filtersiz), BLURINDEX );\n            float s = step( luv.y, f );\n            fragColor = mix( vec4(vec3(0.125),1), weight2col( f ), s );\n            \n            if (   abs(luv.y) < 0.0125 || abs(abs(luv.y)-1.0) < 0.0125\n                || abs(luv.x) < 0.025 )\n\n            {\n                fragColor.rgb += 0.25;\n            }\n            \n            if ( abs(abs(luv.x)-1.0) < 0.0126 )\n                fragColor = vec4( 1, 1, 0, 0 );\n            \n            if ( abs(abs(luv.x)-2.0) < 0.0126 )\n                fragColor = vec4( 1, 0.9, 0, 0 );\n            \n            //note: mark actual filtersize\n            //if ( abs(luv.x) > filtersiz ) { fragColor = mix( fragColor, vec4(0.25), 0.5 ); return; }\n\n            //TODO: COULD mark individual samples for current filtersize...\n            \n            fragColor = srgb2lin(fragColor);\n        }\n        #endif //VIS_FILTER_VIS\n    }\n\n    fragColor.rgb *= step( 0.0025, mod(ssuv.x,0.25) ); //note: black lines\n\n    fragColor.rgb = lin2srgb( fragColor.rgb );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}