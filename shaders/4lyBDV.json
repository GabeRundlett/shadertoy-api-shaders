{
    "Shader": {
        "info": {
            "date": "1544042370",
            "description": "Visualization of raymarching using 2D signed distance functions. With the mouse you can choose a direction for the \"camera\", located near bottom right corner. Automatically you see travel of the ray throught the distance field until it hits the \"world\".",
            "flags": 0,
            "hasliked": 0,
            "id": "4lyBDV",
            "likes": 25,
            "name": "Visualizing Raymarching",
            "published": 3,
            "tags": [
                "2d",
                "raymarching",
                "tutorial",
                "steps",
                "section"
            ],
            "usePreview": 0,
            "username": "josemorval",
            "viewed": 967
        },
        "renderpass": [
            {
                "code": "#define STEPS 10\n#define ANIMDIR mouse.x-mouse.y>0.75\n#define VELANIMDIR 0.5\n#define ANIMRAY false\n#define VELANIMRAY 10.\n\nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox(vec2 p, vec2 r){\n    vec2 d = abs(p)-r;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n    //return max(abs(p.x)-r.x,abs(p.y)-r.y);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//Signed distance scene (one square and four circles)\nfloat scene(vec2 p){\n    \n    float res = sdCircle(p+vec2(-0.3,-0.5),0.25);\n    res = min(res,sdCircle(p+vec2(-1.5,-0.1),0.4));\n    res = min(res,sdCircle(p+vec2(0.3,0.2),0.1));\n    res = min(res,sdCircle(p+vec2(1.2,-0.7),0.2));\n    res = min(res,sdBox(p+vec2(1.2,-0.0),vec2(0.1,0.8)));\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1. + 2. * fragCoord.xy/iResolution.xy;\n    vec2 p = uv;\n    p.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    //Here we draw the scene\n    float res = scene(p);\n    \n    //We make some kind of posterize over distances\n    res = floor(res*15.)/15.;\n    \n    //Some colour based on distances\n    float att =(1.+0.1*(0.5+0.5*sin(-15.*abs(res)+3.*iTime)));\n    if(res<0.){\n    col = 5.*vec3(0.,0.5,1.)*abs(res)*att;\n    }else{\n    col = 1.*vec3(1.,0.5,0.)*(abs(res)*1.1)*att;\n    }\n    \n    vec2 inipos = vec2(1.1,-0.8);\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse-=0.5;\n    mouse.x *= iResolution.x/iResolution.y;\n    \n    //We decide if we like a direction vector animated (simple) or no\n    vec2 dir;\n    if(ANIMDIR){\n        float angle = 3.14159/1.3+1.6*sin(VELANIMDIR*iTime);\n        dir = normalize(vec2(cos(angle),sin(angle))-inipos);  \n    }else{\n    \tdir = normalize(vec2(2.*mouse.x,2.*mouse.y)-inipos);    \n    }\n    \n\t\n    //Here we \"fake\" a raymarching ray, but it is the core of 3D raymarching\n    //Because there no raymarching in 2D, in this case,each pixel knows automatically its distance to the scene\n    \n    float dis = 0.;\n    float c = 0.;\n    float a = 0.;\n    \n    vec2 pos = inipos;\n    for(int i=0;i<STEPS;i++){\n\t\t\n        //Animated raymarch\n        if(ANIMRAY && mod(floor(VELANIMRAY*iTime),float(STEPS))<float(i)){\n        \tbreak;   \n        }\n        \n        //Raymarch core/////\n        pos+=dis*dir;\n        dis = scene(pos);\n        if(dis<0.001) break;\n        ////////////////////\n        \n        //Drawing stuff\n        if(i==0){\n            //Camera position, a annulus with an animated radii\n            c = 1.-smoothstep(0.0,0.003,abs(sdCircle(sin(p-pos),0.05+0.005*sin(10.*iTime)))-0.005);\n        \tcol =  mix(col,vec3(1.,1.,1.),0.5*c);\n        }else{\n            //Steps points, color based on step number\n        \tc = sdCircle(p-pos,0.01);\n         \ta = 3.14159*float(i)/(float(STEPS)+1.);\n        \tcol =  mix(col,\n                   vec3(sin(a),cos(a),0.),\n                   (1.-step(0.,c)));   \n        }\n\n        \n        //Distance region circle: in raymarch you can move in any direction inside this circle\n        //because you have enough distance to move. The color is based in step number of raymarch\n        c = sdCircle(p-pos,dis);\n        col += mix(vec3(0.),0.2*vec3(sin(a),cos(a),0.),(1.-smoothstep(0.0,0.005,c)));\n        \n        //Distance region circumference: only for visual purposes\n        c = abs(sdCircle(p-pos,dis))-0.001;\n        col = mix(col,0.75*col,(1.-smoothstep(0.0,0.05,c)));\n        col += mix(vec3(0.),0.75*vec3(0.5,0.5,0.),(1.-smoothstep(0.0,0.005,c)));\n\n    }\n    \n    //Raymarch ray: only for visual purposes\n    c = sdLine(p,inipos,pos,0.001);\n    col = mix(col,0.75*col,(1.-smoothstep(0.0,0.05,c)));\n    col += mix(vec3(0.),0.5*vec3(1.,1.,1.),(1.-smoothstep(0.0,0.005,c)));\n    \n    \n    //Show the color\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}