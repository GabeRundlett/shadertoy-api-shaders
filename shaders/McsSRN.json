{
    "Shader": {
        "info": {
            "date": "1705014013",
            "description": "multisampled toroidal ",
            "flags": 0,
            "hasliked": 0,
            "id": "McsSRN",
            "likes": 9,
            "name": "Hypno Toroid",
            "published": 3,
            "tags": [
                "hypno",
                "toroid"
            ],
            "usePreview": 0,
            "username": "qwert33",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\n// Stolen from MIT licensed code be Iq https://www.shadertoy.com/view/4sBGDy\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n\nvoid mainImage2( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.xy;\n    vec3 look_at = vec3(0);\n    float t_r = .55;\n    float k = 0.8, mx = -2.*iMouse.x /iResolution.x + .2, my = .5*((iMouse.y)/iResolution.y - .5);\n    vec3 ro = vec3(k*sin(mx), my, k*cos(mx));\n    vec3 f = normalize(vec3(ro - look_at));\n    vec3 r = normalize(cross(vec3(0, 1, 1), f));\n    vec3 u = cross(f, r);\n\tfloat zoom = 1.1;\n   \tvec3 i = ro - zoom * f + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i-ro);\n    vec3 col = vec3(0.);\n    \n    float d = 0., dr;\n   \tvec3 p;\n    /*  \n    // raymarch\n    for(int i = 0; i < 32; i++){\n        p = ro + rd * d;\n        dr = -(length(vec2(length(p.xz)-t_r, p.y)) - .5);\n        if(dr < .0001 || dr > 1e5) break;\n        \n        d += dr;\n    } */\n    d = iTorus(ro.xzy, rd.xzy, vec2(0.6, t_r));\n    p = ro + rd * d;\n    //fragColor = vec4(d, -d, 0, 1);\n    //return;\n    {\n        float fi = atan(p.z, p.x);\n        float r = atan(p.y, length(p.xz)-t_r);\n        float bands = cos(fi*-5. + r*15. + iTime*5.);\n        float f = .5 * fwidth(bands);\n        if (iMouse.z > 0.) {\n            f = .1;\n        }\n        float b1 = smoothstep(-f, f, bands);\n        float b2 = smoothstep(-f, f, bands - .5);\n        col += b1;  \n        }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 foo;\n    fragColor = vec4(0.);\n    float r = .01;\n    for (float dy = -r; dy <= r; dy += r) {\n        for (float dx = -r; dx <= r; dx += r) {\n            mainImage2(foo, fragCoord + vec2(dx, dy));\n            fragColor += foo;\n        }\n    }\n    fragColor /= 9.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}