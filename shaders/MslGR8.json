{
    "Shader": {
        "info": {
            "date": "1362747060",
            "description": "See http://loopit.dk/banding_in_games.pdf for details.\nTest for various ways of removing banding, including a number of different dithering patterns and a color-offset algorithm for purely grayscale images.",
            "flags": 0,
            "hasliked": 0,
            "id": "MslGR8",
            "likes": 158,
            "name": "dithering: Color Banding Removal",
            "published": 3,
            "tags": [
                "noise",
                "banding",
                "grayscale",
                "color",
                "dither",
                "dithering"
            ],
            "usePreview": 0,
            "username": "hornet",
            "viewed": 26404
        },
        "renderpass": [
            {
                "code": "//#define ANIMATED\n//#define CHROMATIC\n\n\n//note: from https://www.shadertoy.com/view/4djSRW\n// This set suits the coords of of 0-1.0 ranges..\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// ====\n/*\n//note: outputs x truncated to n levels\nfloat trunc( float x, float n )\n{\n\treturn floor(x*n)/n;\n}*/\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\nvec4 bluenoise( vec2 fc )\n{\n    return texture( iChannel2, fc / iChannelResolution[2].xy );\n}\n//note: works for structured patterns too\n// [0;1[\nfloat remap_pdf_tri_unity( float v )\n{\n    v = v*2.0-1.0;\n    v = sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n\n    //return v; //note: [-1;1[\n    return 0.5 + 0.5*v; //note: [0;1[\n}\n\n\n// note: valve edition\n//       from http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf\n// note: input in pixels (ie not normalized uv)\nvec3 ScreenSpaceDither( vec2 vScreenPos )\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n\t//vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime ) );\n    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy ) );\n    vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) );\n    \n    //note: apply triangular pdf\n    //vDither.r = remap_noise_tri_erp(vDither.r)*2.0-0.5;\n    //vDither.g = remap_noise_tri_erp(vDither.g)*2.0-0.5;\n    //vDither.b = remap_noise_tri_erp(vDither.b)*2.0-0.5;\n    \n    return vDither.rgb / 255.0; //note: looks better without 0.375...\n\n    //note: not sure why the 0.5-offset is there...\n    //vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) ) - vec3( 0.5, 0.5, 0.5 );\n\t//return (vDither.rgb / 255.0) * 0.375;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = ( fragCoord.xy / iResolution.xy );\n\n    const float c0 = 32.0;\n    \n    #if defined( ANIMATED )\n\tfloat its = mix( 0.0, 1.0 / c0, pos.x + 0.25*sin(0.5*iTime) );\n    #else\n    float its = mix( 0.0, 1.0 / c0, pos.x );\n    #endif\n    \n\tvec3 outcol;\n\n    if ( pos.y > 11.0/12.0 )\n\t{\n\t\toutcol = vec3(its);\n\t}\n\telse if ( pos.y > 10.0/12.0 )\n\t{\n\t\toutcol = vec3( its + 0.5 / 255.0 ); //rounded\n\t}\n\telse if ( pos.y > 9.0/12.0 )\n\t{\n\t\t//note: scanline dithering\n\t\tfloat ofs = floor(mod(fragCoord.y,2.0))*0.5;\n\t\toutcol = vec3( its + ofs/255.0);\t\t\n\t}\n\telse if( pos.y > 8.0/12.0)\n\t{\n        //note: offset r, g, b, limbo-style\n\t\toutcol = vec3(its, its + 1.0/3.0/256.0, its + 2.0/3.0/256.0);\t\t\n        \n\t\t//note: \"luminance\" incr\n\t\t//float e = its - trunc( its, 255.0 ); // = fract( 255.0 * its ) / 255.0;\n\t\t//vec2 rg = mod( floor( vec2(4.0,2.0) * e * 255.0), 2.0 );\n\t\t//outcol = floor( its*255.0 )/255.0 + vec3(rg,0.0) / 255.0;\t\t\n\t}\n    else if ( pos.y > 7.0/12.0 )\n    {\n        //note: 2x2 ordered dithering, ALU-based (omgthehorror)\n\t\tvec2 ij = floor(mod( fragCoord.xy, vec2(2.0) ));\n\t\tfloat idx = ij.x + 2.0*ij.y;\n\t\tvec4 m = step( abs(vec4(idx)-vec4(0,1,2,3)), vec4(0.5) ) * vec4(0.75,0.25,0.00,0.50);\n\t\tfloat d = m.x+m.y+m.z+m.w;\n\n        /*\n        //note: alternative, from https://www.shadertoy.com/view/XtV3RG\n        #define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n\n        //some more optimizations, using bitwise ops\n        float GetBayerFromCoordLevel(vec2 pixelpos)\n        {\n            ivec2 ppos = ivec2(pixelpos);\n            int sum = 0;\n            for(int i=0; i<MAX_LEVEL; i++)\n            {\n                sum += bayer2x2(ppos>>(MAX_LEVEL-1-i)&1)<<(2*i);\n            }\n\n            return float(sum) / float(2<<(MAX_LEVEL*2-1));\n        }\n        */\n\n\n\t\t//alternative version, from https://www.shadertoy.com/view/MdXXzX\n\t\t//vec2 n = floor(abs( fragCoord.xy ));\n\t\t//vec2 s = floor( fract( n / 2.0 ) * 2.0 );\n\t\t//float f = (  2.0 * s.x + s.y  ) / 4.0;\n\t\t//float rnd = (f - 0.375) * 1.0;\n\t\t//outcol = vec3(its + rnd/255.0 );\n\t\t\n\t\toutcol = vec3( its + d/255.0 );\n    }\n\telse if ( pos.y > 6.0/12.0 )\n\t{\n\t\t//note: 8x8 ordered dithering, texture-based\n\t\tconst float MIPBIAS = -10.0;\n\t\tfloat ofs = texture( iChannel0, fragCoord.xy/iChannelResolution[0].xy, MIPBIAS ).r;\n\n\t\toutcol = vec3( its + ofs/255.0 );\n\t}\n    else if ( pos.y > 5.0/12.0 )\n    {\n        vec2 seed = fragCoord.xy;\n        #if defined( ANIMATED )\n        seed += 1337.0*fract(iTime);\n        #endif\n\n        float rnd = InterleavedGradientNoise( seed );\n        //rnd = remap_noise_tri_erp(rnd)*2.0-0.5; //note: terrible pattern\n        \n        #ifdef CHROMATIC\n        outcol = its + vec3(rnd, 1.0-rnd, rnd)/255.0;\n        #else\n        outcol = its + vec3(rnd/255.0);\n        #endif\n        \n        \n    }\n\telse if( pos.y > 4.0/12.0 )\n\t{\n        vec3 rnd = ScreenSpaceDither( fragCoord );\n        #ifdef CHROMATIC\n\t\toutcol = vec3(its) + rnd;\n        #else\n        outcol = vec3(its) + rnd.g;\n        #endif\n\t}\n    else if( pos.y > 3.0/12.0 )\n    {\n        //note: from comment by CeeJayDK\n\t\tfloat dither_bit = 8.0; //Bit-depth of display. Normally 8 but some LCD monitors are 7 or even 6-bit.\t\n\n\t\t//Calculate grid position\n\t\tfloat grid_position = fract( dot( fragCoord.xy - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n\n\t\t//Calculate how big the shift should be\n\t\tfloat dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\t#ifdef CHROMATIC\n        vec3 dither_shift_RGB = vec3(dither_shift, -dither_shift, dither_shift); //subpixel dithering\n        #else\n        vec3 dither_shift_RGB = vec3(dither_shift, dither_shift, dither_shift); //non-chromatic dithering\n        #endif\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position); //shift acording to grid position.\n\n\t\t//shift the color by dither_shift\n\t\toutcol = its + 0.5/255.0 + dither_shift_RGB; \n    }\n    else if ( pos.y > 2.0/12.0 )\n\t{\n        vec2 seed = fragCoord.xy;\n        #if defined( ANIMATED )\n        seed += 1337.0*fract(iTime);\n        #endif\n        \n        #ifdef CHROMATIC\n        vec3 bn = bluenoise(seed).rgb;\n        vec3 bn_tri = vec3( remap_noise_tri_erp(bn.x), \n                            remap_noise_tri_erp(bn.y), \n                            remap_noise_tri_erp(bn.z) );\n        outcol = vec3(its) + (bn_tri*2.0-0.5)/255.0;\n        #else\n        float bn = bluenoise(seed).r;\n        float bn_tri = remap_pdf_tri_unity(bn);\n        outcol = vec3(its) + (bn_tri*2.0-0.5)/255.0;\n        #endif\n\t}\n    else if ( pos.y > 1.0/12.0 )\n    {\n        //note: triangluarly distributed noise, 1.5LSB\n        vec2 seed = pos;\n        #if defined( ANIMATED )\n        seed += fract(iTime);\n        #endif\n        \n        #ifdef CHROMATIC\n\t\tvec3 rnd = hash32( seed ) + hash32(seed + 0.59374) - 0.5;\n        #else\n        vec3 rnd = vec3(hash12( seed ) + hash12(seed + 0.59374) - 0.5 );\n        #endif\n        \n\t\toutcol = vec3(its) + rnd/255.0;\n    }\n\telse\n\t{\n        //note: uniform noise by 1 LSB\n\t\t//note: better to use separate rnd for rgb\n        vec2 seed = pos;\n        #if defined( ANIMATED )\n        seed += fract(iTime);\n        #endif\n        \n        #ifdef CHROMATIC\n\t\tvec3 rnd = hash32( seed ); \n        #else\n        vec3 rnd = vec3( hash12( seed ) );\n        #endif\n\t\t\n\t\t//note: texture-based\n\t\t//const float MIPBIAS = -10.0;\n\t\t//vec2 uv = fragCoord.xy / iChannelResolution[1].xy + vec2(89,27)*fract(iTime);\n\t\t//float rnd = texture( iChannel1, uv, MIPBIAS ).r;\n\t\t\n\t\toutcol = vec3( its ) + rnd/255.0;\n\t}\n\n\toutcol.rgb = floor( outcol.rgb * 255.0 ) / 255.0;\n    outcol.rgb *= c0;\n\n    //note: black bars\n    outcol -= step( mod(pos.y, 1.0/12.0), 0.0025);\n\n\tfragColor= vec4( outcol, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}