{
    "Shader": {
        "info": {
            "date": "1505487609",
            "description": "I was inspired by my PC wallpaper (https://goo.gl/T12YEj), and the PS3 / PS4 animated wallpaper.  Just wanted to make a fun, flowy mess of vector lines!",
            "flags": 0,
            "hasliked": 0,
            "id": "ltXczj",
            "likes": 163,
            "name": "Plasma Waves",
            "published": 3,
            "tags": [
                "2d",
                "antialiasing",
                "aa",
                "fourier"
            ],
            "usePreview": 0,
            "username": "scarletshark",
            "viewed": 7846
        },
        "renderpass": [
            {
                "code": "/* This work is protected under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * more information canbe found at:\n * https://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US\n */\n\nconst float overallSpeed = 0.2;\nconst float gridSmoothWidth = 0.015;\nconst float axisWidth = 0.05;\nconst float majorLineWidth = 0.025;\nconst float minorLineWidth = 0.0125;\nconst float majorLineFrequency = 5.0;\nconst float minorLineFrequency = 1.0;\nconst vec4 gridColor = vec4(0.5);\nconst float scale = 5.0;\nconst vec4 lineColor = vec4(0.25, 0.5, 1.0, 1.0);\nconst float minLineWidth = 0.02;\nconst float maxLineWidth = 0.5;\nconst float lineSpeed = 1.0 * overallSpeed;\nconst float lineAmplitude = 1.0;\nconst float lineFrequency = 0.2;\nconst float warpSpeed = 0.2 * overallSpeed;\nconst float warpFrequency = 0.5;\nconst float warpAmplitude = 1.0;\nconst float offsetFrequency = 0.5;\nconst float offsetSpeed = 1.33 * overallSpeed;\nconst float minOffsetSpread = 0.6;\nconst float maxOffsetSpread = 2.0;\nconst int linesPerGroup = 16;\n\nconst vec4[] bgColors = vec4[]\n    (\n        lineColor * 0.5,\n        lineColor - vec4(0.2, 0.2, 0.7, 1)\n        );\n\n#define drawCircle(pos, radius, coord) smoothstep(radius + gridSmoothWidth, radius, length(coord - (pos)))\n\n#define drawSmoothLine(pos, halfWidth, t) smoothstep(halfWidth, 0.0, abs(pos - (t)))\n\n#define drawCrispLine(pos, halfWidth, t) smoothstep(halfWidth + gridSmoothWidth, halfWidth, abs(pos - (t)))\n\n#define drawPeriodicLine(freq, width, t) drawCrispLine(freq / 2.0, width, abs(mod(t, freq) - (freq) / 2.0))\n\nfloat drawGridLines(float axis)   \n{\n    return   drawCrispLine(0.0, axisWidth, axis)\n           + drawPeriodicLine(majorLineFrequency, majorLineWidth, axis)\n           + drawPeriodicLine(minorLineFrequency, minorLineWidth, axis);\n}\n\nfloat drawGrid(vec2 space)\n{\n    return min(1., drawGridLines(space.x)\n                  +drawGridLines(space.y));\n}\n\n// probably can optimize w/ noise, but currently using fourier transform\nfloat random(float t)\n{\n    return (cos(t) + cos(t * 1.3 + 1.3) + cos(t * 1.4 + 1.4)) / 3.0;   \n}\n\nfloat getPlasmaY(float x, float horizontalFade, float offset)   \n{\n    return random(x * lineFrequency + iTime * lineSpeed) * horizontalFade * lineAmplitude + offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 space = (fragCoord - iResolution.xy / 2.0) / iResolution.x * 2.0 * scale;\n    \n    float horizontalFade = 1.0 - (cos(uv.x * 6.28) * 0.5 + 0.5);\n    float verticalFade = 1.0 - (cos(uv.y * 6.28) * 0.5 + 0.5);\n\n    // fun with nonlinear transformations! (wind / turbulence)\n    space.y += random(space.x * warpFrequency + iTime * warpSpeed) * warpAmplitude * (0.5 + horizontalFade);\n    space.x += random(space.y * warpFrequency + iTime * warpSpeed + 2.0) * warpAmplitude * horizontalFade;\n    \n    vec4 lines = vec4(0);\n    \n    for(int l = 0; l < linesPerGroup; l++)\n    {\n        float normalizedLineIndex = float(l) / float(linesPerGroup);\n        float offsetTime = iTime * offsetSpeed;\n        float offsetPosition = float(l) + space.x * offsetFrequency;\n        float rand = random(offsetPosition + offsetTime) * 0.5 + 0.5;\n        float halfWidth = mix(minLineWidth, maxLineWidth, rand * horizontalFade) / 2.0;\n        float offset = random(offsetPosition + offsetTime * (1.0 + normalizedLineIndex)) * mix(minOffsetSpread, maxOffsetSpread, horizontalFade);\n        float linePosition = getPlasmaY(space.x, horizontalFade, offset);\n        float line = drawSmoothLine(linePosition, halfWidth, space.y) / 2.0 + drawCrispLine(linePosition, halfWidth * 0.15, space.y);\n        \n        float circleX = mod(float(l) + iTime * lineSpeed, 25.0) - 12.0;\n        vec2 circlePosition = vec2(circleX, getPlasmaY(circleX, horizontalFade, offset));\n        float circle = drawCircle(circlePosition, 0.01, space) * 4.0;\n        \n        \n        line = line + circle;\n        lines += line * lineColor * rand;\n    }\n    \n    fragColor = mix(bgColors[0], bgColors[1], uv.x);\n    fragColor *= verticalFade;\n    fragColor.a = 1.0;\n    // debug grid:\n    //fragColor = mix(fragColor, gridColor, drawGrid(space));\n    fragColor += lines;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}