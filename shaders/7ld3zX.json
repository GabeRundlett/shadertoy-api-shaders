{
    "Shader": {
        "info": {
            "date": "1636599879",
            "description": "Final implementation of my water bottle.  Thanks to Reinder for IBL code.\n\nUnfortunately somewhat slow, at least on my laptop chip.  I found it hard to get the precision needed for the thin walls of the bottle without using a fairly high step count.",
            "flags": 32,
            "hasliked": 0,
            "id": "7ld3zX",
            "likes": 16,
            "name": "Cat Bottle",
            "published": 3,
            "tags": [
                "renderer"
            ],
            "usePreview": 1,
            "username": "orangeflea215",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n\n//Set to a higher integer for better aa (at a steep performance cost), if desired\n#define SAMPLES 1\n#define ZERO (min(iFrame,0))\n\n#define MAX_LOD 8.\n#define DIFFUSE_LOD 6.75\n\nfloat PI = 3.14159;\nint maxSteps = 256;\nfloat minStepSize = 0.00005;\nfloat e = .0001;\n\nfloat shadowBias = .01;\n\n//IBL Code from https://www.shadertoy.com/view/lscBW4\n//Thanks to reinder for the implementation\n\nvec3 getSpecularLightColor( vec3 N, float roughness ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return pow(textureLod(iChannel0, N, roughness * MAX_LOD).rgb, vec3(4.5)) * 6.5;\n}\n\nvec3 getDiffuseLightColor( vec3 N ) {\n    // This is not correct. You need to do a look up in a correctly pre-computed HDR environment map.\n    return .25 +pow(textureLod(iChannel0, N, DIFFUSE_LOD).rgb, vec3(3.)) * 1.;\n}\n\n//\n// Modified FrenelSchlick: https://seblagarde.wordpress.com/2011/08/17/hello-world/\n//\nvec3 FresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//\n// Image based lighting\n//\n\nvec3 lighting(in vec3 rayDirection, in vec3 N, in vec3 albedo, in float ao, in float roughness, in float metallic ) {\n    vec3 V = rayDirection;\n    vec3 R = reflect(-V, N);\n    float NdotV = max(0.0, dot(N, V));\n\n    vec3 F0 = vec3(0.08); \n    F0 = mix(F0, albedo, metallic);\n\n    vec3 F = FresnelSchlickRoughness(NdotV, F0, roughness);\n\n    vec3 kS = F;\n\n    vec3 prefilteredColor = getSpecularLightColor(R, roughness);\n    vec2 envBRDF = texture(iChannel3, vec2(NdotV, roughness)).rg;\n    vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n\n    vec3 kD = vec3(1.0) - kS;\n\n    kD *= 1.0 - metallic;\n\n    vec3 irradiance = getDiffuseLightColor(N);\n\n    vec3 diffuse  = albedo * irradiance;\n    vec3 color = kD * diffuse + specular;\n    return color;\n}\n\n/*Not using point lights anymore*/\n\n/*//Point light\n//Intensity at distance of 1 unit\nfloat lInt = 10.0;\nvec3 lCol = vec3(0.2, 1.0, 0.0);\nvec3 lPos = vec3(-2.0, 2.0, -2.0);\n\n//Point light 2\n//Intensity at distance of 1 unit\nfloat lInt2 = 10.0;\nvec3 lCol2 = vec3(1.0, 0.2, 0.0);\nvec3 lPos2 = vec3(2.0, 2.0, -2.0);\n\n//Ambient light\nvec3 ambCol = vec3(0.2,0.2,0.2);\n*/\n\n//Camera\nfloat fov = 50.0 * 2.0 * 3.14159/360.0;\nvec3 camPos = vec3(0.0, 2.0, -9.0);\nvec3 camTar = vec3(0.0, 1.0, 0.0);\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//SDFs\n\n//Sphere\n\nfloat sphereSDF(float d, float r){\n    return d - r;\n}\n\n//Plane\nfloat planeSDF(vec3 d, float l, float w){\n    return max(abs(d.x) - w/2.0,0.0) + max(abs(d.z) - l/2.0,0.0) + abs(d.y);\n}\n\nfloat roundedCylinderSDF (vec3 p, float ra, float rb, float h){\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat cylinderSDF (vec3 p, float ra, float h){\n    vec2 d = vec2( length(p.xz)-ra, abs(p.y) - h/2.0 );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat bottleSDF(vec3 d, float r, float h, float bottomRad, float numLines, float radLines, float midHeight){\n    float topHeight = .3;\n    float bottomHeight = 1.0 - topHeight - midHeight;\n    vec3 bottomCenterVec = d + h * vec3(0.0, .5 - (bottomHeight/2.0),0.0);\n    float bottomCenterDist = cylinderSDF(bottomCenterVec, r, h*bottomHeight);\n    bottomCenterDist -= bottomRad;//bottomRad;\n    \n    vec3 topCenterVec = d - h * vec3(0.0, .5 - (topHeight/2.0),0.0);\n    float topCenterDist = cylinderSDF(topCenterVec, r, h*topHeight);\n    topCenterDist -= bottomRad;//bottomRad;\n    \n    vec2 distV = vec2(length(d.xz) - r, abs(d.y) - h/2.0);\n    //return length(d.xz) - r ;//+ abs(d.y) - h/2.0;\n    float dist = (min(max(distV.x,distV.y),0.0) + length(max(distV,0.0)));\n    float adder = min(length(distV.x) - bottomCenterDist,bottomRad);\n    float tadder = min(bottomRad,length(distV.x) - topCenterDist);\n    \n    float bottomCenterYDist = (bottomHeight*h/2.0) + bottomRad  - abs(bottomCenterVec.y);    \n    float topCenterYDist = (topHeight*h/2.0) + bottomRad  - abs(topCenterVec.y);\n    \n    float segHeight = bottomHeight * h / numLines;\n    //Distance from bottom of bottle\n    float bottomYDist = d.y + .5;\n    vec2 lineDist = vec2(abs(length(d.xz) - r - bottomRad), abs(mod(bottomYDist - segHeight/2.0, segHeight)));// - segHeight/2.0));\n    float lineRadDist = max(0.0 , -sqrt(lineDist.x * lineDist.x + lineDist.y * lineDist.y) + radLines);\n\n\n    dist = dist - (max( topCenterYDist , 0.0)) * max(sign(-topCenterVec.y), 0.0) * (  tadder) / abs(topCenterYDist) - max(sign(topCenterVec.y), 0.0) * bottomRad;\n    dist = dist - (max( bottomCenterYDist , 0.0)) * max(sign(bottomCenterVec.y), 0.0) * (  adder) / abs(bottomCenterYDist) - max(sign(-bottomCenterVec.y), 0.0) * bottomRad;\n    \n    dist = dist + min(pow(max(1.2*(d.y - ((.5 - topHeight + .07) * h)), 0.0),1.96)/.74, 0.28);\n    dist += lineRadDist * max(bottomCenterYDist, 0.0)/(bottomCenterYDist);\n    \n    return dist;\n    }\n\n\n\n//Map function\nvec3 map(vec3 pos){\n    vec3 result = vec3(10000000000.0,0.0,0.0);\n    float res = 0.0;\n    \n    res = bottleSDF((pos - vec3(0.0,.7125,0.0)), .425, 3.25, .03, 5.0, .045, .235);\n    float bottleRes = res + .005;\n    res = abs(res) - .0025;\n    // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(abs(res) <= e){\n        \n        result.y = 3.0;\n    }\n    \n    res = cylinderSDF((pos - vec3(0.0,2.07,0.0)),0.2, .15);\n    res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 5.0;\n    }\n    \n    res = cylinderSDF((pos - vec3(0.0,.975,0.0)),0.425, .6);\n    res = max(-cylinderSDF((pos - vec3(0.0,.975,0.0)),0.40, .7), res);\n\n    //res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 6.0;\n    }\n    \n    vec3 pos2 = pos;\n    pos2.y -= pow(1.4,length(pos.xz)*8.3)*.02;//.1;\n    res = cylinderSDF((pos2 - vec3(0.0,-.8,0.0)),0.425, 1.5);\n    //res -= length(pos.xz);\n    //res = abs(res) - .01;\n    res -= .01;\n   // res = max(res, pos.y - .9);\n    float res2 = max(res, bottleRes);\n    result.x = min(result.x, res2 - .001);\n    \n    if(abs(res2 - .001)  <= e){\n        \n        result.y =7.0;\n    }\n    \n    \n   /* res = sphereSDF(length(pos - vec3(2.0,0.008,0.0)), 1.0);\n    res = abs(res) - .01;\n    result.x = min(result.x, res);\n    \n    if(res <= e){\n        \n        result.y = 3.0;\n    }*/\n    \n    res = planeSDF(pos - vec3(0.0,-.96, 0.0), 5.0, 15.0);\n    result.x = min(res, result.x);\n    if(res <= e){\n        result.y = 4.0;\n    }\n    \n    return result;\n}\n\n//Normals\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.0001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.0001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 tex3D(vec3 dir)\n{\n    return texture(iChannel0, dir).rgb;\n}\n\n//Raymarching function\n//Accepts ray origin and direction\n//Returns intersected position\nvec4 rayMarch(vec3 ro, vec3 rd, int steps){\n    if(steps == 0){\n        steps = maxSteps;\n    }\n    vec3 pos = ro;\n    float dist = (-1.0);\n    float oldDist = dist;\n    vec3 distRes = vec3(0.0,0.0,0.0);\n    for (int i = 0; i < steps; i++){\n        //run sdf\n        //step size is always half of distance\n        distRes = map(pos);\n        dist = distRes.x;\n\n        if(dist < e && dist > 0.0) {\n            pos = pos + rd * dist; \n            if(i < 5){\n            \n                distRes.y = 4.0;\n            \n            }\n            break;\n        }\n        else if(dist < 0.0){\n            \n        }\n        \n        if(dist < minStepSize){\n            dist = minStepSize;\n            oldDist = dist;\n            \n        }\n        else if(dist == oldDist){\n            //Ray has moved further from surface\n            dist = dist * 2.0;\n            oldDist = oldDist + dist;\n            return vec4(pos, 0.0);\n        }\n        else{\n            dist = dist / 2.0;\n            \n            //return vec4(dist,0.0,0.0,0.0);\n            oldDist = oldDist + dist;\n        }\n        \n        pos = pos + rd * dist;\n    }\n    \n    return vec4(pos, distRes.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    \n    float uvFocLen = 0.5 / tan(fov/2.0);\n    float scaleFac = 1.0/uvFocLen;\n    \n    camPos.x = -3.0 * ((iMouse.x/iResolution.x) - .5);\n    \n    \n    vec3 col = vec3(0.0);\n    vec3 fcol = vec3(0.0);\n    \n    for(int k = 0; k < SAMPLES; k++){\n        float offsetx = sin(float(k) * uv.x)/8.0 ;\n        float offsety = cos(float(k) * uv.y)/8.0;\n        \n        vec2 offsetVec = vec2(offsetx, offsety)/iResolution.xy;\n        uv += offsetVec;\n        vec2 uvFOV = (uv - vec2(0.5))*scaleFac;\n\n\n        vec3 camSpaceUVDir = normalize(vec3(uvFOV.x, uvFOV.y/aspect, 1.0));\n\n        mat3 ca = setCamera(camPos, camTar, 0.0);\n\n\n\n        vec3 rayDir = ca * camSpaceUVDir;\n\n        vec4 res = rayMarch(camPos, rayDir, 0);\n        /*vec4 res = vec4(0.0);\n        if(uv.y < .3){\n            res.w = 1.0;\n        }*/\n        \n        if(res.w > 0.0){\n        // Time varying pixel color\n            //col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n            //Normal as color\n            vec3 normal = calcNormal(res.xyz, length(camPos - res.xyz));\n            col = normal;\n\n\n\n            //Calculate light intensity given square falloff\n          /*  float dist = length(lPos - res.xyz) ;\n            float falloff = max(dist, 1.0); \n            float pointInt = lInt / (falloff * falloff);\n            vec3 colInt = lCol * pointInt;\n\n\n\n            //Shadow for light 1\n            vec3 shadRayDir = normalize(lPos - res.xyz);\n            vec4 shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n            if(shadRes.w > 0.0){\n                colInt = vec3(0.0,0.0,0.0);\n            }*/\n\n            //Calculate specular light intensity\n            //Reflected ray for specular\n          /*  vec3 reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n            float reflInt = max(dot(reflRay, rayDir), 0.0);\n\n\n            //point light 2\n            float dist2 = length(lPos2 - res.xyz) ;\n            float falloff2 = max(dist2, 1.0); \n            float pointInt2 = lInt2 / (falloff2 * falloff2);\n            vec3 colInt2 = lCol2 * pointInt2;\n\n            //Shadow for light 2\n            shadRayDir = normalize(lPos2 - res.xyz);\n            shadRes = rayMarch(res.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n            if(shadRes.w > 0.0){\n                colInt2 = vec3(0.0,0.0,0.0);\n            }\n\n             //Calculate specular light intensity\n            //Reflected ray for specular\n            reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n            float reflInt2 = max(dot(reflRay, rayDir),0.0);*/\n\n\n            vec3 surfCol = vec3(1.0,1.0,1.0);\n\n            if(res.w == 4.0){\n                surfCol = vec3(0.0,1.0,0.0);\n            }\n\n            if(res.w == 1.0){\n\n                //Assume white sphere surface, for now\n                surfCol = vec3(1.0,1.0,1.0);\n            }\n            else if(res.w == 2.0){\n                //White ground plane\n                surfCol = vec3(1.0,1.0,1.0);\n            }\n            else if(res.w == 3.0){\n                //Compute Refraction\n                //Fraction of light reflected vs refracted given IOR -- lets try 1.45 for plastic bottle\n                //try 4 refractions\n                //loop -- have incident ray dir, normal, IOR -- don't worry about transparent shadows for now\n                //compute fraction of light reflected vs refracted\n                //compute specular light at each point, multiply by percent reflected\n                //for reflected light, multiply colInt and reflInt by amount reflected\n                //raymarch to next point, comput ray dir, normal, ior\n                //if ray count exceeded and no surface found, compute light at final point and exit\n                \n                //Try\n\n               surfCol = vec3(1.0,1.0,1.0);\n               vec3 calcCol = vec3(0.0,0.0,0.0);\n               float refrInd1 = 1.0;\n               float refrInd2 = 1.5;\n               float refrIndAir = 1.0;\n\n               float reflFrac = 1.0;\n               float transFrac = 0.0;\n               \n               bool insidePlast = true;\n               bool insideWater = false;\n\n               vec3 specRefInt = vec3(0.0);\n\n               float cosAngle = dot(normal, -1.0 * rayDir);\n               float angle = acos(cosAngle);\n\n               vec3 transDir = vec3(0.0,0.0,0.0);\n               float transPow = 1.0;\n\n               vec4 resT = res;\n\n               int numRefr = 10;\n               for (int j = 0; j < numRefr; j++){\n                   float n = refrInd1 / refrInd2;\n                   float n2 = n * n;\n                   float nSin = n * sin(angle);\n                   float nSin2 = nSin * nSin;\n                   float sqrtReflFrac = abs( (refrInd1*cosAngle - refrInd2 * sqrt(1.0 - nSin2))/(refrInd1*cosAngle + refrInd2 * sqrt(1.0 - nSin2)));\n                   reflFrac = sqrtReflFrac * sqrtReflFrac;\n                   //reflFrac = 0.5 * (reflFrac + pow(abs( (-1.0*refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))/(refrInd2*cosAngle + refrInd1 * sqrt(1.0 - pow((refrInd1/refrInd2) * sin(angle), 2.0)))), 2.0));\n\n                   //Use schlick instead\n                  // float r0 = pow((refrInd1 - refrInd2)/(refrInd1 + refrInd2), 2.0);\n                   //reflFrac = r0 + (1.0 - r0)*pow(1.0 - cosAngle, 5.0);\n                  // reflFrac *= 1.0;\n                   /*float cAng = abs(asin(refrInd2/refrInd1));\n                   if(refrInd2 < refrInd1 && angle > cAng){\n                       //reflFrac = min(ang/(PI/2.0), 1.0);\n                       reflFrac = 1.0;\n                   }*/\n                   \n                   reflFrac = min(reflFrac, 1.0);\n                   \n                   transFrac = max(1.0 - reflFrac, 0.0);\n\n                  // specRefInt = surfCol * pow(reflInt, 5.0) * colInt * reflFrac;        \n                   //specRefInt += surfCol * pow(reflInt2,5.0) * colInt2 * reflFrac;\n                   if(j == 0){\n                       \n                       //specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac; \n                       vec3 reflectDir = reflect(rayDir, normal);\n                       specRefInt += surfCol * tex3D(vec3(reflectDir.x, reflectDir.y, -reflectDir.z)) * reflFrac;\n\n                   }\n                   //specRefInt += surfCol * vec3(0.5,0.5,0.5) * reflFrac;\n\n                   \n                   //calcCol = resT.xyz + vec3(0.0, 0.0,0.0);\n                   //calcCol = normal;\n                  /* if(resT.w == 4.0){\n                       calcCol = vec3(1.0, 0.0,0.0);\n                       break;\n                   }*/\n\n\n\n                   if(resT.w == 0.0){\n                      //calcCol += transPow *  vec3(0.5,0.5,0.5);\n                      calcCol += transPow * tex3D(vec3(rayDir.x, rayDir.y, -rayDir.z));\n                     // calcCol = vec3(1.0);\n                      break;\n                   }\n                   \n                   if(resT.w == 7.0){\n                       //Reflecting just the background off the water surface should be a good enough approximation\n                      // calcCol += transPow * reflFrac * vec3(0.5, 0.5, 0.5);\n                   }\n                   \n\n                   else if (resT.w == 2.0  || resT.w == 6.0){\n                       //Compute diffuse\n                       \n                       surfCol = vec3(1.0);\n                       \n                       \n                            //Shadow for light 1\n                           /* vec3 shadRayDir = normalize(lPos - resT.xyz);\n                            vec4 shadRes = rayMarch(resT.xyz - shadowBias * rayDir, shadRayDir, 0);*/\n\n                           /* if(shadRes.w > 0.0){\n                                colInt = vec3(0.0,0.0,0.0);\n                            }*/\n                            \n                          /*  shadRayDir = normalize(lPos2 - resT.xyz);\n                            shadRes = rayMarch(resT.xyz - shadowBias * rayDir, shadRayDir, 0);\n\n                            if(shadRes.w > 0.0){\n                                colInt2 = vec3(0.0,0.0,0.0);\n                            }*/\n                      \n                        \n                      /*  vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - resT.xyz)), 0.0);\n                        difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - resT.xyz)), 0.0);*/\n                       // calcCol += transPow * (surfCol * ambCol + difReflInt);\n                        calcCol += transPow * ( lighting(rayDir, normal, surfCol, 0.0, 0.8, 0.0 )) ;\n                        //calcCol += normal;\n                        //calcCol = resT.xyz;\n                        break;\n                   }\n                   else if(resT.w == 4.0){\n                        //basic mapping\n                        vec2 texUV = vec2(0.0);\n                        texUV.x = (resT.x + 2.5)/5.0; \n                        texUV.y = (resT.z + 2.5)/5.0;\n                        surfCol = texture(iChannel2, texUV).xyz;\n                        float roughness = 0.95;\n                            roughness -= surfCol.b * 0.4;\n                        \n                        calcCol += transPow * ( lighting(rayDir, normal, surfCol, 0.0, roughness, 0.0 )) ;\n                    }\n                  \n                   \n                   calcCol += max(specRefInt * transPow, 0.0);\n                   \n\n                   if(j == numRefr - 1){\n                       break;\n                   }\n\n                   transPow *= transFrac;\n                   //surfCol = surfCol * reflFrac;\n                   transDir = normalize((refrInd1/refrInd2) * rayDir + ((refrInd1/refrInd2) * cosAngle - sqrt(1.0 - pow(refrInd1 / refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0)))) * normal);\n                   //transDir = normalize(sqrt(1.0 - pow(refrInd1/refrInd2, 2.0) * (1.0 - pow(cosAngle, 2.0))) * normal + (refrInd1/refrInd2) * (rayDir - cosAngle * normal));\n                  // transDir = (refrInd1/refrInd2) * (rayDir - cosAngle * normal)  + sqrt(1.0 - pow(length((refrInd1/refrInd2) * (rayDir - cosAngle * normal)), 2.0)) * normal;\n\n                   vec3 oldPos = resT.xyz;\n                   resT = rayMarch(resT.xyz + 3.0 * e * transDir, transDir,2048);\n                   \n                    float temp = refrInd1;\n                    refrInd1 = refrInd2;\n                    refrInd2 = temp;\n                      /*if(j == 1){\n                       //water\n                      refrInd2 = insideWater ? refrInd2 : 1.33;\n         \n                      insideWater = insideWater ? false : true;\n                     \n                          calcCol = vec3(1.0);\n                      \n                      calcCol = transDir;\n                      break;\n                      \n                   }*/\n                  \n                     if(resT.w == 3.0  ){\n                       //plastic\n                      refrInd2 = !insideWater && insidePlast ? refrIndAir : refrInd2;\n                      \n                      \n                      insidePlast = insidePlast ? false : true;\n                      //calcCol = vec3(refrInd1 == 1.0);\n                      //break;\n                      //calcCol = vec3(1.0);\n                   }\n                   \n                   \n                   else if(resT.w == 7.0 ){\n                       //water\n                      refrInd2 = insideWater ? refrInd2 : 1.33;\n         \n                      insideWater = insideWater ? false : true;\n                    /* if(j==1){\n                          calcCol = vec3(1.0);\n                      \n                      calcCol = vec3(refrInd1 == 1.0);\n                      break;\n                      }*/\n                   }\n                   \n                 \n                  \n\n                   //Normal\n                   normal = calcNormal(resT.xyz, length(camPos - resT.xyz));\n                   //col = normal;\n\n                    //Calculate light intensity given square falloff\n                    /*dist = length(lPos - resT.xyz) ;\n                    pointInt = lInt / pow(max(dist, 1.0) , 2.0);\n                    colInt = lCol * pointInt;\n\n\n                    //Calculate specular light intensity\n                    //Reflected ray for specular\n                    shadRayDir = normalize(lPos - resT.xyz);\n                    reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                    reflInt = max(dot(reflRay, transDir), 0.0);\n\n\n                    //point light 2\n                    dist2 = length(lPos2 - resT.xyz) ;\n                    pointInt2 = lInt2 / pow(max(dist2, 1.0) , 2.0);\n                    colInt2 = lCol2 * pointInt2;\n                    \n\n\n                     //Calculate specular light intensity\n                    //Reflected ray for specular\n                    shadRayDir = normalize(lPos2 - resT.xyz);\n                    reflRay = normalize(2.0 * dot(normal, shadRayDir) * normal * -1.0 + shadRayDir);\n                    reflInt2 = max(dot(reflRay, transDir),0.0);\n\n                   */\n\n                    float j_float = float(j);\n                    normal *= 1.0 - 2.0 * mod(j_float + 1.0, 2.0);\n\n                    cosAngle = dot(normal,-1.0 * transDir);\n                    angle = acos(cosAngle);\n\n                    rayDir = transDir;\n               }\n\n\n               col = calcCol * 1.0;\n               //col = vec3(1.0);\n\n            }\n            \n            else if(res.w == 4.0){\n                //basic mapping\n                vec2 texUV = vec2(0.0);\n                texUV.x = (res.x + 2.5)/10.0; \n                texUV.y = (res.z + 2.5)/10.0;\n                surfCol = texture(iChannel2, texUV).xyz;\n            }\n            \n            else if(res.w == 6.0){\n                //cylinder mapping\n                vec2 texUV = vec2(0.0);\n                texUV.x = asin(res.x/length(res.xz));\n                texUV.x = res.z < 0.0 ? texUV.x + PI : texUV.x;\n                texUV.x /= 2.0 *  PI;\n                texUV.y =  1.3 * (res.y - .6) / .975;\n                surfCol = texture(iChannel1, texUV).xyz;\n            }\n\n            //BRDF\n            /*vec3 difReflInt = surfCol * colInt * max(dot(normal, normalize(lPos - res.xyz)), 0.0);\n            difReflInt += surfCol * colInt2 * max(dot(normal, normalize(lPos2 - res.xyz)), 0.0);\n            vec3 specRefInt = surfCol * pow(reflInt, 10.0) * colInt;        \n            specRefInt += surfCol * pow(reflInt2, 10.0) * colInt2;*/\n            if(res.w != 3.0){\n                //col = surfCol * ambCol + 0.8 * difReflInt + 0.2 * specRefInt;\n                float roughness = 0.7;\n                if(res.w == 4.0){\n                    roughness -= -.25 + surfCol.b * 0.4;\n                }\n\n                col = lighting(vec3(rayDir.x, rayDir.y, -rayDir.z), normal, surfCol, 0.0, roughness, 0.0 ) ;\n                //col = vec3(1.0);\n            }\n            \n            else{\n                //col += surfCol * ambCol;\n            }\n        }\n        else{\n            col = vec3(0.5,0.5,0.5);\n            col = tex3D(vec3(rayDir.x, rayDir.y, -rayDir.z));\n        }\n        fcol += col / float(SAMPLES);\n    }\n\n    //gamma\n    fcol = pow(fcol, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(fcol,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Old watch (IBL). Created by Reinder Nijhoff 2018\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/lscBW4\n//\n// In this buffer I pre-calculate the BRDF integration map, as described in:\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n//\n\nconst float PI = 3.14159265359;\n\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat PartialGeometryGGX(float NdotV, float a) {\n    float k = a / 2.0;\n\n    float nominator   = NdotV;\n    float denominator = NdotV * (1.0 - k) + k;\n\n    return nominator / denominator;\n}\n\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\n    float a = roughness*roughness;\n    float G1 = PartialGeometryGGX(NdotV, a);\n    float G2 = PartialGeometryGGX(NdotL, a);\n    return G1 * G2;\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\n} \n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\n    float a = roughness*roughness;\n    float phi      = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    vec3 HTangent;\n    HTangent.x = sinTheta*cos(phi);\n    HTangent.y = sinTheta*sin(phi);\n    HTangent.z = cosTheta;\n\n    return HTangent;\n}\n\nvec2 IntegrateBRDF(float roughness, float NdotV) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    const int SAMPLE_COUNT = 128;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\n        \n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0) {\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nbool resolutionChanged() {\n    return floor(texelFetch(iChannel0, ivec2(0), 0).r) != floor(iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(resolutionChanged()) {\n        if (fragCoord.x < 1.5 && fragCoord.y < 1.5) {\n            fragColor = floor(iResolution.xyxy);\n        } else {\n\t   \t\tvec2 uv = fragCoord / iResolution.xy;\n    \t\tvec2 integratedBRDF = IntegrateBRDF(uv.y, uv.x);\n   \t \t\tfragColor = vec4(integratedBRDF, 0.0,1.0);\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}