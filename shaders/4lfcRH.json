{
    "Shader": {
        "info": {
            "date": "1503519918",
            "description": "I thought it could be a fun exercise to make skeletal animation in shadertoy. It's supposed to be a wireframe of a fish or something like that. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4lfcRH",
            "likes": 17,
            "name": "SkeletalAnimation",
            "published": 3,
            "tags": [
                "2d",
                "animation",
                "skeleton",
                "bones"
            ],
            "usePreview": 0,
            "username": "kuvkar",
            "viewed": 1288
        },
        "renderpass": [
            {
                "code": "// I thought it could be a fun exercise to make skeletal animation in shadertoy.\n// It's supposed to be a wireframe of a fish or something like that.\n// 2D animation only, though extending to 3d should be quite similar.\n\n// Yellow lines are the bones, blue ones vertices and green ones rendered wireframe.\n// Only one bone / vertex, so the weight of each vertex/bone is always 1.\n\n#define PI 3.14159265358\n\n#define BONE_H .07\n#define BONE_W .017\n#define BONES 5\n#define VERTICES 9\n#define INDICES 21\n\nvec2 g_uv;\n\n\nstruct Vertex\n{\n    vec3 pos;\n    int boneIndex; // index of bone this vertex belongs to. The weight is always 1.\n};\n\n\n\nstruct Bone\n{\n    mat3 localMatrix; // local coordinates, rotation + position\n    float h;\n    float w;\n};\n\n    \n    \nVertex vertices[VERTICES];\nBone bones[BONES];\nmat3 bonesWorld[BONES];\nmat3 boneInversesWorld[BONES];\n\n\n// https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat line(in vec2 from, in vec2 to, float w)\n{\n    float l2 = dot(to-from, to-from);\n    float t = max(0., min(1.0, dot(g_uv-from, to-from) / l2));\n    vec2 projection = from + t * (to - from);\n    w *= dFdx(g_uv.x);\n    return smoothstep(0.0025, 0.0025 - w * 4., length(g_uv - projection));\n}\n\nfloat bone(in vec2 from, in vec2 to, float w)\n{\n    float l2 = dot(to-from, to-from);\n    float t = max(0., min(1.0, dot(g_uv-from, to-from) / l2));\n    vec2 projection = from + t * (to - from);\n    w *= dFdx(g_uv.x);\n    float f = length(g_uv-from) * .04;\n    return smoothstep(0.002 + f, 0.002 - w + f, length(g_uv - projection));\n}\n\nfloat circle(in vec2 pos, float r)\n{\n    return length(g_uv - pos) - r;\n}\n\nmat3 rotation(float angle)\n{\n    mat3 rm;\n    rm[0][0] = cos(angle);\n    rm[0][1] = -sin(angle);\n    rm[1][0] = sin(angle);\n    rm[1][1] = cos(angle);\n    rm[2] = vec3(0.0, 0.0, 1.0);\n    return rm;\n}\n\n\nBone getBone(in Bone parent, float h)\n{\n\tBone b;\n    b.w = BONE_W;\n    b.h = h;\n    \n    mat3 r;\n    r[0] = vec3(1.0, 0.0, 0.0);\n    r[1] = vec3(0.0, 1.0, 0.0);\n    r[2] = vec3(0.0, h, 1.0); // h = offset from the parent bone vertically\n    b.localMatrix = r;\n\n    return b;\n}\n\nvoid calculateWorldMatrices()\n{\n \n    for (int i = 0; i < BONES; ++i)\n    {\n        bonesWorld[i] = bones[i].localMatrix;\n    }\n    \n    for (int i = 1; i < BONES; ++i)\n    {\n        bonesWorld[i] = bonesWorld[i - 1] * bonesWorld[i];\n    }\n    \n}\n\nvoid calculateWorldMatriceInverses()\n{\n    for (int i = 0; i < BONES; ++i)\n    {\n        boneInversesWorld[i] = inverse(bonesWorld[i]);\n    }    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(.95, .95, 1., .0);\n\tg_uv = ((fragCoord.xy - iResolution.xy*.5) / iResolution.xy) * vec2(1.0, iResolution.y / iResolution.x);\n    vec2 _uv = g_uv;\n    g_uv *= .5 + sin(iTime * .5) * .05;\n    g_uv.y += 0.1;\n    \n    Bone root;\n    root.localMatrix[0] = vec3(1.0, 0.0, 0.0);\n    root.localMatrix[1] = vec3(0.0, 1.0, 0.0);\n    root.localMatrix[2] = vec3(0.0, 0.0, 1.0);\n    \n    root.w = 0.;\n    root.h = 0.;\n\n    /////// Creating the \"Bind pose\"\n    bones[0] = root;\n\n    bones[1] = getBone(root, BONE_H);\n    bones[2] = getBone(bones[1],BONE_H);\n    bones[3] = getBone(bones[2],BONE_H);\n    bones[4] = getBone(bones[3],BONE_H * .2);\n    \n    // this step is for \n    // calculating the world matrice inverses\n    calculateWorldMatrices();\n\tcalculateWorldMatriceInverses();\n    \n    //////////////////////////////////////////////////\n    ///// Animation //////////////////////////////////\n    //////////////////////////////////////////////////\n    \n    // This is the \"animation data\", which is some translation or rotation applied to the bones\n    bones[0].localMatrix = rotation(cos(iTime * 2.) * .2) * bones[0].localMatrix;\n    bones[0].localMatrix[2] += vec3(sin(-PI*.5+iTime * 2.)* .008, sin(iTime)*.01, 0.0);\n    bones[2].localMatrix = rotation(sin(iTime * 2.)*.15) * bones[2].localMatrix;\n    \n    // moving the middle bone a little, just to see that the animation will work with that.\n    bones[2].localMatrix[2] += vec3(0.0, sin(iTime)*.01, 0.0);\n    \n    // last bone rotations\n    bones[3].localMatrix = rotation(sin(iTime * 2.)*.2) * bones[3].localMatrix;\n    bones[4].localMatrix = rotation(sin(iTime * 2.)*.4) * bones[4].localMatrix;\n    \n    // calculate world matrices at the animated pose.\n    calculateWorldMatrices();\n\t\n\t// render bones    \n    for (int i = 1; i < BONES; ++i)\n    {\n        vec4 color = bone(bonesWorld[i][2].xy, bonesWorld[i-1][2].xy, 3.) * vec4(1.0, 1.0, 0.0, 1.);\n        fragColor = mix(fragColor, color, color.a);\n    }\n    \n    float W = 1.5;\n    float H = 1.;\n    \n    // build vertices\n    vertices[0].pos = vec3(0., 0., 1.);\n    vertices[0].boneIndex = 0;\n    \n    vertices[1].pos = vec3(0.027 * W, 0.05 * H, 1.);\n    vertices[1].boneIndex = 1;\n\n    vertices[2].pos = vec3(-vertices[1].pos.x, vertices[1].pos.y, 1.);\n    vertices[2].boneIndex = vertices[1].boneIndex;\n\n    vertices[3].pos = vec3(0.005 * W, 0.14 * H, 1.);\n    vertices[3].boneIndex = 2;\n\n    vertices[4].pos = vec3(-vertices[3].pos.x, vertices[3].pos.y, 1.);\n    vertices[4].boneIndex = 2;\n    \n    vertices[5].pos = vec3(0.0015 * W, 0.2 * H, 1.);\n    vertices[5].boneIndex = 3;\n    \n    vertices[6].pos = vec3(-vertices[5].pos.x, vertices[5].pos.y, 1.);\n    vertices[6].boneIndex = vertices[5].boneIndex;\n\n    vertices[7].pos = vec3(0.015 * W, 0.22 * H, 1.);\n    vertices[7].boneIndex = 4;\n\n    vertices[8].pos = vec3(-vertices[7].pos.x, vertices[7].pos.y, 1.);\n    vertices[8].boneIndex = vertices[7].boneIndex;\n    \n    // render vertices at their new transformed positions\n    for (int i = 0; i < VERTICES; ++i)\n    {\n        // offset matrix contains a delta from the bind pose to the animated pose\n        // you get this delta by multiplying the current pose by the inverse of the bind pose.\n        // it's what you want to transform the vertices with.\n        mat3 offsetMatrix = (bonesWorld[vertices[i].boneIndex] * boneInversesWorld[vertices[i].boneIndex]);\n        vec3 p = offsetMatrix * vertices[i].pos;\n        vec4 color = vec4(0., 0., 1.,1.) * smoothstep(dFdx(g_uv.x) * 2.5, 0.0, circle(p.xy, .002));\n\t    fragColor = mix(fragColor, color, color.a);\n        vertices[i].pos = p;\n    }\n    \n    \n    // rendering the wireframe\n    int indices[INDICES];\n    \n    indices[0] = 0;\n    indices[1] = 1;\n    indices[2] = 2;\n\n    indices[3] = 2;\n    indices[4] = 3;\n    indices[5] = 1;\n\n    indices[6] = 4;\n    indices[7] = 2;\n    indices[8] = 3;\n\n    indices[9]  = 4;\n    indices[10] = 5;\n    indices[11] = 6;\n\n    indices[12] = 3;\n    indices[13] = 5;\n    indices[14] = 4;\n\n    indices[15] = 6;\n    indices[16] = 7;\n    indices[17] = 8;\n\n    indices[18] = 5;\n    indices[19] = 6;\n    indices[20] = 7;\n    \n    \n    \n    for (int i = 0; i < INDICES; i = i + 3)\n    {\n       vec4 color = line(vertices[indices[i]].pos.xy, vertices[indices[i + 1]].pos.xy, .5) * vec4(0., 1., 0., 1.);\n       fragColor = mix(fragColor, color, color.a);\n        \n       color = line(vertices[indices[i + 1]].pos.xy, vertices[indices[i + 2]].pos.xy, .5) * vec4(0., 1., 0., 1.);\n       fragColor = mix(fragColor, color, color.a);\n\n       color = line(vertices[indices[i + 0]].pos.xy, vertices[indices[i + 2]].pos.xy, .5) * vec4(0., 1., 0., 1.);\n       fragColor = mix(fragColor, color, color.a);\n    }\n    \n    //wignetting\n    fragColor = mix(fragColor, vec4(0.1,  0.1, 0.15, 0.), smoothstep(0.2,0.8, length(_uv*vec2(1.1, 1.9))));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}