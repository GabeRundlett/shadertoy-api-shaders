{
    "Shader": {
        "info": {
            "date": "1579928484",
            "description": "I thought it's fun to utilize \"In Circle Test\" signed volume to reduce sudden triangulation flip.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tVGDV",
            "likes": 16,
            "name": "Delaunay triangulation",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 1485
        },
        "renderpass": [
            {
                "code": "//\n// Delaunay triangulation\n//\n\n#define M_PI 3.14159\n\nfloat SCALE = 5.0;\nfloat SCALE_TIME = .3;\n\nfloat POINT_RADIUS = 3.0;\nfloat GRID_LINE_WIDTH = 1.0;\nfloat QUAD_EDGE_WIDTH = 3.0;\nfloat TRI_EDGE_WIDTH  = 2.0;\n\nvec3 CLEAR_COLOR = vec3(0.15);\nvec3 GRID_LINE_COLOR = vec3(0.3);\nvec3 POINT_COLOR = vec3(0.0, 1.0, 1.0);\nvec3 QUAD_EDGE_COLOR = vec3(1.0, 0.0, 1.0);\nvec3 TRI_EDGE_COLOR  = vec3(1.0, 1.0, 0.0) * 0.8;\nfloat TRI_EDGE_DEGENERACY_FACTOR_SCALE = 0.1; // heuristics to reduce sudden triangulation flip\n\nfloat AA = 2.0;\n\n//\n// Utils\n//\n\nvec2 unitVector2(float t) {\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nfloat distance_Point_LineSegment(vec2 p, vec2 q1, vec2 q2) {\n  // < p - (q + t v), v> = 0  <=>  t = < p - q, v > / < v, v >\n\n  vec2 v = q2 - q1;\n  float dot_vv = dot(v, v);\n  if (dot(v, v) < 0.0001) {\n    return distance(p, q1);\n  }\n  float t = dot(p - q1, v) / dot_vv;\n  float s = clamp(t, 0.0, 1.0);\n  return distance(p, q1 + s * v);\n}\n\n\n//\n// Noise\n//\n\nfloat hash11(float t) {\n  return fract(sin(1.0 + t * 123456.789) * 123456.789);\n}\n\nfloat hash21(vec2 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]));\n}\n\nfloat hash31(vec3 v) {\n  return hash11(hash11(v[0]) + 2.0 * hash11(v[1]) + 3.0 * hash11(v[2]));\n}\n\nvec2 hash22(vec2 v) {\n  return vec2(hash21(v), hash31(vec3(v, 1.0)));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  return unitVector2(hash21(uv));\n}\n\nfloat gradientNoise2(vec2 uv) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  float f00 = dot(hashGradient2(uvi + vec2(0.0, 0.0)), uvf - vec2(0.0, 0.0));\n  float f10 = dot(hashGradient2(uvi + vec2(1.0, 0.0)), uvf - vec2(1.0, 0.0));\n  float f01 = dot(hashGradient2(uvi + vec2(0.0, 1.0)), uvf - vec2(0.0, 1.0));\n  float f11 = dot(hashGradient2(uvi + vec2(1.0, 1.0)), uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nvec2 someNoise(vec2 hash_seed, float conti_seed) {\n  // Taking hashed direction to break inherent velocity pattern of gradientNoise2\n  vec2 p = hash22(hash_seed);\n  vec2 dir1 = unitVector2(p[0]);\n  vec2 dir2 = unitVector2(p[1]);\n  vec2 v = vec2(\n      gradientNoise2(123.456 * hash_seed + 456.789 + conti_seed * dir1),\n      gradientNoise2(456.123 * hash_seed + 789.456 + conti_seed * dir2));\n\n  // Tonemap [0, 1] to make movement more \"dynamical\"\n  return smoothstep(0.0, 1.0, v);\n}\n\n//\n// Delaunay triangulation\n//\n\nvoid distanceToNoiseSitesTriangulation(\n    vec2 uv, float noise_seed,\n    out float min_distance_vertex,\n    out float min_distance_quad_edge,\n    out float min_distance_tri_edge,\n    out float in_circle_test_det) {\n\n  vec2 lattice_uv = floor(uv);\n  min_distance_vertex = sqrt(2.0);\n  min_distance_quad_edge = 1.0;\n  min_distance_tri_edge = sqrt(2.0);\n\n  // Cache sites coordinate\n  vec2 sites[9];\n  #define _ENCODE_IJ(i, j)       (3 * int(i + 1.0) + int(j + 1.0))\n  #define READ_SITE(i, j)        sites[_ENCODE_IJ(i, j)]\n  #define WRITE_SITE(i, j, site) sites[_ENCODE_IJ(i, j)] = site\n\n  // iterate sites\n  for (float i = -1.0; i <= 1.0; i++) {\n    for (float j = -1.0; j <= 1.0; j++) {\n      vec2 lattice_ij = lattice_uv + vec2(i, j);\n      vec2 site_ij = lattice_ij + someNoise(lattice_ij, noise_seed);\n      min_distance_vertex = min(min_distance_vertex, distance(uv, site_ij));\n      WRITE_SITE(i, j, site_ij);\n    }\n  }\n\n  // iterate quad edges\n  // - these quads are not necessarily convex, but the probablity of such case should be quite low.\n  //   or you could force convexity by weaking the noise factor (e.g. 0.5 * someNoise(...)).\n  for (float k = -1.0; k <= 1.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      float d_kl = distance_Point_LineSegment(uv, READ_SITE(k, l), READ_SITE(k + 0.0, l + 1.0));\n      float d_lk = distance_Point_LineSegment(uv, READ_SITE(l, k), READ_SITE(l + 1.0, k + 0.0));\n      min_distance_quad_edge = min(min_distance_quad_edge, min(d_kl, d_lk));\n    }\n  }\n\n  // iterate triangulation diagonal edges\n  for (float k = -1.0; k <= 0.0; k++) {\n    for (float l = -1.0; l <= 0.0; l++) {\n      vec2 v0 = READ_SITE(k + 0.0, l + 0.0);\n      vec2 v1 = READ_SITE(k + 1.0, l + 0.0);\n      vec2 v2 = READ_SITE(k + 0.0, l + 1.0);\n      vec2 v3 = READ_SITE(k + 1.0, l + 1.0);\n\n      // Cf. Guibas 1985, Lemma 8.1 (https://doi.org/10.1145%2F282918.282923)\n      mat3 in_circle_test_mat = mat3(\n          (v1 - v0).x, (v1 - v0).y, dot(v1, v1) - dot(v0, v0),\n          (v2 - v0).x, (v2 - v0).y, dot(v2, v2) - dot(v0, v0),\n          (v3 - v0).x, (v3 - v0).y, dot(v3, v3) - dot(v0, v0));\n      float in_circle_test_det_current = determinant(in_circle_test_mat);\n      float d = in_circle_test_det_current > 0.0\n          ? distance_Point_LineSegment(uv, v1, v2)  // edge: 10 <--> 01\n          : distance_Point_LineSegment(uv, v0, v3); // edge: 00 <--> 11\n      if (d < min_distance_tri_edge) {\n        min_distance_tri_edge = d;\n        in_circle_test_det = in_circle_test_det_current;\n      }\n    }\n  }\n\n  #undef _ENCODE_IJ\n  #undef READ_SITE\n  #undef WRITE_SITE\n}\n\n//\n// Misc\n//\n\n// grid\nfloat distanceToGrid(vec2 uv) {\n  vec2 uvf = fract(uv);\n  return min(min(min(uvf.x, uvf.y), 1.0 - uvf.x), 1.0 - uvf.y);\n}\n\n// anti alias\nfloat smoothBoundaryCoverage(float b, float d, float w) {\n  return 1.0 - smoothstep(0.0, 1.0, (d - b) / w + 0.5);\n}\n\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  float inv_view_scale = SCALE / iResolution.y;\n  vec2 uv =  inv_view_scale * frag_coord;\n  float t = SCALE_TIME * iTime;\n\n  vec3 color = CLEAR_COLOR;\n  {\n    float d = distanceToGrid(uv);\n    float coverage = smoothBoundaryCoverage(0.5 * GRID_LINE_WIDTH, d / inv_view_scale, AA);\n    color = mix(color, GRID_LINE_COLOR, coverage);\n  }\n  {\n    float d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det;\n    distanceToNoiseSitesTriangulation(\n        uv, t, d_vertex, d_quad_edge, d_tri_edge, in_circle_test_det);\n\n    float coverage_vertex = smoothBoundaryCoverage(\n        POINT_RADIUS, d_vertex / inv_view_scale, AA);\n    float coverage_quad_edge = smoothBoundaryCoverage(\n        0.5 * QUAD_EDGE_WIDTH, d_quad_edge / inv_view_scale, AA);\n    float coverage_tri_edge = smoothBoundaryCoverage(\n        0.5 * TRI_EDGE_WIDTH, d_tri_edge / inv_view_scale, AA);\n    float degeneracy_factor = smoothstep(\n        0.0, TRI_EDGE_DEGENERACY_FACTOR_SCALE, abs(in_circle_test_det));\n\n    color = mix(color, QUAD_EDGE_COLOR, coverage_quad_edge);\n    color = mix(color, TRI_EDGE_COLOR, coverage_tri_edge * degeneracy_factor);\n    color = mix(color, POINT_COLOR, coverage_vertex);\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}