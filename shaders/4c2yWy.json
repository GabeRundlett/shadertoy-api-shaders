{
    "Shader": {
        "info": {
            "date": "1722924933",
            "description": "sources https://www.shadertoy.com/view/7lycRt",
            "flags": 0,
            "hasliked": 0,
            "id": "4c2yWy",
            "likes": 2,
            "name": "Octahedron rotate",
            "published": 3,
            "tags": [
                "octahedron"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 77
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS_MARCH 54\n#define WIRE_WIDTH 0.002\n#define ORBIT_DISABLE\n\n//thanks: https://www.shadertoy.com/view/ll33zS\nvec3 getCamera(vec3 z, vec3 p)\n{\n\tvec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    return mat3(x, cross(z, x), z) * p;\n}\n\n//sdLine, thanks: iq\nfloat sdl(vec3 p, vec3 a, vec3 b, float m)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return min(length( pa - ba*h ) - WIRE_WIDTH, m);\n}\n\n//-----------------------------------------------------------------\n\nbool tetra(vec3 p, float s, vec3 t, inout float sd) // Tetrahedron\n{\n    vec3 a = vec3( 0.000, -0.070,  0.175) * s - t;\n    vec3 b = vec3( 0.147, -0.070, -0.084) * s - t;\n    vec3 c = vec3(-0.147, -0.070, -0.084) * s - t;\n    vec3 d = vec3( 0.000,  0.119,  0.000) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, c, a, sd); sd = sdl(p, d, b, sd);\n    return sd < 0.001;\n}\n\nbool octa(vec3 p, float s, vec3 t, inout float sd) // Octahedron\n{\np.zx*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\np.zy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    vec3 a = vec3( 0.10,  0.00,  0.10) * s - t;\n    vec3 b = vec3( 0.10,  0.00, -0.10) * s - t;\n    vec3 c = vec3(-0.10,  0.00, -0.10) * s - t;\n    vec3 d = vec3(-0.10,  0.00,  0.10) * s - t;\n    vec3 e = vec3( 0.00,  0.14,  0.00) * s - t;\n    vec3 f = vec3( 0.00, -0.14,  0.00) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, a, e, sd); sd = sdl(p, b, e, sd);\n    sd = sdl(p, c, e, sd); sd = sdl(p, d, e, sd);\n    sd = sdl(p, a, f, sd); sd = sdl(p, b, f, sd);\n    sd = sdl(p, c, f, sd); sd = sdl(p, d, f, sd);\n    return sd < 0.001;\n}\n\nbool hexa(vec3 p, float s, vec3 t, inout float sd) // Hexahedron (cube)\n{\n    vec3 a = vec3(-0.10,  0.10,  0.10) * s - t;\n    vec3 b = vec3(-0.10,  0.10, -0.10) * s - t;\n    vec3 c = vec3( 0.10,  0.10, -0.10) * s - t;\n    vec3 d = vec3( 0.10,  0.10,  0.10) * s - t;\n    vec3 e = vec3(-0.10, -0.10,  0.10) * s - t;\n    vec3 f = vec3(-0.10, -0.10, -0.10) * s - t;\n    vec3 g = vec3( 0.10, -0.10, -0.10) * s - t;\n    vec3 h = vec3( 0.10, -0.10,  0.10) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, a, sd);\n    sd = sdl(p, e, f, sd); sd = sdl(p, f, g, sd);\n    sd = sdl(p, g, h, sd); sd = sdl(p, h, e, sd);\n    sd = sdl(p, a, e, sd); sd = sdl(p, b, f, sd);\n    sd = sdl(p, c, g, sd); sd = sdl(p, d, h, sd);\n    return sd < 0.001;\n}\n\nbool icos(vec3 p, float s, vec3 t, inout float sd) // Icosahedron\n{\n    vec3 a = vec3(-0.108,  0.066,  0.078) * s - t;\n    vec3 b = vec3( 0.040,  0.066,  0.127) * s - t;\n    vec3 c = vec3( 0.133,  0.066,  0.000) * s - t;\n    vec3 d = vec3( 0.040,  0.066, -0.127) * s - t;\n    vec3 e = vec3(-0.108,  0.066, -0.078) * s - t;\n    vec3 f = vec3(-0.133, -0.066,  0.000) * s - t;\n    vec3 g = vec3(-0.040, -0.066,  0.127) * s - t;\n    vec3 h = vec3( 0.108, -0.066,  0.078) * s - t;\n    vec3 i = vec3( 0.108, -0.066, -0.078) * s - t;\n    vec3 j = vec3(-0.040, -0.066, -0.127) * s - t;\n    vec3 k = vec3( 0.000,  0.150,  0.000) * s - t;\n    vec3 l = vec3( 0.000, -0.150,  0.000) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, b, c, sd);\n    sd = sdl(p, c, d, sd); sd = sdl(p, d, e, sd);\n    sd = sdl(p, e, a, sd); sd = sdl(p, f, g, sd);\n    sd = sdl(p, g, h, sd); sd = sdl(p, h, i, sd);\n    sd = sdl(p, i, j, sd); sd = sdl(p, j, f, sd);\n    sd = sdl(p, a, f, sd); sd = sdl(p, b, g, sd);\n    sd = sdl(p, c, h, sd); sd = sdl(p, d, i, sd);\n    sd = sdl(p, e, j, sd); sd = sdl(p, a, g, sd);\n    sd = sdl(p, b, h, sd); sd = sdl(p, c, i, sd);\n    sd = sdl(p, d, j, sd); sd = sdl(p, e, f, sd);\n    sd = sdl(p, a, k, sd); sd = sdl(p, b, k, sd);\n    sd = sdl(p, c, k, sd); sd = sdl(p, d, k, sd);\n    sd = sdl(p, e, k, sd); sd = sdl(p, f, l, sd);\n    sd = sdl(p, g, l, sd); sd = sdl(p, h, l, sd);\n    sd = sdl(p, i, l, sd); sd = sdl(p, j, l, sd);\n    return sd < 0.001;\n}\n\nbool dode(vec3 p, float s, vec3 t, inout float sd) // Dodecahedron\n{\n    vec3 a = vec3( 0.000,  0.052,  0.139) * s - t;\n    vec3 b = vec3( 0.085,  0.085,  0.085) * s - t;\n    vec3 c = vec3(-0.085,  0.085,  0.085) * s - t;\n    vec3 d = vec3( 0.000, -0.052,  0.139) * s - t;\n    vec3 e = vec3( 0.085, -0.085,  0.085) * s - t;\n    vec3 f = vec3(-0.085, -0.085,  0.085) * s - t;\n    vec3 g = vec3( 0.000,  0.052, -0.139) * s - t;\n    vec3 h = vec3( 0.085,  0.085, -0.085) * s - t;\n    vec3 i = vec3(-0.085,  0.085, -0.085) * s - t;\n    vec3 j = vec3( 0.000, -0.052, -0.139) * s - t;\n    vec3 k = vec3( 0.085, -0.085, -0.085) * s - t;\n    vec3 l = vec3(-0.085, -0.085, -0.085) * s - t;\n    vec3 m = vec3(-0.052,  0.139,  0.000) * s - t;\n    vec3 n = vec3( 0.052,  0.139,  0.000) * s - t;\n    vec3 o = vec3( 0.052, -0.139,  0.000) * s - t;\n    vec3 w = vec3(-0.052, -0.139,  0.000) * s - t;\n    vec3 q = vec3(-0.139,  0.000,  0.052) * s - t;\n    vec3 r = vec3(-0.139,  0.000, -0.052) * s - t;\n    vec3 u = vec3( 0.139,  0.000,  0.052) * s - t;\n    vec3 v = vec3( 0.139,  0.000, -0.052) * s - t;\n\n    sd = sdl(p, a, b, sd); sd = sdl(p, a, c, sd);\n    sd = sdl(p, d, e, sd); sd = sdl(p, d, f, sd); \n    sd = sdl(p, a, d, sd); sd = sdl(p, g, h, sd); \n    sd = sdl(p, g, i, sd); sd = sdl(p, j, k, sd); \n    sd = sdl(p, j, l, sd); sd = sdl(p, g, j, sd);\n    sd = sdl(p, m, n, sd); sd = sdl(p, o, w, sd);\n    sd = sdl(p, m, c, sd); sd = sdl(p, n, b, sd);\n    sd = sdl(p, o, e, sd); sd = sdl(p, w, f, sd);\n    sd = sdl(p, m, i, sd); sd = sdl(p, n, h, sd);\n    sd = sdl(p, o, k, sd); sd = sdl(p, w, l, sd);\n    sd = sdl(p, m, i, sd); sd = sdl(p, n, h, sd);\n    sd = sdl(p, o, k, sd); sd = sdl(p, w, l, sd);\n    sd = sdl(p, b, u, sd); sd = sdl(p, c, q, sd);\n    sd = sdl(p, h, v, sd); sd = sdl(p, i, r, sd);\n    sd = sdl(p, e, u, sd); sd = sdl(p, f, q, sd);\n    sd = sdl(p, k, v, sd); sd = sdl(p, l, r, sd);\n    sd = sdl(p, q, r, sd); sd = sdl(p, u, v, sd);\n    return sd < 0.001;\n}\n\nfloat map(vec3 p, out vec3 color)\n{   \n    float sd = 10000.0;\n    vec3 p2 =p;\n     vec3 p3 =p;\n  p2.zx*=mat2(cos(iTime),-sin(iTime),sin(iTime), cos(iTime));\np2.zy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n  p3.zx*=mat2(cos(iTime),-sin(iTime),sin(iTime), cos(iTime));\np3.zy*=mat2(cos(iTime),-sin(iTime),sin(iTime), cos(iTime));\n        vec3 rp1 = vec3(1.0, 0.0, 0.0);\n        vec3 rp2 = vec3(1.0, 0.0, 0.0);\n    \n   \n     if(octa(p, 4.5, rp2 * 0.0, sd))\n        color = vec3(0.0, 0.0, 1.7);\nelse   if(octa(p3, 2.5, rp2 * 0.0, sd))\n        color = vec3(1.0, 0.5, 2.7);\n        else   if(octa(p2, 1.5, rp2 * 0.0, sd))\n        color = vec3(1.5, 1.5, 0.7);\n    return sd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0) / 4.0;\n    rd.x *= iResolution.x / iResolution.y;\n    \n    // origin direction (or pseudo camera position)\n    float angl = iTime * 0.00;\n    if(iMouse.z > 0.9)\n    {\n        vec2 mPos = iMouse.xy / iResolution.xy;\n        angl = -mPos.x * 20.0 * (1.0 - min(mPos.y + 0.3, 1.0));\n    }\n    \n    vec3 ro = vec3(sin(angl), 0.6, cos(angl));\n    rd = getCamera(ro, vec3(rd.xy, -0.45));\n    \n    // raymarching\n    vec3 r = vec3(0.0);\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        vec3 rgb = vec3(0.0);\n        float sd = map(pos, rgb);\n        if(sd < 0.001)\n        {    \n            r = rgb;\n            break;\n        }\n        t += sd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(r, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}