{
    "Shader": {
        "info": {
            "date": "1556289065",
            "description": "Rendering some abstract objects onto terrain. Inspired by Mike Winkelmann's imagery.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttXGWH",
            "likes": 241,
            "name": "Abstract Terrain Objects",
            "published": 3,
            "tags": [
                "terrain",
                "geometry",
                "scifi",
                "reflect",
                "shine"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 10682
        },
        "renderpass": [
            {
                "code": "/*\n\n    Abstract Terrain Objects\n    ------------------------\n\n\tRendering some abstract geometry onto some terrain in a basic sci-fi tone.\n\n\tThis was inspired by one of Mike Winkelmann's images, which I've included \n\ta link to below. The original image is nicer -- partly due to the fact that\n\tI'm restricted by realtime constraints, and possibly, because I have the\n\tartistic vision of a programmer. :D\n\t\n\tMike Winkelmann is the guy behind the amazing sci-fi flavored Beeple imagery \n\tthat appears in various corners of the internet. For anyone not familiar \n\twith his work, it's well worth the look. Shau has been putting up a few \n\tBeeple inspired shaders lately, which reminded me that I'd been meaning to\n\tdo the same.\n\n\tMost of this is pretty standard stuff: Render some sky, terrain, and some \n\tobjects, with an extra reflective pass on the objects to make them shiny.\n\tI went to the trouble to blend materials when the shiny objects were near \n\tthe terrain. That involved a little bit of fiddly mixing, which complicated \n\tthe code a little, but nothing that anyone here couldn't handle. :)\n\n\n\tOriginal Image:\n\n\t// Putting abstract geometry on terrain is a weird but common concept \n\t// amongst the graphics community, and this is a beautiful example.\n\tTRIOMETRIC - Beeple\n\thttps://twitter.com/beeple/status/848029629973749760\n\n\n\tExamples:\n\n\t// One of Shau's Beeple inspired shaders.\n\tData Surge - shau\n\thttps://www.shadertoy.com/view/3dSXzm\n\n\t// Cool and qwirky. I love the rendering style.\n\t[SH16B] valley flight  - Bananaft\n\thttps://www.shadertoy.com/view/XldGR7\n\n\t// I like the rendering style of this also.\n\tRayCraft - jolle\n\thttps://www.shadertoy.com/view/tslGRX\n\n\t// Another one of Shau's. Fun to watch.\n\tXANNN - shau\n\thttps://www.shadertoy.com/view/llSfzR\n\n*/\n\n// Maximum ray distance. Analogous to the far plane.\n#define FAR 100. \n\n// More correct third pass: The reflection off the reflected surface is less\n// noticeable, so we're saving some computing power and faking it, which means\n// this is not on by default. However, if your computer can afford it, this is \n// a better option.\n//#define THIRD_PASS\n\n\n// Scene object ID. Either the Terrain object (0) or the chrome object (0).\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(1, 113)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    //return sin( p*6.2831853 + iTime ); \n    \n}\n\n\n// Fabrice's consice, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    //return vec2(0);\n    //float s = sin(t/24.)*cos(t/12.);\n    //return vec2(s*4., 0.);\n    \n    float a = sin(t*.11);\n    float b = cos(t*.14);\n    return vec2((a*2./2. - b*1.5/2.), b*1.7/4. + a*1.5/4.);\n    \n    //return vec2(sin(t*.15)*2.4, cos(t*.25)*1.7*.5); \n}\n\n// Smooth fract function.\nfloat sFract(float x, float sf){\n    \n    x = fract(x);\n    return min(x, (1. - x)*x*sf);\n    \n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(113., 57., 27.);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p);\n    p *= p*p*(p*(p*6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n\n\n\n// Cheap and nasty 2D smooth noise function with inbuilt hash function -- based on IQ's \n// original. Very trimmed down. In fact, I probably went a little overboard. I think it \n// might also degrade with large time values.\nfloat n2D(vec2 p) {\n\n\tvec2 i = floor(p); p -= i; //p *= p*(3. - p*2.);  \n    \n    p *= p*p*(p*p*6. - p*15. + 10.); \n    \n    return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))*43758.5453))*\n                vec2(1. - p.y, p.y), vec2(1. - p.x, p.x) );\n\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\nfloat fbmCam(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267; }\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec2 tri(in vec2 x){return abs(x - floor(x) - .5);} // Triangle function.\nvec2 triS(in vec2 x){return cos(x*6.2831853)*.25 + .25;} // Smooth version.\n\n// Height function layers. \nfloat h1(vec2 p){ return dot(tri(p + tri(p.yx*.5 + .25)), vec2(1)); }\nfloat h1Low(vec2 p){ return dot(triS(p + triS(p.yx*.5 + .25)), vec2(1)); }\n\n// Terrain height function. Just a few layers.\nfloat h(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    \n    //for(int i=0; i<1; i++) {\n    \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    //}\n    \n    for(int i=1; i<5; i++) {\n        ret += a*h1(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret /= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n// The camera height function, which is a smoother version of the terrain function.\nfloat hLow(vec2 p) {\n    \n    float ret = 0., m = 1., a = 1., s = 0.;\n    for(int i=0; i<2; i++){\n        \n        ret += a*h1Low(p/m);\n        //ret += a * n2D(p/m);\n        p = r2(1.57/3.73)*p;\n        //p = mat2(1, .75, -.75, 1)*p;\n        m *= -.375;\n        s += a;\n        a *= .3;\n    }\n    \n    ret /= s;\n    \n    return ret*.25 + ret*ret*ret*.75;\n\n}\n\n// Surface function.\nfloat surfaceFunc(vec3 q){\n    \n    // Height.\n    float sf = h(q.xz/20.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*5.;\n}\n\n// Surface function for the camera.\nfloat surfaceFuncCam(vec3 q){\n    \n    // Height.\n    float sf = hLow(q.xz/20.);\n    \n    // Experimental way to dig out a trench.\n    sf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n    \n    return (.5 - sf)*3.;\n}\n\n// Toroidal distance function... Technically, a lot of these are just\n// bounds, so not exactly correct, which means shadows, glow, and other\n// things can be effected. However, they're cheaper, and you can't really\n// tell here.\nfloat distT(vec2 p){\n    \n    // Try some of the others, if you get bored enough. :)\n    \n    //return max(abs(p.x)*.866025 + p.y*.5, -p.y); // Triangle.\n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return (p.x + p.y)*.7071; // Diamond.\n    //return max(p.x, p.y); // Square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max((p.x + p.y)*.7071 - .4, max(p.x, p.y)); // Octagon.\n    \n}\n\n// Poloidal distance function. As mentioned above these are technically\n// bounds, but they work well enough.\nfloat distP(vec2 p){\n    \n    //return length(p); // Circle.\n    \n    p = abs(p);\n    return max((p.x + p.y)*.7071 - .06, max(p.x, p.y)); // Beveled square.\n    //return max(p.x*.866025 + p.y*.5, p.y); // Hexagon.\n    //return max(p.x, p.y); // Square.\n    \n}\n\n// Global scale, to space out the chrome objects.\nconst vec3 sc = vec3(16, 4, 4);\n\nfloat objects(vec3 p){\n    \n    \n    p.xz += sc.xz/2.;\n    \n    vec3 ip = floor(p/sc)*sc;\n    \n \n    // Repeating objects across the terrain in Z direction.\n    p.xz = vec2(p.x, p.z - ip.z) - sc.xz*.5; // Equivalent to: mod(p.xz, sc) - sc*.5;\n    // Repeating objects across the terrain in the X and Z directions.\n    //p.xz = (p.xz - ip.xz) - sc.xz*.5; // vec2(p.x, mod(p.z, sc.y)) - sc*.5;\n    \n    \n    // Obtaining the surface height at the center of the grid. This height is used\n    // to shift the object to the approximate top of the terrain.\n    float sf = surfaceFunc(ip);\n    \n    // Add the grid height to the object's Y position.\n    p.y += sf - 1.8;\n    \n    // Use the object's Z position to rotate it about the XY plane. This effect looks\n    // better on a flat terrain.\n    p.xy = r2(sc.z/16. - ip.z/16.)*p.xy;\n    // Random XZ rotation, just to show it can be done.\n    //p.xz = r2((hash(ip.z) - .5)/2.)*p.xz;\n    \n    \n    const float sz = 1.8;\n    const float th = .5;\n     \n    // Toroidal angle. \n    //float a = atan(p.y, p.x);\n    \n    // Toroidal distance -- The large radius part.\n    p.xy = vec2(distT(p.xy) - sz, p.z);\n    // Windows logo warp. :)\n    //p.xy = vec2(distT(p.xy) - sz + sin(a*4.)*.125, p.z);\n    \n    // Mobius-like twisting: Twisting the toroidal axis one full revolution\n    // about the poloidal plane... Yeah, it confuses me too. :) Be sure to\n    // uncomment the \"atan\" bit above.\n    //p.xz = r2(a)*p.xz;\n    \n    \n    // Poloidal distance. The smaller radius part. \n    float obj = distP(p.xz) - th/2.;\n    \n     \n    // Return the cell object.\n    return obj;\n    \n}\n\n\n// The distance function. Just some geometric objects and some terrain.\nfloat map(vec3 p){\n    \n    // Wrap everything around the path.\n    p.xy -= path(p.z);\n    \n    // The surface function. Essentially, the bumps we add to the terrain.\n    float sf = surfaceFunc(p);\n    \n    // The terrain, which we're lowering a bit.\n    float terr = p.y + .0 + sf;\n\n    // The chrome objects. \n    float obj = objects(p);\n    \n    // Store the terrain and object IDs, for sorting later.\n    objID = vec4(terr, obj, 0, 0);\n    \n    // Return the minimum distance.\n    return min(terr, obj);\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.866; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i=0; i<56; i++){\n\n        d = map(ro + rd*t);//*rDir;\n        \n        if(abs(d)<.001*(t*.1 + 1.) || t>FAR) break;\n        \n        t += d*.9;\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Bump function. \nfloat bumpSurf3D( in vec3 p, float t){\n    \n    \n    float c, c0 = 0., c1 = 0.;\n    \n    //float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    //const float bordW = .0;\n    \n    \n    // Terrain.\n    if(svObjID == 0.){// || abs(bordTx0Tx1)<bordW) {\n        \n        c0 = fbm(p.xz*8.);\n        \n        c0 = (1. - c0)/3.;\n    }\n    /*\n    // Metallic objects. The original image has a metallic bump, \n    // but I wanted to keep it smooth.\n    if(svObjID == 1.){// || abs(bordTx0Tx1)<bordW) {\n    \n        \n        c1 = (n3D(p*6.)*.66 + n3D(p*12.)*.34);\n        c1 = smoothstep(0., .1, n3D(p*3.) - .65)*c1/12.;\n        \n        //c1 = (1. - smoothstep(.05, .3, c1))/4.;\n        \n    }\n    */\n    // Used to fade the bump when objects are near one another, but\n    // I feel it's a little bit of overkill, for this particular example.\n    //c = mix(c0, c1, step(oSvObjID.y, oSvObjID.x));\n    //c = mix(c0, c1, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n    \n    c = c0;\n    \n    // Fading the bump out over distance.\n    return c/(1. + t*t*3.);\n    \n}\n\n\n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor, float t){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0); \n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    float ref = bumpSurf3D(p, t);\n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, t),\n                      bumpSurf3D(p - e.yxy, t),\n                      bumpSurf3D(p - e.yyx, t)) - ref)/e.x; \n    \n    /*\n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    vec3 grad = vec3(bumpSurf3D(p - e.xyy, t) - bumpSurf3D(p + e.xyy, t),\n                     bumpSurf3D(p - e.yxy, t) - bumpSurf3D(p + e.yxy, t),\n                     bumpSurf3D(p - e.yyx, t) - bumpSurf3D(p + e.yyx, t))/e.x*.5;\n    */\n       \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= nor*dot(nor, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(nor + grad*bumpfactor);\n\t\n}\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .05, .5); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 0.) + .2, 1.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n    \n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n\nvec3 getSky(vec3 ro, vec3 rd, vec3 lp){\n\n    // Gradient blues, and red, or something.\n    vec3 sky = max(mix(vec3(1, .7, .6), vec3(.7, .9, 1.5), rd.y + .0), 0.)/4.; \n    \n    // Last minute contrast.\n    sky = pow(sky, vec3(1.25))*1.25;\n    \n    // Horizon strip.\n    sky = mix(sky, vec3(1, .1, .05), (1. - smoothstep(-.1, .25, rd.y))*.3);\n    \n    \n\t// Blending in the sun.\n    float sun = max(dot(normalize(lp - ro), rd), 0.);\n    //sky = mix(sky, vec3(.6, 1, .5), pow(sun, 6.)*.5);\n    sky = mix(sky, vec3(1, .7, .6)*.9, pow(sun, 6.));\n    sky = mix(sky, vec3(1, .9, .8)*1.2, pow(sun, 32.));\n\n\n    // Subtle, fake sky curvature.\n    rd.z *= 1. + length(rd.xy)*.25;\n    rd = normalize(rd);\n\n    // A simple way to place some clouds on a distant plane above the terrain -- Based on something IQ uses.\n    const float SC = 1e5;\n    float tt = (SC - ro.y - .15)/(rd.y + .15); // Trace out to a distant XZ plane.\n    vec2 uv = (ro + tt*rd).xz; // UV coordinates.\n\n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n    if(tt>0.) {\n\n        float cl = fbm(1.5*uv/SC);\n\n        // White clouds.\n        sky =  mix(sky, vec3(1)*vec3(1, .9, .85), smoothstep(.3, .95, cl)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.5); \n        // Fake dark shadow. Subtle, but kind of worth doing. :)\n        sky =  mix(sky, vec3(0), smoothstep(.0, .95, cl)*fbm(7.*uv/SC)*\n                   smoothstep(.475, .575, rd.y*.5 + .5)*.3);\n\n    }\n\n    // Speckles. Not science based, but it looks intering.\n    vec3 p = (ro + rd*FAR)/1. + vec3(0, 0, iTime);\n    float st = n3D(p)*.66 + n3D(p*2.)*.34;\n    st = smoothstep(.1, .9, st - .0);\n    sky = mix(sky, vec3(.7, .9, 1), (1. - sqrt(st))*.05);\n    \n    // The sky color.\n    return sky;\n\n}\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    // Contorting the texture coordinates to math the contorted scene.\n    //vec3 txP = p - vec3(path(p.z), 0.);\n    p = p - vec3(path(p.z), 0.);\n\n    // Texture value, and individual texture values.\n    vec3 tx, tx0, tx1;\n    \n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075;\n    \n     \n    // If we hit the terrain, or hit the region near the terrain, color\n    // it up.\n    if(svObjID==0. || abs(bordTx0Tx1)<bordW){\n        \n        // Noisy color mixing. Tweaked until it looked right.\n        vec2 q = p.xz;\n\n        float c = n2D(q)*.6 + n2D(q*3.)*.3 + n2D(q*9.)*.1;\n        c = c*c*.7 + sFract(c*4., 12.)*.3;\n        c = c*.9 + .2;\n        tx0 = mix(vec3(1, .3, .2), vec3(1, .35, .25), n2D(q*6.));\n        tx0 *= c;\n\n        float c2 = n2D(q*20.)*.66 + n2D(q*40.)*.34;\n        c2 = smoothstep(.1, .6, c2*c2);\n\n\n        tx0 = mix(tx0*vec3(1.2, .8, .65).zyx, tx0, abs(n));\n        tx0 = mix(tx0, vec3(0), c2*.4);\n\n        //tx0 *= mix(vec3(1.2, .8, .6), vec3(1.2, .8, .6).yxz, -n.y*.5 + .5);\n\n        \n        /*\n        // Extra shadowing. A bit much, in this case.\n \t\t\n\t\t// Matches the terrain height function.\n        float sf = h(p.xz/20.);\n    \n        // Experimental way to dig out a trench.\n    \tsf -= smax(1.4 - q.x*q.x*.5, 0., 1.)*.12;\n        \n        tx0 *= smoothstep(-.1, .5, sf) + .5;\n        */\n        \n    }\n     \n    // If the ray hits the metallic object, or close to it, color it dark.\n    // The shininess is provided with the relective color. I used to get \n    // this wrong all the time. :)\n    if(svObjID==1. || abs(bordTx0Tx1)<bordW) tx1 = vec3(.08, .1, .12);\n    \n    \n    // Return the color, which is either the terrain color, the shiny object color,\n    // or if we're in the vicinity of both, make it a mixture of the two.\n    tx = mix(tx0, tx1, smoothstep(-bordW, bordW, bordTx0Tx1));\n   \n    \n    return tx; // Return the object color.\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float edge, float crv, float ao, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 1.5/(1. + lDist*0.001 + lDist*lDist*0.0001);\n\n        // Standard diffuse term.\n        float diff = max(dot(ld, sn), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max(dot(reflect(-ld, sn), -rd), 0.), 32.);\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n        \n        // Ramp up the diffuse value on the shiny geometric object. It's a cheap\n        // trick to make things look shiny.\n        if(svObjID==1.) diff *= diff*2.;\n\n        // Coloring the object, accoring to object ID,.        \n        vec3 objCol = getObjectColor(sp, sn);\n\n        \n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .35 + fres*fres*0. + vec3(.5, .7, 1)*spec);\n        \n        \n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    // Get the sky color.  \n    vec3 sky = getSky(ro, rd, lp);\n    \n    // Smoothly blend it in, according to the FAR plane distance. Basically, we want it\n    // to fade in strongly as we hit the horizon.\n    sceneCol = mix(sceneCol, sky, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc.\n \n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2., occ = 0.;\n    for(int i=0; i<5; i++){\n    \n        float hr = .01 + float(i)*.5/4.;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= .7;\n    }\n    return clamp(1. - occ, 0., 1.);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 1.25, iTime*2.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .5);  // \"Look At\" position.\n    \n    \n    // Light position. Set in up in the sky above the horizon -- out near the far plane.\n    vec3 lp = ro + vec3(-20, 30, 60);\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path, which is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    // Using a smoother version of the terrain function to move the camera up and down.\n    // Alternatively, you could thread it through some Bezier points... if you're not\n    // lazy, like me. :D\n    ro.y -= surfaceFuncCam(ro.xyz);\n    lk.y -= surfaceFuncCam(lk.xyz);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Warped unit direction vector, for a warped lens effect.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.15));\n    \n    \n    // Edge and curvature variables. Not used here.\n    float edge = 0., crv = 1.;\n\n    \n    // FIRST PASS.\n    //\n    float t = trace(ro, rd); // Trace.\n\n    // Save the object IDs after the first pass.\n    svObjID = objID.x<objID.y? 0. : 1.;\n    oSvObjID = objID;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    vec3 sp = ro + rd*t;\n    \n    // Retrieving the normal at the hit point, plus the edge and curvature values.\n    //vec3 sn = getNormal(sp, edge, crv);\n    vec3 sn = getNormal(sp);\n    \n    // Function based bump mapping. the final value is a fade off with\n    // respect to distance.\n    sn = doBumpMap(sp, sn, .2, t/FAR);\n    \n\n    \n    // Fresnel. Handy for all kinds of aesthetic purposes. Not used here.\n    //float fr = clamp(1. + dot(rd, sn), 0., 1.);\n    \n    // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n    // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n    // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n    // right without them.\n    float sh = softShadow(sp + sn*.002, lp, 12., t); // Set to \"1.,\" if you can do without them.\n    float ao = calculateAO(sp, sn);\n    sh = (sh + ao*.3)*ao;\n    \n\n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, sp, rd, sn, lp, edge, crv, ao, t);\n\n    \n   \n    // SECOND PASS\n    \n    // Reflected and refracted rays.\n    vec3 refl = reflect(rd, sn); // Standard reflection.\n    //vec3 refr = refract(rd, sn, 1./1.33); // Water refraction. Note the inverted index.\n    \n    // We're branching off from the same spot in two directions, so we'll use this so as\n    // not to interfere with the original surface point vector, \"sp.\" It was a style\n    // choice on my part, but there are other ways.\n    vec3 refSp; \n    \n    // REFLECTED PASS\n    //\n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that.\n    \n    \n    // Making thing complicated for myself, and anyone trying to read this, just so I\n    // can blend the terrain into the object... In my defence, the unblended dirt doesn't\n    // quite look right sitting against the object. :)\n    float bordTx0Tx1 = oSvObjID.x - oSvObjID.y;\n    const float bordW = .075; // Blend border width... Kind of.\n    \n    // If the ray hits the chrome geometric object, or the ground nearby, perform a\n    // reflective pass.\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n\n        // The ray is edged off the surface, as required, but note that it has to be enough\n        // to avoid conflict with the break condition in the \"reflected\" trace algorithm.\n        t = traceRef(sp + refl*.002, refl);\n\n        // Save the object IDs after the second pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n\n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = sp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n        //sceneColor = sceneColor + reflColor*1.33;\n        //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n        \n        \n        #ifndef THIRD_PASS\n        // Very cheap third pass: It'd be nice to put a proper third pass in, but we're \n        // pushing our luck as it is, so we'll make do with a makeshift sky reflection.\n      \n        //if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        if(svObjID == 1. && t<FAR){\n            \n            refl = reflect(refl, sn);\n            vec3 sky = getSky(ro, refl, lp);\n            sceneColor = mix(sceneColor, sceneColor*.7 + sceneColor*sky*5.*vec3(1.15, 1, .85), smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n            //sceneColor = sceneColor + tpCol*sky*4.;\n            //sceneColor = sceneColor*.7 + tpCol;\n            //sceneColor = sceneColor*.35 + mix(reflColor, sceneColor, fr*fr*.66 + .34)*2.5;\n            \n        }\n        #endif\n    \n    }\n    \n    /*\n\t// Really bad cheap reflection pass. Only here for debug purposes. \n    //if(svObjID==1. && t<FAR){\n    if((svObjID==1. || abs(bordTx0Tx1)<bordW)  && t<FAR){\n        \n         vec3 sky = getSky(sp, refl, lp);\n         sceneColor = mix(sceneColor, sceneColor + sceneColor*sky*20., smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n      \n    }\n    */\n    \n    #ifdef THIRD_PASS\n    // More correct third pass: Since it's just a reflection off a reflection of one\n    // object, we're not using it by default, but it's there if you want it.\n    if(svObjID == 1. && t<FAR){\n        \n        refl = reflect(refl, sn);\n        \n        t = traceRef(refSp + refl*.002, refl);\n\n        // Save the object IDs after the third pass.\n        svObjID = objID.x<objID.y? 0. : 1.;\n    \toSvObjID = objID;\n        \n\n        // Advancing the ray from the new origin, \"sp,\" to the new reflected hit point.\n        refSp = refSp + refl*t;\n\n        // Retrieving the normal at the reflected hit point.\n        sn = getNormal(refSp);//*rDir;\n        //edge = 0.;\n\n        \n        // Color at the reflected hit point.\n        vec3 reflColor = doColor(sp, refSp, refl, sn, lp, edge, crv, 1., t);\n        sceneColor = mix(sceneColor, sceneColor + reflColor*1.33, smoothstep(-bordW/2., bordW/2., bordTx0Tx1));\n     \n        //sceneColor = sceneColor + reflColor*1.25; \n    }\n    #endif\n     \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway.\n    sceneColor *= sh;\n    \n    \n    \n   \n    // POSTPROCESSING\n    // Interesting red to blueish mix.\n    //sceneColor = mix(sceneColor, pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)), uv.y);\n    //sceneColor = pow(max(sceneColor, 0.), vec3(1.25))*1.33; // Adding a bit of contrast.\n    //sceneColor *= mix(vec3(1.2, 1, .9).yxz, vec3(1.2, 1, .9).zyx, -rd.y*.5 + .5);\n    \n    /*\n    vec2 u2 = uv*r2(3.14159/6.);\n    float overlay = 1. + .35*sin(u2.x*3.14159*iResolution.y/1.5);\n    overlay *= 1. + .35*sin(u2.y*3.14159*iResolution.y/1.5); \n    sceneColor *= overlay*1.1;\n    */\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(max(sceneColor, 0.)), 1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}