{
    "Shader": {
        "info": {
            "date": "1502903837",
            "description": "Quick demo of Screen-Space Ambient Occlusion (SSAO).\n\nNothing new (this specific technique is used a by a few other shadertoys), but needed a SSAO implementation for other shaders in development.\n\nUse mouse to drag screen dividers.",
            "flags": 32,
            "hasliked": 0,
            "id": "Xd2BDt",
            "likes": 6,
            "name": "SSAO Demo",
            "published": 3,
            "tags": [
                "demo",
                "occlusion",
                "ambient",
                "ssao"
            ],
            "usePreview": 0,
            "username": "ssell",
            "viewed": 1592
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://www.shadertoy.com/view/Xd2BDt\n *\n * Demo of Screen-Space Ambient Occlusion (SSAO).\n * See 'Buf B' for SSAO implementation and reference.\n *\n * Top Left Screen:  Full lighting (diffuse, ambient, specular, shadows, AO)\n * Top Right Screen: Lighting without AO.\n * Bottom Screen:    AO only.\n *\n * Use mouse to drag dividers.\n */\n\n// '3Dfx Rotated Grid' from\n// https://www.shadertoy.com/view/4dGXW1\nvec4 SampleAA(sampler2D sampler, in vec2 uv)\n{\n    vec2 s = vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n    vec2 o = vec2(0.11218413712, 0.33528304367) * s;\n    \n    return (texture(sampler, uv + vec2(-o.x,  o.y)) +\n            texture(sampler, uv + vec2( o.y,  o.x)) +\n            texture(sampler, uv + vec2( o.x, -o.y)) +\n            texture(sampler, uv + vec2(-o.y, -o.x))) * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec4 color = SampleAA(iChannel0, uv);\n   \n    // Don't apply vignette to surface of AO only render.\n    if(color.a > 0.01)\n    {\n        color.rgb *= 0.5 + 0.5 * pow(16.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.3);\n    }\n    \n    fragColor = vec4(color.rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://www.shadertoy.com/view/Xd2BDt\n *\n * Simple test scene for SSAO composed of a fractal sphere.\n *\n * It outputs a buffer containing the following:\n *\n *     .rgb = Surface normal.\n *     .a.x = Depth\n *     .a.y = Material ID\n *     .a.z = Shadow \n *\n * Where .a is a packed R8G8B8 vector.\n */\n\n//------------------------------------------------------------------------------------------\n// Defines and Constants\n//------------------------------------------------------------------------------------------\n\n#define NearClip 0.01\n#define FarClip  10.0\n#define MaxSteps 100\n#define ScenePos vec3(2.0, -3.0, -5.0)\n\nconst vec3 SunLightDir = normalize(vec3(-1.0, 2.0, 1.0));\n\n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------\n\nstruct Ray { vec3 o; vec3 d; }; struct Camera { vec3 r; vec3 u; vec3 f; vec3 o; }; Ray Camera_GetRay(in Camera camera, vec2 uv) { Ray ray; uv = (uv * 2.0) - 1.0; uv.x *= (iResolution.x / iResolution.y); ray.o = camera.o; ray.d = normalize((uv.x * camera.r) + (uv.y * camera.u) + (camera.f * 2.5)); return ray; } Camera Camera_LookAt(vec3 o, vec3 lookAt) { Camera camera; camera.o = o; camera.f = normalize(lookAt - camera.o); camera.r = normalize(cross(camera.f, vec3(0.0, 1.0, 0.0))); camera.u = normalize(cross(camera.r, camera.f)); return camera; }\n\nfloat PackR8G8B8(vec3 rgb)\n{\n    rgb = (rgb * 255.0) + 0.5;\n    return float((uint(rgb.r)) | (uint(rgb.g) << 8) | (uint(rgb.b) << 16));\n}\n\n//------------------------------------------------------------------------------------------\n// SDFs\n//------------------------------------------------------------------------------------------\n\nvec3 Repeat(vec3 p, vec3 c)\n{\n\treturn mod(p, c) - (0.5 * c);    \n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\nfloat Cutout(vec3 p, float d)\n{\n\tvec2 l = vec2(FarClip, d);\n    \n    float x = Capsule(p, -l.xyy, l.xyy, d);\n    float y = Capsule(p, -l.yxy, l.yxy, d);\n    float z = Capsule(p, -l.yyx, l.yyx, d);\n    \n    return min(x, min(y, z));\n}\n\nvec2 Scene(vec3 pos)\n{\n    pos -= ScenePos;\n    \n    float id    = 0.0;\n    float base  = Sphere(pos, 2.0);\n    float scale = 0.51;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        vec3 p = Repeat(pos, vec3(4.3 + sin(iTime * 0.1)) * scale);\n        \n    \tfloat cut  = Cutout(p, scale);\n        float temp = max(base, -cut);\n        \n        if(temp > base)\n        {\n            base = temp;\n            id = float(i);\n        }\n        \n        scale *= 0.2;\n    }\n    \n    return vec2(base, id);\n}\n\n//------------------------------------------------------------------------------------------\n// Raymarching\n//------------------------------------------------------------------------------------------\n\nvec2 March(in Ray ray)\n{\n    float depth = NearClip;\n    \n    for(int i = 0; i < MaxSteps; ++i)\n    {\n    \tvec3 pos = ray.o + (ray.d * depth);\n        vec2 sdf = Scene(pos);\n        \n        if((sdf.x <= (0.001 * depth)) || (depth >= FarClip))\n        {\n            return vec2(depth, sdf.y);\n        }\n        \n        depth += sdf.x;\n    }\n    \n    return vec2(FarClip, 0.0);\n}\n\nvec3 Normal(vec3 pos, float depth)\n{\n    vec2 eps = vec2(0.00001 * depth, 0.0);\n    return normalize(vec3(Scene(pos + eps.xyy).x - Scene(pos - eps.xyy).x,\n                          Scene(pos + eps.yxy).x - Scene(pos - eps.yxy).x,\n                          Scene(pos + eps.yyx).x - Scene(pos - eps.yyx).x));\n}\n\nfloat Shadow(vec3 pos)\n{\n    float shadow = 1.0;\n    float depth  = 0.1;\n    \n    for(int i = 0; i < 32; ++i)\n    {\n        vec3 p = pos + (SunLightDir * depth);\n        vec2 sdf = Scene(p);\n        \n        shadow = min(shadow, (16.0 * sdf.x) / depth);\n        depth += sdf.x;\n        \n        if(sdf.x < 0.001)\n        {\n            break;\n        }\n    }\n    \n    return shadow;\n}\n\n//------------------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------------------\n\nvoid Render(Ray ray, inout vec3 norm, inout float depth, inout float id, inout float shadow)\n{\n    vec2 march = March(ray);\n    \n    if(march.x < FarClip)\n    {\n        vec3 pos = ray.o + (ray.d * march.x);\n        \n        norm   = Normal(pos, march.x);\n        depth  = clamp(march.x / FarClip, 0.0, 1.0);\n        id     = march.y;\n        shadow = Shadow(pos);\n    }\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    Camera camera = Camera_LookAt(vec3(0.0, 0.0, 0.0), ScenePos);\n    Ray ray = Camera_GetRay(camera, uv);\n    \n    vec3  norm   = vec3(0.0);\n    float depth  = 1.0;\n    float id     = 0.0;\n    float shadow = 1.0;\n    \n    Render(ray, norm, depth, id, shadow);\n    \n    fragColor = vec4(norm, PackR8G8B8(vec3(depth, id / 2.0, shadow)));\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/**\n * Created by Steven Sell (ssell) / 2017\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * https://www.shadertoy.com/view/Xd2BDt\n *\n * This SSAO implementation is based on the article found at:\n *\n *     https://www.gamedev.net/articles/programming/graphics/a-simple-and-practical-approach-to-ssao-r2753\n *\n * The basic algorithm can be summed up as:\n *\n *     In screen-space, we sample a number of neighboring UV positions.\n *     For each sample, we must be able to reconstruct a position.\n *     This position is used to calculate the distance and angle between\n *     the sample and our current texel.\n *\n *     The distance and angle are used in the following formula to calculate\n *     an ambient occlusion value:\n *\n *         max(0.0, dot(N, V)) * (1.0 / (1.0 + D))\n * \n *     Where,\n *\n *         N: Our texel's normal\n *         V: Is the normalized vector to the sample position\n *         D: Is the distance to the sample position from our texel position.\n *\n *         max(0.0, dot(N, V)) : Angle cosine on range [0, 1]\n *         (1.0 / (1.0 + D)) : Interpolation based on distance\n *\n *     So neighboring samples that are spatially near our texel contribute to occlusion.\n *     This contribution is scaled by the relative location of the neighbor to the texel.\n *     Neighbors near to, and directly above, our texel contribute a significant amount\n *     of occlusion. Density of neighbors also affects the overall occlusion value.\n *\n *     We sum the individual contribution of neighboring samples and then divide it\n *     by the number of samples taken to produce the final average occlusion value.\n *\n *     This occlusion value represents:\n *\n *         0.0: No occlusion (full ambient lighting)\n *         1.0: Full occlusion (no ambient lighting)\n *\n *     So our final ambient lighting value is:\n *\n *         (Ambient Lighting) * (1.0 - Ambient Occlusion)\n */\n\n//------------------------------------------------------------------------------------------\n// Defines and Constants\n//------------------------------------------------------------------------------------------\n\n#define PiTwo           6.2832\n#define OneOverPi       0.3183\n#define FarClip         10.0\n#define ScenePos        vec3(2.0, -3.0, -5.0)\n\n#define AOSampleRadius  10.0\n#define AOSampleCount   8\n#define AODistScale     1.0\n#define AOIntensity     5.0\n\nconst vec3 SunLightDir = normalize(vec3(-1.0, 2.0, 1.0));\nconst vec3 SunLightCol = vec3(1.0);\nconst vec3 AmbLightDir = normalize(SunLightDir * vec3(-1.0, 0.0, -1.0));\nconst vec3 AmbLightCol = vec3(1.0);\n\n//------------------------------------------------------------------------------------------\n// Utilities\n//------------------------------------------------------------------------------------------\n\nstruct Ray { vec3 o; vec3 d; }; struct Camera { vec3 r; vec3 u; vec3 f; vec3 o; }; Ray Camera_GetRay(in Camera camera, vec2 uv) { Ray ray; uv = (uv * 2.0) - 1.0; uv.x *= (iResolution.x / iResolution.y); ray.o = camera.o; ray.d = normalize((uv.x * camera.r) + (uv.y * camera.u) + (camera.f * 2.5)); return ray; } Camera Camera_LookAt(vec3 o, vec3 lookAt) { Camera camera; camera.o = o; camera.f = normalize(lookAt - camera.o); camera.r = normalize(cross(camera.f, vec3(0.0, 1.0, 0.0))); camera.u = normalize(cross(camera.r, camera.f)); return camera; }\n\nvec3 UnpackR8G8B8(float f)\n{\n    uint ufloat = uint(f);\n    return vec3(float(ufloat & 0xFFu), float((ufloat >> 8) & 0xFFu), float((ufloat >> 16) & 0xFFu)) * 0.00392156862;\n}\n\nvec4 GetUVNormDepth(vec2 uv)\n{          \n    return textureLod(iChannel0, uv, 0.0);\n}\n\n//------------------------------------------------------------------------------------------\n// SSAO \n//------------------------------------------------------------------------------------------\n\n\nfloat SampleAO(\n    vec3 pos,         // The world position for our current texel\n    vec3 norm,        // The normal for our current texel\n    vec2 sampleUV)    // The UV for the sample\n{\n    Camera camera = Camera_LookAt(vec3(0.0), ScenePos);\n    Ray ray = Camera_GetRay(camera, sampleUV);\n    \n\tfloat aoSampleDepth = UnpackR8G8B8(GetUVNormDepth(sampleUV).a).r;    // Retrieve sample depth value.\n    \n    vec3 aoSamplePos = ray.o + (ray.d * aoSampleDepth * FarClip);        // Reconstruct sample position.\n    vec3 aoToVector  = (aoSamplePos - pos);                              // Vector from texel to sample.\n     \n    float dist = length(aoToVector) * AODistScale;\n    float occl = max(0.0, dot(norm, normalize(aoToVector))) * (1.0 / (1.0 + dist)) * AOIntensity;\n    \n    return clamp(occl, 0.0, 1.0);\n}\n\nfloat AmbientOcclusion(\n    vec2 uv,          // The UV for our current texel\n    vec3 pos,         // The world position for our current texel\n    vec3 norm)        // The normal for our current texel\n{\n    float ao     = 0.0;\n    float rstep  = (AOSampleRadius / pos.z) / float(AOSampleCount);\n    float radius = rstep;                                             \n    float rangle = textureLod(iChannel1, uv * 100.0, 0.0).r * PiTwo;\n    \n    // Perform a radial sampling. For each iteration we adjust the angle and increase the radius.\n    for(int i = 0; i < AOSampleCount; ++i, radius += rstep, rangle += 2.4)\n    {\n        vec2 sampleUV = vec2(sin(rangle), cos(rangle)) * radius;\n        ao += SampleAO(pos, norm, uv + sampleUV);\n    }\n    \n    return clamp(ao / float(AOSampleCount), 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------------------\n\nconst vec3 Albedos[3] = vec3[](vec3(0.3, 0.4, 0.5), vec3(0.3, 0.3, 0.4), vec3(0.175, 0.175, 0.275));\n\nvec3 BuildAlbedo(int id)\n{\n    return Albedos[clamp(id, 0, 3)];\n}\n\nvec3 LambertianDiffuse(vec3 albedo)\n{\n    return albedo * OneOverPi;\n}\n\nvec3 Lighting(vec3 rd, vec2 uv, vec3 pos, vec3 norm, float ao, float shadow)\n{\n    vec3 sunLight = SunLightCol * clamp(dot(norm, SunLightDir), 0.0, 1.0) * 4.0;\n    vec3 ambLight = AmbLightCol;\n    \n    vec3 reflVec   = reflect(-SunLightDir, norm);\n    vec3 specLight = pow(max(0.0, dot(rd, -reflVec)), 2.0) * vec3(1.0) * shadow * 2.0;\n    \n    return (sunLight * shadow) + (ambLight * ao) + specLight;\n}\n\nvec3 GammaCorrect(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvec4 Shade(vec2 uv, Ray ray, vec3 norm, float depth, float shadow, int id, int section)\n{\n    vec3  pos = ray.o + (ray.d * depth);\n    float ao  = 1.0 - AmbientOcclusion(uv, pos, norm);\n    \n    if(section == 3)         // AO Only\n    {\n        return vec4(vec3(ao), 0.0);\n    }\n    \n    if(section == 2)         // No AO \n    {\n        ao = 1.0;\n    }\n                             \n    vec3 albedo  = BuildAlbedo(id);\n    vec3 diffuse = LambertianDiffuse(albedo);\n    vec3 light   = Lighting(ray.d, uv, pos, norm, ao, shadow);\n    \n    vec3 color = GammaCorrect(diffuse * light);\n    \n    return vec4(color, 1.0);\n}\n\n//------------------------------------------------------------------------------------------\n// Main\n//------------------------------------------------------------------------------------------\n\nint ScreenSection(vec2 fragCoord)\n{\n\tvec2 mouse = iMouse.xy;\n    \n    if(mouse.xy == vec2(0.0))\n    {\n        mouse.xy = iResolution.xy * vec2(0.5, 0.3);\n    }\n    \n    if(abs(fragCoord.y - mouse.y) < 1.0 || \n      (abs(fragCoord.x - mouse.x) < 1.0 && fragCoord.y > mouse.y))\n    {\n        return 0;      // Divider line\n    }\n    \n    if(fragCoord.y > mouse.y)\n    {\n    \tif(fragCoord.x < mouse.x)\n        {\n            return 1;  // Top Left - With AO\n        }\n        \n        return 2;      // Top Right - Without AO\n    }\n        \n    return 3;          // Bottom - AO Only  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.1, 0.1, 0.125, 1.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 normDepth = GetUVNormDepth(uv);\n    \n    Ray ray = Camera_GetRay(Camera_LookAt(vec3(0.0), ScenePos), uv); \n    \n    vec3 unpacked = UnpackR8G8B8(normDepth.a);\n    \n    vec3  norm    = normDepth.rgb;\n    float depth   = unpacked.r;\n    float shadow  = unpacked.b;\n    int   matID   = int(unpacked.g * 3.0);\n    int   section = ScreenSection(fragCoord);\n    \n    if(section == 0)\n    {\n        fragColor.rgb = vec3(0.1, 0.1, 0.125);\n        return;\n    }\n    \n    if(depth < 0.999)\n    {\n\t\tfragColor = Shade(uv, ray, norm, depth, shadow, matID, section);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}