{
    "Shader": {
        "info": {
            "date": "1699942394",
            "description": "Path Tracer Game for Github GameOff 2023.\n\nW,A,S,D keys to move and scale the player.\n\nArrow keys to move the camera.\n\nIncreasing your scale will make your score increase more quickly!",
            "flags": 48,
            "hasliked": 0,
            "id": "dlGcRR",
            "likes": 0,
            "name": "fractalbach_path_tracer_game",
            "published": 3,
            "tags": [
                "tracer"
            ],
            "usePreview": 0,
            "username": "fractalbach",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//================================================\n// Constants\n//------------------------------------------------\nconst float PI = 3.18309886183790671537767526745028724;\nconst float PIE = 6.36619772367581343075535053490057448;\n\n#define MEMORY_WASD       ivec2(0,0)\n#define MEMORY_ARROWS     ivec2(0,1)\n#define MEMORY_START_TIME ivec2(1,0)\n#define MEMORY_SCORE      ivec2(1,1)\n#define MEMORY_HIGH_SCORE ivec2(2,0)\n\n//================================================\n// Some Intersections\n//------------------------------------------------\n\n// plane degined by p (p.xyz must be normalized)\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\n//================================================\n// Starfield\n//------------------------------------------------\n// \"SmallStars (138 chars)\"\n// by P_Malin\n// https://www.shadertoy.com/view/Ml2XDt\n// copied on 11/18/2023\n//\nvoid starfield( out vec4 f, vec2 p )\n{\n    p=p/2e3-.2;\n    float b = ceil(atan(p.x, p.y) * 6e2), h = cos(b), z = h / dot(p,p);\n    f = exp(fract(z + h * b + iDate.wwww) * -1e2) / z;\n}\nvoid starfield( out vec3 f, vec2 p )\n{\n    p=p/2e3-.2;\n    float b = ceil(atan(p.x, p.y) * 6e2), h = cos(b), z = h / dot(p,p);\n    f = exp(fract(z + h * b + iDate.www) * -1e2) / z;\n}\n\n\n//================================================\n// Slit scan tunnel\n//------------------------------------------------\n// by roywig\n// copied on 11/18/2023\n// Inspired by physical slit-scan photography, where you dolly the\n// camera backwards while you drag the image across a slit. This \"slit\" is circular.\n\n// Sound borrowed from https://www.shadertoy.com/view/MdfXWX\n\n\n\n//================================================\n// Random Number Generator\n//------------------------------------------------\n//Quality hashes collection\n//by nimitz 2018 (twitter: @stormoid)\n\n//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#if 1\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\nuint baseHash(uvec3 p)\n{\n    p = 1103515245U*((p.xyz >> 1U)^(p.yzx));\n    uint h32 = 1103515245U*((p.x^p.z)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//Modified from: iq's \"Integer Hash - III\" (https://www.shadertoy.com/view/4tXyWN)\n//Faster than \"full\" xxHash and good quality\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n#else\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\nuint baseHash(uvec3 p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 =  p.z + PRIME32_5 + p.x*PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17)));\n\th32 += p.y * PRIME32_3;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\n//XXHash32 based (https://github.com/Cyan4973/xxHash)\n//Slower, higher quality\nuint baseHash(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uint p)\n{\n\tconst uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n\tuint h32 = p + PRIME32_5;\n\th32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    return h32^(h32 >> 16);\n}\n#endif\n\n//---------------------3D input---------------------\nfloat hash13(uvec3 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash23(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash33(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash43(uvec3 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n//---------------------2D input---------------------\n\nfloat hash12(uvec2 x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash22(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash32(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash42(uvec2 x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n//---------------------1D input---------------------\nfloat hash11(uint x)\n{\n    uint n = baseHash(x);\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash21(uint x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash31(uint x)\n{\n    uint n = baseHash(x);\n    uvec3 rz = uvec3(n, n*16807U, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash41(uint x)\n{\n    uint n = baseHash(x);\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\n//================================================\n// Fonts\n//------------------------------------------------\n// by kishimisu\n// https://www.shadertoy.com/view/dsGXDt\n\n#define FONT_TEXTURE iChannel2\n#define CHAR_SPACING 0.44\n#define makeStr(func_name) float func_name(vec2 u) { _print \n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n#define _end    ); return d; }\n#define _ch(i)  _ 65+int(i)\n#define _dig(i) _ 48+int(i)\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n#define _SPA    ); u.x -= CHAR_SPACING; (0\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    if (decimals > 0) {\n        (0 _DOT ); // Print a dot\n    }\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n\n//================================================\n// Other\n//------------------------------------------------\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\nconst float velocity = 15.0;\n\nconst vec2 min_offset_wasd = vec2(-1.0, 0.0);\nconst vec2 max_offset_wasd = vec2( 1.0, 1.0);\n\nconst vec2 min_offset_arrows = vec2(-1.0, -0.2);\nconst vec2 max_offset_arrows = vec2( 1.0,  1.0);\n\n\nvoid handleMemory( out vec4 fragColor, in vec2 fragCoord, float player_scale, bool player_enemy_collision )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    \n    if ( iTime < 0.5 ) { \n        fragColor = vec4(0.); \n        return; \n    }\n    \n    // Movement and Scaling using W,A,S,D\n    if ( coord == ivec2(0,0) )\n    {\n        vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n        vec2 left   = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x * vec2(-0.1,  0.0);\n        vec2 up     = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x * vec2( 0.0,  0.1);\n        vec2 right  = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x * vec2( 0.1,  0.0);\n        vec2 down   = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x * vec2( 0.0, -0.1);\n        \n        offset += (left + up + right + down) * velocity * iTimeDelta;\n        offset = clamp( offset, min_offset_wasd, max_offset_wasd );\n        \n        fragColor.xy = offset;\n    }\n    \n    // Moving the camera around using arrow keys\n    else if ( coord == ivec2(0,1) )\n    {\n        vec2 offset = texelFetch( iChannel0, ivec2(0,1), 0 ).xy;\n        vec2 left   = texelFetch( iChannel1, ivec2(KEY_LEFT ,0), 0 ).x * vec2(-0.1,  0.0);\n        vec2 up     = texelFetch( iChannel1, ivec2(KEY_UP   ,0), 0 ).x * vec2( 0.0,  0.1);\n        vec2 right  = texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x * vec2( 0.1,  0.0);\n        vec2 down   = texelFetch( iChannel1, ivec2(KEY_DOWN ,0), 0 ).x * vec2( 0.0, -0.1);\n        \n        offset += (left + up + right + down) * velocity * iTimeDelta;\n        offset = clamp( offset, min_offset_arrows, max_offset_arrows );\n        \n        fragColor.xy = offset;\n    }\n    \n    else if ( coord == MEMORY_START_TIME )\n    {\n        float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n        \n        if ( player_enemy_collision ) {\n            fragColor.x = iTime;\n        } else {\n            fragColor.x = start_time;\n        }\n    }\n    \n    else if ( coord == MEMORY_SCORE )\n    {\n        float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n        if ( player_enemy_collision ) {\n            score = 0.0;\n        }\n        \n        float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n        \n        float new_score = score += iTimeDelta * player_scale; // iTimeDelta + iTimeDelta * (player_scale - 1.0) * 4.0;\n        fragColor.x = new_score;\n        \n    }\n    \n    else if ( coord == MEMORY_HIGH_SCORE )\n    {\n        float high_score = texelFetch( iChannel0, MEMORY_HIGH_SCORE, 0 ).x;\n        float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n        fragColor.x = max( high_score, score );\n    }\n}\n\n\n\n//================================================\n// HEY, YOU! TRY ADJUSTING THESE CONSTANTS :D\n//------------------------------------------------\n\n// Higher numbers --> Higher quality\n// Lower numbers  --> Better Performance\n\nconst int MAX_SAMPLES = 2; // initial number of rays born into the world, for each pixel.\nconst int MAX_DEPTH   = 6; // maximum number of reflections or refractions, for each ray.\n\n\n//================================================\n// Structures\n//------------------------------------------------\n\nstruct ray {\n    vec3 origin;    // point in world-space where the ray begins\n    vec3 direction; // unit-vector for the direction of the ray\n};\n\nstruct hit_result {\n    // bool exists        // true if the ray actually hit something\n    vec3  p;            // point in world-space at which the hit occurred\n    vec3  n;            // normal vector (could point either outside or inside)\n    float t;            // time at which the ray hit\n    bool  front_facing; // normal is pointing outwards\n};\n\nstruct sphere {\n    float radius;\n    vec3  center;\n    uint  material;\n};\n\nstruct camera {\n    float aspect_ratio;\n    int image_width;\n    int image_height;\n    vec3 center;\n    vec3 pixel00_loc;\n    vec3 pixel_delta_u;\n    vec3 pixel_delta_v;\n};\n\nstruct material {\n    uint type; // enumerated value corresponding to unique material types\n    float albedo;\n    float attenuation;\n    float fuzz;\n};\n\n//================================================\n// Constants\n//------------------------------------------------\n\nconst float FLOAT_BIG  = 3.4e38; // not the maximum possible float, but it's up there.\nconst vec3 ALBEDO_METAL_GOLD = vec3(0.8, 0.6, 0.2);\n\n// Material Enumerations\nconst uint MAT_LAMBERTIAN = 1u;\nconst uint MAT_METAL = 2u;\nconst uint MAT_DIELECTRIC = 3u;\nconst uint MAT_CHECKER = 4u;\n\n//================================================\n// Variables\n//------------------------------------------------\n\n// Need to make these variable for the moment so that they can be \n// accessed by the random number generator, but there's gotta be a better way\nint current_sample = 0;\n\n// CAMERA\ncamera cam;\n\n\n//================================================\n// The World\n//------------------------------------------------\n\nconst int MAX_SPHERES = 17;\nconst int ENEMY_INDEX_BEGIN = 5;\nconst int NUM_ENEMIES = 8;\n\nsphere all_spheres[MAX_SPHERES] = sphere[MAX_SPHERES]\n(\n    sphere( -0.2 , vec3( 0.0, -0.3, 2.0), MAT_DIELECTRIC ),    // the sphere you control\n    sphere( 0.2 ,  vec3(1.5, -0.3 , 1.0), MAT_DIELECTRIC ),     // another sphere you may control later (off the right atm)\n    sphere( 200.0 , vec3(0., -200.5 , 0. ), MAT_CHECKER ), // the ground\n    sphere( 1.0,  vec3(-0.8, 3.0, 20.0), MAT_METAL ), // the sun\n    sphere( -1.0, vec3(-0.8, 3.0, 20.0), MAT_DIELECTRIC ), // the moon\n    \n    // some spheres that will approach us through the tunnel\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    sphere( 0.2, vec3(0.3), MAT_LAMBERTIAN ),\n    sphere( 0.2, vec3(0.3), MAT_METAL ),\n    \n    // extras\n    sphere( -5.5 , vec3(- 8.0, 2.3 , 15.0 ), MAT_DIELECTRIC ), // the left globe\n    sphere( -5.5 , vec3(  8.0, 2.3 , 15.0 ), MAT_DIELECTRIC ), // the right globe\n    \n    sphere( 2.0 , vec3(-6.0, 1.0 ,  6.0 ), MAT_METAL ), // the left globe\n    sphere( 2.0 , vec3( 6.0, 1.0 ,  6.0 ), MAT_METAL ) // the right globe\n    \n    // sphere( 0.15 , vec3(0.0, 0.0 , 0.0 ), MAT_LAMBERTIAN ), // head\n    // sphere( 0.05 , vec3(0.0, 0.3 , 4.0 ), MAT_DIELECTRIC ), // right arm\n    // sphere( 0.05 , vec3(0.0, 0.3 , 4.0 ), MAT_DIELECTRIC ) // left arm\n);\n\n#define SPHERE_SUN 3\n#define SPHERE_MOON 4\n#define SPHERE_HEAD 15\n#define SPHERE_ARM_LEFT 16\n#define SPHERE_ARM_RIGHT 17\n\n//================================================\n// Update the World\n//------------------------------------------------\n\nvoid update_world()\n{\n    float C = cos(iTime/PIE);\n    float S = sin(iTime/PIE);\n    \n    // Control of the Primary Sphere\n    // all_spheres[0].center.x = (iMouse.x / iResolution.x - 0.5) * 5.0;\n    // all_spheres[0].center.y = (iMouse.y / iResolution.y - 0.5) / 2.0 - 0.15;\n    all_spheres[0].center.z = 2.0;\n    // all_spheres[0].radius   = ((iMouse.y / iResolution.y) / 2.0 + 0.2);\n    \n    vec2 input_wasd = texelFetch( iChannel0, MEMORY_WASD, 0 ).xy;\n    all_spheres[0].center.x = 2.0 * input_wasd.x;\n    all_spheres[0].center.y = ( input_wasd.y ) / 1.0 - 0.21;\n    all_spheres[0].radius   = ( input_wasd.y ) / 1.0 + 0.4;\n    \n    \n    // all_spheres[1].center.x = (iMouse.x / iResolution.x - 0.5) * 5.0 + 0.5;\n    all_spheres[1].center.x = all_spheres[0].center.x;\n    all_spheres[1].center.y = all_spheres[0].center.y + 1.5 * abs(all_spheres[0].radius);\n    all_spheres[1].center.z = 2.0;\n    all_spheres[1].radius   = all_spheres[0].radius;\n    \n    // all_spheres[SPHERE_HEAD].center = all_spheres[1].center + vec3( 0.0, all_spheres[0].radius + all_spheres[SPHERE_HEAD].radius - 0.05, 0.0 );\n\n    /*\n    all_spheres[3].center.x = S;\n    all_spheres[3].center.z = -2.-cos(iTime/PIE);\n    all_spheres[1].center.y = 1. + C;\n    all_spheres[2].cent er.y = 1. + S;\n    */\n\n    // update the sun and moon\n    all_spheres[SPHERE_SUN].center.x = 4.0 * cos(iTime);\n    all_spheres[SPHERE_SUN].center.y = 4.0 * sin(iTime);\n   \n    all_spheres[SPHERE_MOON].center.x = 4.0 * cos(iTime + PI);\n    all_spheres[SPHERE_MOON].center.y = 4.0 * sin(iTime + PI);\n    \n    for (int i = ENEMY_INDEX_BEGIN; i < (ENEMY_INDEX_BEGIN + NUM_ENEMIES); i++) {\n        float zi = 50.0;\n        float zf = -1.0;\n        float tf = 2.5;\n        float rate = (zf - zi) / tf;\n        float newTime = iTime + ( float(i)/float(NUM_ENEMIES) * tf );\n        float t = mod(newTime, tf);\n        all_spheres[i].center.z = zi + rate * t;\n        // all_spheres[i].center.x = ( float(i%5)/5. - 0.5 ) * 6.0;\n        all_spheres[i].center.x = ( hash12( uvec2( newTime/tf, i) ) * 2.0 - 1.0 ) * 3.0;\n        all_spheres[i].center.y = -0.5;\n    }\n}\n\n\n//================================================\n// Utils\n//------------------------------------------------\n\n// point in world-space where ray r would be at time t\nvec3 at( ray r, float t ) {\n    return r.origin + t * r.direction;\n}\n\nbool near_zero(in vec3 v) {\n    return all(lessThan(v,vec3(1e-8)));\n}\n\nbool sphere_sphere_collides( sphere s1, sphere s2 ) {\n    float rsquared = ( abs(s1.radius) + abs(s2.radius) );\n    rsquared *= rsquared;\n    vec3 delta = s2.center - s1.center;\n    return dot(delta,delta) < rsquared;\n}\n\n// RANDOM\n\n// uniformly random on the surface of a sphere\n// produces normal vectors as well\n// requires 2 randomly generated numbers between (0.0, 1.0)\n/*\nvec3 uniform_sphere_area(vec2 rnds) {\n    vec2 u = rnds;\n    float phi = 6.28318530718*u.x;\n    float rho_c = 2.0 * u.y - 1.0;\n    float rho_s = sqrt(1.0 - (rho_c * rho_c));\n    return vec3(rho_s * cos(phi), rho_s * sin(phi), rho_c);\n}\n\n    float r1 = rnds[0];\n    float r2 = rnds[1];\n    float theta = 2. * PI * r1;\n    float phi = acos(1. - 2. * r2);\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x,y,z);\n*/\nvec3 uniform_sphere_area(int sample_number, int depth, vec2 fragCoord) {\n    int i = 0;\n    while (true) {\n        vec3 p = hash33(uvec3(iFrame+i, sample_number*MAX_SAMPLES + depth, fragCoord.x + iResolution.x * fragCoord.y));\n        p = 2. * p - 1.;\n        if (dot(p,p) < 1.)\n            return p;\n    }\n}\n\n// returns a randomly generated normal vector\n// on the outward surface of a sphere\nvec3 random_on_hemisphere(vec3 normal, int sample_number, int depth, vec2 fragCoord) {\n    vec3 on_unit_sphere = 2. * normalize(uniform_sphere_area(sample_number, depth, fragCoord)) + 1.;\n    if ( dot( on_unit_sphere, normal ) > 0. ) \n        return on_unit_sphere;\n    else\n        return -on_unit_sphere;\n}\n\n//================================================\n// Textures\n//------------------------------------------------\n\n// color of a checkered texture, given some uv's and a point in world space.\n// However.. the uv's are actually ignored in this current implementation.\nvec3 color_checkers( vec2 uv, vec3 p )\n{\n    const float CHECKER_SCALE = 1.0 / 1.32;\n    const vec3 CHECKER_COLOR_1 = vec3( 0.1, 0.3, 0.2 );\n    const vec3 CHECKER_COLOR_2 = vec3( 0.9, 0.9, 0.9 );\n    ivec3 ip = ivec3( floor( CHECKER_SCALE * p ) );\n    bool isEven = ( ip.x + ip.y + ip.z ) % 2 == 0;\n    return isEven ? CHECKER_COLOR_1 : CHECKER_COLOR_2;\n}\n\nvec3 sky_color(ray r) {\n    vec3 unit = normalize( r.direction );\n    float a = 0.5 * ( unit.y + 1. );\n    vec3 color1 = vec3( 1.0, 1.0, 1.0 );\n    vec3 color2 = vec3( 0.5, 0.7, 1.0 );\n    vec3 result = mix( color1, color2, a );\n    \n    // special sky experiment! I want to add a starfield eventually.\n    // if ( r.direction.y > cos(iTime/PIE) && r.direction.x < (cos(iTime/PIE)) && r.direction.z < sin(iTime/PIE) ) { result = vec3(1.0, 0.5, 0.5); }\n    // iChannelResolution.x * r.direction;\n    // convert cartesian to spherical coordinates\n    \n    float theta = acos( r.direction.z );\n    float phi = sign( r.direction.y ) * acos( r.direction.x / length(r.direction.xy) );\n    \n    float theta1 = theta / PI;\n    float phi1 = phi / PIE;\n    color2 = vec3(cos(theta1 + iTime*2.), 1., 1.);\n    float trippy = sin(10.*abs(r.direction.z / r.direction.x) + 5.*iTime) * 0.5 + 0.5;\n    \n    color1 = vec3(0.9-trippy, 0.5 , 0.7);\n    \n    result = mix(color1, color2, a);\n    \n    return color1;\n}\n\n\n//================================================\n// Path Tracing\n//------------------------------------------------\n\n\nvec3 tunnel1(in vec2 pt) {\n    pt = 3.0*(pt.xy / iResolution.xy - 0.5)*vec2(iResolution.x/iResolution.y,1);\n    float rInv = 1./length(pt);\n    pt = pt * rInv - vec2(rInv + iTime,0.5);\n    return (texture(iChannel0,pt)*rInv/2.).xyz;\n}\n\nvec3 tunnel_reverse(in vec2 pt) {\n    pt = 3.0*(pt.xy / iResolution.xy - 0.5)*vec2(iResolution.x/iResolution.y,1);\n    float rInv = 1./length(pt);\n    pt = pt * rInv - vec2(rInv - iTime,0.5);\n    return (texture(iChannel0,pt)*rInv/2.).xyz;\n}\n\n// Intersection test between a ray and a sphere. If there's a hit, \n// this function will populate the hit_result and then return true.\nbool hit_sphere(in ray r, in sphere s, float tmin, float tmax, out hit_result res) {\n    vec3 oc = r.origin - s.center;\n    float a = dot(r.direction, r.direction);\n    float half_b = dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float d = half_b * half_b - a * c;\n    if (d <= 0.) { return false; }\n    \n    float sqrtd = sqrt(d);\n    float root = (-half_b - sqrtd) / a;\n    if (root <= tmin || tmax <= root) {\n        root = (-half_b + sqrtd) / a;\n        if (root <= tmin || tmax <= root)\n            return false;\n    }\n    res.t = root;\n    res.p = at(r, root);\n    res.n = normalize( (res.p - s.center) / s.radius );\n    res.front_facing = dot(r.direction, res.n) < 0.;\n    res.n = res.front_facing ? res.n : -res.n;\n    return true;\n}\n\n\nbool scatter_metal(in ray r_in, in hit_result rec, in vec3 albedo, inout vec3 attenuation, inout ray scattered, vec2 fragCoord) {\n    const float fuzz = 0.1; // 0.3; // TODO: make this a material parameter\n    vec3 reflected = reflect(normalize(r_in.direction), rec.n);\n    \n    // vec3 uniform_sphere_area(int sample_number, int depth, vec2 fragCoord) {\n    vec3 vec_random = uniform_sphere_area(current_sample, int(fragCoord.x), fragCoord);\n    \n    scattered = ray(rec.p, reflected + fuzz*vec_random);\n    attenuation = albedo;\n    return true;\n}\n\n\nbool scatter_dielectric(in ray r_in, in hit_result rec, in vec3 albedo, inout vec3 attenuation, inout ray scattered) {\n    attenuation = vec3(1.0, 1.0, 1.0);\n    const float ir = 1.5; // index of refraction, TODO: make this a material parameter\n    float refraction_ratio = rec.front_facing ? (1.0/ir) : ir;\n    vec3 unit_direction = normalize(r_in.direction);\n\n    float cos_theta = min(dot(-unit_direction, rec.n), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    vec3 direction;\n\n    if (cannot_refract)\n        direction = reflect(unit_direction, rec.n);\n    else\n        direction = refract(unit_direction, rec.n, refraction_ratio);\n\n    scattered = ray(rec.p, direction);\n\n    return true;\n}\n\n\nvec3 ray_color( ray r, in vec2 fragCoord, int sample_number, bool player_turns_red ) {\n\n    vec3 final_color = vec3(1., 1., 1.);\n    int depth=0;\n    float reflectance = 0.8;\n    \n    for (depth=0; depth<MAX_DEPTH; depth++)\n    {\n        hit_result best_result;\n        sphere sphere_hit;\n        int sphere_hit_index;\n        float tmin = 0.001;\n        float tmax = FLOAT_BIG;\n        bool hit_anything = false;\n        vec3 col = vec3(0.0, 0.0, 0.0);\n\n        // Check for intersections with spheres\n        for (int i=0; i<MAX_SPHERES; i++)\n        {\n            // if (i==0 && tan(hash12(uvec2(iFrame/12, fragCoord.x + iResolution.x*fragCoord.y))/PIE) < 0.4) { continue; } // HACKY TRANSPARENCY\n            // if ( i==0 && ( int(iResolution.x*fragCoord.y)%2==0 ) ) { continue; } // HACKY TRANSPARENCY\n            // if ( i==0 && ( int(fragCoord.x)%2 == 0 && int(fragCoord.y)%2 == 0 ) ) { continue; } // HACKY TRANSPARENCY\n            sphere s = all_spheres[i];\n            hit_result result;\n            bool hit = hit_sphere( r, s, tmin, tmax, result );\n            if (hit) {\n                hit_anything = true;\n                tmax = result.t;\n                best_result = result;\n                sphere_hit = s;\n                sphere_hit_index = i;\n            }\n        }\n\n        if (hit_anything)\n        {\n            // Calculate where the next ray should go\n            float some_random = hash13(uvec3(iFrame, depth*sample_number, fragCoord.y*fragCoord.x));\n            float another_random = hash13(uvec3(iFrame, depth*sample_number, fragCoord.y*fragCoord.x));\n            \n            ray scattered;\n            vec3 attenuation;\n            \n            if (sphere_hit.material == MAT_METAL && scatter_metal(r, best_result, ALBEDO_METAL_GOLD, attenuation, scattered, fragCoord)) {\n                col = attenuation;\n                r = scattered;\n            } \n            else if (sphere_hit.material == MAT_DIELECTRIC && scatter_dielectric(r, best_result, ALBEDO_METAL_GOLD, attenuation, scattered)) {\n                col = attenuation;\n                r = scattered;\n            }\n            else { \n                // lambertian is the default right now\n                // Determine the color (TODO: do this better)\n                if  (sphere_hit.material == MAT_CHECKER ) {\n                    col = color_checkers( vec2(0.0), best_result.p );\n                } else {\n                    col = 0.5 * (normalize(best_result.n) + 1.); // Normal Vector Debug Color\n                }\n                \n                r.direction = best_result.n + random_on_hemisphere(best_result.n, sample_number, depth, fragCoord); // Lambertian\n                if ( near_zero(r.direction) ) {\n                    r.direction = best_result.n;\n                }\n                r.origin = best_result.p + 0.01 * r.direction;\n            }\n\n            // apply red color if the player sphere has been hit recently\n            if ( player_turns_red && (sphere_hit_index == 0 || sphere_hit_index == 1) ) {\n                col = vec3( 1.0, 0.0, 0.0 );\n            }\n            \n            // Fully Apply Color?\n            final_color *= reflectance * col;\n            \n            // final_color = final_color + col * pow(reflectance, float(depth+1));\n        }\n        else\n        {\n            col = sky_color(r);\n            // if ( tan(hash12(uvec2(iFrame/12, fragCoord.x + iResolution.x*fragCoord.y))/PIE) < 0.4 ) { col *= 0.9 ; } //HACKY COLOR CHANGE\n            // starfield(col, vec2((r.direction.x+1.)/2.*iResolution.x, (r.direction.y+1.)/2.*iResolution.y));\n            final_color *= reflectance * col; // pow(reflectance, float(depth+1));\n            // final_color = col;\n            break;\n        }\n    }\n    \n    if (depth==0) {\n        // starfield(final_color, fragCoord);\n        // final_color = tunnel1(fragCoord) * ( tan(hash12(uvec2(iFrame/12, fragCoord.x+iResolution.x*fragCoord.y))/PIE)<0.5 ? 0.4 : 1. );\n        final_color = sky_color(r);\n    } else {\n        final_color = final_color * pow(reflectance, float(depth));\n    }\n    \n    return final_color;\n}\n\n\n//================================================\n// TEXT\n//------------------------------------------------\nmakeStr1f(printHighScore) _T _o _p _SPA _S _c _o _r _e _COL _SPA _dec(i,0) _end\nmakeStr1f(printScore) _S _c _o _r _e _COL _SPA _dec(i,0) _end\nmakeStr1f(printScale) _S _c _a _l _e _COL _SPA _dec(i,2) _end\n\n\n//================================================\n// Main Image\n//------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // UPDATE WORLD\n    update_world();\n\n    // Collision Check\n    bool player_enemy_collision = false;\n    for ( int i = ENEMY_INDEX_BEGIN; i < (ENEMY_INDEX_BEGIN + NUM_ENEMIES); i++ )\n    {\n        if ( sphere_sphere_collides( all_spheres[0], all_spheres[i] ) ) {\n            player_enemy_collision = true;\n            break;\n        }\n    }\n    \n    // Some variables used to turn the player red if there has been a collision recently\n    float start_time = texelFetch( iChannel0, MEMORY_START_TIME, 0 ).x;\n    bool player_turns_red = ( iTime - start_time ) < 0.5;\n    \n    // Camera\n    cam.center  = vec3(  0.0,  0.5, -2.0 ); // Point camera is looking from\n    vec3 lookat = vec3(  0.0,  0.5,  3.0 ); // Point camera is looking at\n\n    // Camera Hack for fun\n    vec2 input_arrow_keys = texelFetch( iChannel0, ivec2(0,1), 0 ).xy;\n    cam.center.xy += 5.0 * input_arrow_keys.xy;\n    // lookat.xy = lookat.xy + input_arrow_keys.xy;\n    // cam.center.y = max(cam.center.y, 0.0);\n        \n\n    vec3 vup = vec3(0.0, 1.0,  0.0);     // Camera-relative \"up\" direction\n    float vfov = 45.;\n    float focal_length = length(cam.center - lookat);\n    float theta = radians(vfov);\n    float h = tan(theta/2.); \n\n    // Viewport Calculations\n    cam.aspect_ratio = iResolution.x / iResolution.y;\n    float viewport_height = 2. * h * focal_length;\n    float viewport_width = viewport_height * cam.aspect_ratio;\n    \n    // Calculate the u,v,w unit basis vectors for the camera coordinate frame.\n    vec3 w = normalize(cam.center - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n    // vectors across the viewport\n    vec3 viewport_u = viewport_width * -u;\n    vec3 viewport_v = viewport_height * v;\n    \n    // horizontal and vertical delta vectors from pixel to pixel\n    cam.pixel_delta_u = viewport_u / iResolution.x;\n    cam.pixel_delta_v = viewport_v / iResolution.y;\n    \n    // calculate location of the upper left pixel\n    vec3 viewport_upper_left = cam.center - (focal_length * w) - viewport_u/2. - viewport_v/2.;\n    cam.pixel00_loc = viewport_upper_left + 0.5 * (cam.pixel_delta_u + cam.pixel_delta_v);\n    \n    // AIM AND LOAD THE RAY-CANNON\n    vec3 pixel_center = cam.pixel00_loc + (fragCoord.x * cam.pixel_delta_u) + (fragCoord.y * cam.pixel_delta_v);\n    vec3 ray_direction = pixel_center - cam.center;\n    ray r = ray(cam.center, ray_direction);\n    \n    // FIRE THE RAY CANNONS!!!!\n    vec3 col = vec3(0.,0.,0.);\n    for (int i=0; i<MAX_SAMPLES; i++) {\n        r.origin = cam.center;\n        vec2 offset = hash23( uvec3(iFrame, i, fragCoord.x*fragCoord.y) )/2.;\n        vec3 pixel_sample_square = offset.x * cam.pixel_delta_u + offset.y * cam.pixel_delta_v;\n        vec3 pixel_sample = pixel_center + pixel_sample_square;\n        r.direction = pixel_sample - r.origin;\n        col += ray_color(r, fragCoord, i, player_turns_red);\n    }\n    col = col / float(MAX_SAMPLES);\n    \n    // col = ray_color(r, fragCoord);\n    \n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    // Gamma Correction\n    col = sqrt(col);\n\n\n    // Font on the top\n    float player_scale = ( 1.0 + texelFetch( iChannel0, MEMORY_WASD, 0 ).y * 4.0);\n    float score = texelFetch( iChannel0, MEMORY_SCORE, 0 ).x;\n    float high_score = texelFetch( iChannel0, MEMORY_HIGH_SCORE, 0 ).x;\n\n    \n    vec2 uv = fragCoord / iResolution.y;\n    const float fontsize = 14.0;\n    uv *= fontsize;        // Scale font with font_size\n    uv.y -= fontsize - 1.; // Start drawing from the top\n    // TEXT HIGH SCORE\n    col -= vec3( 0.2, 0.2, 0.2 ) * printHighScore( uv + vec2( -0.05, 0.05 ), high_score ); // shadow text\n    col += vec3( 0.8, 1.0, 0.8 ) * printHighScore( uv, high_score ); // foreground text\n    uv.y++;\n    // TEXT SCORE \n    vec3 score_col1 = player_turns_red ? vec3( 1.0, 0.0, 0.0 ) : vec3( 0.8, 1.0, 0.8 );\n    col -= vec3( 0.2, 0.2, 0.2 ) * printScore( uv + vec2( -0.05, 0.05 ), score ); // shadow text\n    col += score_col1 * printScore( uv, score ); // foreground text\n    uv.y++;\n    // TEXT PLAYER SCALE\n    col -= vec3( 0.2, 0.2, 0.2 ) * printScale( uv + vec2( -0.05, 0.05 ), player_scale ); // shadow text\n    col += vec3( 0.8, 1.0, 0.8 ) * printScale( uv, player_scale ); // foreground text\n\n    // Prevent out-of-bounds colors\n    col = clamp(col, 0., 1.);\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n    \n    handleMemory( fragColor, fragCoord, player_scale, player_enemy_collision );\n    // fragColor = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}