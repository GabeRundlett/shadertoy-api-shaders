{
    "Shader": {
        "info": {
            "date": "1669933951",
            "description": "An amusing discovery made with Hatchling's graph plotter framework. Nvidia seems just as bad as Intel on this one.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdBXRW",
            "likes": 7,
            "name": "sinc(x) around zero.",
            "published": 3,
            "tags": [
                "graph",
                "aa",
                "sinc"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "bool alert = false;\n\nconst vec4 BackgroundColor = vec4(0.0, 0.05, 0.1, 1);\n\n//#define sin(x) (abs(x) < 0.0002 ? (x) : sin(x))\nconst float PI = 3.141592654;\n\nfloat f(float x) {\n //return x;\n float k = exp2(23.0); \n //k /= 0.5*PI; // Nvidia\n //if (abs(x) < 1.0/k) alert = true;\n //if (x < 0.0) return floor(abs(x)*k)/k*sign(x); // Identical to sin(x) for small x\n return(sin(x));\n //return asinh(x);\n //return exp2(x)-1.0;\n}\n\nfloat scale;\nfloat myFunc(float x) \n{ \n    x /= scale;\n    // Write your custom function to plot here.\n    return f(x)/x; \n} \n\nfloat myFunc2(float x) \n{ \n    // Write your custom function to plot here.\n    x /= scale; // Zoom in\n    return 4.0*scale*f(x); \n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scale = exp2(26.0*(0.5-0.5*cos(0.5*iTime))-3.0); // Zoom in\n\n    gFragCoord = fragCoord;\n    gResolution = iResolution.xy;\n    \n    fragColor = BackgroundColor;\n    \n    // Draw grids.\n    drawGrid(fragColor, vec2(0.1), vec4(1,0.5,0.5,0.02), vec4(0.5, 1, 0.5, 0.02));\n    drawGrid(fragColor, vec2(1), vec4(1,0.5,0.5,0.1), vec4(0.5, 1, 0.5, 0.1));\n    drawGraph(fragColor, tf(myFunc, fragCoord), vec4(1,1,0,1));\n    drawGraph(fragColor, tf(myFunc2, fragCoord), vec4(1,0,0,1));\n    if (alert) fragColor.b = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Displayed range of the graph.\nconst vec2 mini = vec2(-5, -2);\nconst vec2 maxi = vec2(5, 2);\n\n#define StLine 0\n#define StSolid 1\n#define Style StLine\n\n// Global vars used by overloads when you're lazy.\nvec2 gFragCoord;\nvec2 gResolution;\n\nvec2 fragToView(vec2 fragCoord, vec2 resolution)\n{\n    return mix(mini, maxi, fragCoord / resolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord, vec2 resolution)\n{\n    return (viewCoord - mini) / (maxi - mini) * resolution;\n}\n\nvec2 fragToView(vec2 fragCoord)\n{\n    return fragToView(fragCoord, gResolution);\n}\n\nvec2 viewToFrag(vec2 viewCoord)\n{\n    return viewToFrag(viewCoord, gResolution);\n}\n\nfloat fragToViewX(float fragCoordX, float resolutionX)\n{\n    return mix(mini.x, maxi.x, fragCoordX / resolutionX);\n}\n\nfloat viewToFragY(float viewCoordY, float resolutionY)\n{\n    return (viewCoordY - mini.y) / (maxi.y - mini.y) * resolutionY;\n}\n\nfloat fragToViewX(float fragCoordX)\n{\n    return fragToViewX(fragCoordX, gResolution.x);\n}\n\nfloat viewToFragY(float viewCoordY)\n{\n    return viewToFragY(viewCoordY, gResolution.y);\n}\n\n#define tf(func, fragCoord) (viewToFragY(func(fragToViewX(fragCoord.x))))\n\nfloat getGraphOpacity( in float fragHeight, in float graphHeight )\n{\n    if(isnan(graphHeight) || isinf(graphHeight)) \n        return 0.0;\n    \n    float range = (1.0 + abs(dFdx(graphHeight)));\n    \n    #if Style == StLine\n        range *= 2.0;\n    #endif\n    \n    float upper = graphHeight + range;\n    float lower = graphHeight - range;\n    \n    float value = (fragHeight - lower) / (upper - lower);\n    \n    #if Style == StLine\n        value = (abs(value - 0.5) * 2.0);\n    #endif\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float fragHeight, in float graphHeight, in vec4 color )\n{\n    float opacity = getGraphOpacity(fragHeight, graphHeight);\n    \n    vec4 c = color;\n    c.a *= opacity;\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGraph( inout vec4 fragColor, in float graphHeight, in vec4 color )\n{\n    drawGraph(fragColor, gFragCoord.y, graphHeight, color);\n}\n\nvec2 getGridOpacity(in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing)\n{\n    vec2 viewCoord = fragToView(fragCoord, resolution) / gridSpacing;\n    vec2 nearestGridViewCoord = round(viewCoord) * gridSpacing;\n    vec2 nearestGridFragCoord = viewToFrag(nearestGridViewCoord);\n    \n    const vec2 range = vec2(2);\n    \n    vec2 upper = nearestGridFragCoord + range;\n    vec2 lower = nearestGridFragCoord - range;\n    \n    vec2 value = (fragCoord - lower) / (upper - lower);\n    \n    value = (abs(value - 0.5) * 2.0);\n    \n    return 1.0 - smoothstep(0., 1., value);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 fragCoord, in vec2 resolution, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    vec2 opacity = getGridOpacity(fragCoord, resolution, gridSpacing);\n    \n    vec4 cH = colorHorizLines;\n    cH.a *= opacity.y;\n    vec4 cV = colorVertLines;\n    cV.a *= opacity.x;\n    \n    float ratio = cV.a / (cV.a + cH.a);\n    \n    if(isnan(ratio) || isinf(ratio)) ratio = 0.5;\n    \n    vec4 c;\n    c.rgb = mix(cH.rgb, cV.rgb, ratio);\n    c.a = mix(cH.a, 1.0, cV.a);\n    \n    fragColor.rgb = mix(fragColor.rgb, c.rgb, c.a);\n    fragColor.a = mix(fragColor.a, 1.0, c.a);\n}\n\nvoid drawGrid( inout vec4 fragColor, in vec2 gridSpacing, in vec4 colorHorizLines, in vec4 colorVertLines )\n{\n    drawGrid(fragColor, gFragCoord, gResolution, gridSpacing, colorHorizLines, colorVertLines);\n}\n\n// Wrapper for division to allow emulation of GPU style division\n// on CPU, not that this makes much difference to result.\nfloat fdiv(float x, float y) { return x/y; }\n\n// If we've found the character for the target index, return it.\n#define CHAR(c) { if (index++ == cindex) return(c); }\n\n// https://www.shadertoy.com/view/4sBfRd\nvec2 char(vec2 p, int c) {\n  // Compute uv for font texture.\n  // p is [0,1] coordinates in square character\n  return (p + vec2(c,15-c/16))/16.0;\n}\n\n#define assert(x)\nint printfloat(float x, int digits, int cindex) {\n  if (cindex < 0 || cindex > digits+6) return 0;\n  int index = 0;\n  const float pmax = 1e15; //  Large power of 10 with a nice representation\n  const int emax = 15; // Exponent of pmax\n  const float pow10[] = float[]( 1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8 );\n  const int ZERO = 0x30, POINT = 0x2e, MINUS = 0x2d, PLUS = 0x2b;\n  const int A = 0x61, E = 0x65, F = 0x66, I = 0x69, N = 0x6e;\n  const int SPACE = 0x20;\n  if (isinf(x)) {\n    if (x < 0.0) CHAR(MINUS);\n    CHAR(I); CHAR(N); CHAR(F);\n  } else if (isnan(x)) {\n    if (floatBitsToInt(x) < 0) CHAR(MINUS);\n    CHAR(N); CHAR(A); CHAR(N);\n  } else if (x == 0.0) {\n    if (1.0/x < 0.0) CHAR(MINUS);\n    CHAR(ZERO);\n  } else {\n    if (x < 0.0) CHAR(MINUS) // No semicolon!\n    else CHAR(SPACE);\n    x = abs(x);\n    int exp = 0; // Compute exponent here\n    float llimit = pow10[digits-2], ulimit = 10.0*llimit;\n    // Now put x in the range llimit <= x <= ulimit\n    while (x > llimit*pmax) { x /= pmax; exp += emax; }\n    while (x < fdiv(ulimit,pmax)) { x *= pmax; exp -= emax; }\n    if (x >= ulimit) {\n      float p = 1.0;\n      while (fdiv(x,p) > ulimit) {\n        exp++; p *= 10.0;\n      }\n      x = fdiv(x,p);\n    } else if (x < llimit) {\n      float p = 1.0;\n      while (x*p < llimit) {\n        exp--;  p *= 10.0;\n      }\n      x *= p;\n    }\n    assert(!isinf(x));\n    assert(!isnan(x));\n    assert(x >= llimit);\n    assert(x <= ulimit); // Equality is possible!\n    // Round to an integer which has exactly the significant figures we want.\n    int n = int(round(x));\n    if (n == int(ulimit)) {\n      // Just in case the round has taken us the wrong way\n      n /= 10; exp++;\n    }\n    assert(n >= int(llimit));\n    assert(n < int(ulimit));\n    // Now we have our (correctly rounded) integer representation\n    // together with the correct exponent.\n    // See if we want to use exponent notation\n    int e = 0;\n    if (exp <= -digits-4) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    } else if (exp > 0) {\n      e = exp+digits-1;\n      exp = -digits+1;\n    }\n    while(n%10 == 0 && exp < 0) {\n      // Remove trailing zeros\n      n /= 10; exp++;\n    }\n    int m = 1, i = exp+1;\n    while (10*m <= n) { m *= 10; i++; }\n    // i is number of characters in front of decimal point\n    if (i <= 0) {\n      CHAR(ZERO);\n      CHAR(POINT);\n      // Add leading digits for 0 < x < 1\n      while(i < 0) {\n        CHAR(ZERO); i++;\n      }\n    }\n    while(m != 0) {\n      CHAR(ZERO+n/m%10);\n      m /= 10; i--;\n      // Don't print trailing point!\n      if (i == 0 && m != 0) CHAR(POINT);\n    }\n    if (e != 0) {\n      CHAR(E);\n      CHAR(e < 0 ? MINUS : PLUS);\n      e = abs(e);\n      CHAR(ZERO+e/10); CHAR(ZERO+e%10); \n    }\n  }\n  return 0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}