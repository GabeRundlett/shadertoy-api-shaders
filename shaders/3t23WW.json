{
    "Shader": {
        "info": {
            "date": "1559653474",
            "description": "Simple raymarched iterative function system. Click and drag to control.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t23WW",
            "likes": 8,
            "name": "ifs1",
            "published": 3,
            "tags": [
                "raymarched",
                "ifs",
                "kifs"
            ],
            "usePreview": 0,
            "username": "karltechno",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "const int TRACE_STEPS = 32;\nconst int SHADOW_STEPS = 32;\n\nconst float TRACE_EPS = 0.001;\nconst float NORM_EPS = 0.01;\n\nconst float kPi = 3.14159265359;\nconst float k2Pi = kPi*2.;\n\nmat2 rot2(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return\n        mat2\n        (\n            c, s,\n            -s, c\n        );\n}\n\nmat3 rotZ(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            c, \ts, \t0.,\n           -s, \tc, \t0.,\n            0., 0., 1.\n         );\n}\n\nmat3 rotX(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            1., 0., 0.,\n           \t0.,\tc, \ts,\n            0., -s, c\n         );\n}\n\nmat3 rotY(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return \n        mat3\n        (\n            c, 0., -s,\n            0.,\t1., 0,\n            s, 0, c\n         );\n}\n\n// http://www.chilliant.com/rgb2hsv.html\nvec3 hue_to_rgb(float h)\n{\n    float R = abs(h * 6. - 3.) - 1.;\n    float G = 2. - abs(h * 6. - 2.);\n    float B = 2. - abs(h * 6. - 4.);\n    return min(vec3(1.), max(vec3(0.), vec3(R,G,B)));\n}\n\nvec3 hsv_to_rgb(vec3 HSV)\n{\n    vec3 RGB = hue_to_rgb(HSV.x);\n    return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n}\n\nvec3 Tonemap(vec3 x)\n{\n    return 1. - exp2(-x);\n}\n\n// NOISE\n\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// value noise\n\nfloat noise11(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash11(i), hash11(i + 1.0), u);\n}\n\n\nfloat noise12 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash12(i);\n    float b = hash12(i + vec2(1.0, 0.0));\n    float c = hash12(i + vec2(0.0, 1.0));\n    float d = hash12(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm1(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < 6; ++i) {\n\t\tv += a * noise11(x);\n\t\tx = x * 2.0 + 100.25;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// https://www.shadertoy.com/view/MdX3Rr\nfloat fbm2( in vec2 p ){\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    float f = 0.0;\n    f += 0.5000*noise12( p ); p = m2*p*2.02;\n    f += 0.2500*noise12( p ); p = m2*p*2.03;\n    f += 0.1250*noise12( p ); p = m2*p*2.01;\n    f += 0.0625*noise12( p );\n\n    return f/0.9375;\n}\n\n\nstruct Ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n    \nstruct Intersection\n{\n    vec3 pos;\n    float rayT;\n};\n    \nvec3 Cam_MakeRayDir(vec3 f, vec3 u, vec2 uv)\n{\n    vec3 r = normalize(cross(f, u));\n    vec3 u2 = normalize(cross(r, f));\n    return normalize(uv.x * r + uv.y * u + f * 6.); // todo: fov\n}\n\nvec4 Scene_Map(vec3 p);\n\nvec4 Scene_Trace(in Ray r, out Intersection intersect)\n{\n    float t = 0.;\n    float minDist = 3e10;\n    int i = 0;\n    for(; i < TRACE_STEPS; ++i)\n    {\n        vec3 p = r.ro + r.rd*t;\n               \n        vec4 dist = Scene_Map(p);\n        minDist = min(minDist, dist.x);\n        float eps = max(TRACE_EPS, TRACE_EPS * t);\n        if(abs(dist.x) < eps)\n        {\n            intersect.pos = p;\n            intersect.rayT = t;\n            return vec4(dist.x, minDist, float(i), 0.);\n        }\n        \n        t += dist.x;\n    }\n    return vec4(-1.0, minDist, float(i), 0.);\n}\n\nvec3 Scene_Norm(vec3 p)\n{\n    vec2 e0 = vec2(NORM_EPS, 0.);\n    return normalize(vec3(\n        Scene_Map(p + e0.xyy).x - Scene_Map(p - e0.xyy).x,\n        Scene_Map(p + e0.yxy).x - Scene_Map(p - e0.yxy).x,\n        Scene_Map(p + e0.yyx).x - Scene_Map(p - e0.yyx).x\n    ));\n}\n\nfloat Scene_AO(vec3 p, vec3 n, float k)\n{\n    const float AO_STEP = 0.1; \n\tfloat occl = 0.;\n    for(int i = 0; i < 6; ++i)\n    {\n        float diff = float(i)*AO_STEP;\n        float d = Scene_Map(p + n*diff).x;\n        occl += (diff - d) * pow(2., float(-i));\n    }\n    return min(1., 1. - k*occl);\n}\n\n\nconst float IFS_SCALE = 1.21;\nconst vec3 IFS_OFFSET = vec3(-0.6, -2.05, -0.5);\nconst int IFS_ITER = 16;\n\nmat3 scene_mtx;\n\nvec4 Scene_Map(vec3 p)\n{\n    float scaleAccum = 1.;\n     \n    for(int i = 0; i < IFS_ITER; ++i)\n    {\n        p = abs(p);\n        p *= IFS_SCALE;\n        scaleAccum *= IFS_SCALE;\n        p += IFS_OFFSET;\n        p = scene_mtx * p;\n        \n    }\n    return vec4(length(p) / scaleAccum - 0.15, 0., 0., 0.);\n}\n\n\nfloat Scene_Shadow(Ray r, float minT, float maxT, float k)\n{\n    float res = 1.0;\n    float t=minT;\n    for(int i = 0; i < SHADOW_STEPS; ++i)\n    {\n        float h = Scene_Map(r.ro + r.rd*t).x;\n        if( h<0.005 )\n            return 0.0;\n\n        res = min( res, k*h/t );\n        t += h;\n\n        if(t >= maxT)\n        {\n            break;\n        }\n\n    }\n    return res;\n}\n\n#define NUM_AA 2\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 rotyz;\n    if(iMouse.z > 0.)\n    {\n        rotyz = k2Pi*iMouse.xy / iResolution.xy;\n    }\n    else\n    {\n        rotyz = vec2(iTime*0.2, iTime*0.4);\n    }\n    \n    scene_mtx = rotY(rotyz.x) * rotZ(rotyz.y);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 st = uv;\n  \tst *= 2.0;\n    st -= vec2(1.0, 1.0);\n    st.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = rotY(iTime*0.3) * vec3(0., 0., 50.);\n \tvec3 colAccum = vec3(0.);\n    vec2 this_uv = st;\n    #if NUM_AA > 0\n    for(int aaY = 0; aaY < NUM_AA; ++aaY)\n    for(int aaX = 0; aaX < NUM_AA; ++aaX)\n    {\n\n        vec2 aa_jit = vec2(float(aaX), float(aaY)) / float(NUM_AA);\n        aa_jit /= iResolution.xy;\n        this_uv += aa_jit;\n    #endif     \t\n        \n        Ray r;\n        r.ro = ro;\n        r.rd = Cam_MakeRayDir(normalize(-r.ro), vec3(0., 1., 0.), this_uv);\n\n        Intersection intersect;\n        vec4 trace = Scene_Trace(r, intersect);\n\n        vec3 baseCol = hsv_to_rgb(vec3(fract(iTime*0.1), 0.7, 0.9));\n\n        vec3 col = vec3(0.3);\n        if(trace.x > -1.)\n        {\n            vec3 norm = Scene_Norm(intersect.pos); \n            \n            Ray shadowR;\n            shadowR.ro = intersect.pos;\n            shadowR.rd = norm;\n            float skyOccl = Scene_Shadow(shadowR, 0.01, 150., 5.);\n            vec3 v = -r.rd;\n            vec3 refl = reflect(v, norm);\n            float tHighlight = (trace.z) / float(TRACE_STEPS);\n            tHighlight = pow(tHighlight, 1.5);\n            \n            float ao = Scene_AO(intersect.pos, norm, 4.);\n            //ao = 1.;\n            vec3 spec = texture(iChannel0, refl).xyz;\n            col = 0.9*skyOccl * spec + baseCol * tHighlight;\n            col *= ao;            \n        }\n        else\n        { \n            float a = sin(atan(st.y, st.x) + kPi);\n            float glowRnd = fbm1(a + iTime);    \n \n            float glowDist = max(0.001, pow(glowRnd*5., 0.8));\n\n            \n            float stept = (1.- (trace.y/glowDist))*(1. - step(glowDist, trace.y));\n            vec3 glow = pow(stept, 3.) * baseCol * 0.6;\n            col += glow;\n        }\n\t\tcolAccum += col;\n    #if NUM_AA > 0\n    }\n\n    colAccum /= float(NUM_AA*NUM_AA);\n\t#endif\n \n    // vignette/post\n    colAccum *= pow(1.0 - smoothstep(0.1, 0.9, length(uv - vec2(0.5))), 0.5);\n    colAccum = Tonemap(colAccum*3.4);\n    fragColor = vec4(colAccum, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}