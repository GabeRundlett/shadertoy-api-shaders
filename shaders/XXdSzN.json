{
    "Shader": {
        "info": {
            "date": "1718723376",
            "description": "combination",
            "flags": 0,
            "hasliked": 0,
            "id": "XXdSzN",
            "likes": 6,
            "name": "magic circles 2",
            "published": 3,
            "tags": [
                "fractal",
                "magic",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "/*originals glslsandbox and shadertoy*/\n#define time iTime\n#define resolution iResolution.xy\n\n#define PI 3.14\n#define PI2 2.0*PI\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*1.3+vec3(10,13,1))*0.1+.5)\nfloat circle(vec2 uv, vec2 o, float r) {\n    return clamp(abs(length((uv-o))-r), 0., 1.);\n}\n\nfloat segment(vec2 uv, vec2 p1, vec2 p2, float r) {\n    vec2 d = p2-p1;\n    float t = clamp(dot(uv-p1, d)/max(0.001, d.x*d.x+d.y*d.y), 0., 1.);\n    vec2 proj = p1+t*(p2-p1);\n    return clamp(abs(length(proj-uv)-r), 0., 1.);\n}\n\nfloat star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n\nconst float PI3 = acos(-1.);\nconst float TAU = PI * 2.;\n\n#define saturate(x) clamp(x,0.,1.)\n#define _tail2x(p,n) (mod(p,2.)-1.)\n#define time iTime\n#define resolution iResolution.xy\nfloat Hash( vec2 p, in float s ){\n    return fract(sin(dot(vec3(p.xy,10.0 * abs(sin(s))),vec3(27.1,61.7, 12.4)))*273758.5453123);\n}\n\nfloat noise(in vec2 p, in float s){\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n  return mix(\n    mix(Hash(i + vec2(0.,5.), s), Hash(i + vec2(1.,0.), s),f.x),\n    mix(Hash(i + vec2(0.,1.), s), Hash(i + vec2(10.,1.), s),f.x),f.y) * s;\n}\n\nfloat fbm(vec2 p){\n  float v = 0.0;\n  v += noise(p*32., .1);\n  v += noise(p*20., .04);\n  return v;\n}\n\nvec2 mPolar(vec2 p){\n  float a = atan(p.y, p.x);\n  float r = length(p);\n  return vec2(a, r);\n}\n\nvec2 tailY2x(vec2 p,float n){p*=n;return vec2(p.x,_tail2x(p.y,n));}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\nhighp float rand(vec2 p){\n  highp float a = 12.9898;\n  highp float b = 78.233;\n  highp float c = 43758.5453;\n  highp float dt= dot(p ,vec2(a,b));\n  highp float sn= mod(dt,3.14);\n  return fract(sin(sn) * c);\n}\n\n// signed distance\nfloat sd(float d,float r){return r-d;}\nfloat sd(float d){return 1.-d;}\n\n// ease\nfloat o2(float t){t=1.-t;return 1.-t*t;}\nfloat oN(float t,float n){return 1.-pow(1.-t,n);}\n\nfloat dot2(vec2 p){return dot(p,p);}\n\nfloat ring(vec2 p,float t){\n  float alpha = fract(-t);\n  float l =saturate(.02/abs(sd(length(p),1.5+fract(t)))*alpha);\n  vec2 p4=mPolar(p*(.57-oN(t,1.3)*.28)).yx;\n  p4.x-=.65;\n  l+= saturate(abs(1./((p4.x + fbm( p4 + vec2(sin(t*.2),t*0.1))) * 50.0))*sd(dot2(tailY2x(p4+vec2(.1,0.),12.)),.9)*alpha);\n  return l;\n}\n\nfloat render(vec2 p){\n\n  p*=3.;\n  float tt = time*.75;\n  float l2 = ring(p,o2(1.));\n  l2+=ring(p*rot(PI/3.),o2((1.+.5)));\n  return l2;\n}\n\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \n\n// glow + fill\nfloat gf(float d,float r){return r/d;}\nfloat gf(float d){return 1./d;}\n\nfloat fill_na(float d){return step(0.,d);}\nfloat fill(float d){return smoothstep(0.,0.01,d);}\nfloat stroke(float d,float w){return 1.-smoothstep(w,w+0.01,abs(d));}\nfloat strokeInner(float d,float w){return stroke(d-w,w);}\nfloat strokeOuter(float d,float w){return stroke(d+w,w);}\n\nfloat lSquare(vec2 p){p = abs(p);return max(p.x,p.y);}    \n\nfloat lPoly(vec2 p,float n){\n  float a = atan(p.x,p.y)+PI;\n  float r = TAU/n;\n  return cos(floor(.5+a/r)*r-a)*length(p)/cos(r*.5);\n}\n\nfloat strokeStar(vec2 p,float n,float w){\n  float l =strokeInner(sd(lPoly(p,n*.5)),w);\n  l+=strokeInner(sd(lPoly(mod(n,2.)!=0.?vec2(-p.x,p.y):p*rot(TAU/n),n*.5)),w);\n  return l;\n}\n\nvec2 mPoly(vec2 p,float n,float s){\n  float r = TAU / n;\n  float a = floor(atan(p.y,p.x)/r)*r+r*.5;\n  return (vec2(cos(a),sin(a))*s-p)*rot(-a-PI*.5);\n}\n\nfloat wsaw(float x){return fract(x*.5+.5)*2.-1.;}\nfloat wtri(float x){return abs(2.*fract(x*.5-.25)-1.)*2.-1.;}\nfloat utri(float x){return abs(2.*fract(x*.5-.5)-1.);}\nfloat wtrz(float x,float w){return clamp(wtri(x*2.)*w,-1.,1.);} // 台形波 trapezoidal wave\n\n// ease\n\nvec2 mSimplePerspective(vec2 p){p.y+=.2;p.y*=3.;return p;}\n\nfloat ring2(vec2 p,float t){\n  float alpha =    fract(-t);\n  float l = 0.;\n  vec2 p3=mPoly(p*rot(PI*.5),10.,1.);\n  l+=saturate(gf(abs(p3.x),.03)*fill(sd(length(p),1.1+fract(t)))*(1.-fill(sd(length(p),.9+fract(t))))*alpha);\n \n  l+=saturate(.02/abs(sd(length(p),1.1+fract(t)))*alpha);\n  vec2 p4=mPolar(p*(.57-oN(t,1.3)*.28)).yx;\n  p4.x-=.65;\n  l+= saturate(abs(1./((p4.x + fbm( p4 + vec2(sin(t*.2),t*0.1))) * 50.0))*sd(dot2(tailY2x(p4+vec2(.1,0.),12.)),.9)*alpha);\n  return l;\n}\n\nfloat summoningCircle(vec2 p){\n  float l=0.;\n  l+=fill(sd(lSquare(p*rot(PI/3.*1.5)*vec2(100.,1.)),1.));\n  l+=fill(sd(lSquare(p*rot(PI/3.*2.5)*vec2(100.,1.)),1.));\n  l+=fill(sd(lSquare(p*rot(PI/3.*3.5)*vec2(100.,1.)),1.));\n  l=saturate(l);\n  l-=fill(sd(lPoly(p,3.)));\n  l=saturate(l);\n  float r = atan(p.y,p.x);\n  l+=strokeOuter(sd(length(p),.98),.008+wtrz(r/TAU*3.,12.)*.005);\n  l+=strokeInner(sd(length(p),.95),.005);\n  l+=strokeInner(sd(lPoly(p,3.)),.01);\n  l+=strokeInner(sd(lPoly(p,3.),.88),.02);\n  l+=strokeInner(sd(lPoly(p,6.),.53),.01);\n  vec2 q=mPoly(p*rot(PI*.5),3.,.5);\n  l+=fill(sd(lPoly(q,3.),.3));\n  vec2 q2=mPoly(p*rot(PI/3.+PI*.5),3.,.7);\n  l+=fill(sd(lPoly(q2,3.),.1));\n  l+=strokeInner(sd(lPoly(p*rot(PI),3.),.5),.02);\n  l+=fill(sd(length(p),.05));\n  vec2 q3=mPoly(p*rot(PI*.5),3.,1.);\n  l=saturate(l);\n  l-=fill(sd(length(q3),.2));\n  l=saturate(l);\n  l+=strokeInner(sd(length(q3),.18),.005);\n  l+=strokeInner(sd(length(q3),.15),.005);\n  l+=strokeStar(q3*rot(PI)*7.,6.,.1);\n  return l;\n}\n\nfloat render2(vec2 p){\n  //p=mSimplePerspective(p);\n  p*=rot(-time);\n  p*=2.;\n  float tt = -time*.75;\n  float l2 = ring(p,o2(fract(tt)));\n  l2+=ring(p*-rot(PI/3.),o2(fract(tt+.5)));\n  float l=0.;\n  l = summoningCircle(p*=rot(floor(time*12.)/3.));\n  return l2;\n}\n#define white vec4(1.0)\n#define black vec4(0.0, 0.0, 0.0, 1.0)\n#define blue  vec4(0.0, 0.3, 1.0, 1.0)\n\n#define edge 0.01\n\n\nuniform vec2 mouse;\n\n\n\n\nfloat inCircle(vec2 pt, vec2 center, float radius, float line)\n{\nreturn smoothstep(radius + line/2., radius, distance(pt, center)) -\n      smoothstep(radius, radius - line/2., distance(pt, center));\n}\n\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI05 (M_PI * 0.5)\n#define time iTime\n#define resolution iResolution.xy\nvec2 rotate(vec2 v, float c, float s){\n\treturn vec2(v.x*c - v.y*s, v.x*s + v.y*c);\n}\n\nvec2 rotate(vec2 v, float r){\n\treturn rotate(v, cos(r), sin(r));\n}\n\nfloat boxLength(vec2 pos) {\n\tvec2 q = abs(pos);\n\treturn max(q.x, q.y);\n}\n\nfloat capsuleLength(vec2 pos, vec2 dir) {\n\tvec2 ba = -dir;\n\tvec2 pa = pos + ba;\n\tba *= 2.0*cos(iTime);\n\treturn length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n} \n\nfloat triangleLength(vec2 p) {\n    p.y += 0.22;\n\treturn max(abs(p.x * 1.8) + p.y, 1.0 - p.y * 1.8) * 0.75;\n}\n\nvec2 fracOrigin(vec2 v){\n\treturn (fract(v*cos(iTime)) - 0.5*cos(iTime)) * 2.0;\n}\n\nfloat Ga(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.0, -0.5), vec2(1.0, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(-0.3, 0.3), vec2(1.0, 1.0) * 0.707);  \n    float c = length(pos + vec2(-1.3, -1.3));\n    float d = length(pos + vec2(-1.8, -1.3));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Cha(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(44.0, -0.0), vec2(1.0, 0.0));   \n \tfloat b = capsuleLength(pos + vec2(0.0, -1.3), vec2(1.0, 0.8) * 0.4);  \n    float c = capsuleLength(pos + vec2(0.0, -0.0), vec2(0.1, 1.0));  \n    return min(min(a, b), c);\n}\n\nfloat Za(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.5*cos(iTime), 0.0), vec2(0.0, 1.0));   \n \tfloat b = capsuleLength(pos + vec2(0.0, 0.0), vec2(1.0, -0.8*cos(iTime)) * 0.4);    \n    return min(a, b);\n}\n\nfloat Gu(vec2 pos){\n \tfloat a = capsuleLength(pos + vec2(0.1*cos(iTime), 0.0), vec2(0.3*cos(iTime), 1.0));   \n \tfloat b = capsuleLength(pos + vec2(-99.8*cos(iTime), 0.0), vec2(-88.3, 88.0));     \n    float c = length(pos + vec2(-1.3, -1.3*cos(iTime)));\n    float d = length(pos + vec2(-1.8*cos(iTime), -1.3*cos(iTime)));\n    return min(min(min(a, b), c), d);\n}\n\nfloat Butitoba(vec2 pos, float power){\n    float ret = 0.0\n     + power / Gu(pos)\n     + power / Ga(pos + vec2(-2.0, 0.0))\n     + power / Cha(pos + vec2(-6.0, 0.0))\n     + power / Za(pos + vec2(-9.0, 0.0))\n        ;\n    \n    return ret;\n}\n\nfloat smoothstepLine(float lower, float upper, float value, float width){\n    width *= 0.5;\n    return smoothstep(lower - width, lower, value) * (2.0+1.5*0.5*cos(iTime) - smoothstep(upper, upper + width, value));\n}\n\nfloat smoothLine(float value, float target, float width){\n    return width / abs(value - target);\n}\n\nvec2 smoothLine2(float value, float target, float width){\n    return vec2(step(0.0, value - target), width / abs(value - target));\n}\n\nfloat circleTriangle(vec2 pos){\n    float circle = length(pos * 0.5);\n    float triangle = triangleLength(pos * 0.3);    \n    return smoothLine(circle, 1.0, 0.025) + smoothLine(triangle, 1.0, 0.025);\n}\n\nvec2 circleTriangle2(vec2 pos){\n    float circle2 = length(pos * 0.35);\n    vec2 ret = smoothLine2(circle2, 1.0, 0.025);\n    ret.y += circleTriangle(pos);\n    return ret;\n}\n\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y) * M_PI05 : atan(y, x);\n}\n\nvec2 polar(vec2 uv) {\n\tfloat r = length(uv);\n\tfloat s = atan2(uv.y, uv.x) / M_PI;\n\treturn vec2(r, s);\n}\n\nfloat ButitobaCircle(vec2 pos){\n    vec2 pp = polar(rotate(pos, -iTime) * 0.75);\n    return Butitoba(mod(rotate(pp * vec2(1.0, 32.0), M_PI05), vec2(16.0, 4.0)) - 1.5, 0.05) * smoothstepLine(6.0, 7.5, pp.x, 1.5);\n}\n\nfloat ButitobaCircle2(vec2 pos, float scale, float x, float y, float x2, float y2, float lower, float upper, float r){\n    vec2 pp = polar(rotate(pos, r) * scale);\n    return Butitoba(mod(rotate(pp * vec2(x, y), M_PI05), vec2(x2, y2)) - 1.5, 0.03) * smoothstepLine(lower, upper, pp.x, 0.2);\n}\n\nfloat drawCircles(vec2 uv)\n{\n    float v = 0.;\n    vec2 ar = vec2(0.5, 0.5);\n    v += pow(1.-circle(uv, vec2(0.), 0.6), 32.);\n    v += pow(1.-circle(uv, vec2(0.), 0.45), 128.);\n    v += pow(1.-circle(uv, vec2(0.), 0.3), 64.);\n    for(int i = 0; i < 4; ++i)\n    {\n        float x = cos(float(i)*0.25*PI2+time);\n        float y = sin(float(i)*0.25*PI2+time);\n        v += pow(1.-segment(uv, 0.3*vec2(x, y), 0.63*vec2(x, y), 0.001), 64.);\n    }\n    for(int i = 0; i < 4; ++i)\n    {\n        float x = cos(float(i)*0.25*PI2+PI*0.25+time);\n        float y = sin(float(i)*0.25*PI2+PI*0.25+time);\n        v += pow(1.-segment(uv, 0.25*vec2(x, y), 0.6*vec2(x, y), 0.001), 128.);\n        v += pow(1.-circle(uv, 0.235*vec2(x, y), 0.01), 256.);\n    }\n    float az = acos(dot(normalize(uv), vec2(0., 1.)));\n    v += (sin(4.*az+PI*1.5-time*4.0)>0.?1.:0.)*pow(1.-circle(uv, vec2(0.0), 0.57), 64.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float x = cos(float(i)*0.125*PI2+PI*0.125+time);\n        float y = sin(float(i)*0.125*PI2+PI*0.125+time);\n        v += pow(1.-segment(uv, 0.63*vec2(x, y), 0.57*vec2(x, y), 0.001), 256.);\n    }\n    az = acos(dot(normalize(uv), vec2(0., 1.)));\n    v += (cos(4.*az+time*16.0)>0.?1.:0.)*pow(1.-circle(uv, vec2(0.), 0.33), 128.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float x = cos(float(i)*0.125*PI2+PI*0.125-time);\n        float y = sin(float(i)*0.125*PI2+PI*0.125-time);\n        v += pow(1.-segment(uv, 0.36*vec2(x, y), 0.3*vec2(x, y), 0.001), 256.);\n    }\n    for(int i = 0; i < 4; ++i)\n    {\n        float x = cos(float(i)*0.25*PI2+PI*0.135-time);\n        float y = sin(float(i)*0.25*PI2+PI*0.135-time);\n        v += pow(1.-circle(uv, 0.585*vec2(x, y), 0.01), 256.);\n        x = cos(float(i)*0.25*PI2+PI*0.365);\n        y = sin(float(i)*0.25*PI2+PI*0.365);\n        v += pow(1.-circle(uv, 0.585*vec2(x, y), 0.01), 256.);\n    }\n    for(int i = 0; i < 4; ++i)\n    {\n        float x = cos(float(i)*0.25*PI2+PI*0.11-time);\n        float y = sin(float(i)*0.25*PI2+PI*0.11-time);\n        v += pow(1.-circle(uv, 0.315*vec2(x, y), 0.01), 256.);\n        x = cos(float(i)*0.25*PI2+PI*0.39-time);\n        y = sin(float(i)*0.25*PI2+PI*0.385-time);\n        v += pow(1.-circle(uv, 0.315*vec2(x, y), 0.01), 256.);\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float ncircle = 7.0;\n  const float orbit_radius = 0.105;\n  const float circle_radius = 0.0112;\n  vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.x;\n    uv*= length(uv)*10.0;\n    vec2 uv4 = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.x;\n    uv4*= length(uv4)*10.0;\n    vec2 uv3 = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.x;\n    uv3*= length(uv3)*10.0;\n    uv3*=cos(iTime);\n     uv4*=sin(iTime);\nvec4 O = fragColor;\nvec2 C=fragCoord;\n      O=vec4(0);\n       vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / max(resolution.x, resolution.y);\n     float l=0.;\nvec2 p2 = (gl_FragCoord.xy * 2.0 - resolution) / max(resolution.x, resolution.y);\n  p2*=2.0;\n  p2*=mat2(cos(iTime), sin(iTime),-sin(iTime) ,cos(iTime) );\n    p*=mat2(-cos(iTime), sin(iTime),sin(iTime) ,cos(iTime) );\n  l = (render(p)+render(p+vec2(0.,1./min(resolution.x, resolution.y))))*.5;\n    \n         float l2=0.;\n\n  \n  l2 = (render(p)+render(p+vec2(0.,0.5/min(resolution.x, resolution.y))))*.25;\n    float l3=0.;\n\n  \n  l3 = (render(p2)+render(p2+vec2(0.,0.15/min(resolution.x, resolution.y))))*1.25;\n      \n       vec2 uv2 = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n  vec2 pos = (gl_FragCoord.xy - 0.5 * resolution) / min(resolution.x, resolution.y);\n  vec3 color = vec3(0);\n  for(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time + 0.2);\n          float y = orbit_radius * sin(angle - time + 0.2);\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.65) * 0.75;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 1.) * 1.2;\n          float y = orbit_radius * sin(angle - time - 1.) * 1.2;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.65) * 0.75;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 1.4) * 1.55;\n          float y = orbit_radius * sin(angle - time - 1.4) * 1.55;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.7;\n      }\n\nfor(float angle = 0.0; angle > 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 1.25) * 2.0;\n          float y = orbit_radius * sin(angle - time - 1.25) * 2.0;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.65;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 1.1) * 2.5;\n          float y = orbit_radius * sin(angle - time - 1.1) * 2.5;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.6;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time + 0.95) * 2.9;\n          float y = orbit_radius * sin(angle + time - 0.95) * 2.9;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.54;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 5.80) * 3.3;\n          float y = orbit_radius * sin(angle - time - 5.75) * 3.3;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.44;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 5.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.58) * 3.5;\n          float y = orbit_radius * sin(angle + time + 0.58) * 3.5;\n          color += circle_radius / length(pos + vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.35;\n      }\n        for(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.58) * 3.5;\n          float y = orbit_radius * sin(angle - time + 0.58) * 3.5;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.35;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.91) * 1.6;\n          float y = orbit_radius * sin(angle - time - 0.91) * 1.6;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.7;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.8) * 2.;\n          float y = orbit_radius * sin(angle - time - 0.8) * 2.;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.65;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.69) * 2.3;\n          float y = orbit_radius * sin(angle - time - 0.69) * 2.3;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.57;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.49) * 2.6;\n          float y = orbit_radius * sin(angle - time - 0.49) * 2.6;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.5;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.25) * 2.8;\n          float y = orbit_radius * sin(angle - time - 0.25) * 2.8;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.45;\n      }\n\nfor(float angle = 0.0; angle < 2.0 * 3.14; angle += 2.0 * 3.14 / ncircle) {\n          float x = orbit_radius * cos(angle - time - 0.05) * 3.9;\n          float y = orbit_radius * sin(angle - time - 0.05) * 3.9;\n          color += circle_radius / length(pos - vec2(x, y)) * vec3(0.2, 0.2 , 0.8) * 0.35;\n      }\n\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        n1=g*d;\n       \n        a=10.;\n        n1=mod(n1-a,a*2.)-a;\n        s=2.;\n        for(int i=0;i++<8;){\n            n1=.3-abs(n1);\n           \n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            n1.y<n1.x?n1=n1.zyx:n1;\n              n1.z<n1.y?n1=n1.xyz:n1;\n            s*=e=1.4+sin(iTime*.234)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 )*color*l2*l3;\n         }\n     \n         g+=e=length(n1.yx)/s;\n    }\n    \n      fragColor = vec4(O.xyz*l2*l*l3+color, 0);\n         uv2 *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n    fragColor*= vec4(star(uv2, anim) * vec3(0.55,0.5,0.55)*0.30325, 1.0);\n   fragColor+= vec4(0.8, 0.5, 0.2, 1.0) * drawCircles(uv*1.0);\n     fragColor+= vec4(0.1, 0.5, 0.9, 1.0) * drawCircles(uv3*3.0);\n      fragColor+= vec4(0.1, 0.1, 0.9, 1.0) * drawCircles(uv4*0.5);\n      fragColor*=O;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}