{
    "Shader": {
        "info": {
            "date": "1609193015",
            "description": "Implementing [url]https://bottosson.github.io/posts/oklab/[/url]. See comments at top of code for instructions/details.",
            "flags": 16,
            "hasliked": 0,
            "id": "WtccD7",
            "likes": 41,
            "name": "oklab colorspace testing",
            "published": 3,
            "tags": [
                "hsv",
                "lab",
                "colorspace",
                "oklab"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 3693
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////\n//\n// Visualizing BjÃ¶rn Ottosson's \"oklab\" colorspace\n//\n// shadertoy implementation by mattz\n//\n// license CC0 (public domain)\n// https://creativecommons.org/share-your-work/public-domain/cc0/\n//\n// Click and drag to set lightness (mouse x) and chroma (mouse y).\n// Hue varies linearly across the image from left to right.\n//\n// While mouse is down, plotted curves show oklab components\n// L (red), a (green), and b (blue). \n//\n// To test the inverse mapping, the plotted curves are generated\n// by mapping the (pre-clipping) linear RGB color back to oklab \n// space.\n//\n// White bars on top of the image (and black bars on the bottom of\n// the image) indicate clipping when one or more of the R, G, B \n// components are greater than 1.0 (or less than 0.0 respectively).\n//\n// The color accompanying the black/white bar shows which channels\n// are out of gamut.\n//\n// Click in the bottom left to reset the view.\n//\n// Hit the 'G' key to toggle displaying a gamut test:\n//\n//   * black pixels indicate that RGB values for some hues\n//     were clipped to 0 at the given lightness/chroma pair.\n//\n//   * white pixels indicate that RGB values for some hues\n//     were clipped to 1 at the given lightness/chroma pair\n//\n//   * gray pixels indicate that both types of clipping happened\n//\n// Hit the 'U' key to display a uniform sampling of linear sRGB \n// space, converted into oklab lightness (x position) and chroma\n// (y position) coordinates. If you mouse over a colored dot, the\n// spectrum on screen should include that exact color.\n//\n//////////////////////////////////////////////////////////////////////\n\n//////////////////////////////////////////////////////////////////////\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n//////////////////////////////////////////////////////////////////////\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nconst float max_chroma = 0.33;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // setup oklab color\n    float theta = 2.*3.141592653589793*uv.x;\n    \n    float L = 0.8;\n    float chroma = 0.1;\n    \n    if (max(iMouse.x, iMouse.y) > 0.05 * iResolution.y) {\n        L = iMouse.x / iResolution.x;\n        chroma = iMouse.y * max_chroma / iResolution.y;\n    }\n    \n    float a = chroma*cos(theta);\n    float b = chroma*sin(theta);\n    \n    vec3 lab = vec3(L, a, b);\n\n    // convert to rgb \n    vec3 rgb = linear_srgb_from_oklab(lab);\n    \n    // roundtrip back to oklab\n    vec3 hopefully_lab_again = oklab_from_linear_srgb(rgb);\n    \n    // see if we left the RGB color cube?\n    float cmin = min(rgb.x, min(rgb.y, rgb.z));\n    float cmax = max(rgb.x, max(rgb.y, rgb.z));\n    \n    // clamp into rgb color cube\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    ////////////////////////////////////////////////////////////\n    // display gamut test\n    \n    if (texelFetch(iChannel0, ivec2(71, 2), 0).x != 0.0) {\n    \n        // sweep across 32 hues for a given lightness, chroma pair\n        const float hmax = 32.;\n        \n        // find min/max in RGB space across hue sweep\n        float cmin = 1.0;\n        float cmax = 0.0;\n\n        for (float h=0.0; h<hmax; ++h) {\n\n            float theta = 2.*3.141592653589793*h/hmax;\n\n            // oklab space\n            vec3 lab = vec3(uv.x, max_chroma*uv.y*vec2(cos(theta), sin(theta)));\n\n            // get color in RGB space\n            vec3 rgb_test = linear_srgb_from_oklab(lab);\n    \n            // update min max\n            cmin = min(cmin, min(rgb_test.x, min(rgb_test.y, rgb_test.z)));\n            cmax = max(cmax, max(rgb_test.x, max(rgb_test.y, rgb_test.z)));\n\n\n        }\n        \n        // color output\n        if (cmin < 0.0) {\n            if (cmax > 1.0) {\n                rgb = vec3(0.5);\n            } else {\n                rgb = vec3(0.0);\n            }\n        } else if (cmax > 1.0) {\n            rgb = vec3(1.0);\n        }\n\n    } \n    \n\n    ////////////////////////////////////////////////////////////\n    // display bars on top/bottom for clipping\n\n    if (uv.y < 0.05 && cmin < 0.0) {\n        if (uv.y < 0.01) {\n            rgb = step(rgb, vec3(0.0));\n        } else {\n            rgb = vec3(0);\n        }\n    } else if (uv.y > 0.95 && cmax > 1.0) {\n        if (uv.y > 0.99) {\n            rgb = step(vec3(1.0), rgb);\n        } else {\n            rgb = vec3(1);\n        }\n    }\n\n    ////////////////////////////////////////////////////////////\n    // plot oklab l,a,b curves  \n\n    if (max(iMouse.z, iMouse.w) > 0.05 * iResolution.y) {\n    \n        vec3 y = iResolution.y * vec3(hopefully_lab_again.x, hopefully_lab_again.yz*0.5/max_chroma + 0.5);\n        vec3 dydx = dFdx(y);\n        \n        vec3 y_alt= iResolution.y * vec3(L, 0.5*chroma*vec2(cos(theta), sin(theta))/max_chroma + 0.5);\n        vec3 dydx_alt = dFdx(y_alt);\n        \n        if (mod(fragCoord.x, 2.0) > 0.5) {\n            y = y_alt;\n            dydx = dydx_alt;\n        }\n        \n        vec3 scl = 1.0 / sqrt(1.0 + dydx*dydx);\n        vec3 d = abs(fragCoord.y - y)*scl;\n\n        for (int i=2; i>=0; --i) {\n            vec3 color = vec3(0);\n            color[i] = 1.0;\n            rgb = mix(rgb, vec3(1), smoothstep(1.0, 0.0, d[i]-4.0));\n            rgb = mix(rgb, color, smoothstep(1.0, 0.0, d[i]-1.0));\n        }\n        \n    }\n\n    ////////////////////////////////////////////////////////////\n    // uniform sampling of RGB cube\n\n    if (texelFetch(iChannel0, ivec2(85, 2), 0).x != 0.0) {\n            \n        const float drgb = 0.5;\n        float sz = 0.02 * iResolution.y;\n    \n        for (float r=0.0; r<=1.0; r+=drgb) {\n            for (float g=0.0; g<=1.0; g+=drgb) {\n                for (float b=0.0; b<=1.0; b+=drgb) {\n                \n                    vec3 rgb_test = vec3(r, g, b);\n                    \n                    vec3 lab = oklab_from_linear_srgb(rgb_test);\n                    \n                    float l = lab.x;\n                    float c = length(lab.yz)/max_chroma;\n                    \n                    vec2 p = vec2(l, c)*iResolution.xy - fragCoord.xy;\n                    \n                    float d = length(p);\n                    \n                    \n                    rgb *= smoothstep(0.0, 1.0, d-sz*1.25);\n                    rgb = mix(rgb, rgb_test, smoothstep(1.0, 0.0, d-sz));\n                    \n                \n                }\n            }\n        }\n    \n    }\n    \n    ////////////////////////////////////////////////////////////\n    // transform to sRGB space\n\n    rgb = srgb_from_linear_srgb(rgb);\n\n    fragColor = vec4(rgb, 1.0);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}