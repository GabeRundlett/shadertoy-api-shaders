{
    "Shader": {
        "info": {
            "date": "1630962359",
            "description": "Animating [url=https://www.shadertoy.com/view/fddGDs]https://www.shadertoy.com/view/fddGDs[/url].",
            "flags": 0,
            "hasliked": 0,
            "id": "fdK3RR",
            "likes": 15,
            "name": "Walking Rainbow",
            "published": 3,
            "tags": [
                "bezier",
                "animation",
                "rainbow",
                "walk"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 209
        },
        "renderpass": [
            {
                "code": "// Length between a starting (t1) and ending (t2) position\nfloat bezierArclength(in float t1, in float t2, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    vec2 t = (u * vec2(t1, t2) + v) / sqrt(dis);\n    vec2 y = asinh(t) + t * sqrt(t * t + 1.0);\n    return (y.y - y.x) * dis / pow(u, 1.5);\n}\n\n// Newton-Raphson solver for inverse arclength\nfloat bezierInvArclength(in float d, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 abc = a - 2.0 * b + c;\n    vec2 ba = b - a;\n\n    float u = dot(abc, abc);\n    float v = dot(abc, ba);\n    float w = dot(ba, ba);\n\n    float dis = u * w - v * v;\n    float sdis = sqrt(dis);\n    float disu = dis / u;\n    float k = dis / pow(u, 1.5);\n\n    float y = v / sdis;\n    d += (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n\n    float t = ((sqrt(disu + u * abs(d)) - sqrt(disu)) * sign(d) - v) / u;\n    for (int n=0; n < 5; n++) {\n        float y = (u * t + v) / sdis;\n        float arclen = (asinh(y) + y * sqrt(y * y + 1.0)) * k;\n        float arcint = 2.0 * sqrt((u * t + 2.0 * v) * t + w);\n        t -= (arclen - d) / arcint;\n    }\n\n    return t;\n}\n\n// ---------- Helper functions ----------\nvec3 hue2rgb(in float hue) {\n    return abs(2.0 * smoothstep(0.0, 1.0, fract(vec3(hue, hue - 1.0 / 3.0, hue + 1.0 / 3.0))) - 1.0);\n}\n\nmat2 Rotate2D(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float p) {\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash21(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat snoise(in vec2 p) {\n    vec2 c = floor(p);\n    vec2 f = fract(p);//smoothstep(0.0, 1.0, fract(p));\n\n    float bl = Hash21(c);\n    float br = Hash21(c + vec2(1.0, 0.0));\n    float tl = Hash21(c + vec2(0.0, 1.0));\n    float tr = Hash21(c + 1.0);\n\n    return mix(mix(bl, br, f.x), mix(tl, tr, f.x), f.y);\n}\n\n// ---------- SDFs ----------\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdStar5(in vec2 p, in float r, in float rf) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0.0, 1.0);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\n// Returns vec2(shortest distance to the curve, parameter of the nearest position on the curve)\nfloat dot2(in vec2 v) { return dot(v, v); }\nvec2 sdBezier(in vec2 p, in vec2 v1, in vec2 v2, in vec2 v3) {\n    vec2 c1 = p - v1;\n    vec2 c2 = 2.0 * v2 - v3 - v1;\n    vec2 c3 = v1 - v2;\n\n    float t3 = dot(c2, c2);\n    float t2 = dot(c3, c2) * 3.0 / t3;\n    float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n    float t0 = dot(c1, c3) / t3;\n\n    float t22 = t2 * t2;\n    vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n    float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n    float p2 = abs(pq.x);\n    float r1 = 1.5 / pq.x * pq.y;\n\n    if (qq * 0.25 + ppp / 27.0 > 0.0) {\n        float r2 = r1 * sqrt(3.0 / p2), root;\n        if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n        else root = sinh(asinh(r2) / 3.0);\n        root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n        return vec2(length(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)), root);\n    }\n\n    else {\n        float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n        vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n        float d1 = dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x));\n        float d2 = dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y));\n        return d1 < d2 ? vec2(sqrt(d1), roots.x) : vec2(sqrt(d2), roots.y);\n    }\n}\n\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.0;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 2.0;\n    float unit = 4.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // Color bands in the background\n    color = vec3(floor(snoise(vec2(uv.y * 4.0, 0.1 * iTime)) * 5.0) * 0.25);\n    color *= step(0.0, 0.2 - snoise(vec2(uv.y * 10.0, iTime)));\n    color *= fragCoord.y / iResolution.y;\n\n    // Control points\n    vec2 a = vec2(-1.0, -0.5);\n    vec2 b = vec2(-0.5, 0.25);\n    vec2 c = vec2(0.0, -0.5);\n\n    float time = mod(iTime, 6.28);\n    uv.x += time / 6.28 * 2.0 - 0.5;\n    float transition = 0.5 - 0.5 * cos(min(time, 3.14));\n\n    // Rotate back segment forward\n    a -= c;\n    a *= Rotate2D(3.14 * transition);\n    a += c;\n\n    b.x = mix(-0.5, 0.5, transition);\n\n    // Repeat, but this time with the forward (now back) segment\n    if (time > 3.14) {\n        float transition = 0.5 + 0.5 * cos(time);\n\n        c -= a;\n        c *= Rotate2D(3.14 * transition);\n        c += a;\n\n        b.x = mix(0.5, 1.5, transition);\n    }\n\n    // Poles or whatever its walking on\n    drawSDF(sdBox(vec2(fract(uv.x + 0.5) - 0.5, uv.y + 10.55), vec2(0.05, 9.95)) - 0.05, vec3(0.0, 0.8, 0.6));\n\n    // Bezier curve\n    vec2 bezClosest = sdBezier(uv, a, b, c);\n    float bezLength = bezierArclength(0.0, 1.0, a, b, c);\n    bezClosest.y = bezierArclength(0.0, bezClosest.y, a, b, c) / bezLength;\n    drawSDF(bezClosest.x - 0.05, hue2rgb(bezClosest.y));\n\n    // Plot rotating stars at regular intervals\n    mat2 rot = Rotate2D(iTime);\n\n    float du = bezLength / 5.0;\n    for (float u=0.0; u < 6.0; u++) {\n        float t = bezierInvArclength(u * du, a, b, c);\n        vec2 pos = mix(mix(a, b, t), mix(b, c, t), t);\n\n        mat2 starRot = rot;\n        if (int(u) % 2 == 0) starRot = transpose(starRot); // Alternate rotation direction\n\n        drawSDF(sdStar5((uv - pos) * starRot, 0.05, 0.5), vec3(0.25, 0.0, 0.5));\n    }\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}