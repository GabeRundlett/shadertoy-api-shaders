{
    "Shader": {
        "info": {
            "date": "1687371539",
            "description": "* Drag -> Look around\n* WASD -> Move\n* Shift -> Sprint\n* Alt -> Stealth?\n* R -> Reset\n",
            "flags": 48,
            "hasliked": 0,
            "id": "dsjcRR",
            "likes": 6,
            "name": "PBR with Ray Marching (WIP)",
            "published": 3,
            "tags": [
                "raymarching",
                "camera",
                "pathtracing"
            ],
            "usePreview": 1,
            "username": "beans_please",
            "viewed": 403
        },
        "renderpass": [
            {
                "code": "// Image\n// iChannel0 = Buffer A\n\n// Controls\n// * Drag -> Look around\n// * WASD -> Move\n// * Shift -> Sprint\n// * Alt -> Stealth?\n// * R -> Reset\n\nvec3 viewTransform(vec3 inp)\n{\n\t// Clip negatives\n    inp = max(inp, 0.0);\n\n    // Pre-Exposure\n    inp *= pow(2.0, 1.5);\n\n    // Offset\n    inp += vec3(0.0, 0.0, 0.006);\n\n    // Uniform Reinhard (good enough for now)\n    float lum = dot(inp, lumWeights);\n    inp /= lum + 1.0;\n    inp = mix(inp, vec3(1.0), smoothstep(0.0, 1.0, map_range_clamp(log2(lum), -1.0, 10.0, 0.0, 1.0)));\n\n    // OETF (Gamma)\n    inp = pow(inp, vec3(1.0 / 2.2));\n\n    return inp;\n}\n\nvec3 getAccumulated(in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return data.rgb * SAMPLE_COUNT_MUL / data.w;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = getAccumulated(fragCoord);\n    col = viewTransform(col);\n\n    fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Common\n\n#define PI 3.14159265359\n#define DEG_TO_RAD 0.01745329251994\n\n#define SAMPLE_COUNT_MUL 0.01\n\nconst vec3 lumWeights = vec3(0.2126, 0.7152, 0.0722);\nconst vec3 defPlayerPos = vec3(-1.5, -3.7, 0.4);\nconst vec3 defCamOrient = vec3(97.0, 0.0, -25.0);\n\nfloat map_range(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    return out_start + ((out_end - out_start) / (inp_end - inp_start)) * (inp - inp_start);\n}\n\nfloat map_range_clamp(float inp, float inp_start, float inp_end, float out_start, float out_end)\n{\n    float t = clamp((inp - inp_start) / (inp_end - inp_start), 0.0, 1.0);\n    float v = out_start + t * (out_end - out_start);\n    return v;\n}\n\nvec3 mixColPerceptual(vec3 a, vec3 b, float t)\n{\n    //return mix(a, b, t);\n    return pow(mix(sqrt(a), sqrt(b), t), vec3(2.0));\n}\n\nvec3 rotateEuler(vec3 v, vec3 angle)\n{\n    angle *= DEG_TO_RAD;\n\n    // X\n    v.x = v.x * cos(angle.x) - v.y * sin(angle.x);\n    v.y = v.x * sin(angle.x) + v.y * cos(angle.x);\n\n    // Y\n    v.x = v.x * cos(angle.y) + v.z * sin(angle.y);\n    v.z = -v.x * sin(angle.y) + v.z * cos(angle.y);\n\n    // Z\n    v.y = v.y * cos(angle.z) - v.z * sin(angle.z);\n    v.z = v.y * sin(angle.z) + v.z * cos(angle.z);\n\n    return v;\n}\n\n// Ignores Y (roll)\nvec3 orientationToDirection(vec3 orient)\n{\n    orient.x -= 90.0;\n    orient.x *= DEG_TO_RAD;\n    orient.z *= -DEG_TO_RAD;\n\n    return vec3(vec2(sin(orient.z), cos(orient.z)) * cos(orient.x), sin(orient.x));\n}\n\n// ***********************************************\n// Source: https://www.shadertoy.com/view/WdSSRt\n// ***********************************************\n\n/* Usage Example:\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Using the function:\n    float a = random();\n    vec3 b = vec3(random(), random(), random());\n    \n    ...\n}\n\n*/\n\nuint eprng_state[2];\n\nuint eprng_rot(uint x, int k)\n{\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat random()\n{\n    uint s0 = eprng_state[0];\n    uint s1 = eprng_state[1];\n    uint result = eprng_rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    eprng_state[0] = eprng_rot(s0, 26) ^ s1 ^ (s1 << 9);\n    eprng_state[1] = eprng_rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid eprng_init(vec2 uv, float iTime)\n{\n    uv *= (iTime + 10.258);\n\n    eprng_state[0] = floatBitsToUint(uv.x);\n    eprng_state[1] = floatBitsToUint(uv.y);\n\n    random();\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Source: https://github.com/MaxBittker/glsl-voronoi-noise\n// ***********************************************\n\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv)\n{\n    uv *= myt;\n    uv *= mys;\n    return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash2(vec3 p)\n{\n    return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)), dot(p, vec3(113.0, 1.0, 57.0)))) *\n        43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float id = 0.0;\n    vec2 res = vec2(100.0);\n    for (int k = -1; k <= 1; k++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            for (int i = -1; i <= 1; i++)\n            {\n                vec3 b = vec3(float(i), float(j), float(k));\n                vec3 r = vec3(b) - f + hash2(p + b);\n                float d = dot(r, r);\n\n                float cond = max(sign(res.x - d), 0.0);\n                float nCond = 1.0 - cond;\n\n                float cond2 = nCond * max(sign(res.y - d), 0.0);\n                float nCond2 = 1.0 - cond2;\n\n                id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n                res = vec2(d, res.x) * cond + res * nCond;\n\n                res.y = cond2 * d + nCond2 * res.y;\n            }\n        }\n    }\n\n    return vec3(sqrt(res), abs(id));\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Keyboard Utils\n// ***********************************************\n\n// Key code constants\n// https://asawicki.info/nosense/doc/devices/keyboard/key_codes.html\n\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_R = 82;\nconst int KEY_Q = 81;\nconst int KEY_Z = 90;\n\nbool keyIsDown(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 0), 0).x != 0.0;\n}\n\nbool keyGotPressed(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 1), 0).x != 0.0;\n}\n\nbool keyToggleState(int key, sampler2D keyboardChannel)\n{\n    return texelFetch(keyboardChannel, ivec2(key, 2), 0).x != 0.0;\n}\n\nfloat keyIsDownF(int key, sampler2D keyboardChannel)\n{\n    return keyIsDown(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyGotPressedF(int key, sampler2D keyboardChannel)\n{\n    return keyGotPressed(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\nfloat keyToggleStateF(int key, sampler2D keyboardChannel)\n{\n    return keyToggleState(key, keyboardChannel) ? 1.0 : 0.0;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\n// ***********************************************\n// Data Buffer Utils\n// ***********************************************\n\nvec4 fetchVec4(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0);\n}\n\nvec3 fetchVec3(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xyz;\n}\n\nvec2 fetchVec2(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).xy;\n}\n\nfloat fetchScalar(sampler2D channel, ivec2 coord)\n{\n    return texelFetch(channel, coord, 0).x;\n}\n\n// ***********************************************\n// End\n// ***********************************************\n\nvec3 randomUnitVector()\n{\n    const int numAttempts = 100;\n\n    float l = 0.0;\n    for (int i = 1; i <= numAttempts; i++)\n    {\n        // random() returns a float in the [0, 1] range\n        vec3 p = vec3(random(), random(), random());\n        p = p * 2.0 - 1.0;\n\n        // Normalize and return if length <= 1\n        if ((l = length(p)) <= 1.0)\n            return p / l;\n    }\n\n    // If all failed\n    return normalize(vec3(random(), random(), random()));\n}\n\nvec3 randomPointInUnitSphere()\n{\n    return random() * randomUnitVector();\n}\n\nfloat mengerSpongeDF(int n, vec3 pos)\n{\n    if (length(pos) > 2.2)\n        return length(pos) - 1.8;\n\n    //by recursively digging a box\n    float x = pos.x, y = pos.y, z = pos.z;\n    x = x * 0.5 + 0.5;\n    y = y * 0.5 + 0.5;\n    z = z * 0.5 + 0.5; //center it by changing position and scale\n\n    float xx = abs(x - 0.5) - 0.5, yy = abs(y - 0.5) - 0.5, zz = abs(z - 0.5) - 0.5;\n    float d1 = max(xx, max(yy, zz)); //distance to the box\n    float d = d1; //current computed distance\n    float p = 1.0;\n    for (int i = 1; i <= n; ++i)\n    {\n        float xa = mod(3.0 * x * p, 3.0);\n        float ya = mod(3.0 * y * p, 3.0);\n        float za = mod(3.0 * z * p, 3.0);\n        p *= 3.0;\n\n        //we can also translate/rotate (xa,ya,za) without affecting the DE estimate\n\n        float xx = 0.5 - abs(xa - 1.5), yy = 0.5 - abs(ya - 1.5), zz = 0.5 - abs(za - 1.5);\n        d1 = min(max(xx, zz), min(max(xx, yy), max(yy, zz))) / p; //distance inside the 3 axis-aligned square tubes\n\n        d = max(d, d1); //intersection\n    }\n    //return d*2.0; //the distance estimate. The *2 is because of the scaling we did at the beginning of the function\n    return d;\n}\n\n// https://iquilezles.org/articles/mandelbulb\nfloat mandelbulb(in vec3 p, out vec4 resColor)\n{\n    if (length(p) > 1.5)\n        return length(p) - 1.2;\n\n    vec3 w = p;\n    float m = dot(w, w);\n\n    vec4 trap = vec4(abs(w), m);\n    float dz = 1.0;\n\n    for (int i = 0; i < 4; i++)\n    {\n#if 0\n        // polynomial version (no trigonometrics, but MUCH slower)\n        float m2 = m * m;\n        float m4 = m2 * m2;\n        dz = 8.0 * sqrt(m4 * m2 * m) * dz + 1.0;\n\n        float x = w.x;\n        float x2 = x * x;\n        float x4 = x2 * x2;\n        float y = w.y;\n        float y2 = y * y;\n        float y4 = y2 * y2;\n        float z = w.z;\n        float z2 = z * z;\n        float z4 = z2 * z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n        float k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = p.x + 64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n        w.y = p.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n        w.z = p.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4) * k1 * k2;\n#else\n        // trigonometric version (MUCH faster than polynomial)\n\n        // dz = 8*z^7*dz\n        dz = 8.0 * pow(m, 3.5) * dz + 1.0;\n\n        // z = z^8+c\n        float r = length(w);\n        float b = 8.0 * acos(w.y / r);\n        float a = 8.0 * atan(w.x, w.z);\n        w = p + pow(r, 8.0) * vec3(sin(b) * sin(a), cos(b), sin(b) * cos(a));\n#endif        \n\n        trap = min(trap, vec4(abs(w), m));\n\n        m = dot(w, w);\n        if (m > 256.0)\n            break;\n    }\n\n    resColor = vec4(m, trap.yzw);\n\n    // distance estimation (through the Hubbard-Douady potential)\n    return 0.25 * log(m) * sqrt(m) / dz;\n}\n\nfloat boxSD(vec3 p, vec3 center, vec3 scale)\n{\n    float x = max(p.x - center.x - scale.x / 2., center.x - p.x - scale.x / 2.);\n    float y = max(p.y - center.y - scale.y / 2., center.y - p.y - scale.y / 2.);\n\n    float z = max(p.z - center.z - scale.z / 2., center.z - p.z - scale.z / 2.);\n    float d = x;\n    d = max(d, y);\n    d = max(d, z);\n    return d;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat anotherFractalSD(vec3 p, float scale, int iters)\n{\n\tvec3 a1 = vec3(1,1,1);\n\tvec3 a2 = vec3(-1,-1,1);\n\tvec3 a3 = vec3(1,-1,-1);\n\tvec3 a4 = vec3(-1,1,-1);\n\tvec3 c;\n\tint n = 0;\n\tfloat dist, d;\n\twhile (n < iters) {\n\t\t c = a1; dist = length(p-a1);\n\t        d = length(p-a2); if (d < dist) { c = a2; dist=d; }\n\t\t d = length(p-a3); if (d < dist) { c = a3; dist=d; }\n\t\t d = length(p-a4); if (d < dist) { c = a4; dist=d; }\n\t\tp = scale*p-c*(scale-1.0);\n\t\tn++;\n\t}\n\n\treturn length(p) * pow(scale, float(-n));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Buffer A\n// iChannel0 = Buffer A\n// iChannel1 = Buffer B\n\nprecision highp float;\n\n#define OBJID_BOX 0\n#define OBJID_FLOOR 1\n#define OBJID_WALL 2\n#define OBJID_FRACTAL 3\n#define OBJID_FRACTAL2 4\n\n// SD object info\nstruct SdInfo\n{\n    int objID;\n    vec4 data;\n};\n\nstruct HitInfo\n{\n    // Always present\n    vec3 rayDir;     // Ray direction (normalized)\n    bool hit;        // Have we hit something?\n    vec3 pos;        // Last position on the ray\n    float dist;      // Total distance traveled\n    SdInfo sdInfo;   // Last SD object info\n\n    // Only present if hit == true\n    vec3 normal;\n};\n\nconst float rayOffset = .02;\nconst float hitThreshold = .0006;\nconst float maxTotalDist = 100.;\nconst float eps = .0005;\n\nconst vec3 sunDir = normalize(vec3(0, 1, -.8));\n\nvec2 pixelToDeviceCoords(vec2 coords)\n{\n    vec2 uv = coords / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv = (uv * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    return uv;\n}\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nfloat sceneSD(vec3 p, out SdInfo info)\n{\n    // Store individual distances\n    const int numObjs = 5;\n    float dists[5];\n\n    // Mouse UV\n    vec2 mouseUV = getMouseUV();\n\n    // Box\n    vec3 boxPos = vec3(-2.55, 6.0, -.2);\n    vec3 boxBounds = vec3(0.8, 2.5, 0.8);\n    dists[0] = boxSD(p, boxPos, boxBounds);\n\n    // Floor\n    vec3 planeNormal = normalize(vec3(0.0, 0.0, 1.0));\n    float planeHeight = -.601;// - voronoi3d(vec3(p.xy * 0.3, 1.0)).x;\n    dists[1] = dot(p, planeNormal) - planeHeight;\n\n    // Wall\n    vec3 planeNormal2 = normalize(vec3(1.0, 0.0, 0.0));\n    float planeHeight2 = 0.0;\n    dists[2] = dot(p - vec3(-3.0, 0.0, 0.0), planeNormal2) - planeHeight2;\n\n    // Fractal\n    vec4 mandelbulbData = vec4(1.0);\n    dists[3] = mandelbulb((p - vec3(1.9, -2.8, 0.5)) / 1.0, mandelbulbData); \n    \n    // Another fractal\n    dists[4] = mengerSpongeDF(5, 1.1 * p - vec3(1.0, 1.0, 0.6));\n\n    // Find minimum distance\n\n    float minDist = dists[0];\n    info.objID = 0;\n\n    if (numObjs < 2)\n        return minDist;\n\n    for (int i = 1; i < numObjs; i++)\n    {\n        if (dists[i] < minDist)\n        {\n            minDist = dists[i];\n            info.objID = i;\n\n            if (i == OBJID_FRACTAL)\n            {\n                info.data = mandelbulbData;\n            }\n        }\n    }\n\n    return minDist;\n}\n\nvoid rayMarch(vec3 orig, vec3 dir, out HitInfo hitInfo)\n{\n    dir = normalize(dir);\n    orig += rayOffset * dir;\n\n    float totalDist = 0.0;\n    SdInfo sdInfo;\n\n    float sd = sceneSD(orig, sdInfo);\n\n    while (sd > hitThreshold && totalDist < maxTotalDist)\n    {\n        orig += sd * dir;\n        totalDist += sd;\n\n        sd = sceneSD(orig, sdInfo);\n    }\n\n    hitInfo.hit = false;\n    hitInfo.rayDir = dir;\n    hitInfo.pos = orig;\n    hitInfo.dist = totalDist;\n    hitInfo.sdInfo = sdInfo;\n\n    if (sd > hitThreshold)\n        return;\n\n    hitInfo.hit = true;\n    hitInfo.normal = normalize(vec3(sceneSD(orig + vec3(eps, 0.0, 0.0), sdInfo) - sceneSD(orig - vec3(eps, 0.0, 0.0), sdInfo), sceneSD(orig + vec3(0.0, eps, 0.0), sdInfo) - sceneSD(orig - vec3(0.0, eps, 0.0), sdInfo), sceneSD(orig + vec3(0.0, 0.0, eps), sdInfo) - sceneSD(orig - vec3(0.0, 0.0, eps), sdInfo)));\n}\n\n// https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lightPos, float lightRadius)\n{\n    SdInfo sdInfo;\n\n    vec3 toLight = normalize(lightPos - pos);\n    float distToLight = length(lightPos - pos);\n    float d, t = lightRadius * 0.1;\n    float obstruction = 0.;\n    for (int j = 0; j < 32; j++)\n    {\n        d = sceneSD(pos + t * toLight, sdInfo);\n        obstruction = max(0.5 - d * distToLight / (2. * lightRadius * t), obstruction);\n        if (obstruction >= 1.)\n            break;\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lightRadius * t / distToLight);\n        if (t >= distToLight)\n            break;\n    }\n\n    return clamp(obstruction, 0., 1.);\n}\n\nvoid shadeRay(HitInfo hit, out vec3 incomingLight, out vec3 rayColor)\n{\n    // Sky\n    if (!hit.hit)\n    {\n        // Deep orange\n        const vec3 skyColor1 = vec3(0.60, 0.13, 0.07);\n        const float skyLine1 = -0.01;\n\n        // Orange\n        const vec3 skyColor2 = vec3(1.00, 0.40, 0.16);\n        const float skyLine2 = 0.03;\n\n        // Gray\n        const vec3 skyColor3 = vec3(0.64, 0.59, 0.55);\n        const float skyLine3 = 0.075;\n\n        // Cyan\n        const vec3 skyColor4 = vec3(0.04, 0.25, 0.63);\n        const float skyLine4 = 0.14;\n\n        // Blue\n        const vec3 skyColor5 = vec3(0.006, 0.027, 0.263);\n        const float skyLine5 = 0.25;\n\n        // Dark Blue\n        const vec3 skyColor6 = vec3(0.0002, 0.002, 0.055);\n        const float skyLine6 = 0.53;\n\n        float z = hit.rayDir.z;\n        z += map_range_clamp(voronoi3d(vec3(vec2(hit.rayDir.xy * 2.2), 0.0)).x, 0.0, 1.0, -0.02, 0.0);\n\n        // Color gradient\n\n        float fac = map_range_clamp(z, skyLine1, skyLine2, 0.0, 1.0);\n        vec3 col = mixColPerceptual(skyColor1, skyColor2, fac);\n\n        fac = map_range_clamp(z, skyLine2, skyLine3, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor3, fac);\n\n        fac = map_range_clamp(z, skyLine3, skyLine4, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor4, fac);\n\n        fac = map_range_clamp(z, skyLine4, skyLine5, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor5, fac);\n\n        fac = map_range_clamp(z, skyLine5, skyLine6, 0.0, 1.0);\n        col = mixColPerceptual(col, skyColor6, fac);\n\n        // Stars\n        fac = voronoi3d(hit.rayDir.xyz * 33.0).x;\n        if (fac < 0.035)\n        {\n            float intensity = random() * 4.0 + 0.5;\n            intensity *= max(0.0, (hit.rayDir.z - 0.1) * 1.9);\n            col += vec3(intensity);\n        }\n\n\n\n        incomingLight += rayColor * col;\n\n        return;\n    }\n\n    // Diffuse\n    if (hit.sdInfo.objID == OBJID_FLOOR)\n    {\n        rayColor *= vec3(0.08, 0.3, 0.005);\n    }\n    if (hit.sdInfo.objID == OBJID_BOX)\n    {\n        // Emission\n        //incomingLight += rayColor * vec3(1000.0, 50.0, 5.0);\n\n        rayColor *= vec3(0.5, 0.03, 0.01);\n    }\n    if (hit.sdInfo.objID == OBJID_WALL)\n    {\n        rayColor *= vec3(0.55, 0.55, 0.5);\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL)\n    {\n        // Fractal color\n        vec3 c = pow(hit.sdInfo.data.ywz, vec3(0.5));\n\n        // Saturation\n        c = mix(vec3(dot(c, lumWeights)), c, 1.3);\n\n        // Clamp\n        c = clamp(c, 0.0, 1.0);\n\n        // Edge glow\n        // If ray dir and hit normal are 90 deg apart\n        // (dot is closer to 0) then we add light.\n        incomingLight += rayColor * pow(1.0 - abs(dot(hit.normal, hit.rayDir)), 1.5) * 0.05 * c;\n\n        // Diffuse color\n        rayColor *= c;\n    }\n    if (hit.sdInfo.objID == OBJID_FRACTAL2)\n    {\n        rayColor *= vec3(0.85, 0.05, 0.005);\n    }\n\n    // Conservation of energy? (IDK)\n    //rayColor /= PI;\n}\n\n// inspired by https://iquilezles.org/articles/fog/\nvec3 pretty_fog(\n    vec3 col,\n    float hit_dist,\n    vec3 ray_dir, // must be normalized\n    vec3 sun_dir, // must be normalized\n    float fog_start_dist, // normally 0\n    vec3 absorption_col, // RGB values below 1, or white to disable\n    float scatter_density, // usually near 0 like .04\n    vec3 scatter_col_sky, // normally a cold color\n    vec3 scatter_col_sun, // normally a warm color\n    float sun_sharpness // default=8\n)\n{\n    // subtract starting distance, return if depth is too low\n    hit_dist -= fog_start_dist;\n    if (hit_dist < .00001)\n    {\n        return col;\n    }\n    \n    // absorption\n    col *= pow(absorption_col, vec3(hit_dist));\n\n    // scatter color depends on view dir and sun dir\n    float sun_fac = pow(\n        max(dot(ray_dir, sun_dir), 0.),\n        sun_sharpness\n    );\n    vec3 scatter_col = mix(\n        scatter_col_sky,\n        scatter_col_sun,\n        sun_fac\n    );\n    \n    // scattering\n    col = mix(\n        col,\n        scatter_col,\n        1. - exp(-hit_dist * scatter_density)\n    );\n    \n    return col;\n}\n\nvoid shadeRayFog(HitInfo firstHit, inout vec3 col)\n{\n    if (!firstHit.hit)\n        return;\n\n    // Fog if we've hit an object\n    col = pretty_fog(\n        col,\n        firstHit.dist,\n        firstHit.rayDir,\n        sunDir,\n        1.,\n        vec3(.99, 1, .995),\n        .04,\n        vec3(.02, .03, .12),\n        vec3(.2, .15, .14),\n        8.\n    );\n}\n\nvec3 tracePath(vec3 rayOrig, vec3 rayDir, out HitInfo firstHit)\n{\n    HitInfo hit;\n    vec3 incomingLight = vec3(0.0);\n    vec3 rayColor = vec3(1.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        // Ray march\n        rayMarch(rayOrig, rayDir, hit);\n\n        if (i == 0)\n            firstHit = hit;\n\n        // Update the colors\n        shadeRay(hit, incomingLight, rayColor);\n\n        // Stop if we hit the sky\n        if (!hit.hit)\n            break;\n\n        // Should we stop bouncing?\n        if (random() > (1.0 / (2.0 * PI)))\n            break;\n\n        // Update the ray\n        rayOrig = hit.pos;\n        rayDir = hit.normal + randomUnitVector();\n        if (dot(rayDir, hit.normal) <= 0.0)\n        {\n            rayDir = -rayDir;\n        }\n\n        //vec3 reflectNormal = reflect(hit.rayDir, hit.normal);\n    }\n\n    // Cast ray towards point light\n    if (hit.hit)\n    {\n        vec3 pointLightPos = vec3(-2.6, 2.5, 3.6);\n        float pointLightStrength = 150.0;\n        vec3 pointLightCol = vec3(1.0, 0.9, 0.6);\n        float pointLightRadius = 0.3;\n\n        vec3 toLight = pointLightPos + (pointLightRadius * randomUnitVector()) - hit.pos;\n\n        float distToLight = length(toLight);\n\n        HitInfo hit2;\n        rayMarch(hit.pos, toLight, hit2);\n\n        if ((!hit2.hit) || (hit2.dist > distToLight))\n        {\n            incomingLight += rayColor * pointLightCol * pointLightStrength * max(dot(hit.normal, normalize(toLight)), 0.0) / (distToLight * distToLight);\n        }\n    }\n\n    return incomingLight;\n}\n\nvec3 render(vec2 uv)\n{\n    // Read data\n    vec3 camOrient = fetchVec3(iChannel1, ivec2(1, 0));\n    vec3 playerPos = fetchVec3(iChannel1, ivec2(2, 0));\n\n    // Setup camera\n\n    vec3 camPos = playerPos;\n    float camFOV = 80.0;\n    float camZoom = 90.0 / camFOV;\n\n    vec3 camForward = orientationToDirection(camOrient);\n    vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n    vec3 camUp = cross(camRight, camForward);\n\n    // Ray\n    vec3 rayOrig = camPos;\n    vec3 rayDir = normalize(camForward + camRight * (uv.x / camZoom) + camUp * (uv.y / camZoom));\n\n    // Lighting\n    HitInfo firstHit;\n    vec3 col = tracePath(rayOrig, rayDir, firstHit);\n\n    // Fog\n    shadeRayFog(firstHit, col);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // UV from -1 to +1\n    vec2 uv = pixelToDeviceCoords(fragCoord.xy);\n\n    // Initialize PRNG\n    eprng_init(fragCoord.xy / max(iResolution.x, iResolution.y), iTime);\n\n    // Previous frame data\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Jitter sample count (increases over time)\n    int numJitterSamples;\n    if (prev.w < (90.0 * SAMPLE_COUNT_MUL))\n        numJitterSamples = 1;\n    else\n        numJitterSamples = 5;\n\n    // Render\n    vec3 col = vec3(0.0);\n    vec2 msPixelOffset = pixelToDeviceCoords(vec2(1.0, 1.0)) - pixelToDeviceCoords(vec2(0.0, 0.0));\n    for (int i = 1; i <= numJitterSamples; i++)\n    {\n        float offsetX = random() - 0.5;\n        float offsetY = random() - 0.5;\n\n        col += render(uv + msPixelOffset * vec2(offsetX, offsetY));\n    }\n    col /= float(numJitterSamples);\n\n    // Should we reset accumulation?\n    vec4 mouseAndRes = fetchVec4(iChannel1, ivec2(0));\n    vec4 camOrient = fetchVec4(iChannel1, ivec2(1, 0));\n    vec4 playerPos = fetchVec4(iChannel1, ivec2(2, 0));\n    bool reset = (iFrame == 0) || (iTime == 0.0) || (iMouse.xy != mouseAndRes.xy) || (iResolution.xy != mouseAndRes.zw) || (playerPos.w == 1.0) || (camOrient.w == 1.0);\n\n    // Accumulate\n    if (reset)\n    {\n        fragColor = vec4(col, SAMPLE_COUNT_MUL);\n    }\n    else\n    {\n        fragColor.rgb = prev.rgb + col;\n        fragColor.w = prev.w + SAMPLE_COUNT_MUL;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B\n// iChannel0 = Buffer B\n// iChannel1 = Keyboard\n\nvec2 getMouseUV()\n{\n    if (ivec2(iMouse) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = iMouse.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvec2 getMouseUV(vec2 pos, vec2 res)\n{\n    if (ivec2(pos) == ivec2(0))\n        return vec2(0.0);\n\n    vec2 uv = pos.xy / res.xy;\n    uv = uv * 2.0 - 1.0;\n    return uv;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Mouse position and resolution\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        fragColor = vec4(iMouse.xy, iResolution.xy);\n    }\n\n    bool reset = (iFrame < 4) || (iTime == 0.0) || keyGotPressed(KEY_R, iChannel1);\n\n    // Mouse drag info\n    if (ivec2(fragCoord) == ivec2(3, 0))\n    {\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n\n        // Update if needed\n        if (iMouse.z > 0.0)\n        {\n            mouseDrag = vec3(getMouseUV(), 1.0);\n        }\n        else\n        {\n            mouseDrag.z = 0.0;\n        }\n\n        // Write\n        fragColor = vec4(mouseDrag, 0);\n    }\n\n    // Camera orientation\n    if (ivec2(fragCoord) == ivec2(1, 0))\n    {\n        // Read\n        vec4 camOrient = fetchVec4(iChannel0, ivec2(1, 0));\n\n        // W == 1 means accumulation should be reset\n        if (camOrient.w == 1.0)\n            camOrient.w = 0.0;\n\n        // Reset if needed\n        if ((camOrient.xyz == vec3(0.0)) || (length(camOrient.xyz) < 0.1) || reset)\n        {\n            camOrient = vec4(defCamOrient, 1.0);\n        }\n\n        // Delta mouse UV\n        vec3 mouseDrag = fetchVec3(iChannel0, ivec2(3, 0));\n        vec2 deltaMouseUV = getMouseUV() - mouseDrag.xy;\n\n        // Update if needed\n        if (iMouse.z > 0.0 && mouseDrag.z > 0.0 && length(deltaMouseUV) > 0.00001)\n        {\n            camOrient.x += deltaMouseUV.y * 84.5;\n            camOrient.z += deltaMouseUV.x * -120.0;\n            camOrient.w = 1.0;\n        }\n\n        // Write\n        fragColor = camOrient;\n    }\n\n    // Player position\n    if (ivec2(fragCoord) == ivec2(2, 0))\n    {\n        // Read\n        vec4 playerPos = fetchVec4(iChannel0, ivec2(2, 0));\n\n        // W == 1 means accumulation should be reset\n        if (playerPos.w == 1.0)\n            playerPos.w = 0.0;\n\n        // Reset if needed\n        if (playerPos.xyz == vec3(0.0) || reset)\n            playerPos = vec4(defPlayerPos, 1.0);\n\n        // Get camera directions for movement\n        vec3 camOrient = fetchVec3(iChannel0, ivec2(1, 0));\n        vec3 camForward = orientationToDirection(camOrient);\n        vec3 camRight = normalize(cross(camForward, vec3(0, 0, 1)));\n\n        // Get velocity based on the keyboard input\n        vec3 velocity = vec3(0.0);\n        velocity += camForward * keyIsDownF(KEY_W, iChannel1);\n        velocity += -camForward * keyIsDownF(KEY_S, iChannel1);\n        velocity += -camRight * keyIsDownF(KEY_A, iChannel1);\n        velocity += camRight * keyIsDownF(KEY_D, iChannel1);\n        velocity.z = 0.0;\n\n        // Up/down movement\n        velocity.z += 0.5 * keyIsDownF(KEY_Q, iChannel1);\n        velocity.z -= 0.5 * keyIsDownF(KEY_Z, iChannel1);\n\n        // Speed multiplier\n        float speed = 1.5;\n        if (keyIsDown(KEY_SHIFT, iChannel1))\n            speed = 4.0;\n        if (keyIsDown(KEY_ALT, iChannel1))\n            speed = 0.4;\n        velocity *= speed;\n\n        // Move if needed\n        if (velocity != vec3(0.0))\n        {\n            playerPos.xyz += velocity * iTimeDelta;\n            playerPos.w = 1.0;\n        }\n\n        // Write\n        fragColor = playerPos;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}