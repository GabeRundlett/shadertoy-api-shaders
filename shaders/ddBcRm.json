{
    "Shader": {
        "info": {
            "date": "1688272921",
            "description": "who needs volumetrics anyways?\nwasd + space + shift to move\nmouse to pan\ngo to common to mess with the variables",
            "flags": 48,
            "hasliked": 0,
            "id": "ddBcRm",
            "likes": 4,
            "name": "Clouds 2136",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 296
        },
        "renderpass": [
            {
                "code": "//cloud color gradients (rgb = color, a = color mid point)\nconst vec4 cloudLit[] = vec4[](\n    vec4(0.7,0.7,0.8,0.2),\n    vec4(0.8,0.3,0.4,0.25),\n    vec4(1,0.95,0.9,0.3),\n    vec4(1,0.95,0.9,0.7),\n    vec4(0.8,0.3,0.4,0.75),\n    vec4(0.7,0.7,0.8,0.8),\n    vec4(0.7,0.7,0.8,1)\n);\n\nconst vec4 cloudShadowed[] = vec4[](\n    vec4(0.4,0.4,0.5,0.2),\n    vec4(0.5,0.3,0.4,0.25),\n    vec4(0.7,0.7,0.8,0.3),\n    vec4(0.7,0.7,0.8,0.7),\n    vec4(0.5,0.3,0.4,0.75),\n    vec4(0.4,0.4,0.5,0.8),\n    vec4(0.4,0.4,0.5,1)\n);\n\n//gets a color at a position on a gradient\nvec3 grad(vec4[7] grad, float x){\n    x = fract(x);\n    for (int i = 0; i < grad.length(); i++){\n        if (grad[i].a > x){\n            vec4 gradStart = grad[i - 1];\n            vec4 gradEnd = grad[i];\n            return mix(gradStart.rgb,gradEnd.rgb,smoothstep(gradStart.a,gradEnd.a,x));\n        }\n    }\n}\n\n//samples the cloud renderer using a median filter (sort of) for the nice smoothing\nvec4 medianSampler(in vec2 uv, in vec2 ires, in int radius){\n    vec4 avg = vec4(0);\n    float elements = pow(float(radius*2 + 1),2.0);\n    for (int x = -radius; x <= radius; x++){\n        for (int y = -radius; y <= radius; y++){\n            avg += texture(iChannel1, (uv + vec2(x,y)/ires)*(min(res,iResolution.xy)/ires));\n        }\n    }\n    avg /= elements;\n    \n    vec4 data = vec4(0.0);\n    float dist = 999.0;\n    for (int x = -radius; x <= radius; x++){\n        for (int y = -radius; y <= radius; y++){\n            vec4 pxcol = texture(iChannel1, (uv + vec2(x,y)/ires)*(min(res,iResolution.xy)/ires));\n            float d = abs((pxcol.x - avg.x)*(pxcol.y - avg.y));\n            if (d < dist){\n                data = pxcol;\n                dist = d;\n            }\n        }\n    }\n    data.z = avg.z;\n    return data;\n}\n\n//renders a lens flare\nvec3 renderLensFlare(vec3 rd, vec3 light, vec3 position, vec3 rotation, vec2 uv){\n    vec3 lr = rotate3dbackwards(-light,rotation,vec3(0));\n    if (lr.z > 0.0){\n        vec2 luv = lr.xy*cameraFrustum/lr.z;\n        float ld = distance(luv,uv);\n        vec2 ln = (luv-uv)/ld;\n                \n        //ghosts\n        vec3 ghosts = vec3(0);\n        ghosts += renderhex(uv, -luv*0.25, 0.35, vec3(0.25,0.75,0));\n        ghosts += renderhex(uv, luv*0.25, 0.125, vec3(1,0.5,0.5));\n        ghosts += renderhex(uv, luv*0.1, 0.4, vec3(1,1,1));\n        ghosts += renderhex(uv, luv*1.8, 0.5, vec3(0,0.5,0.75));\n        ghosts += renderhex(uv, luv*1.25, 0.2, vec3(1,1,0.5));\n        ghosts += renderhex(uv, -luv*1.25, 1.25, vec3(0.5,0.5,0.25));\n        ghosts += fpow(1.0 - abs(distance(luv*0.8,uv) - 0.35),0.985)*vec3(0.15,0.1,0);\n        \n        float flare = fpow(textureLod(iChannel2,ln*0.25,0.0).r,0.3)*0.01/ld;\n        float bloom = fpow(max(1.01 - ld,0.0),0.9);\n        \n        return (ghosts/(1.0 + distance(uv,luv)) + vec3(1.0,0.8,0.1)*min(bloom + flare,1.0));\n    }\n    return vec3(0);\n}\n\nvec3 getSkyColor(vec3 dir){\n    vec3 skycol = vec3(0);\n    vec3 water = vec3(0.3,0.4,0.8);\n    vec3 sky = vec3(0,0.6,1);\n    vec3 haze = vec3(0.9,0.9,0.9);\n    if (dir.y < 0.0) {\n        skycol = mix(haze, water, clamp(-dir.y,0.0,1.0));\n    } else {\n        skycol = mix(haze, sky, clamp(dir.y,0.0,1.0));\n    }\n    return skycol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    float t = fract(texelFetch(iChannel0, ivec2(6,0),0).w);\n    vec3 lightDirection = texelFetch(iChannel0, ivec2(6,0),0).xyz*(t > 0.25 && t < 0.75 ? 1.0 : -1.0);\n    vec3 col = vec3(0);\n        \n    //sample cloud render\n    vec4 renderdata = medianSampler(fragCoord/iResolution.xy, iResolution.xy, medianRadius);\n    float shadow = max(renderdata.x,0.0); //used to determine cloud base color\n    float depth = renderdata.y; //used to blend sky and cloud at distance\n    float density = renderdata.w;\n    float hit = renderdata.z;\n    vec3 point = depth*ray.direction + position;\n    //from https://advances.realtimerendering.com/s2015/The%20Real-time%20Volumetric%20Cloudscapes%20of%20Horizon%20-%20Zero%20Dawn%20-%20ARTR.pdf\n    float densshade = (1.0 - pow(2.0,-2.0*density))*0.3 - 0.2;\n\n    //cloud colors\n    float lining = fpow(max(dot(ray.direction,-lightDirection),0.0),0.8);\n    col = mix(grad(cloudLit,t), grad(cloudShadowed,t), clamp(shadow - lining - densshade,-0.5,1.0));\n    //fade out at distance\n    col = mix(col,getSkyColor(ray.direction),clamp(depth/far,0.0,1.0));\n\n    //sun effects\n    vec3 flare = renderLensFlare(ray.direction, lightDirection, position, rotation, cam.uv);\n    col += max(flare/(1.0 + shadow*10.0),0.0);\n    \n    fragColor = col.rgbb;\n    //fragColor = vec4(hit);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//resolution to render clouds at (must be less than or equal to screen res)\n#define res vec2(800,450)\n//sets smoothing (higher res screen = use more smoothing)\n#define medianRadius 2 \n\n#define PI 3.14159265\n#define maxsteps 512\n#define maxlightsteps 16\n#define far 500.0\n#define cameraFrustum 0.7\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 position;\n    Ray ray;\n    vec2 uv;\n    mat3 transmat;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n    vec3 point;\n    float shadow;\n    float density;\n};\n\n//fakes x^n for specular effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3dbackwards(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= inverse(rotationMatrix(angle)); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//https://iquilezles.org/articles/noacos/\nmat3 rotationAlign(vec3 d, vec3 z){\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                 v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                 v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 cameraPos, vec3 camRot, float frustumLength){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, frustumLength);\n    vec3 uvd = normalize(uv);\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 ro = uv*rotmat + cameraPos;\n    vec3 rd = uvd*rotmat;\n    mat3 rottomat = rotationAlign(uvd,vec3(0,0,1));\n    mat3 TransitionMatrix = mat3(\n        vec3(1,0,0)*rottomat*rotmat, \n        vec3(0,1,0)*rottomat*rotmat, \n        vec3(0,0,1)*rottomat*rotmat\n    );\n    return Camera(cameraPos, Ray(ro, rd), uv.xy, TransitionMatrix);\n}\n\nfloat smin( float a, float b, float k){\n     float h = max(k-abs(a-b), 0.0)/k;\n     return min(a, b) - h*h*k*0.25;\n}\n\nfloat sdHex(vec2 p){\n    p = abs(p);\n\tvec2 q = vec2(p.x*2.0*0.5773503, p.y + p.x*0.5773503);\n\treturn dot(step(q.xy,q.yx), 1.0-q.yx);\n}\n\nvec3 renderhex(vec2 uv, vec2 p, float s, vec3 col){\n    uv -= p;\n    if (abs(uv.x) < 0.2*s && abs(uv.y) < 0.2*s){\n        return mix(vec3(0),mix(vec3(0),col,0.1 + fpow(length(uv/s),0.1)*10.0),smoothstep(0.0,0.3,sdHex(uv*5.0/s)));\n    }\n    return vec3(0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //velocity\n    if (floor(fragCoord) == vec2(3,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        vec2 forward = rotate3d(vec3(1,0,0),vec3(0,texelFetch(iChannel0, ivec2(1,0),0).x*sensitivity,0), vec3(0)).xz;\n        vec2 right = vec2(-forward.y,forward.x);\n        vec3 relative = vec3(keyPressed(_d)-keyPressed(_a), 0, keyPressed(_w)-keyPressed(_s));\n        float up = keyPressed(_space) - keyPressed(_shift);\n        vec3 move = vec3(relative.x*forward.x + relative.z*right.x, up, relative.x*forward.y + relative.z*right.y);\n        velocity = move != vec3(0) ? velocity*moveDamping + normalize(move)*moveSpeed : velocity*moveDamping;\n        \n        if (position.y < -1000.0){\n            velocity = vec3(0);\n        }\n        col.xyz = velocity;\n    }\n    \n    //position\n    if (floor(fragCoord) == vec2(4,0)){\n        vec3 velocity = texelFetch(iChannel0, ivec2(3,0), 0).xyz;\n        vec3 position = texelFetch(iChannel0, ivec2(4,0), 0).xyz;\n        position += velocity*iTimeDelta*60.0;\n        \n        if (position.y < -500.0){\n            position = vec3(0,24,0);\n        }\n        \n        if (iFrame == 0){\n            position = vec3(0,-40,0);\n        }\n        col.xyz = position;\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\nfloat hash13(vec3 p3){\n  p3 = floor(p3);\n  p3 = fract(p3*0.1031);\n  p3 += dot(p3, p3.zyx + 31.32);\n  return fract((p3.x + p3.y)*p3.z);\n}\n\n//3d noise from texture\nfloat noise(vec3 p){\n  p -= 0.5;\n  vec3 i = p - floor(p); //interpolant\n  vec2 o = vec2(0.0, 1.0);\n\n  float r0 = hash13(p + o.xxx);\n  float r1 = hash13(p + o.yxx);\n  float r2 = hash13(p + o.xyx);\n  float r3 = hash13(p + o.yyx);\n  float r4 = hash13(p + o.xxy);\n  float r5 = hash13(p + o.yxy);\n  float r6 = hash13(p + o.xyy);\n  float r7 = hash13(p + o.yyy);\n\n  vec3 k = smoothstep(0.0,1.0,i);\n  float k1 = mix(r0,r1,k.x);\n  float k2 = mix(r2,r3,k.x);\n  float k3 = mix(r4,r5,k.x);\n  float k4 = mix(r6,r7,k.x);\n\n  float c1 = mix(k1,k2,k.y);\n  float c2 = mix(k3,k4,k.y);\n\n  return mix(c1,c2,k.z);\n}\n*/\n\n//3d noise from texture\nfloat noise(vec3 p){\n  p -= 0.5;\n  vec3 i = p - floor(p); //interpolant\n  vec2 o = vec2(0.0, 1.0);\n\n  float r0 = texelFetch(iChannel1, ivec3(mod(p + o.xxx,32.0)),0).r;\n  float r1 = texelFetch(iChannel1, ivec3(mod(p + o.yxx,32.0)),0).r;\n  float r2 = texelFetch(iChannel1, ivec3(mod(p + o.xyx,32.0)),0).r;\n  float r3 = texelFetch(iChannel1, ivec3(mod(p + o.yyx,32.0)),0).r;\n  float r4 = texelFetch(iChannel1, ivec3(mod(p + o.xxy,32.0)),0).r;\n  float r5 = texelFetch(iChannel1, ivec3(mod(p + o.yxy,32.0)),0).r;\n  float r6 = texelFetch(iChannel1, ivec3(mod(p + o.xyy,32.0)),0).r;\n  float r7 = texelFetch(iChannel1, ivec3(mod(p + o.yyy,32.0)),0).r;\n\n  vec3 k = smoothstep(0.0,1.0,i);\n  float k1 = mix(r0,r1,k.x);\n  float k2 = mix(r2,r3,k.x);\n  float k3 = mix(r4,r5,k.x);\n  float k4 = mix(r6,r7,k.x);\n\n  float c1 = mix(k1,k2,k.y);\n  float c2 = mix(k3,k4,k.y);\n\n  return mix(c1,c2,k.z);\n}\n\n/*vec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}*/\n\n/*vec3 hash33(vec3 p3){\n    return texelFetch(iChannel3,ivec3(mod(p3,32.0)),0).xyz;\n\n}\n\nfloat noise(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x <= 1; x++){\n        for (int y = -1; y <= 1; y++){\n            for (int z = -1; z <= 1; z++){\n                vec3 d = floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)) - uv;\n                n = min(n,dot(d,d));\n            }\n        }\n    }\n    return sqrt(n);\n}*/\n\n/*//thanks fad (same function as above, but using hardware interpolation (less accurate))\nfloat noise(vec3 p){\n    vec3 s = vec3(textureSize(iChannel1, 0));\n    p /= s;\n    p = p*s - 0.5;\n    return texture(iChannel1, (floor(p) + smoothstep(0.0, 1.0, fract(p)) + 0.5)/s).r;\n}*/\n\n//sigmoid wave similar to cos\nfloat fcos(float x){\n  x = abs(2.0*fract(x) - 1.0)/(2.0*PI);\n  return 2.0*x*x*(3.0 - 2.0*x) - 1.0;\n}\n\n//cloud sdf\nfloat sceneSdf(vec3 p){\n    p.x += iTime;\n    float v0 = noise(p/64.0 + vec3(fcos(iTime*0.02 - PI/2.0),0,fcos(iTime*0.02)));\n    if (v0 > 0.7) return 5.0;\n    float v1 = noise(p/16.0 + v0);\n    float v2 = noise(p/4.0 + v1);\n    float v3 = noise(p);\n    float highcloud = p.y*0.6 - 40.0;\n    float yshape = min(max(-0.2*p.y, 0.07*p.y), highcloud*highcloud + 0.2);\n    float n = v0*4.0 + v1*2.0 + v2*v1 + v3*v2*0.25 - 2.5 + yshape;\n    return n/2.0;\n}\n\n//cloud raymarcher\nHit marchRay(Ray ray, vec3 lightDir){\n    vec3 pos = ray.origin;\n    vec3 dir = ray.direction;\n    float t = 0.0;\n    bool hit = false;\n    float multiplier = 1.5;\n    \n    //depth cast\n    for(int i = 0; i < maxsteps; i++){ \n        if (t >= far || (pos.y > 70.0 && dir.y > 0.0) || (pos.y < -15.0 && dir.y < 0.0)) break;\n        if (i == maxsteps-1) pos = dir*10.0;\n        float sdf = sceneSdf(pos);\n        if (sdf <= 0.01){\n            hit = true;\n            break;\n        }\n        t += abs(sdf)*(multiplier + t*0.001);\n        pos += dir*abs(sdf)*(multiplier + t*0.001);\n    }\n    \n    if (hit){\n        vec3 lightpos = pos;\n        float shadow = 0.0;\n\n        //shadow cast\n        for(int i = 0; i < maxlightsteps; i++){\n            float sdf = sceneSdf(lightpos);\n            if (lightpos.y > 70.0 || lightpos.y < -15.0) break;\n            if (sdf < 0.0){\n                shadow += -sdf;\n            }\n            lightpos += -lightDir*0.5;\n        }\n        \n        vec3 pos2 = pos;\n        float density = 0.0;\n\n        //density cast\n        for(int i = 0; i < maxlightsteps; i++){\n            float sdf = sceneSdf(pos2);\n            if (pos2.y > 70.0 || pos2.y < -15.0) break;\n            if (sdf < 0.0){\n                density += -sdf;\n            }\n            pos2 += dir*0.5;\n        }\n        \n        //hit\n        return Hit(hit, t, pos, sqrt(shadow), density);\n    }\n    //no hit\n    return Hit(hit, far, pos, 0.5, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //limit resolution\n    if (fragCoord.x > min(res.x,iResolution.x) || fragCoord.y > min(res.y,iResolution.y)) return;\n    //cam setup\n    vec3 position = texelFetch(iChannel0, ivec2(4,0),0).xyz;\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(-1,1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, min(res,iResolution.xy), position, rotation, cameraFrustum);\n    Ray ray = cam.ray;\n    float t = fract(texelFetch(iChannel0, ivec2(6,0),0).w);\n    vec3 lightDirection = texelFetch(iChannel0, ivec2(6,0),0).xyz*(t > 0.25 && t < 0.75 ? 1.0 : -1.0);\n\n    //raymarch\n    Hit hit = marchRay(ray, lightDirection);\n\n    fragColor = vec4(hit.shadow, hit.dist, hit.hit, hit.density);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}