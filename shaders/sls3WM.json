{
    "Shader": {
        "info": {
            "date": "1622325847",
            "description": "Trying to quickly compose a song on GPU with an interesting structure.\nThe song structure was inspired by [this video](https://youtu.be/_q3MFMQ8ao4).\n\nI'm pretty happy with this, but transitions are HARD.",
            "flags": 8,
            "hasliked": 0,
            "id": "sls3WM",
            "likes": 173,
            "name": "Techno Song (sound)",
            "published": 3,
            "tags": [
                "2d",
                "sound",
                "song",
                "techno",
                "vinyl"
            ],
            "usePreview": 1,
            "username": "athibaul",
            "viewed": 7718
        },
        "renderpass": [
            {
                "code": "// ********************************\n// Techno Song - by Alexis THIBAULT\n// 29/05/2021\n// ********************************\n\n// See the \"Common\" tab for sound design and song structure.\n\n\n#define dot2(x) dot(x,x)\n#define hypot(x, y) sqrt((x)*(x) + (y)*(y))\n\nfloat onRing(vec2 p, float r1, float r2, float eps)\n{\n    float d1 = length(p);\n    return smoothstep(r1-eps,r1+eps,d1) * smoothstep(r2+eps,r2-eps,d1);\n}\n\nfloat borromeanRings(vec2 p, float eps)\n{\n    p = p.yx;\n    // rotate p back to the two slices around the positive x axis\n    float th = TAU/3.*round(atan(p.y,p.x)/TAU*3.);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float rings = 0.;\n    float d = 0.65;\n    if(p.y > 0.)\n    {\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(1,0), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n    }\n    else\n    {\n        rings += onRing(p-d*vec2(1,0), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,-0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,-0.866), 0.9, 1.1, eps);\n        rings *= 1. - onRing(p-d*vec2(-0.5,0.866), 0.7, 1.3, eps);\n        rings += onRing(p-d*vec2(-0.5,0.866), 0.9, 1.1, eps);\n    }\n    \n    return rings;\n}\n\nvec4 turningDisk(vec2 p, vec3 baseCol, float eps)\n{\n    float th = -iTime * TAU * 33./60.;\n    \n    float th0 = atan(p.y, p.x);\n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    float d1 = length(p);\n    float th1 = atan(p.y, p.x);\n    float r1 = 0.6, r2 = 0.65;\n    float relAngle = mod(th1,TAU)-TAU/2.;\n    float onEdge = onRing(p, 0.6, 0.65, eps);\n    // Thin stripe on the outer edge\n    float w = 0.02;\n    onEdge *= smoothstep(w-eps,w+eps, abs(p.y)+step(0.,p.x));\n    \n    // Inner circle\n    onEdge += onRing(p, 0.02, 0.18, eps);\n    \n    // Black logo on the inner circle\n    onEdge -= borromeanRings((p - vec2(0.09,0.0))*25., eps*25.);\n    \n    \n    // Flashing color\n    vec3 edgeCol = baseCol;\n    edgeCol = pow(edgeCol, 1.5*vec3(2. - sin(3.*p.y + p.x +iTime)));\n    \n    \n    vec4 col = vec4(edgeCol, onEdge);\n    \n    // Vinyl part\n    \n    float onDisk = onRing(p, 0.18, 0.58, eps);\n    float albedo = clamp(6.+6.*sin(d1*80.), 0., 1.) * (0.8+0.1*noise(2.*th1+0.5*d1/eps)*sin(th1)+0.1*noise(0.5*d1/eps));\n    float lighting = pow(abs(sin(th0+1.0)), 5.);\n    \n    col += albedo*lighting*onDisk * 0.4;\n    \n    return col;\n    \n}\n\nfloat onBox(vec2 p, vec2 r, float rounded, float eps)\n{\n    vec2 q = abs(p) - r + rounded;\n    float d = length(max(q,0.)) - rounded;\n    return smoothstep(1.5*eps,0.,d);\n}\n\nvec4 squarePad(vec2 p, vec2 r, vec3 baseCol, float eps)\n{\n    float onSquare = onBox(p, r, 0.02, eps);\n    vec3 col = pow(baseCol, vec3(2.- sin(iTime)) + 2.*dot2(p/r));\n    return vec4(col, onSquare);\n}\n\nvec4 waveform(vec2 p, vec3 baseCol, float eps)\n{\n    float t = p.x + iTime;\n    float envSq = exp(-10.*mod(t,0.5));\n    envSq += 0.2*exp(-20.*mod(t,0.25)) * (1.+sin(t*4.));\n    envSq += window(0.1,0.2,mod(t,0.25)) * (1.-sin(3.*t)) * 0.02;\n    float envenv = 0.9 + 0.1*smoothstep(0.,0.5,mod(t,0.5)) * 0.8*window(0.,4.,mod(t,8.));\n    envenv *= step(0.,t);\n    envenv *= smoothstep(0.,2.,t);\n    envSq *= envenv;\n    float env = sqrt(envSq) * 0.7;\n    vec3 col = pow(baseCol, 3.*vec3(abs(p.y) + 3.*(1.-envenv)));\n    return vec4(col, smoothstep(env+eps,env-eps,abs(p.y)));\n}\n\nvec4 turntableArm(vec2 p, float eps)\n{\n    p -= vec2(0.65,0.55);\n    float th0 = atan(p.y, p.x);\n    float thMin = -0.2, thMax = -0.6;\n    float th = mix(thMin, thMax, clamp(iTime/146., 0., 1.));\n    \n    p *= mat2(cos(th), sin(th), -sin(th), cos(th));\n    \n    vec4 col = vec4(0);\n    \n    float len = 0.42;\n    float wid = 0.02;\n    vec4 shadow = vec4(0,0,0, onBox(p-vec2(0,-len), vec2(wid,len), 0.1, 0.1) * 0.9);\n    col = mix(col, shadow, shadow.a);\n    float rect = onBox(p-vec2(0.,-len), vec2(wid,len), eps, eps);\n    vec3 armcol = vec3(clamp(0.1 - sin(2.*p.x / sqrt(max(wid*wid - p.x*p.x, 0.0002)) - p.y), 0.07, 1.));\n    col = mix(col, vec4(armcol, 1), rect);\n    \n    \n    float d = length(p);\n    vec3 chromeBrush = vec3(0.8+0.1*noise(5. + 0.5*d/eps));\n    float lighting = mix(0.07, 1., pow(abs(sin(th0+1.0)), 8.));\n    col = mix(col, vec4(chromeBrush*lighting, 1), onRing(p, 0.,0.1, eps));\n    \n    p -= vec2(0,-2.*len);\n    float head1 = onBox(p, vec2(0.03,0.05), eps, eps);\n    col = mix(col, vec4(0.7 - 10.*p.x,0,0,1), head1);\n    float head2 = onBox(p-vec2(0,0.02), vec2(0.04,0.05), eps, eps);\n    float head2sh = onBox(p-vec2(0,0.02), vec2(0.04,0.05), 0.02, 0.02);\n    col = mix(col, vec4(0,0,0,1), head2sh*0.7);\n    vec3 headCol = vec3(0.4);\n    float rings = borromeanRings(50.*(p-vec2(0,0.02)), 50.*eps);\n    headCol = mix(headCol, vec3(0.1,0.1,0.1), rings);\n    headCol *= smoothstep(0.1,-0.1,p.x)*2.;\n    \n    col = mix(col, vec4(headCol, 1), head2);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    float eps = 1.5/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float t = mod(iTime, 0.5);\n    float kickin = (iTime > 2.) ? exp(-t*10.) : 0.;\n    vec3 baseCol = mix(vec3(0.5,0.75,1.000), vec3(1.), kickin);\n    \n    vec2 p = uv - vec2(0.7,-0.2);\n    vec4 diskCol = turningDisk(p, baseCol, eps);\n    col = mix(col, diskCol.xyz, diskCol.a);\n    vec4 armCol = turntableArm(p, eps);\n    col = mix(col, armCol.xyz, armCol.a);\n    \n    \n    p = uv - vec2(-1.0,-0.5);\n    vec2 padC = clamp(round(p/0.2),-1.,4.)*0.2;\n    baseCol = mix(pow(normalize(0.5 + 0.4*cos(iTime+padC.xyx*3.+vec3(0,2,4))), vec3(0.3)), vec3(1.), kickin);\n    vec4 padCol = squarePad(p - padC, vec2(0.092), baseCol, eps);\n    col = mix(col, padCol.xyz, padCol.a);\n    \n    baseCol = mix(vec3(0.95,0.8,0.2), vec3(1.), kickin);\n    vec4 waveformCol = waveform((uv-vec2(0,0.8)) * 5., baseCol, eps * 5.);\n    col = mix(col, waveformCol.xyz, waveformCol.a);\n    \n    //col = vec3(1)*borromeanRings(uv*2.0, 2.*1.5/iResolution.y);\n    \n    \n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// See \"Common\" tab",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n// The code below is split into several parts.\n// UTILS - Constants and hash functions and stuff\n// WAVEFORMS - Basic noise and tone generators\n// INSTRUMENTS - Stuff that makes notes\n// PHRASES AND SONG PARTS - What to play, how to play it, up to the final mix.\n\n\n///////////////////////////////\n/////////// UTILS /////////////\n///////////////////////////////\n\n#define TAU (2.*3.1415926)\n// Convert MIDI note number to cycles per second\n#define midicps(n) (440.*exp(log(2.)*(n-69.)/12.))\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 rand2(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n////////////////////////////////////\n/////////// WAVEFORMS //////////////\n////////////////////////////////////\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    //sf = sf*sf*sf*(sf*(sf*6.0-15.0)+10.0); // quintic curve\n    // see https://iquilezles.org/articles/texture\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\nvec2 noise2(float s){\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\n}\n\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    //float n1 = noise(t*df);\n    //float n2 = noise(t*df - 100000.);\n    //vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return sin(TAU*fc*fract(t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    vec2 noiz = noise2(t*df);\n    vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return modul*noiz;\n}\n\n\nfloat window(float a, float b, float t)\n{\n    return smoothstep(a, (a+b)*0.5, t) * smoothstep(b, (a+b)*0.5, t);\n}\n\nfloat formantSin(float phase, float form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\nvec2 formantSin2(vec2 phase, vec2 form)\n{\n    // Inspired by the wavetable \"formant\" option\n    // in software synthesizer Surge (super cool freeware synth!)\n    phase = fract(phase);\n    phase = min(phase*form, 1.);\n    return sin(TAU*phase);\n}\n\n\nfloat lpfSaw(float t, float f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    float omega_c = 2.*3.14159*fc/f; // relative\n    t = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    float alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    float tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    float phi = atan(tanphi);\n    float A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    float v = 1.-2.*t + A*exp(-alpha*t) * cos(omega_c*t+phi);\n    return v;\n}\n\nvec2 lpfSaw(float t, vec2 f, float fc, float Q)\n{\n    // Low-pass-filtered sawtooth wave\n    // arguments are time, frequency, cutoff frequency, and resonance quality factor\n    vec2 omega_c = 2.*3.14159*fc/f; // relative\n    vec2 t2 = f*t - floor(f*t);\n    // Compute the exact response of a second order system with those parameters\n    // (value and derivative are continuous)\n    // It is expressed as\n    // 1 - 2t + A exp(-omega_c*t/Q) * cos(omega_c*t+phi)\n    // We need to compute the amplitude A and phase phi.\n    vec2 alpha = omega_c/Q, beta=exp(-alpha), c = cos(omega_c), s = sin(omega_c);\n    vec2 tanphi = (alpha*beta*c + beta*omega_c*s - alpha) / (omega_c + alpha*beta*s - beta*omega_c*c);\n    // We could use more trigonometric identities to avoid computing the arctangent, but whatever.\n    vec2 phi = atan(tanphi);\n    vec2 A = -2./(cos(phi) - beta*cos(omega_c+phi));\n    \n    vec2 v = 1.-2.*t2 + A*exp(-alpha*t2) * cos(omega_c*t2+phi);\n    return v;\n}\n\n\n///////////////////////////////////\n//////// INSTRUMENTS //////////////\n///////////////////////////////////\n\nvec2 hat1(float t)\n{\n    // Smooth hi-hat, almost shaker-like\n    return coloredNoise2(t, 10000., 5000.) * smoothstep(0.,0.02,t) * smoothstep(0.06,0.01,t) * 0.1;\n}\n\nvec2 hat2(float t, float fc)\n{\n    // Short hi-hat with tuneable center frequency\n    return coloredNoise2(t, fc, fc-1000.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\n}\n\nvec2 snare1(float t)\n{\n    // Composite snare\n    float body = (sin(TAU*t*250.) + sin(TAU*t*320.)) * smoothstep(0.1,0.0,t) * 1.;\n    vec2 timbre = coloredNoise2(t, 1000., 7000.) * exp(-12.*t) * smoothstep(0.5,0.,t) * 8.;\n    vec2 sig = (body+timbre) * smoothstep(0.,0.001,t);\n    sig = sig/(1.+abs(sig)); // distort\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    return sig * 0.1;\n}\n\nvec2 snare2(float t)\n{\n    // Basic noise-based snare\n    float noi = coloredNoise(t, 4000., 1000.) + coloredNoise(t, 4000., 3800.) + coloredNoise(t,8000.,7500.) * 0.5;\n    float env = smoothstep(0.,0.001,t) * smoothstep(0.2,0.05,t);\n    env *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    env *= (1. - 0.5*window(0.02,0.1,t)); // fake compression\n    vec2 sig = vec2(noi) * env;\n    sig = sig/(1.+abs(sig));\n    return sig * 0.1;\n}\n\nfloat kick1(float t)\n{\n    // Composite kick\n    \n    // Kick is composed of a decaying sine tone, and a burst of noise,\n    // all of it distorted and shaped with a nice envelope.\n    \n    // frequency is assumed to be f0 + df*exp(-t/dftime);\n    float f0 = 50., df=500., dftime=0.02;\n    float phase = TAU * (f0*t - df*dftime*exp(-t/dftime));\n    float body = sin(phase) * smoothstep(0.15,0.,t) * 2.;\n    float click = coloredNoise(t, 8000., 2000.) * smoothstep(0.01,0.0,t);\n    //float boom = sin(f0*TAU*t) * smoothstep(0.,0.02,t) * smoothstep(0.15,0.,t);\n    float sig = body + click;\n    sig = sig/(1.+abs(sig));\n    //sig += boom;\n    sig *= (1. + smoothstep(0.02,0.0,t)); // increase transient\n    sig *= (1. + window(0.05,0.15,t)); // increase tail\n    return sig * 0.2;\n}\n\nvec2 bass1(float t, float f, float cutoff)\n{\n    // Composite bass\n    // (I'm very happy about this one!)\n    \n    // \"Cutoff\" is not actually the cutoff frequency of a filter,\n    // but it controls the amount of high frequencies\n    // we bring in using the \"formantSin\" waveform.\n    cutoff *= exp(-t*5.);\n    float formant = max(cutoff/f, 1.);\n    // Pure sine tone\n    float funda = sin(TAU*f*t);\n    // Phase-modulated sine gives more \"body\" to the sound\n    float body = sin(2.*TAU*f*t + (0.2*formant)*sin(TAU*f*t));\n    // Gritty attack using a truncated sinusoid waveform\n    // (dephased for stereo effect)\n    vec2 highs = formantSin2(f*t + vec2(0,0.5), vec2(formant)) * exp(-t*10.);\n    vec2 sig = body + highs + funda;\n    // Two-rate envelope with a strong transient and long decay\n    sig *= (2.*exp(-t*20.) + exp(-t*2.));\n    sig *= (1. + 0.3*smoothstep(0.05,0.0,t)); // increase transient\n    \n    // Finally, add some distortion\n    //sig = sig / (1. + abs(sig)); // Feel free to try how this one sounds.\n    sig = sin(sig); // This one gives lovely sidebands when pushed hard.\n    return sig * 0.1;\n}\n\nvec2 pad1(float t, vec4 f, float fc, float Q)\n{\n    // Filtered sawtooth-based pad, playing four-note chords\n    \n    // f: frequencies of the four notes\n    // fc, Q: cutoff frequency and quality factor of the 12dB/octave lowpass filter\n    vec2 sig = vec2(0);\n    sig += lpfSaw(t, f.x+vec2(-2,2), fc, Q);\n    sig += lpfSaw(t, f.y+vec2(1.7,-1.7), fc, Q);\n    sig += lpfSaw(t, f.z+vec2(-0.5,0.5), fc, Q);\n    sig += lpfSaw(t, f.w+vec2(1.5,-1.5), fc, Q);\n    return sig * 0.02;\n}\n\nvec2 arp1(float t, vec4 f, float fc, float dur)\n{\n    // Plucky arpeggiator, playing 16th notes.\n    \n    // dur: decay time of the notes (amplitude and filter)\n    vec2 sig = vec2(0);\n    vec4 ts = mod(t-vec4(0,0.125,0.25,0.375), 0.5);\n    sig += lpfSaw(t, f.x, fc*exp(-ts.x/dur), 10.) * smoothstep(0.0,0.01,ts.x) * exp(-ts.x/dur);\n    sig += lpfSaw(t, f.y, fc*exp(-ts.y/dur), 10.) * smoothstep(0.0,0.01,ts.y) * exp(-ts.y/dur);\n    sig += lpfSaw(t, f.z, fc*exp(-ts.z/dur), 10.) * smoothstep(0.0,0.01,ts.z) * exp(-ts.z/dur);\n    sig += lpfSaw(t, f.w, fc*exp(-ts.w/dur), 10.) * smoothstep(0.0,0.01,ts.w) * exp(-ts.w/dur);\n    return sig * 0.04;\n}\n\nvec2 marimba1(float t, float f)\n{\n    // Simple phase-modulation based marimba\n    \n    vec2 sig = vec2(0);\n    // Super basic marimba sound\n    sig += sin(TAU*f*t + exp(-50.*t)*sin(TAU*7.*f*t)) * exp(-5.*t) * step(0.,t);\n    // Fake reverb effect: long-decay, stereo-detuned fundamental\n    sig += sin(TAU*(f+vec2(-2,2))*t) * exp(-1.5*t) * 0.5;\n    return vec2(sig) * 0.05;\n}\n\nvec2 pad2(float t, vec4 f, float fres)\n{\n    // Four-note, phase-modulation-based pad.\n    \n    // fres: center frequency of the faked \"spectral aliasing\"\n    \n    vec2 sig = vec2(0);\n    // Index of modulation\n    // https://en.wikipedia.org/wiki/Frequency_modulation#Modulation_index\n    vec4 iom1 = 2.+0.5*sin(t + vec4(0,1,2,3));\n    // Play an octave lower than asked\n    f *= 0.5;\n    // Modulator has frequency 2f -> odd harmonics only\n    sig += sin(TAU*t*f.x + iom1.x * sin(2.*TAU*t*(f.x+vec2(-1,1)))) * vec2(1,0);\n    sig += sin(TAU*t*f.y + iom1.y * sin(2.*TAU*t*(f.y+vec2(-1.2,0.8)))) * vec2(0.7,0.3);\n    sig += sin(TAU*t*f.z + iom1.z * sin(2.*TAU*t*(f.z+vec2(-0.5,1.5)))) * vec2(0.3,0.7);\n    sig += sin(TAU*t*f.w + iom1.w * sin(2.*TAU*t*(f.w+vec2(-1.3,0.7)))) * vec2(0,1);\n    \n    // Fake spectral aliasing, to add some high-end\n    vec2 warped = vec2(0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.x)) * vec2(1,0);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.y)) * vec2(0.7,0.3);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.z)) * vec2(0.3,0.7);\n    warped += sin(TAU*t*fres + 5.*sin(TAU*t*f.w)) * vec2(0,1);\n    \n    // Mix to taste\n    sig = (sig + 0.01*warped) * 0.02;\n    // Reduce stereo image\n    sig = mix(sig.xy, sig.yx, 0.1);\n    return sig;\n}\n\n\n////////////////////////////////////////////\n/////// PHRASES AND SONG PARTS /////////////\n////////////////////////////////////////////\n\n\nfloat leadphrasenote(float t)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // MIDI note number (or 0. if silence)\n    float note =\n        (t<0.5) ? 69. : (t<1.) ? 71. : (t<1.5) ? 72. : (t<1.75) ? 76. :\n        (t<3.0) ? 74. : (t<3.25) ? 0. : (t<3.5) ? 72. : (t<3.75) ? 74. :\n        (t<5.5) ? 76. : (t<5.75) ? 79. : (t<7.5) ? 71. : 0.;\n    return note;\n}\n\nvec2 leadphrase1(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    \n    float note = leadphrasenote(t);\n    // Add some vibrato\n    float vibStrength = window(2.,3.,t) + window(4.,5.5,t) + window(6.,8.,t);\n    float f = midicps(note + vibStrength*0.01*sin(5.*TAU*t)/(t+0.1));\n    // Cut silence\n    float env = (note > 0.) ? 1. : 0.;\n    \n    // \"Super-saw\" lead\n    vec2 sig = lpfSaw(t, f+vec2(-2,2), fc, 1.);\n    sig += lpfSaw(t, f+vec2(3.2,-3.2), fc, 1.);\n    sig += lpfSaw(t, f, fc, 1.);\n    \n    // Distort\n    sig *= 2.;\n    sig = sig/(1.+abs(sig));\n    \n    return sig * 0.05 * env;\n}\n\nvec2 leadchorus(float t, float fc)\n{\n    // Four-bar lead synth phrase in the final chorus\n    // Add delay effect\n    vec2 sig = leadphrase1(t, fc);\n    sig = mix(sig, sig.yx, 0.3);\n    sig += leadphrase1(mod(t-0.25,8.), fc*0.7).yx * vec2(0.5,-0.5);\n    sig += leadphrase1(mod(t-1., 8.), 1000.) * 0.5;\n    return sig;\n}\n\nvec2 basschorus(float t, float fc)\n{\n    // Bass of the final chorus:\n    // Simply play the fundamental of each bar, with octave jumps\n    \n    // Every second 8th note is an octave above\n    float octave = 12.*step(0.25,mod(t,0.5));\n    // Fundamental of each of the four bars\n    float note = (t<2.) ? 69.-36.+octave : \n                 (t<4.) ? 62.-36.+octave :\n                 (t<6.) ? 60.-36.+octave :\n                 67.-36.+octave;\n    \n    float t1 = mod(t, 0.25);\n    vec2 sig = bass1(t1, midicps(note), fc);\n    \n    return sig;\n}\n\nvec2 padchorus(float t, float fc, float Q)\n{\n    // Pad part for the final chorus\n    // Simply play the (slightly rich) chords\n    // ||: Am(add9) | Dm7 | C(add9) | G(add9) :||\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    \n    vec2 pad = pad1(t, midicps(chord), fc, Q);\n    return pad;\n}\n\n\nvec2 arpchorus(float t, float fc, float dur)\n{\n    // Arpeggiator part for the final chorus\n    // Simply arpeggiate the four chords\n    vec4 chord = (t<2.) ? vec4(57,60,64,71) : (t<4.) ? vec4(57,62,65,72) : (t<6.) ? vec4(60,62,64,67) : vec4(59,62,67,69);\n    vec2 arp = arp1(t, midicps(chord+12.), fc, dur);\n    return arp;\n}\n\n\nvec2 fullChorus(float time)\n{\n    // Full mix for the final chorus\n    time = mod(time, 8.);\n    vec2 v = vec2(0);\n    \n    // Percussions (with a slight 16th-note swing)\n    v += hat1(mod(time, 0.25)) * vec2(0.8,1.0);\n    v += hat1(mod(time-0.14, 0.25)) * vec2(0.3,-0.2);\n    v += snare1(mod(time-0.5, 1.));\n    v += kick1(mod(time, 0.5));\n    \n    // Low-frequency oscillator on a macro control\n    float cutoff = 300. + 200.*sin(time);\n    \n    float t = mod(time, 0.5);\n    // Another LFO for fake sidechain compression (\"pumping\" effect)\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    \n    v += basschorus(mod(time,8.), cutoff) *mix(pumping, 1.,0.3);\n    \n    vec2 pads = padchorus(mod(time, 8.), 8000.-1000.*sin(time), 2.);\n    pads *= mix(pumping, 1., 0.1);\n    v += pads;\n    \n    // A third LFO to vary the note length of the arpeggiator\n    float dur = 0.2 * exp(0.2*sin(time*0.6));\n    vec2 arp = arpchorus(mod(time, 8.), 5000.-1000.*cos(0.7*time), dur);\n    v += arp * mix(pumping, 1.,0.2);\n    \n    v += leadchorus(mod(time,8.), 10000.) * mix(pumping,1.,0.5);\n    \n    return v;\n}\n\nvec2 padPhraseVerse(float time, float fc)\n{\n    // Pad during the verse: play three chords in four bars\n    // ||: Am(add11) | FMaj7 | Em7 | Em7 :||\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,60,62,64) : (t<4.) ? vec4(53,57,60,64) : vec4(52,55,62,64);\n    // Smoothe out the transitions from one chord to the next,\n    // as they are not masked by percussion.\n    float env = 1. - window(-0.1,0.1,t) - window(1.9,2.1,t) - window(3.9,4.1,t) - window(7.9,8.1,t);\n    // Add some movement with volume automation\n    env *= 1. + 0.2*window(0.25,0.5,mod(t,0.5));\n    return pad1(t, midicps(chord), fc*0.7, 2.) * env;\n}\n\nvec2 padVerse(float time, float fc)\n{\n    // Verse pad with delay effect\n    return padPhraseVerse(time, fc) + 0.5*padPhraseVerse(time-0.5,fc).yx + 0.2*padPhraseVerse(time-1.5,fc);\n}\n\nvec2 marimbaVerse(float t, float fc)\n{\n    // Marimba part for the verse:\n    // just a few notes, always the same.\n    vec2 v = vec2(0);\n    v += marimba1(mod(t-0.00,8.), midicps(72.));\n    v += marimba1(mod(t-0.75,8.), midicps(71.));\n    v += marimba1(mod(t-1.50,8.), midicps(69.));\n    v += marimba1(mod(t-2.25,8.), midicps(64.));\n    v += marimba1(mod(t-7.50,8.), midicps(69.));\n    v += marimba1(mod(t-7.75,8.), midicps(71.));\n    return v;\n}\n\nvec2 arpVerse(float time, float fc, float dur)\n{\n    // Verse arpeggiator: just arpeggiate the chords\n    // (different notes than the pad this time).\n    // Cutoff frequency and note duration will be varied for tension.\n    float t = mod(time, 8.);\n    vec4 chord = (t<2.) ? vec4(57,64,69,71) : (t<4.) ? vec4(57,64,65,72) : vec4(59,64,69,74);\n    return arp1(t, midicps(chord), fc, dur);\n}\n\nvec2 fullVerse(float time)\n{\n    vec2 v = vec2(0);\n    // Cutoff frequency: dark sound initially,\n    // but with a riser in the last four bars.\n    float fc = 400. - 100.*cos(time) + 10000. * pow(clamp((time-24.)/(32.-24.),0.,1.), 4.);\n    v += padVerse(time, fc) * 0.5;\n    v += marimbaVerse(time, fc);\n    if(time > 16.)\n    {\n        // Arpeggiator comes in after 8 bars, and note duration increases\n        // during the riser.\n        float dur = mix(0.05,0.5, smoothstep(24.,32.,time));\n        v += arpVerse(time, fc, dur) * smoothstep(16.,18.,time);\n    }\n    return v;\n}\n\nvec2 bassDrop1(float time)\n{\n    // Groovy four-bar phrase of the bass during the drop.\n    \n    // (In fact, it is the only part of this song with\n    // some melodic/rhythmic complexity and variation.\n    // The rest is extremely mechanical.)\n    \n    vec2 v = vec2(0);\n    \n    time = mod(time, 8.);\n    \n    float sx = floor(time / 0.125); // sixteenth note number\n    float st = mod(time, 0.125);\n    bool isShort = true; // True for 16th note, false for 8th note\n    vec2 nn = vec2(0.,0.); // note number, trigger short note\n    nn = (sx == 0. || sx == 5. || sx==8.) ? vec2(33,1) : \n         (sx == 2.) ? vec2(48,1) :\n         (sx == 3.) ? vec2(45,1) :\n         (sx == 14.) ? vec2(35,1) :\n         (sx == 15. || sx == 35.) ? vec2(36,1) :\n         (sx == 16. || sx == 21. || sx == 24. || sx == 30. || sx == 31.) ? vec2(26,1) :\n         (sx == 18.) ? vec2(41,1) :\n         (sx == 19.) ? vec2(38,1) :\n         (sx == 32. || sx == 37. || sx == 38. || sx == 40.) ? vec2(24,1) :\n         (sx == 34.) ? vec2(40,1) :\n         (sx == 46.) ? vec2(28,1) :\n         (sx == 47.) ? vec2(29,1) :\n         (sx == 48. || sx == 53. || sx == 54. || sx == 56. || sx == 57.) ? vec2(31,1) :\n         (sx == 50.) ? vec2(47,1) :\n         (sx == 51. || sx == 58.) ? vec2(43,1) :\n         (sx == 60. || sx == 61.) ? vec2(32,1) :\n         (sx == 62.) ? vec2(44,1) :\n         vec2(0,0);\n    \n    \n    if(sx == 30. || sx == 56. || sx == 60.)\n    { // First half of 8th notes\n        isShort = false;\n    }\n    if(sx == 31. || sx == 57. || sx == 61.)\n    {  // Second half of 8th notes\n        st += 0.125;\n        isShort = false;\n    }\n    \n    \n    float fc = 400. + 50.*sin(TAU*time);\n    v += bass1(st, midicps(nn.x), fc) * nn.y;\n    \n    // Decay end of note to avoid clicks\n    if(isShort) v *= smoothstep(0.125,0.12,st);\n    else v *= smoothstep(0.125,0.12,st-0.125);\n    \n    return v;\n}\n\nvec2 padDrop1(float time, float fres)\n{\n    // Pad part for the drop : uses pad2 (the phase-modulation based pad)\n    vec2 v = vec2(0);\n    \n    float t = mod(time, 8.);\n    // Very sparse choice of notes.\n    // Chord transitions happen after the start of the bar.\n    vec4 chord = (t < 2.75) ? vec4(69,72,69,72) : \n    (t < 4.75) ? vec4(69,72,69,74) : (t < 6.75) ? vec4(69,72,67,72) : vec4(69,72,69,71);\n    // Funky automation to avoid boredom\n    float env = (0.05 + window(0.,4.,t) + window(4.,8.,t)) * exp(-5.*mod(-t, 0.25));\n    v += pad2(time, midicps(chord), fres) * env;\n    \n    return v;\n}\n\nvec2 fullDrop1(float time)\n{\n    // Full mix of the bass drop.\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    // Fake sidechain compression again\n    float pumping = mix(smoothstep(0.0,0.25,t), smoothstep(0.0,0.5,t), 0.2);\n    // Hi-hat timbre rises from \"dull\" to \"harsh\"\n    float fhat = 5000. + 3000.*smoothstep(24.,32.,time);\n    \n    v += bassDrop1(time) * mix(pumping, 1., 0.8);\n    v += kick1(mod(time, 0.5) + 0.008);\n    \n    v += padDrop1(time, 8000.) * mix(pumping, 1., 0.05);\n    \n    if(time > 8.)\n    {\n        // Snare comes in after 4 bars.\n        v += snare2(mod(time-0.5, 1.));\n    }\n    if(time > 16.)\n    {\n        // Hi-hat comes in after 8 bars\n        // Short hi-hat sound with fast attack and decay. Slight swing.\n        v += hat2(mod(time, 0.25), fhat) * vec2(0.8,1.0) * 0.7;\n        v += hat2(mod(time-0.14, 0.25), fhat) * vec2(0.3,-0.2) * 0.7;\n    }\n    return v;\n}\n\nvec2 fermata1(float time)\n{\n    // 2-bar fermata after verse\n    vec2 v = vec2(0);\n    // Let the last marimba note decay\n    v += marimba1(time, midicps(69.));\n    // Let the pad go from bright to dark\n    float fc = 10000. * exp(-5.*smoothstep(0.,4.,time));\n    v += pad1(time, midicps(vec4(57,60,62,64)), fc, 2.) * smoothstep(0.,0.1,time) * smoothstep(4.,0.,time);\n    \n    // Riser before drop:\n    // Lots of low-frequency noise + a bit of high-frequency\n    vec2 noise = (coloredNoise2(time, 250., 250.) + 0.1*coloredNoise2(time, 8000., 2000.)) * 0.2 * exp(-6.*smoothstep(4.,1.,time)) * smoothstep(4.,3.99,time);\n    v += noise;\n    \n    return v;\n}\n\n\nvec2 teller1(float time)\n{\n    // 1-bar riser before chorus\n    vec2 v = vec2(0);\n    float t = mod(time, 0.5);\n    float fc = 10000.*exp(2.*(time-2.));\n    // Noise riser\n    vec2 riser = coloredNoise2(time, fc*0.3, fc*0.3);\n    v += riser * smoothstep(0.,2.,time) * 0.3 * exp((time-2.)*3.);\n    // Announce the \"middle A\" played by the lead synth on the chorus\n    vec2 teller = pad1(time, midicps(vec4(69)), fc, 2.);\n    v += teller;\n    return v;\n}\n\n\nvec2 verseTeller(float time)\n{\n    // Pre-announce the first note played by the marimba.\n    float fC5 = midicps(72.);\n    return (sin(TAU*(fC5+vec2(-2,2))*time) + 0.5*sin(TAU*(fC5+vec2(3,-3))*time)) * 0.1 * exp(-5.*(2.-time));\n    \n}\n\nvec2 fullSong(float time)\n{\n    // Combine all parts of the song into a structured whole.\n    \n    vec2 v = vec2(0);\n    \n    if(0.<time && time < 2.)\n    {\n        v += verseTeller(time);\n    }\n    \n    time -= 2.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullVerse(time);\n    }\n        \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += padVerse(time, 10000.) * smoothstep(0.5,0.,time);\n        v += fermata1(time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 32.)\n    {\n        v += fullDrop1(time);\n    }\n    \n    time -= 32.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += bass1(time, midicps(33.), 400.);\n        v += pad2(time, midicps(vec4(69,71,69,72)), 8000.) * (0.5 + 0.3*cos(2.*TAU*time)) \n             * smoothstep(0.,0.5,time) * smoothstep(4.,0.,time);\n        v += verseTeller(time-2.);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time && time < 16.)\n    {\n        v += fullVerse(time+16.);\n    }\n    \n    time -= 16.;\n    \n    if(0. < time && time < 4.)\n    {\n        v += fermata1(time);\n        v += teller1(time-2.) * smoothstep(2.,4.,time);\n    }\n    \n    time -= 4.;\n    \n    if(0. < time)\n    {\n        v += fullChorus(time) * smoothstep(48.,32.,time); // fade out on chorus\n    }\n    \n    return v;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v = vec2(0);\n    v = fullSong(time);\n    \n    //v = fullChorus(time - 20., 10000.);\n    //v = vec2(kick1(mod(time, 0.5)));\n    \n    //v = fullDrop1(time);\n    \n    //v = fermata1(time);\n    \n    // Avoid clicks at the beginning\n    return v * smoothstep(0.,0.01,time);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}