{
    "Shader": {
        "info": {
            "date": "1593613920",
            "description": "glass dice in a room full of mirrors",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2cRR",
            "likes": 3,
            "name": "mirrors dice",
            "published": 3,
            "tags": [
                "mirrorglassredinfinitedice"
            ],
            "usePreview": 0,
            "username": "ich",
            "viewed": 408
        },
        "renderpass": [
            {
                "code": "#define pi 3.141\n#define pi2 (pi*2.)\n#define surf_dist .005\n#define max_dist 100.\n#define max_it 100\n#define recursions 10.\n\nfloat n21(vec2 uv) {\n\treturn fract(9876. * sin(dot(uv, vec2(987, 654))));\n}\n\nvec2 n22(vec2 uv) {\n\tfloat n = n21(uv);\n\treturn vec2(n, n21(vec2(n)));\n}\n\nfloat n11(float v) {\n\treturn n21(vec2(v));\n}\n\nvec3 n33(vec3 p) {\n\tfloat n = n21(p.xy);\n\treturn vec3(n11(p.x), n, n21(vec2(n, p.z)));\n}\n\nmat2 rot2(float a) {\n\treturn mat2(\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t);\n}\n\nvec3 rot3(vec3 p, float a) {\n\treturn vec3(rot2(a) * p.xy, p.z);\n}\n\nvec3 rot3(vec3 p, vec3 a) {\n\treturn rot3(rot3(rot3(p, a.z).zxy, a.y).yzx, a.x);\n}\n\nmat3 look(vec3 d) {\n\tvec3 u = vec3(0, 1, 0);\n\tvec3 r = normalize(cross(u, d));\n\tu = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\nfloat plane(vec3 p, vec3 n, float r) {\n\treturn dot(p, n) - r;\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat quickcube(vec3 p, float r)\n{\n\tp = abs(p);\n\treturn max(p.x, max(p.y, p.z)) - r;\n}\n\nfloat quickcube(vec3 p, vec3 r)\n{\n\tp = abs(p);\n\treturn max(p.x - r.x, max(p.y - r.y, p.z - r.z));\n}\n\nvoid min_mat(inout float l0, inout vec4 mat0, float l1, vec4 mat1) {\n\tif (l1 < l0) {\n\t\tl0 = l1;\n\t\tmat0 = mat1;\n\t}\n}\n\nfloat scene(vec3 p) {\n\tfloat l = max_dist;\n\n\tvec3 p0 = p - vec3(2, .5, -2);\n\tvec3 p1 = rot3(p - vec3(2, .5, 2), vec3(0, pi*.75, 0));\n\tl = min(l, plane(p, vec3(0, 1, 0), -.6));\n\tl = min(l, max(quickcube(p, .5), sphere(p, .7)));\n\tl = min(l, plane(p, normalize(vec3(1, 0, 0)), -4.));\n\tl = min(l, -quickcube(p, 5.));\n\n\treturn l;\n}\n\nvec4 material(vec3 p) {\n\tfloat l = max_dist;\n\tvec4 mat = vec4(0);\n\n\tvec3 p0 = p - vec3(2, .5, -2);\n\tvec3 p1 = rot3(p - vec3(2, .5, 2), vec3(0, pi*.75, 0));\n\tmin_mat(l, mat, plane(p, vec3(0, 1, 0), -.6), vec4(p0, 1));\n\tmin_mat(l, mat, max(quickcube(p, .5), sphere(p, .7)), vec4(vec3(.85, 0, 0), 2));\n\tmin_mat(l, mat, plane(p, normalize(vec3(1, 0, 0)), -4.), vec4(vec3(0), 3));\n\tmin_mat(l, mat, -quickcube(p, 5.), vec4(vec3(0), 4.));\n\n\treturn mat;\n}\n\nfloat march(vec3 ro, vec3 rd, float s) {\n\tvec3 p = ro;\n\tfloat lo = 0.;\n\n\tfor (int i = 0; i < max_it; ++i) {\n\t\tfloat l = s * scene(p);\n\t\tlo += l;\n\t\tp = ro + rd * lo;\n\n\t\tif (l < surf_dist || lo > max_dist)\n\t\t\tbreak;\n\t}\n\n\treturn lo;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\treturn march(ro, rd, 1.);\n}\n\nvec3 normal(vec3 p) {\n\tfloat l = scene(p);\n\tvec2 e = vec2(0, surf_dist / 2.);\n\treturn normalize(\n\t\tl - vec3(\n\t\t\tscene(p - e.yxx),\n\t\t\tscene(p - e.xyx),\n\t\t\tscene(p - e.xxy)\n\t));\n}\n\nfloat ambient_occlusion(vec3 p, vec3 n, float r) {\n\tfloat l = 0.;\n\tfloat it = 3.;\n\tfor (float i = 0.; i < it; ++i) {\n\t\tl += min(1., scene(p + n * r) / r);\n\t\tr *= .5;\n\t}\n\treturn pow(max(0., l / it), .2);\n}\n\nvec3 color(vec4 mat) {\n\tswitch(int(mat.w)) {\n\tcase 1: return vec3(smoothstep(.0, .1, sin(mat.x * 20.) * sin(mat.z * 20.)), 0, 0);\n\tcase 2: return vec3(.9, 1, .95);\n\tcase 3: return vec3(1, 0, 0);\n\tcase 4: return vec3(.9, 1, .95);\n\tdefault: return vec3(0, 0, 1);\n\t}\n}\n\nfloat shadow(vec3 p, vec3 n, float l, vec3 rd) {\n\tfloat c = 1.;\n\tc *= max(0., dot(rd, -n));\n\tc *= 1. - l / max_dist;\n\tc *= ambient_occlusion(p, n, 1.);\n\treturn c;\n}\n\nvec3 mirror(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tp += n * surf_dist * 2.;\n\trd = reflect(rd, n);\n\n\tfloat l = march(p, rd);\n\tp = p + rd * l;\n\tn = normal(p);\n\n\tmat = material(p);\n\treturn shadow(p, n, l, rd) * color(mat);\n}\n\nvec3 glass(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tp += -n * surf_dist * 2.;\n\trd = refract(rd, n, mat.x);\n\n\tfloat l = march(p, rd, -1.);\n\tp = p + rd * l;\n\tn = normal(p);\n\n\tp += n * surf_dist * 2.;\n\trd = refract(rd, -n, mat.x);\n\n\tl = march(p, rd);\n\tp = p + rd * l + -n * surf_dist * 2.;\n\tn = normal(p);\n\n\tmat = material(p);\n\treturn shadow(p, n, l, rd) * color(mat);\n}\n\nvec3 surface(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tswitch(int(mat.w)) {\n\tcase 1: return mirror(p, n, rd, mat);\n\tcase 2: return glass(p, n, rd, mat);\n\tcase 3: return color(mat);\n\tcase 4: return mirror(p, n, rd, mat);\n\tdefault: return vec3(0, 0, 1);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 R = iResolution.xy;\n    vec2 C = fragCoord;\n\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tvec3 c = vec3(0);\n  \tvec2 m = vec2(iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n\tm *= 5.;\n\tvec3 ro = vec3(sin(m.x) * cos(m.y), sin(m.y), cos(m.x) * cos(m.y)) * 3.5;\n\tro.y = max(-.5, ro.y);\n\tvec3 rd = look(normalize(vec3(0, .5, 0) - ro)) * normalize(vec3(uv, 1.));\n\n\tfloat lo = 0.;\n\tfloat l = march(ro, rd);\n\tvec3 p = ro + rd * l;\n\tvec3 n = normal(p);\n\tvec4 mat = material(p);\n\tvec3 col = color(mat);\n\n\tc += shadow(p, n, l, rd) * col * 1. / 5.;\n\tfor (float i = 1.; i < recursions; ++i)\n\t\tc += surface(p, n, rd, mat) / recursions * 4. / 5.;\n\n\tfragColor = vec4(c, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}