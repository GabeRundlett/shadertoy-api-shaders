{
    "Shader": {
        "info": {
            "date": "1569032464",
            "description": "Inspriation: some gifs by wblut and muratpak on Twitter\n[url]https://twitter.com/wblut/status/1157370352718307328[/url]\n[url]https://twitter.com/muratpak/status/1234879106774372353[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "tddGzf",
            "likes": 11,
            "name": "Rubik's Transformation (wip)",
            "published": 3,
            "tags": [
                "wip"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "// /*\n// Current code for \"Rubik's Transformation\"\n// Title: -\n// Started: 2020 3/13\n// Tags: wip\n// Description: Inspriation: some gifs by wblut and muratpak on Twitter\n//     [url]https://twitter.com/wblut/status/1157370352718307328[/url]\n//     [url]https://twitter.com/muratpak/status/1234879106774372353[/url]\n\n// 2020 7/11 I've been working on this on and off for a long time now. I think\n//   i've finally formulated the idea for the generalized algorithm for\n//   splicing space in my head now - it would be nice to finally get this\n//   project over with as also btw i had a faulty prototype (though laggy with\n//   only a few panes and texture mapping from the original space was not\n//   working)\n//\n//   so today i restarted from scratch (except for code to trace/march onto\n//   primitives and code to render to screen a specular-mapped thing i.e. we\n//   are restarting the inter_shattered() function (the core of this entire\n//   shaer)\n//\n// 2020 8/9 Picking up this project after another few weeks' inactivity.\n//   Managed to kill a number of straggler bugs and am about to implement the\n//   rotation as described at\n//   http://paulbourke.net/geometry/rotate/\n//\n// 2020 8/11 So I think I've finally got it working lol. Took forever. very\n//   complicated, but it seems to be getting the normals right now,\n\n// TODO:\n// - make the actual thing, and work\n//   - delete unused variables\n//   - to fix some bugs:\n//     - abs(SDFp) < 1e-4 may be contradicting p += d*1e-3\n//     - increase max steps to about 1 million\n//     - multiply step size by ~1/2\n//     - try improving newly-added-face detection\n//     - multisample pixel position from 4x4 square grid\n//     - fix normals of both inter_closest and panes\n//\n// then play around w it\n// - schlick fractal gradient-noise water\n// - shattered tribar (voxel w specular highlights)\n//   - shadow on self (point lights rotate around inverted circle)\n//   - black/cyan tinted glass\n\n// - shattered wire cube\n// - shattered infinite world//cylinder\n// - shattered 4x4x4 aqua/pearl spheres\n// - / frameblend\n\n\n\n// i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582097494459230\n//7816406286208998628\n#define TAU PI*2.\n\n#define arg mod(float(iFrame)/60./14., 1.)\n\n\n\n\n\n\n\n\n\n// sky map\n\nvec3 sky_map (vec3 d) {\n    //return abs(d);\n    //return vec3(1.);\n    // return vec3(0., 0., 100./255.);\n    \n    float dimness = .5+.5*clamp(cos(d.y*PI), -.8, .8);\n    \n    //return texture(iChannel2, d).rgb;\n    \n    vec3 aus = vec3(0.);\n    float licht;\n    licht = clamp(dot(d, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n    aus += vec3(1.)*pow(licht, 1.);\n    licht = clamp(dot(d, normalize(vec3(0., 1., 1.)) ), 0., 1.);\n    aus += vec3(0., 0., 1.)*pow(licht, 5.);\n    \n    \n    //vec2 pl = d.xz/d.y*6.;\n    //if (d.y < 0.) { aus += mod(floor(pl.x)+floor(pl.y), 2.); }\n    \n    //return clamp(aus, 0., 1.);\n    \n    float a = 2.;\n    float ah = dot(vec3(d.x, -abs(d.y), d.z), normalize(vec3(0., -a, 0.)) );\n    float h = a/ah;\n    float o = sqrt(h*h-a*a);\n    float th = atan(d.z, d.x);\n    // g is where it hits the ground/sky\n    vec2 g = vec2(cos(th)*o, sin(th)*o);\n    \n    // get ths sky color\n    float cloudamt = 0.;\n    cloudamt += .7*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/43.).r;\n    cloudamt += .3*texture(iChannel1, vec2(g.x+g.y, g.x-g.y)/15.).r;\n    cloudamt = pow(cloudamt, 2.);\n    // cloudamt *= .4;\n    // cloudamt += .0*texture(iChannel0, vec2(g.x+g.y, g.x-g.y)/90.).r;\n    \n    vec3 SKY_COLOR = vec3(.0, .5, 1.);\n    SKY_COLOR += cloudamt;\n        // dimness = mix(dimness, 1., sunhalo);//sunamt*sunamt);\n    if (d.y > .2) {\n        return clamp(SKY_COLOR*pow(dimness, .05), 0., 1.);\n    }\n    else {\n        // return vec3(1.)*mod(floor(g.x)+floor(g.y), 2.);\n        vec3 GROUND_COLOR = vec3(.3, .5, .3)*(\n            .0+.8*texture(iChannel1, g/5.).r);\n        \n        GROUND_COLOR = 3.*GROUND_COLOR*GROUND_COLOR-\n            2.*GROUND_COLOR*GROUND_COLOR*GROUND_COLOR;\n        GROUND_COLOR *= 4.;\n        GROUND_COLOR = clamp(GROUND_COLOR, 0., 1.);\n        \n        float puddleamt = .5+.5*sin(g.x*o*.05);\n        puddleamt = .5*puddleamt+.5*texture(iChannel1, vec2(g.x, g.y)/20.).r;\n        puddleamt = pow(puddleamt, .3);\n        dimness = mix(dimness, 1., puddleamt)*.5;\n        \n        if (puddleamt > .8) {\n            float amt = (puddleamt-.3)/.6;\n            amt = clamp(amt, 0., 1.);\n            amt = pow(amt, 2.);\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR+vec3(.4), amt);\n        }\n        if (-.2 <= d.y && d.y <= .2) {\n            float amt = (d.y+.2)/.4;\n            dimness = mix(\n                dimness,\n                mix(\n                    dimness*2.,\n                    1.,\n                    -puddleamt\n                ),\n                amt\n            );\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            amt = 3.*amt*amt-2.*amt*amt*amt;\n            GROUND_COLOR = mix(GROUND_COLOR, SKY_COLOR, amt);\n        }\n        return clamp(GROUND_COLOR*dimness*mix(0., 1., clamp(abs(d.y)*12., 0., 1.)), 0., 1.);\n    \n    }\n\n}\n\n\n\n\n\n// related to tracing onto things (return distance and normal)\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n// plane - one liner lol\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n\n#define inter_plane_short(p, d, c, n) (\\\n    dot(n, d) > 1e-6 ? vec4(-n, dot(c-p, n)/dot(n, d)) : inter_sky )\n// #define inter_plane_dist(p, d, c, n) (\\\n//dot(n, d) > 1e-6 ? dot(c-p, n)/dot(n, d) : inter_sky )\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n// sphere\n#define SDF_sphere(p, c, r) ( length(p-c)-r )\n\n// #define inter_sphere(p, d, c, r) ( dot(d, c-p)\n\n\n// SDF\n\n#define SDF_sq(p) ( length(max(abs(p)-.98, 0.))-.015 )\n//#define SDF_core(p) ( length(max(abs(p)-.8, 0.))-.015 )\n//#define SDF(p) max(SDF_sq(p), -SDF_core(p) )\n#define SDF(p) SDF_sq(p)\n//#define SDF(p) ( length(p)-2. )\n\n\n\n\n#define inf vec2(1e-3, 0.)\n\n#define dSDF(p) normalize(vec3(SDF(p+inf.xyy),SDF(p+inf.yxy),SDF(p+inf.yyx))-SDFp)*sign(SDFp)\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    // return inter_sphere(p, d, vec3(0.), .5);\n    float SDFp;\n    \n    vec3 camp = p;\n    \n    //for (int i=0; i<1333222; ++i) {\n    for (int i=0; i<333; ++i) {\n        SDFp = SDF(p);\n        //if (abs(SDFp) < 1e-4 && i > 10) {\n        if (abs(SDFp) < 1e-4) {\n            return vec4(dSDF(p), length(p-camp));\n        }\n        //p += d*abs(SDFp)*.5;\n        p += d*abs(SDFp);\n        if (abs(SDFp) > 10.) {\n            break;\n        }\n    }\n    \n    return inter_sky;\n}\n\n\nvoid shift_shard (inout vec3 p, inout vec3 d, vec3 c, vec3 n, float angtot, float amt, out mat3 rot) {\n    #define iv .4\n    //p += n*.1*clamp(amt/iv, 0., 1.);\n    //p += n*.01;\n    //p -= n*.1*clamp((amt-iv)/(1.-iv), 0., 1.);\n    //p += n*.05;\n    //p += n*.2*amt;\n    \n    float arg4 = clamp((amt-iv)/(1.-iv), 0., 1.);\n    \n    #define easen 5.\n    //arg4 = 1.- pow(.3, floor(arg4*(easen*2.-1.)/2.-.5)+1.) * abs(sin(PI*( arg4*(easen*2.-1.)/2. - .5)  ));\n    #undef easen\n    \n    arg4 = .5-.5*cos(arg4*PI);\n    \n    p -= c;\n    // d -= c;\n    \n    \n    // https://en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle\n    float th = arg4*angtot;\n    float costh = cos(th);\n    float ONE_MIN = 1.-costh;\n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    p = rot*p;\n    d = rot*d;\n    \n    th = -th;\n    costh = cos(th);\n    ONE_MIN = 1.-costh;\n    /*rot = mat3(\n        cos(th)+n.x*n.x*(1.-cos(th)),     n.x*n.y*(1.-cos(th))-n.z*sin(th), n.x*n.z*(1.-cos(th))+n.y*sin(th),\n        n.y*n.x*(1.-cos(th))+n.z*sin(th), cos(th)+n.y*n.y*(1.-cos(th)),     n.y*n.z*(1.-cos(th))-n.x*sin(th),\n        n.z*n.x*(1.-cos(th))-n.y*sin(th), n.z*n.y*(1.-cos(th))+n.x*sin(th), cos(th)+n.z*n.z*(1.-cos(th))\n    );*/\n    \n    rot = mat3(\n        costh+n.x*n.x*ONE_MIN,     n.x*n.y*ONE_MIN-n.z*sin(th), n.x*n.z*ONE_MIN+n.y*sin(th),\n        n.y*n.x*ONE_MIN+n.z*sin(th), costh+n.y*n.y*ONE_MIN,     n.y*n.z*ONE_MIN-n.x*sin(th),\n        n.z*n.x*ONE_MIN-n.y*sin(th), n.z*n.y*ONE_MIN+n.x*sin(th), costh+n.z*n.z*ONE_MIN\n    );\n    \n    //nc = n;\n    //nc = vec3(1., 0., 0.);\n    \n    p += c;\n    // d += c;\n    //#undef iv\n}\n\n\n#define numpanes 5\nvec4 inter_shattered (vec3 p, vec3 d, vec3 panec[numpanes],\n    vec3 panen[numpanes], float angtot[numpanes], inout vec3 pT, inout vec3 dT, out int midspace) {\n    //pT = p; dT = d; return inter_SDF(p, d);\n    float arg2 = min(arg*2., 2.-arg*2.);\n    //arg2 = max(1.+(arg2-1.)*1.0, 0.);\n    arg2 = min(arg2*1.4, 1.);\n    arg2 = max(1.-(1.-arg2)*1.4, 0.);\n    vec4 inter_closest;\n    vec4 inter_pane1;\n    vec4 inter_pane1T;\n    vec4 inter_SDF1;\n    //\n    float arg3; mat3 rottot = mat3(1.); mat3 rottot_; mat3 rot;\n    // for jumps\n    inter_closest = inter_sky;\n    pT = p;\n    dT = d;\n    midspace = 0;\n    //for (int i=0; i<numpanes; ++i) {\n    for (int i=numpanes-1; i>=0; --i) {\n        pT = p;\n        dT = d;\n        arg3 = clamp(arg2*float(numpanes)-float(i), 0., 1.);\n        if (arg3 == 0.) {continue;}\n        \n        if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n            // upper space - no transform\n            inter_pane1 = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            if (inter_pane1.w < inter_closest.w) {\n                inter_closest = inter_pane1;\n            }\n        }\n        else {\n            // keep track of plane in original space\n            inter_pane1 = inter_plane(p, d, panec[i], panen[i]);\n            // warp space and check stuff\n            shift_shard(pT, dT, panec[i], panen[i], angtot[i],\n                arg3, rot\n            );\n            \n            rottot_ = rottot;\n            // rottot = rot*rottot;\n            rottot = rottot * rot;\n            \n            inter_pane1T = inter_plane(pT, dT, panec[i], panen[i]);\n            \n            \n            if (SDF_plane(pT, panec[i], panen[i]) > 0.) {\n                // midspace - can only trace onto 2 planes to escape\n                midspace += 1;\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n                if (inter_pane1.w < inter_closest.w) {\n                    // we are dealing in untransformed space\n                    // this one pane gets the texture coords of\n                    // upper space\n                    pT = p;\n                    dT = d;\n                    inter_closest = inter_pane1;\n                    inter_closest.xyz = rottot_ * inter_closest.xyz;\n                }\n            }\n            else {\n                // lower space - can only trace onto transformed\n                // pane or obj\n                if (inter_pane1T.w < inter_closest.w) {\n                    inter_closest = inter_pane1T;\n                    inter_closest.xyz = rottot * inter_closest.xyz;\n                }\n            }\n            \n        }\n        p = pT;\n        d = dT;\n    }\n    if (midspace == 0) {\n        inter_SDF1 = inter_SDF(pT, dT);\n        if (inter_SDF1.w < inter_closest.w) {\n            inter_closest = inter_SDF1;\n        }\n        inter_closest.xyz = rottot*inter_closest.xyz;\n    }\n    \n    \n    \n    return inter_closest;\n    //return inter_sky;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec3 panec[numpanes];\n    vec3 panen[numpanes];\n    float angtot[numpanes];\n    \n    panec[0] = vec3(.03, 0., 0.);\n    panec[1] = vec3(.0, .1, .0);\n    panec[2] = vec3(.0, .0, .0);\n    panec[3] = vec3(.4, .4, .4);\n    panec[4] = vec3(.0, 0., 0.);\n    \n    panen[0] = normalize(vec3(0., 1., 1.));\n    panen[1] = normalize(vec3(1., 0., 0.));\n    panen[2] = normalize(vec3(0., 0., 1.));\n    panen[3] = normalize(vec3(-1.));\n    panen[4] = normalize(vec3(-1., 1., 0.));\n    \n    angtot[0] = PI;\n    angtot[1] = PI*.5;\n    angtot[2] = PI*.5;\n    angtot[3] = TAU/3.;\n    angtot[4] = PI;\n    \n    \n    #define spp 1\n    #define spw 1.\n    vec3 finalCol = vec3(0.);\n    vec3 randy;\n    float ox; float oy;\n    for (ox=0.; ox<spw; ++ox) {\n        for (oy=0.; oy<spw; ++oy) {\n            #define samplei 0.\n            //for (float samplei=0.; samplei<float(spp); ++samplei) {\n                randy = vec3(\n                    fract(sin(\n                        mod(\n                            samplei*21.463049023049+\n                                (float(iFrame)+fragCoord.x)*0.021415,\n                            TAU\n                        )+fragCoord.y*52.2324352432\n                    )),\n                    fract(sin(\n                        mod(\n                            samplei*421.83743204984+\n                                (float(iFrame)+fragCoord.x)*8.234203,\n                            TAU\n                        )+fragCoord.y*123.242543465\n                    )),\n                    fract(sin(\n                        mod(\n                        samplei*952.13454543556+\n                            float(iFrame)*8.234203,\n                        TAU\n                        )+fragCoord.y*.003432443\n                    ))\n                );\n                vec2 screen = (fragCoord.xy+vec2(ox, oy)/spw+randy.rg/spw-iResolution.xy/2.)/iResolution.y;\n                \n                // camera\n                vec3 camp = vec3(0., 0., -4.);\n                vec3 camd = normalize(vec3(screen.x, screen.y, 1.));\n                \n                float ph = (iMouse.y/iResolution.y*2.-1.)*4.;\n                mat2 zenith = mat2(\n                    cos(ph), cos(PI*.5+ph),\n                    sin(ph), sin(PI*.5+ph)\n                );\n                camd.yz *= zenith;\n                camp.yz *= zenith;\n                \n                float th = (iMouse.x/iResolution.x*2.-1.)*TAU;\n                //th += arg*TAU;\n                if (iMouse.x <= 0.001) { th += arg*TAU; } // only rotate in preview or when mouse unknown\n                mat2 azimuth = mat2(\n                    cos(th), cos(PI*.5+th),\n                    sin(th), sin(PI*.5+th)\n                );\n                camd.xz *= azimuth;\n                camp.xz *= azimuth;\n                \n                camd = normalize(camd);\n                \n                camp += camd*(randy.b*2.-1.)*1e-2;\n                \n                // retina color at point from raytracing\n                vec3 retina = vec3(0.);\n                float shiny = 1.;\n                vec4 inter_shattered1;\n                vec3 p = camp;\n                vec3 d = camd;\n                vec3 pT;\n                vec3 dT;\n                int midspace;\n                bool wasout;\n                bool isout;\n                vec3 pT2;\n                vec3 dT2;\n                \n                //vec4 inter_cam = inter_plane(\n                //    p, d, normalize(p)*.5, normalize(p-vec3(0.))\n                //);\n                //p += d*inter_cam.w;\n                \n                for (int bounces=0; bounces<37; ++bounces) {\n                    if (shiny < .1) {\n                        break;\n                    }\n                    inter_shattered1 = inter_shattered(\n                        p, d, panec, panen, angtot, pT, dT, midspace\n                    );\n                    if (inter_shattered1.w >= inter_sky.w) {\n                        // too far - hits sky\n                        break;\n                    }\n                    else {\n                        p += d*inter_shattered1.w;\n                        pT += dT*inter_shattered1.w;\n                        \n                        \n                        wasout = midspace > 0 || SDF(pT) > 1e-3;\n                        inter_shattered(\n                            p+d*1e-2, d, panec, panen, angtot, pT2, dT2, midspace);\n                        \n                        //if (abs(SDF(pT)) < 1e-3 ) {\n                        //if (abs(SDF(pT)) < 1e-3 || SDF(pT) < 1e-2 &&\n                        //    sign_shattered(p+d*1e-2, panec, panen) !=\n                        //    sign_shattered(p-d*1e-2, panec, panen) ) {\n                        //if (wasout != isout) {\n                        if (abs(SDF(pT)) < 1e-3 ||\n                            wasout != (midspace > 0 || SDF(pT2+dT2*1e-2) > 1e-3)) {\n                            \n                            // hits object - have distance to intersection and normal\n                            \n                            /*//vec3 TEXp = .5+.5*(inter_shattered1.xyz);\n                            float SDFp = SDF(pT);\n                            vec3 seid = abs(dSDF(pT) );\n                            \n                            vec3 TEXp = vec3(0., 0., 0.);\n                            float ang1;\n                            \n                            ang1 = acos(dot(seid, vec3(0., 1., 0.) ));\n                            TEXp = mix(TEXp, vec3(0., 1., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            ang1 = acos(dot(seid, vec3(1., 0., 0.) ));\n                            TEXp = mix(TEXp, vec3(1., 1., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            ang1 = acos(dot(seid, vec3(0., 0., 1.) ));\n                            TEXp = mix(TEXp, vec3(0., 0., 1.), 1.-clamp(\n                                ang1/(PI*.5),\n                                0., 1.\n                            ));\n                            \n                            #if 1\n                            TEXp = mix(\n                                TEXp,\n                                vec3(.3),\n                                .0+.3*mod(floor(pT.x*9.+.001)+floor(pT.y*9.+.001)+floor(pT.z*9.+.001), 2.)\n                            );\n                            #endif\n                            //TEXp = abs(inter_shattered1.xyz);\n                            //TEXp = vec3(0.);\n                            */\n                            vec4 inter_closest = inter_shattered1;\n                            vec3 specular = sky_map(reflect(camd, inter_closest.xyz))*0.;\n                            float specularh = length(specular)/sqrt(3.);\n                            vec3 TEXp;\n                            \n                            #define cz1 2.\n                            \n                            //if (mod(floor(pT.x*cz1-inf.x)+floor(pT.y*cz1-inf.x)+floor(pT.z*cz1-inf.x), 2.) < 1.) {\n                            if (abs(SDF(pT)) < 1e-3 && !(length(pT-vec3(1., 0., 0.)) < .5) ) {\n                                // pearly white\n                                float diffuse = clamp(dot(inter_closest.xyz, normalize(vec3(1., 1., 1.)) ), 0., 1.);\n                                // specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 4.);\n                                TEXp = vec3(.53)+vec3(.6)*diffuse+specularh*.7;\n                                \n                                \n                                #define shininess .79993\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                            else {\n                                // heres for blue bubble\n                                /*vec4 inter_inside = inter_sphere(camp, camd, closest_center, closest_r, true);\n                                vec2 glob = vec2(\n                                    .5+.5*dot(inter_inside.xyz, normalize(vec3(0., -1., .5)) ),\n                                    .5+.5*dot(inter_closest.xyz, normalize(vec3(0., -1., .5)) )\n                                );\n                                float glo = length(glob)/sqrt(2.);*/\n                                float glo = 1.-(.5+.5*p.y); //mod(p.y*cz1, 1.);\n                                \n                                glo = 3.*glo*glo-2.*glo*glo*glo;\n                                //glo = pow(glo, 1.7);\n                                \n                                specularh = 3.*specularh*specularh-2.*specularh*specularh*specularh;\n                                specularh = pow(specularh, 1.5);\n                                \n                                float glo2 = pow(glo, 2.);\n                                TEXp = vec3(.0, .3, .5) + vec3(.0*glo2, .5*glo2, .5*glo) + vec3(1.)*specularh*.95;\n                                \n                                \n                                #define shininess .999\n                                retina += TEXp*shiny*shininess;\n                                shiny *= 1.-shininess;\n                                //d = reflect(d, inter_shattered1.xyz);\n                                p += d*1e-3;\n                                #undef shininess\n                            }\n                        }\n                        else {\n                            // hits pane - translucency if want debug\n                            \n                            vec3 TEXp = abs(inter_shattered1.xyz)*0.+mod(\n                                floor(p.x+1e-3)+floor(p.y+1e-3)+floor(p.z+1e-3),\n                                2.\n                            );\n                            #define shininess .0\n                            retina += TEXp*shiny*shininess;\n                            shiny *= 1.-shininess;\n                            \n                            //d = reflect(d, inter_shattered1.xyz);\n                            p += d*1e-4;\n                            #undef shininess\n                        }\n                    }\n                }\n                \n                if (shiny == 1.) {\n                    // white background if never hit obj\n                    retina = vec3(0., 0., 100./255.);\n                    shiny *= 0.;\n                }\n                \n                // add sky color to last reflection/refaction etc.\n                retina += shiny*sky_map(d);\n                finalCol += retina;\n            //}\n        }\n    }\n    finalCol /= float(spp);\n    fragColor = vec4(finalCol, 1.);\n    \n}\n\n\n\n\n\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n// OLD CODE FOR: \"kissing blobs\"\n// title: kissing blobs\n// created: 2019 9/21\n// tags: blobs, slime, field\n// description: I independently discovered that summing up the\n// reciprocol of the blobs distances gave the desired effect I'd\n// seen here:\n// khanacademy.org/computer-programming/metalslab/6640525797228544\n// years ago, but I did not realize that \"meatballs\" were already a\n// \"thing\"\nfloat daht(vec2 pos, vec2 screen, float rad) {\n    float p = length(pos-screen)/rad;\n    return (0.5/p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 centre = iResolution.xy/2.;\n    \n    float count = 0.;\n    \n    // BLOBS\n    count += daht(centre, fragCoord, 50.);\n    float arg1 = 150.*sin(iTime);\n    float arg2 = 80.*sin(iTime*0.5);\n    count += daht(centre+vec2(90.+arg1, 10.+arg2), fragCoord, 50.);\n    count += daht(iMouse.xy, fragCoord, 50.);\n    \n    // old code\n    // float val = min(count/1.0, 1.0);\n    // val = val >= 1.0 ? 1. : 0.;\n    //fragColor = vec4(val, val, val, 1.0);\n    \n    // new code thx to FabriceNeyret2\n    float val = count/1. - 1.;\n    fragColor = vec4( smoothstep( -.7,.7, val / fwidth(val) ) );\n}\n/**/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}