{
    "Shader": {
        "info": {
            "date": "1646386658",
            "description": "Domain distortion experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "ssSfWw",
            "likes": 8,
            "name": "Quantum substance",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "El_Sargo",
            "viewed": 4221
        },
        "renderpass": [
            {
                "code": "//Heavy performance impact \n#define AA 1\n#define raymarchSteps 100\n//#define vanillaMarch\n#define rotationSpeed 7.\n#define ZERO min(iFrame, 0)\n\nconst float pi = 3.14159265359;\n\nfloat sdBox( in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.0); rot[1] = vec3(sin(a), cos(a), 0.0); rot[2] = vec3(0.0, 0.0, 1.0); return rot; }\n\n\nvec4 map(vec3 p) {\n    for(int i =0;i<2;i++){\n    const float s = .6;\n    p *=roty(s*sin(iTime*0.5)*p.y)*rotz(s*p.z*cos(iTime*2.1))*rotx(s*p.x*-cos(iTime));\n    p.x += cos(iTime*2.141)*0.15*abs(p.y);\n    p.y += sin(iTime*1.123123)*0.15*abs(p.z);\n    p.z += -cos(iTime*3.123123)*0.15*abs(p.x);\n\n    }\n    float d =  sdBox(p, vec3(1.));//sdSkeleton(p, iTime);\n    \n    return vec4(d-0.3, p);\n}\n#ifndef vanillaMarch \nvec3 intersection(vec3 ro, vec3 rd){\n    \n    //Boring variables\n    float zslice = -.158;//cos(stime);\n    vec3 pos = ro;\n    vec2 mouseUV = (iMouse.xy-iResolution.xy*.5f)/iResolution.x * 5.;\n    float T = 0.;\n    \n    //Colour \n    float h = map(pos).x;\n    \n    \n    //The interesting part\n    float omega = 1.;\n    float pom = 1.;\n    float ph = 1e5;\n    vec2 gap = vec2(0.,0.);\n    for (int i = 0; i<raymarchSteps; ++i) {\n    \n        //Position and distance estimation\n        vec3 p = ro+T*rd;\n        h = map(p).x*0.5;\n        \n        if (h > 20.)\n            break;\n        \n        //Overstep recovery\n        float om = (ph+h)/ph;\n        \n        if (om<pom && pom > 1.) { //ph+h<ph*pom\n            \n            gap = vec2(h,T);\n            T+=(1.-pom)*ph;\n            pom = 1.;\n            \n        } else {\n            \n            //Variable updates\n        \tT += h * omega;\n            ph = h;\n            pom = omega;\n            \n            //Back to the place where the gap opened (foward)\n        \tif (T>=gap.y-gap.x && gap.y+gap.x > T) {T = gap.y+gap.x*omega; ph = gap.x;};\n        }\n        \n          \n        //Dynamic Omega \n        //omega = clamp((omega+om)*.5,1.,3.);\n        omega = clamp(omega+(om-omega)*.6,1.,3.);\n    }\n    return ro+T*rd;;\n}\n#else\n//https://www.shadertoy.com/view/wlVGRV\nvec3 intersection(vec3 ro, vec3 rd){\n    for(int i=0;i < raymarchSteps;i++){\n        float dist = map(ro).x*1.;\n        ro += rd*dist;\n        if(dist <0.01)\n            break;\n    }\n    return ro;\n}\n#endif\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p ){\n    const float h = 1.1;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<3; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 sky(vec3 rd, samplerCube sam){\n    return texture(sam, rd).xyz;\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    \n    //world info\n     vec3 pos = intersection(ro,rd);\n     vec4 sce = map(pos);\n    float dis = sce.x;\n     vec3 trp = sce.yzw;\n    float tpd = distance(trp,pos);\n    \n    //Shading\n     vec3 sun = vec3(0., 1., 0);\n    float sha = softshadow(pos, sun, 0.1, 2., 1.);\n     vec3 nor = calcNormal(pos);\n    float occ = calcAO(pos, nor);\n    float lig = (dot(sun,nor)*0.5+0.5);\n\n    //Colors\n     vec3 col = vec3(0);\n     vec3 bcl = vec3(smoothstep(-2., 1., tpd));\n     vec3 scl = sky(nor, iChannel1);\n     vec3 amb = vec3(0.9, 0.9, 1.);\n    \n    //\n     //vec3 txs = texture(iChannel0, rd).xyz;\n     //vec3 txr = texture(iChannel0, reflect(nor, rd)).xyz;\n    vec3 ref = reflect(rd,nor);\n    if (dis < 2.1) {\n        //Sun\n        //col += .75*lig*sha*scl*bcl*(max(0.,dot(sun,nor)));\n        //Ambient\n        col += 0.5*mix(vec3(0.463,0.376,0.318),vec3(1.000,1.000,1.000),smoothstep(-1.,1.,nor.y))*occ;\n        //Reflect\n        col += 2.*bcl*sha*sha*sky(ref,iChannel1)*occ*(1.+dot(ref,rd));\n    } else\n        col = sky(rd,iChannel0);\n    return vec4(col, 0.1);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -5.5);\n    mat3 yrot = roty(iTime*0.2);\n    mat3 xrot = rotx(-iMouse.y/iResolution.y*rotationSpeed);\n           ro*=xrot*yrot;\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        tot += render(ro, rd*xrot*yrot) / float(AA*AA);\n    }}\n\n    tot = smoothstep(-.1,1.4,tot);\n    \n    // Output to screen\n    fragColor = tot;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}