{
    "Shader": {
        "info": {
            "date": "1556659394",
            "description": "For the most part this is an exercise in trying out folding of space... with a bit of basic toon- and blinn/phong-shading.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtXGzS",
            "likes": 11,
            "name": "Folding space",
            "published": 3,
            "tags": [
                "3d",
                "phong",
                "ray",
                "sdf",
                "sphere",
                "shading",
                "marching",
                "folding",
                "ao",
                "tracing",
                "blinn",
                "toon"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 813
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Space folding exercise - Learning experience with regards to folding space\n// and playing a bit with different shading methods.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg)\n{\n    float r = radians (deg);\n    float c = cos (r);\n    float s = sin (r);\n    return mat2 (c, s, -s, c);\n}\n\nvec3 smin (vec3 d1, vec3 d2, float k)\n{\n    vec3 h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n    return mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat vary (float v, float s)\n{\n    return v*(.5 + .5*cos(s*iTime));\n}\n\n// ollj suggested map() variation, which lets you control smooth-minimum distance and\n// cube edge-radius with the mouse\nfloat map (vec3 p, out int id)\n{\n    float t = iTime*.5;\n    float s = 3.;\n    for(float i = .0; i < 5.; i += 1.) {\n        p.xz *= r2d (degrees(t + i));\n        p.xy *= r2d (degrees(-t*.4 - i));\n        p = smin (p, -p, -.25-3.*iMouse.x/iResolution.x);\n        p -= s; s *= .625;\n    }\n    vec3 size = vec3 (.4);\n    float d = length (max (vec3 (.0), abs (p) - size))-iMouse.y/iResolution.y;\n    id = 3;\n    return d;\n}\n\n// my original version of map()\nfloat map2(vec3 p, out int id)\n{\n\tfloat t = iTime*.5;\n\tfloat s = 3.;\n\tfor(float i = .0; i < 5.; i += 1.) {\n\t\tp.xz *= r2d (degrees(t + i));\n\t\tp.xy *= r2d (degrees(-t*.4 - i));\n\t\tp = smin (p, -p, -1.25);\n\t\tp -= s;\n\t\ts *= .625;\n\t}\n\tvec3 size = vec3 (.4);\n    float d = length (max (vec3 (.0), abs (p) - size)) - .1;\n    id = 3;\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, out int id, out int iter)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0;i < 48; ++i) {\n\t\titer = i;\n\t\tt = map(ro + d*rd, id);\n\t\tif (abs(t) < .01*(1. + .125*t)) break;\n\t\td += t*.95;\n\t}\n\treturn d;\n}\n\nvec3 normal (vec3 p)\n{\n    int ignored;\n    vec2 e = vec2 (.001, .0);\n    float d = map (p, ignored);\n    return normalize (vec3 (map (p + e.xyy, ignored),\n                            map (p + e.yxy, ignored),\n                            map (p + e.yyx, ignored)) - d);\n}\n\nfloat shadow (vec3 p, vec3 ldir, vec3 n, float ldist)\n{\n    int ignored;\n    int ignored2;\n    float d2w = march (p + .01*n, ldir, ignored, ignored2);\n    return ldist < d2w ? 1. : .25;\n}\n\nfloat ao (vec3 p, vec3 n, float d)\n{\n\tint ignored;\n\treturn clamp (map (p + d*n, ignored)/d, .0, 1.);\n}\n\nvec3 shade (vec3 rd, vec3 p, vec3 n, vec3 lp, vec3 lc, float li, int id)\n{\n    vec3 am = vec3(.1);\n    float ldist = distance (lp, p);\n    float att = 800./(ldist*ldist);\n    vec3 ldir = normalize(lp - p);\n    vec3 h = normalize(-rd + ldir);\n    float s = shadow(p, ldir, n, ldist);\n    vec3 mat = vec3(.3);\n    float shiny = 80.;\n    if (id == 3){ mat = vec3 (1.,.5,.25); shiny = 70.;}\n    float sp = pow (max (.0, dot (n, h)), shiny);\n    float diff = max (.0, dot (n, ldir));\n    float ao = ao (p, n, 1.5);\n\n    return att*s*(am + ao*diff*li*lc*mat + sp*vec3 (1.));\n}\n\nvec3 gradient (float value) {\n\tvec3 color = vec3 (.2);\n\tif (value > .0 && value < .2) {\n\t\tcolor = vec3 (.3, .4, .5);\n\t} else if (value >= .2 && value < .4) {\n\t\tcolor = vec3 (.35, .5, .7);\n\t} else if (value >= .4 && value < .7) {\n\t\tcolor = vec3 (.4, .6, .8);\n\t} else if (value >= .7 && value < .9) {\n\t\tcolor = vec3 (.5, .7, .85);\n\t} else if (value >= .9) {\n\t\tcolor = vec3 (.85, .9, .95);\n\t}\n\treturn color;\n}\n\nvec3 shadeToon (vec3 p, vec3 n, vec3 lp, vec3 rd)\n{\n\tvec3 ldir=normalize(lp-p);\n\tfloat diff=max(.0,dot(n,ldir));\n\tvec3 color = gradient (diff);\n\tvec3 outline = vec3 (.0);\n\n    return color;\n}\n\nvec3 camera (vec2 uv, vec3 ro, vec3 aim, float z)\n{\n    vec3 f = normalize (aim - ro);\n    vec3 wu = vec3 (.0, 1., .0);\n    vec3 r = normalize (cross (wu, f));\n    vec3 u = normalize (cross (f, r));\n    vec3 c = ro + f*z;\n\n    return normalize (c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy*2.-1.;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    vec3 ro = vec3 (4., 0.5, 33.);\n    vec3 aim = vec3 (.0);\n    float zoom = 2.25;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    int id=0;\n\tint iter=0;\n    float d=march(ro,rd,id,iter);\n\tfloat fog=1./(1.+d*d*.05);\n    vec3 p=ro+d*rd;\n    vec3 n=normal(p);\n\n    // light one\n    vec3 lp1=vec3(10.,20.,30.);\n    lp1.xz*=r2d(vary(45.,2.));\n    vec3 lc1=vec3(.9,.8,.7);\n    float li1=24.;\n\n    // light two\n\tvec3 lp2=vec3(-10.,5.,30.);\n    lp2.yz*=r2d(vary(45.,2.));\n    vec3 lc2=vec3(.7,.8,.9);\n    float li2=20.;\n\n    // light three\n\tvec3 lp3=vec3(-8.,-20.,30.);\n    lp3.xy*=r2d(vary (45.,2.));\n    vec3 lc3=vec3(.2,.3,.9);\n    float li3=22.;\n\n    vec3 c;\n\tif (uv.x < uv.y*aspect - .01) {\n    \tc = shade (rd, p, n, lp1, lc1, li1, id);\n    \tc += shade (rd, p, n, lp2, lc2, li2, id);\n    \tc += shade (rd, p, n, lp3, lc3, li3, id);\n\t\tc *= fog;\n    \tc = c/(1. + c);\n\t\tc *= 1. - .25*pow (length (uv), 2.);\n    \tc = pow (c, vec3 (1./2.2));\n\t} else if (uv.x >= uv.y*aspect - .01 && uv.x < uv.y*aspect + .01) {\n\t\tc = vec3 (1.);\n\t} else {\n\t\tfloat glow = float (iter)/48.;\n\t\tc = shadeToon (p, n, lp2, rd);\n    }\n\n    fragColor = vec4 (c, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}