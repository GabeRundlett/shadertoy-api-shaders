{
    "Shader": {
        "info": {
            "date": "1564104102",
            "description": "Like Star Wars pod racer :\nW/S : speed \nLEFT/RIGHT : rotation\nUP/DOWN : more speed/flying",
            "flags": 112,
            "hasliked": 0,
            "id": "WtlXWS",
            "likes": 76,
            "name": "Path racer",
            "published": 3,
            "tags": [
                "reflection",
                "game",
                "volumetric",
                "racer",
                "pod"
            ],
            "usePreview": 1,
            "username": "XT95",
            "viewed": 3340
        },
        "renderpass": [
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Post processing pass\n\n// https://www.shadertoy.com/view/XlKSDR\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 acesToneMapping( vec3 col )\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (col * (a * col + b)) / (col * (c * col + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.)/ iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n\n    // post processing effects\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // blur godrays\n    vec3 godray = vec3(0.);\n    for(float x=-3.; x<=3.; x+=1.)\n    for(float y=-3.; y<=3.; y+=1.) { \n    \tgodray += texture(iChannel1,uv*.5+vec2(x,y)*invRes).rgb;\n    }\n    godray = (godray/49.); \n    col += godray*.5;\n    \n    // vignetting\n    col.rgb *= saturate(pow( uv.x * uv.y * (1.-uv.x) * (1.-uv.y)*100., .2));\n    \n    // tone mapping\n    col = acesToneMapping( col );\n    \n    \n    fragColor = vec4(col.rgb,1.) * smoothstep(0.,3., iTime);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 21688,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/nauticus89/duel-of-the-fates-with-vst"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// All data of the game is defined here\n// + some usefull functions :)\n\n// Game\nstruct GameData {\n    vec3 shipPos;\n    vec3 shipLastPos;\n    vec3 shipAccel;\n    vec3 shipVelocity;\n    vec3 shipDirection;\n    float shipTheta;\n    vec3 touchStart;\n};\nGameData readGameData(sampler2D tex, vec2 invRes);\nvec4 writeGameData(vec4 col, vec2 fragCoord, GameData data);\nfloat level(vec3 p);\nfloat levelSafe(vec3 p);\nvec3 normalLevel( vec3 p, const float eps );\nfloat ship(vec3 p);\nfloat world( vec3 p );\nfloat worldSafe( vec3 p );\n\n// Global\nconst vec3 sunDir = normalize( vec3(2., 1., .4) );\nGameData data;\nfloat time;\nvec2 glowAcc; // minimal distance from the reactors and the laser (reset by calling raymarch())\n\n// Math\n#define PI 3.141592653589\n#define saturate(x) clamp(x,0.,1.)\nfloat hash( vec3 x );\nfloat hash( vec2 p );\nfloat hash( float p );\nfloat hash2Interleaved( vec2 x );\nfloat noise( vec3 x );\nmat2 rotate( float t );\nvec3 randomSphereDir( vec2 rnd );\nvec3 randomHemisphereDir( vec3 dir, float i );\n\n// data IO\nfloat readData1(sampler2D tex, int id); \nvec3 readData3(sampler2D tex, int id);\nvec4 readData4(sampler2D tex, int id);\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value);\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value);\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value);\n\n\n\n// SDF Toolbox\nfloat box( vec3 p, vec3 b );\nfloat caps( vec3 p, vec3 a, vec3 b, float r );\nfloat torus( vec3 p, vec2 t );\nfloat smin( float a, float b, float k );\nvec3 raymarch( vec3 ro, vec3 rd, const vec2 nf, const float eps );\nvec3 raymarchFast( vec3 ro, vec3 rd, const vec2 nf, const float eps );\nvec3 normal( vec3 p, const float eps );\nfloat ambientOcclusion( vec3 p, vec3 n, float maxDist, float falloff );\nfloat shadow( vec3 ro, vec3 rd, float mint, float tmax );\nfloat shadowFast( vec3 ro, vec3 rd, float mint, float tmax );\n\n\n// ---------------------------------------------\n// Game\n// ---------------------------------------------\nfloat level( vec3 p )\n{\n    float d = p.y ;\n    \n    // truchet tiles\n    vec3 pp = p;\n    vec2 pi = floor(pp.xz*.01);\n    float rnd = hash(pi);\n    pp.xz = mod(pp.xz, vec2(100.))-50.;\n    \n    \n    \n    pp.xz = rotate(floor(rnd*2.)*.5*PI) * pp.xz;\n    if (rnd>.4) {\n        d = p.y-12.+cos(p.z*.2)-length(pp)/10.;//+rnd*10.;\n        d = max(d, -torus(pp-vec3(-50., 8.75,-50.), vec2(50.,8.5)));\n        d = max(d, -torus(pp-vec3( 50., 8.75, 50.), vec2(50.,8.5)));\n        d += sin(p.y)*.3;\n        d += sin(p.x*.1)*.5;\n        d += sin(p.z*.1)*.5;\n        //d = min(d, p.y);\n    } else if(rnd>.2){\n        vec3 ppp = pp*.15+.5;\n        ppp.y -= .5;\n        d =  smin(p.y+1.,dot(cos(ppp),sin(ppp.zxy))/.15+length(pp)*.2,10.);\n        pp = abs(pp);\n    \td = smin(d, box(pp-vec3(31.,0.,48.), vec3(25.,20.,2.)),10.);\n    \td = smin(d, box(pp-vec3(48.,0.,31.), vec3(2.,20.,25.)),10.);\n    } else { \n        d = p.y-10.;\n        d = max(d, -box(pp-vec3(0.,26.,0.),vec3(5.,26.,500.)));\n        d = max(d, -box(pp-vec3(0.,26.,0.),vec3(500.,26.,5.)));\n        d = min(d, box(pp-vec3(0.,11.,0.),vec3(10.,1.,10.)));\n    }\n    return d;\n}\nfloat levelSafe(vec3 p) {\n    float d = level(p);\n    \n    // hackish way to avoid distance discontinuity on the edges of each tile\n    vec3 pp = p;\n    pp.xz = mod(pp.xz, vec2(100.))-50.;\n    float a = -abs(pp.x)+50.1;\n    a = min(a, -abs(pp.z)+50.1);\n    a  = max(a, pp.y-20.);\n    d = min(d,a);\n    return d;\n}\nfloat ship(vec3 p) {\n    p -= data.shipPos;\n    p.xz = rotate(data.shipTheta) * p.xz;\n    p.xy = rotate(-data.shipAccel.x*.6) * p.xy;\n    \n    float y = max(0.,data.shipAccel.y)*.15 + abs(data.shipAccel.x)*.15;\n    \n    // body\n    float d = torus((p-vec3(0.,0.5,-.5)).zxy, vec2(.5,.08));\n    d = smin(d, caps(p, vec3(0.0,.4,-.7), vec3(.0, .3, -.7),.1), 0.3);\n    \n    // reactor\n    d = min(d, caps(p, vec3(1.,0.4-y,.8), vec3(1.,0.4+y,1.5), .25));\n    d = min(d, caps(p, vec3(-1.,0.4-y,.8), vec3(-1.,0.4+y,1.5), .25));\n    d = max(d, -length(p-vec3(-1.,0.4-y,.8))+.3);\n    d = max(d, -length(p-vec3(1.,0.4-y,.8))+.3);\n    float react = caps(p, vec3(1.,0.4-y,1.), vec3(1.,0.4-y,0.8), .1);\n    react = min(react, caps(p, vec3(-1.,0.4-y,1.), vec3(-1.,0.4-y,0.8), .1));\n    glowAcc.x = min(glowAcc.x,react);\n    \n    d = min(d, react);\n    \n    // lines\n    d = smin(d, caps(p, vec3(-1.,0.4-y,1.7), vec3(0.,0.,0.), .05), .3);\n    d = smin(d, caps(p, vec3(1.,0.4-y,1.7), vec3(0.,0.,0.), .05), .3);\n    \n    // laser\n    p.y += noise(p*vec3(13.,0.,0.)+vec3(0.,0.,time*10.))*.01;\n    float l = caps(p, vec3(-.75,0.4+y,1.3), vec3(.75,0.4+y,1.3), .01);\n    glowAcc.y = min(glowAcc.y, l);\n    d = min(d, l);\n    \n    return d;\n}\nvec3 normalLevel( vec3 p, const float eps ) {\n    float d = level(p);\n    vec2 e = vec2(eps, 0.);\n    \n    vec3 n;\n    \n    n.x = d - level(p-e.xyy);\n    n.y = d - level(p-e.yxy);\n    n.z = d - level(p-e.yyx);\n    \n    return normalize(n);\n}\nfloat world( vec3 p )\n{\n    float d = level(p);\n    d = min(d, ship(p));\n    return d;\n}\nfloat worldSafe( vec3 p )\n{\n    float d = levelSafe(p);\n    d = min(d, ship(p));\n    return d;\n}\n\n\n// ---------------------------------------------\n// Data IO\n// ---------------------------------------------\nfloat readData1(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).r;\n}\nvec3 readData3(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0).rgb;\n}\nvec4 readData4(sampler2D tex, int id) {\n    return texelFetch(tex, ivec2(id,0), 0);\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, float value) {\n    if (floor(fragCoord.x) == float(id))\n        col.r = value;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec3 value) {\n    if (floor(fragCoord.x) == float(id))\n        col.rgb = value.rgb;\n        \n    return col;\n}\nvec4 writeData(vec4 col, vec2 fragCoord, int id, vec4 value) {\n    if (floor(fragCoord.x) == float(id))\n        col = value;\n        \n    return col;\n}\nGameData readGameData(sampler2D tex, vec2 invRes) {\n\tGameData data;\n    \n    data.shipPos = readData3(tex, 0);\n    data.shipLastPos = readData3(tex, 1);\n    data.shipAccel = readData3(tex, 2);\n    data.shipVelocity = readData3(tex, 3);\n    data.shipTheta = readData1(tex, 4);\n    data.shipDirection = vec3(sin(data.shipTheta), 0.f, cos(data.shipTheta));\n    data.touchStart = readData3(tex, 5);\n    \n    return data;\n}\nvec4 writeGameData(vec4 col, vec2 fragCoord, GameData data) {\n    col = writeData(col, fragCoord.xy, 0, data.shipPos);\n    col = writeData(col, fragCoord.xy, 1, data.shipLastPos);\n    col = writeData(col, fragCoord.xy, 2, data.shipAccel);\n    col = writeData(col, fragCoord.xy, 3, data.shipVelocity);\n    col = writeData(col, fragCoord.xy, 4, data.shipTheta);\n    col = writeData(col, fragCoord.xy, 5, data.touchStart);\n    return col;\n}\n    \n\n// ---------------------------------------------\n// Math\n// ---------------------------------------------\nfloat hash( vec3 p )\n{\n    return fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123);\n}\n\nfloat hash( vec2 p )\n{\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\n\nfloat hash( float p ) \n{\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat hash2Interleaved( vec2 x )\n{\n    // between random & dithered pattern\n    // good for jittering and blur as well as blue noise :)\n    // http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\n    vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( x, magic.xy ) ) );\n}\nfloat noise( vec3 x )\n{\n\t// https://iquilezles.org/articles/gradientnoise\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nmat2 rotate( float t ) {\n    float a = cos(t);\n    float b = sin(t);\n    \n    return mat2( a, b, -b, a );\n}\nvec3 randomSphereDir( vec2 rnd )\n{\n    float s = rnd.x*PI*2.;\n    float t = rnd.y*2.-1.;\n    return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir( vec3 dir, float i )\n{\n    vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n    return v * sign(dot(v, dir));\n}\n\n// ---------------------------------------------\n// SDF Toolbox\n// ---------------------------------------------\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\nfloat caps( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec3 raymarch( vec3 ro, vec3 rd, const vec2 nf, const float eps ) {\n    glowAcc = vec2(999.);\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=0; i<128; i++) {\n\t\tfloat d = worldSafe(p);\n        l += d;\n        p += rd * d;\n        \n        if(d < eps || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\nvec3 raymarchFast( vec3 ro, vec3 rd, const vec2 nf, const float eps ) {\n    glowAcc = vec2(999.);\n    vec3 p = ro + rd * nf.x;\n    float l = 0.;\n    for(int i=0; i<64; i++) {\n\t\tfloat d = world(p);\n        l += d;\n        p += rd * d*1.2;\n        \n        if(d < eps || l > nf.y)\n            break;\n    }\n    \n    return p;\n}\n\nvec3 normal( vec3 p, const float eps ) {\n    float d = world(p);\n    vec2 e = vec2(eps, 0.);\n    \n    vec3 n;\n    \n    n.x = d - world(p-e.xyy);\n    n.y = d - world(p-e.yxy);\n    n.z = d - world(p-e.yyx);\n    \n    return normalize(n);\n}\nfloat ambientOcclusion( vec3 p, vec3 n, float maxDist, float falloff )\n{\n\tconst int nbIte = 8;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(world( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat shadow( vec3 ro, vec3 rd, float mint, float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = worldSafe( ro + rd*t );\n\t\tres = min( res, 80.0*h/t );\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadowFast( vec3 ro, vec3 rd, float mint, float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    \n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = world( ro + rd*t );\n\t\tres = min( res, 80.0*h/t );\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//Physic engine pass\n\nconst float G = 9.81;\n\nvoid simulation() {\n    \n    // keyboard input\n    const int KEY_LEFT  = 37;\n    const int KEY_UP    = 38;\n    const int KEY_RIGHT = 39;\n    const int KEY_DOWN  = 40;\n    const int KEY_W     = 87;\n    const int KEY_S     = 83;\n    \n    vec3 keyDir = vec3(0.);\n    keyDir.z += texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n    keyDir.z -= texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n    keyDir.y += texelFetch( iChannel1, ivec2(KEY_DOWN,0), 0 ).x;\n    keyDir.y -= texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x;\n    keyDir.x += texelFetch( iChannel1, ivec2(KEY_LEFT,0), 0 ).x;\n    keyDir.x -= texelFetch( iChannel1, ivec2(KEY_RIGHT,0), 0 ).x;\n    \n    // TODO : support iDeltaTime\n    float dt = 1. / 60.;\n    \n    \n    if (data.touchStart.z == 1.) {\n        keyDir.z += clamp((iMouse.y - data.touchStart.y)/10., -1., 1.);\n        keyDir.x -= clamp((iMouse.x - data.touchStart.x)/50., -1., 1.);\n    }\n    \n    // acceleration\n    data.shipAccel += keyDir * dt * vec3(15.,20.,20.);\n    data.shipAccel *= .8;\n    data.shipTheta -= data.shipAccel.x * dt *3.;\n\n    // velocity\n    data.shipVelocity += data.shipDirection * (data.shipAccel.z-data.shipAccel.y*.1)*120.;\n    data.shipVelocity.y += data.shipAccel.y*50.;\n    \n    // gravity\n    data.shipVelocity.y += -G*20.;\n    \n    // world feedback \n    float d = level(data.shipPos-vec3(0.,0.,-1.5)) - 1.5; // bounding sphere for free :))!\n    vec3 n = normalLevel(data.shipPos, 0.01);\n    data.shipVelocity += n*G / abs(exp(d)) * 50.;\n    data.shipVelocity.xyz *= .9;\n    \n    \n    // update position\n    data.shipLastPos = data.shipPos;\n    data.shipPos += data.shipVelocity * dt * dt;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invRes = vec2(1.)/ iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    // init global\n    time = iTime;\n    if (iFrame == 0) { \n        data.shipPos = vec3(50., 2., 5.);\n        data.shipAccel = vec3(0.);\n        data.shipVelocity = vec3(0.);\n        data.shipDirection = vec3(0., 0., 1.);\n        data.shipTheta = 0.;\n        data.touchStart = vec3(0.,0.,0.);\n    } else {\n        data = readGameData(iChannel0, invRes);\n    }\n    \n    // physic simulation\n    simulation();\n    \n    \n    // touch for shadertoy phone app\n    if (iMouse.z > 0. && data.touchStart.z == 0.) {\n        data.touchStart = iMouse.xyz;\n        data.touchStart.z = 1.;\n    } else if (iMouse.z <= 0.01) {\n        data.touchStart.z = 0.;\n    }\n    \n    // write game data\n    vec4 col = vec4(0.);\n    col = writeGameData(col, fragCoord.xy, data);\n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Raytracing pass\n\n// ---------------------------------------------\n// Shading\n// ---------------------------------------------\nvec3 tex3D( sampler2D tex, vec3 p, vec3 n )\n{\n    n = abs(n);\n\tvec4 col = texture(tex, p.yz)*n.x + texture(tex, p.xz)*n.y + texture(tex, p.xy)*n.z;\n    return pow(col.rgb,vec3(2.2));\n}\n// clever code taken from Shane\n// https://www.shadertoy.com/view/MscSDB\nvec3 bumpMapping( sampler2D tex, vec3 p, vec3 n, float bf )\n{\n    const vec2 e = vec2(0.001, 0);\n    \n    mat3 m = mat3( tex3D(tex, p - e.xyy, n).rgb,\n                   tex3D(tex, p - e.yxy, n).rgb,\n                   tex3D(tex, p - e.yyx, n).rgb);\n    \n    vec3 g = vec3(0.299, 0.587, 0.114) * m;\n    g = (g - dot( tex3D(tex,  p , n).rgb, vec3(0.299, 0.587, 0.114)) )/e.x;\n    g -= n * dot(n, g);\n                      \n    return normalize( n + g*bf );\n    \n}\nvec3 skyColor( vec3 rd )\n{\n    rd.y = max(rd.y+0.03, 0.02);\n\tconst float anisotropicIntensity = 0.03; \n\tconst float density = .3;\n    \n    \n    float l = length(rd - sunDir);\n    \n    vec3 col = vec3(0.39, 0.57, 1.0) * (1.0 + anisotropicIntensity);\n    \n\tfloat zenith = density / pow(max(rd.y, 0.35e-2), 0.75);\n    vec3 absorption = exp2(col * -zenith) * 2.;\n\tfloat rayleig = 1.0 + pow(1.0 - clamp(l, 0.0, 1.0), 2.0) * PI * 0.5;\n    \n    vec3 sun = vec3(1.,.3,.01) * smoothstep(0.03, 0.0, l) * 100.0;\n    sun += vec3(1.,.7,.5) * smoothstep(0.3, 0.0, l) * .5;\n    col = col * zenith * rayleig * absorption*.5 + sun;\n    col *= (vec3(.6,.7,.8)/sqrt(l)); //sun\n    //col = mix(col, FOGCOLOR, saturate((.06-rd.y)*50.));\n    return col*2.;\n}\n\n\nvoid getMaterial(in vec3 p, inout vec3 n, out float metalness,out vec3 albedo) {\n\n    if (level(p) < ship(p)) {\n    \tfloat rnd = hash(floor(p.xz*.01));\n        if (rnd>.4) {\n\t\t\talbedo = tex3D(iChannel2,p.xyz*.025,n)*vec3(.4,.6,1.)*2.;\n\t\t\tn = bumpMapping(iChannel2,p.xyz*.2,n,.05);\n\t\t\tmetalness = 0.;\n\t\t} else if(rnd>.2){\n\t\t\talbedo = tex3D(iChannel3,p.xyz*.002,n)*vec3(.3,.7,1.);\n\t\t\tn = bumpMapping(iChannel3,p.xyz*.15,n,.05);\n\t\t\tmetalness = 2.;\n        } else {\n\t\t\talbedo = tex3D(iChannel3,p.xyz*.03,n);\n\t\t\tn = bumpMapping(iChannel3,p.xyz*.2,n,.05);\n            metalness = .2;\n        }\n     } else {\n\t\talbedo = vec3(1.);\n        metalness = 1.;\n     }\n}\nvoid computeGlow(inout vec3 col, vec2 acc) {\n    col += vec3(.8,.3,1.) / pow(acc.y+.95,20.);\n    col += vec3(.8,.3,1.)*.3 / pow(acc.y+.95,3.);\n    \n    col += (vec3(1.,.2,.1) / pow(acc.x+.9,20.) +\n            vec3(1.,.2,.1) / pow(acc.x+.95,3.)*.5)* max(0.4,data.shipAccel.z);\n\n    \n}\nvec3 shadeFast( vec3 p, vec3 n, vec3 ro, vec3 rd )\n{\n    float d = length(p-ro);\n    vec3 sky = skyColor(rd);\n    vec3 col = sky;\n    \n    if (d < 100.)\n    {\n        vec3 albedo = vec3(.8);\n        float metalness = 0.;\n        getMaterial(p, n, metalness, albedo);\n        \n        float ao = ambientOcclusion(p,n, 10., 2.);\n        float shad = shadowFast(vec3(p), vec3(sunDir), float(0.5), float(80.));\n\t\tfloat fre = saturate(1.+dot(rd,n));\n        \n        vec3 amb = vec3(.5,.5,.5) * ao;\n        vec3 diff = vec3(1.,.7,.5) * max(0., dot(n, sunDir) ) * shad;\n                \n        col = albedo * ( diff*2. + amb );\n        \n        col = mix(col, skyColor(vec3(1.,.2,.1))*.25, 1.-exp(-length(p-ro)*.01));\n    }\n    computeGlow(col,glowAcc);\n    \n    return col;\n}\n\nvec3 shade( vec3 p, vec3 n, vec3 ro, vec3 rd )\n{\n    vec2 glowAccCopy = glowAcc; // copy since it will be reset by the reflection raymarch loop\n    float d = length(p-ro);\n    vec3 sky = skyColor(rd);\n    vec3 col = sky;\n    \n    if (d < 300.)\n    {\n        vec3 albedo = vec3(.8);\n        float metalness = 0.;\n        getMaterial(p, n, metalness, albedo);\n        \n        float ao = ambientOcclusion(p,n, 10., 2.)* ambientOcclusion(p,n, 1., .5);\n        float shad = shadow(vec3(p), vec3(sunDir), float(1.), float(80.));\n\t\tfloat fre = saturate(1.+dot(rd,n));\n        \n        vec3 amb = vec3(.5,.5,.5) * ao;\n        vec3 diff = vec3(1.,.7,.5) * max(0., dot(n, sunDir) ) * shad;\n        vec3 bnc = vec3(1.,.7,.4) * saturate(-n.y) * ao;\n        \n        \n        col = albedo * ( diff*2. + amb );\n        \n        vec3 refl;\n        {\n            vec3 rro = p+n*0.1;\n            vec3 rrd = reflect(rd,n);\n            vec3 rp = raymarchFast(rro,rrd, vec2(.1,100.), 0.001);\n            refl = shadeFast(rp, normal(rp, 0.01), rro, rrd);\n            if (ship(p)<level(p)) {\n                col = refl;\n            } else {\n\t\t\t\tcol += refl * pow(fre,5.)*metalness;\n            }\n        }\n        \n        col = mix(col, skyColor(vec3(1.,.2,.1))*.25, 1.-exp(-length(p-ro)*.01));\n    }\n    computeGlow(col,glowAccCopy);\n    \n    return col;\n}\n\n\n\n// ---------------------------------------------\n// Rendering\n// ---------------------------------------------\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{    \n    // coord setup\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    vec2 uv = fragCoord * invRes;\n    \n    // init\n    time = iTime;\n    data = readGameData(iChannel0, invRes);\n    \n    \n    // camera setup\n    vec2 v = -1.0+2.0*(uv);\n\tv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0., 1.3, 0.)+data.shipPos-data.shipDirection*3.;\n    vec3 rd = normalize( vec3(v, 1.45) );\n    rd.xy = rotate(data.shipAccel.x*.2) * rd.xy;\n    rd.xz = rotate(-data.shipTheta) * rd.xz;\n    \n    // sdf rendering\n    vec3 p = raymarch(ro, rd, vec2(2.,300.), 0.01);\n    vec3 n = normal(p, 0.001);\n    vec3 col = shade(p, n, ro, rd);\n    \n    // color + depth in the alpha channel\n    fragColor = vec4(col,length(p-ro));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by anatole duprat - XT95/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// God ray pass in half resolution\n\n\nfloat phaseFunction(float lightDotView)\n{\n    const float k = .8;\n\tfloat v = 1.0 - k * k;\n\tv /= (4.0 * PI * pow(1.0 + k * k - (2.0 * k)*lightDotView, 1.5));\n\treturn v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init global\n    vec2 invRes = vec2(1.) / iResolution.xy;\n    data = readGameData(iChannel0, invRes);\n    time = iTime;\n    \n    // early exit because we want half resolution\n    vec2 uv = fragCoord * invRes*2.;\n\tfloat l = texture(iChannel1, uv).a;\n    if(uv.x>1. || uv.y>1. )\n    {\n        fragColor = vec4(0.);\n        return;\n    } \n    \n    // camera ray\n    vec2 v = -1.0+2.0*(uv);\n\tv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0., 1.3, 0.)+data.shipPos-data.shipDirection*3.;\n    vec3 rd = normalize( vec3(v, 1.45) );\n    rd.xy = rotate(data.shipAccel.x*.2) * rd.xy;\n    rd.xz = rotate(-data.shipTheta) * rd.xz;\n    \n    float jitt = hash2Interleaved(gl_FragCoord.xy)*.2;\n    const float eps = 0.2;\n    \n    // acc shadow loop\n    float phase = phaseFunction(dot(sunDir,rd));\n    vec3 godray = vec3(0.);\n    for(float i=0.0; i<1.; i+=eps) {\n       vec3 p = ro+rd*l*(i+jitt);\n       float d = shadow(p, sunDir, float(.2), float(80.));\n       d += d*(texture(iChannel3, p*0.01+time*0.05).r*2.-1.);\n       d += d*(texture(iChannel3, p*0.02-time*0.02).r*2.-1.);\n       godray += d * phase;\n    }\n\tgodray = vec3(1.,.7,.5) * godray;\n        \n    \n    fragColor = vec4(godray,l);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}