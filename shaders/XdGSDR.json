{
    "Shader": {
        "info": {
            "date": "1463861944",
            "description": "Late 80s style barrel text scroller. Sort of like the sine scrollers but ray traced on a cylinder instead.",
            "flags": 32,
            "hasliked": 0,
            "id": "XdGSDR",
            "likes": 8,
            "name": "Late 80s Amiga 500 intro",
            "published": 3,
            "tags": [
                "scroller"
            ],
            "usePreview": 1,
            "username": "PompeyPaul",
            "viewed": 1261
        },
        "renderpass": [
            {
                "code": "// My 80s Amiga intro barrel roll shader\n// Twitter @PompeyPaulRoss\n\nconst float PI = 3.14159;\nconst float WRAPSPEED=0.4;\n\n// Star field\nconst int StarsPerLevel\t=\t40;\nconst int DepthLevel = 5;\n\n\n// Random function\nfloat rand(float i)\n{\n    return fract(sin(dot(vec2(i, i) ,vec2(32.9898,78.233))) * 43758.5453);\n}\n\n\nvoid CalcIntersectionUV(in vec3 IntersectPos, out vec2 UVIntersection)\n{\n    \n    // Projet so we know the angle around we are\n    vec3 Lever = vec3(0.0,IntersectPos.y,IntersectPos.z);\n    Lever = normalize(Lever);\n    float AngleAround = Lever.y;\n    AngleAround = acos(AngleAround)/PI;\n    \n    // If we're in the front\n    if(IntersectPos.z < 0.0)\n    {\n\t    UVIntersection = vec2(IntersectPos.x, 1.0 - (0.5 * AngleAround));\n    }\n    else\n    {\n\t    UVIntersection = vec2(IntersectPos.x, 0.5 * AngleAround);\n    }\n}\n\n\n// Intersect cylinder\nbool CylinderIntersect(in vec3 RayOrigin, in vec3 RayDirection, in float CylinderRadius,\n                       out vec2 FrontIntersection, out vec2 BackIntersection)\n{\n    // Calculate quadratic values\n    float ATerm= RayDirection.y*RayDirection.y + RayDirection.z * RayDirection.z;\n    float BTerm= 2.0*RayDirection.y*RayOrigin.y + 2.0*RayDirection.z*RayOrigin.z;\n    float CTerm= RayOrigin.y*RayOrigin.y + RayOrigin.z * RayOrigin.z - CylinderRadius*CylinderRadius;\n    \n    // Calculate if there is an intersection\n    if(BTerm*BTerm<4.0*ATerm*CTerm)\n    {\n        // No intersection so bail out\n        return false;\n    }\n    \n    // Calculate interscetion point\n    float IntersectionA = -BTerm + sqrt(BTerm*BTerm - 4.0 * ATerm * CTerm);\n    IntersectionA /= (2.0 * ATerm);\n    \n    float IntersectionB = -BTerm - sqrt(BTerm*BTerm - 4.0 * ATerm * CTerm);\n    IntersectionB /= (2.0 * ATerm);\n\n    // If IntersectionA is in front then calculate this\n    CalcIntersectionUV(RayOrigin + RayDirection * IntersectionA, BackIntersection);\n    CalcIntersectionUV(RayOrigin + RayDirection * IntersectionB, FrontIntersection);\n\n    // Intersects\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 ScrollerPixelColour;\n    \n    // Calculate ray trace locations\n\tvec3 ViewPlanePoint = vec3((2.0*fragCoord.xy-iResolution.xy) / iResolution.y,0.0);\n\tvec3 RayOrigin = vec3(0.0, 0.0, -5.1 );\n\tvec3 RayDirection = normalize((ViewPlanePoint - RayOrigin));\n    \n    // Intersect sphere\n    vec2 FrontIntersection,RearIntersection;\n    bool Intersects = CylinderIntersect(RayOrigin,RayDirection,0.5,\n                                        FrontIntersection, RearIntersection);\n   \n    if(Intersects)\n    {\n        float FrontMappedX = 0.5 + 0.2*FrontIntersection.x;\n        vec4 FrontPixel = texture( iChannel0, \n                                    fract(\n                                        vec2(FrontMappedX,\n                                             0.5*(fragCoord.x/iResolution.x) + \n                                             FrontIntersection.y + iTime*WRAPSPEED)));\n        \n        // make from pixel blue\n        FrontPixel *= vec4(0.0,0.0,1.0,0.0);\n        \n        float RearMappedX = 0.5 + 0.2*RearIntersection.x;\n        vec4 RearPixel = texture( iChannel0, \n                                   fract(\n                                       vec2(RearMappedX,\n                                            0.5*(fragCoord.x/iResolution.x) + \n                                            RearIntersection.y + iTime*WRAPSPEED)));\n        \n        // Make rear red\n        RearPixel *= vec4(0.0,0.0,0.5,0.0);\n\n        fragColor = FrontPixel + RearPixel;\n    }\n    else\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n    \n    // Draw star background\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n    for(int DepthCount=0;DepthCount<DepthLevel;DepthCount++)\n    {\n        float StarIntensity = 1.0 - (float(DepthCount) / float(DepthLevel));\n        \n        for(int Count=0;Count<StarsPerLevel;Count++)\n        {\n            // Calculate a star position\n            vec2 StarPos = vec2(fract(rand(float(DepthCount*Count)) - \n                                float((DepthLevel+1)-(DepthCount+1))*iTime*0.01),\n                                rand(float(DepthCount*(Count+1))));\n\n            // Is this us?\n            if(length(StarPos - uv)<float(DepthLevel+1-DepthCount)*0.00025)\n            {\n                fragColor += vec4(StarIntensity,StarIntensity,StarIntensity,StarIntensity);\n            }\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Simple Bitmap Text by Gerard Geer\n// \n// Essentially a \"hmm, how does that work?\" educational rewrite of P_Malin's text renderer:\n// https://www.shadertoy.com/view/4sBSWW\n// Each character is a 4x5 bitmap encoded into a float, where each hex digit convieniently\n// represents one row.\n// License: Creative Commons CC0 1.0 Universal (CC-0) \n\nconst float SCROLLSPEED = 0.2;\n\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n       \t  \t  CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n\t\t  \t  CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n\t\t  \t  CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n\t\t  \t  CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n\t\t  \t  CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n\t\t  \t  CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n\t\t  \t  CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n    \t  \t  CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x6bd96),\n\t\t  \t  CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n\t\t  \t  CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n\t\t  \t  CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n\t\t  \t  CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n\t\t  \t  CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n\t\t  \t  CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n\t\t  \t  CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n    \t  \t  CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n\t\t\t  CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442);\nconst lowp vec2 MAP_SIZE = vec2(4,5);\n#undef flt\n\n// Character spacing\nfloat CharacterWidth = 0.03;\nfloat CharacterHeight = 0.03;\nfloat CharacterStepping = 0.035;\n\n// Running totals\nvec2 CurrentRenderPos;\n\n/*\n\treturns the status of a bit in a bitmap. This is done value-wise, so\n\tthe exact representation of the float doesn't really matter.\n*/\nfloat getBit( in float map, in float index )\n{\n    // Ooh -index takes out that divide :)\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n/*\n\tDraws a character, given its encoded value, a position, size and\n\tcurrent [0..1] uv coordinate.\n*/\nfloat drawChar( in float char, in vec2 uv )\n{\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv-=CurrentRenderPos;\n    \n    // Update render pos\n    CurrentRenderPos.x += CharacterStepping;\n    \n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= vec2(CharacterWidth,CharacterHeight);    \n    \n    // Create a place to store the result.\n    float res;\n    \n    // Branchless bounding box check.\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    \n    // Go ahead and multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= MAP_SIZE;\n    \n    // Get the appropriate bit and return it.\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    return clamp(res,0.0,1.0);\n}\n\nfloat drawMultiChar(in float Chr, in float charA,in float charB, in float charC, in float charD, in vec2 uv)\n{\n    float ClampValue = Chr;\n    ClampValue += drawChar(charA,uv);\n    ClampValue += drawChar(charB,uv);\n    ClampValue += drawChar(charC,uv);\n    ClampValue += drawChar(charD,uv);\n    \n    return ClampValue;\n}\n\n\nfloat text( in vec2 uv )\n{\n    // and a starting position.\n    //CurrentRenderPos = vec2(0.0,0.5-CharacterHeight*0.5); \n    CurrentRenderPos = vec2(-iTime*SCROLLSPEED, 0.5-CharacterHeight*0.5);\n    \n    // Draw some text!\n    float chr = 0.0;\n    \n    // Bitmap text rendering!\n    for(int i=0;i<50;i++)\n    {\n        chr += drawChar(CH_BLNK,uv);\n    }\n    \n    chr += drawMultiChar(chr,CH_L,CH_A,CH_T,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_8,CH_0,CH_APST, uv);\n    chr += drawMultiChar(chr,CH_S,CH_BLNK,CH_E,CH_A, uv);\n    chr += drawMultiChar(chr,CH_R,CH_L,CH_Y,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_9,CH_0,CH_S,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_A,CH_M,CH_I,CH_G, uv);\n    chr += drawMultiChar(chr,CH_A,CH_BLNK,CH_I,CH_N, uv);\n    chr += drawMultiChar(chr,CH_T,CH_R,CH_O,CH_FSTP, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_BLNK,CH_M, uv);\n    chr += drawMultiChar(chr,CH_A,CH_D,CH_E,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_T,CH_H,CH_I,CH_S, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_A,CH_F,CH_T, uv);\n    chr += drawMultiChar(chr,CH_E,CH_R,CH_BLNK,CH_W, uv);\n    chr += drawMultiChar(chr,CH_A,CH_T,CH_C,CH_H, uv);\n    chr += drawMultiChar(chr,CH_I,CH_N,CH_G,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_QUOT,CH_F,CH_R,CH_O, uv);\n    chr += drawMultiChar(chr,CH_M,CH_BLNK,CH_B,CH_E, uv);\n    chr += drawMultiChar(chr,CH_D,CH_R,CH_O,CH_O, uv);\n    chr += drawMultiChar(chr,CH_M,CH_S,CH_BLNK,CH_T, uv);\n    chr += drawMultiChar(chr,CH_O,CH_BLNK,CH_B,CH_I, uv);\n    chr += drawMultiChar(chr,CH_L,CH_L,CH_I,CH_O, uv);\n    chr += drawMultiChar(chr,CH_N,CH_S,CH_BLNK,CH_HYPH, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_T,CH_H,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_A,CH_M,CH_I, uv);\n    chr += drawMultiChar(chr,CH_G,CH_A,CH_BLNK,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_E,CH_A,CH_R,CH_S, uv);\n    chr += drawMultiChar(chr,CH_QUOT,CH_FSTP,CH_BLNK,CH_I, uv);\n    chr += drawMultiChar(chr,CH_T,CH_BLNK,CH_R,CH_E, uv);\n    chr += drawMultiChar(chr,CH_M,CH_I,CH_N,CH_D, uv);\n    chr += drawMultiChar(chr,CH_E,CH_D,CH_BLNK,CH_M, uv);\n    chr += drawMultiChar(chr,CH_E,CH_BLNK,CH_O,CH_F, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_A,CH_BLNK,CH_D, uv);\n    chr += drawMultiChar(chr,CH_E,CH_M,CH_O,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_I,CH_BLNK,CH_C,CH_O, uv);\n    chr += drawMultiChar(chr,CH_D,CH_E,CH_D,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_A,CH_R,CH_O,CH_U, uv);\n    chr += drawMultiChar(chr,CH_N,CH_D,CH_BLNK,CH_APST, uv);\n    chr += drawMultiChar(chr,CH_9,CH_4,CH_BLNK,CH_B, uv);\n    chr += drawMultiChar(chr,CH_U,CH_T,CH_BLNK,CH_B, uv);\n    chr += drawMultiChar(chr,CH_A,CH_C,CH_K,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_T,CH_H,CH_E,CH_N, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_BLNK,CH_D, uv);\n    chr += drawMultiChar(chr,CH_I,CH_D,CH_N,CH_APST, uv);\n    chr += drawMultiChar(chr,CH_T,CH_BLNK,CH_H,CH_A, uv);\n    chr += drawMultiChar(chr,CH_V,CH_E,CH_BLNK,CH_T, uv);\n    chr += drawMultiChar(chr,CH_H,CH_E,CH_BLNK,CH_C, uv);\n    chr += drawMultiChar(chr,CH_P,CH_U,CH_BLNK,CH_T, uv);\n    chr += drawMultiChar(chr,CH_O,CH_BLNK,CH_R,CH_E, uv);\n    chr += drawMultiChar(chr,CH_A,CH_L,CH_BLNK,CH_T, uv);\n    chr += drawMultiChar(chr,CH_I,CH_M,CH_E,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_R,CH_A,CH_Y,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_T,CH_R,CH_A,CH_C, uv);\n    chr += drawMultiChar(chr,CH_E,CH_FSTP,CH_BLNK,CH_T, uv);\n    chr += drawMultiChar(chr,CH_O,CH_D,CH_A,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_BLNK,CH_D, uv);\n    chr += drawMultiChar(chr,CH_O,CH_EXCL,CH_BLNK,CH_G, uv);\n    chr += drawMultiChar(chr,CH_R,CH_E,CH_E,CH_T, uv);\n    chr += drawMultiChar(chr,CH_S,CH_BLNK,CH_T,CH_O, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_A,CH_N,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_B,CH_O,CH_D,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_W,CH_H,CH_O, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_P,CH_I,CH_C, uv);\n    chr += drawMultiChar(chr,CH_K,CH_E,CH_D,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_U,CH_P,CH_BLNK,CH_A, uv);\n    chr += drawMultiChar(chr,CH_N,CH_BLNK,CH_A,CH_S, uv);\n    chr += drawMultiChar(chr,CH_S,CH_E,CH_M,CH_B, uv);\n    chr += drawMultiChar(chr,CH_L,CH_E,CH_R,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_A,CH_N,CH_D,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_S,CH_Q,CH_U,CH_I, uv);\n    chr += drawMultiChar(chr,CH_R,CH_T,CH_E,CH_D, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_S,CH_O,CH_M, uv);\n    chr += drawMultiChar(chr,CH_E,CH_BLNK,CH_R,CH_E, uv);\n    chr += drawMultiChar(chr,CH_G,CH_I,CH_S,CH_T, uv);\n    chr += drawMultiChar(chr,CH_E,CH_R,CH_S,CH_COMM, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_T,CH_H,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_B,CH_L,CH_I, uv);\n    chr += drawMultiChar(chr,CH_T,CH_T,CH_E,CH_R, uv);\n    chr += drawMultiChar(chr,CH_COMM,CH_BLNK,CH_T,CH_H, uv);\n    chr += drawMultiChar(chr,CH_E,CH_BLNK,CH_M,CH_O, uv);\n    chr += drawMultiChar(chr,CH_T,CH_O,CH_R,CH_O, uv);\n    chr += drawMultiChar(chr,CH_L,CH_A,CH_BLNK,CH_6, uv);\n    chr += drawMultiChar(chr,CH_8,CH_K,CH_COMM,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_A,CH_N,CH_G,CH_U, uv);\n    chr += drawMultiChar(chr,CH_S,CH_COMM,CH_BLNK,CH_D, uv);\n    chr += drawMultiChar(chr,CH_E,CH_N,CH_I,CH_S, uv);\n    chr += drawMultiChar(chr,CH_E,CH_COMM,CH_BLNK,CH_P, uv);\n    chr += drawMultiChar(chr,CH_A,CH_U,CH_L,CH_A, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_BLNK,CH_S, uv);\n    chr += drawMultiChar(chr,CH_T,CH_I,CH_L,CH_L, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_L,CH_O,CH_V, uv);\n    chr += drawMultiChar(chr,CH_E,CH_BLNK,CH_Y,CH_A, uv);\n    chr += drawMultiChar(chr,CH_H,CH_EXCL,CH_BLNK,CH_M, uv);\n    chr += drawMultiChar(chr,CH_A,CH_Y,CH_B,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_BLNK,CH_S, uv);\n    chr += drawMultiChar(chr,CH_H,CH_O,CH_U,CH_L, uv);\n    chr += drawMultiChar(chr,CH_D,CH_BLNK,CH_B,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_D,CH_O,CH_I, uv);\n    chr += drawMultiChar(chr,CH_N,CH_G,CH_BLNK,CH_S, uv);\n    chr += drawMultiChar(chr,CH_O,CH_M,CH_E,CH_T, uv);\n    chr += drawMultiChar(chr,CH_H,CH_I,CH_N,CH_G, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_L,CH_E,CH_S, uv);\n    chr += drawMultiChar(chr,CH_S,CH_BLNK,CH_S,CH_A, uv);\n    chr += drawMultiChar(chr,CH_D,CH_BLNK,CH_O,CH_N, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_A,CH_BLNK,CH_S, uv);\n    chr += drawMultiChar(chr,CH_A,CH_T,CH_U,CH_R, uv);\n    chr += drawMultiChar(chr,CH_D,CH_A,CH_Y,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_N,CH_I,CH_G,CH_H, uv);\n    chr += drawMultiChar(chr,CH_T,CH_BLNK,CH_T,CH_H, uv);\n    chr += drawMultiChar(chr,CH_A,CH_N,CH_BLNK,CH_C, uv);\n    chr += drawMultiChar(chr,CH_O,CH_D,CH_I,CH_N, uv);\n    chr += drawMultiChar(chr,CH_G,CH_BLNK,CH_A,CH_M, uv);\n    chr += drawMultiChar(chr,CH_I,CH_G,CH_A,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_I,CH_N,CH_T,CH_R, uv);\n    chr += drawMultiChar(chr,CH_O,CH_S,CH_BLNK,CH_O, uv);\n    chr += drawMultiChar(chr,CH_N,CH_BLNK,CH_S,CH_H, uv);\n    chr += drawMultiChar(chr,CH_A,CH_D,CH_E,CH_R, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_T,CH_O,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_FSTP,CH_BLNK,CH_I,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_S,CH_H,CH_O,CH_U, uv);\n    chr += drawMultiChar(chr,CH_L,CH_D,CH_BLNK,CH_W, uv);\n    chr += drawMultiChar(chr,CH_O,CH_R,CH_K,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_O,CH_U,CH_T,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_H,CH_O,CH_W,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_T,CH_O,CH_BLNK,CH_L, uv);\n    chr += drawMultiChar(chr,CH_O,CH_O,CH_P,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_T,CH_H,CH_E,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_S,CH_C,CH_R,CH_O, uv);\n    chr += drawMultiChar(chr,CH_L,CH_L,CH_E,CH_R, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_B,CH_U,CH_T, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_I,CH_T,CH_APST, uv);\n    chr += drawMultiChar(chr,CH_S,CH_BLNK,CH_T,CH_I, uv);\n    chr += drawMultiChar(chr,CH_M,CH_E,CH_BLNK,CH_F, uv);\n    chr += drawMultiChar(chr,CH_O,CH_R,CH_BLNK,CH_A, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_B,CH_E,CH_E, uv);\n    chr += drawMultiChar(chr,CH_R,CH_FSTP,CH_BLNK,CH_E, uv);\n    chr += drawMultiChar(chr,CH_N,CH_J,CH_O,CH_Y, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_T,CH_H,CH_E, uv);\n    chr += drawMultiChar(chr,CH_BLNK,CH_P,CH_R,CH_I, uv);\n    chr += drawMultiChar(chr,CH_D,CH_D,CH_Y,CH_BLNK, uv);\n    chr += drawMultiChar(chr,CH_S,CH_T,CH_A,CH_R, uv);\n    \n    return chr;\n}\n\n/*\n\tShadertoy's fancy entry function.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get normalized UV coords.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n    // Draw some text!\n    float txt = text(uv);\n    \n    if(txt>1.0)\n    {\n        txt = 1.0;\n    }\n    \n\tfragColor = vec4(txt,txt,txt,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}