{
    "Shader": {
        "info": {
            "date": "1578344200",
            "description": "Yet another 10print stuff..\nWith all those fancy light maths and bitmap rendering.\n(Best enjoyed with Earthbound music)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlyGRh",
            "likes": 7,
            "name": "42PRINT",
            "published": 3,
            "tags": [
                "10print"
            ],
            "usePreview": 0,
            "username": "zikbakguru",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "#define HEXRGB(hex) vec3(float((hex & 0xff0000) >> 16) / 255.0, float((hex & 0x00ff00) >> 8) / 255.0, float(hex & 0x0000ff) / 255.0)\n\n// Declare sprite data\nconst int[] sprHead =\n    int[](\n        0xF9, 0xFF, 0xFF, 0xBF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0x3F, 0xF0, \n        0xF, 0xFC, 0xFF, 0xF3, \n        0xFF, 0xFC, 0xD7, 0xF3, \n        0xFF, 0xFC, 0xFF, 0xFF, \n        0xFF, 0xF, 0x0, 0xF8, \n        0xFF, 0x7F, 0x0, 0xFC, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFD, 0xFF, 0xFF, 0xBF, \n        0x0, 0x0, 0x0, 0x0\n    );\n\nconst int[] sprBody1 =\n    int[]\n    (\n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x15, 0xAA, 0x4A, 0x55, \n        0xA5, 0xAA, 0x6A, 0x55, \n        0xA1, 0xA8, 0x2A, 0x55, \n        0x28, 0xA8, 0x2A, 0x55, \n        0x68, 0xA8, 0x2A, 0x7E, \n        0x7F, 0xA8, 0x2A, 0x6E, \n        0x6F, 0xA9, 0x2A, 0x40, \n        0x40, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55, \n        0x55, 0x55, 0x55, 0x55\n    );\n\nconst int[] sprBody2 =\n    int[]\n    (\n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0xAB, 0xEA, 0xFF, \n        0xFF, 0x54, 0x15, 0xFF, \n        0x7F, 0x55, 0x55, 0xFC, \n        0x4F, 0x1, 0x40, 0xFD, \n        0x4F, 0xFC, 0xF, 0xF5, \n        0xF, 0xFC, 0x3F, 0xC0, \n        0x57, 0xFC, 0x3F, 0x50\n    );\n\nfloat sampleSpriteHead (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 16.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprHead[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody1 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody1[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat sampleSpriteBody2 (vec2 uv)\n{\n    vec2 fracuv = fract(uv);\n    int x = int(fracuv.x * 16.0);\n    int y = int(fracuv.y * 20.0);\n    \n    // 16 idx data per row, 1 element & 4 index per 1 element...\n    // => 4 element per row\n    int indexperelement = 4;\n    int elementperrow = 4;\n    int bitsperindex = 2;\n    int arrayidx = y * elementperrow + x / indexperelement;\n    int idx = x % indexperelement;\n    int bitoffset = (idx) * bitsperindex;\n    int mask = 3 << bitoffset;\n    int bits = (sprBody2[arrayidx] & mask) >> bitoffset; // test\n\n    float value = float(bits) / 3.0;\n    return (value);\n}\n\nfloat getrectmix (vec2 uv, vec2 sz)\n{\n    float val = 0.0;\n    vec2 rectsz = (vec2(0.5) - sz * 0.5);\n    vec2 rect = step(rectsz, uv);\n    val = rect.x * rect.y;\n    \n    rect = step(rectsz, vec2(1.0) - uv);\n    val *= rect.x * rect.y;\n    return val;\n}\n\nvec3 mixSpriteHead (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteHead(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody1 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody1(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0 / 3.0; // discard if image idx == 1\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\nvec3 mixSpriteBody2 (vec3 orig, vec2 uv)\n{\n    vec3 colour = orig;\n    float spr = sampleSpriteBody2(uv * 1.0);\n    \n    vec2 sprUVDelta = step(abs(uv - vec2(0.5, -0.5)), vec2(0.5));\n    float sprMix = sprUVDelta.x * sprUVDelta.y;\n    \n    float discardMask = 1.0; // discard if image idx == 3\n    if (spr == discardMask)\n        sprMix = 0.0;\n    \n    colour = mix(colour, vec3(spr), sprMix);\n    return colour;\n}\n\n// Noise functions from\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// HSV -> RGB routine from\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat samplenaejang (vec3 uv, float time)\n{\n    // prevent floating point error\n    // time = mod(time, 6.285);\n    \n    // apply wobble\n    vec2 wobblyUV = vec2(uv.x, uv.y);\n    wobblyUV.x += sin(uv.y * 10.0 + mod(time * 0.82, 6.28) + cos(uv.x * 2.5 + time * 0.5) * 0.15) * 0.065;\n    wobblyUV.y += cos(uv.x * 14.2 + mod(time * 0.75, 6.28) + sin(uv.y * 1.5 + time * 0.6) * 0.2) * 0.065;\n    \n    // calculate 10PRINT\n    vec2 uvMult = wobblyUV * 8.0;\n   \tvec2 uvChunky = floor(uvMult) / 8.0;\n    vec2 uvChunkyLocal = fract(uvMult);\n    float chunkFlip = sign(floor(noise(uvChunky * 10.0) + 0.5) - 0.5);\n    \n    vec2 gridDelta = fract(vec2(uvChunkyLocal.x * chunkFlip, uvChunkyLocal.y)) - 0.5;\n    float dist1 = min(distance(vec2(0.5), gridDelta), distance(vec2(0.5), -gridDelta));\n    float dist2 = abs(0.5 - dist1);\n    float thiccness = 0.8 + pow(sin(time), 3.0) * 0.4;\n    float shape = dist2 * thiccness;//smoothstep(0.3, 0.75, dist2 * thiccness);\n    \n    return clamp((1.0 - shape) - uv.z, 0.0, 1.0);\n}\n\nvec3 getnaejangnormal (vec2 uv, float time)\n{\n    vec3 normal;\n    vec2 smol = vec2(0.00001, 0.0);\n    vec3 uv3D = vec3(uv, 0.0);\n    \n    // calculate normal via central whatever method\n    normal.x = (samplenaejang(uv3D - smol.xyy, time) - samplenaejang(uv3D + smol.xyy, time));\n    normal.y = (samplenaejang(uv3D - smol.yxy, time) - samplenaejang(uv3D + smol.yxy, time));\n    normal.z = 2.0 * smol.x;\n    return normalize(normal);\n}\n\nvec3 samplerectBG (vec2 absuv, vec2 rectUV, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 colourRect;\n    \n    // Prepare rect properties\n    const float rectScrollPower = 3.0;\n    vec2 rectUVOffset = vec2(pow(sin(time * 0.5), rectScrollPower) * 1.0, pow(cos(time * 0.25), rectScrollPower) * 4.0);\n    rectUV += rectUVOffset; // / (rectHalfSize * 2.0);\n\n    // Foreground : 10PRINT\n    float naejangSDF = samplenaejang(vec3(rectUV, 0.0), time);\n    vec3 naejangNormal = getnaejangnormal(rectUV, time); // vec3(clamp(getnaejangnormal(rectUV, time), -1.0, 1.0), 0.5);\n\tfloat naejangCenterMix = pow(1.0 - pow(1.0 - naejangSDF, 1.0), 4.0);//smoothstep(0.0, 0.75, naejangSDF - 0.1);\n    naejangNormal.xy = mix(naejangNormal.xy, vec2(0.0), naejangCenterMix);\n    naejangNormal.z = 1.0;//mix(0.0, 1.0, naejangCenterMix);\n    \n    // Calculate light\n    vec3 viewVector = vec3(0.0, 0.0, 1.0);\n    float lightTime = mod(time * 2.0, 6.254);\n    vec3 lightPos = vec3(uvsizeHalf + vec2(cos(lightTime), sin(lightTime)) * (uvsizeHalf * 0.75), 1.0);\n    vec3 lightDelta = lightPos - vec3(absuv, 0.05 + naejangSDF * 0.35);\n    vec3 lightDir = normalize(lightDelta);\n    float lightDist = length(lightDelta);\n    \n    // 1] albedo\n    vec3 plasmacolour1 = hsv2rgb(vec3(fract(time * 0.2), 0.5, 1.0));\n    vec3 plasmacolour2 = hsv2rgb(vec3(fract(1.0 - time * 0.2), 1.0, 0.5));\n    \n    vec3 diffuse = mix(plasmacolour2, plasmacolour1, naejangCenterMix);\n    //colourRect = diffuse;\n    \n    // 2] lambert\n    float lightAmbient = 0.5;\n    float lightDot = dot(naejangNormal, lightDir);\n    float lightDistRange = smoothstep(0.3, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float lightLit = clamp((lightDot * lightDistRange + lightAmbient), 0.0, 1.0);\n    colourRect = diffuse * lightLit;\n    \n    // 3] Blinn-phong specular reflection\n    vec3 phongH = normalize(lightDelta + viewVector);\n    float phongDistRange = naejangCenterMix * smoothstep(0.5, 0.7, clamp(1.0 / (lightDist * lightDist * 4.0), 0.0, 1.0));\n    float phongDot = dot(naejangNormal, phongH);\n    float phongClamped = clamp(phongDot, 0.0, 1.0);\n    float phong = pow(phongClamped, 800.0);\n    \n    colourRect += vec3(phong * phongDistRange);\n    \n    return colourRect;\n}\n\nvec3 samplescene (vec2 uv, float time)\n{\n    vec2 uvsize = (iResolution.xy / iResolution.x);\n    vec2 uvsizeHalf = uvsize * 0.5;\n    vec3 final = vec3(0.0);\n    \n    // Prepare rect properties\n    vec2 rectHalfSize = vec2(0.4, 0.225);\n    const float rectUVScale = 1.5;\n    vec2 rectUV = (uv - (uvsizeHalf - rectHalfSize)) * rectUVScale;\n    \n    // Downscale the rectangle's resolution\n    const float crunchfactor = 64.0;\n    vec2 uvcrunchy = floor(rectUV * crunchfactor) / crunchfactor;\n    vec2 uvcrunchylocal = fract(rectUV * crunchfactor);\n    \n    // Commodore colours\n    vec3 colourBG = HEXRGB(0x887ecb);\n    vec3 colourRect = HEXRGB(0x50459b);\n    \n    // Background C64 loading screen-like raster bars\n    float rasterScale = 15.0;\n    float rasterOff = time * 0.5;\n    float rasterMix = floor(fract((uv.y + rasterOff) * rasterScale + (uv.x * sin(time * 3.0)) * 0.5) + 0.5);\n    const vec3 colours[3] = vec3[3](HEXRGB(0x6abfc6), HEXRGB(0xa1683c), HEXRGB(0x9ae29b));\n    \n    colourBG = mix(colours[int(time) % 3], HEXRGB(0xadadad), rasterMix);\n    \n    // Foreground : 10PRINT\n    const float uvdownscaleFactor = 64.0;\n    vec2 uvdownscale = (rectUV * uvdownscaleFactor + 0.5);\n    vec2 uvdownscaleLocal = fract(uvdownscale);\n    uvdownscale = floor(uvdownscale) / uvdownscaleFactor;\n    \n    vec3 rectBG = samplerectBG(uv, uvdownscale, time);\n    float rectBGLuma = clamp(dot(rectBG, rectBG), 0.0, 1.0);\n    \n    // apply LED light effect to foreground's 10PRINT BG(??)\n    float ledDiscRadius = 0.25 * rectBGLuma + 0.20;\n    const float ledDiscRadiusSmooth = 0.1;\n    float ledDiscDelta = distance(vec2(0.5), uvdownscaleLocal);\n    float ledDiscMix = smoothstep(ledDiscRadius + ledDiscRadiusSmooth, ledDiscRadius, ledDiscDelta);\n    colourRect = mix(rectBG * 0.5, rectBG, ledDiscMix);\n    colourRect = clamp(colourRect + pow(1.0 - ledDiscDelta, 2.0) * 0.2, 0.0, 1.0);\n\n    // Foreground : Sprites\n    vec2 sprUV;\n    float sprAnimTime = time * 2.0;\n    float sprRot = sin(sprAnimTime);\n    float sprScale = 8.0;\n    vec2 sprOff = vec2(sin(time * 0.5 + cos(time * 0.1) * 0.01) * 0.05, cos(time * 0.5) * 0.025 + sin(time * 0.1) * 0.01);\n    \n    // body\n    float rot = radians(pow(sprRot, 4.0) * 12.0 * 0.1);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.6;\n    colourRect = mixSpriteBody2(colourRect, sprUV);\n    \n    // body\n    rot = radians(pow(sprRot, 3.0) * 12.0 * 0.3);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    //sprUV.y -= 0.75;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += -0.65 + sin(sprAnimTime * 2.0) * 0.05;\n    colourRect = mixSpriteBody1(colourRect, sprUV);\n    \n    // head\n    rot = radians(sprRot * 12.0 * -0.5);\n    sprUV = (vec2(uv.x, uv.y) - uvsizeHalf + sprOff) * sprScale;\n    sprUV *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    sprUV += 0.5;\n    sprUV.y *= -1.0;\n    sprUV.y += sin(sprAnimTime * 2.0) * 0.1;\n    colourRect = mixSpriteHead(colourRect, sprUV);\n    \n    // debug light\n    //float lightCircleMix = smoothstep(0.01, -0.01, length(lightDelta.xy) - 0.01);\n    //colourRect = mix(colourRect, vec3(0.0, 1.0, 1.0), lightCircleMix);\n    \n    // Draw commodore 64-esque screen\n    // shadow\n    vec2 centerDelta = uvsizeHalf - uv + vec2(0.025, -0.025);\n    float rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    float rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    vec3 rect = mix(colourBG, colourBG * vec3(0.5), rectfactor);\n    \n    // screen\n    centerDelta = uvsizeHalf - uv;\n    rectMinDelta = max(abs(centerDelta.x) - rectHalfSize.x, abs(centerDelta.y) - rectHalfSize.y);\n    rectfactor = 1.0 - ceil(max(rectMinDelta, 0.0));\n    rect = mix(rect, colourRect, rectfactor);\n    \n\treturn rect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvratio = (iResolution.xy / iResolution.x);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvPixelperfect = fragCoord/iResolution.xy * uvratio;\n\n    // Uh yeah woo yeah woo hoo\n    vec3 col = samplescene(uvPixelperfect, iTime);\n    \n    // Test : sprite\n    // vec3 col = vec3(sampleSpriteHead(vec2(uv.x, 1.0 - uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}