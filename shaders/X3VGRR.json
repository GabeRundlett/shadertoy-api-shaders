{
    "Shader": {
        "info": {
            "date": "1722688054",
            "description": "this is a proof of concept for an algo to get a pretty accurate SDF of SOME TREES, NOT ALL OF THEM.\ni know it's not a pretty shader, it hasn't been optimized in the slightest and there's a bunch of useless stuff scattered all over the place",
            "flags": 0,
            "hasliked": 0,
            "id": "X3VGRR",
            "likes": 4,
            "name": "proof of concept tree SDF",
            "published": 3,
            "tags": [
                "2d",
                "fractal",
                "sdf",
                "tree"
            ],
            "usePreview": 0,
            "username": "dottedboxguy",
            "viewed": 284
        },
        "renderpass": [
            {
                "code": "//the red highlighted segments are all the segments that are computed for a sample point at the mouse's position\n\n#define PI 3.14159265359\n#define HALFPI 1.57079632679\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\nfloat sdRoundCone(vec2 p, vec2 a, vec2 b, float r1, float r2){ // from tdXGWr, only converted to 2D\n    // sampling independent computations (only depend on shape)\n    vec2 ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec2 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 circle(in float angle, in float r){\n    float t = angle*PI;\n    return r*vec2(cos(t), sin(t));\n}\n\n\nfloat nextBranchAngle(in float angle_range, in float branch_count,  //these should be constant over a tree\n                in float branch_id, in float last_branch_orientation){\n    return last_branch_orientation+angle_range-(2.*angle_range*branch_id/(branch_count-1.));\n}\n\n\nfloat sdTree(in vec2 p, in int dep){\n\n    const float branch_count = 2.;\n    const int brnch_count = 2;\n    float angle_range = cos(iTime/2.);\n    const float thickness = .2;\n    float initial_d = length(p); // (; https://www.youtube.com/watch?v=dv13gl0a-FA\n    \n    float depth = 1.;\n    float branch = 1.;\n\n    float d = initial_d - thickness;\n    vec2 current_pos = vec2(0.);\n    float current_orientation = .5;\n    \n    vec2 working_pos = vec2(0.);\n    float working_orientation = .0;\n    float working_d = 0.;\n    \n    vec2 chosen_pos = current_pos;\n    float chosen_orientation = .5;\n    float chosen_d = 0.;\n    \n    for (int dep_i = 0;dep_i<dep;dep_i++){\n        chosen_orientation = nextBranchAngle(angle_range, branch_count, 0., current_orientation);\n        chosen_pos = current_pos + circle(chosen_orientation, 1./(depth));\n        chosen_d = sdRoundCone(p, chosen_pos, current_pos + circle(chosen_orientation, .1/(depth)), thickness/(depth+.9), thickness/depth);\n        //chosen_d = sdSegment(p, chosen_pos, current_pos + circle(chosen_orientation, .1/(depth))) - thickness/depth;\n        //chosen_d = length(p - chosen_pos) - thickness/depth;\n        \n        for(int brnch = 1; brnch<=brnch_count-1;brnch++){\n            \n            working_orientation = nextBranchAngle(angle_range, branch_count, branch, current_orientation);\n            working_pos = current_pos + circle(working_orientation, 1./(depth));\n            working_d = sdRoundCone(p, working_pos, current_pos + circle(working_orientation, .1/(depth)), thickness/(depth+.9), thickness/depth);\n            //working_d = sdSegment(p, working_pos, current_pos + circle(working_orientation, .1/(depth))) - thickness/depth;\n            //working_d = length(p - working_pos) - thickness/depth;\n            \n            \n            if (working_d < chosen_d){\n                chosen_orientation = working_orientation;\n                chosen_pos = working_pos;\n                chosen_d = working_d;\n            }\n            \n            branch++;\n        }\n        \n        \n        d = min(d,chosen_d);\n        current_pos = chosen_pos;\n        current_orientation = chosen_orientation;\n        \n        chosen_d = initial_d;\n        branch = 1.;\n        depth++;\n    }\n    \n    return d;\n}\n\n// a quick and dirty modified version to show how the algo works\nfloat sdAttractedTree(in vec2 p, in vec2 attractor, in int dep){ \n\n    const float branch_count = 2.;\n    const int brnch_count = 2;\n    float angle_range = cos(iTime/2.);\n    const float thickness = .2;\n    float initial_d = length(attractor); // (; https://www.youtube.com/watch?v=dv13gl0a-FA\n    \n    float depth = 1.;\n    float branch = 1.;\n\n    float d = initial_d - thickness;\n    vec2 current_pos = vec2(0.);\n    float current_orientation = .5;\n    \n    vec2 working_pos = vec2(0.);\n    float working_orientation = .0;\n    float working_d = 0.;\n    \n    vec2 chosen_pos = current_pos;\n    float chosen_orientation = .5;\n    float chosen_d = 0.;\n    \n    \n    float real_d = initial_d;\n    float attractor_d = real_d;\n    \n    for (int dep_i = 0;dep_i<dep;dep_i++){\n        chosen_orientation = nextBranchAngle(angle_range, branch_count, 0., current_orientation);\n        chosen_pos = current_pos + circle(chosen_orientation, 1./(depth));\n        chosen_d = sdRoundCone(p, chosen_pos, current_pos + circle(chosen_orientation, .1/(depth)), thickness/(depth+.9), thickness/depth);\n        attractor_d = sdSegment(attractor, chosen_pos, current_pos + circle(chosen_orientation, .1/(depth)));\n        real_d = min(real_d, attractor_d);\n        //chosen_d = sdSegment(p, chosen_pos, current_pos + circle(chosen_orientation, .1/(depth))) - thickness/depth;\n        //chosen_d = length(p - chosen_pos) - thickness/depth;\n        \n        for(int brnch = 1; brnch<=brnch_count-1;brnch++){\n            \n            working_orientation = nextBranchAngle(angle_range, branch_count, branch, current_orientation);\n            working_pos = current_pos + circle(working_orientation, 1./(depth));\n            working_d = sdRoundCone(p, working_pos, current_pos + circle(working_orientation, .1/(depth)), thickness/(depth+.9), thickness/depth);\n            \n            attractor_d = sdSegment(attractor, working_pos, current_pos + circle(working_orientation, .1/(depth)));\n            real_d = min(real_d, attractor_d);\n            //working_d = sdSegment(p, working_pos, current_pos + circle(working_orientation, .1/(depth))) - thickness/depth;\n            //working_d = length(p - working_pos) - thickness/depth;\n            \n            \n            if (working_d < chosen_d){\n                chosen_orientation = working_orientation;\n                chosen_pos = working_pos;\n                chosen_d = working_d;\n            }\n            \n            branch++;\n        }\n        \n        \n        d = min(d,chosen_d);\n        current_pos = chosen_pos;\n        current_orientation = chosen_orientation;\n        \n        chosen_d = initial_d;\n        branch = 1.;\n        depth++;\n    }\n    \n    return real_d;\n}\n\n\nvec4 scene(in vec2 p){\n\n\n    float d = sdTree(p-vec2(0., -1.), 20);\n    \n    //coloring taken from iq\n    vec3 color = vec3(0.);\n    float px = 2./iResolution.y;\n    color = (d>0.0) ? vec3(.9,.6,.3) : vec3(.65,.85,1.);\n    color *= 1. - exp2(-24.*abs(d));\n    color *= .8 + .2*cos(120.*abs(d));\n    color = mix(color, vec3(1.), 1.-smoothstep(-px,px,abs(d)-0.005));\n    \n    \n    return vec4(color, d);\n}\n\nfloat preview_scene(in vec2 p, in vec2 m){\n    return sdAttractedTree(p-vec2(0., -1.), m-vec2(0., -1.), 20);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.xy;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 m = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n    m.y *= iResolution.y/iResolution.x;\n    m.x *= iResolution.y/iResolution.x;\n    \n    //vec2 offset = -m;\n    vec2 offset = vec2(0.);\n    vec2 scale = vec2(10.);\n    \n    vec4 s = scene((uv + offset) * scale);\n    \n    vec3 col = s.xyz;\n    \n    \n    // distance from pointer\n    float d = scene((m + offset) * scale).w;\n    d = sdCircle((uv-m+offset)*scale, abs(d));\n    if (d<0.01 && d>0.){col = vec3(0.);}\n    \n    float preview_d = preview_scene((m + offset) * scale, (uv + offset) * scale);\n    if (preview_d<0.01 && preview_d>0.){col = vec3(1., 0., 0.);}\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}