{
    "Shader": {
        "info": {
            "date": "1636064835",
            "description": "shear brick",
            "flags": 0,
            "hasliked": 0,
            "id": "st33D8",
            "likes": 3,
            "name": "shear brick",
            "published": 3,
            "tags": [
                "2d",
                "brick",
                "shear"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "///shear brick\n///por jorge2017a2...2021-nov-04\n///referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.05),b,d)\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n\n\nvec2 ShearX(float sh, vec2 p) \n{\n    mat2 shm= mat2(\n        1.0, sh, // column 1\n        0.0, 1.0     // column 2\n    );\n    \n    return shm*p;\n}\n\nvec2 ShearY(float sh, vec2 p) \n{   mat2 shm= mat2(\n        1.0, 0.0, // column 1\n       sh, 1.0     // column 2\n    );\n    \n    return shm*p;\n}\n\n\n///---------------------------\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.05,0.0));\n  return colOut;\n}\n\nvec3 DrawFig(vec3 pColObj, vec3 colOut, float distObj )\n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0)); return colOut;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{  vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{  vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 ParedDif(float dist, vec2 p, vec3 col, vec3 col1,vec3 col2)\n{\n    float d1=dist;\n    vec2 p1, p2;\n    p1=p;\n    p2=p-vec2(0.7,0.6);\n    float alto=1.2;\n    float ancho=1.2;\n    p1.x= opRep1D(p1.x, ancho);\n    p1.y= opRep1D(p1.y, alto);\n    p2.x= opRep1D(p2.x, ancho);\n    p2.y= opRep1D(p2.y, alto);\n    \n    float d2=sdBox(p1, vec2(0.5,0.23) );\n    float d3=sdBox(p2, vec2(0.5,0.23) );\n    float dif=differenceSDF(d1,d2);\n     dif=differenceSDF(dif,d3);\n    col= DrawFig(col1, col, d1);\n    col= DrawFig(col2, col, dif);\n    return col;\n}\n\n\nvec3 cuarto(vec2 p, vec3 col)\n{\n    float wi, he,sk;\n    wi=0.7;\n    he=0.7;\n    sk=0.5;\n    \n    float d1=sdParallelogram( p.yx,  wi, he,sk );\n\n    \n    float d2=sdBox(p-vec2(1.4,0.5), vec2(0.7,0.7) );\n    float d3=sdParallelogram( vec2(-p.y, p.x)-vec2(0.0,2.8),  wi, he,sk );\n      vec2 p1=p*5.0;\n       p1= ShearX(0.7, vec2(-p1.x,p1.y));\n    col=ParedDif(d1,p1, col, VERDE3,NEGRO);\n    \n    \n    \n    vec2 p2=p*5.0;\n       p2= ShearX(0.7, p2);\n     col=ParedDif(d3,p2, col, VERDE3,NEGRO);\n    \n    \n    ///pared frente\n    float dPuerta=sdBox(p-vec2(1.4,0.3), vec2(0.3,0.5) );\n    d2=differenceSDF(d2,dPuerta);\n    col=ParedDif(d2,p*5.4+vec2(0.5,0.1),col, VERDE2,NEGRO);\n   \n    \n    float r1, r2;\n    r1=1.83;\n    r2=0.7;\n    he=0.4; \n    float d4= sdTrapezoid( p-vec2(1.4,-0.6),r1, r2,he );\n    \n    vec2 p3=p*3.5;\n       p3+= rotatev2(p3, radians(290.0));\n     \n      p3= ShearY(0.7, p3);\n    col=ParedDif(d4,p3, col, CAFE2,NEGRO);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    //vec3  col=vec3(0.45,0.7,1.0)-uv.y*0.45;\n    vec3  col=vec3(0.0);\n    \n    float zoom = fract(iTime * 0.3);\n    vec2 offset = vec2(-0.5, 0.5);\n\tfloat scale = 3.5;\n\tvec2 pan = offset * zoom;\n\n\tfloat fullA = 0.5;\n\tmat2 fullRot = mat2(cos(fullA), sin(fullA), -sin(fullA), cos(fullA));\n    \n\tfloat a = -fullA * zoom;\n\tmat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n\tvec2 pos = (uv - offset) * exp(-zoom * scale) * rot + offset;\n\n\tvec3 col1 = vec3(0.0);\n    //vec3  col1=vec3(0.45,0.7,1.0)-uv.y*0.45;\n\tcol1=cuarto(pos-vec2(-1.5,0.0),col1);\n    \n\tvec3 col2 = vec3(0.0);\n\tcol2=cuarto((pos - offset) * exp(scale) * fullRot + offset, col2);\n\tcol = mix(col1, col2, zoom);\t\n\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec3 CAFE0=vec3(90,39,41)/255.;\nconst vec3 CAFE1=vec3(118,57,49)/255.;\nconst vec3 VERDE0=vec3(0.1,0.35,0.35);\nconst vec3 VERDE1=vec3(0.0,0.4,0.4);\nconst vec3 VERDE2=vec3(0.0,0.5,0.5);\nconst vec3 VERDE3=vec3(30,122,144)/255.0;\nconst vec3 VERDE4=vec3(9,87,87)/255.;\nconst vec3 CALLE1=vec3(1,74,74)/255.0;\nconst vec3 CAFE2=vec3(128,77,77)/255.0;\nconst vec3 CAFE3=vec3(99,67,56)/255.0;\nconst vec3 FVENTANA=vec3(150,141,141)/255.0;\nconst vec3 FVENTANA2=vec3(164,173,106)/255.0;\nconst vec3 VERDE5=vec3(2,73,73)/255.0;\nconst vec3 NEGRO=vec3(0,0,2)/255.0;\nconst vec3 TECHO1=vec3(33,99,123)/255.0;\nconst vec3 VERDE5P=vec3(16,132,9)/255.0;\nconst vec3 VERDE6P=vec3(3,80,24)/255.0;\nconst vec3 CASA5=vec3(92,90,107)/255.0;\nconst vec3 CASA4=vec3(69,66,66)/255.0;\nconst vec3 CASA5A=vec3(90,82,82)/255.0;\nconst vec3 CASA5B=vec3(140,114,114)/255.0;\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}