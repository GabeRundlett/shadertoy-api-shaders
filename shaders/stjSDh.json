{
    "Shader": {
        "info": {
            "date": "1629227685",
            "description": "I'm still pretty jacked up on UV mapping a torus right now!\n\n(Click and mouse to zoom/show enlarged view)",
            "flags": 0,
            "hasliked": 0,
            "id": "stjSDh",
            "likes": 24,
            "name": "Metal Donuts & Springs",
            "published": 3,
            "tags": [
                "raymarching",
                "torus",
                "uv",
                "isometric"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 550
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Metal Art Donuts &Springs\n    @byt3_m3chanic | 08/17/21\n\n    you dont learn till you do it over and over and over...\n    Just trying to isolate the UV mapping things\n    playing around with animation and movement.\n    \n    truchet tiles are so hot right now!\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .001\n#define MAX_DIST 90.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq torus\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time;\n\nconst vec2 sc = vec2(.125), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    p.y+=2.;\n    p.x+=time;\n    vec2 res = vec2(1e5,0);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n    float rnd = hash21(id);\n\n    float mx = .7+.3*sin(id.x*1.25);\n    float my = .7+.3*sin(id.y*2.);\n    float fid = (mx*my);\n    float wv = 1.65*sin(fid*T*4.5);\n \n    // spheres\n    float b1 = rnd >.2 ? length(q-vec3(0,1.8-wv,0))-(fid) : 1e5;\n    float w1=wv*.3;\n    float w2=wv*.15;\n    vec3 vq = vec3(q.x,abs(abs(q.y-.75-w2)-.5)-.25,q.z);\n    b1 = min(torus(vq,vec2(1.25-w1,.075)),b1);\n    if(b1<res.x) {\n        res = vec2(b1,2.);\n    \thit=p;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n\n    float b2 = torus(q-vec3(0, 1.05,0),vec2(2.75 ,1.00 ));\n    if(b2<res.x) {\n        res = vec2(b2,3.);\n    \thit=q;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n    \n    // floor\n    float d9 = p.y;\n    d9 = max(d9,-(length(q)-1.25));\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gid=id;\n        gto=vec3(fid,dir,rnd);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t)\n{ \n    vec3 d = vec3(0.961,0.541,0.220);\n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<150;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x*.85;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,8,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n\n        float shdw = 1.0;\n        for( float t=.05; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint*sc.xxx;\n            h = vec3(.7);\n            vec2 f = fract(hp.xz*2.)-.5;\n            if(f.x*f.y>0.) h=clamp( hue( fresnel-length(hp.xz*.15) )+.2,vec3(0),vec3(1) );\n            ref = vec3(h*.5)-fresnel;\n        }\n        \n        if(m==2.) {\n            h=vec3(.5);\n            ref = h-fresnel;\n        }\n\n        if(m==3.) {\n            vec3 hp = hitPoint;\n            float fhs = hash21(sid.xy+50.);\n            float angle = atan(hp.z,hp.x)/PI2;\n            float gz =  atan( hp.y,  length(hp.zx)-2.75 ) / PI2;\n\n            vec2 uv = vec2(angle,gz+(T*.1*fhs));\n        \n            float px  = .005*d;\n            vec2 scaler = vec2(48.,32.);\n            vec2 grid = fract(uv.xy*scaler)-.5;\n            vec2 id   = floor(uv.xy*scaler);\n            float hs = hash21(id);\n            if(hs>.5) grid.x*=-1.;\n\n            float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n            vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n            vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n            float circle = length(gx)-.5;\n            \n            if(fhs>.4){\n                float circle2 = fhs>.85 ? abs(abs(circle)-.25)-.2 : abs(abs(circle)-.15)-.05 ;\n                circle2=smoothstep(-px,.001+px,circle2);\n                circle=(chk>0.^^ hs>.5) ? smoothstep(-px,.001+px,circle) : smoothstep(.001+px,-px,circle);\n                \n                if(fhs>.75) circle= min(circle2,circle);\n                     \n            }else{\n            \n                circle=smoothstep(-px,.001+px,abs(circle)-.15);\n            }\n           \n        \n            h = mix(h, hue(fresnel-(sto.z*3.35)),circle);\n            ref = vec3(.4-circle)-fresnel;\n        }\n        \n        C = h*diff+spec;\n        C = mix(FC.rgb,C,  exp(-.00005*d*d*d));\n    \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nfloat zoom = 14.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.75;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    float x = -1.;\n    \n    if(M.z>0.) x = .5-(M.x-F.x);\n     \n    if(uv.x>x && M.z>0.) zoom *= .5;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n\n    mat2 rx = rot(-45.*PI/180.);\n    mat2 ry = rx;\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    //C = mix(C,C+.07,hash21(uv));\n    C=clamp(C,vec3(.03),vec3(.9));\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}