{
    "Shader": {
        "info": {
            "date": "1612084815",
            "description": "A small test that I never got around to finishing. Uses IQâ€™s soft shadow method. Move your mouse to the right half of the screen for better graphics.",
            "flags": 0,
            "hasliked": 0,
            "id": "wsVBR1",
            "likes": 2,
            "name": "Infinite wooden spheres",
            "published": 3,
            "tags": [
                "raymarching",
                "spheres",
                "textures"
            ],
            "usePreview": 0,
            "username": "Rowsej",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "#define MAX_RAY_DIS 10.\n#define EPSILON .001\n\n#define GROUND_TEXTURE true\n#define SPHERE_TEXTURE true\n#define BETTER_LIGHT iMouse.x > iResolution.x / 2.\n\nfloat randIndex = 0.;\n\nfloat sdSphere(vec3 s, float r, vec3 p);\nfloat getSde(vec3 p);\n// Thanks to IQ for this\nvec3 estimateNormal(vec3 p) {\n    vec2 h = vec2(EPSILON, 0.0);\n    return normalize(vec3(getSde(p + h.xyy) - getSde(p - h.xyy),\n                         getSde(p + h.yxy) - getSde(p - h.yxy),\n                         getSde(p + h.yyx) - getSde(p - h.yyx)));\n}\nfloat rand(vec2 fragCoord) {\n    float index = iTime + randIndex;\n    vec2 coords = fragCoord;\n    coords.x += index;\n    while(coords.x > 63.) {\n        coords.x -= 64.;\n        coords.y += 1.;\n    }\n    return texture(iChannel2, coords).x;\n}\n\nfloat sdSphere(vec3 s, float r, vec3 p) {\n    return length(p - s) - r;\n}\nfloat sdGround(vec3 p) {\n    return p.y + .5;\n}\nfloat getSde(vec3 p) {\n    return min(sdSphere(vec3(.5), .25, mod(p, 1.)), sdGround(p));\n}\nvec2 getBlinnPhongShading(vec3 n, vec3 v, vec3 l, float shininess) {\n    float ambient = .1;\n    float diffuse = clamp(dot(n, l), 0., 1.);\n    float specular = clamp(pow(dot(normalize(l - v), n), shininess) * (1. - diffuse), 0., 1.);\n    return vec2(ambient + diffuse, specular);\n}\nfloat marchShadowRay(vec3 f, vec3 l) {\n    vec3 ro = f;\n    vec3 rd = normalize(l - f);\n    float md = length(l - f);\n    float res = 1.;\n    for(float t = EPSILON * 15.; t < md;) {\n        vec3 p = ro + rd * t;\n        float sde = getSde(p);\n        if(sde < EPSILON) return 0.;\n        res = min(res, 64. * sde / t);\n        t += sde;\n    }\n    return res;\n}\n\nvec3 getCol(vec2 coords) {\n    vec3 ro = vec3(0., 0., sin(iTime));\n    vec3 rd = normalize(vec3(coords, 1.));\n    vec3 p = ro;\n    for(float t = 0.; t < MAX_RAY_DIS;) {\n        float sde = getSde(p);\n        p += rd * sde;\n        if(sde < EPSILON) {\n            vec3 n = estimateNormal(p);\n            vec3 v = rd;\n            vec3 light = vec3(cos(iTime), 1., -sin(iTime));\n            vec3 lightDir = normalize(light - p);\n            vec2 shading = getBlinnPhongShading(n, v, lightDir, 64.);\n            float shadow = marchShadowRay(p, light);\n            shading.y *= pow(shadow, 4.);\n            shading.x *= max(shadow, .3);\n            vec3 obCol = mod(floor(p.x * 2.) + floor(p.y * 2.) + floor(p.z * 2.), 2.) == 0.? vec3(0., 1., 0.) : vec3(1., 0., 0.);\n            if(SPHERE_TEXTURE) {\n\t            obCol = texture(iChannel1, p.xz).xyz;\n            }\n            if(sdGround(p) < EPSILON) {\n                obCol = floor(mod(p.x / .3, 2.)) == floor(mod(p.z / .3, 2.))? vec3(.6) : vec3(.8);\n                if(GROUND_TEXTURE) {\n\t                obCol *= texture(iChannel0, p.xz).x;\n                }\n            }\n            vec3 col = obCol * shading.x + vec3(1.) * shading.y;\n            if(BETTER_LIGHT) {\n\t            col /= length(light - p) / 4.;\n            }\n            vec3 fogCol = vec3(0.);\n            return col;\n        }\n        t += sde;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float mind = min(iResolution.x, iResolution.y);\n    if(!(BETTER_LIGHT)) {\n        fragCoord.x = floor(fragCoord.x / 8.) * 8.;\n        fragCoord.y = floor(fragCoord.y / 8.) * 8.;\n    }\n    vec2 coords = fragCoord / mind * 2. - 1.;\n    coords.x -= (iResolution.x - mind) / mind;\n    coords.y -= (iResolution.y - mind) / mind;\n    vec3 col = getCol(coords);\n    \n    // Add the light effect (which, if you look close enough, still shows even if the light is behind shadow).\n    const float bloomSize = .2;\n    const float strength = 1.;\n    float bloom = 0.;\n    vec3 ro = vec3(0., 0., sin(iTime));\n    vec3 rd = normalize(vec3(coords, 1.));\n    for(float t = 0.; t < MAX_RAY_DIS;) {\n        vec3 p = ro + rd * t;\n        float sde = length(p - vec3(cos(iTime), 1., -sin(iTime)));\n        if(sde < bloomSize) {\n            bloom = (1. - sde / bloomSize) * strength;\n            break;\n        }\n        t += sde;\n    }\n    col += vec3(1.) * bloom;\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}