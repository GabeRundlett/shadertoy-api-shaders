{
    "Shader": {
        "info": {
            "date": "1599944560",
            "description": "Funky projection of boxes to other boxes, with even more boxes inside the projected boxes. Overly convoluted, but that's the way I roll :P\n\nPlay with the macro values for extra fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "WtSBD3",
            "likes": 2,
            "name": "Box Projection Projection",
            "published": 3,
            "tags": [
                "distortion",
                "projection",
                "box",
                "stripes"
            ],
            "usePreview": 0,
            "username": "timeisbeautifulhere",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "\n#define LINE_WIDTH 0.005\n\n//Scale ratio of outer to inner boxes\n#define SCALE_RATIO 0.65\n\n//How far apart subsequent boxes are\n#define SCALE_SPACING 0.55\n\n//When a box should loop\n#define SCALE_CUTOFF 1.25\n\n#define NUM_SQUARES 3\n#define TIME_CONST 0.1\n\n//Variables for \"split\" stripe effect.\n//High values for SPLIT_COUNT are fun.\n#define SPLIT_COUNT 5\n#define STRIPE_LINE_WIDTH 0.03\n#define STRIPE_TIME_CONST 0.25\n#define STRIPE_TIME_CUTOFF 10.0\n\n//Color variables\n#define STRIPE_CONST_A 1.3\n#define STRIPE_CONST_B 0.712\n#define STRIPE_COLOR_TIME_CONST 0.025\n\n#define DISABLE_STRIPE_TIME_EFFECT false\n#define DISABLE_STRIPE_LOOP false\n//#define DISABLE_STRIPE_TIME_EFFECT true\n//#define DISABLE_STRIPE_LOOP true\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Same as above, but returns distance instead\nfloat dist_from_segment(vec2 p1, vec2 p2, vec2 p3){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\t\n    return distance(point_on_line, p3);\n}\n\nbool on_rectangle(vec2 ll, vec2 ur, vec2 uv){\n    vec2 ul = vec2(ll.x,ur.y),\n        lr = vec2(ur.x, ll.y);\n    \n    return on_segment(ll,lr,uv,LINE_WIDTH) ||\n        on_segment(lr,ur,uv,LINE_WIDTH) ||\n        on_segment(ur,ul,uv,LINE_WIDTH) ||\n        on_segment(ul,ll,uv,LINE_WIDTH);\n}\n\n//Find \"split point\", or where the closest\n//stripe line is given a split factor.\n//The use of this is less apparent with\n//DISABLE_STRIPE_TIME_EFFECT false\nfloat closest_split(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    float closest = (closest_delta*delta);\n    \n    return closest - dist;\n}\n\nint closest_split_num(vec2 uv, int split_cnt){\n    \n    float dist = uv.y;\n    float delta = (dist*2.0)/float(split_cnt);\n    \n    float x = uv.x + (dist);\n    \n    float closest_delta = round(x/delta);\n    \n    return int(closest_delta);\n}\n\n//Check if uv is on a \"stripe\" between two scaled\n//boxes\nint on_stripes(vec2 uv, int split_cnt, float inner_scale, float outer_scale){\n    \n    if((abs(uv.x)<inner_scale && abs(uv.y)<inner_scale) ||\n       (abs(uv.x)>outer_scale && abs(uv.y)>outer_scale))\n        return -1;\n   \t\n    vec2 p = vec2(uv);\n    \n    //In \"top\" region\n    if(uv.y > inner_scale && uv.x > -uv.y && uv.x < uv.y)\n        p = vec2(uv.x, uv.y);\n    \n    //In \"bottom\" region\n    else if(uv.y < -inner_scale && uv.x > uv.y && uv.x < -uv.y)\n        p = vec2(uv.x, -uv.y);\n    \n    //In \"left\" region\n    else if(uv.x < -inner_scale && uv.y > uv.x && uv.y < -uv.x)\n        p = vec2(uv.y, -uv.x);\n   \t\n    //In \"right\" region\n    else if(uv.x > inner_scale && uv.y > -uv.x && uv.y < uv.x)\n        p = vec2(uv.y, uv.x);\n    \n    //Inside box, not in any region\n    else\n        return -1;\n    \n    if(p.y > outer_scale)\n        return -1;\n    \n    //Really funky time based effect on\n   \t//stripes\n    if(!DISABLE_STRIPE_TIME_EFFECT){\n    \t//\"Loop\" time effect on distortion of stripes.\n        //Here because it gets weird at higher time values.\n    \tif(!DISABLE_STRIPE_LOOP)\n    \t\tp.x += mod(iTime*STRIPE_TIME_CONST,STRIPE_TIME_CUTOFF);\n        else\n            p.x += iTime*STRIPE_TIME_CONST;\n    \tp.x = mod(p.x, p.y);\n    }\n    \n    float closest = closest_split(p, split_cnt);    \n    if(abs(closest-p.x) < STRIPE_LINE_WIDTH)\n        return closest_split_num(p, split_cnt);\n    else\n        return -1;\n}\n\n//Draw an array of boxes, defined by their \"outer scale\".\n//Draws the boxes and stripes inside them.\nvec3 draw_rectangles(vec2 uv, float scales[NUM_SQUARES]){\n    vec3 col = vec3(1.0);\n    \n    for(int i=0;i<NUM_SQUARES;i++){\n        float scale_outer = scales[i],\n            scale_inner = scales[i]*SCALE_RATIO;\n        \n        //Check if on any \"stripes\" splitting edge regions\n        int stripe_num = on_stripes(uv, SPLIT_COUNT, scale_inner, scale_outer);\n        if(stripe_num != -1){\n            //Funky color effect with random math\n            float stripe_1 = float(stripe_num) * STRIPE_CONST_A + STRIPE_CONST_B,\n                stripe_2 = float(stripe_num) * (1.0/STRIPE_CONST_B) + STRIPE_CONST_A,\n                stripe_3 = STRIPE_COLOR_TIME_CONST * iTime;\n            \n\t        col = vec3(\n                fract(stripe_1 * stripe_3),\n                fract(stripe_2 * stripe_3),\n                fract(mix(stripe_1,stripe_2, stripe_3))\n            );\n        }\n        \n        //Draw outer and inner boxes\n    \tvec2 ll = vec2(-scale_outer,-scale_outer),\n        \tur = vec2(scale_outer,scale_outer);\n    \tvec2 inner_ll = vec2(-scale_inner,-scale_inner),\n\t        inner_ur = vec2(scale_inner,scale_inner);\n    \n    \tif(on_rectangle(ll,ur,uv) || on_rectangle(inner_ll,inner_ur, uv))\n        \tcol = vec3(0.0);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1, 1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    vec3 col = vec3(1.0);\n    \n    float scales[NUM_SQUARES];\n    scales[0] = 1.0 + TIME_CONST*iTime;\n    for(int i=1;i<NUM_SQUARES;i++)\n    \tscales[i] = scales[i-1]-SCALE_SPACING;\n    for(int i=0;i<NUM_SQUARES;i++){\n        float inner = scales[i]*SCALE_RATIO;\n        if(inner > SCALE_CUTOFF)\n            scales[i] = mod(inner,SCALE_CUTOFF)/SCALE_RATIO;\n    }\n    \n    col = draw_rectangles(uv,scales);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}