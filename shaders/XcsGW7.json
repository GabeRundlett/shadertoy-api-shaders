{
    "Shader": {
        "info": {
            "date": "1703143520",
            "description": "1. heat map (off)\n2. shadows (on)\n3. reflections (on)\n4. diffuse (on)\n5. ambient (on)\n6. render IOR (off)",
            "flags": 16,
            "hasliked": 0,
            "id": "XcsGW7",
            "likes": 13,
            "name": "all the rays we cannot see",
            "published": 3,
            "tags": [
                "refraction",
                "optics"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "// Fork of \"draft: more glass 2\" by elenzil. https://shadertoy.com/view/Xcf3RH\n// 2023-12-21 07:18:41\n\n\n\n\n/*\n\nKeyboard (iChannel3)\n--------------------\n1. heat map\n2. shadows\n3. reflections\n4. diffuse\n5. ambient\n6. render IOR\n\n*/\n\nconst float gZoom       = 0.8;\nconst float gFOVZoom    = 3.0;\n      float gT;         // set in main\n      vec3  gDebugRGB   = v0;\n      \n//--------------------------------------------------------------------------\n// ray handling parameters\n\n// maximum number of rays per pixel.\n// reflections, shadows, and transmission all spawn a ray,\n// and a single ray travels until it hits a boundary.\nconst uint  gMaxRays        = 20u;\n\n// standard marching parameters\nconst uint  gMaxMarchSteps  = 120u;\nconst float gMarchEps       = 0.001;\nconst float gNormEps        = gMarchEps * 5e-1;\nconst float gMarchMaxDist   = 6e1;\nconst float gMarchUnderstep = 0.9;\n\n// cleans up a little bit of sparklies.\nconst float gHitBackoff     = gMarchEps * 4.0;\n\n// smallest contribution before extinguishing a ray\nconst float gMinAmt         = 0.01;\n\n// heat map stuff\n      float gMapCount       = 0.0;\nconst float cHeatMapSteps   = 130.0;\nconst float cHeatMapRays    = 15.0;\n\n// ambient!\nconst vec3  gAmbient        = v1 * 0.02;\n      \n// FIFO queue of rays. see Common tab.\n#define Q_TYPE ray_t\n#define Q_MAX_ENTRIES (gMaxRays)\nQ_IMPLEMENTATION\n\n\n//---------------------------------------------------------\n#define renderSegmentsMax (26u)\n#if (renderSegmentsMax % 2u != 0u) || (renderSegmentsMax < 1u)\n#error renderSegmentsMax must be even and positive\n#endif\nuint renderSegmentCount = 0u;\nvec4 renderSegments[renderSegmentsMax];\nbool gIncludeRenderRays = false;\n\nMST sdRenderRays(in vec3 p) {\n    float d = 1e9;\n    \n    for (uint n = 0u; n < renderSegmentCount; n += 2u) {\n        float amt = renderSegments[n + 0u].w;\n        amt = pow(amt, 0.25);\n        float segD = sdCapsule(p,\n                        renderSegments[n + 0u].xyz,\n                        renderSegments[n + 1u].xyz,\n                        0.2 * amt);\n        d = min(d, segD);\n                        \n    }\n        \n    return MST(d, 4u);\n}\n\n\n//--------------------------------------------------------------------------\n// Scene Setup\nvec3  gSceneCenter;\nfloat gFloorGap;\nvec3  gLightDir;\nmat2  gObjRot1;\n\nvoid setupScene() {\n    gSceneCenter = vY * 5.0;\n    gFloorGap    = gMarchEps * 3.0;\n    gLightDir    = normalize(vec3(1.0, 1.5, 1.9));\n    gObjRot1     = rot2(gT * 0.2);\n}\n\nMST sdScene(vec3 p) {\n    MST ms = MST(1e9, 0u);\n\n    if (p.y < 0.0) {\n        return ms;\n    }\n\n    gMapCount += 1.0;\n    \n    \n    vec3 q = p - (gSceneCenter + gFloorGap);\n        \n    float h   = gSceneCenter.y;\n    float r   = h * 0.05;\n    float b   = h * 0.2 - r;\n    vec3  rod = vec3(b, b, h + 2.0 * b);\n    \n    if (true || !gIncludeRenderRays) {\n    opUnion   (ms, MST(sdBox(q, (h - r) * v1           ) - r, 2u));\n//    opSub     (ms,     sdBox(q.zyx, rod) - r);\n//    q.xy = abs(q.xy) - h + 4.0 * r + b;\n//    q.xy *= gObjRot1;\n//    opSubUnion(ms, MST(sdBox(q, rod) - r, 3u));\n       q.xz *= gObjRot1;\n    opSub(ms.dist, sdBox(q, h * 0.5 * v1) - r * 3.0);\n    }\n    \n    if (gIncludeRenderRays) {\n        opSubUnion(ms, sdRenderRays(p));\n    }\n    \n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvec3 albedo(hit_t hit) {\n    switch(hit.ms.mtl) {\n        case 1u: return v1 * 0.3;\n        case 2u: return 0.0 * (vX + vY);\n        case 3u: return 0.0 * (vec3(0.3, 0.7, 0.8));\n        case 4u: return v1 * 8.0;\n        default: return (vX + vZ) * 1e9;\n    }\n}\n\n\nfloat ior(MST ms) {\n    if (ms.dist > 0.0) {\n        return 1.0;\n    }\n    \n    switch(ms.mtl) {\n        case 1u: return 1.0;\n        case 2u: return 1.2;\n        case 3u: return 1.2;\n        case 4u: return 1.0;\n        default: return 1e9;\n    }\n}\n\n\n//---------------------------------------------------------------------\n// keyboard stuff\n\nconst float cPipScale = 0.45;\n\nbool kPipOn       = false;      // heat map.          1\nbool kShadows     = true;       // shadows.           2\nbool kReflections = true;       // reflections.       3\nbool kDiffuse     = true;       // diffuse.           4\nbool kAmbient     = true;       // ambient.           5\nbool kRenderIOR   = true;\n\nvoid readKeyboard() {\n    const int ZRO = 48;\n    kPipOn        =  KEY_TOGGLED(ZRO + 1, iChannel3);\n    kShadows      = !KEY_TOGGLED(ZRO + 2, iChannel3);\n    kReflections  = !KEY_TOGGLED(ZRO + 3, iChannel3);\n    kDiffuse      = !KEY_TOGGLED(ZRO + 4, iChannel3);\n    kAmbient      = !KEY_TOGGLED(ZRO + 5, iChannel3);\n    kRenderIOR    =  KEY_TOGGLED(ZRO + 6, iChannel3);    \n}\n\n\n//--------------------------------------------------------------------------\n\nvec3 sky(ray_t ray) {\n\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(ray.rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(ray.rd, gLightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float dddd = d * d;\n    dddd *= dddd;\n    c *= mix(sin(dddd * dddd * 30.0 + gT) * 0.5 + 0.5, 1.0, 1.0 - dddd * 0.1);\n    \n    float a = atan(ray.rd.z, ray.rd.x);\n    \n    c = mix(c, v1 * (1.0 - sqrt(d)), 0.3 * smoothstep(0.06 + (1.0 - d) * 0.02 * cos(a * 23.0), 0.0, abs(ray.rd.y)));\n    return c;\n}\n\n//--------------------------------------------------------------------------\n\nvoid rayVsFloor(ray_t ray, inout hit_t hit) {\n    float t = rayVsPlane(ray.ro, ray.rd, vY, 0.0);\n    if (t > 0.0 && (!hit.hit || t < hit.t)) {\n        hit.t   = t;\n        hit.hit = true;\n        hit.pnt = ray.ro + ray.rd * t;\n        hit.of_nrm = vY;\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = MST(0.0, 1u);\n    }\n}\n\nvoid rayMarch(ray_t ray, inout hit_t hit) {\n\n    float t = 0.0;\n    \n    MST ms;\n    uint n;\n    vec3 p;\n    for (n = 0u; n < gMaxMarchSteps; ++n) {\n    \n        // if our hit already has a hit\n        // and our t is not closer than it, return.\n        if (hit.hit && t >= hit.t) {\n            return;\n        }\n    \n        // sample the map\n        p        = ray.ro + ray.rd * t;        \n        ms       = sdScene(p);\n        float d  = abs(ms.dist);\n\n        if (d < gMarchEps) {\n            // close to a surface!\n            // mark it the hit & return\n            hit.hit    = true;\n            hit.t      = t;\n            hit.pnt    = p;\n            hit.of_nrm = normalScene(p - ray.rd * gHitBackoff);\n            hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n            hit.ms     = ms;\n            return;\n        }\n        \n        // advance\n        t += d * gMarchUnderstep;\n        \n        // if we're just too far away, return.\n        if (dot(p, p) > (gMarchMaxDist * gMarchMaxDist)) {\n            return;\n        }\n    }\n    \n    if (t < 1e4) {\n        // ran out of steps.\n        hit.hit = true;\n        hit.t   = t;\n        hit.pnt = p;\n        hit.of_nrm = normalScene(p - ray.rd * gHitBackoff);\n        hit.hf_nrm = hit.of_nrm * -sign(dot(hit.of_nrm, ray.rd));\n        hit.ms  = ms;        \n    }\n}\n\nhit_t rayVsScene(ray_t ray) {\n    hit_t hit;\n    hit.hit = false;\n    \n    rayVsFloor(ray, hit);\n    rayMarch  (ray, hit);\n    \n    return hit;\n}\n\nvoid tryAddRenderRay(ray_t ray, hit_t hit) {\n    if (gIncludeRenderRays) {\n        return;\n    }\n    if (ray.isLightingRay) {\n       return;\n    }\n    if (renderSegmentCount > renderSegmentsMax - 2u) {\n        return;\n    }\n    vec3 endPoint;\n    if (hit.hit) {\n        endPoint = hit.pnt;\n    }\n    else {\n        endPoint = ray.ro + ray.rd * 1e2;\n    }\n    renderSegments[renderSegmentCount + 0u] = vec4(ray.ro , ray.amt);\n    renderSegments[renderSegmentCount + 1u] = vec4(endPoint, 0.0);\n    renderSegmentCount += 2u;\n}\n\n\n// run a single ray.\n// if it hits the sky, contribute sky.\n// if it hits external surfaces, fire a ray to the light.\n// if it's a \"light ray\", and it doesn't get blocked, contribute to the scene.\nvec3 runRay(ray_t ray) {\n    hit_t hit = rayVsScene(ray);\n\n    tryAddRenderRay(ray, hit);\n\n    if (ray.isLightingRay) {\n        if (!hit.hit) {\n            return ray.amt;\n        }\n        return v0;\n    }\n    \n    if (!hit.hit) {\n        return ray.amt * sky(ray);\n    }\n    \n    // transmission part 1.\n    // sample the scene on either side of the surface,\n    // so we can get the ratio of indices of refraction.\n    const float matSampOff = gMarchEps * 2.0;\n    MST   msA = sdScene(hit.pnt + hit.hf_nrm * matSampOff);\n    MST   msB = sdScene(hit.pnt - hit.hf_nrm * matSampOff);\n    bool  totalInternal = false;\n    float eta = ior(msA) / ior(msB);\n    if (gIncludeRenderRays && !kRenderIOR) {\n        eta = 1.0;\n    }\n\n    vec3  rfr = refract(ray.rd, hit.hf_nrm, eta);\n    if (dot(rfr, rfr) == 0.0) {\n        // total internal.\n        totalInternal = true;\n    }\n    \n    \n    vec3  reflAmt;\n    if (totalInternal) {\n        reflAmt = v1;\n    }\n    else {\n        // fake fresnel\n        vec3  reflMin = v1 * 0.05;\n        vec3  reflMax = v1 * 0.95;\n        float fakeFres = 1.0 + dot(ray.rd, hit.hf_nrm);\n        reflAmt = mix(reflMin, reflMax, sqr(fakeFres));\n        if (gIncludeRenderRays && !kRenderIOR) {\n            reflAmt = v0;\n        }\n    }\n    vec3  tmp;\n    tmp = reflAmt * ray.amt;\n    if (kReflections && vmax(tmp) > gMinAmt && !QIsFull()) {\n        ray_t reflectRay;\n        reflectRay.amt = tmp;\n        reflectRay.ro = hit.pnt + hit.hf_nrm * gMarchEps * 2.0;\n        reflectRay.rd = reflect(ray.rd, hit.hf_nrm);\n        reflectRay.isLightingRay = false;\n        reflectRay.isRenderRay   = ray.isRenderRay;\n        QEnqueue(reflectRay);\n    }\n    \n    vec3 diffAmt = 1.0 - reflAmt;\n    \n    // only used for 'no shadows' mode.\n    vec3 shadowlessAmt = v0;\n    \n    // enqueue lighting ray\n    // but only if we're in the open air.\n    if (kDiffuse && hit.ms.dist >= 0.0 && !QIsFull()) {\n        vec3 legitFactors = diffAmt * max(0.0, dot(hit.of_nrm, gLightDir));\n        tmp = albedo(hit) * ray.amt * legitFactors;\n        tmp *= 1.0 - gAmbient;\n        if (vmax(tmp) > gMinAmt) {\n            ray_t lightingRay;\n            lightingRay.amt = tmp;\n            lightingRay.ro = hit.pnt + hit.of_nrm * gMarchEps * 2.0;\n            lightingRay.rd = gLightDir;\n            lightingRay.isLightingRay = true;\n            lightingRay.isRenderRay   = ray.isRenderRay;\n            if (kShadows) {\n                QEnqueue(lightingRay);\n            }\n            else {\n              shadowlessAmt = lightingRay.amt;\n            }\n        }\n    }\n\n\n    // transmission part 2\n    vec3 trnAmt = ray.amt * 0.4; // sssssssss\n    if (hit.ms.mtl == 4u) {\n        trnAmt = v0;\n    }\n    if (!totalInternal && !QIsFull() && vmax(trnAmt) > gMinAmt) {\n        ray_t transmissionRay;\n        transmissionRay.amt = trnAmt;\n        transmissionRay.ro = hit.pnt - hit.hf_nrm * matSampOff;\n        transmissionRay.rd = rfr;\n        transmissionRay.isLightingRay = false;\n        transmissionRay.isRenderRay   = ray.isRenderRay;\n        if (true) {\n            QEnqueue(transmissionRay);\n        }\n    }\n    \n    \n    vec3 ambient;\n    if (kAmbient) {\n        ambient = albedo(hit) * gAmbient;\n    }\n    else {\n        ambient = v0;\n    }\n    \n    return ray.amt * (shadowlessAmt + ambient);\n}\n\nvoid runRenderRays() {\n    uint rayCount = 0u;\n    bool keepGoing = true;\n    gIncludeRenderRays = false;\n    while (keepGoing) {\n        keepGoing = keepGoing && !QIsEmpty();\n        keepGoing = keepGoing && rayCount < gMaxRays;\n        keepGoing = keepGoing && renderSegmentCount < renderSegmentsMax;\n        if (!keepGoing) {\n            break;\n        }\n        ray_t ray = QDequeue();\n        runRay(ray);\n        rayCount += 1u;\n    }\n}\n\nvec3 runRays() {\n\n    vec3 rgb = v0;\n    \n    uint rayCount = 0u;\n    \n    gIncludeRenderRays = true;\n\n\n    while (!QIsEmpty() && rayCount < gMaxRays) {\n        rgb += runRay(QDequeue());\n        rayCount += 1u;\n    }\n    \n    return rgb;\n}\n\n//--------------------------------------------------------------------------\n\nray_t getCameraRay(vec2 xy) {\n    ray_t ret;\n    \n    vec3 lookFrom = vec3(0.0, 2.0, 14.0) * 2.0;\n    float rX      = 0.0;\n    float rY      = 0.0;\n    if (length(MS) > 50.0) {\n        rX = (MS.x / RES.x * 2.0 - 1.0) * pi * -1.2;\n        rY = (1.0 - MS.y / RES.y) * pi * 0.45;\n    }\n    \n    lookFrom.yz  *= rot2(rY);\n    lookFrom.xz  *= rot2(rX);\n    lookFrom.y    = max(0.1, lookFrom.y);\n         \n    vec3 lookTo   = gSceneCenter;\n    \n    vec3 camFw    = normalize(lookTo - lookFrom);\n    vec3 camRt    = normalize(cross(camFw, vY));\n    vec3 camUp    = cross(camRt, camFw);\n    \n    ret.ro            = lookFrom;\n    ret.rd            = normalize(camFw + (xy.x * camRt + xy.y * camUp) / gFOVZoom);\n    ret.amt           = v1;\n    ret.isLightingRay = false;\n        \n    return ret;\n}\n      \n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    readKeyboard();\n    \n    // modify XY for picture-in-picture\n    bool isPip = kPipOn && (XY.x < RES.x * cPipScale && XY.y < RES.y * cPipScale);\n    if (isPip) {\n        XY /= cPipScale;\n    }\n\n    gT      = iTime;\n    vec2 xy = VIEWFROMSCREEN(XY);\n    \n    setupScene();\n    \n    ray_t renderRay;\n    renderRay.ro  = vec3(9.0, 8.0 + 8.0 * sin(gT * 0.356), 0.0) * 1.3;\n    renderRay.ro.xz *= rot2(gT * 0.2);\n    \n    renderRay.rd  = normalize(gSceneCenter + vX * gSceneCenter.y * 0.9 - renderRay.ro);\n    renderRay.amt = v1;\n    renderRay.isLightingRay = false;\n    renderRay.isRenderRay   = true;\n    QEnqueue(renderRay);\n    \n    runRenderRays();\n    \n    QClear();\n    QEnqueue(getCameraRay(xy));\n\n    vec3 c  = runRays();\n\n    c      *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.8, 3.0);\n    c       = pow(c, vec3(1.0 / 2.2));\n    c      *= 1.0;\n    c      += gDebugRGB;\n    \n    if (isPip) {\n        const vec3 cCool = vec3(0.0, 0.0, 0.2);\n        const vec3 cHot  = vec3(1.0, 0.9, 0.2);\n        float temp = gMapCount / float(cHeatMapSteps * cHeatMapRays);\n        c = mix(cCool, cHot, pow(temp, 0.6));\n    }\n    \n    RGBA    = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define MS     (iMouse.xy)\n#define ZERO   (min(iFrame,0))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n#define saturate(v) ( clamp((v), 0.0, 1.0) )\n#define sqr(a) ( (a) * (a) )\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat vmax(vec2 A) { return max(    A.x, A.y); }\nfloat vmax(vec3 A) { return max(max(A.x, A.y), A.z); }\nfloat vmin(vec2 A) { return min(    A.x, A.y); }\nfloat vmin(vec3 A) { return min(min(A.x, A.y), A.z); }\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    bool  isLightingRay;\n    bool  isRenderRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\n//--------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opSubUnion(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\n\nvoid opSubUnion(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    return t;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}