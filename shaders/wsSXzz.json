{
    "Shader": {
        "info": {
            "date": "1552678123",
            "description": "You're invited to a Shadertoy party! San Francisco, March 19th 2019, 18:30, Figma headquarters, 116 New Montgomery St, 9th floor. Check the meetup site for details/RSVP. meetup.com/San-Francisco-shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "wsSXzz",
            "likes": 86,
            "name": "SF Shadertoy party invite",
            "published": 3,
            "tags": [
                "meetup",
                "sanfrancisco",
                "shadertoyparty"
            ],
            "usePreview": 1,
            "username": "otaviogood",
            "viewed": 5953
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// THIS NEEDS A WEBGL 2.0 CAPABLE BROWSER OR IT WILL NOT WORK.\n\n// ---------------- Config ----------------\n// This is an option that lets you render high quality frames for screenshots. It enables\n// stochastic antialiasing and motion blur automatically for any shader.\n//#define NON_REALTIME_HQ_RENDER\nconst float frameToRenderHQ = 50.0; // Time in seconds of frame to render\nconst float antialiasingSamples = 16.0; // 16x antialiasing - too much might make the shader compiler angry.\n\n//#define MANUAL_CAMERA\n\n\n// --------------------------------------------------------\n// These variables are for the non-realtime block renderer.\nfloat localTime = 0.0;\n#ifdef NON_REALTIME_HQ_RENDER\nfloat seed = 1.0;\n#endif\n\n// Animation variables\nvec3 sunDir;\nint currentText;\n\n// Animation key frames\nconst int numKeyFrames = 8;\nconst float keys[numKeyFrames] = float[numKeyFrames]\n    (0.0, 14.0, 16.0, 24.0, 32.0, 40.0, 50.0, 59.0);\n\n// Deterministic hash that should work the same on all video cards. Just something I made up.\n// Should return a number [0..1)\nfloat JankyHash(uint seed) {\n    seed ^= ((seed ^ uint(1000000207)) * uint(1000000007)) >> 7;\n    seed = (seed ^ uint(1000000409)) * uint(1000000531);\n    return float(seed & uint(0xffff)) / (65536.0);\n}\n\nvec2 JankyHash2(uint seed) {\n    seed ^= ((seed ^ uint(1000000207)) * uint(1000000007)) >> 7;\n    seed = (seed ^ uint(1000000409)) * uint(1000000531);\n    return vec2(seed & uint(0xffff), seed >> 16) / (65536.0);\n}\n\n// ---- noise functions ----\nfloat v31(vec3 a)\n{\n    return a.x + a.y * 37.0 + a.z * 521.0;\n}\nfloat v21(vec2 a)\n{\n    return a.x + a.y * 37.0;\n}\nfloat Hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\nfloat Hash21(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nvec2 Hash22(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nvec2 Hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nvec2 NoiseTex(in vec3 x) {\n    vec3 fr = fract(x);\n    vec3 fl = floor(x);\n\tfr.xy = fr.xy * fr.xy * (3.0 - 2.0 * fr.xy);\n\tvec2 uva = (fl.xy + vec2(37.0, 17.0)*fl.z) + fr.xy;\n\tvec2 uvb = (fl.xy + vec2(37.0, 17.0)*fl.z + vec2(37.0, 17.0)) + fr.xy;\n\tvec2 a = textureLod( iChannel1, (uva + 0.5) / 256.0, 0.0).yx;\n\tvec2 b = textureLod( iChannel1, (uvb + 0.5) / 256.0, 0.0).yx;\n    return mix(a, b, fr.z) - 0.5;\n}\n\nconst float PI=3.14159265;\n\n#define saturate(a) clamp(a, 0.0, 1.0)\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 2D, Seed 10, Waves 8, Octaves 5, Smooth 1\nfloat NoiseGen(vec2 p) {\n    // This is a bit faster if we use 2 accumulators instead of 1.\n    // Timed on Linux/Chrome/TitanX Pascal\n    float wave0 = 0.0;\n    float wave1 = 0.0;\n    wave0 += sin(dot(p, vec2(0.600, -2.119))) * 0.2939877018;\n    wave1 += sin(dot(p, vec2(0.972, 2.283))) * 0.2387554666;\n    wave0 += sin(dot(p, vec2(3.511, 0.119))) * 0.1406977328;\n    wave1 += sin(dot(p, vec2(0.494, -5.303))) * 0.0817366769;\n    wave0 += sin(dot(p, vec2(8.383, -1.242))) * 0.0473036532;\n    wave1 += sin(dot(p, vec2(3.356, -7.905))) * 0.0465956513;\n    wave0 += sin(dot(p, vec2(-7.794, 10.606))) * 0.0290698451;\n    wave1 += sin(dot(p, vec2(15.407, -2.728))) * 0.0241393549;\n    return wave0+wave1;\n}\n\n// Returns gradient of the noise function at position p.\nvec2 NoiseGenGrad(vec2 p) {\n    vec2 dWave0 = vec2(0.0);\n    vec2 dWave1 = vec2(0.0);\n    vec2 dir = vec2(0.0);\n    dir = vec2(0.600, -2.119);    dWave0 += dir * cos(dot(p, dir)) * 0.2939877018;\n    dir = vec2(0.972, 2.283);    dWave1 += dir * cos(dot(p, dir)) * 0.2387554666;\n    dir = vec2(3.511, 0.119);    dWave0 += dir * cos(dot(p, dir)) * 0.1406977328;\n    dir = vec2(0.494, -5.303);    dWave1 += dir * cos(dot(p, dir)) * 0.0817366769;\n    dir = vec2(8.383, -1.242);    dWave0 += dir * cos(dot(p, dir)) * 0.0473036532;\n    dir = vec2(3.356, -7.905);    dWave1 += dir * cos(dot(p, dir)) * 0.0465956513;\n    dir = vec2(-7.794, 10.606);    dWave0 += dir * cos(dot(p, dir)) * 0.0290698451;\n    dir = vec2(15.407, -2.728);    dWave1 += dir * cos(dot(p, dir)) * 0.0241393549;\n    return dWave0+dWave1;\n}\n\nvec3 RotateY(vec3 v, float rad)\n{\n  float c = cos(rad);\n  float s = sin(rad);\n  return vec3(c * v.x - s * v.z, v.y, s * v.x + c * v.z);\n}\n\nvec2 Rotate(vec2 v, float rad)\n{\n  float c = cos(rad);\n  float s = sin(rad);\n  return vec2(c * v.x - s * v.y, s * v.x + c * v.y);\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir, vec3 sunCol)\n{\n\tvec3 localRay = rayDir;\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*150.0)*7000.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.002;\n}\n\nvec3 GetEnvMap(vec3 rayDir, vec3 sunDir,\n               vec3 sunCol, vec3 groundCol, vec3 horizonCol, vec3 skyCol)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.25))*0.95;\n    // make clouds - just a horizontal plane with noise\n    //float n = noise2d(rayDir.xz/rayDir.y*1.0);\n    //n += noise2d(rayDir.xz/rayDir.y*2.0)*0.5;\n    //n += noise2d(rayDir.xz/rayDir.y*4.0)*0.25;\n    //n += noise2d(rayDir.xz/rayDir.y*8.0)*0.125;\n    float n = NoiseGen(rayDir.xz/rayDir.y)*2.0+0.6;\n    vec2 ng = NoiseGenGrad(rayDir.xz/rayDir.y);\n    n = pow(abs(n), 3.0);\n    n = n * saturate(abs(rayDir.y * 4.0));  // fade clouds in distance\n\tfloat dist = 1.0 - (dot(rayDir, sunDir) * 0.5 + 0.5);\n    float cloudShadow = -dot(ng, sunDir.xz)*0.5+0.5;\n    vec3 cloudCol = (vec3(0.5,0.3,0.1)/dist+sunCol*cloudShadow)*saturate((rayDir.y+0.2)*5.0);\n    finalColor = mix(finalColor, cloudCol, saturate(n*0.0625));\n\n    // Background mountains\n    float n2 = NoiseGen(rayDir.xz*16.0)*0.75;\n    n2 += 1.5 - saturate(-rayDir.x)*3.0;\n    vec3 mountainCol = (horizonCol * 0.75 + skyCol * 0.25) * 0.55 - rayDir.y*3.0;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.025-rayDir.y)*512.0));\n\n    // Foreground mountains\n    n2 = NoiseGen(-rayDir.xz*16.0)*1.0;\n    n2 += 1.8 - saturate(-rayDir.x)*3.0;;\n    mountainCol = (horizonCol * 0.8 + skyCol * 0.2) * 0.40 + vec3(0.035, 0.0, 0.0);\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.0125-rayDir.y)*512.0));\n\n    // Foreground mountains\n    n2 = NoiseGen(-rayDir.zx*16.0)*1.0;\n    n2 += 0.6 - saturate(-rayDir.x)*3.0;;\n    mountainCol = (horizonCol * 0.5 + groundCol * 0.5) * 0.45 + vec3(0.0, 0.025, 0.0);\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.0125-rayDir.y)*512.0));\n\n    // Ground color fade\n    finalColor = mix(finalColor, (groundCol + horizonCol)*0.4, saturate(-rayDir.y*16.0));\n    finalColor = mix(finalColor, groundCol*0.4, saturate(-5.0-rayDir.y*8.0));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunCol);\n    return finalColor;\n}\n\nvec3 GetEnvMapSimple(vec3 rayDir, vec3 sunDir, vec3 sunCol, vec3 horizonCol, vec3 skyCol)\n{\n    // fade the sky color, multiply sunset dimming\n    vec3 finalColor = mix(horizonCol, skyCol, pow(saturate(rayDir.y), 0.25))*0.95;\n    // make clouds - just a horizontal plane with noise\n    float n = NoiseGen(rayDir.xz/rayDir.y)*2.0+0.6;\n    n = pow(abs(n), 3.0);\n    n = n * saturate(abs(rayDir.y * 4.0));  // fade clouds in distance\n\tfloat dist = 1.0 - (dot(rayDir, sunDir) * 0.5 + 0.5);\n    vec3 cloudCol = (vec3(0.5,0.3,0.1)/dist+sunCol)*saturate((rayDir.y+0.2)*5.0);\n    finalColor = mix(finalColor, cloudCol, saturate(n*0.0625));\n\n    // Background mountains\n    float n2 = NoiseGen(rayDir.xz*16.0)*0.75;\n    n2 += 1.5 - saturate(-rayDir.x)*3.0;\n    vec3 mountainCol = (horizonCol * 0.75 + skyCol * 0.25) * 0.55 - rayDir.y*3.0;\n    finalColor = mix(finalColor, mountainCol, saturate((n2*0.025-rayDir.y)*512.0));\n\n    // Ground color fade\n    //finalColor = mix(finalColor, (groundCol + horizonCol)*0.4, saturate(-rayDir.y*16.0));\n    //finalColor = mix(finalColor, groundCol*0.4, saturate(-5.0-rayDir.y*8.0));\n\n    // add the sun\n    finalColor += GetSunColorSmall(rayDir, sunDir, sunCol);\n    return finalColor;\n}\n\nvec3 GetEnvMapSkyline(vec3 rayDir, vec3 sunDir, float height,\n                      vec3 sunCol, vec3 horizonCol, vec3 skyCol)\n{\n    vec3 finalColor = GetEnvMapSimple(rayDir, sunDir, sunCol, horizonCol, skyCol);\n\n    // Make a skyscraper skyline reflection.\n    float radial = atan(rayDir.z, rayDir.x)*4.0;\n    float skyline = floor((sin(5.3456*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6);\n    radial *= 4.0;\n    skyline += floor((sin(5.0*radial) + sin(1.234*radial)+ sin(2.177*radial))*0.6)*0.1;\n    float mask = saturate((rayDir.y*8.0 - skyline-2.5+height)*24.0);\n    float vert = sign(sin(radial*32.0))*0.5+0.5;\n    float hor = sign(sin(rayDir.y*256.0))*0.5+0.5;\n    mask = saturate(mask + (1.0-hor*vert)*0.05);\n    finalColor = mix(finalColor * vec3(0.1,0.07,0.05), finalColor, mask);\n\n\treturn finalColor;\n}\n\n// min function that supports materials in the y component\nvec2 matmin(vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\nvec2 matmax(vec2 a, vec2 b)\n{\n    if (a.x > b.x) return a;\n    else return b;\n}\n\n// -------- Ray intersection functions and data structures --------\nconst float farPlane = 1024.0;\n\nvec4 Union(vec4 a, vec4 b)\n{\n    if (a.w < b.w) return a;\n    else return b;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\n// Return value is normal in xyz, t in w.\n// outside is 1 to intersect from the outside of the sphere, -1 to intersect from inside of sphere.\nvec4 SphereIntersect3(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad, int outside)\n{\n    vec4 rh = vec4(farPlane);\n    vec3 delta = spherePos - pos;\n    float projdist = dot(delta, dirVecPLZNormalizeMeFirst);\n    vec3 proj = dirVecPLZNormalizeMeFirst * projdist;\n    vec3 bv = proj - delta;\n    float b2 = dot(bv, bv);\n    if (b2 > rad*rad) return rh;  // Ray missed the sphere\n    float x = sqrt(rad*rad - b2);\n    rh.w = projdist - (x * float(outside));\n    vec3 hitPos = pos + dirVecPLZNormalizeMeFirst * rh.w;\n    rh.xyz = normalize(hitPos - spherePos);  // Normal still points outwards if collision from inside.\n    return rh;\n}\n\n// Return value is normal in xyz, t in w.\nvec4 PlaneIntersect(vec3 camPos, vec3 dirVecPLZNormalizeMeFirst, vec3 planeNormal, vec3 pointOnPlane) {\n    vec4 rh = vec4(farPlane);\n    float denom = dot(planeNormal, dirVecPLZNormalizeMeFirst);\n    if (denom != 0.0) {\n        vec3 p0l0 = pointOnPlane - camPos;\n        rh.w = dot(p0l0, planeNormal) / denom;\n        //rh.hit = camPos + dirVecPLZNormalizeMeFirst * rh.t;\n        rh.xyz = planeNormal * sign(-denom);\n    }\n    if (rh.w <= 0.0) rh.w = farPlane;\n    return rh;\n}\n\n// https://tavianator.com/fast-branchless-raybounding-box-intersections/\n// Return value is normal in xyz, t in w.\n// rayInv is 1.0 / direction vector\nvec4 BoxIntersect(vec3 pos, vec3 rayInv, vec3 boxPos, vec3 rad)\n{\n    vec3 bmin = boxPos - rad;\n    vec3 bmax = boxPos + rad;\n//    vec3 rayInv = 1.0 / dirVecPLZNormalizeMeFirst;\n\n    vec3 t1 = (bmin - pos) * rayInv;\n    vec3 t2 = (bmax - pos) * rayInv;\n\n    vec3 vmin = min(t1, t2);\n    vec3 vmax = max(t1, t2);\n\n    float tmin = max(vmin.z, max(vmin.x, vmin.y));\n    float tmax = min(vmax.z, min(vmax.x, vmax.y));\n\n    vec4 rh = vec4(0,1,0,farPlane);\n    if ((tmax <= tmin)) return rh;\n    if ((tmin <= 0.0)) return rh;\n    rh.w = tmin;\n    // optimize me!\n    if (t1.x == tmin) rh.xyz = vec3(-1.0, 0.0, 0.0);\n    if (t2.x == tmin) rh.xyz = vec3(1.0, 0.0, 0.0);\n    if (t1.y == tmin) rh.xyz = vec3(0.0, -1.0, 0.0);\n    if (t2.y == tmin) rh.xyz = vec3(0.0, 1.0, 0.0);\n    if (t1.z == tmin) rh.xyz = vec3(0.0, 0.0, -1.0);\n    if (t2.z == tmin) rh.xyz = vec3(0.0, 0.0, 1.0);\n    return rh;\n}\n\n// ---- shapes defined by distance fields ----\n// See this site for a reference to more distance functions...\n// https://iquilezles.org/articles/distfunctions\n\n// signed box distance field\nfloat sdBox(vec3 p, vec3 radius)\n{\n  vec3 dist = abs(p) - radius;\n  return min(max(dist.x, max(dist.y, dist.z)), 0.0) + length(max(dist, 0.0));\n}\n\n// capped cylinder distance field\nfloat cylCap(vec3 p, float r, float lenRad)\n{\n    float a = length(p.xy) - r;\n    a = max(a, abs(p.z) - lenRad);\n    return a;\n}\n\n// k should be negative. -4.0 works nicely.\n// smooth blending function\nfloat smin(float a, float b, float k)\n{\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nfloat Repeat(float a, float len)\n{\n    return mod(a, len) - 0.5 * len;\n}\n\n// Font rendering macros (ASCII codes)\n#define _SPACE 32\n#define _EXCLAMATION 33\n#define _COMMA 44\n#define _DASH 45\n#define _PERIOD 46\n#define _SLASH 47\n#define _COLON 58\n#define _AT 64\n#define _A 65\n#define _B 66\n#define _C 67\n#define _D 68\n#define _E 69\n#define _F 70\n#define _G 71\n#define _H 72\n#define _I 73\n#define _J 74\n#define _K 75\n#define _L 76\n#define _M 77\n#define _N 78\n#define _O 79\n#define _P 80\n#define _Q 81\n#define _R 82\n#define _S 83\n#define _T 84\n#define _U 85\n#define _V 86\n#define _W 87\n#define _X 88\n#define _Y 89\n#define _Z 90\n\n#define _a 97\n#define _b 98\n#define _c 99\n#define _d 100\n#define _e 101\n#define _f 102\n#define _g 103\n#define _h 104\n#define _i 105\n#define _j 106\n#define _k 107\n#define _l 108\n#define _m 109\n#define _n 110\n#define _o 111\n#define _p 112\n#define _q 113\n#define _r 114\n#define _s 115\n#define _t 116\n#define _u 117\n#define _v 118\n#define _w 119\n#define _x 120\n#define _y 121\n#define _z 122\n\n#define _0 48\n#define _1 49\n#define _2 50\n#define _3 51\n#define _4 52\n#define _5 53\n#define _6 54\n#define _7 55\n#define _8 56\n#define _9 57\n\n// San Francisco\n// Shadertoy party\n// March 19 2019 18:30\n// @ Figma\n// 116 New Montgomery, 9th floor\n// meetup.com/San-Francisco-shadertoy\n\nconst int numLetters = 118;\nconst int wordStarts[6] = int[6] (0, 14, 31, 44, 62, 94);  // This is weird. Oh well. Bugs.\nconst int wordLens[6] = int[6] (13, 15, 19, 7, 28, 35);\nconst float wordScales[6] = float[6] (2.0, 0.35, 0.5, 0.087, 0.044, 1.0);\nconst vec3 currentTextPos[6] = vec3[6] (\n    vec3(-12.0,6.0,29.0),\n    vec3(-1.35,0.11,16.5),\n    vec3(-2.0,3.5,2.2),\n    vec3(16.795, 0.88, 2.5),\n    vec3(10.83, 0.02, 0.948),\n    vec3(-19.5,8.0,33.2));\nconst int letterArray[numLetters] = int[numLetters]\n    (_S,_a,_n,_SPACE,_F,_r,_a,_n,_c,_i,_s,_c,_o,  // 13\n     _S,_H,_A,_D,_E,_R,_T,_O,_Y,_SPACE,_P,_A,_R,_T,_Y,  // 15\n    _M,_a,_r,_c,_h,_SPACE,_1,_9,_SPACE,_2,_0,_1,_9,_SPACE,_1,_8,_COLON,_3,_0,  // 19\n    _AT,_SPACE,_F,_I,_G,_M,_A,  // 7\n    _1,_1,_6,_SPACE,_N,_e,_w,_SPACE,_M,_o,_n,_t,_g,_o,_m,_e,_r,_y,_COMMA,_9,_t,_h,_SPACE,_f,_l,_o,_o,_r, _SPACE,  // 29\n    _m,_e,_e,_t,_u,_p,_PERIOD,_c,_o,_m,_SLASH,_S,_a,_n,_DASH,_F,_r,_a,_n,_c,_i,_s,_c,_o,_DASH,_s,_h,_a,_d,_e,_r,_t,_o,_y, _SPACE);  // 35\n\nvec4 SampleFontTex(vec2 uv)\n{\n    float fl = floor(uv + 0.5).x;\n    float cursorPos = fl;\n    int letter = 0;\n\n    letter = letterArray[int(cursorPos - 0.0)];\n    vec2 lp = vec2(letter % 16, 15 - letter/16);\n    vec2 uvl = lp + fract(uv+0.5)-0.5;\n\n    // Sample the font texture. Make sure to not use mipmaps.\n    // Add a small amount to the distance field to prevent a strange bug on some gpus. Slightly mysterious. :(\n    return texture(iChannel2, (uvl+0.5)*(1.0/16.0), -100.0) + vec4(0.0, 0.0, 0.0, 0.000000001);\n}\n\n// Distance function that defines the car.\n// Basically it's 2 boxes smooth-blended together and a mirrored cylinder for the wheels.\nvec2 Car(vec3 baseCenter, float unique)\n{\n    // bottom box\n    float car = sdBox(baseCenter + vec3(0.0, -0.008, 0.002), vec3(0.009, 0.00225, 0.0275)) - 0.0015;\n    // top box smooth blended\n    car = smin(car, sdBox(baseCenter + vec3(0.0, -0.016, 0.0075), vec3(0.004, 0.0005, 0.007)), -160.0);\n    // mirror the z axis to duplicate the cylinders for wheels\n    vec3 wMirror = baseCenter + vec3(0.0, -0.005, 0.002);\n    wMirror.z = abs(wMirror.z)-0.02;\n    float wheels = cylCap((wMirror).zyx, 0.004, 0.0135);\n    // Set materials\n    vec2 distAndMat = vec2(wheels, 3.0);\t// car wheels\n    // Car material is some big number that's unique to each car\n    // so I can have each car be a different color\n    distAndMat = matmin(distAndMat, vec2(car, 100000.0 + unique));\t// car\n    return distAndMat;\n}\n\nconst float parkHeight = 0.1;\nfloat Hills(vec3 p) {\n    vec2 tempP = p.xz;\n    tempP.y = abs(tempP.y - 29.6) - 29.6;\n    float pxz2 = dot(tempP.xy, tempP.xy);\n    float noise = NoiseGen(-p.zx*0.125)*0.2;\n    float height = p.y;\n    height -= 2.0f / exp(pxz2*0.008);\n    return height + 0.13 + noise ;\n}\n\n// How much space between voxel borders and geometry for voxel ray march optimization\nconst float voxelPad = 0.2;\n// p should be in [0..1] range on xz plane\n// pint is an integer pair saying which city block you are on\nvec2 CityBlock(vec3 p, vec2 pint)\n{\n    // Get random numbers for this block by hashing the city block variable\n    vec4 rand;\n    //rand.xy = Hash22(pint);\n    //rand.zw = Hash22(rand.xy);\n    //vec2 rand2 = Hash22(rand.zw);\n    rand.xy = JankyHash2(uint(pint.x + pint.y * 103.0 + 10009.0));\n    rand.zw = JankyHash2(uint(pint.x + pint.y * 103.0 + 10007.0 + rand.x*211.0));\n    vec2 rand2 = JankyHash2(uint(pint.x + pint.y * 103.0 + 10007.0 + rand.y*211.0));\n\n    // Radius of the building\n    float baseRad = 0.2 + (rand.x) * 0.1;\n    baseRad = floor(baseRad * 20.0+0.5)/20.0;\t// try to snap this for window texture\n\n    // make position relative to the middle of the block\n    vec3 baseCenter = p - vec3(0.5, 0.0, 0.5);\n    float height = rand.w*rand.z + 0.1; // height of first building block\n    // Make the city skyline higher in the middle of the city.\n    float downtown = saturate(4.0 / length(pint.xy));\n    height *= downtown;\n    height *= 0.5+(baseRad-0.15)*20.0;\n    height += 0.1;\t// minimum building height\n    //height += sin(iTime + pint.x);\t// animate the building heights if you're feeling silly\n    height = floor(height*20.0)*0.05;\t// height is in floor units - each floor is 0.05 high.\n\tfloat d = sdBox(baseCenter, vec3(baseRad, height, baseRad)); // large building piece\n\n    // road\n    d = min(d, p.y);\n\n    //if (length(pint.xy) > 8.0) return vec2(d, mat);\t// Hack to LOD in the distance\n\n    // height of second building section\n    float height2 = max(0.0, rand.y * 2.0 - 1.0) * downtown;\n    height2 = floor(height2*20.0)*0.05;\t// floor units\n    rand2 = floor(rand2*20.0)*0.05;\t// floor units\n    // size pieces of building\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad, height2 - rand2.y, baseRad*0.4)));\n\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.4, height2 - rand2.x, baseRad)));\n    // second building section\n    if (rand2.y > 0.25)\n    {\n\t\td = min(d, sdBox(baseCenter - vec3(0.0, height, 0.0), vec3(baseRad*0.8, height2, baseRad*0.8)));\n        // subtract off piece from top so it looks like there's a wall around the roof.\n        float topWidth = baseRad;\n        if (height2 > 0.0) topWidth = baseRad * 0.8;\n\t\td = max(d, -sdBox(baseCenter - vec3(0.0, height+height2, 0.0), vec3(topWidth-0.0125, 0.015, topWidth-0.0125)));\n    }\n    else\n    {\n        // Cylinder top section of building\n\t\tif (height2 > 0.0) d = min(d, cylCap((baseCenter - vec3(0.0, height, 0.0)).xzy, baseRad*0.8, height2));\n    }\n    // mini elevator shaft boxes on top of building\n\td = min(d, sdBox(baseCenter - vec3((rand.x-0.5)*baseRad, height+height2, (rand.y-0.5)*baseRad),\n                     vec3(baseRad*0.3*rand.z, 0.1*rand2.y, baseRad*0.3*rand2.x+0.025)));\n    // mirror another box (and scale it) so we get 2 boxes for the price of 1.\n    vec3 boxPos = baseCenter - vec3((rand2.x-0.5)*baseRad, height+height2, (rand2.y-0.5)*baseRad);\n    float big = sign(boxPos.x);\n    boxPos.x = abs(boxPos.x)-0.02 - baseRad*0.3*rand.w;\n\td = min(d, sdBox(boxPos,\n    vec3(baseRad*0.3*rand.w, 0.07*rand.y, baseRad*0.2*rand.x + big*0.025)));\n\n    // Put domes on some building tops for variety\n    if (rand.y < 0.04)\n    {\n        d = min(d, length(baseCenter - vec3(0.0, height, 0.0)) - baseRad*0.8);\n    }\n\n    // Transamerica pyramid special-case building.\n    if ((pint.x == 0.0) && (pint.y == 1.0)) {\n        vec3 slice = abs(baseCenter) - 0.25;\n    \td = max(max(slice.x + slice.y * 0.1, slice.z + slice.y * 0.1), baseCenter.y - 2.55);\n        d = min(d, sdBox(baseCenter - vec3(0.0, 1.2, 0.0), vec3(0.05, 0.9, 0.17)));\n\n    } //else\n    //d = max(d, p.y);  // flatten the city for debugging cars\n\n    // Need to make a material variable.\n    vec2 distAndMat = vec2(d, 0.0);\n    // sidewalk box with material\n    distAndMat = matmin(distAndMat, vec2(sdBox(baseCenter, vec3(0.35, 0.005, 0.35)), 1.0));\n\n    return distAndMat;\n}\n\n// landmark ideas\n// gg bridge\n// lombard\n// pier 39\n// transamerica\n// salesforce tower?\n// alcatraz\n// coit tower\n// figma office\n\nvec2 Render3dText(vec3 p, vec3 textOrigin, float angle, int start, int len, float scale) {\n\t// Load the font texture's distance field.\n    vec3 p2 = p - textOrigin;\n    vec3 pr = RotateY(p2.xyz, angle)/scale + vec3(6+start, 0.0, 0.0);\n    float letterDistField = ((SampleFontTex(pr.xy).w - 0.5) + 1.0 / 256.0)*wordScales[currentText];\n    vec3 boxDim = abs(RotateY(vec3(float(len) * 0.5, 0.5, 0.1025), angle)) * scale;\n    float cropBox = sdBox(p + vec3(0.0, 0.0, 0.0) - textOrigin, boxDim);\n    return vec2(max(cropBox, letterDistField), 5.0);\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec2 DistanceToObject(vec3 p)\n{\n    vec3 origp = p;\n    p.y = Hills(p);\n    vec3 rep = p;\n    rep.xz = fract(p.xz); // [0..1] for representing the position in the city block\n    vec2 pint = floor(p.xz);\n    vec2 distAndMat = CityBlock(rep, pint);\n\n    float blockHill = Hills(vec3(pint.x, 0, pint.y));\n    if ((blockHill > -parkHeight) || (pint.y > 15.0)) distAndMat = matmax(distAndMat, vec2(p.y, 4.0));\n\n    // Make an extra hill (mirrored) at the 2 ends of the Golden Gate Bridge\n    vec3 hillPos = p + vec3(6.0, 3.65, -20.0);\n    hillPos.z = abs(hillPos.z-12.8)-12.8;\n    //float d = length(hillPos * vec3(2.0, 1.0, 1.0)) / vec3(2.0,1.0,1.0) - 4.0;\n    vec3 r = vec3(8.0, 4.0, 1.0);\n    // Ellipse distance field\n    float k0 = length(hillPos/r);\n    float k1 = length(hillPos/(r*r));\n    float d = k0*(k0-1.0)/k1;\n\n    // Add noise and smooth blend it into the landscape.\n    float noiseTemp = NoiseGen(hillPos.xz*2.0)*0.25;\n    noiseTemp += NoiseGen(hillPos.xz*16.0)*0.0625*0.25;\n    distAndMat.x = smin(distAndMat.x, d + noiseTemp, -2.2);\n\n    // Set up the cars. This is doing a lot of mirroring and repeating because I\n    // only want to do a single call to the car distance function for all the\n    // cars in the scene. And there's a lot of traffic!\n    vec3 p2 = p;\n    rep.xyz = p2;\n    float carTime = localTime*0.2;  // Speed of car driving\n    float crossStreet = 1.0;  // whether we are north/south or east/west\n    float repeatDist = 0.25;  // Car density bumper to bumper\n    // If we are going north/south instead of east/west (?) make cars that are\n    // stopped in the street so we don't have collisions.\n    if (abs(fract(rep.x)-0.5) < 0.35)\n    {\n        p2.x += 0.05;\n        p2.xz = p2.zx * vec2(-1.0,1.0);  // Rotate 90 degrees\n        rep.xz = p2.xz;\n        crossStreet = 0.0;\n        repeatDist = 0.1;  // Denser traffic on cross streets\n    }\n\n    rep.z += floor(p2.x);\t// shift so less repitition between parallel blocks\n    rep.x = Repeat(p2.x - 0.5, 1.0);\t// repeat every block\n    rep.z = rep.z*sign(rep.x);\t// mirror but keep cars facing the right way\n    rep.x = (rep.x*sign(rep.x))-0.09;\n    rep.z -= carTime * crossStreet;\t// make cars move\n    float uniqueID = floor(rep.z/repeatDist);\t// each car gets a unique ID that we can use for colors\n    rep.z = Repeat(rep.z, repeatDist);\t// repeat the line of cars every quarter block\n    rep.x += (Hash11(uniqueID)*0.075-0.01);\t// nudge cars left and right to take both lanes\n    float frontBack = Hash11(uniqueID*0.987)*0.18-0.09;\n    frontBack *= sin(localTime*2.0 + uniqueID);\n    rep.z += frontBack * crossStreet; // nudge cars forward back for variation\n    float isBridge = 0.0;\n    if ((p.x > -7.15) && (p.x < -6.85)){\n        isBridge = 0.7;\n        rep.y = origp.y;\n    }\n    vec2 carDist = Car(rep-vec3(0.0, isBridge, 0.0), uniqueID); // car distance function\n\n    // Drop the cars in the scene with materials\n    if ((blockHill < -parkHeight) && (pint.y < 15.0) || (isBridge > 0.0)) distAndMat = matmin(distAndMat, carDist);\n\n    // ******************** Render the text ********************\n    int startIndex = wordStarts[currentText];\n    int len = wordLens[currentText];\n    vec3 tp = currentTextPos[currentText];\n    float rot = PI;\n    if ((currentText >= 2)) rot = -PI * 0.5;\n    distAndMat = matmin(distAndMat, Render3dText(p, tp, rot,\n        startIndex, len, wordScales[currentText]));\n\n    return distAndMat;\n}\n\n// This basically makes a procedural texture map for the sides of the buildings.\n// It makes a texture, a normal for normal mapping, and a mask for window reflection.\nvoid CalcWindows(vec2 block, vec3 pos, inout vec3 texColor, inout float windowRef, inout vec3 normal)\n{\n    bool pyramid =((block.x == 0.0) && (block.y == 1.0));\n\n    vec3 hue = vec3(Hash21(block)*0.8, Hash21(block*7.89)*0.4, Hash21(block*37.89)*0.5);\n    if (pyramid) hue = vec3(2.5, 1.6, 1.0)*0.8;\n    texColor += hue*0.4;\n    texColor *= 0.75;\n    float window = 0.0;\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.y*20.0-0.35)*2.0+0.1)));\n    if (pos.y < 0.05) window = 1.0;\n    float winWidth = Hash21(block*4.321)*2.0;\n    if (pyramid) winWidth = 1.0;\n    if ((winWidth < 1.2) && (winWidth >= 1.0)) winWidth = 1.2;\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.x * 40.0+0.05)*winWidth)));\n    window = max(window, mix(0.2, 1.0, floor(fract(pos.z * 40.0+0.05)*winWidth)));\n    if (window < 0.5)\n    {\n        windowRef += 1.0;\n    }\n    if (!pyramid) window *= Hash21(block*1.123);\n    texColor *= window;\n\n    if (!pyramid) {\n        float wave = floor(sin((pos.y*40.0-0.1)*PI)*0.505-0.5)+1.0;\n        normal.y -= max(-1.0, min(1.0, -wave*0.5));\n        float pits = min(1.0, abs(sin((pos.z*80.0)*PI))*4.0)-1.0;\n        normal.z += pits*0.25;\n        pits = min(1.0, abs(sin((pos.x*80.0)*PI))*4.0)-1.0;\n        normal.x += pits*0.25;\n    }\n}\n\nvec4 RayTraceBridgeTower(vec3 pos, vec3 dirVecN) {\n    vec3 rayInv = 1.0 / dirVecN;\n    vec4 rh = BoxIntersect(pos, rayInv, vec3(0.0, 1.135, 0.0), vec3(0.03, 2.27, 0.08)*0.5);\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 1.135, 0.0), vec3(0.03, 2.27, 0.08)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.6, 0.0), vec3(0.08, 1.2, 0.14)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.6, 0.0), vec3(0.08, 1.2, 0.14)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.775, 0.0), vec3(0.06, 1.55, 0.12)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.775, 0.0), vec3(0.06, 1.55, 0.12)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.95, 0.0), vec3(0.04, 1.9, 0.10)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.95, 0.0), vec3(0.04, 1.9, 0.10)*0.5));\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.325, 0.0), vec3(0.1, 0.65, 0.16)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.325, 0.0), vec3(0.1, 0.65, 0.16)*0.5));\n    return rh;\n}\n\nvoid MakeCables(inout vec4 cables, vec3 hitPos) {\n    if ((hitPos.y > 2.3) || (hitPos.y < 0.65) || (abs(hitPos.z) > 12.8)) cables.w = farPlane;\n    else {\n        vec3 tempNormal = cables.xyz;\n        float repz = Repeat(hitPos.z+6.4, 12.8);\n        float base = hitPos.y - 0.75;\n        float curve = 0.0365;\n        bool isSmallCable = (abs(repz * repz) * curve) > base;\n        float reps = Repeat(repz, 0.15);\n        if (reps < 0.065) isSmallCable = false;\n        bool isBigCable = abs((abs(repz * repz) * curve) - base) < 0.0125;\n        float cablePosY = -((abs(repz * repz) * curve) - base)*50.0;\n        if (isBigCable) tempNormal = normalize(tempNormal + vec3(0.0, cablePosY, 0.0));\n        //tempNormal = vec3(0.0, -1.0, 0.0);\n        if ((!isBigCable) && (!isSmallCable)) cables.w = farPlane;\n        else cables.xyz = tempNormal;\n    }\n}\n\nvec4 RayTraceGoldenGateBridge(vec3 pos, vec3 dirVecN) {\n    vec3 rayInv = 1.0 / dirVecN;\n    vec4 rh = BoxIntersect(pos, rayInv, vec3(0.0, 0.65, 0.0), vec3(0.27, 0.1, 25.6)*0.5);\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(-0.15, 0.0, -6.4), dirVecN));\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(0.15, 0.0, -6.4), dirVecN));\n\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(-0.15, 0.0, 6.4), dirVecN));\n    rh = Union(rh, RayTraceBridgeTower(pos + vec3(0.15, 0.0, 6.4), dirVecN));\n\n    vec4 struts = PlaneIntersect(pos, dirVecN, vec3(0.0, 0, 1.0), vec3(-6.4));\n    vec3 hitPos = pos + dirVecN * struts.w;\n    if ((abs(hitPos.x) < 0.135) && (hitPos.y < 2.27) && (hitPos.y > 1.0)) {\n        float repy = Repeat(hitPos.y, 0.35);\n\t\tif (repy < -0.05) rh = Union(rh, struts);\n    }\n    struts = PlaneIntersect(pos, dirVecN, vec3(0.0, 0, 1.0), vec3(6.4));\n    hitPos = pos + dirVecN * struts.w;\n    if ((abs(hitPos.x) < 0.135) && (hitPos.y < 2.27) && (hitPos.y > 1.0)) {\n        float repy = Repeat(hitPos.y, 0.35);\n\t\tif (repy < -0.05) rh = Union(rh, struts);\n    }\n    hitPos = pos + dirVecN * rh.w;\n    if (abs(rh.z) > 0.9) {\n\t\trh.xyz = normalize(rh.xyz + vec3(abs(Repeat(hitPos.x, 0.05)), 0.0, 0.0)*75.0);\n    }\n\n    vec4 cables = PlaneIntersect(pos, dirVecN, vec3(1.0, 0.0, 0.0), vec3(0.135, 0.0, 0.0));\n    hitPos = pos + dirVecN * cables.w;\n    MakeCables(cables, hitPos);\n    rh = Union(rh, cables);\n\n    cables = PlaneIntersect(pos, dirVecN, vec3(1.0, 0.0, 0.0), vec3(-0.135, 0.0, 0.0));\n    hitPos = pos + dirVecN * cables.w;\n    MakeCables(cables, hitPos);\n    rh = Union(rh, cables);\n\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.0, -6.4), vec3(0.8, 0.1, 0.3)*0.5));\n    rh = Union(rh, BoxIntersect(pos, rayInv, vec3(0.0, 0.0, 6.4), vec3(0.8, 0.1, 0.3)*0.5));\n\n    return rh;\n}\n\n// Input is UV coordinate of pixel to render.\n// Output is RGB color.\nvec3 RayTrace(in vec2 fragCoord )\n{\n\t// -------------------------------- animate ---------------------------------------\n\tsunDir = normalize(vec3(0.2, 1.0, 0.9));\n    vec3 sunCol = vec3(250.0, 220.0, 200.0) / 155.0;\n    vec3 horizonCol = vec3(0.75, 0.7, 0.85)*1.5;\n    vec3 skyCol = vec3(0.02,0.45,1.0)*0.7;\n\tvec3 groundCol = vec3(0.8,0.75,0.67)*0.45;\n    currentText = 0;\n    float exposure = 1.0;\n\n\tvec3 camPos, camUp, camLookat;\n    camUp = vec3(0,1,0);\n\t// ------------------- Set up the camera rays for ray marching --------------------\n    // Map uv to [-1.0..1.0]\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    uv /= 2.0;  // zoom in\n\n    // Do the camera fly-by animation and different scenes.\n    // Time variables for start and end of each scene\n    // Repeat the animation after time t6\n    float keyEnd = keys[numKeyFrames - 1];\n    localTime = fract(localTime / keyEnd) * keyEnd;// + keys[6];\n    if (localTime < keys[1])\n    {\n        currentText = 0;\n        float time = localTime - keys[0];\n        exposure = saturate(time+0.1);\n        float alpha = time / (keys[1] - keys[0]);\n        camPos = vec3(7.0, 1.4, 27.5);\n        camPos.x -= smoothstep(0.0, 1.0, alpha) * 11.5;\n        camPos.z += smoothstep(0.0, 1.0, alpha) * 15.0;\n        camUp=vec3(0,1,0);\n        camLookat=vec3(-8,1.5,32.0);\n    } else if (localTime < keys[2]) {\n        currentText = 0;\n        camPos = vec3(7.0, 1.4, 27.5);\n        camPos.x -= 11.5;\n        camPos.z += 15.0;\n        camLookat=vec3(-8,1.5,32.0);\n    } else if (localTime < keys[3]) {\n        float time = localTime - keys[2];\n        float alpha = time / (keys[3] - keys[2]);\n        alpha = saturate(alpha*1.4);\n        if (alpha > 0.33) currentText = 1;\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(-4.5, 1.4, 42.5);\n        camPos += vec3(2.0, -0.5, -23) * salpha;\n\n        camLookat=vec3(-8,1.5,32.0);\n        camLookat += vec3(8, -1.5, -24) * salpha;\n    } else if (localTime < keys[4]) {\n        currentText = 2;\n        float time = localTime - keys[3];\n        float alpha = time / (keys[4] - keys[3]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(2, 2.3, 2.5);\n        camPos += vec3(0, 2.0, -2.1) * salpha;\n        camLookat=vec3(0.5,3.2,1.5);\n        camLookat.y += 1.0 * salpha;\n    } else if (localTime < keys[5]) {\n        currentText = 3;\n        float time = localTime - keys[4];\n        float alpha = time / (keys[5] - keys[4]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(21, 0.1, 1.5);\n        camPos += vec3(-3.6, 0.6, 1.0) * salpha;\n        camLookat=vec3(0.5,3.2,1.5);\n        sunDir = normalize(vec3(3,1,1));\n    } else if (localTime < keys[6]) {\n        currentText = 4;\n        float time = localTime - keys[5];\n        float alpha = time / (keys[6] - keys[5]);\n        alpha = saturate(alpha*1.4);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(14.5, 0.3, 1.0);\n        camPos += vec3(-2.97, 0.4, -0.1) * salpha;\n        camLookat=vec3(0.5,0.2,1.0);\n        sunDir = normalize(vec3(1.3,1,1.1));\n    } else if (localTime < keys[7]) {\n        currentText = 5;\n        float time = localTime - keys[6];\n        float alpha = time / (keys[7] - keys[6]);\n        alpha = saturate(alpha*1.7);\n        float salpha = smoothstep(0.0, 1.0, alpha);\n        camPos = vec3(12.0, 0.5, 32.7);\n        camPos += vec3(-11.0, 0.0, 0.0) * salpha;\n        camLookat=vec3(-10.5,0.2,32.7);\n\n        sunDir = normalize(vec3(-10.95, -1.3, 0.1));\n        sunCol = vec3(258.0, 60.0, 10.0) / 35.0;\n        exposure *= 0.2;\n        horizonCol = vec3(1.0, 0.25, 0.08)*1.95;\n        skyCol = vec3(0.15,0.5,0.95);\n    }\n#ifdef MANUAL_CAMERA\n    if (length(iMouse.xy) > 10.0) {\n        // Camera up vector.\n        camUp=vec3(0,1,0);\n\n        // Camera lookat.\n        camLookat=vec3(0.0,0.0,12.0);\n\n        // debugging camera\n        float mx=-iMouse.x/iResolution.x*PI*2.0;// + localTime * 0.05;\n        float my=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;// + sin(localTime * 0.3)*0.8+0.1;//*PI/2.01;\n        camPos = camLookat + vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*8.0;\n    }\n#endif\n\n\t// Camera setup for ray tracing / marching\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;\n\tvec3 rayVec = normalize(worldPix - camPos);\n\n\t// ----------------------------- Ray march the scene ------------------------------\n\tvec2 distAndMat;  // Distance and material\n\tfloat t = 0.05;// + Hash2d(uv)*0.1;\t// random dither-fade things close to the camera\n\tfloat maxDepth = 55.0; // farthest distance rays will travel\n\tvec3 pos = vec3(0.0);\n    const float smallVal = 0.000625;\n\n    int rtMaterial = 0;\n\tvec4 rh = RayTraceGoldenGateBridge(camPos + vec3(7.0, 0.0, -32.7), rayVec);\n\n    if (rh.w < maxDepth) {\n        maxDepth = min(maxDepth, rh.w);\n        rtMaterial = 1;\n    }\n    vec4 waterPlane = PlaneIntersect(camPos, rayVec, vec3(0.0, 1.0, 0.0), vec3(0.0));\n    rh = Union(rh, waterPlane);\n    if ((waterPlane.w == rh.w) && (waterPlane.w < farPlane)) {\n        rtMaterial = 2;\n        maxDepth = min(maxDepth, rh.w);\n    }\n\n    // ray marching time\n    for (int i = 0; i < 250; i++)\t// This is the count of the max times the ray actually marches.\n    {\n        // Step along the ray.\n        pos = (camPos + rayVec * t);\n        // This is _the_ function that defines the \"distance field\".\n        // It's really what makes the scene geometry. The idea is that the\n        // distance field returns the distance to the closest object, and then\n        // we know we are safe to \"march\" along the ray by that much distance\n        // without hitting anything. We repeat this until we get really close\n        // and then break because we have effectively hit the object.\n        distAndMat = DistanceToObject(pos);\n\n        // 2d voxel walk through the city blocks.\n        // The distance function is not continuous at city block boundaries,\n        // so we have to pause our ray march at each voxel boundary.\n        float walk = distAndMat.x;\n        float dx = -fract(pos.x);\n        if (rayVec.x > 0.0) dx = fract(-pos.x);\n        float dz = -fract(pos.z);\n        if (rayVec.z > 0.0) dz = fract(-pos.z);\n        float nearestVoxel = min(fract(dx/rayVec.x), fract(dz/rayVec.z))+voxelPad;\n        nearestVoxel = max(voxelPad, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n        //nearestVoxel = max(nearestVoxel, t * 0.02); // hack to stop voxel walking in the distance.\n        walk = min(walk, nearestVoxel);\n\n        // move down the ray a safe amount\n        t += walk;\n        // If we are very close to the object, let's call it a hit and exit this loop.\n        if ((t > maxDepth) || (abs(distAndMat.x) < smallVal)) break;\n    }\n    \n    // Combine ry tracing and ray marching results.\n    if (abs(distAndMat.x) < smallVal) rtMaterial = 0;\n    else {\n        t = rh.w;\n        pos = camPos + rayVec * t;\n    } \n\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\tvec3 finalColor = vec3(0.0);\n\n\t// If a ray actually hit the object, let's light it.\n    if ((t <= maxDepth) || (rtMaterial > 0))\n\t{\n        float dist = distAndMat.x;\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(smallVal, 0, 0);\n/*        vec3 normalU = vec3(dist - DistanceToObject(pos - smallVec.xyy).x,\n                           dist - DistanceToObject(pos - smallVec.yxy).x,\n                           dist - DistanceToObject(pos - smallVec.yyx).x);\n        vec3 normal = normalize(normalU);*/\n        vec3 normalU = vec3(0.0);\n        for( int i=min(0,iFrame); i<4; i++ )\n        {\n            vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n            normalU += e*DistanceToObject(pos+0.0005*e).x;\n        }\n\n        vec3 normal = normalize(normalU);\n        if (rtMaterial > 0) normal = rh.xyz;\n\n        // calculate ambient occlusion.\n        float ff = 0.0125;\n        float aa = 80.0;\n        float ambient = 1.0;\n        for( int i=min(0,iFrame); i<6; i++ )\n        {\n            ambient *= saturate(DistanceToObject(pos + normal * ff).x*aa);\n            ff *= 2.0;\n            aa /= 2.0;\n        }\n\n/*        float ambient = 1.0;\n        ambient *= saturate(DistanceToObject(pos + normal * 0.0125).x*80.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.025).x*40.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.05).x*20.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambient *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);*/\n        ambient = max(0.025, pow(ambient, 0.5));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n        float ambientAvg = ambient;// (ambient*3.0 + ambientS) * 0.25;\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(rayVec, normal);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        if (length(pos.xz) < 20.0) {\n            float iter = 0.01;\n            vec3 nudgePos = pos + normal*0.002;\t// don't start tracing too close or inside the object\n            for (int i = 0; i < 40; i++)\n            {\n                vec3 shadowPos = nudgePos + sunDir * iter;\n                float tempDist = DistanceToObject(shadowPos).x;\n                sunShadow *= saturate(tempDist*150.0);\t// Shadow hardness\n                if (tempDist <= 0.0) break;\n\n                float walk = tempDist;\n                float dx = -fract(shadowPos.x);\n                if (sunDir.x > 0.0) dx = fract(-shadowPos.x);\n                float dz = -fract(shadowPos.z);\n                if (sunDir.z > 0.0) dz = fract(-shadowPos.z);\n                float nearestVoxel = min(fract(dx/sunDir.x), fract(dz/sunDir.z))+smallVal;\n                nearestVoxel = max(0.2, nearestVoxel);// hack that assumes streets and sidewalks are this wide.\n                walk = min(walk, nearestVoxel);\n\n                iter += max(0.01, walk);\n                if (iter > 4.5) break;\n            }\n            sunShadow = saturate(sunShadow);\n        \t// Raytraced shadows\n\t\t\t//vec4 rhs = RayTraceGoldenGateBridge(nudgePos + vec3(7.0, 0.0, -32.7), sunDir);\n        \t//if (rhs.w < farPlane) sunShadow = 0.0;\n        }\n\n        // make a few frequencies of noise to give it some texture\n        float n =0.0;\n        n += noise2d(pos.xz*32.0);\n        n += noise2d(pos.xz*64.0);\n        n += noise(fract(pos)*128.0);\n        n += noise(fract(pos)*256.0);\n        n += noise(fract(pos)*512.0);\n        n = mix(0.7, 0.95, n);\n\n        // ------ Calculate texture color  ------\n    \tfloat posHilly = Hills(pos);\n        vec2 block = floor(pos.xz);\n        vec3 texColor = vec3(0.95, 1.0, 1.0);\n        texColor *= 0.8;\n        float windowRef = 0.0;\n        // texture map the sides of buildings\n        if ((normal.y < 0.1) && (distAndMat.y == 0.0))\n        {\n            vec3 posdx = dFdx(pos);\n            vec3 posdy = dFdy(pos);\n            vec3 posGrad = posdx * Hash21(uv) + posdy * Hash21(uv*7.6543);\n\n            // Quincunx antialias the building texture and normal map.\n            // I guess procedural textures are hard to mipmap.\n            vec3 colTotal = vec3(0.0);\n            vec3 colTemp = texColor;\n            vec3 nTemp = vec3(0.0);\n            CalcWindows(block, pos, colTemp, windowRef, nTemp);\n            colTotal = colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.666 + posdy * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdy * 0.666, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            colTemp = texColor;\n            CalcWindows(block, pos + posdx * 0.333 + posdy * 0.333, colTemp, windowRef, nTemp);\n            colTotal += colTemp;\n\n            texColor = colTotal * 0.2;\n            windowRef *= 0.2;\n\n            normal = normalize(normal + nTemp * 0.2);\n        }\n        else\n        {\n            // Draw the road\n            float xroad = abs(fract(pos.x+0.5)-0.5);\n            float zroad = abs(fract(pos.z+0.5)-0.5);\n            float road = saturate((min(xroad, zroad)-0.143)*480.0);\n            texColor *= 1.0-normal.y*0.95*Hash21(block*9.87)*road; // change rooftop color\n            texColor *= mix(0.1, 1.0, road);\n\n            // double yellow line in middle of road\n            float yellowLine = saturate(1.0-(min(xroad, zroad)-0.002)*480.0);\n            yellowLine *= saturate((min(xroad, zroad)-0.0005)*480.0);\n            yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n            texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\n\n            // white dashed lines on road\n            float whiteLine = saturate(1.0-(min(xroad, zroad)-0.06)*480.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.056)*480.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n            whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\n            whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\n            texColor = mix(texColor, vec3(0.5), whiteLine);\n\n            whiteLine = saturate(1.0-(min(xroad, zroad)-0.11)*480.0);\n            whiteLine *= saturate((min(xroad, zroad)-0.106)*480.0);\n            whiteLine *= saturate((xroad*xroad+zroad*zroad-0.06)*880.0);\n            texColor = mix(texColor, vec3(0.5), whiteLine);\n\n            // crosswalk\n            float crossWalk = saturate(1.0-(fract(xroad*40.0)-0.5)*280.0);\n            crossWalk *= saturate((zroad-0.15)*880.0);\n            crossWalk *= saturate((-zroad+0.21)*880.0)*(1.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.25), crossWalk);\n            crossWalk = saturate(1.0-(fract(zroad*40.0)-0.5)*280.0);\n            crossWalk *= saturate((xroad-0.15)*880.0);\n            crossWalk *= saturate((-xroad+0.21)*880.0)*(1.0-road);\n            crossWalk *= n*n;\n            texColor = mix(texColor, vec3(0.25), crossWalk);\n\n            {\n                // sidewalk cracks\n                float sidewalk = 1.0;\n                vec2 blockSize = vec2(100.0);\n                if (posHilly > 0.1) blockSize = vec2(10.0, 50);\n                //sidewalk *= pow(abs(sin(pos.x*blockSize)), 0.025);\n                //sidewalk *= pow(abs(sin(pos.z*blockSize)), 0.025);\n                sidewalk *= saturate(abs(sin(pos.z*blockSize.x)*800.0/blockSize.x));\n                sidewalk *= saturate(abs(sin(pos.x*blockSize.y)*800.0/blockSize.y));\n                sidewalk = saturate(mix(0.7, 1.0, sidewalk));\n                sidewalk = saturate((1.0-road) + sidewalk);\n                texColor *= sidewalk;\n            }\n        }\n        // Car tires are almost black to not call attention to their ugly.\n        if (distAndMat.y == 3.0)\n        {\n            texColor = vec3(0.05);\n        }\n\n        // apply noise\n        texColor *= vec3(1.0)*n;//*0.05;\n        texColor *= 0.7;\n        texColor = saturate(texColor);\n\n        float windowMask = 0.0;\n        if (distAndMat.y >= 100.0)\n        {\n            // car texture and windows\n            texColor = vec3(Hash11(distAndMat.y)*1.0, Hash11(distAndMat.y*8.765), Hash11(distAndMat.y*17.731))*0.1;\n            texColor = pow(abs(texColor), vec3(0.2));  // bias toward white\n            texColor = max(vec3(0.25), texColor);  // not too saturated color.\n            texColor.z = min(texColor.y, texColor.z);  // no purple cars. just not realistic. :)\n            texColor *= Hash11(distAndMat.y*0.789) * 0.15;\n            windowMask = saturate( max(0.0, abs(posHilly - 0.0175)*3800.0)-10.0);\n            vec2 dirNorm = abs(normalize(normal.xz));\n            float pillars = saturate(1.0-max(dirNorm.x, dirNorm.y));\n            pillars = pow(max(0.0, pillars-0.15), 0.125);\n            windowMask = max(windowMask, pillars);\n            texColor *= windowMask;\n            texColor *= 10.0;\n            //if (normal.x > .995) texColor = vec3(0.02);\n        } else\n        // Parks, beach\n        if (distAndMat.y == 4.0) {\n            vec3 grassCol = vec3(0.45, 0.7, 0.3)*0.345;\n            vec3 dirtCol = vec3(1.0, 0.8, 0.5)*0.46;\n            texColor = mix(dirtCol, grassCol, saturate(n-0.4));\n            dirtCol = vec3(1.3, 0.45, 0.2)*0.1;\n            texColor = mix(dirtCol, texColor, saturate(normal.y*normal.y*normal.y*normal.y));\n            //texColor = mix(vec3(0.35, 0.32, 0.3), grassCol, saturate(normal.y-0.4));\n            // Fade to beach\n            vec3 beachCol = vec3(1.0, 0.85, 0.7)*0.3*(n+0.8);\n            texColor = mix(texColor, beachCol, saturate((0.015-pos.y)*200.0));\n            //if (pos.y < 0.003) texColor = vec3(1.0, 0.9, 0.8)*0.04;\n        } else if (distAndMat.y == 5.0) {\n            // Letters\n            texColor = mix(vec3(0.97, 0.2, 0.1), vec3(1.0, 1.0, 0.1), abs(normal.z));\n        }\n\n        // Golden Gate Bridge\n        if (rtMaterial == 1) {\n\t        if (rtMaterial > 0) normal = rh.xyz;\n            float bridgeX = 7.0;\n            texColor = vec3(1.0, 0.2, 0.1)*0.6;\n            ambient = 1.0;\n            if (pos.y < 0.125) texColor = vec3(0.55, 0.4, 0.3)*0.5*n*saturate(pos.y*10.0);\n            if ((pos.y > 0.62) && (pos.y < 0.68) && (abs(pos.x+bridgeX) < 0.14)) {\n                texColor = mix(texColor, texColor * 0.2, saturate((abs(Repeat(pos.z, 0.15))-0.02) * 30.0));\n            }\n            if ((pos.y > 0.68) && (pos.y < 0.72) && (abs(pos.x+bridgeX) < 0.128) && (normal.y == 1.0)) {\n                // Road pavement on bridge\n                texColor = vec3(0.1);\n\n                float xroad = abs(fract(pos.x+bridgeX+0.5)-0.5);\n                float zroad = abs(fract(pos.z+0.5)-0.5);\n                //float road = saturate((min(xroad, zroad)-0.143)*480.0);\n                // double yellow line in middle of road\n                float yellowLine = saturate(1.0-(xroad-0.002)*480.0);\n                yellowLine *= saturate((xroad-0.0005)*480.0);\n                //yellowLine *= saturate((xroad*xroad+zroad*zroad-0.05)*880.0);\n                texColor = mix(texColor, vec3(1.0, 0.8, 0.3), yellowLine);\n\n                // white dashed lines on road\n                float whiteLine = saturate(1.0-(xroad-0.06)*480.0);\n                whiteLine *= saturate((xroad-0.056)*480.0);\n                whiteLine *= saturate(1.0-(fract(zroad*8.0)-0.5)*280.0);  // dotted line\n                //whiteLine *= saturate(1.0-(fract(xroad*8.0)-0.5)*280.0);\n                texColor = mix(texColor, vec3(0.45), whiteLine);\n\n                whiteLine = saturate(1.0-(xroad-0.11)*480.0);\n                whiteLine *= saturate((xroad-0.106)*480.0);\n                texColor = mix(texColor, vec3(0.5), whiteLine);\n                texColor *= vec3(0.7)*n;\n                texColor = saturate(texColor);\n            }\n        }\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = (sunCol * saturate(dot(normal, sunDir))) * sunShadow;\n        // Add sky color with ambient acclusion\n        lightColor += (skyCol * saturate(normal.y *0.5+0.5))*pow(ambientAvg, 0.35)*0.35;\n        // Ground light\n        lightColor += (groundCol * saturate(-normal.y *0.5+0.5)) * 0.25 * ambientAvg;\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n        // Reflections for cars\n        if ((distAndMat.y >= 100.0) && (rtMaterial == 0))\n        {\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\n            // low-res way of making lines at the edges of car windows. Not sure I like it.\n            yfade *= (saturate(1.0-abs(dFdx(windowMask)*dFdy(windowMask))*250.995));\n            finalColor += GetEnvMapSkyline(ref, sunDir, posHilly-1.5, sunCol, horizonCol, skyCol)*\n                0.3*yfade*max(0.4,sunShadow);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.2,sunShadow);\n        }\n        // reflections for building windows\n        if ((windowRef != 0.0) && (rtMaterial == 0))\n        {\n            finalColor *= mix(1.0, 0.6, windowRef);\n            float yfade = max(0.01, min(1.0, ref.y*100.0));\n            finalColor += GetEnvMapSkyline(ref, sunDir, posHilly-0.5, sunCol, horizonCol, skyCol)\n                *0.6*yfade*max(0.6,sunShadow)*windowRef;//*(windowMask*0.5+0.5);\n            finalColor += saturate(texture(iChannel0, ref).xyz-0.35)*0.15*max(0.25,sunShadow)*windowRef;\n        }\n        // water\n        if ((pos.y <= 0.001f) || (rtMaterial == 2)) {\n            if (rtMaterial == 2){\n                pos.y = -10.1f;\n                //finalColor = vec3(0.0);\n            }\n            /*float waterNoise = noise2d(pos.xz*4.0+localTime)*0.1 +\n                noise2d(pos.xz*8.0+localTime)*0.03 +\n                noise2d(pos.xz*16.0-localTime)*0.015 +\n                noise2d(pos.xz*32.0-localTime)*0.005 +\n                noise2d(pos.xz*64.0-localTime)*0.002;\n            // Fade the waves a bit in the distance.\n            float r = dot(pos.xz, pos.xz);\n            waterNoise = waterNoise * saturate(1.0/(r));\n            vec3 dx = vec3(1.0, dFdx(waterNoise)*8000.0, 0.0);\n            vec3 dy = vec3(0.0, dFdy(waterNoise)*8000.0, 1.0);\n            normal = -cross(dx, dy);*/\n\n            vec2 sp = pos.xz * 2.0;\n            vec2 waterNoise = NoiseTex(vec3(sp.x*32.0, sp.y*32.0 + localTime, localTime))*0.125;\n            waterNoise += NoiseTex(vec3(sp.x*16.0 + localTime, sp.y*16.0, localTime+0.2))*0.25;\n            waterNoise += NoiseTex(vec3(sp.x*8.0, sp.y*8.0 - localTime, localTime+0.4))*0.5;\n            waterNoise += NoiseTex(vec3(sp.x*4.0 - localTime, sp.y*4.0, localTime+0.6));\n\t        ref = reflect(rayVec, normalize(normal + vec3(waterNoise.x, 0.0, waterNoise.y)* 0.4));\n            ref.y = abs(ref.y);\n\n            // This make the water either reflect or refract with the right amount\n            // Schlick's approximation\n            float oneMinusCos = 1.0 - saturate(dot(rayVec, -normal));\n            float fresnel = 0.02;  // reflectance\n            float reflectProb = fresnel + (1.0-fresnel) * pow(oneMinusCos, 5.0);\n\n            float waterDepth = saturate(1.0+pos.y*256.0);\n            vec3 waterColor = mix(vec3(0.025, 0.35, 0.1)*0.2 * lightColor, finalColor, waterDepth);\n            vec3 env = GetEnvMapSimple(ref, sunDir, sunCol, horizonCol, skyCol);\n            float bridgeX = 7.0;\n\t\t\tvec4 rh = BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 10.0, -32.7+6.4), vec3(0.3, 1.55*2.0, 0.1));\n\t\t\trh = Union(rh, BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 10.0, -32.7-6.4), vec3(0.3, 1.55*2.0, 0.1)));\n\t\t\trh = Union(rh, BoxIntersect(pos, 1.0/normalize(ref), -vec3(7.0, 9.3, -32.7), vec3(0.2, 0.1, 32.7)));\n            if (rh.w < farPlane) env *= vec3(0.3, 0.15, 0.15);\n            waterColor = mix(waterColor*0.75, env, reflectProb);\n        \tfinalColor = mix(finalColor, waterColor, saturate((0.0-pos.y)*2048.0));\n        }\n        // fog\n        vec3 rv2 = rayVec;\n        rv2.y *= saturate(sign(rv2.y));\n        vec3 fogColor = groundCol*0.7 + horizonCol * 0.3;\n        fogColor = min(vec3(9.0), fogColor);\n        finalColor = mix(fogColor, finalColor, exp(-t*0.013));\n\n        // visualize length of gradient of distance field to check distance field correctness\n        //finalColor = vec3(0.5) * (length(normalU) / smallVec.x);\n        //finalColor = normal * 0.5 + 0.5;\n        //finalColor = vec3(ambientAvg)*0.7;\n\t}\n    else\n    {\n        // Our ray trace hit nothing, so draw sky.\n        finalColor = GetEnvMap(rayVec, sunDir, sunCol, groundCol, horizonCol, skyCol);\n    }\n\n    // vignette FTW\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/1.3));\n    finalColor *= 1.3*exposure;\n\n\t// output the final color without gamma correction - will do gamma later.\n\treturn vec3(clamp(finalColor, 0.0, 1.0));\n}\n\n#ifdef NON_REALTIME_HQ_RENDER\n// This function breaks the image down into blocks and scans\n// through them, rendering 1 block at a time. It's for non-\n// realtime things that take a long time to render.\n\n// This is the frame rate to render at. Too fast and you will\n// miss some blocks.\nconst float blockRate = 20.0;\nvoid BlockRender(in vec2 fragCoord)\n{\n    // blockSize is how much it will try to render in 1 frame.\n    // adjust this smaller for more complex scenes, bigger for\n    // faster render times.\n    const float blockSize = 64.0;\n    // Make the block repeatedly scan across the image based on time.\n    float frame = floor(iTime * blockRate);\n    vec2 blockRes = floor(iResolution.xy / blockSize) + vec2(1.0);\n    // ugly bug with mod.\n    //float blockX = mod(frame, blockRes.x);\n    float blockX = fract(frame / blockRes.x) * blockRes.x;\n    //float blockY = mod(floor(frame / blockRes.x), blockRes.y);\n    float blockY = fract(floor(frame / blockRes.x) / blockRes.y) * blockRes.y;\n    // Don't draw anything outside the current block.\n    if ((fragCoord.x - blockX * blockSize >= blockSize) ||\n    \t(fragCoord.x - (blockX - 1.0) * blockSize < blockSize) ||\n    \t(fragCoord.y - blockY * blockSize >= blockSize) ||\n    \t(fragCoord.y - (blockY - 1.0) * blockSize < blockSize))\n    {\n        discard;\n    }\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef NON_REALTIME_HQ_RENDER\n    // Optionally render a non-realtime scene with high quality\n    BlockRender(fragCoord);\n#endif\n\n    // Do a multi-pass render\n    vec3 finalColor = vec3(0.0);\n#ifdef NON_REALTIME_HQ_RENDER\n    for (float i = 0.0; i < antialiasingSamples; i++)\n    {\n        const float motionBlurLengthInSeconds = 1.0 / 60.0;\n        // Set this to the time in seconds of the frame to render.\n\t    localTime = frameToRenderHQ;\n        // This line will motion-blur the renders\n        localTime += Hash11(v21(fragCoord + seed)) * motionBlurLengthInSeconds;\n        // Jitter the pixel position so we get antialiasing when we do multiple passes.\n        vec2 jittered = fragCoord.xy + vec2(\n            Hash21(fragCoord + seed),\n            Hash21(fragCoord*7.234567 + seed)\n            );\n        // don't antialias if only 1 sample.\n        if (antialiasingSamples == 1.0) jittered = fragCoord;\n        // Accumulate one pass of raytracing into our pixel value\n\t    finalColor += RayTrace(jittered);\n        // Change the random seed for each pass.\n\t    seed *= 1.01234567;\n    }\n    // Average all accumulated pixel intensities\n    finalColor /= antialiasingSamples;\n#else\n    // Regular real-time rendering\n    localTime = iTime;\n    finalColor = RayTrace(fragCoord);\n#endif\n\n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}