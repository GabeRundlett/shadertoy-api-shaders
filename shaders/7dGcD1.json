{
    "Shader": {
        "info": {
            "date": "1654768214",
            "description": ":/",
            "flags": 0,
            "hasliked": 0,
            "id": "7dGcD1",
            "likes": 0,
            "name": "new473563479",
            "published": 3,
            "tags": [
                "hbfhjfvbf"
            ],
            "usePreview": 0,
            "username": "Igger",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "#define myPi 3.141592654f \n#define Eps 1e-8 \n#define maxZ 100.0 \n \nconst int n = 5; \nvec3 colVec[n] = vec3[n](vec3(0.98, 0.23, 0.20), vec3(0.0, 0.1, 0.57), vec3(0.99, 0.93, 0.0), vec3(1.0, 1.0, 1.0), vec3(0.9, 0.4, 0.05));\nvec3 BGcol = vec3(0.0, 0.0, 0.0);\n\n \nint sizes[n] = int[n](3, 3, 4, 3, 5), inds[n] = int[n](0, 3, 6, 10, 13); const int m = 18; \nvec2 polygonsXY[m]; float polygonsZ[m]; \n \nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){ \n// 0 -- triangle \n    polygonsXY[0] = vec2(0.02, 0.05); polygonsZ[0] = 0.9;  \n    polygonsXY[1] = vec2(0.5, 0.95); polygonsZ[1] = 0.8; \n    polygonsXY[2] = vec2(0.02, 0.95); polygonsZ[2] = 0.9; \n// 1 -- triangle \n    polygonsXY[3] = vec2(0.0, 0.0); polygonsZ[3] = 0.09; \n    polygonsXY[4] = vec2(1.0, 0.85); polygonsZ[4] = 0.11; \n    polygonsXY[5] = vec2(0.85, 1.0); polygonsZ[5] = 0.09; \n \n// 3 -- rotated square \n    float w = 2.0; \n    vec3 center = vec3(0.64, 0.5 + 0.2*cos(time*w) , 0.1); float r = 0.2; \n    int i; float j =0.0, phi = myPi/7.0; \n    float ang = 2.0*myPi/4.0;  \n    vec3 tmpVec; \n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) ); \n    for (i = 6; i < 10; i++){ \n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0));  \n        polygonsXY[i] = tmpVec.xy + center.xy; \n        polygonsZ[i] = tmpVec.z + center.z; \n        j = j + 1.0; \n    } \n     \n// 4 -- rotated triangle \n    float w2 = 3.0; \n    vec3 center2 = vec3(0.64, 0.5 + 0.2*cos(time*w) , 0.1); float R = 0.35; \n    int k; float t =0.0, phi2 = myPi/4.0;\n    float ang2 = 2.0*myPi/7.0;  \n    vec3 tmpVec2; \n    mat3 rot2 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi2), sin(phi2)), vec3(0.0, -sin(phi2), cos(phi2)) ); \n    for (k = 10; k < 13; k++){ \n        tmpVec2 = rot2*(R*vec3(cos(t*ang2 + time), sin(t*ang2 + time), 0.0));  \n        polygonsXY[k] = tmpVec2.xy + center2.xy; \n        polygonsZ[k] = tmpVec2.z + center2.z; \n        t = t + 1.0; \n    } \n    \n// 5 -- pentagon\n    polygonsXY[13] = vec2(0.1, 0.05); polygonsZ[3] = 0.9;\n    polygonsXY[14] = vec2(0.95, 0.05); polygonsZ[4] = 0.9;\n    polygonsXY[15] = vec2(0.95, 0.4); polygonsZ[5] = 0.9;\n    polygonsXY[16] = vec2(0.75, 0.4); polygonsZ[6] = 0.9;\n    polygonsXY[17] = vec2(0.6, 0.63); polygonsZ[7] = 0.9;\n     \n} \n \n \n \nint leftTurn(in vec2 a, in vec2 b, in vec2 c) \n{ \n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x); \n    if (abs(tmp) < Eps)  \n        return 0; \n    else  \n        return tmp > 0.0 ? 1: -1; \n} \n \n \nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order \n{ \n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0; \n    while(res && (i < ind0 + size -1)) \n    { \n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++; \n    } \n    return res; \n} \n \nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b) \n{ \n    vec3 nrm = cross(a-b, c-b); \n    //float D = - dot(nrm, b); \n    if (abs(nrm.z) < Eps) return a.z; \n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z; \n} \n \n \n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined \nvoid initColours (float time, vec2 uv){\n    \n    int i;\n    vec3 col;\n    float b = uv.x + uv.y;\n    float j = 0.0;\n    for (i = 0; i < 100; i++){\n        if ((b > j*0.02) && (b < (j + 1.5)*0.02))\n            if (i % 3 == 0){\n                col = 0.06 + 0.3*cos(uv.xyx+vec3(0,3,8));\n                colVec[4] = vec3(col);\n            }\n        j+= 1.0;\n        } \n        \n    \n    float w = 2.0;\n    \n    vec3 center = vec3(0.75, 0.58 + 0.4*cos(time*w) , 0.89);\n    colVec[3] = vec3(center);\n    \n    colVec[2] = vec3(1.0, 0.93, cos(3.0*time)); \n    \n} \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy; \n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time); \n    initColours(time, uv); \n    vec3 col = BGcol; float z = maxZ;  \n    int i; \n    for (i =0; i < n; i++){ \n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){ \n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv); \n            if (tmp < z){ \n                z = tmp; col = colVec[i];  \n            } \n        } \n    } \n \n \n    // Output to screen \n    fragColor = vec4(col,1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}