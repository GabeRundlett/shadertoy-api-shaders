{
    "Shader": {
        "info": {
            "date": "1610481234",
            "description": "fractato",
            "flags": 32,
            "hasliked": 0,
            "id": "ttKyRh",
            "likes": 9,
            "name": "Day 392",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "// wip\n\n\n// shadows and smoothops from iq\n\n// FXAA from mudlord?\n\n// cyclic noise from nimitz\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    \n    col = pow(col,vec3(1.03,1.03,0.95 + dot(uv,uv)*0.02));\n    \n    \n    col *= 3.3;\n    col = mix(col,smoothstep(0.,1.,col*vec3(0.95,1.,1.)*1.),0.5);\n    \n    col = mix(acesFilm(col), col, 0.);\n    \n    \n    col = mix(col,col*col*col*0.5,dot(uv,uv));\n    //col *= 1. - dot(uv,uv*0.4)*2.;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nvec2 dmin(vec2 d, float db, float dbid){return d.x < db ? d : vec2(db,dbid);}\nvec2 dmin(vec2 d, vec2 b){return d.x < b.x ? d : b;}\n\nfloat wallNoise = 0.;\nfloat wallNoiseB = 0.;\n\nvec2 sdFrac(vec3 po){\n\n    vec4 p = vec4(po,1.);\n    \n    vec2 d = vec2(10e5);\n    \n    p.xy -= 1.;\n    \n    float id = floor(p.z/4. + 0.5);\n    p.xyz = pmod(p.xyz,vec3(2.,2.,4.));\n    for(int i = 0; i < 4; i++){\n        \n        p.xyz = abs(p.xyz);\n        \n        if(p.x > p.y) p.xy = p.yx;\n        if(p.x < p.z) p.xz = p.zx;\n        if(p.y > p.z) p.yz = p.zy;\n        \n        p.xyz -= vec3(0.,0.1,0.3 - sin(id*2. )*0.1);\n        \n        p *= 4.5;\n        \n        //p.xy *= rot(0.125*pi);\n        \n    }\n    \n    \n    p.xyz /= p.w;\n    \n    p.w = 1.;\n    \n    for(int i = 0; i < 4; i++){\n        \n        float dpp = dot(p.xyz,p.xyz*1.);\n        p.xyz = pmod(p.xyz,vec3(4.3,2.,3.6));\n        \n        p.xyz = abs(p.xyz);\n        \n        p /= dpp;\n        \n        p.x -= 0.06;\n        p.y -= 0.03;\n        \n        p.z -= 0.05;\n        \n        p.zx *= rot(-0.5*pi);\n        p *= 3.;\n        \n        \n    }\n    \n    p.xyz /= p.w;\n\n    vec3 pp = p.xyz;\n    float da = length(p.xy) - 0.03;\n    //d = dmin(d, max(abs(p.x),abs(p.y)) - 0.03, ID_GOLD);\n    \n    p.xz *= rot( 0.*pi);\n    p.x += 0.07;\n    float db = max(abs(p.x),abs(p.z)) - 0.04;\n    db = length(p.xz) - 0.03;\n    \n    \n    pp.xz *= rot(-0.125*pi);\n    \n    pp -= vec3(-0.,0.01,0.1);\n    \n    \n    pp.yz *= rot(0.25*pi);\n    \n    float dc = length(pp.yz) - 0.04;\n    \n    \n    d = dmin(d, da, ID_GOLD);\n    d = dmin(d,db, ID_OTHER);\n    d = dmin(d,dc, ID_THIRD);\n    //d = dmin(d, max(abs(p.x),abs(p.z)) - 0.02, ID_OTHER);\n    \n    //d = min(d,length(p) - 0.2);\n\n    return d;\n}\n\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    //vec2 dwall = sdWall(p); \n    vec2 dsilk = sdFrac(p);\n\n    d = dmin(d, dsilk);\n    \n    return d;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h*0.4;\n    }\n    return res;\n}\n\nvec3 getNormal(vec3 p, float precis){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*precis).x;\n    }\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 muv = (iMouse.xy)/iResolution.xy;\n    \n    gmuv = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    //uv *= 1. + dot(uv,uv)*5.;\n    \n    muv = muv*2. - 1.;\n    if (muv.x < -0.85){\n        muv -= muv;\n    }\n    \n    vec3 ro = vec3(0);\n    \n    ro.z -= 1. - iTime*0.2;    \n    ro *= 1.9;\n    \n    \n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    \n    //lookAt.z += muv.x*0.3;\n    lookAt.y += muv.y;\n    \n    \n    lookAt += normalize(vec3(cos(iTime*0.5),sin(iTime*0.7),cos(iTime*0.3)))*0.3;\n    \n    vec3 rd = getRd(ro, lookAt, uv, 2.);\n    \n    \n    \n    //ro -= rd*1.;\n    \n    vec3 col = vec3(0);\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    \n    vec3 atten = vec3(1.);\n    \n    \n    vec3 hitCol = vec3(0);\n    \n    \n    \n    float i = 0.;\n    vec3 reflalbedo = mix(ambientCol, lightCol,0.5);\n    for(; i < maxIters; i++){\n\n        p = ro + rd*(t += d.x*stepSz);\n        d = map(p);\n\n        if(d.x < eps){\n            hit = true;\n            break;\n        }\n\n    }\n\n    \n    vec3 n = getNormal(p,eps);\n    n = normalize(n - lDir*cyclicNoise(p*220.,0.)*0.3);\n        \n                    \n    {\n        #define AO(n,a) clamp(map(p + normalize(mix(n,lDir,0.23))*a).x/a, 0., 1.)\n        \n        float ao = AO(n,0.3)*AO(n,0.5)*AO(n,0.04)*AO(n,.14)*1.;\n         \n        //float SSS = SSS(vec3(-1.,.5,0.9),1.9)*1.*SSS(vec3(-4.,2.,0.2),5.)*1.;//*AO(lDir,0.5)*AO(-n,0.9);\n\n        vec3 halfV = normalize(lDir - rd);\n        float fres = pow(1.-max(dot(-rd, n),0.0001),3.);\n        float spec = pow(max(dot(n,halfV),0.),8.);\n        float diff = dot(n,lDir);\n                     \n        vec3 albedo = vec3(0.);\n        vec3 sssalbedo = vec3(0.);\n        \n        float shad = softshadow( p, lDir, 0.01, 10., 2.);\n        \n        //float shad = 1.;\n        shad = min(shad,diff);\n        \n        vec3 colSilk = vec3(0);\n        {\n            map(p);\n            albedo = silkCol;\n            \n            albedo -= albedo;\n            \n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(n*2.)*0.5 + 0.5),4.)/sqrt(3.); \n            float factb = pow(length(sin(r*3. + n*5. + 4. + iTime*0.)*0.5 + 0.5)/sqrt(3.),0.4); \n            float factc = pow(length(sin(r*5. + n*4. + 4. + iTime*2.2)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            albedo += mix( silkCol, vec3(0) + ambientCol*0.04 + silkCol*silkCol*silkCol*0.45,factb);;\n            albedo = mix( albedo, vec3(0) + ambientCol*0.02 + silkCol*silkCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += lightCol*45.*(1.-pow(factb,.005))*(1. + silkCol*.3);\n            colSilk = albedo*lightCol;\n\n            //colSilk = mix(colSilk, reflalbedo, clamp(fres + spec,0.,1.)*ao*0.3);\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colSilk = mix((colSilk + colSilk*ambientCol)*0., colSilk, ao);\n            //colSilk = mix((colSilk + colSilk*ambientCol)*0.5,colSilk, shad);\n            \n            \n        }\n        \n        vec3 colOther = vec3(0);\n        \n        \n        {\n            map(p);\n            \n            albedo -= albedo;\n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(r*4. - n*15.)*0.5 + 0.5)/sqrt(2.),0.2); \n            float factb = pow(length(sin(r*4. + n*6. + 0. + iTime*0.)*0.5 + 0.5),1.5)/sqrt(3.); \n            float factc = pow(length(sin(r*1. + n*5. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            \n            \n            vec3 otherCol = vec3(0.7,0.5,0.15)*0.1;\n            albedo += mix( otherCol, vec3(0.3,0.6,0.4)*0.00,fact);;\n            //albedo = mix( albedo, vec3(0) + ambientCol*0. + otherCol*otherCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += (1.-pow(factb,0.4))*vec3(1.8,1.2,0.55)*0.05;\n            \n            colOther = albedo;\n\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colOther = mix((colOther + colOther*ambientCol)*0.5, colOther, ao);\n            colOther = mix((colOther + colOther*ambientCol)*0.5,colOther, shad);\n            \n            \n        }\n        \n        \n        vec3 colThird = vec3(0);\n        \n        {\n            map(p);\n            \n            albedo -= albedo;\n            vec3 r = reflect(rd,n);\n            \n            float fact = pow(length(sin(r*11. - n*2.)*0.5+ 0.5)/sqrt(3.),0.07); \n            float factb = pow(length(sin(r*4. + n*6. + 0. + iTime*0.)*0.5 + 0.5),1.5)/sqrt(3.); \n            float factc = pow(length(sin(r*1. + n*5. + 4. + iTime*0.)*0.5 + 0.5),1.)/sqrt(3.); \n            \n            factb = clamp(factb,0.,1.);\n            factc = clamp(factc,0.,1.);\n            \n            \n            vec3 otherCol = vec3(0.5,0.5,0.4)*0.76;\n            albedo += mix( otherCol, vec3(0.5,0.3,0.)*0.003,fact);;\n            //albedo = mix( albedo, vec3(0) + ambientCol*0. + otherCol*otherCol*0.2,pow(factc,1.)*1.);;\n            \n            \n            \n            albedo += (1.-pow(factb,0.05))*vec3(1.8,1.2,0.55)*0.03;\n            \n            colThird = albedo;\n\n            ao = max(ao,0.);\n            shad = max(shad,0.);\n            \n            \n            colThird = mix((colThird + colThird*ambientCol)*0.3, colThird, ao);\n            colThird = mix((colThird + colThird*ambientCol)*0.4,colThird, shad);\n            \n            \n        }\n        \n        hitCol += colSilk*float(floor(d.y) == ID_GOLD);\n\n        hitCol += colOther*float(floor(d.y) == ID_OTHER);\n\n        hitCol += colThird*float(floor(d.y) == ID_THIRD);\n\n        \n        \n        //hitCol = mix(hitCol, hitCol + hitCol*ambientCol, shad);\n    \n    }\n    \n    if(hit)\n        col += hitCol*atten;\n    \n    //col = mix(col, vec3(1),smoothstep(0.,1.,t*0.05 - 0.6));\n    p = ro + rd*min(t,10.);\n    \n    float fogFact = smoothstep(0.,1.,i/maxIters*3.75 - 0.4);\n    float fogFactB = smoothstep(0.,1.,length(t)*0.13 - .2);\n    \n    \n    \n    //fogFact *= 1. - cyclicNoise(p*2.,1.);\n    \n    \n    vec3 fogCol = vec3(0.1,0.5,0.5)*0.02;\n    \n    //fogCol = mix(fogCol, fogCol*fogCol*fogCol*0.3, cyclicNoiseFog(normalize(rd)*14.,iTime*0.5)*pow(fogFact,4.2));\n    fogCol = mix(fogCol, fogCol*fogCol*fogCol*0.3, cyclicNoiseFog(normalize(rd)*14. + vec3(0,0,iTime),iTime*0.5)*pow(fogFactB,4.2));\n    \n    \n    \n    col = mix(col, fogCol,fogFactB);\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat FXAAamt = 0.5;\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 pp = 1. / iResolution.xy;\n    vec4 color = texture(iChannel0, vec2(fragCoord.xy * pp));\n    vec3 luma = vec3(.299, 0.587, 0.114);\n    \n    float lumaNW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaNE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, -1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSW = dot(texture(iChannel0, (fragCoord.xy + vec2(-1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaSE = dot(texture(iChannel0, (fragCoord.xy + vec2(1.0, 1.0)*FXAAamt) * pp).xyz, luma);\n    float lumaM  = dot(color.xyz,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * (1.0/8.0)), (1.0/128.0));\n\n    float rcpDirMin = 2.5 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(8.0, 8.0),\n              max(vec2(-8.0, -8.0),\n              dir * rcpDirMin)) * pp;\n\n    vec3 rgbA = 0.5 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(iChannel0, fragCoord.xy * pp + dir * -0.5).xyz +\n        texture(iChannel0, fragCoord.xy * pp + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax)){\n        fragColor = vec4(rgbA, color.w);\n    } else {\n        fragColor = vec4(rgbB, color.w);\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ID_GOLD 1.\n#define ID_OTHER 2.\n#define ID_THIRD 3.\n\n#define stepSz 0.25\n#define eps 0.001\n#define maxIters 280.\n    \n\n#define ambientCol vec3(0.5,0.5,0.5)\n#define lightCol vec3(0.9,0.8,0.8)*1.\n#define lDir normalize(vec3(-4.5,4,1.))\n#define silkCol vec3(0.3,0.22,0.03)*3.\n#define sssSilkCol vec3(0.9,0.3,0.3)*0.\n\n\n#define pi acos(-1.)\n\n\n\n#define pmod(p,a) mod(p - 0.5*a,a) - 0.5*a\n\nvec2 gmuv;\n\nvec3 getRd( inout vec3 ro, vec3 lookAt, vec2 uv, float sc){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir)); \n    vec3 up = normalize(cross(dir, right));    \n    //ro += right*uv.x*sc;\n    //ro += up*uv.y*sc;\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nfloat eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoise(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.75;\n    const float lacunarity = 1.4;\n    const int octaves = 4;\n    \n    \n    \n    \n    const float warp = 0.75;    \n    float warpTrk = 1.4 ;\n    const float warpTrkGain = 1.25;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin((p.zxy + vec3(-sin(time)*0.1,time*0.25,time*0.4))*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n            \n        //noise += sin(dot(cos(p), sin(p.zyx)))*amp;\n        \n        float f = sin(dot(cos(p), sin(p.zyx)));\n        //f = sign(f)*pow(abs(f),1.);\n        noise += f*amp;\n        \n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return (noise*0.25 + 0.5);\n\n    //return 1. - abs(noise)*0.5;\n}\n\n\nfloat cyclicNoiseFog(vec3 p, float time){\n    float noise = 0.;\n    \n    // These are the variables. I renamed them from the original by nimitz\n    // So they are more similar to the terms used be other types of noise\n    float amp = 1.;\n    const float gain = 0.55;\n    const float lacunarity = 1.5;\n    const int octaves = 4;\n    \n    \n    \n    \n    const float warp = 0.5;    \n    float warpTrk = 1.5 ;\n    const float warpTrkGain = .25;\n    \n    // Step 1: Get a simple arbitrary rotation, defined by the direction.\n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n    \n        // Step 2: Do some domain warping, Similar to fbm. Optional.\n        \n        p += sin((p.zxy + vec3(-sin(time)*0.1,time*0.25,time*0.4))*warpTrk - 2.*warpTrk)*warp; \n    \n        // Step 3: Calculate a noise value. \n        // This works in a way vaguely similar to Perlin/Simplex noise,\n        // but instead of in a square/triangle lattice, it is done in a sine wave.\n            \n        //noise += sin(dot(cos(p), sin(p.zyx)))*amp;\n        \n        float f = sin(dot(cos(p), sin(p.zyx)));\n        //f = sign(f)*pow(abs(f),1.);\n        noise += f*amp;\n        \n        \n        // Step 4: Rotate and scale. \n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return (noise*0.25 + 0.5);\n\n    //return 1. - abs(noise)*0.5;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}