{
    "Shader": {
        "info": {
            "date": "1708182873",
            "description": " The original game is called X2 blocks. The goal is to merge as many equal numbers that are touching each other. It's one of my first shaders, and I'm trying out to use the buffer input as a state. There are still some glitches while merging blocks.",
            "flags": 32,
            "hasliked": 0,
            "id": "XXjGzR",
            "likes": 3,
            "name": "X2 Blocks game",
            "published": 3,
            "tags": [
                "game",
                "number",
                "merge"
            ],
            "usePreview": 0,
            "username": "jildert",
            "viewed": 120
        },
        "renderpass": [
            {
                "code": "\nvec3 textC = vec3(1.0);\n\nvec3 textC2 = vec3(0.949, 0.59, 0.0);\nvec3 textC4 = vec3(0.0, 0.851, 0.039);\nvec3 textC8 = vec3(1.0, 1.0, 0.039);\nvec3 textC16 = vec3(0.0, 0.4, 0.89);\nvec3 textC32 = vec3(0.96, 0.0, 0.96);\n\nvec3 textC1024 = vec3(1.0, 0.96, 0.01);\n\nvec3 getTextColor(float printV) {\n    vec3 textColor = textC * sin(printV);\n    if (printV == 2.0) textColor = textC2;\n    else if (printV == 4.0) textColor = textC4;\n    else if (printV == 8.0) textColor = textC8;\n    else if (printV == 16.0) textColor = textC16;\n    else if (printV == 32.0) textColor = textC32;\n    else if (printV == 1024.0) textColor = textC1024;\n\n\n    return textColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blockWidth = iResolution.x / 16.0;\n    \n    float scale = iResolution.x / 1200.0;\n    vec2 vFontSize = vec2(20.0, 35.0) * scale;\n    \n    // 8 width\n    float marginX = blockWidth * 4.0;\n    float marginY = blockWidth * 1.0;\n    \n    vec3 col = vec3(0.28, 0.123, 0.4);\n    \n    float xoffset = 48.0 * scale;\n    float yoffset = 20.0 * scale;\n    \n    float gridXClick = (abs(iMouse.z) - blockWidth * 4.0) / blockWidth;\n    \n    float outsideOffset = 3.0;\n    if (fragCoord.x > marginX - outsideOffset && fragCoord.x < iResolution.x - marginX + outsideOffset) {\n        if (fragCoord.y > marginY - outsideOffset && fragCoord.y < iResolution.y - marginY + outsideOffset) {\n             vec2 gridPosF = (fragCoord - vec2(marginX, marginY)) / blockWidth;\n             ivec2 gridpos = ivec2(gridPosF);\n             \n             float printV = texelFetch(iChannel0, gridpos, 0).x;\n             float printX = float(gridpos.x);\n             float printY = float(gridpos.y);\n             \n             vec2 currentFontSize = vFontSize;\n             \n             // value in this grid position\n             if (printV > 0.0) {\n                 if (printV < 10.0) xoffset -= 15.0 * scale;\n                 else if (printV < 100.0) xoffset -= 7.0 * scale;\n                 \n                 if (printV > 1000.0) {\n                     xoffset += 5.0 * scale;\n                     currentFontSize *= .8;\n                 }\n                 \n                 vec3 textColor = getTextColor(printV);\n                 col = mix(col, textColor, PrintValue(fragCoord, vec2(xoffset + marginX + printX * blockWidth, blockWidth + yoffset + printY * blockWidth), currentFontSize, printV, 0.0, 0.0));\n             }\n             \n             if (int(gridXClick) == gridpos.x) {\n                 col *= .9;\n             }\n\n             // grid lines\n             float gridLineX = smoothstep(0.45, .45, getClosenessToRounded(gridPosF.x));\n             float gridLineY = smoothstep(0.45, .45, getClosenessToRounded(gridPosF.y));\n             col = mix(col, vec3(0.0), max(gridLineX, gridLineY));\n        }\n    }\n    \n    float customStateOffset = 10.0;\n    float currentOptionIx = customStateOffset + 1.0;\n    float debugIx = customStateOffset + 2.0;\n    float gridClickIx = customStateOffset + 3.0;\n    float scoreIx = customStateOffset + 5.0;\n    float gameOverIx = customStateOffset + 6.0;\n    \n    float currentOption = texelFetch(iChannel0, ivec2(currentOptionIx), 0).x;\n    float debugVal = texelFetch(iChannel0, ivec2(debugIx, 0), 0).x;\n    float gridClickVal = texelFetch(iChannel0, ivec2(gridClickIx, 0), 0).x;\n    float score = texelFetch(iChannel0, ivec2(scoreIx, 0), 0).x;\n    float gameOver = texelFetch(iChannel0, ivec2(gameOverIx, 0), 0).x;\n    \n    col = mix(col, getTextColor(currentOption), PrintValue(fragCoord, vec2(scale * 50.0), vFontSize, currentOption, 0.0, 0.0));\n    \n    // debug value\n    //col = mix(col, textC, PrintValue(fragCoord, vec2(scale * 200.0,scale * 50.0), vFontSize, debugVal, 0.0, 0.0));\n    \n    \n    \n    float gameOverTime = 0.0;\n    if (gameOver > 0.0) {\n        col *= .2;\n        gameOverTime = min(iTime - gameOver, 2.0);\n    }\n    \n    col = mix(col, textC, PrintValue(fragCoord, vec2(scale * (200.0 + gameOverTime * 120.0), scale * (600.0 - gameOverTime * 120.0)), vFontSize * 1.5 * (1.0 + gameOverTime), score, 0.0, 0.0));\n    \n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Number Printing - @P_Malin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// For a smaller less restrictive version, see this shader: https://www.shadertoy.com/view/4sBSWW\n\n//#define BITMAP_VERSION\n\nconst float kCharBlank = 12.0;\nconst float kCharMinus = 11.0;\nconst float kCharDecimalPoint = 10.0;\n\n#ifndef BITMAP_VERSION\n\nfloat InRect(const in vec2 vUV, const in vec4 vRect)\n{\n\tvec2 vTestMin = step(vRect.xy, vUV.xy);\n\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\n\tvec2 vTest = vTestMin * vTestMax;\n\treturn vTest.x * vTest.y;\n}\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\n\tconst float x0 = 0.0 / 4.0;\n\tconst float x1 = 1.0 / 4.0;\n\tconst float x2 = 2.0 / 4.0;\n\tconst float x3 = 3.0 / 4.0;\n\tconst float x4 = 4.0 / 4.0;\n\t\n\tconst float y0 = 0.0 / 5.0;\n\tconst float y1 = 1.0 / 5.0;\n\tconst float y2 = 2.0 / 5.0;\n\tconst float y3 = 3.0 / 5.0;\n\tconst float y4 = 4.0 / 5.0;\n\tconst float y5 = 5.0 / 5.0;\n\n\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\n\t\n\tvec4 vRect0 = vec4(0.0);\n\tvec4 vRect1 = vec4(0.0);\n\tvec4 vRect2 = vec4(0.0);\n\t\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tvRect0 = vec4(x1, y0, x2, y1);\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tvRect0 = vec4(x0, y2, x3, y3);\n\t}\t\n\t\n\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\n\t\n\treturn mod(fResult, 2.0);\n}\n\n#else\n\nfloat SampleDigit(const in float fDigit, const in vec2 vUV)\n{\t\t\n\tif(vUV.x < 0.0) return 0.0;\n\tif(vUV.y < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\t// In this version, each digit is made up of a 4x5 array of bits\n\t\n\tfloat fDigitBinary = 0.0;\n\t\n\tif(fDigit < 0.5) // 0\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 1.5) // 1\n\t{\n\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\n\t}\n\telse if(fDigit < 2.5) // 2\n\t{\n\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 3.5) // 3\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 4.5) // 4\n\t{\n\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\n\t}\n\telse if(fDigit < 5.5) // 5\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 6.5) // 6\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 7.5) // 7\n\t{\n\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 8.5) // 8\n\t{\n\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 9.5) // 9\n\t{\n\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\n\t}\n\telse if(fDigit < 10.5) // '.'\n\t{\n\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\telse if(fDigit < 11.5) // '-'\n\t{\n\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\n\t}\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\n}\n\n#endif\n\nfloat PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\tfloat fAbsValue = abs(fValue);\n\t\n\tfloat fStringCharIndex = floor(vStringCharCoords.x);\n\t\n\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\n\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\n\t\n\t// This is the character we are going to display for this pixel\n\tfloat fDigitCharacter = kCharBlank;\n\t\n\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\n\t{\n\t\tif(fDigitIndex > fBiggestDigitIndex)\n\t\t{\n\t\t\tif(fValue < 0.0)\n\t\t\t{\n\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharMinus;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tif(fDigitIndex == -1.0)\n\t\t\t{\n\t\t\t\tif(fDecimalPlaces > 0.0)\n\t\t\t\t{\n\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(fDigitIndex < 0.0)\n\t\t\t\t{\n\t\t\t\t\t// move along one to account for .\n\t\t\t\t\tfDigitIndex += 1.0;\n\t\t\t\t}\n\n\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\n\n\t\t\t\t// This is inaccurate - I think because I treat each digit independently\n\t\t\t\t// The value 2.0 gets printed as 2.09 :/\n\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\n\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\n\t\t\t}\t\t\n\t\t}\n\t}\n\n\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\n\n\treturn SampleDigit(fDigitCharacter, vCharPos);\t\n}\n\nfloat PrintValue(in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n\treturn PrintValue((fragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\n}\n\nfloat GetCurve(float x)\n{\n\treturn sin( x * 3.14159 * 4.0 );\n}\n\nfloat GetCurveDeriv(float x) \n{ \n\treturn 3.14159 * 4.0 * cos( x * 3.14159 * 4.0 ); \n}\n\nfloat getClosenessToRounded(float value) {\n    float roundedValue = round(value);\n    float fraction = fract(value);\n    float difference = abs(0.5 - fraction);\n    return difference;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nfloat options[4] = float[4](2.0, 4.0, 8.0, 16.0);\n\nfloat rand() { return fract(sin(iTime*100.0*(91.3458)) * 47453.5453); }\n\nfloat randomOption() {\n    return options[int(rand() * 4.0)];\n}\n\nbool isState(float x, float ix) {\n    return abs(x - ix) < 1.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float customStateOffset = 10.0;\n    float blockWidth = iResolution.x / 16.0;\n    \n    ivec2 fragCoordI = ivec2(fragCoord.xy);\n    float gridIx = float(fragCoordI.x + fragCoordI.y * 8);\n   \n    \n    vec4 stateVec = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float state = stateVec.x;\n    float stateY = stateVec.y;\n    float stateZ = stateVec.z;\n    float stateW = stateVec.w;\n    \n    \n    float currentOptionIx = customStateOffset + 1.0;\n    float debugIx = customStateOffset + 2.0;\n    float gridClickIx = customStateOffset + 3.0;\n    float prevMouseIx = customStateOffset + 4.0;\n    float scoreIx = customStateOffset + 5.0;\n    float gameOverIx = customStateOffset + 6.0;\n    float mergeTargetIx = customStateOffset + 7.0;\n    \n    float gridClickVal = texelFetch(iChannel0, ivec2(gridClickIx, 0), 0).x;\n    float prevMouse = texelFetch(iChannel0, ivec2(prevMouseIx, 0), 0).x;   \n    float currentOption = texelFetch(iChannel0, ivec2(currentOptionIx), 0).x;\n    vec2 mergeTarget = texelFetch(iChannel0, ivec2(mergeTargetIx, 0), 0).xy;\n    \n    \n    if (isState(fragCoord.x, currentOptionIx)) {\n        if (currentOption == 0.0 || gridClickVal > 0.0) {\n            currentOption = randomOption();\n        }\n        state = currentOption;\n    }\n    else if (int(fragCoord.x) == int(debugIx)) {\n        state = mergeTarget.x * 10.0 + mergeTarget.y;\n    }\n    else if (int(fragCoord.x) == int(gridClickIx)) {\n        float gridX = (iMouse.z - blockWidth * 4.0) / blockWidth;\n        float lastValue = texelFetch(iChannel0, ivec2(gridX, 0), 0).x;\n        bool canPlace = lastValue == 0.0 || lastValue == currentOption;\n        \n        state = canPlace && prevMouse == 0.0 && gridX > 0.0 && gridX < 8.0 ? gridX : 0.0;\n        \n    }\n    else if (int(fragCoord.x) == int(prevMouseIx)) {\n        state = iMouse.z > 0.0 ? 1.0 : 0.0;\n    }\n    else if (int(fragCoord.x) == int(scoreIx)) {\n        if (gridClickVal > 0.0) {\n            state = state + currentOption;\n        }\n    }\n    else if (int(fragCoord.x) == int(gameOverIx)) {\n        bool gameOver = true;\n        int checkX = 0;\n        while (checkX <= 7) {\n            float lastValue = texelFetch(iChannel0, ivec2(checkX, 0), 0).x;\n            if(lastValue == 0.0 || lastValue == currentOption) {\n                gameOver = false;\n                break;\n            }\n            checkX++;\n        }\n           \n        state = gameOver ? (state == 0.0 ? iTime : state) : 0.0;\n    }\n    \n    \n    if (gridClickVal > 0.0 && int(fragCoord.x) == int(gridClickVal)) {\n        float gridTargetY = 6.0;\n        float lastValue = texelFetch(iChannel0, ivec2(gridClickVal, 0), 0).x;\n        \n        while (gridTargetY > 0.0 && texelFetch(iChannel0, ivec2(gridClickVal, gridTargetY), 0).x != 0.0) {\n            gridTargetY -= 1.0;\n        }\n        \n        \n        //if (texelFetch(iChannel0, ivec2(gridClickVal, gridTargetY + 1.0), 0).x == currentOption) {\n         //   gridTargetY += 1.0;\n        //    currentOption *= 2.0;\n        //}\n        \n        if (lastValue == currentOption && int(fragCoord.y) == 0) {\n            state *= 2.0;\n        }\n        else if (int(fragCoord.y) == int(gridTargetY)) {\n            state = currentOption;\n        }\n    }\n    \n    \n    // merging\n    int intX = int(fragCoord.x);\n    int intY = int(fragCoord.y);\n    if (intX >= 0 && intX <= 7 && intY >= 0 && intY <= 6) {\n        vec4 myVec4 = texelFetch(iChannel0, ivec2(intX, intY), 0);\n        stateZ = 0.0;\n        stateW = 0.0;\n        \n        vec4 bottom = texelFetch(iChannel0, ivec2(intX, intY - 1), 0);\n        \n        if (state == 0.0 && bottom.z < 0.0) {\n            state = abs(bottom.z);\n        }\n        \n        if (myVec4.x > 0.0 && myVec4.z == 0.0 && myVec4.w == 0.0) {\n\n            vec4 left = texelFetch(iChannel0, ivec2(intX - 1, intY), 0);\n            vec4 right = texelFetch(iChannel0, ivec2(intX + 1, intY), 0);\n            vec4 top = texelFetch(iChannel0, ivec2(intX, intY + 1), 0);\n            \n            bool removed = false;\n            \n            if (state > 0.0 && intY < 6 && top.x == 0.0 && top.w == 0.0) {\n                stateZ = -state;\n                state = 0.0;\n                removed = true;\n            }\n            else if (state > 0.0 && intX > 0 && int(left.z) == intX && int(left.w) == intY + 1) {\n                state = 0.0;\n                removed = true;\n            }\n            else if (state > 0.0 && intX < 6 && int(right.z) == intX && int(right.w) == intY + 1) {\n                state = 0.0;\n                removed = true;\n            }\n            else if (state > 0.0 && intY < 7 && int(top.z) == intX && int(top.w) == intY + 1) {\n                state = 0.0;\n                removed = true;\n            }             \n            \n            \n            if (!removed && state > 0.0) {\n                if (iFrame % 2 == 0 && intX > 0 && left.x == myVec4.x) {\n                    state *= 2.0;\n                    stateZ = float(intX - 1);\n                    stateW = float(intY) + 1.0;\n                }\n                if (iFrame % 2 != 0 && intY > 0 && bottom.x == myVec4.x) {\n                    state *= 2.0;\n                    stateZ = float(intX);\n                    stateW = float(intY - 1) + 1.0;\n                }\n                //if (right.x == myVec4.x) {\n                //    state *= 2.0;\n                //    stateZ = float(intX + 1);\n                //    stateW = float(intY);\n                //}\n            }\n            \n        }\n    }\n    \n    \n    fragColor = vec4(state, stateY, stateZ, stateW);\n    //fragColor = vec4(gridIx,0.0,0.0,0.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}