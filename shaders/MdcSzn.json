{
    "Shader": {
        "info": {
            "date": "1457307549",
            "description": "A signal viewer meant to be useful at validating the analytic derivative of a given function.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdcSzn",
            "likes": 63,
            "name": "Analytic Derivative Viewer2D",
            "published": 3,
            "tags": [
                "derivative",
                "analytic",
                "viewer"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 2772
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : May 2015\n// Modified : Jan 2016\n//\n// This shader was written with the intent of easing the pain of finding and validating \n// analytic derivatives. I had decided to do this after having read an interesting article, from Inigo Quilez :\n// https://iquilezles.org/articles/morenoise\n//\n// Although deriving a function in a theorical context is not so difficult, it can still \n// quickly become an overwhelming task if you stack up multiple layers of rotated, scaled, and distorted noise.\n// How do you rotate the derivatives, do you simply rotate the gradient in the same direction as the noise function?\n// What do you do with time multiplier, is it always derived as a constant factor?\n// Do you also have to derive the bilinear / trilinear equation, or just the ease function?\n// \n//\n// License : Creative Commons Non-commercial (NC) license\n\nconst int COUNT = 5;                 //Graph Count\nconst float HORIZONTAL_UNITS = 15.0; //Horizontal Span (domain units)\nconst float INFINITY = 10000.0;\nconst float VERTICAL_UNITS = float(COUNT);\nconst float FUNC_A = 0.25; // A constant expression used in the wave function. It control how \"spikey\" they are.\nfloat g_animTime = 0.0;  \n\nfloat genRdm( vec2 p )\n{\n    //(Numbers are arbitrary, this is pseudo-random)\n    return fract(sin(p.x*347.1+p.y*283.1)*987643.21234);\n}\n\n// -----------------------------------------------------------\n// The 4 corners of the bilinear interpolation (view from top)\n//\n//       (1,0)              (1,1)\n// 1    c-----------f------d\n// |    |           .      |\n// |    |           .      |\n// |    |           .      |\n//t.y   g...........v......h\n// |    |           .      |\n// |    |           .      |\n// |    |           .      |\n// |    |           .      |  \n// |    |(0,0)      .      |(1,0)  \n// 0    a-----------e------b      ->x\n//\n//                  \n//      0__________t.x_____1\n//    \n// -----------------------------------------------\n// And the ease function below (value view, with tangent)\n//\n// Here, the ease function to               ......h\n// interpolate from g to h.           ......      \n// The value delta between        ....            \n// h and g is indeed         / ...                \n// a scaling multiplier     /..\n// applied on top          /.                     \n// of the ease            /.\n// function            ../\n// derivative      .... /\n//           ......\n//   g.......                                      \n//\n#define CUBIC   1\n#define QUINTIC 2\n#define SINE    3\n#define EASE_FUNC QUINTIC\nvec3 bilinearNoise( in vec2 p, float fTime ) \n{\n    const float PI = 3.14159;\n    p.xy += fTime;\n    vec2 x = fract( p );\t\n    vec2 i = p-x;\n#if(EASE_FUNC==CUBIC)\n    //Option 1 : Cubic ease function\n    vec2 t = x*x*(3.0-2.0*x); //ease function\n    vec2 d_xy = 6.0*x*(1.0-x);//derivative\n#elif(EASE_FUNC==QUINTIC)\n    //Option 1 : Quintic ease function\n    vec2 t = (6.*x*x-15.0*x+10.)*x*x*x; //ease function\n    vec2 d_xy = (30.*x*x-60.*x+30.)*x*x;  //derivative\n#elif(EASE_FUNC==SINE)\n    //Option 3 : Trigonometric ease function\n    vec2 t = 0.5+0.5*sin(-PI/2.0+x*PI);   //ease function\n    vec2 d_xy = 0.5*PI*cos(-PI/2.0+x*PI); //derivative\n#endif\n    \n    //bilinear interpolation (abcd = 4 corners)\n\tfloat a = genRdm( i + vec2(0.0,0.0) );\n\tfloat b = genRdm( i + vec2(1.0,0.0) );\n\tfloat c = genRdm( i + vec2(0.0,1.0) );\n\tfloat d = genRdm( i + vec2(1.0,1.0) );\n    \n    //Note : g and h could be factorized out.\n    float e = a+(b-a)*t.x; //Horizontal interpolation 1 (e)\n    float f = c+(d-c)*t.x; //Horizontal interpolation 2 (f)\n\tfloat v = e*(1.-t.y)+f*(t.y); //Vertical interpolation (v)\n    \n    //All this could be factorized and be made more compact.\n    //Step by step is much easier to understand, however.\n    float g = a+(c-a)*t.y; //Vertical interpolation (g)\n\tfloat h = b+(d-b)*t.y; //Vertical interpolation (h)\n    \n    //Noise delta scaling (the lookup value slope along x/y axis).\n    float sx = h-g; //dv/dx scaling\n    float sy = f-e; //dv/dy scaling\n    \n    return vec3(v,\n\t            d_xy.x*sx,\n                d_xy.y*sy);\n    \n    //return [h,dh/dx,dh/dy]\n}\n//The 2D function shown in the middle graph.\n//This fonction was created to be used as a base for water waves.\nfloat warpedGrid01(vec2 uv, float fTime)\n{\n    float a = FUNC_A;\n    uv += bilinearNoise(uv,fTime).x;\n    float gx = 0.5+sin(2.0*uv.x)*0.5;\n    float hx = a/(gx+a);\n    float gy = 0.5+sin(2.0*uv.y)*0.5;\n    float hy = a/(gy+a);\n    return (hx+hy)*0.5;\n}\n\n//****************************************\n// Signal 1 (topmost)\nfloat F(float x)\n{\n    //f(x) = noise(x).x\n    return bilinearNoise(vec2(x,0),g_animTime).x;\n}\nfloat dF(float x)\n{\n    //f'(x) = noise(x).y\n    //vec3[h,dx,dy]=waveNoise(x)\n    return bilinearNoise(vec2(x,0),g_animTime).y; //waveNoise(x).y=dh/dx\n}\n//****************************************\n// Signal 2 (second from the top)\nfloat G(float x)\n{\n    //g(x) = 0.5 + sin(2f(x))/2\n    vec2 uv = vec2(x,0);\n    uv += bilinearNoise(uv,g_animTime).x;\n    return 0.5+sin(2.0*uv.x)*0.5;\n}\nfloat dG(float x)\n{\n    //Theory : g'(x) = cos(2f(x))*(1+n'(x)) \n    vec2 uv = vec2(x,0);\n    uv += bilinearNoise(uv,g_animTime).x;\n    return cos(2.0*uv.x)*(1.0+dF(x));\n}\n//****************************************\n// Signal 3 (third from the top)\nfloat H(float x)\n{\n    float a = FUNC_A;\n    //h(x) = a/(g(x)+a)\n    vec2 uv = vec2(x,0);\n    uv += bilinearNoise(uv,g_animTime).x;\n    float gx = 0.5+sin(2.0*uv.x)*0.5;\n    float hx = a/(gx+a);\n    return hx;\n}\nfloat dH(float x)\n{\n    //Theory : h'(x) = -g'(x)*a/(g(x)+a)^2\n    float a = FUNC_A;\n    float g = G(x);\n    //Application : \n    return -dG(x)*a/((G(x)+a)*(G(x)+a));\n}\n\n//****************************************\n// Signal 4 (third from the top) : basic example\nfloat Func4(float x)\n{\n    return 0.5+0.5*sin(x);\n}\nfloat dFunc4(float x)\n{\n    return 0.5*cos(x);\n}\n//****************************************\n// Signal 5 (third from the top) : basic example\nfloat Func5(float x)\n{\n    return 0.5+0.5*sin(4.*x);\n}\nfloat dFunc5(float x)\n{\n    return 0.5*4.0*cos(4.*x);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//Returns the domain (x) position at pixel px\nfloat getDomainValue(float px)\n{\n    //The fract(x/1000.0)*1000.0 is there to prevent precision issues with large numbers.\n    return fract((iTime)/1000.0)*1000.0 + px*HORIZONTAL_UNITS;\n}\n\n//When the analytic derivative is calculated properly, this function returns\n//the distance to a small segment which must be tangeant to the function signal.\n//(If the derivative computation is wrong, displayed tangent will not match the slope)\nfloat distToAnalyticDerivatives(vec2 p)\n{\n    const float TAN_LEN = 0.05; //The segment (tangent) half-length\n    float imageHeight = iResolution.y/iResolution.x;\n    \n    //Conversion factor from computation space to image space (Horizontal & Vert)\n    vec2 imgScaling = vec2(1.0/HORIZONTAL_UNITS,imageHeight/VERTICAL_UNITS);\n    \n    //px = position (uv.x) at which the derivative is evaluated.\n    float px = 0.5; //0.5 = image center\n    if(iMouse.z > 0.1)\n    {\n        px = iMouse.x/iResolution.x;\n    }\n    float x = getDomainValue(px);\n    \n    vec2 V_Dx[COUNT];\n    V_Dx[0] = vec2(F(x),dF(x));\n    V_Dx[1] = vec2(G(x),dG(x));\n    V_Dx[2] = vec2(H(x),dH(x));\n    V_Dx[3] = vec2(Func4(x),dFunc4(x));\n    V_Dx[4] = vec2(Func5(x),dFunc5(x));\n    \n    float minDist = INFINITY;\n    for(int i=0; i < COUNT; ++i)\n    {\n        //Signal height, image space [0-imageHeight]\n        float signalHeight = imgScaling.y*float(COUNT-1-i);\n        \n        //Computation space value and tangent\n        float functionValue = V_Dx[i].x; //f(x)\n        vec2 functionTan    = vec2(1.0,V_Dx[i].y); //vec2 = [dx,df'(x)], in other words, the variation of f(x) per unit of x\n        \n        //Image space value and tangent\n        vec2 imageValue = vec2(px,signalHeight+functionValue*imgScaling.y);\n        vec2 imageTangent = normalize(functionTan*imgScaling)*TAN_LEN;\n                                \n    \tminDist = min(minDist,distanceToLineSeg(p,imageValue-imageTangent,imageValue+imageTangent));\n    }\n\treturn minDist;\n}\n\n//Returns the vertical distance of point p to graph line.\nfloat distanceToGraphValue(vec2 p)\n{\n    //Vertical span for each signal\n    float vSpan = float(COUNT)*(iResolution.x/iResolution.y);\n    //x pos at pixel p.x\n    float x = getDomainValue(p.x);\n    \n    float graphValues[COUNT];\n    graphValues[0] = F(x);\n    graphValues[1] = G(x);\n    graphValues[2] = H(x);\n    graphValues[3] = Func4(x);\n    graphValues[4] = Func5(x);\n    \n    float minDist = INFINITY;\n    for(int i=0; i < COUNT; ++i)\n    {\n        float vOffset = float(COUNT-1-i)/vSpan;\n        vec2 p = vec2(p.x,(p.y-vOffset)*vSpan);\n\t\tminDist = min(minDist,abs(p.y-graphValues[i]));\n    }\n\treturn minDist;\n}\n\n//Returns the [x,y] gradient magnitude. All signals are processed.\nvec2 absGrad(vec2 p, float d0)\n{\n    //Note : using max(d+,d-) derivative to reduce artifacts.\n    const float fEps = 0.001;\n    float dxp = abs(distanceToGraphValue(p+vec2(fEps,0))-d0);\n    float dyp = abs(distanceToGraphValue(p+vec2(0,fEps))-d0);\n    float dxm = abs(distanceToGraphValue(p-vec2(fEps,0))-d0);\n    float dym = abs(distanceToGraphValue(p-vec2(0,fEps))-d0);\n    return vec2(max(dxp,dxm),max(dyp,dym))/fEps;\n}\n\n//Note : the valueGradient could be computed at the end, just like the normal is computed \n//       using the global terrain/map function. In fact, the entire graph program could probably be written\n//       just like a distance field.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv : x:[0,1]\n    vec2 uv = fragCoord.xy / iResolution.xx;\n    \n    //Vertical span for a single signal\n    float vSpan = VERTICAL_UNITS*(iResolution.x/iResolution.y);\n    g_animTime = iTime;\n\t\n    //<Distance To Graph Value>\n    float d = distanceToGraphValue(uv); //Vertical Distance\n    vec2 aGrad = absGrad(uv,d); //Gradient\n    d = d/length(aGrad);        //Slope compensation, to keep the line width constant.\n    //</Distance To Graph Value>\n    \n    //<Distance To Derivative Line>\n    float der = distToAnalyticDerivatives(uv);\n    //</Distance To Graph Value>\n    \n    //<Background + graph window separation>\n    float dSigWin = abs(fract((uv.y)*vSpan+0.5)-0.5);\n    float cSigWin = smoothstep(0.0, 0.005*VERTICAL_UNITS, dSigWin);\n    vec3 cBack = mix(vec3(0,0,0.8),vec3(1),cSigWin);\n    //</Background + graph window separation>\n    \n    //Darken the background along plot lines\n    cBack *= smoothstep(0.0, 0.003, d); //Close = 0(Black), Far(>.003) = 1(White)\n    \n    //Mix derivative Color with whatever is behind\n    float derivativeLineIntensity = 1.0-smoothstep(0.0, 0.003, der);\n    cBack = mix(cBack,vec3(1,0.2,0.2),derivativeLineIntensity);\n    \n    //Return Final Color\n\tfragColor = vec4(cBack, 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}