{
    "Shader": {
        "info": {
            "date": "1583626805",
            "description": "Made a scene with FPS controls (WASD + Mouse + EQ (Up/Down)). \nWant to test RayCasts to make fast RayMarching for primitives.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtKSzd",
            "likes": 7,
            "name": "Interactive Explorer (v.0)",
            "published": 3,
            "tags": [
                "raymarching",
                "template"
            ],
            "usePreview": 0,
            "username": "quizcanners",
            "viewed": 346
        },
        "renderpass": [
            {
                "code": "// A better iteration of this shader: https://www.shadertoy.com/view/wdsyzM\n\n// I want to try out combining RayCast (Intersect) functions with RayMarching.\n// Red color shows how many steps were made before getting the color.\n// Also to add Camra Controls for exploring a raymarch shader. \n\n// Fork of \"RayMarching starting point\" by BigWIngs. https://shadertoy.com/view/WtGXDD\n// Camera Rotation:\t\t \t ssell      \t\t     https://www.shadertoy.com/view/XtXyW4\n// Ray Box intersection: \tyuchengzhong \t\t\t https://www.shadertoy.com/view/wtKXWV\n// Fish Eye:\t\t\t\tTDM\t\t\t\t\t\t https://www.shadertoy.com/view/XsfXWX\n// Also looking into this one: \t\t\t\t\t     https://www.shadertoy.com/view/tl23Rm\n// Shadows: Maarten \t\t\t\t\t\t\t\t https://www.shadertoy.com/view/4dfXDn\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec4 Volume(vec3 pos){\n\tfloat hmix;\n                 \n    vec4 bakeUV = SampleVolume(pos, GetVolumeHSlices(iResolution.y), hmix);\n             \n    return mix( texture(iChannel0, bakeUV.xy), texture(iChannel0, bakeUV.zw), hmix);\n}\n\nvec3 getFishEye(vec2 uv, float level) {\n    \n    float len = length(uv);\n    float a = len * level;\n    vec3 fishUV = vec3(uv / len * sin(a), cos(a));\n    \n    vec3 camForward = \t\tloadValue(CAM_FORWARD).xyz;\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    return (fishUV.x * camRight) + (fishUV.y * camUp) + (fishUV.z * camForward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cameraPosition = loadValue(CAM_POS_PRSST).xyz;\n\tvec3 rayDirection = getFishEye(uv,  1.5);\n    \n    vec2 rayCast = GetRaycastDist(cameraPosition, rayDirection);\n\n   // rayCast.x = 0.; // DEBUG\n    \n    vec3 col = vec3(0);\n    \n    if (rayCast.x<MAX_DIST){\n\n        float dist = max(0.,rayCast.x);\n        float steps;\n        \n        float mxDist = \n            //MAX_DIST;\n            rayCast.y;\n        \n        GetRayMarchDist(cameraPosition, rayDirection, mxDist, dist, steps);\n        \n        steps /= 30.; // DEBUG\n\n         if(dist<mxDist) {\n            vec3 hitPos = cameraPosition + rayDirection * dist;\n            vec3 n = GetNormal(hitPos, dist);\n            float dif = dot(n, normalize(vec3(1,2,3)))*.5+.6;\n            col += dif;  \n             \n            #ifdef DEBUG\n             col.r =  steps; \n            #endif\n             \n             vec3 safeHitPos = hitPos + n * 0.001*dist; // To start other calculations not trom inside the object\n             \n             float shadow = Shadow(safeHitPos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n\n             vec4 baked = Volume(safeHitPos + n*VOLUME_SCALE * .3);\n             \n             col.rgb *= (shadow * lightSource_0_Color + baked.b * skyColor);\n             \n         \t\n             \n         } else {\n              col.rgb = \n             #ifdef DEBUG\n                 vec3(steps,0.,0.);\n             #else\n             \t SkyBox(rayDirection);\n             #endif\n         }\n\n        \n        //float remapped = sharpstep(0., 2., rayCast.y);\n      \t//col.rgb = vec3(0., remapped, remapped);\n        \n         col.rgb = max(vec3(0.), col.rgb);\n         col = pow(col, vec3(.4545));\t// gamma correction\n         vec3 mixed = col.gbr + col.brg;\n    \n    col.rgb += mixed*mixed *  .2;\n   } else {\n    \tcol.rgb = SkyBox(rayDirection); \n   }\n    \n   \n    // Volumetric lights \n    \n    const float VOL_STEPS = 10.;\n    \n    const float VOL_STEP_SIZE = 3. * VOLUME_SCALE/ VOL_STEPS;\n    \n    const float FOG_DENSITY = .25/VOL_STEPS;\n    \n    vec4 ambientLight = vec4(0., 0., 0., FOG_DENSITY);\n    \n    float volDist = VOL_STEP_SIZE;\n    \n    for (float i=0.; i<VOL_STEPS; i+=1.)\n    {\n    \tvec3 volumePosition = cameraPosition + rayDirection * volDist;\n        \n        vec3 volCol = Volume(volumePosition).rgb;\n        \n        float smoothAdd = smoothstep(rayCast.x, rayCast.x*0.7, volDist);\n       \n        float adding = FOG_DENSITY * smoothAdd;\n        \n        ambientLight.rgb += volCol * adding / ambientLight.a;\n      \n        ambientLight.a += adding;\n        \n        volDist += VOL_STEP_SIZE * (1. + i*i/VOL_STEPS); // volDist*1.6;\n        \n        i+= (1. - smoothAdd) * 100.;\n    }\n    \n    ambientLight.a = min(1., ambientLight.a);\n  \n    ambientLight.rgb =  \n        lightSource_0_Color.rgb *  (0.05 * lightSource_0.w * ambientLight.r) +\n        skyColor * ambientLight.b * 0.2\n        ;\n    \n    col.rgb = mix(col.rgb, ambientLight.rgb , ambientLight.a);\n  \n    fragColor = vec4(col,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CONFIGS\n\n#define MAX_STEPS 25\n#define MAX_DIST 500.\n#define SURF_DIST .001\n//#define MARCH_VOLUME_SHADOW\n#define DEBUG\n\n//___ MOVEMENT\nconst float PLAYER_SPEED = .6;\nconst float PLAYER_RUN_SPEED = 1.;\nconst float MOUSE_SENSITIVITY = 3.;\nconst float PLAYER_SIZE = .1;\nconst float SLOWDOWN_RANGE = 5.;\n\n//__ RENDERING\nconst float  SHADOW_RADIUS = 8.;\n\nconst float VOLUME_SCALE = 10.;\nconst vec4 VOLUME_POSITION_N_SIZE = vec4(50., -20., 10., 1./VOLUME_SCALE); // w = 1/size\nconst float VOLUME_HEIGHT = 16.;\nconst float DE_VOL_HEIGHT = 1./VOLUME_HEIGHT;\n\nvec3 skyColor= vec3(.3,.3, .7);\nvec3 eqColor = vec3(.5,.4,.4);\nvec3 floorColor = vec3(.1,.3,.1);\n\nvec3 SkyBox(vec3 rayDirection)\n{\n    return  floorColor * max(0., -rayDirection.y)\n        +   eqColor * (1.-abs(rayDirection.y)) \n        +\tskyColor * (max(0., rayDirection.y));\n        \n    \n\t//return vec3(rayDirection.x*max(0.,rayDirection.y),rayDirection.y,.1);\n}\n\n\n// *************** PERSISTANCE\n\nconst ivec2 CAM_POS_PRSST       \t= ivec2(1, 1);\nconst ivec2 CAM_ROT_PRSST       \t= ivec2(3, 1);\nconst ivec2 CAM_MOUSE_PREV_PRSST    = ivec2(7, 1);\nconst ivec2 CAM_ROTATION_PRSST      = ivec2(9, 1);\nconst ivec2 CAM_FORWARD       \t\t= ivec2(11, 1);\nconst ivec2 GAME_STATE       \t\t= ivec2(13, 1);\n\nconst float PRSST_MAX_Y = 2.;\n\nbool inStoreArea( in ivec2 dataIndex, in ivec2 fragCoord)\n{\n  return ( dataIndex.x==fragCoord.x && dataIndex.y==fragCoord.y);\n}\n\nbool inStoreRange( in ivec2 dataIndex1, in ivec2 dataIndex2, in ivec2 fragCoord)\n{\n  return ( dataIndex1.x<=fragCoord.x && dataIndex1.y<=fragCoord.y && dataIndex2.x>=fragCoord.x && dataIndex2.y>=fragCoord.y);\n}\n\nvoid storeValue( in ivec2 dataIndex, in vec4 data, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = inStoreArea(dataIndex, fragCoord) ? data : fragColor;\n}\n\n// ************** MATH\n\nvec3 hash33(vec3 pos)\n{\n\tpos = fract(pos * vec3(.1234, .5678, .923));\n    pos += dot(pos, pos.yxz+23.45);\n    return fract((pos.xxy + pos.yxx)*pos.zyx);\n\n}\n\nfloat sharpstep(float a, float b, float x){\n    return (x-a)/(b-a);\n}\n\nvec2 Rot(vec2 uv, float angle){\n\tfloat si = sin(angle);\n\tfloat co = cos(angle);\n    return vec2(co * uv.x - si* uv.y, si * uv.x + co * uv.y);\n}\n\n// ************** VOLUME\n\n\n\nvec4 GetVolumeHSlices(float resolutionY)\n{\n  float sliceWidth = (resolutionY - VOLUME_HEIGHT * 2.) * DE_VOL_HEIGHT;       \n  return vec4(VOLUME_HEIGHT, sliceWidth* .5, 1./sliceWidth, DE_VOL_HEIGHT);\n}\n\nvec4 SampleVolume(vec3 worldPos, vec4 VOLUME_H_SLICES, out float hmix) {\n\n    vec4 outputUV = vec4(0.);\n    \n\tvec3 bsPos = (worldPos.xyz - VOLUME_POSITION_N_SIZE.xyz) * VOLUME_POSITION_N_SIZE.w;\n\n\tbsPos.xz = clamp((bsPos.xz + VOLUME_H_SLICES.y)* VOLUME_H_SLICES.z, 0., 1.)*VOLUME_H_SLICES.w;\n\tfloat h = min(max(0., bsPos.y), VOLUME_H_SLICES.x*VOLUME_H_SLICES.x - 1.);\n\n\tfloat sectorY = floor(h * VOLUME_H_SLICES.w);\n\tfloat sectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n    vec2 uv_low = vec2(sectorX, sectorY) * VOLUME_H_SLICES.w;\n    \n\tvec2 sector = clamp(uv_low, 0., 1.)+ bsPos.xz;\n\n    outputUV.xy = sector;\n\n\th += 1.;\n\n\tsectorY = floor(h * VOLUME_H_SLICES.w);\n\tsectorX = floor(h - sectorY * VOLUME_H_SLICES.x);\n\n\tsector = clamp(vec2(sectorX, sectorY)*VOLUME_H_SLICES.w, 0., 1.) + bsPos.xz;\n\n    outputUV.zw = sector;\n\n\thmix = fract(h); \n\n\treturn outputUV;\n}\n\n// **************  RAYMARCHING\n\n\nfloat smAdd(float d1, float d2, float smth)\n{\n\tfloat h = max(smth - abs(d1 - d2), 0.0) / (smth + 0.0001);\n\treturn min(d1, d2) - h * h*h*smth*(1.0 / 6.0);\n}\n\nfloat smMinus(float d1, float d2, float k) {\n\n\tfloat h = clamp((1. - (d2 + d1) / (k + 0.0001))*0.5, 0.,1.);\n\n\treturn mix(d1, -d2, h) + k * h * (1. - h);\n}\n\n// ****************** SHAPES\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p)-s; \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy))+bias)/scale - thickness;\n}\n\nfloat distToBox(in vec2 pos, in vec2 boxMin, in vec2 boxMax, in float expand)\n{\n    boxMin -= vec2(expand,expand);\n    boxMax += vec2(expand,expand);\n    float bMax = max(pos.x - boxMax.x, pos.y - boxMax.y);\n    float bMin = max(boxMin.x - pos.x, boxMin.y - pos.y);\n    return max(bMax, bMin);\n}\n\n\n// ****************** RAY CASTING\n\nfloat planeLineIntersect(vec3 o,vec3 d,vec3 pn,vec3 pp)\n{\n    return dot(pp-o,pn)/dot(d,pn);\n}\n\n// Box:             https://www.shadertoy.com/view/ld23DV\nvoid iBox( in vec3 ro, in vec3 m, in vec3 boxSize, inout vec2 nearestCast) \n{ \n    \n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n    float isNear = step(tN, tF) * step(0., tF) * step(tN, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(tN, tF), isNear);\n}\n\nvoid IntersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 pos, float radius, inout vec2 nearestCast)\n{\n    float t = max(0.,dot(pos - rayOrigin, rayDirection));\n    vec3 p = rayOrigin + rayDirection * t;\n    float y = length(pos - p);\n    \n    float hit = step(y, radius);\n    \n    float x = sqrt(mix(1., radius * radius - y * y,  hit));\n\n    float isNearest = hit * step(t-x, nearestCast.x);\n\n    nearestCast = mix(nearestCast, vec2(t-x,t+x), isNearest);\n}\n\n\n// ***************** TEST SCENE\n\n\nconst int SPHERE_CNT = 7;\n\nvec4 lightSource_0 = vec4(70., 60., 100., 20.);\n\nvec3 lightSource_0_Color = vec3(.8, .8, .1);\n\nvec4[SPHERE_CNT] GetSpheres(){\n\tvec4  spheres[SPHERE_CNT];\n    spheres[0] = vec4(30.,\t80.,\t\t5., \t32.5);\n    spheres[1] = vec4(60.,\t15.,\t\t-29., \t17.);\n    spheres[2] = vec4(10.,\t0.,\t\t45., \t22.5);\n    spheres[3] = vec4(35.,\t0.,\t\t50., \t31.);\n    spheres[4] = vec4(60.,\t1.,\t\t65., \t9.);\n    spheres[5] = vec4(100.,\t15.,\t\t5., \t22.5);\n    spheres[6] = vec4(110.,\t45.,\t9., \t31.);\n    return spheres;\n}\n\nconst int BOX_CNT = 3;\n\nvec4[BOX_CNT] GetBoxes(){\n\tvec4  boxes[BOX_CNT];\n    boxes[0] = vec4(-28.,\t56.,\t5., \t38.5);\n    boxes[1] = vec4(100.,\t21.,\t39., \t25.);\n    boxes[2] = vec4(380.,\t-370.,\t15., \t360.);\n    \n    return boxes;\n}\n\nconst int TOTAL_SHAPE_VARIATION = 2;\nconst int TOTAL_SHAPES = SPHERE_CNT+BOX_CNT;\n\nvec2 GetRaycastDist(vec3 rayPos, vec3 rayDir)\n{\n   \t \n    vec2 nearestCast = vec2(MAX_DIST+1.,MAX_DIST+1.);\n    \n    // SPHERES\n    int raycastIndex = 0;\n    vec4  spheres[SPHERE_CNT] = GetSpheres();\n    \n    for(int i=0; i<SPHERE_CNT; i++)\n    {\n        vec4 s = spheres[i];\n        IntersectSphere(rayPos, rayDir, s.xyz , s.w, nearestCast);\n    }\n\n    // BOXES\n    vec4  boxes[BOX_CNT] = GetBoxes();\n    vec3 precalculateM = sign(rayDir)/max(abs(rayDir), 1e-8);\n    \n    for(int i=0; i<BOX_CNT; i++)\n    {\n        vec4 b = boxes[i];\n        iBox(rayPos - b.xyz, precalculateM, vec3(b.w,b.w,b.w), nearestCast);\n    }\n    \n    return nearestCast;\n}\n\n\nfloat GetDist(vec3 p) {\n    \n    vec4  spheres[SPHERE_CNT] = GetSpheres();\n    \n    float sphereDist = MAX_DIST; \n    \n    for(int i=0; i<SPHERE_CNT; i++)\n    {\n        vec4 s = spheres[i];\n        float dist = sdSphere(p - s.xyz, s.w);\n        sphereDist = \n            smAdd(sphereDist, dist, 1.);\n            min(dist, sphereDist);\n    }\n    \n   float gyr = sdGyroid(p, .7, 1., .01);\n    \n   sphereDist = smMinus(sphereDist, gyr, 0.4);\n \n    \n    vec4  boxes[BOX_CNT] = GetBoxes();\n    \n    for(int i=0; i<BOX_CNT; i++)\n    {\n       vec4 b = boxes[i];\n       float dist = sdBox(p - b.xyz, vec3(b.w,b.w,b.w));\n        \n       sphereDist = smAdd(sphereDist, dist, 10.);\n           min(dist, sphereDist);\n    }\n\n    return sphereDist;\n}\n\nvec3 GetNormal(vec3 p, float dist ) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat Shadow(vec3 p, vec3 pos, float radius, float lightPower)\n{\n\tvec3 rayDir = normalize(pos - p);\n\tfloat maxDist = length(p - pos);\n\t\n\t// fraction of light visible, starts at one radius (second half added in the end);\n\tfloat lf = radius * maxDist;\n\t\n    float minStep = radius * 0.15;\n    \n\t// distance traveled\n\tfloat dt =minStep;\n\n    float sd = 0.;\n    \n    float fullShadow = 0.;\n    \n\tfor (float i = 0.; i < 32.; i+=1.)\n\t{\t\t\t\t\n\t\tsd = GetDist(p + rayDir * dt);\n\n\t\tlf = min(lf, sd / dt);\n\t\t\n\t\t// move ahead\n\t\tdt += max(minStep, abs(sd));\n\t\t\n        fullShadow = step(sd, -radius);\n        \n        i+= (fullShadow + step(maxDist,dt))* 100.;\n\t}\n\n\tlf = clamp((lf*maxDist + radius) / (2.0 * radius), 0.0, 1.0);\n\tlf = smoothstep(0.0, 1.0, lf);\n\n\treturn lf * lightPower / maxDist ;\n}\n\n\n\nvoid GetRayMarchDist(vec3 rayPos, vec3 rayDir, float maxDist, inout float dist, out float steps){\n    \n    steps = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = rayPos + rayDir*dist;\n        float dS = GetDist(p);\n        dist += dS;\n        #ifdef DEBUG\n        steps += 1.; // DEBUG\n        #endif\n        if(dist>maxDist || abs(dS)<SURF_DIST*(1.+dist))\n        { \n            break;\n        }\n    }\n   \n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// This buffer handles camera movement\n// ASCII: https://www.ascii-code.com/\n\nconst float KEY_E            = 69.5 / 256.0;\nconst float KEY_Q            = 81.5 / 256.0;\nconst float KEY_W            = 87.5 / 256.0;\nconst float KEY_A            = 65.5 / 256.0;\nconst float KEY_S            = 83.5 / 256.0;\nconst float KEY_D            = 68.5 / 256.0;\nconst float KEY_LEFT         = 37.5 / 256.0;\nconst float KEY_UP           = 38.5 / 256.0;\nconst float KEY_RIGHT        = 39.5 / 256.0;\nconst float KEY_DOWN         = 40.5 / 256.0;\nconst float KEY_SHIFT        = 16.5 / 256.0;\nconst float KEY_SPACE \t     = 32.5 / 256.0;\n\nvec4 loadValue( in ivec2 dataIndex )\n{\n    return texelFetch( iChannel0, dataIndex, 0 );\n}\n\nvec3 volumeUVtoWorld(vec2 uv, vec4 VOLUME_H_SLICES) {\n\n\tfloat hy = floor(uv.y*VOLUME_H_SLICES.x);\n\tfloat hx = floor(uv.x*VOLUME_H_SLICES.x);\n\n\tvec2 xz = uv * VOLUME_H_SLICES.x;\n\n\txz.x -= hx;\n\txz.y -= hy;\n\n\txz = (xz*2. - 1.) *VOLUME_H_SLICES.y;\n\t\n\tfloat h = hy * VOLUME_H_SLICES.x + hx;\n\n\tvec3 bsPos = vec3(xz.x, h, xz.y) / VOLUME_POSITION_N_SIZE.w;\n\n\tvec3 worldPos = VOLUME_POSITION_N_SIZE.xyz + bsPos;\n\n\treturn worldPos;\n}\n\nvec4 Quat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    return normalize(vec4(axis * sin(angle), cos(angle)));\n}\n\nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + (q.w * t) + cross(q.xyz, t);\n}\n\nvec4 QxQ(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = (q1.w * q2.w) - dot(q1.xyz, q2.xyz);\n    res.xyz = (q1.w * q2.xyz) + (q2.w * q1.xyz) + cross(q1.xyz, q2.xyz);\n    return normalize(res);\n}\n\nvec2 GetMouseDelta()\n{\n        vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n        float downPrevious = mousePrevious.z; \n        float down = clamp(iMouse.z * 800., 0. , 1.);\n        return down * downPrevious *  (iMouse.xy/iResolution.xy-mousePrevious.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    if (fragCoord.y<=PRSST_MAX_Y) {\n        \n      fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        \n       ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n        \n       #define WRITE_INDEX(data) inStoreArea(data, ifragCoord)  \n       #define PRSST_RANGE(data1, data2) inStoreRange(data1, data2, ifragCoord)  \n        \n        \n        vec4 gameState = loadValue(GAME_STATE);\n        \n        if (gameState.x == 0.)\n        {\n        \n            if (WRITE_INDEX(CAM_FORWARD)){\n             \tfragColor = vec4(vec3(0.,0.,1.), 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(GAME_STATE)){\n             \tfragColor = vec4(1., 0., 0. , 0.0);\n                return;\n            }\n            \n            if (WRITE_INDEX(CAM_ROTATION_PRSST))\n       \t\t{\n                fragColor = vec4(0., 0., 0., 1.0);\n                return;\n            }\n            \n            discard;\n        }\n        \n        // Camera persistance: \n        \n        if (WRITE_INDEX(CAM_FORWARD)) {\n            \n             vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n            \n            fragColor = vec4(Rotate(lastQuat, vec3(0.,0.,1.)), 0.0);\n            \n       } else  if (WRITE_INDEX(CAM_ROTATION_PRSST)) {\n            \n            vec4 lastQuat    = loadValue(CAM_ROTATION_PRSST);\n            vec2 mouseDelta  = GetMouseDelta() * MOUSE_SENSITIVITY;\n\n            vec3 forward = loadValue(CAM_FORWARD).xyz;\n            vec3 right   = normalize(cross(forward, vec3(0.,1.,0.)));\n            vec3 up      = normalize(cross(right, forward));\n\n            lastQuat = QxQ(Quat(up, -mouseDelta.x), lastQuat);\n            lastQuat = QxQ(Quat(right, mouseDelta.y), lastQuat);\n            fragColor = lastQuat;\n           \n       } else  if (WRITE_INDEX(CAM_MOUSE_PREV_PRSST)) {\n           \n           vec4 mousePrevious = loadValue( CAM_MOUSE_PREV_PRSST);\n           mousePrevious.xy = iMouse.xy/iResolution.xy;\n           mousePrevious.z = clamp(iMouse.z * 800., 0. , 1.);\n           fragColor = mousePrevious;\n           \n           \n       } else if (WRITE_INDEX(CAM_POS_PRSST)) {\n           \n \t\t\tvec4 camera = loadValue(CAM_POS_PRSST);\n  \n           \n             vec3 off;\n\n            off.x -=  texture( iChannel1, vec2(KEY_A,0)).x;\n            off.x +=  texture( iChannel1, vec2(KEY_D,0)).x;\n            off.z +=  texture( iChannel1, vec2(KEY_W,0)).x;\n            off.z -=  texture( iChannel1, vec2(KEY_S,0)).x;\n            off.y +=  texture( iChannel1, vec2(KEY_E,0)).x;\n            off.y -=  texture( iChannel1, vec2(KEY_Q,0)).x;\n\n            if (length(off)>0.0001){\n                \n                off = normalize(off);\n                \n                vec3 camForward = \tloadValue(CAM_FORWARD).xyz;\n    \t\t\tvec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0))); \n\n                vec3 add = camForward * off.z + camRight * off.x;\n             \n                float run = texture( iChannel1, vec2(KEY_SHIFT,0)).x;\n                \n                float dist = min(1., GetDist(camera.xyz) / SLOWDOWN_RANGE);\n                \n                camera.xyz += (vec3(add.x,0.,add.z) + vec3(0., 1., 0.) * off.y) * max(0.1, dist)  * mix(PLAYER_SPEED, PLAYER_RUN_SPEED, run);\n            \n                if (dist<PLAYER_SIZE)\n                {\n                    camera.xyz += GetNormal(camera.xyz, 1.) * (PLAYER_SIZE - dist);\n                }\n            }\n            \n            \n            fragColor = camera;\n       }\n    } else {\n\n        // Ambient Light Baking\n        \n        vec2 uv = fragCoord/iResolution.xy;\n \n        fragColor = texture(iChannel0, uv);\n                \n        vec3 pos = volumeUVtoWorld(uv, GetVolumeHSlices(iResolution.y));\n\n        vec3 randomDirection = normalize(hash33(pos + iTime));\n        \n        pos += randomDirection* VOLUME_SCALE * 0.5;\n        \n        float dist = GetDist(pos);\n        \n        if (dist<0.)\n            return;\n        \n        vec3 addColor = vec3(0.);\n        \n        // SKY LIGHT\n        \n        vec2 rayCast = GetRaycastDist(pos, randomDirection);\n        \n        if (rayCast.x + 1. > MAX_DIST) \n        {\n        \taddColor.b = 1.;  //SkyBox(randomDirection);\n        }\n        \n        // LIGHT POINT\n        \n        vec3 toLight = lightSource_0.xyz- pos;\n        float len = length(toLight);\n        \n        #ifdef MARCH_VOLUME_SHADOW\n        \tfloat visible =  Shadow(pos, lightSource_0.xyz, SHADOW_RADIUS, lightSource_0.w);\n        #else\n         \tvec2 lightPointRay = GetRaycastDist(pos, normalize(toLight));\n        \tfloat visible = step(0., dist) * step(length(toLight), lightPointRay.x + 0.01);\n        #endif\n        \n       \n        addColor.r += visible;\n      \n        \n        //addColor += lightSource_0_Color.rgb *  ( lightSource_0.w * visible * 1000. / (len*len + 1.));\n\n        // STORING\n        \n        fragColor.a += 1.;\n        \n        float newPortion = 1./ (fragColor.a);\n        \n        fragColor.a = min(50., fragColor.a);\n        \n        fragColor.rgb = mix(fragColor.rgb, addColor, newPortion);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}