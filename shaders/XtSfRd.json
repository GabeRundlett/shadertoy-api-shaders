{
    "Shader": {
        "info": {
            "date": "1516911822",
            "description": "trying out a worley noise implementation",
            "flags": 0,
            "hasliked": 0,
            "id": "XtSfRd",
            "likes": 4,
            "name": "Worley Noise Test",
            "published": 3,
            "tags": [
                "worleynoise"
            ],
            "usePreview": 0,
            "username": "ircss",
            "viewed": 589
        },
        "renderpass": [
            {
                "code": "// Cellular noise (\" Worley noise \") in 2D in GLSL , simplified version .\n// Copyright (c) Stefan Gustavson 2011-04 -19. All rights reserved .\n// This code is released under the conditions of the MIT license .\n// See LICENSE file for details .\n\nvec4 permute(in vec4 x)\n{\n return mod ((34.0 * x + 1.0) * x , 289.0);   \n}\n\nvec2 celluar2x2( vec2 P, float  jitterng) {\n    \n    float pp =  1.0 + floor(jitterng* 2.0) *7.0; \n    \n \tfloat K = 1.0/pp;\n\tfloat K2 = 0.5/pp;\n\tfloat jitter = jitterng /*abs( fract(iTime * 0.1)* 2.0 - 1. )*/; // jitter 1.0 makes F1 wrong more often\n\tvec2 Pi = mod(floor(P), 289.0) ;\n\tvec2 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\tvec4 p = permute (Pi.x + vec4(0.0 , 1.0, 0.0, 1.0));\n\tp = permute (p + Pi.y + vec4(0.0 , 0.0, 1.0, 1.0));\n\tvec4 ox = mod(p, pp) * K + K2;\n\tvec4 oy = mod(floor(p * K) ,pp) * K + K2;\n\tvec4 dx = Pfx + jitter * ox;\n\tvec4 dy = Pfy + jitter * oy;\n\tvec4 d = dx * dx + dy * dy; // distances squared\n\t// Cheat and pick only F1 for the return value\n\td.xy = min(d.xy, d.zw);\n\td.x = min(d.x, d.y);\n\treturn d.xx; // F1 duplicated , F2 not computed\n \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float middleOfScreenX = 0.5* (iResolution.x/ iResolution.y);\n    vec2 middleVector = vec2(middleOfScreenX, 0.5);\n    \n    float distanceToMiddle = distance(middleVector, uv);\n    float radius = fract(iTime * 0.1);\n    float jitterFactor = 1.0 - smoothstep(radius, radius + 0.25, distanceToMiddle);\n    jitterFactor = 1.0 - clamp( abs(distanceToMiddle - radius) / (radius + 0.01), 0.0 , 1.0);\n    \n    vec2 F = celluar2x2(vec2(uv.x  + floor(iTime* 0.1), uv.y) *10.0, jitterFactor);\n    float n = 1.0 - 1.5 * F.x;\n    \n\tfragColor = 1.0 -  vec4(n, n, n , 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}