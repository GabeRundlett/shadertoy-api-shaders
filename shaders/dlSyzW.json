{
    "Shader": {
        "info": {
            "date": "1691512777",
            "description": "Tiling demo and circle drawing demo.\n\nUse the mouse to change the tile size.",
            "flags": 0,
            "hasliked": 0,
            "id": "dlSyzW",
            "likes": 1,
            "name": "Tiled Circles",
            "published": 3,
            "tags": [
                "circles",
                "tiling"
            ],
            "usePreview": 0,
            "username": "LeifMessinger",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.1415926535897932384626433832795\n\n//Boolean circles don't have AA. Switch to 1 to make circles boolean.\n#define CIRCLE_BOOL 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    bool mouseInactive = iMouse.xy == vec2(0.0, 0.0);\n    //Tile size in pixels\n    vec2 tileSize = mouseInactive? (iResolution.xy/8.0): iMouse.xy;\n    \n    //This gets the coords, which is the fragCoord from [0.0, 0.0] to [1.0, 1.0] inside the tile\n    ivec2 tileIndex;\n    vec2 coords = tile(fragCoord, tileSize, tileIndex);\n    \n    //Checking if it's an even or an odd tile\n    bool white = ((tileIndex.x ^ tileIndex.y) % 2) == 0;\n    \n    const float pulseSpeed = .5;\n    float diameter = abs(sin(M_PI * iTime * pulseSpeed));\n\n    #if CIRCLE_BOOL\n        bool inCircle = isInCircle(coords, vec2(1.0, 1.0), diameter);\n\n        float brightness = float(true ^^ inCircle ^^ white);\n\n        vec3 color = vec3(brightness);\n        // Output to screen\n        fragColor = vec4(color,1.0);\n    #else\n        const float AA_STRENGTH = 2.0;\n        float featherSize = diameter - ((1.0 / min(tileSize.x, tileSize.y)) * AA_STRENGTH);\n        float inCircle = circle(coords, vec2(1.0, 1.0), diameter, featherSize);\n\n        float brightness = (white)? inCircle : (1.0 - inCircle);\n\n        vec3 color = vec3(brightness);\n        // Output to screen\n        fragColor = vec4(color,1.0);\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Tiles coordinates\n//loopDistance is the xy size of a tile\n//the output is the coordinate from [0,1] with respect to its own tile\nvec2 tile(in vec2 coord, in vec2 loopDistance, out ivec2 tileIndex){\n    vec2 xy = coord/loopDistance; //This is the xy of one tile\n    vec2 coords = fract(xy); //Same as mod(x,1.0);\n    tileIndex = ivec2(trunc(xy));\n    return coords;\n}\n\nvec2 tile(in vec2 coord, in vec2 loopDistance){\n    ivec2 tileIndex; //We throw this away\n    return tile(coord, loopDistance, tileIndex);\n}\n\n\n//Centers a coordinate\n//Imagine a square that goes from [0, 0] to [x, y]. If we center it, we make it [-x/2, -y/2] to [x/2, y/2]\nvec2 center(in vec2 coord, in vec2 boundingBoxSize){\n    return coord - (.5 * boundingBoxSize);\n}\n\n//Maybe better looking, because of curves, but probably not worth the performance hit. Probably keep off.\n#define CIRCLE_SMOOTHSTEP 0\n//This one lets you make feather greater than radius and it'll fall back to the boolean circle converted to a float.\n#define CIRCLE_SAFETY 1\n//Makes the circles gray when the safety is triggered\n#define CIRCLE_SAFETY_DEBUG 0\n\n//Returns true if coord is in the circle\n//If the coord is in the circle, then the magnitude of the coordinate is less than the radius\n//The circle's origin is at 0,0\nbool isInCircle(in vec2 coord, in float radius){\n    return length(coord) < radius;\n}\n\n//The diameter is the size from 0.0 to 1.0 (or larger) of the circle within the bounding box\nbool isInCircle(in vec2 coord, in vec2 boundingBox, in float diameter){\n    //Center the coorinates\n    coord = center(coord, boundingBox);\n    \n    //Gets coordinates from [0, 0] to [1, 1] inside the box\n    vec2 xy = coord / boundingBox;\n    \n    return isInCircle(coord, diameter/2.0);\n}\n\nbool isInCircle(in vec2 coord, in vec2 boundingBox){\n    return isInCircle(coord, boundingBox, 1.0);\n}\n\n//Returns 1.0 if coord is in the circle\n//If the coord is in the circle, then the magnitude of the coordinate is less than the radius\n//The circle's origin is at 0,0\nfloat circle(in vec2 coord, in float radius){\n    return float(isInCircle(coord, radius));\n}\n\n//Feather is what point of the circle is good enough to be 1.0. Feather should be < radius\nfloat circle(in vec2 coord, in float radius, in float feather){\n    #if CIRCLE_SAFETY\n        #if CIRCLE_SAFETY_DEBUG\n            if(feather >= radius) return  .5 * circle(coord, radius);\n        #else\n            if(feather >= radius) return circle(coord, radius);\n        #endif\n    #endif\n    \n    #if CIRCLE_SMOOTHSTEP\n        //Typically, smoothstep is (min, max, x), which gives you 0.0 to 1.0 as x grows\n        //Turns out, you can flip it to (max, min, x) and it'll give you 1.0 to 0.0\n        return smoothstep(radius, feather, length(coord));\n    #else\n        return 1.0 - ((length(coord)-feather) / (radius-feather));\n    #endif\n}\n\n\n//The diameter is the size from 0.0 to 1.0 (or larger) of the circle within the bounding box\nfloat circle(in vec2 coord, in vec2 boundingBox, in float diameter, in float feather){\n    //Center the coorinates\n    coord = center(coord, boundingBox);\n    \n    //Gets coordinates from [0, 0] to [1, 1] inside the box\n    vec2 xy = coord / boundingBox;\n    \n    return circle(coord, diameter/2.0, feather/2.0);\n}\n\n//If you don't specify a feather, just call the boolean function instead. Can't really do anything if you don't specify feather.\nfloat circle(in vec2 coord, in vec2 boundingBox, in float diameter){\n    return float(isInCircle(coord, boundingBox, diameter));\n}\n\nfloat circle(in vec2 coord, in vec2 boundingBox){\n    return circle(coord, boundingBox, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}