{
    "Shader": {
        "info": {
            "date": "1672186501",
            "description": "3D modelling / raymarching practice",
            "flags": 0,
            "hasliked": 0,
            "id": "dtlGzf",
            "likes": 23,
            "name": "A pear",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "chengsun",
            "viewed": 233
        },
        "renderpass": [
            {
                "code": "/* A pear: a study on the basics of distance-field modelling, and raymarched\n * rendering.\n *\n * I'm reasonably happy with how things turned out here, for my first serious\n * attempt at modelling a nontrivial 3D object. Things to think about for next\n * time:\n *\n * - The noise/hash as used on the texture of the pear body isn't great. The\n *   current implementation was lifted directly from another shader, and then\n *   left pretty much untweaked because it looked \"good enough\". We could get\n *   away with a cheaper implementation and/or one that has fewer artifacts.\n *\n * - Play around with the difference between small-scale distance field\n *   displacement and bump-mapping, for subtle surface qualities. I used a mix\n *   of the two here; could I have gotten away with the latter for everything?\n *   It seems likely to be considerably cheaper. How much \"worse\" is it?\n *\n * - Figure out how texture mapping / UV coordinates are meant to work. This\n *   time I simply gave up on UV mapping and simply used the 3D coordinates in\n *   model space. I'm not convinced this method is very good. It certainly\n *   doesn't if I want to animate the model at all.\n *\n * - Learn and use a more realistic reflection model -- I used Blinn-Phong\n *   because it's all I know.\n *\n * - Work on making the background more appealing. The current background is\n *   both very expensive and very boring: the backdrop casts full-blown\n *   lighting/shadow rays for very little visual gain.\n *\n * - Try animating the model, or at least making the object do something a bit\n *   more stylish than simply rotating in place.\n *\n * - Working in a linear colour space (gamma-corrected and tonemapped) from the\n *   beginning made both very easy. iq's article was super helpful here:\n *   https://iquilezles.org/articles/outdoorslighting/\n *   Debanding was added afterwards and was also super easy. But, I need to\n *   figure out some sort of antialiasing for next time (I couldn't get\n *   supersampling to work properly here; I probably did something wrong).\n */\n\n#define ZERO (min(iFrame, 0))\n\n// polynomial smooth min\n// https://iquilezles.org/articles/smin/\nfloat smin(float d1, float d2, float k) {\n    float h = max(k - abs(d1 - d2), 0.) / k;\n    return min(d1, d2) - h * h * k * 0.25;\n}\n\n// cubic pulse\n// https://iquilezles.org/articles/functions/\nfloat pulse(float c, float w, float x) {\n    x = abs(x - c);\n    if(x > w) return 0.;\n    x /= w;\n    return 1. - x * x * (3. - 2. * x);\n}\n\nmat2 rotationMatrix(float th) {\n    return mat2(cos(th), -sin(th), sin(th), cos(th));\n}\n\n// SDF primitives\n// https://iquilezles.org/articles/distfunctions/\n//\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat sdVerticalCapsule(vec3 p, float h, float r) {\n    p.y -= clamp(p.y, 0., h);\n    return length(p) - r;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n  // sampling independent computations (only depend on shape)\n  float b = (r1 - r2) / h;\n  float a = sqrt(1. - b * b);\n\n  // sampling dependant computations\n  vec2 q = vec2(length(p.xz), p.y);\n  float k = dot(q, vec2(-b, a));\n  if (k < 0.) return length(q) - r1;\n  if (k > a*h) return length(q - vec2(0., h)) - r2;\n  return dot(q, vec2(a, b)) - r1;\n}\n\n// distance fields\n\nfloat mapStalk(vec3 pp) {\n    float dd;\n\n    // main stalk\n    {\n        vec3 p = pp;\n        p.xy = rotationMatrix(0.11) * p.xy;\n        p.yz = rotationMatrix(-0.04) * p.yz;\n\n        // bend a bit\n        p.xz -= vec2(-0.16, -0.06)*smoothstep(0.3, 1.3, p.y);\n\n        dd = sdVerticalCapsule(p, 0.6, 0.1);\n    }\n\n    // knobbly tip\n    {\n        vec3 p = pp - vec3(-0.18, 0.75, -0.12);\n        p.yz = rotationMatrix(-0.4) * p.yz;\n\n        float d = sdRoundBox(p, vec3(0.03), 0.06);\n\n        // displacement for roughness where the stalk was cut\n        float displacement = 0.01 * sin(110. * pp.x) * sin(110. * pp.y) * sin(110.*pp.z);\n        d += displacement*smoothstep(0.1, -0.2, p.x);\n\n        dd = smin(dd, d, 0.16);\n    }\n\n    return dd;\n}\n\nvec2 map(vec3 pp, out vec3 uv) {\n    float dd = 100.;\n    float material = 0.;\n\n    // rotate model with time\n    pp.xz = rotationMatrix(-iTime) * pp.xz;\n\n    uv = pp;\n\n    // base\n    {\n        vec3 p = pp - vec3(0., -3.58, 0.);\n\n        // flatten the base a bit\n        vec3 v = pow(p, vec3(4.)) - vec3(0., 0.24, 0.);\n        p = sign(v) * pow(abs(v), vec3(.25)) - vec3(0., 1.75, 0.);\n\n        dd = sdSphere(p, 1.18);\n    }\n\n    // neck\n    {\n        vec3 p = pp - vec3(-0.2, -0.8, 0.);\n        p.xy = rotationMatrix(0.22) * p.xy;\n\n        // bend neck a bit\n        p.z -= 0.26 * smoothstep(0.1, 2.8, p.y);\n\n        // carve a little saddle into the top\n        p.y += 0.05 * pulse(0., 0.2, p.x);\n\n        float d = sdRoundCone(p, 0.77, 0.4, 2.);\n\n        dd = smin(dd, d, 0.65);\n    }\n\n\n    // stalk\n    {\n        vec3 p = pp - vec3(-0.7, 1.5, 0.24);\n        float d = mapStalk(p);\n\n        if (dd > d) {\n            dd = d;\n            material = 1.;\n        }\n    }\n\n    return vec2(dd, material);\n}\n\nfloat map(vec3 pp) {\n    vec3 uv = vec3(0.);\n    return map(pp, uv).x;\n}\n\n// ACES tonemap\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Noise\n// https://iquilezles.org/articles/morenoise\n// This particular code from \"Rainforest - iq\"\n// https://www.shadertoy.com/view/4ttSWf\n\nfloat hash1(float n) {\n    return fract(n * 17. * fract(n * 0.3183099));\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float n = p.x + 317.0*p.y + 157.0*p.z;\n\n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n    float f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nfloat fbm(in vec3 x) {\n    float result = 0.;\n    for (int i = ZERO; i <= 3; ++i) {\n        result += noise(x);\n        x = 3.*x;\n    }\n    return result;\n}\n\n// Raymarch loop\nfloat march(vec3 ro, vec3 rd) {\n    float t = 0.;\n    vec3 p = ro;\n    for (int i = ZERO; i < 32; ++i) {\n        float dt = map(p);\n        t += dt;\n        p = ro + t * rd;\n        if (dt <= 0.01 || t > 20. || p.y < -3.) break;\n    }\n    return t;\n}\n\n// Soft shadows raymarch loop\n// https://iquilezles.org/articles/rmshadows/\nfloat shadow(vec3 ro, vec3 rd) {\n    float t = 0.1;\n    vec3 p = ro + t * rd;\n    float res = 1.0;\n    for (int i = ZERO; i < 16; ++i) {\n        float dt = map(p);\n        t += dt;\n        p = ro + t * rd;\n        res = min(res, 2.*dt/t);\n        if (dt <= 0.01) return 0.;\n        if (t > 20. || p.y < -3.) break;\n    }\n    return res;\n}\n\nvec3 lighting1(vec3 p, vec3 norm, vec3 ro, vec3 matcol, vec3 ld, float specular_factor) {\n    float diffuse = 1. * clamp(dot(norm, ld), 0., 1.);\n    vec3 view = normalize(p - ro);\n    vec3 refl_view = view - 2.*dot(view, norm)*norm;\n    float specular = specular_factor * pow(clamp(dot(refl_view, ld), 0., 1.), 7.);\n\n    return diffuse * matcol + specular;\n}\n\nvec3 lighting(vec3 p, vec3 norm, vec3 ro, vec3 matcol, float specular_factor) {\n    vec3 col = vec3(0.);\n\n    // two strip lights to the left and right\n    for (float lx = float(ZERO)-6.; lx <= 6.; lx += 12.) {\n        int nz = 4;\n        for (int zz = 0; zz < nz; ++zz) {\n            vec3 lo = vec3(lx, 4., mix(-4., 4., float(zz)/float(nz-1)));\n            vec3 ld = normalize(lo - p);\n            float sh = shadow(p, ld);\n\n            col += vec3(4.1 / float(nz)) * sh * lighting1(p, norm, ro, matcol, ld, specular_factor);\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 scr = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0., 0., -10.);\n    vec3 rd = normalize(vec3(scr*3.4, 0.) - ro);\n\n    float t = march(ro, rd);\n    vec3 p = ro + t * rd;\n    vec3 uv = vec3(0.);\n    vec2 map_result = map(p, uv);\n    float d = map_result.x;\n    float material = map_result.y;\n\n    float groundheight = -2.7;\n    float groundt = (groundheight - ro.y)/rd.y;\n    vec3 groundmatcol = vec3(1., 1., 1.) * 0.4;\n\n    vec3 pearmatcol0 = vec3(0.89, 0.81, 0.3) * 0.15;\n    vec3 pearmatcol1 = vec3(0.75, 0.9, 0.1) * 0.15;\n    vec3 pearmatcol2 = vec3(0.9, 0.5, 0.2) * 0.15;\n\n    vec3 stalkmatcol1 = pearmatcol1 * 0.9;\n    vec3 stalkmatcol2 = vec3(0.65, 0.45, 0.25) * 0.15;\n    vec3 stalkmatcol3 = vec3(0.9, 0.6, 0.6) * 0.055;\n    vec3 stalkmatcol4 = vec3(0.9, 0.8, 0.7) * 0.045;\n\n    vec3 col = vec3(0.);\n    if (groundt >= 0. && length(ro+groundt*rd) <= 10. && (d > 0.01 || groundt < t)) {\n        // ground circle\n        p = ro + groundt * rd;\n        vec3 norm = vec3(0., 1., 0.);\n        float specular_factor = 0.1;\n        col = lighting(p, norm, ro, groundmatcol, specular_factor);\n\n        // pear indirect bounce -- very subtle\n        col += 0.5*mix(pearmatcol1, pearmatcol2, 0.2) * lighting1(p, norm, ro, groundmatcol, normalize(vec3(0.)-p), specular_factor);\n    } else if (d <= 0.01) {\n        // pear\n        vec3 norm = vec3(0.);\n        vec2 eps = vec2(0.0001, 0.);\n        norm = vec3(map(p + eps.xyy) - map(p - eps.xyy),\n                    map(p + eps.yxy) - map(p - eps.yxy),\n                    map(p + eps.yyx) - map(p - eps.yyx));\n\n        vec3 matcol;\n        float specular_factor;\n        if (material < 0.5) {\n            // fruit body\n            matcol = mix(pearmatcol0, pearmatcol1, smoothstep(-2., 0., uv.y - 0.2*abs(uv.x) + 0.4*abs(uv.z)));\n            matcol = mix(matcol, pearmatcol2, clamp(fbm(uv), 0., 1.));\n            specular_factor = 0.08;\n\n            // bumpmap\n            norm += noise((uv+vec3(1.,2.,-1.))*vec3(100.,30.,100.))*0.00001;\n            norm = normalize(norm);\n        } else {\n            // stalk\n            matcol = mix(stalkmatcol1, stalkmatcol2, clamp(smoothstep(1.5, 1.8, uv.y) + 0.6*pow(fbm(uv*20.*vec3(0.7,0.2,0.7)),3.), 0., 1.));\n            matcol = mix(matcol, stalkmatcol3, clamp(fract(2.8*cos(1.4+15.*uv.x+sin(0.3+31.*uv.z))+cos(5.2*uv.y+0.8))+smoothstep(1.6, 2.3, uv.y-uv.z*0.6)-0.89, 0., 1.));\n\n            float cut_factor = smoothstep(0.09, 0.03, uv.z);\n            matcol = mix(matcol, stalkmatcol4, cut_factor);\n            specular_factor = mix(0.01, 0.08, cut_factor);\n\n            // bumpmap\n            norm += noise((uv+vec3(1.,2.,-1.))*vec3(70.,10.,70.))*0.00009;\n            norm = normalize(norm);\n        }\n\n        // lights\n        col += lighting(p, norm, ro, matcol, specular_factor);\n\n        // ground indirect bounce\n        vec3 ld = vec3(0., -1., 0.);\n\n        float occlusion = mix(0.4, 1., smoothstep(-2.65, -2.4, p.y));\n\n        float sh = clamp(shadow(p, ld) * occlusion, 0., 1.);\n        col += groundmatcol * sh * matcol * pow(clamp(dot(norm, vec3(0., -1., 0.)), 0., 1.), 0.5);\n    } else {\n        // walls\n        float specular_factor = 0.1;\n        p = ro + 20. * rd;\n        col = lighting(p, normalize(p - ro), ro, groundmatcol, specular_factor);\n    }\n\n    // tonemapping, gamma correction, debanding\n    col = aces(col);\n    col = pow(col, vec3(0.4545));\n    col += vec3(noise(vec3(fragCoord.xyy))) / 256.;\n\n    fragColor = vec4(col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}