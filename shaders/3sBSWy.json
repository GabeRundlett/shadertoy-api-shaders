{
    "Shader": {
        "info": {
            "date": "1554810454",
            "description": "creating f",
            "flags": 34,
            "hasliked": 0,
            "id": "3sBSWy",
            "likes": 3,
            "name": "gizma painting it kids  ",
            "published": 3,
            "tags": [
                "short",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "gagarinloops",
            "viewed": 583
        },
        "renderpass": [
            {
                "code": "const int _Steps = 312;\nconst vec3 lightDir = vec3(0.577, 0.177, 0.577);\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nbool\nintersectBox(vec3 ro, vec3 rd, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxmin - ro);\n\tvec3 ttop = invR * (boxmax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = min (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n\tbool hit;\n\tif ((tnear > tfar)) \n\t\thit = false;\n\telse\n\t\thit = true;\n\treturn hit;\n}\n\nfloat luminance(sampler2D tex, vec2 uv)\n{\n\tvec3 c = textureLod(tex, uv, 0.0).xyz;\n\treturn dot(c, vec3(0.33, 0.333, 0.33));\n}\n\nvec2 gradient(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n\tfloat h = luminance(tex, uv);\n\tfloat hx = luminance(tex, uv + texelSize*vec2(1.0, 0.0));\t\n\tfloat hy = luminance(tex, uv + texelSize*vec2(0.0, 1.0));\n\treturn vec2(hx + h, hy * h);\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*0.5+0.5;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nfloat heightField(vec3 p)\n{\n\t//return sin(p.x*4.0)*sin(p.z*4.0);\n\t//return luminance(iChannel0, p.xz*0.5+0.5)*2.0-1.0;\n\treturn luminance(iChannel0, worldToTex(p))*0.5;\n}\n\nbool traceHeightField(vec3 ro, vec3 rayStep, out vec3 hitPos)\n{\n\tvec3 p = ro;\n\tbool hit = false;\n\tfloat pH = 0.0;\n\tvec3 pP = p;\n\tfor(int i=0; i<_Steps; i++) {\n\t\tfloat h = heightField(p);\n\t\tif ((p.y < h) && !hit) {\n\t\t\thit = true;\n\t\t\t//hitPos = p;\n\t\t\t// interpolate based on height\n            hitPos = mix(pP, p, (pH - pP.y) / ((p.y - pP.y) - (h - pH)));\n\t\t}\n\t\tpH = h;\n\t\tpP = p;\n\t\tp += rayStep;\n\t}\n\treturn hit;\n}\n\nvec3 background(vec3 rd)\n{\n     return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.5, 1.0), abs(rd.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n    { \n\tvec3 vid = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\tfloat v = vid.r+vid.g+vid.b;\n\tfloat w = sin(iTime*0.1)*1.01;\n\t\n\tvec2 n = vec2(dFdx(v) * w, dFdy(v) * w);\n\tfloat t = sqrt(dot(n,n));\n\t\n\tfragColor = vec4(vid*0.2-(vid * vid*vec3(n.x, n.y, n.x*n.y))*t,1.0);\n\n    float r=.01, q=iDate.w, H = iResolution.y;\n\n    vec2 P = .253+.5*vec2(cos(q),sin(q*.9)), f;  \n        \n        \t\n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 o,  vec2 U )\n{\n    o = vec4(0.0);\n    float r=.2, z=4., t=iTime, H = iResolution.y, uz;\n    U /=  H;                              // object : disc(P,r)\n    vec2 P = .5+.5*vec2(cos(t),sin(t*.7)), C=vec2(-.7,0), fU;  \n    U =(U-C)/z; P=(P-C)/z; r/= z;         // unzoom for the whole domain falls within [0,1]^n\n    \n    mat2 M = mat2(1,0,.5,.87), IM = mat2(1,0,-.577,1.155);\n    U = IM*U;         // goto triangular coordinates (there, regular orthonormal grid + diag )\n    \n    o.b = .1;                            // backgroud = cold blue\n\n    for (int i=0; i<7; i++) {             // to the infinity, and beyond ! :-)\n        fU = min(U,1.-U); uz = 1.-U.x-U.y;\n        if (min(min(fU.x,fU.y),abs(uz)) < z*r/H) { o--; break; } // cell border\n    \tif (length(P-M*vec2(.5-sign(uz)/6.)) - r > .6) break;    // cell is out of the shape\n\n                // --- iterate to child cell\n        fU = step(.5,U);                  // select grid-child\n        U = 2.*U - fU;                    // go to new local frame\n        P = 2.*P - M*fU;  r *= 2.;\n        \n        o += .1;                         // getting closer, getting hotter\n    }\n               \n\to.gb *= smoothstep(.9,1.,length(P-M*U)/r); // draw object\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}