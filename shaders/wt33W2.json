{
    "Shader": {
        "info": {
            "date": "1577586764",
            "description": "IF YOU DON'T SEE THE VIDEO, WAIT.\ndoesn't animate/still no video: pause+play video below, and wait 30 seconds.\n(unmute the video while you're there!)\n\nTUNE OPTIONS IN THE SHADER\ndefault settings are \"won't instantly kill your PC\".\nread more in the shader",
            "flags": 0,
            "hasliked": 0,
            "id": "wt33W2",
            "likes": 29,
            "name": "pinscreen video — sat.sketch #5",
            "published": 3,
            "tags": [
                "phong",
                "postprocessing",
                "video",
                "camera",
                "lambert",
                "ao",
                "hdr",
                "blinn",
                "marble",
                "hemisphere",
                "pp",
                "realistic",
                "gold",
                "temporal",
                "taa",
                "pin",
                "pinscreen",
                "pinart"
            ],
            "usePreview": 0,
            "username": "szczm_",
            "viewed": 1136
        },
        "renderpass": [
            {
                "code": "// \"Temporally supersampled\" Anti Aliasing samples. Make it as high as you can! But be careful.\n// 12 should be good enough. 128 would be awesome. 1 is for my laptop.\n#define TAA_SAMPLES 4\n\n// Comment out to disable post processing\n#define PP\n\n// Comment out to disable tonemapping\n#define TONEMAPPING\n\n\n\n/******************************************************************************\n\n pinscreen video — saturday sketch #5\n  — Matthias Scherba (szczm_)\n\n\n This took a lot more time than I expected. I had a note that said:\n  \"pintable shader\"\n and I didn't really plan to make it look this good. Sorry :(\n\n\n Includes:\n - video pinscreen!\n - nice camera paths\n - nicely commented code\n - Lambert + Blinn-Phong shading\n - temporal supersampling\n - simple Reinhardt tonemapping\n - hemispherical ambient occlusion\n - nice post processing\n\n\n Fun fact: there are no shadows, it's just lighting (w/ attenuation) and AO.\n\n Sad fact: no motion vectors, and can't rewind/fast forward video so no motion blur on the pins :(\n\n\n Any questions? Feedback! Let me know!\n\n Signing out -\n\n - actually, I'm not signing out\n\n\n******************************************************************************/\n\n\nconst int MAX_STEPS = 150;\nconst float MIN_DIST = 0.5;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 5e-4;\n\n\nfloat time;\n\nstruct DistMat {\n    float dist;\n    int mat;\n};\n\n    \n// SDF functions\nfloat planeSDF(vec3 p, vec3 n) {\n    return length(p) * dot(normalize(p), n);\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n// Fix for some drivers\n#define TAU 6.28318530718\nfloat sinf(float arg) { return sin(mod(arg, TAU)); }\nfloat cosf(float arg) { return cos(mod(arg, TAU)); }\n\n\nmat3 rotY(float angle) {\n    return mat3(\n        vec3(cos(angle), 0.0, sin(angle)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(angle), 0.0, cos(angle))\n    );\n}\n\n\nconst float pinSpacing = 0.04;\n\n\n// Calculates correct coordinates from worldspace and returns a texel of the video\nvec3 getVideoTexel(vec3 p) {\n        \n    p.x = -p.x;\n    p.xz += vec2(3.0, 2.3);\n    \n   \tconst vec2 modDomain = vec2(pinSpacing) * 0.5;\n    \n    vec3 pp = p;\n    pp.xz = mod(pp.xz + modDomain, modDomain * 2.0) - modDomain;\n    \n    // What I'm doing here is called a pro gamer move.\n    // we are taking the difference from original coordinates and using it\n    // as the UVs. Each box is the same, but each is different. B)\n    vec2 uv = (p.xz - pp.xz) * 0.2;\n    uv.x *= iChannelResolution[0].y / iChannelResolution[0].x;\n    \n    vec3 tex = pow(texture(iChannel0, uv).rgb, vec3(2.2));\n    \n    return tex * step(0.01, uv.x) * step(0.01, 1.0 - uv.x) * step(0.01, uv.y) * step(0.01, 1.0 - uv.y);\n}\n\nfloat luminance(vec3 col) {\n    return dot(col, vec3(0.299, 0.587, 0.114));\n}\n\n\nDistMat sum(DistMat a, DistMat b) {\n    if (a.dist < b.dist)\n\t\treturn a;\n    else\n\t\treturn b;\n}\n\nDistMat intersect(DistMat a, DistMat b) {\n    if (a.dist < b.dist)\n        return b;\n    else\n        return a;\n}\n\n\nDistMat sceneSDF(vec3 p)\n{    \n    vec3 op = p;\n    \n    float texel = luminance(getVideoTexel(p));\n    \n    p.x = -p.x;\n    p.xz += vec2(3.0, 2.3);\n    \n   \tconst vec2 modDomain = vec2(pinSpacing) * 0.5;\n    p.xz = mod(p.xz + modDomain, modDomain * 2.0) - modDomain;\n    \n    // Pin height\n    float h = (texel - 0.015) * 0.14;\n    \n    // Pinscreen\n    DistMat scene = DistMat(boxSDF(p - vec3(0.0, h, 0.0), vec3(pinSpacing * 0.4, h, pinSpacing * 0.4)) - 0.004, 0);\n    \n    // Rest of the room\n    scene = sum(scene, DistMat(-boxSDF(op - vec3(0.0, 8.0, 0.0), vec3(5.15, 8.0, 5.15)), 1));\n    \n    return scene;\n}\n\n\nDistMat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int mat = 0;\n    int i;\n    \n    for (i = 0; i < MAX_STEPS; i++) {\n        DistMat dist = sceneSDF(eye + depth * marchingDirection);\n        \n        // Relax, distance. You don't want to miss your opportunities.\n        depth += dist.dist * 0.3;\n        mat = dist.mat;\n        \n        if (abs(dist.dist) < EPSILON) {\n\t\t\tbreak;\n        }\n        \n        if (depth >= end) {\n            depth = end;\n            break;\n        }\n    }\n    \n    return DistMat(depth, mat);\n}      \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 normal(vec3 p, vec3 viewDir) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\n\n// Simple hash functions. How do you create a hash function?\n// Display it on the screen. Type in random numbers until it looks good enough.\n// Easy.\nfloat hash(float i) {\n    return fract(sinf(785172.9189*i) * 20412.021401);\n}\n\nfloat hash(vec3 i) {\n    return hash(dot(i, vec3(2154.9251, 9253.5219, 5021.2510)));\n}\n\n\n// Not too uniform because the above comment about my hash functions is true, but uniform enough.\nvec3 randomPointOnHemisphere(vec3 dir, float seed) {\n    float a = hash(seed);\n    float b = hash(seed + 1.0);\n    float c = hash(seed + 2.0);\n    \n    vec3 point = normalize(-1.0 + 2.0 * vec3(a, b, c));\n    \n    // Point it in the right direction.\n    return point * sign(dot(dir, point));\n}\n\n\n// Hemispherical AO\nfloat ao(vec3 p, vec3 n) {\n    float accu = 0.0;\n    float mult = 0.0;\n    \n    // One sample is enough with \"TAA\" and a big viewing distance.\n    // I mean the viewport, not the screen. Don't sit further away, silly.\n    for (float depth = 0.05; depth <= 0.25; depth += 0.05) {\n        vec3 dir = normalize(n + randomPointOnHemisphere(n, depth * 10.0 + hash(p) + time));\n        float dist = sceneSDF(p + depth * dir).dist;\n        accu += dist;\n        mult += depth;\n    }\n    \n    return clamp(accu / mult, 0.0, 1.0);\n}\n\n\nvec3 lightPosition() {\n    return vec3(1.5, 4.0, 1.0);\n}\n\nvec3 lightColor() {\n    return vec3(1.0, 0.95, 0.9);\n}\n\nfloat lightIntensity() {\n    return 50.0;\n}\n\n\nvec3 lighting(in vec3 position, in vec3 normal, in vec2 coords, in vec3 viewDir, in int mat)\n{\n    vec3 lightPos = lightPosition();\n    vec3 lightCol = lightColor();\n    \n    float lightAtten = lightIntensity() / pow(distance(position, lightPos), 2.0);\n    \n    // The floor/wall pattern\n    float zig = abs(mod(position.x * 4.0, 2.0) - 1.0) + abs(mod(position.y * 4.0 - 1.0, 2.0) - 1.0) + abs(mod(position.z * 4.0, 2.0) - 1.0);\n    zig = step(1.0, zig);\n    \n    // \"Left\" is gold, \"right\" is white \"marble\".\n    vec3 color = mix(vec3(1.0, 0.94, 0.75) * 0.47, vec3(0.72), zig);\n    float shininess = mix(0.4, 0.1, zig);\n    float roughness = mix(50.0, 0.1, zig);\n\n    // mat 0 is our pinscreen. I'm not using the material system in the end, somehow.\n    if (mat == 0) {\n        color = getVideoTexel(position) + 0.15;\n        roughness = 0.2;\n        shininess = 0.05;\n    }\n        \n    vec3 lightDir = normalize(lightPos - position);\n    \n    \n    // Diffuse terms, e.g. \"I see you as a friend.\"\n    float ndotl = dot(normal, normalize(lightDir));\n    \n    float diffuseLambert = max(0.0, ndotl);\n    \n    \n    // Specular terms\n    float ndoth = dot(normal, normalize(-viewDir + lightDir));\n    float ldotr = dot(lightDir, reflect(viewDir, -normal));\n    \n    float specularBlinnPhong = pow(max(ndoth, 0.0), roughness);\n    float specularPhong = pow(max(ldotr, 0.0), roughness);\n    \n    \n    // Ambient Occlusion\n    float ao = ao(position, normal);\n    \n    \n    float ambient = 0.6;\n    float diffuse = diffuseLambert * (1.0 - ambient);\n    \n    // You can swap specularBlinnPhong for specularPhong\n    float specular = specularBlinnPhong * shininess;\n\n    \n    // Uncomment and play with the below line to check out specific terms!\n    // return vec3(ao);\n    \n    \n    return vec3(ambient * color + (diffuse * color + specular) * ao * lightAtten) * lightCol;\n}\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat getTake() {\n    const float take_duration = 9.0;\n    const float take_count = 3.0;\n    \n    // Uncomment below line to force a take (0.0, 1.0, 2.0)\n    // return 1.0;\n    \n    return float(int(mod(time / take_duration, take_count) * take_duration) / int(take_duration));\n}\n\nvec3 getEye() {\n    vec3 eye1 = rotY(0.65 + sinf(1.0 * time * TAU * 0.02) * 0.5) * vec3(-3.0, 7.0, -4.0);\n    vec3 eye2 = rotY(time * 0.15) * vec3(3.0, 0.8, 2.0);\n    vec3 eye3 = vec3(sin(time * 0.2) * 4.5, 2.0, cos(time * 0.2) * 1.0);    \n    \n    float take = getTake();\n    \n    vec3 eye = mix(eye1, eye2, step(1.0, take));\n    eye = mix(eye, eye3, step(2.0, take));\n    \n    return eye;\n}\n\nfloat getFov() {\n    float take = getTake();\n    \n    float fov = mix(60.0, 90.0, step(1.0, take));\n    fov = mix(fov, 30.0, step(2.0, take));\n    \n    return fov;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n\n    \n    vec2 coord = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    float dt = 0.0;\n    float da = 0.0;\n    \n    \n    #define DS float(TAA_SAMPLES)\n    #define DDT 0.001\n    \n    for (dt = -DS*0.5*DDT; dt < DS*0.5*DDT; dt += DDT)\n    {\n        // Angle by which a sample will be offset\n        da = dt / DDT;\n\n        time = iTime + dt;\n        \n\n        // Every game needs it.\n        vec3 cameraShake = vec3(cosf(time * 3.3), sinf(time * 3.7), cosf(time * 4.3)) * 0.015 * (getFov() / 60.0);\n        // getFov() / 60.0 is just to weaken the shake for smaller FoVs\n        \n        vec3 eye = getEye() + cameraShake;\n        mat4 viewToWorld = viewMatrix(eye, vec3(0.0, -0.5, 0.0) + cameraShake, vec3(0.0, 1.0, 0.0));\n\n        // Offset the sample a bit for every sample, free AA!\n        vec2 sampleOffset = vec2(cos(da), sin(da)) * 0.4;\n\n        vec3 viewDir = rayDirection(getFov(), iResolution.xy, fragCoord.xy + sampleOffset);\n        vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n        \n        \n        DistMat hitInfo = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n        \n        // Magenta helps every time.\n        vec3 c = vec3(1.0, 0.0, 1.0);\n\n        if (hitInfo.dist < MAX_DIST)\n        {    \n            vec3 p = eye + hitInfo.dist * worldDir;\n            vec3 n = normal(p, worldDir);\n\n            c = lighting(p, n, fragCoord.xy / iResolution.xy, worldDir, hitInfo.mat);\n        }\n\n        color += c;\n    }\n    \n    \n    color /= DS;\n    \n    \n    float l = luminance(color);\n    \n#ifdef TONEMAPPING\n    l *= 4.0;\n    l /= 1.0 + l;\n    \n    // Reinhardt tonemapping\n    color /= l;\n#endif\n    \n#ifdef PP\n    // Cool hue changing vignette\n    color = pow(color, mix(vec3(1.0), vec3(1.0, 1.1, 1.25), 0.1 + length(coord - 0.5)));\n    \n    // Cool DARKNESS vignette\n    color *= mix(1.0, 0.5, pow(length(coord - 0.5), 2.0));\n    \n    // Cool grain- okay, it's just noise.\n    color += 0.1 * pow(1.0 - l, 1.5) * hash(vec3(coord, time));\n    \n    // Cool cool.\n    color = mix(color, vec3(1.0), 0.05);\n#endif\n\n    \n\tfragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}