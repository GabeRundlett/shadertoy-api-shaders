{
    "Shader": {
        "info": {
            "date": "1585467291",
            "description": "A donut.",
            "flags": 1,
            "hasliked": 0,
            "id": "tsfyWB",
            "likes": 7,
            "name": "Tom's Donut",
            "published": 3,
            "tags": [
                "sdf",
                "donuts"
            ],
            "usePreview": 0,
            "username": "tmulgrew",
            "viewed": 488
        },
        "renderpass": [
            {
                "code": "// A little SDF ray-marching \"framework\".\n// Much of the techniques are copied from IQ's demos and articles.\n\n#define AA 1\n#define ZERO (min(iFrame,0))\n// Pinched from \"Happy Jumping\"\n//#define DEBUGSTEPS\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Constants\n\nconst float tmin = 0.01;\t\t\t\t\t\t\t\t// Ray minimum distance\nconst float tmax = 15.0;\t\t\t\t\t\t\t\t\nconst int raySteps = 100;\t\t\t\t\t\t\t\t// Max iterations when resolving a ray\nconst int shadowSteps = 50;\t\t\t\t\t\t\t\t// Max iterations when resolving a shadow ray\nconst float limit = 0.0005;\t\t\t\t\t\t\t\t// Convergence to surface limit when ray tracing\nconst float screenDist = 0.5;\t\t\t\t\t\t\t// Screen distance as a fraction of screen width\nconst vec3 light = normalize(vec3(-1.0, -0.75, -0.52));\t// Light direction\nconst float ambient = 0.3;\t\t\t\t\t\t\t\t// Ambient light\nconst int bounces = 2;\t\t\t\t\t\t\t\t\t// Max reflection bounces (actually bounces + 1, as includes initial ray)\nconst int shadowBounces = 1;\t\t\t\t\t\t\t// Bounces during which shadow rays are cast.\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Data structures\n\nstruct lightingParams {\n \tfloat diffuse;\n    float specular;\n    float shiny;\n};\n\nstruct material {\n    vec3 col;\t\t\t\t\t\t\t\t\t\t\t// Surface colour\n    lightingParams lighting;\n    float reflective;\t\t\t\t\t\t\t\t\t// Reflectiveness. 0 = not reflective. 1 = completely reflective (e.g. mirror).\n};\n    \nstruct rayInfo {\n    vec3 origin;\n    vec3 dir;\n};\n    \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Functions (implemented at the bottom)\n    \n// Get camera ray for specified pixel\nrayInfo getRay(in vec2 fragCoord);\n\n// Get VR ray\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir);\n\n// Get sample point.\n// Format is vec4:\n//\tx,y\t\t= Material parameter (e.g. uv)\n//\tz\t\t= Distance to nearest surface\n//\tw\t\t= Material index (will be passed to getMaterial())\nvec4 map(in vec3 p);\n\n// Get material properties by index\nmaterial getMaterial(float index, vec2 uv, vec3 p);\n\n// Get colour for ray that misses\nvec3 getRayMissCol(in rayInfo ray);\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Trig\n\nconst float PI = 3.14159265;\n\nvec3 rotatex(in vec3 p, float a) {\n\treturn vec3(p.x,\n                cos(a) * p.y - sin(a) * p.z,\n                cos(a) * p.z + sin(a) * p.y);\n}\n\nvec3 rotatey(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotatez(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nvec3 rotate(in vec3 p, in vec3 euler) {\n \treturn rotatey(rotatex(rotatez(p, euler.z), euler.x), euler.y);   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Helper functions\n\nbool checkerboard(in vec2 p) {\n\tfloat x = mod(p.x, 2.0);\n    if (x < 0.0) x += 2.0;\n    float y = mod(p.y, 2.0);\n    if (y < 0.0) y += 2.0;\n    return (x < 1.0) == (y < 1.0);\n}\n\n// Pinched from: https://iquilezles.org/articles/smin\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Combining shapes\n//\n// Sample format is vec3:\n//\tx,y\t\t= Material parameter (e.g. texture coordinates)\n//\tz\t\t= Distance\n\n// Union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2) { \n    return p1.z < p2.z ? p1 : p2;\n}\n\n// Smoothed union of two shapes\nvec3 combine(in vec3 p1, in vec3 p2, float k) {\n    return vec3(p1.z < p2.z ? p1.xy : p2.xy, sminCubic(p1.z, p2.z, k));\n}\n\n// Subtract shape p2 from p1\nvec3 carve(in vec3 p1, in vec3 p2) { \n    return p1.z > -p2.z ? p1 : vec3(p2.xy, -p2.z);\n}\n\nvec3 carve(in vec3 p1, in vec3 p2, float k) {\n \treturn vec3(p1.z > -p2.z ? p1.xy : p2.xy, -sminCubic(-p1.z, p2.z, k));   \n}\n\n// Intersection of two shapes\nvec3 intersect(in vec3 p1, in vec3 p2) { \n    return p1.z > p2.z ? p1 : p2;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Shape primitives\n\nvec3 sphere(in vec3 p, float rad) { \n    return vec3(atan(p.x, p.y) * rad, atan(length(p.xy), p.z) * rad, length(p) - rad); \n}\nvec3 box(in vec3 p, in vec3 size) {\n    vec3 o = abs(p) - size;\t\t\t\t\t\t// Distance inside/outside each side\n    float d = max(o.x, max(o.y, o.z));   \t\t// Negative distance to nearest wall if inside box\n    if (d > 0.0) {\t\t\t\t\t\t\t\t// Refine distance if outside box\n\t    vec3 n = min(o, vec3(0));\t\t\t\t// Clamp to box boundaries to get nearest point. (Could be edge/corner).\n        d = length(o - n);\n    }\n    vec3 a = abs(o);\t\t\t\t\t\t\t// Nearest wall determines texture coordinates\n    vec2 uv = a.x < a.y && a.x < a.z ? p.yz\t\t\n    \t\t: a.y < a.z \t\t\t ? p.xz\n            :                          p.xy;\n    return vec3(uv, d);\n}\nvec3 planeBottom(in vec3 p, float y)\t\t\t\t{ return vec3(p.xz, y-p.y); }\nvec3 planeTop(in vec3 p, float y) \t\t\t\t\t{ return vec3(p.xz, p.y-y); }\nvec3 cylinder(in vec3 p, float radius, float height) { \n    vec3 tube = vec3(atan(p.x, p.z) * radius, p.y, length(p.xz) - radius);\n    vec3 top = planeTop(p, height);\n    vec3 bottom = planeBottom(p, -height);\n    return intersect(tube, intersect(top, bottom));\n}\nvec3 torus(in vec3 p, float radius, float thickness) { \n    vec2 circleOffs = vec2(length(p.xz) - radius, p.y);\n    return vec3(atan(p.x, p.z) * radius, atan(circleOffs.x, circleOffs.y) * thickness, length(circleOffs) - thickness);\n}\nvec3 line(in vec3 p, in vec3 from, in vec3 to, float thickness) {\n\t\n    vec3 d = to - from;\n    vec3 n = normalize(d);\n    float l = length(d);\n    \n    float proj = dot(p - from, n);\n    proj = clamp(proj, 0.0, l);\n    vec3 pt = from + n * proj;\n    return vec3(0, 0, length(p - pt) - thickness);    \n}\n\n// Creating and combining full sample including material index\nvec4 makes(in vec3 d, float material) {\n    // Like a distance sample, but with w = material index.\n    // Specifically:\n    //\tx,y\t= material parameter (e.g. texture coord)\n    //\tz\t= distance\n    //\tw\t= material index\n \treturn vec4(d, material);   \n}\n\nvec4 merges(in vec4 result, in vec3 d, float material) {\n \treturn d.z < result.z ? makes(d, material) : result;\n}\n\nvec4 merge(in vec4 result, in vec4 d) {\n \treturn d.z < result.z ? d : result;   \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Rendering\n\n// Calculate ray direction for a given pixel\nvec3 screenRay(in vec2 s) {\n    s -= iResolution.xy / 2.0;\n    return vec3(s / (screenDist * iResolution.x), 1);\n}\n\n// Simple lighting\nfloat shading(in vec3 e, in vec3 n, in lightingParams p) {\n    \n    // Diffuse term\n    float d = dot(n, -light) * p.diffuse;\n    \n    // Specular term\n    vec3 h = -(normalize(e) + light) / 2.0;\n    float s = pow(dot(n, h), p.shiny) * p.specular;\n\n    return max(d + s, 0.0);\n}\n\n// Calculate normal at a point\nvec3 normal(in vec3 p, float t) {\n    \n\t// Calculate pixel size at point distance. \n    // This will be the distance of the normal samples from the original point.\n    float s = 0.1 / t;\n    \n    // Sample relative distance along each axis\n    float d = map(p).z;\t\t\t// Need original distance to compare it to\n    vec3 r = vec3(\n        map(p + vec3(s,0,0)).z - d,\n        map(p + vec3(0,s,0)).z - d,\n        map(p + vec3(0,0,s)).z - d);\n    \n    return normalize(r);\n}\n\n// Cast regular ray\nvec4 raycast(in vec3 from, in vec3 dir) {\n    \n    float t = tmin;\n    vec4 d;\n    int i;\n    for (i = 0; i < raySteps && t < tmax; i++) {\n        vec3 p = from + dir * t;\n        d = map(p);\n        if (abs(d.z) <= limit * t) {\n            d.z = t;\n#ifdef DEBUGSTEPS\n            d.x = float(i) / float(raySteps);\n#endif            \n            return d;\n        }\n        t += d.z;\n    }    \n    \n    // Avoid flicker when polygons are edgewise to the camera.\n    // In this case the ray cannot quite find the surface and runs out of steps.\n    // Just return the last sample point.\n    if (t < tmax) {\n#ifdef DEBUGSTEPS\n        d.x = float(i) / float(raySteps);\n#endif            \n        d.z = t;\n        return d;\n    }\n    \n#ifdef DEBUGSTEPS\n    return vec4(float(i) / float(raySteps),0,-1.0,0);\n#else    \n    return vec4(0,0,-1.0,0);\n#endif    \n}\n\n// Cast shadow ray\nfloat shadow(in vec3 from, in vec3 dir, float k) {\n    float res = 1.0;\n    float t = tmin;    \n    for (int i = 0; i < shadowSteps && t < tmax; i++) {\n     \tvec3 p = from + dir * t;\n        float d = map(p).z;\n        if (d <= 0.0)\n            return 0.0;\n        res = min(res, k*d/t);\n        t += d;\n    }\n    \n    return res;\n}\n\nvec3 drawPixel(in rayInfo ray) {\n    ray.dir = normalize(ray.dir);\n\n    // Sum up reflection bounces    \n    vec3 sumCol = vec3(0);\n    float alpha = 1.0;\n    for (int bounce = 0; alpha > 0.0002; bounce++) {\n    \n\t    // Ray cast\n\t    vec4 r = bounce < bounces \n            ? raycast(ray.origin, ray.dir) \n            : vec4(0,0,-1,0);\t\t\t\t\t// Last ray always misses\n    \n#ifdef DEBUGSTEPS        \n        sumCol = vec3(r.x*16.0 - floor(r.x*16.0), r.x*4.0 - floor(r.x*4.0), r.x);\n        break;\n#endif        \n        \n        // Distance is returned in r.z\n\t    // Miss?\n\t    if (r.z == -1.0)\n\t    {\n            vec3 missCol = getRayMissCol(ray);\n            sumCol += missCol * alpha;\n\t        break;\n\t    }\n        \n\t    // Position and normal\n\t    vec3 p = ray.origin + r.z * ray.dir;\n\t    vec3 n = normal(p, r.z);\n\n        // Get material info\n        material mat = getMaterial(r.w, r.xy, p);\n        \n        // Apply lighting\n        float i = shading(ray.dir, n, mat.lighting);\n        if (i > 0.0 && bounce < shadowBounces) \n            i *= shadow(p, -light, 16.0);    \n        i = clamp(i + ambient, 0.0, 1.0);\n        mat.col *= i;\n\n        // Add to sum of colours\n        mat.col *= (1.0 - mat.reflective);\n        sumCol += mat.col * alpha;\n        alpha *= mat.reflective;\n        \n        // Calculate reflection vector\n        ray.origin = p;\n        ray.dir = normalize(reflect(ray.dir, n));\n    }    \n    \n    return sumCol;\n}\n\n// Main entrypoints\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if AA > 1    \n    vec3 col = vec3(0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n\t    rayInfo ray = getRay(fragCoord + vec2(m,n) / vec2(AA));\n\t    col += drawPixel(ray) / (float(AA) * float(AA));\n\t    fragColor = vec4(col, 1);\n    }\n#else    \n    rayInfo ray = getRay(fragCoord);\n    vec3 col = drawPixel(ray) / (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n#endif    \n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) \n{\n \trayInfo ray = getVRRay(fragCoord, fragRayOri, fragRayDir);\n    vec3 col = drawPixel(ray);\n    fragColor = vec4(col, 1);\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------\n\nconst vec3 camCentre = vec3(0, .4, 0);\nconst vec3 camOffs = vec3(0, 0, -3.5);\n\nrayInfo getRay(in vec2 fragCoord) {    \n\n    // Get base ray\n    rayInfo ray;\n\tray.origin = camOffs;\n    ray.dir = screenRay(fragCoord);\n    \n    // Apply camera rotation\n    float camY = iTime * .2 + 0.9;\n    float camX = sin(iTime*.1)*.35 + .6;\n    \n    //camX = (1. - iMouse.y / iResolution.y) * PI/2.;\n    //camY = iMouse.x / iResolution.x * PI*2.;\n    \n    ray.origin = camCentre + rotatey(rotatex(ray.origin, camX), camY);\n    ray.dir = rotatey(rotatex(ray.dir, camX), camY);\n    \n    return ray;\n}\n\nrayInfo getVRRay(in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir) {\n \trayInfo ray;\n    ray.origin = rotatey(fragRayOri * 40.0 + vec3(0,28,10), PI*0.5);\n    ray.dir = rotatey(fragRayDir, PI*0.5);\n    return ray;\n}\n\nvec3 getRayMissCol(in rayInfo ray) {\n\treturn texture(iChannel0, ray.dir).xyz;    \n}\n\n// Material types.\n// Returned by map(). Then passed into getMaterial() to get colour, lighting etc.\nconst float groundMat = 0.;\nconst float donutMat = 1.;\nconst float icingMat = 2.;\nconst float candyMat = 3.;\n\n// Lookup material colour etc\nmaterial getMaterial(float matType, vec2 uv, vec3 p) {\n    \n    // Set defaults\n    material mat;\n    mat.col = vec3(0.8);\n    mat.lighting.diffuse = 0.8;\n    mat.lighting.specular = 0.6;\n    mat.lighting.shiny = 64.0;\n    mat.reflective = 0.0001;\n    \n    if (matType < groundMat + 1.) {\n        int u = int(uv.x + 1000.);\n        int v = int(uv.y + 1000.);\n        if ((u & 1) == (v & 1))\n            mat.col = vec3(.3,.3,.4);\n       \telse\n            mat.col = vec3(0,.025,.1);\n        mat.reflective = 0.1;\n    }\n    else if (matType < donutMat + 1.) {\n        mat.col = vec3(1,.6,.3) * .8;\n    }\n    else if (matType < icingMat + 1.) {\n     \tmat.col = vec3(.9,.8,1);\n        mat.reflective = 0.02;\n    }\n    else if (matType < candyMat + 1.) {\n\t\tfloat f = fract(matType) * 2.*PI * 3.;\n        mat.col = min(vec3(sin(f), sin(f+.666*PI), sin(f+1.333*PI)) * 1.5 + vec3(.6), vec3(1));\n        mat.reflective = 0.075;\n    }\n    \n    return mat;\n}\n\nvec4 donut(in vec3 p) {\n    p.y-=.45;\n    float ang = atan(p.x, p.z);\n    float d = length(p.xz);\n\n\t// Base    \n    vec3 base = torus(p, 1., .45);\n\n    // Icing\n    vec3 icingTorus = torus(p, 1., .48);\n    float waveFactor = (d > 1. ? 1. : .5);\n    float wave = sin(ang * 12. * waveFactor) * .062 \n               + sin(ang * 34. * waveFactor + .7) * 0.027\n               + sin(ang * 42. * waveFactor + 1.7) * 0.015;\n        \n    vec3 icingWave = vec3(0, 0, p.y - (wave + .03));    \n    vec3 icing = carve(icingTorus, icingWave, .2);\n    \n    // Candy\n    const float candySpacing = 2.*PI / 11.;\n    float candyAng = round(ang / candySpacing) * candySpacing;\n    \n    vec3 candyPos = vec3(sin(candyAng), .51, cos(candyAng)) * 1.;\n    vec3 candyp = p - candyPos;\n    candyp.y *= 3.;\n    vec3 candyShape = sphere(candyp, 0.15);\n    candyShape.z /= 3.;\n    vec4 candy = makes(candyShape, candyMat + fract(candyAng/(2.*PI)));\n    \n    \n    // Candy icing indentation\n    vec3 indentPos = candyPos + vec3(sin(candyAng * 7.)*.01,0,sin(candyAng * 11.)*.01);\n    indentPos.y -= 0.1;\n    vec3 indentp = p - indentPos;\n    indentp.y *= 2.5;\n    vec3 icingIndent = sphere(indentp, 0.2);\n    icingIndent.z /= 2.5;\n    icing = combine(icing, icingIndent, .07);\n    icing = carve(icing, candyShape, 0.05);\n\n    // Table surface objects\n    p.y += .45;\n\n    // Fallen candy\n    vec3 fallCandyp = p - vec3(-.5, 0.05, 1.6);\n    fallCandyp.y *= 3.;\n    vec3 fallCandy = sphere(fallCandyp, 0.15);\n    fallCandy.z /= 3.;\n    \n    // Icing blobs\n    p.y *= 2.;\n    vec3 blob1 = sphere(p - vec3(1.5, 0, 0), 0.25);\n    vec3 blob2 = sphere(p - vec3(1.7,0,.45), 0.175);\n    vec3 blob3 = sphere(p - vec3(1.9,0,-.35), 0.1);\n    vec3 blob = combine(combine(blob1, blob2, .5), blob3);\n    blob.z /= 2.;\n   \n    vec4 r = makes(base, donutMat);\n    r = merges(r, icing, icingMat);\n    if (candyAng != 0.) r = merge(r, candy);\n    r = merges(r, blob, icingMat);\n    r = merges(r, fallCandy, candyMat + 0.0);\n\treturn r;    \n}\n\n\nvec4 map(in vec3 p) {\t\n    \n    // Find signed distance sample\n    // x,y = uv\n    // z   = distance\n    // w   = material\n    vec4 r;\n    \n    // Ground plane\n    vec3 ground = cylinder(p - vec3(0, -.05, 0), 5., .05);\n    r = makes(ground, groundMat);\n    \n    vec4 dn = donut(p);\n    r = merge(r, dn);\n    \n    return r;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}