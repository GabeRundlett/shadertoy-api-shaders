{
    "Shader": {
        "info": {
            "date": "1648137195",
            "description": "parte dos del parcial ATI",
            "flags": 32,
            "hasliked": 0,
            "id": "stscDM",
            "likes": 0,
            "name": "Parciel 2",
            "published": 3,
            "tags": [
                "ati"
            ],
            "usePreview": 0,
            "username": "arostaky",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 buf1 = texture(iChannel0,uv).rgb; \n    vec3 buf2 = texture(iChannel1,uv+vec2(-0.1,0.0)).rgb; \n  //  vec3 buf3 = texture(iChannel0,uv+vec2(0.0,0.1)).rgb;\n  //  vec3 buf4 = texture(iChannel0,uv+vec2(0.0,-0.1)).rgb;\n    vec3 col = buf1;\n    col*= -10.0;\n    col+= 0.2;\n    // Output to screen\n    col *= 4.7;\n    col += 10.;\n    fragColor = vec4(col,1.);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sub(float d1, float d2){\n\n    return max(-d1, d2);\n    \n}\n\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nmat2 rot (float a) { \n\n    float c=cos(a),s=sin(a); return mat2(c,-s,s,c); \n\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n      vec3 q = abs(p) - b;\n      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n      vec3 pa = p - a, ba = b - a;\n      float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      return length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r ){\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\nvec2 opU2(vec2 d1, vec2 d2){\n\n     return (d1.x <d2.x)? d1 : d2;\n\n}\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 opRep(vec3 p , vec3 c){\n\n    return mod(p+0.5*c,c)-0.5*c;\n\n}\n\nvec2 map(vec3 pos){\n    \n    float v = 0.0;\n    \n    pos.xz *= rot(sin(iTime*1.1));\n    pos.yz *= rot(cos(iTime*1.1));\n    pos = opRep(pos, vec3(9.1, 10.1, 40.1));\n    //pos.yz *= rot(.01+sin(iTime*1.1));\n    //v = sdSphere(pos, 1.0);\n    \n  //  vec2 c = vec2(sdRoundCone(pos,vec3(2.0),vec3(1.1),0.1,0.5),0.5);\n   // c *= rot(3.14/4.0);\n    //pos.yz = rot(0.1);\n    vec2 a = vec2(sdBox(vec3(pos.x+1.,pos.y,pos.z),vec3(1.,.1,3.)),1.);\n    vec2 b = vec2(sdBox(vec3(pos.x+1.,pos.y-.5,pos.z),vec3(1.,.1,3.)),1.);\n    //b *= rot(.001);\n    vec2 a2 = vec2(sdBox(vec3(pos.x-3.,pos.y,pos.z),vec3(.5,.1,1.5)),1.);\n    //vec2 b2 = vec2(sdBox(vec3(pos.x-3.,pos.y-.5,pos.z),vec3(.5,.1,1.5)),1.);\n    vec2 e = vec2(sdBox(vec3(pos.x-3.,pos.y-.5,pos.z),vec3(.5,1.,.01)),1.);\n    \n    \n    vec2 c = vec2(sdBox(vec3(pos.x,pos.y+.2,pos.z),vec3(4,.4,.4)),1.);\n    \n    \n    vec2 engine = vec2(sdBox(vec3(pos.x+1.,pos.y-.9,pos.z),vec3(1,.4,.4)),1.);\n    vec2 engine2 = vec2(sdBox(vec3(pos.x+2.,pos.y-.9,pos.z),vec3(.1,1.,.1)),1.);\n    \n    \n   // vec2 box4 = vec2(sdCapsule(pos,vec3(0.7),vec3(0.2),.5));\n    vec2 alas = opU2(a,b);\n    vec2 alas_back = opU2(a2,e);\n    //vec2 alas_back2 = opU2(alas_back, e);\n    vec2 alas_total = opU2(alas,alas_back);\n    //vec2 engine_total  = opU2(engine, engine2);\n    vec2 alas_engine = opU2(engine,alas_total);\n    vec2 cuerpo = opU2(alas_engine,c);\n    \n    return cuerpo;\n}\n\n\nvec3 GetNormal (vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x\n        ) - v);\n}\n\n\nvec2 CastRay(vec3 ro, vec3 rd) \n{\n    float contact = 0.0;\n    \n    for(int marche = 0; marche < 64 ; marche++)\n    {\n        vec2 ray = map(ro + rd * contact);\n        \n        if(ray.x < (0.0001*contact))\n        {\n           return vec2(contact,ray.y);\n        }\n        \n        contact += ray.x;\n    }\n\n    return vec2(-1.0,0.0);\n}\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec2 contact = CastRay(ro, rd);\n    \n    vec3 col;\n    \n    if(contact.x == -1.0)\n    {\n        col = vec3(0.0,sin(iTime*0.1),cos(iTime*0.1));\n    }\n    else\n    {\n        if(contact.y==0.0){\n            col =vec3(1.0,1.5+sin(iTime*.1),1.0);\n            vec3 nor = GetNormal(ro + rd * contact.x);\n            \n            //col = nor;\n        }\n        else{\n        \n            \n            col = vec3(0.9,1.5,1.5);\n        \n        }\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = 0.0;iTime * .5;\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 50.0+sin(t));\n    vec3 cameraTar = vec3(2.0, 2.0, 0.0-t);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n    \n    \n    float p_angle = atan(uv.x, uv.y*0.5);\n    float p_distance = length(uv)*2.0;\n    \n    vec2 st = vec2(p_distance, p_angle);\n    st.y += sin(iTime);\n    float depth = min(st.x*.7,1.0);\n    vec3 col = render(cameraPos, viewDir);\n    col += texture(iChannel0, vec2(1.0 / st.x, st.y)).rgb;\n    //col *=100.;\n    //col *= depth;\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = 2.0  * fragCoord/iResolution.xy -1.0;\n   uv.x *= iResolution.x/iResolution.y; \n   float p_angle = atan(uv.x, uv.y*0.5);\n   float p_distance = length(uv)*2.0;\n   vec2 st = vec2(p_distance, p_angle);\n   st.y += sin(iTime);\n   \n   float depth = min(st.x*.7,1.0);\n   vec3 col  = texture(iChannel0, vec2(1.0 / st.x + iTime, st.y)).rgb+cos(iTime*2.1);\n   col *= depth;\n   fragColor = vec4(col, 1.0);\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}