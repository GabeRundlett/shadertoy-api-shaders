{
    "Shader": {
        "info": {
            "date": "1603951004",
            "description": "Babylon 5\nNot finished, but I haven't had time to work on it for a long time, so I decided to publish it.",
            "flags": 96,
            "hasliked": 0,
            "id": "Wtd3R2",
            "likes": 10,
            "name": "Babylon 5",
            "published": 3,
            "tags": [
                "raymarch",
                "b5"
            ],
            "usePreview": 0,
            "username": "hubbe",
            "viewed": 396
        },
        "renderpass": [
            {
                "code": "#define R 0.08\n#define CUTR (R/8.0)\n\nconst float pi = 3.1415926535;\n\n\nmat3 rotz(float f) {\n    return mat3(cos(f), sin(f), 0,\n                -sin(f), cos(f), 0,\n                0,0,1);\n}\nmat3 roty(float f) {\n    return mat3(cos(f), 0, sin(f),\n                0,1,0,\n                -sin(f), 0, cos(f));\n}\nmat3 rotx(float f) {\n    return mat3(1,0,0,\n                0, cos(f), sin(f),\n                0, -sin(f), cos(f));\n}\nmat3 scale(float x, float y, float z) {\n    return mat3(x,0,0,\n                0,y,0,\n                0,0,z);\n}\n\nvec3 R4YZ(vec3 p) {\n//    p *= rotx(3.1415);\n    p.z = abs(p.z);\n    p.y = abs(p.y);\n    return p;\n}\n\n\nvec3 R8YZ(vec3 p) {\n    p = R4YZ(p);\n    if (p.y < p.z) {\n        return p.xyz;\n    } else {\n        return p.xzy;\n    }\n\n}\n\nvec3 R4XZ(vec3 p) {\n//    p *= rotx(3.1415);\n//    p.z = abs(p.z);\n//    p.x = abs(p.x);\n    if (p.x < 0.0) p.x = - p.x;\n//    if (p.y > 0.0) p.y = - p.y;\n    if (p.z > 0.0) p.z = - p.z;\n    return p;\n}\n\n\nvec3 R8XZ(vec3 p) {\n    p = R4XZ(p);\n    if (-p.x < p.z) {\n        return p.xyz;\n    } else {\n        return p.zyx;\n    }\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPanelHeight = 0.38;\n\nfloat sdPanelOneEdge(vec3 p) {\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    p.y -= sdPanelHeight;\n    p.x = mod(p.x, 0.2) - 0.1;\n    p.x = abs(p.x);\n    float p1 = sdPlane(p, normalize(vec4( 8,1,0,-0.5)));\n    float p3 = sdPlane(p, normalize(vec4( 2,-1,0,-0.4)));\n    float p2 = abs(p.y) -0.3; // max(-0.3 - p.y, p.y - 0.3);\n//    p.y = abs(p.y);\n//    float p2 = 0.0;\n//    float p2 = min(p.y, 0.3) - p.y;\n    return max(p1, max(p2, p3));\n//    return max(p1, p3);\n}\n\nfloat sdPanelOne(vec3 x) {\n    vec3 p = x;\n    p.y -= sdPanelHeight;\n    p.x = mod(p.x, 0.2) - 0.1;\n    p.x = abs(p.x);\n    float b =  sdBox(p - vec3(0,0,0.3), vec3(0.3,0.3,0.005));\n    float p1 = sdPanelOneEdge(x);\n    return max(b, p1);\n}\n\n\nfloat sdPanel(vec3 p) {    \n    float dist = sdPanelOne(vec3(p.x, abs(p.y), abs(p.z)));\n    float box1 = sdBox(p + vec3(1.5,0,0), vec3(0.3, 0.8, 0.31));\n    dist = max(dist, box1);\n//    float box2 = sdBox(p + vec3(1.5, 0.0, 0.4), vec3(0.1, 0.8, 0.31));\n//    dist = min(dist, box2);\n    return dist;\n}\n\nfloat sdSphere( vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTriPrism( vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h) {\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat storage(vec3 p) {\n    p -= vec3(-0.83, 0.25, -0.02);\n    p.z = abs(p.z);\n    float d = sdHexPrism(p.zyx, vec2(0.04, 0.35));\n    p -= vec3(0, 0.08, 0);\n    p.x = mod(p.x, 0.12) - 0.06;\n    float b = sdBox(p, vec3(0.05, 0.1, 0.1));\n    return max(d, b);\n}\n\nfloat topSection(vec3 p) {\n    float s = sdBox(p - vec3(0.31,0.15,0), vec3(0.03,0.1,0.1));\n    \n    p.z = -abs(p.z);\n    vec3 pos = vec3(0.3,0.25,0.0);\n//    float a = sdBox(rotx(0.3) * (p - pos), vec3(0.5,0.05,0.3));\n//    float c = sdBox(rotx(-0.3) * (p - pos), vec3(0.5,0.05,0.3));\n    float b = sdBox(p - pos, vec3(0.5,0.031,0.13));\n    float c = sdBox(p - pos - vec3(0.5,0,0), vec3(0.5,0.13,0.027));\n    float p1 = sdPlane(p - pos, normalize(vec4( -1, -12,0,0.2)));\n    float p2 = sdPlane(p - pos, normalize(vec4( -1, -3, 8, 0.8)));\n    float p3 = sdPlane(p - pos, normalize(vec4( -1, -12, 2, 0.25)));\n    \n    float p4 = sdPlane(p - pos, normalize(vec4( 1, 0, 1.5, 0.25)));\n    float p5 = sdPlane(p - pos, normalize(vec4( 1, 5, 0, 0.25)));\n\n//    return max(a, max(b, c));\n    b=max(b, -c);\n    b=max(b, -p1);\n    b=max(b, -p2);\n    b=max(b, -p3);\n    b=max(b, -p4);\n    b=max(b, -p5);\n    b = min(b, s);\n    \n    b = min(b, storage(p));\n    float x = sdBox(p - pos - vec3(-1.2,0,0), vec3(0.6, 0.010, 0.027));\n    b = min(b, x);\n    \n    \n    vec3 pos2 = vec3(-0.1,0.25,0.0);\n    float q = sdBox(p - pos2, vec3(0.22, 0.035, 0.082));\n    float q1 = sdPlane(p - pos, normalize(vec4(1,3,0,0.5 )));\n    float q2 = sdPlane(p - pos, normalize(vec4(-1,3,0,-0.2 )));\n    float q3 = sdPlane(p - pos, normalize(vec4(-1,-8,0,-0.05 )));\n    float q4 = sdPlane(p - pos, normalize(vec4(0,1,1,0.07 )));\n    float q5 = sdPlane(p - pos, normalize(vec4(0,-1,1,0.1 )));\n    q = max(q, -q1);\n    q = max(q, -q2);\n    q = max(q, -q3);\n    q = max(q, -q4);\n    q = max(q, -q5);\n    b = min(b, q);\n    \n    return b;\n}\n\nfloat hand(vec3 p) {\n    p.z = abs(p.z);\n    float dist = sdBox(p + vec3(0.1, 0.042, 0), vec3(0.13, 0.05, 0.04));\n//    float \n//    dist = max(dist, - sdBox(p + vec3(0.1, 0.042, 0), vec3(0.13, 0.05, 0.04)));\n\n    dist = max(dist,sdPlane(p, normalize(vec4(-1,2,0,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(1,3,0,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(0,3,1,  -0.04 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(1,0,1.5,  -0.06 ))));\n    dist = max(dist,sdPlane(p, normalize(vec4(-1,0,8,  -0.35 ))));\n//    dist = max(dist,sdPlane(p, normalize(vec4(0,3,-1,  -0.04 ))));\n        float cut = sdBox(p + vec3(-0.05, 0, 0), vec3(0.04, 0.05, 0.008));\n    dist = max(dist, -cut);\n\n    return dist;\n}\n\nfloat rotating_gray(vec3 p) {\n    p *= rotx(iTime * pi * 2.0 / 45.0);\n    float dist = 100000.0;\n    \n    dist = min(dist, hand((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0)));\n  return dist;\n}\n\nfloat rotating_section(vec3 p) {\n    p *= rotx(iTime * pi * 2.0 / 45.0);\n    float dist = 100000.0;\n    \n    dist = min(dist, sdBox((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(-0.1,0.13,0.0), vec3(0.1, 0.01, 0.03)));\n    dist = min(dist, hand((R4XZ(p.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0)));\n    \n    // Rotating section...\n    dist = min(dist, sdSphere(p - vec3(0.08,0.0,0.0), 0.18));\n    dist = min(dist, sdCappedCylinder(p.yxz - vec3(0,0.05,0), 0.11, 0.3));\n\n    // main barrel\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,0.95,0), 0.18/2.0, 0.09, 0.75));\n    \n    // Main barrel segments\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,0.35,0), 0.22/2.0, 0.04, 0.10));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.025,0), 0.20/2.0, 0.04, 0.07));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.7,0), 0.22/2.0, 0.04, 0.10));\n    \n//    dist = min(dist, sdBox(p.yxz * roty(-3.1516/8.0) + vec3(0,1.025,0), vec3(0.19, 0.7, 0.01)));\n    dist = min(dist, sdBox(R8XZ(p.yxz) * roty(-pi/8.0) + vec3(0,1.025,0), vec3(0.19, 0.7, 0.01)));\n\n  return dist;    \n}\n\nfloat fingers(vec3 p) {\n    p += vec3(1.5, 0.0, 0.3);\n    p.y = abs(p.y);\n    float dist = sdBox(p, vec3(0.4,0.03,0.015));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.0,0.1,-0.15,-0.004))));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.0,-0.4,-0.012))));\n//    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.1,-0.4,-0.012))));\n    dist = max(dist, sdPlane(p, normalize(vec4(0.03,0.25,-0.15,-0.016))));\n\n    return dist;\n}\n\nfloat end_section(vec3 p) {\n    float dist = 10000.0;\n    // X\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi*3.0/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    dist = min(dist, sdBox(R4XZ(p.yxz) * roty(-pi*5.0/12.0) + vec3(0,1.65,0), vec3(0.1, 0.7, 0.01)));\n    \n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.7,0), 0.08/2.0, 0.01, 0.7));\n    \n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,2.4,0), 0.14/2.0, 0.05, 0.01));\n\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,1.8,0), 0.06/2.0, 0.01, 1.0));\n    dist = min(dist, sdRoundedCylinder(p.yxz + vec3(0,2.8,0), 0.12/2.0, 0.01, 0.05));\n    dist = min(dist, fingers(p));\n    return dist;\n}\n\nvec3 dorot(vec3 p) {\n    p = p  * roty(-0.4) * rotx(-pi/8.0);\n    p += vec3(-1,0,0);\n    return p;\n}\n\n// Return actual distance, step\nvec2 map(vec3 p) {\n    // p = vec3(p.x, -p.z, p.y);\n    // Top view\n    //p = p  * roty(0.2) * rotx(-pi/2.0);\n    // view\n    p = dorot(p);\n    \n    float dist = 10000.0;\n    \n    dist = min(dist, sdPanel(p));\n    dist = min(dist, topSection(p));\n    dist = min(dist, rotating_section(p));\n    dist = min(dist, end_section(p));\n    return vec2(dist);\n}\n\nvec4 Color(vec3 hp, vec3 ray_dir) {\n    vec4 c;\n        hp = dorot(hp);\n\n    float panel_dist = sdPanel(hp);\n\tfloat top_section_dist = topSection(hp);\n    float rotating_dist = rotating_section(hp);\n    float storage_dist = storage(hp);\n    \n    if (storage_dist+0.0001 >= top_section_dist &&\n        panel_dist > storage_dist &&\n        rotating_dist > storage_dist) {\n        float x = mod(hp.x + 0.83, 0.12) - 0.06;\n        if (abs(x) < 0.04) return vec4(1,0,0,1);\n        return vec4(0.8, 0.8, 0.8,1);\n    }\n    \n    if (panel_dist < rotating_dist && panel_dist < rotating_dist) {\n       float poe = sdPanelOneEdge(hp);\n        if (poe < -0.01) {\n           vec2 tpos = vec2(dot(hp, 8.0*vec3(0.1,1,0.5)), 8.0 * dot(hp, vec3(1,0.1,0.2)));\n           c = texture(iChannel3, tpos) * mat4(0.2,0,0,0, 0,0.2,0,0, 0.5,0.5,0.8,0, 0,0,0,1);\n           return c;\n        }\n    }\n    \n    if (rotating_dist < panel_dist && rotating_dist < top_section_dist) {\n      hp *= rotx(iTime * pi * 2.0 / 45.0);\n        \n        \n        bool blue = false;\n        if (hp.x > -0.02 && hp.x < 0.18) {\n            int ring = int( (hp.x - 0.08 + (0.2/3.0)) / (0.1/3.0) );\n            int slice = int(50.0 + atan(hp.y,hp.z)*16.0/pi);\n            if ((ring + slice) % 2 == 0 || ring < 1 || ring > 2) {\n                blue = true;\n            }\n        }\n        if (hp.x > -0.21 && hp.x < -0.14) {\n            \tblue = true;\n        }\n        if (hp.x > -0.3 && hp.x < -0.24) {\n            \tblue = true;\n        }\n        if (hp.x > -1.1 && hp.x < -0.945) {\n            \tblue = true;\n        }\n        if (mod(atan(hp.y, hp.z) * 4.0 / pi + 24.0, 1.0) < 0.05) {\n            blue=false;\n        }\n\n        if (blue) {\n            float hand_dist = hand((R4XZ(hp.yxz) * roty(-pi / 4.0)).yxz - vec3(0.08,0.19,0.0));\n            if (rotating_dist != hand_dist) {\n \n              vec2 tpos = vec2(dot(hp, vec3(0.1,1,0.5)), dot(hp, vec3(1,0.1,0.2)));\n  \t       \t    c = texture(iChannel0, tpos) * mat4(0.4,0,0,0, 0,0.4,0,0, 0.3,0.3,0.5,0, 0,0,0,1);\n              return c;\n            }\n        }\n    }\n    \n    vec2 tpos = vec2(dot(hp, vec3(0.1,1,0.5)), dot(hp, vec3(1,0.1,0.2)));\n    c = texture(iChannel0, tpos);\n    return c;\n}\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n        float step_size = hit ? tmp.x : tmp.y;\n\n        if (distance_to_closest_object < 0.001) {\n        \tif (distance_to_closest_object < 0.0) {\n                // We are inside of an object. Go back to the\n                // previous position and stop using tangent distances\n                // so that we can find the surface.\n            \thit = true;\n          \t    travel_distance = last_travel_distance;\n           \t    continue;\n            }\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += step_size;\n    }\n    // We hit something, but then we ran out of iterations while\n    // finding the surface.\n    #if 1\n    return travel_distance;\n        #else\n    if (hit) return travel_distance;\n    // We walked 50 steps without hitting anything.\n    return 0.0;\n    #endif\n}\n\n\nvec3 norm(vec3 pos) {\n    float d = 0.0001;\n    float dist = map(pos).x;\n    return normalize(vec3(map(pos + vec3(d,0,0)).x - dist,\n                          map(pos + vec3(0,d,0)).x - dist,\n                          map(pos + vec3(0,0,d)).x - dist));\n}\n\nfloat shade(vec3 from, vec3 light_pos) {\n    vec3 direction = light_pos - from;\n    float d2 = dot(direction, direction);\n    float dist = sqrt(d2);\n    direction /= dist;\n    \n    float small_step = 0.0005;\n    float dist_from_surface = map(from).x;\n    float dist_closer_to_light = map(from + small_step * direction).x;\n\n    float shading = max(0.0, (dist_closer_to_light - dist_from_surface) / small_step);\n//    float shading = max(0.0, (dist_from_surface - dist_closer_to_light) / small_step);\n    shading += 0.1;\n    shading = min(1.0, shading);\n    \n    float travel_distance = 0.01;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        vec2 tmp = map(position);\n\t    float distance_to_closest_object = tmp.x;\n\n        if (travel_distance >= dist) {\n            break;\n        }\n        if (distance_to_closest_object < 0.001) {\n            return 0.0;\n        }\n        \n        shading = min(shading, 10.0 * distance_to_closest_object / travel_distance);\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += tmp.y;\n\n    }\n    shading = shading / (1.0 + d2 * 0.2);\n    \n    return shading;\n}\n\nvoid planet(out vec4 O,vec2 I)\n{\n    vec4 bg = texture(iChannel2, I / iResolution.xy);\n//    O = bg;    return ;\n    vec2 P =(( I / iResolution.x)/0.8+vec2(-0.9, 0.5)) / 1.0;\n    vec3 RR = vec3(P,sqrt(max(1.-dot(P,P),0.)));\n\tO = mix(\n        texture(iChannel1, .001*iTime+.3*RR.xy/sqrt(RR.z))*max(RR.x*.3+RR.y*.9+RR.z*.1+.5,.1),\n            vec4(.6,.4,.3,1)/dot(P,P*.5),pow(1.-RR.z,2.));\n    if (RR.z == 0.0)\n      O = mix(O, bg, min(1.0, max(0.0, pow((dot(P,P)-1.0),0.2))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -3.5);\n    vec3 light_position = vec3(1.1, 1.1, 1.1);\n\n    // Animate\n  // camera_position.z += iTime/2.0 + iTime * iTime / 200.0;\n // camera_position.x += iTime/2.0;\n\n   light_position += camera_position;\n //   camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 0.9;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance > 50.0) {\n        planet(fragColor, fragCoord);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n    \n    \n    float sunlight = shade(hit_position, light_position);\n\n      fragColor = Color(hit_position, ray_direction);\n     vec3 light_dir = normalize(light_position - hit_position);\n    vec3 normal = norm(hit_position);    \n    vec3 reflection = reflect(ray_direction, normal);\n    float l2 = max(dot(reflection, light_dir), 0.0);\n    float spec = pow(l2, 4.0) * 0.3;\n    \n    fragColor = pow(fragColor * sunlight + vec4(1,1,1,0) * spec, vec4(1.0/2.2));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////\n// Xavier Benech\n// Galaxy Trip\n// Inspired by \"Star Tunnel\" shader from P_Malin\n// https://www.shadertoy.com/view/MdlXWr\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n\n// Increase pass count for a denser effect\n#define PASS_COUNT 4\n\nfloat fBrightness = 2.5;\n\n// Number of angular segments\nfloat fSteps = 121.0;\n\nfloat fParticleSize = 0.015;\nfloat fParticleLength = 0.5 / 60.0;\n\n// Min and Max star position radius. Min must be present to prevent stars too near camera\nfloat fMinDist = 0.8;\nfloat fMaxDist = 5.0;\n\nfloat fRepeatMin = 1.0;\nfloat fRepeatMax = 2.0;\n\n// fog density\nfloat fDepthFade = 0.8;\n\nfloat Random(float x)\n{\n\treturn fract(sin(x * 123.456) * 23.4567 + sin(x * 345.678) * 45.6789 + sin(x * 456.789) * 56.789);\n}\n\nvec3 GetParticleColour( const in vec3 vParticlePos, const in float fParticleSize, const in vec3 vRayDir )\n{\t\t\n\tvec2 vNormDir = normalize(vRayDir.xy);\n\tfloat d1 = dot(vParticlePos.xy, vNormDir.xy) / length(vRayDir.xy);\n\tvec3 vClosest2d = vRayDir * d1;\n\t\n\tvec3 vClampedPos = vParticlePos;\n\t\n\tvClampedPos.z = clamp(vClosest2d.z, vParticlePos.z - fParticleLength, vParticlePos.z + fParticleLength);\n\t\n\tfloat d = dot(vClampedPos, vRayDir);\n\t\n\tvec3 vClosestPos = vRayDir * d;\n\t\n\tvec3 vDeltaPos = vClampedPos - vClosestPos;\t\n\t\t\n\tfloat fClosestDist = length(vDeltaPos) / fParticleSize;\n\tfloat fShade = clamp(1.0 - fClosestDist, 0.0, 1.0);\n\t\n\tif (d<3.0)\n\t{\n\t\tfClosestDist = max(abs(vDeltaPos.x),abs(vDeltaPos.y)) / fParticleSize;\n\t\tfloat f = clamp(1.0 - 0.8*fClosestDist, 0.0, 1.0);\n\t\tfShade += f*f*f*f;\n\t\tfShade *= fShade;\n\t}\n\t\n\tfShade = fShade * exp2(-d * fDepthFade) * fBrightness;\n\treturn vec3(fShade);\n}\n\nvec3 GetParticlePos( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\n\tfloat fAngle = atan(vRayDir.x, vRayDir.y);\n\tfloat fAngleFraction = fract(fAngle / (3.14 * 2.0));\n\t\n\tfloat fSegment = floor(fAngleFraction * fSteps + fSeed) + 0.5 - fSeed;\n\tfloat fParticleAngle = fSegment / fSteps * (3.14 * 2.0);\n\n\tfloat fSegmentPos = fSegment / fSteps;\n\tfloat fRadius = fMinDist + Random(fSegmentPos + fSeed) * (fMaxDist - fMinDist);\n\t\n\tfloat tunnelZ = vRayDir.z / length(vRayDir.xy / fRadius);\n\t\n\ttunnelZ += fZPos;\n\t\n\tfloat fRepeat = fRepeatMin + Random(fSegmentPos + 0.1 + fSeed) * (fRepeatMax - fRepeatMin);\n\t\n\tfloat fParticleZ = (ceil(tunnelZ / fRepeat) - 0.5) * fRepeat - fZPos;\n\t\n\treturn vec3( sin(fParticleAngle) * fRadius, cos(fParticleAngle) * fRadius, fParticleZ );\n}\n\nvec3 Starfield( const in vec3 vRayDir, const in float fZPos, const in float fSeed )\n{\t\n\tvec3 vParticlePos = GetParticlePos(vRayDir, fZPos, fSeed);\n\t\n\treturn GetParticleColour(vParticlePos, fParticleSize, vRayDir);\t\n}\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle); float c = cos(fAngle);\n    return vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n}\n\n// Simplex Noise by IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( in vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat marble(in vec2 p)\n{\n\treturn cos(p.x+fbm4(p));\n}\n\nfloat dowarp ( in vec2 q, out vec2 a, out vec2 b )\n{\n\tfloat ang=0.;\n\tang = 1.2345 * sin (33.33); //0.015*iTime);\n\tmat2 m1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 0.2345 * sin (66.66); //0.021*iTime);\n\tmat2 m2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\ta = vec2( marble(m1*q), marble(m2*q+vec2(1.12,0.654)) );\n\n\tang = 0.543 * cos (13.33); //0.011*iTime);\n\tm1 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\tang = 1.128 * cos (53.33); //0.018*iTime);\n\tm2 = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n\n\tb = vec2( marble( m2*(q + a)), marble( m1*(q + a) ) );\n\t\n\treturn marble( q + b +vec2(0.32,1.654));\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y *= iResolution.y/iResolution.x;\n\tfloat T = 180.0;\n\t// camera\t\n\tvec3 rd = normalize(vec3( q.x, q.y, 1. ));\n\tvec3 euler = vec3(\n\t\tsin(T * 0.2) * 0.625,\n\t\tcos(T * 0.1) * 0.625,\n\t\tT * 0.1 + sin(T * 0.3) * 0.5);\n\n\tif(iMouse.z > 0.0)\n\t{\n\t\teuler.x = -((iMouse.y / iResolution.y) * 2.0 - 1.0);\n\t\teuler.y = -((iMouse.x / iResolution.x) * 2.0 - 1.0);\n\t\teuler.z = 0.0;\n\t}\n\trd = RotateX(rd, euler.x);\n\trd = RotateY(rd, euler.y);\n\trd = RotateZ(rd, euler.z);\n\t\n\t// Nebulae Background\n\tfloat pi = 3.141592654;\n\tq.x = 0.5 + atan(rd.z, rd.x)/(2.*pi);\n\tq.y = 0.5 - asin(rd.y)/pi + 0.512 + 0.001*iTime;\n\tq *= 2.34;\n\t\n\tvec2 wa = vec2(0.);\n\tvec2 wb = vec2(0.);\n\tfloat f = dowarp(q, wa, wb);\n\tf = 0.5+0.5*f;\n\t\n\tvec3 col = vec3(f);\n\tfloat wc = 0.;\n\twc = f;\n\tcol = vec3(wc, wc*wc, wc*wc*wc);\n\twc = abs(wa.x);\n\tcol -= vec3(wc*wc, wc, wc*wc*wc);\n\twc = abs(wb.x);\n\tcol += vec3(wc*wc*wc, wc*wc, wc);\n\tcol *= 0.7;\n\tcol.x = pow(col.x, 2.18);\n\tcol.z = pow(col.z, 1.88);\n\tcol = smoothstep(0., 1., col);\n\tcol = 0.5 - (1.4*col-0.7)*(1.4*col-0.7);\n\tcol = 0.75*sqrt(col);\n\tcol *= 1. - 0.5*fbm4(8.*q);\n\tcol = clamp(col, 0., 1.);\n\t\n\t// StarField\n\tfloat fShade = 0.0;\n\tfloat a = 0.2;\n\tfloat b = 10.0;\n\tfloat c = 1.0;\n\tfloat fZPos = 5.0;// + iTime * c + sin(iTime * a) * b;\n\tfloat fSpeed = 0.; //c + a * b * cos(a * iTime);\n\t\n\tfParticleLength = 0.25 * fSpeed / 60.0;\n\t\n\tfloat fSeed = 0.0;\n\t\n\tvec3 vResult = vec3(0.);\n\t\n\tvec3 red = vec3(0.7,0.4,0.3);\n\tvec3 blue = vec3(0.3,0.4,0.7);\n\tvec3 tint = vec3(0.);\n\tfloat ti = 1./float(PASS_COUNT-1);\n\tfloat t = 0.;\n\tfor(int i=0; i<PASS_COUNT; i++)\n\t{\n\t\ttint = mix(red,blue,t);\n\t\tvResult += 1.1*tint*Starfield(rd, fZPos, fSeed);\n\t\tt += ti;\n\t\tfSeed += 1.234;\n\t\trd = RotateX(rd, 0.25*euler.x);\n\t}\n\t\n\tcol += sqrt(vResult);\n\t\n\t// Vignetting\n\t//vec2 r = -1.0 + 2.0*(uv);\n\t//float vb = max(abs(r.x), abs(r.y));\n\t//col *= (0.15 + 0.85*(1.0-exp(-(1.0-vb)*30.0)));\n\tfragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 21480,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/nailz1911/babylon-5-intro-theme"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}