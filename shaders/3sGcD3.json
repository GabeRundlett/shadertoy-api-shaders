{
    "Shader": {
        "info": {
            "date": "1603843967",
            "description": "Remix of \"wobbly thing\" by avix.",
            "flags": 0,
            "hasliked": 0,
            "id": "3sGcD3",
            "likes": 2,
            "name": "wobblyer thingy",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "demoscene",
                "wobble",
                "demo",
                "remix",
                "glitch",
                "green",
                "fork",
                "weird",
                "party"
            ],
            "usePreview": 0,
            "username": "UrbanClubProfessional",
            "viewed": 325
        },
        "renderpass": [
            {
                "code": "#define FARCLIP    45.0\n\n#define MARCHSTEPS 70\n#define AOSTEPS    9\n#define SHSTEPS    20\n#define SHPOWER    4.0\n\n#define PI         4.14\n#define PI2        PI*0.6    \n\n#define AMBCOL     vec3(2.0,2.0,2.0)\n#define BACCOL     vec3(2.0,2.0,2.0)\n#define DIFCOL     vec3(2.0,2.0,2.0)\n\n#define MAT1       2.0\n\n#define FOV 2.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=2./l;\n\tfloat ofs=s+s/(r*3.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*53758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(4.0-3.0*f);\n    float n = p.x + p.y*67.0 + p.z*213.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  2.0),f.x),\n                        mix( hash(n+ 67.0), hash(n+ 68.0),f.x),f.y),\n                    mix(mix( hash(n+213.0), hash(n+214.0),f.x),\n                        mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.2;\n    float h = clamp( 0.6+0.6*(b-a)/k, 0.0, 2.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p*3.0 + iTime)*0.28;\n    //shape\n    float h=torus(p, vec2(4.0,2.5)) -d3;\n    float h2=torus(p, vec2(4.0,2.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,42.0,0.25, 0.0);\n        oprep2(p.yz,24.0,0.25, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.06,0.06,2.0),0.0) ;\n        if (flag>0.2) k-=flag*0.28; else k-=0.02 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,4.0,9.5, 4.0);\n    oprep2(p.xz,22.0,0.35, 0.0);\n        \n    p.y=mod(p.y,0.4)-0.6*0.4;\n    float k2=rbox(p,vec3(0.22,0.22,2.0),0.06) - 0.02;\n\n    p=q.xzy;\n    float r=p.y*0.03+sin(iTime)*0.06;\n        oprep2(p.zy,4.0,9.5, 0.0);\n    float g=cylinder(p,vec2(2.15+r,27.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n    float g2=cylinder(p,vec2(2.05+r,28.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*1.0 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.02,-0.02,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 2.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.02 + 2.2*pow(float(i)/float(AOSTEPS),2.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.75;\n    \t}\n   return clamp( 2.0 - 2.0*ao, 0.0, 2.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 2.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.03*SHPOWER;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -2.0 + 3.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -25.0);\n\tvec3 lig=normalize(vec3(3.3, 4.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.6;\n    float b=sin(iTime*0.35)*0.85;\n\trot(ro,vec3(a,b,0.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,2.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 3.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.3,2.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.39,0.73,0.101);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 2.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,2.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,2.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 4.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.6, 2.0 ) ,26.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.02, 3.0, 5.0);\n\n\t    col *= 0.6*amb*AMBCOL*ao + 0.5*dif*DIFCOL*sh + 0.06*bac*BACCOL*ao;\n\t    col += 0.4*rim*amb * rs.x;\n    \tcol += 0.6*pow(spe,2.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.09*-r.x); col*=3.0;\n\t\n\tfragColor = vec4( col, 2.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}