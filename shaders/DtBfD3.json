{
    "Shader": {
        "info": {
            "date": "1695413226",
            "description": "Inverse Alpha Deblending ([url=https://ggx-research.github.io/publication/2023/05/10/publication-iadb.html]paper[/url]), forward and backward, showing tracks/source points/mean sources/...\nMouse: click (reset) + drag (forward paused toy)",
            "flags": 32,
            "hasliked": 0,
            "id": "DtBfD3",
            "likes": 12,
            "name": "IADB gaussian to discrete",
            "published": 3,
            "tags": [
                "gaussian",
                "discrete",
                "iadb"
            ],
            "usePreview": 0,
            "username": "pyBlob",
            "viewed": 214
        },
        "renderpass": [
            {
                "code": "/* See *configuration* in Common for playing around. */\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    resolution = iResolution;\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float alpha = clamp(root.x / float(nstep), 0., 1.);\n    vec4 tracks = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 stats = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    fragColor = vec4(1);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0)/20.+.5; return;\n    //fragColor = tracks; return;\n    //fragColor = stats/float(targets.length()-1); return;\n\n    // target of a source point (scatterplot, one color per target)\n    float hasTarget = float(stats.y >= 0.);\n    blend(fragColor, vec4(hue(stats.y/float(targets.length()-1)),1), hasTarget);\n\n    // forward tracks (black lines)\n    blend(fragColor, vec4(0,0,0,1), (1. - tracks.x) * mix(1., .8, hasTarget));\n\n    // source distribution (red dot, red circle)\n    float r = length(fragCoord - world(vec2(0)));\n    blend(fragColor, vec4(1,0,0,1), 3. - r);\n    blend(fragColor, vec4(1,0,0,1), 1. - abs(3. * f() - r));\n\n    // forward track heads (green dots, pink lines)\n    for (int i=0 ; i<int(iResolution.x) ; ++i)\n    {\n        vec4 x = texelFetch(iChannel0, ivec2(i,1), 0);\n        vec2 x1 = predict_x1(x, alpha, method);\n        blend(fragColor, vec4(1,0,1,0.2), 1. - sdSegment(fragCoord, world(x.xy), world(x1)));\n        blend(fragColor, vec4(0,.5,0,1), 2.5 - length(fragCoord - world(x.xy)));\n    }\n\n    // mean destination (orange dot)\n    blend(fragColor, vec4(1,.2,0,1), 3. - length(fragCoord - world(mean_target())));\n\n    // expected source for each target (purple circles)\n    vec2 X0 = vec2(0);\n    for (int j=0 ; j<targets.length() ; ++j)\n    {\n        vec2 mean_x0 = texelFetch(iChannel2, ivec2(j+1,0), 0).zw;\n        blend(fragColor, vec4(0.5,0,1,1), 2. - abs(5. - length(fragCoord - world(mean_x0))));\n        X0 += mean_x0;\n    }\n    X0 /= float(targets.length());\n\n    // mean of expected sources, should be zero (orange circle)\n    blend(fragColor, vec4(1,.2,0,1), 2. - abs(5. - length(fragCoord - world(X0))));\n\n    // reverse tracks (green lines)\n    blend(fragColor, vec4(0,.2,0,1), 1. - tracks.y);\n\n    // reverse track heads (green dots)\n    for (int j=0 ; j<targets.length() ; ++j)\n    {\n        vec4 x = texelFetch(iChannel0, ivec2(j+1,0), 0);\n        //vec2 x0 = predict_x0(x, alpha, method);\n        //blend(fragColor, vec4(1,0,1,1), 1.5 - sdSegment(fragCoord, world(x.xy), world(x0)));\n        blend(fragColor, vec4(0,.5,0,1), 2.5 - length(fragCoord - world(x.xy)));\n    }\n\n    // targets (blue dots)\n    for (int i=0 ; i<targets.length() ; ++i)\n        blend(fragColor, vec4(0,.2,1,1), 3. - length(fragCoord - world(target(i))));\n\n    fragColor = sqrt(fragColor);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Each pixel is a particle, except (0, 0) which stores the simulation progress.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 index = ivec2(fragCoord);\n    vec4 x = rand(uvec4(iFrame * 0, fragCoord, 0));\n    vec4 n = boxMuller(x);\n\n    if (index == ivec2(0))\n        // (0, 0) simulation progress\n        fragColor = vec4(0, 0, 0, 0);\n    else if (index.y == 0)\n        // (x, 0) backward particles\n        fragColor = target(index.x - 1).xyxy;\n    else\n        // forward particles\n        fragColor = n.xyxy;\n\n    if (iFrame == 0 || iMouse.w > 0.)\n        return;\n\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float da = 1. / float(nstep);\n\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (index == ivec2(0))\n    {\n        fragColor.x += 1.;\n    }\n    else if (index.y == 0)\n    {\n        fragColor = fragColor.xyxy;\n\n        float alpha = 1. - root.x / float(nstep);\n        if (alpha == 1.)\n            fragColor.xy = undo_last(fragColor.xy, da, method);\n        else if (alpha > 0.)\n            fragColor.xy -= da * tangent(fragColor.xy, alpha, method);\n    }\n    else// if (index.y < 100)\n    {\n        fragColor = fragColor.xyxy;\n        //fragColor.xy += n.xy * 0.01; return;\n\n        float alpha = root.x / float(nstep);\n        if (alpha < 1.)\n            fragColor.xy += da * tangent(fragColor.xy, alpha, method);\n     }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Particles tracks. (r: forward of (x, 1), g: backward)\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    resolution = iResolution;\n\n    fragColor = vec4(1);\n    if (iFrame == 0 || root.x == 0.)\n        return;\n\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    for (int i=0 ; i<int(iResolution.x) ; ++i)\n    {\n        vec4 n = texelFetch(iChannel0, ivec2(i, 1), 0);\n        vec2 a = world(n.xy);\n        vec2 b = world(n.zw);\n        fragColor.r = mix(fragColor.r, 0., 0.2 * clamp(1. - sdSegment(fragCoord, a, b), 0., 1.));\n    }\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec4 n = texelFetch(iChannel0, ivec2(i+1, 0), 0);\n        vec2 a = world(n.xy);\n        vec2 b = world(n.zw);\n        fragColor.g = mix(fragColor.g, 0., 1. * clamp(1.5 - sdSegment(fragCoord, a, b), 0., 1.));\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float dot2(vec2 x) { return dot(x, x); }\n#define R(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nconst float pi = radians(180.);\n\n/* configuration */\n\nconst int method = 0;  // 0: mix, 1: turn\nconst int nstep = 100; // deblending substeps\n\n/*\nUniform scaling only changes the intermediate trajectories\nand at which alpha the particles basically travel linearly\ntowards the targets!\nTranslation adds a constant velocity to the particles.\n*/\n// transform (skew, rotation, scale) applied to selected points\n#define T mat2(1,0,0,1)*R(0.)/1.\n\nconst vec2 radius = vec2(5);    // view paddng\nconst vec2 offset = vec2(0, 0); // translation of targets\n\n#if 1\n// explicit target datasets\nconst vec2 targets[] = vec2[](\n    //vec2(1, 0), vec2(0, 1)\n    //vec2(2, 0), vec2(0, 2)\n    //vec2(5, 0), vec2(0, 5)\n    //vec2(.5, -.5), vec2(-.5, .5)\n    T*vec2(5, 0), T*vec2(0, 5), T*vec2(-8, -3)//, T*vec2(-2, 0)\n    //T*vec2(-8, 0), T*vec2(3, 0), T*vec2(5, 0)\n    //vec2(0, -5), vec2(0, 2), vec2(0, 3)\n    //vec2(-5,0), vec2(-4,0), vec2(-3,-1), vec2(-2,0), vec2(-1,0), vec2(0), vec2(1,0), vec2(2,0), vec2(3,0), vec2(4,0), vec2(5,0)\n    //, vec2(0, 5)\n);\nvec2 target(int i) { return targets[i] + offset; }\n#else\n// procedural target dataset\nconst int H = 5;\nconst int W = 5;\nvec2 targets[H * W];\nvec2 target(int i) { return T*(vec2(i/W, i%W) - float(W/2)) + offset; }\n#endif\n\n/* iadb */\n\nvec2 tangent_mix(vec2 x, float alpha)\n{\n    // x = (1. - alpha) * x0 + alpha * x1\n    float ps = 0.;\n    vec2 t = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec2 x1 = target(i);\n        vec2 x0 = x1 - (x1 - x) / (1. - alpha);\n        float p = exp(-dot2(x0) / 2.);\n        t += p * (x1 - x0);\n        ps += p;\n    }\n    return t / ps;\n}\n\nvec2 tangent_turn(vec2 x, float alpha)\n{\n    // x = cos(alpha) * x0 + sin(alpha) * x1\n    alpha = pi / 2. * alpha;\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float ps = 0.;\n    vec2 t = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n    {\n        vec2 x1 = target(i);\n        vec2 x0 = (x - s * x1) / c;\n        float p = exp(-dot2(x0) / 2.);\n        t += p * (-s * x0 + c * x1);\n        ps += p;\n    }\n    return pi / 2. * t / ps;\n}\n\nvec2 tangent(vec2 x, float alpha, int method)\n{\n    switch (method)\n    {\n    case 0: return tangent_mix(x, alpha);\n    case 1: return tangent_turn(x, alpha);\n    }\n}\n\nvec2 undo_last(vec2 x, float da, int method)\n{\n    switch (method)\n    {\n    case 0: return x * (1. - da);\n    case 1: return x;\n    }\n}\n\nvec2 predict_x1(vec4 x, float alpha, int method)\n{\n    switch (method)\n    {\n    case 0: return x.xy + (x.xy - x.zw) * (1. - alpha) * float(nstep);\n    case 1: return x.xy; // not implemented\n    }\n}\n\n/* setup */\n\nvec3 resolution;\nfloat f() { return resolution.y / (offset + 2. * radius + 2.).y; }\nvec2 world(vec2 x)\n{\n    return resolution.xy / 2. + f() * (x - offset / 2.);\n}\n\nvec3 hue(float x)\n{\n    return pow(cos(4. * pi / 3. * vec3(x, x-.5, x-1.)) / 2. + .5, vec3(2));\n}\n\nvec2 mean_target()\n{\n    float ps = float(targets.length());\n    vec2 x1 = vec2(0);\n    for (int i=0 ; i<targets.length() ; ++i)\n        x1 += target(i);\n    return x1 / ps;\n}\n\nvoid blend(inout vec4 fragColor, vec4 color, float f)\n{\n    fragColor = mix(fragColor, vec4(color.rgb, 1), color.a * clamp(f, 0., 1.));\n}\n\n/* random numbers */\n\nuvec4 pcg4d(uvec4 v)\n{\n    // https://www.shadertoy.com/view/XlGcRh\n    // http://www.jcgt.org/published/0009/03/02/\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    //v ^= v >> 16u;\n\n    return v;\n}\n\nvec4 rand(uvec4 x)\n{\n    return vec4(pcg4d(x)) / float(~0u);\n}\n\nvec4 boxMuller(vec4 x)\n{\n    vec2 a = 2. * pi * x.yw;\n    return sqrt(-2. * log(x.xz)).xxyy * vec4(cos(a), sin(a)).xzyw;\n}\n\n/* shapes */\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Statistics.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 index = ivec2(fragCoord);\n    vec4 x = rand(uvec4(iFrame * 0, fragCoord, 0));\n    vec4 n = boxMuller(x);\n\n    vec4 root = texelFetch(iChannel0, ivec2(0), 0);\n    float alpha = clamp(root.x / float(nstep), 0., 1.);\n    resolution = iResolution;\n\n    fragColor = vec4(0, -1, 0, 0);\n    if (iFrame == 0 || root.x == 0.)\n        return;\n\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    if (index == ivec2(0))\n    // (0, 0)\n    {}\n    if (index.y == 0)\n    // (x, 0) expected source for each target -> .zw\n    {\n        if (index.x < targets.length()+1)\n        {\n            float total = 0.;\n            vec2 mean_x0 = vec2(0);\n            int k = 1;\n            for ( ; k<100 && k<int(iResolution.y) ; ++k)\n            for (int i=0 ; i<int(iResolution.x) ; ++i)\n            {\n                int closestTarget = int(texelFetch(iChannel2, ivec2(i,k), 0).x);\n                vec2 x0 = boxMuller(rand(uvec4(0, i,k, 0))).xy;\n                if (closestTarget == index.x-1)\n                {\n                    ++total;\n                    mean_x0 += x0;\n                }\n            }\n            mean_x0 /= total;\n            fragColor.zw = mean_x0;\n        }\n    }\n    else// if (index.y < 100)\n    // (x, y) when one-step predicting alpha=1, index of the closest target for each particle -> .x\n    {\n        vec2 x0 = boxMuller(rand(uvec4(0, index, 0))).xy;\n        vec4 x = texelFetch(iChannel0, index, 0).xyzw;\n        vec2 x1 = predict_x1(x, alpha, method);\n        int closestTarget = 0;\n        float r = length(x1 - target(0));\n        for (int j=1 ; j<targets.length() ; ++j)\n        {\n            float rj = length(x1 - target(j));\n            if (rj < r)\n                closestTarget = j, r = rj;\n        }\n        fragColor.x = float(closestTarget);\n    }\n\n    // draws index of predicted target at initial location of all particles -> .y\n    {\n        //int k = iFrame % (100-1) + 1;\n        int k = iFrame % (int(iResolution.y)-1) + 1;\n        for (int i=0 ; i<int(iResolution.x) ; ++i)\n        {\n            int closestTarget = int(texelFetch(iChannel2, ivec2(i,k), 0).x);\n            vec2 x0 = boxMuller(rand(uvec4(0, i,k, 0))).xy;\n            if (length(fragCoord - world(x0)) < 1.)\n                fragColor.y = float(closestTarget);\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}