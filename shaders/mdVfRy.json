{
    "Shader": {
        "info": {
            "date": "1698356809",
            "description": "𝐑𝐨𝐭𝐚𝐭𝐞= 𝐀𝐫𝐫𝐨𝐰𝐊𝐞𝐲𝐬 || 𝐃𝐫𝐚𝐠𝐌𝐨𝐮𝐬𝐞 +𝐖𝐑 (=roll) \n𝐒𝐭𝐫𝐚𝐟𝐞= 𝐄𝐒𝐃𝐅                                +𝐓𝐆 (=upDown)  \nhttps://www.shadertoy.com/view/fsXXzX\nwith quaternion-camera of\nhttps://www.shadertoy.com/view/wtdyRs",
            "flags": 48,
            "hasliked": 0,
            "id": "mdVfRy",
            "likes": 31,
            "name": "Quat_Flycam + English_Lane",
            "published": 3,
            "tags": [
                "forest",
                "cellular",
                "trees",
                "nature",
                "path",
                "roads",
                "devon"
            ],
            "usePreview": 1,
            "username": "ollj",
            "viewed": 904
        },
        "renderpass": [
            {
                "code": "/*\nvec4 Mode0_NoBuffer_mainImage( vec2 fragCoord, float aTime, vec3 aResolution, int aFrame, vec4 aMouse, sampler2D aChannel1\n){vec4 ppd\n ;vec4 col = mainScene( fragCoord, aTime, aResolution, aFrame, aMouse, aChannel1, ppd )\n ;col.rgb = postProcess( col.rgb, fragCoord / aResolution.xy, ppd )\n ;return col;}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord\n){fragColor = Mode0_NoBuffer_mainImage( fragCoord, iTime, iResolution, iFrame, iMouse , iChannel1); }\n\n/**/\n\nfloat segment(vec2 P, vec2 A, vec2 B\n){vec2 g=B-A\n ;vec2 h=P-A\n ;return length(h-g*clamp(dot(g,h)/dot(g,g),0.,1.));}\n\n\n#define fra(u)(u-.5*iResolution.xy)/iResolution.y\n\nvec4 drawDragVector(vec2 u\n){if (iMouse.z<0.)return vec4(0)\n ;vec2 a=fra(abs(iMouse.xy))\n ;vec2 b=fra(abs(iMouse.zw))\n ;//float r=smoothstep(.01,0.,abs(length(b-u)-.02));//ring\n ;float r=min(   segment(u,a,b   )//line segment\n             ,abs(length(b-u)-.02)//ring\n             )\n ;r=smoothstep(.01,0.,r)*.3//thickness, transparency\n ;return vec4(r);}//premultiplied for porterDuff\n\nvoid mainImage(out vec4 o, in vec2 u){\n //o=mainImage2(o,u);                         //mainIimage is in THIS channel\n o=texture(iChannel2,u/iResolution.xy, -100.);//mainIimage is in Ichannel2\n o=sat(o);//may need to clamp for an overlayd line\n //o+=drawDragVector(u/iResolution.xy*iResolution.x);//almost sufficient for a white line overlay\n o=pdOver(drawDragVector(fra(u)),o);//proper porter duff overlay.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//union of \n//https://www.shadertoy.com/view/fsXXzX (English Lane                       )\n//https://www.shadertoy.com/view/wl3yDs (reproject volume quaternion 2022-02)\n//mostly to improve camera controls\n\n//tags:\n//traceQuadratic,bezierPatch,Quaternioncamera,fly,aabv,bspline,bpatch,pqfm\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define vec1 float\nstruct v22{vec3 a,b;};//for 2 domains(density/distance field)\n\n//way too common subroutine shorthands:\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define u2(u) ((u)*2.-1.)\n#define iR iResolution\n#define iM iMouse\nvec3 ma0(vec3 a){return max(a,0.);}\nfloat mu(vec2 a){return a.x*a.y;}float mu(vec3 a){return a.x*a.y*a.z;}\nfloat su(vec2 a){return a.x-a.y;}float su(vec3 a){return a.x+a.y-a.z;}\nfloat ad(vec2 a){return a.x+a.y;}float ad(vec3 a){return a.x+a.y+a.z;}\n//2d rotation matrix from angle(deg)\nmat2 rot(float ang){return mat2(cos(ang),sin(ang),-sin(ang),cos(ang));}\n//return smallest angle between 2 vectors\nfloat AngleBetween(vec3 a,vec3 b){;return acos(dot(a,b)/(length(a)*length(b)));}\n\n\n\n//----- START  of parameters and common functions for camera controls\n//\n//simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n#define noRollCam     0\n//\n//quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n#define quaternionCam 1\n//\n//\n//temporal-Reprojection appears initialize wrongly with quaternionCam (must reset time)\n//\n#define camType quaternionCam\n//[noRoll] camera is worse than [quaternionCam]\n//- does not allow for roll (and thus it never gridlocks)\n//- camAng1 is just a doubleBuffered iMouse.xy (is not true angularVelocity, but has similar effect)\n//- camPos1 (posaition derivative) has a confused .w factor (maxVelocity, but it changes)\n//\n//global buffereB Addresses for camera controls/properties\n//eg: use get(camP1).xyz to get camera position\n//all positions are vec3.xyz\n//all rotations are vec4.xyzw quaternions (stored (very close to) normalized) (for the quaternion camera)\n//all rotations are vec2.xy   jaw+roll    for the non-quaternion camera\nconst float //values must count up from 9, and NBuffB muzst be the last+largest.\n camP0=0.//camera position (0th derivative/time)\n,camA0=1.//camera rotation (0th derivative/time)\n,camP1=2.//camera position (1th derivative/time) == camera velocity\n,camA1=3.//camera rotation (1th derivative/time) == camera momentum\n,li0P0=4.//light0 position\n,li1P0=5.//light1 position\n,camP0p=6.//camera position of previous frame\n,camA0p=7.//camera rotation of previous frame\n,NBuffB=8.//max address count (for Bounding Volume)\n;//\n\n\n//camera starting position\nconst vec4 posStart=vec4(0,1,0,1);\n//\n#if (camType==0) \n #define CAMERA_SPEED .05\n const float MOUSE_SENSITIVITY=.2/60.;\n#else\n const vec2 MOUSE_SENSITIVITY = vec2(-1.,1.)*9.;\n \n //accelleration and drag must be set to the scene scaling\n #define setScale 5.\n \n const float\n // if (camera is closer than PHYSICS_RADIUS) apply pushing force PHYSICS_REPEL along surface-normal.\n  //set to -100. to skip collisions\n  //=.01 is reasonable for the mandelbulb distanceField\n  PHYSICS_RADIUS=.0000001 //-100.\n ,PHYSICS_REPEL=1.//normal(cameraPosition)*PHYSICS_REPEL= how much colisions push the camera away. \n                  //no normalize() happens outside of normal(), which you may add or remove\n                  //depending on how good your df is andOr how your collisions handle deformed fields.\n ,LIN_ACCE=setScale*4.5//linear accelleration\n ,ANG_ACCE=setScale*2.0//angular accelleration\n ,LIN_DRAG=setScale*1.0//linear  drag/friction\n ,ANG_DRAG=setScale*2.0//angular drag/friction\n;\n#endif\n\n\n\n\n//#endif\n//\n//radius of lightSource sphere\n#define LIGHT_RADIUS .01\n//\n#define get(i)texelFetch(iChannel2,ivec2(i,0),0)\nvec4 get2(ivec2 a,sampler2D b){return texelFetch(b,a,0);}\nvec4 get2(float a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\nvec4 get2(int   a,sampler2D b){return texelFetch(b,ivec2(a,0),0);}\n//----- end of parameters and common functions for camera controls\n\n\n//--- quaternionRotation math (updated 2021-Jan-7) //https://www.shadertoy.com/view/4tSyRz\n//\n//essential for the quaternion-camera.\n//\n//ANY rotations in 3d are non-commutative!\n//\n//matrix rotations are just bulky, memory wasting\n//EulerRotations almost certainly fail to rotate over the SHORTEST path.\n//EulerRotations almost certainly will gimbalLock and get stuck along one axis\n//QuaternionRotations are superior here.\n//-> we only use EulerRorations for simple input devices (keyboard input)\n//-> we convert to quaternions, buffered as vec4.\nvec4 qid(){return vec4(0,0,0,1);}//quaternion Identity\n//\n//---quaternion & AxisAngle (==quaternion multiplication)\n//\n//return quaternion from Axis[a] and Angle[r]\nvec4 aa2q(vec3 a,float r){vec2 g=vec2(sin(r),cos(r))*.5;return normalize(vec4(a*g.x,g.y));}\n//return AxisAngle of NORMALIZED quaternion input\nvec4 q2aa(vec4 q){return vec4(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.);}//assumed q is normalized coverts to axis&angle\n//return q2, rotated by q1, order matters (is non commutative) : (aka quaternion multiplication == AxisAngleRotation)\nvec4 qq2q(vec4 q1, vec4 q2){return vec4(q1.xyz*q2.w+q2.xyz*q1.w+cross(q1.xyz,q2.xyz),(q1.w*q2.w)-dot(q1.xyz,q2.xyz));}\n//extension to qq2q(), scaled by sensitivity [f] (==quaternion ANGULAR equivalent to slerp() )\nvec4 qq2qLerp(vec4 a, vec4 b, float f//jonathanBlow wrote many documents about better alternatives.\n){float d=dot(a,b),t=acos(abs(d)),o=(1./sin(t));return normalize(a*sin(t*(1.0-f))*o*sign(d)+b*sin(t*f)*o);}\n//doing qq2q() multiple times, you need to normalize() the quaternion, to fix rounding errors.\n//how often you do this is up to you.\n//normalize q (assuming length(q) is already close to 1, we can skip whe sqrt()\nvec4 qn(vec4 q//){return q/dd(q) //not as wortksafe, division is slow.\n){float w=dot(q,q);return w==1.?q:.5*(3.-w)*q;}//worksafe and faster: https://www.shadertoy.com/view/llySRh\n//return normalize(q) //unnecessary, as long as lenght(q) is close to 1.\n\n//qexp() qlog() qpow() seem useful for fractals.\nvec4 qexp(vec4 v\n){float a=dot(v.xyz,v.xyz)\n ;if (a<1e-7) return vec4(0,0,0,1)\n ;a=.5*sqrt(a)\n ;return vec4(cos(a),v.xyz*(sin(a)*.5/a));}\nvec4 qlog(vec4 q\n){float l=length(q.xyz),s=2.*atan(l/q.w)/l\n ;return vec4(q.xyz*2.*atan(l/q.w)/l,l);}//bug in qexp, final quat constructor args reversed.\nvec4 wpow(vec4 a,vec4 b){return qexp(qlog(a)*b);}//or something like that\nvec4 qrev(vec4 q){q.w=-q.w;return q;}// conjugate quaternion\n//this shader solves for smooth qlerp: \n//https://www.shadertoy.com/view/DtyfRV\n// untested, just tossed together to demo qlog,qexp instead of porting original lol - probably backward\n//below is a likely bad untested qlerp.\n/*vec4 qq2qLerpBAD(vec4 a, vec4 b, float i){\n    //ERROR; will go around the wrong long-angle hyper-geodesic half-the-time, needs bit of work\n   ;if (dot(a, b) < 0.) b.w = -b.w; // should help\n    return qq2q(a,qexp(qlog(qq2q(qrev(a),b))*i));}//from https://www.shadertoy.com/view/ssGSDm\n*/\n//\n//not sure about more use-cases pf qexp() qlog() qpow()\n//\n//return quaternion, that is the shortest rotation, between looking to [a before], and looking to [b after] the rotation.\nvec4 qBetween(vec3 a,vec3 b//http://wiki.secondlife.com/wiki/LlRotBetween\n){float v=sqrt(dd(a)*dd(b));if(v==0.)return qid();v=dot(a,b)/v\n ;vec3 c=a.yzx*b.zxy-a.zxy*b.yzx/v;float d=dd(c)\n ;if(d!=0.){float s=(v>-0.707107) ? 1.+v : d/(1.+sqrt(1.-d));return vec4(c,s)/sqrt(d+s*s);}\n ;if(v>0.)return qid()\n ;float m=length(a.xy);return (m!=0.) ? vec4(a.y,-a.x,0,0)/m : vec4(1,0,0,0);\n ;}//Written by Moon Metty, optimized by Strife Onizuka (faster version, without trigonometry)\n//the above has better precision than the below, but the functions are hopefully identical.\nvec4 qBetween2(vec3 a,vec3 b){if(a==b)return qid();return aa2q(cross(a,b),AngleBetween(a,b));}//qBetween() with less code, but has some slower or less precise cases.\n//return inverse of quaternion\nvec4 qinv(vec4 q){return vec4(-q.xyz,q.w)/dd(q);}\n//return VECTOR p, rotated by quaterion q;\nvec3 qv2v(vec4 q,vec3 p){return qq2q(q,qq2q(vec4(p,.0),qinv(q))).xyz;}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){\n//return qv2v(b*vec4(1,1,1,-1),v);//somehow this is not identical, fuck it all!\nv2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//\n//qv2v()  with swapped inputs\n//return quaterion P (as vector), as if it i rotated by VECTOR p (asif it is a quaternion)\nvec3 vq2v(vec3 p,vec4 q){return qq2q(qinv(q),qq2q(vec4(p,0.0),q)).xyz;}\nvec3 vq2v(vec4 a,vec3 b){return qv2v(a,b);}//in case of namespace confuction\nvec3 qv2v(vec3 a,vec4 b){return vq2v(a,b);}//in case of namespace confuction\n//\n//---quaternion & matrix (second to last in list, because they are bulky)\n//\n//return mat3 of (normalized) [q]uaternion (rotation matrix without translation)\n//uncomment notWorkSafeForNoGoodReason, to break the matrix on some opengl implementations.\n//#define notWorkSafeForNoGoodReason\n//or use mat4 quat_to_transform() (without the translation part) of /WsGfWm\nmat3 q2m(vec4 q //https://www.shadertoy.com/view/WsGfWm\n){vec3 a=vec3(-1,1,0)\n ;mat3 m=mat3(.5)+mat3(q.xzy*a.zxy,q.zyx*a.yzx,q.yxz*a)*q.w\n //above is necessary for compatibility, see /wtdyRs\n +matrixCompMult(outerProduct(q.xyz,q.xyz),1.-mat3(1))//3 unnecessary multy by 0.\n ;q*=q//<-everythig except the main diagonal\n ;m-=mat3(q.y+q.z,0,0,0,q.x+q.z,0,0,0,q.x+q.y)//<- only the main diagonal\n ;return m*2.;}//this *2 scalar may not need to be internal\n//\n//return q2m() as mat4, with [t]ranslation\nmat4 q2m(vec4 q,vec3 t //studying https://www.shadertoy.com/view/WsGfWm\n){mat3 m=q2m(q);return mat4(m[0],0,m[1],0,m[2],0,t,0);}//*=2,and add tranlation\n//return rotation matrix sub of mat4\nmat3 m42Rot(mat4 a){return mat3(a[0].xyz,a[1].xyz,a[2].xyz);}\n#define m2f(a,b) m[a][b]-m[b][a]\nvec4 m2q(mat3 m//return quaternion of orthogonal matrix (with determinant==1., or else quaternionm will not be normalized)\n){float q=2.*sqrt(abs(1.+m[0][0]+m[1][1]+m[2][2]))//http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/\n ;return vec4(vec3(m2f(2,1),m2f(0,1),m2f(1,0))/q/4.,q);}\n//\n//---quaternion+ EulerRot (last in list, because they are the worst)\n//\n//eulerRot2Quaternion and back \n//- not elegant, not fast\n//- and theres 6 arbitiary, incompatible and non commutative permutatuions of [yaw opitch roll] order\n//BUT, your keyboard inputs are most likely Euler-rotations, so we have to chose one:\n//wikipedia does (jaw pitch roll) order: of a plane taking of;\n//; (jaw)   first    steers like a car\n//, (pitch) secondly the nose pulls up\n//, (roll)  lastly   and in the air to roll\n//\n//above function is used here, but it lacks an inverse, unlike below other order:\n//\nfloat at2e(vec2 a){a*=2.;return atan(a.x,1.-a.y);}\n//return quaternion of Euler[yaw,pitch,roll]     //this one needs to be phased out\n//float mu(vec3 a){return a.x*a.y*a.z;}\nvec4 eYPR2q(vec3 o){o*=.5;vec3 s=sin(o);o=cos(o)\n//https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Source_code\n ;vec4 a=vec4(s.xz,o.xz);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\nvec4 eYPR2q(vec2 o){o*=.5;vec2 s=sin(o);o=cos(o)\n ;vec4 a=vec4(s.x,0.,o.x,0.);return  a.yyww*a.zxxz*o.y+a.wwyy*a.xzzx*s.y*vec4(-1,1,-1,1);}\n//return Euler[yaw,pitch,roll]  of quaternion \nvec3 q2eYPR(vec4 q){vec3 r=vec3(0,2.*(q.w*q.y-q.z*q.x),0)\n ;return vec3(at2e(vec2(dot(q.wx,q.zy),dd(q.yz)))          //yaw   (z-axis rotation)\n             //at2e(vec2(q.w*q.z+q.x*q.y,q.y*q.y+q.z*q.z)) //yaw   (z-axis rotation)\n              ,(abs(r.y)>=1.)?r.y=sign(r.y)*pi*.5:asin(r.y)//pitch (y-axis rotation) (worksaved asin())\n              ,at2e(vec2(dot(q.wy,q.xz),dd(q.xy))))        //roll  (x-axis rotation)\n            //,at2e(vec2(q.w*q.x+q.y*q.z,q.x*q.x+q.y*q.y)))//roll  (x-axis rotation)\n ;}//<-untested function\n/*\n//these EulerOrders are being phased out:\n//return quaternion of Euler [pitch, yaw, roll]  //this one needs to be phased out\nvec4 ePYR2q(vec3 o){//return eYPR2q(o.zyx)\n;o*=.5;vec3 s=sin(o);o=cos(o);vec4 a=vec4(s.xy,o.xy)//https://www.shadertoy.com/view/4tSyRz\n ;return a.xyxz*a.wzyw*o.z+a.yxzx*a.zwwy*s.z*vec4(1,-1,1,-1);}\n//return quaternion of EulerRotation [around axes in (Z,Y,X)==(roll,pitch,yaw) order]\nvec4 eRPY2q(vec3 c){c*=.5;vec3 s=sin(c);c=cos(c)//http://wiki.secondlife.com/wiki/LlEuler2Rot\n ;return qq2q(qq2q(vec4(0,0,s.z,c.z),vec4(0,s.y,0,c.y)),vec4(s.x,0,0,c.x));}\n/**/\n\n//from https://www.shadertoy.com/view/wlSyzd\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qq2q(qinv(q),qq2q(v3(p,0.0),q)).xyz;}//inverse rotation\n//---end__ quaternion\n\n\n\n\n\n\n\n\n\n//#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\n//v0 ad(v1 a){return a.x+a.y;}\n//v0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//instead of doing imouse.zw=abs(imouse.zw) iMouseZwFix only changes sign when needed.\nvec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n  \n//checkerboard of https://www.shadertoy.com/view/4lySzc\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n\n//a matrix of quadraticFields, that share no prime factors, is a fast and simple hash.\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n//maybe see https://www.shadertoy.com/results?query=pqfm\n\n//random number (permuted congruential generator)\nuvec4 s0,s1;//internal RNG state \nivec2 pixel;//internal RNG state \nvoid rng_initialize(vec2 p,int frame\n){pixel=ivec2(p)\n ;s0=uvec4(p,uint(frame),uint(p.x)+uint(p.y))//white noise seed\n ;s1=uvec4(frame,frame*15843,frame*31+4566,frame*2345+58585)//blue noise seed\n ;}\nuvec4 pcg4d(uvec4 v//https://www.pcg-random.org/\n){v=v*1664525u+1013904223u\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;v=v ^ (v>>16u)\n ;v.x+=v.y*v.w;v.y+=v.z*v.x;v.z+=v.x*v.y;v.w+=v.y*v.z\n ;return v;}\n//float rand(){return float(pcg4d(s0).x)/float(0xffffffffu);}\nvec2 rand2(){return  vec2(pcg4d(s0).xy)/float(0xffffffffu);}\n//vec3 rand3(){return  vec3(pcg4d(s0).xyz)/float(0xffffffffu);}\nvec4 rand4(){return  vec4(pcg4d(s0))/float(0xffffffffu);}\nivec2 shift2(//random blue noise sampling pos\n){return (pixel+ivec2(pcg4d(s1).xy%0x0fffffffu))%1024;}\nvec3 udir(//uniformly spherically distributed\n){vec2 rng=rand2()\n ;vec2 r=vec2(2.*pi*rng.x,acos(2.*rng.y-1.))\n ;vec4 c=vec4(cos(r),sin(r))\n ;return vec3(c.xz*c.ww,c.y);}\nfloat HenyeyGreenstein(float g,float costh\n){return (1.-g*g)/(4.*pi*pow(1.0+g*g-2.0*g*costh,3./2.));}\n \nfloat sdBox(vec3 p,vec3 b\n){vec3 q=abs(p)-b\n ;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.);}\n\n\n\n\n\n\n\n\n\n//https://en.wikipedia.org/wiki/Alpha_compositing\n//https://doc.qt.io/archives/qq/qq17-compositionmodes.html \n//from   https://www.shadertoy.com/view/wdsSWS\n//.w=0 is fully transparent, .W=1 is fully visible\n//iff(you want to keep an alpha channel after a composition) you must premultiplay all inputs wioth their alpha;\n//; a.xyz*=a.w\n//; b.xyz*=b.w\n//and the outputs of these functions will be already_premultiplied.\n//\n//else if(you to one last pdOver a nontransparent background) you must NOT premultiply the backbround!\n//pdver without premultiplied alpha, note that nonstransparent red+nontransparent green = nontransparendt yellow.\n//vec4 pdo(vec4 a,vec4 b){return vec4((a.xyz*a.w+b.xyz*b.w)/(a.xyz+b.w*(1.-a.w)),,a.w+b.w*(1.-a.w));}\n//these functions are with premultiplied alpha (better performance, easy to buffer)\n//\n//GENERAL alpha composition:  named after porterDuff\n//see https://en.wikipedia.org/wiki/Alpha_compositing\n//    https://doc.qt.io/archives/qq/qq17-compositionmodes.html\n//.w=0 is fully transparent, .W=1 is fully visible\n//inputs should be x=sat(x), or you likely get [color inverted hazes], this version is still not haze-free?\n//\n//on premultiplication:\n//iff (you want to keep an alpha channel after a composition)  !!!!\n//You must FIRST premultiplay all inputs with their alpha.w :  !!!!\n//; a.xyz*=a.w                                                 !!!!\n//; b.xyz*=b.w                                                 !!!!\n//on general [premultiply], you may want to watch              !!!!\n//https://www.youtube.com/watch?v=XobSAXZaKJ8                  !!!!\n//\n//IFF you can discard the alpha channel after a SINGLE composition\n//, you may also skip the premultiply-multiplication in some cases.\n\n//ut() is a subroutine for alpha compositing:\n//#define ut(a,b) (a*(1.-b))   //this one liner is a lot less worksafe!\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}\n//below are the 5 alpha compositions:\nvec4 pdOut (vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+(a*b.w);}\nvec4 pdXor (vec4 a,vec4 b){return ut(b,a.w)+vec4(ut(a,b.w));}\nvec4 pdIn  (vec4 a,vec4 b){return vec4(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//the above ommits the variant that returns 0 and a&b-inoput-swapped functions to half function/count\n//the above ommits 2 functions, that return a or b, for simplicity\n//end of basic part of alpha compositing (yep, thats ALL there is to it)\n//\n//start of extended alpha compositing \n//...adds interpolation+generalization to compositing (interpolating different types of compositing)\n//The below allows you to MIX(a,b,c) between any 2 or 4 types of alpha compositing, by the parameter [c]\n//pf() does unify all 5 pd-compositions (above) into 1 parametric function\n//pf() was a silly idea of smoothly cyling between 5 compositions\n//pf() was quickly obsoleted by pf()\n//pdOverAtop() and pdOutXor() are interpolating subroutines for pf()\n#define pdOverAtop(a,b,c) a*mix(b,1.,c)\n#define pdOutXor(a,b,c) mix(ut(a,b),vec3(0),c)\n//pf() has c set how we interpolate; c is range [0..4] and whole-bumber-c causes a [mix(a,b,0.)==a] result\n#define Over 0. //[c range 0..1 => over..atop]\n#define Atop 1. //[c range 1..2 => atop..out]\n#define Out  2. //[c range 2..3 =>  out..Xor]\n#define Xor  3. //[c range 3..4 =>  xor..In]\n#define In   4.\n//the ability to interpolate is just a side effect of using mix() to generalize.\n//pf() may actually only work well for c=floor(c) its not tested well.\nvec3 pf(vec4 a,float c,vec4 b\n){if(c>3.)return a.xyz*b.w//pdIn is just multiplication.\n ;vec3 d=vec3(0);d=mix(pdOverAtop(a.xyz,b.w,c),pdOutXor(a.xyz,b.w,c-2.),step(2.,c));return d+ut(b.xyz,a.w) ;}\n//\n//pd() makes more sense than pf() for demoing interpolation of compositing\n//pd() does bilinear interpolatin over c.xy, as in https://www.shadertoy.com/view/wdsSWS\n//top    left  = Over\n//top    right = Xor\n//bottom left  = Atop\n//bottom right = Out \nvec4 pd(vec4 a,vec2 c,vec4 b){c.x=sat(c.x)//clamping c.x to ensure bounds.\n ;return mix(a*mix(b.w,1.,c.y),ut(a,b.w)*c.y,c.x)+ut(b,a.w);}\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// English Lane by Jerome Liard, April 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/fsXXzX\n//\n// You are walking and flying through an infinite English countryside.\n// Chill out and use the mouse to look around. \n// A single walk->fly cycle is about 50s.\n//\n// Shadertoy compilation time seems to be about 15s, thanks for your patience.\n\n// first lane index, at each walk-flight cycle we switch to next lane midair\n#define FIRST_LANE_INDEX 10.0\n\n// If the reprojection is janky please press the button that resets time to zero.\n//\n// I wanted to make a navigable countryside with paths inspired by paintings from Richard Thorn (see his book \"Down an English Lane\"), \n// and a little bit by Hiroshi Nagai and Tezuka Osamu's Jumping short anime (both life long inspirations).\n//\n// Creation of the initial patchwork and parameterized paths network:\n//\n//   - 2 perpendicular sets of regularly spaced parallel 1d lanes are used. \n//   - Each 1d lane has an id. The amplitude of each 1d lane must be such that they don't cross the previous or next 1d lane.\n//   - The horizonal set of parallel lanes have constant vertical center spacing.\n//   - The twist: the vertical set of parallel lanes can have their spacing set more freely based on which stab we are in the horizontal set.\n//     This helps generating complex branching patterns.\n//   - For each set of parallel lanes we simply use its local x coordinate as a parameter (used for garden brick wall and camera).\n//   - The intersections of lane stabs give us a cellular base for country patches, and for each patch we get an id, a distance to boundary, and parameterized borders.\n//\n// Trees and houses placement:\n//\n//   - Patches ids is used to decide what combination of things goes on the patch (trees, bushes, farms, walls, lawn...)\n//   - There are 3 layers of cellular placement for trees, bushes, and farms.\n//     - Bushes are too close to each other and must be soft blended, but 3x3 search is no-no so we do a \"4 or 5\" neighbours search (we only consider checkboard black cells).\n//     - For farms and trees we use randomly decimated jittered grid and actually only consider the current cell we are in, and hack marching to death to compensate.\n//   - Modeling:\n//     - Trees leaves volume have a base shape done with 2 spheres soft blended, then distored by 2 layers of packed 3d spheres tiling to blobify the leaves volume, and then some fine noise distortion on the surface.\n//       The use of densely packed sphere tiling is inspired by @Shane's Cellular Tiling https://www.shadertoy.com/view/4scXz2\n//     - Farms are randomized with gable and hipped roof, chimneys and colors very vaguely inspired by pictures of Devon.\n//\n// Marching:\n//\n//   - For patches, marching uses ghost steps nearby patch boundaries so that we don't check neighbour patches objects, only the patch we are in.\n//   - For trees and farms too, we force the raymarch to take ghost steps along their cell borders for x1 sdf eval.\n//     - This ghost point machinery is hacky and not perfect (esp on patches boundary where we don't have clean intersections) but still helps.\n//   - Because of all the cellular evals going on, to save height evals we use taylor expansion of the heightfield on local neiborhood.\n//   - Despite above efforts I had to resort to reprojection and still perf isn't great. \n//     Blurring the noise with reprojection also helps hide the general noisy lameness and gives better colors.\n//\n// Clouds are volumetric but baked in a spheremap at first frame and assumed distant.\n// Also had to turn view trace/shadow trace/scene gradient/cellular evals into loops to help compile time on the website, sometimes at the expense of runtime perfs.\n// As always some code, techniques, ideas from @iq, @Dave_Hoskins, @Shane, @FabriceNeyret2 are used in various places, \n// this shader also uses some spherical gaussian code from Matt Pettineo \n// (see comment for links to references).\n\n#define PI 3.141592654 // He does love his numbers\n#define FLT_MAX 1000000.0\n\n#define SQR2 1.414213562\n#define SQR3 1.732050807\n\n#define RED  vec3( 1, 0, 0 )\n#define GREEN vec3( 0, 1, 0 )\n#define BLUE vec3( 0, 0, 1 )\n#define WHITE vec3( 1, 1, 1 )\n#define BLACK vec3( 0, 0, 0 )\n#define MAGENTA vec3( 1, 0, 1 )\n#define YELLOW vec3( 1, 1, 0 )\n#define AZURE vec3( 0.0, 0.5, 1.0 )\n\n#define VECTYPE(type) \\\ntype saturate(type x){return clamp( x, type(0.0), type(1.)); } \\\ntype smoothstep_unchecked( type x )   { return (x*x)*(type(3.)-x*2.);} \\\ntype smoothstep_unchecked_d( type x ) { return 6.*x*(type(1.)-x); }\nVECTYPE( float )\nVECTYPE( vec2 )\nVECTYPE( vec3 )\nVECTYPE( vec4 )\n//oh wow, this works, and this is Great.\n\n//parent library, unused outcommented.\n//float exp_decay( float x ){return 1. - exp( -x );}\n// cubic bump that goes through (0,0)->(1,0)\n// slope at x=0 is df0\n// slope at x=1 is df1\nfloat cubicbump(v0 x,v0 c,v0 a){a+=c;return x*(x*(x*a-a-c)+c); }\nfloat smoothbump(v0 a,v0 r,v0 x){return 1.-smoothstep_unchecked(min(abs(x-a),r)/r);}\n//smoothstep(x,center,radius)\nfloat smoothstep_c(v0 x,v0 c,v0 r){return smoothstep(c-r,c+r,x);}\n//smoothstep centered at 0\nfloat smoothband(v0 x,v0 r,v0 raa){return 1.-smoothstep_c(abs(x),r,raa );}\n// range s,e\nfloat smoothband(v0 x,v0 s,v0 e,v0 raa){return smoothband(x-(e+s)*.5,(e-s)*.5,raa);}\nvec2 perp(v1 v){return vec2( -v.y,v.x );}\nfloat calc_angle(vec2 v){return atan(v.y,v.x);} // range[-pi,pi]\n//float calc_angle( vec2 a,vec2 b){return calc_angle(vec2(dot(a,b),dot(perp(a),b))); }\nfloat contrast( float x, float s ) { return ( x - 0.5 ) * s + 0.5; }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat lensqr( vec2 v ) { return dot( v, v ); }\nfloat lensqr( vec3 v ) { return dot( v, v ); }\nfloat lensqr( vec4 v ) { return dot( v, v ); }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\n// variant of exp/log soft min and max that save a few instructions\nfloat smin_exp2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat smax_exp2( float a, float b, float k ) { return -smin_exp2( -a, -b, k ); }\n// https://iquilezles.org/articles/smin\nfloat smin_pol( float a, float b, float k ) { float h = clamp( 0.5f + 0.5f * ( b - a ) / k, 0.0f, 1.0f ); return mix( b, a, h ) - k * h * ( 1.0 - h ); }\nfloat smax_pol( float a, float b, float k ) { return -smin_pol( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat min_( float x, float y, float z ) { return min( min( x, y ), z ); }\nfloat max_( float x, float y, float z ) { return max( max( x, y ), z ); }\nfloat nearest( float x ) { return floor( 0.5 + x ); }\nfloat nearest( float x, float spacing ) { return floor( 0.5 + x / spacing ) * spacing; }\nvec2 nearest( vec2 x, vec2 spacing ) { return floor( vec2( 0.5 ) + x / spacing ) * spacing; }\nfloat sum( vec4 v ) { return v.x + v.y + v.z + v.w; }\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\n\n// project this on line (O,d), d is assumed to be unit length\n#define PROJECT_ON_LINE1(type) \\\ntype project_on_line( type P, type O, type d ) { return O + d * dot( P - O , d ) / dot(d, d ); } \\\ntype project_on_plane( type P, type O, type n ) { return P - n * dot( P - O , n ) / dot(n, n ); } \\\n\nPROJECT_ON_LINE1( vec2 )\nPROJECT_ON_LINE1( vec3 )\n\n// https://iquilezles.org/articles/distance\n// fast and nice in most cases\n#define FAST_SIGNED_DISTANCE_TO_FUNC_11_ARG(s,p,f,a,e  \\\n){vec2 _p=p;float _e=e;float _y=f(_p.x, a)  \\\n ;float _dd=(f(_p.x+_e,a)-_y)*(1./_e)       \\\n ;s=(_p.y-_y)/sqrt(1.+_dd*_dd);}            \\\n\n//transform vec3 by mat4 (camera projection matrix)\nvec3 transform_vector(mat4 m, vec3 v){return (m*vec4( v,0)).xyz;}\n\nstruct bounds2 { vec2 pmin; vec2 pmax; };\nbounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; }\n\n#define REPEAT_FUNCTIONS( type ) \\\ntype repeat( type x, type len ) { return len * fract( x * ( type( 1.0 ) / len ) ); }\\\ntype repeat_mirror( type x, type len ) { return len * abs( type( -1.0 ) + 2.0 * fract( ( ( x * ( type( 1.0 ) / len ) ) - type( -1.0 ) ) * 0.5 ) ); }\n\nREPEAT_FUNCTIONS( float )\nREPEAT_FUNCTIONS( vec2 )\n\n// badly antialiased stripes\n// r is the half width of the stripes\n// raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// period is the distance between 2 consecutive stripes\n\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n\n// triangular sin waves - you can drop in as a replacement for sin to get polygonized looks\nfloat tri_sin( float x ) { return (abs(fract((x-PI*0.5)/(PI*2.))-0.5)-0.25)*4.0; }\n\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\nfloat hash11(float p) { p = fract(p * .1031); p *= p + 33.33; p *= p + p; return fract(p); }\nfloat hash12(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nfloat hash13(vec3 p3) { p3 = fract(p3 * .1031); p3 += dot(p3, p3.yzx + 33.33); return fract((p3.x + p3.y) * p3.z); }\nvec2 hash22(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec2 hash23(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xx +p3.yz )*p3.zy ); }\nvec3 hash31(float p) { vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yzx +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash32(vec2 p) { vec3 p3 = fract(vec3(p.xyx ) * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy +p3.yzz )*p3.zyx ); }\nvec3 hash33(vec3 p3) { p3 = fract(p3 * vec3(.1031, .1030, .0973)); p3 += dot(p3, p3.yxz +33.33); return fract((p3.xxy + p3.yxx )*p3.zyx ); }\n\n//###############################################################################\n\n// iq's function munged for vec4, used in city shader...\n// https://www.shadertoy.com/view/XlXcW4 note: source has changed since then...\n\nvec4 hash42_( ivec2 x0 )\n{\n\tuint k = 1103515245U;  // GLIB C\n\tuvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n\tx = (( x >> 13U ) ^ x.yzwx ) * k;\n\tx = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference\n\treturn vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\n\n// integer hashes\n// https://www.shadertoy.com/view/4tXyWN iq\n\nfloat hash1u2_4tXyWN( uvec2 x )\n{\n\tuvec2 q = 1103515245U * ( ( x >> 1U ) ^ ( x.yx  ) );\n\tuint  n = 1103515245U * ( ( q.x  ) ^ ( q.y >> 3U ) );\n\treturn float( n ) * ( 1.0 / float( 0xffffffffU ) );\n}\n\n// https://nullprogram.com/blog/2018/07/31/ Chris Wellons\n// https://www.shadertoy.com/view/WttXWX via Fabrice\n\nuint lowbias32(uint x) { x ^= x >> 16; x *= 0x7feb352dU; x ^= x >> 15; x *= 0x846ca68bU; x ^= x >> 16; return x; }\nfloat hash11u_lowbias32( uint x ) { return float( lowbias32( x ) ) / float( 0xffffffffU ); }\n\n#define V30 vec2( 0.866025403, 0.5 )\n#define V45 vec2( 0.707106781, 0.707106781 )\n#define V60 vec2( 0.5, 0.866025403 )\n\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n\n// theta is angle with the z axis, range [0,pi].\n// phi is angle with x vectors on z=0 plane, range [0,2pi].\n// theta_vec is the unit vector for angle theta\n// phi_vec is the unit vector for angle phi\nvec3 zup_spherical_coords_to_vector( vec2 theta_vec, vec2 phi_vec ) { return vec3( theta_vec.y * phi_vec, theta_vec.x ); }\nvec3 zup_spherical_coords_to_vector( float theta, float phis ) { \nreturn zup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phis ) ); }\nvec3 zup_spherical_coords_to_vector( vec2 theta_phi ) { return zup_spherical_coords_to_vector( theta_phi.x, theta_phi.y ); }\n\n// note: n.xy==0 is undefined for phi, pleae handle in caller code\nvec2 vector_to_zup_spherical_coords( vec3 n )\n{\n\tfloat theta = safe_acos( n.z ); // note: vectors normalized with normalize() are not immune to -1,1 overflow which cause nan in acos\n\tfloat phis = calc_angle( n.xy  );\n\treturn vec2( theta, phis );\n}\n\nvec3 yup_spherical_coords_to_vector( vec2 theta, vec2 phis ) { return zup_spherical_coords_to_vector( theta, phis ).yzx ; }\nvec3 yup_spherical_coords_to_vector( float theta, float phis ) {\nreturn yup_spherical_coords_to_vector( unit_vector2( theta ), unit_vector2( phis ) ); }\n\n/*\nmat4 yup_spherical_coords_to_matrix( vec2 theta, vec2 phis , vec4 camRotQ, vec3 ro)\n{\n    mat3 omgSourceCamsuckedHARD=q2m(camRotQ);\n\treturn ( mat4( vec4( omgSourceCamsuckedHARD[0], 0.0 ), vec4( omgSourceCamsuckedHARD[1], 0.0 ), vec4( omgSourceCamsuckedHARD[2], 0.0 ), vec4(ro, 1 ) ) );\n}\n\n\nmat4 yup_spherical_coords_to_matrix( float theta, float phis ,vec4 camRotQ,vec3 ro) { \n\n    mat3 omgSourceCamsuckedHARD=q2m(camRotQ);\n\treturn ( mat4( vec4( omgSourceCamsuckedHARD[0], 0.0 ), vec4( omgSourceCamsuckedHARD[1], 0.0 ), vec4( omgSourceCamsuckedHARD[2], 0.0 ), vec4(ro, 1 ) ) );\n}*/\n\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\n\nmat3 mat3_rotation_x( vec2 v ) { return mat3( vec3( 1, 0, 0 ), vec3( 0, v.x, v.y ), vec3( 0, -v.y, v.x ) ); }\nmat3 mat3_rotation_z( vec2 v ) { return mat3( vec3( v.x, v.y, 0 ), vec3( -v.y, v.x, 0 ), vec3( 0, 0, 1 ) ); }\n\n// icdf for pdf a*exp(-a*x) (wikipedia Exponential distribution)\nfloat ed_icdf( float u, float a ) { return -log( 1. - u ) * ( 1.0 / a ); }\n\n#define INDEXHASHOFFSET3 vec3( 137.0, 53.0, 173 )\n\n#define LAYERED1(func,p,args) ((func(p*1.0,args)*0.5)                                                                                               *(1.0/(0.5)))\n#define LAYERED2(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25)                                                                         *(1.0/((0.5+0.25))))\n#define LAYERED4(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625)                          *(1.0/((0.5+0.25+0.125+0.0625))))\n#define LAYERED5(func,p,args) ((func(p*1.0,args)*0.5+func(p*2.0,args)*0.25+func(p*4.0,args)*0.125+func(p*8.0,args)*0.0625+func(p*16.0,args)*0.03125)*(1.0/((0.5+0.25+0.125+0.0625+0.03125))))\n\nfloat noise12( vec2 p, bool use_smooth\n){p -= 0.5\n ;vec2 p00 = floor( p )\n ;vec2 p10 = p00 + vec2( 1, 0 )\n ;vec2 p01 = p00 + vec2( 0, 1 )\n ;vec2 p11 = p00 + vec2( 1, 1 )\n ;float v00 = hash12( p00 )\n ;float v10 = hash12( p10 )\n ;float v01 = hash12( p01 )\n ;float v11 = hash12( p11 )\n ;vec2 f = fract( p ) // p-p00 but beware large values...\n ;if ( use_smooth ) f = smoothstep_unchecked( f )\n ;float A = v10 - v00\n ;float B = v01 - v00\n ;float C = ( v11 - v01 ) - A\n ;float D = v00\n ;//\treturn mix( mix( v00, v10, f.x ), mix( v01, v11, f.x ), f.y ),\n ;return A * f.x + B * f.y + C * f.x * f.y + D;}\n\nfloat noise13( vec3 p, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;float v000 = hash13( p000 )\n ;float v100 = hash13( p000 + vec3( 1, 0, 0 ) )\n ;float v010 = hash13( p000 + vec3( 0, 1, 0 ) )\n ;float v110 = hash13( p000 + vec3( 1, 1, 0 ) )\n ;float v001 = hash13( p000 + vec3( 0, 0, 1 ) )\n ;float v101 = hash13( p000 + vec3( 1, 0, 1 ) )\n ;float v011 = hash13( p000 + vec3( 0, 1, 1 ) )\n ;float v111 = hash13( p000 + vec3( 1, 1, 1 ) )\n ;vec3 f = fract( p ) // bilinear\n ;if ( use_smooth ) f = smoothstep_unchecked(f)\n ;return mix(mix(mix(v000,v100,f.x)\n                ,mix(v010,v110,f.x),f.y )\n            ,mix(mix(v001,v101,f.x)\n                ,mix(v011,v111,f.x),f.y),f.z);}\n\nvec3 noise33( vec3 p, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;vec3 v000 = hash33( p000 )\n ;vec3 v100 = hash33( p000 + vec3( 1, 0, 0 ) )\n ;vec3 v010 = hash33( p000 + vec3( 0, 1, 0 ) )\n ;vec3 v110 = hash33( p000 + vec3( 1, 1, 0 ) )\n ;vec3 v001 = hash33( p000 + vec3( 0, 0, 1 ) )\n ;vec3 v101 = hash33( p000 + vec3( 1, 0, 1 ) )\n ;vec3 v011 = hash33( p000 + vec3( 0, 1, 1 ) )\n ;vec3 v111 = hash33( p000 + vec3( 1, 1, 1 ) )\n ;vec3 f = fract( p )// bilinear\n ;if ( use_smooth ) f = smoothstep_unchecked(f) // looks sharper in 3d\n ;return mix(mix(mix(v000,v100,f.x)\n                ,mix(v010,v110,f.x),f.y)\n            ,mix(mix(v001,v101,f.x)\n                ,mix(v011,v111,f.x),f.y),f.z );}\n\nfloat enoise13( vec3 p, float a, bool use_smooth\n){p -= 0.5\n ;vec3 p000 = floor( p ) + INDEXHASHOFFSET3\n ;vec3 p100 = p000 + vec3( 1, 0, 0 );\n\tvec3 p010 = p000 + vec3( 0, 1, 0 );\n\tvec3 p110 = p000 + vec3( 1, 1, 0 );\n\tvec3 p001 = p000 + vec3( 0, 0, 1 );\n\tvec3 p101 = p000 + vec3( 1, 0, 1 );\n\tvec3 p011 = p000 + vec3( 0, 1, 1 );\n\tvec3 p111 = p000 + vec3( 1, 1, 1 );\n\tvec2 h000 = hash23( p000 );\n\tvec2 h100 = hash23( p100 );\n\tvec2 h010 = hash23( p010 );\n\tvec2 h110 = hash23( p110 );\n\tvec2 h001 = hash23( p001 );\n\tvec2 h101 = hash23( p101 );\n\tvec2 h011 = hash23( p011 );\n\tvec2 h111 = hash23( p111 );\n\tfloat v000 = ed_icdf( h000.x, a ) * h000.y;\n\tfloat v100 = ed_icdf( h100.x, a ) * h100.y;\n\tfloat v010 = ed_icdf( h010.x, a ) * h010.y;\n\tfloat v110 = ed_icdf( h110.x, a ) * h110.y;\n\tfloat v001 = ed_icdf( h001.x, a ) * h001.y;\n\tfloat v101 = ed_icdf( h101.x, a ) * h101.y;\n\tfloat v011 = ed_icdf( h011.x, a ) * h011.y;\n\tfloat v111 = ed_icdf( h111.x, a ) * h111.y;\n\tvec3 f = fract( p ); // bilinear\n\tif ( use_smooth ) f = smoothstep_unchecked(f); // looks sharper in 3d\n\treturn mix( mix( mix( v000, v100, f.x ),\n\t\t\t\t\t mix( v010, v110, f.x ), f.y ),\n\t\t\t\tmix( mix( v001, v101, f.x ),\n\t\t\t\t\t mix( v011, v111, f.x ), f.y ), f.z );}\n\n// prefix meaning: \n//  e stands for exponential distribution\n//  s stands for smoothstep interpolation\nfloat snoise12_( vec2 p, float args ) { return noise12( p, true ); }\nfloat snoise13_( vec3 p, float args ) { return noise13( p, true ); }\nvec3 noise33_( vec3 p, float args ) { return noise33( p, false ); }\nfloat enoise13_( vec3 p, float a ) { return enoise13( p, a, false ); }\nfloat sfbm1_12( vec2 p ) { return LAYERED1( snoise12_, p, -1.0); }\nfloat sfbm2_13( vec3 p ) { return LAYERED2( snoise13_, p, -1.0); }\nfloat sfbm2_13_leaf( vec3 p ) { return (noise13(p*0.8,true)+noise13(p*4.0,true)*0.6)/1.5;}\nfloat sfbm2_12( vec2 p ) { return LAYERED2( snoise12_, p, -1.0); }\nfloat efbm4_13( vec3 p, float arg ) { return LAYERED4( enoise13_, p, arg); }\nvec3 sfbm4_33( vec3 p ) { return LAYERED5( noise33_, p, -1.0); }\n\nstruct Ray {vec3 o;vec3 d;};\nRay mkray( vec3 o, vec3 d ){ Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\n\nvec3 get_view_dir( vec2 normalized_pos, float aspect, float tan_half_fovy_rcp\n){return normalize( vec3( normalized_pos.x * aspect, normalized_pos.y, -tan_half_fovy_rcp ) );} // note: looking down z\n\n//note that htis has no znear clipping\n// note that we pass the reciprocal of tan_half_fovy\n// normalized_pos is (-1,1-)->(1,1)\nRay get_view_ray2(vec2 u,float a,float f, mat4 cam//normalized_pos,aspect,tan_half_fovy_rcp,camera\n){vec3 transformed=transform_vector(cam,get_view_dir(u,a,f))\n ;return mkray(cam[3].xyz,transformed);}\n\nmat4 lookat( vec3 eye, vec3 center, vec3 up\n){vec3 z = normalize( eye - center )\n ;vec3 x = normalize( cross( up, z ) )\n ;vec3 y = cross( z, x )\n ;return mat4( vec4(x,0.), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0));}\n\nvec2 sphere_trace( Ray ray, float radius, vec3 center\n){vec3 O = ray.o\n ;vec3 d = ray.d\n ;float tp = dot( center - O, d ) // O + d * tp = center projected on line (O,d)\n ;float h_sqr = lensqr( ( O + d * tp ) - center )\n ;float radius_sqr = radius * radius\n ;if ( h_sqr > radius_sqr ) return vec2( FLT_MAX, FLT_MAX ) // ray missed the sphere\n ;float dt = sqrt( radius_sqr - h_sqr ) // distance from P to In (near hit) and If (far hit)\n ;return vec2( tp - dt, tp + dt );} // record 2 hits In, If\n\nfloat plane_trace( vec3 ray_o, vec3 ray_d, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray_d, n ); return abs( ddotn ) > epsilon ? dot( base - ray_o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace( Ray ray, vec3 base, vec3 n, float epsilon ) { float ddotn = dot( ray.d, n ); return abs( ddotn ) > epsilon ? dot( base - ray.o, n ) / ddotn : FLT_MAX; }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : FLT_MAX; }\n// d is a unit direction, ray starts at 0,0,0 base is plane position along z, this is just a division...\nfloat plane_trace_z( vec3 d, float base, float epsilon ) { return abs( d.z ) > epsilon ? base / d.z : FLT_MAX; }\n\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n// smooth bevel (like a soft_abs function)\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); return x > r ? x : her2( x, r ); }\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return smax_exp2( a, b, k ); }\nfloat opI_soft2_pol( float a, float b, float k ) { return smax_pol( a, b, k ); }\nfloat opI_weld_quadric( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_weld_quadric( a - c, r ); }\n// min(a,b) = -max(-a,-b)\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_soft2_pol( float a, float b, float k ) { return -opI_soft2_pol( -a, -b, k ); }\nfloat opU_weld_quadric( float a, float b, float r ) { return -opI_weld_quadric( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 );}\nfloat opS_soft2( float a, float b, float k ) { return opI_soft2( -b, a, k ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n\n// r can be zero\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r\n){vec2 h = ( ma - mi ) * 0.5\n ;p = abs( p - ( mi + ma ) * 0.5 )\n ;vec2 c = h - r\n ;float mask = maxcomp( step( c, p ) )\n ;return mix( maxcomp( p - c ), length( max( p - c, vec2( 0.0 ) ) ), mask ) - r;}\n\n// r can be zero\nfloat sd_bounds_range_round( vec3 p, vec3 mi, vec3 ma, float r\n){vec3 h = ( ma - mi ) * 0.5\n ;p = abs( p - ( mi + ma ) * 0.5 )\n ;vec3 c = h - r\n ;float mask = maxcomp(step( c, p ) )\n ;return mix( maxcomp( p - c ), length( max( p - c, vec3( 0.0 ) ) ), mask ) - r;}\n\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\n\nfloat sd_sphere( vec3 p, vec3 center, float radius ) { return length( p - center ) - radius; }\nfloat sd_sphere( vec2 p, vec2 center, float radius ) { return length( p - center ) - radius; }\n\n// iq's https://www.shadertoy.com/view/Xds3zN modified for z up\nfloat sdCylinder( vec3 p, vec2 h\n){vec2 d = abs( vec2( length( p.xy ),p.z)) - h\n ;return min( max( d.x, d.y ), 0.0 ) + length( max( d, vec2( 0.0 ) ) );}\n\n//length(a)==sqrt(dot(a,a))\n#define dd(a) dot(a,a)\n// internal function in packed_spheres_tiling3d\nfloat pstil(vec3 p//packed_spheres_tiling3d_internal_layer\n){vec2 rh=vec2(1.,SQR3) // r=1  (normally h = spacing*0.5 * SQR3, and here spacing=2)\n ;vec2 c=rh*2. // cell size for each row\n ;return min(\n  dd(p-vec3((floor( p.xy    /c)+vec2(.5))*c   ,0)),\n  dd(p-vec3((floor((p.xy-rh)/c)+vec2(.5))*c+rh,0)));}//second row offset by rh\n\n// sdf of packed spheres of radius 1 (just add to distance for smaller radius...)\nfloat pst(vec3 p//packed_spheres_tiling3d\n){vec3 p0 = p\n ;float h=SQR3 // height of equilateral triangle of edge len 1+1=2\n ;float b=(1.-h*h)/(2.*h)\n ;float c=h+b\n ;float h3=sqrt(4.-c*c) // height of tetrahedra, also the spacing between layers, also the half period of each layer\n ;float h6=2.*h3//-1 mult\n ;float h1=.5/h3//-1 division\n ;p = p0\n ;p.z -=(floor((p.z+h3)*h1)+.5)*h6-h3 //repeat layer\n ;float d1=pstil(p) //;return d1 //early cop out\n ;p=p0\n ;p.y+=h+b // offset to overlap centers of first layer exactly\n ;p.z-=(floor(p.z*h1)+.5)*h6 //repeat layer\n ;float d2=pstil(p)\n ;//return d2\n ;//return opU(d1,d2)\n ;return sqrt(min(d1,d2))-1.f;}\n\n// r is sphere radius, distance between 2 spheres is spacing\n// r must be < spacing/2\nfloat pst( vec3 p, float r, float s\n){s *=.5;return pst(p*(1./s))*s+(s-r);}\n\n// r is sphere radius, distance between 2 spheres is 2*r\nfloat pst( vec3 p, float r\n){return pst(p*(1./r))*r;}\n\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n\n// the couple of following functions are copied from Matt Pettineo's spherical gaussian article, \n// I liked the soft look and ease of use of SG and ended up keeping to the end\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n\nstruct SG { vec3 Amplitude; vec3 Axis; float Sharpness; };\n\n// approximate integral on omega of sg(v)dv\nvec3 ApproximateSGIntegral( in SG sg ) { return 2. * PI * ( sg.Amplitude / sg.Sharpness ); }\n\nSG CosineLobeSG(vec3 d\n){SG c;c.Axis=d;c.Sharpness=2.133f;c.Amplitude=vec3(1.17f);return c;}\n\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-3-diffuse-lighting-from-an-sg-light-source/\nvec3 SGIrradianceFitted(SG lightingLobe,vec3 normal\n){float muDotN = dot( lightingLobe.Axis, normal )\n ;float lambda = lightingLobe.Sharpness\n ;float c0 = 0.36f\n ;float c1 = 1.0f / ( 4.0f * c0 )\n ;float eml  = exp( -lambda )\n ;float em2l = eml * eml\n ;float rl   = 1.0 / lambda\n ;float scale = 1.0f + 2.0f * em2l - rl\n ;float bias  = ( eml - em2l ) * rl - em2l\n ;float x  = sqrt( 1.0f - scale )\n ;float x0 = c0 * muDotN\n ;float x1 = c1 * x\n ;float n = x0 + x1\n ;float y = saturate( muDotN )\n ;if ( abs( x0 ) <= x1 ) y = n * n / x\n ;float result = scale * y + bias\n ;return result * ApproximateSGIntegral( lightingLobe );}\n\n// what am I doing\nvec3 SGDiffuseFitted( in SG lightingLobe, in vec3 normal, vec3 albedo\n){vec3 brdf = albedo / PI\n ;return SGIrradianceFitted( lightingLobe, normal ) * brdf;}\n\n\n//#define BUFFER_MODE 0\n//the tempral reprojection of the parent shader looked bad,\n//and i hope that i can take the TR of another shader instead.\n\n// iChannel0 is always Buf A\n// iChannel1 is always Buf B\n\n// note: glsl doesn't let us write if (1), so we write if (_1), note that occasionally compiler may fail to treat that as a static branch\n#define _1 true\n#define _0 false\n\n// skip space faster above bushes (and maybe other things if proves useful)\n// notes:\n//  - at higher res we can see that causes artifacts, see the bit that sets\n//    eval.terrain_warp and tweak hack constants there\n//  - this causes artifacts on trees's tracing... close to patch borders maybe? (messes with shadows sometimes)\n//  - this messes with bush shadows even when bush surface seems unchanged (shrinks shadows a bit)\n#define TERRAIN_WARP\n\n#define FORCE_LOOP +min(0,F)\n#define FORCE_LOOPF +min(0.0,float(aFrame))\n\n#define SHADOW_TINT_SATURATION 0.45 // [0,1]\n\n#define AO _0 // nice term, visible extra cost, but doesn't contribute much, so disable \n#define SHADOWS _1\n\n#define SUN _1\n#define SUN_GLARE _0 // could be interesting but needs more work\n\n#define GROUND_OCCLUSION _1 // first sdf is ground's base level so we get occlusion\n#define PATH _1 // cost peanuts\n#define GRAS _1 // cost peanuts\n#define BUSH _1 // a bit expensive\n#define TREE _1 // super expensive\n#define FARM _1 // cost a little bit\n#define BRICKWALL _1 // cost a little bit\n\n#define TAYLOR_HEIGHT_BUSH _1\n#define TAYLOR_HEIGHT_TREE _1\n#define TAYLOR_HEIGHT_FARM _0 // object is too large, causes a little bit too much distortion\n\n#define GHOST_STEPS_PATCH _1\n#define GHOST_STEPS_TREE _1 // visible extra cost, fixes the trees, but we start hitting iteration limit\n#define GHOST_STEPS_FARM _1 // little cost (large cells) and fixes farms, hits a little bit more max iterations far away\n// about GHOST_MAX_DIST:\n// introduced a second distance for bird views\n// having 2 thresh lets us fix bird view, but they get more expensive\n#define GHOST_MAX_DIST_FROM_T0 7.0\n#define GHOST_MAX_DIST_ABS 25.0\n// fixes weird grain that happens when using second threshold that goes further away... hack hack...\n#define GHOST_EPS 0.0001\n\n#define DISPLACE_PATH _1 // a bit expensive, actually\n#define DISPLACE_PATH_AMPL 0.002\n\n#define DISPLACE_PINE _1\n#define DISPLACE_TREE _1\n#define DISPLACE_BUSH _1\n#define DISPLACE_BUSH_FREQ 8.0\n\n// CLOUD_MODE\n//  0: no cloud\n//  1: trace cloud per pixel (for debug)\n//  2: cache trace cloud in B texture every frame and use that (for debug)\n// >3: cache trace cloud in B texture only first frame and use that (same cost as no cloud)\n#define CLOUD_MODE 3\n\n// the wind doesn't have much amplitude, and movement isn't smooth enough, but reprojection hides that a bit...\n#define WIND_BUSH _1\n#define WIND_TREE_AND_PINES _1\n\n#define FARM_WINDOWS _1\n\n#define SOFT_BLEND_BUSH _1\n#define SQUARE_BUSH_TEST _1 // some farms have nicely cut bushes arounds them\n\n#define MATID_NONE       0.0\n#define MATID_BUSH       1.0\n#define MATID_TRUNK      2.0\n#define MATID_HOUSE_TOP  3.0\n#define MATID_ROOF       4.0\n#define MATID_PINE       5.0\n#define MATID_BRICKWALL  6.0\n#define MATID_GRASS      7.0\n#define MATID_GROUND     8.0\n#define MATID_TREE       9.0\n#define MATID_WINDOW    10.0\n#define MATID_HOUSE_BOT 11.0\n\n#define BROWN (vec3(133,84,57)/255.0)\n#define COLOR_PATH1 BROWN\n#define COLOR_PATH2 (BROWN*0.8)\n#define COLOR_BUSH1 (0.8*vec3(0.07,0.3,0.05))\n#define COLOR_BUSH2 (0.55*vec3(0.12,0.6,0.2))\n#define COLOR_BUSH3 (0.55*vec3(0.1,0.35,0.09))\n#define COLOR_BUSH4 (0.82*vec3(0.18,0.39,0.06))\n#define COLOR_BUSH5 vec3(0.1,0.3,0.01) // rare color\n#define COLOR_TREE1 (vec3(0.1,0.35,0.09)*0.55)\n#define COLOR_TREE2 (vec3(0.1,0.45,0.08)*0.8)\n#define COLOR_TREE_SURF vec3(0.15,0.4,0.04)\n#define COLOR_GRASS vec3(0.1,0.35,0.09)\n#define COLOR_GRASS2 vec3(0.35,0.39,0.06)\n#define COLOR_MOWED_GRASS vec3(0.17,0.37,0.05)\n#define COLOR_MOWED_GRASS2 (COLOR_MOWED_GRASS* 0.6)\n#define COLOR_PINE (vec3(0.4,1.0,0.2)*0.2)\n#define COLOR_PINE2 (vec3(0.5,1.0,0.0)*0.32)\n#define COLOR_TRUNK (BROWN*0.5)\n#define COLOR_ROOF1 (vec3(0.6,0.2,0.3)*0.7)\n#define COLOR_ROOF2 (vec3(0.1,0.4,0.5)*0.7)\n#define COLOR_BRICKWALL mix(vec3(0.52,0.33,0.22),vec3(0.9,0.9,0.7),0.35)\n#define COLOR_HOUSE mix((vec3(1,1,1)*0.65),COLOR_BRICKWALL,0.1) // white is a bit too white so blend with brickwall color\n#define COLOR_HOUSE_BOTTOM (COLOR_HOUSE*0.7)\n\nstruct CellPoint{\n\tvec2 p;\n\tivec2 _pi; // some cell index to take a hash from\n\tfloat pradius; // point radius, small points can be closer to cell edges\n};\n\n// meaning of id varies, if 32bits floats we should be able to have exact ints up to 2^24=16777216\nstruct DistanceId { float d; float id;  };\n\nDistanceId MkDistanceId( float d, float id ) { DistanceId v; v.d = d; v.id = id; return v; }\n\nDistanceId MkDistanceId_16( float d, float id, float id_fraction )\n{\n\treturn MkDistanceId( d, float( int( id ) | ( int( id_fraction * 65535.0 ) << 5 ) ) );\n}\n\nDistanceId MkDistanceId_5_5_5( float d, float id, vec3 v ){\n\treturn MkDistanceId( d, float( int( id )\n\t\t\t\t\t\t\t\t   | ( int( v.x * 31.0 ) <<  5 )\n\t\t\t\t\t\t\t\t   | ( int( v.y * 31.0 ) << 10 )\n\t\t\t\t\t\t\t\t   | ( int( v.z * 31.0 ) << 15 ) ) );}\n\nvec2 DecodeId_16( DistanceId di ){\n\tint i = int( di.id );\n\treturn vec2( float( i&31 ), float( i >> 5 ) * ( 1.0 / 65535.0 ) );}\n\nfloat DecodeId( DistanceId di ){\n\tint i = int( di.id );\n\treturn float( i&31 );}\n\nvec4 DecodeId_5_5_5( DistanceId di ){\n\tint i = int( di.id );\n\treturn vec4( float( i&31 )\n\t\t\t\t , float( ( i >>  5 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 10 ) & 31 ) * ( 1.0 / 31.0 )\n\t\t\t\t , float( ( i >> 15 ) & 31 ) * ( 1.0 / 31.0 ) );}\n\n#if 0 \n// bogus build error on ? : in shadertoy\nDistanceId opUdi( DistanceId a, DistanceId b ) { return a.d < b.d ? a : b; }\n#else\nDistanceId opUdi( DistanceId a, DistanceId b ) { if ( a.d < b.d ) return a; return b; }\n#endif\n\n// some rough scale for the roads pattern\n// you need to tweak x spacing and y spacing of path slabs\n// and the x and y scale of the main path function\n#define LANEWIDTH 0.08\n\n// 0: sin waves\n//>1: sin waves with flat sections (default)\n// 2: constant (straight lines, rectangular layout)\n// 3: smooth noise\n#define LANE_FUNC 1\n\nvec2 PathNoise11sD( float x ){\n\tx -= 0.5;\n\tfloat fr = fract( x );\n\tint x0 = int( x - fr );\n\tuint i = uint( x0 );\n\tfloat y0 = hash11u_lowbias32( i );\n\tfloat y1 = hash11u_lowbias32( i + 1u );\n\tfloat f = smoothstep_unchecked( fr );\n\tfloat fd = smoothstep_unchecked_d( fr );\n\treturn vec2( mix( y0, y1, f ), ( y1 - y0 ) * fd );}\n\n// return lane's (y,y'), called a lot so make it cheap (this *does not* return world space y coord)\nvec2 wavyLaneFuncAndDerivative( float x, float lane_index\n#if LANE_FUNC==0\n){float a = mix( 0.5, 1.7, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\treturn vec2( ( sin( a * x ) + 1.0 ) * 0.5, 0.5 * a * cos( a * x ) );}\n#elif LANE_FUNC==1\n){// sin wave with soft straight sections so it's just all curvy\n\tfloat a = mix( 0.9, 2.0, ( 1.0 + cos( lane_index ) ) * 0.5 ); // per lane constant\n\tfloat z = ( 1.0 + sin( x * a ) ) * 0.5;\n\treturn vec2( z * z, a * z * cos( a * x ) );}\n#elif LANE_FUNC==2\n){return vec2( 0.5, 0 );}\n#else //LANE_FUNC==3\n){return PathNoise11sD( x - lane_index * 80.0 );}\n#endif\n\n\n#define PATH_SPACING_Y 1.0\n// used by camera, don't forget to offset by lane_index (regular wavyLaneFuncAndDerivative() doesn't care!)\nvec2 wavyLaneFuncAndDerivative_WORLD( float x, float l\n){return wavyLaneFuncAndDerivative(x,l)+vec2(l*PATH_SPACING_Y, 0 );}\n\n// this macro returns:\n//  - the vector to the closest point on a curve (the length of which gives a better distance than FAST_SIGNED_DISTANCE_TO_FUNC_11) \n//  - the tangent at that closest point\n// http://www.geometrie.tugraz.at/wallner/sproj.pdf\n// input:\n//  a_p               eval at pos\n//  a_funcd           is the R->R function to evaluate, first guess (iteration start point) is vec2(a_p.x,a_func(a_p.x))\n//                    a_funcd can be a macro, it seems\n//                    returns the function value at t in .x and the derivative at t in .y\n//  a_funcd_arg       an argument passed to a_func\n//  a_cheap           num iterations, 2 should be enough, a_cheap==true only does 1 iteration\n//\n// output:\n//  a_ret   \t\t  a_ret.xy is vector to closest point on curve\n//                    a_ret.zw is the derivative (tangent at the closest point)\n//\n// note: we could get the sign from the first iteration\n\n\n#define CLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( a_ret, a_p, a_funcd, a_funcd_arg, a_cheap ) \\\n{ \\\n\tvec2 _p = a_p.xy, _c, _dc, _ev; \\\n\tfloat _t = _p.x; /* t0, could be a parameter if the user knows better */ \\\n\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t_c = vec2( _t, _ev.x ); \\\n\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\tif ( !(a_cheap) ) /* IMPORTANT: if num iteration is 2, an if test can behave much better than for loop */ \\\n\t{ \\\n\t\t/*#if 0*/ \\\n\t\t/*vec2 _q = project_on_line( _p.xy, _c, _dc );*/ \\\n\t\t/*_t += dot( _dc, _q - _c ) / dot( _dc, _dc );*/ \\\n\t\t/* simplifies to: */ \\\n\t\t/*#else*/ \\\n\t\t_t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); \\\n\t\t/*#endif*/ \\\n\t\t_ev = a_funcd( _t, a_funcd_arg ); \\\n\t\t_c = vec2( _t, _ev.x ); \\\n\t\t_dc = vec2( 1.0, _ev.y ); /*important: 1 in x!*/ \\\n\t} \\\n\ta_ret = vec4( _c - _p, _dc ); \\\n}\n\n// return vector to closest point in .xy, derivative there in .zw\n// use cheap when you don't care about accurate distance or closest point\nvec4 sdWavyLane( vec2 p, float lane_index, bool cheap )\n{\n\tvec4 ret;\n\tCLOSEST_POINT_TANGENT_TO_FUNCD_11_ARG_CHEAP( ret, p, wavyLaneFuncAndDerivative, lane_index, cheap )\n\treturn ret;\n}\n\nstruct SceneIn\n{\n\t// constant during trace:\n//\tvec3 o;\n\tvec3 v;\n\tvec3 v_rcp; // for cell boundaries\n\tint trace_flags; // we can skip material related calculations during the traversal and enable only on shade\n\t// varying during trace:\n\tvec3 p;\n\tfloat t0; // warp start to hmax\n\tfloat t;\n};\n\nstruct ClosestPath\n{\n\tDistanceId patch_di; // patch id and distance (which is also the distance to paths)\n\tvec2 v2closest; // vector to closest patch boundary point, in world coords\n\tfloat curve_local_param; // the curve parameter, p.x in the local curve distance eval, so we can parametrixe space for making walls etc\n\t\t\t\t\t   // (since the path uses x and y directions we need to know which was used)\n};\n\nvec2 GetLocalCurvePoint( ClosestPath path ) { return vec2( path.curve_local_param, length( path.v2closest ) ); }\n\n// spacing must be >= 1 for the band to work\nClosestPath EvalClosestPathSlab( vec2 p, float spacing, bool cheap ){\n\tfloat id1 = floor( p.y / spacing );\n\tp.y = p.y - id1 * spacing;\n\tvec4 c1 = sdWavyLane( p, id1, cheap ); // should return in 0,spacing\n\tfloat d1 = cheap ? abs( c1.y ) : length( c1.xy );\n\tfloat s1 = sign( c1.y ); // this tells us if are above or below the curve (which adjacent curve to eval)\n\n\tfloat id2 = id1 - s1; // find the other 1d lane of the slab we are in: next or prev\n\tvec4 c2 = sdWavyLane( p + vec2( 0, s1 * spacing ), id2, cheap );\n\tfloat d2 = cheap ? abs( c2.y ) : length( c2.xy );\n\tfloat s2 = sign( c2.y );\n\n\tfloat m = s2 < 0.0 ? id1 : id1 - s1;\n\n\tClosestPath eval;\n\tif ( d1 < d2 ) { eval.patch_di.d = d1; eval.v2closest = c1.xy; }\n\telse           { eval.patch_di.d = d2; eval.v2closest = c2.xy; }\n\teval.patch_di.id = m;\n\teval.curve_local_param = p.x;\n\treturn eval;}\n\n// the lane curve is evaluated 4 times (twice per axis)\nClosestPath EvalClosestPath( vec2 p, bool cheap ){\n\t// horizonal lanes\n\t// PATH_SPACING_Y must be >= 1 for the band to work\n\tClosestPath ev1 = EvalClosestPathSlab( p, PATH_SPACING_Y, cheap );\n\n\t// vertical lanes\n\t// each horizontal stab can call a different set of vertical lanes which generates complex patterns\n\tvec2 p2 = perp( p ); // 90 degrees\n\t// important: spacing2 must be >= 1 for the band to work\n\tfloat spacing2 = ( 1.0 + 4.0 * ( sin( ev1.patch_di.id * 10.0 ) + 1.0 ) * 0.5 ); // spacinf of vertical lane can differ per horizontal stab which is key to complex branching patterns\n\tClosestPath ev2 = EvalClosestPathSlab( p2, spacing2, cheap );\n\tev2.v2closest = -perp( ev2.v2closest ); // put v2closest back to world coords (-90 degrees)\n\n\tClosestPath eval = ev1;\n\teval.patch_di.id *= ev2.patch_di.id; // get a unique id for this patch\n\tif ( ev2.patch_di.d < ev1.patch_di.d )\t{\n\t\teval.patch_di.d = ev2.patch_di.d;\n\t\teval.v2closest = ev2.v2closest;\n\t\teval.curve_local_param = ev2.curve_local_param;\t}\n\treturn eval;}\n\n// I hope you like magic constant\n#define MAX_TERRAIN_HEIGHT 0.74\n#define TALLEST_OBJECT_HEIGHT 0.645\n\nfloat sin_bumps_array( vec2 p ) { return sin( p.x ) * sin( p.y ) + 1.0; }\n\n// this function is called a lot so pick something simple\nfloat BaseGroundHeight( vec2 p  ){\n\tfloat h = sin_bumps_array( p.xy * ( 0.16 * PI ) ) * 0.5;\n\treturn h * h * MAX_TERRAIN_HEIGHT;} // sinbumps as is is too bumpy everywhere, we need also flatter areas, so square h\n\n\n// image was blue point juniper... end result is noise vomit\nfloat pine_tree_cross_section( float x, vec2 rh ) { x /= rh.y; return cubicbump( x, 3.0, -0.98 ) * rh.x; }\nfloat sdRevolutionPine( vec3 p, float r, float h ){\n\tvec2 p2d = vec2( ( p.z ), length( p.xy ) );\n\tif ( p2d.x >= h ) return length( p2d - vec2( h, 0 ) ); // don't forget to deal with endpoints...\n\tif ( p2d.x <= 0.0 ) return length( p2d - vec2( 0, 0 ) );\n\tfloat d; // note: we could use FAST_SIGNED_DISTANCE_TO_FUNCD_11_ARG but function is relatively cheap to eval so\n\tFAST_SIGNED_DISTANCE_TO_FUNC_11_ARG( d, p2d, pine_tree_cross_section, vec2( r, h ), 1e-3 );\n\treturn d;} // note: this is already signed\n\nvec3 ApplyWind( vec3 pd, float aTime ) { return vec3( sin( aTime * 0.8 + pd.zx ) * 0.0003, 0 ); }\n\nfloat ddPineSurfLayer( vec3 p ){\n\tp *= 400.0;\n\tp.z *= 0.25;\n\tp.xy = rotate_with_angle( p.xy, p.z * 0.11 );\n\treturn ( ( tri_sin( p.x ) + tri_sin( p.y ) + tri_sin( p.z ) ) + 3. ) * ( 1. / 6. );} // normalize to 0,1\n\n\nfloat ddPineSurf( vec3 p ){\n\treturn ( ddPineSurfLayer( p ) + ddPineSurfLayer( vec3( rotate_with_angle( p.xy, 0.5 ), p.z ) * 0.5 ) )\n\t\t   * ( 1. / ( 2.5 ) );} // normalize to 0,1\n\n\nfloat sdDisplacePine( vec3 p, float d, float uheight ){\n\tif ( !DISPLACE_PINE ) return d;\n\tfloat dd_amp = 0.018;\n\tif ( d > dd_amp ) return d;\n\tdd_amp *= ddPineSurf( p );\n\treturn d + dd_amp;}\n\n#define TRACE_VIEW 1\n#define TRACE_SHADE 2\n#define TRACE_AO 4\n#define TRACE_SHADOW 16\n#define TRACE_HAS_DIRECTION 64 // note: it is faster to check flags than checking for v_rcp == 0 or whatnot (that might not been resolved to static)\n\nbool IsShadeTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADE ) != 0; }\nbool IsShadowTrace( int trace_flags ) { return ( trace_flags & TRACE_SHADOW ) != 0; }\nbool HasDirection( int trace_flags ) { return ( trace_flags & TRACE_HAS_DIRECTION ) != 0; }\n\nDistanceId sdTreeLeaves( vec3 p, vec2 c, float cz, float trunk_height\n\t\t\t\t\t\t , float leaves_volume_base_radius\n\t\t\t\t\t\t , float leaves_volume_top_radius\n\t\t\t\t\t\t , int trace_flags\n\t\t\t\t\t\t , float color_rnd ){\n\tfloat d = FLT_MAX;\n\tvec3 c0 = vec3( c, cz + trunk_height * 0.7 );\n\tvec3 c1 = vec3( c, cz + trunk_height );\n\tfloat d0 = length( p - c0 ) - leaves_volume_base_radius;\n\tfloat d1 = length( p - c1 ) - leaves_volume_top_radius;\n\t// soft blend between 2 sphere for the base leaves volumes\n\tfloat k = leaves_volume_base_radius * 0.4;\n\td = opU_soft2_pol( d0, d1, k );\n//\treturn MkDistanceId( d, MATID_TREE );\n#define TREE_SDD 0.02 // upper bound for  amplitude of fine displacement on pines and trees\n\tfloat dd1 = 0.007;\n\tif ( d > dd1 + TREE_SDD ) return MkDistanceId( d, MATID_TREE ); // massive saving. only consider envelope displacement when we are close\n\tfloat d_envelope = d;\n\tbool blend = _1;\n\tfloat depth = 0.0;\n\tfloat uheight = 0.0;\n\tif ( _1 )\t{\n\t\t// make the leaves volume more bubbly by using 2 layers of *packed* 3d spheres regular tiling (non packed doesn't work well)\n\t\t// see @Shane's cellular tiling shaders/comments\n\n\t\tmat3 m3 =\n\t\t\tmat3_rotation_x( unit_vector2( radians( c.x * 200. ) ) ) *\n\t\t\tmat3_rotation_z( unit_vector2( radians( c.y * 200. ) ) );\n\n\t\tfloat dl1;\t\t{\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.3;\n\t\t\tfloat da1 = pst( p * m3, c1, c1 * 2.5 ); // more spacing gives more clustering/bumpiness\n\t\t\tda1 += smoothstep( cz + trunk_height * 0.75, cz + trunk_height, p.z ) * 0.007;\n\t\t\tdl1 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.3 )\n\t\t\t\t: opI( d_envelope, da1 );\t\t}\n\n\t\tfloat dl2;\t\t{\n\t\t\t// note: the second packed_spheres_tiling3d could just be global and evaluated 1 for the 3 trees\n\t\t\tfloat c1 = leaves_volume_base_radius * 0.4;\n\t\t\tfloat da1 = pst( m3 * p, c1, c1 * 2.5 );\n\t\t\tdl2 = blend\n\t\t\t\t? opI_weld_quadric( d_envelope, da1, leaves_volume_base_radius * 0.25 )\n\t\t\t\t: opI( d_envelope, da1 );\t\t}\n\n\t\tfloat d_leaf_clusters = blend\n\t\t\t? opU_weld_quadric( dl1, dl2, leaves_volume_base_radius * 0.1 )\n\t\t\t: opU( dl1, dl2 );\n\n\t\td = blend\n\t\t\t? opU_weld_quadric( d_leaf_clusters, d_envelope + 0.02, leaves_volume_base_radius * 0.19 )\n\t\t\t: d_leaf_clusters;\n\n\t\tdepth = saturate( 1.0 / ( 1. + abs( d - d_envelope ) * 100. ) );\n\t\t\n\t\tfloat b = c0.z - leaves_volume_base_radius; // bottom most-ish\n\t\tfloat t = c1.z + leaves_volume_top_radius; // topmost-ish\n\t\tuheight = saturate( ( p.z - b )/( t - b ) ); // a 0-1 normalized height value for shading\n\t}\n\n\tif ( _1 )\t{\n\t\t// clip leaves volume's bottom with a wavy surface so it's not spherical things everywhere\n\t\tfloat clipsurf = ( ( c0.z - leaves_volume_base_radius * .6 )\n\t\t\t\t\t\t   + leaves_volume_base_radius * 0.1\n\t\t\t\t\t\t   * ( sin_bumps_array( p.xy * ( 13.0 * PI ) ) - 2.4 ) );\n\t\td = blend\n\t\t\t? opI_weld_quadric( d, -( p.z - clipsurf ), leaves_volume_base_radius * 0.15 )\n\t\t\t: opI( d, -( p.z - clipsurf ) );\t}\n\n\treturn MkDistanceId_5_5_5( d, MATID_TREE, saturate( vec3( depth, uheight, color_rnd ) ) );}\n\n// retrieve terrain height, using full eval or taylor expansion\nfloat CalcHeight( vec2 c, vec2 p, vec3 h_gradval, bool taylor_expansion_height ){\n\treturn taylor_expansion_height\n\t\t   ? h_gradval.z + dot( h_gradval.xy, c - p ) // h(p)=h(c)+(c-h).grad(c): taylor expansion to skip height evaluations \n\t\t   : BaseGroundHeight( c );}\n\nDistanceId sdGridObj_TreeOrPine( DistanceId di\n\t\t\t\t\t\t\t\t , vec3 p\n\t\t\t\t\t\t\t\t , CellPoint cr\n\t\t\t\t\t\t\t\t , float radius_fraction\n\t\t\t\t\t\t\t\t , float patch_id\n\t\t\t\t\t\t\t\t , inout vec3 color\n\t\t\t\t\t\t\t\t , SceneIn scenein\n\t\t\t\t\t\t\t\t , vec3 h_gradval, bool taylor_expansion_height ){\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\t// doesn't save enough vs extra test cost\n\tif ( HasDirection( scenein.trace_flags ) )\n\t{\n\t\tvec2 n = perp( scenein.v.xy );\n\t\tvec2 o = scenein.o.xy;\n\t\tvec2 pp = project_on_plane( c, o, n );\n\t\tif ( lensqr( p.xy - pp ) > r * r ) return di;\n\t}\n#endif\n\tvec4 hhh = hash42_( cr._pi * 123 );\n\tvec3 tree_base_point = vec3( c, cz );\n\n\tfloat pine_dice_roll = hhh.x;\n\tfloat pine_probability = 0.7;\n\t\n\tif ( _1 && ( pine_dice_roll > pine_probability) )\n\t{\n\t\tfloat pine_radius_scale = mix( 0.65, 0.75, hhh.w ) * r;\n\t\tfloat pine_height = mix( 0.42, 0.56, hhh.z * hhh.z );\n\t\tfloat uheight = saturate( ( p.z - cz ) / pine_height );\n\t\tDistanceId pine_tree = MkDistanceId_5_5_5( \n\t\t\tsdDisplacePine( p - tree_base_point\n\t\t\t\t\t\t\t, sdRevolutionPine( p - tree_base_point, pine_radius_scale, pine_height ), uheight )\n\t\t\t, MATID_PINE, vec3( 0.0, uheight, ( ( hhh.x - pine_probability ) * ( 1.0 / ( 1.0 - pine_probability ) ) ) ) );\n\t\treturn opUdi( di, pine_tree );\n\t}\n\n\thhh.x *= 1.0/pine_probability; // back into [0,1]\n\tfloat aa = mix( 0.018, 0.012, hhh.y ); // trunk\n\tfloat trunk_height = aa * ( 1.1 * 1.0 / 0.018 ) * mix( 0.2, 0.35, hhh.z * hhh.z );\n\tfloat trunk_radius = aa * 0.8;\n\tfloat leaves_volume_top_radius = mix( 0.5, 0.7, hhh.w ) * r;\n\tfloat leaves_volume_base_radius = mix( 1.1, 1.35, hhh.y ) * leaves_volume_top_radius;\n\tDistanceId leaves = sdTreeLeaves( p, c, cz, trunk_height, leaves_volume_base_radius, leaves_volume_top_radius, scenein.trace_flags, hhh.x );\n\tfloat trunk_uheight = saturate( ( p.z - cz ) / trunk_height );\n\ttrunk_radius *= mix(0.8,1.2,pow2(1.0-saturate(trunk_uheight*3.5)));\n\tDistanceId trunk = MkDistanceId( sdCylinder( p - tree_base_point, vec2( trunk_radius, trunk_height ) ), MATID_TRUNK );\n\tif ( trunk.d < 0. ) leaves = trunk; // horrible hack to force trunk to be trunk inside leaves, as the leaves sdf has been hacked to death and union doesn't quite work anymore\n\treturn opUdi( di, opUdi( trunk, leaves  ) );\n}\n\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); return min( a1 * x, a2 * ( x - p ) ); }\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return 0.1 * hard_waves( p.y, 0.3, -1.1, 0.024 ) + 0.001 * ( 1.0 - pow2( 1.0 - abs( sin( p.x * 200. ) ) ) ); }\n\nstruct WindowOrDoorArg{\n\tvec2 c; // cellsize\n\tvec2 g; // num cells\n\tfloat frame_width, border_height, border_depth, glass_depth, frame_depth;};\n\nvoid sdOneWindow( vec3 p, inout DistanceId eval, WindowOrDoorArg args ){\n\tfloat d_in = eval.d;\n\tvec2 c = args.c;\n\tvec2 g = args.g - vec2( 1 );\n\tp.x += ( args.g.x * 0.5 - 0.5 ) * c.x; // center on x...\n\tvec2 pmin = -c.xy * 0.5;\n\tvec2 pmax = c.xy * ( vec2( 0.5 ) + g );\n\t// window glass and frame\n\tvec3 pr = p;\n\tvec2 i = floor( ( pr.xy - ( -c * 0.5 ) ) / c ); // c the cell size\n\ti = clamp( i, vec2( 0, 0 ), g );\n\tpr.xy -= i * c;\n\tfloat d_glass = sd_bounds_half_size( pr, vec3( c * 0.5 - vec2( args.frame_width ) * 0.5, args.glass_depth ) );\n\teval.d = opS( eval.d, d_glass );\n\t// window general frame\n\tfloat d_frame = sd_bounds_range( p, vec3( pmin, -args.frame_depth ), vec3( pmax, args.frame_depth ) );\n\teval.d = opS( eval.d, d_frame ); // make the whole window sink a bit\n\t// window border\n\tif ( _1 ) eval.d = opI( d_in - args.border_depth // clamp vs inflated version of source block we are decorating\n\t\t\t\t\t\t\t, opU( eval.d\n\t\t\t\t\t\t\t\t   , sd_bounds_range( p\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmin.x, pmin.y - args.border_height, 0 )\n\t\t\t\t\t\t\t\t\t\t\t\t\t  , vec3( pmax.x, pmin.y, args.border_depth ) ) ) );\n\tif ( -d_glass == eval.d ) eval.id = MATID_WINDOW;}// we used opS so we need -d_glass\n\n\nvoid addWindow( inout DistanceId eval, vec3 p, float is_chimney_face, float half_wall_width ){\n\tp.y += 0.016; // adjust windows height\n\tvec2 c = vec2( 0.07*mix(1.8,1.0,is_chimney_face), 0.07 ); // tile size\n\tvec2 window_size = vec2( 0.018, 0.02 ); // size of the object inside each tile, must be smaller than c\n\tfloat d_glass = FLT_MAX;\n\tvec2 i = floor( ( p.xy - ( -c.xy * 0.5 ) ) / c.xy ); // c the cell size\n\tfloat maxnum_cells = floor( (half_wall_width / c.x) - 0.5 ); // max num window that fit on this wall, assume p.x centered\n\tivec2 imin = ivec2( -maxnum_cells, 1 );\n\tivec2 imax = ivec2(  maxnum_cells, 1 );\n\ti = clamp( i, vec2(imin), vec2(imax) );\n\tp.xy -= i * c;\n\tWindowOrDoorArg args;\n\targs.c = window_size; // cellsize\n\targs.g = mix( vec2( 2, 2 ), vec2( 2, 2 ), is_chimney_face ); // window glass grid size\n\tfloat scl = 0.012;\n\targs.frame_width = 0.05 * scl;\n\targs.border_height = 0.3 * scl;\n\targs.border_depth = 0.2 * scl; // can't be bigger than d_house_bottom_inset\n\targs.glass_depth = 0.3 * scl;\n\targs.frame_depth = 0.1 * scl;\n\tsdOneWindow( p, eval, args );}\n\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2yface( vec3 p, vec2 orig ) { p.y = abs( p.y ); p.xy -= orig; p.xzy = p.xyz; p.x = -p.x; return p; }\n// convert point p to y=0 face local point, a is a plane base3d/origin2d point\nvec3 p2xface( vec3 p, vec2 orig ) { p.x = abs( p.x ); p.xy -= orig; return p.yzx; }\n\n// note: tracing detail doesn't always work very well on heightfields so z proj/triplanar type of mapping isn't great for roof\n// instead we do more tedious evals, building roof local points + 3d detail on that etc\nDistanceId sdFarm( vec3 p, CellPoint cr,float patch_id,float r, float detail ){\n\tvec4 hh = hash42_( cr._pi);\n\tbool has_chimney = hh.y > 0.4;\n\tbool _x2chimney = _1;\n\tvec2 hs1 = vec2( 0.25, 0.083 );\n\tvec2 hs2 = vec2( 0.083, 0.18+hh.z*0.02 );\n\tfloat h = 0.0996;\n\tfloat bottom_block_inset = 0.00498;\n\tfloat bottom_block_inset2 = bottom_block_inset*(has_chimney?0.0:1.0);\n\tfloat roof_thickness = 0.00166;\n\tfloat chimney_side_len = 0.018+hh.z*0.002; // chimney side length\n\tfloat chimney_height = h + hs1.y + chimney_side_len;\n\tfloat chimney_bottom = h + hs1.y - 0.04;\n\tfloat roof_tile_scl = 2.5; \n\tfloat roof_tile_scl2 = 1.1; \n\tbool half_hipped = hh.z>0.5;\n\tfloat bottom_inflate = 0.001;\n\tvec2 hs1_in = hs1 - vec2( bottom_block_inset2, bottom_block_inset );\n\tvec2 hs2_in = hs2 - vec2( bottom_block_inset );\n\t// symmetric window plane\n\tfloat block1_chimney_wall_plane_x = hs1_in.x;\n\tfloat block1_wall_plane_y = hs1_in.y;\n\tfloat block2_wall_plane_y = hs2_in.y;\n\tvec3 ps = p; // store signed p\n\tvec3 pay = p; pay.y = abs( pay.y ); // symmetric around y\n\tvec3 pax = p; pax.x = abs( pax.x ); // symmetric around x\n\tfloat d_block1_bottom = FLT_MAX;\n\tfloat d_block1_roof = FLT_MAX;\n\tfloat d_block1_bottom2 = FLT_MAX;\t{\n\t\t// --- gable roof, 2 planes (v-shaped)\n\t\tbounds2 block1 = mkbounds_unchecked( -hs1, hs1 );\n\t\tfloat d_block1_footprint = sd_bounds_range( p.xy, block1.pmin.xy, block1.pmax.xy );\n\t\tvec3 roof1_top_point = vec3( hs1.x, 0, h + hs1.y );\n\t\t// p.yz is the gable roof cross section space point\n\t\tvec3 roof_plane_local_p = vec3( -dot( pay.yz - roof1_top_point.yz, perp( V45 ) ), p.x, dot( pay.yz - roof1_top_point.yz, V45 ) );\n\t\td_block1_bottom = opI( roof_plane_local_p.z, d_block1_footprint );\n\t\td_block1_bottom = opI( d_block1_bottom, pay.y -hs1_in.y );\n\t\td_block1_bottom = opI( d_block1_bottom, pax.x - block1_chimney_wall_plane_x );\n\t\td_block1_bottom = opI( d_block1_bottom, roof_plane_local_p.z + 0.002 );\n\t\t// add tile detail to gabble roof, hacky mess to be sorted\n\t\td_block1_roof = roof_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof_plane_local_p.yx * roof_tile_scl )* roof_tile_scl2;\n\t\td_block1_roof = opS( d_block1_roof, roof_plane_local_p.z + 0.002 );\n\t\td_block1_roof = opI( d_block1_roof, d_block1_footprint );\n\t\td_block1_bottom2 = opI(d_block1_footprint-bottom_inflate,p.z);\t}\n\tfloat d_chimney = FLT_MAX;\n\tif ( has_chimney )\t{\n\t\tvec2 chimney_c = vec2( hs1_in.x, 0 );\n\t\tbounds2 chimney_footprint_b = mkbounds_unchecked( chimney_c - vec2( chimney_side_len ), chimney_c + vec2( 0, chimney_side_len * 0.5 ) );\n\t\tfloat d_chimney_footprint = sd_bounds_range( _x2chimney ? abs( p.xy ) : p.xy, chimney_footprint_b.pmin.xy, chimney_footprint_b.pmax.xy );\n\t\td_chimney = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z -chimney_height ) );\n\t\tfloat d_chimney_hole = opI( chimney_bottom - p.z, opI( d_chimney_footprint, p.z - chimney_height * 1.5 ) ) + 0.002;\n\t\td_chimney = opS( d_chimney, d_chimney_hole );\t}\n\tfloat d_block2_roof = FLT_MAX;\n\tfloat d_block2_bottom = FLT_MAX;\n\tfloat d_block2_bottom2 = FLT_MAX;\n\tif ( hh.x > 0.4 )\t{\n\t\t// --- hipped roof\n\t\tbounds2 block2 = mkbounds_unchecked( -hs2, hs2 );\n\t\tfloat d_block2_footprint = sd_bounds_range( p.xy, block2.pmin.xy, block2.pmax.xy );\n\t\t//return d_block1_roof;\n\t\td_block2_bottom = opI( d_block2_footprint + bottom_block_inset, ( p.z - h ) ); // block2 is inset equally on x and y \n\t\td_block2_bottom2 = opI(d_block2_footprint-bottom_inflate,p.z);\n\t\t\n\t\t//return d_block2_bottom;\n\t\tvec3 roof2_corner_point = vec3( hs2, h );\n\t\tvec3 roof2a_plane_local_p = vec3( p.y, -dot( pax.xz - roof2_corner_point.xz, perp( V45 ) ),dot( pax.xz - roof2_corner_point.xz, V45 ) );\n\t\tfloat roof2detail_a = roof2a_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2a_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\t// like the s1 one, exactly. just offset, can we factorize?\n\t\tvec3 roof2b_plane_local_p = vec3( p.x, -dot( pay.yz - roof2_corner_point.yz, perp( V45 ) ),dot( pay.yz - roof2_corner_point.yz, V45 ) );\n\t\tfloat roof2detail_b = roof2b_plane_local_p.z - detail*hf_SurfaceRoofTiles( roof2b_plane_local_p.xy * roof_tile_scl ) * roof_tile_scl2;\n\t\td_block2_roof = opI( roof2b_plane_local_p.z, roof2a_plane_local_p.z );\n\t\td_block2_roof = opI( roof2detail_a, roof2detail_b );\n\n\t\tif ( half_hipped )\t\t{\n\t\t\td_block2_roof = opI( d_block2_roof, p.y );\n\t\t\td_block2_bottom = opI( d_block2_bottom, p.y );\n\t\t\td_block2_bottom2 = opI( d_block2_bottom2, p.y );}}\n\tDistanceId bb1 = MkDistanceId( d_block1_bottom, MATID_HOUSE_TOP );\n\tDistanceId bb2 = MkDistanceId( d_block2_bottom, MATID_HOUSE_TOP );\n\tif ( FARM_WINDOWS )\t{\n\t\taddWindow( bb1, p2xface( p, vec2( hs1_in.x, 0.0 ) ), 1., hs1_in.y );\n\t\taddWindow( bb1, p2yface( p, vec2( 0, hs1_in.y ) ), 0., hs1_in.x );\n\t\taddWindow( bb2, p2yface( p, vec2( 0, hs2_in.y ) ), 0., hs2_in.x );\t}\n\tDistanceId roof_eval = MkDistanceId( opI( h - p.z, opU( d_block1_roof, d_block2_roof ) ), MATID_ROOF );\n\tDistanceId bottom_eval = MkDistanceId( d_chimney, MATID_HOUSE_TOP );\n\tbottom_eval = opUdi( bottom_eval, bb1 );\n\tbottom_eval = opUdi( bottom_eval, bb2 );\n\tDistanceId bottom2_eval = MkDistanceId( opU( d_block1_bottom2, d_block2_bottom2 ), MATID_HOUSE_BOT );\n\treturn opUdi( opUdi( roof_eval, bottom_eval ), bottom2_eval );}\n\nDistanceId sdGridObj_Farm( DistanceId di\n\t\t\t\t\t\t   , vec3 p\n\t\t\t\t\t\t   , CellPoint cr\n\t\t\t\t\t\t   , float radius_fraction\n\t\t\t\t\t\t   , float patch_id\n\t\t\t\t\t\t   , inout vec3 color\n\t\t\t\t\t\t   , SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval, bool taylor_expansion_height ){\n\tvec2 c = cr.p;\n\tfloat r = radius_fraction * cr.pradius;\n\tfloat cz = CalcHeight( cr.p, p.xy, h_gradval, taylor_expansion_height );\n\t\n\tif ( _0 && ( ( length( p - vec3( c, cz ) ) - cr.pradius ) > di.d ) ) return di; // CULL\n#if 0\n\tif ( HasDirection( scenein.trace_flags ) \n\t\t && ( sphere_trace( mkray( scenein.p, scenein.v ), r, vec3( c, cz ) ).x == FLT_MAX ) )\t{\n\t\treturn di;\t}\n#endif\n\t// orient farm along terrain gradient to reduce sinking cases\n\tvec2 e = vec2( 1e-3, 0 );\n\tvec2 h_gradval_at_c = ( vec2( BaseGroundHeight( c.xy + e.xy ),\n\t\t\t\t\t\t\t\t  BaseGroundHeight( c.xy + e.yx ) ) - vec2( cz ) ) / e.x; // be careful to not divide by e since it has zero in .y\n\tfloat grad_len = length( h_gradval_at_c );\n\t#define FARMS_GRAD_LIMIT   _1 // don't place farms when slope is too strong\n\t#define FARMS_GRAD_ELEVATE _1 // elevate house so they don't sink into the ground, using the gradient\n\t#define FARMS_GRAD_ALIGN   _1 // align farm with terrain gradient instead of random rotation\n\tif ( FARMS_GRAD_LIMIT && ( grad_len > 0.17 ) ) return di;\n\tif ( FARMS_GRAD_ELEVATE ) cz += r * grad_len * 0.65;\n\t// move to local coords\n\tp.xy -= c;\n\tp.z -= cz;\n\tp.xy = rotate_with_unit_vector( p.xy, FARMS_GRAD_ALIGN && ( grad_len > 0.01 )\n\t\t\t\t\t\t\t\t\t? normalize( h_gradval_at_c ) \n\t\t\t\t\t\t\t\t\t: unit_vector2( hash1u2_4tXyWN( uvec2(cr._pi) ) * 2.0 * PI ) ); // random rotation\n\n\tif ( _0 ) return MkDistanceId( sd_sphere( p, vec3( 0 ), r ), MATID_HOUSE_TOP ); // try make the building fit inside the sphere\n\n\tDistanceId eval = sdFarm( p, cr,patch_id, r, 1.0 );\n\t\n\tif ( IsShadeTrace( scenein.trace_flags ) && ( DecodeId( eval ) == MATID_ROOF ) )\t{\n\t\teval = MkDistanceId_16( eval.d, MATID_ROOF, hash11( patch_id ) );\t} // same roof color for all houses in patch\n\treturn eval;}\n\nfloat sdBrickWall( vec3 p, ClosestPath path, float h\n){\tfloat wall_start_dist = LANEWIDTH * 0.5 + 0.005;\n\tfloat wall_thickness = 0.018;\n\tfloat wall_height = 0.05;\n\tfloat wall_radius = 0.008;\n\tfloat d = FLT_MAX;\n\tfor ( float k = 0.0; k < 2.0; k += 1.0 )\n\t{\n\t\tvec3 pl = p; // p local\n\t\tpl.xy = GetLocalCurvePoint( path );\n\t\tpl.y -= wall_start_dist + wall_thickness * 0.5;\n\t\tpl.z -= h;\n\t\tvec3 s = vec3( 0.01, 0.006, 0.006 );\n\t\tfloat spacing = 0.0015;\n\t\tvec3 c;\n\t\tc.xz = vec2( s.x + spacing, 2.0 * s.z + spacing );\n\t\tc.y = s.y + spacing;\n\t\tvec2 offset = -0.5 * c.xz;\n\t\tfloat o = 0.5 * k;\n\t\toffset.xy += o * c.xz;\n\t\tvec2 i;\n\t\ti = floor( ( pl.xz - offset ) / c.xz );\n\t\ti.y = min( i.y, 2.0 );\n\t\tpl.xz -= i * c.xz;\n\t\tpl.xz -= o * c.xz;\n\t\tfloat r = 0.002;\n\t\td = opU( d, sd_bounds_range_round( pl, -s * 0.5, s * 0.5, r ) );\n\t}\n\tif ( _1 ) d -= 0.003 * sfbm2_13( p * 80.0 );\n\treturn d;}\n\nfloat sdGrass( vec3 p, float h ) { return p.z - h; }\n\n// scene eval output\nstruct SceneOut{\n\tDistanceId object_di;\n\tfloat d_ghost; // can we optimize that and have less of those?\n\tfloat base_height; // base ground height\n\tClosestPath path;\n\tClosestPath test2d; // for 2d view mode\n\tvec3 color; // special color case for bushes (when id_fraction is not enough)\n#ifdef TERRAIN_WARP\n\t// this cuts bush evals massively\n\tfloat terrain_warp; // todo: move out of this struct, this is not part of returned information\n#endif\n};\n\nvoid SceneOutInit( inout SceneOut eval ) { eval.d_ghost = FLT_MAX; }\n\nvec3 get_bush_palette( vec2 uv ){\n\treturn mix( mix( mix( COLOR_BUSH1, COLOR_BUSH2, uv.x ), mix( COLOR_BUSH3, COLOR_BUSH4, uv.x ), uv.y )\n\t\t\t\t, COLOR_BUSH5, smoothband( uv.x, 0.49, 0.51, 0.01 ) );}\n\nbool is_white_cell( vec2 p_index ) { return ( int( p_index.x + p_index.y ) & 1 ) == 1; }\n\nvoid consider_close_point_hi(\ninout float d, vec2 index, float r\n, inout vec4 color, vec3 p, float cellsize\n, vec3 h_gradval, bool taylor_expansion_height, int trace_flags ){\n\tvec3 c;\n\tvec3 h = hash32( index );\n\tc.xy = ( index + h.xy ) * cellsize;\n\tc.z = CalcHeight( c.xy, p.xy, h_gradval, taylor_expansion_height ) + r * mix( -0.8, 1.3, h.z );\n\tfloat di = length( c - p ) - r;\n\td = min( d, di );\n\tif ( IsShadeTrace( trace_flags ) )\t{\n\t\tvec2 ch = hash22( index );\n\t\t// this is called only once in shade, knock yourself out\n\t\tfloat w = max( 1. - smoothstep( -r * 0.1, r * 0.25, di ), 1e-3 );\n\t\tcolor.xyz += get_bush_palette( ch ) * w;\n\t\tcolor.a += w;}}\n\nstruct CloseGridPointArgs { float cell_size, max_radius, radius_disparity; };\n\nstruct CloseGridPointArgsWithBand{\n\tCloseGridPointArgs args0;\n\tfloat band_start, band_end;\n\tbool taylor_expansion_height;};\n\n// 45 means we consider 4 or 5 neighbour (instead of 3x3) depending on whether we are on a white or a black cell (not perfect but covers lots of cases)\n// instead of giving the closest point this version does a little bit of extra calculation or each candidate for color blending on bushes\nfloat GetCloseGridPoints45( inout vec3 a_color, vec3 p, float cellsize\n, vec3 h_gradval, CloseGridPointArgsWithBand args, int trace_flags, int F){\n///..., frame\n\tfloat r = args.args0.max_radius * 0.8;\n\tvec2 p_index = floor( p.xy * ( 1.0 / cellsize ) );\n\n\tfloat d = FLT_MAX;\n\tvec4 color = vec4( 0.0 );\n#if 0\n\t// the unrolled code path is faster on my current view (70ms->68ms) but shader compilation prefers the loop (-1s)\n\tif ( is_white_cell( p_index ) )\t{\n\t\t//white cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}else{\n\t\t//black cell\n\t\tconsider_close_point_hi( d, p_index + vec2( -1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1,  1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2( -1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  1, -1 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\tconsider_close_point_hi( d, p_index + vec2(  0,  0 ), r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t}\n#else\n\tvec2 offset = vec2( 0, 1 ); // white cells check 4 canonical axis neigbours\n\tif ( !is_white_cell( p_index ) )\t{\n\t\tconsider_close_point_hi( d, p_index, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags ); // this cell, only checked if black\n\t\toffset = vec2( 1, 1 );\t} // black cells check the 4 diagonal neighbours\n\n\n\tfor ( int i = 0 FORCE_LOOP; i < 4; ++i )\t{\n\t\tconsider_close_point_hi( d, p_index + offset, r, color, p, cellsize, h_gradval, args.taylor_expansion_height, trace_flags );\n\t\toffset = perp( -offset );\t} // go to next neighbour by rotating +90\n\n#endif\n\tif ( IsShadeTrace( trace_flags ) ) // skipping this test breaks the trees...\n\t\ta_color = color.xyz / color.a;\n\treturn d;}\n\n#define bush_max_radius 0.04\n// for bushes we do something symbolic looking, with a slight Hiroshi Nagai vibe \nvoid AddContributionBush(float groundz, inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t\t, vec3 h_gradval,  vec3 patch_id_hash\n\t\t\t\t\t\t\t, bool is_forest_patch, float aTime, int aFrame ){\n\tvec3 p = scenein.p;\n\tbool has_bushes = patch_id_hash.x > 0.2;\n\tbool has_cut_bushes = SQUARE_BUSH_TEST && ( !is_forest_patch && patch_id_hash.x > 0.62 );\n\n\tfloat bush_cell_size = 0.095;\n\n\tfloat bush_d_min = p.z - ( groundz + bush_max_radius*1.9 ); // upper bound for distance to bushes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  // multiply by 2 else lots of bushes get cut... \n\n\t// note: whether we use > or <= has resulted in big difference in the past sometimes\n\tif ( !has_bushes\n\t\t || ( bush_d_min > eval.object_di.d )\n#ifdef TERRAIN_WARP\n\t\t || (\n\t\t\t  ( eval.terrain_warp != 0.0 ) &&\n\t\t\t  ( bush_d_min > 0.0 ) &&\n\t\t\t  ( bush_d_min < eval.terrain_warp ) ) // we know we can roughly traverse by eval.terrain_warp before hitting next bush\n#endif\n\t\t) return;\n\n\tfloat d = FLT_MAX;\n\tfloat id_fraction = 0.0;\n\tfloat freq = 1.0;\n\n\tif ( has_cut_bushes\n    ){\tfreq = DISPLACE_BUSH_FREQ;\n\t\t\n\t\t// patch section 2d point\n\t\tvec2 p_patch_section = vec2( eval.path.patch_di.d, p.z - eval.base_height );\n\t\tfloat d_square_bush = sd_bounds_range( p_patch_section, vec2( LANEWIDTH - 0.015, 0 ), vec2( LANEWIDTH + 0.02, 0.05 ) );\n\t\td = d_square_bush; // we distort so...\n\n\t\teval.color = COLOR_BUSH3;\n\t}\telse\t{\t\n       freq = DISPLACE_BUSH_FREQ;\n\n\t\t// this is a patch with bushes on the side\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = bush_cell_size;\n\t\targs.args0.max_radius = bush_max_radius;\n\t\targs.args0.radius_disparity = 0.4;\n\t\targs.band_start = LANEWIDTH * 0.5 + args.args0.max_radius * 0.5; // take a fraction of the radius so that some of the bushes overlap a bit with the path\n\t\targs.band_end = args.band_start + 0.18 + pow2( patch_id_hash.z ) * 0.3;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_BUSH;\n\t\td = GetCloseGridPoints45( eval.color, p, args.args0.cell_size * 0.5, h_gradval, args, scenein.trace_flags, aFrame );\n\t\tif ( SOFT_BLEND_BUSH ) d = opU_weld_quadric( p.z - eval.base_height, d, 0.027 );\n\t\t// clip bush vs path/walls (leak through walls is a happy accident)\n\t\tif ( _1 ) d = opS_soft2( d, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5, 100.0 );\n\t\tif ( _1 )\t\t{\n\t\t\t// fade bush inside patch\n\t\t\tfloat bf = ( sfbm1_12( p.xy * 18.0 ) - 0.5 ) * 0.33; // distort fade boundary\n\t\t\td = opS_soft2( d, args.band_end * ( 1. + bf ) - eval.path.patch_di.d, 30.0 );\t\t}\t}\n\n\tif ( DISPLACE_BUSH )\t{\n\t\tfloat dd = 0.0045; // need more displacement to see shadows...\n\t\tvec3 pd = p;\n\t\tif ( WIND_BUSH ) pd += ApplyWind( pd, aTime );\n\t\t // the test is < ..*3 because we INFLATE\n\t\tif ( d < dd * 3.0 ) d -= sfbm2_13( pd * vec3( 80.0, 80.0, 100 ) * freq ) * dd;\t}\n\teval.object_di = opUdi( eval.object_di, MkDistanceId_16( d, MATID_BUSH, id_fraction ));}\n\n// return closest cell point with a radius, no neighbour, used by farms and trees\n// max_radius must be less than cell_size*0.5\n// radius_disparity percentage in 0,1\n// grid_offset in 0,1, conceptually...\nvoid GetClosestGridPoint( inout CellPoint point, vec2 p\n, CloseGridPointArgs args0, float grid_offset, float hoffset\n){\tvec2 piss = floor( ( p - grid_offset ) / args0.cell_size );\n\tpoint._pi = ivec2( piss + vec2( hoffset ) );\n\tvec4 ph = hash42_( point._pi );\n//\tph.xy = vec2( 0.5 ); // debug\n\tpoint.pradius = args0.max_radius * ( 1.0 - args0.radius_disparity * ph.z );\n\tvec2 a = grid_offset + piss * args0.cell_size;\n\tvec2 b = a + vec2( args0.cell_size );\n\tpoint.p = mix( a + vec2( point.pradius ),\n\t\t\t\t   b - vec2( point.pradius ), ph.xy );} // important: +offset to put back in same space as p\n\n\n// used by farms and trees\nbool GetClosestGridPointWithPathBand_x1( inout CellPoint point\n\t\t\t\t\t\t\t\t\t\t , vec2 p\n\t\t\t\t\t\t\t\t\t\t , vec3 h_gradval\n\t\t\t\t\t\t\t\t\t\t , CloseGridPointArgsWithBand args\n\t\t\t\t\t\t\t\t\t\t , float grid_offset, float hoffset\n){\tGetClosestGridPoint( point, p, args.args0, grid_offset, hoffset );\n\t// we want to know if this point is within a band of the country patch we are currently in\n\tfloat distance_to_patch_border = abs( EvalClosestPath( point.p, true ).patch_di.d );\n\treturn ( distance_to_patch_border > args.band_start )\n\t\t&& ( distance_to_patch_border < args.band_end );}\n\nvoid SetSceneInDirection( inout SceneIn scenein, vec3 o, vec3 v, int trace_flags\n){\tscenein.v = v;\n\tscenein.v_rcp = vec3( 1.0 ) / v;\n//\tscenein.o = o;\n\tscenein.trace_flags = trace_flags | TRACE_HAS_DIRECTION;\n\tscenein.t0 = 0.0;}\n\nvoid SetSceneInDirectionless( inout SceneIn scenein, int trace_flags\n){\tscenein.v = vec3( 0.0 );\n\tscenein.v_rcp = vec3( 0.0 );\n//\tscenein.o = vec3( 0.0 );\n\tscenein.trace_flags = trace_flags;\n\tscenein.t0 = 0.0;}\n\nfloat ClampRayAgainstCurrentGridCell( vec3 p, vec3 v_rcp, vec3 cell_size, float cell_inflate_epsilon\n){\t// we know the direction therefore we only have to test one side of each axis\n\tvec3 s = sign( v_rcp );\n\tvec3 amin = floor( p / cell_size ) * cell_size;\n\tamin -= vec3( cell_inflate_epsilon ); // instead of adding that to d_ghost we clamp to cell_size + cell_inflate_epsilon\n\tvec3 a = amin + ( ( s + 1.0 ) * 0.5 ) * ( cell_size + 2.0 * vec3( cell_inflate_epsilon ) );\n\tvec3 t = ( a - p ) * v_rcp; // ray vs all closest box planes\n//\tt += FLT_MAX * ( 1.0 - abs( s ) ); // when sign is zero, push next hit at t=+infinite, v_rcp has been set to zero in that case\n\treturn min( min( t.x, t.y ), t.z );} // should be > 0 by construction\n\nbool CanGhostStep( SceneIn scenein, float maxdist_from_t0, float maxdist_abs\n){\treturn HasDirection( scenein.trace_flags )\n\t\t&& ( scenein.t < maxdist_abs ) // GHOST_MAX_DIST_ABS\n\t\t&& ( ( scenein.t - scenein.t0 ) < maxdist_from_t0 );} // GHOST_MAX_DIST_FROM_T0\n\n\nvoid GhostGridSteps( inout SceneOut eval, SceneIn scenein, float cell_size, float cell_inflate_epsilon \n){\tfloat dm = ClampRayAgainstCurrentGridCell( scenein.p, scenein.v_rcp\n\t\t\t\t\t\t\t\t\t\t\t   , vec3( cell_size, cell_size, 20.0 ), cell_inflate_epsilon );\n\t// note that this doesn't deal with diagonals which might cross another cell\n\teval.d_ghost = min( eval.d_ghost, max( dm, GHOST_EPS ) );}\n\n// used by farms and trees\n#define SD_OBJECT_CONTRIB( _di_, _object_sd_func_, _grid_offset_, _hoffset_ ) {\\\n\tCellPoint _cp_; \\\n\tif ( GetClosestGridPointWithPathBand_x1( _cp_, p.xy, h_gradval, args, _grid_offset_, _hoffset_ ) )\\\n\t\t_di_.object_di = _object_sd_func_( _di_.object_di, p, _cp_, radius_fraction, _di_.path.patch_di.id, eval.color, scenein, h_gradval, args.taylor_expansion_height );\\\n}\n\nvoid AddContributionTree( float groundz, \ninout SceneOut eval, SceneIn scenein\n, vec3 h_gradval,vec3 patch_id_hash, int aFrame, float aTime \n){\tvec3 p = scenein.p;\n\tfloat tree_max_radius = 0.15;\n\tCloseGridPointArgsWithBand args;\n\targs.args0.cell_size = 0.4;\n\targs.args0.max_radius = tree_max_radius;\n\targs.args0.radius_disparity = 0.1;\n\targs.band_start = args.args0.max_radius;\n\t// some patches are filled with trees, some other patches only have trees on the border\n#if 1\n\targs.band_end = patch_id_hash.x > 0.9 ? FLT_MAX : args.args0.max_radius * 3.0;\n#else\n\targs.band_end = FLT_MAX;\n#endif\n\targs.taylor_expansion_height = TAYLOR_HEIGHT_TREE;\n\n\tfloat grid_offset_step = 0.25; // this is wrong actually but creates a certain sparsity that is welcome\n\tvec3 grid_offsets = vec3( 0., 1.0, 2.0 ) * grid_offset_step * args.args0.cell_size;\n\tfloat radius_fraction = 1.0;\n#if 0\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.x, 000.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.y, 100.0 );\n\tSD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offsets.z, 200.0 );\n#else\n\t// this might be a bit faster (92->71!), also shadertoy compile time\n\tfor ( float f = 0.0 FORCE_LOOPF; f < 3.0; f += 1.0\n    ){SD_OBJECT_CONTRIB( eval, sdGridObj_TreeOrPine, grid_offset_step * args.args0.cell_size * f, 100.0 * f );}\n#endif\n\n\tfloat mat_id = DecodeId( eval.object_di );\n\t// displace all the trees at once...\n\tif ( DISPLACE_TREE && ( ( mat_id == MATID_TREE ) || ( mat_id == MATID_PINE ) )\n    ){\tvec3 pd = p;\n\t\tif ( WIND_TREE_AND_PINES ) pd += ApplyWind( pd, aTime );\n\t\tfloat is_pine = ( mat_id == MATID_PINE ) ? 1. : 0.;\t\t\n\t\tpd.z *= mix(1.,0.75,is_pine);\t\t\n\t\teval.object_di.d += sfbm2_13_leaf( pd * 80.0 * 2.2 ) * TREE_SDD * mix( 1., 0.4, is_pine ) * 0.8\n    ;}\n\tif ( GHOST_STEPS_TREE && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS )\n    ){// note: offset zero for all + smallest cell size fraction multiple should yield same result\n\t\tfloat cell_inflate_epsilon = 0.004; // tree\n\t\tGhostGridSteps( eval, scenein, grid_offset_step * args.args0.cell_size, cell_inflate_epsilon );}}\n\nvoid AddContributionFarm(float groundz, inout SceneOut eval, SceneIn scenein\n\t\t\t\t\t\t   , vec3 h_gradval,  vec3 patch_id_hash\n\t\t\t\t\t\t   , float cpmph ){\n                           //... cpmph == closest_path_middle_point_height\n\tvec3 p = scenein.p;\n\tbool is_farm_patch = patch_id_hash.x > 0.2;\n\n\tif ( !is_farm_patch ) return;\n\n\tif ( FARM )\n\t{\n\t\t// farms are sparse so use 1 cell\n\t\tCloseGridPointArgsWithBand args;\n\t\targs.args0.cell_size = 1.2;\n\t\targs.args0.max_radius = 0.35;\n\t\targs.args0.radius_disparity = 0.3;\n\t\targs.band_start = args.args0.max_radius * 1.5;\n\t\targs.band_end = FLT_MAX;\n\t\targs.taylor_expansion_height = TAYLOR_HEIGHT_FARM;\n\t\tfloat radius_fraction = 0.8;\n\t\tSD_OBJECT_CONTRIB( eval, sdGridObj_Farm, 0.0, 0.0 );\n\t\tif ( GHOST_STEPS_FARM && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS ) )\n\t\t{\n\t\t\tfloat cell_inflate_epsilon = 0.004;\n\t\t\tGhostGridSteps( eval, scenein, args.args0.cell_size, cell_inflate_epsilon );\n\t\t}\n\t}\n\n\tif ( BRICKWALL && patch_id_hash.y > 0.7 ) // note: not all farm patch have a visible house on them...\n\t{\n\t\tDistanceId walls = MkDistanceId( sdBrickWall( p, eval.path, eval.base_height ), MATID_BRICKWALL );\n\t\teval.object_di = opUdi( eval.object_di, walls );\n\t}\n}\n\nvoid AddContributionGras(float groundz,  inout SceneOut eval, vec3 p, vec3 patch_id_hash )\n{\n\tfloat grass_height = ( groundz - 0.01 ) // make sure grass doesn't cover the path ground\n\t\t+ smoothstep( -0.02, 0.04, abs( eval.path.patch_di.d ) - LANEWIDTH * 0.5 ) * 0.0195;\n\tDistanceId grass = MkDistanceId_16( sdGrass( p, grass_height ), MATID_GRASS, patch_id_hash.z ); // each patch has slightly different colors\n\teval.object_di = opUdi( eval.object_di, grass );\n}\n\nvoid AddContributionPath( float groundz , inout SceneOut eval, SceneIn scenein)\n{\n\tvec3 p = scenein.p;\n\tfloat path_d_min = p.z - groundz;\n\n\tif ( !( path_d_min < eval.object_di.d ) ) return; // weird compiler horror happened depending how we write the if branch here\n\n\t// path is the most occluded thing so do it last\n\tDistanceId path_di = MkDistanceId_16( path_d_min // lower bound for bushes\n\t\t\t\t\t\t\t\t\t   , MATID_GROUND, ( 1.0 - smoothstep( 0.0, 0.05, eval.path.patch_di.d ) ) );\n\tif ( DISPLACE_PATH )\n\t{\n\t\t// this displacement is expensive, cull as much as we can, maybe we could just do that in shade\n\t\tfloat path_blend = 1.0 - smoothstep( 0.001, 0.008, eval.path.patch_di.d - LANEWIDTH * 0.5 );\n\t\tfloat distance_blend = 1.0 - smoothstep( 6.0, 7.0, scenein.t );\n\t\tfloat fade = path_blend * distance_blend;\n\t\tif ( fade > 0.0 ) // that cuts a bit\n\t\t{\n\t\t\t// so we can scale along road direction\n\t\t\tpath_di.d += fade * sfbm2_12( GetLocalCurvePoint( eval.path ) * vec2( 1, 2 ) * 80.0 ) * DISPLACE_PATH_AMPL;\n\t\t}\n\t}\n\n\teval.object_di = opUdi( eval.object_di, path_di );\n}\n\nSceneOut evalScene( SceneIn scenein, int F, float T//scenein,aFrame,aTime\n){vec3 p = scenein.p//+vec3(0,0,11)\n ;SceneOut eval\n ;SceneOutInit(eval)\n ;float groundz = BaseGroundHeight( p.xy )\n ;eval.base_height = groundz\n ;eval.path = EvalClosestPath( p.xy, false )\n ;vec3 h_gradval = vec3( 0.0, 0.0, groundz )\n ;\n #ifdef TERRAIN_WARP\n ;vec3 ground_normal\n #endif\n ;if(\n #ifdef TERRAIN_WARP\n _1 ||\n #endif\n\t// any of those need the height gradient at p\n TAYLOR_HEIGHT_BUSH ||\n TAYLOR_HEIGHT_TREE ||\n TAYLOR_HEIGHT_FARM\n ){vec2 e = vec2( 1e-3, 0)\n  ;float hx = BaseGroundHeight( p.xy + e.xy )\n  ;float hy = BaseGroundHeight( p.xy + e.yx )\n  ;h_gradval.xy = vec2( hx-eval.base_height,hy-eval.base_height)/e.x //beware that e.y=0.\n  #ifdef TERRAIN_WARP\n  ;vec3 px = vec3( p.xy + e.xy, hx )\n  ;vec3 py = vec3( p.xy + e.yx, hy )\n  ;vec3 pc = vec3( p.xy, eval.base_height )\n  ;ground_normal = normalize( cross( px - pc, py - pc ) )\n  #endif\n ;}\n #ifdef TERRAIN_WARP\n ;eval.terrain_warp = 0.\n ;if ( HasDirection( scenein.trace_flags ) \n ){float large_optimistic_step = 3.0\n  ;vec3 base = vec3( p.xy, eval.base_height + bush_max_radius*2.5 )\n  ;Ray warp_ray\n  ;warp_ray.o = scenein.p\n  ;warp_ray.d = scenein.v\n  ;float t2 = plane_trace( warp_ray, base, ground_normal, 1e-3 )\n  ;if (t2>0.\n  ){//if ( dot( ground_normal, scenein.v ) < 0 ) // if terrain is convex at ground_normal in trace direction?\n   ;eval.terrain_warp = min( t2, large_optimistic_step )\n  ;}}\n  #endif\n  ;// eval.path.patch_di.id is the patch id\n  ;// eval.path.patch_di.d is the distance to closest path\n  ;// the path we walk on is flat so we need the height of center of the road\n  ;vec2 closest_patch_border_point2 = p.xy + eval.path.v2closest // center of road\n  ;float cpmph = BaseGroundHeight( closest_patch_border_point2 ) // fences use\n  ;eval.test2d = eval.path\n  ;// upper bound for distance to ground, take into account displacement that might dig a little on paths\n  ;float d_ground_max = p.z - ( eval.base_height - DISPLACE_PATH_AMPL * 2.0 )\n  ;if ( GROUND_OCCLUSION ) eval.object_di = MkDistanceId( d_ground_max, MATID_GROUND ) // occlusion helps\n  ;else eval.object_di = MkDistanceId( FLT_MAX, MATID_NONE ) // enable PATH to get a ground\n  ;// hit the patch boundary tangent plane, this has 2 properties we want:\n  ;//  1- the closer we are to the boundary the more this approximates the hit point, sort of\n  ;//  2- if ray leaches the patch boundary, the hit point will be far away\n  ;//      -> that second one improves significantly the horrible artifact where we run out of points...\n  ;//  also ignore far away hits for perfs   \n  ;// todo: we don't need ghost steps if we are far above the ground! we can save a bit\n  ;if ( GHOST_STEPS_PATCH && CanGhostStep( scenein, GHOST_MAX_DIST_FROM_T0, GHOST_MAX_DIST_ABS )\n  ){vec3 base = vec3( p.xy + eval.path.v2closest, p.z )\n   ;vec3 normal = normalize( -vec3( eval.path.v2closest, 0 ) )\n   ;float t2 = plane_trace( p, scenein.v, base, normal, 1e-3 )\n   ;if ( t2 > 0.0 ) eval.d_ghost = min( eval.d_ghost, max( t2, GHOST_EPS ) )\n  ;}\n//\tvec3 patch_id_hash = hash31( eval.path.patch_di.id )\n ;vec3 patch_id_hash = hash42_( ivec2( int( eval.path.patch_di.id ) ) ).xyz// paranoid use of ints for important structural elements\n ;bool is_forest_patch = patch_id_hash.x > 0.65\n ;if (is_forest_patch\n  ){if(TREE)AddContributionTree(groundz,eval,scenein,h_gradval,patch_id_hash,F,T)\n  ;}else    AddContributionFarm(groundz,eval,scenein,h_gradval,patch_id_hash,cpmph)\n ;if (BUSH) AddContributionBush(groundz,eval,scenein,h_gradval,patch_id_hash,is_forest_patch,T,F )\n ;if (PATH) AddContributionPath(groundz,eval,scenein)\n ;if (GRAS )AddContributionGras(groundz,eval,p,patch_id_hash)\n ;return eval;}\n\n\n\nstruct TraceOutput{\n\tfloat t;\n\tfloat dist; // distance to surface (error)\n\tfloat shadow;}; // sun/main light occlusion\n\n\n\n\n#define MAX_ITERATIONS_VIEW 120\n#define MAX_ITERATIONS_SHADOW 40 // set this as small as you can with your lighting setting, even if shadow ray escape to sky quickly this results in big win\n#define TMAX_VIEW 80.0 // was 200 before\n#define TMAX_SHADOW 40.0 // reducing this doesn't help much\n#define TFRAC 0.8\n#define DBREAK 0.0025 // tweak for perfs!!! depends on scene scale etc might make small features thicker than they actually are\n\n\n\nTraceOutput traceScene( Ray ray, float shadow_sharpness, int trace_flags\n, int max_iterations, float tfrac\n, float tmaxmax, float dbreak, vec2 uv, vec2 fragCoord, int F, float aTime ){\n//...,iFraame,iTime\n\n\tTraceOutput to;\n\tto.t = 0.0;\n\tto.dist = 0.0;\n\tto.shadow = 1.0;\n\n\tfloat tmax = tmaxmax;{ // default to absolute max\n\t\t// clamp traced segment\n\t\tfloat hmax = MAX_TERRAIN_HEIGHT + TALLEST_OBJECT_HEIGHT; // there must be nothing above this height\n\t\tfloat thit = plane_trace_z( ray, hmax, 1e-4 );\n\t\tif ( thit > 0.0 )\t\t{\n\t\t\tif ( ray.o.z > hmax ) to.t = thit; // above hmax looking down\n\t\t\telse tmax = min( thit, tmaxmax ); // below hmax looking up, clamp at hmax\n\t\t}else if ( ray.o.z > hmax\n        ){\t\tto.t = tmaxmax * 1.1; // above hmax looking up, there is only sky\n//\t\t\treturn to; // don't branch here, that might be actually slower\n\t}}\n\n\tSceneIn scenein;\n\tSetSceneInDirection( scenein, ray.o, ray.d, trace_flags );\n\tscenein.t0 = to.t;\n    \n\t    //core raymarch loop:\n        //core raymarch loop:\n        //core raymarch loop:\n        //core raymarch loop:\n\tfor ( int i = 0 FORCE_LOOP; i < max_iterations; ++i \n    ){\tscenein.p = ray.o + to.t * ray.d;\n\t\tscenein.t = to.t;\n\t\tSceneOut eval = evalScene( scenein, F, aTime );\n\t\tfloat d = min( eval.object_di.d, eval.d_ghost );\n\t\t// note: ghost points might make us jump over solid tfrac points\n\t\tfloat is_ghost_step = ( d == eval.d_ghost ? 1.0 : 0.0 );\n\t\tto.dist = d;\n\t\t// important: do not move this block after the to.dist check!\n\t\tif ( IsShadowTrace( trace_flags )\n\t\t\t//&& ( is_ghost_step == 0.0 ) // creates ugly discontinuities\n\t\t\t)\n\t\t{\n\t\t\t// note: if eval.object_di.d < 0 we set shadow to 0 in effect\n\t\t\t// that catches the case where first point is inside an object (because shadow ray offset issues, ex: bush vs ground normal discontinuity)\n\t\t\t// for regular case if distance is neg it means we hit an object and so shadow = 0 too anyway\n\t\t\t// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf for shadows\n\t\t\tto.shadow = min( to.shadow, shadow_sharpness * max( eval.object_di.d, 0.0 ) / ( to.t + 1e-4f ) );\n\t\t\t\n\t\t\tif ( to.shadow <= 0.01 ) break;\t\t}\n\n\t\t// warning: never stop on a ghost step!!\n\t\tif ( ( ( is_ghost_step == 0.0 ) && ( to.dist <= dbreak * to.t ) )\n\t\t\t || ( to.t > tmax ) ) break;\n\n\t\t// the amount by which we advance t: drop tfrac on ghost steps\n\t\tfloat dt = to.dist * mix( tfrac, 1.0, is_ghost_step );\n\n\t\tto.t += dt;\n\t}\n\n\tif ( to.t > tmax ) to.t = tmaxmax * 1.1;\n\n\treturn to;\n}\n\n#ifdef SHADERTOY_STANDALONE\n#define TIME_OF_DAY iSlider0\n#else\n#define TIME_OF_DAY 0.56\n#endif\n\nvec3 get_sun_direction(float aTime\n){\tfloat sun_elevation = radians( mix( -30.0, 90.0, TIME_OF_DAY ) ); // careful with z, long shadows make the tracing slower\n\treturn zup_spherical_coords_to_vector( unit_vector2( PI * 0.5 - sun_elevation )\n\t\t\t\t\t\t\t\t\t\t\t , _1 ? V45 : unit_vector2( 2.0 * PI * aTime / 3.0 ) );}\n\n#define cloud_re 3000.0\n#define cloud_r1 ((cloud_re)+8.0)\n#define cloud_r2 ((cloud_r1)+1.8)\n#define fake_earth_center vec3(0,0,-cloud_re)\n\nfloat cloudDensity( vec3 p \n){\tfloat sparsity = 0.07; // 0,1.x\n\tfloat freq = 0.2;\n\tfloat d = efbm4_13( p * freq, 1.0 + sparsity );\n\tfloat r = length( p - fake_earth_center );\n\tfloat r2 = length( p.xy );\n\tfloat c = smoothstep( 3., 5., r2 ); // cleanup singularity at north pole a little bit\n\td *= smoothstep( 0.4, 0.6, d * c ); // multiply d by c give best fade out\n\td = max( d, 0. );\n\td *= smoothstep( cloud_r1, cloud_r1 + 0.1, r )\n\t\t* ( 1.0 - smoothstep( cloud_r2 - 0.1, cloud_r2, r ) ); // altitude band\n\treturn d;}\n\n// make some ultra basic clouds out of thin air, we will bake them in a spheremap\nvec3 traceClouds( vec3 n, float aTime\n){\tvec3 sun_direction = get_sun_direction(aTime);\n\tRay ray = mkray( vec3( 0.0 ), n );\n\tvec2 vt1 = sphere_trace( ray, cloud_r1, fake_earth_center );\n\tvec2 vt2 = sphere_trace( ray, cloud_r2, fake_earth_center );\n\t//return vec4( vec3( 0.1*( t2.y - t1.y ) / ( r2 - r1 ) ), 0 );\n//\tfloat li = 1.0;\n\tfloat vlen = ( vt2.y - vt1.y );\n\tfloat vdt = vlen / 100.0;\n\tfloat vt = vt1.y;\n\tfloat vod = 0.0;\n\tfloat vod2 = 0.0;\n\tfloat c = 0.8;\n\t// view ray\n\tfor ( ; vt < vt2.y ; vt += vdt\n    ){\t\tvec3 p = ray.o + ray.d * vt;\n\t\tfloat pd = cloudDensity( p );\n\t\t{\n\t\t\t// sun ray\n\t\t\tRay lray = mkray( p, sun_direction );\n\t\t\tvec2 lt2 = sphere_trace( lray, cloud_r2, fake_earth_center );\n\t\t\tfloat llen = lt2.y;\n\t\t\tfloat ldt = llen / 5.0;\n\t\t\tfloat lt = ldt;\n\t\t\tfloat lod = 0.0;\n\t\t\tfor (; lt < llen; lt += ldt )\n\t\t\t{\n\t\t\t\tvec3 lp = lray.o + lray.d * lt;\n\t\t\t\tfloat lpd = cloudDensity( p );\n\t\t\t\tlod += vdt * lpd * c * 10.0;\n\t\t\t}\n\t\t\tvod2 += vdt * pd * exp( -lod -vod ); // inscatter\n\t\t}\n\t\tvod += vdt * pd * c; // absorption\n\t}\n\t// for compositing we do something like exp( -vod ) * distant_sky_color + vod2\n\treturn vec3( saturate(vod2), exp( -vod ), 0 );\n\t\n#define cloud_lowest_absorption_remap 0.6\n\t\n}\n\n// map theta to uv .5 r, we only keep the [0,PI/2] theta range\n#if 0\nfloat theta2r05( float theta ) { return theta *(1.0/PI) ; }\nfloat r052theta( float r ) { return r * PI; }\n#else\n// give more resolution to the horizon\nfloat theta2r05( float theta ) { return pow(saturate(theta*(1.0/(PI*0.5))),2.0) *0.5; }\nfloat r052theta( float r ) { return pow((r*2.0),0.5) *PI*0.5; }\n#endif\n\nvec3 get_cloud( vec3 v, sampler2D aChannel1, vec3 aResolution, float aTime\n){\tvec3 cloud = vec3(0.0);\n#if 0\n\tif ( CLOUD_MODE>0 ){\n\t\tvec2 sc = vector_to_zup_spherical_coords( v );\n\t\tif ( sc.x > PI * 0.5 ) return BLUE;\n\t\tvec2 uv = vec2( 0.5 ) + unit_vector2( sc.y ) * theta2r05( sc.x );\n\t\tuv.x *= aResolution.y / aResolution.x;\n\t\tcloud = CLOUD_MODE==1\n\t\t\t? traceClouds( v, aTime )\n\t\t\t: texture( aChannel1, uv ).xyz; // return the highres one here for debug, should match with sampled one\n\t}\n#endif\t\n\treturn cloud;} // debug\n\n\nfloat sFlarePeak( vec2 p, float da, float a, float a_offset\n){\ta += a_offset;\n\ta = floor( ( a / da ) + 0.5 ) * da;\n\tvec2 vv = unit_vector2( a - a_offset );\n\treturn abs( dot( p, perp( vv ) ) );}\n\nvec4 sunGlareCoords( mat4 cam, vec3 v, vec3 l\n){\tvec3 sy = normalize( cross( cam[0].xyz, l ) );\n\tvec3 sx = normalize( cross( l, sy ) );\n\treturn vec4( normalize( vec2( dot( v, sx ), dot( v, sy ) ) ), dot( v, l ), -cam[2].z );}\n\nvec3 sunGlare( vec4 ppd // xy: angle as unit vector z: dot(v,l)\n\t\t\t   , float solid_sun_disk_radius\n\t\t\t   , float ray_length // higher value = shorter length\n\t\t\t   , float ray_thickness\n\t\t\t   , float ray_thickness_disparity\n\t\t\t   , float n1 // can be arbitrarily large\n\t\t\t   , float n2 // there is a loop on n2 - the number of rays is n1*n2 so we have a trade off between the repeat in sFlarePeak (which can't do proper additive on rays) and the for loop (which can)\n\t\t\t   , float falloff_glare_attn\n\t\t\t   , float falloff_glare_p1\n\t\t\t   , float falloff_glare_p2\n\t\t\t   , bool falloff_glare_multiplicative\n){\tvec2 anglev = ppd.xy; // angle as unit vector\n\tfloat v_dot_l = ppd.z;\n\tfloat r = safe_acos( v_dot_l ) / PI; // could do without acos but it is a lot more easier to work with regular spacing\n\tvec2 p = anglev * r;\n\tfloat a = calc_angle( anglev );\n//\treturn vec3( stripes(r,0.02,0.001,0.001/2.0), stripes(degrees(a),10.,0.1,0.1/2.0),0.); // visualize polarcoords\n\tfloat v = 0.0;\n\tfloat d2 = max( r - solid_sun_disk_radius, 0. ); // falloff glare\n\tfloat da = 2.0 * PI / n1;\n\tfloat da2 = 2.0 * PI / ( n1 + n2 );\n\tfor ( float i = 0.; i < n2; ++i\n    ){  vec3 rr = hash31( i + 1. );\n\t\tfloat rda = rr.x * da2 * 0.1;\n\t\tfloat d1 = sFlarePeak( p, da, a, -i * da / n2 + rda );\n\t\tif ( r < solid_sun_disk_radius ) d1 = 0.;\n\t\tv += exp2( -d1 * d1 * ray_thickness * mix( 1.0-ray_thickness_disparity, 1.+ray_thickness_disparity, rr.y )\n\t\t\t\t   -d2 * ray_length * mix( 0.5, 1.5, rr.z ) );\t}\n\tfloat falloff_glare = falloff_glare_attn * ( 1.0 - powerful_scurve( d2, falloff_glare_p1, falloff_glare_p2 ) );\n\tv = falloff_glare_multiplicative ? v * falloff_glare : v + falloff_glare;\n\tv = min( v, 1. );\n\treturn vec3( v );}\n\n#define FOG_GROUND _1\n\n // set render to false for getting a value for lighting calculation as opposed to display\nvec3 get_top_sky_color( bool render ) {  return AZURE * ( render ? 0.6 : 1.0 ); }\nvec3 get_sky_horizon_color() { return mix( WHITE, AZURE, 0.4 ); }\nvec3 get_fog_color() { return mix( AZURE, WHITE, 0.15 ); }\n\n// return a v.z normalized so that horizon view direction is remapped to 0 and zenith is still 1\nfloat get_hacked_vz( vec3 v, float ez ){\n\tfloat zmin = -max(ez,0.)/(TMAX_VIEW*1.1); // z/f=zmin/1. where f=TMAX_VIEW*1.1\n\treturn max(0.,(v.z-zmin)/(1.-zmin));}\n\nvec3 get_sky( vec3 v, vec3 l, float ez, bool render ){\t\n\tfloat hz = get_hacked_vz( v, ez );\n\treturn mix( get_sky_horizon_color(), get_top_sky_color(render), pow( hz, 0.2 ));}\n\nvec3 get_sky_plus_clouds( vec3 v, vec3 l, float ez, sampler2D aChannel1, vec3 aResolution, float aTime\n){\tvec3 col = get_sky( v, l, ez, true );\n\tvec3 cloud = get_cloud( v, aChannel1, aResolution, aTime  );\n\tvec3 sky_with_clouds =  col * mix( cloud_lowest_absorption_remap, 1., cloud.y ) + vec3( cloud.x ); // composite clouds, col * absorption + scattering\n\treturn mix( col, sky_with_clouds, smoothstep( 0., 0.025, v.z ) );} // fade to sky on thin horizon band\n\n\n// e = eye pos, v = view vector, p = lit point, n = normal, l = sun direction\nvec3 shadeSample(in vec3 e\n, in vec3 v\n, mat4 cam\n, in vec3 p\n, in vec3 n //surface normal (for reflection)\n, vec3 l\n, float shadow\n, TraceOutput to\n, float ao\n, vec2 uv\n, SceneOut eval\n, bool sky\n, sampler2D aChannel1\n, vec3 aResolution\n, float aTime\n){vec3 col=vec3(0)\n ;vec3 sunI=vec3(2)\n ;vec3 top_sky_color = get_sky(vec3(0,0,1),l,e.z,false)\n ;SG sun_lobe=CosineLobeSG(l)\n ;sun_lobe.Amplitude*=sunI\n ;SG sky_lobe=CosineLobeSG(vec3(0,0,1))\n ;sky_lobe.Amplitude*=top_sky_color\n ;if(!sky\n ){vec3 scene_color=vec3(0)\n  ;float bush_factor=0.\n  ;float tree_factor=0.\n  ;float pine_factor=0.\n  ;vec3 sky_reflection=vec3(0)\n  ;vec2 mm=DecodeId_16(eval.object_di)\n  ;float matid=mm.x\n  ;float matid_f=mm.y // we can have color variations within an id\n  ;bush_factor=smoothbump(MATID_BUSH,.5,matid)\n  ;tree_factor=smoothbump(MATID_TREE,.5,matid)\n  ;pine_factor=smoothbump(MATID_PINE,.5,matid)\n  ;vec4 mm4=DecodeId_5_5_5(eval.object_di) // yzw = depth uheight color_rnd\n  ;float tree_ao=mix(.6,1.,smoothstep(0.,.5,mm4.z)) // make it very faint, doesn't fit the style\n  ;scene_color=vec3(0)\n  +bush_factor*eval.color\n  +tree_factor*mix(mix(COLOR_TREE1,COLOR_TREE2,mm4.w ),COLOR_TREE_SURF,0.*mm4.y*mm4.y*mm4.y)*tree_ao\n  +pine_factor*mix(COLOR_PINE,COLOR_PINE2,mm4.w)* tree_ao\n  +smoothbump(MATID_NONE     ,.5,matid)*MAGENTA\n  +smoothbump(MATID_TRUNK    ,.5,matid)*COLOR_TRUNK\n  +smoothbump(MATID_HOUSE_TOP,.5,matid)*COLOR_HOUSE\n  +smoothbump(MATID_HOUSE_BOT,.5,matid)*COLOR_HOUSE_BOTTOM\n  +smoothbump(MATID_BRICKWALL,.5,matid)*COLOR_BRICKWALL\n  +smoothbump(MATID_ROOF     ,.5,matid)*mix(COLOR_ROOF1,COLOR_ROOF2 ,matid_f)\n  +smoothbump(MATID_GRASS    ,.5,matid)*mix(COLOR_GRASS,COLOR_GRASS2,matid_f)\n  +smoothbump(MATID_GROUND   ,.5,matid)*mix(COLOR_PATH1,COLOR_PATH2 ,matid_f)\n  ;if(MATID_WINDOW == matid\n  ){scene_color=BLACK\n   ;vec3 vr=reflect(v,n)\n   ;vec3 refl_color=get_sky_plus_clouds(vr,l,p.z,aChannel1,aResolution,aTime)\n   ;refl_color=mix(COLOR_GRASS*mix(.2,1.,shadow),refl_color,smoothstep(-.03,0.,vr.z))\n   ;sky_reflection=refl_color*mix( .2,1.,pow(1.-saturate(dot(-v,n)),2.))\n  ;}\n  ;if(MATID_GRASS == matid\n        ){\tvec3 lf = sfbm4_33( p * 40.0 );\n\t\t\tfloat hf = sfbm1_12( p.xy * 2800.0 );\n\t\t\tif ( matid_f > ( 1. - 0.04 )  // mowed lawn, should be rare\n\t\t\t){\tfloat period = 0.07;\n\t\t\t\tfloat s = stripes( rotate_with_angle( p.xy, matid_f * 1000.0 ).x, period, period * 0.25, 0.004 );\n\t\t\t\tscene_color = mix( COLOR_MOWED_GRASS, COLOR_MOWED_GRASS2, saturate( s + ( lf.x - 0.38 ) * 1.5 ) );}\n\t\t\t// just apply some noise\n\t\t\tscene_color *= 1.0 - 0.2 * ( saturate( 1.0 - lf.y ) );\n\t\t\tscene_color *= saturate( 1.0 - 0.4 * hf * saturate( 1.0 - lf.y ) );\t\t}\n\t\tvec3 albedo = scene_color; // return albedo;\n\t\tcol += shadow * SGDiffuseFitted( sun_lobe, n, albedo );\n\t\t// this way of doing diffuse makes shadow color be different on ground than back of object resting on it which sucks\n\t\tif ( _1 ) col += mix( SGDiffuseFitted( sky_lobe, n, albedo ), top_sky_color, SHADOW_TINT_SATURATION )\n\t\t\t\t// add more sky ambient to tint shadow in blue? in a way that is not too hacky?\n\t\t\t\t* mix( 0.15, 0.02, shadow )\n\t\t\t\t* ao;\n\t\tcol += sky_reflection;\n\t\tfloat d = length( p - e );\n\t\tif ( FOG_GROUND ) col = mix( col, get_fog_color() * 0.8, ( 1. - exp( -0.1 * max( d - 6.1, 0. ) ) ) * 0.378 ); // fog\n\t}else{\n\t\tcol = get_sky_plus_clouds( v, l, e.z, aChannel1, aResolution, aTime );\n\t\tif ( SUN ){ // this sun is the one in the sky\n\t\t\tvec4 ppd = sunGlareCoords( cam, v, l );\n\t\t\tcol += sunGlare( ppd, 0.007, 280., 100000.0, 0.2, 20.0, 4.0, 0.3, 0.4, 8., false )\n\t\t\t\t* vec3( 0.8, 0.8, 0.5 ) * sunI;}}\n\t// note: we would like to do SUN_GLARE here, but reprojection only works on solid world pos or distance sky\n\treturn col;}\n\nvec3 postProcess( vec3 col, vec2 uv, vec4 ppd\n){if ( SUN_GLARE\n  ){col.xyz += 0.116 * sunGlare( ppd, 0., 7., 8000.0, 0.2, 8.0, 8.0, 0.3, 2., 2., true )\n\t\t\t* vec3( 1., 0.7, 0.2 ) * 2. // use warmer color for this glare\n\t\t\t* smoothstep( -0.15, 0.3, ppd.w )\n\t\t\t* (1.0-smoothstep( 0.78, 0.9, ppd.z ));}\n\tfloat exposure = 3.0; \n\t// maybe auto expose when staring straight at the sun? the sun is a bit saturated on the clouds\n\t//exposure = mix(exposure,1.,smoothstep(0.985,1.0,1.-ppd.z));\n\tcol = exposure * tonemap_reinhard( col );\n//\tcol = max( vec3( 0. ), contrast( col, vec3( 1.02 ) ) );\n\tfloat vignette = .0 + 1. * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.15 );\n\tcol *= vignette;\n\tcol = contrast( col, vec3( 1.06 ) );\n\tcol = gamma_correction_itu( col );\n\treturn col;}\n\nstruct CameraRet {vec3 eye; vec3 target; float roll; float pitch;};\n\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\n\n// a cubicstep function that takes 2 arbitrary end points and 2 (begin end) slopes\nfloat cubicstep2(float x, vec2 p0, vec2 p1, float s0, float s1\n){x -= p0.x\n ;p1 -= p0\n ;x = clamp( x, 0., p1.x )\n ;float x1_sqr = p1.x * p1.x\n ;vec3 eq1 = vec3( 3.0 * x1_sqr, 2.0 * p1.x, s1 - s0 )\n ;vec3 eq2 = vec3( x1_sqr * p1.x, x1_sqr, p1.y - s0 * p1.x )\n ;float a = ( eq1.y * eq2.z - eq1.z * eq2.y ) / ( eq1.y * eq2.x - eq1.x * eq2.y )\n ;float b = ( eq1.z - eq1.x * a ) / eq1.y\n ;return p0.y+((a*x+b)*x+s0)*x;}\n\n//read by GetCameraTransform by mainScene is read by buffA and mainImage\nmat4 getCam(vec4 camRotQ,vec3 ro\n){mat3 camRotM=q2m(camRotQ);//camera rotation mat3 from quaternion\n ;mat4 ccc=mat4(vec4(camRotM[0],0)\n               ,vec4(camRotM[1],0)\n               ,vec4(camRotM[2],0)\n               ,vec4(ro,1));  //this MAY result in fisheye, not sure\n               //note, that FoV for rayDirection is done later.\n ;mat4 look=lookat(vec3(0,0,1),vec3(1,0,1),vec3(0,0,1))//user friendly init for a mult\n ;return look*ccc;}\n\nstruct CameraData{mat4 camera;float fovy;}; // what we need to write for the reprojection\n\n//return normal (and materialID?) (and distanceFog data?)\nvec3 normal(SceneIn scenein,float e,int F,float T,inout SceneOut eval_for_shade){\n   #if 0\n   ;SceneIn scenein2 = scenein\n   ;scenein2.p = scenein.p+vec3(e,0,0);v.x=evalScene(scenein2,F,T).object_di.d\n   ;scenein2.p = scenein.p+vec3(0,e,0);v.y=evalScene(scenein2,F,T).object_di.d\n   ;scenein2.p = scenein.p+vec3(0,0,e);v.z=evalScene(scenein2,F,T).object_di.d\n   ;eval_for_shade=evalScene(scenein,F,T)\n   ;v.w eval_for_shade.object_di.d\n   #else\n   ;vec4 v; // center in .w, deltas in .xyz\n   ;for ( int i = 0 FORCE_LOOP; i < 4; ++i //apparently identical forced-loop of above\n   ){SceneIn scenein2 = scenein\n    ;if ( i != 3 ) scenein2.p[i] += e        // let's live dangerously and use vector component random access\n\t;eval_for_shade = evalScene( scenein2, F, T )// eval_for_shade contains material data at center, at the end of the loop\n\t;v[i] = eval_for_shade.object_di.d;}\n   #endif\n   ;return normalize(v.xyz-vec3(v.w))\n ;}\n\n//mainScene is read by buffA and mainImage\nvec4 mainScene(vec2 U,float T,vec3 R,int F,vec4 M,sampler2D aChannel1,out vec4 O\n//uv,iTime,iResolutionframe,imouse\n,vec4 camRotQ,vec3 ro//camRot,camPos\n){vec2 u=U.xy/R.xy\n ;vec4 fragColor=vec4(0)\n ;CameraData cam\n ;cam.fovy=.6\n ;cam.camera=getCam(camRotQ,ro);\n ;Ray view_ray=get_view_ray2((u-vec2(.5))*2.,R.x/R.y,1./cam.fovy,cam.camera)\n ;float ao = 1.0\n ;vec3 sun_direction = get_sun_direction( T )\n ;bool sky = false\n ;float shadow = 1.0\n ;TraceOutput to\n ;vec3 p2\n ;vec3 norm //surface normal\n ;SceneOut eval_for_shade\n ;SceneOutInit(eval_for_shade)\n ;Ray trace_ray=view_ray\n ;int trace_flags=TRACE_VIEW\n ;int max_iterations=MAX_ITERATIONS_VIEW\n ;float tmaxmax=TMAX_VIEW\n ;// force a loop on view ray, shadow ray to prevent shadertoy compilation abject unrolling horror\n ;for (int pass = 0 FORCE_LOOP;pass<(SHADOWS?2:1);++pass\n ){TraceOutput tmp_to = traceScene( trace_ray,5., trace_flags\n  ,max_iterations,TFRAC,tmaxmax,DBREAK,u, U, F, T )\n  ;if ( pass == 1\n  ){//shadow = ( tmp_to.t > TMAX_SHADOW ? 1 : 0 ); // check hard shadows\n   ;//shadow = tmp_to.shadow; // default soft shadows, don't work well with this scene\n   ;shadow = mix( 0.05, 1.0, smoothstep( 0.4, 0.6, tmp_to.shadow ) ) // take a threshold on default soft shadows, good for sunny setting\n   ;break;}\n  ;// only view rays make it here... \n  ;to = tmp_to\n  ;p2 = view_ray.o + to.t * view_ray.d\n  ;sky = to.t > TMAX_VIEW\n  ;if ( sky ) break\n  ;// only view rays that hit solid surfaces make it here...\n  ;// evaluate normal vector at hit point, we will also retrieve extra material calculations\n  ;SceneIn scenein\n  ;scenein.p = p2\n  ;SetSceneInDirectionless( scenein, TRACE_SHADE )\n  ;scenein.t = 0.0\n  ;{// to set this epsilon, set the camera at 1000 and check fence and terrain normal...\n   ;// it should look the same as 0,0,0...\n   ;float e = 1e-3 * 2.\n   \n   //surface normal calculation:\n   ;norm = normal( scenein, e,F, T,  eval_for_shade)    \n  ;}  \n  ;if ( AO\n  ){SceneIn scenein2 = scenein\n   ;SetSceneInDirection( scenein2, p2, norm, TRACE_AO )  // shouldn't change anything\n   ;// https://iquilezles.org/www/material/nvscene2008/rwwtt.pdf\n   ;float delta = 0.1\n   ;float a = 0.0\n   ;float b = 1.0\n   ;for ( int i = 0 FORCE_LOOP; i < 4; i++\n   ){float fi = float( i )\n    ;scenein2.p = p2 + norm * delta * fi\n    ;float d = evalScene(scenein2,F,T).object_di.d\n    ;a += ( delta * fi - d ) * b\n    ;b *=.5;}\n   ;ao = max( 1.0 - 1.8 * a, 0.0 );}\n  ;if(SHADOWS\n  ){// hack: use a different normal offset for trees as noise shadows are very sensitive to that\n   ;vec4 mm4 = DecodeId_5_5_5( eval_for_shade.object_di )\n   ;float tree_ao = 1.0\n   ;if ( (mm4.x == MATID_TREE) || (mm4.x == MATID_PINE)\n   ){tree_ao += 1.0 - smoothstep( 0.2, 0.5, mm4.z )\n    ;tree_ao -= smoothstep( -0.2, 0.0, dot( sun_direction, norm ) )\n    ;tree_ao = saturate( tree_ao );}\n   ;// note: because of surface noise, tweaking the shadow ray normal bias has a lot of impact on vegetation\n   ;// might want to tweak it per surface too\n   ;trace_ray = mkray( p2 + norm * mix( 0.004, 0.0005, tree_ao ), sun_direction ) // if bias is too small here tree shadows become shitty\n   ;trace_flags = TRACE_SHADOW\n   ;max_iterations = MAX_ITERATIONS_SHADOW\n   ;tmaxmax = TMAX_SHADOW\n ;}}\n //surface normal [norm] is known by now\n ;fragColor.rgb=shadeSample(view_ray.o,view_ray.d,cam.camera,p2,norm\n ,sun_direction,shadow,to,ao,u,eval_for_shade,sky,aChannel1,R,T)\n ;O=sunGlareCoords(cam.camera,view_ray.d,sun_direction)\n ;fragColor.a = to.t// write depth in .w to recover the world position in reprojection\n ;return fragColor;}\n\n\n//vec2 NumSubpixels( vec3 aResolution){return aResolution.xy / 2.0; }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//Camera Controller (quaternion 2022-02)\n//also contains the non-quaternion camera controller (toggle is [camType] in commontab):\n\n//lots of paramerets for this exist in the commontab\n\n/*\nto enable camera-to-object collisions\n, the normals() and setting() distance field (and all its subroutines)\nneed to either be duplicated into the camera-movement buffer\n, OR moved into the common-tab\nThis may be too excessive and it tends to cause WAY too many namespace conflicts to be worth it.\n\nthis is its own fragment-buffer-tab  \njust for convenience + simplicity + compatibility (quick copying of whole buffers)\n\ninstead, it could just overlay its 4 bottom left pixel\nof in the actual image of another buffer (ccopying from another image-tab)\nwhich sure makes enabling-of-collisions much simpler (no duped code needed in that case)\n*/\n\n// // simpler camera, can not roll of https://www.shadertoy.com/view/wttyDX\n// // #define noRollCam     0\n// // quaternion cam,              of https://www.shadertoy.com/view/wtdyRs\n// // #define quaternionCam 1\n// // \n// // #define camType quaternionCam\n\n//note. for cvollision to work, this function needs df() and normal() functions\n//added to collide with a distanceField bacl along a surface normal\n//they are commented out in THIS shader\n\n//full alphabet + arrows\nconst int keyLe=37,keyUp=38,keyRi=39,keyDn=40\n,keyA=65,keyB=66,keyC=67,keyD=68,keyE=69,keyF=70,keyG=71,keyH=72,keyI=73,keyJ=74,keyK=75,keyL=76,keyM=77,keyN=78,keyO=79,keyP=80,keyQ=81,keyR=82,keyS=83,keyT=84,keyU=85,keyV=86,keyW=87,keyX=88,keyY=89,keyZ=90;\n\n\n/*\n//Keyboard constants (ESDF/arrows+TG+MouseDrag)\n//esdf is mor comparible than wasd (especially with french layout)\n//modify inputs by changing the ivec3() below (keys are defined in CommonTab)\nconst ivec3 klp=ivec3(keyF ,keyT ,keyE).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyS ,keyG ,keyD).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyR) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyW);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n/**/\n//some shaders have ditfferent pyr or camera matrix setups (handedness, negative view directions...)\n//you first fis the mouse quaternion cam (.swively.xyz for the PYR function, and THEN you rebind the keys here...\n//because straving comes AFTER rotation (quaternion modifies  strave directions)\n\nconst ivec3 klp=ivec3(keyT ,keyD ,keyF).zxy//right ,up  ,front      ==+linear strave\n           ,kln=ivec3(keyG ,keyE ,keyS).zxy//left  ,down,back       ==-linear strave\n           //... above .zxy swivel is a porting artefact\n           ,kap=ivec3(keyLe,keyUp,keyW) //kPitchLeft ,kJawUp  ,kRollRight ==+angular rotate\n           ,kan=ivec3(keyRi,keyDn,keyR);//kPitchRight,kJawDown,kRollLeft  ==-angular rotate\n/**/\n\n\n//above is from quat source, BUT \"English lane\" camera is messy, so i rather rebing and reorder pyr.\n\n\n//constant code:\nbool key(int k){return texelFetch(iChannel3,ivec2(k,0),0).x>0.5;}\nfloat kg(int k){return texelFetch(iChannel3,ivec2(k,0),0).x;}\nvec3 ks(ivec3 a){return vec3(kg(a.x),kg(a.y),kg(a.z));}//key input subroutine\nvec3 drag(vec3 r,vec3 a,float d){return (r+a*iTimeDelta)*(1.-d*iTimeDelta);}\n\n\n//convoluted structs wont EASILY give me what I need for colisions\n//and evalScene() is quite the big function\n//\n//SHOULD return distanceToSurface of point [u] to scene\n//BUT this bridge function fails to translate between structs, apparently.\n//it continuously collides\n//, likely because it constnatly returns too large values?\nfloat df(vec3 u){\n ;SceneIn scenein2\n ;int   F=iFrame\n ;float T=iTime\n ;return evalScene(scenein2,F,T).object_di.d;}\n\n//this still does not return a normal-useful for colisions...\n//return surface notmal of point [u] at scene\nvec3 normal(vec3 u\n){SceneIn scenein\n ;scenein.p = u\n ;float e=0.0001 //epsilon?\n ;int   F=iFrame\n ;float T=iTime\n ;SceneOut eval_for_shade;\n ;vec4 v=vec4(0)\n ;SceneIn scenein2 = scenein\n ;scenein2.p = scenein.p+vec3(e,0,0);v.x=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,e,0);v.y=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,0,e);v.z=evalScene(scenein2,F,T).object_di.d\n ;scenein2.p = scenein.p+vec3(0,0,0);v.w=evalScene(scenein2,F,T).object_di.d\n ;return normalize(v.xyz-vec3(v.w))\n// ;                                   v.w=eval_for_shade.object_di.d\n ;return normal(scenein,e,F,T, eval_for_shade);}\n\n#if (camType==0) \nvec4 cp0( //non quaternion camera\n){if(iFrame<1)return posStart;\n ;vec4 v=get(camP1)\n ;if(length(v.xyz)>0.1)return vec4(0);\n ;//if(w>0.)c.xyz+=0.1*vec3(sin(iTime),cos(iTime),0.)*speed\n ;return vec4(get(camP0).xyz+v.xyz*abs(v.w),0);}\n#else\nvec4 cp0( //quaternion camers\n//return camera linear Position.xyz (.w is unused)\n){if (iFrame<1)return posStart;\n ;vec3 r=get(camP0).xyz//camPos\n;if(PHYSICS_RADIUS>-99.){// gating to skip the colision calculation that is likely disabled anyways.\n  //include the function that estimates the surface normal of the df() function above this \n  //to push the camera away, alogn the surfaceNormal to avoid collisions\n  //then remove the commentingPut line / * below and you have some physics\n  //, use constants to set scaling.\n \n /*  //collissions overridden cause its bugged\n \n  ;float d=.1//PHYSICS_RADIUS\n  //;d=length(df(r)) //include df() as distance field function here to collide the dcamera\n  //;if (d>0.)r.xyz+=vec3(0.,0,PHYSICS_REPEL)//push up workaround that works without normal()\n  ;if (df(r)<d)r+=vec3(.1)//to debug only the df() returned value\n  //;if (df(r)<d)r-=vec3(1)// normalize(normal(r))*d //push camera away, alons surface normal.\n  //optional collision , needs normal() of the df()\n\n  /**/ \n  //collisions need the df() and its normal() function to be also here, or shared in commontab.\n ;}\n ;return vec4(r+(q2m(get(camA0),vec3(0))\n               *vec4(get(camP1).xyz,0)).xyz*iTimeDelta,0);}\n#endif\n\n#if (camType==0) \nvec4 cp1(  //non quaternion camera\n//return camera linear velocity.xyz a vec3 with speed.w as scalart, unaffected by change-of-direction\n){vec4 c=get(camP1)\n ;if(iFrame<1)c.w=CAMERA_SPEED\n ;if(key(keyQ))c.w*=1.01\n ;if(key(keyE))c.w*=0.99\n ;mat3 camera=getCam(get(camA0).xy)\n ;c.w=-sign(c.w)\n ;float s=abs(c.w)*iTimeDelta*.1\n ;if(key(keyUp)||key(keyE))c+=vec4( camera[0]*s,0)\n ;if(key(keyDn)||key(keyD))c+=vec4(-camera[0]*s,0)\n ;if(key(keyRi)||key(keyF))c+=vec4( camera[1]*s,0)\n ;if(key(keyLe)||key(keyS))c+=vec4(-camera[1]*s,0)\n ;c.xyz*=.8 \n ;return c;}\n#else   \n  //quaternion camera\nvec4 cp1(//return camera linear velocity.xyz (.w is unused)\n){return vec4(drag(get(camP1).xyz,LIN_ACCE*(ks(klp)-ks(kln)),LIN_DRAG),0);}\n#endif\n \nconst vec4 rotStart=vec4(-.27,.5,0,0)*pi;\n#if (camType==0) \nvec4 ca0( //non quaternion camera\n){if(iFrame<1)return rotStart\n ;vec4 c=get(camA0)\n ;c.xy=c.xy+c.zw*MOUSE_SENSITIVITY\n ;c.y=clamp(c.y,pi*.01,pi*.99)\n ;c.zw+=vec2(-1,1)*get(camA1).xy\n ;c.zw*=.6\n ;return c;} \n#else \n//quaternion camera\nvec4 ca0(//return camera angular Position.xyz (quaternion)\n){if (iTime < 0.1)return aa2q(vec3(0,0,1),-2.75)\n //;return normalize(qq2q(eYPR2q(iTimeDelta*get(camA1).zxy),get(camA0)));}\n ;return normalize(qq2q(eYPR2q(-iTimeDelta*get(camA1).yzx),get(camA0)));}\n#endif\n\n#if (camType==0) \n //non quaternion camera\nvec4 ca1(//mouse angularVelocity (just a mouse.xyxy doubleBuffer)\n){if(iFrame<1)return vec4(0,0,iM.xy)\n ;vec4 c=get(camA1)\n ;return vec4((length(iM.zw-iM.xy)>10.)?iM.xy-c.zw:vec2(0),iM.xy);}\n#else\n  //quaternion camera\nvec4 ca1(//return camera angular velocity.xyzw (quaternion)\n){vec3 a=ks(kap)-ks(kan)\n ;if(sign(iMouse.z)==1.)a.xy+=MOUSE_SENSITIVITY*(iM.xy-abs(iM.zw))/iR.xy;\n ;a=clamp(a,-1.,1.)\n ;a=a.yzx\n ;return vec4(drag(get(camA1).xyz,a*ANG_ACCE,ANG_DRAG)\n ,0.);}\n#endif\n\n//keyL and keyP may be used to position 2 seperate light sources \n//at the current camera position, when the key L/P is pressed\nvec4 lightPos(float q,int k,vec4 d\n){if(iFrame<1)return d\n ;vec4 c=get(q)\n ;if(key(k))c.xyz=get(camP0).xyz+vec3(LIGHT_RADIUS*1.3);\n ;return c;}\n \nvec4 cam4(float u//4 buffers for CameraControl\n){if(u<2.){if(u==camP0)return cp0();return ca0();}\n ;         if(u==camP1)return cp1();return ca1();}\n\n//2 buffers for 2 movable light sources\nvec4 switchcase(float u\n){u=floor(u)//essential\n ;if(u<4.)return cam4(u);\n ;if(u==camP0p)return get(camP0)//memorize previous pos\n ;if(u==camA0p)return get(camA0)//memorize previous angle\n ;if(u==li0P0)return lightPos(u,keyL,vec4(.2,.9,0,0))\n ;if(u==li1P0)return lightPos(u,keyP,vec4(-.9,0,0,0))\n ;return vec4(0);}\n\nvoid mainImage(out vec4 c,vec2 u\n){if(!(u.y<0.||u.x<NBuffB))discard\n ;c=switchcase(u.x);}\n \n ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//buffC.start\n//ichannel0=self\n//ichannel1=keyIn\n\n//this buffer has its own shitty cameraControls\n//, to be replaced by the camera control of BuffB\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\n//v3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\n//v3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\n//v3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\n//v3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\n//v2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\n\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.\n\n\n//--- all above code used to be in a commontab\n\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=qBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;//v4iSect form may be return v3(S+a.y*E,a.y)\n //where S and E are baricentric.xyz and a.x (or a.y) are the closest root.\n ;//we basically only care for the .w parameter\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.\n ){\n  ;return v2(.5)//if(ray misses AABV)return grey!\n ;}\n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){v2 //3 corners.xyx of a triangle\n//, that the bezier patch is pklaced above and below of\n//all ControllVectors only move in the .z direction.\n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\n\n//below code copied from https://www.shadertoy.com/view/DsKBDw\n//and then slowly modified to replace the camera, and to understand it more (compacting/aliasing...)\n \n// https://www.shadertoy.com/view/DsKBDw asymmetric blocks with portals reflections, 2023 by jt\n// based on https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d\n// Added reflections and stairs to https://www.shadertoy.com/view/msVfzw asymmetric blocks with portals 3d.\n// Thanks to Shane for suggesting the DDA-plugin / snap-to-voxel method & for the asymmetric blocks idea!\n\n// tags: 3d, random, reflections, t, blocks, portal, double, door, passage, connection, alternating, irregular, asymmetric\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// For correct ambient occlusion sample 2x2x2 voxels (slow!)\n//#define HIGH_QUALITY XXX CURRENTLY BROKEN DUE TO APPROXIMATE SDF AT PORTALS XXX\n\n/*\nfloat hash12(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);}\n\nvec2 hash22(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);}\n\nvec3 hash32(vec2 p){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);}\n\nvec3 hash33(vec3 p3){ // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);}\n*/\n\nstruct block{\n    vec4 center;\n    vec4 extent;\n    ivec2 id;\n    ivec2 id0;\n    ivec2 id1;\n    bool flag;};\n\nblock empty_block(){return block(vec4(0), vec4(0), ivec2(0), ivec2(0), ivec2(0), false);}\n\n#define block_offset 0.2\n#define wall_size 0.02\n\nfloat block_hash(ivec2 t, int x, int y, bool choose, bool mirror){\n    ivec2 d = (mirror?ivec2(y, x):ivec2(x, y));\n    //vec2 r = fract(hash22(vec2(t+d)))+vec2(d); // [0,1]\n    vec2 r = mix(vec2(block_offset), vec2(1.0 - block_offset), fract(hash22(vec2(t+d))))+vec2(d); // [constrained]\n    return choose?r.y:r.x;}\n\n// Inspired by https://www.shadertoy.com/view/Ws3GRs Asymmetric Blocks by Shane.\n// Checkerboard tiling of alternating (horizontal vs. vertical) (double-T-) crossings.\n// Returns minimum, maximum, id.\n// Compactified using implicit matrix transpose & deferred hash calls.\n//(NOTE: inlining the hash-function and using out parameters instead of block structure\n//       could be used to turn this into a stand-alone function.)\nblock blocks_layout(ivec2 tile, vec2 local){ // https://www.shadertoy.com/view/dstfzf asymmetric blocks compactified f by jt\n    //bool flip = (tile.x % 2) != (tile.y % 2); // XXX breaks on windows XXX\n    bool flip = (tile.x & 1) != (tile.y & 1); // alternate direction of double T crossings: vertical or horizontal\n    //flip = !flip; // \"dual\" pattern (i.e. T-crossings flipped)\n\n    // layout (NOTE: matrix notation upside down compared to coordinate system!)\n    // NW N NE\n    //  W C E\n    // SW S SE\n    // transposed (NOTE: matrix notation upside down compared to coordinate system!)\n    // SE W NE\n    //  N C S\n    // SW E NW\n    if(flip){ // horizontal line goes through: swap vertical with horizontal\n        // swap components\n        local = local.yx;}\n    // vertical line goes through (on flip transpose for horizontal line)\n    //                 c\n    //   +-+---------+---+-------+\n    //   | |         |   |       |\n    //   | |         |   #-------+ d\n    // d +-#-#-------+---M       |\n    //   |   |       |   |       |\n    //   +---+-------+---+-------+\n    //   |   |       |   |       |\n    //   |   m-------+---#---#---+\n    //   +---#       |       |   |\n    //   |   |       |       |   |\n    //   +---+-------+-------+---+\n    float c = block_hash(tile, 0, 0,  flip, flip); // offset of central line\n    int x = 1-int(local.x < c); // [0,1]\n    int X = 2*x-1; // [-1,+1]\n    float d = block_hash(tile,+X, 0, !flip, flip); // offset of branching line\n    float e = block_hash(tile,-X, 0,!flip, flip); // offset of branching line\n    int y = 1-int(local.y < d); // [0,1]\n    int Y = 2*y-1; // [-1,+1]\n    vec4 vv0 =\n        vec4 (\n            // primary corner in (0,0) tile\n            c,d,\n            // secondary corner in (0,0) tile\n            c,e);\n    vec4 vv1 = vec4(\n            // primary corner in (X,Y) tile\n            block_hash(tile,X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip),\n            // secondary corner in (X,Y) tile\n            block_hash(tile,2*X,Y, flip, flip),\n            block_hash(tile,0,Y,!flip, flip) );\n\n    if(flip) tile = tile.yx;\n    vv0 += vec2(tile).xyxy;\n    vv1 += vec2(tile).xyxy;\n    ivec2 id = tile + ivec2(x,y);\n    ivec2 id0 = tile + ivec2(1-x,1-int(local.y < e));\n    ivec2 id1 = tile + ivec2(1-x,1-int(local.y < e));\n\n    if(flip)    { // horizontal line goes through: unswap vertical with horizontal\n        vv0 = vv0.yxwz;\n        vv1 = vv1.yxwz;\n        id = id.yx;\n        id0 = id0.yx;\n        id1 = id1.yx;}\n\n    bool flag = vv0.y > vv1.y;\n    // using abs in conversion to center-extend fixes order of min/max corners\n    return block((vv0+vv1)/2.0, abs(vv0-vv1)/2.0, id, id0, id1, flag);}\n\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll){\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n    return R * S * T;}\n\nfloat halfspace(vec3 p){return p.z + 1.0;}\n\nfloat sphere(vec3 p, float r){    return length(p) - r;}\n\nfloat approx_crossing(vec3 p, float r)\n{//return sphere(p, r);\n    return max(length(p.xz)-r, length(p.yz)-r);\n}\n\nfloat box(vec2 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(p) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));}\n\nfloat box(vec3 p, vec3 p0, vec3 p1){\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0);}\n\nfloat box(vec2 p, vec2 p0, vec2 p1, float r){ // min-max box with rounded corner\n    return box(p-(p1+p0)/2.0, abs(p1-p0)/2.0-r)-r;}\n\nfloat box(vec3 p, vec3 p0, vec3 p1, float r){ // min-max box with rounded corner\n    float d = box(p.xy, p0.xy, p1.xy, r);\n    vec2 w = vec2(d, abs(p.z-(p1.z+p0.z)/2.0) - (p1.z-p0.z)/2.0);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat dot2( in vec2 v ){return dot(v,v);}\n\nfloat cone(vec3 p, float h, float r1, float r2){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 q = vec2(length(p.xy), p.z);\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );}\n\n/*\nfloat cylinder(vec3 p, vec2 s){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - s;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n*/\nfloat cylinder(vec3 p, float r, float h){ // adapted from https://iquilezles.org/articles/distfunctions/\n    vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));}\n\nfloat frame(vec2 p, vec2 s, float t){\n    return max(box(p, s),-box(p, s-t));}\n\nfloat frame(vec3 p, vec3 s, float t){\n    float d = frame(p.xy, s.xy, t);\n    // extrude https://iquilezles.org/articles/distfunctions/\n    vec2 w = vec2(d, abs(p.z) - s.z);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));}\n\nfloat vmax(vec2 v){return max(v.x, v.y);}\n\nvoid pR45(inout vec2 p){p = (p + vec2(p.y, -p.x))*sqrt(0.5);}\n\nfloat pMod1(inout float p, float size){\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;}\n\n// https://www.shadertoy.com/view/Xs3GRB HG SDF in WebGL by tomkh,\n// implementation of http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n){\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));}\n\n#define dd(a) dot(a,a)\n/*\nfloat make_cylinder_grid(vec3 l, float r){\n  return sqrt(min(\n            min(dd(l.xz-vec2(1.0,0))-r,dd(l.xz-vec2(0.0,0))-r),\n            min(dd(l.yz-vec2(1.0,0))-r,dd(l.yz-vec2(0.0,0))-r)));}\n    \n/*\n    float d =min(\n            min(length(l.xz-vec2(1.0,0))-r,length(l.xz-vec2(0.0,0))-r),\n            min(length(l.yz-vec2(1.0,0))-r,length(l.yz-vec2(0.0,0))-r)        );\n    return d;}\n /**/\n\n/*\nfloat make_cuboid_grid(vec3 l, float r, float s){\n    float d =min(\n            min(box(l.xz-vec2(1.0,0),vec2(r,s)), box(l.xz-vec2(0.0,0),vec2(r,s))),\n            min(box(l.yz-vec2(1.0,0),vec2(r,s)), box(l.yz-vec2(0.0,0),vec2(r,s)))        );\n    return d;} /**/\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\nstruct result{\n    float dist;\n    vec4 color_specular;\n    bool flag;};\n\nresult combine(result a, result b){\n    if(a.dist < b.dist) return a;\n    return b;}\nresult remove(result a, result b){\n    if(a.dist > -b.dist) return a;\n    return result(-b.dist, b.color_specular, b.flag);}\n\nvec3 colorize(ivec2 id){\n    vec3 color = hash32(vec2(id));\n    if(((id.x^id.y)&1)==0)\n        color = 1.0 - color;\n    vec3 n = vec3(1,1,1);\n    color -= 0.5*dot(color,n)*n/dot(n,n); // remove part of component along diagonal\n    return color;}\n\nresult map(ivec2 v, vec3 l){ // unit grid: voxel = float(position), local = fract(position)\n    result res = result(DIST_MAX, vec4(vec3(1), 0), false);\n    block b = blocks_layout(v.xy, l.xy);\n    float h = 0.2;\n    //float h = 0.2+0.1 * hash12(vec2(b.id));\n    //float h0 = 0.1 * hash12(vec2(b.id0));\n    //float h1 = 0.1 * hash12(vec2(b.id1));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy-wall_size,h), wall_size), vec4(colorize(b.id), 0), false));\n    res = combine(res, result(frame(vec3(v,0)+l-vec3(b.center.xy,0), vec3(b.extent.xy,h/* *0.9*/), wall_size), vec4(vec3(1), 0), false));\n    vec2 vv0 = b.center.xy - b.extent.xy - vec2(v);\n    vec2 vv1 = b.center.xy + b.extent.xy - vec2(v);\n    vec2 w0 = b.center.zw - b.extent.zw - vec2(v);\n    vec2 w1 = b.center.zw + b.extent.zw - vec2(v);\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y), h), vec4(vec3(1),0), false));\n    //res = combine(res, result(cylinder(vec3(v,0)+l-vec3(b.center.xy,0), 0.25*min(b.extent.x, b.extent.y)+0.05, 0.01), vec4(vec3(0.25),0), false));\n    \n/*\n    float cyl =\n        min\n        (\n            min\n            (\n                cylinder(l-vec3(v0.xy,0), h, 0.1),\n                cylinder(l-vec3(v1.xy,0), h, 0.1)\n            ),\n            min\n            (\n                cylinder(l-vec3(v0.x, v1.y,0), h, 0.1),\n                cylinder(l-vec3(v1.x, v0.y,0), h, 0.1)\n            )\n        );\n    res.dist = min(res.dist, cyl);\n*/\n    //if(true){{\n    if(!b.flag){{\n            vec3 c = vec3(vv1.x+w1.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv0.x+w0.x,vv0.y+w0.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv0.y-w0.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)), colorize(b.id0)));\n            //res = combine(res, result(sphere(l-c, max(e.x,e.y)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv1.x+2.0*wall_size,vv0.y+wall_size,0), vec3(w1.x-2.0*wall_size, w0.y-wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}else{{\n            vec3 c = vec3(vv0.x+w0.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv0.x-w0.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n\n            //res = combine(res, result(box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(vv0.x-2.0*wall_size,vv1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n        }{\n            vec3 c = vec3(vv1.x+w1.x,vv1.y+w1.y,0/*+h*/)/2.0;\n            vec3 e = abs(vec3(vv1.x-w1.x,vv1.y-w1.y,-h))/2.0 - wall_size;\n            //res = combine(res, result(box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)), colorize(b.id0)));\n            // remove wall at portal\n            //res.dist = max(res.dist,-box(l, vec3(v0.x-2.0*wall_size,v1.y-wall_size,0), vec3(w0.x+2.0*wall_size, w1.y+wall_size, 0.25)));\n            res = remove(res, result(approx_crossing(l-c, max(e.x,e.y)-wall_size), vec4(vec3(1),0), false));\n    }}\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = remove(res, result(make_cylinder_grid(l-vec3(0,0,h), 0.1), vec4(vec3(1),0), false));\n    //res = combine(res, result(make_cuboid_grid(l-vec3(0,0,h*0.6), 0.05, 0.005), vec4(vec3(0.25),0), false));\n    //res = combine(res, result(l.z, vec3(1))); // floor\n    float f = l.z; // floor\n    float cone_south = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y-b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_north = cone(vec3(v,0)+l-vec3(b.center.x,b.center.y+b.extent.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_west = cone(vec3(v,0)+l-vec3(b.center.x-b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    float cone_east = cone(vec3(v,0)+l-vec3(b.center.x+b.extent.x,b.center.y,0.0), h-0.0001, .0, h/4.0);\n    //res.dist = min(res.dist, cone0);\n    f = fOpUnionStairs(f, min(min(cone_south, cone_east), min(cone_north, cone_west)), h, 10.0);\n    res = combine(res, result(f, vec4(1.-colorize(b.id), 1), true)); // floor\n    return res;}\n    \n#ifdef HIGH_QUALITY\n//for correct AO, we must sample 2x2x2 voxels, much slower\nresult map(vec3 p){\n    // I think kastorp originally suggested to sample only 2x2x2 instead of 3x3x3, thanks!\n    result d = result(DIST_MAX, vec4(vec3(0),0), false);\n    ivec2 s = ivec2(step(0.5, fract(p.xy)));\n    ivec2 o;\n    for(o.y = s.y-1; o.y < s.y+1; o.y++)\n        for(o.x = s.x-1; o.x < s.x+1; o.x++){\n            result r = map(ivec2(floor(p.xy))+o, vec3(fract(p.xy), p.z)-vec3(o,0));\n            if(r.dist < d.dist)\n                d = r;\n    }return d;}\n#else\n//much less taps \nresult map(vec3 p){return map(ivec2(floor(p.xy)), vec3(fract(p.xy), p.z));}\n#endif\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p){\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy*map(p + k.xyy*h).dist +\n                     k.yyx*map(p + k.yyx*h).dist +\n                     k.yxy*map(p + k.yxy*h).dist +\n                     k.xxx*map(p + k.xxx*h).dist);}\n\n// NOTE: Apparently sign fails on some systems! Thanks to spalmer for debugging this!\n// WORKAROUND FOR COMPILER ERROR on some systems\nvec2 sgn(vec2 v){return step(vec2(0), v) * 2.0 - 1.0;}\n\nresult trace(vec3 ro, vec3 rd, float t0, float t1){ // ray-march sdf handling discontinuities between voxels  (jt)\n    result h;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++) { // finite loop originally suggested by pyBlob to avoid stalling if ray parallel to surface just above EPSILON\n        vec3 p = ro + rd * t;\n        h = map(p);\n        if(h.dist < EPSILON)return result(t, h.color_specular, h.flag);\n\n        // NOTE: An extra step per block, use if sdf discontinuous between blocks\n        //       Could make this conditional by prefixing sth. like if(block_changed) // suggested by spalmer\n        // constrain step to blocks (voxel-snap ray-march plugin by jt, thanks to Shane for the idea!)\n        {\n            block b = blocks_layout(ivec2(floor(p.xy)), fract(p.xy));\n            // NOTE: assuming unit grid\n            // sgn(rd)*extent are the block walls in ray direction, fract(p) - center is position relative to center of block\n            //vec2 sd = (sgn(rd.xy)*b.extent.xy - (fract(p.xy) - (b.center.xy-floor(p.xy))))/rd.xy; // distances to block sides / walls\n            vec2 sd = (sgn(rd.xy)*b.extent.xy - p.xy + b.center.xy)/rd.xy; // distances to block sides / walls\n            vec2 n = step(sd.xy, sd.yx); // component true if corresponding wall is nearest (at most one component true) NOTE: originally I used lessThanEqual, min from fb39ca4/kzy then switched to step, min by iq\n            float skip = dot(sd, n) + EPSILON; // distance to next block: sum up all components, weighted by the nearest flag (assuming only one component is true this selects the nearest component)\n            h.dist = min(h.dist, skip); // constrain step to at most next block to handle sdf discontinuities between voxels\n        }t += h.dist;}\n    return result(t, h.color_specular, h.flag);} \n    // stop on running out of iterations\n    //return result(t1, vec4(0), false); // pass on running out of iterations\n\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\n//       Thanks to spalmer for pointing that out.\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1){\n    return trace(ro, rd, t0, t1).dist < t1 ? 0.0 : 1.0;}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k){\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)    {\n        float h = map(ro + rd*t).dist;\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }return res;}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor ){\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).dist;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;}\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );}\n\nfloat checker(vec2 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi));}\n\nfloat checker(vec3 p){\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi)*sin(p.z*pi));}\n\nvec3 material(vec3 p){\n    //return vec3(1.0-pow(0.5+0.5*sin(p.z*pi*10.0), 50.0))\n    return vec3(1.0)\n    //return mix(vec3(0.25), vec3(0.75), checker(p*2.0+0.5))\n;}\n\nvec3 sky(vec3 lightdir, vec3 d){// no particular meaning - just tweaked until it looks skyish\n    float v = 0.5*abs(d.z)+0.5;\n    return vec3(pow(1.0-v,2.0),1.0-v,v);}\n\n\nfloat sun(vec3 lightdir, vec3 rd){// sun with halo\n    float d = max(0.0, dot(rd, lightdir));\n    return smoothstep(0.998, 0.999, d) + exp(-pow((1.0-d)*500.0, 2.0));} \n\n\nvec3 pass(vec3 ro, vec3 rd, result r){\n    vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,1),abs(-rd.z));\n    //vec3 sky_color = mix(vec3(0.2,0.5,0.5),vec3(0,0,0.5),sqrt(abs(rd.z)));\n    vec3 sky_color = sky(lightdir, rd);\n    sky_color += sun(lightdir, rd);\n    vec3 color = vec3(1);\n    if(r.dist < DIST_MAX){\n        color *= r.color_specular.xyz;\n        vec3 dst = ro + rd * r.dist;\n        vec3 n = normal(dst);\n        //color *= (n * 0.5 + 0.5);\n        //color *= material(dst);\n        vec3 ambient = vec3(0.4);\n        float brightness = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness *= shadow(ro + rd * r.dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness);\n\n        if(brightness > 0.0){\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular * r.color_specular.w;}\n\n        vec3 fog_color = sky_color;\n        color = mix(fog_color, vec3(color), exp(-pow(r.dist/20.0, 2.0))); // fog\n    }else{\n        color *= sky_color;\n    }return color;}\n\nfloat grey(vec3 color){return dot(color, vec3(1.0/3.0));}\n\nvoid scene2(vec3 ro, vec3 rd, inout vec4 fragColor){\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma\n\n\n//#define     noQuaterionCam_Use_DsKBDw_instead\n\n#ifdef        noQuaterionCam_Use_DsKBDw_instead\n//https://www.shadertoy.com/view/DsKBDw , modified to remain functional as \n//mainImage() instead of mainImage2()\n//while using a subroutine to work merged with quaternionCameras of\n//https://www.shadertoy.com/view/wtdyRs (oldest)\n//https://www.shadertoy.com/view/DsKBDw (newer)\nvoid mainImage(out vec4 fragColor, vec2 I){\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    //I = (4.0 * floor(I * 0.5) + 2.0 - R) / R.y; // integrated pixelize (speedup & looks cool) thanks to spalmer\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    vec3 rd = normalize(vec3(I.xy, 2.0));\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    ro.z += 0.0;\n    \n    scene2(ro,rd,fragColor);}\n    /*\n    result res = trace(ro, rd, 0.0, DIST_MAX);\n    vec3 color = pass(ro, rd, res);\n    if(res.dist < DIST_MAX && res.flag){\n        //color = vec3(1);\n        ro.z = -ro.z;       // reflect camera position\n        rd.z = -rd.z;        // reflect view direction\n        res = trace(ro, rd, res.dist+0.01, DIST_MAX);\n        vec3 reflection = pass(ro, rd, res);\n        //color *= reflection; // clear\n        //color = mix(color, reflection, 0.5); // muddy (light)\n        color *= mix(vec3(1), reflection, 0.5); // muddy (dark)\n        //color += reflection; // additive\n        //color *= grey(pass(ro, rd, res)); // unrealistic\n    }\n    color = tanh(color); // roll-off overly bright colors\n    fragColor = vec4(color, 1);\n    fragColor = sqrt(fragColor);} // approximate gamma*/\n\n#else\n\n//quaternion camera control canvas\nconst float FOV=1.;\nvoid mainImage(out v3 O,v1 U\n){vec4 q=get(camA0) //get camera rotation as quaternion\n ;mat3 cam=q2m(q)   //camera matrix from camera quaternion.\n ;vec2 uv=(U-0.5*iResolution.xy)/iResolution.y //scale uv to range [-1..1]\n ;vec3 rd=normalize(cam*vec3(1.,FOV*uv))//rayDirection for uv from camera matrix \n ;vec3 ro=get(camP0).xyz\n \n //alternative scene of parent shader https://www.shadertoy.com/view/DsKBDw\n //kept here as example on how to modiy a shader to fit in here.\n //;O=v3(scene(ro,rd),1);//tracing a triangle,bend up+down by 3 sides, that are flat-triangle-orthogonal quadratic-beziers.\n //;return;\n \n //make a scene(rayorigin,raydirection) or scene2(rayorigin,raydirection,fragColor) function\n //that returns a fragment color for uv.xy[-1..1] \n ;vec4 fragColor=vec4(1);\n //scene2(get(camP0).xyz,rd,fragColor);\n ;vec4 ppd\n ;//Ray view_ray=Ray(rd,ro);\n ;vec4 col = mainScene( U, iTime, iResolution, iFrame,iMouse, iChannel2, ppd,q,ro);\n ;col.rgb=postProcess( col.rgb, U / iResolution.xy, ppd );\n O=col;\n ;} \n \n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}