{
    "Shader": {
        "info": {
            "date": "1585657827",
            "description": "A variant on [url]https://www.shadertoy.com/view/4sVcDG[/url] showing a plane section through a hypercubic lattice. See code for details.",
            "flags": 48,
            "hasliked": 0,
            "id": "tdsyW2",
            "likes": 8,
            "name": "Hypercubic Honeycomb II",
            "published": 3,
            "tags": [
                "honeycomb",
                "hypercubic"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Created 2018, updated 2020, by Matthew Arcus\n//\n// Display a section through a hypercubic lattice in R4.\n// Earlier version: https://www.shadertoy.com/view/4sVcDG\n// Inspired by: https://www.shadertoy.com/view/Mts3Wl by TekF\n//\n// This just shows the point and edge intersections (by default - to\n// see the faces press 'f') which appear as spheres and\n// ellipsoids. When the section plane passes through a vertex, the\n// point sphere appears and the ellipsoids corresonding to the four\n// grid lines at that vertex all pass through each other. The colours\n// on the edge ellipsoids indicate the faces at that point (each face\n// appears as an elliptical cylinder in section).\n//\n// <mouse>: rotate\n// <up>/<down>: move in/out\n// f: show face intersections\n// i: apply inversion\n// p: show point intersections\n// q: R4 rotation\n// t: R4 translation\n// x: fold\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool doinvert = true;\nbool dofold = true;\nbool dofaces = false;\nbool dopoints = true;\nbool dotranslate = false;\nbool doquaternion = true;\n\nconst float maxdist = 20.0;\nvec3 laxis = normalize(vec3(0,0,1));\nvec3 raxis = normalize(vec3(1,2,3));\nfloat fwidth = 0.04;\nfloat ewidth = 0.08;\nfloat pwidth = 0.12;\nconst float precis = 0.001;\n\nconst vec3 Face0Color = vec3(1,0,0);\nconst vec3 Face1Color = vec3(0,1,0);\nconst vec3 Face2Color = vec3(0,0,1);\nconst vec3 Face3Color = vec3(1,1,0);\nconst vec3 Face4Color = vec3(1,0,1);\nconst vec3 Face5Color = vec3(0,1,1);\nconst vec3 EdgeColor = vec3(0.1,0.1,0.1);\nconst vec3 PointColor = vec3(1);\n\nconst float PI\t= 3.141592;\n\nint type = 0; // Set this if we hit a point.\nvec4 lquat,rquat; // Quaternions for R4 rotation.\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n//#define assert(x)\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvoid qinit() {\n  float t = iTime;\n  float ltheta = 0.1*t;\n  float rtheta = 0.065*t;\n  lquat = vec4(sin(ltheta)*laxis,cos(ltheta));\n  rquat = vec4(sin(rtheta)*raxis,cos(rtheta));\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec4 iproject(vec3 p3) {\n  float t = iTime;\n  vec4 p = vec4(p3,0);\n  if (dotranslate) {\n    p.w = sin(0.2*t);\n    //p.xw = rotate(p.xw,0.2*t); \n  }\n  if (doquaternion) {\n    p = qmul(p,rquat);\n    //p = qmul(lquat,p);\n  }\n  return p;\n}\n\nvec4 map(vec3 p, inout float scale) {\n  if (doinvert) {\n    float c = cos(0.25*iTime);\n    float r = 1.0/c;\n    float r2 = r*r;\n    p.x -= r-c;\n    float k = r2/dot(p,p);\n    p *= k;\n    scale *= k;\n    p.x += r-c;\n  }\n  vec4 p4 = iproject(p);\n  return p4;\n}\n\nfloat scene(vec4 pos4) {\n  float d = 1e8;\n  if (dofold) {\n    pos4 = fract(pos4);\n    pos4 = min(pos4,1.0-pos4);\n  }\n  type = 0;\n  // Distance from edges - these appear as points, usually\n  d = min(d,length(pos4.xyz) - ewidth);\n  d = min(d,length(pos4.yzw) - ewidth);\n  d = min(d,length(pos4.zwx) - ewidth);\n  d = min(d,length(pos4.wxy) - ewidth);\n  // Distance from faces - these appear as lines, usually\n  if (dofaces) {\n    d = min(d,length(pos4.xy) - fwidth);\n    d = min(d,length(pos4.yz) - fwidth);\n    d = min(d,length(pos4.zx) - fwidth);\n    d = min(d,length(pos4.xw) - fwidth);\n    d = min(d,length(pos4.yw) - fwidth);\n    d = min(d,length(pos4.zw) - fwidth);\n  }\n  if (dopoints) {\n    float k = length(pos4) - pwidth;\n    if (k < d) { type = 1; d = k; }\n  }\n  return d;\n}\n\nvec3 getColor(vec3 p3){\n  if (type == 1) return PointColor;\n  float k, d = 1e8;\n  vec4 p = map(p3,k);\n  if (dofold) {\n    p = fract(p);\n    p = min(p,1.0-p);\n  }\n  vec3 col = EdgeColor;\n  d = 1e8;\n  d = min(d,length(p.xyz) - ewidth);\n  d = min(d,length(p.yzw) - ewidth);\n  d = min(d,length(p.zwx) - ewidth);\n  d = min(d,length(p.wxy) - ewidth);\n  if (true) {\n    // Do the face colouring always, so they show up on the edges.\n    k = length(p.xy) - fwidth;\n    if (k < d) { d = k; col = Face0Color; }\n    k = length(p.yz) - fwidth;\n    if (k < d) { d = k; col = Face1Color; }\n    k = length(p.zx) - fwidth;\n    if (k < d) { d = k; col = Face2Color; }\n    k = length(p.xw) - fwidth;\n    if (k < d) { d = k; col = Face3Color; }\n    k = length(p.yw) - fwidth;\n    if (k < d) { d = k; col = Face4Color; }\n    k = length(p.zw) - fwidth;\n    if (k < d) { d = k; col = Face5Color; }\n  }\n  return col;\n}\n\nfloat de(vec3 p3) {\n  float scale = 1.0;\n  vec4 p = map(p3,scale);\n  float d = scene(p);\n  return d/scale;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n  vec2 e = vec2(t*precis, 0.0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n  float t = 0.1;\n  for(int i = 0; i < 200; i++) {\n    //assert(i < 100);\n    float h = de(ro + rd * t);\n    if (h < t*precis) return t;\n    if (doinvert) h *= 0.5;\n    t += h;\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  //p.yz = rotate(p.yz,iTime * 0.125);\n  //p.zx = rotate(p.zx,iTime * 0.2);\n  return p;\n}\n\nconst int CHAR_F = 70;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_T = 84;\nconst int CHAR_X = 88;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nbool keypress(int code) {\n    return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dofaces = keypress(CHAR_F);\n  doinvert = keypress(CHAR_I);\n  dopoints = !keypress(CHAR_P);\n  doquaternion = !keypress(CHAR_Q);\n  dotranslate = !keypress(CHAR_T);\n  dofold = !keypress(CHAR_X);\n  qinit();\n  \n  vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n  vec3 bgcol = 0.5+(0.25-0.25*p.y)*vec3(1,1,0);\n  p *= 3.0;\n  vec3 ro = vec3(0,0,-2.5);\n  vec3 rd = vec3(p, 6.0);\n  vec3 li = vec3(0.5, 2.0, -1);\n  ro.z *= 1.0 + 0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP));\n\n  ro = transform(ro);\n  rd = transform(rd);\n  li = transform(li);\n  rd = normalize(rd);\n  li = normalize(li);\n  vec3 col = bgcol;\n  float t = march(ro, rd);\n  if (t > 0.0) {\n    vec3 p = ro + t * rd;\n    vec3 n = calcNormal(p,t);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col = getColor(p) * (0.2+0.8*diffuse);\n    col = mix(col,bgcol,t/maxdist);\n  }\n  col = pow(col, vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0) {\n      t = vec4(0);\n    } else {\n      t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}