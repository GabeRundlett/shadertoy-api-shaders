{
    "Shader": {
        "info": {
            "date": "1603412761",
            "description": "Einstein is kool <insert sunglasses emoji>",
            "flags": 32,
            "hasliked": 0,
            "id": "3dKcRV",
            "likes": 7,
            "name": "Black Hole Test",
            "published": 3,
            "tags": [
                "test",
                "noise",
                "blackhole",
                "volumetrics"
            ],
            "usePreview": 1,
            "username": "milesWaugh",
            "viewed": 623
        },
        "renderpass": [
            {
                "code": "vec3 tex(vec2 fragCoord, vec2 off) {\n    return texture(iChannel0, (fragCoord + off) / iResolution.xy).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(0.);\n\n    for(int i = -2; i < 3; i++) {\n        for(int j = -2; j < 3; j++) {\n            /*float mul = 1.;\n            if(i*j == 0){mul=2.; if(i+j == 0){ mul = 4.;}}*/\n            col += tex(fragCoord, vec2(i, j)) / (dot(vec2(i, j), vec2(i, j)) + .5);\n        }\n    }\n\n    col /= 40.;\n    col = (1. - (1. / (1. + (4. * (col * col))))) * 1.;\n    float br = (col.x + col.y + col.z) / 3.;\n    col = col + .2 * (col - br);\n    col = vec3(pow(max(col.x - .02, .0), .6), pow(max(col.y - .02, 0.), .55), pow(col.z, .6));\n    br = (col.x + col.y + col.z) / 3.;\n    col = col + .2 * (col - br);\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Modeling how light bends around a black hole to render an accretion disk\n\n//Accretion disk simulates volumbetric emmission and volumetric absorption\n\n//Strength of gravity\n#define gravitationalConstant 0.022\n\n//Higher values are better quality but slower. Higher values also cause more gravity and brighter accretion disk.\n//Simulation precision when moving through empty space\n#define minorStep 10000.\n//Simulation precision when moving through accresion disk\n#define majorStep 15000.\n\n#define rot -sin(iTime/7.)/3.\n#define c cos(rot)\n#define s sin(rot)\n#define c2 cos(.4)\n#define s2 sin(.4)\n#define s3 sin(iTime/3.)\n#define c3 cos(iTime/3.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(int(fragCoord.y) % 4 == iFrame % 4) {\n        vec2 co = fragCoord.xy;\n        vec2 uv = ((co + texture(iChannel1, vec3(co.x, co.y, iTime) / 32.).xy) - iResolution.xy / 2.) / iResolution.x;\n        uv = vec2(c2 * uv.x - s2 * uv.y, c2 * uv.y + s2 * uv.x) / 1.1;\n        uv += 5. * (texture(iChannel3, vec2(iTime / 64., iTime * 4.)) - .5).xy / iResolution.x;\n        vec3 pos = vec3(0., 0., -7.);\n        vec2 rotpos;\n        vec3 vel = vec3(uv.x, uv.y, 1.) * 1.8;\n        vec3 col = vec3(0.);\n        float gravity = 0.;\n        float dt = 1.;\n        vec3 gravdir = vec3(0.);\n        int iters = 0;\n        float step = 800.;\n        vec2 sgn = vec2(1., 1.);\n        int switches = 0;\n        vec3 emit = vec3(1. / 1.1, 1. / 2., 1. / 3.5);\n        vec3 absorb = vec3(0.995, 1., 1.005);\n        \n        while(iters < 2048 && pos.z < 5. && dot(pos, pos) > .01 && switches < 3) {\n            gravity = gravitationalConstant / dot(pos, pos);\n            gravdir = normalize(-pos);\n            float stepcur = 2. * step * texture(iChannel0, vec3(float(iters) / 32., pos.x, pos.y)).r;\n            stepcur += step;\n            stepcur /= 2.;\n            dt = gravity * stepcur;\n            vel += gravdir * gravity;\n            sgn = vec2(sgn.y, vel.z / abs(vel.z));\n            if(sgn.x / sgn.y < 0.) {\n                switches++;\n            }\n            pos += vel / dt;\n            iters++;\n            rotpos = vec2(c * pos.z - s * pos.y, c * pos.y + s * pos.z);\n            vec2 xz = vec2(pos.x, rotpos.x);\n            float rad = dot(xz, xz);\n            float thickness = pow((30. - rad) / 2., 0.25) / 2. - 0.49;\n            if(rad < 30. && abs(rotpos.y) < thickness && dot(pos, pos) > 1.) {\n                float noise = 0.;\n                float scale = 6.;\n                vec3 posr = vec3(pos.x * c3 - pos.z * s3, pos.y, pos.z * c3 + pos.x * s3);\n                for(int i = 0; i < 4; i++) {\n                    noise += texture(iChannel0, posr / scale).r * pow(scale, 0.8) * 0.04;\n                    scale /= 2.;\n                }\n                float ch = min(max((noise * 20. - (abs(rotpos.y) - thickness) * 40. - 10.5), 0.), 1.);\n                col += (ch * 0.09) * emit;\n                col *= (1.05 - ch * 0.15) * absorb;\n                if(step == minorStep) {\n                    step = -minorStep;\n                } else {\n                    step = majorStep;\n                }\n            } else {\n                if(step == -minorStep) {\n                    step = majorStep;\n                } else {\n                    step = minorStep;\n                }\n            }\n        }\n        \n        col = max(col, 0.);\n        fragColor = (vec4(col, 1.0) * 20. + texture(iChannel2, fragCoord / iResolution.xy)) / 21.;\n    } else {\n        fragColor = texture(iChannel2, fragCoord / iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    },
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}