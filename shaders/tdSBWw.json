{
    "Shader": {
        "info": {
            "date": "1590138871",
            "description": "My first glsl project.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdSBWw",
            "likes": 1,
            "name": "Reshaping sphere",
            "published": 3,
            "tags": [
                "raymarching3d"
            ],
            "usePreview": 0,
            "username": "kotfind",
            "viewed": 322
        },
        "renderpass": [
            {
                "code": "#define ROTATION\n#define LIGHT_SOURCE_ATTACHED_TO_CAMERA\n#define LIGHTING\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 100.;\n\nconst float colissiondist = 0.00001;\nconst int maxIter = 1000;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nfloat f(in vec3 p) {\n    return distance(p, vec3(0., 0., 0.)) - 2. + sin(p.x * 10.) * sin(iTime * 2.);\n}\n\nvoid dist(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = f(p);\n    color = vec3(1., 0., 0.);\n    color = vec3(sin(p.x * 3.)  + sin(p.y * 5.)  * cos(p.z * 100.), \n                 sin(p.x * 30.) * sin(p.y * 1.)  + sin(p.z * 2.),\n                 sin(p.x * 9.)  * cos(p.y * 25.) + sin(p.z * 700.));\n    const float E = 0.000001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        dist(orig, d, color, norm);\n        #ifdef LIGHTING\n            #ifdef LIGHT_SOURCE_ATTACHED_TO_CAMERA\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(viewpoint - dir))));\n            #else\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(vec3(0., 3., 4.) - dir))));\n            #endif\n        #else\n            if (d < colissiondist) return color;\n        #endif\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.1;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 7.;\n    viewpoint.z = cos(a) * 7.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}