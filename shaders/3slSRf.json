{
    "Shader": {
        "info": {
            "date": "1551785247",
            "description": "Ray-tracing. All description is in readme.txt or comments in code\n\nmade by Arbuzov Petr, 312 group, spring 2019.",
            "flags": 0,
            "hasliked": 0,
            "id": "3slSRf",
            "likes": 2,
            "name": "Ray-Tracing by Petr Arbuzov",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "arbuzovp",
            "viewed": 395
        },
        "renderpass": [
            {
                "code": "//Made by Arbuzov Petr , 312 group, spring 2019.\n//Read readme.txt\n\n/*19-21 баллов:\n-Основная часть +15\n-Мягкие тени +2-3\n-Анти-алиасинг +1\n-Отражения +1\n-Неочевидная геометрия(поворот оражневого цилиндра с помощью матрицы поворота) +1 на ваше усмотрение. \n\n*/\n\n\n#define MAX_DISTANCE 100.\n#define SURF_DISTANCE .001\n#define STEPS_MAX 1000\n\n#define REFLECTION 2\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat length8(vec2 v)\n{\n    float x = v.x;\n    float y = v.y;\n    x = pow(x, 8.);\n    y = pow(y, 8.);\n    \n    return pow(x+y, 1./8.);\n}\n\n\n\nstruct Ray{\n    vec3 ro;\n    vec3 rd;\n};\n    \nstruct Light{\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Material{\n    vec3 dif;\n    vec3 amb;\n};\n\nstruct Dist{\n\tfloat dist;\n    Material mat;\n    bool exist;\n};\n        \nstruct Hit{\n\tvec3 point;\n    Material mat;\n    bool exist;\n};\n        \n\n\nDist DistSurface(vec3 p) {\n    \n    //Считаем расстояние до поверхностей и сохраняем материалы\n    \n    //Зеленая сфера, синий эллипсоид, розовый квадратный тор,\n    //Оранжевый цилиндр, бордовый бокс\n\tvec4 s = vec4(0, 1.1, 6, 1);\n    \n    vec3 spdif = vec3(0., 1., 0.);\n    \n    vec3 pd = vec3(0.8, 0.8, 0.8);\n    \n    vec3 cyl = vec3(1.5, 1.5, 4);\n    \n    vec3 box = vec3(2., .4, 3.);\n    \n    vec3 boxdif = vec3(1., 0., 0.7);\n    \n    vec3 cyldif = vec3(1., 160./255., 0.);\n    \n    vec3 r = vec3(.4, 1., .6);\n    vec3 rd = vec3(0., 0.1, 1.);\n    \n    \n    vec2 t = vec2(.4, 0.15);\n    \n    \n    vec2 q = vec2(length8((p - vec3(-.5, .2, 4.3)).xz)-t.x,(p - vec3(-.5, .2, 4.)).y);\n    float tord =  length8(q)-t.y;\n    vec3 tordif = vec3(255./256., 203./256., 219./256.);\n    \n\n    float coned = (length( (p - vec3(-2., 1.1, 4.))/r ) - 1.0) * min(min(r.x,r.y),r.z);\n\n    \n    float sphereDist =  length(p-s.xyz);\n    sphereDist -= s.w;\n    float planeDist = p.y;\n    \n   \n    vec2 h = vec2(.5, .25);\n    \n    vec3 cp = p - cyl.xyz;\n    \n    float Pi = 3.1415926;\n    \n    cp.xy *= Rot(Pi/2.);\n   \n    \n    vec2 dc = abs(vec2(length(cp.xz),cp.y)) - h;\n    float cylDist = min(max(dc.x,dc.y),0.0) + length(max(dc,0.0));\n    \n    vec3 b = vec3(.6, .3, .3);    \n    \n    float boxDist =  length(max(abs(p - box.xyz)-b,0.0));\n  \n    \n    \n    \n    Dist d;\n    \n    d.dist = min(sphereDist, planeDist);\n    d.dist = min(d.dist, cylDist);\n    d.dist = min(d.dist, coned);\n    d.dist = min(d.dist, tord);\n    d.dist = min(d.dist, boxDist);\n    if (sphereDist < planeDist)\n        d.mat.dif = spdif;\n    else\n        d.mat.dif = pd;\n    if (d.dist == coned)\n        d.mat.dif = rd;\n    else\n        if (d.dist == cylDist)\n            d.mat.dif = cyldif;\n        else\n            if (d.dist == tord)\n                d.mat.dif = tordif;\n            else\n                if (d.dist == boxDist)\n                \td.mat.dif = boxdif;\n            \n    //Нужно взять расстояние от точки до ближайшей поверхности и сохранить материал\n    return d;\n}\n\nDist RayMarching(Ray ray) {\n\tDist distOrigin;\n    distOrigin.dist = 0.;\n    distOrigin.exist = true;\n    for(int i=0; i<STEPS_MAX; i++) {\n    \tvec3 p = ray.ro + ray.rd*distOrigin.dist;\n        distOrigin.mat = DistSurface(p).mat;\n        distOrigin.dist += DistSurface(p).dist;\n        if (distOrigin.dist > MAX_DISTANCE) { distOrigin.exist = false;  break; }\n        if(DistSurface(p).dist<SURF_DISTANCE) break;\n    }\n    //Просто Ray Marching. Двигаемся кругами, считаем расстояние до поверхности,\n    //пока оно не будет меньше погрешности или больше максимального\n    return distOrigin;\n}\n\nvec3 CountNormal(vec3 p) { \n\tDist d = DistSurface(p);\n    vec2 e = vec2(.01, 0);\n    \n    float x =  DistSurface(p-e.xyy).dist; \n    float y =  DistSurface(p-e.yxy).dist;\n    float z  = DistSurface(p-e.yyx).dist;\n    \n    vec3 nnn = vec3(x, y, z);\n    \n    vec3 n = d.dist - nnn;\n    \n    n = normalize(n);\n       \n    return n; \n}\n\nvec3 GetLum(Hit hit, Light light) {\n    \n    vec3 n = CountNormal(hit.point);\n    vec3 vec = light.pos - hit.point;\n    vec3 l = normalize(vec);\n    \n    float shin = dot(n, l);\n    shin = clamp(shin, 0., 1.);\n    vec3 difcomp = hit.mat.dif * light.color;\n    \n    \n    vec3 dif = shin * difcomp;\n    \n    vec3 origin = hit.point + n*SURF_DISTANCE*4.;\n    \n    Ray ray;\n    ray.ro = origin;\n    ray.rd = l;\n    \n    Dist d = RayMarching(ray);\n    if(d.dist < length(vec)) dif *= .3;\n    //Создаем затенение\n    \n    return dif;\n}\n\nvec3 CountColor(Ray ray)\n{\n    Dist d = RayMarching(ray);\n    Hit hit;\n    vec3 po = ray.ro;\n    po += ray.rd * d.dist;\n    hit.point = po;\n    hit.mat = d.mat;\n    hit.exist = d.exist;\n    \n    Light lightArr[2];\n    lightArr[0].pos = vec3(3., 5., 6.);\n    lightArr[0].color = vec3(.5 ,.5, .5);\n    \n    \n    lightArr[1].pos = vec3(-1., 6., 0.);\n    lightArr[1].color = vec3(.8 ,.8, .8);\n    \n    \n    \n\n    \n\tvec3 color = vec3(0.,0.,0.);\n\tvec3 k = vec3(1.0, 1.0, 1.0);\n\tfor(int i=0;i < REFLECTION;i++)\n\t{\n\t\td = RayMarching(ray);\n \t\tvec3 point = ray.ro;\n        point += ray.rd * d.dist;\n        hit.point = point;\n \t\thit.mat = d.mat;\n \t\thit.exist = d.exist;\n \t\tif (!hit.exist)\n \t\t\tbreak;\n \n \t\t//пересчитываем точку падения луча, с учетом материалов\n\n    \n    \n \t\tfor(int i=0;i < 2;i++)\n \t\t{\n    \t\t for (int j=0; j < 2; j++){\n        \t\t for (int e = 0; e < 2; e++){\n            \t \n      \t     \t\tlightArr[i].pos += vec3(0.03 * float(e) * (-1. + float(j) * 2.), 0., 0.);\n        \t\t\t\n         \t\t\tcolor += k*GetLum(hit, lightArr[i]);\n   \t\t\t    \tlightArr[i].pos -= vec3(0.03 * float(e) * (-1. + float(j) * 2.), 0., 0.);\n         \t       //создаем мягкие тени, сдвигаем источник по x и по y, пересчитываем освещенность, затем усредним \n     \t    \t }\n     \t\t\t}\t\n    \n \t\t}\n \tcolor /= 4.;\n \tray.rd = reflect(ray.rd, CountNormal(hit.point));\n        ray.ro = hit.point;\n    ray.ro += CountNormal(hit.point) * SURF_DISTANCE * 2.;\n \tk = k * hit.mat.dif;\n\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy + 0.001)/iResolution.y;\n    //центрируем систему координат\n       \n    vec3 ro = vec3(0, 1.2, 0);\n    vec3 dir = vec3(uv.x, uv.y, 1);\n    vec3 rd = normalize(dir);\n    \n    //создаем источник лучей и задаем направление\n    \n    Ray ray[4];\n    \n    \n    vec3 Xmove = vec3(0.5/iResolution.x, 0.0, 0.0);\n    vec3 Ymove = vec3(.0, 0.5/iResolution.y, 0.0);\n    ray[0].rd = rd + Xmove;\n    ray[1].rd = rd + Ymove;\n\tray[2].rd = rd - Xmove;\n    ray[3].rd = rd - Ymove;    \n    //создаем 4 направления луча для анти-алисинга, каждый сдвигаем на пол-пикселя.\n    \n    vec3 col = vec3(0., 0., 0.);\n    \n    for (int i = 0; i < 4; i++)\n    {\n        ray[i].ro = ro; \n        vec3 color = CountColor(ray[i]);\n        col += color;\n    }\n    \n    col /= 4.; \n    //anti-aliasing, пускаем 4 луча на каждый пиксель\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}