{
    "Shader": {
        "info": {
            "date": "1567503678",
            "description": "exp(-avg_angle/solid_angle) is displayed with a heatmap palette\navg_angle = PI / (2 * N * N)\nat degree 3 smallest/largest ~ 1/4\nSee https://math.stackexchange.com/questions/3342761/octahedral-facet-solid-angle",
            "flags": 32,
            "hasliked": 0,
            "id": "tlBXDd",
            "likes": 7,
            "name": "Octahedral facet solid angle",
            "published": 3,
            "tags": [
                "octahedralsegmentsolidangle"
            ],
            "usePreview": 0,
            "username": "aschrein",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "float get_slider(int id)\n{\n    return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy).r;\n}\n\nvec3 get_on_octahedron(vec2 p) {\n\treturn vec3(p.x, p.y, 1.0 - p.x - p.y);\n}\n\nfloat get_angle(vec3 a, vec3 b) {\n\treturn acos(\n        \tdot(a, b)/\n        \tsqrt(\n                dot(a, a) * dot(b, b)\n            \t)\n    \t);\n}\n\nvec3 get_angle_3(vec3 a, vec3 b, vec3 c) {\n\treturn vec3(\n        get_angle(a, b),\n        get_angle(b, c),\n        get_angle(c, a)\n        );\n}\n\n// Src\n// https://math.stackexchange.com/questions/1211287/how-to-find-out-the-solid-angle-subtended-by-a-tetrahedron-at-its-vertex\n\nfloat get_solid_angle_vanilla(vec3 a) {\n\treturn acos(\n        \t(cos(a.x) - cos(a.y) * cos(a.z)) / (sin(a.y) * sin(a.z))\n        )\n        -\n        asin(\n        \t(cos(a.y) - cos(a.x) * cos(a.z)) / (sin(a.x) * sin(a.z))\n        )\n        -\n        asin(\n        \t(cos(a.z) - cos(a.y) * cos(a.x)) / (sin(a.y) * sin(a.x))\n        );\n}\n\n// See https://math.stackexchange.com/q/3343709\nfloat get_solid_angle_enhanced(vec3 a) {\n    float C = acos(\n        \t(cos(a.z) - cos(a.y) * cos(a.x)) / (sin(a.y) * sin(a.x))\n        );\n    float k = tan(a.x / 2.0) * tan(a.y / 2.0);\n\treturn 2.0 * atan(\n    \tk * sin(C),\n        1.0 + k * cos(C)\n    );\n}\n// Optimized\nfloat get_solid_angle_enhanced_1(vec3 a, vec3 b, vec3 c) {\n    float aa = dot(a, a);\n    float bb = dot(b, b);\n    float cc = dot(c, c);\n    float ab = dot(a, b);\n    float sab = aa * bb - ab * ab;\n    float bc = dot(b, c);\n    float sbc = bb * cc - bc * bc;\n    float ca = dot(c, a);\n    float sca = aa * cc - ca * ca;\n    float cos_C = (ca * bb - ab * bc);\n    float sin_C = sqrt(sab * sbc - cos_C * cos_C);\n    // tan(B/2) = ± √(1 − cos B)/(1 + cos B)\n    float cos_B = ab;\n    float k_B = sqrt(aa*bb);\n    float cos_A = bc;\n    float k_A = sqrt(cc*bb);\n    float k = (k_B - cos_B) * (k_A - cos_A);\n\treturn 2.0 * atan(\n    \tsin_C,\n        sqrt((sab * sbc * (k_A + cos_A) * (k_B + cos_B)) / k) + cos_C\n    );\n}\n// Optimized #2\nfloat get_solid_angle_enhanced_2(vec3 a, vec3 b, vec3 c) {\n    float aa = 1.0;\n    float bb = 1.0;\n    float cc = 1.0;\n    float ab = dot(a, b);\n    float sab = aa * bb - ab * ab;\n    float bc = dot(b, c);\n    float sbc = bb * cc - bc * bc;\n    float ca = dot(c, a);\n    float sca = aa * cc - ca * ca;\n    float cos_C = (ca * bb - ab * bc);\n    float sin_C = sqrt(sab * sbc - cos_C * cos_C);\n    // tan(B/2) = ± √(1 − cos B)/(1 + cos B)\n    float cos_B = ab;\n    float k_B = sqrt(aa*bb);\n    float cos_A = bc;\n    float k_A = sqrt(cc*bb);\n    float k = (k_B - cos_B) * (k_A - cos_A);\n\treturn 2.0 * atan(\n    \tsin_C,\n        sqrt((sab * sbc * (k_A + cos_A) * (k_B + cos_B)) / k) + cos_C\n    );\n}\nvoid get_oct_points(vec3 p, float N,\n                   out vec2 p0,\n                   out vec2 p1,\n                   out vec2 p2\n                   ) {\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 frac = N * p.xy;\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n  p0 = parity == 1.0 ? (xy + vec2(1.0, 1.0))/N : xy/N;\n  p1 = (xy + vec2(1.0, 0.0))/N;\n  p2 = (xy + vec2(0.0, 1.0))/N;\n}\n\nvec4 render_1(in vec2 fragCoord) {\n    float OCTAHEDRON_DEGREE = floor(MAX_OCTAHEDRON_DEGREE * get_slider(0));\n    // Setup camera state\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ty = 2.0 * uv - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    float camera_distance = 25.0;\n    vec3 camera_up = vec3(0.0, 0.0, 1.0);\n    vec3 camera_lookat = vec3(0.0, 0.0, 0.0)/2.0;\n    vec2 mouse_uv = iMouse.xy / iResolution.xy;\n    \n    vec3 camera_pos = camera_distance * vec3(\n        sin(mouse_uv.y * 10.0 + 3.141592/4.0) * cos(mouse_uv.x * 10.0),\n        sin(mouse_uv.y * 10.0 + 3.141592/4.0) * sin(mouse_uv.x * 10.0),\n        cos(mouse_uv.y * 10.0 + 3.141592/4.0)\n    ) + camera_lookat;\n    \n    vec3 camera_look = normalize(camera_lookat - camera_pos);\n    vec3 camera_left = normalize(cross(camera_look, camera_up));\n    camera_up = normalize(cross(camera_left, camera_look));\n    // PI/2 fov\n    vec3 ray_dir = normalize(camera_look + ty.x * camera_left * aspect + ty.y * camera_up);\n    vec3 normal;\n    \n    vec3 total_val = vec3(0.6, 0.5, 0.12) * grid(camera_pos, ray_dir);\n    \n    float t1, t2;\n    if (intersect_sphere(camera_pos, ray_dir, vec3(0.0, 0.0, 0.0), 16.0, normal, t1, t2)) {\n    \t\n        vec3 dir = normalize(camera_pos + ray_dir * t1);\n        if (dir.z > 0.0) {\n            float N = pow(2.0, OCTAHEDRON_DEGREE);\n           \tvec2 p0, p1, p2;\n            get_oct_points(dir, N, p0, p1, p2);\n            float avg_angle = PI / (2.0 * N * N);\n            float solid_angle = get_solid_angle_enhanced_2(\n                normalize(get_on_octahedron(p0)),\n                normalize(get_on_octahedron(p1)),\n                normalize(get_on_octahedron(p2)));\n            \n            total_val =\n                (1.0 - 0.4 * get_oct_line(dir, N).x) *\n            fireGradient(exp(-avg_angle/solid_angle));\n            \n        }\n    }\n    return vec4(total_val,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = render_1(fragCoord) + texture(iChannel0, fragCoord.xy / iResolution.xy).xyzw;   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/**\n * -----------------------------------------------------------\n * -- User Interface\n * -----------------------------------------------------------\n *\n *     'UI Easy to Integrate' - XT95\n *     https://www.shadertoy.com/view/ldKSDm\n */\n\n#define MAX_DIGIT 2\n#define FLOAT_PRECISION 2\n#define SLIDER_LENGTH 128.\n#define WIDGET_COLOR vec3(0.0)\n\n/* global var */  vec4  col = vec4(0.); vec2 pos = vec2(0.);  vec2 uv = vec2(0.);\n/* char sprite */ vec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000); vec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000); vec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000); vec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000); vec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000); vec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000); vec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000); vec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000); vec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000); vec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000); vec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000); vec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000); vec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000); vec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000); vec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000); vec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000); vec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000); vec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000); vec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000); vec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000); vec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000); vec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000); vec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000); vec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000); vec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000); vec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000); vec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000); vec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000); vec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000); vec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000); vec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000); vec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000); vec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000); vec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000); vec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000); vec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000); vec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000); vec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000); vec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000); vec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000); vec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000); vec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000); vec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000); vec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000); vec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000); vec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000); vec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000); vec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000); vec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000); vec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00); vec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000); vec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000); vec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000); vec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000); vec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000); vec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000); vec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000); vec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000); vec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000); vec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000); vec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000); vec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000); vec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000); vec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00); vec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000); vec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000); vec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000); vec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000); vec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000); vec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000); vec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78); vec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000); vec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000); vec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78); vec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000); vec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000); vec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000); vec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000); vec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000); vec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0); vec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E); vec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000); vec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000); vec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000); vec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000); vec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000); vec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000); vec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000); vec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0); vec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000); vec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000); vec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000); vec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000); vec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000); vec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n#define _a  col += vec4( char(ch_a) );\n#define _b  col += vec4( char(ch_b) );\n#define _c  col += vec4( char(ch_c) );\n#define _d  col += vec4( char(ch_d) );\n#define _e  col += vec4( char(ch_e) );\n#define _f  col += vec4( char(ch_f) );\n#define _g  col += vec4( char(ch_g) );\n#define _h  col += vec4( char(ch_h) );\n#define _i  col += vec4( char(ch_i) );\n#define _j  col += vec4( char(ch_j) );\n#define _k  col += vec4( char(ch_k) );\n#define _l  col += vec4( char(ch_l) );\n#define _m  col += vec4( char(ch_m) );\n#define _n  col += vec4( char(ch_n) );\n#define _o  col += vec4( char(ch_o) );\n#define _p  col += vec4( char(ch_p) );\n#define _q  col += vec4( char(ch_q) );\n#define _r  col += vec4( char(ch_r) );\n#define _s  col += vec4( char(ch_s) );\n#define _t  col += vec4( char(ch_t) );\n#define _u  col += vec4( char(ch_u) );\n#define _v  col += vec4( char(ch_v) );\n#define _w  col += vec4( char(ch_w) );\n#define _x  col += vec4( char(ch_x) );\n#define _y  col += vec4( char(ch_y) );\n#define _z  col += vec4( char(ch_z) );\n#define _A  col += vec4( char(ch_A) );\n#define _B  col += vec4( char(ch_B) );\n#define _C  col += vec4( char(ch_C) );\n#define _D  col += vec4( char(ch_D) );\n#define _E  col += vec4( char(ch_E) );\n#define _F  col += vec4( char(ch_F) );\n#define _G  col += vec4( char(ch_G) );\n#define _H  col += vec4( char(ch_H) );\n#define _I  col += vec4( char(ch_I) );\n#define _J  col += vec4( char(ch_J) );\n#define _K  col += vec4( char(ch_K) );\n#define _L  col += vec4( char(ch_L) );\n#define _M  col += vec4( char(ch_M) );\n#define _N  col += vec4( char(ch_N) );\n#define _O  col += vec4( char(ch_O) );\n#define _P  col += vec4( char(ch_P) );\n#define _Q  col += vec4( char(ch_Q) );\n#define _R  col += vec4( char(ch_R) );\n#define _S  col += vec4( char(ch_S) );\n#define _T  col += vec4( char(ch_T) );\n#define _U  col += vec4( char(ch_U) );\n#define _V  col += vec4( char(ch_V) );\n#define _W  col += vec4( char(ch_W) );\n#define _X  col += vec4( char(ch_X) );\n#define _Y  col += vec4( char(ch_Y) );\n#define _Z  col += vec4( char(ch_Z) );\n#define _spc  col += vec4( char(ch_spc) );\n#define _float(a)  col += vec4(print_float(a));\n#define _int(a)  col += vec4(print_int(a));\n#define _slider(x,y,id,v) setCursor(x,y);print_slider(id,v);\n#define _color(x,y,id,v) setCursor(x,y);print_color(id,v);\n#define _box(p,s,c) print_box(p,s,c);\n#define _cursor(x,y)  setCursor(x,y);\nvoid setCursor(int x, int y){pos = vec2(float(x),iResolution.y-float(y));}float extract_bit(float n, float b){    b = clamp(b,-1.0,24.0);    return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   }float sprite(vec4 spr, vec2 size, vec2 uv){    uv = floor(uv);    float bit = (size.x-uv.x-1.0) + uv.y * size.x;    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));        float pixels = 0.0;    pixels += extract_bit(spr.x, bit - 72.0);    pixels += extract_bit(spr.y, bit - 48.0);    pixels += extract_bit(spr.z, bit - 24.0);    pixels += extract_bit(spr.w, bit - 00.0);        return bounds ? pixels : 0.0;}float char(vec4 ch){    float px = sprite(ch, vec2(8, 12), uv - pos);    pos.x += 8.;    return px;}vec4 get_digit(float d){    d = floor(d);    if(d == 0.0) return ch_0;    if(d == 1.0) return ch_1;    if(d == 2.0) return ch_2;    if(d == 3.0) return ch_3;    if(d == 4.0) return ch_4;    if(d == 5.0) return ch_5;    if(d == 6.0) return ch_6;    if(d == 7.0) return ch_7;    if(d == 8.0) return ch_8;    if(d == 9.0) return ch_9;    return ch_0;}float print_float(float number){    float result = 0.0;        for(int i = MAX_DIGIT-1; i >= -FLOAT_PRECISION;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);                if(i == -1)        {            result += char(ch_per);        }                if((abs(number) > pow(10.0, float(i))) || i <= 0)        {            result += char(get_digit(digit));        }    }     return result;}float print_int(float number){    float result = 0.0;        for(int i = MAX_DIGIT;i >= 0;i--)    {        float digit = mod( number / pow(10.0, float(i)) , 10.0);        if(abs(number) > pow(10.0, float(i)) || i == 0)        {            result += char(get_digit(digit));        }    }       return result;}vec3 hsv2rgb( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}vec3 widgetSelected(){    return texture(iChannel0, vec2(.5,2.5)/iResolution.xy).rgb;}vec4 uiSlider(int id){return texture(iChannel0, vec2(float(id)+.5,0.5)/iResolution.xy);}vec4 uiColor(int id){return texture(iChannel0, vec2(float(id)+.5,1.5)/iResolution.xy);}float roundBox( in vec2 p, in vec2 b, in float r ) {    vec2 q = abs(p) - b;    vec2 m = vec2( min(q.x,q.y), max(q.x,q.y) );    float d = (m.x > 0.0) ? length(q) : m.y;     return d - r;}void print_slider( int id, float v ){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 value = uiSlider(id);    if(value.a == 0.)        value.r = v;        bool selected = ( select.r == .1 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tvalue.r = clamp((iMouse.x-pos.x-2.)/SLIDER_LENGTH,0.,1.);    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3((clamp( 1.3-abs(d) , 0., 2.))*max(.0,-sign(uv.x-pos.x-value.r*SLIDER_LENGTH))*.5 );    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        float oldx = pos.x;    pos.x += SLIDER_LENGTH-8.*4.;    _float(value.r)    pos.x = oldx;        if(puv.x == float(id) && puv.y==0.)        col = vec4(value.r,0.,0.,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.1,float(id)/255.,0.,0.);    }}void print_color( int id, vec3 v){    vec2 puv = uv-vec2(.5);    vec3 select = widgetSelected();    float sl2 = SLIDER_LENGTH/2.;    vec4 color = uiColor(id);    if(color.a == 0.)        color.rgb = v;        bool selected = ( select.r == .2 && select.g*255. == float(id) );    bool mouseAndNoSelect = iMouse.w>.5 && roundBox( iMouse.xy-pos-vec2(sl2,6.), vec2(sl2,3.), 5.) < 0. && select.r == 0.;         if(mouseAndNoSelect || selected)    \tcolor.rgb = hsv2rgb( vec3( (iMouse.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );    float d = roundBox( uv-pos-vec2(sl2,6.), vec2(sl2,3.), 5.);    float layer = clamp(sign(-d),0.,1.);    col.rgb += vec3( layer*color*max(.0,sign(uv.x-pos.x-SLIDER_LENGTH*.9)));    col.rgb += WIDGET_COLOR*vec3( clamp( 1.-abs(d)*.75 , 0., 1.) );    col.a += layer + clamp( 1.-abs(d) , 0., 1.);        if((mouseAndNoSelect || selected) && uv.x-pos.x-SLIDER_LENGTH*.9<0.)        col.rgb += layer*hsv2rgb( vec3( (uv.x-pos.x)/(SLIDER_LENGTH*.9),1.,1.) );            if(puv.x == float(id) && puv.y==1.)        col = vec4(color.rgb,1.);        if(puv.x == 0. && puv.y == 2.)    {        if(iMouse.w<.5)            col = vec4(0.);        else if(mouseAndNoSelect)        \tcol = vec4(.2,float(id)/255.,0.,0.);    }}void print_box(vec2 p, vec2 s, vec4 c){    if(uv.x>p.x && uv.x <p.x+s.x && uv.y>p.y && uv.y<p.y+s.y)        col += c;}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uv = fragCoord.xy;\n    \n    int rx = int(iResolution.x * 0.5) - 150;\n    int ry = int(iResolution.y) - 10;\n    \n    if(uv.x-.5 == 0. && uv.y-.5 == 2.)\n        col = vec4(widgetSelected(),0.);\n        \n    _slider(rx, ry, 0, 0.6) _D _e _e _g _r _e\n        \n       \n    //_slider(rx - 150, ry, 1, 0.6) _I _m _p _l\n        \n    fragColor = min(col.rgba, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159265359\nfloat MAX_OCTAHEDRON_DEGREE = 10.0;\n// Palette by Inigo Quilez\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 hueGradient(float t) {\n    vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\n\treturn (clamp(p - 1.0, 0.0, 1.0));\n}\nvec3 rainbow(float x) {\n\treturn //hueGradient(x);\n        pal(fract(x), vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n// Src: https://www.shadertoy.com/view/4dsSzr\nvec3 fireGradient(float t) {\n\treturn max(pow(vec3(min(t * 1.02, 1.0)), vec3(1.7, 25.0, 100.0)), \n\t\t\t   vec3(0.06 * pow(max(1.0 - abs(t - 0.35), 0.0), 5.0)));\n}\n//------------------------------------------------------------------------------------------\n// Hammersley Sampling\n//------------------------------------------------------------------------------------------\n// Src: https://www.shadertoy.com/view/4lscWj\n\nvec2 Hammersley(float i, float numSamples)\n{   \n    uint b = uint(i);\n    \n    b = (b << 16u) | (b >> 16u);\n    b = ((b & 0x55555555u) << 1u) | ((b & 0xAAAAAAAAu) >> 1u);\n    b = ((b & 0x33333333u) << 2u) | ((b & 0xCCCCCCCCu) >> 2u);\n    b = ((b & 0x0F0F0F0Fu) << 4u) | ((b & 0xF0F0F0F0u) >> 4u);\n    b = ((b & 0x00FF00FFu) << 8u) | ((b & 0xFF00FF00u) >> 8u);\n    \n    float radicalInverseVDC = float(b) * 2.3283064365386963e-10;\n    \n    return vec2((i / numSamples), radicalInverseVDC);\n} \n\nvec3 SampleHemisphere_Uniform(float i, float numSamples)\n{\n\tvec2 xi = Hammersley(i, numSamples);\n    \n    float phi      = xi.y * 2.0 * PI;\n    float cosTheta = 1.0 - xi.x;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\nvec3 SampleHemisphere_Cosinus(float i, float numSamples)\n{\n    vec2 xi = Hammersley(i, numSamples);\n    \n    float phi      = xi.y * 2.0 * PI;\n    float cosTheta = sqrt(1.0 - xi.x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n     \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n}\n\n\n//------------------------------------------------------------------------------------------\n//------------------------------------------------------------------------------------------\n\nfloat nrand( float n )\n{\n\treturn fract(sin(n * 12.9898)* 43758.5453);\n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nbool intersect_sphere(vec3 camera_pos, vec3 ray_dir, vec3 pos,\n                      float radius, out vec3 out_normal, out float out_t1,  out float out_t2) {\n    vec3 dr = pos - camera_pos;\n    float dr_dot_v = dot(dr, ray_dir);\n    float c = dot(dr, dr) - dr_dot_v * dr_dot_v;\n    float radius2 = radius;\n    radius2 = radius2 * radius2;\n    if (c < radius2) {\n        float t = dr_dot_v;\n        if (t < -1.0e-3)\n            return false;\n        float dt = sqrt(radius2 - c);\n        out_t1 = t - dt;\n        out_t2 = t + dt;\n        out_normal = normalize(camera_pos + ray_dir * t - pos);\n        return true;\n    }\n    return false;\n    \n}\n\nvec2 to_angle(vec3 p) {\n\t\n    p = normalize(p);\n    float theta = acos(p.z);\n    vec2 xy = normalize(p.xy);\n    float phi = acos(xy.x);\n    if (xy.y < 0.0)\n        phi = 2.0 * PI - phi;\n    return vec2(phi, theta);\n}\n\nbool intersect_plane(vec3 p, vec3 n, vec3 ray, vec3 ray_origin, out vec3 hit) {\n  vec3 dr = ray_origin - p;\n  float proj = dot(n, dr);\n  float ndv = dot(n, ray);\n  if (proj * ndv > -1.0e-6) {\n    return false;\n  }\n  float t = proj / ndv;\n  hit = ray_origin - ray * t;\n  return true;\n}\n\n\nvec3 mkbary(vec2 p) {\n  return vec3(p,1.0-dot(p,vec2(1)));\n}\nfloat linedistance2(vec3 p, vec3 A, vec3 B) {\n  vec3 d = B-A;\n  vec3 q = A+dot(p-A,d)/dot(d,d)*d;\n  return dot(p-q,p-q);\n}\nconst float linewidth2 = 0.001*0.001;\nvec3 get_oct_line(vec3 p, float N) {\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 frac = N * p.xy;\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n\n  vec3 A = mkbary((xy+vec2(1,0))/N);\n  vec3 B = mkbary((xy+vec2(0,1))/N);\n  vec3 C = mkbary((parity==0.0?xy:xy+vec2(1))/N);\n  if (linedistance2(p,A,B) < linewidth2 ||\n      linedistance2(p,B,C) < linewidth2 ||\n      linedistance2(p,C,A) < linewidth2 ||\n      false) {\n    return vec3(1.0, 1.0, 1.0);\n  }\n    return vec3(0);\n}\n\nvec3 my_sign(vec3 v)\n{\n    return vec3(\n        v.x < 0.0 ? -1.0 : 1.0,\n        v.y < 0.0 ? -1.0 : 1.0,\n        v.z < 0.0 ? -1.0 : 1.0\n        );\n}\n\nfloat get_oct_id(vec3 p, float N) {\n  vec3 side = vec3(my_sign(p)) * 0.5 + vec3(0.5);\n  float octant_id = dot(side, vec3(1.0, 2.0, 4.0));\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 frac = N * p.xy;\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n  float index = 2.0*xy.x + parity;\n  index = clamp(index,0.0,2.0*(N-xy.y-1.0));\n  float k = xy.y - 1.0;\n  index += clamp((k + 1.0) * ((2.0 * N - 1.0) - k), 0.0, N * N);\n  return octant_id * N * N + index;\n}\n\n\nfloat get_oct_id_zpos(vec3 p, float N) {\n  vec3 side = vec3(my_sign(p)) * 0.5 + vec3(0.5);\n  float octant_id = dot(side, vec3(1.0, 2.0, 0.0));\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 frac = N * p.xy;\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n  float index = 2.0*xy.x + parity;\n  index = clamp(index,0.0,2.0*(N-xy.y-1.0));\n  float k = xy.y - 1.0;\n  index += clamp((k + 1.0) * ((2.0 * N - 1.0) - k), 0.0, N * N);\n  return octant_id * N * N + \n      index;\n}\n\nvec2 get_oct_2id_zpos(vec3 p, float N) {\n  vec3 side = vec3(my_sign(p)) * 0.5 + vec3(0.5);\n  p = abs(p);\n  p /= dot(p,vec3(1));\n  vec2 frac = N * p.xy;\n  vec2 xy = clamp(floor(frac),0.0,N-1.0);\n  frac -= xy;\n  float parity = float(dot(frac,vec2(1)) > 1.0);\n  float index = 2.0*xy.x + parity;\n  index = clamp(index,0.0,2.0*(N-xy.y-1.0));\n  float k = xy.y - 1.0;\n  return vec2(index, xy.y);\n}\n\nvec3 grid(vec3 camera_pos, vec3 ray_dir) {\n    float sa = hash(17.9898);\n    vec3 total_val = vec3(0.0, 0.0, 0.0);\n\tvec3 hit_pos;\n    for (uint iter = 0u; iter < 4u; iter++) {\n        // Quick and dirty random for antialiasing\n    \tvec3 new_dir = normalize(ray_dir +\n               1.2/512.0 * normalize(vec3(\n                   hash(float(iter) * 17.9898),\n                   hash(float(iter + 1u) * 78.233),\n                   hash(float(iter + 2u) * -17.9898)\n                                )));\n        if (intersect_plane(\n            vec3(0.0, 0.0, 0.0),\n            normalize(vec3(0.0, 0.0, 1.0)),\n            new_dir,\n            camera_pos,\n            hit_pos\n        )) { \n           vec3 f = fract(vec3(hit_pos.x, hit_pos.y, 0.0)/4.0);\n           float eps = 0.04;\n           if (\n               abs(hit_pos.x) < 16.0 &&\n               abs(hit_pos.y) < 16.0 &&\n               (f.x > 1.0 - eps || f.y > 1.0 - eps || f.x < eps || f.y < eps))\n               total_val += vec3(1.0, 1.0, 1.0);\n        }\n    }\n\treturn total_val / 4.0;\n}\n\nfloat get_lum(vec3 v) {\n\treturn dot(v, vec3(0.2127f, 0.7152f, 0.0722f));\n}\n\nvec3 polar_to_cartesian(float sinTheta, \n                        float cosTheta, \n                        float sinPhi,\n                        float cosPhi)\n{\n    return vec3(sinTheta * cosPhi,\n                sinTheta * sinPhi,\n                cosTheta);\n}\n\nvec3 uniform_sample_cone(vec2 u12, \n                         float cosThetaMax, \n                         vec3 xbasis, vec3 ybasis, vec3 zbasis)\n{\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * PI * 2.0;\n    vec3 samplev = polar_to_cartesian(sinTheta, cosTheta, sin(phi), cos(phi));\n    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;\n}\n\n// --------------------------------------\n// from dave hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}