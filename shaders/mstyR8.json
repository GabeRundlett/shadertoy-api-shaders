{
    "Shader": {
        "info": {
            "date": "1694738727",
            "description": "why not.\nfollow-up: https://www.shadertoy.com/view/csccz7",
            "flags": 0,
            "hasliked": 0,
            "id": "mstyR8",
            "likes": 22,
            "name": "coiled grove",
            "published": 3,
            "tags": [
                "twist",
                "rope",
                "braid",
                "understepping"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 263
        },
        "renderpass": [
            {
                "code": "const uint  march_MaxSteps  = 250u;\nconst float march_epsilon   = 0.01;\n      float march_understep = 0.2;\nconst float normal_epsilon  = 0.05;\n\nconst bool  do_Shadows      = true;\nconst bool  do_Reflections  = true;\n\n\nfloat gMapCount = 0.0;\n\nfloat sdScene(in vec3 p) {\n\n    gMapCount += 1.0;\n\n    float d = 1e9;\n    \n    vec3 q = p;\n        \n    q.xz = abs(q.xz);\n    q.xz -= 9.0;\n    \n    q.xz *= rot2(q.y * q.y * 0.006 - iTime * 0.1);\n    q.xz *= 2.0 * (0.5 +  smoothstep(10.0, 50.0, q.y));\n    \n    q.xz = abs(q.xz);\n    q.xz -= 4.0;\n\n    float fade = smoothstep(1.0, 15.0, q.y);\n    q.xz *= rot2(q.y * 0.5  - iTime);\n    q.x = abs(q.x);\n    q.x -= 2.0 * fade;\n    \n    d = min(d, sdDisk(q.xz, 1.0));\n    \n    d += fade * 0.015 * (sin(q.x * 10.0) + sin(q.z * 10.0));\n\n    d = smin(d, p.y, 4.5);\n\n    return d;\n}\n\nvec3 gradScene(in vec3 p) {\n    if (p.y < march_epsilon) {\n        // cheat for floor\n        return vY;\n    }\n    float d = sdScene(p);\n    return vec3(\n        sdScene(p + vX * normal_epsilon) - d,\n        sdScene(p + vY * normal_epsilon) - d,\n        sdScene(p + vZ * normal_epsilon) - d\n    );\n}\n\nvec3 normalScene(in vec3 p) {\n    return normalize(gradScene(p));\n}\n\nfloat rayVsScene(in vec3 ro, in vec3 rd, out bool outOfSteps) {\n\n    // analytic ground plane in addition to the raymarched one.\n    float pt = rayVsPlane(ro, rd, vY, 0.0);\n    \n    outOfSteps = false;\n\n    float t = 0.0;\n\n    for (uint n = 0u; n < march_MaxSteps; ++n) {\n        vec3  p = ro + t * rd;\n        float d = sdScene(p);\n        if (d < march_epsilon) {\n            return min(pt, t);\n        }\n        if (dot(p.xz, p.xz) > 40000.0) {\n            return pt;\n        }\n        \n        t += d * march_understep;\n    }\n   \n    // next time we call this, use less precision.\n    march_understep = mix(march_understep, 1.0, 0.5);\n    \n    outOfSteps = true;\n    return pt;\n}\n\nconst vec3 lightDir = normalize(vec3(1.0, 1.5, 1.9));\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n    vec3 c = v1 * (1.0 - (0.2 + 0.8 * saturate(rd.y)));\n    c.r *= 0.2;\n    c.g *= 0.4;\n    \n    float d = dot(rd, lightDir) * 0.5 + 0.5;\n    \n    c = mix(c, v1, sqr(sqr(sqr(d))) * 0.85);\n    \n    float a = atan(rd.z, rd.x);\n    \n    c = mix(c, v1, smoothstep(0.06 + (1.0 - d) * 0.01 * cos(a * 13.0), 0.0, abs(rd.y)));\n    return c;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    bool outOfSteps;\n    float t = rayVsScene(ro, rd, outOfSteps);\n    if (t > 1e8) {\n        return sky(ro, rd);\n    }\n    \n    vec3 p;\n    vec3 n;\n    \n    p = ro + t * rd;\n    n = normalScene(p);\n    \n    vec3 c = v1 * (saturate(dot(n, lightDir)));\n\n    // shadow and one reflection bounce\n    ro = p + n * march_epsilon * 2.0;\n    \n    if (do_Shadows) {\n        // shadow\n        t = rayVsScene(ro, lightDir, outOfSteps);\n        p = ro + t * lightDir;\n\n        if (t < 1e9 || outOfSteps) {\n            c *= 0.4;\n        }\n    }\n\n    if (do_Reflections) {\n        // reflect\n        float fres = mix(0.01, 0.8, smoothstep(0.9, 0.1, abs(dot(rd, n))));\n\n        vec3 c2;\n        rd = reflect(rd, n);\n        t = rayVsScene(ro, rd, outOfSteps);\n        if (t > 1e8) {\n            c2 = sky(ro, rd);\n        }\n        else {\n            p = ro + t * rd;\n            n = normalScene(p);\n            c2 = v1 * (saturate(dot(n, lightDir)));\n        }\n\n        c = mix(c, c2, fres);\n    }\n    \n    return c;\n}\n\nvec3 getRayDir(in vec2 xy, in vec3 ro, in vec3 lookTo, in float fov) {\n    vec3 camFw = normalize(lookTo - ro);\n    vec3 camRt = normalize(cross(camFw, vY));\n    vec3 camUp = cross(camRt, camFw);\n    \n    vec3 rd;\n    rd = camFw + fov * (camRt * xy.x + camUp * xy.y);\n    rd = normalize(rd);\n    \n    return rd;\n}\n\nbool gHeatMap = false;\nvoid readKeyboard() {\n    gHeatMap = bool(texelFetch(iChannel0, ivec2(49, 2), 0).x);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    readKeyboard();\n    \n    const float zoom = 0.8;\n    \n    vec2 xy = (XY * 2.0 - RES) / MINRES / zoom;\n    \n    const float heatMapSize = 0.4;\n    bool isHeatMap = gHeatMap && XY.x < RES.x * heatMapSize && XY.y < RES.y * heatMapSize;\n    if (isHeatMap) {\n        xy = (XY * 2.0 - RES * heatMapSize) / MINRES / heatMapSize / zoom;\n    }\n    \n    vec2 M = iMouse.xy;\n    if (length(M) < 100.0) {\n        M = RES/2.0;\n        M.x += iTime * 7.0;\n    }\n    \n    vec3 ro = vec3(0.0, 8.0, -30.0);\n    ro.xz *= rot2(3.141 + (M.x / RES.x - 0.5) * -7.0);\n    vec3 lt = vY * (0.0 - 20.0 * (M.y / RES.y - 1.0));\n    vec3 rd = getRayDir(xy, ro, lt, 0.5);\n    \n    RGBA.rgb = render(ro, rd);\n    \n    if (isHeatMap) {\n        float h = saturate(gMapCount / 500.0);\n        vec3 cool = vec3(0.0, 0.0, 0.7);\n        vec3 warm = vec3(1.0, 0.9, 0.0);\n        RGBA.rgb = mix(cool, warm, h);\n    }\n    \n    // gamma\n    RGBA.rgb = pow(RGBA.rgb, vec3(1.0/2.2));\n    \n    RGBA.a   = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\nconst vec3 vX = vec3(1.0, 0.0, 0.0);\nconst vec3 vY = vX.yxy;\nconst vec3 vZ = vX.yyx;\nconst vec3 v0 = vX.yyy;\nconst vec3 v1 = vX.xxx;\n\nmat2 rot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2  saturate(vec2  v) { return clamp(v, 0.0, 1.0); }\nvec3  saturate(vec3  v) { return clamp(v, 0.0, 1.0); }\n\nfloat sqr(float a) {\n    return a * a;\n}\n\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n//--------------------------------------------------------------------------------\n\n// iq\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*1./6.;\n}\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nfloat rayVsPlane(in vec3 ro, in vec3 rd, in vec3 n, in float d) {\n    float t = -(dot(ro, n) + d) / (dot(rd, n));\n    if (t < 0.0) {\n        t = 1e9;\n    }\n    return t;\n}\n\n\n//--------------------------------------------------------------------------------\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}