{
    "Shader": {
        "info": {
            "date": "1722792684",
            "description": "source https://www.shadertoy.com/view/lc2czD https://glslsandbox.com/e#79834.4",
            "flags": 0,
            "hasliked": 0,
            "id": "XcSczt",
            "likes": 2,
            "name": " colorful Kaleidoscope  10",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 58
        },
        "renderpass": [
            {
                "code": "#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*2.5+.5)\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nvec2 surfacePosition;\n vec2 surfaceSize;\n\nvoid post_process(){\n\tfloat f1 = sdRoundedBox(surfacePosition, vec2(1,1)*0.4, vec4(0.2));\n\t\n\tif(f1 <= 0.) return;\n\t\n\t  float fragColor = min(abs(f1)*64., 2.)/2.;\n\t//gl_FragColor *= 1.+f1;\n\t\n\n\t\n\n}\n#define time iTime\n#define resolution iResolution.xy\n\n\n\nfloat aastep(float threshold, float value) {\n  #ifdef GL_OES_standard_derivatives\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n  #else\n    return step(threshold, value);\n  #endif  \n}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P, float seed) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 4. // Less gives more regular pattern\n\tvec2 Pi = mod(floor(P), 289.0);\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod(floor(p*K),7.0)*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod(floor(p*K),7.0)*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\nfloat facets(vec2 F)\n{\n\treturn 0.1 + (F.y - F.x);\n}\n\nfloat blobs(vec2 F)\n{\n\treturn 1.0 - F.x * F.x;\n}\n\nfloat rings(vec2 F)\n{\n\treturn 1.0 - aastep(0.45, F.x) + aastep(0.55, F.x);\n}\n\nvec3 mod289(vec3 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat snoise(vec2 v)\n{\n        const vec4 C = vec4(0.211324865405187,  // (3.0 - sqrt(3.0)) / 6.0\n                            0.366025403784439,  // 0.5 * (sqrt(3.0) - 1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439);  // 1.0 / 41.0\n\n        // First corner\n        vec2 i = floor(v + dot(v, C.yy));\n        vec2 x0 = v - i + dot(i, C.xx);\n\n        // Other corners\n        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n\n        // Permutations\n        i = mod289(i);  // Avoid truncation effects in permutations\n        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n        vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n        m = m * m;\n        m = m * m;\n\n        // Gradients\n        vec3 x = 3.0 * fract(p * C.wwz) - 1.0;\n        vec3 h = abs(x) - 1.5;\n        vec3 a0 = x - floor(x + 0.5);\n\n        // Normalize gradients implicitly by scaling m\n        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n\n        // Compute final noise value at P\n        vec3 g;\n        g.x = a0.x * x0.x + h.x * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n}\n\nfloat fbm(vec2 st, float l, float r)\n{\n\tconst int octaves = 8;\n\t\n\tfloat sum = 0.0;\n\tfloat f = 1.5;\n\tfloat s = 1.0;\n\tfor (int i=0; i < octaves; ++i)\n\t{\n\t\tsum = sum + s * snoise(f *cos(iTime)* st);\n\t\ts = s * r*cos(iTime);\n\t\tf = f * l;\n\t}\n\treturn sum;\n}\n\nvec3 starfield(vec2 st)\n{\n\tvec2 F = cellular(st, time);\n\t\n\tfloat value;\n\tvalue = 1.0 - F.x;\n\t\n\tvalue = pow(value, 40.0 + snoise(st * 10.0) * 10.0);\n\tfloat alpha = F.y - 0.5;\n\t// star colors\n\tvec3 c1 = vec3(.35, .4, .6);\n\tvec3 c2 = vec3(.3, .5, .8);\n\treturn mix(c1, c2, alpha) * value;\n}\n\nvec3 starfield_fractal(vec2 st, float l, float r)\n{\n\tconst int octaves = 5;\n         st.xy*=mat2(cos(iTime),sin(iTime) ,-sin(iTime),cos(iTime));\n\n\tvec3 sum = vec3(0, 0, 0);\n\tfloat f = .35;\n\tfloat s = 2.5;\n\tfor (int i=0; i < octaves; ++i)\n\t{st.xy*=mat2(cos(iTime),sin(iTime) ,-sin(iTime),cos(iTime));\n\n\n\t\tsum = sum + s * starfield(f * st);\n\t\ts = s * r;\n\t\tf = f * l;\n\t}\n\treturn sum;\n}\nconst float SceneDurationSeconds = 4.;\nconst float Complexity = 7.;\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec4 o = O;\n    \n      vec2 uv = C/max(iResolution.x, iResolution.y)-0.5;\n   \n\n\n    vec4 hscene = hash42(vec2(uv));\n  \n vec2 st = uv;\n\t\n     st.y+=0.2;\n\tvec3 star = starfield_fractal(st * 30.0, 1.4, 0.75);\n\t\n\tfloat n = fbm(st * 1.0, 2.0, .75);\n\tvec3 nebula = vec3(n) * 0.14;\n\tstar = star * (n * 0.7 + 1.2);\n\t\n        float n2 = fbm((st + vec2(132.0, 112.0)) * 1.5, 2.3, 0.6);\n\tvec3 nebula2 = mix(vec3(1, 0, 0), vec3(0.5, 0.5, 1.), n2) * (n2 - 0.3) * 0.14;\n\t\n\n\t\n\n    vec2 uvn = C/iResolution.xy-.5;\n    float ds = max(abs(uvn.x), abs(uvn.y))*1.;\n     vec4 h ;\n    for (float i = 1.; i < Complexity; ++ i) {\n        vec2 c = floor(uv);\n        h = hash42(c);\n        vec2 p = fract(uv);\n        vec2 a = abs(p-.5);\n        float sd = .5-max(a.x, a.y);\n        o = h*sqrt(sd)*4.;\n        uv *= 2.;\n        float sc = 1./i;\n       \n    }\n    o = clamp(o * hscene,0.,1.);\n    o.rgb = mix(vec3(o.r+o.g+o.b)/3., o.rgb, 1.-ds*ds);\n    o += (hash42(C+iTime).r-.5)*.15;\n    o *= 1.-dot(uvn,uvn*2.);\n     vec4 p;\n    vec3 q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1.1,0.2,1.),H(g*0.25),0.78)*1./e/8e3\n    )\n    {\n        p.xyz=g*d;\n\n   p.z+=30.*cos(iTime);\n          p.z-=5.0;\n              p.w*=ceil(p.z*dot(p.x,p.z));\n              \n        s=3.;\n        for(int i=0;i++<15;\n  \n  \n        p.xyz=abs(p.xyz)*e-vec3(p.w,1,1))\n        \n            p.xyz=.1-abs(p.xyz-1.1),\n             \n            p.x<p.z?p.xyz=p.zyx:p.xyz,\n            p.z<p.y?p.xyz=p.xzy:p.xyz,\n               p.y<p.x?p.xyz=p.xyz:p.xyw,\n                \n            s*=e=1.0+p.w;\n           \n         g+=e=abs(p.x)/s+.011;\n         g+=e=abs(p.z)/s+.011;\n          g+=e=abs(p.y)/s+.011;\n    }\n    O+= vec4(nebula2 + clamp(star, 0.0, 1.0), 0.75);\n\t\n\tpost_process(); \n \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}