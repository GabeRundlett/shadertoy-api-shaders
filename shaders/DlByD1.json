{
    "Shader": {
        "info": {
            "date": "1691696836",
            "description": "raytraced terrain and good music.",
            "flags": 40,
            "hasliked": 0,
            "id": "DlByD1",
            "likes": 14,
            "name": "Bilinear terrain marching +music",
            "published": 3,
            "tags": [
                "terrain",
                "music",
                "heightmap",
                "normal",
                "bilinear"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "vec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir*0.5 + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nconst float inf = 10000.;\nvec2 box( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(inf); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2(tN, tF);\n}\nvec4 join(in vec4 a, in vec4 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\nfloat blin(in vec2 p, in vec4 h) {\n    \n    float k = h.x+p.x*h.y-p.x*h.x+p.y*h.z+p.y*p.x*h.w-p.y*p.x*h.z-p.y*h.x-p.y*p.x*h.y+p.y*p.x*h.x;\n    return k;\n}\nfloat blin(in vec3 o, in vec3 d, in vec3 rdi, in vec4 h) {\n    float m = max(max(h.x, h.y), max(h.z, h.w));\n    //if (-(o.z-m)*rdi.z < 0.0) return inf;\n    float a = 0.005+d.y*d.x*(h.w-h.z+h.x-h.y);\n    if (a == 0.0) {\n        return (a = (-o.z+h.x)*rdi.z) >= 0.0?a:inf;\n    }\n    float b = d.y*(o.x*h.w+h.z+h.x*o.x-h.x-h.y*o.x-o.x*h.z)-d.z+h.x*o.y*d.x-d.x*h.x-h.y*o.y*d.x+d.x*h.y+o.y*d.x*h.w-o.y*d.x*h.z;\n    float disc = b*b-4.*a*(o.x*(o.y*(h.x-h.y)+h.y-h.x+o.y*(h.w-h.z))+o.y*(h.z-h.x)+h.x-o.z);\n    if (disc < 0.0) return inf;\n    vec2 roots = (-b+vec2(1, -1)*sqrt(disc))/a;\n    if (roots.x < 0.0) roots.x = inf;\n    if (roots.y < 0.0) roots.y = inf;\n    return min(roots.x, roots.y)*0.5;\n}\nvec3 normall(in vec3 p, in vec4 h) {\n    vec4 l = vec4(h.x,-h.y,-h.z,h.w);\n    return normalize(vec3(h.y-h.x+dot(p.yyyy,l),h.z-h.x+dot(p.xxxx,l),1));\n}\nfloat blinBox(in vec3 ro, in vec3 rd, in vec3 rdi, in vec2 b, in vec4 dat) {\n    vec3 n;\n    float d = blin(ro+rd*b.x, rd, rdi, dat);\n    if (d > b.y-b.x) return inf;\n    d = min(d, b.y-b.x);\n    return d+b.x;\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    vec3 rdi3 = 1./rd;\n    float maxHeight = 36.25;\n    bool inside = ro.z < maxHeight;\n    if (!inside) {\n        float boundPlain = -(ro.z-maxHeight)*rdi3.z;\n        if (boundPlain < 0.0) return vec3(0);\n        ro += rd*boundPlain;\n    }\n    vec2 i = floor(ro.xy);\n    float dist;\n    int ii;\n    vec2 normal;\n    vec2 srd = sign(rd.xy);\n    vec2 rdi = 1./(2.*rd.xy);\n    float old = 0.0;\n    vec2 oldI = i;\n    vec4 s = vec4(1, 1, 0, 1);\n    float c = inf;\n    vec4 u;\n    for (ii = 0; ii < 300; ii += 1) {\n        u = texelFetch(iChannel0, ivec2(oldI+iResolution.xy*0.5), 0);\n            float distt = blinBox(ro-vec3(oldI, 0), rd, rdi3, vec2(old, dist), \n                u\n            );\n            c = min(c, distt);\n\n            if (distt < inf || inside && (ro.z+rd.z*dist > maxHeight)) break;\n        old = dist;\n        oldI = i;\n        vec2 plain = ((1.+srd-2.*(ro.xy-i))*rdi);\n        dist = min(plain.x, plain.y);\n        normal = vec2(equal(vec2(dist), plain))*srd;\n        i += normal;\n    }\n    //return vec3(ii)*0.01;\n    vec3 n;\n    //c = blinBox(ro-vec3(oldI, 0), rd, vec2(old, dist));\n    if (c == inf) return vec3(0);\n    float ground = -(ro.z-0.2)/rd.z;\n    if (ground < 0.0) ground = inf;\n    vec3 p = ro+rd*c;\n    vec3 no = normalize(vec3(\n        u.y-u.x,\n        u.z-u.x,\n        1\n    ));\n    no = normall(vec3(fract(p.xy), p.z), u);\n    return (no*0.5+0.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = vec2(iTime*0.8, 1.5);\n    if (iMouse.z > 0.0) m = ((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*10.0;//*max(pow(2., 5.-iTime*2.0), 5.0);\n    vec3 rd = getRay(-normalize(ro), uv);\n    //ro += 1.0;\n    ro.z += 1.0;\n    vec3 color = getColor(ro, rd);\n\n    //super sample\n    fragColor = vec4(color, 1);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0)*0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//music!\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\nfloat f[16] = float[16](\n400.,\n500.,\n450.,\n400.,\n500.,\n450.,\n400.,\n500.,\n500.,\n450.,\n400.,\n300.,\n400.,\n300.,\n400.,\n300.\n);\nfloat noise(in float x) {\n    return mix(hash(uint(floor(x))),hash(uint(floor(x+1.0))),fract(x));//mix(hash(uint(x), x+1, fract(x));//mix(hash(uint(floor(x))), hash(uint(floor(x))), fract(x));\n}\nfloat k(in float x, in float n) {\n    return (sign(-(fract(x)-n))*0.5+0.5)*sin((2.*3.14159*fract(x))/n);\n}\nfloat sound(in float time) {\n    float tm = time;//mod(time, 2.0);\n    float t = tm*3.1415*2.0;\n    float n = f[int(floor(time*3.0))%15];//sin(t*)*400.;\n    float nn = n*0.0001;//hash11(s)*0.4+0.1;\n    float v = sin(t*n);\n    v = sin(t*nn*n+v*n*0.01);\n    v = sin(v*n*0.003+t*n*0.03);\n   // v = sin(t*100.+v*2.0);\n   float vv = v;\n    v *= exp(-fract(time*2.0)*2.0);\n    v = mix(v, noise(time*1000.+vv*0.5), 0.7+sin(time*2.0)*0.1);\n    v += noise(time*(1000.+500.*mod(floor(time*7.0), 3.0)))*exp(-mod(time, 2.0));\n    v += 0.5*exp(-mod(time, 9.)*0.75)*sin(sin(t*(200.+mod(floor(time*5.0), 3.0)*20.))*10.0*exp(-mod(time*5.0, 1.0)*2.)+t);\n    v += 0.5*exp(-mod(time+4.0, 9.))*sin(sin((0.5+t)*(200.+mod(floor(time*10.0+0.3), 3.0)*20.))*10.0*exp(-mod(time*2.0+0.1, 1.0)*2.)+t);\n    float c = 250.*hash(uint(floor(time*0.2))+10u);\n    float a = 500.;\n    v += 0.5*exp(-mod(time, 5.0))*k(time*a+sin(time*c), 0.1*sin(fract(time*100.)*3.1415*2.0)+0.5);\n    return v*0.5;\n}\nfloat fbm(in float x) {\n    float v = 0.0;\n    for (int i = 0; i < 9; i += 1) {\n        v += noise(x*float(1<<i))*pow(2., -float(i));\n    }\n    return v*0.5;\n}\nvec2 mainSound( int samp, float time )\n{\n    uint s = uint(samp);\n    float v = sound(time);\n    float range = mix(noise(time*2.0)*0.1, 0.0, min(time*0.1, 1.0));\n    //if (time > 20.) range = clamp((time-20.)*0.1, 0.0, 1.0);\n    float d = 0.0;\n    for (float i = -1.0; i <= 1.0; i += 0.2) {\n        float w = i*i;\n        v += sound(time+i*range)*w;\n        d += w;\n    }\n    v /= d;\n    //v += sound(time)*0.5;\n    //v = sin(time*500.*noise(time));\n    v = mix(v, fbm(time*400.), 1.-min(time*0.1, 1.0));\n    return vec2(v);//return vec2(sound(time), sound(time+noise(time)*0.1));//vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float v = fract((p3.x + p3.y) * p3.z);\n    return v;//texture(iChannel0, p*0.01+0.5).x*20.0-v*0.001;\n}\nfloat noise(in vec2 p) {\n    vec2 k = fract(p);\n    vec2 f = floor(p);\n    k = k*k*(3.0-2.0*k);\n    return mix(mix(hash12(f), hash12(f+vec2(1, 0)), k.x),\n               mix(hash12(f+vec2(0, 1)), hash12(f+vec2(1, 1)), k.x), k.y);\n}\nfloat fbm(in vec2 p) {\n    float v = 0.0;\n    for (float i = 0.; i < 10.; i += 1.) {\n        v += pow(noise(p*pow(2., i)+i*100.), 1.5)*pow(2., -i);\n    }\n    return v*0.5;\n}\nfloat get(in vec2 p) {\n    float v = pow(fbm(p*0.03), 1.0)*50.-12.0;\n    return (v);//max(v, 5.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (fragCoord.xy-iResolution.xy*0.5);\n    fragColor = vec4(get(p), get(p+vec2(1, 0)), get(p+vec2(0, 1)), get(p+vec2(1, 1)));//vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}