{
    "Shader": {
        "info": {
            "date": "1614223601",
            "description": "Animation of https://www.shadertoy.com/view/WtGfDh",
            "flags": 0,
            "hasliked": 0,
            "id": "WtGfW1",
            "likes": 5,
            "name": "Fast implicit random walk 2",
            "published": 3,
            "tags": [
                "random",
                "brownian"
            ],
            "usePreview": 0,
            "username": "ttg",
            "viewed": 387
        },
        "renderpass": [
            {
                "code": "/*\n\nFast implicit random walk 2\nCreated by Theron Tarigo, 2021\nhttps://www.shadertoy.com/view/WtGfW1\n\nRandom walk (brownian motion) implies integration to know particle position as\na function of time, but a recursive solution can provide a qualitatively and\nstatistically equivalent result.\n\nAnimation of https://www.shadertoy.com/view/WtGfDh\n\n*/\n\nvec2 randwalk_dumb (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=0; j<i; j++) {\n    x+= rnd2_gaussian(uint(j)+0xda6cu*seed);\n  }\n  return x;\n}\n\nvec2 randwalk_fast (int i, uint seed) {\n  vec2 x = vec2(0.);\n  for (int j=1; j<20; j++) {\n    uint n = uint(i)>>j;\n    uint k = uint(i)-(uint(n)<<j);\n    float l = 1.-abs(1.-float(k)*exp2(-float(j))*2.);\n    x+=rnd2_gaussian(((2u*n+1u)<<(j-1))+0xda6cu*seed)*l*exp2(.5*float(j)-1.);\n  }\n  return x;\n}\n\nvoid mainImage( out vec4 fd, in vec2 fc ) {\n\n  fd = vec4(0.);\n\n  vec3 col = vec3(0.);\n\n  float R = iResolution.y * .01;\n  vec2 uv = (2.*fc - iResolution.xy) / R;\n  \n  for (uint seed=0u; seed<64u; seed++) {\n    vec2 p = randwalk_fast(iFrame,seed);\n    col+=max(0., (1.-length(p-uv))*R);\n  }\n\n  // Convert to Gamma=2.2 and output to screen\n  fd.rgb = pow(col, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//////  COMPLEX ARITHMETIC  ///////////////////////////////////////////////////\nconst float pi = 3.1415927;\nvec2 compmul(vec2 a, vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\nvec2 compsin(float x){return vec2(cos(x),sin(x));}\nvec2 compinv(vec2 a){return vec2(1,-1)*a/dot(a,a);}\nfloat comparg(vec2 a){return atan(a.y,a.x);}\nvec2 comppow(vec2 a, float n){return compsin(comparg(a)*n)*pow(dot(a,a),n/2.);}\nvec2 compconj(vec2 a){return vec2(a.x,-a.y);}\n\nvec4 compmul(vec4 a, vec2 b){return vec4(compmul(a.xy,b),compmul(a.zw,b));}\n\n// https://www.shadertoy.com/view/WttXWX\n// --- triple32 from Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvec2 rnd2_gaussian(uint seed) {\n  uint r = triple32(seed);\n  uvec2 r2 = (uvec2(r)>>uvec2(0,16))&0xFFFFu;\n  vec2 U = vec2(r2+1u)/float(0x10000u);\n  U = sqrt(abs(2.*log(U.x)))*compsin(2.*pi*U.y);\n  return U;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}