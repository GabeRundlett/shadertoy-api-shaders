{
    "Shader": {
        "info": {
            "date": "1647351654",
            "description": "An irregular pinwheel tile pattern consisting of hexagons and triangle wedges.",
            "flags": 0,
            "hasliked": 0,
            "id": "ss2BDc",
            "likes": 43,
            "name": "Hexagon Triangle Wedge Pattern",
            "published": 3,
            "tags": [
                "triangle",
                "hexagon",
                "pattern",
                "tile",
                "pinwheel",
                "irregular",
                "semiregular"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagon Triangle Wedge Pattern\n\t------------------------------\n    \n    I haven't posted anything in a while due to Shadertoy having problems\n    dealing with excess traffic -- If you're going to have a website problem, \n    too much popularity would be the one you'd want to have. :) Having said \n    that, I doubt it's been a fun couple of weeks for the creators. \n    \n    Anyway, this is a simple rendering of one of the many cliche hexagon grid \n    based patterns that exist. I'm sure most have seen this one around.  \n    \n    There's not really much to it: Create a hexagon grid, render some hexagons \n    in the centers, then construct triangles around the hexagon edges in a \n    pinwheel fashion. How you do that is down to common sense. If you know \n    how to move, rotate and render 2D objects, then it shouldn't give you too\n    much trouble.\n    \n    The default pattern is kind of interesting, given the fact that the triangles\n    look like they infinitly overlap one another. There's also an option below \n    to display a semi-regular hexagon triangle pinwheel arrangement.\n    \n    There would be faster ways to render the pattern. The brute force 7-tap \n    method I've employed works well enough, but you could get that number down. \n    I also have an extruded version ready to go. It was surprisingly easy to \n    put together, and I intend to post that a little later.\n\n\t\n    \n    Other Tiled Pattern Examples:\n\n    // Here's a much more interesting irregular tiling.\n    Moebius Lizard - iapafoto \n    https://www.shadertoy.com/view/wtjyz1\n    \n    // Heaps of different tiled configurations.\n    Wythoff Uniform Tilings + Duals - fizzer\n    https://www.shadertoy.com/view/3tyXWw\n    \n    // A decent irregular tiling example.\n    escherized tiling 2 (WIP) - Fabrice\n    https://www.shadertoy.com/view/lsdBR7\n    \n\n*/\n\n\n// Color scheme - White: 0, Random color: 1, Ordered color: 2.\n#define COLOR 1\n\n// A pinwheel arrangement with wedge looking triangles. Commenting this \n// out will result in a regular hexagon triangle pinwheel arrangement.\n#define WEDGE\n\n// Show the hexagon grid that the pattern is based on. Knowing where\n// the cell boundary lies can be helpful.\n//#define SHOW_GRID\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nfloat hash21(vec2 p){ \n   \n    //return texture(iChannel0, p).x;\n    // IQ's vec2 to float hash.\n    //return fract(sin(dot(p, vec2(57.609, 27.781)))*43758.5453); \n     \n    // Using a very slight variation on Dave Hoskin's hash formula, \n    // which can be found here: https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    \n}\n\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(1.7320508, 1);\n\n// Hexagon edge and vertex IDs. They're useful for neighboring edge comparisons,\n// etc. Multiplying them by \"s\" gives the actual vertex postion.\n//\n// Vertices and edges: Clockwise from the left.\n//\n// Note that these are all six times larger than usual. We're doing this to \n// get rid of decimal places, especially those that involve division by three.\n// I't a common accuracy hack. Unfortunately, \"1. - 1./3.\" is not always the \n// same as \"2./3.\" on a GPU.\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top hexagon.\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n}\n\n// Triangle bound.\nfloat getTri(vec2 p){\n\n    p.x = abs(p.x);\n    return max(dot(p, s/2.), -p.y*s.y);\n}\n\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Global scale factor.\n    #ifdef WEDGE\n    const float sc = 3.;\n    #else\n    const float sc = 4.5;\n    #endif\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    mat2 sRot = mat2(1, 0, 0, 1);//rot2(-3.14159/24.); // Scene rotation.\n    vec2 camDir = sRot*normalize(s); // Camera movement direction.\n    vec2 ld = sRot*vec2(-cos(3.14159/5.), -sin(3.14159/5.)); // Light direction.//-.5, -1.732\n    vec2 p = sRot*uv*sc + camDir*s.xy*iTime/6.; \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    float df = 1e5, dfHi = 1e5;\n    \n    // Cell object ID and cell arrangement ID.\n    vec2 id;\n    float tID;\n    \n    // A cell ratio factor for the two arrangements.\n    #ifdef WEDGE \n    const float divF = 1./6.;\n    #else\n    const float divF = 1./4.;\n    #endif\n    \n    // Set the initial ID and minimum distance to the central hexagon.\n    df = gHx - divF;\n    #ifdef WEDGE\n    id = p4.zw*18.;\n    #else\n    id = p4.zw*12.;\n    #endif\n    \n    // Pinwheel ID for the hexagon: There are seven objects per cell. The\n    // central hexagon ID is the highest and the surrounding pinwheel objects\n    // are numbered zero through to five.\n    tID = 6.; \n    \n    // Offset hexagon for highlighting purposes.\n    dfHi = getHex(p4.xy - ld*.001) - divF;\n     \n     \n    // Iterate through all six sides of the hexagon cell.\n    for(int i = min(0, iFrame); i<6; i++){ \n            \n            \n            #ifdef WEDGE \n            \n                // Triangle 1 central offset index. These numbers have been multiplied\n                // by 18 to produce integers for more index accuracy... It's related to\n                // GPUs giving different results for \"1. - 1./3.\" and \"2./3.\".  \n                vec2 indx1 = vID[i];\n\n                // Local coordinates.\n                vec2 q = p4.xy - indx1*s/18.;\n                // The sign matters for bump mapping, etc.\n                mat2 mR = rot2(6.2831/6.*float(i));\n                // Triangle one (and highlight field).\n                float tri1 = getTri(mR*q) - divF;\n                float tri1B = getTri(mR*(q - ld*.001)) - divF;\n\n\n                // Go to the neighboring cell and retrieve the opposite overlapping\n                // triangle by rotating forward 4 vertices.\n                //\n                // Triangle 2 central offset index.\n                vec2 indx2 = eID[i]*3. + vID[(i + 4)%6];\n                // Local coordinates.\n                q = p4.xy - indx2*s/18.;\n\n                // The neighboring triangle (and highlight field). See the image\n                // for a clearer picture.\n                float tri2 = getTri(mR*q) - divF;\n                float tri2B = getTri(mR*(q - ld*.001)) - divF;\n                // Using the neighboring triangle to chop a little wedge out of\n                // the main triangle. Obviously, that's what gives it a V-shape.\n                tri1 = max(tri1, -tri2);\n                tri1B = max(tri1B, -tri2B);\n\n                // Set the minimum distance and IDs for the inner object.\n                if(tri1<df) {\n\n                    df = tri1;\n                    tID = float(i);\n                    id = p4.zw*18. + indx1;\n                }\n\n                // Set the minimum distance and IDs for the outer object. If you\n                // don't include this, the neighboring triangle won't fill in the\n                // V-shape's wedge gap.\n                if(tri2<df) {\n\n                    df = tri2;\n                    tID =  float((i + 4)%6);\n                    id = p4.zw*18. + indx2;\n                }            \n\n                // Offset distance field value for highlighting. \n                dfHi = min(dfHi, min(tri1B, tri2B));\n            \n            #else\n            \n                vec2 indx1 = vID[i]; // Vertex postion index.\n                vec2 q = p4.xy - indx1*s/12.; // Local coordinates.\n                mat2 mR = rot2(6.2831/6.*float(i));\n                // Triangle one (and highlight field).\n                float tri1 = getTri(mR*q) - divF; //1./.8660254+1.;//\n                float tri1B = getTri(mR*(q - ld*.001)) - divF;\n\n                // Set the minimum distance and IDs for the inner object.\n                if(tri1<df) {\n\n                    df = tri1;\n                    tID = float(i);\n                    id = p4.zw*12. + indx1;\n                }\n\n                // Offset distance field value for highlighting. \n                dfHi = min(dfHi, tri1B);\n            \n            #endif\n\n    }\n    \n    // Giving the object some edging and rescaling the ID\n    #ifdef WEDGE\n    float ew = .018;\n    id /= 18.;\n    #else\n    float ew = .025;\n    id /= 12.;\n    #endif\n    //\n    df += ew;\n    dfHi += ew;\n     \n    \n     \n    // Using the IDs for coloring.\n    #if COLOR == 1\n    float rnd2 = hash21(id);\n    vec3 tCol = .5 + .45*cos(6.2831*rnd2 + vec3(0, 1, 2)*1.5);\n    // if(tID>5.5) tCol = vec3(.8); // White hexagons.\n    #elif COLOR == 2\n    #ifndef WEDGE\n    // This is a bit of a cop-out, but I didn't feel like arranging for all \n    // colors to line up in a manner similar to the ordered wedge arrangement... \n    // It could be done by a less lazy person though. :)\n    if(tID<5.5) tID = mod(tID, 2.) + 2.;\n    #endif\n    vec3 tCol = .5 + .45*cos(6.2831*tID/6. + vec3(0, 1, 2)*1.5 + .5);\n    if(tID>5.5) tCol = vec3(.8); // White hexagons.\n    #else\n    vec3 tCol = vec3(.8);\n    #endif\n    \n    // Evening the color intensity a bit.\n    //tCol /= (.75 + dot(tCol, vec3(.299, .587, .114))*.5);\n    \n    /*\n    // Textures work too, but they're not used here.\n    vec3 tx = texture(iChannel0, p/8.).xyz; tx *= tx;\n    tx = smoothstep(-.1, .5, tx);\n    vec3 tx2 = texture(iChannel1, id/8.).xyz; tx2 *= tx2;\n    tx2 = smoothstep(-.1, .5, tx2);\n    tCol *= tx*tx2*1.5;\n    */\n \n    // Applying some directional derivative based highlighting. \n    float b = max(dfHi - df, 0.)/.001;\n    tCol = tCol*.65 + mix(tCol, vec3(1), .05)*b*b*.65;\n     \n \n    // Subtle line pattern overlay.\n    vec2 ruv = rot2(-3.14159/3.)*p;\n    float lSc = (120./sc);\n    float pat = (abs(fract(ruv.x*lSc - .5) - .5) - .125)/lSc/2.;\n    tCol *= smoothstep(0., sf, pat)*.35 + 1.;\n     \n    // Applying the object color to the background.\n    vec3 col = mix(vec3(0), tCol, (1. - smoothstep(0., sf, df)));\n \n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., abs(gHx - .5) - .012))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(gHx - .5) - .012)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, abs(gHx - .5) - .003)));\n    #endif\n   \n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}