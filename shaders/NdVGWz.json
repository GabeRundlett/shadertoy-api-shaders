{
    "Shader": {
        "info": {
            "date": "1631355126",
            "description": "check out Slowtember by megaelod on IG\nhttps://www.instagram.com/p/CSCRu85jWe0/",
            "flags": 0,
            "hasliked": 0,
            "id": "NdVGWz",
            "likes": 12,
            "name": "Slowtember10-12: Cafe/Date",
            "published": 3,
            "tags": [
                "slowtember"
            ],
            "usePreview": 0,
            "username": "klemek",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "#define PI 3.1416\n#define FAR 10.0\n#define MAX_RAY 92\n#define MAX_REF 16\n#define FOV 1.57\n#define OBJ_MIN_D 0.01\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat rand(float seed) {\n    float v = pow(seed, 6.0 / 7.0);\n    v *= sin(v) + 1.;\n    return v - floor(v);\n}\n\nvec3 col(float x) {\n    return vec3(\n        .5 * (sin(x * 2. * PI) + 1.),\n        .5 * (sin(x * 2. * PI + 2. * PI / 3.) + 1.),\n        .5 * (sin(x * 2. * PI - 2. * PI / 3.) + 1.)\n    );\n}\n\nfloat smin( float a, float b, float s ){\n\n    float h = clamp( 0.5+0.5*(b-a)/s, 0.0, 1.0 );\n    return mix( b, a, h ) - s*h*(1.0-h);\n}\n\nfloat smod(float x, float m) {\n    return (1. - step(m * .95, mod(x, m))) * min(m, mod(x, m) * 1.05) + step(m * .95, mod(x, m)) * min(m, mod(-x, m) * 40.); \n}\n\nvec3 rot(vec3 v, vec3 c, vec3 a) {\n    return (v - c)\n    * mat3(1, 0, 0,\n         0, cos(a.x * 2. * PI), sin(a.x * 2. * PI),\n         0, -sin(a.x * 2. * PI), cos(a.x * 2. * PI))\n    * mat3(cos(a.y * 2. * PI), 0, sin(a.y * 2. * PI),\n         0, 1, 0,\n         -sin(a.y * 2. * PI), 0, cos(a.y * 2. * PI))\n    * mat3(cos(a.z * 2. * PI), sin(a.z * 2. * PI), 0,\n         -sin(a.z * 2. * PI), cos(a.z * 2. * PI), 0,\n         0, 0, 1) + c;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere(vec3 q, vec3 p, float r) {\n    return length(q - p) - r;\n}\n\nfloat plane(vec3 q, vec3 d, float offset) {\n    return dot(d, q) + offset;\n}\n\nfloat capsule(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab1 = p2 - p1;\n    vec3 ap1 = q - p1;\n    float t1 = dot(ap1, ab1) / dot(ab1, ab1);\n    t1 = clamp(t1, 0., 1.);\n    vec3 c1 = p1 + t1 * ab1;\n    return length(q - c1) - r;\n}\n\nfloat torus(vec3 q, vec3 p, float r1, float r2) {\n    q -= p;\n    float x = length(q.xz) - r1;\n    return length(vec2(x, q.y)) - r2;\n}\n\nfloat box(vec3 q, vec3 p, vec3 s, float r) {\n    return length(max(abs(q - p) - s + r, 0.)) - r;\n}\n\nfloat cyl(vec3 q, vec3 p1, vec3 p2, float r) {\n    vec3 ab2 = p2 - p1;\n    vec3 ap2 = q - p1;\n    float t2 = dot(ap2, ab2) / dot(ab2, ab2);\n    vec3 c2 = p1 + t2 * ab2;\n    float d = length(q - c2) - r;\n    float y = (abs(t2 - .5) - .5) * length(ab2);\n    float e = length(max(vec2(d, y), 0.));\n    float i = min(max(d, y), 0.);\n    return e + i;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n#define OBJ_COUNT 6\n\nfloat objects[OBJ_COUNT] = float[](FAR, FAR, FAR, FAR, FAR, FAR);\nvec3 objectsColor[OBJ_COUNT] = vec3[](vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.), vec3(1.));\nconst float objectsRef[OBJ_COUNT] = float[](.4,.0,.0,.0,.3,.1);\n\nvoid setObjects(vec3 q) {\n    objects[0] = FAR;\n    objects[0] = min(objects[0], plane(q, vec3(.0, 1., .0), 0.));\n    \n    vec3 q2 = q;\n    q2.x = mod(q.x, 2.);\n    q2.z = mod(q.z, 1.);\n    \n    float chair_seed = abs(floor(q.x)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    float table_seed = abs(floor(q.x * .5)) * 100. + abs(floor(q.z)) * 100. + 100.;\n    \n    vec3 q3 = q2;\n    if(q2.x < 1.) {\n        q3.x = 1. - q2.x + .1 * rand(chair_seed++);\n    } else if (q2.x < 2.) {\n        q3.x -= 1. + .1 * rand(chair_seed++);\n    }\n    \n    vec3 q4 = rot(q3, vec3(.5), vec3(.0, .04 * (rand(chair_seed++) - .5),.0));\n    \n    objects[1] = FAR;\n    objects[1] = min(objects[1], box(q4, vec3(.5, .3, .5), vec3(.2, .02, .2), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .69), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .3, .31), vec3(.01, .3, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .31), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.31, .15, .69), vec3(.01, .15, .01), .005));\n    objects[1] = min(objects[1], box(q4, vec3(.69, .59, .5), vec3(.01, .05, .2), .005));\n    \n    objects[2] = FAR;\n    objects[2] = min(objects[2], box(q4, vec3(.49, .33, .5), vec3(.24, .02 + .0005 * sin(q2.x * 200.) * sin(q2.z * 200.), .25), .1));\n    objects[2] = min(objects[2], box(q4, vec3(.65, .59, .5), vec3(.03 + .0005 * sin(q2.y * 200.) * sin(q2.z * 200.), .1, .22), .05));\n    \n    q2 = rot(q2, vec3(.5), vec3(.0, .01 * (rand(table_seed++) - .5),.0));\n    \n    objects[3] = FAR;\n    objects[3] = min(objects[3], box(q2, vec3(1., .5, .5), vec3(.3, .02, .3), .0));\n    \n    objects[4] = FAR;\n    objects[4] = min(objects[4], cyl(q2, vec3(1., .0, .5), vec3(1., .5, .5), .05));\n    \n    vec3 cup_center = vec3(.2 - .1 * rand(chair_seed++), .0, .5 + .2 * (rand(chair_seed++) - .5));\n    \n    vec3 q5 = rot(q3, cup_center, vec3(.0, rand(chair_seed++),.0));\n    \n    objects[5] = FAR;\n    objects[5] = min(objects[5], cyl(q5, cup_center + vec3(.0, .51 + length(q3.xz - cup_center.xz)* .3, .0), cup_center + vec3(.0, .52  + length(q3.xz - cup_center.xz)* .3, .0), .04));\n    objects[5] = min(objects[5], torus(q5, cup_center + vec3(.0, clamp(q3.y, .54, .56), .0), .02 + (q3.y - .54) * .6, .004));\n    \n    objects[5] = min(objects[5], torus(rot(q5, cup_center + vec3(.0, .55, .04), vec3(.0, .0, .25)), cup_center + vec3(.0, .55, .04), .01, .004));\n}\n\n#define TILING .3\n\nvoid setObjectColors(vec3 q) {\n\n    bool tile = (mod(q.x, 2. * TILING) < TILING) ^^ (mod(q.z, 2. * TILING) < TILING);\n\n    objectsColor[0] = tile ? vec3(.9) : vec3(.4, .0, .0);\n    objectsColor[1] = vec3(.8, .3, .1);\n    objectsColor[2] = vec3(.9);\n    objectsColor[3] = vec3(.8, .3, .1);\n    objectsColor[4] = vec3(.3);\n}\n\nfloat map(vec3 q) {\n    float d = FAR;\n    \n    setObjects(q);\n    \n    for(int i = 0; i < OBJ_COUNT; i++)\n        d = min(d, objects[i]);\n    \n    return d;\n}\n\nvec3 mapColor(vec3 q, float t) {\n    setObjects(q);\n    setObjectColors(q);\n    \n    vec3 c = vec3(.0);\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             c = objectsColor[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return c;\n}\n\nfloat mapRef(vec3 q, float t) {\n    setObjects(q);\n    \n    float ref = .0;\n    float mind = FAR;\n    \n    for(int i = 0; i < OBJ_COUNT; i++) {\n        if(abs(objects[i]) < .001 * (t * .25 + 1.) && abs(objects[i]) < mind){\n             ref = objectsRef[i];\n             mind = abs(objects[i]);\n        }\n    }\n\n    return ref;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, int max_d) {\n    float t = 0., d;\n    for(int i = 0; i < max_d; i++){\n        d = map(ro + rd * t);\n        if(abs(d) < .001 * (t * .25 + 1.) || t > FAR)  break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p) {\n    //Tetrahedral normal\n    const vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{\n    float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {\n    \n        float hr = 0.01 + float(i) * 0.5 / 4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvec4 getHitColor(vec3 ro, vec3 rd, float t, vec3 lightPos) {\n    vec3 hit = ro + rd * t;\n    vec3 norm = normal(hit);\n    \n    vec3 light = lightPos - hit;\n    float lightDist = max(length(light), .001);\n    float atten = 1. / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    light /= lightDist;\n    \n    float occ = occlusion(hit, norm);\n    \n    float dif = clamp(dot(norm, light), 0.0, 1.0);\n    dif = pow(dif, 4.) * 2.;\n    float spe = pow(max(dot(reflect(-light, norm), -rd), 0.), 8.);\n    \n    vec3 color = mapColor(hit, t) * (dif + .35  + vec3(.35, .45, .5) * spe) + vec3(.7, .9, 1) * spe * spe;\n    \n    return vec4(color, atten * occ);\n}\n\nvec3 getColor(vec2 uv, vec3 ro, vec3 dir, vec3 lightPos) {\n    vec3 fwd = normalize(dir);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x));\n    vec3 up = (cross(fwd, rgt));\n    \n    vec3 rd = normalize(fwd + FOV*(uv.x*rgt + uv.y*up));\n    \n    float t = rayMarch(ro, rd, MAX_RAY);\n    \n    vec3 outColor = vec3(.0);\n    \n    if(t < FAR) {\n        vec3 hit = ro + rd * t;\n        vec3 norm = normal(hit);\n        vec4 color = getHitColor(ro, rd, t, lightPos);\n        \n        vec3 ref = reflect(rd, norm);\n        float refQ = mapRef(hit, t);\n        float t2 = refQ <= .001 ? .0 : rayMarch(hit + ref * .1, ref, MAX_REF);\n        vec4 color2 = refQ <= .001 ? vec4(.0) : getHitColor(hit + ref * .1, ref, t2, lightPos);\n    \n        outColor = (color.xyz * (1. - refQ) + refQ * color2.xyz * color2.w) * color.w;\n    }\n    \n    outColor = mix(min(outColor, 1.), vec3(.0), 1. - exp(-t*t/FAR/FAR*10.));\n    \n    return outColor;\n}\n\n#define CAMERA_SPEED .5\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 pos = vec3(1. + 3. * cos(iTime * CAMERA_SPEED), 1. + sin(iTime * CAMERA_SPEED) * .2, 3. * sin(iTime * CAMERA_SPEED));\n    vec3 dir = vec3(3. * cos(iTime * CAMERA_SPEED + PI), -1.5, 3. * sin(iTime * CAMERA_SPEED + PI));\n    vec3 light = vec3(.0, 4., .0);\n    \n    vec3 c = getColor(uv, pos, dir, light);\n    \n    fragColor = vec4(sqrt(c),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}