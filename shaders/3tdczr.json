{
    "Shader": {
        "info": {
            "date": "1608391825",
            "description": "conformal polygonal morphism\n\npolyhedral symmetry in the riemann sphere \n[url]https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in-the-riemann-sphere[/url]\nconfigure code to see other spherical polyhedra",
            "flags": 0,
            "hasliked": 0,
            "id": "3tdczr",
            "likes": 16,
            "name": "conformal polygonal morphism",
            "published": 3,
            "tags": [
                "sphere",
                "conformal",
                "tiling"
            ],
            "usePreview": 0,
            "username": "cyperus",
            "viewed": 658
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// \"conformal polygonal morphism\"\n//\n// created by Colling Patrik (cyperus) in 2020\n//\n// DOCUMENTATION:\n// https://math.stackexchange.com/questions/1469554/polyhedral-symmetry-in-the-riemann-sphere\n//\n////////////////////////////////////////////////////////////////////////////////\n// animation\nconst float anim_velocity = 1.0;\n// camera\nconst float cam_dist = 3.0;\nconst float cam_fle = 2.;\n// raymarch\nconst int rm_maxi = 100;\nconst float rm_mindist = 1.5, rm_maxdist = 4.0;\nconst float rm_slmul = 0.3;\n// texture\nconst float ba_v_distri = 0.5;\nconst float tex_u_subdiv = 6.0, tex_v_subdiv = 6.0;\n// anti-aliasing\nconst float AA = 2.0;\n\nfloat map( in vec4 pt, out vec4 mat ){    \n    float time = pt.w;   \n\tvec3 p = pt.xyz, pn = normalize(p);\n    int k, n;\n    vec2 z, zk; \n    #if 0\n    // Fk,2(z) = wk2(z)\n    k = 3;\n    vec2 wk2;\n    float a1 = float(k);\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-(pn.z));\n        zk = cpow(z,k);\n        wk2 = a1 * cdiv(zk, cpow(zk - vec2(1.,0.) ,2));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        wk2 = a1 * cdiv(zk, cpow(vec2(1.,0.) - zk ,2));     \n    }    \n    float srk2 = float(length(wk2)>1.0?-2:k);\n    #endif\n    #if 0\n    // F3,3(z) = w33(z)\n    k = 3, n = 3;\n    const float a1 = 2.*sqrt(2.);\n    vec2 w33;\n    if (pn.z < 0.) // stereographic (north pol)\n    {\n        z = pn.xy/(1.0-pn.z);\n        zk = cpow(z,k);\n        w33 = 1./(8.*a1) * zk;\n        w33 = cmul(w33, cpow(zk-vec2(a1,0.),k));\n        w33 = cdiv(w33, cpow(zk+ vec2(1./a1,0.0),n));\n    }else        // stereographic (south pol)\n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        w33 = 1./(8.*a1)*cinv(zk);       \n        w33 = cmul(w33, cpow(vec2(1.,0.) - zk * a1 ,k));\n        w33 = cdiv(w33, cpow(vec2(1.,0.) + zk / a1 ,n));    \n    }\n    float sr33 = float(length(w33)>1.0?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,3.}\n    #endif \n    #if 1\n    // F4,3(z) = w43(z)  \n    k = 4, n = 3;\n    vec2 w43;\n    if (pn.z < 0.) // stereographic (north pol)\n    {        \n        z = vec2(pn.x, pn.y)/(1.-pn.z);\n        zk = cpow(z,k);\n        w43 = 108. * zk;\n        w43 = cmul(w43, cpow(zk - vec2(1.,0.)                   ,k));\n        w43 = cdiv(w43, cpow(cmul(zk,zk) + 14.*zk + vec2(1.,0.) ,n));\n    }else         // stereographic (south pol) \n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        w43 = 108. * zk;\n        \n        w43 = cmul(w43, cpow(vec2(1.,0.) - zk                   ,k));\n        w43 = cdiv(w43, cpow(vec2(1.,0.) + 14.*zk + cmul(zk,zk) ,n)); \n    }\n    float sr43 = float(length(w43)>1.?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,4.}\n    #endif\n\t#if 1\n    // F5,3(z) = w53(z)\n    k = 5, n = 3;\n    vec2 w53;  \n    if (pn.z < 0.) // stereographic (north pol)\n    {  \n        z = pn.xy/(1.+abs(pn.z));\n        zk = cpow(z,k); \n        vec2 zk2 = cmul(zk,zk);\n        w53 = 1728. * zk;\n        w53 = cmul(w53, cpow(  zk2-11.*zk-vec2(1.,0.)  ,k));\n        w53 = cdiv(w53, cpow(   cmul(zk2,zk2)\n                       +228.*cmul(zk2,zk)\n                       +494.*zk2\n                       -228.*zk\n                       +vec2(1.,0.) ,n)  );\n    } else        // stereographic (south pol)                    \n    {\n        z = vec2(pn.x, -pn.y)/(1.+pn.z);\n        zk = cpow(z,k);\n        vec2 zk2 = cmul(zk,zk);\n        w53 = 1728. * zk; \n        w53 = cmul(w53, cpow( vec2(1.,0.) - 11.*zk - zk2 ,k));\n        w53 = cdiv(w53, cpow( vec2(1.,0.)\n                       +228.0*zk\n                       +494.0*zk2\n                       -228.0*cmul(zk2,zk)\n                       +cmul(zk2,zk2) ,n)  );\n    }\n    float sr53 = float(length(w53)>1.0?-n:k);\n    // sense of rotation of the polygon: sign(sr) in {-1.,+1.}\n    // number of sides of the polygon: abs(sr) in {3.,5.}\n\t#endif\n    \n    vec2 w; float sr;\n    //switch: {1,0} => {single polyhedron, metamorphose of 2 polyhedra}\n\t#if 0\n    //select polyhedron from (wk2,srk2 ), (w33,sr33), (w43,sr43), (w53,sr53)\n    w = w43; sr = sr43;\n\t#else\n    float ff = smoothrecpuls(0.02*time,0.0,1.0,0.3,0.3);\n    //select polyhedra from (wk2,srk2 ), (w33,sr33), (w43,sr43), (w53,sr53)\n    w = metamorph(w43,w53,ff); sr = metamorph(sr43,sr53,ff);\n\t#endif\n    \n    // return texture data\n\tmat = vec4(w,sr,1.0 );\n \n\t// sdf r(w) sphere\n    float r = 1.0 + 0.1*sin(atan(log(length(w))*ba_v_distri));\n\tfloat d = length(p)-r;\n\t//\n    return d;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px ,in float time)\n{\n    float res = -1.0; // init no intersection\n    \n    // bb boundingbox\n    vec2 dis = isphere( ro, rd , 2.);\n    \n    if( dis.y<0.0 ) // if no hit with bb return\n        return -1.0;\n    dis.x = max( dis.x, rm_mindist );\t// start_raylength from bb or minimal_raylength\n    dis.y = min( dis.y, rm_maxdist );\t// end_raylength from bb or maximal_raylength\n    // raymarch signed distance field\n\tvec4 data; // accumulated data while raymarching\n    \n\tfloat t = dis.x; // init with start_raylength\n\tfor( int i=0; i<rm_maxi; i++  )\n    { \n        vec4 pt = vec4(ro + rd*t,time);\n        float th = 0.0001*px*t; //th = 0.0001; // iso_surface-hit-delta\n\t\tfloat h = map( pt, data );\n\t\tif( t>dis.y || h<th ) break; // reached end_raylength or hit iso_surface\n        t += h*rm_slmul; // step-length-multiplier\n    }\n    \n    if( t<dis.y ) // ray is inside bb\n    {\n        rescol = data; // return data\n        res = t;       // return ray_length\n    }\n    return res;\n}\n\n// transform from mla\nvec3 transform(in vec4 p){\n\tif (iMouse.x > 0.0)\n\t{\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tp.yz = crot(p.yz,theta);\n\t\tp.zx = crot(p.zx,-phi);\n\t}\n\tp.xz = crot(p.xz,p.w*0.1);\n\treturn p.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// global time\n\tfloat time = anim_velocity*iTime;\n    \n\t// camera\n\tvec3 ro = transform(vec4(0,0,-cam_dist,time)).xyz;\n    \n\t// anti-aliasing\n\tvec3 aacol = vec3(0);\n\tfor (float i = 0.0; i < max(-time,AA); i++) {\n\t\tfor (float j = 0.0; j < max(-time,AA); j++) {\n        \n\t\t\t// ray direction\n\t\t\tvec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(transform(vec4(uv,cam_fle,time)));\n            \n\t\t\t// get ray distance to (intersection) hit point\n\t\t\tvec4 mat = vec4(0.0);\n\t\t\tfloat px = 2.0/( iResolution.y*cam_fle );\n\t\t\tfloat t = intersect( ro, rd, mat, px ,time);\n\n\t\t\tvec3 col;\n\t\t\tif (t < 0.0){ // sky\n\t\t\t\tcol = vec3(0.8,0.6,1.0)*(0.3+0.2*rd.y); // background-color\n\t\t\t}\n\t\t\telse{ // intersection with surface\n\t\t\t\tvec3 p = ro + rd * t;// intersection point\n                \n\t\t\t\t// texture_data, mat = vec4(w,sr,1.0 );\n\t\t\t\tvec2 w = vec2(mat.s,mat.t); float sr = mat.p;\n                \n\t\t\t\t// texture_coords\n\t\t\t\tfloat u = atan(w.y,w.x)/PI;// [-PI,+PI] => u in[-1.,0.,+1.]\n\t\t\t\t// length(w) in[0.,1.,+inf] => [-inf,0.,+inf] => [-0.5*PI,+0.5*PI] => v in[-1.,0.,+1.]\n\t\t\t\tfloat v = atan(log(length(w))*ba_v_distri)/(0.5*PI);\n                \n\t\t\t\t// texture_color\n                float col_h = 1.0; // h in [-0.5,0.0,+0.5] => [green_cyan,red,blue_cyan]\n                col_h *= 0.5*v;\n                //col_h *= 0.5*u;\n\t\t\t\tfloat col_s = 1.0;\n\t\t\t\tcol_s *= 0.9+0.1*sign(sr);\n                col_s *= (t == rm_mindist)?0.5:1.0;\n\t\t\t\tfloat col_v = 1.0;\n\t\t\t\tcol_v *= .5+.5*fract(tex_u_subdiv*1.0*(.5+.5*u) - 0.3* time);\n\t\t\t\tcol_v *= .5+.5*fract(tex_v_subdiv*2.0*(.5+.5*v) - 0.3* time);\n\t\t\t\tcol = hsv2rgb(col_h, col_s, col_v);// color (hue, saturation, value)\n\t\t\t}\n\t\t\taacol += col;\n\t\t}\n\t}\n\taacol /= float(AA*AA);\n\taacol = pow(aacol,vec3(0.4545)); // gamma correction\n\tfragColor = vec4(aacol,1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// const\nconst float PI = 3.14159265359;\n\n// 2D transformations: vec2 => vec2\n// complex\nvec2 cmul(vec2 za,vec2 zb){\n    return za*mat2(zb.x,-zb.y,zb.yx);\t// za*zb\n}\nvec2 cinv(vec2 z) {\t\t\t\t\t\t// 1/z\n  return z*vec2(1,-1)/dot(z,z);\n}\nvec2 cdiv(vec2 z, vec2 w){\t\t\t\t// z/w\n  return cmul(z,cinv(w));\n}\n\nvec2 cpow(vec2 z, int n) {\t\t\t\t// z^n\n  float r = length(z);\n  float theta = atan(z.y,z.x);\n  return pow(r,float(n))*normalize(vec2(cos(float(n)*theta),sin(float(n)*theta)));\n}\n\nvec2 crot(vec2 z,float a){\n    float si = sin(a), co = cos(a);\t\t// z*e^(j*a)\n    return mat2(co,-si,si,co)*z;\n}\n\nvec2 metamorph(vec2 z0,vec2 z1, float f){\n\tif (f<= 0.0) return z0;\n\tif (f>= 1.0) return z1;\n\telse return cdiv(cmul(z0,z1),(f*z0+(1.0-f)*z1));\n}\n\nfloat metamorph(float x0,float x1, float f){\n\tif (f<= 0.0) return x0;\n\tif (f>= 1.0) return x1;\n\treturn x0*x1/(f* x0+(1.0-f)*x1);\n}\n\n//\nfloat smoothrecpuls(float x,float aa,float ab,float ia,float ib){\n\t/*\n\tsmoothrecpuls is an periodic smooth rectangle-function\n\twith normalized periode == 1.\n\tIt starts at x == 0 with the first-transition-interval, followed by puls-a-const-\n\t, second-transition- and puls-b-const-interval.\n\tfloat x  : value\t\t(normalized)\n\tfloat aa : amplitude pulse a\n\tfloat ia : interval puls a\t\tia in [0,1]  (normalized)\n\tfloat ab : amplitude pulse b\n\tfloat ib : interval puls b\t  \tib in [0,1]  (normalized)\n\n\tcheck ia+ib < 1.0; it+ia+it+ib = 1.0;\n\t */\n\tia = abs(ia);\n\tib = abs(ib);\n\t// function smooth2puls\n\tfloat it = 0.5*(1.-ia-ib); // interval transition\n\tx = fract(x);\n\treturn   (aa-ab)*smoothstep(0.0\t\t,it\t\t\t,x)+ab\n\t\t\t-(aa-ab)*smoothstep(it+ia\t,it+ia+it\t,x);\n}\n\n// 3D-transformations: vec3 => vec3\n//color\nvec3 hsv2rgb(float h, float s, float v){\t\t// hue, saturation, value\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing       \n  return v * mix( vec3(1.0), rgb, s);\n}\n\nvec2 isphere(in vec3 ro, in vec3 rd, in float r )\n{// sphere centered at the origin, with size rd\n    \n\tfloat b = dot(ro,rd);\n\tfloat c = dot(ro,ro) - r*r;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}