{
    "Shader": {
        "info": {
            "date": "1578203120",
            "description": "- Standard \"Escher-Droste\" effect with a procedural terrain and skybox.\n- Use mouse drag to change some parameters.",
            "flags": 32,
            "hasliked": 0,
            "id": "tl3GW2",
            "likes": 155,
            "name": "Portal 1",
            "published": 3,
            "tags": [
                "procedural",
                "terrain",
                "droste",
                "escher",
                "aurora",
                "desert"
            ],
            "usePreview": 0,
            "username": "tmst",
            "viewed": 2794
        },
        "renderpass": [
            {
                "code": "#define TWOPI 6.283185307179586\n\n#define IMAGE_ASPECT_WIDTH_OVER_HEIGHT 1.0\n\n#define FIXED_UP vec3(0.0, 1.0, 0.0)\n#define TAN_HALF_FOVY 0.7673269879789604\n#define CAM_Z_NEAR 0.1\n#define CAM_Z_FAR 50.0\n\n#define MIN_DIST 0.005\n#define MAX_DIST 50.0\n#define RAY_STEPS 30\n#define RAY_STEPS_SHADOW 10\n#define POM_QUALITY 100\n#define POM_QUALITY_REFL 40\n\n#define TEX_SCALE 40.0\n#define BUMP_TEX_DEPTH 0.12\n#define BOUNDARY_RADIUS 0.2\n#define PLANE_DEPTH 3.0\n#define NV_PLANE_N vec3(0.0, 1.0, 0.0)\n\n#define TWIST\n#define TWIST_EXPONENT 1.0\n#define DROSTE\n\n// =============================================\n// Some generic helpers\n// =============================================\n\n// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat lensq(vec3 p, vec3 q) {\n    vec3 pq = q - p;\n    return dot(pq, pq);\n}\n\nfloat hitPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p, vec3 v) {\n    return dot(planePoint - p, nvPlaneN) / dot(v, nvPlaneN);\n}\n\nmat4 getClipToWorld(float aspectWoverH, vec3 nvCamFw) {\n    mat4 clipToEye = mat4(\n        aspectWoverH * TAN_HALF_FOVY, 0.0, 0.0, 0.0,\n        0.0, TAN_HALF_FOVY, 0.0, 0.0,\n        0.0, 0.0,  0.0, (CAM_Z_NEAR - CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR),\n        0.0, 0.0, -1.0, (CAM_Z_NEAR + CAM_Z_FAR)/(2.0 * CAM_Z_NEAR * CAM_Z_FAR)\n    );\n\n    vec3 nvCamRt = normalize(cross(nvCamFw, FIXED_UP));\n    vec3 nvCamUp = cross(nvCamRt, nvCamFw);\n    mat4 eyeToWorld = mat4(\n         nvCamRt, 0.0,\n         nvCamUp, 0.0,\n        -nvCamFw, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n\n    return eyeToWorld * clipToEye;\n}\n\nvec3 nvDirFromClip(mat4 clipToWorld, vec2 clip) {\n    vec4 world = clipToWorld * vec4(clip, 1.0, 1.0);\n    return normalize(world.xyz / world.w);\n}\n\nvoid computeLighting(\n    in float diffuseCoefficient,\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 lightColor,\n    in vec3 texColor,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam,\n    out vec3 diffuse,\n    out vec3 specular\n) {\n    float valDiffuse = max(0.0, dot(nvNormal, nvFragToLight));\n    valDiffuse *= diffuseCoefficient;\n\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    diffuse = valDiffuse * texColor * lightColor;\n    specular = valSpecular * lightColor;\n}\n\n// =============================================\n// \"Portal object\" rendering\n// =============================================\n\nvec3 cpPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    float t = dot(p - planePoint, nvPlaneN);\n    return p - t*nvPlaneN;\n}\n\nvec3 cpSeg(vec3 q0, vec3 q1, vec3 p) {\n    vec3 vEdge = q1 - q0;\n    float t = dot(p - q0, vEdge) / dot(vEdge, vEdge);\n    return q0 + clamp(t, 0.0, 1.0)*vEdge;\n}\n\nvec3 cpTuple2(vec3 q0, vec3 q1, vec3 p) {\n    vec3 q = q0;\n    return mix(q, q1, step( lensq(p,q1), lensq(p,q) ));\n}\n\nvec3 cpTuple3(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 q = cpTuple2(q0,q1, p);\n    return mix(q, q2, step( lensq(p,q2), lensq(p,q) ));\n}\n\nvec3 cpTuple4(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    vec3 q = cpTuple3(q0,q1,q2, p);\n    return mix(q, q3, step( lensq(p,q3), lensq(p,q) ));\n}\n\nvec3 cpTriBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    return cpTuple3(cpSeg(q0,q1, p), cpSeg(q1,q2, p), cpSeg(q2,q0, p), p);\n}\n\nvec3 cpQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    return cpTuple4(\n        cpSeg(q0,q1, p), cpSeg(q1,q2, p),\n        cpSeg(q2,q3, p), cpSeg(q3,q0, p), p\n    );\n}\n\nfloat pointInTri(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 v01 = cross(q1-q0, p-q0);\n    vec3 v12 = cross(q2-q1, p-q1);\n    vec3 v20 = cross(q0-q2, p-q2);\n    return step(0.0, dot(v01,v12)) * step(0.0, dot(v01,v20));\n}\n\nvec3 cpTri(vec3 q0, vec3 q1, vec3 q2, vec3 p) {\n    vec3 nvPlaneN = normalize(cross(q1-q0, q2-q0));\n    vec3 xp = cpPlane(q0, nvPlaneN, p);\n    return mix(cpTriBoundary(q0,q1,q2, p), xp, pointInTri(q0,q1,q2, xp));\n}\n\nvec3 cpQuad(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    return cpTuple2(cpTri(q0,q1,q2, p), cpTri(q0,q2,q3, p), p);\n}\n\nfloat sdQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, float r, vec3 p) {\n    vec3 x = cpQuadBoundary(q0,q1,q2,q3, p);\n    return distance(x, p) - r;\n}\n\nvec3 normalQuadBoundary(vec3 q0, vec3 q1, vec3 q2, vec3 q3, vec3 p) {\n    vec3 x = cpQuadBoundary(q0,q1,q2,q3, p);\n    return normalize(p - x);\n}\n\nfloat sdQuad(vec3 q0, vec3 q1, vec3 q2, vec3 q3, float r, vec3 p) {\n    vec3 x = cpQuad(q0,q1,q2,q3, p);\n    return distance(x, p) - r;\n}\n\nvoid hitObject(\n    in vec3 startPos, in vec3 nvRayDir,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out float didHit, out vec3 hitPos\n){\n    didHit = 0.0;\n    float travel = 0.0;\n    vec3 curPos = startPos;\n\n    for (int k = 0; k < RAY_STEPS; k++) {\n        float sdCur = sdQuadBoundary(q00,q10,q11,q01, BOUNDARY_RADIUS, curPos);\n\n        if (sdCur < MIN_DIST) {\n            didHit = 1.0;\n            break;\n        }\n\n        curPos += sdCur * nvRayDir;\n        travel += sdCur;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n\n    hitPos = curPos;\n}\n\nvoid hitShadow(\n    in vec3 startPos, in vec3 nvRayDir,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out float lightPercent\n){\n    lightPercent = 1.0;\n    float travel = 0.0;\n    vec3 curPos = startPos;\n\n    for (int k = 0; k < RAY_STEPS_SHADOW; k++) {\n        float sdCur = sdQuad(q00,q10,q11,q01, BOUNDARY_RADIUS, curPos);\n\n        float curLightPercent = abs(sdCur)/(0.02*travel);\n        lightPercent = min(lightPercent, curLightPercent);\n\n        if (sdCur < MIN_DIST) {\n            lightPercent = 0.0;\n            break;\n        }\n\n        curPos += sdCur * nvRayDir;\n        travel += sdCur;\n        if (travel > MAX_DIST) {\n            break;\n        }\n    }\n}\n\n// =============================================\n// Terrain and sky rendering\n// =============================================\n\nvec4 bumpTex(vec2 uv) {\n    float r = textureLod(iChannel0, uv, 0.0).r;\n\n    float ang = (r + fract(uv.x) + fract(uv.y)) * TWOPI;\n    vec2 q = uv + 0.1*vec2( cos(ang), sin(ang) );\n\n    float height = textureLod(iChannel0, q, 0.0).r;\n    vec3 color = mix(vec3(0.0), vec3(1.0, 0.2, 0.1), height);\n\n    return vec4(color, height);\n}\n\nvec2 skyTex(vec2 uv) {\n    vec4 data = textureLod(iChannel0, uv, 0.0);\n\n    float starIntensity = data.b;\n    \n    float ang = (data.g + iTime*0.1) * TWOPI;\n    vec2 q = uv + 0.05*vec2( cos(ang), sin(ang) );\n    float cloudIntensity = textureLod(iChannel0, q, 0.0).g;\n    \n    return vec2(cloudIntensity, starIntensity);\n}\n\nvec3 bumpTexNormal(vec2 uv) {\n    vec2 uvPixel = 1.0 / iResolution.xy;\n    float hSA = bumpTex(uv + vec2(-uvPixel.s, 0.0)).a;\n    float hSB = bumpTex(uv + vec2( uvPixel.s, 0.0)).a;\n    float hTA = bumpTex(uv + vec2(0.0,-uvPixel.t)).a;\n    float hTB = bumpTex(uv + vec2(0.0, uvPixel.t)).a;\n\n    vec2 dhdt = vec2(hSB-hSA, hTB-hTA) / (2.0 * uvPixel);\n    vec2 gradh = BUMP_TEX_DEPTH * dhdt;\n    return normalize(vec3( -gradh, 1.0 ));\n}\n\nvec3 skyColor(vec3 nvDir) {\n    float yy = clamp(nvDir.y+0.1, 0.0, 1.0);\n    float horiz0 = pow(1.0 - yy, 30.0);\n    float horiz1 = pow(1.0 - yy, 5.0);\n    \n    vec3 sv = nvDir - vec3(0.0, -1.0, 0.0);\n    vec2 uvCloud = 0.25*(sv.xz / sv.y) + vec2(0.5);\n    vec2 skyTexVal = skyTex(uvCloud);\n\n    float cloudIntensity = pow(skyTexVal.x, 2.0);\n    float starIntensity = pow(skyTexVal.y, 2.0);\n\n    vec3 c = vec3(0.0);\n    c = mix(c, vec3(0.2, 0.0, 0.5), horiz1);\n    c = mix(c, vec3(1.0), horiz0);\n    c = mix(c, vec3(0.45, 0.5, 0.48), (1.0-horiz0)*cloudIntensity);\n    c = mix(c, vec3(1.0), (1.0-horiz1)*starIntensity);\n    return c;\n}\n\nvoid getParallaxMaxOffsets(\n    in vec3 tangentS,\n    in vec3 tangentT,\n    in vec3 nvNormal,\n    in vec3 camToFrag,\n    in float depthMax,\n    out vec2 maxTexOffset,\n    out vec3 maxPosOffset\n){\n    // Scale camToFrag so that its depth into the surface == depthMax\n    float camDist = -dot(camToFrag, nvNormal);\n    maxPosOffset = (depthMax / camDist) * camToFrag;\n\n    // maxPosOffset = a*tangentS + b*tangentT + N <=> maxTexOffset = [a,b]\n    float dss = dot(tangentS, tangentS);\n    float dst = dot(tangentS, tangentT);\n    float dtt = dot(tangentT, tangentT);\n    float dcs = dot(maxPosOffset, tangentS);\n    float dct = dot(maxPosOffset, tangentT);\n    float invDet = 1.0 / (dss * dtt - dst * dst);\n    maxTexOffset = invDet * vec2(dtt*dcs - dst*dct, -dst*dcs + dss*dct);\n}\n\nfloat getParallaxDepthFactor(vec2 uvInitial, vec2 maxTexOffset, int steps) {\n    vec2 uvMax = uvInitial + maxTexOffset;\n    float dt = 1.0 / float(steps);\n\n    float tOld = 0.0, depthOld = 0.0;\n    float tCur = 0.0, depthCur = 0.0;\n\n    for(int i=0; i<=steps; ++i){\n        tOld = tCur;\n        tCur = float(i)*dt;\n\n        depthOld = depthCur;\n        depthCur = 1.0 - bumpTex(mix(uvInitial, uvMax, tCur)).a;\n\n        if(tCur > depthCur){\n            tCur = mix(tOld, tCur, unmix(depthOld-tOld, depthCur-tCur, 0.0));\n            break;\n        }\n    }\n\n    return tCur;\n}\n\nvoid terrainAndSky(\n    in vec3 startPos, in vec3 nvRayDir, in vec3 lightPos, in int pomSteps,\n    in vec3 q00, in vec3 q10, in vec3 q11, in vec3 q01,\n    out vec3 hitColor\n) {\n    float tPlane = hitPlane(\n        vec3(0.0, -PLANE_DEPTH, 0.0), NV_PLANE_N,\n        startPos, nvRayDir\n    );\n    float didHitPlane = step(0.0, tPlane);\n\n    if (didHitPlane > 0.5) {\n\n        vec3 hitPos = startPos + tPlane*nvRayDir;\n        vec2 hitTex = hitPos.xz / TEX_SCALE;\n\n        vec2 maxTexOffset;\n        vec3 maxPosOffset;\n        getParallaxMaxOffsets(\n            vec3(TEX_SCALE, 0.0, 0.0),\n            vec3(0.0, 0.0, TEX_SCALE),\n            vec3(0.0, 1.0, 0.0),\n            hitPos - startPos,\n            BUMP_TEX_DEPTH * TEX_SCALE,\n            maxTexOffset,\n            maxPosOffset\n        );\n        float depthPct = getParallaxDepthFactor(hitTex, maxTexOffset, pomSteps);\n        vec2 hitTexBump = hitTex + depthPct*maxTexOffset;\n        vec3 hitPosBump = hitPos + depthPct*maxPosOffset;\n\n        vec3 bumpColor = bumpTex(hitTexBump).rgb;\n        vec3 nvNormal = bumpTexNormal(hitTexBump);\n        vec3 nvBumpNormal = normalize(vec3(nvNormal.x, 1.0, nvNormal.y));\n\n        if (distance(startPos, hitPosBump) < MAX_DIST) {\n\n            // Hit terrain: Compute fog, lighting, and shadow\n\n            vec3 nvBumpPosToLight = normalize(lightPos - hitPosBump);\n            vec3 vBumpPosToStart = startPos - hitPosBump;\n            float dHit = length(vBumpPosToStart);\n            vec3 nvBumpPosToStart = vBumpPosToStart / dHit;\n\n            float lightPercent = 1.0;\n            hitShadow(\n                hitPosBump, nvBumpPosToLight,\n                q00,q10,q11,q01,\n                lightPercent\n            );\n            lightPercent *= mix(1.0, 0.0, depthPct);\n\n            vec3 diffuse;\n            vec3 specular;\n            computeLighting(\n                0.8, 0.3, 5.0,\n                vec3(1.0), bumpColor,\n                nvBumpNormal, nvBumpPosToLight, nvBumpPosToStart,\n                diffuse, specular\n            );\n            vec3 ambient = 0.1 * bumpColor;\n            vec3 matColor = ambient + lightPercent*(diffuse + specular);\n\n            float fogMin = 0.0;\n            float fogMax = 0.8;\n            vec3 fogColor = vec3(0.9, 0.8, 1.0);\n            float fogT = mix(fogMin, fogMax, unmix(0.0, MAX_DIST, dHit) );\n            float fogAmount = pow(fogT, 1.5);\n\n            hitColor = mix(matColor, fogColor, fogAmount);\n\n        } else {\n\n            // Too far, use skybox\n            hitColor = skyColor(nvRayDir);\n\n        }\n\n    } else {\n\n        // Didn't hit plane, use skybox\n        hitColor = skyColor(nvRayDir);\n    }\n}\n\n// =============================================\n// Overall scene\n// =============================================\n\nfloat subrectSize() {\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    float valDefault = 0.25;\n    float valPressed = mix(0.04, 0.6, iMouse.x/iResolution.x);\n    return mix(valDefault, valPressed, isMousePressed);\n}\n\nvec4 scene(vec2 p) {\n\n    // Camera\n    // ---------------------------\n    vec3 camPos = 4.0 * vec3(cos(iTime*0.2), 0.0, sin(iTime*0.2));\n    camPos += vec3(0.0, 0.75 + 0.5*cos(iTime*0.5), 0.0);\n    vec3 lookTarget = vec3(0.0);\n\n    vec3 movement = vec3(2.0, 0.0, -iTime*2.0);\n    camPos += movement;\n    lookTarget += movement;\n\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    mat4 clipToWorld = getClipToWorld(IMAGE_ASPECT_WIDTH_OVER_HEIGHT, nvCamFw);\n    vec3 nvCamDir = nvDirFromClip(clipToWorld, p);\n\n    // Portal geometry\n    // ---------------------------\n    float a = subrectSize();\n\n    vec3 nv00 = nvDirFromClip(clipToWorld, vec2(-a,-a));\n    vec3 nv10 = nvDirFromClip(clipToWorld, vec2( a,-a));\n    vec3 nv01 = nvDirFromClip(clipToWorld, vec2(-a, a));\n    vec3 nv11 = nvDirFromClip(clipToWorld, vec2( a, a));\n\n    float minY = -PLANE_DEPTH + 2.5*BOUNDARY_RADIUS;\n    float tL = hitPlane(vec3(0.0,  minY, 0.0),  NV_PLANE_N, camPos, nv00);\n    float tU = hitPlane(vec3(0.0, -minY, 0.0), -NV_PLANE_N, camPos, nv01);\n    float tPortal = min(12.0, min(\n        mix(MAX_DIST, tL, step(0.0, tL)),\n        mix(MAX_DIST, tU, step(0.0, tU))\n    ));\n\n    vec3 q00 = camPos + tPortal*nv00;\n    vec3 q10 = camPos + tPortal*nv10;\n    vec3 q01 = camPos + tPortal*nv01;\n    vec3 q11 = camPos + tPortal*nv11;\n\n    vec3 portalVX = normalize(q10 - q00);\n    vec3 portalVY = normalize(q01 - q00);\n    vec3 portalVZ = cross(portalVX, portalVY);\n\n    q00 += BOUNDARY_RADIUS * ( -portalVX - portalVY );\n    q10 += BOUNDARY_RADIUS * (  portalVX - portalVY );\n    q01 += BOUNDARY_RADIUS * ( -portalVX + portalVY );\n    q11 += BOUNDARY_RADIUS * (  portalVX + portalVY );\n\n    // Light placement\n    // ---------------------------\n    vec3 lightPos = 0.5*(q01 + q11) + 1.0*portalVY + 5.0*portalVZ;\n\n    // Render scene\n    // ---------------------------\n    vec3 sceneColor = vec3(0.0);\n\n    float didHitPortal;\n    vec3 hitPos;\n    hitObject(camPos, nvCamDir, q00,q10,q11,q01, didHitPortal, hitPos);\n\n    if (didHitPortal > 0.5) {\n\n        vec3 n = normalQuadBoundary(q00,q10,q11,q01, hitPos);\n        vec3 nvRefl = normalize(reflect( hitPos-camPos, n ));\n\n        vec3 diffuse;\n        vec3 specular;\n        computeLighting(\n            0.2, 0.8, 20.0,\n            vec3(1.0), 0.4*vec3(1.0, 0.5, 1.0),\n            n, normalize(lightPos - hitPos), normalize(camPos - hitPos),\n            diffuse, specular\n        );\n        vec3 matColor = diffuse + specular;\n\n        vec3 terrainColor;\n        terrainAndSky(\n            hitPos, nvRefl, lightPos, POM_QUALITY_REFL,\n            q00,q10,q11,q01,\n            terrainColor\n        );\n\n        sceneColor = matColor + 0.8*terrainColor;\n\n    } else {\n\n        terrainAndSky(\n            camPos, nvCamDir, lightPos, POM_QUALITY,\n            q00,q10,q11,q01,\n            sceneColor\n        );\n\n    }\n\n    return vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}\n\n// ------------------------------------------\n// Helpers to achieve \"Escher effect\"\n// ------------------------------------------\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 clog(vec2 a) {\n    return vec2(0.5*log(dot(a,a)), atan(a.y, a.x));\n}\n\nvec2 cexp(vec2 a) {\n    return exp(a.x)*vec2(cos(a.y), sin(a.y));\n}\n\nvec2 twist(vec2 p) {\n#ifdef TWIST\n    float a = subrectSize();\n\n    vec2 r = vec2(TWIST_EXPONENT, log(a)/TWOPI);\n    return cexp(cmul(r, clog(p)));\n#else\n    return p;\n#endif\n}\n\nvec2 droste(vec2 p) {\n#ifdef DROSTE\n    float a = subrectSize();\n\n    float isMousePressed = clamp(iMouse.z, 0.0, 1.0);\n    float apow = mix(\n        fract(iTime*0.2), 4.0*iMouse.y/iResolution.y, isMousePressed\n    );\n    p *= pow(a, apow);\n\n    vec2 log_a = log(abs(p)) / log(a);\n    float adjust = min(floor(log_a.x), floor(log_a.y));\n    log_a -= vec2(adjust);\n\n    return sign(p) * pow(vec2(a), log_a);\n#else\n    return p;\n#endif\n}\n\n// ------------------------------------------\n// Put it all together!\n// ------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = (2.0*uv - 1.0);\n    p.x *= (iResolution.x / iResolution.y) / IMAGE_ASPECT_WIDTH_OVER_HEIGHT;\n\n    vec2 radv = uv - vec2(0.5, 0.5);\n    float dCorner = length(radv);\n    float vignetteFactor = 1.0 - mix(0.0, 0.3, smoothstep(0.2, 0.707, dCorner));\n\n    fragColor = vignetteFactor * scene(droste(twist(p)));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Find t so that mix(a,b,t) = x\nfloat unmix(float a, float b, float x) {\n    return (x - a)/(b - a);\n}\n\nfloat rand(in vec2 p) {\n    return fract(sin(dot(p,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(in vec2 p) {\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n\n    float r00 = rand(vec2(pi.x    ,pi.y    ));\n    float r10 = rand(vec2(pi.x+1.0,pi.y    ));\n    float r01 = rand(vec2(pi.x    ,pi.y+1.0));\n    float r11 = rand(vec2(pi.x+1.0,pi.y+1.0));\n\n    return mix(mix(r00, r10, pf.x), mix(r01, r11, pf.x), pf.y);\n}\n\nfloat fbm(vec2 uv) {\n    vec2 p = uv*256.0;\n    \n    float v = noise(p);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    p *= 0.3;\n    v = mix(v, noise(p), 0.8);\n\n    return v;\n}\n\nfloat nearInt(float x) {\n    return pow(0.5 + 0.5*cos(x*6.28),10.0);\n}\n\nfloat fbmWithBorder(vec2 uv) {\n    float r = fbm(uv);\n    return mix(1.0, fbm(uv), (1.0-nearInt(uv.x))*(1.0-nearInt(uv.y)) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float heightTerrain = fbmWithBorder(uv);\n    float cloudIntensity = heightTerrain;\n    \n    float starVal = noise(uv*1024.0);\n    float starIntensity = unmix(0.95, 1.0, starVal) * step(0.95, starVal);\n\n    fragColor = vec4(heightTerrain, cloudIntensity, starIntensity, 0.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}