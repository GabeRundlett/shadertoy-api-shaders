{
    "Shader": {
        "info": {
            "date": "1716525637",
            "description": ".",
            "flags": 0,
            "hasliked": 0,
            "id": "4333WM",
            "likes": 2,
            "name": "Monte-Carlo Mistakes!",
            "published": 3,
            "tags": [
                "tutorial",
                "antialiasing",
                "antialiasing",
                "antialiasing",
                "aa",
                "montecarlo",
                "tonemapping",
                "tonemapping",
                "tonemap",
                "tonemap"
            ],
            "usePreview": 0,
            "username": "Real_NC",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "//TL;DR: Look at the edges and change the settings\n\n/*\nFixing, some mistakes were made here.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*/\n\n// Comment these out to see how it looks to do it wrong:\n#define CORRECT_TONE_MAPPING\n#define CORRECT_ENCODING\n//------------------------------------------------------\n\n\n\n#define SAMPLE_COUNT 256\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    fragColor = vec4(0);\n    \n    for(int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        vec3 thisSample = imageSample(uv + (hash2(uvec2(iFrame,i)) - 0.5)/iResolution.y) * hash2(uvec2(fragCoord.xy)+uint(i)*256u).x*2.0;\n        \n        #ifdef CORRECT_TONE_MAPPING\n        thisSample = tonemap(thisSample); // CORRECT; tone map each individual sample\n        #endif\n        \n        #ifndef CORRECT_ENCODING\n        thisSample = srgb_encode(thisSample); // INCORRECT; encoding each sample to sRGB before averaging\n        #endif\n        \n        fragColor.rgb += thisSample;\n    }\n    \n    fragColor.rgb /= float(SAMPLE_COUNT);\n    \n    \n    #ifndef CORRECT_TONE_MAPPING\n    #ifndef CORRECT_ENCODING\n    fragColor.rgb = srgb_decode(fragColor.rgb); //srgb_decode is here for fully wrong solution because tonemap must have a linear input\n    fragColor.rgb = tonemap(fragColor.rgb); // INCORRECT; tone map the cumulative result.\n    fragColor.rgb = srgb_encode(fragColor.rgb);\n    #else\n    fragColor.rgb = tonemap(fragColor.rgb); // INCORRECT; tone map the cumulative result.\n    #endif\n    #endif\n    \n    #ifdef CORRECT_ENCODING\n    fragColor.rgb = srgb_encode(fragColor.rgb); // CORRECT; encode the final result to sRGB after averaging\n    #endif\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// tonemapping curves & luminance function courtesy of https://64.github.io/tonemapping/\nfloat luminance(vec3 v)\n{\n    return dot(v, vec3(0.2126f, 0.7152f, 0.0722f));\n}\n\nvec3 change_luminance(vec3 c_in, float l_out)\n{\n    float l_in = luminance(c_in);\n    return c_in * (l_out / l_in);\n}\n\nvec3 tonemap(vec3 v) // \"aces_approx\" tone mapping function\n{\n    v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// sRGB EOTF-1 from ttg\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,lessThan(vec3(.0031308),v));\n}\n// sRGB EOTF\nvec3 srgb_decode (vec3 v) {\n    return mix(v/12.92,pow((v+.055)/1.055, vec3(2.4)),lessThan(vec3(.04045),v));\n}\n\n// pcg hash from https://www.pcg-random.org/ and https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 hash2(uvec2 v)\n{\n    uvec2 pcg = pcg2d(v);\n    return vec2(pcg)*(1.0/float(0xffffffffU));\n}\n// demo image\nvec3 imageSample( vec2 p )\n{\n    vec3 col = vec3(0);\n    \n    float dr = distance(p, vec2(0.0,    0.1));\n    float dg = distance(p, vec2(0.12,  -0.1));\n    float db = distance(p, vec2(-0.12, -0.1));\n    \n    if(dr < 0.2) col += vec3(1,0.004,0.004) * (1.0 + 1.0 / (0.001 + dr));\n    if(dg < 0.2) col += vec3(0.004,1,0.004) * (1.0 + 1.0 / (0.001 + dg));\n    if(db < 0.2) col += vec3(0.004,0.004,1) * (1.0 + 1.0 / (0.001 + db));\n    \n    return col*3.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}