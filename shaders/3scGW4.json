{
    "Shader": {
        "info": {
            "date": "1568468978",
            "description": "following Inigo Quilez livre stream on youtube",
            "flags": 0,
            "hasliked": 0,
            "id": "3scGW4",
            "likes": 2,
            "name": "Inigo Quilez tutorial",
            "published": 3,
            "tags": [
                "inigoquilez"
            ],
            "usePreview": 0,
            "username": "victorqribeiro",
            "viewed": 590
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159\n\nvec2 map(in vec3 pos ){\n      \n    float sphere = length(pos-vec3(0.,abs(sin(iTime*2.)),0.)) - 0.25;\n    \n    float result = sphere;\n    float id = 1.0;\n\n    float sphere2 = length(pos-vec3(1.,abs(sin(iTime*2.+PI/2.)),0.)) - 0.25;\n    \n    if( sphere2 < result ){\n        result = sphere2;\n    \tid = 2.0;\n    }\n    \n    float plane = pos.y - (-0.25);\n    \n    if( plane < result ){\n     \tresult = plane;\n        id = 3.0;\n    }\n   \n    return vec2(result, id);\n}\n\nvec3 calcNormal(in vec3 pos){\n    vec2 e = vec2(0.0001, 0.);\n\treturn normalize(\n    \tvec3(\n            map(pos+e.xyy).x-map(pos-e.xyy).x,\n            map(pos+e.yxy).x-map(pos-e.yxy).x,\n            map(pos+e.xyx).x-map(pos-e.xyx).x\n        )\n    );\n}\n\nvec2 castRay(in vec3 ro, vec3 rd){\n    float t = 0., id = 0.;\n    for(int i = 0; i < 100; i++){\n    \tvec3 pos = ro + t * rd;\n        \n        vec2 object_id = map( pos );\n        \n        float object = object_id.x;\n        \n        id = object_id.y;\n        \n        if( object < 0.0001 ) break;\n        \n        t += object;\n        \n        if( t > 20. ) break;\n    }\n    \n    if( t > 20.0 ) \n        t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float an = iTime/4.;\n \n    //camera pos\n    vec3 ro = vec3(2.*sin(an), 0, 2.*cos(an));\n    \n    //camera look at\n    vec3 ta = vec3(0,.25,0);\n    \n    // wuv coordinates\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    \n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5* ww );\n    \n    //sky color with gradient\n    vec3 col = vec3(0.6, 0.7, 0.8) - 0.5 * rd.y;\n    \n    //horizon\n    col = mix( col, vec3(0.7,0.75,0.8), exp(-10.0*rd.y) );\n    \n    vec2 result = castRay( ro, rd );\n    \n    float t = result.x;\n    \n    float id = result.y;\n    \n    if( t > 0. ){\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate;\n        \n        if( id < 1.5 ){\n            mate = vec3(0.18);\n        }else if( id < 2.5 ){\n            mate = vec3(.8);\n        }else{\n         \tmate = vec3(0.02,0.2,0.02);\n        }\n        \n        \n        vec3  sun_dir = normalize( vec3(0.8, 0.4, 0.2) );\n        float sun_dif = clamp( dot(nor,sun_dir), 0.0, 1.0  );\n        float sun_sha = step( castRay( pos+nor*0.001, sun_dir ).x, 0.0);\n        float sky_dif = clamp( .5 + .5 * dot(nor,vec3(0,1,0)), 0., 1. );\n        float bou_dif = clamp( .5 + .5 * dot(nor,vec3(0,-1,0)), 0., 1. );\n        \n        //sun ligth + sun shadows\n        col  = mate*vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha;\n        \n        //sky indirect light\n        col += mate*vec3(0.5, 0.8, 0.9) * sky_dif;\n            \n        //bounce light\n        col += mate*vec3(0.7, 0.3, 0.2) * bou_dif;\n    }\n    \n    //gamma correction\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}