{
    "Shader": {
        "info": {
            "date": "1690033839",
            "description": "Amalgamating cell-by-cell traversal and raymarching to render a subdivided rectangular grid.",
            "flags": 0,
            "hasliked": 0,
            "id": "DdBfzt",
            "likes": 66,
            "name": "Cell-By-Cell Raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "grid",
                "rectangle",
                "prism",
                "city",
                "block",
                "traversal",
                "sparse"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 958
        },
        "renderpass": [
            {
                "code": "/*\n\n    Cell-By-Cell Raymarching\n    ------------------------\n\n\tAmalgamating cell-by-cell traversal and raymarching to render a \n    subdivided rectangular grid. There are a few examples involving \n    similar methods on Shadertoy, so this is not new. However, it's \n    a really useful method that isn't used very often, so I figured \n    I'd attempt to post a simple example in the hopes that those not \n    familiar with the process might benefit from it.\n    \n    If you've ever tried raymarching a repeat space grid containing \n    objects comparable to the size of the grid cell boundaries, you'll \n    notice a lot of artifacts. The two main solutions involve\n    raymarching the grid neighbors, which is usually expensive and\n    doesn't always work, or to perform a cell-by-cell traversal, which\n    is great, but you lose a lot of raymarching benefits, like simple\n    CSG, soft shadows, uncomplicated ambient occlusion formulas, etc.\n    \n    The solution is to combine the two aforementioned methods in a\n    surprisingly easy to implement fashion. In addition to raymarching \n    the grid as usual, you determine the distance from the ray \n    position to the cell boundary and use that to restrict the ray \n    from advancing too far. The entire process requires the addition\n    of just a few extra lines.\n    \n    I'm not sure who first demonstrated the technique on Shadertoy, \n    but Nimitz's \"Sparse grid marching\" is a really nice early example. \n    IQ's \"Cubescape\" shader was posted over ten years ago, and that \n    utilizes similar principles, but it involves advancing the ray \n    from cell to cell, then raymarching at each step. I'm not sure \n    which method is more efficient, but I'm employing a 2D version of \n    the former. The difference between this and a regular raymarched\n    grid example is a small amount of setup and extra lines in the \n    distace, trace and shadow functions.\n    \n    This particular method can be applied to all kinds of rectangular\n    grids, and with some adjustments, I'd imagine other grid types \n    would be possible. I have a simple 3D version that I'll post at\n    some stage, and I intend to attempt some others later.\t\n    \n    \n\n\tSimilar examples:\n    \n    // Really stylish.\n    Sparse grid marching - nimitz\n    https://www.shadertoy.com/view/XlfGDs\n    \n\t// A cell be cell traversal with raymarching inside each cell.\n    // Amazing to think that this is over ten years old.\n    Cubescape  - iq\n\thttps://www.shadertoy.com/view/Msl3Rr  \n    \n    // A really clever 3D subdivided example. Traversing a\n    // variable sized 3D box grid is on my list.\n    Box Singularity - Tater\n    https://www.shadertoy.com/view/7dVGDd\n\n*/\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Scene color - Bluish purlple: 0, Tequila sunrise: 1.\n#define COLOR 1\n\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853))*43758.5453); \n}\n\n\n\n// Cube face texturing -- Hacked together quickly, but it'll work.\nvec3 texCube(sampler2D iCh, in vec3 p, in vec3 n){\n\n    \n    // Use the normal to determine the face. Z facing normals \n    // imply the XY plane, etc.\n    n = abs(n);\n    p.xy = n.x>.5? p.yz : n.y>.5? p.xz : p.xy; \n    \n    // Reusing \"p\" for the color read.\n    p = texture(iCh, p.xy).xyz;\n \n    // Rough conversion from sRGB to linear.\n    return p*p;\n\n}\n\n// Texture sample.\n//\nvec3 getTex(sampler2D iCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iCh, p/8.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(iChannel0, p), vec3(.299, .587, .114)); }\n\n\n\n// IQ's 3D signed box formula: I tried saving calculations by using the unsigned one, and\n// couldn't figure out why the edges and a few other things weren't working. It was because\n// functions that rely on signs require signed distance fields... Who would have guessed? :D\nfloat sBoxS(vec3 p, vec3 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.)) - sf;\n}\n\n// IQ's 2D signed box formula with some added rounding.\nfloat sBoxS(vec2 p, vec2 b, float sf){\n\n  p = abs(p) - b + sf;\n  return min(max(p.x, p.y), 0.) + length(max(p, 0.)) - sf;\n}\n\n\n// Subdivided rectangle grid.\nvec4 getGrid(vec2 p, inout vec2 sc){\n    \n    // Block offsets.\n    vec2 ipOffs = vec2(0);\n    // Row or column offset. Values like \"1/3\" would offset more\n    // haphazardly, but I wanted to maintain a little symmetry.\n    const float offDst = .5; \n    if(mod(floor(p.y/sc.y), 2.)<.5){\n        p.x -= sc.x*offDst; // Row offset.\n        ipOffs.x += offDst;\n    }\n    //if(mod(floor(p.x/sc.x), 2.)<.5){\n        //p.y -= sc.y*offDst; // Column offset.\n        //ipOffs.y += offDst;\n    //}\n    \n    vec2 oP = p;\n    \n    // Block ID.\n    vec2 ip;\n    \n    //#define EQUAL_SIDES\n    \n    // Subdivide.\n    for(int i = 0; i<4; i++){\n        \n        // Current block ID.\n        ip = floor(p/sc) + .5;\n        float fi = float(i)*.0617; // Unique loop number.\n        #ifdef EQUAL_SIDES        \n        // Squares.\n        \n        // Random split.\n        if(hash21(ip + .253 + fi)<.333){\n           sc /= 2.;\n           p = oP;\n           ip = floor(p/sc) + .5; \n        }\n        \n        #else\n        \n        // Powers of two rectangles.\n        \n        // Random X-split.\n        if(hash21(ip + .253 + fi)<.333){//3 && sc.x>1./8.\n           sc.x /= 2.;\n           p.x = oP.x;\n           ip.x = floor(p.x/sc.x) + .5;\n        }\n        // Random Y-split.\n        if(hash21(ip + .453 + fi)<.333){ // && sc.y>1./8.\n           sc.y /= 2.;\n           p.y = oP.y;\n           ip.y = floor(p.y/sc.y) + .5;\n        }\n        \n        #endif\n         \n    }\n    \n    // Local coordinates and cell ID.\n    return vec4(p - ip*sc, (ip + ipOffs)*sc);\n\n}\n\n// Global cell boundary distance variables.\nvec3 gDir; // Cell traversing direction.\nvec3 gRd; // Ray direction.\nfloat gCD; // Cell boundary distance.\n// Box dimension and local XY coordinates.\nvec3 gSc; \nvec2 gP;\n\n \n// An extruded subdivided rectangular block grid. Use the grid cell's \n// center pixel to obtain a height value (read in from a height map), \n// then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n \n    // Local coordinates.\n    vec2 p = q3.xy;\n\n\n    vec3 sc = vec3(1); // Scale.\n    // Local coordinates and cell ID.\n    vec4 p4 = getGrid(p, sc.xy); \n    p = p4.xy;\n    vec2 id = p4.zw;\n\n\n    // The distance from the current ray position to the cell boundary\n    // wall in the direction of the unit direction ray. This is different\n    // to the minimum wall distance, so you need to trace out instead\n    // of merely doing a box calculation. Anyway, the following are pretty \n    // standard cell by cell traversal calculations. The resultant cell\n    // distance, \"gCD\", is used by the \"trace\" and \"shadow\" functions to \n    // restrict the ray from overshooting, which in turn restricts artifacts.\n    vec3 rC = (gDir*sc - vec3(p, q3.z))/gRd;\n    //vec2 rC = (gDir.xy*sc.xy - p)/gRd.xy; // For 2D, this will work too.\n    \n    // Minimum of all distances, plus not allowing negative distances, which\n    // stops the ray from tracing backwards... I'm not entirely sure it's\n    // necessary here, but it stops artifacts from appearing with other \n    // non-rectangular grids.\n    //gCD = max(min(min(rC.x, rC.y), rC.z), 0.) + .0015;\n    gCD = max(min(rC.x, rC.y), 0.) + .001; // Adding a touch to advance to the next cell.\n\n\n    // The extruded block height. See the height map function, above.\n    float h = hm(id);\n    h = (h*.975 + .025)*2.5;\n\n\n    // Change the prism rectangle scale just a touch to create some subtle\n    // visual randomness. You could comment this out if you prefer more order.\n    sc.xy -= .05*(hash21(id)*.9 + .1);\n\n    // Lower box prism.\n    float d = sBoxS(vec3(p, q3.z + h/2.), vec3(sc.xy, h)/2., .0);\n\n    // Putting some random boxes on top.\n    if(min(sc.x, sc.y)>.125 && hash21(id + .03)<.5){ \n       float d2 = sBoxS(vec3(p, q3.z + (h*1.3)/2.), vec3(sc.xy - .16, h*1.3)/2., .0);\n       d = min(d, d2);\n    }\n\n    // Saving the box dimensions and local coordinates.\n    gSc = vec3(sc.xy, h);\n    gP = p;\n\n        \n   \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, 0);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec4 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor.\n    float fl = -p.z;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float d, t = 0.; //hash31(ro + rd)*.15\n    \n    //vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = step(0., rd) - .5;\n    gRd = rd; \n    \n    int i;\n    const int iMax = 128;\n    for (i = min(iFrame, 0); i<iMax; i++){ \n    \n        d = map(ro + rd*t);       \n        //dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        \n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, \n        // as \"t\" increases. It's a cheap trick that works in most situations.\n        if(abs(d)<.001*(1. + t*.05)|| t>FAR) break; \n        \n        //t += i<32? d*.75 : d; \n        t += min(d, gCD); \n    }\n    \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    //if(i>=iMax - 1) t = dt.y;\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more \n// symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n                     map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with \n// limited iterations is impossible... However, I'd be very grateful if someone could \n// prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    // Set the global ray direction varibles -- Used to calculate\n    // the cell boundary distance inside the \"map\" function.\n    gDir = sign(rd)*.5;\n    gRd = rd;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        \n        \n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(min(d, gCD), .02, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Shadow.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.    \n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(iTime/2., 0, -4); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.02, .18, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning.\n    vec3 lp = ro + vec3(2, 2, 0);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x ));\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Rotation.\n\trd.xy *= rot2(-.25);    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec4 svGID = gID;\n    \n    // Scene object ID. Either the pylons or the floor.\n    float svObjID = objID;\n    \n    // Saving the bloxk scale and local 2D base coordinates.\n    vec3 svSc = gSc;\n    vec2 svP = gP;\n    \n\t\n    // Initiate the scene color to black.\n    vec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n          \n        // Obtaining the texel color. \n\t    vec3 objCol; \n        \n        float svObjEdge = 1.;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n            /*\n            // Random coloring using IQ's short versatile palette formula.\n            float rnd = hash21(svGID.yz + .34);\n            vec3 tx = .5 + .48*cos(6.2831853*rnd/10. + vec3(0, 1, 2) + .8);\n            tx *= .5;\n            */\n       \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(iChannel1, svGID.yz);\n            // Grunge texturing.\n            vec3 tx2 = texCube(iChannel2, sp/4., sn);\n            // Combining.\n            objCol = tx.yzx*(tx2*2. + .2);\n            //objCol = tx.yzx*.65;//\n                      \n                \n            \n            // Last minute edge routine. I've returned the nearest rectangle ID\n            // and dimensions from the \"raycasting\" routine, and the rest \n            // figures itself out.\n            float ew = .0125*(1. + t*.1); // Edge width.\n            float h = svSc.z;\n            float rct = sBoxS(svP, svSc.xy/2., .0);\n            float top = max(abs(sp.z + h), abs(rct));\n            float side = abs(abs(svP.x) - svSc.x/2.);\n            side = max(side, abs(abs(svP.y) - svSc.y/2.));\n            float objEdge = min(top, side) - ew;\n            \n            // Same for the boxes on top.\n            if(min(svSc.x, svSc.y)>.125 && hash21(svGID.yz + .03)<.5){\n                rct = sBoxS(svP, (svSc.xy - .16)/2., .0);\n                top = max(abs(sp.z + h), abs(rct));\n                top = min(top, max(abs(sp.z + h*1.3), abs(rct)));\n                side = abs(abs(svP.x) - (svSc.x - .16)/2.);\n                side = max(side, abs(abs(svP.y) - (svSc.y - .16)/2.));\n                objEdge = min(objEdge, min(top, side) - ew);\n            }\n            \n            svObjEdge = objEdge;\n           \n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // you still need it.\n            vec3 tx = getTex(iChannel2, sp.xy);\n            objCol = vec3(.3, .15, 1)/8.*(tx*2. + 1.);\n            //objCol = vec3(0);\n        }\n      \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(1. + lDist*.125);\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff = pow(diff, 2. + 16.*objCol.x*objCol.x)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.  \n        \n        /*\n        // Cheap specular reflections. Requires loading the \"Forest\" cube map \n        // into \"iChannel3\".\n        float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 5.);\n        vec3 rf = reflect(rd, sn); // Surface reflection.\n        vec3 rTx = texture(iChannel3, rf.xzy*vec3(1, -1, -1)).xyz; rTx *= rTx;\n        objCol = objCol*.5 + objCol*speR*rTx*4.;\n        */\n        \n        float svEw = .0125*(1. + t*.1);\n        float sf = 4./iResolution.y;\n        objCol = mix(objCol, objCol*1.5, 1. - smoothstep(0.,sf, svObjEdge - svEw));\n        objCol = mix(objCol, objCol/4., 1. - smoothstep(0., sf, svObjEdge));\n        \n        \n        // Combining the above terms to procude the final color.\n        col = objCol*(diff*sh + vec3(.2, .4, 1) + vec3(1, .97, .92)*spec*freS*sh*8.);\n        \n        \n        // Shading.\n        col *= ao*atten;\n          \n\t\n\t}\n    \n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    col = mix(col, vec3(1, .5, 2), smoothstep(.25, .9, t/FAR));\n \n    #if COLOR == 1\n    // Some gradient coloring.\n    col = mix(col.zyx, col.zxy, uv.y + .5);\n    #endif\n    \n    // Greyscale.\n    //col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    \n \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}