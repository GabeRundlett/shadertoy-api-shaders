{
    "Shader": {
        "info": {
            "date": "1712428949",
            "description": "Raymarched geometry used to create an \"Angel\", an eyeball surrounded by golden rings, flying through the sky.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ft3Ds",
            "likes": 2,
            "name": "Biblically Accurate Angel",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "codeinsilence",
            "viewed": 107
        },
        "renderpass": [
            {
                "code": "#define NUM_LOOPS 500\n#define MAX_DIST 100.0\n#define MIN_STEP 0.001\n\n// Scene distance\nSurface map(vec3 p, vec2 fragCoord) {\n\n     // SPHERE(S) TO BE USED ON THE RINGS\n     vec3 q_sph = p;     \n     float spiral_rate = 10.0;\n     float spiral_width = 20.0;\n     q_sph.x += spiral_width*cos(spiral_rate*iTime);\n     q_sph.y += spiral_width*sin(spiral_rate*iTime);\n     q_sph.z -= spiral_rate*iTime;\n     q_sph = fract(q_sph/2.0) - 0.5;\n     vec3 sphere_pos = vec3(0,0,0);\n     float sphere_dist = sdSphere(q_sph - sphere_pos, 0.1);\n     Surface sphere = Surface(sphere_dist, WHITE);\n \n    // === PART I: CREATING THE EYE ===\n    // SPHERE EYEBALL\n    vec3 q = p;\n    //q = fract(q/2.0) - 0.5;\n    vec3 eyelid_pos = vec3(0,0,0);\n    float eyelid_dist = sdSphere(q - eyelid_pos, 1.0);\n    Surface eyelid = Surface(eyelid_dist, FLESH);\n\n    //SOLID ANGLE INTERSECTION TO MAKE \"WHITE\" OF THE EYE\n    vec3 eyeball_pos = eyelid_pos;\n    float eyeball_radian = PI/3.0;\n    vec3 q_1 = p;\n    vec3 q_2 = p;\n    float diff = 0.55 - 0.01 * (1.0 - (0.5 * sin(iTime) + 0.5)); // 0.45\n    q_1.yz *= rot2D(HALF_PI - diff);\n    q_2.yz *= rot2D(HALF_PI + diff);\n    q_1.xy *= rot2D(0.5 * sin(iTime));\n    q_2.xy *= rot2D(0.5 * sin(iTime));\n    float eyeball_1 = sdSolidAngle(q_1 - eyeball_pos, vec2(sin(eyeball_radian),cos(eyeball_radian)), 1.001);\n    float eyeball_2 = sdSolidAngle(q_2 - eyeball_pos, vec2(sin(eyeball_radian),cos(eyeball_radian)), 1.001);\n    \n    Surface eyeball_visible = Surface(opIntersection(eyeball_1, eyeball_2), WHITE);\n    \n    // SOLID ANGLE TO MAKE THE IRIS OF THE EYE\n    vec3 iris_pos = eyelid_pos;\n    float iris_radian = PI/8.0;\n    vec3 q_iris = p;\n    q_iris.yz *= rot2D(HALF_PI);\n    q_iris.xy *= rot2D(sin(iTime));\n    float iris_dist = sdSolidAngle(q_iris - iris_pos, vec2(sin(iris_radian),cos(iris_radian)), 1.002);\n    Surface iris = Surface(iris_dist, LIGHT_GREEN);\n    \n    // SOLID ANGLE TO MAKE THE PUPIL OF THE EYE\n    vec3 pupil_pos = eyelid_pos;\n    float pupil_radian = PI/16.0;\n    vec3 q_pupil = p;\n    q_pupil.yz *= rot2D(HALF_PI);\n    q_pupil.xy *= rot2D(sin(iTime));\n    float pupil_dist = sdSolidAngle(q_pupil - pupil_pos, vec2(sin(pupil_radian),cos(pupil_radian)), 1.003);\n    Surface pupil = Surface(pupil_dist, BLACK);\n    \n    // Output color of the mapping\n    Surface eye_surface = minWC(pupil, minWC(iris, minWC(eyeball_visible, eyelid)));\n    \n    // === PART II: CREATING THE RINGS ===\n    #define RING_SPEED 0.15\n    //INNER TORUS\n    vec3 torus_pos = vec3(0,0,0);//vec3(0,time_scale*cos(time_speed*(iTime)),6);\n    vec3 q_tor = p;\n    q_tor.yz *= rot2D(2.0 * PI * (RING_SPEED * iTime));\n    //q_tor.xy *= rot2D((cos(0.05*iTime)+iTime) + PI);\n    //q_tor += fract(p/2.0) - 0.5;\n    float torus_dist = sdTorus(q_tor - torus_pos, vec2(2.25,0.075));\n    Surface tor_in = Surface(torus_dist, GOLD);\n    //INNER TORUS 2\n    q_tor.yz *= rot2D(PI/2.0);\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.25,0.075));\n    Surface tor_in_2 = Surface(torus_dist, GOLD);\n    \n    //OUTER TORUS\n    q_tor = p;\n    q_tor.yz *= rot2D(2.0 * PI * 0.25);\n    q_tor.xy *= rot2D(2.0 * PI * (RING_SPEED*iTime));\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.75,0.075));\n    Surface tor_out = Surface(torus_dist, GOLD);\n    //OUTER TORUS 2\n    q_tor.xy *= rot2D(PI/2.0);\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.75,0.075));\n    Surface tor_out_2 = Surface(torus_dist, GOLD);\n    // smoothed together\n    Surface inner_smooth = Surface(smin(tor_in.sd, tor_in_2.sd, 0.5), GOLD);\n    Surface outer_smooth = Surface(smin(tor_out.sd, tor_out_2.sd, 0.5), GOLD);\n    \n    Surface ring_surface = minWC(outer_smooth, inner_smooth);\n\n    float ringball_dist = smin(ring_surface.sd,sphere.sd,1.0);\n    Surface ringball = Surface( opSmoothSubtraction(sphere.sd,ringball_dist,0.2),YELLOW);\n    \n    // === PART III: CREATING THE WALL ===\n    #define UV_C vec2(0.5,0.5)\n    #define WALL_SPEED 2.0\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 ichan_col = texture(iChannel0, uv);\n    vec2 sites[3] = vec2[3](\n                    UV_C + 0.5*vec2(cos(WALL_SPEED*iTime),sin(WALL_SPEED*iTime)),\n                    UV_C + 0.5*vec2(cos(WALL_SPEED * (iTime + (2.0*PI/3.0)) ),sin( WALL_SPEED *(iTime + (2.0*PI/3.0) ))),\n                    UV_C + 0.5*vec2(cos(WALL_SPEED * (iTime + (4.0*PI/3.0)) ),sin(WALL_SPEED * (iTime + (4.0*PI/3.0) )))\n                    );\n    \n    vec3 wall_col = LIGHT_BLUE;//vec3(0,0,0);\n    \n    float noise = ichan_col.r * 0.024;\n    \n    float dist_site = smin(distance(min(uv + noise,uv), sites[0]), smin(\n                        distance(min(uv + noise,uv), sites[2]),\n                        distance(min(uv + noise,uv), sites[1]), 1.0 + 0.5 * cos(iTime*3.0)\n                        ),1.0 + 0.5 * sin(iTime*3.0));\n    \n    wall_col += 3.5*dist_site*dist_site;\n    \n    //if(uv.x > 0.5){wall_col = vec3(0,1,0);}\n    \n    vec3 wall_pos = vec3(0,0,0);\n    Surface wall = Surface(\n                    sdPlane( p - wall_pos, vec3(0,0,-1), 5.0),\n                    wall_col);\n    \n    return minWC(wall, minWC(ringball,eye_surface));\n}\n\nvec3 calcNormal( in vec3 pos, in vec2 fragCoord){\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    float xyy = map( pos + e.xyy*eps , fragCoord).sd;\n    float yyx = map( pos + e.yyx*eps , fragCoord).sd;\n    float yxy = map( pos + e.yxy*eps , fragCoord).sd;\n    float xxx = map( pos + e.xxx*eps , fragCoord).sd;\n    return normalize( e.xyy * xyy + \n\t\t\t\t\t  e.yyx*yyx + \n\t\t\t\t\t  e.yxy* yxy+ \n\t\t\t\t\t  e.xxx*yxy );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(cos(iTime), sin(iTime), -5.0 + 0.5*cos(iTime + PI));         // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    float t = 0.; // total distance travelled\n    \n    vec3 map_color = vec3(1,1,1);\n    float diffuse = 0.0;\n    // Raymarching\n    for (int i = 0; i < NUM_LOOPS; i++) {\n        vec3 p = ro + rd * t;     // position along the ray\n        vec3 norm = calcNormal(p, fragCoord);\n        //p.xz *= rot2D((2.0 * PI * -(iMouse.xy/iResolution.xy).x)+PI); // rotate with mouse\n        vec3 light_dir = normalize(vec3(-1,1,0));\n        diffuse = clamp( dot(norm,light_dir), 0.0, 1.0 );\n        Surface map_surface = map(p, fragCoord);\n\n        map_color = map_surface.col;\n        float d = map_surface.sd;       // current distance to the scene\n\n        t += d;                   // \"march\" the ray\n\n        if (d < MIN_STEP) break;      // early stop if close enough\n        if (t > MAX_DIST) break;      // early stop if too far\n    }\n    \n    // Coloring\n    col = map_color - vec3(t * .01);           // color based on distance\n    col += vec3(0.7) * diffuse;\n    //col += ;\n    fragColor = vec4(col, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// LIBRARY OF METHODS TO GENERATE GEOMETRY\n// Signed distance functions and their operations taken from Inigo Quilez's work\n// https://iquilezles.org/articles/distfunctions/\n// Additional functions provided by kishimisu - An introduction to Raymarching\n// https://www.youtube.com/watch?v=khblXafu7iA\n#define PI      3.141592653589793\n#define HALF_PI 1.5707964\n\n// COLORS\n#define RED vec3(1,0,0)\n#define LIGHT_GREEN vec3(0.471, 0.851, 0.514)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define LIGHT_BLUE vec3(0.5,0.5,1)\n#define FLESH vec3(1,0.796,0.643)\n#define GOLD vec3(0.831, 0.686, 0.217)\n#define YELLOW vec3(1, 0.89, 0.141)\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n\n// === SURFACE STUFF ===\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface minWC(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\n// === SIGNED DISTANCE FUNCTIONS (SDF) ===\n\n// Sphere SDF\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n// Torus SDF\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// Plane SDF\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n// Solid Angle\n// c = vec2(sin(theta),cos(theta))\nfloat sdSolidAngle(vec3 p, vec2 c, float ra){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float l = length(q) - ra;\n\tfloat m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n// Revolved Vesica SDF\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w ){\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\n// +++ GEOMETRIC OPERATIONS +++\n\n// UNION\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n// SUBTRACTION\nfloat opSubtraction( float d1, float d2 ){\n    return max(-d1,d2);\n}\n// INTERSECTION\nfloat opIntersection( float d1, float d2 ){\n    return max(d1,d2);\n}\n// EXCLUSIVE OR\nfloat opXor(float d1, float d2 ){\n    return max(min(d1,d2),-max(d1,d2));\n}\n\n// SMOOTH UNION\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n// SMOOTH SUBTRACTION\nfloat opSmoothSubtraction( float d1, float d2, float k ){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n// SMOOTH INTERSECTION\nfloat opSmoothIntersection( float d1, float d2, float k ){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n// ONION\nfloat opOnion( in float sdf, in float thickness ){\n    return abs(sdf)-thickness;\n}\n// ==== ROTATIONS ====\n\n// Rodrigues' rotation formula\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n// 2D rotation\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\n// === OTHER METHODS ===\n\n// Smooth minimum function\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b),0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}