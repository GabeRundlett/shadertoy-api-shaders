{
    "Shader": {
        "info": {
            "date": "1672667713",
            "description": "Constructing and rendering an extruded packed geometric heart pattern in realtime.",
            "flags": 0,
            "hasliked": 0,
            "id": "ddSXR1",
            "likes": 63,
            "name": "Extruded Neon Hearts",
            "published": 3,
            "tags": [
                "raymarching",
                "heart",
                "neon",
                "extrude",
                "semiregular",
                "floret"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 749
        },
        "renderpass": [
            {
                "code": "/*\n\n    Extruded Neon Hearts\n    --------------------\n    \n    This is an extruded version of a reasonably popular geometric heart pattern that has\n    been constructed and rendered in realtime. It's a simple variation on a common pentagon \n    floret arrangement, which is technically known for being the dual of a 3,3,3,3,6 snub \n    trihexagonal semi-regular tessellation of the grid... It's a fancy sounding description, \n    but the imagery is pretty basic, if you're not sure and feel like looking it up. :)\n    \n    Extruded square grids are a modern computer image cliche. You'll see them everywhere,\n    especially in stock imagery. Hexagon grids are less common, and triangle grids are \n    less common still, but there are still plenty around. There are a lot of varations as \n    well, like subdivided grids, offset grids to a lesser degree and so forth.\n    \n    After looking around the internet, I noticed that people don't stray much from these \n    base extrusion patterns. Semi-regular grid patterns and their duals are reasonably \n    common in the 2D realm, but you rarely see extruded versions, if at all, so a while \n    back I decided to make some. Obviously, more complicated patterns require more\n    calculation, and that can be exacerbated in a realtime pixelshader environment, but \n    I've seen people on here code harder stuff, so I'm surprised that there are no examples\n    on here at all.\n    \n    There are a number of ways to construct these patterns, and I'm not sure what would\n    be the most efficient, but I've tried my best. The objective for the time being was to \n    get a few extruded semi-regular patterns on the board with the hope that better methods \n    for their construction will be devised later.\n    \n    By the way, there a couple of defines to change the pattern shape and glow color, for\n    anyone interested.\n\n\n    \n    Related examples:\n    \n    // I like this example, since it's a simple 2D semi-regular tiling \n    // visual reference. The floret pattern is contained in it somewhere.\n    Wythoff Uniform Tilings + Duals - Fizzer \n    https://www.shadertoy.com/view/3tyXWw\n    \n    // A Wythoff\\Kaspar-Klug based approach to semi-regular patterns, etc. It's\n    // a nice looking shader. Remaindeer has a really cool extruded boundary \n    // version on here too, if you feel like looking that up. Although, that\n    // shouldn't be confused with the kind of extrusion I'm performing here, which\n    // requires neighboring cell considerations.\n    caspar-klug sdf - remaindeer\n    https://www.shadertoy.com/view/cdsSDS\n    \n    // The following is mildly related believe it or not.\n    Extruded Hexagon Fractal Curve - Shane\n    https://www.shadertoy.com/view/cdjGWy\n    \n*/\n\n\n// Glow color - Red: 0, Blue: 1, Green: 2\n#define COLOR 1\n\n// Extruded shape. Just the two. The floret is a little slow at the moment,\n// but I'll put some effort in later to make it faster.\n//\n// Heart: 0, Floret 1.\n#define SHAPE 0\n\n\n\n#define ZERO min(iFrame, 0)\n\n// Global tile scale.\nconst float scale = 1./2.;\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Scene object ID.\nfloat objID;\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\nvec3 getCol(sampler2D s2D, vec2 p){\n \n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(s2D, p*scale/16.*s).xyz; \n    return tx*tx;\n\n    //float rnd = hash21(p);\n    //return .5 + .45*cos(6.2831*rnd + vec3(0, 1, 2)*1.5);\n}\n\nfloat ht;\nfloat getHeight(vec2 p){\n\n    vec3 col = getCol(iChannel0, p);\n    if(fract(dot(col, vec3(1))*143.5273)<.2) return -1.;\n    float h = dot(col, vec3(.299, .587, .114));\n    ht = smoothstep(.9, .94, sin(6.2831*h*4. + iTime));\n    return h*.25*(1. + ht) + .025; \n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n\n\n\nvec4 gVal; // Global container for 2D distance, etc.\nvec3 glow, lCol; // Global glow and glow color variables.\n\n\n// The extruded image.\nfloat map(vec3 p){\n\n    \n    \n    // Floor.\n    float fl = abs(p.z - .5) - .5;\n\n    \n    float gridScale = scale;\n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p.xy/gridScale);\n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy, .5, 0.);\n    \n \n    \n    const vec2 sDiv12 = s/12.;\n    \n    \n    const float ew = .0; // Edge width.\n    const float ang = atan(sqrt(3.)/5.); // Rotation angle.\n    const float invR = 1./sqrt(7.); // Scaling factor.\n    vec2 q = p4.xy;\n    \n    // Rotate the coordinates in the hexagon grid.\n    q = rot2(ang)*q;\n    float hR = 1.5*invR;\n    float ctrHx = getHex(q, hR, 0.);\n    \n    \n    // Triangle radius.\n    float tR = hR/.8660254;\n    float ctrTri = getTri(rot2(3.14159/6.)*q, tR);\n    ctrTri = min(ctrTri, getTri(rot2(-3.14159/6.)*q, tR));\n    ctrTri = max(ctrTri, ctrHx);\n    \n    // Edge construction lines and shape distance holder.\n    float[6] flLn, flLn2, d6;\n    \n    \n    // Iterate through all six sides of the hexagon cell and create\n    // some edge construction lines.\n    for(int i = 0; i<6; i++){\n       vec2 vi = vID[i]*sDiv12;\n       // Short for the following:\n       //flLn[i] = distLineS(q, vec2(0), vi);\n       flLn[i] = dot(q, vec2(-vi.y, vi.x)*sqrt(3.));\n    }\n    \n    #if SHAPE == 0\n    int j = int(mod(floor(hash21(p4.zw)*36.), 2.));\n    #endif\n    \n \n    vec2[6] cID6;\n    #if SHAPE == 0\n    for(int i = ZERO; i<6; i+=2){\n    #else\n    for(int i = ZERO; i<6; i++){\n    #endif\n    \n        \n        #if SHAPE == 0\n        int ip0 = (i + j)%6;\n        int ip1 = (i + 2 + j)%6;\n        #else\n        int ip0 = i;\n        int ip1 = (i + 1)%6;\n        #endif\n        \n        // The 2D field for this particular shape.\n        d6[i] = (max(ctrTri, max(flLn[ip0], -flLn[ip1])) + ew)*gridScale;\n        // The ID.\n        cID6[i] = p4.zw + eID[i]*invR*2.;\n         \n    }\n    \n    /*\n    // It'd be nice to use polar partitioning to cut down on GPU costs, but,\n    // unfortunately, there are overlap issues. I might try again later.\n    float naB;\n    vec2 qB = rot2(-3.14159/6.)*q;\n    qB = polRot(qB, naB, 6.);\n    int indB = int(mod(8. - naB, 6.));\n    float hi = getHeight(cID6[indB]);\n    */\n    \n    float svHt = -1e5;\n\n    float df = 1e5;\n    #if SHAPE == 0\n    for(int i = ZERO; i<6; i+=2){\n    #else\n    for(int i = ZERO; i<6; i++){\n    #endif        \n \n        // Extruding the 2D field.\n        float hi = getHeight(cID6[i]);//dot(dCol, vec3(.299, .587, .114))*.2;//.2;\n        float di = opExtrusion(d6[i], p.z + hi/2., hi/2.);\n        // Extra face height to reflect light a bit better.\n        di += d6[i]*.125;\n        // Face rippling.\n        //di += (smoothstep(0., .5, sin(d6[i]*124. - 1.57/2.*0.)*.5 + .5) - .5)*.005;\n        \n        // Minimum distance.\n        if(di<df){\n        \n            df = di;\n            gVal = vec4(d6[i], hi, cID6[i]);\n            svHt = ht;\n        }\n    }\n    \n    /////\n        \n    // Some of the neighboring florets (or heart tips) encroach into this cell, so we \n    // need to construct those too. We only need the tips of the objects, which are\n    // hexagonal in shape, so those will do.\n    float na;\n    q = polRot(q, na, 6.);\n    q.x -= tR;\n    q *= rot2(3.14159/6.);\n    float smHx = getHex(q, invR/2. - ew, 0.); // Triangle.\n    smHx *= gridScale;\n    \n    int ind = int(mod(8. - na, 6.));\n    \n    \n    // Add the neighbors.\n    #if SHAPE == 0\n    // Check to see whether the neighbor has been rotated, and if so\n    // offset the index to match.\n    int jn = int(mod(floor(hash21(p4.zw + eID[ind]*2.)*36.), 2.));\n    int ind2 = int(mod(7. - floor((na + float(jn))/2.)*2., 6.));\n    vec2 smHxID = p4.zw + eID[(ind)%6]*2. - eID[(ind2)%6]*invR*2.;\n    #else\n    vec2 smHxID = p4.zw + eID[ind]*(1. - invR)*2.; // See above.\n    #endif\n    \n    float hgt = getHeight(smHxID);\n    float dB = opExtrusion(smHx, p.z + hgt/2., hgt/2.);\n    dB += smHx*.125;\n    //dB += (smoothstep(0., .5, sin(smHx*80. - 1.57/2.*0.)*.5 + .5) - .5)*.003;\n         \n    // Update.\n    if(dB<df){\n        df = dB;\n        gVal = vec4(smHx, hgt, smHxID);\n        svHt = ht;\n    }\n    \n    \n    // Overall object ID.\n    objID = fl<df? 1. : 0.;\n \n    // Glow color beam calculations.\n    lCol = vec3(0);\n    if(df<.25 && objID<.5){\n       vec3 gCol = mix(vec3(1, .1, .3), vec3(1., .3, .1), hash21(gVal.zw + .12));\n       lCol = svHt*gCol*smoothstep(0., .5, -(gVal.x));\n    }\n   \n    \n    \n    // Combining the floor with the extruded object.\n    return  min(fl, df);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319) + rd)*.1, d;\n    \n    glow = vec3(0);\n    \n    for(int i = ZERO; i<96; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += d*.7;//d<.5? d*.5 : d*.9; \n        \n        // Accumulate the glow color.\n        glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.7, .1); \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.004, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d, .005, .1); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    \n\t// Camera Setup.\n    vec3 ro = vec3(cos(iTime/4.)*.15, sin(iTime/4.)*.15 + iTime/8., -1.5); // Camera position.\n\tvec3 lk = vec3(0, iTime/8. + .6, 0);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = lk + vec3(-.5, 1.5, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro); // Forward.\n    //if(dot(fwd, vec3(fwd.z, 0, -fwd.x))==0.) fwd = normalize(fwd - vec3(0, 0, .00001));\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd));// Right. \n    // \"right\" and \"forward\" are perpendicular normals, so the result is normalized.\n    vec3 up = cross(fwd, rgt); // Up.\n    \n    // Camera.\n    //mat3 mCam = mat3(rgt, up, fwd);\n    // rd - Ray direction.\n    //vec3 rd = mCam*normalize(vec3(uv, 1./FOV));//\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the object ID.\n    float svObjID = objID;\n    \n    vec4 svVal = gVal;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        //sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol = vec3(.6); \n        \n        vec3 txP = sp;\n        float sf = 1.5/iResolution.y;\n        float ew = .005;\n\n        // The extruded grid.\n        if(svObjID<.5){\n            \n             // Light edge.\n            float d = svVal.x; // 2D face distance.\n            float h = svVal.y; // Object height.\n            float dz = txP.z + h; // Heigh cutoff.\n            \n            // Face color.\n            vec3 fCol = getCol(iChannel0, svVal.zw/1.);\n            fCol = vec3(1.35)*(dot(fCol, vec3(.299, .587, .114)) + .25);\n      \n          \n            // Tri-planar texture lookup.\n            vec3 tx = tex3D(iChannel1, sp - vec3(0, 0, -h), sn);\n           \n           \n            // Matches the glow color in the distance function.\n            vec3 hCol = mix(vec3(1, .1, .3), vec3(1., .3, .1), hash21(svVal.zw + .12));\n            // Blending the glow portion from timber to metallic when it's glowing.\n            vec3 tx2 = mix(tx*vec3(.8, 1, 1.2)*(hCol*.5 + 1.25), tx, min(glow.x*2., 1.));\n            \n            // Rendering face colors and borders.\n            vec3 sideCol = vec3(.35);\n            texCol = mix(sideCol, vec3(0), 1. - smoothstep(0., sf, dz - ew));\n            texCol = mix(texCol, sideCol, 1. - smoothstep(0., sf, d + ew));//*vec3(1.4, 1, .5)\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, d + .04));\n            texCol = mix(texCol*(tx*2. + .05), fCol*(tx2*2. + .05), 1. - smoothstep(0., sf, d + .04 + ew*2.));\n            \n             // Ramp up the diffuse value for a more metallic look.\n            //diff = pow(diff, 4.)*2.;\n           \n \n        }\n        else {\n            \n            // The floor.\n            \n            // Background.\n            texCol = vec3(.7);\n            \n             // Tri-planar texture lookup.\n            vec3 tx = tex3D(iChannel1, sp, sn);\n           \n            // Combine for the final surface color.\n            texCol *= tx + .05;//*vec3(1.2, 1, .8);\n            \n            //texCol *= vec3(1.2, 1, .8);\n            \n            // Ground rim.\n            float d = abs(svVal.x) - ew*1.5;\n            if(svVal.y>0.) texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, d)); \n          \n        }\n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel2, ref).xyz; refTx *= refTx;\n        refTx = (texCol*1.5 + .66)*refTx;//smoothstep(.2, .5, refTx);\n        float spRef = pow(max(dot(hv, sn), 0.), 8.); // Specular reflection.\n        float rf = (svObjID == 1.)? .25 : 1.;//mix(.5, 1., 1. - smoothstep(0., .01, d + .08));\n        texCol += spRef*refTx*rf*1.; //smoothstep(.03, 1., spRef) \n\n        //texCol = texCol + vec3(4, .5, 1)*texCol*glow*4.;\n       \n        \n        // Combining the above terms to produce the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .97, .92)*spec*freS*2.*sh);\n        \n        // Apply the glow color.\n        #if COLOR == 0\n        col = col/2. + col*glow*36.;\n        #elif COLOR == 1\n        col *= vec3(1.1, 1, .9);   \n        col = col/2. + col*glow.zyx/vec3(1.1, 1, .9)*40.;\n        #else\n        col *= vec3(1.2, 1, .8);   \n        col = col/2. + col*glow.yxz/vec3(1.2, 1, .8)*32.;\n        #endif\n        \n        // Shading.\n        col *= ao*atten;\n        \n        // It's sometimes helpful to check things like shadows and AO by themselves.\n        //col = vec3(ao);\n          \n\t\n\t}\n    \n    // Horizon fog. Not visible here, but provided for completeness.\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n          \n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n\nfloat hash21(vec2 p){ \n    \n    return fract(sin(dot(p, vec2(27.617, 57.643)))*43758.5453); \n    \n    /*\n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx + 43.123);\n    return fract((p3.x + p3.y)*p3.z);\n    */\n    \n    /*\n    // IQ's vec2 to float hash.\n    // An accuracy hack for this particular example. Unfortunately, \n    // \"1. - 1./3.\" is not always the same as \"2./3.\" on a GPU.\n    p = floor(p*32768.)/32768.;\n    return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); \n    */\n}\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n// Multiplying them by \"s\" gives the actual vertex postion.\n#ifdef FLAT_TOP\n// Vertices: Clockwise from the left.\n                     \n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-4, 0), vec2(-2, 6), vec2(2, 6), \n                      vec2(4, 0), vec2(2, -6), vec2(-2, -6)); \n\nconst vec2[6] eID = vec2[6](vec2(-3, 3), vec2(0, 6), vec2(3), \n                      vec2(3, -3), vec2(0, -6), vec2(-3));\n\n#else\n// Vertices: Clockwise from the bottom left. -- Basically, the ones \n// above rotated anticlockwise. :)\n\n// Multiplied by 12 to give integer entries only.\nconst vec2[6] vID = vec2[6](vec2(-6, -2), vec2(-6, 2), vec2(0, 4), \n                      vec2(6, 2), vec2(6, -2), vec2(0, -4));\n\nconst vec2[6] eID = vec2[6](vec2(-6, 0), vec2(-3, 3), vec2(3, 3), vec2(6, 0), \n                      vec2(3, -3), vec2(-3, -3));\n\n#endif\n/*\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n*/\n\n// Signed distance to a regular hexagon, with a hacky smoothing variable thrown\n// in. -- It's based off of IQ's more exact pentagon method.\nfloat getHex(in vec2 p, float r, in float sf){\n   \n      #ifdef FLAT_TOP\n      // Flat top.\n      const vec3 k = vec3(-.8660254, .5, .57735); // pi/6: cos, sin, tan.\n      #else\n      // Pointed top.\n      const vec3 k = vec3(.5, -.8660254, .57735); // pi/6: cos, sin, tan.\n      #endif\n     \n      // X and Y reflection.  \n      p = abs(p); \n      p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n\n      r -= sf;\n      // Polygon side.\n      #ifdef FLAT_TOP\n      // Flat top.\n      return length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - sf;\n      #else\n      // Pointed top.\n      return length(p - vec2(r, clamp(p.y, -k.z*r, k.z*r)))*sign(p.x - r) - sf;\n      #endif\n    \n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    // The ID is multiplied by 12 to account for the inflated neighbor IDs above.\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy*12.) : vec4(q.zw, ip.zw*12. + 6.);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\n\n\n// Standard polar partitioning.\nvec2 polRot(vec2 p, inout float na, float aN){\n\n    float a = atan(p.y, p.x);\n    na = mod(floor(a/6.2831*aN), aN);\n    float ia = (na + .5)/aN;\n    p *= rot2(-ia*6.2831);\n\n    return p;\n}\n ",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}