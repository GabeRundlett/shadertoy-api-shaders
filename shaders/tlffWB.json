{
    "Shader": {
        "info": {
            "date": "1597608927",
            "description": "A quick doodle inspired by BigWings' torus knot tutorial",
            "flags": 0,
            "hasliked": 0,
            "id": "tlffWB",
            "likes": 6,
            "name": "Razor Blossom",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "torus"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 314
        },
        "renderpass": [
            {
                "code": "// Razor Blossom by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat hash12(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(3.5341, 2.9413))) * 4321.123);\n}\n\nvec2 hash21(float v)\n{\n    vec2 p = vec2(v * 12.3 + 2., v + 11.31);\n\treturn fract(sin(p + dot(p, vec2(2.5341, 1.9413))) * 41321.123);\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene(vec3 p)\n{\n    p.y *= 2.;\n    vec2 h2 = hash21(floor(p.y - .5));\n    p.xz += h2 * 3.;\n    float s = fract(dot(floor(p.xz - .5), vec2(1)) * .5) * 4. - 1.;\n    float h = hash12(floor(p.xz) + h2.x);\n    p.y -= .5;\n    p = abs(fract(p) * 2. - 1.);\n    float a = atan(p.x, p.z) * s;\n    float x = length(p) - .75;\n    vec2 cp = vec2(x, p.y);\n    cp *= rot(a * 2. + iTime * (6. + h * 7.));\n    cp.y = abs(abs(cp.y) - .0625) - .025;\n    \n\treturn (max(abs(cp.x), abs(cp.y)) - .025) * .3;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat d = scene(p);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        scene(p - e.xyy),\n        scene(p - e.yxy),\n        scene(p - e.yyx)));\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 v = vec3(.2, 0., .1) * iTime;\n    vec3 ro = vec3(0, .25, -2) + v;\n    vec3 tgt = vec3(-1) + v;\n    vec3 rd = ray(ro, tgt, uv, .7);\n    vec3 p;\n    float t = 0.;\n    \n    for(int i = 0; i < 200; i++)\n    {\n    \tp = ro + rd * t;\n        float d = scene(p) * (1. + rd.y * .5);\n        t += d;\n        if (abs(d) < .0001 || t > 10.) break;\n    }\n    \n    vec3 n = normal(p);\n    vec3 lDir = normalize(ro - p);\n    float l = dot(n, lDir) * .5 + .5;\n    l *= sat(2. - length(ro - p) * .4);\n    l *= sat(scene(p + n * .01) * 200.) * .5 + .5;\n    \n    vec3 col = mix(vec3(.05,.05,.3), vec3(.9, .4, .8), l);\n    col += l * l * l;\n    col *= sat(2. - t * .3);\n\n    col *= vec3(1., .97, .92);\n    \n    col = pow(col, vec3(1./2.2));\n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}