{
    "Shader": {
        "info": {
            "date": "1443367533",
            "description": "test of realistically modeling the atmosphere.\n\nuse mouse to switch perspective",
            "flags": 0,
            "hasliked": 0,
            "id": "XtBXDz",
            "likes": 210,
            "name": "Atmosphere system test",
            "published": 3,
            "tags": [
                "sky",
                "volumetric",
                "scattering",
                "atmosphere",
                "rayleigh",
                "mie"
            ],
            "usePreview": 0,
            "username": "valentingalea",
            "viewed": 19719
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------------------------------------\n// Rayleigh and Mie scattering atmosphere system\n//\n// implementation of the techniques described here:\n// http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n// ----------------------------------------------------------------------------\n\n#ifdef GL_ES\n#define _in(T) const in T\n#define _inout(T) inout T\n#define _out(T) out T\n#define _begin(type) type (\n#define _end )\n#define mul(a, b) (a) * (b)\n#endif\n\n#define PI 3.14159265359\n\n// Shadertoy specific uniforms\n#define u_res iResolution\n#define u_time iTime\n#define u_mouse iMouse\n\nstruct ray_t {\n\tvec3 origin;\n\tvec3 direction;\n};\n#define BIAS 1e-4 // small offset to avoid self-intersections\n\nstruct sphere_t {\n\tvec3 origin;\n\tfloat radius;\n\tint material;\n};\n\nstruct plane_t {\n\tvec3 direction;\n\tfloat distance;\n\tint material;\n};\n\nmat3 rotate_around_x(_in(float) angle_degrees)\n{\n\tfloat angle = radians(angle_degrees);\n\tfloat _sin = sin(angle);\n\tfloat _cos = cos(angle);\n\treturn mat3(1, 0, 0, 0, _cos, -_sin, 0, _sin, _cos);\n}\n\n\nray_t get_primary_ray(\n\t_in(vec3) cam_local_point,\n\t_inout(vec3) cam_origin,\n\t_inout(vec3) cam_look_at\n){\n\tvec3 fwd = normalize(cam_look_at - cam_origin);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 right = cross(up, fwd);\n\tup = cross(fwd, right);\n\n\tray_t r = _begin(ray_t)\n\t\tcam_origin,\n\t\tnormalize(fwd + up * cam_local_point.y + right * cam_local_point.x)\n\t\t_end;\n\treturn r;\n}\n\nbool isect_sphere(_in(ray_t) ray, _in(sphere_t) sphere, _inout(float) t0, _inout(float) t1)\n{\n\tvec3 rc = sphere.origin - ray.origin;\n\tfloat radius2 = sphere.radius * sphere.radius;\n\tfloat tca = dot(rc, ray.direction);\n\tfloat d2 = dot(rc, rc) - tca * tca;\n\tif (d2 > radius2) return false;\n\tfloat thc = sqrt(radius2 - d2);\n\tt0 = tca - thc;\n\tt1 = tca + thc;\n\n\treturn true;\n}\n\n// scattering coefficients at sea level (m)\nconst vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6); // Rayleigh \nconst vec3 betaM = vec3(21e-6); // Mie\n\n// scale height (m)\n// thickness of the atmosphere if its density were uniform\nconst float hR = 7994.0; // Rayleigh\nconst float hM = 1200.0; // Mie\n\nfloat rayleigh_phase_func(float mu)\n{\n\treturn\n\t\t\t3. * (1. + mu*mu)\n\t/ //------------------------\n\t\t\t\t(16. * PI);\n}\n\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nconst float g = 0.76;\nfloat henyey_greenstein_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t\t(1. - g*g)\n\t/ //---------------------------------------------\n\t\t((4. * PI) * pow(1. + g*g - 2.*g*mu, 1.5));\n}\n\n// Schlick Phase Function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nconst float k = 1.55*g - 0.55 * (g*g*g);\nfloat schlick_phase_func(float mu)\n{\n\treturn\n\t\t\t\t\t(1. - k*k)\n\t/ //-------------------------------------------\n\t\t(4. * PI * (1. + k*mu) * (1. + k*mu));\n}\n\nconst float earth_radius = 6360e3; // (m)\nconst float atmosphere_radius = 6420e3; // (m)\n\nvec3 sun_dir = vec3(0, 1, 0);\nconst float sun_power = 20.0;\n\nconst sphere_t atmosphere = _begin(sphere_t)\n\tvec3(0, 0, 0), atmosphere_radius, 0\n_end;\n\nconst int num_samples = 16;\nconst int num_samples_light = 8;\n\nbool get_sun_light(\n\t_in(ray_t) ray,\n\t_inout(float) optical_depthR,\n\t_inout(float) optical_depthM\n){\n\tfloat t0, t1;\n\tisect_sphere(ray, atmosphere, t0, t1);\n\n\tfloat march_pos = 0.;\n\tfloat march_step = t1 / float(num_samples_light);\n\n\tfor (int i = 0; i < num_samples_light; i++) {\n\t\tvec3 s =\n\t\t\tray.origin +\n\t\t\tray.direction * (march_pos + 0.5 * march_step);\n\t\tfloat height = length(s) - earth_radius;\n\t\tif (height < 0.)\n\t\t\treturn false;\n\n\t\toptical_depthR += exp(-height / hR) * march_step;\n\t\toptical_depthM += exp(-height / hM) * march_step;\n\n\t\tmarch_pos += march_step;\n\t}\n\n\treturn true;\n}\n\nvec3 get_incident_light(_in(ray_t) ray)\n{\n\t// \"pierce\" the atmosphere with the viewing ray\n\tfloat t0, t1;\n\tif (!isect_sphere(\n\t\tray, atmosphere, t0, t1)) {\n\t\treturn vec3(0);\n\t}\n\n\tfloat march_step = t1 / float(num_samples);\n\n\t// cosine of angle between view and light directions\n\tfloat mu = dot(ray.direction, sun_dir);\n\n\t// Rayleigh and Mie phase functions\n\t// A black box indicating how light is interacting with the material\n\t// Similar to BRDF except\n\t// * it usually considers a single angle\n\t//   (the phase angle between 2 directions)\n\t// * integrates to 1 over the entire sphere of directions\n\tfloat phaseR = rayleigh_phase_func(mu);\n\tfloat phaseM =\n#if 1\n\t\thenyey_greenstein_phase_func(mu);\n#else\n\t\tschlick_phase_func(mu);\n#endif\n\n\t// optical depth (or \"average density\")\n\t// represents the accumulated extinction coefficients\n\t// along the path, multiplied by the length of that path\n\tfloat optical_depthR = 0.;\n\tfloat optical_depthM = 0.;\n\n\tvec3 sumR = vec3(0);\n\tvec3 sumM = vec3(0);\n\tfloat march_pos = 0.;\n\n\tfor (int i = 0; i < num_samples; i++) {\n\t\tvec3 s =\n\t\t\tray.origin +\n\t\t\tray.direction * (march_pos + 0.5 * march_step);\n\t\tfloat height = length(s) - earth_radius;\n\n\t\t// integrate the height scale\n\t\tfloat hr = exp(-height / hR) * march_step;\n\t\tfloat hm = exp(-height / hM) * march_step;\n\t\toptical_depthR += hr;\n\t\toptical_depthM += hm;\n\n\t\t// gather the sunlight\n\t\tray_t light_ray = _begin(ray_t)\n\t\t\ts,\n\t\t\tsun_dir\n\t\t_end;\n\t\tfloat optical_depth_lightR = 0.;\n\t\tfloat optical_depth_lightM = 0.;\n\t\tbool overground = get_sun_light(\n\t\t\tlight_ray,\n\t\t\toptical_depth_lightR,\n\t\t\toptical_depth_lightM);\n\n\t\tif (overground) {\n\t\t\tvec3 tau =\n\t\t\t\tbetaR * (optical_depthR + optical_depth_lightR) +\n\t\t\t\tbetaM * 1.1 * (optical_depthM + optical_depth_lightM);\n\t\t\tvec3 attenuation = exp(-tau);\n\n\t\t\tsumR += hr * attenuation;\n\t\t\tsumM += hm * attenuation;\n\t\t}\n\n\t\tmarch_pos += march_step;\n\t}\n\n\treturn\n\t\tsun_power *\n\t\t(sumR * phaseR * betaR +\n\t\tsumM * phaseM * betaM);\n}\n\nvoid mainImage(_out(vec4) fragColor, vec2 fragCoord)\n{\n\tvec2 aspect_ratio = vec2(u_res.x / u_res.y, 1);\n\tfloat fov = tan(radians(45.0));\n\tvec2 point_ndc = fragCoord.xy / u_res.xy;\n\tvec3 point_cam = vec3((2.0 * point_ndc - 1.0) * aspect_ratio * fov, -1.0);\n\n\tvec3 col = vec3(0);\n\n\t// sun\n\tmat3 rot = rotate_around_x(-abs(sin(u_time / 2.)) * 90.);\n\tsun_dir *= rot;\n\n    if (u_mouse.z < 0.1) {\n        // sky dome angles\n        vec3 p = point_cam;\n        float z2 = p.x * p.x + p.y * p.y;\n        float phi = atan(p.y, p.x);\n        float theta = acos(1.0 - z2);\n        vec3 dir = vec3(\n            sin(theta) * cos(phi),\n            cos(theta),\n            sin(theta) * sin(phi));\n\n        ray_t ray = _begin(ray_t)\n            vec3(0, earth_radius + 1., 0),\n            dir\n        _end;\n\n        col = get_incident_light(ray);\n    } else {\n        vec3 eye = vec3 (0, earth_radius + 1., 0);\n        vec3 look_at = vec3 (0, earth_radius + 1.5, -1);\n\n        ray_t ray = get_primary_ray(point_cam, eye, look_at);\n\n        if (dot(ray.direction, vec3(0, 1, 0)) > .0) {\n            col = get_incident_light(ray);\n        } else {\n            col = vec3 (0.333);\n        }\n    }\n\n\tfragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}