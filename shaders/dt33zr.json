{
    "Shader": {
        "info": {
            "date": "1681861722",
            "description": "pattern",
            "flags": 0,
            "hasliked": 0,
            "id": "dt33zr",
            "likes": 2,
            "name": "glassvoronoi",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "brackets1",
            "viewed": 152
        },
        "renderpass": [
            {
                "code": "const float TWIRL_FACTOR = 0.5;\nconst float OFFSET_FACTOR = 1.0;\nconst float GROWTH_FACTOR = 0.5;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 hexagon(in vec2 p) {\n    vec2 q = vec2(p.x * 2.0 * 0.5773503, p.y + p.x * 0.5773503);\n    vec2 pi = floor(q), pf = fract(q);\n    float v = mod(pi.x + pi.y, 3.0);\n    float ca = step(1.0, v), cb = step(2.0, v);\n    vec2 ma = step(pf.xy, pf.yx);\n    float e = dot(ma, 1.0 - pf.yx + ca * (pf.x + pf.y - 1.0) + cb * (pf.yx - 2.0 * pf.xy));\n    p = vec2(q.x + floor(0.5 + p.y / 1.5), 2.0 * p.y / 3.0) * 0.5 + 0.5;\n    float f = length((fract(p) - 0.5) * vec2(1.0, 0.2));\n    return vec4(pi + ca - cb * ma, e, f);\n}\n\nvec2 twirl(vec2 p, float factor) {\n    float radius = length(p);\n    float angle = atan(p.y, p.x);\n    angle += factor * radius;\n    return vec2(cos(angle), sin(angle)) * radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Get time\n    float time = iTime * 0.5;\n\n    // Calculate tunnel distance\n    float tunnelDist = 5.0 + 3.0 * sin(time);\n\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n\n    // Twirl the coordinates\n    vec2 twirled_p = twirl(p, TWIRL_FACTOR);\n\n    // Divide the cells from the center\n    float radius = length(p);\n    float scaleFactor = exp(-radius * GROWTH_FACTOR);\n    twirled_p /= scaleFactor;\n\n    // Apply a small random offset to each tile\n    vec4 h = hexagon(twirled_p * tunnelDist);\n    vec2 offset = vec2(rand(h.xy) - 0.5, rand(h.xy + 0.3) - 0.5) * OFFSET_FACTOR;\n    h = hexagon((twirled_p + offset) * tunnelDist);\n\n    vec3 col = vec3(h.z);\n    \n    col = mix(col, 1.0 - col, smoothstep(-0.2, .13, h.z));\n\n    fragColor = vec4(col, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}