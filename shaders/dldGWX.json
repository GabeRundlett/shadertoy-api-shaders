{
    "Shader": {
        "info": {
            "date": "1683265726",
            "description": "CC0: B/W logarithmic circles\n Inspired by this tweet: https://twitter.com/concinnus/status/1654244526297583616?s=20\n Not an exact copy but good enough for a quick morning hack\n",
            "flags": 0,
            "hasliked": 0,
            "id": "dldGWX",
            "likes": 20,
            "name": "B/W logarithmic circles",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 304
        },
        "renderpass": [
            {
                "code": "// CC0: B/W logarithmic circles\n//  Inspired by this tweet: https://twitter.com/concinnus/status/1654244526297583616?s=20\n//  Not an exact copy but good enough for a quick morning hack\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float ExpBy = log2(2.24);\n\nfloat forward(float l) {\n  return exp2(ExpBy*l);\n}\n\nfloat reverse(float l) {\n  return log2(l)/ExpBy;\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = TAU/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nvec3 effect(vec2 p) {\n  float aa = 4.0/RESOLUTION.y;\n  float ltm = 0.75*TIME;\n  mat2 rot0 = ROT(-0.5*ltm); \n  float mtm = fract(ltm);\n  float ntm = floor(ltm);\n  float zz = forward(mtm);\n\n  vec2 p0 = p;\n  p0 *= rot0;\n  p0 /= zz;\n\n  float l0 = length(p0);\n  \n  float n0 = ceil(reverse(l0));\n  float r0 = forward(n0);\n  float r1 = forward(n0-1.0);\n  float r = (r0+r1)/2.0;\n  float w = r0-r1;\n  float nn = n0;\n  n0 -= ntm;\n  vec2 p1 = p0;\n  p1 *= ROT(3.0*n0*TAU/16.0);\n  float n1 = modPolar(p1, 8.0);\n  p1.x -= r;\n\n  float a = 0.5*ltm+n1/8.0;\n  a = fract(a);\n  float d1 = length(p1)-0.5*w;\n  float d2 = length(p1)-0.5*w*smoothstep(0.0, 0.45, mod(a, 0.5));\n  d1 *= zz;\n  d2 *= zz;\n  vec3 col = vec3(0.2*smoothstep(-sqrt(0.5), sqrt(0.5), sin(0.5*TAU*p.y/aa)));\n  vec3 ccol = vec3(1.0)*smoothstep(0.0, -aa, d2);\n  if (a >= 0.5) ccol = 1.0-ccol;\n  col = mix(col, ccol, smoothstep(0.0, -aa, d1));\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}