{
    "Shader": {
        "info": {
            "date": "1630704556",
            "description": "visual experiment",
            "flags": 32,
            "hasliked": 0,
            "id": "Ns33DX",
            "likes": 12,
            "name": "Elastic cube",
            "published": 3,
            "tags": [
                "cube",
                "elastic"
            ],
            "usePreview": 0,
            "username": "avin",
            "viewed": 401
        },
        "renderpass": [
            {
                "code": "\n#define DISPLAY_GAMMA 1.5\nconst float PI = 3.14159265359;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    \n    float t = iTime*.5;   \n    float pm = floor(t);\n    \n    float sn = sin(fract(t) * PI);\n    \n    sn *= sn * .005;\n    \n    vec4 color = vec4(1.);\n    if(mod(pm, 2.) != 0.){        \n        vec4 c1 = texture(iChannel0, uv-vec2(0.,sn*1.5)).rgba;\n        vec4 c2 = texture(iChannel0, uv+vec2(0.,sn*1.5)).rgba;\n        vec4 c3 = texture(iChannel0, uv).rgba;\n        color = vec4(c1.r, c2.b, c3.g, 1.);\n    } else {\n        vec4 c1 = texture(iChannel0, uv+vec2(sn,0.)).rgba;\n        vec4 c2 = texture(iChannel0, uv-vec2(sn,0.)).rgba;\n        vec4 c3 = texture(iChannel0, uv).rgba;\n        color = vec4(c1.r, c2.b, c3.g, 1.);        \n    }\n         \n    vec3 col = color.rgb;              \n    \n    //-----------------------------------------------------\n    // postprocessing\n    //-----------------------------------------------------    \n    \n    //tone mapping\n    col = vec3(1.7, 1.8, 1.9) * col / (1.0 + col);    \n\n    // Color control\n    col = 0.5 * col + 0.5 * col * col * (3.0 - 2.0 * col);\n\n    // Border dark\n    col *= 0.2 + 0.8 * pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.3);\n\n    // Fade in\n    col *= smoothstep(0.0, 1.0, iTime);    \n    \n    color.rgb = col;\n    \n    // -----------------------------------------------------\n    \n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14159265359;\nconst float fov = 40.0;\n\nconst float S = 0.0001;\n\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n// --------------------------------\n\nfloat deg2rad(float d) { return PI * d / 180.0; }\nfloat rad2deg(float r) { return 180.0 * r / PI; }\n\nvec4 quatAxisAngle(vec3 axis, float angle)\n{ \n    float half_angle = angle*0.5;\n    return vec4(axis*sin(half_angle), cos(half_angle));\n}\n\nvec4 quatConj(vec4 q)\n{ \n    return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quatMul(vec4 q1, vec4 q2)\n{ \n    vec4 qr;\n    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n    return qr;\n}\n\nvec3 rotate(vec4 q, vec3 p)\n{\n    vec4 conj = quatConj(q);\n    vec4 q_tmp = quatMul(q, vec4(p, 0));\n    return quatMul(q_tmp, conj).xyz;\n}\n\n// --------------------------------\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) { \n    vec3 q = abs(p) - b; \n    return length(max(q,0.1)) + min(max(q.x,max(q.y,q.z)),0.0) - r; \n}\n\n\nfloat distanceToNearestSurface(vec3 p){   \n    float t = iTime*.5;   \n    float pm = floor(t);\n    float dF = .5;\n    float pf = fract(t) * (1. + dF);\n    \n    float rs = .1;\n\n    if(mod(pm, 2.) != 0.){\n        float rpf = max(min(pf + (p.z*rs-.25), 1.), 0.);\n        float a = (cos(rpf * PI) * PI * 2.) / 2.;        \n        vec4 q = quatAxisAngle(vec3(0.,0.,1.), a);\n        \n        p = rotate(q, p);               \n    } else {\n        float rpf = max(min(pf + (p.y*rs-.25), 1.), 0.);\n        float a = (cos(rpf * PI) * PI * 2.) / 2.;        \n        vec4 q = quatAxisAngle(vec3(0.,1.,0.), a);\n        \n        p = rotate(q, p);               \n    }\n    \n\n    return sdRoundBox(p, vec3(1.), 0.);                        \n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n        distanceToNearestSurface(p+deltax)-d,\n        distanceToNearestSurface(p+deltay)-d,\n        distanceToNearestSurface(p+deltaz)-d\n    ));\n}\n\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n\nvec4 intersectWithWorld(vec3 p, vec3 dir){\n    float dist = 0.0;\n    float nearest = 0.0;\n    vec3 result = vec3(0.0);\n    for(int i = 0; i < 40; i++){\n        nearest = distanceToNearestSurface(p + dir*dist);\n        \n        vec3 hit = p+dir*dist;\n        vec3 light = vec3(100.0, 30.0, 50.0);\n        result = computeLambert(hit, computeSurfaceNormal(hit), light);\n        result += hit*.2;            \n        \n        dist += nearest;\n    }\n    return vec4(result, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 backCol = texture(iChannel0, uv).rgb;\n    \n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(10.0, 5.0, 10.0);\n\tvec3 cameraDirection = vec3(-1.0, -.50, -1.0);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n      \n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n    vec4 ir = intersectWithWorld(cameraPosition, rayDirection);\n    vec3 tCol = ir.rgb;\n    float tDepth = ir.a*.25;\n    float fog = 1.0 / (1.0 + tDepth * tDepth * 0.01);  \n    vec3 col = mix(vec3(0.0), tCol, fog);\n    \n    col = clamp(col, vec3(0.0), vec3(1.));\n      \n    col = mix(col*col, backCol,0.75);    \n            \n\tfragColor = vec4(col, 1.);        \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}