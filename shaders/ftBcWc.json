{
    "Shader": {
        "info": {
            "date": "1650301646",
            "description": "an SDF I used in my 4k exegfx demo \"grazing\"",
            "flags": 0,
            "hasliked": 0,
            "id": "ftBcWc",
            "likes": 14,
            "name": "Object Maker",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "// the \"obj\" function is one I made to allow me to quickly generate shapes for the pumpjacks in my 4k exegfx demo \"grazing\"\n// can be used to make I-beams with internal supports, steel objects with ridges, and ladders\n\n\n//fancy repetition to make the dictionary compressor happy :3\nfloat mx(vec2 p) {\n    return max(p.x,p.y);\n}\nfloat mx(vec3 p) {\n    return max(p.x,mx(p.yz));\n}\nfloat mx(vec4 p) {\n    return max(p.x,mx(p.yzw));\n}\n#define corner(p) (length(max(p,0.)) + min(0.,mx(p)))\n#define box(p,d) corner(abs(p)-(d/2.))\n//todo: make tri less..... like this\n#define tri(p,r) (asin(sin((p)*r))/r)\n\nfloat hex(vec2 p, vec3 rad) {\n    vec3 p2 = vec3(.81,-.4,-.4)*p.y + vec3(0,-.71,.71)*p.x;\n    return box(p2,vec3(rad));\n}\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat feature(vec3 p, float d, float w, float t) {\n    float body = corner(p.xy-vec2(-t,d)/2.); // main body or nothing\n    float perp = box(p.xy,vec2(t,w)); // perpendicular beam\n    float supp = corner(vec3(p.x,abs(p.yz))-vec3(-t,mix(w,d,.3),t)/2.); // supporting beam\n    return smin(min(supp,body),perp,t/2.)-0.0100;\n}\n\n//d.x = I extrusion depth, d.yz = body dimensions\n//dp = depth of webbing\n//t = I extrusion thickness\n//y = greeble dimension\n//o = 45deg cut offset\nfloat obj(vec3 p, vec3 d, float dp, float t, float y, float o) {\n    float body = -smin(-box(p.yz,d.yz),(o+p.y-p.z)*.71,0.0500);\n    return feature(vec3(body,abs(p.x),y),dp,d.x,t);\n}\n\nfloat scene(vec3 p) {\n    p.z -= .5;\n    float o1 = obj(p, vec3(.2,2.,.3), .01, .01, p.y, 1e4);\n    p.z += .5;\n    float o2 = obj(p, vec3(.2,1.5,.3), .16, .01, p.z, .7);\n    p.z += .5;\n    float o3 = obj(p, vec3(.05,2.,.3), -.1, .01, tri(p.y,12.), 1e4);\n    return min(min(o1,o2),o3);\n\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-3.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    vec3 atten = vec3(1);\n    vec3 first = vec3(0);\n    bool hit = false;\n    for (int i = 0; i < 150; i++) {\n        float dist = scene(p);\n        //hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>10.) break;\n        if (dist*dist < 1e-6) {\n            vec3 n = norm(p);\n            float fres = 1. - pow(abs(dot(cam,n)),.5)*.98;\n            cam = reflect(cam,n);\n            atten *= vec3(.9) * fres * smoothstep(-.04,.02,scene(p+cam*.02));\n            p += n*.01;\n            if (!hit) {\n                hit = true;\n                first = n;\n            }\n        }\n    }\n    fragColor.xyz = sqrt(atten * length(sin(cam*2.)*.4+.6) );\n    return;\n    /*\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    //don't ask how I stumbled on this texture\n    float spec = length(sin(r*3.5)*.4+.6)/sqrt(3.);\n    spec *= smoothstep(-.04,.02,scene(p+r*.02));\n    vec3 col = vec3(.4,.1,.1)*pow(spec,2.) + pow(spec,8.);\n    float bgdot = length(sin(cam*2.)*.4+.6)/2.;\n    vec3 bg = vec3(.95,.95,.9) * bgdot + pow(bgdot, 10.);\n    fragColor.xyz = hit ? col : bg;\n    fragColor = sqrt(smoothstep(.1,1.2,sqrt(fragColor)) * (1.- dot(uv,uv)*.5));*/\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}