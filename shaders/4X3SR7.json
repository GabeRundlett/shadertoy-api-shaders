{
    "Shader": {
        "info": {
            "date": "1718756841",
            "description": "🏳️‍⚧️",
            "flags": 0,
            "hasliked": 0,
            "id": "4X3SR7",
            "likes": 10,
            "name": "bloom filter",
            "published": 3,
            "tags": [
                "2d",
                "flowers"
            ],
            "usePreview": 0,
            "username": "ahihi",
            "viewed": 236
        },
        "renderpass": [
            {
                "code": "#define TILE_SIZE 80.0\n#define STROKE 0.08\n#define MARGIN (STROKE*0.5)\n#define D_EDGE 0.04\n\n#define UNI2BI(x) (x * 2.0 - 1.0)\n#define BI2UNI(x) ((x + 1.0) * 0.5)\n#define NOISE3D psrdnoise_wrapper\n\n#define TAU 6.283185307179586\n\nvec2 polar(vec2 p) {\n    if(p.x == 0.0 && p.y == 0.0) {\n        return vec2(0.0, 0.0);\n    } else {\n        return vec2(atan(p.y, p.x), length(p));\n    }\n}\n\nvec2 cartesian(vec2 p) {\n    return vec2(p.y * cos(p.x), p.y * sin(p.x));\n}\n\nfloat linlin(float x, float l0, float r0, float l1, float r1) {\n    return (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 rotate(vec2 p, float angle) {\n    return cartesian(polar(p) + vec2(angle, 0.0));\n}\n\n//\n// psrdnoise3.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer periods\n// up to 289 units in the x, y and z directions. Specifying a longer\n// period than 289 will result in errors in the noise field.\n//\n// This particular version of 3-D noise also implements animation by rotating\n// the generating gradient at each lattice point around a pseudo-random axis.\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along the fourth\n// dimension in 4-D noise.\n//\n// The rotating gradients in conjunction with the built-in ability to\n// compute exact analytic derivatives allow for \"flow noise\" effects\n// as presented by Ken Perlin and Fabrice Neyret.\n//\n\n// Use Perlin's rotated grid instead of the new tiling grid?\n// Enabling this adds about 1% to the execution time and\n// requires all periods to be multiples of 3. Other\n// integer periods can be specified, but when not evenly\n// divisible by 3, the actual period will be 3 times longer.\n// Take care not to overstep the maximum allowed period (288).\n//#define PERLINGRID\n\n// Enable faster gradient rotations?\n// Enabling this saves about 10% on execution time,\n// but the function will not run faster for alpha = 0.\n//#define FASTROTATION\n\n\n// Permutation polynomial for the hash value\nvec4 permute(vec4 x) {\n     vec4 xm = mod(x, 289.0);\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\n}\n\n//\n// 3-D tiling simplex noise with rotating gradients and first order\n// analytical derivatives.\n// \"vec3 x\" is the point (x,y,z) to evaluate\n// \"vec3 period\" is the desired periods along x,y,z, up to 289.\n// (If Perlin's grid is used, multiples of 3 up to 288 are allowed.)\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\n// The \"float\" return value is the noise value, and\n// the \"out vec3 gradient\" argument returns the x,y,z partial derivatives.\n//\n// The function executes 15-20% faster if alpha is constant == 0.0\n// across all fragments being executed in parallel.\n// (This speedup will not happen if FASTROTATION is enabled. Do not specify\n// FASTROTATION if you are not actually going to use the rotation.)\n//\n// Setting any period to 0.0 or a negative value will skip the periodic\n// wrap for that dimension. Setting all periods to 0.0 makes the function\n// execute 10-15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function by\n// around 10%.\n//\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n\n#ifndef PERLINGRID\n  // Transformation matrices for the axis-aligned simplex grid\n  const mat3 M = mat3(0.0, 1.0, 1.0,\n                      1.0, 0.0, 1.0,\n                      1.0, 1.0, 0.0);\n\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                        0.5,-0.5, 0.5,\n                        0.5, 0.5,-0.5);\n#endif\n\n  vec3 uvw;\n\n  // Transform to simplex space (tetrahedral grid)\n#ifndef PERLINGRID\n  // Use matrix multiplication, let the compiler optimise\n  uvw = M * x;\n#else\n  // Optimised transformation to uvw (slightly faster than\n  // the equivalent matrix multiplication on most platforms)\n  uvw = x + dot(x, vec3(1.0/3.0));\n#endif\n\n  // Determine which simplex we're in, i0 is the \"base corner\"\n  vec3 i0 = floor(uvw);\n  vec3 f0 = fract(uvw); // coords within \"skewed cube\"\n\n  // To determine which simplex corners are closest, rank order the\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\n  // and traverse the four corners from largest to smallest magnitude.\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison \"less-than\"\n  vec3 l_ = 1.0 - g_;             // complement is \"greater-or-equal\"\n  vec3 g = vec3(l_.z, g_.xy);\n  vec3 l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l );\n  vec3 o2 = max( g, l );\n\n  // Enumerate the remaining simplex corners\n  vec3 i1 = i0 + o1;\n  vec3 i2 = i0 + o2;\n  vec3 i3 = i0 + vec3(1.0);\n\n  vec3 v0, v1, v2, v3;\n\n  // Transform the corners back to texture space\n#ifndef PERLINGRID\n  v0 = Mi * i0;\n  v1 = Mi * i1;\n  v2 = Mi * i2;\n  v3 = Mi * i3;\n#else\n  // Optimised transformation (mostly slightly faster than a matrix)\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n  // Compute vectors to each of the simplex corners\n  vec3 x0 = x - v0;\n  vec3 x1 = x - v1;\n  vec3 x2 = x - v2;\n  vec3 x3 = x - v3;\n\n  if(any(greaterThan(period, vec3(0.0)))) {\n    // Wrap to periods and transform back to simplex space\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n        // Wrap to periods where specified\n        if(period.x > 0.0) vx = mod(vx, period.x);\n        if(period.y > 0.0) vy = mod(vy, period.y);\n        if(period.z > 0.0) vz = mod(vz, period.z);\n    // Transform back\n#ifndef PERLINGRID\n    i0 = M * vec3(vx.x, vy.x, vz.x);\n    i1 = M * vec3(vx.y, vy.y, vz.y);\n    i2 = M * vec3(vx.z, vy.z, vz.z);\n    i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n    v0 = vec3(vx.x, vy.x, vz.x);\n    v1 = vec3(vx.y, vy.y, vz.y);\n    v2 = vec3(vx.z, vy.z, vz.z);\n    v3 = vec3(vx.w, vy.w, vz.w);\n    // Transform wrapped coordinates back to uvw\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n        // Fix rounding errors\n    i0 = floor(i0 + 0.5);\n    i1 = floor(i1 + 0.5);\n    i2 = floor(i2 + 0.5);\n    i3 = floor(i3 + 0.5);\n  }\n\n  // Compute one pseudo-random hash value for each corner\n  vec4 hash = permute( permute( permute(\n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\n\n  vec4 Ct = cos(theta);\n  vec4 St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\n\n  vec4 gx, gy, gz;\n\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\n#ifdef FASTROTATION\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\n  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator\n  vec4 qy = -Ct;\n  vec4 qz = vec4(0.0);\n\n  vec4 px =  sz * qy;   // p' = cross(q, s)\n  vec4 py = -sz * qx;\n  vec4 pz = sz_prime;\n\n  psi += alpha;         // psi and alpha in the same plane\n  vec4 Sa = sin(psi);\n  vec4 Ca = cos(psi);\n\n  gx = Ca * px + Sa * qx;\n  gy = Ca * py + Sa * qy;\n  gz = Ca * pz + Sa * qz;\n#else\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\n  // useful conditional speedup for alpha = 0 across all fragments\n  if(alpha != 0.0) {\n    vec4 Sp = sin(psi);          // q' from psi on equator\n    vec4 Cp = cos(psi);\n\n    vec4 px = Ct * sz_prime;     // px = sx\n    vec4 py = St * sz_prime;     // py = sy\n    vec4 pz = sz;\n\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')\n    vec4 qx = mix( Ctp*St, Sp, sz);\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\n    vec4 Ca = vec4(cos(alpha));\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n  }\n  else {\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\n    gy = St * sz_prime;\n    gz = sz;\n  }\n#endif\n\n  // Reorganize for dot products below\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n  // Radial decay with distance from each simplex corner\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0);\n  vec4 w2 = w * w;\n  vec4 w3 = w2 * w;\n\n  // The value of the linear ramp from each of the corners\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n  // Multiply by the radial decay and sum up the noise value\n  float n = dot(w3, gdotx);\n\n  // Compute the first order partial derivatives\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n  // Scale the return value to fit nicely into the range [-1,1]\n  return 39.5 * n;\n}\n\nfloat psrdnoise_wrapper(vec3 x) {\n    vec3 grad;\n    return psrdnoise(x, vec3(289.0), 0.0, grad);\n}\n\nfloat rand(vec2 p){\n    return fract(sin(dot(p.xy, vec2(1.3295, 4.12))) * 493022.1);\n}\n\nvec2 petal(vec2 uv, float scale, float squeeze_scale) {\n    vec2 uv1_bi = UNI2BI(uv) * vec2(2.0, 2.0*squeeze_scale) + vec2(-1.0, 0.0);\n    float dist = length(uv1_bi);\n    float edge_outer = 1.0-MARGIN*scale;\n    vec2 r = vec2(smoothstep(edge_outer, edge_outer-D_EDGE*4.0*scale, dist), 0.0);\n    return r;\n}\n\n#define PETALS(n, scale, squeeze_scale, angle, hole_size, r) { \\\n    for(float i = 0.0; i < (n); i++) { \\\n        (r) = max((r), petal(BI2UNI(rotate(UNI2BI(uv), i*TAU/(n) + (angle))), (scale), (squeeze_scale))); \\\n    } \\\n    (r).x *= smoothstep(hole_size-D_EDGE*scale, hole_size, length(UNI2BI(uv) * 2.0)); \\\n}\n\nvec2 flower3(vec2 uv, float scale, bool alt_rot) {\n    vec2 r = vec2(0.0);\n    PETALS(3.0, scale, 2.0, alt_rot ? TAU/4.0 : 0.0, 0.3, r)\n    return r;\n}\n\nvec2 flower4(vec2 uv, float scale, bool alt_rot) {\n    vec2 r = vec2(0.0);\n    PETALS(4.0, scale, 2.0, alt_rot ? TAU/8.0 : 0.0, 0.3, r)\n    return r;\n}\n\nvec2 flower5(vec2 uv, float scale, bool alt_rot) {\n    vec2 r = vec2(0.0);\n    PETALS(5.0, scale, 2.5, TAU/4.0 + (alt_rot ? TAU/2.0 : 0.0), 0.3, r)\n    return r;\n}\n\nvec2 flower6(vec2 uv, float scale, bool alt_rot) {\n    vec2 r = vec2(0.0);\n    PETALS(6.0, scale, 2.5, alt_rot ? TAU/4.0 : 0.0, 0.4, r)\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = fragCoord.xy * 1920.0 / max(iResolution.x, iResolution.y);\n    xy.y = iResolution.y - xy.y;\n\n    float r_warp = NOISE3D(vec3(0.003*xy, 0.1*iTime));\n    vec2 xy_p = polar(UNI2BI(xy / iResolution.xy));\n    float k_warp = BI2UNI(r_warp);\n    xy = BI2UNI(cartesian(vec2(xy_p.x, xy_p.y * linlin(k_warp, 0.0, 1.0, 0.98, 1.03)))) * iResolution.xy;\n    \n    vec2 movement = vec2(0.0, TILE_SIZE*0.5);\n    vec3 bgcolor0 = vec3(13.0, 0.0, 8.0) / 255.0;\n    vec3 bgcolor1 = vec3(43.0, 0.0, 38.0) / 255.0;\n    float bg_blend = BI2UNI(NOISE3D(vec3(0.1*iTime, xy*0.001 + 0.7*movement)));\n    vec3 background_color = mix(bgcolor0, bgcolor1, bg_blend);\n    vec3 flower_color = vec3(89.0, 19.0, 89.0) / 255.0;\n    \n    float tile_size = TILE_SIZE;\n    xy = xy + iTime * mod(movement, 293.0*TILE_SIZE);\n    vec2 tile = floor(xy / tile_size);\n    vec2 tile_uv_unscaled = fract(xy / tile_size);\n    float r_type = abs(rand(tile*-92.1984 - 0.1));\n    float r_scale = abs(rand(tile.yx*-12.21 - 0.21));\n    float r_rot_speed = abs(rand(tile*21.14 + 0.2));\n    float r_shrink_rate = abs(rand(tile*32.35 + 0.9));\n    float r_shrink_phase = abs(rand(tile*42.25 + 1.9));\n    float r_alt_color = abs(rand(tile.yx*2.3 - 9.19));\n\n    float thresh = tile.x / (iResolution.x / tile_size - 1.0);\n    vec2 flower = vec2(0.0);\n    float num_flowers = 4.0;\n    float scale = floor(linlin(pow(r_scale, 1.2), 0.0, 1.0, 1.0, 4.0) + 0.5);\n    float shrink = sin(iTime*linlin(r_shrink_rate, 0.0, 1.0, 0.5, 2.0) + r_shrink_phase * TAU);\n    float k_shrink = BI2UNI(shrink);\n    shrink = linlin(k_shrink, 0.0, 1.0, 1.0, 1.5);\n    vec2 flower_uv = tile_uv_unscaled * scale;\n    flower_uv = fract(flower_uv);\n    float rot_speed = UNI2BI(r_rot_speed);\n    float speed_sign = rot_speed >= 0.0 ? 1.0 : -1.0;\n    rot_speed = linlin(abs(rot_speed), 0.0, 1.0, 0.2, 1.0) * speed_sign;\n    flower_uv = BI2UNI(rotate(UNI2BI(flower_uv), iTime*rot_speed) * shrink);\n    bool alt_rot = false;\n    float k_type = r_type;\n    if(k_type < 1.0/num_flowers) {\n        flower = flower3(flower_uv, scale, alt_rot);\n    } else if(k_type < 2.0/num_flowers) {\n        flower = flower4(flower_uv, scale, alt_rot);\n    } else if(k_type < 3.0/num_flowers) {\n        flower = flower5(flower_uv, scale, alt_rot);\n    } else if(k_type < 4.0/num_flowers) {\n        flower = flower6(flower_uv, scale, alt_rot);\n    }\n\n    vec3 alt_color = vec3(0.0);\n    if(r_alt_color < 1.0/3.0) {\n        alt_color = vec3(1.0, 0.0, 1.0);\n    } else if(r_alt_color < 2.0/3.0) {\n        alt_color = vec3(0.0, 1.0, 1.0);\n    } else {\n        alt_color = vec3(1.0);\n    }\n    float kira = pow(BI2UNI(NOISE3D(vec3(0.01*xy, -0.008*iTime))), 3.0);\n    flower_color = mix(flower_color, alt_color, (1.0-k_shrink)*kira*0.8);\n    vec3 color = mix(background_color, flower_color, flower.x*linlin(k_shrink, 0.0, 1.0, 1.0, 0.0));\n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}