{
    "Shader": {
        "info": {
            "date": "1502593936",
            "description": "tours",
            "flags": 0,
            "hasliked": 0,
            "id": "ls2fWc",
            "likes": 2,
            "name": "Tours",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "mikatalk",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "// Forked from https://www.shadertoy.com/view/4dSfzt\n\n#define Pi 3.1415926\n#define Pi2 1.5707963\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\n\nfloat Sphere( vec3 centre, float radius, vec3 pos )\n{\n    return length(centre-pos)-radius;\n}\n\nfloat Torus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 Sub( vec2 a, vec2 b )\n{\n    return max(-a.x, b.x) == -a.x ? a : b;\n}\n\nfloat BoxUn( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// A more interesting SDF:\nfloat Superellipsoid( vec3 centre, float radius, float power, vec3 pos )\n{\n    pos = abs(pos-centre)/radius; // scale and sign-flip pos into a [0,1] range\n    pos = pow(pos,vec3(power)); // apply power before summing components\n    float d = dot(pos,vec3(1)); // add the components together\n\td = pow(d,1./power); // apply inverse power so SDF is well behaved\n    float fix = min(1.,.5+.5*(power-1.)); // corrective factor for lower powers, ensure gradient of SDF doesn't exceed 1.\n    return fix*(d-1.)*radius; // undo the scaling, to hit the desired radius\n}\n\n// pass vec2's so we can attach an object-ID to objects in the SDF\nvec2 Union( vec2 a, vec2 b )\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 Intersection( vec2 a, vec2 b )\n{\n    return a.x > b.x ? a : b;\n}\n\n\nfloat CappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nvec3 pMod(vec3 t, float d) {\n    return mod(t + d/2.0, d) - d/2.0;\n}\n\nfloat fMod(float t, float d) {\n    return mod(t + d/2.0, d) - d/2.0;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\nfloat smin2( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smin3( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nvec2 Blend(  vec2 a, vec2 b)\n{\n    return vec2(smin2( a.x, b.x, 1.0 ), a.y);\n}\nvec2 Blend2(  vec2 a, vec2 b)\n{\n    return vec2(smin2( a.x, b.x, .5 ), a.y);\n}\n\n\n\nvec2 Scene( vec3 pos, vec2 fragCoord )\n{\n//\tvec2 angle = vec2(-2.4, 0.);\n\tvec2 angle = vec2(-iTime*.25,0);\n    Rotate(pos,angle);\n\n    vec3 offset = vec3(0.,2.,0);\n    vec3 tmp = pos + offset;\n    \n    vec2 f = vec2(1.0, 0.);\n   \n    float s1 =  floor(((tmp.x + 3.25)/7.5 )* 15.)/ 15.;\n    float s2 =  floor(((tmp.z + 3.25)/7.5 )* 15.)/ 15.;\n//    float s = mix(s1, s2, .5);\n    float s = length(tmp.xz) / 7.5;\n    s = texture(iChannel1, vec2( s, 0.)).r;\n    \n    \n    tmp.x = fMod(tmp.x, .5);\n    tmp.z = fMod(tmp.z, .5);\n \n  \n    vec3 size = vec3(.2, s*5., .2);//vec3(.06 - .02*sin(iTime));\n            \n    // bar \n    vec2 bar = vec2( BoxUn(tmp, vec3(size)), 0.0 );\n   // bar = Blend(bar, bar);\n   // bar = Blend(bar, bar);\n    \n    \n\tf = Union( f, bar );\n    \n    // world box\n    //f = Intersection( f, vec2( BoxUn(pos+vec3(0.,3.,0.), vec3(3.75,5.,3.75)), 0.0 ) );\n    f = Intersection(f, vec2( Sphere(vec3(0,0,0),7.5,pos), 1.0 ));\n\n    // floor\n\tf = Union(f, vec2( Sphere(vec3(0,-220,0),218.,pos), 1.0 ));\n    \n   // f = Blend2(f, f);\n    \n    return f;\n}\n\n\nfloat SDF( vec3 pos, vec2 fragCoord )\n{\n    return Scene(pos, fragCoord).x;\n}\n\nfloat GetShapeIndex( vec3 pos, vec2 fragCoord )\n{\n    return Scene(pos, fragCoord).y;\n}\n\nfloat ShadowMarch( vec3 pos, vec3 light, vec2 fragCoord )\n{\n    vec3 ray = normalize(light-pos);\n    float e = length(light-pos);\n    float t = .02; // step away from the surface\n    for ( int i=0; i < 50; i++ )\n    {\n        float h = SDF(pos+ray*t, fragCoord);\n        if ( h < .001 )\n        {\n            return 0.; // hit something\n        }\n        if ( t >= e )\n        {\n            break;\n        }\n        t += h;\n    }\n    return 1.; // didn't hit anything\n}\n\n// material parameters, per shape\nconst vec3 albedo[] = vec3[](\n    vec3(1.01),\n    vec3(1.05)\n);\nconst vec3 fresnelColour[] = vec3[](\n    vec3(.2, .6, .2),\n    vec3(.4, .6, .6)\n);\nconst float roughness[] = float[](\n   .2f,\n   .2f\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray = normalize( vec3(\n\t\t\t\t(fragCoord-iResolution.xy*.5)/iResolution.x, // pixel pos on screen\n\t\t\t\t1 ) ); // place screen 1 unit in front of eye\n    vec3 pos = vec3(0,0,-20); // move eye 18 units back from scene\n\tvec2 angle = vec2(0,.25);\n\tif ( iMouse.z > .0 ) angle = vec2(0., 1.2)+(vec2(3.0, .8)*iMouse.xy/iResolution.xy-.5)*Pi;\n\tRotate(pos,angle);\n\tRotate(ray,angle);\n\t\n    fragColor = pow(texture(iChannel0, ray),vec4(2.2));\n    for ( int i=0; i < 128; i++ )\n    {\n        float h = SDF(pos, fragCoord);\n        if ( h < .01 )\n        {\n            fragColor = vec4(0);\n            break;\n        }\n        pos += ray*h;\n    }\n\n    if ( SDF(pos, fragCoord) < .01 )\n    {\n        vec3 normal;\n        normal.x = SDF(pos+vec3(.01,0,0), fragCoord) - SDF(pos-vec3(.01,0,0), fragCoord);\n        normal.y = SDF(pos+vec3(0,.01,0), fragCoord) - SDF(pos-vec3(0,.01,0), fragCoord);\n        normal.z = SDF(pos+vec3(0,0,.01), fragCoord) - SDF(pos-vec3(0,0,.01), fragCoord);\n        normal = normalize(normal);\n\n        vec3 lightSource = vec3(-10,6,16);\n\t\tfloat light = max(.0,dot(normal,normalize(lightSource-pos)));\n        light *= ShadowMarch( pos, lightSource, fragCoord );\n\n        vec3 ambient = mix( vec3(.7), vec3(.8,.8,.9), normal.y*.5+.5 ); // looks better than a flat colour\n        vec3 lightCol = vec3(.8);\n        vec3 lighting = light*lightCol + ambient;\n\n        // material\n        int shapeIndex = int(GetShapeIndex(pos, fragCoord));\n        \n        fragColor.rgb = albedo[shapeIndex] * lighting;\n        \n        // specular highlight\n        \n        // reflection mapping\n        vec3 reflection = reflect(ray,normal);\n        vec3 refMap = .75*pow(texture(iChannel0, reflection).rgb,vec3(2.2));\n        vec3 fresnel = mix( fresnelColour[shapeIndex], vec3(1.-roughness[shapeIndex]), pow(dot(normal,ray)+1.,5.) );\n        fragColor.rgb = mix( fragColor.rgb, refMap, fresnel );\n    }\n    \n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n//      fragColor = texture(iChannel1, abs(ray.xy)* .5);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 21,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}