{
    "Shader": {
        "info": {
            "date": "1448441008",
            "description": "fuggin around",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtGz4",
            "likes": 3,
            "name": "Sphield",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "haptix",
            "viewed": 435
        },
        "renderpass": [
            {
                "code": "float glow = 0.;  //GLOW baby\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nvec3 twist(vec3 pos)\n{\n    float c = cos(0.33 * pos.y + iTime*1.2);\n    float s = sin(0.33 * pos.y + iTime*1.2);\n    mat2  m = mat2(c, -s, s, c);\n    return vec3(m * pos.xz, pos.y);\n}\n\nvec3 repeat(vec3 pos, float spacing)\n{\n\treturn mod(pos, spacing) - 0.5 * spacing;\n}\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\nfloat hollowBox(vec3 pos, float radius)\n{\n    return differenceSDF(box(pos, vec3(radius)), sphere(pos, radius*1.3));\n}\n\nfloat distfunc(vec3 pos, float radius)\n{\n    float hollowB = hollowBox(twist(repeat(pos, 10.0)), radius);\n    float sphereB = sphere(repeat(pos, 10.0), radius*0.75);\n    float shape = unionSDF(hollowB, sphereB);\n    glow += 0.1 / (0.1 + hollowB*hollowB);\n    return shape;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 cameraOrigin = vec3(0.0, 0.0, fract(iTime) * 10.0);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 upDirection = vec3(sin(iTime * 0.2), cos(iTime * 0.2), 0.0);\n    vec3 cameraDir = normalize(cameraOrigin - cameraTarget);\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n    \n    const int MAX_ITER = 128;\n    const float MAX_DIST = 275.0;\n    const float EPSILON = 0.001;\n\n    float totalDist = 0.0;\n    vec3 pos = cameraOrigin;\n    float dist = EPSILON;\n\n    float radius = 1.4;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distfunc(pos, radius);\n        totalDist += dist;\n        pos += dist * rayDir * 0.4;\n    }\n    \n    if (dist < EPSILON)\n    {\n        vec2 eps = vec2(0.0, EPSILON);\n\n        vec3 normal = normalize(vec3(\n            distfunc(pos + eps.yxx, radius) - distfunc(pos - eps.yxx, radius),\n            distfunc(pos + eps.xyx, radius) - distfunc(pos - eps.xyx, radius),\n            distfunc(pos + eps.xxy, radius) - distfunc(pos - eps.xxy, radius)));\n\n        float diffuse = max(0.0, dot(-rayDir, normal));\n        float specular = pow(diffuse, 32.0);\n        vec3 color = vec3(.2*sin(iTime*0.2) + 0.45,\n                          .2*cos(iTime*0.3) + 0.45,\n                          .2*sin(iTime*0.5) + 0.45) * (diffuse + specular) / (1. + totalDist * 0.05);\n\n        fragColor = vec4(color + glow*.01, 1.0);\n    }\n    else\n        fragColor = vec4(0.) + glow*.02;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}