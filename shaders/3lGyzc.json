{
    "Shader": {
        "info": {
            "date": "1611399037",
            "description": "Selective grain & simple radial blur applied except for an arbitrary quad. Inverse bilinear interpolation gives the appropriate UVs for the masking quad.",
            "flags": 0,
            "hasliked": 0,
            "id": "3lGyzc",
            "likes": 1,
            "name": "Fake Tilt Shift / Miniature",
            "published": 3,
            "tags": [
                "tiltshift",
                "selective",
                "miniature"
            ],
            "usePreview": 1,
            "username": "serkan3k",
            "viewed": 763
        },
        "renderpass": [
            {
                "code": "// to see borders of the arbitrary quad, make this 1\n#define DRAWBORDERS 0\n\n// https://iquilezles.org/articles/ibilinear\nfloat cross2d(in vec2 a, in vec2 b ) { \n    return a.x*b.y - a.y*b.x; \n}\nvec2 invBilinear(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n    float k2 = cross2d(g,f);\n    float k1 = cross2d(e,f) + cross2d(h,g);\n    float k0 = cross2d(h,e);\n    float w = k1*k1 - 4.0*k0*k2;\n    if(w<0.0) {\n        return vec2(-1.0);\n    }\n    w = sqrt(w);\n    float v = 2.0*k0/(-k1 - w); \n    if(v<0.0 || v>1.0) v = 2.0*k0/(-k1 + w);\n    float u = (h.x - f.x*v)/(e.x + g.x*v) ;\n    if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) {\n        return vec2(-1,0);\n    }\n    return vec2( u, v );\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length(pa - ba*h);\n}\n\nfloat rand(vec2 uv){\n return fract(sin(dot(uv, vec2(12.9898,78.233)))*43578.5453);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    fragColor = vec4(0.0);\n    vec2 a = vec2(-1,0.75);\n    vec2 b = vec2(1,0.75);\n    vec2 c = vec2(1.8,-0.5);\n    vec2 d = vec2(-1.8,-0.5);  //d = c + a -b;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mask_uv = invBilinear(p,a,b,c,d );\n    if( mask_uv.x>-1.0 && mask_uv.x < 1.0){\n        fragColor = vec4(texture(iChannel0, uv).xyz, 1.0);\n#if DRAWBORDERS\n        float h = 5.0/iResolution.y;\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,a,b)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,b,c)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,c,d)));\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), 1.0-smoothstep(h,2.0*h,sdSegment(p,d,a)));\n#endif\n    }\n    else{\n        float dist = 1.0; \n        int iterations = 10; \n        vec2 texel = 1.0 / iResolution.xy;\n        vec2 texel_dist = texel * dist;\n        for(int i = 0; i < iterations; i++){\n            float r1 = clamp(rand(uv * float(i))*2.0-1.0, -texel_dist.x, texel_dist.x);\n            float r2 = clamp(rand(uv * float(i+iterations))*2.0-1.0, -texel_dist.y, texel_dist.y);\n            fragColor += texture(iChannel0, uv + vec2(r1 , r2));\n        }\n        fragColor /= float(iterations);\n        float twopi = 6.28318530718;\n        float dir = 16.0; \n        float step = 4.0; \n        float size = 4.0; \n        vec2 radius = size/iResolution.xy;\n        for( float d=0.0; d<twopi; d+=twopi/dir){\n            for(float i=1.0/step; i<=1.0; i+=1.0/step){\n                fragColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*radius*i) ;\t\n            }\n        }\n        fragColor /= step * dir ;\n    }\n    fragColor.w = 1.0f;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}