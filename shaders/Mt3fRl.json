{
    "Shader": {
        "info": {
            "date": "1540591950",
            "description": "Illuminating a scene using a grid of lights sampled from the screen.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mt3fRl",
            "likes": 14,
            "name": "Movie Night",
            "published": 3,
            "tags": [
                "raytracing",
                "video",
                "lighting"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 693
        },
        "renderpass": [
            {
                "code": "vec3 movieScale = vec3(1)/blurDim.y;\nvec3 moviePos = vec3(-.5*blurDim.x/blurDim.y,0,2);\n\n\nfloat Lighting( vec3 pos, vec3 normal, vec3 lp )\n{\n    // maybe trace shadows for each light - to get better colouring in the shadows\n    vec3 d = lp-pos;\n    float l2 = dot(d,d);\n    d = normalize(d);\n    \n    // compute approximate area of the texel from this angle\n    vec2 dxy = sqrt(vec2(1)+.1-d.xy*d.xy)*movieScale.xy;\n    float area = dxy.x*dxy.y;\n    area /= l2; // divide by distance squared so it's angular area from this position\n//    area *= step(0.,d.z);// mask when behind\n    \n    \n    return max(0.,dot(normal,d))*area;\n}\n\n\nvec3 sampleLighting( in vec3 pos, in vec3 normal )\n{\n    vec3 light = vec3(0);\n    for ( int y=0; y < int(blurDim.y); y++ )\n    {\n\t    for ( int x=0; x < int(blurDim.x); x++ )\n        {\n            vec3 lp = vec3(vec2(x,y)+.5,0)*movieScale + moviePos;\n            vec3 lc = texelFetch(iChannel1,ivec2(x,y),0).rgb;\n            light += lc * Lighting( pos, normal, lp );\n        }\n    }\n    return light;\n}\n\n\nstruct Surface\n{\n    vec3 pos;\n    float dist;\n    vec3 norm;\n};\n\nSurface Trace( vec3 rayStart, vec3 rayDir )\n{\n    vec3 norm = vec3(0);\n    float t = 1e10;\n    \n    #define Plane(n,d) { float t2 = (d-dot(rayStart,n))/dot(rayDir,n); if ( t2 > 0. && t2 < t ) { t = t2; norm = n; } }\n    #define Sphere(p,r) { vec3 dp = p-rayStart; float d = dot(rayDir,dp); float s2 = dot(dp,dp)-d*d; if ( s2 < r*r ) { float t2 = d - sqrt(r*r-s2); if ( t2 > 0. && t2 < t ) { t = t2; norm = normalize(rayStart+t*rayDir-p); } } }\n    \n    Plane( vec3(0,1,0), -.0 );\n    Plane( vec3(1,0,0), -1.2 );\n    Plane( vec3(-1,0,0), -1.2 );\n    Plane( normalize(vec3(1,0,-.3)), -1.6 );\n    Plane( normalize(vec3(-1,0,-.3)), -1.6 );\n    Plane( vec3(0,0,-1), -2.2 );\n    Sphere( vec3(0,.5,-.4), .1 );\n    Sphere( vec3(0,.2,-.4), .2 );\n    Sphere( vec3(-.4,.45,-.4), .1 );\n    Sphere( vec3(.4,.5,-.4), .1 );\n    Sphere( vec3(.4,.2,-.4), .2 );\n\n    Sphere( vec3(.6,.35,.1), .1 );\n    Sphere( vec3(.6,.07,.1), .2 );\n    Sphere( vec3(.22,.4,.15), .1 );\n    Sphere( vec3(.2,.11,.15), .2 );\n    Sphere( vec3(-.2,.35,.1), .1 );\n    Sphere( vec3(-.2,.1,.1), .2 );\n    Sphere( vec3(-.6,.4,.12), .1 );\n    Sphere( vec3(-.6,.1,.12), .2 );\n\n    Sphere( vec3(.8,.3,.7), .1 );\n    Sphere( vec3(.8,.0,.7), .2 );\n    Sphere( vec3(.4,.3,.7), .1 );\n    Sphere( vec3(.4,.0,.7), .2 );\n    Sphere( vec3(.0,.3,.7), .1 );\n    Sphere( vec3(.0,.0,.7), .2 );\n    Sphere( vec3(-.4,.3,.7), .1 );\n    Sphere( vec3(-.4,.0,.7), .2 );\n    Sphere( vec3(-.8,.3,.7), .1 );\n    Sphere( vec3(-.8,.0,.7), .2 );\n    \n    vec3 pos = rayStart + rayDir*t;\n    return Surface( pos, t, norm );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 camPos = vec3(-.2,.8,-1);\n    vec3 camK = normalize(vec3(0,.5,0)-camPos);\n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    float zoom = .7;\n    vec3 ray = vec3(fragCoord-iResolution.xy*.5,zoom*length(iResolution.xy));\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    Surface surf = Trace( camPos, ray );\n    \n    vec3 light = sampleLighting( surf.pos, surf.norm );\n    fragColour.rgb = light * vec3(.95);\n    \n    // composite screen\n    vec3 n = vec3(0,0,-1);\n\tfloat t = (moviePos.z*n.z-dot(camPos,n))/dot(ray,n);\n    if ( t > 0. && t < surf.dist )\n    {\n        vec2 uv = camPos.xy + ray.xy*t;\n        uv = (uv-moviePos.xy)/movieScale.xy;\n        uv /= blurDim;\n        \n        float bound = min(min(uv.x,uv.y),min(1.-uv.x,1.-uv.y));\n        if ( bound >= 0. )\n            fragColour.rgb = mix( fragColour.rgb, texture(iChannel0,uv).rgb, smoothstep(.0,.01,bound) );\n    }\n\n    // exposure\n    fragColour.rgb *= 1.5;\n    \n\tfragColour.rgb = pow(fragColour.rgb,vec3(1./2.2));\n    \n    fragColour.a = 1.;\n//    fragColour = texelFetch(iChannel1,ivec2(uv*blurDim),0);\n//    fragColour = texelFetch(iChannel0,ivec2(fragCoord),0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColour = pow(texture(iChannel0,uv),vec4(2.2));\n    \n    const vec3 componentWeights = vec3(.299,.587,.114);\n    float mask = smoothstep( .1, .2, dot( abs(fragColour.rgb - vec3(0,.373,0)), componentWeights ) );\n    vec3 bg = vec3(.003,.006,.009);//.03*(.5,+.5*sin(vec3(0)+vec3(4,8,7)*fragCoord.y/iResolution.y+vec3(1,3,2)*iTime));\n    fragColour.rgb = mix( bg, fragColour.rgb, mask );\n    \n    // flicker\n    fragColour.rgb *= mix( 1., .5+.5*sin(iTime*24.*6.283185), .1 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// downsample the video\n\n// this is an optimal distribution of 4-dimensional points\n// and .yw is close to optimal for 2D\n// from: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec4 Quasirand( uint seed )\n{\n\treturn vec4(\n\t\tfloat(seed*0xDB4F0B91U)/exp2(32.),\n\t\tfloat(seed*0xBBE05633U)/exp2(32.),\n\t\tfloat(seed*0xA0F2EC76U)/exp2(32.),\n\t\tfloat(seed*0x89E18285U)/exp2(32.)\n\t);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv0 = fragCoord/blurDim;\n    \n    fragColour = vec4(0);\n    \n    uint n = 256U; // lower numbers work okay, but for the google turbine get flicker even at 64\n    for ( uint i=0U; i < n; i++ )\n    {\n        vec4 r = Quasirand(i);\n        \n        vec2 uv = uv0 + (r.yw-.5)/blurDim;\n\n        if ( min(uv.x,uv.y) >= 0. && max(uv.x,uv.y) <= 1. ) fragColour += texture(iChannel0,uv);\n\t}\n    fragColour /= float(n);\n    fragColour = fragColour;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec2 blurDim = vec2(16,9)*1.;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}