{
    "Shader": {
        "info": {
            "date": "1672620823",
            "description": "Wave function collapse-like shader of an Celtic knot pattern. The blurry tiles show all the remaining possible matches given the existing neighbors, superimposed.\n\n*mouse camera*\n*key up/down zoom* \n*space to reset sim*\n*shift-space also resume attract*",
            "flags": 48,
            "hasliked": 0,
            "id": "mtfGWX",
            "likes": 29,
            "name": "Celtic Knotwork WFC",
            "published": 3,
            "tags": [
                "knot",
                "celtic",
                "wfc",
                "wavefunctioncollapse"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 334
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Another in my series trying to do something similar to the \"simple tiled model\" of \n//  Wave Function Collapse:\n//\n//      https://github.com/mxgmn/WaveFunctionCollapse\n//\n//  My other WFC shaders:\n//\n//      Simple Wave Function Collapse     https://shadertoy.com/view/DdfSzj\n//      Circuit Board WFC                 https://shadertoy.com/view/mdBSRW\n//      Roguelike Dungeon WFC             https://shadertoy.com/view/ddSXzW\n//      Tiny Town WFC                     https://shadertoy.com/view/ds2XzD\n//      Raymarched Circuit Board WFC      https://shadertoy.com/view/mdjSDz\n//      Superposition Weave WFC           https://shadertoy.com/view/Ds2XRV\n//\n//  For this shader I abandoned the sprite rendering in favor of SDFs, so I could get\n//  higher resolution tiles. I was inspired by Ben Griffin's Knot project and typeface:\n//\n//      https://github.com/MrBenGriffin/Knot\n//      https://fontlibrary.org/en/font/knots\n//\n//  Of course his patterns are cooler than mine are, so far. I'd like to add the dragon\n//  heads and tails, but I'm afraid of the number of tile types exploding. Tune in to\n//  the next shader to find out if I succeed!\n//  \n//  Buffer A computes the wave function collapse\n//  Buffer B handles camera controls\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec3 BACKGROUND = vec3(.1, 0, 0);\nconst vec3 LINES = vec3(.4, .4, 0);\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rotate(float a)\n{\n    vec2 sc = vec2(sin(a), cos(a));\n    return mat2(sc.y, sc.x, -sc.x, sc.y);\n}\n\n// cell distance functions\nvec3 spEmpty(vec2 p)\n{\n    return BACKGROUND;\n}\n\nfloat sdIStSt(vec2 p)\n{\n    return min(abs(p.x - 2.), abs(p.x - 6.)) - 1.;\n}\n\nconst float ARC_ANGLE = PI / 8.;\nconst vec2 ARC_SC = vec2(sin(ARC_ANGLE), cos(ARC_ANGLE));\n\nfloat sdCross(vec2 p)\n{\n    float dist = sdArc(rotate(5. * PI / 8.) * (p - vec2(4, 2.85)), ARC_SC, 2., 1.);\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(2.8, 1.37)), vec2(.35, 1)));\n    return dist;\n}\n\nfloat sdIStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 7), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(6, 7), vec2(1, 4)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdICrCr(vec2 p)\n{\n    const float BIG_ARC_ANGLE = 2. * PI / 8.;\n    const vec2 BIG_ARC_SC = vec2(sin(BIG_ARC_ANGLE), cos(BIG_ARC_ANGLE));\n    float dist = sdArc(rotate(4. * PI / 8.) * (p - vec2(1.65, 4)), BIG_ARC_SC, 4.5, 1.);\n    dist = min(dist, sdArc(rotate(-4. * PI / 8.) * (p - vec2(6.35, 4)), BIG_ARC_SC, 4.5, 1.));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p - vec2(4, 0)), vec2(1, 1.5)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1.5, 1.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p * -1. + vec2(4, 8)), vec2(1, 1.5)));\n\n    return dist;\n}\n\nfloat sdEndCorner(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 4), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(4, 6), vec2(3, 1)));\n    dist = min(dist, sdCross(p));\n    return dist;\n}\n\nfloat sdEndFoot(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 1), vec2(1, 1));\n    dist = min(dist, sdBox(p - vec2(6, 1), vec2(1, 1)));\n    const float a = PI / 2.;\n    const vec2 sc = vec2(sin(a), cos(a));\n    dist = min(dist, sdArc((p - vec2(4, 2)), sc, 2., 1.));\n    return dist;\n}\n\nfloat sdCornerStSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(5, 2), vec2(4, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 6.5), vec2(1, 1.5)));\n    dist = min(dist, sdBox(p - vec2(6.5, 6), vec2(1.5, 1)));\n    return dist;\n}\n\nfloat sdCornerCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 4));\n    dist = min(dist, sdBox(p - vec2(4, 2), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4., 0.)), vec2(1.5, 1.)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.85, 1.32)), vec2(.25, 1)));\n\n    return dist;\n}\n\nfloat sdCornerStCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(5, 2), vec2(4, 1));\n    dist = min(dist, sdBox(p - vec2(2, 4), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(8, 6), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.9, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2.0, 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(5.3, 1.22)), vec2(.35, 1)));\n\n    return dist;\n}\n\nfloat sdCornerCrCr(vec2 p)\n{\n    float dist = sdBox(p - vec2(3, 2), vec2(2, 1));\n    dist = min(dist, sdBox(p - vec2(2, 3), vec2(1, 2)));\n\n    vec2 p1 = rotate(PI / -2.) * (p - vec2(8, 0));\n    \n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p1 - vec2(4, 3)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p1 - vec2(4, 0)), vec2(1.5, 1)));\n\n    vec2 p2 = rotate(PI / -2.) * (p.yx - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(11. * PI / 8.) * (p2 - vec2(4, 2.85)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 1)));\n    dist = min(dist, sdBox(rotate(-PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1.5, 2.5)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(7, 3)), vec2(1, 2.75)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(6.67, 5.15)), vec2(.25, .99)));\n\n    return dist;\n}\n\nfloat sdTStCrSt(vec2 p)\n{\n    float dist = sdBox(p - vec2(2, 5), vec2(1, 6));\n    dist = min(dist, sdBox(p - vec2(6, .5), vec2(1, 1)));\n    dist = min(dist, sdBox(p - vec2(6, 8), vec2(1, 1)));\n    \n    vec2 p2 = rotate(PI / -2.) * (p - vec2(8, 0));\n\n    dist = min(dist, sdArc(rotate(-PI / 8.) * (p2 - vec2(6.85, 0)), ARC_SC, 2., 1.));\n    dist = min(dist, sdArc(rotate(PI / 8.) * (p2 - vec2(1.35, 0)), ARC_SC, 2., 1.));\n    dist = max(dist, -sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1.5, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(4, 0)), vec2(1, 2)));\n    dist = min(dist, sdBox(rotate(PI / 4.) * (p2 - vec2(2.9, 1.3)), vec2(.25, .99)));\n\n    return dist;\n}\n\nvec3 spCell(vec2 p, int type, float zoom)\n{\n    float dist = 1e6;\n    \n    if (type == I_ST_ST)           dist = sdIStSt(p);\n    else if (type == I_ST_CR)      dist = sdIStCr(p);\n    else if (type == I_CR_CR)      dist = sdICrCr(p);\n    else if (type == END_CR)       dist = sdEndCorner(p);\n    else if (type == END_FOOT)     dist = sdEndFoot(p);\n    else if (type == CORNER_ST_ST) dist = sdCornerStSt(p);\n    else if (type == CORNER_CR_ST) dist = sdCornerCrSt(p);\n    else if (type == CORNER_ST_CR) dist = sdCornerStCr(p);\n    else if (type == CORNER_CR_CR) dist = sdCornerCrCr(p);\n    else if (type == T_ST_CR_ST)   dist = sdTStCrSt(p);\n    \n    return vec3(mix(LINES, BACKGROUND, smoothstep(0., zoom * 10., dist)));\n}\n\nvec2 rot90(vec2 v, int r)\n{\n    if (r == 0) return v;\n    if (r == 1) return vec2(v.y, 8. - v.x);\n    if (r == 2) return 8. - v;\n    if (r == 3) return vec2(8. - v.y, v.x);\n}\n\nvec4 render( vec2 u, fxState state, float zoom )\n{\n    u = (u - .5 * iResolution.xy) * zoom + state.center * iResolution.y + .5 * iResolution.xy;\n    vec2 p = fract(u) * 8.;\n    \n    if (u.x < 1. ||\n        u.x >= iResolution.x - 1. ||\n        u.y < 1. ||\n        u.y >= iResolution.y - 1.) return vec4(spEmpty(p), 1);\n\n    uvec4 valid = floatBitsToUint(texelFetch(iChannel0, ivec2(u), 0));\n    if (valid == uvec4(0)) return vec4(spEmpty(p), 1);\n    \n    vec4 c = vec4(0);\n    for (int rot = 0; DONT_UNROLL && rot < 4; ++rot)\n    {\n        uint bit = 1u;\n        for (int type = 0; DONT_UNROLL && type < NUM_TILES; ++type)\n        {\n            if ((valid[rot] & bit) != 0u)\n            {\n                c += vec4(spCell(rot90(p,rot), type, zoom), 1);\n            }\n            bit <<= 1;\n        }\n    }\n\n    return c / c.a;\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    fxState state = fxGetState();\n    if (state.zoomFade > 0.)\n    {\n        vec4 c = render(u, state, state.zoom);\n        vec4 n = render(u, state, state.nextZoom);\n        O = mix(n, c, state.zoomFade);\n    }\n    else\n        O = render(u, state, state.zoom);\n        \n    O = sqrt(O);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const uvec4 MAX_UVEC4 = uvec4(0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);\n#define DONT_UNROLL min(iFrame,0) >= 0\n\nconst float PI = 3.141592653589793;\n\nconst int EMPTY = 0;\nconst int I_ST_ST = 1;\nconst int I_ST_CR = 2;\nconst int I_CR_CR = 3;\nconst int END_CR = 4;\nconst int END_FOOT = 5;\nconst int CORNER_ST_ST = 6;\nconst int CORNER_CR_ST = 7;\nconst int CORNER_ST_CR = 8;\nconst int CORNER_CR_CR = 9;\nconst int T_ST_CR_ST = 10;\nconst int NUM_TILES = 11;\n\n// Integer Hash - II by iq\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\n\nvec3 hash3( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nint countBits(uint n)\n{\n    int count = 0;\n    while (n != 0u)\n    {\n        n &= (n - 1u);\n        count++;\n    }\n    return count;\n}\n\nint countBits(uvec4 v)\n{\n    return countBits(v.x) + countBits(v.y) + countBits(v.z) + countBits(v.w);\n}\n\nint log2int(uint n)\n{\n    int bits = 0;\n\n    if (n > 0xffffu)\n    {\n        n >>= 16u;\n        bits = 16;\n    }\n\n    if (n > 0xffu)\n    {\n        n >>= 8u;\n        bits += 8;\n    }\n\n    if (n > 0xfu)\n    {\n        n >>= 4u;\n        bits += 4;\n    }\n\n    if (n > 0x3u)\n    {\n        n >>= 2u;\n        bits += 2;\n    }\n\n    if (n > 0x1u)\n    {\n        bits += 1;\n    }\n    \n    return bits;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define KEY_SHIFT 16\n#define KEY_SPACE 32\n#define KEY_UP 38\n#define KEY_DOWN 40\n\nstruct fxState\n{\n    vec2 center;\n    float resolution;\n    float zoom;\n    float nextZoom;\n    float zoomFade;\n    float time;\n    bool attract;\n};\n\nfxState fxGetStateInternal(sampler2D sampler)\n{\n    vec4 data0 = texelFetch(sampler, ivec2(0), 0);\n    vec4 data1 = texelFetch(sampler, ivec2(1, 0), 0);\n    fxState state;\n    state.center = data0.xy;\n    state.resolution = data0.z;\n    state.attract = data0.w != 0.;\n    state.zoom = data1.x;\n    state.time = data1.y;\n    state.nextZoom = data1.z;\n    state.zoomFade = data1.w;\n    return state;\n}\n\n#define fxGetState() fxGetStateInternal(iChannel1)\n\nvec4 fxPutState(fxState state, ivec2 ifc)\n{\n    if (ifc == ivec2(0))\n    {\n        return vec4(state.center, state.resolution, state.attract ? 1. : 0.);\n    }\n    \n    return vec4(state.zoom, state.time, state.nextZoom, state.zoomFade);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Computes the remaining possibilities for each square (aka entropy). Each component \n// corresponds to a rotation, and within that each bit is a valid tile possibility.\n// ---------------------------------------------------------------------------------------\n\n// cell shapes\nconst mat3 S_EMPTY =\n    mat3(0,0,0,\n         0,0,0,\n         0,0,0);\n         \nconst mat3 S_I_ST_ST =\n    mat3(0,1,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_I_ST_CR =\n    mat3(0,1,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_I_CR_CR =\n    mat3(0,2,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_CR =\n    mat3(0,0,0,\n         0,1,0,\n         0,2,0);\n         \nconst mat3 S_END_FOOT =\n    mat3(0,0,0,\n         0,1,0,\n         0,1,0);\n         \nconst mat3 S_CORNER_ST_ST =\n    mat3(0,1,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_CORNER_ST_CR =\n    mat3(0,2,0,\n         0,1,1,\n         0,0,0);\n         \nconst mat3 S_CORNER_CR_CR =\n    mat3(0,2,0,\n         0,1,2,\n         0,0,0);\n         \nconst mat3 S_T_ST_CR_ST =\n    mat3(0,1,0,\n         0,1,2,\n         0,1,0);\n         \n         \nmat3 shCell(int type)\n{\n    if (type == EMPTY)          return S_EMPTY;\n    if (type == I_ST_ST)        return S_I_ST_ST;\n    if (type == I_ST_CR)        return S_I_ST_CR;\n    if (type == I_CR_CR)        return S_I_CR_CR;\n    if (type == END_CR)         return S_END_CR;\n    if (type == END_FOOT)       return S_END_FOOT;\n    if (type == CORNER_ST_ST)   return S_CORNER_ST_ST;\n    if (type == CORNER_CR_ST)   return S_CORNER_CR_ST;\n    if (type == CORNER_ST_CR)   return S_CORNER_ST_CR;\n    if (type == CORNER_CR_CR)   return S_CORNER_CR_CR;\n    /*if (type == T_ST_CR_ST)*/ return S_T_ST_CR_ST;\n}\n\n// cell probabilities\nfloat probCell(int type)\n{\n    if (type == EMPTY)          return 0.;\n    if (type == I_ST_ST)        return .1;\n    if (type == I_ST_CR)        return .1;\n    if (type == I_CR_CR)        return .1;\n    if (type == END_CR)         return .1;\n    if (type == END_FOOT)       return .1;\n    if (type == CORNER_ST_ST)   return .1;\n    if (type == CORNER_CR_ST)   return .1;\n    if (type == CORNER_ST_CR)   return .1;\n    if (type == CORNER_CR_CR)   return .1;\n    /*if (type == T_ST_CR_ST)*/ return .1;\n\n}\n\n// cell self-connection ability\nbool selfCell(int type)\n{\n    return type == I_ST_ST || type == I_ST_CR || type == I_CR_CR;\n}\n\n#define R1(m) mat3(m[0][2], m[1][2], m[2][2], m[0][1], m[1][1], m[2][1], m[0][0], m[1][0], m[2][0])\n\n// rotate a shape matrix r times to the right\n// NOTE: R1(R1(R1(s))) seems wasteful, but I originally had R2 and R3 and it didn't seem to matter. I believe the optimizer is\n// able to optimize away the extra calculations.\nmat3 rotShape(mat3 s, int r)\n{\n    while (r < 0) r += 4;\n    r = r % 4;\n    if (r == 1) s = R1(s);\n    else if (r == 2) s = R1(R1(s));\n    else if (r == 3) s = R1(R1(R1(s)));\n    \n    return s;\n}\n\nbool tilesMatch(mat3 a, mat3 b) { return a[0][0] == b[2][0] && a[0][1] == b[2][1] && a[0][2] == b[2][2]; }\n\n// compute a bit mask showing which tiles could be compatible with a specfic other tile along one side\nuvec4 findValidTiles(int t, int d, int r)\n{\n    uvec4 valid = uvec4(0);\n    mat3 nShape = rotShape(shCell(t), d + r);\n    uint bit = 2u;\n    \n    for (int i = 1; i < NUM_TILES; ++i)\n    {\n        if (t != i || selfCell(i))\n        {\n            mat3 myShape = shCell(i);\n            for (int d = 0; d < 4; ++d)\n            {\n                if (tilesMatch(rotShape(myShape, d), nShape))\n                {\n                    valid[(d + 4 - r) % 4] |= bit;\n                }\n            }\n        }\n        bit <<= 1;\n    }\n    return valid;\n}\n\nivec2 nDir(int d)\n{\n    if (d == 0) return ivec2(0, 1);\n    if (d == 1) return ivec2(1, 0);\n    if (d == 2) return ivec2(0, -1);\n    /*if (d == 0)*/ return ivec2(-1, 0);\n}\n\n// how many components of the vector, from left to right, are all full of zeroes\nint emptyWords(uvec4 v, out uint top)\n{\n    int n = 0;\n    top = v.x;\n    if (v.x == 0u)\n    {\n        ++n;\n        top = v.y;\n        if (v.y == 0u)\n        {\n            top = v.z;\n            ++n;\n            if (v.z == 0u)\n            {\n                ++n;\n                top = v.w;\n            }\n        }\n    }\n    return n;\n}\n\n// this shouldn't be necessary, but just calling the function directly seems not to work (compiler bug...?)\nvec4 ubtf(uvec4 v)\n{\n    return uintBitsToFloat(v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fxState state = fxGetState();\n    ivec2 ifc = ivec2(fragCoord);\n    if (keyDown(KEY_SPACE) ||\n        iFrame == 0 ||\n        state.resolution < 0. ||\n        ifc.x == 0 || // establish boundary so we don't have to check during simulation\n        ifc.x == int(iResolution.x) - 1 ||\n        ifc.y == 0 ||\n        ifc.y == int(iResolution.y) - 1)\n    {\n        // reset\n        fragColor = uintBitsToFloat(MAX_UVEC4);\n        \n        // seed one pixel in the middle of the field\n        if (ifc == ivec2(iResolution.xy * vec2(.280, .652))) fragColor = ubtf(uvec4(2, 0, 0, 0));\n        \n        return;\n    }\n\n    fragColor = texelFetch(iChannel0, ifc, 0);\n\n    // update on staggered checkerboard pattern, to ensure no cell updates at the same time as its neighbor\n    if (((ifc.x + ifc.y) & 1) != (iFrame & 1)) return;\n    \n    vec3 h = hash3(uvec3(ifc, iFrame));\n    if (countBits(floatBitsToUint(fragColor)) == 1)\n    {\n        // if we've collapsed to a single state already, only just consider backtracking, sometimes\n        if (h.x < .25)\n        {\n            for (int d = 0; d < 4; ++d)\n            {\n                uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n                if (n == uvec4(0))\n                {\n                    fragColor = uintBitsToFloat(MAX_UVEC4); // neighbor is in trouble, revert\n                    return;\n                }\n\n            }\n        }\n        \n        return;\n    }\n\n    // compute the valid placements given our non-empty neighbors\n    uvec4 valid = MAX_UVEC4;\n    for (int d = 0; d < 4; ++d)\n    {\n        uvec4 n = floatBitsToUint(texelFetch(iChannel0, ifc + nDir(d), 0));\n        if (n != MAX_UVEC4)\n        {\n            if (countBits(n) == 1) // neighbor has collapsed to a single state, use it to limit our own possibilities\n            {\n                uint top;\n                int rot = emptyWords(n, top);\n                int type = log2int(top);\n\n                uvec4 nResult = findValidTiles(type, rot, d);\n\n                valid &= nResult;\n                if (valid == uvec4(0)) break;\n            }\n        }\n    }\n    \n    if (valid == MAX_UVEC4)\n    {\n        // if we have no collapsed neighbors, there's a chance we might collapse spontaneously\n        if (h.x < 1e-5)\n        {\n            valid = uvec4(0);\n            int rot = int(h.y * 1000.) % 4;\n            int type = int(h.z * 1000.) % NUM_TILES;\n            valid[rot] = (1u << type);\n        }\n    }\n    else // if we have collapsed neighbors, consider collapsing ourseles\n    {\n        uint top;\n        int rot = emptyWords(valid, top);\n        int numValid = countBits(valid);\n        int choice = int(h.y * 1000.) % numValid;\n        \n        // strip off 1 bit, \"choice\" times\n        while(choice > 0)\n        {\n            top &= (top - 1u);\n            if (top == 0u)\n            {\n                valid[rot] = 0u;\n                top = valid[++rot];\n            }\n            if (rot > 3) break;\n            choice--;\n        }\n        \n        // last remaining highest bit is chosen one\n        int type = log2int(top);\n        \n        // last chance rejection by probability, unless we're the only choice left\n        if (h.z < probCell(type) || numValid == 1)\n        {\n            // install the chosen valid tile\n            valid = uvec4(0);\n            valid[rot] = (1u << type);\n        }\n    }\n\n    fragColor = uintBitsToFloat(valid);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Just for handling persistent state: camera position and zoom level.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    if (ifc != ivec2(0) && ifc != ivec2(1, 0)) { discard; }\n    \n    const float START_ZOOM = 1./256.;\n    fxState state = fxGetState();\n    if (iFrame == 0 || keyClick(KEY_SPACE) && keyDown(KEY_SHIFT) || iResolution.x * iResolution.y != abs(state.resolution))\n    {\n        state.center = vec2(0);\n        state.resolution = -iResolution.x * iResolution.y;\n        state.nextZoom = state.zoom = START_ZOOM * 1000. / iResolution.y;\n        state.time = 0.;\n        state.zoomFade = 0.;\n        state.attract = true;\n        \n        fragColor = fxPutState(state, ifc);\n\n        return;\n    }\n\n    state.resolution = abs(state.resolution);\n    state.time += iTimeDelta;\n    if (state.zoomFade > 0.)\n    {\n        state.zoomFade -= iTimeDelta;\n        if (state.zoomFade < 0.)\n        {\n            state.zoomFade = 0.;\n            state.zoom = state.nextZoom;\n        }\n    }\n\n    if (iMouse.z > 0.)\n    {\n        state.attract = false;\n        state.center = (iMouse.xy - iResolution.xy*.5) / iResolution.y;\n    }\n\n    if (keyClick(KEY_UP))\n    {\n        state.nextZoom = min(state.nextZoom, state.zoom) * .5;\n        state.zoomFade = 1.;\n        state.attract = false;\n    }\n    if (keyClick(KEY_DOWN))\n    {\n        state.nextZoom = max(state.nextZoom, state.zoom) * 2.;\n        state.nextZoom = min(1., state.nextZoom);\n        state.zoomFade = 1.;\n        state.attract = false;\n    }\n\n    if (state.attract)\n    {\n        state.center = .42*vec2(sin(state.time/iResolution.y - 1.2), cos(state.time/iResolution.y - 1.2));\n        float zoom = pow(.5, floor(3. - mod(state.time / 4., 3.))) * 4. * START_ZOOM * 1000. / iResolution.y;\n        if (zoom != state.zoom && zoom != state.nextZoom)\n        {\n            state.nextZoom = zoom;\n            state.zoomFade = 1.;\n        }\n    }\n    \n    fragColor = fxPutState(state, ifc);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}