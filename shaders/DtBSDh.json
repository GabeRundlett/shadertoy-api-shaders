{
    "Shader": {
        "info": {
            "date": "1675960565",
            "description": "Forked from Leon's donut sketch",
            "flags": 0,
            "hasliked": 0,
            "id": "DtBSDh",
            "likes": 0,
            "name": "Donut Slug",
            "published": 3,
            "tags": [
                "cartoon",
                "window",
                "donut"
            ],
            "usePreview": 0,
            "username": "drliquidglitch",
            "viewed": 191
        },
        "renderpass": [
            {
                "code": "// Fork of leon's Tribute\n// using code from IQ, Mercury, LJ, Duke, Koltes\n\n// tweak it\n#define donut 30.\n#define cell 3.\n#define height 2.\n#define thin .04\n#define radius 15.\n#define speed 1.\n#define wigglex 0.2*sin(time)\n#define wiggley 0.8\n\n#define STEPS 100.\n#define VOLUME 0.001\n#define PI 3.14159\n#define TAU (2.*PI)\n#define time iTime\n\n// raymarching toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdDisk (vec3 p, vec3 s) { return max(max(length(p.xz)-s.x, s.y), abs(p.y)-s.z); }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat sdTorus( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat amodIndex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); return c; }\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nvec2 repeat (vec2 v, vec2 c) { return mod(v,c)-c/2.; }\nvec3 repeat (vec3 v, float c) { return mod(v,c)-c/2.; }\nfloat smoo (float a, float b, float r) { return clamp(.5+.5*(b-a)/r, 0., 1.); }\nfloat smin (float a, float b, float r) { float h = smoo(a,b,r); return mix(b,a,h)-r*h*(1.-h); }\nfloat smax (float a, float b, float r) { float h = smoo(a,b,r); return mix(a,b,h)+r*h*(1.-h); }\nvec2 displaceLoop (vec2 p, float r) { return vec2(length(p.xy)-r, atan(p.y,p.x)); }\nfloat map (vec3);\nfloat getShadow (vec3 pos, vec3 at, float k) {\n    vec3 dir = normalize(at - pos);\n    float maxt = length(at - pos);\n    float f = 01.;\n    float t = VOLUME*50.;\n    for (float i = 0.; i <= 1.; i += 1./15.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        f = min(f, k * dist / t);\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return f;\n}\nvec3 getNormal (vec3 p) { vec2 e = vec2(.01,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }\n\nvoid camera (inout vec3 p) {\n    p.xz *= rot(PI/8.);\n    p.yz *= rot(PI/6.);\n}\n\nfloat windowCross (vec3 pos, vec4 size, float salt) {\n    vec3 p = pos;\n    float sx = size.x * (.6+salt*.4);\n    float sy = size.y * (.3+salt*.7);\n    vec2 sxy = vec2(sx,sy);\n    p.xy = repeat(p.xy+sxy/2., sxy);\n    float scene = sdBox(p, size.zyw*2.);\n    scene = min(scene, sdBox(p, size.xzw*2.));\n    scene = max(scene, sdBox(pos, size.xyw));\n    return scene;\n}\n\nfloat window (vec3 pos, vec2 dimension, float salt) {\n    float thinn = .008;\n    float depth = .04;\n    float depthCadre = .06;\n    float padding = .08;\n    float scene = windowCross(pos, vec4(dimension,thinn,depth), salt);\n    float cadre = sdBox(pos, vec3(dimension, depthCadre));\n    cadre = max(cadre, -sdBox(pos, vec3(dimension - padding, depthCadre*2.)));\n    scene = min(scene, cadre);\n    return scene;\n}\n\nfloat boxes (vec3 pos, float salt) {\n    vec3 p = pos;\n    float ry = cell * .43*(.3+salt);\n    float rz = cell * .2*(.5+salt);\n    float salty = rng(vec2(floor(pos.y/ry), floor(pos.z/rz)));\n    pos.y = repeat(pos.y, ry);\n    pos.z = repeat(pos.z, rz);\n    float scene = sdBox(pos, vec3(.1+.8*salt+salty,.1+.2*salt,.1+.2*salty));\n    scene = max(scene, sdBox(p, vec3(cell*.2)));\n    return scene;\n}\n\nfloat map (vec3 pos) {\n    vec3 camOffset = vec3(-4,0,0.);\n\n    float scene = 1000.;\n    vec3 p = pos + camOffset;\n    float segments = PI*radius;\n    float indexX, indexY, salt;\n    vec2 seed;\n\n    // donut distortion\n    vec3 pDonut = p;\n    pDonut.x += donut;\n    pDonut.y += radius;\n    pDonut.xz = displaceLoop(pDonut.xz, donut);\n    pDonut.z *= donut;\n    pDonut.xzy = pDonut.xyz;\n    pDonut.xz *= rot(time*.05*speed);\n\n    // ground\n    p = pDonut;\n    scene = min(scene, sdCylinder(p.xz, radius-height));\n\n    // walls\n    p = pDonut;\n    float py = p.y + time * speed;\n    indexY = floor(py / (cell+thin));\n    p.y = repeat(py, cell+thin);\n    scene = min(scene, max(abs(p.y)-thin, sdCylinder(p.xz, radius)));\n    amod(p.xz, segments);\n    p.x -= radius;\n    scene = min(scene, max(abs(p.z)-thin, p.x));\n\n\n    // elements\n    p = pDonut;\n    p.xz *= rot(PI/segments);\n    py = p.y + cell/2. + time * speed;\n    indexY = floor(py / (cell+thin));\n    p.y = repeat(py, cell+thin);\n    indexX = amodIndex(p.xz, segments);\n    amod(p.xz, segments);\n    seed = vec2(indexX, indexY);\n    salt = rng(seed);\n    p.x -= radius - height;\n    scene = max(scene, boxes(p, salt));\n\n    return scene;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord ) {\n    vec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    uv.x += wigglex*sin(time+(11.0*uv.y));\n    uv.y += wiggley*cos(time+uv.x*uv.y);\n    uv.xy *= rot((1.+sin(time)));\n    vec3 eye = vec3(15.0*sin(time),20.0*cos(time),-100.0+(sin(time)*80.0));\n    vec3 ray = normalize(vec3(uv, 1.3*abs(sin(time))));\n    camera(eye);\n    camera(ray);\n    float dither = rng(uv+fract(time));\n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += 1./STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME) {\n            shade = 1.-i;\n            break;\n        }\n        dist *= .5 + .1 * dither;\n        pos += ray * dist;\n    }\n    vec3 light = vec3(40.,100.,-10.);\n    float shadow = getShadow(pos, light, 4.);\n    color = vec4(1);\n    color *= shade;\n    color *= shadow;\n    color = smoothstep(.0, .5, color);\n    color.r *= 1.0/dither;\n    color.g += uv.y-uv.x;\n    color.b -= uv.y+uv.x;\n    color.rgb = sqrt(color.rgb);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}