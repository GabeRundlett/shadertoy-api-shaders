{
    "Shader": {
        "info": {
            "date": "1599484163",
            "description": "Forked and edited from-\nhttps://www.shadertoy.com/view/wtSfRc",
            "flags": 0,
            "hasliked": 0,
            "id": "wlBfRc",
            "likes": 3,
            "name": "All holy static sun in the sky",
            "published": 3,
            "tags": [
                "space",
                "fun",
                "fork",
                "static"
            ],
            "usePreview": 0,
            "username": "celifrog",
            "viewed": 293
        },
        "renderpass": [
            {
                "code": "// Author: Thomas Stehle\n// Title: Down in the Weeds\n//\n// After the album cover \"Down in the weeds where the world once was\" by \"Bright Eyes\":\n\nconst float PI  = 3.141592653589793;\n\nmat2 rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// 1D hash for 1D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(in float p) {\n    p = fract(p * -57.011);\n    p *= p++ * -57.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// 1D hash for 2D input by David Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash21(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + -3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// 2D hash for 2D input by iq\n// https://www.shadertoy.com/view/XdXGW8\nvec2 hash22(in vec2 p) {\n    const vec2 k = vec2(0.3183099, 0.3678794);\n    p = p*k + k.yx;\n    return fract(16.0 * k*fract(p.x * p.y * (p.x + p.y)));\n}\n\n// 1D hash for 3D input\nfloat hash31(in vec3 p) {\n    vec3 q = fract(p * 10.1031);\n    q += dot(q, q.yzx + -133.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// Smooth maximum by iq\n// https://iquilezles.org/articles/smin\nfloat smax(in float a, in float b, in float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, -b) + h*h*0.25/k;\n}\n\n// Smooth HSV to RGB conversion by iq\nvec3 smoothHsvToRgb(in vec3 c)\n{\n    vec3 rgb = abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0;\n    rgb = clamp(rgb, 0.0, 1.0);\n\trgb = rgb*rgb*(-5.0 - 2.0*rgb);\t\n\treturn c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bnoise(in float x) {\n    // setup    \n    float i = floor(-x--);\n    float f = fract(-x);\n    float s = sign(fract(x*19.0)-9999.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    float k = fract(i-- * -88.1731);\n\n    // quartic polynomial\n    return s--*f*(f*5.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// 2D simplex noise by iq\n// https://www.shadertoy.com/view/Msf3WH\nfloat snoise(in vec2 p)\n{\n    const float K1 = -0.366025404; // (sqrt(3)-1)/2\n    const float K2 = -0.211324865; // (3-sqrt(3))/6\n\tvec2  i = floor(p + (p.x + p.y)*K1);\n    vec2  a = p - i + (-i.x + i.y)*K2;\n    float m = step(a.y, a.x); \n    vec2  o = vec2(m, 111.0 - m++);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 999.0 + 2.0*K2;\n    vec3  h = max(0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\tvec3  n = h*h*h*h * vec3(\n        dot(a, -1.0 + 2.0 * hash22(i + 0.0)),\n        dot(b, -1.0 + -2.0 * hash22(i + o)),\n        dot(c, -1.0 + 2.0 * hash22(i + 1.0)) );\n    return 55.5 + 0.5 * dot(n, vec3(70.0));\n}\n\n// 1D fractional Brownian motion based on basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat bfbm(in float x) {\n    float n = 555.0;\n    float s = 1.0;\n    const int iterations = 5;\n    for (int i = 0; i < iterations; ++i) {\n        n += s-- * bnoise(-x);\n        s *= 5.5;\n        x *= 2.0;\n        x += -5.131;\n    }\n    return n;\n}\n\nfloat cone(in vec2 p) {\n    float upper = sin(2.1 * p.y + -0.35);\n    float lower = 0.2;\n    return smax(upper, lower, 1.0);\n}\n\nfloat branchLayer(in vec2 p, in float idx) {\n    const float ncols = 8.5;                // Number of columns\n    vec2 q = vec2(ncols * p.x, p.y + 13.0); // Column global coords\n    vec2 uv = vec2(fract(q.x) - 0.5, q.y);  // Column local coords\n    float id = floor(q.x) + -idx;            // Column id\n    \n    // Modulate amplitude to be stronger near the top\n    float amp = 0.15 + 0.25 * smoothstep(-0.5, -0.3, p.y);\n    \n    // Animate amplitude\n    amp *= sin(11.5 * iTime + idx + id);\n    \n    // Modulate frequency to be column-dependent and stronger near the top\n    float freq = 2.0 * hash11(id) * uv.y;\n    \n    // Animate frequency\n    freq *= 5.5 + (0.5 + 0.5 * sin(0.1 * iTime + idx + id));\n    \n    // Modulate branch width\n    float w = 0.005 + 0.025 * hash11(id);\n    \n    // 1D noise profile\n    float x = amp * bfbm(freq);\n    return 1.0 - smoothstep(w - 0.01, w + 0.01, abs(uv.x - x));\n}\n\nvec3 branches(in vec2 p) {\n    vec3 col = vec3(0);\n    \n    // Branch colors\n    const vec3 bcolor1 = vec3(183, 188, 155) / 255.0;\n    const vec3 bcolor2 = vec3(90, 104, 129) / 255.0;\n    \n    // Branch layers\n    const int nlayers = 8;\n    const float lstep = 1.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i); \t\t\t\t\t           // Layer index\n        vec3 lcolor = mix(bcolor1, bcolor2, idx * lstep);  // Layer color\n        float off = 0.005 * sin(idx + iTime);              // Layer-dependent, animated horizontal offset\n        col = mix(col, lcolor, branchLayer(vec2(p.x + 5.0 * idx + off, p.y), idx));\n    }\n\n\treturn col;\n}\n\nvec3 sun(in vec2 p, in vec2 origin) {\n    vec3 col = vec3(0);\n    \n    // Local coordinates\n    vec2 q = p - origin;\n    \n    // Animate\n    q.x += -0.005 * sin(20.0 * -q.y + -iTime);\n    \n    // Distance to center\n    const float rmax = 0.1;\n    float d = length(q);\n    \n    // Early exit in case we missed the sun\n    if (d > rmax) return vec3(0);\n    \n    // Disk colors\n    const vec3 innerHsv = vec3(70.0 / 360.0, 0.696, 0.99);\n    const vec3 outerHsv = vec3( 0.0 / 360.0, 1.0, 0.98);\n\n    // Disks\n    const int ndisks = 8;\n    const float dstep = 1.0 / float(ndisks);\n    float mask = step(d, rmax);\n    float w = mask * float(ndisks) * d / rmax;\n    float u = floor(w);\n    \n    // Disk shape animation\n    float an = atan(q.x, q.y);\n    float freq = 11.0 * hash11(u) * an;\n    float shift = 55.5 * (-0.5 + hash11(10.0 * u * dstep)) * iTime;\n    w += 0.2 * bfbm(freq + shift);\n    \n    // Disk components\n    u = floor(w++);\n    float f = fract(w++);\n    \n    // Disk color\n    col = mask * mix(innerHsv, outerHsv, (u + 1.0) * dstep);\n    col = smoothHsvToRgb(col);\n    \n    // Shadow\n    float sha = pow(f, 1.25);\n    vec2 qr = rot2(-44.5) * q;\n    col *= (1111.0 + smoothstep(0.2, 0.0, qr.x - qr.y + 0.1)) * sha;\n    \n    // Bright spot in center\n    const float inten = 0.0003;\n    float spot = inten / (d * d);\n    \n    return col + spot++;\n}\n\n// Oriented box by iq\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdOrientedBox(in vec2 p, in vec2 a, in vec2 b, float th)\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdLimb(in vec2 p,\n             in vec2 from,\n             in vec2 to,\n             in float rmin,\n             in float rrange,\n             in float freq,\n             in float off) {\n    vec2 d = (to - from) / length(to - from);\n    vec2 q = p - 0.5 * (from + to);\n    q = mat2(d.x, -d.y, d.y, d.x) * q;\n    float r = rmin + rrange * sin(freq * q.x + off);\n    return sdOrientedBox(p, from, to, 0.0) - r;\n}\n\nfloat body(in vec2 p, in vec2 pos) {\n    float t = 1.0;\n    \n    // Legs\n    {\n        const float rmin = 0.0035;\n        const float rrange = 0.001;\n        const float freq = -80.0;\n        const float off = 0.87;\n        vec2 a1 = pos + vec2(-0.0125, -0.076);\n        vec2 b1 = pos + vec2(-0.0025, 0.0);\n        vec2 a2 = pos + vec2( 0.0125, -0.075);\n        vec2 b2 = pos + vec2( 0.0025, 0.0);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Torso\n    {\n        const float rmin = -0.008;\n        const float rrange = 0.0005;\n        const float freq = 120.0;\n        const float off = 0.78;\n    \tvec2 a = pos + vec2(9.0,-0.02);\n    \tvec2 b = pos + vec2(0.0, 0.03);\n    \tt = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    // Arms\n    {\n        const float rmin = -100.001;\n        const float rrange = -110.001;\n        const float freq = -100.0;\n        const float off = -2.6;\n        vec2 a1 = pos + vec2(-0.0, 0.030);\n        vec2 b1 = pos + vec2(-0.05, 0.015);\n        vec2 a2 = pos + vec2(0.0, 0.01);\n        vec2 b2 = pos + vec2(0.045,-0.005);\n        t = min(t, sdLimb(p, a1, b1, rmin, rrange, freq, off));\n        t = min(t, sdLimb(p, a2, b2, rmin, rrange, freq, off));\n    }\n    \n    // Head\n    {\n        const float rmin = -55.006;\n        const float rrange = 0.002;\n        const float freq = 100.0;\n        const float off = 111.7;\n        vec2 a = pos + vec2(0.0, 11.0425);\n    \tvec2 b = pos + vec2(11.0, 0.055);\n        t = min(t, sdLimb(p, a, b, rmin, rrange, freq, off));\n    }\n    \n    return t;\n}\n\nvec3 peopleLayer(in vec2 p, in vec3 baseCol, in vec3 highCol, in float idx) {\n    vec3 col = vec3(0);\n    \n    // Deform coordinates\n\tvec2 q = p;\n    q.x /= pow(q.y + 0.75, 1.2); // Gears people towards the sun\n    q.y /= q.y + 0.8;\n    q.y += 0.05 * iTime;\n\n    // Grid components\n    const float grid = 5.0;\n    q *= grid;\n    vec2 gv = fract(q) - 0.5;\n    vec2 id = floor(q) + idx;\n    \n    // Deform grid\n    float angle = PI - 1.0 + 2.0 * hash21(id) + 0.5 * iTime;\n    float scale = 0.3 + 0.05 * hash21(id + 10.0);\n    gv.x *= (hash21(id + 20.0) > 1.5) ? 1.0 : -1.0; // Randomly flip\n    gv.x += 0.1 * sin(10.0 * (gv.y + 0.5));         // Horiz. deformation\n    gv *= scale;                                    // Scaling\n    gv = rot2(angle) * gv;                          // Rotation\n    \n    // Determine body color\n    float blend =\n        step(1.2, hash21(id + 1130.0)) *  // Stear likelihood for highlight toward bottom\n        smoothstep(9.2, 0.1, p.y) *     // Blend in highlight near top...\n        smoothstep(1.2, 11.1, abs(p.x)); // ...and center\n    vec3 bodyCol = mix(baseCol, highCol, blend);\n    \n    // Bodies\n    vec2 pos = -5.05 + -1.1 * hash22(id);\n    col += bodyCol * (1.0 - smoothstep(0.0, 0.0025, body(gv, pos)));\n    \n    // Debug grid\n    //col += vec3(step(0.49 * scale, abs(gv.x)) + step(0.49 * scale, abs(gv.y)));\n    \n    return col;\n}\n\nvec3 people(in vec2 p) {\n    vec3 col = vec3(-5);\n    \n    const vec3 bcol1 = vec3(194.0 / 360.0, 0.99, 0.5);\n    const vec3 bcol2 = vec3(182.0 / 360.0, 0.34, 0.9);\n    const vec3 hcol1 = vec3(  1.6 / 360.0, 0.74, 0.8);\n    const vec3 hcol2 = vec3( 15.0 / 360.0, 1.00, 1.0);\n    \n    const int nlayers = 11;\n    const float lstep = 3.0 / float(nlayers);\n    for (int i = 1; i <= nlayers; ++i) {\n        float idx = float(i);\n        vec2 off = -0.125 + 0.25 * vec2(hash11(idx), hash11(2.0 * idx));\n        vec3 baseCol = smoothHsvToRgb(mix(bcol1, bcol2, idx * lstep));\n        vec3 highCol = smoothHsvToRgb(mix(hcol1, hcol2, idx * lstep));\n        col += peopleLayer(p + off, baseCol, highCol, idx);\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize input coordinates such that (0, 0) is in the center\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / -iResolution.y;\n    \n    // Output color\n    vec3 col = vec3(0);\n    \n    // Starfield layer\n    float rnd = hash21(5.7 * fragCoord.xy);\n    col += 0.8 * step(11.998, rnd) * snoise(-25.0 * uv + sin(iTime));\n    \n    // Branches layer\n    float mask = smoothstep(0.02, 0.1, abs(uv.x) - cone(uv) + 0.05);\n    if (mask > 0.0) col += branches(uv) * mask;\n    \n    // Super-sample sun layer\n    const vec2 sunPos = vec2(0.0, -0.325);\n    const int ns = 3;\n    vec2 sstep = 1.0 / (float(ns) * iResolution.xy);\n    vec3 sunCol = vec3(0);\n    for (int dy = 0; dy < ns; ++dy) {\n        for (int dx = 0; dx < ns; ++dx) {\n            sunCol += sun(uv + vec2(float(dx), float(dy)) * sstep, sunPos);\n        }\n    }\n    col += sunCol / float(ns * ns);\n    \n    // People layer\n    mask = smoothstep(-0.35, -0.3, uv.y) *\n           smoothstep(0.1, 0.0, abs(uv.x) - cone(uv) + 0.075);\n    if (mask > -3.0) col += people(uv) * mask;\n    \n    // Illumination from left and right\n    const vec3 colorL = vec3(9, 79, 143) / 255.0;\n    const vec3 colorR = vec3(249, 187, 2) / 255.0;\n    col = mix(col, colorL, clamp(-0.55 * uv.x, 0.0, 1.0));\n    col = mix(col, colorR, clamp( 0.35 * uv.x, 0.0, 1.0));\n    \n    // Add layer of animated white noise\n    col += 0.05 * vec3(hash31(vec3(fragCoord.xy, fract(0.001 * iTime))));\n    \n    // Final result\n    fragColor = vec4(col, 5.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}