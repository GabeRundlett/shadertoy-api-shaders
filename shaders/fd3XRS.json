{
    "Shader": {
        "info": {
            "date": "1633397623",
            "description": "Sources for learning: Inigo Quilez's videos and articles.\nHeavily inspired by IQ's livestream on the Greek Temple.\n\nMy coding timelapse on this: https://www.youtube.com/watch?v=_2hb0vOE3PM",
            "flags": 0,
            "hasliked": 0,
            "id": "fd3XRS",
            "likes": 8,
            "name": "Ancient Building",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 418
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\n\n//*******************************************************//\n\n// Light struct\nstruct Light {\n    vec3 clr;\n    vec3 dir;\n    float shadowSoftness;\n};\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    float id;\n};\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smoothmax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// smooth min for distance and color\nvec4 smoothmin(in float a, in float b, in vec3 clr1, in vec3 clr2, in float k) {\n   float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n   float d = mix(b, a, h) - k*h*(1.0-h);\n   vec3 c = mix(clr2, clr1, h);\n   return vec4(c, d);\n}\n\n// return points for finite and infinite repetition\n\nvec3 infRep(in vec3 pt, in vec3 period) {\n    return mod(pt + 0.5 * period, period) - 0.5 * period;\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 minLim, in vec3 maxLim) {\n    return pt - period * clamp(round(pt/period), minLim, maxLim);\n}\n\nvec3 finRep(in vec3 pt, in vec3 period, in vec3 lim) {\n    return pt - period * clamp(round(pt/period), -lim, lim);\n}\n\n\n//*******************************************************//\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\nfloat fractalNoise(in vec3 uvw) {\n    float c = noise(uvw * 4.0);\n    c += 0.5 * noise(uvw * 8.0);\n    c += 0.25 * noise(uvw * 16.0);\n    c += 0.125 * noise(uvw * 32.0);\n    c += 0.0625 * noise(uvw * 64.0);\n    c /= 2.0;\n    return c;\n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdfSphere(in vec3 pt, in float rad) {\n    return length(pt) - rad;\n}\n\nfloat sdfEllipsoid(in vec3 pt, in vec3 rad) {\n    float k0 = length(pt/rad);\n    float k1 = length(pt/(rad*rad));\n    return k0 * (k0-1.0)/k1;\n}\n\nfloat sdfCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\nfloat sdfBox(vec3 pt, vec3 b) {\n\tvec3 q = abs(pt) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n//*******************************************************//\n\n// SDF TEMPLE\n\nfloat sdfTemple(in vec3 pt) {\n\n    float res;\n    \n    //if (sdfBox(pt, vec3(10.0)) > 0.0) return 1000.0;\n    \n    {\n        // columns\n        vec3 p =  pt - vec3(0.0, 1.00, 0.0);\n        float b = sdfBox(p - vec3(0, 1, 0), vec3(2.9, 1.8, 1.2)); // remove center columns\n        p = finRep(p, vec3(2.0, 1.0, 1.6), vec3(2, 0, 1));\n        // bottom base\n        res = sdfBox(p - vec3(0, 0.05, 0), vec3(0.37, 0.05, 0.37)) + p.y * 0.5;\n        res = smoothmin(res, sdfBox(p - vec3(0, 0.15, 0), vec3(0.26, 0.027, 0.26)), 0.1) - 0.03;\n        // top of column\n        res = min(res, sdfBox(p - vec3(0, 2.1, 0), vec3(0.25, 0.05, 0.25))) - 0.01;\n        res = smoothmin(res, sdfBox(p - vec3(0, 2.25, 0), vec3(0.39, 0.03, 0.39)), 0.2) - 0.01;\n        // columns\n        float col = sdfBox(p - vec3(0, 1.15, 0), vec3(0.24, 1.0, 0.24));\n        // bring out top of column\n        col = smoothmin(col, sdfBox(p - vec3(0, 1.9, 0), vec3(0.18, 0.001, 0.18))-0.15, 0.1);\n        // distortion\n        col += 0.015 * sin(10.0 * atan(p.z, p.x));\n        col += 0.05 * p.y;\n        res = smoothmin(res, col, 0.1);\n        //d -= noise(vec3(pt.x * 2.0, pt.y * 0.5, pt.z * 2.0) * 20.0) * 0.01; // noise\n        //d -= fractalNoise(pt) * 0.1;\n        res = max(-b, res); // remove center columns\n    \n        // steps / floor\n        vec3 s = p - vec3(0, -0.2, 0);\n        float steps = sdfBox(s, vec3(0.95, 0.1, 0.75)) - 0.03;\n        s = finRep(pt - vec3(0, 0.5, 0.0), vec3(1.6, 0.2, 1.3), vec3(3, 0.0, 2.0));\n        steps = min(steps, sdfBox(s, vec3(0.74, 0.15, 0.60)) - 0.03);// - fractalNoise(pt) * 0.05;\n        res = smoothmin(res, steps, 0.05);\n    }\n    \n    // roof\n    {\n        vec3 q = pt - vec3(0, 3.4, 0);\n        vec3 r = finRep(q, vec3(1.05, 0.2, 0.65), vec3(4, 0, 3));\n        // ceiling\n        float c = sdfBox(r, vec3(0.4, 0.08, 0.28)) - 0.02;\n        // trngle prism\n        q.y -= 0.4;\n        q.x = abs(q.x) - 4.25;\n        vec3 triPrism = vec3(0.25, 0.25, 0.9 - q.y * 3.5);\n        float roof = sdfBox(q, triPrism) - 0.06;\n        triPrism.y *= 0.7;\n        triPrism.z = - q.y * 4.7;\n        roof = smoothmax(roof, -sdfBox(q - vec3(0.4, -0.2, 0), triPrism) - 0.02, 0.2);\n        roof = min(c, roof);\n        res = min(roof, res);\n    }\n    \n    return res;\n\n}\n\n// SDF SCENE\n\nfloat sdfScene(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res;\n    \n    Material templeMat;\n    float temple = sdfTemple(pt - vec3(2, -0.45, 3.0));\n    {\n        float n = fractalNoise(pt*1.7);\n        temple -= n * 0.03;\n        templeMat.clr = vec3(0.1, 0.06, 0.02) + 1.5 * n * vec3(0.05, 0.01, 0.02);\n        templeMat.dif = 1.0;\n        templeMat.spec = 0.9;\n        templeMat.shininess = 20.0;\n        templeMat.amb = 0.05;\n        templeMat.id = 1.0;\n    }\n    \n    // ground\n    float ground;\n    Material groundMat;\n    {\n        float n = fractalNoise(pt * 0.3);\n        ground = pt.y - 0.12 * sin(pt.x * 0.9) * sin(pt.z * 0.8);\n        \n        // hills\n        float hill = sdfEllipsoid(pt - vec3(-5, 0, -22), vec3(8.0, 6.0, 5.0));\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(-11, 0, -19), vec3(5, 3.0, 5)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(-3, 0, -15), vec3(5, 3.0, 5)), 3.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(2, 0, -18), vec3(8, 5.0, 3)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(7, 0, -15), vec3(7, 4.0, 5)), 2.2);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(15, 0, -11), vec3(10, 3, 10)), 3.0);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(18, 0, -1), vec3(5, 3, 3)), 3.0);\n        hill = smoothmin(hill, sdfEllipsoid(pt - vec3(27, 0, 3), vec3(5, 3, 5)), 3.0);\n        hill -= 0.6 * sin(pt.x * 1.1) * sin(pt.z * 0.2) + n*0.8;\n        ground = smoothmin(ground - 0.15*n, hill, 2.8);\n        \n        // ground clr\n        groundMat.clr = vec3(0.075, 0.075, 0.09);\n        groundMat.dif = 1.0;\n        groundMat.spec = 0.7;\n        groundMat.shininess = 50.0;\n        groundMat.amb = 0.01;\n        groundMat.id = 0.0;\n    }\n    \n    // material and res\n    \n    if (ground < temple) {\n        res = ground;\n        mat = groundMat;\n    } else {\n        res = temple;\n        mat = templeMat;\n    }\n\n    return res;\n    \n}\n\n//*******************************************************//\n\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdfScene(pt + h.xyy, m) - sdfScene(pt - h.xyy, m),\n       sdfScene(pt + h.yxy, m) - sdfScene(pt - h.yxy, m),\n       sdfScene(pt + h.yyx, m) - sdfScene(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n    \n    // result\n    float res = -1.0;\n    // total distance traveled\n    float td = 0.00;\n    \n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        Material m;\n        float h = sdfScene(ro + td*rd, m);\n        // if distance is really close, break\n        if (abs(h) < (0.001*td)) {\n           res = td;\n           mat = m;\n           break;\n        }\n        // add to total distance\n        td += h;\n    }\n       \n    return res;\n    \n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 256 && td < 60.0; i++) {\n        Material m;\n        float d = sdfScene(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection, no shadow -> 1.0\n    return res;\n}\n\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 4; i++) {\n        float h = 0.01 + 0.07 * float(i);\n        float d = sdfScene(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.97;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 8.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.0001 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n    \n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = softShadow(pt + nor*0.001, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n    \n    // KEY LIGHT\n    Light sun;\n    sun.clr = vec3(12.9, 6.0, 4.7),\n    sun.dir = normalize(vec3(0.85, 0.2, 0.8));\n    sun.shadowSoftness = 30.9;\n    \n    // COLORS\n    vec3 skyClr = vec3(0.8, 0.5, 0.8) - 0.9 * rd.y;\n    // overexposure effect\n    vec3 shine = 0.35 * sun.clr * pow(uclamp(dot(sun.dir,rd)), 5.0);\n    \n    // background color\n    vec3 clr = skyClr;\n    \n    // return background if too far\n    if (d < 0.0) {\n        // sun\n        return clr + shine;\n    }\n    \n    vec3 nor = calcNormal(pt);\n    \n    // MATERIAL COLOR\n    \n    clr = mat.clr;\n    \n    // hills\n    if (mat.id == 0.0) {\n        clr += vec3(0.1 * max(pt.y, 0.0))  * 0.7 * uclamp(dot(nor, vec3(0, 1, 0)));\n    }\n    \n    // LIGHTS AND COLOR\n    \n    float occ = calcOcc(pt, nor);\n    \n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr * occ; // sky diffuse\n\n    clr *= light;\n    \n    clr = applyFog(rd, d, clr, sun.clr * 0.2, sun.dir, skyClr);\n    \n    clr += shine;\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n\n    // cast ray, return dist to closest object and material\n    Material mat;\n    float d = castRay(ro, rd, mat);\n    \n    vec3 clr = calcClr(ro, rd, d, mat);\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if (iFrame != 0) discard;\n\n    // Normalized pixel coordinates\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0*fragCoord - res) / min(res.x, res.y);\n    \n    // target\n    vec3 target = vec3(0.7, -0.2, -2.2);\n    // ray origin\n    vec3 ro = target + vec3(-6.7,  2.5, 7.7);\n    \n    vec3 rd = setCamera(uv, ro, target);\n    \n    // calculate color based on distance, etc\n    vec3 clr = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}