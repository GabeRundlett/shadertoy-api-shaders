{
    "Shader": {
        "info": {
            "date": "1580569019",
            "description": "Set what is red in the webcam to fire.\n\nNot completely satisfied with the fire effect, but the overall effect is nice....",
            "flags": 34,
            "hasliked": 0,
            "id": "WltSzN",
            "likes": 6,
            "name": "Fire on Camera",
            "published": 3,
            "tags": [
                "fire",
                "red",
                "webcam"
            ],
            "usePreview": 0,
            "username": "ManuManu",
            "viewed": 950
        },
        "renderpass": [
            {
                "code": "// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nvec4 shapeToFlame(vec2 uv, float n, float c )\n{\n    float c1 = n * c * (1.5-pow(1.5*uv.y,.9));\n//\tfloat c1 = n * c * (1.5-pow(2.50*uv.y,4.));\n\tc1=clamp(c1,0.,1.);\n\n    float boostRed = 1.6;\n\tvec4 col = vec4(boostRed*c1, boostRed*c1*c1*c1, c1*c1*c1*c1*c1*c1,c1);\n    \n#ifdef TRY_SMOKE\n    float blackAdded = 1.- distance( c1, 0.3 );\n    blackAdded = clamp( blackAdded, 0.,1.);\n    blackAdded = pow( blackAdded, 20.0);\n    \n    vec4 blackCol = vec4(0., 0.,0.,1.);\n    col = mix ( col, blackCol, blackAdded-noise(uv+vec2(0, iTime))*0.5);\n#endif // TRY_SMOKE    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float strength = floor(uv.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime;\n\n    float n= fbm( uv * strength *4.5 - vec2(0,T3) );\n    \n    float flameShape = vec3( texture(iChannel0, uv)).r;\n    //flameShape = 10.0;\n    float maxVal = 1.5;\n    flameShape = clamp(flameShape, 0.,maxVal);\n    \n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }\n    \n    flameShape = pow(flameShape/maxVal, 0.8)*maxVal;\n    \n    \n    if ( isDebug()> .5 )\n    {\n        if ( uv.x > 0.8 && uv.x < 0.9 )\n            flameShape = ( 1.-uv.y) * maxVal;\n    }    \n    vec4 colFire = shapeToFlame( uv, n, flameShape );\n    \n    \n    \n    \n    vec3 col;// = colFire;\n    \n    col = mix( texture(iChannel1, uv).rgb, colFire.rgb, colFire.a);\n    \n   /* \n    float valTry = col.r;\n    if ( uv.y < .5 )\n    {\n        if ( uv.x < .5 )\n            col.r = 0.2;\n        else\n            col.r = col.g;\n    }\n    else\n    {\n        float minVal = .2;\n        float maxVal = col.g;\n        //col.r = step( .5, uv.x ) * ( maxVal - minVal ) + minVal;\n        col.r = mix( minVal, maxVal, step(.5, uv.x ) );\n    }   \n    */\n    \n    \n    \n\n    \n    //col = vec3(n);\n    //col = vec3(flameShape);\n    \n    // for test :\n    //col = vec3( texture(iChannel2, uv));\n    //col = vec3( texture(iChannel0, uv));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float isRedColor( vec3 color )\n{\n    vec3 wantedColor=  vec3( 1.0, .0, .0 );\n    float distToColor = distance( color.rgb, wantedColor ) ;\n    return distToColor;\n}\n\n\nconst float threshold = .6;\nvec3 onlyRedImage2( vec3 color )\n{\n    float isRed = isRedColor( color );\n    return mix( color, vec3(0.), step(threshold, isRed ) );\n}\n\n\nvec3 onlyRedImage1( vec3 col )\n{\n\tfloat maxgb = max( col.g, col.b );\n    float k = clamp( (col.r-maxgb)*5.0, 0.0, 1.0 );\n    return mix( vec3(0.), col, k);\n}\n\nvec3 onlyRedImage( vec3 col )\n{\n    if (lotsOfRed() > 0.5)\n        return onlyRedImage1(col);\n\treturn onlyRedImage2(col);\n}\n\n\nfloat HorizontalLine( vec2 uv, float size )\n{\n    uv = uv /  vec2( size, .02);\n    vec2 absUV = abs(uv);\n    \n    return 1.-step( 1., max(absUV.x, absUV.y) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n    \n    \n    // get red color from camera :\n\tvec3 color = onlyRedImage( origColor );\n    \n    if ( isDebug()> .5 )\n    {\n        float m = HorizontalLine( uv - vec2( .1, .1), .05);\n        const vec3 redColor = vec3(1., .0, .0);\n        color = mix( color, redColor, m );\n    }\n\n    fragColor = vec4(color, .1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "webcam",
                        "id": 31,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/webcam.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//#define FOUR_POINTS\n\n\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 origColor = vec3( texture(iChannel0, uv));\n\n    vec2 pix = 1.0 / iResolution.xy;\n    \n\n#ifdef FOUR_POINTS\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n\tfireColor *= 0.248;  // cold phase\n#else\n    vec3 fireColor = \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y)).rgb + \n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*2.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(0.0, pix.y*3.0)).rgb +\n        \ttexture(iChannel1, uv - vec2(2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-2.*pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(pix.x, pix.y)).rgb +\n        \ttexture(iChannel1, uv - vec2(-pix.x, pix.y)).rgb;\n    vec3 randSeed = vec3( uv.x + 5.1*iTime, uv.y + 3.2*iTime, iTime/1.5);\n    //float randValue = rand(randSeed);\n    float randValue = hash13(randSeed);\n    //float randValue = .5;\n\tfireColor *= 0.135 + randValue / 100.;  // cold phase\n#endif // FOUR_POINTS\n    \n    \n    // Output to screen\n    fragColor = vec4(fireColor + origColor,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define DEBUG_MODE 1\n\n\nfloat isDebug()\n{\n    return 0.0;\n}\n\n\nfloat lotsOfRed()\n{\n    return 0.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}