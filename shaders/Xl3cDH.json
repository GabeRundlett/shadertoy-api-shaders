{
    "Shader": {
        "info": {
            "date": "1533027953",
            "description": "Max Headroom - A computer generated simulation of Matt Frewer pretending to be CGI. :)\nVery popular in the 1980s, this guy in a plastic suit was famous for a short while.",
            "flags": 96,
            "hasliked": 0,
            "id": "Xl3cDH",
            "likes": 46,
            "name": "[SH18] Max Headroom",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "tv",
                "max",
                "headroom",
                "human",
                "maxheadroom"
            ],
            "usePreview": 1,
            "username": "Dave_Hoskins",
            "viewed": 4272
        },
        "renderpass": [
            {
                "code": "// [SH18] Max Headroom\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Max Headroom from 1980s TV - A computer generated simulation of Matt Frewer pretending to be CGI!\n// Audio is taken directly from https://youtu.be/cYdpOjletnc\n\n// This tab does a old TV bloom effect, well at least it messses it up a bit, and makes\n// \tthe background blur into the Max nicely.\n\n#define GOLDEN_ANGLE 2.39996\n#define ITERATIONS 50\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//-------------------------------------------------------------------------------------------\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius)\n{\n\tvec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.01 / sqrt(float(ITERATIONS)));\n    vec2 pixel = vec2(1, iResolution.x / iResolution.y);\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        // the approx increase in the scale of sqrt(0, 1, 2, 3...)\n        r += 1. / r;\n\t    vangle = rot * vangle;\n        vec3 col = texture(tex, uv + ((r-1.) * vangle * pixel), 1.5).xyz; /// ... Sample the image\n        col = pow(col, vec3(2.5)); // ... Contrast it for better highlights - leave this out elsewhere.\n\t\tvec3 bokeh = col;\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;//float(ITERATIONS);\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\tfloat rad = .4;\n    \n    vec3 betaMax = hash13(vec3(uv*vec2(200., 2000.), iTime*10.))*vec3(.05, .03, .12);\n \tvec3 col = betaMax  + texelFetch(iChannel0, ivec2(fragCoord), 0).xyz * .4\n        \t\t\t\t+ Bokeh(iChannel0, uv, rad)*.85;\n    fragColor = vec4(col, 1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// [SH18] Max Headroom\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This tab stores some animations in the buffer. I know I could have kept the arrays,\n//\tbut I didn't know how big everything was going to be in the end.\nvec4[] tilt = vec4[](\n    \tvec4(0.0, -.1, .2, .17),\n    \tvec4(.14, .1, .06, .02),\n    \tvec4(0, 0, 0, 0),\n    \tvec4(0, 0.1, 0.0, 0.0),\n    \tvec4(0, 0, 0.,  -0.05),\n    \tvec4(0, 0, 0., 0.),\t\n    \tvec4(0., 0, 0., 0.), // Television\n    \tvec4(0, 0.0, 0.0, 0.2),\n    \tvec4(0, .2, 0.1, 0.2), // Yes it, yes it\n    \tvec4(0.3, .0, 0., 0.),\n    \tvec4(0, 0, 0., -0.2),  // The Max Headroom story.\n    \tvec4(-.2, -0.2, 0., .0), // OH!\n    \tvec4(0.1, 0, 0, 0.),\n    \tvec4(0, 0, 0.2, 0.), // I wanna talk to you\n    \tvec4(0, -.1, -0.3, -.3), // Namely Max Headroom\n    \tvec4(-.2, -.2, -0.2, -0.2),  // SO!\n    \tvec4(.0, 0, 0., 0.1),\n    \tvec4(0.1, 0.2, 0.2, 0.2),\n    \tvec4(.2, 0.2, .2, .3),\n    \tvec4(.3, .3, .3, .3)\n    \n    );\n\nvec4[] shake = vec4[](\n    \tvec4(0, 0, 0, -.1),\n    \tvec4(-.2, -.3, -.3, -.3),\n    \tvec4(-.1, -.1, -.05, .0),\n    \tvec4(0.0, -0.05, 0.05, -0.05),\n    \tvec4(0.05, .1, -0.3,  -.1),\n    \tvec4(0.05, .0, -0.1, -.2),\t\n    \tvec4(-0.4, -.35, 0, 0.), // Television\n    \tvec4(-0., -0., 0., 0.),\n    \tvec4(0, 0, 0., 0.0), // Yes it, yes it\n    \tvec4(0.0, 0.3, 0.4, 0.4),\n    \tvec4(0.4, 0.4, 0.2, 0.0),  // The Max Headroom story.\n    \tvec4(0, 0., 0., .0),// OH!\n    \tvec4(0.1, 0, 0., 0.),\n    \tvec4(0, 0, 0.0, -0.2), // I wanna talk to you\n    \tvec4(0, 0, 0., 0.), // Namely Max Headroom\n    \tvec4(0, 0.2, 0.1, 0.),  // SO!\n    \tvec4(.0, 0, 0., 0.),\n    \tvec4(.0, 0, 0., 0.),\n    \tvec4(.0, 0, 0., 0.),\n    \tvec4(.0, 0, 0., 0.)\n    \t\n    );\n\nvec4[] squint = vec4[](\n    \tvec4(.1, .3, .4, .6),\n    \tvec4(.4, .3, .3, .3),\n    \tvec4(.1, .1, .05, .01),\n    \tvec4(0.0, 0.1, 0., -.15),\n    \tvec4(0.05, .1, 0.1,  .3),\n    \tvec4(0.5, .7, 0.4, 0.3),\t // Television\n    \tvec4(-0.0, -.2 , 0.6, 0.2),// More...\n    \tvec4(-0.4, -0.4, 0., 0.),\n    \tvec4(0, 0, 0., 0.0), // Yes it, yes it\n    \tvec4(0.0, 0.3, 0.3, 0.5),\n    \tvec4(0.5, 0.5, 0.4, -0.5),  // The Max Headroom story.\n    \tvec4(-.5, -.5, -.2, 0.),// OH!\n    \tvec4(0.1, 0, 0., 0.),\n    \tvec4(0, 0, 0.4,.4), // I wanna talk to you\n    \tvec4(.5, -.5, -.5, 0.), // Namely Max Headroom\n    \tvec4(0, 0, 0., -0.3),  // SO!\n    \tvec4(.0, 0, 0., 0.),\n    \tvec4(.0, .5, .5, .5),\n    \tvec4(.5, .5, 1., 1.),\n    \tvec4(1., 1., 1., 1.)\n    );\n\n\nfloat grabTime()\n{\n  \tfloat m = (iMouse.x/iResolution.x)*80.0;\n\treturn (iTime+m+410.)*32.;\n}\nint StoreIndex(ivec2 p)\n{\n\treturn p.x + 256 * p.y;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    if (iFrame > 1) discard;\n    ivec2 pos = ivec2(fragCoord);\n    vec4 col = vec4(0);\n    \n\tint n = pos.x;\n    if (n > tilt.length())\n    \tdiscard;\n\n    \n\tswitch (pos.y)\n\t{\n\t\tcase 1:\n\t\t\tcol = tilt[n];\n        \t\tbreak;\n\t\tcase 2:\n\t\t\tcol = shake[n];\n\t\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcol = squint[n];\n\t\t\tbreak;\n    }\n\n\tfragColour = col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// [SH18] Max Headroom\n// by David Hoskins.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This tab draws the whole scene\n\n\n#define PI 3.141\n#define SUN_GLASSES\nbool inTransparency = false;\nbool hitSpecs = false;\nfloat specular;\nfloat specAmp;\nvec3 lightDir;\nvec3 backDir;\nvec2 eyeLook;\nfloat illum = .0;\nfloat squint = 0.2;\nfloat curl = 0.0;\nfloat ooo = 1.4;\nfloat jaw;\nvec2 tilt;\nfloat gTime;\n\nvec4 getStore(int num)\n{\n\treturn  texelFetch(iChannel0, ivec2(num, 0), 0);\n}\nmat3 setCamMat( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat DistanceToBoxBack(in vec3 dir, out int side)\n{ \n    \n\t// Don't need 'tmax' as we're inside the box looking for the back.\n\tvec3 invDir = 40.0/dir;\n\n\tfloat tx1 = (-40. - dir.x)*invDir.x;\n\tfloat tx2 = ( 40. - dir.x)*invDir.x;\n\tfloat tmin = min(tx1, tx2); side =1;\n\t\n\tfloat ty1 = (-40. - dir.y)*invDir.y;\n\tfloat ty2 = ( 40. - dir.y)*invDir.y;\n    \n    float m =  min(ty1, ty2);\n\tif (tmin < m)\n    \t{tmin = m; side = 2;}\n        \n\n\tfloat tz1 = (-40. - dir.z)*invDir.z;\n\tfloat tz2 = (40. - dir.z)*invDir.z;\n\tm = min(tz1, tz2);\n   \tif (tmin < m)\n\t    {tmin =  m; side = 0;}\n\n\treturn tmin;\n}\n\nmat2 rotation2D(float angle)\n{\n\tfloat c = cos( angle );\n\tfloat s = sin( angle );\n\t\n\treturn mat2(c, s, -s, c);\n}\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n//------------------------------------\n// Do Mr Headroom...\nfloat teeth(vec3 HC)\n{\n\tfloat d = rBox(HC+vec3(0,8.5,-8.8)*rotationXY(vec2(0,HC.x*.2)), vec3(8,.4, .1), .1);\n\td = min(d, rBox(HC+vec3(0, 9.8+jaw,-8.3)*rotationXY(vec2(0,HC.x*.2)), vec3(8,.4, .1), .1));\n\treturn d;\n}\n\n//------------------------------------\nfloat hair( vec3 p)\n{\n    p += vec3(0,-1.2,2.);\n    float x = smoothstep(0., 12., p.z)*2.+.9;\n\tp.y*= x;\n    p.y-=x*14.-9.;\n    return (rBox(p, vec3(2.,.1,2.5), 10.))-cos(p.x*28./(pow(abs(p.y+11.),1.4))*1.2)*.3;\n}\n\n//------------------------------------\nfloat mouth(vec3 p)\n{\n    p+=vec3(0,9.5+jaw*.5,-10);\n    p.xy = p.xy*rotation2D(p.x*.05*(1.0-curl));\n    p.x *= smoothstep(.0, 2., abs(p.y))*.3+.7;\n    float d = rBox(p, vec3(ooo-jaw*.2, -.2+jaw+curl,5.0), .25);\n    return d;\n}\n\n//------------------------------------\nfloat nose(vec3 p)\n{\n\n    vec3 n = (p+vec3(0,2.,-8.5));\n    n.x*= 1.2;\n    n.yz = n.yz * rotation2D(-PI/5.+.2);\n    n.xz = n.xz * rotation2D(-PI/4.);\n\n    float d  = rBox(n, vec3(1.,6.,1.), .8); \n    d = sMax(d, -rBox(p+vec3(0.,13.,-10), vec3(25.,6.,4.), 1.2), 1.);\n    return d;\n}\n\n//------------------------------------\nfloat head(vec3 p)\n{\n    // Top of head...\n    float d = rBox(p- vec3(0,3.2,0), vec3(2.5,3.5,1.1), 8.6);\n    // Lower head...\n\td = sMin(d, rBox(p + vec3(0,7, -1), vec3(4.,3.,1.), 4.5), 3.);\n  \n    // Chin..\n    d = sMin(d, rBox(p+ vec3(0.,8.+jaw,-5.), vec3(3.5,2.5+jaw,1.4), 3.), 2.5);\n    d = sMin(d, rBox(p+ vec3(0.,12.5+jaw*2.,-8.), vec3(1.5,-.1,.1), 2.5),2.);\n    \n    // Cheek hollow..\n    p.x = abs(p.x);\n    d = sMax(d, -sphere(p+vec3(-4.5,1.,-11.), 1.5), 3.);\n    \n    // Brows...\n    p.xz = p.xz*rotation2D(-.35);\n\td = sMin(d, rBox(p+vec3(-1.5,-2.+squint,-9.), vec3(2.6,.4,.1), .3), 4.);\n\n    return d;\n}\n\n//------------------------------------\nfloat eyes(vec3 p, vec3 add, float r)\n{\n    add *= rotationXY(vec2(tilt.x-.2, tilt.y));\n    p+=add;\n\n    \n    float d = sphere(p+vec3(-4.2, -.1, -6.8),r);\n    d = min(d, sphere(p+vec3(4.2, -.1, -6.8),r));\n    \n    return d;\n}\n\n\n//------------------------------------\nfloat eyeLids(vec3 p, float r)\n{\n   \tfloat d = sdEllipsoid(p+vec3(-4.2, -.1, -6.6), vec3(r, r*.7, r));\n    d = max(d, -sdEllipsoid(p+vec3(-4.2, .0+squint*.6, -7.3), vec3(r, (r-.1)*.6-squint, r)));\n    \n    return d;\n}\n\n//------------------------------------\nfloat ears(vec3 p, float d)\n{\n    p.x = abs(p.x);\n    p = p+vec3(-11.4,2.3,.6);\n    p.y*= .87;\n    \n    vec3 p2 = p*rotationXY(vec2(PI/2.0,1.2));\n\n    d = sMin(d, cylinder(p2, vec2(3.5,min(pow(abs(length(p2.xyz)), .4 )-.1, .4))), .5);\n    \n    p = (p+vec3(-.5,.3,-1.8))*rotationXY(vec2(PI/2.0,1.));\n    d = sMax(d, -sphere(p, .8), 1.5);\n    return d;\n}\n\n//------------------------------------\nfloat suit(vec3 p)\n{\n    vec3 su = p+vec3(0,80,3);\n    su.y += max(abs(p.x*.25)-2.5, 0.0);\n    float d = rBox(su, vec3(24,60.,2.2), 4.5);\n    d = max(d, -cylinder(p+vec3(0,15,2), vec2(9.5,16)));\n    return d;\n}\n\n//------------------------------------\nfloat shirt(vec3 p)\n{\n    vec3 su = p+vec3(0,80,4);\n    su.y += abs(p.x*.4);\n    float d = rBox(su, vec3(22,61,1.8), 5.);\n    \n    d = min(d, cylinder(p+vec3(0,21.5,6), vec2(8.4,6)));\n    d = max(d, -cylinder(p+vec3(0,21.5,6), vec2(7.7,7)));\n    p.x = abs(p.x);\n\n    p = (p+vec3(-4.5,17.5,-1.7))*rotationXY(vec2(-1.2,2.));\n    p.xz = p.xz*rotation2D(1.1);\n    d = sMin(d, triPrism(p, vec2(3.5,.1)), 1.);\n    return d;\n}\n\n//------------------------------------\nfloat tie(vec3 p)\n{\n\tvec3 ti = p+vec3(0,35,-2.5);\n\tfloat d = rBox(ti, vec3(1., 17,.5), .2);\n    p.y = -p.y;\n    p = p+vec3(0,-19.,-2.3);\n    p.yz = p.yz*rotation2D(.1);\n    d = sMin(d, triPrism(p, vec2(3.5,.2)), 3.);\n    return d;\n}\n//------------------------------------\n\n#ifdef SUN_GLASSES\nfloat sunGlasses(vec3 p)\n{\n    vec3 n = (p+vec3(-4.1,.7,-10.9));\n\n    n.zx  *= rotation2D(.3);\n    \n    n.x*= .4;\n    float h= clamp(pow(max(3.5-n.x*n.x, 0.), 1.4)*2., 0., 3.1)*.8;\n    float d = rBox(n, vec3(.4, 1.4, -1.2), 1.5);\n    \n    // Bridge...\n    n = (p+vec3(0.0,.1,-11.3));\n    d = sMin(d, rBox(n, vec3(.8,0.1,.3), .1), .4);\n\n    // Ear bits...\n    n = (p+vec3(-10.8,-1.,0.));\n    n.zx  *= rotation2D(min((6.0-n.z)*.08, .4));\n    d = sMin(d, rBox(n, vec3(.03,.1,10.0), .05), 1.0);\n    \n    return d;\n}\n#endif\n\n//--------------------------------------------------------------------------\nfloat DF(vec3 p, bool ignoreSpecs)\n{\n    float d = 1.e10;\n    hitSpecs = false;\n    vec3 headP = p-vec3(0,3,-5);\n    headP = (headP+vec3(0,12,4)) * rotationXY(vec2(tilt.x, tilt.y)) - vec3(0,12,4);\n    \n    \n    d = head(headP);\n    d = ears(headP, d);\n    d = sMin(d, cylinder(p+vec3(0,15,6), vec2(7.,10)), 2.8); // Neck\n\n    d = sMin(d, nose(headP), 1.);\n\n    float m = mouth(headP);\n    d = sMax(d, -m, 1.5);\n    d = min(d, teeth(headP));\n    \n    // Do eye sockets...\n    vec3 HC = headP;\n    HC.x = abs(HC.x);\n    \n    d = sMax(d, -rBox(HC+vec3(-5.2,.3+squint*.3,-10.5), vec3(3.,.3-squint,1.5),.4), 1.8);\n    d = min(d, eyes(headP, vec3(0), 2.2));\n    d = min(d, hair(headP));\n    d = min(d, eyeLids(HC, 2.8));\n#ifdef SUN_GLASSES\n    if (!ignoreSpecs)\n    {\n    \tfloat f = sunGlasses(HC);\n        d = min(d, f);\n        if (f < .1)\n            hitSpecs = true;\n    }\n#endif\n    d = min(d, suit(p));\n    d = min(d, shirt(p));\n    d = min(d, tie(p));\n    return d;\n}\n\n//--------------------------------------------------------------------------\n\nvec3 CF(vec3 p)\n{\n    specular = 2.4;\n\tspecAmp  = .4;\n\n\tfloat d, f;\n    vec3 dif = vec3(.85, .55, .4);\n    d = 1.e10;\n    vec3 headP = p-vec3(0,3,-5);\n        headP = (headP+vec3(0,12,4)) * rotationXY(vec2(tilt.x, tilt.y)) - vec3(0,12,4);\n    \n    d = head(headP);\n    d = sMin(d, nose(headP), 1.3);\n    vec3 HC = headP;\n    HC.x = abs(HC.x);\n   \t//d = sMax(d, -rBox(HC+vec3(-8.,0,-9), vec3(6.,.3,1.),.2), 2.-squint);\n    d = sMax(d, -rBox(HC+vec3(-4.,0.+squint,-8.5), vec3(7.,.3-squint,.5),.1), 3.);\n    \n    float m = -mouth(headP);\n    if  (m > -.7) dif = vec3(.7, .4, .3);\n    d = sMax(d, m, 1.5);\n    \n    \n    // Do eyes, with pupil and iris stuff inside so it doesn't leak...\n    if (eyes(headP,vec3(0.0), 2.2) < .1)\n    {\n       illum = .1;\n       specular = 50.;\n       specAmp = 6.0;\n       dif = vec3(.9);\n       f = eyes(headP, vec3(0,0,-1.3), 1.1);\n       if (f < .1)\n\t    {\n    \t  \n            f= clamp(f*10., 0.0, .3);\n        \tdif = vec3(.2,.6-f,.8);\n    \t}\n        if (eyes(headP,vec3(0., .0, -2.), .3) < .1)\n        \tdif = vec3(0);\n    }\n    d = sMin(d, cylinder(p+vec3(0,15,6), vec2(7.1,10)), 2.8);\n\n    if (d>= teeth(headP))\n    {\n        illum = .3;\n        dif = vec3(1);\n    }\n\n    if (hair(headP) <= d)\n    {\n        specular = 10.;\n        specAmp = 2.;\n        dif = vec3(1,1,.3 );\n    }\n    \n#ifdef SUN_GLASSES\n        f = sunGlasses(HC);\n    \td = min(d, f);\n        if (f < .15)\n        {\n            inTransparency = true;\n            specular = 25.0;\n            specAmp = 4.0;\n\t\t\tdif = vec3(.0);\n        }\n#endif\n    \n    \n\tf = min(d, suit(p));\n    \n    if (f < d)\n    {\n        specular = 3.0;\n        d = f; dif = vec3(0);\n    }\n    f = min(d, shirt(p));\n   \n    if (f < d)\n    {\n        d = f; dif = vec3(1.);\n    }\n    f = min(d, tie(p));\n    if (f < d)\n    {\n        dif = vec3(0,0.03,.08);\n    }\n\n\n\n    return dif;\n}\n\n//--------------------------------------------------------------------------    \nfloat trace(vec3 pos, vec3 dir, bool ignoreSpecs, int len)\n{\n    inTransparency = false;\n    float t = 1.;\n    int i = 0;\n    for (; i< len; i++)\n    {\n        \n        vec3 p = pos+t*dir;\n        float d =DF(p, ignoreSpecs);\n        if (d < 0.1 || t > 100.0)\n            break;\n        t += d*.7;\n    }\n    if (i >= 100 || t> 80.0) t = -10.0;\n    return t;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = .1;\n\tfloat h;\n\tvec3 p;\n    for (int i = max(0,iFrame); i < 12; i++)\n\t{\n        p =  ro + rd*t;\n \t\t\n\t\th = DF(p, false);\n      \tres = min(5.*h / t, res);\n        res = max(res, hitSpecs ? .4: .05);\n\n\t\tt += h;\n\t}\n    return res;\n}\nvec3 doNormal(vec3 pos, bool ignoreSpecs)\n{\n\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    DF(pos+eps.xyy, ignoreSpecs) - DF(pos-eps.xyy, ignoreSpecs),\n\t    DF(pos+eps.yxy, ignoreSpecs) - DF(pos-eps.yxy, ignoreSpecs),\n\t    DF(pos+eps.yyx, ignoreSpecs) - DF(pos-eps.yyx, ignoreSpecs));\n\treturn normalize(nor);\n}\nfloat getTexFloat(int x, int y)\n{\n    if (x < 0) x = 0;\n    int n = x/4;\n    //n =0;y=1;\n    vec4 v = texelFetch(iChannel0, ivec2(n, y), 0);\n    float r = v[x&3];\n    return r;\n}\nfloat spline(float p0, float p1, float p2, float p3, float t)\n{\n\n    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +\n            (p0*2. - p1*5. + p2*4. - p3)*t*t +\n            (-p0 + p2)*t + p1*2.)*.5;\n}\nfloat splineTexture(float t, int y)\n{\n    int x = int(t);\n    t = fract(t);\n    float p0  =  getTexFloat(x-1, y);\n    float p1  =  getTexFloat(x, y);\n    float p2  =  getTexFloat(x+1, y);\n    float p3  =  getTexFloat(x+2, y);\n    p0 = spline(p0,p1,p2,p3,t);\n\n    return p0;\n}\nvoid getAnimations(float t)\n{\n     tilt.x = splineTexture(t, 1);\n     tilt.y = splineTexture(t, 2);\n     squint = splineTexture(t, 3)*.9+.2;\n}\n\nfloat audioMouth()\n{\n\tfloat a = pow(texelFetch(iChannel1, ivec2(20,0), 0).x, 3.5);\n    curl = (smoothstep(15.0, 16.5, gTime)*smoothstep(17.5, 17., gTime)) ;\n    curl += (smoothstep(21.5, 22., gTime)*smoothstep(22.1, 22., gTime))*.6 ;\n    ooo -= (smoothstep(21.5, 22., gTime)*smoothstep(22.1, 22., gTime)) *.5;\n    ooo -= (smoothstep(28.7, 29.2, gTime)*smoothstep(30.2, 29.5, gTime));  // \"SO!!\"\n\n    return a;\n}\nvec3 doLighting(vec3 pos, vec3 dir, bool ignoreSpecs)\n{\n    // Light the model...\n    vec3 col;\n    vec3 norm = doNormal(pos, ignoreSpecs);\n    float sh = shadow(pos+norm*.5, lightDir);\n    float b = max(dot(norm, lightDir),0.0);\n    float bl = max(dot(norm, backDir),0.0);\n    vec3 ref = reflect(dir, norm);\n    vec3 diff = CF(pos);\n    float s = pow(max(dot(ref, lightDir),0.0), specular)*specAmp;\n    col = (diff*b+ s*vec3(.6,.55, .5))*sh;\n    col += diff*illum+ diff*bl*vec3(0.05,0.05,.4)+.01;\n    return col;\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (-iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n\n\tgTime \t\t= max(iChannelTime[1]-1., 0.0);\n\n    // Time j-j-j-jumps...\n    if (gTime > 1.6 && gTime < 2.2) \n        gTime = 3.6+mod(gTime, .15);\n    \n\tif (gTime > 9.6 && gTime < 10.0) \n\t   gTime = 9.6+mod(gTime, .1);\n    \n\tif (gTime > 19.5 && gTime < 20.)\n        gTime = 20.5+mod(gTime, .2);\n\n\tif (gTime > 27.5 && gTime < 28.3)\n\t\tgTime = 3.5+mod(gTime, .15);\n\n    \n    lightDir\t= normalize( vec3(  -.7, 1.,  1. ) );\n    backDir\t= normalize( vec3(  5., -.6,  -4. ) );\n    vec3 camPos = vec3(cos(gTime*.2)*4.,sin(gTime*.23)*4.0-2.,22 );\n    vec3 camTar = vec3 (0,0, -2);\n    vec3 v = camTar - camPos;\n    eyeLook.x = atan(v.y, v.z);\n    eyeLook.y = atan(v.x, v.z);\n    mat3 camMat = setCamMat(camPos, camTar, 0.0);\n    \n    getAnimations(gTime*2.);\n\n    vec3 col =vec3(.1);\n    \n    vec3 dir  = normalize(camMat * ( vec3(uv, .9)));\n   \n    jaw = audioMouth();\n    \n    float dist = trace(camPos, dir, false, 75);\n    \n    vec3 pos = camPos + dir*dist;\n\n    if (dist < .0)\n    {\n        int side = 0;\n\n        vec3 rdir = dir*rotationXY(vec2(sin(gTime*.015)*10., sin(gTime*.011 )*10.));\n        pos = DistanceToBoxBack(rdir, side)*rdir;\n        //side = 1;\n        float f = fract(pos[side]*.01);\n        if (side == 0) \n            col = vec3(0., .7, .7);\n        else\n        if (side == 1) \n            col = vec3(.0, .4, 1.);\n        else\n            col = vec3(.7, .3, 1);\n        col *= smoothstep(.8, .9, f)*smoothstep(1.0, .9, f);\n    }else\n    {\n        // Light the model...\n\t\tcol = doLighting(pos, dir, false);\n    }\n    //  Did we hit the glasses...\n    if (inTransparency)\n    {\n        // Tint the result because of the sun glasses...\n        col*=.6;\n        camPos = pos;\n        dist = trace(camPos, dir, true, 15);\n        \n\t\tif (dist> 0.0)\n        {\n        \tpos = camPos + dir*dist;\n    \n            // Add in the rest of the face...\n\t        col += doLighting(pos, dir, true)*.4;\n        }\n    }\n        \n   \n\n    // Output to screen\n    col *= smoothstep(0.0,1.5, gTime) * smoothstep(38.5,36.0, gTime);\n    fragColor = vec4(sqrt(col),1.0);\n}    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 23985,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/dave-h-3/maxheadroom"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/// Thanks to IQ for these distance functions...\n\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\nfloat sMin( float a, float b, float k )\n{\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\nfloat sMax(in float x, in float y, in float s)\n{\n    float b = clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (b - 1.0) * (b - 1.0);\n}\n\nfloat sphere( vec3 p,float r )\n{\n    return length(p)-r;\n}\nfloat rBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    // distance bound\n    float d2 = max(q.x*0.866025+p.y*.5,-p.y)-h.x*.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}