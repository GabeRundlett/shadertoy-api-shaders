{
    "Shader": {
        "info": {
            "date": "1591805710",
            "description": "Percolation on a cubic lattice",
            "flags": 0,
            "hasliked": 0,
            "id": "tlfcDn",
            "likes": 12,
            "name": "Lattice Percolation",
            "published": 3,
            "tags": [
                "random",
                "lattice",
                "cluster"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 386
        },
        "renderpass": [
            {
                "code": "// \"Lattice Percolation\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Lattice percolation: grid cells are randomly occupied with probability p; adjacent\n  occupied cells are assigned to the same cluster; as p increases the mean cluster size\n  grows, and above a critical vaue of p there is a nonzero probability that a cell belongs\n  to the 'infinite' cluster. This is an extensively studied model that exhibits critical\n  behavior, and is widely used in many fields (including disease spreading).\n  \n  Here, the value of p oscillates slowly over a range of values, occupied cells are shown\n  containing spheres, and adjacent occupied cells are connected.\n  \n  Normal and panoramic views - mouseable\n*/\n\nfloat Minv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\n\nvec3 ltDir, cId;\nfloat tCur, dstFar, pVal;\nbool cOcc;\nconst float pi = 3.14159;\n\nbool IsOcc (vec3 c)\n{\n  return (pVal + Hashfv3 (c) > 1.);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d, rc, bl;\n  d = dstFar;\n  rc = 0.1;\n  bl = 0.251;\n  if (cOcc) {\n    p -= cId + 0.5;\n    for (float s = -1.; s <= 1.; s += 2.) {\n      if (IsOcc (cId + vec3 (s, 0., 0.)))\n         d = min (d, max (length (p.yz) - rc, abs (p.x - s * bl) - bl));\n      if (IsOcc (cId + vec3 (0., s, 0.)))\n         d = min (d, max (length (p.xz) - rc, abs (p.y - s * bl) - bl));\n      if (IsOcc (cId + vec3 (0., 0., s)))\n         d = min (d, max (length (p.xy) - rc, abs (p.z - s * bl) - bl));\n    }\n    /*if (d < dstFar)*/ d = min (d, length (p) - 1.5 * rc);\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cIdP, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p);\n    if (cId != cIdP) {\n      cOcc = IsOcc (cId);\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (cId + step (0., rd) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, nDotL;\n  bgCol = vec3 (0.1, 0.25, 0.3);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = vec3 (0.3, 1., 0.7);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = col * (0.1 + 0.3 * max (- dot (vn, ltDir), 0.) + 0.8 * nDotL * nDotL) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col = mix (col, bgCol, 0.3 + 0.7 * smoothstep (0.4, 1., dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, colF[2], col;\n  vec2 canvas, uv, ut, mSize, mMid, msw;\n  float el, az, asp, regId, regBdy, tc, ti, nStep;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (asp * (1. - mSize.y), 1. - mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuMode = 0;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuMode = 1;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = (mPtr.xy * vec2 (asp, 1.) - 0.5 * mMid) / mSize;\n    if (max (abs (msw.x), abs (msw.y)) < 0.5) regId = 1.;\n    else msw = mPtr.xy;\n    if (vuMode == 0) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n    if (regId == 1.) vuMode = 1 - vuMode;\n  }\n  regBdy = length (uv * vec2 (1. / asp, 1.)) - 1.5 * SmoothBump (0.5, 0.997, 0.003, mod (0.03/4. * tCur, 1.));\n  if (regBdy < 0.) vuMode = 1 - vuMode;\n  if (vuMode == 0 && mPtr.z <= 0.) {\n    az = -0.3 * pi * sin (0.01 * pi * tCur);\n    el = -0.1 * pi * cos (0.005 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0.01, 0.01, 0.5 * tCur);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 50.;\n  if (vuMode == 0) rd = normalize (vec3 (uv, 2.));\n  else rd = normalize (vec3 (0.5 * sin (uv.x * pi / asp + vec2 (0., 0.5 * pi)), uv.y).xzy);\n  rd = vuMat * rd;\n  tc = 1. - abs (1. - mod (0.03 * tCur, 2.));\n  nStep = 25.;\n  ti = floor (nStep * tc) / nStep;\n  for (int k = 0; k < 2; k ++) {\n    pVal = 0.01 + 0.98 * (ti + float (k) / nStep) ;\n    colF[k] = ShowScene (ro, rd);\n  }\n  col = mix (colF[0], colF[1], (tc - ti) * nStep);\n  if (vuMode == 1) col = pow (col, vec3 (0.9));\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 3. ||\n     abs (regBdy) * canvas.y < 1.) col = vec3 (0.5, 0.5, 0.);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}