{
    "Shader": {
        "info": {
            "date": "1609073478",
            "description": "Playing around with Zhao Liang's interpretation of Greg Egan's aperiodic hypercube projection routines to produce a triangular tiled weave.",
            "flags": 0,
            "hasliked": 0,
            "id": "WltcWr",
            "likes": 62,
            "name": "Aperiodic Hypercube Tile Weave",
            "published": 3,
            "tags": [
                "tile",
                "penrose",
                "hypercube",
                "lattice",
                "aperiodic",
                "weave",
                "ammann",
                "beenker",
                "pentagrid"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1186
        },
        "renderpass": [
            {
                "code": "/*\n\n    Aperiodic Hypercube Tile Weave\n    ------------------------------\n    \n    In short, this is an orthonormal projection of a five-demensional \n    hypercube lattice (pentagrid) onto a particularly aligned 2D plane. The\n    result is a versatile aperiodic tiling of rhomboids -- which have been\n    split along the short opposite diagonals to produce a triangular tiling. \n    If you look more closely at the resultant default pattern, you should be \n    able to make out some hidden icosahedral shapes.\n\n    More times than I can count, someone has dropped some exceptionally\n    nice code onto Shadertoy demonstrating a concept that is difficult\n    to find code for. The other day Zhao Liang posted a rough pixel shader \n    translation of Greg Egan's aperiodic hypercube tiling example written \n    in Javascript, which in turn was based on de Bruijn's algebraic approach \n    to aperiodic tiling -- The link to Zhao Liang's work is below.\n    \n    Virtually all of the difficult work was put together by Zhao Liang and\n    Grey Egan. All I've done is rearrange things a little and utilize it.\n    By the way, others on Shadertoy have produced similar code, like \n    Knighty's really nice \"Cut n'project\" example (link below), but I like \n    the way Zhao's code was presented, so went with that.\n    \n    The theory behind the method is such a clever piece of applied \n    mathematics that it's difficult to do it justice with a simple example. \n    The explanation as to why this particular method works and the history \n    behind the initial discovery is fascinating and really clever, but kind \n    of lengthy, so I've provided a list of examples and references below that \n    should explain it better than I can.\n    \n    I seem to say this a lot, but this isn't my area, so any corrections or\n    suggestions for improvement are always welcome.\n\n\n\n    Other Examples:\n    \n    // Zhao Liang's Shadertoy example. I've always wanted to produce one\n    // of these patterns using this method, so was pretty happy to see it.\n    Impossible aperiodic tiling - neozhaoliang\n    https://www.shadertoy.com/view/wsKBW1  \n    \n    // Also involves 5D projection. Very nice, and explained well. \n    Cut n'project - knighty\n    https://www.shadertoy.com/view/XdtBzH\n    //\n    // A related tiling. I'd like to do a standalone version along \n    // these lines too at some stage.\n    Ammann-Beenker - knighty\n    https://www.shadertoy.com/view/MddfzH\n    \n    \n    References:\n    \n    deBruijn -- Mathematical Details - Greg Egan\n    https://www.gregegan.net/APPLETS/12/deBruijnNotes.html\n    \n    Penrose Tilings -- Tied up in Ribbons\n    http://www.ams.org/publicoutreach/feature-column/fcarc-ribbons\n    \n    Penrose Tiling - Andrejs Treibergs\n    http://www.math.utah.edu/~treiberg/PenroseSlides.pdf\n    \n   \n*/\n\n\n\n// Random weave, or not. With a PN value of 5 or more, the patterns are\n// still interesting.\n#define RANDOM\n\n// Display the weave.\n#define WEAVE\n\n// Display the points.\n#define POINTS\n\n///////\n\n// Number of grid directions, which relate to the hypercube dimension. \n// I stuck with the original 5, as it looks nicest. However, I modified\n// things slightly so that it will work with other numbers -- about \n// 3 to 9. More than that and the pattern gets too tight. PN of 3 will \n// give you back a basic isometric grid -- subdivided into triangles.\n#define PN 5\n\n// As Zhao Liang pointed out, halving the grid numbers is the correct way to \n// handle even grid numbers, as it will result in an Ammann-Beenker tiling.\n// However, not doing so will still produce an interesting tiling pattern. \n// For instance, choosing \"PN = 4\" and commenting out the following will produce \n// a basic Truchet pattern.\n#define AMMANN_BEENKER\n\n\n \n\n// Note: I've left Zhao Liang's functions and comments largely untouched, but have\n// rewritten them to make it a litle more compact. However, that wouldn't necessarily\n// translate to speed or readability, so if you're interested in this kind of thing, \n// I'd strongly suggest referring to the original code, and perhaps looking at \n// Greg Egan's original Javascript.\n\n// Grid directions.\nvec2[PN] grid; \n// Five individual grid shift values. \nfloat[PN] shift; \n\n// The rhombus information.\nstruct Rhombus{\n\n    // r, s for the r-th and s-th grids.\n    int r, s;\n    // kr, ks, for the lines in the two grids.\n    float kr, ks;\n    \n    // Local coordinates and center.\n    vec2 p, cent;\n \n    // Rhombus vertices.\n    vec2[4] vert; \n \n}; \n \n\n// Find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s grids.\nvoid rhombusVerts(int r, int s, float kr, float ks, out vec2[4] vert){\n \n    // Produce points with +/- coordinates in intersection dimensions to \n    // complete projection... I was too lazy to double check this, but it\n    // seems to project to the plane as advertised, so that's good enough\n    // for me. :)\n    vec2 pI = grid[r]*(ks - shift[s]) - grid[s]*(kr - shift[r]);\n    pI = vec2(-pI.y, pI.x)/grid[s - r].y;\n  \n     \n    // Convert to screen coordinates.\n    vec2 sum = grid[r]*kr + grid[s]*ks;\n    for(int k=0; k<PN; k++) {\n    \n       // Intersection point notwithstanding, project the other points to \n       // the \"m + 1\"-th line in the k-th grid.\n       if(k != r && k != s) sum += grid[k]*ceil(dot(pI, grid[k]) + shift[k]); \n    }\n     \n    // Four vertices.\n    vert[0] = sum, vert[1] = sum + grid[r], vert[3] = sum + grid[s];\n    vert[2] = vert[1] + grid[s];\n\n}\n \n \n// Determine which rhombus the transformed point lies in by iterating over all possible \n// combinations... Part of me wonders whether there is a faster way, but GPUs are fast\n// anyway and for \"PN = 5,\" this is at most 40 checks (or thereabouts), which is more\n// than doable.\nRhombus rhombusInfo(vec2 p){\n\n\n    // Initate the rhombus struct.\n    Rhombus rb;\n    rb.p = vec2(0);\n    rb.vert = vec2[4](vec2(0), vec2(0), vec2(0), vec2(0));\n    \n    float[PN] pindex;\n\n    float theta;\n    for(int k=0; k<PN; k++){\n    \n        // Initiate the grid directions -- We choose the fifth roots of unity.\n        // Note the 1e-5 on the end. It's a hack I've added to make it work\n        // with other odd PN values. The tiny extra shift is a hack to get it\n        // working when PN is three.\n        shift[k] = 1./float(PN) + (PN==3? 1e-5 : 0.); // Penrose.\n        //shift[k] = hash21(vec2(k) + iDate.w)*.999 + .001; // Random shift option.\n        //shift[k] = .5; // Etc.\n        \n        #ifdef AMMANN_BEENKER\n        // Halve the number of grids for even numbers. \n        theta = PI/float(PN)*float(k)*((PN%2 == 1)? 2. : 1.);\n        #else\n        // The correct way to handle even numbered grids occurs above. However, you \n        // can still achieve a nice tiling pattern with double the grid numbers.\n        theta = PI*2./float(PN)*float(k);\n        #endif\n       \n        grid[k] = vec2(cos(theta), sin(theta));\n        \n        // Project the point to the m-th line in the k-th grid.\n        pindex[k] = (dot(p, grid[k]) + shift[k]);\n        \n   \n        // DeBruijn_transform.\n        // This is the \"continous\" transformation that maps a pixel to its position in the tiling\n        rb.p += grid[k]*pindex[k]; // Project \"p\" to the k-th grid;\n         \n    } \n    \n    \n    // Iterate over all rhomboids to determine which one we're inside, then return\n    // the pertinent information, like vertices, etc.\n    for(int r = 0; r<PN - 1; r++){\n    \n        for(int s = r + 1; s<PN; s++){\n        \n            // Thanks to Zhao Liang for realizing that even grid numbers\n            // require extra rhomboid searches.\n            for(int drs = 0; drs<9; drs++){\n                \n                // Odd numbered grids only require a 2x2 search. This is a\n                // hacky way to get around that.\n                if(PN%2==1 && drs<4) continue;\n                \n                float kr = floor(pindex[r]) + float((drs/3) - 1);\n                float ks = floor(pindex[s]) + float((drs%3) - 1);\n                rhombusVerts(r, s, kr, ks, rb.vert);\n\n                if(sdPoly4(rb.p, rb.vert)<=0.){\n\n                    rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                    r = s = PN; // Forcing a complete break?\n                    drs = 9;\n                    break;\n                }\n                \n            }\n       }         \n    }\n \n    // I noticed that the winding order was backward on some rhombuses, so\n    // had to fix that.\n    if(winding(rb.vert)>0.){\n       swap(rb.vert[0], rb.vert[2]);\n    }\n    \n    // Rhombus center.\n    rb.cent = (rb.vert[0] + rb.vert[1] + rb.vert[2] + rb.vert[3])/4.;\n    \n    return rb; // Return the rhombus.\n\n}\n\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale.\n    float gSc = 3.;\n    // Readjusting the scale for different dimensions.\n    if(PN==3) gSc += 1.; \n    if(PN>5) gSc = max(3. - float(PN - 5)*.5, 1.5);\n    \n    // Smoothing factor.\n    float sf = gSc*2./iResolution.y;\n    \n    // Scaling and translation.\n    vec2 p = uv*gSc + iTime/4.;\n    \n\n    // Obtain the rhombus information. This includes local coordinates\n    // and vertices.\n    Rhombus rh = rhombusInfo(p);\n    \n    \n   \n    // Rhobus vertices and mid edge points.\n    vec2[4] v = rh.vert; \n    vec2[4] e;\n    e[0] = mix(v[0], v[1], .5), e[1] = mix(v[1], v[2], .5);\n    e[2] = mix(v[2], v[3], .5), e[3] = mix(v[3], v[0], .5);\n    \n    // Mid edge point normals.\n    vec2[4] n;\n    n[0] = normalize(v[0] - v[1]).yx*vec2(1, -1), n[1] = normalize(v[1] - v[2]).yx*vec2(1, -1);\n    n[2] = normalize(v[2] - v[3]).yx*vec2(1, -1), n[3] = normalize(v[3] - v[0]).yx*vec2(1, -1);\n \n     \n    // Splitting the rhombus across the shortest opposite edge distance into two triangles.\n    float shortest = length(v[0] - v[2]);\n    int ind2 = length(v[0] - v[2])<length(v[1] - v[3])? 0 : 1;\n \n    // Determine which triangle we're in.\n    float wt = line(rh.p, v[ind2], v[(ind2 + 2)%4]);\n    int triIndex = wt<0.? 0 : 1;\n   \n    // Triangle information.\n    vec2[3] tri0;\n    if(triIndex == 0) tri0 = vec2[3](v[ind2], v[(ind2 + 1)%4], v[(ind2 + 2)%4]);\n    else tri0 = vec2[3](v[ind2], v[(ind2 + 2)%4], v[(ind2 + 3)%4]);\n    // Triange center.\n    vec2 triCent = (tri0[0] + tri0[1] + tri0[2])/3.;\n    \n    // The triangle distance field.\n    float tri = sdTriR(rh.p, tri0[0], tri0[1], tri0[2]);\n    \n    // Triangle ID.\n    int index = ((rh.r + rh.s)*2 + triIndex);\n    \n    // Using the ID for some color.\n    vec3 oCol = .5 + .45*cos(6.2831*(float(index))/float(PN*PN*2)*2. + vec3(0, 1, 2) - .25);\n    vec3 oCol2 = .5 + .45*cos(6.2831*dot(triCent, vec2(1))/float(PN*2) + vec3(0, 1, 2) - .25);\n    //oCol = vec3(float(index)/50.);\n    oCol = mix(oCol, pow(oCol*oCol2, vec3(.65))*2., .25); \n    oCol = mix(oCol, oCol.xzy, float(index)/float(PN*PN)/2.*3./6.);  \n    \n     // Initializing the scene background color.\n    vec3 col = vec3(.1);\n    \n    // Line width.\n    float lw = .02;\n    \n    // Render the colored background triangles.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., tri))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, tri));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, tri + lw));       \n    \n    /*\n    // Incircles (Uncomment the incircle routine also).\n    vec3 sCol = col;\n    vec3 inCB = inCentRad(tri0[0], tri0[1], tri0[2]);\n    float cir = length(rh.p - inCB.xy) - inCB.z/1.25;// + .015;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cir))*.9);\n    col = mix(col, mix(sCol*1.5, vec3(1), .0), (1. - smoothstep(0., sf, cir + .03)));\n    */\n    \n    // Indices for shuffling, in order to render the chords in random order.\n    const int N2 = 4;\n    int shuff[N2] = int[N2](0, 1, 2, 3);  // Initializing the shuffle array.\n\n    #ifdef RANDOM   \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think this \n    // is the Fisherâ€“Yates method, but don't quote me on it. It's been a while since I've used \n    // a shuffling algorithm, so if there are inconsistancies, etc, feel free to let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    //int index = N;\n    for(int i = N2 - 1; i>0; i--){\n\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each edge position.\n        float rs = hash21(rh.cent + fi/float(N2));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(shuff[i], shuff[j]);\n \n     }\n     #endif  \n     \n     \n     \n    \n    #ifdef WEAVE\n    // Using the rhombus mid edge points to create a weave. \n    \n    const float aW = .06; // Chord width.\n    float tightness = 3. + (float(PN) - 3.)/4.;\n    if(PN%2==0) tightness = 3.25;\n    #ifdef AMMANN_BEENKER\n    // More hacks to help everything work. \"One size fits all\" options can\n    // get messy. :)\n    if(PN>=8) tightness =  3. + (float(PN) - 3.)/4.;\n    #endif\n    \n    // Combining the mide edge points and normals.\n    vec4[4] p4 = vec4[4](vec4(e[0], n[0]), vec4(e[1], n[1]), vec4(e[2], n[2]), vec4(e[3], n[3]));\n\n    // Chord tighness.\n    float cr = length(p4[shuff[0]].xy - p4[shuff[1]].xy)/tightness;\n    // Chord distances.\n    float arc = doSeg(rh.p, p4[shuff[0]], p4[shuff[1]], cr) - aW;\n    cr = length(p4[shuff[2]].xy - p4[shuff[3]].xy)/tightness;\n    float arc2 = doSeg(rh.p, p4[shuff[2]], p4[shuff[3]], cr) - aW;\n\n    // Rndering the chords, or arcs.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., arc))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, arc + lw*1.6));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., arc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, arc2));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, arc2 + lw*1.6));\n    #endif\n\n    #ifdef POINTS\n    // Rhombus mid edge points... I think that add visual interest,\n    // but I could be wrong. :)\n    for(int i = 0; i<4; i++){\n    \n        float dv = length(rh.p - e[i]) - .1; //\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .1 - lw));\n    }\n    #endif\n  \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.141592653 \n\n// A swap without the extra declaration, but involves extra operations -- \n// It works fine on my machine, but if it causes trouble, let me know. :)\n//#define swap(a, b){ a = a + b; b = a - b; a = a - b; }\n\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\nvoid swap(inout vec2 a, inout vec2 b){ vec2 tmp = a; a = b; b = tmp; }\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// A random hash that I made up a while back. It's based on a few things\n// I've come across, but is mostly experimental. If it doesn't work on \n// your system, feel free to let me know.\nfloat hash21(vec2 p) {\n    \n    p = fract(p*2.014371)*128. - vec2(63.537567, 64.484713);\n    return fract(dot(p.xyx*p.xyy, vec3(128.390654, 128.713193, 2.1396217)));\n}\n\n\n// Triangle's incenter and radius.\nvec3 inCentRad(vec2 p0, vec2 p1, vec2 p2){\n    \n    // Side lengths.\n    float bc = length(p1 - p2), ac = length(p0 - p2), ab = length(p0 - p1);\n    vec2 inCir = (bc*p0 + ac*p1 + ab*p2)/(bc + ac + ab);   \n    \n    // Area.\n    float p = (bc + ac + ab)/2.;\n    float area = sqrt(p*(p - bc)*(p - ac)*(p - ab));\n    \n    return vec3(inCir, area/p);\n}\n\n// IQ's distance to a regular polygon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define NV2 4\n//\nfloat sdPoly4(in vec2 p, in vec2[NV2] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n\n\n// IQ's signed distance to a 2D triangle.\nfloat sdTri(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2){\n \n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n\n\tvec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0, e0)/dot(e0, e0), 0., 1.);\n\tvec2 pq1 = v1 - e1*clamp( dot(v1, e1)/dot(e1, e1), 0., 1.);\n\tvec2 pq2 = v2 - e2*clamp( dot(v2, e2)/dot(e2, e2), 0., 1.);\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x);\n    vec2 d = min( min( vec2(dot(pq0, pq0), s*(v0.x*e0.y - v0.y*e0.x)),\n                       vec2(dot(pq1, pq1), s*(v1.x*e1.y - v1.y*e1.x))),\n                       vec2(dot(pq2, pq2), s*(v2.x*e2.y - v2.y*e2.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// Rounded triangle routine. Not used here, but handy.\nfloat sdTriR(vec2 p, vec2 v0, vec2 v1, vec2 v2){\n     \n    vec3 inC = inCentRad(v0, v1, v2);\n    float ndg = .09/inC.z;\n    return sdTri(p, v0 - (v0 - inC.xy)*ndg,  v1 - (v1 - inC.xy)*ndg,  v2 - (v2 - inC.xy)*ndg) - .08;      \n        \n} \n\n// Vertice winding order... It works fine, but there'd be better ways.\nfloat winding(in vec2[NV2] v){\n\n    const int num = v.length();\n    float sum = 0.;\n    for (int i = 0; i < num; i++) {\n        vec2 v1 = v[i];\n        vec2 v2 = v[(i + 1)%num];\n        sum += (v2.x - v1.x)*(v2.y + v1.y);\n    }\n    \n    return sum>0.? 1. : -1.;\n}\n\n// Determines which side of a line a pixel is on. Zero is the threshold.\nfloat line(vec2 p, vec2 a, vec2 b){\n     return ((b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x));\n}\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = r;//length(b.xy - a.xy)/3.25;//1.732/6.; // ;//\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n//    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}