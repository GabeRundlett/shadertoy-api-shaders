{
    "Shader": {
        "info": {
            "date": "1518994180",
            "description": "This shader generates test bars for calibrating your monitor against the sRGB standard. See code comments for details.",
            "flags": 0,
            "hasliked": 0,
            "id": "MsdyD4",
            "likes": 11,
            "name": "gammatest",
            "published": 3,
            "tags": [
                "test",
                "gradient",
                "gamma",
                "monitor"
            ],
            "usePreview": 0,
            "username": "hellotanjent",
            "viewed": 10890
        },
        "renderpass": [
            {
                "code": "/*\nThis shader generates a test image for calibrating your monitor against the sRGB\nstandard.\n\nTo use, click the \"Go Fullscreen\" button at the bottom right of the shader and\nview the monitor from 3-5 feet away.\n\nIn a \"perfect\" result the color blocks will appear flat and motionless.\nIn a \"decent\" result the blocks will appear to have a faint wave pattern.\nIn a \"bad\" result the blocks will have very bright or dark waves.\n\nA monitor can be perfectly color-calibrated and still display waves in this test\n- the test is _very_ picky about the monitor displaying _exactly_ what the GPU\nis sending it.\n\nThe following things will all cause the waves to be more visible:\n\n- Non-native resolution\n- Display scaling not at 100%\n- Non-sRGB color space\n- Compressed color signals like YUV422, YUV420 YCbCr422, YCbCr420, etcetera.\n- \"Limited\" dynamic range color output\n- Too-high or too-low contrast, brightness, or gamma\n- Very high refresh rates\n- \"Fastest\" monitor overdrive modes\n- GSYNC or FreeSync turned on (in some cases, not all)\n- Sharpening filters\n- Black stabilizer filters\n- Inter-pixel interference inside the panel itself (mostly on VA panels)\n- Display stream compression, probably, though I can't currently test it.\n*/\n\n\nfloat gamma(float x) {\n  x = clamp(x, 0.0, 1.0);\n  // srgb standard\n  x = (x < 0.0031308) ? 12.92 * x : (1.0 + 0.055) * pow(x, 1.0 / 2.4) - 0.055;\n  \n  // gamma 2.2\n  //x = pow(x, 1.0 / 2.2);\n  return x;\n}\n\nfloat bit(float x, int bit) {\n    x = fract(x * exp2(float(-bit - 1)));\n    return x < 0.5 ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Divide the screen into 7 vertical stripes and make each one a different color.\n    float barX = floor(7.0 * fragCoord.x / iResolution.x) + 1.0;\n    float r = bit(barX, 0);\n    float g = bit(barX, 1);\n    float b = bit(barX, 2);\n    vec4 barColor = vec4(r, g, b, 1.0);\n\n    // Make each horizontal region 1/2 the brightness of the one above it.\n    int barY = int(8.0 * fragCoord.y / iResolution.y);\n    barColor *= exp2(float(barY - 8));\n    \n    // Make a moving horizontal wave pattern with a bit of a flat top and bottom.\n    float waveX = sin((iTime * 2.7 + 15.0 * fragCoord.x / iResolution.x) * 2.0 * 3.14159);\n    waveX *= 1.05;\n    waveX = clamp(waveX * 0.5 + 0.5, 0.0, 1.0);\n\n    // Interpolate between the pure color and a \"checkerboard\" version of the color\n    // based on the wave pattern.\n    float checker = (bit(fragCoord.x, 0) + bit(fragCoord.y, 0)) == 1.0 ? 0.0 : 1.0;\n    checker = checker * 2.0 - 1.0;\n    \n    fragColor = mix(barColor, barColor + barColor * float(checker), waveX);\n    \n    // Convert from linear color to inverse-gamma-corrected color.\n    // When displayed on a calibrated monitor, this will turn back into linear color.\n    fragColor.r = gamma(fragColor.r);\n    fragColor.g = gamma(fragColor.g);\n    fragColor.b = gamma(fragColor.b);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}