{
    "Shader": {
        "info": {
            "date": "1628908579",
            "description": "Doing this shader reminded me the Zeno's paradox.\nhttps://en.wikipedia.org/wiki/Zeno%27s_paradoxes",
            "flags": 0,
            "hasliked": 0,
            "id": "ft2SWt",
            "likes": 28,
            "name": "Zeno's dominoes",
            "published": 3,
            "tags": [
                "reflection",
                "zoom",
                "spiral",
                "loop",
                "infinite",
                "dominoes",
                "cineshader",
                "domino",
                "dominos",
                "zeno"
            ],
            "usePreview": 0,
            "username": "xjorma",
            "viewed": 6322
        },
        "renderpass": [
            {
                "code": "// Created by David Gallardo - xjorma/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define NO_UNROLL min(iFrame, 0)\n\nconst int nbPoints = 150;\nconst int pointsPerTurn = 30;\nconst float turnDuration = 3.0;\nconst float finalAngle = 1.19;\n\nconst float PI = radians(180.0);\n\nconst float maxDist = 10000.0;\n\nconst vec3 lightDir = normalize(vec3(0.4, 1.f, 0.7)); \nconst vec3 dominoSize = vec3(0.075, 0.4, 0.2);\n\nfloat smoothsteplin(in float edge0, in float edge1, in float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n}\n\nvec3 dominoColor(float v)\n{\n    vec3 col = vec3(sin(v * 0.43 + 2.85), sin(v * 0.63 + 1.28), sin(v * 0.81 + 4.71)) * 0.5 + 0.5;\n    return col / max(col.x, max(col.y, col.z));\n}\n\nfloat floorIntersect(in vec3 ro, in vec3 rd)\n{\n    if (rd.y < -0.01)\n    {\n        return ro.y / -rd.y;\n    }\n    return maxDist;\n}\n\n// Hash from Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nint dotsMask( in float v )\n{\n    int mask[6] = int[](16, 68, 84, 325, 341, 455);\n    return mask[int(hash11(v) * 6.0)];\n}\n\n\n// Box intersection by IQ https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n\n    return vec2( tN, tF );\n}\n\nvec3 getSkyColor(in vec3 rd)\n{\n    vec3 blue = smoothstep(.2, 1., rd.y) * vec3(0, 0, .5);\n    float nDotL = clamp(dot(rd, lightDir), 0., 1.);\n    vec3 highlight = vec3(pow(nDotL, 100.) * 2.0);\n    return vec3(blue + highlight);\n}\n\nfloat rayTrace(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color)\n{\n    float t = iTime;\n    float fltime = floor(t / turnDuration);\n    float frtime = fract(t / turnDuration);\n    float globalscale = 1.0 / (pow(0.5, 1.0 + frtime) * 2.0);\n    int domino = int(floor(float(pointsPerTurn) * frtime));\n    \n    float dist = floorIntersect(ro, rd);\n    if(dist < maxDist)\n    {\n        normal = vec3(0,1,0);\n        color = vec3(0.5);\n    }\n    \n    int hitDominoIte = -1;\n    vec3 hitDominoNormal;\n    mat4 hitDominoMatrix;\n    float hitDominoScale;\n\n    for(int i = domino + NO_UNROLL; i < nbPoints + domino; i++)\n    {\n        float turn = float(i) / float(pointsPerTurn);\n        float theta = 2.0 * PI * turn;\n        float phi = smoothsteplin((float(i) - 3.6) / float(pointsPerTurn), (float(i) + 1.0 + 0.5) / float(pointsPerTurn), frtime + 2.0) * finalAngle;\n        float fadeScale = smoothsteplin(float(i) - 4.0, float(i) + 1.0, frtime * float(pointsPerTurn) + (float(nbPoints) - 5.0));\n        float scale = pow(0.5, 1.0 + turn) * 2.0 * globalscale;\n        vec3 pos = vec3(cos(theta), 0, sin(theta)) * scale;\n        vec3 dir = vec3(-sin(theta) * cos(phi), -sin(phi), cos(theta) * cos(phi));\n        vec3 up = vec3(-sin(theta) * sin(phi), cos(phi), cos(theta) * sin(phi));\n        \n        vec3 size = dominoSize * scale * fadeScale * 0.5;\n        \n        \n        vec3 x = dir;\n        vec3 y = up;\n        vec3 z = cross(x, y);\n        mat4 r = mat4(\n        x.x,\t\ty.x,\t\tz.x,         0,\n        x.y,\t\ty.y,\t\tz.y,         0,\n        x.z,\t\ty.z,\t\tz.z,         0,\n        size.x,\t    -size.y,\t0,           1.0 );\n\n        mat4 t = mat4(\n        1.0,\t\t0.0,\t\t0.0,         0.0,\n        0.0,\t\t1.0,\t\t0.0,         0.0,\n        0.0,\t\t0.0,\t\t1.0,         0.0,\n        -pos.x,\t-pos.y,\t-pos.z,     1.0 );\n        \n        mat4 tr = r * t;\n        \n        vec3 n;\n        vec2 bi = boxIntersection( (tr * vec4(ro, 1)).xyz , (tr * vec4(rd, 0)).xyz, size, n);\n        if(bi.x > 0.0 && bi.x < dist)\n        {\n            dist = bi.x;\n            hitDominoIte = i;\n            hitDominoNormal = n;\n            hitDominoMatrix = tr;\n            hitDominoScale = scale;\n        }\n    }\n    if(hitDominoIte >= 0)\n    {\n        float dominoId = float(hitDominoIte) + fltime * float(pointsPerTurn);\n        color =  dominoColor(dominoId);\n        normal = (inverse(hitDominoMatrix) * vec4(hitDominoNormal, 0)).xyz;\n        // Dots\n        int msk;\n        vec2 p = (hitDominoMatrix * vec4((ro + dist * rd), 1)).zy / hitDominoScale;\n        if(p.y < 0.0)\n        {\n            msk = dotsMask(dominoId);\n            p.y += dominoSize.y * 0.25;\n        }\n        else\n        {\n            msk = dotsMask(dominoId + 1.0);\n            p.y -= dominoSize.y * 0.25;\n        }\n        for(int k = 0; k < 3; k++)\n        {\n            for(int l = 0; l < 3; l++)\n            {\n                float m = float(msk & (1 << (k * 3 + l)));\n                color *= max(1.0 - m, smoothstep(0.015, 0.016, distance(p, vec2(float(k - 1) * 0.050, float(l - 1) * 0.050))));\n            }\n        }\n    }\n    return dist;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 n, c;\n    float d = rayTrace(ro, rd, n, c);\n    \n    if(d < maxDist)\n    {\n        vec3 pos = ro + d * rd;\n        // Shadow\n        vec3 sc, sn;\n        float sd = rayTrace(pos + lightDir * 0.00001, lightDir, sn, sc);\n        float sh = 1.0;\n        if(sd < maxDist)\n        {\n            sh = 0.0;\n        }\n        // Reflection\n        vec3 refdir = reflect(rd, n);\n        vec3 rc, rn;\n        float rd = rayTrace(pos + refdir * 0.00001, refdir, rn, rc);\n        vec3 refcol = getSkyColor(refdir);\n        if(rd < maxDist)\n        {\n            refcol = rc * (max(0.0, dot(rn, lightDir)));\n        }\n        return c * (max(0.0, dot(n, lightDir)) * sh + 0.5) + refcol * 0.5;\n    }\n    return vec3(0);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera        \n    float theta\t= radians(0.0); //radians(360.) * (iMouse.x/iResolution.x-0.5); // + iTime*.2;\n    float phi\t= radians(-20.0); //radians(70.) * (iMouse.y/iResolution.y-0.5) - radians(60.);\n    vec3 ro = 0.45 * vec3( sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n    vec3 ta = vec3( 0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta );\n    vec3 rd =  ca*normalize(vec3(p,1.5));        \n    vec3 col = render(ro ,rd);  \n    col = pow(col, vec3(1. / 2.2));\n    col = vignette(col, fragCoord / iResolution.xy, 0.6);\n    fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}