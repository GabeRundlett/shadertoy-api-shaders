{
    "Shader": {
        "info": {
            "date": "1664348258",
            "description": "Tower with chained bubble",
            "flags": 0,
            "hasliked": 0,
            "id": "7lGfDz",
            "likes": 0,
            "name": "Tower Bubble",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Visiware",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "// License: MIT\n// This shader was ported to shadertoy from my GLSL experiments on PC for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// There is very many roughs\n\n#define PI 3.1415926535897932384626433832795\n#define PI2 (PI*2.)\n\n#define radians(x) ((x/360.0*PI2))\n\n#define FOV 1.309\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\nfloat smoothIntersectSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distA - distB)/k,0.0,1.0);\n\treturn mix(distA,distB,h) + k*h*(1.0 - h); \n}\n\nfloat smoothUnionSDF(float distA,float distB,float k) {\n\tfloat h = clamp(0.5 + 0.5*(distA - distB)/k,0.0,1.0);\n \treturn mix(distA,distB,h) - k*h*(1.0 - h); \n}\n\nfloat smoothDifferenceSDF(float distA, float distB, float k) {\n\tfloat h = clamp(0.5 - 0.5*(distB + distA)/k,0.0,1.0);\n\treturn mix(distA,-distB,h) + k*h*(1.0 - h); \n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixX(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[1][1] = cos(angle);\n\tm[2][1] = -sin(angle);\n\tm[1][2] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\nmat4 RotMatrixZ(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][1] = sin(angle);\n\tm[1][0] = -sin(angle);\n\tm[1][1] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nstruct MarchRet_t {\n\tfloat d;\n\tint i;\n};\n\n\nstruct CastRet_t {\n\tvec3 intersect;\n\tvec3 normal;\n\tbool casted;\n\t\n\tMarchRet_t march;\n};\n\n#define SMALLADD 0.004\n\n#define DISTMAX 3000.0\n\n\nMarchRet_t marchUnionSDF(MarchRet_t a,MarchRet_t b) {\n\tif (a.d < b.d) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn b;\n\t}\n}\n\n\n\n#define HEX_SEMISIZE 2.1\n#define HEX_SIZE (HEX_SEMISIZE*2.)\n#define HEX_MAXRADIUS (HEX_SEMISIZE/0.866)\n\n#define HEXAMAP_HEIGHT 10.0\n\n\n\nMarchRet_t HexagonSDF(vec3 ori) {\n\tif (ori.y > HEXAMAP_HEIGHT) {\n\t\treturn MarchRet_t(ori.y - (HEXAMAP_HEIGHT - 1.),0);\n\t}\n\t\n\tivec2 coord;\n\t\n\tvec3 o = ori;\n\tint zv = int(ori.z/5.0);\n\tif (ori.z < 0.) {\n\t\tzv++;\n\t}\n\tif (zv%2 == 1) {\n\t\to.x += HEX_MAXRADIUS;\n\t}\n\tcoord.x = int(o.x/5.0);\n\tcoord.y = int(o.z/5.0);\n\to.x = mod(o.x,5.0) - 2.5;\n\to.z = mod(o.z,5.0) - 2.5;\n\t\n\t\n\tvec2 norm0 = vec2(cos(radians(30.)),sin(radians(30.)));\n\tvec2 norm1 = vec2(cos(radians(90.)),sin(radians(90.)));\n\tvec2 norm2 = vec2(cos(radians(150.)),sin(radians(150.)));\n\t\n\tvec2 dir = normalize(o.xz);\n\t\n\tfloat v0 = length(o.xz)*sin(acos(dot(dir,norm0)));\n\tfloat v1 = length(o.xz)*sin(acos(dot(dir,norm1)));\n\tfloat v2 = length(o.xz)*sin(acos(dot(dir,norm2)));\n\t\n\tfloat d = max(max(max(abs(v0) - HEX_SEMISIZE,abs(v1) - HEX_SEMISIZE),abs(v2) - HEX_SEMISIZE),o.y + cos(float(coord.x)*3.0) + sin(float(coord.y)*1.5) - 1.0);\n\t\n\td /= 1.2;\n\t\n\treturn MarchRet_t(d,0);\n}\n\n\nMarchRet_t WallsSDF(vec3 o,vec3 dir) {\n\tfloat minuscube = max(-length(o.xz) + 30.,-o.y + 40.);\n\t\n\tfloat d = differenceSDF(length(o.xz) - 50.,minuscube);\n\t\n\treturn MarchRet_t(d,1);\n}\n\n\n\n#define CHAIN_WIDTH 800.0\n\nMarchRet_t ChainSDF(vec3 o) {\n\to = (RotMatrixZ(radians(239.98 - 30.0*(o.y/CHAIN_WIDTH)))*vec4(o,1.0)).xyz; // There is a bug, because this is a ported version\n\t\n\tfloat yv = o.y/1.5;\n\t\n\tfloat my = mod(yv,PI2);\n\t\n\tfloat av = sin(yv)*1.2;\n\t\n\tfloat d0 = length(vec2(o.x + av*float(my < PI2/2.),o.z + av*float(my >= PI2/2.))) - 0.5;\n\tfloat d1 = length(vec2(o.x + -av*float(my < PI2/2.),o.z + -av*float(my >= PI2/2.))) - 0.5;\n\t\n\tfloat d = smoothUnionSDF(d0,d1,0.25);\n\t\n\td = intersectSDF(d,max(o.y - CHAIN_WIDTH,-o.y));\n\t\n\treturn MarchRet_t(d,2);\n}\n\nMarchRet_t MainCloudSDF(vec3 o) {\n\treturn MarchRet_t(length(o) - 50.,3);\n}\n\n\nMarchRet_t SceneSDF(vec3 ori,vec3 dir) {\n\tMarchRet_t ret;\n\tret.i = 0;\n\t\n\tret = HexagonSDF(ori);\n\t\n\tret = marchUnionSDF(ret,WallsSDF(ori,dir));\n\t\n\tret = marchUnionSDF(ret,ChainSDF(ori + vec3(0,-20,0)));\n\t\n\tret = marchUnionSDF(ret,MainCloudSDF(ori + vec3(-600,-500,0)));\n\t\n\treturn ret;\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z),vec3(0,1,0)).d,\n\t\t\t\t\t\t  SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON),vec3(0,1,0)).d - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON),vec3(0,1,0)).d));\n}\n\n\n\n#define ITERMAX 200\n\n#define EPSILON 0.008\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir,float outmax) {\n\tCastRet_t maincast;\n\t\n\tmaincast.intersect = pos;\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\t\n\t\n\t\n\tvec3 ori = pos;\n\tfloat l = 0.;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tMarchRet_t march = SceneSDF(ori,dir);\n\t\t\n\t\tfloat d = march.d/1.5;\n\t\t\n\t\t\n\t\tif (l > outmax) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tl += d;\n\t\t\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.intersect = epspos;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tmaincast.march = march;\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n\t\n\treturn maincast;\n}\n\n\n\nvec3 ColorByMaterial(int index) {\n\tif (index == 0) {\n        return vec3(1.0,1.0,0.95);\n    }\n    else if (index == 1) {\n        return vec3(1.0,0.9,0.0);\n    }\n    else if (index == 2) {\n        return vec3(0.1,0.8,0.95);\n    }\n    else if (index == 3) {\n        return vec3(0.0,0.7,0.8);\n    }\n    return vec3(0);\n}\n\n\n\nbool mat_traceshadow(int index) {\n    return index == 1;\n}\n\nfloat mat_specular(int index) {\n    if (index == 0) {\n        return 900.0;\n    }\n    else if (index == 1) {\n        return 30.0;\n    }\n    else if (index == 2) {\n        return 80.0;\n    }\n    else if (index == 3) {\n        return 75.0;\n    }\n    return 0.0;\n}\n\n\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir,vec3 camera_pos) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tCastRet_t maincast = TraceObjects(pos,dir,DISTMAX);\n\t\n\tif (maincast.casted) {\n\t\tcolor = ColorByMaterial(maincast.march.i);\n\t\t\n\t\tvec3 lightpos = camera_pos + vec3(1.0,0,0);\n\t\tvec3 lightvecfull = lightpos - maincast.intersect;\n\t\tvec3 lightvec = normalize(lightvecfull);\n\t\t\n\t\tfloat cval = dot(maincast.normal,lightvec);\n\t\t\n\t\tbool shadowcasted = false;\n\t\t\n\t\tif (mat_traceshadow(maincast.march.i)) {\n\t\t\tvec3 shadow_pos = maincast.intersect + lightvec*SMALLADD;\n\t\t\t\n\t\t\t\n\t\t\tCastRet_t shadowcast = TraceObjects(shadow_pos,lightvec,length(lightvecfull));\n\t\t\tshadowcasted = shadowcast.casted;\n\t\t\t\n\t\t\t\n\t\t\tfloat spec = mat_specular(maincast.march.i);\n\t\t\t\n\t\t\tvec3 refl = normalize(maincast.normal*2.*dot(maincast.normal,lightvec) - lightvec);\n\t\t\t\n\t\t\tvec3 tocam = normalize(camera_pos - maincast.intersect);\n\t\t\t\n\t\t\tfloat cosangle = clamp(dot(tocam,refl),0.,1.);\n\t\t\tcval += pow(cosangle,spec);\n\t\t}\n\t\t\n\t\tif (cval < 0.0) {\n\t\t\tcolor = color*MINCOLOR;\n\t\t}\n\t\telse {\n\t\t\tif (shadowcasted) {\n\t\t\t\tcolor = color*MINCOLOR;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcolor = color*max(MINCOLOR,cval);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n    \n    mat4 camera = RotMatrixY(iTime*2.)*TransMatrix(150.0,300.0,1000.0 - 600.0*sin(iTime*0.97));\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir,vec3(camera[3][0],camera[3][1],camera[3][2])),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}