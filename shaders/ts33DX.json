{
    "Shader": {
        "info": {
            "date": "1569368973",
            "description": "My first ShaderToy entry : a poetic rain of stylized sakura flowers with intricate self shadowing and tilt-shift effect.",
            "flags": 0,
            "hasliked": 0,
            "id": "ts33DX",
            "likes": 103,
            "name": "Sakura Bliss",
            "published": 3,
            "tags": [
                "2d",
                "flower",
                "bokeh",
                "pattern",
                "cherry",
                "blossom",
                "sakura"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 4158
        },
        "renderpass": [
            {
                "code": "//\n// Sakura Bliss by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n//\n// I recently stumbled upon Martijn Steinrucken aka BigWings Youtube channel\n// his work amazed me and inspired me to take a leap and try it out for myself.\n//\n// This is my first ShaderToy entry.\n//\n\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n\n\n// Borrowed from BigWIngs\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Computes the RGB and alpha of a single flower in its own UV space\nvec4 sakura(vec2 uv, vec2 id, float blur)\n{\n    float time = iTime + 45.0; //time is offset to avoid the flowers to be aligned at start\n    \n    vec4 rnd = N14(mod(id.x, 500.0) * 5.4 + mod(id.y, 500.0) * 13.67); //get 4 random numbersper flower\n    \n    // Offset the flower form the center in a random Lissajous pattern\n    uv *= mix(0.75, 1.3, rnd.y);            \n    uv.x += sin(time * rnd.z * 0.3) * 0.6;\n    uv.y += sin(time * rnd.w * 0.45) * 0.4;\n    \n    \n    // Computes the angle of the flower with a random rotation speed\n    float angle = atan(uv.y, uv.x) + rnd.x * 421.47 + iTime * mix(-0.6, 0.6, rnd.x);\n    \n    \n    // euclidean distance to the center of the flower\n    float dist = length(uv);\n   \n  \t// Flower shaped distance function form the center\n    float petal = 1.0 - abs(sin(angle * 2.5));\n    float sqPetal = petal * petal;\n    petal = mix(petal, sqPetal, 0.7);\n    float petal2 = 1.0 - abs(sin(angle * 2.5 + 1.5));\n    petal += petal2 * 0.2;\n    \n    float sakuraDist = dist + petal * 0.25;\n    \n   \n    // Compute a blurry shadow mask.\n    float shadowblur = 0.3;\n    float shadow = S(0.5 + shadowblur, 0.5 - shadowblur, sakuraDist) * 0.4;\n    \n    //Computes the sharper mask of the flower\n    float sakuraMask = S(0.5 + blur, 0.5 - blur, sakuraDist);\n    \n    // The flower has a pink hue and is lighter in the center\n    vec3 sakuraCol = vec3(1.0, 0.6, 0.7);\n    sakuraCol += (0.5 -  dist) * 0.2;\n    \n\t// Computes the border mask of the flower\n    vec3 outlineCol = vec3(1.0, 0.3, 0.3);\n    float outlineMask = S(0.5 - blur, 0.5, sakuraDist + 0.045);\n    \n    // Defines a tiling polarspace for the pistil pattern\n    float polarSpace = angle * 1.9098 + 0.5;\n    float polarPistil = fract(polarSpace) - 0.5; // 12 / (2 * pi)\n    \n    // Round dot in the center\n    outlineMask += S(0.035 + blur, 0.035 - blur, dist);\n    \n    float petalBlur = blur * 2.0;\n    float pistilMask = S(0.12 + blur, 0.12, dist) * S(0.05, 0.05 + blur , dist);\n    \n    // Compute the pistil 'bars' in polar space\n    float barW = 0.2 - dist * 0.7;\n    float pistilBar = S(-barW, -barW + petalBlur, polarPistil) * S(barW + petalBlur, barW, polarPistil);\n    \n    // Compute the little dots in polar space\n    float pistilDotLen = length(vec2(polarPistil * 0.10, dist) - vec2(0, 0.16)) * 9.0;\n    float pistilDot = S(0.1 + petalBlur, 0.1 - petalBlur, pistilDotLen);\n    \n    //combines the middle an border color\n    outlineMask += pistilMask * pistilBar + pistilDot;\n    sakuraCol = mix(sakuraCol, outlineCol, sat(outlineMask) * 0.5);\n    \n    //sets the background to the shadow color\n    sakuraCol = mix(vec3(0.2, 0.2, 0.8) * shadow, sakuraCol, sakuraMask);\n    \n    //incorporates the shadow mask into alpha channel\n    sakuraMask = sat(sakuraMask + shadow);\n    \n\t//returns the flower in pre-multiplied rgba\n    return vec4(sakuraCol, sakuraMask);\n}\n\n// blends a pre-multiplied src onto a dst color (without alpha)\nvec3 premulMix(vec4 src, vec3 dst)\n{\n    return dst.rgb * (1.0 - src.a) + src.rgb;\n}\n\n// blends a pre-multiplied src onto a dst color (with alpha)\nvec4 premulMix(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = premulMix(src, dst.rgb);\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n    return res;\n}\n\n\n// Computes a Layer of flowers\nvec4 layer(vec2 uv, float blur)\n{\n    vec2 cellUV = fract(uv) - 0.5;\n    vec2 cellId = floor(uv);\n    \n    vec4 accum = vec4(0.0);\n    \n    // the flowers can overlap on the 9 neighboring cells so we blend them all together on each cell\n    for (float y = -1.0; y <= 1.0; y++)\n    {\n        for (float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offset = vec2(x, y); \n            vec4 sakura = sakura(cellUV - offset, cellId + offset, blur);\n            accum = premulMix(sakura, accum);\n        }\n    }\n    \n \treturn accum;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 nominalUV = fragCoord/iResolution.xy;\n    \n    vec2 uv = nominalUV - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Scroll the UV with a cosine oscillation\n    uv.y += iTime * 0.1;\n    uv.x -= iTime * 0.03 + sin(iTime) * 0.1;\n    \n    uv *= 4.3;\n\n    //Compute a BG gradient\n    float screenY = nominalUV.y;\n    vec3 col = mix(vec3(0.3, 0.3, 1.0), vec3(1.0, 1.0, 1.0), screenY);\n    \n    // Compute a tilt-shift-like blur factor\n    float blur = abs(nominalUV.y - 0.5) * 2.0;\n    blur *= blur * 0.15;\n    \n    // Computes several layers with various degrees of blur and scale\n    vec4 layer1 = layer(uv, 0.015 + blur);\n    vec4 layer2 = layer(uv * 1.5 + vec2(124.5, 89.30), 0.05 + blur);\n    layer2.rgb *= mix(0.7, 0.95, screenY);\n    vec4 layer3 = layer(uv * 2.3 + vec2(463.5, -987.30), 0.08 + blur);\n    layer3.rgb *= mix(0.55, 0.85, screenY);\n    \n    // Blend it all together\n\tcol = premulMix(layer3, col);\n    col = premulMix(layer2, col);\n\tcol = premulMix(layer1, col);\n    \n    // Adds some light at the to of the screen\n    col += vec3(nominalUV.y * nominalUV.y) * 0.2;\n\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}