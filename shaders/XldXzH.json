{
    "Shader": {
        "info": {
            "date": "1478186073",
            "description": "Day 2. Took yesterday's fokeh shader, added a crappy raymarched thing. It looked like crap. Deleted the bokeh stuff, added some cheap fake as hell refraction and reflection, called it a day. Tomorrow will probably be a tidy up of this with a few tweaks ;)",
            "flags": 0,
            "hasliked": 0,
            "id": "XldXzH",
            "likes": 5,
            "name": "The Daily Shade day 2: sphere",
            "published": 3,
            "tags": [
                "raymarch",
                "sphere",
                "daily"
            ],
            "usePreview": 0,
            "username": "psonice",
            "viewed": 965
        },
        "renderpass": [
            {
                "code": "// Day 2: Add some raymarched thing to the bokeh from day 1... \n// ...which didn't work so well, bokeh deleted.\n\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\n// maximum iteration count\n#define kMAXITERS 100\n#define kEPSILON 0.01\n\n// A camera. Has a position and a direction. \nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n    \n// A ray. Has origin + direction.\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// A disk. Has position, size, colour.\nstruct Disk {\n    vec3 pos;\n    float radius;\n    vec3 col;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float radius;\n};\n        \n    vec4 intersectDisk(in Ray ray, in Disk disk, in float focalPoint) {\n        // Move ray to Z plane of disk\n        ray.origin += ray.dir * disk.pos.z;\n        \n        // Find distance from ray to disk (only xy needs considering since they have equal Z)\n        float dist = length(ray.origin.xy - disk.pos.xy);\n        \n        // blur depends on distance from focal point\n        float blurRadius = abs(focalPoint - disk.pos.z) * 0.1;\n       // blurRadius = 0.5 + disk.pos.z * 0.5;\n        // Calculate alpha component, using blur radius and disk radius\n        float alpha = 1. - smoothstep(max(0., disk.radius - blurRadius), disk.radius + blurRadius, dist);\n       \n        // Limit to 50% opacity\n        alpha *= 0.3;\n       \t\n        // Pre-multiply by alpha and return\n        return vec4(disk.col * alpha, alpha);\n    }\n\n// Normalised random number, borrowed from Hornet's noise distributions: https://www.shadertoy.com/view/4ssXRX\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sphereDist(in Ray ray, in Sphere sphere) {\n    return length(ray.origin - sphere.pos) - sphere.radius;\n}\n\nfloat sceneDist(in Ray ray) {\n    Sphere s0 = Sphere(vec3(0, 0, 0), 2.0);\n \treturn sphereDist(ray, s0);\n}\n\nvec3 normal(in Ray ray) {\n    vec2 eps = vec2(kEPSILON, 0);\n    float baseDist = sceneDist(ray);\n \treturn normalize(vec3(\n        sceneDist(Ray(ray.origin + eps.xyy, ray.dir)) - baseDist,\n        sceneDist(Ray(ray.origin + eps.yxy, ray.dir)) - baseDist,\n        sceneDist(Ray(ray.origin + eps.yyx, ray.dir)) - baseDist\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We'll need a camera. And some perspective.\n    \n\t// Get some coords for the camera angle from the frag coords. Convert to -1..1 range.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2. - 1.;\n    \n    // Aspect correction so we don't get oval bokeh\n    uv.y *= -iResolution.y/iResolution.x;\n    \n    // Make a camera at 0,0,0 pointing forwards\n    Camera cam = Camera(vec3(0, 0, -5.), vec3(0, 0, 1));\n                        \n    // Find the ray direction. Simple in this case.\n    Ray ray = Ray(cam.pos, normalize(cam.dir + vec3(uv, 0)));\n    \n    float time = iTime * 0.1;\n    \n    ray.origin.xz = R(ray.origin.xz, time);\n    ray.dir.xz = R(ray.dir.xz, time);\n    \n    // Let's raymarch some stuff and inject that into the scene...\n    \n    Ray marchRay = ray;\n    float maxZ = 1000.0;\n    bool hit = false;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        float d = sceneDist(marchRay);\n        marchRay.origin += marchRay.dir * d;\n        \n        if (d < kEPSILON) {\n            maxZ = marchRay.origin.z;\n            hit = true;\n            break;\n        }\n    }\n    \n    // Create an empty colour\n    vec4 col = vec4(0.0);\n    \n    vec3 n = normal(marchRay);\n    \n    vec3 samplePos = hit ? refract(ray.dir, n, 0.85) : ray.dir;\n    col = texture(iChannel0, samplePos);\n    if (hit) {\n        float fresnel = 1. -abs(dot(n, ray.dir));\n        fresnel = pow(fresnel, 2.0);\n       \n    \tcol = mix(col, texture(iChannel1, -n), fresnel);\n    }\n    \n\tfragColor = vec4(col.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}