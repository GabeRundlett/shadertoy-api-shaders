{
    "Shader": {
        "info": {
            "date": "1524575769",
            "description": "(WIP)  \ncolored version of [url]https://www.shadertoy.com/view/MstBR7[/url]\n\nnot the right filling strategy because:\n- very not-stared contour (\"wave\", \"crocodile leg\")) would fail\n- segment elbows missing\n",
            "flags": 0,
            "hasliked": 0,
            "id": "lsdBR7",
            "likes": 4,
            "name": "escherized tiling 2 (WIP)",
            "published": 3,
            "tags": [
                "escher",
                "pattern",
                "tile",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 647
        },
        "renderpass": [
            {
                "code": "// colored variant of https://shadertoy.com/view/MstBR7\n// polylines must pass to corners and mid-side of brick.\n\n#define MM 0\nfloat  CELL = 10.,                   // grid size vertically -> cell size\n      RATIO = 2.,                    // brick length / brick width\n      BEVEL = .1,                    // bevel width ( cell %  )\n       GAP  = 0.;                    // inter brick gap ( cell % )\nvec2  CYCLE = 0.*vec2(3,2);          // pattern repeat scale ( in #brick )\n      \nbool  BRICK = true;                  // tiling or bricks\n\n// .---1---.---2---.\n// |               |\n// 3               3\n// |               |\n// .---2---.---1---.\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.25,.1), vec2(.75,-.1),vec2(1,0) );\nvec2 polyline2[] = vec2[]( vec2(0,0), vec2(.25,.3), vec2(.5,.1),  vec2(.75,-.3),vec2(1,0) );\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(.1,-.25), vec2(0,-.4), vec2(-.3,-.75),vec2(0,-1) );\n\n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x )              // integer param\n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU);\n}\nvec3 hash3f(vec3 x) {              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU) ) );\n}\n\n// distance to line\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n\treturn length( p - b*hs );     // with round edges\n  //return h==hs ? length( p - b*hs ) : 1e5; // without round edge\n}\n\n// signed distance to line\nfloat sline( vec2 p, vec2 a, vec2 b , float s)\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ), l;\n    p -= b*hs;                     // projection point on line\n    l = length(p) * s* sign(p.x*b.y-p.y*b.x); // signed distance to line\n\t//return l;                   // with round edges\n    return h==hs ? l : 1e5;       // without round edge\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    O -= O;\n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    U *= CELL/W;\n#if !MM\n     if (!BRICK && RATIO==2.) polyline1[polyline1.length()-1] = vec2(2,0);\n    BEVEL = 1.5*CELL/R.y;                       // <- for demo\n#endif\n    float ofs = mod(floor(U.y),2.);\n    if (BRICK) \n        U.x += .5*ofs;\n    else ofs = 0.;\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n\n    float d = 1e5,s,l, X = RATIO/2.;\n    \n#define testline(O,sgn,T)                          \\\n        l =  sline( S-O, _P, P ,sgn) ;             \\\n        if (abs(l)< d) d = abs(l), s=l, D = s>0.? vec2(0): T;\n    \n    vec2 P = polyline1[0], _P, D; \n    float X0 = BRICK ? 0. : -X;\n    for (int i=0; i < polyline1.length()-1; i++) {\n        _P = P; P = polyline1[i+1];\n        testline( vec2(-X, .5), 1., vec2(  -ofs, 1) );\n        testline( vec2(X0,-.5),-1., vec2(float(BRICK)-ofs,-1) );\n    }\n    if (BRICK) {\n    P = polyline2[0];\n    for (int i=0; i < polyline2.length()-1; i++) {\n        _P = P; P = polyline2[i+1];\n        testline( vec2( 0, .5), 1., vec2(1.-ofs, 1) );\n        testline( vec2(-X,-.5),-1., vec2(  -ofs,-1) );\n    }}\n    P = polyline3[0];\n    for (int i=0; i < polyline3.length()-1; i++) {\n        _P = P; P = polyline3[i+1];\n        testline( vec2( X, .5), 1., vec2( 1,0) );\n        testline( vec2(-X, .5),-1., vec2(-1,0) );\n    }\n    \n    vec2 H = U+D+1.; // vec2 tile id\n    H = CYCLE==vec2(0) ? H : mod(H,CYCLE);\n    O += clamp ( (d-GAP)/BEVEL, 0., 1.); \n#if !MM    \n    O.rgb *= hash3(uvec3(H,2));\n#else  \n // O-=O;\n    O.r =  hash3(uvec3(H,2)).r;\n#endif    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}