{
    "Shader": {
        "info": {
            "date": "1593000242",
            "description": "Test for future shader",
            "flags": 0,
            "hasliked": 0,
            "id": "tlsyWB",
            "likes": 4,
            "name": "Red Noisy volume, Dark inside",
            "published": 3,
            "tags": [
                "noise",
                "sphere",
                "red",
                "dark",
                "bolume"
            ],
            "usePreview": 0,
            "username": "Leria",
            "viewed": 360
        },
        "renderpass": [
            {
                "code": "#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct BlackHole\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //blackhole mass\n    float attraction_radius; //attraction radius of the blackhole\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nBlackHole bh;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\n//iq noise\n/*\n\nfloat hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n*/\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nfloat fbm( vec3 p ) { // in [-1,1]\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.;\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    return f;\n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tbh = BlackHole(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 bh_vec = bh.pos - p;\n    float d = dot(bh_vec,bh_vec);\n    vec3 res = normalize(bh_vec) * (GRAV_CONST*bh.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 12), bh.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n/*note:\n\n               if(sdf_cylinder(p-bh.pos, vec3(0., 0., -1.), vec3(0., 0., 1.), \n                        RADIUS) < 0.)\n        {\n            vec4 tex = texture(iChannel0, p/16.+0.05*iTime);\n           \n            t_loc = clamp(   smoothstep(-.5,.5,tex.r)\n                            - smoothstep(2.,.5,length(p)-RADIUS/2.+8.*((2.*fbm(p/8.)-1.))) , 0.,1.);\n            t_gen *= t_loc;\n        }  \n\n*/\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    vec3 c_tmp = vec3(0);\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //p = ( vec4(p, 1.)*ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n    float perturbation = fbm(p);\n  \tfloat dens = perturbation;\n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {       \n        //p = (vec4(p, 1.)*vec4(ROT(vec3(0., 1., 0.), degree) * cam.view).xyz;\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(bh.pos-cam.pos);\n        vec3 center = p-bh.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5;\n\n        if(d > -.5)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }\n        \n        float anim_coef = 1.5*cos(0.);\n        //center = (vec4( center, 1.) * ROT(vec3(0., 1., 0.), degree) ).xyz*(vec4( center, 1.) * ROT(vec3(1., 0., 0.), degree2) * cam.view ).xyz ;\n\t\t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            float anim_coef = 1.5*cos(iTime);\n            \n            #if COLOR           \n            float n = ( abs(fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     2.*RADIUS+anim_coef, \n                                     (RADIUS-length(center))- 128.*n) ;\n            \n            /*\n\t\n\t\t\t//Avec Bnoise()\n\n            float n = ( (fbm(p/8.*anim_coef)));\n            float mask = smoothstep(.2, \n                                     3.*RADIUS+anim_coef, \n                                     (RADIUS-length(p))- 64.*n) ;\n*/\n            \n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            vec3 rgb_t = vec3(transp(uniform_step, 4.,  dens), \n                      \ttransp(uniform_step, 16.,dens ),\n              \t      \ttransp(uniform_step, 16., dens));  \n            t_acc *= rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+bh.accretion_disk_radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = t_acc;\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    bh.pos = normalize(vec3(-10, 20., bh.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}