{
    "Shader": {
        "info": {
            "date": "1520587938",
            "description": "Num keys : nb of arms\nMouse.x : rotation\nMouse.y : warp\nF : flip\nToggles :\nW : white orthogonal spiral\nM : white orthogonal mesh\nB : bulb\nD : debug display\nR : reset zone display\n\nN : normals & tangents\nL : long normals",
            "flags": 16,
            "hasliked": 0,
            "id": "Xd3cWf",
            "likes": 3,
            "name": "Spiral orthogonality",
            "published": 3,
            "tags": [
                "spiral",
                "logarithmic",
                "orthogonal",
                "orthogonality"
            ],
            "usePreview": 0,
            "username": "ABizard",
            "viewed": 651
        },
        "renderpass": [
            {
                "code": "\n// Thanks to FabriceNeyret for his help :-)\n\n/*\nPaste this in js console :\nM101 :\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/M101_hires_STScI-PRC2006-10a.jpg/1280px-M101_hires_STScI-PRC2006-10a.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nor\nM51 :\ngShaderToy.SetTexture(0, {mSrc:'https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Messier51_sRGB.jpg/1280px-Messier51_sRGB.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n#define M101 1\t// M51 or M101 ?\n\n//#define SMOOTH(V,A) smoothstep(3./iResolution.y,0.,abs(V)-A)\n#define SMOOTH(V,A) smoothstep(1.5,0.,abs(V) / min(1.,length(vec2(dFdx(V),dFdy(V)))) - A)\n\n#define PI 3.141593\n#define E 2.718282\n\n#define keyToggle(K) (texture(iChannel1,vec2((.5+float(K))/256.,0.75)).x > 0.)\n#define keyPress(K) (texelFetch(iChannel1, ivec2(K, 0), 0).x > 0.)\n\n#define InBLCorner(UV) (length(UV)<30.)\n//#define InBLCorner(UV) false\n\n\n#define BLACK\t\tvec3(0)\n#define WHITE\t\tvec3(1)\n#define GREY(A)\t\tvec3(A)\n#define RED  \t\tvec3(1,0,0)\n#define GREEN\t\tvec3(0,1,0)\n#define BLUE \t\tvec3(0,0,1)\n#define TURQUOISE \tvec3(0,1,1)\n#define YELLOW \t\tvec3(1,1,0)\n#define PURPLE \t\tvec3(.5,0,1)\n#define LIGHT_BLUE\tvec3(0,.5,1)\n#define PINK\t\tvec3(1,.3,.7)\n\n///////\n// Default parameters for the spiral :\n// Zoom\n#define DEF_ALPHA .1\n// Warp\n//#define DEF_BETA (E - 1.)/2. + 1.\n#define DEF_BETA 3.\n// Number of arms\n#define DEF_N 3\n// Rotation\n#define DEF_GAMMA 0.\n///////\n\n// Max number of arms - actually the size of array \"colors\" :-)\n#define MAX_N 6\n\n#define WHITE_MESH 2\n#define ORTH_MESH_FACTOR 1./log(beta)\n\n#define SPIRAL_THICKNESS\t\t1.5\n#define ORTH_MESH_THICKNESS\t\t.1\n\n// Number of normal/tangents samples per 2PI (per revolution)\n#define SAMPLES 4\n\n// Number of revolutions of the spiral\n#define SPIRAL_SIZE 5\n\n//////////////////////////////////////////////\n// Keyboard controls\n\n// 'F' : flip the spiral\n#define FLIP\t\t\t\t!keyToggle(70)\n// 'W' : display white orthogonal spiral\n#define DO_WHITE_SPIRAL\t\t keyToggle(87)\n// 'M' : display white orthogonal mesh\n#define DO_WHITE_MESH\t\t!keyToggle(77)\n// 'D' : display the spiral parameters\n#define DISPLAY_PARAMS\t\t keyToggle(68)\n// 'R' : display reset zone\n#define DISPLAY_RESET\t\t keyToggle(82)\n// 'B' : display a bulb at the center\n#define DO_BULB\t\t\t\t!keyToggle(66)\n\n// 'N' : draw the normals\n#define DO_NORMALS_SAMPLES\t keyToggle(78)\n// 'L' : do short or long normals ? \n#define LONG_NORMALS\t \t keyToggle(76)\n\n//////////////////////////////////////////////\n\n#define R iResolution\n\n\n// Colors of the arms\nconst vec3[] colors = vec3[](RED,GREEN,YELLOW,PURPLE,PINK,TURQUOISE);\n\n// rho = f(theta)\nfloat f(float theta, float alpha, float beta){\n    return alpha*pow(beta,theta);\t\t\t\t\t// Logarithmic spiral\n    //return alpha+beta*(theta);\t\t\t\t\t// Archimede spiral\n}\n\n// f'\nfloat df(float theta, float alpha, float beta){\n    return alpha*pow(beta,theta) * log(beta);\t\t// Logarithmic spiral\n    //return beta;\t\t\t\t\t\t\t\t\t// Archimede spiral\n}\n\n// Offset to repeat the spiral\n#define OFFSET(K,ARM,N) float(K)*2.*PI + (float(ARM)/float(N))*2.*PI\n\nvoid drawSpiral(inout vec3 color, vec3 spiral_color, float thickness,\n                float rho, float theta, float alpha, float beta, float gamma,\n                int arm, int total_arms){\n    for(int k=-SPIRAL_SIZE; k<=SPIRAL_SIZE; k++)\n            color = mix(color,spiral_color,\n                        SMOOTH(rho - f(theta+gamma+OFFSET(k,arm,total_arms),alpha,beta),thickness));\n}\n\nvoid drawTangentAndNormal(vec2 pixel, float theta, float alpha, float beta, float gamma, int n, int k, int arm, inout vec3 color){\n    \n    float rho = f(theta+gamma+OFFSET(k,arm,n),alpha,beta);\n    if(rho>0.05){\n        float drho_dtheta = df(theta+gamma+OFFSET(k,arm,n),alpha,beta);\n        float dy_dx = (drho_dtheta*sin(theta) + rho*cos(theta))\n            / (drho_dtheta*cos(theta) - rho*sin(theta));\n\n        vec2 point_on_spiral = vec2(rho*cos(theta),rho*sin(theta));\n        // (x,y) with origin on the point of intersection with the spiral\n        vec2 xy = pixel - point_on_spiral;\n\n        // Tangent in blue\n        if(length(xy)<.05){\n        \tfloat tangent_slope = dy_dx;\n            color = mix(color,BLUE,\n                        SMOOTH(distPointToLine(xy,tangent_slope,1.),SPIRAL_THICKNESS));\n        }\n        // Normal in white\n        if(LONG_NORMALS || length(xy)<.05){\n            float normal_slope = -1./dy_dx;\n            color = mix(color,WHITE,\n                        SMOOTH(distPointToLine(xy,normal_slope,1.),SPIRAL_THICKNESS*.5));\n        }\n    }\n}\n\n//////////////////////////////////////////////\n///////////////////  MAIN  ///////////////////\n//////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    \n    // Centered normalized coordinates in [-1,1]\n    vec2 pixel = 2.*(fragCoord-floor(R.xy/4.)*2.) / R.y;\n    \n    if(FLIP)\n        pixel.y = -pixel.y;\n    \n    // Polar coords\n\tfloat rho = length(pixel),\n          theta = atan(pixel.y,pixel.x); // theta in [-PI,PI]\n    \n    \n    // Parameters of the spiral\n    float alpha,\t// zoom\n          beta,\t\t// warp\n    \t  gamma;\t// rotation\n    int\t  n;\t\t// number of arms\n    \n    // Tuning of the parameters\n    vec2 mouse = iMouse.xy;\n    bool control_by_mouse = !InBLCorner(mouse);\n    beta  =\tcontrol_by_mouse ?\n        \t\t1. + POW2(mouse.y/R.y + .15)*3.\t\t: DEF_BETA;\n    gamma =\tcontrol_by_mouse ?\n        \t\t(mouse.x/R.x)*2.*PI\t\t\t\t\t: DEF_GAMMA;\n    alpha = DEF_ALPHA;\n        \n    n = DEF_N;\n    for(int i=1;i<=MAX_N;i++)\t// Num keys to change n\n        if(keyPress(48+i))\n            n = i;\n    \n    /////////////////////////\n    // Custom texure (optional)\n    \n#if M101\n    // Offset if the center of the galaxy is not the center of the image\n    vec2 tex_offset1 = vec2(-4,-3);\n    float image_ratio = 1280./1001.;\n#else // M51\n    // Offset if the center of the galaxy is not the center of the image\n    vec2 tex_offset1 = vec2(-58,6);\n    float image_ratio = 1280./888.;\n#endif\n    \n    tex_offset1 *= R.xy/vec2(640,360);\n    \n    // Offset to center the texture\n    vec2 tex_offset2 = vec2(R.y*image_ratio/2.-R.x/2.,0);\n    \n    vec2 tex_offset = tex_offset1 + tex_offset2;\n    \n    color = texture(iChannel0,(fragCoord+tex_offset)/vec2(R.y*image_ratio,R.y)).rgb;\n    /////////////////////////\n    \n    /////////////////////////\n    // Draw the white mesh\n    if(DO_WHITE_MESH){\n        /**/\n        int n_parallel = n*WHITE_MESH;\n        for(int arm = 0; arm<n_parallel; arm++)\n            drawSpiral(color,GREY(.8),ORTH_MESH_THICKNESS,rho,theta,alpha,beta,gamma,arm,n_parallel);\n        \n        /**/\n        float beta_prime = exp(-1./log(beta));\n        int n_orth = n*int(10./beta);//int(round(float(n*WHITE_MESH)*ORTH_MESH_FACTOR));\n        for(int arm = 0; arm<n_orth; arm++)\n            drawSpiral(color,GREY(.8),ORTH_MESH_THICKNESS,rho,theta,alpha,beta_prime,gamma,arm,n_orth);\n        /**/\n    }\n    /////////////////////////\n    /**/\n    /////////////////////////\n    // Display of the colored main spiral\n    for(int arm = 0; arm<n; arm++)\n        drawSpiral(color,colors[arm],SPIRAL_THICKNESS,rho,theta,alpha,beta,gamma,arm,n);\n    /////////////////////////\n    /**/\n    /////////////////////////\n    if(DO_WHITE_SPIRAL){\n        // Draw white spiral\n        for(int arm = 0; arm<n; arm++)\n            drawSpiral(color,WHITE,SPIRAL_THICKNESS*.5,rho,theta,alpha,exp(-1./log(beta)),gamma,arm,n);\n    }\n    /////////////////////////\n    \n    \n    /////////////////////////\n    // Display of the normals & tangents\n    if(DO_NORMALS_SAMPLES){\n        // Draw tangents & normals at some points\n        for(int arm = 0; arm<n; arm++){\n            for(int i = 0; i<SAMPLES; i++){\n                // Some theta where to draw the normals\n                float theta_sample = float(i-1)*2.*PI/float(SAMPLES);\n                for(int k = -SPIRAL_SIZE; k<SPIRAL_SIZE; k++)\n                    drawTangentAndNormal(pixel,theta_sample,alpha,beta,gamma,n,k,arm,color);\n            }\n        }\n    }\n    /////////////////////////\n    \n    // Display parameters alpha,beta,gamma on top left\n    if(DISPLAY_PARAMS){\n\t\tvec2 pos ;\n        float scale = 0.06;\n        vec2 pixel_disp = fragCoord/R.y;\n        const vec3 display_color = LIGHT_BLUE;\n        // alpha\n        pos = vec2(.03*R.x,.92*R.y)/R.y;\n        if(display(pixel_disp, pos, scale, 0., alpha*100.))\n        \tcolor=display_color;\n        else{\n        \t// beta\n            pos.y -= scale*1.5;\n            if (display(pixel_disp, pos, scale, 0.,beta))\n                color=display_color;\n            else{\n                // gamma\n                pos.y -= scale*1.5;\n                if (display(pixel_disp, pos, scale, 0.,gamma))\n                    color=display_color;\n            }\n        }\n        \n        // FPS counter\n        scale = .03;\n        pos = vec2(.94*R.x,.95*R.y)/R.y;\n        if(display(pixel_disp, pos, scale, 0., iFrameRate))\n        \tcolor=display_color;\n\t}\n    \n    // Display reset zone\n    if(DISPLAY_RESET && InBLCorner(fragCoord)){\n        color = YELLOW;\n        if(InTriangle(fragCoord,vec2(6,12),vec2(18,4),vec2(18,20))\n           || abs(fragCoord.x - 6.) <= 2. && abs(fragCoord.y - 12.) <= 8.)\n            color = BLUE;\n    }\n    \n    if(DO_BULB){\n        #define BULB_R .1\n        #define BULB_COL vec3(.9,.9,.8)\n        float r = rho/BULB_R;\n        float bulb = exp(-r*r*r);\n        color = mix(color, BULB_COL,bulb);\n    }\n\n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// --- Digit display ----------------------------------------------------\n// Borrowed & slightly adapted from FabriceNeyret's\n//\t\thttps://www.shadertoy.com/view/ldjGWc\n//     ... adapted from Andre in https://www.shadertoy.com/view/MdfGzf\n\nfloat segment(vec2 uv, bool On) {\n\treturn (On) ?  (1.-smoothstep(0.08,0.09+float(On)*0.02,abs(uv.x)))*\n\t\t\t       (1.-smoothstep(0.46,0.47+float(On)*0.02,abs(uv.y)+abs(uv.x)))\n\t\t        : 0.;\n}\n\nfloat sevenSegment(vec2 uv,int num) {\n\tfloat seg= 0.;\n    seg += segment(uv.yx+vec2(-1., 0.),num!=-1 && num!=1 && num!=4                    );\n\tseg += segment(uv.xy+vec2(-.5,-.5),num!=-1 && num!=1 && num!=2 && num!=3 && num!=7);\n\tseg += segment(uv.xy+vec2( .5,-.5),num!=-1 && num!=5 && num!=6                    );\n   \tseg += segment(uv.yx+vec2( 0., 0.),num!=-1 && num!=0 && num!=1 && num!=7          );\n\tseg += segment(uv.xy+vec2(-.5, .5),num==0 || num==2 || num==6 || num==8           );\n\tseg += segment(uv.xy+vec2( .5, .5),num!=-1 && num!=2                              );\n    seg += segment(uv.yx+vec2( 1., 0.),num!=-1 && num!=1 && num!=4 && num!=7          );\t\n\treturn seg;\n}\n\nfloat showNum(vec2 uv,int nr, bool zeroTrim) { // nr: 2 digits + sgn . zeroTrim: trim leading \"0\"\n\tif (abs(uv.x)>2.*1.5 || abs(uv.y)>1.2) return 0.;\n\n\tif (nr<0) {\n\t\tnr = -nr;\n\t\tif (uv.x>1.5) {\n\t\t\tuv.x -= 2.;\n\t\t\treturn segment(uv.yx,true); // <<<< signe. bug\n\t\t}\n\t}\n\t\n\tif (uv.x>0.) {\n\t\tnr /= 10; if (nr==0 && zeroTrim) nr = -1;\n\t\tuv -= vec2(.75,0.);\n\t} else {\n\t\tuv += vec2(.75,0.); \n\t\tnr = int(mod(float(nr),10.));\n\t}\n\n\treturn sevenSegment(uv,nr);\n}\n\nfloat dots(vec2 uv, int dot) {\n\tfloat point0 = float(dot/2),\n\t\t  point1 = float(dot)-2.*point0; \n\tuv.y -= .5;\tfloat l0 = 1.-point0+length(uv); if (l0<.13) return (1.-smoothstep(.11,.13,l0));\n\tuv.y += 1.;\tfloat l1 = 1.-point1+length(uv); if (l1<.13) return (1.-smoothstep(.11,.13,l1));\n\treturn 0.;\n}\n//    ... end of digits adapted from Andre\n\n#define STEPX .875\nfloat _offset=0.; // auto-increment useful for successive \"display\" call\n\n// 2digit int + sign\nbool display(vec2 pixel, vec2 pos, float scale, float offset, int number, int dot){\n    // dot: draw separator\n\tvec2 uv = (pixel-pos)/scale*2.; \n    uv.x = .5-uv.x + STEPX*offset;\n\tuv.y -= 1.;\n\t\n\tfloat seg = showNum(uv,number,false);\n\toffset += 2.;\n\t\n\tif (dot>0) {\n\t\tuv.x += STEPX*offset; \n\t\tseg += dots(uv,dot);\n\t\toffset += 2.;\n\t}\n\t_offset = offset;\n\treturn (seg>0.);\n}\n\n// 2.2 float + sign\nbool display(vec2 pixel, vec2 pos, float scale, float offset, float val) {\n    // dot: draw separator\n\tif (display(pixel, pos, scale, 0., int(val), 1))\n        return true;\n    if (display(pixel, pos, scale, _offset, int(fract(val)*100.), 0))\n        return true;\n\treturn false;\n}\n\n////////////////////////////////////////////////\n\n#define POW2(A) ((A)*(A))\n#define POW3(A) ((A)*(A)*(A))\n#define POW4(A) ((A)*(A)*(A)*(A))\n\n// Determines if p is in the triangle (v1,v2,v3).\n// v1,v2,v3 must be in counterclockwise order\nbool InTriangle (vec2 p, vec2 v1, vec2 v2, vec2 v3)\n{\n    return cross(vec3(p-v1,0),vec3(v2-v1,0)).z <= 0.\n        && cross(vec3(p-v2,0),vec3(v3-v2,0)).z <= 0.\n    \t&& cross(vec3(p-v3,0),vec3(v1-v3,0)).z <= 0.;\n}\n\n// Distance between a point p and a line of equation aX+bY=0\nfloat distPointToLine(vec2 p, float aX, float bY){\n    return abs(bY*p.y - aX*p.x)/sqrt(POW2(aX)+POW2(bY));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}