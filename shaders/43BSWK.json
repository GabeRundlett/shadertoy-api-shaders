{
    "Shader": {
        "info": {
            "date": "1711043955",
            "description": "i want an nGon with smin() corners, this is the first time i see it done.",
            "flags": 0,
            "hasliked": 0,
            "id": "43BSWK",
            "likes": 5,
            "name": "smin() nGon [inefficient]",
            "published": 3,
            "tags": [
                "conveyor",
                "bound",
                "pmod",
                "mstretch",
                "kerning",
                "inverval",
                "followpath"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "//this hand fan polar symmetry was done by gaz before, similar but different\n//https://www.shadertoy.com/view/4tXGDS\n// https://www.shadertoy.com/view/4tX3DS\n//but it did not use an explicir pmox-subroutine\n\n/*\n//this shader improves on pModInterval\nparent: https://www.shadertoy.com/view/4ttyDN\nby adding a bound to pModInterval\nthis is needed for conveyor-arcs/chains/BookBinding as in\nincomplete: https://www.shadertoy.com/view/4l3Bzs\n\nproblem:\n- flipping/moving pages of a book, or items on a conveyor belt\n- should use mod() folding\n- simple approach is only c1 continuous, it shows in the border.\n- to flatten pages on the top arch, i would still need a long mod() neighborhood.\n- - looping over the whole round top half may still be simpler and faster.\n\n- just normalizing a vector field of isoline-pages would likely much simpler here.\n- ,but not stretching the uvw map on that one\n- would involve arclength() calculations aslongside isolines.\n- - quadratic Bezier (20s cartoon kinematic) knee() function would likely be just fine.\n\nthis function can make an array of dots follow along a segmented path\n, like dots that move around the corners of an F-shape.\nyou just have to get the phase right.\nand then you can hash colors via (hash(r.y)) textureID\n\npModR with bound does not behave too well for negative periods (support for that is hacky and bad)\npModR with bound also hints at how you can use a hash to make some dots invisible\n, by shifting their (r.y) identity to (floor(r.y)-floor(n)), and offsetting their fract() gradient equally.\n\n*/\n\n//_start_ constant irrationals\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n\n//__end__ constant irrationals\n//_start_ basics\n\n#define ve0 float\n#define ve1 vec2\n#define ve2 vec3\n#define ve3 vec4\n#define norma normalize\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define cosu5(a) u5(cos(a))\n\n#define viewZoom(t,u,r,m) 9.\n#define Aa(t,u,r,m) min(r.x,r.y)\n//(hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n\nve0 ad(ve3 a){return dot(ve3(1),a);}ve0 ad(vec3 a){return dot(ve2(1),a);}ve0 ad(vec2 a){return a.x+a.y;}//add vector components\n//for deferred shading IDs:\n#define minx(a,b) mix(b,a,step(a.x,b.x))\n#define manx(a,b) mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b) -minx(-a,-b)\n\nfloat ss(float a,float b){return smoothstep(b,-b,a);}\nvec2 ss(vec2 a,float b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,float b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,float b){return smoothstep(b,-b,a);}\n#define aA(t,u,r,m) min(r.x,r.y)\n\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbowt(float a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\nvec4 ut(vec4 a,ve0 b){return a*(1.-b);}//v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,ve0 b){return a*(1.-b);}//v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,ve0 b){return a*(1.-b);}//v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nve0 ut(ve0 a,ve0 b){return a*(1.-b);}//v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here\n\n/*i am overthinking this, dot radius shall be irrelevant\n//only distance between dots matters.\n*/\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod(inout float p, float size//mercury.sexy hg_sdf \n){float halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 v,float tt,float mm//mercury.sexy hg_sdf\n){float gg=pi/tt\n ,aa=atan(v.y,v.x)-gg-mm\n ,rr=length(v)\n ,cc=floor(aa*.5/gg)\n ;aa=mod(aa,gg*2.)-gg\n ;v=vec2(cos(aa),sin(aa))*rr\n ;return cc;}\n\nfloat arg(vec2 a){return atan(a.y,a.x);}\nvec2 c2p(vec2 a){return vec2(arg(a),length(a));}\nvec2 p2c(vec2 a){return vec2(cos(a.x),sin(a.x))*a.y;}//.x  to .x is correct!\n\n\n//generic rotation formula\nvec2 rot(vec2 u,float a){//return u, rotated by [a], full rotation a==pi*2\n\treturn vec2(u.x*cos(a)-u.y*sin(a)\n               ,u.y*cos(a)+u.x*sin(a));}\n       \n\n// exponential smin\nfloat smin( float a, float b, float k ){\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n//looks like this kreaks for very small k on larger input values..\n\n\n\n\n\n        \nvec2 nGonsmin(vec2 u,vec4 m\n){vec2 r=vec2(2)\n//;m.xy=m.zw;\n ;m.x=abs(m.x) \n ;m.y=0.\n //;m.y=pi*.5//m.y is phase!!! //only swivel in positive .my, negative ones are a bit buggy!!!\n     //pi*.5 is a quater rotation\n    //i want to add a totation to that, that is a .5/m.x\n //;m.y+=.45/m.x //may be a usefull option one day\n \n ;m.x*=3. //mouae inpout scaling\n ;m.x+=2.\n //;m.x=6. //m.x == numberOfSides\n ;vec2 v=u.xy//+vec2(-1) //offsets the whole triangle\n \n //;r.y = pModPolar(v,m.x,m.y-pi*.5) //pi offset makeOrBreakss a good mirror\n ;float tt=m.x\n ;float mm=m.y//-pi*.5\n ;float gg=pi/tt\n ,aa=atan(v.y,v.x)-gg-mm\n ,rr=length(v)\n ,cc=floor(aa*.5/gg)\n ;aa=mod(aa,gg*2.)-gg\n ;v=vec2(cos(aa),sin(aa))*rr\n ;r.y=cc\n //end of pmodpolar, inserted to see if i need a variant or not\n \n ;vec2 start=vec2(2,0)\n ;vec2 end=rot(start,-pi/m.x) //from slice-center to one       side of a cake slice \n ;   start=rot(start, pi/m.x) //from slice-center to the other sede of a cake slice\n ;start=rot(v-start,pi/m.x)//offset rotation\n ;end  =rot(v-end  ,-pi/m.x)//offset rotation\n ;v=vec2(\n   smin(-start.x,-end.x\n   ,mix(.01,.1,cos(iTime*9.)*.5+.5) // k-smoothness oscillate fast\n   )\n  )//use max(start.x,end.x) or smin(-start.x,-end.x,k) (for polynomial=fastest==worst smin)\n\n ;v=abs(v)\n ;r.x=max(v.x,v.y) //non rounded box/line\n -.04 // box/line thickness\n ;return r;}\n\nve3 mainEntry(ve0 t,ve1 u,ve2 r,ve3 m\n){ve3 c=ve3(1)\n ;u*=.42              //terrible scaling adusmtment\n ;u   =fra(t,u   ,r,m) //remap() of uv\n ;u-=vec2(-1.3,.4)     //terrible scalingg adjustment\n ;if(m.z>0.\n ){m.xy=fra(t,m.xy,r,m)\n  ;m.zw=fra(t,m.zw,r,m)\n ;}else m.xy=vec2(cos(iTime*.7)*1.5,1)+2.2 //mouse.y oscillates while mouse is up.\n //;m.x*=.4 //m.x sets number of segment,s we make that lesssegments here.\n ;m.x=mix(.1,1.6,abs(m.x*.5))\n ;c.xy=nGonsmin(u+3.,m)\n  ;c.x-=.02\n ;vec4 col=vec4(rainbow(c.y*u5(sqrt(5.)),2./6.),1)\n ;c=mix(ss(c.xxxx,.04),fract(c.xxxx),.2)*mix(vec4(1),col,\n 1.\n //cos(iTime*1.61 )\n )\n ;return c;}\n\n\nvoid mainImage(out ve3 o,in ve1 u){\n o=mainEntry(iTime,u,iResolution,iMouse);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}