{
    "Shader": {
        "info": {
            "date": "1583642964",
            "description": "raymarching",
            "flags": 32,
            "hasliked": 0,
            "id": "ttKSWK",
            "likes": 3,
            "name": "SDF_CornellBox",
            "published": 3,
            "tags": [
                "raymarching",
                "cornellbox",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "Hei149",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "///SDF path tracing cornell box\n#define rotate(angle) mat2(cos(angle), sin(angle), -sin(angle), cos(angle))\nconst vec3 light_position = vec3(0.0, 24.9, 0.0);\nconst vec3 light_dimension = vec3(8.0, 1.0, 8.0);\nconst float lightIntensity = 2.0f;\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\nfloat sdCappedCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) - r, abs(p.y) - h);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 h = abs(p) - b;\n    return max(h.x, max(h.y, h.z));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat matId = 0.0;\nfloat map(vec3 p)\n{\n    float d = sdBox(p - vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));\n    float d1= sdBox(p + vec3(25.0, 0.0, 0.0), vec3(0.1, 25.0, 25.0));\n    if(d < d1){\n        matId = 1.0;\n    }\n    else\n    {\n        matId = 2.0;\n        d = d1;\n    }\n    d1 = sdBox(p - vec3(0.0, 0.0, 25.0), vec3(25.0, 25.0, 0.1));\n    d1 = min(d1, sdBox(abs(p) - vec3(0.0, 25.0, 0.0), vec3(25.0, 0.1, 25.0)));\n    \n    vec3 rp = p + vec3(-8.0, 18.0, 15.0);\n    rp.xz *= rotate(-0.314);\n    d1 = min(d1, sdBox(rp, vec3(7)));\n\n    rp = p + vec3(8., 12.0, 0.0);\n    rp.xz *= rotate(0.262);\n    if(d1 < d)\n    {\n        matId = 0.0;\n        d = d1;\n    }\n    d1 = sdBox(rp, vec3(7, 14, 7));\n    if(d1 < d)\n    {\n        matId = 4.0;\n        d = d1;\n    }\n    d1 = sdBox(p - light_position, light_dimension);\n    if(d1 < d)\n    {\n        matId = 3.0;\n        d = d1;\n    }\n    \n    return d;\n}\n\nvec3 hash33(vec3 p)\n{\n    return fract(sin(p * vec3(29.244, 89.6994, 456.4939)) * 50391.2484);\n}\n\nvec3 RandomInUnitSphere(vec3 seed) \n{\n    vec3 h = hash3(g_seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool rayMarch(vec3 r0, vec3 rd, inout float d)\n{\n    d = 0.0;\n    for(int i = 0; i < 100; ++i)\n        {\n            vec3 p = r0 + d * rd;\n            float t = map(p);\n            d += t;\n            if(abs(t) < 0.001)\n            {\n                return true;\n            }\n            if(d > 200.0) break;\n        }\n    return false;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    g_seed = float(base_hash(floatBitsToUint(gl_FragCoord.xy)))/float(0xffffffffU)+iTime;\n    vec2 luv = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord + vec2(fract(iTime)) - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.1, 0.0, -100.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 10.;\n    \n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    float zoom = 1.5;\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + zoom * ww);\n    \n    float d = 0.0;\n    vec3 col = vec3(1.0);\n    const vec3 red =  vec3(0.65, 0.05, 0.05);\n    const vec3 white = vec3(0.73);\n    const vec3 green = vec3(0.12, 0.45, 0.15);\n\n    vec3 albedo = white;\n    vec3 tcol = vec3(0.0);\n    for(int i = 0; i < 4; ++i){\n        if(rayMarch(r0, rd, d))\n        {\n            if(matId == 1.0)\n            {\n                albedo = red;\n            }\n            else if(matId == 2.0)\n            {\n                albedo = green;\n            }\n            else if(matId == 3.0)\n            {\n                if(dot(norm(r0 + d * rd), vec3(0.0, 1.0, 0.0)) < 0.0)\n                    tcol += col * lightIntensity;\n                break;\n            }\n            else\n            {\n                albedo = white;\n            }\n\n            vec3 p = r0 + d * rd;\n            vec3 n = norm(p);\n            //magic number \n            r0 = p + n * 0.01;\n            col *= albedo;\n#if 1\n            if(matId == 4.0)\n            {\n                r0 = p + n * 0.01;\n                rd = normalize(reflect(rd, n));\n            }\n            else\n               #endif\n              \trd = normalize(RandomInUnitSphere(r0) + n);\n\n            vec2 rand = hash2(g_seed);\n            vec3 lp = vec3(light_position.x + rand.x * light_dimension.x, light_position.y, rand.y * light_dimension.z);\n             vec3 ld = normalize(lp - p);\n             float sdis = 0.0;\n             if(rayMarch(r0, ld, sdis))\n             {\n                 if(matId == 3.0f)\n                 {\n                     float area = light_dimension.x * light_dimension.z;\n                     float weight = sqrt(1.0f - clamp(area / dot(lp, lp), 0.0f, 1.0f));\n                     weight = 2.0f * 3.141592 * (1.0f - weight);\n                     tcol += (col / 3.141592 * lightIntensity) * weight * max(dot(n, ld), 0.0f);\n                 }\n             }\n        }\n        else\n        {\n            col *= vec3(0.0);\n            break;\n        }\n    }\n    \n    col = pow(tcol, vec3(0.4545));\n    \n    float numSample = texture(iChannel0, luv).w + 1.0;\n    col = mix(texture(iChannel0, luv).rgb, col, 1.0 / numSample);\n    fragColor = vec4(col, numSample);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}