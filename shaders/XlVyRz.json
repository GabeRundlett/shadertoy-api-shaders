{
    "Shader": {
        "info": {
            "date": "1534878990",
            "description": "port of ancient iOS app i wrote",
            "flags": 0,
            "hasliked": 0,
            "id": "XlVyRz",
            "likes": 16,
            "name": "spinnerjoy",
            "published": 3,
            "tags": [
                "aliasing",
                "moire",
                "artifacts",
                "spinners"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 814
        },
        "renderpass": [
            {
                "code": "// parameters\n#define BOX_SIZE      17.0\n#define LINE_WIDTH     4.0\n#define RENDER_CROSS   1\n#define MOUSE_AMOUNT   0.0\n#define LINE_LENGTH    1.5\n#define JUST_THE_TIPS  1\n\n// careful with this value. iterations = (2n + 1)^2\n// needs to be large enough to fit LINE_LENGTH.\n#define offsetSize     1.0\n\n// not parameters\n#define LARGE_VALUE 100000000.0\n#define STRAIGHT       1\n\nfloat oxeVec2f_distanceRight_PointLine(vec2 linePt, vec2 unitDir, vec2 pt)\n{\n   float vx = pt.x - linePt.x;\n   float vy = pt.y - linePt.y;\n   return unitDir.y * vx - unitDir.x * vy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float boxDim = BOX_SIZE;\n    vec2 lineCenterC = vec2(boxDim, boxDim) * 0.5;\n    vec2 fc2 = fragCoord - (iResolution.xy * 0.5);\n    vec2 pt  = mod(fc2, boxDim);\n    \n    #if STRAIGHT\n    vec2 boxPosC = (floor(fc2 / boxDim) + vec2(0.5)) * boxDim + iResolution.xy * 0.5;\n    #else\n    vec2 boxPosC = fc2;\n    #endif\n    \n    vec3 col = vec3(0.);\n    \n    float r = LINE_LENGTH;\n        \n    for (float dx = -offsetSize; dx <= offsetSize; dx += 1.0) {\n\t    for (float dy = -offsetSize; dy <= offsetSize; dy += 1.0) {\n            vec2 offset = vec2(dx, dy) * boxDim;\n            vec2 lineCenter = lineCenterC + offset;\n            vec2 boxPos = boxPosC + offset;\n\t\t    float boxDist1 = length(boxPos - iResolution.xy * 0.5) *  1.0;\n\t\t    float boxDist2 = length(boxPos - iMouse.xy)            * -MOUSE_AMOUNT;\n\t\t\tfloat boxDist = boxDist1 + boxDist2;\n    \n\t\t    float t = iTime * 1.4 * (boxDist * 0.003 + 0.2);\n            vec2 lineDir = vec2(cos(t), sin(t));\n    \n\t\t    float distN = length(pt - lineCenter) / (boxDim * 0.5);\n\n            // make it a sort of bone shape instead of a flat line\n            float tmp = smoothstep(0.0, 2.0, distN);\n           // tmp *= tmp;\n            float lw = LINE_WIDTH * (tmp * 0.3 + 0.7);\n    \n            float d = 0.0;\n            d = max(d, clamp(lw * 0.5 - abs(oxeVec2f_distanceRight_PointLine(lineCenter, lineDir, pt)), 0.0, 1.0));\n    \n            #if RENDER_CROSS\n            lineDir = vec2(-lineDir.y, lineDir.x);\n            d = max(d, clamp(lw * 0.5 - abs(oxeVec2f_distanceRight_PointLine(lineCenter, lineDir, pt)), 0.0, 1.0));\n            #endif // RENDER_CROSS\n\n            // restrict to a circle\n            d *= smoothstep(r, r - 0.1, distN);\n            \n            #if JUST_THE_TIPS\n            d *= smoothstep(r, r - 0.1, distN);\n            #endif\n    \n            // grey in the middle\n            // d *= smoothstep(0.0, 0.8, distN) * 0.5 + 0.5;\n    \n            col.xyz += d;\n   \t\t    // col.z   = boxDist / iResolution.y;\n        }\n    }\n\t\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}