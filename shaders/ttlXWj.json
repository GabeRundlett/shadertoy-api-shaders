{
    "Shader": {
        "info": {
            "date": "1564384625",
            "description": "Nighttime version of [url=https://www.shadertoy.com/view/3dsSD7]Maze Trip[/url] - see source",
            "flags": 32,
            "hasliked": 0,
            "id": "ttlXWj",
            "likes": 6,
            "name": "Maze Riding",
            "published": 3,
            "tags": [
                "interactive",
                "maze",
                "puzzle"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "// \"Maze Riding\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Nighttime version of \"Maze Trip\" with a few tweaks; sliders control rider\n  height and speed (click anywhere to see controls); click ring for new maze;\n  click in small view to switch views; mouse to look around.\n*/\n\n#define AA  0   // optional antialiasing\n\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat Maxv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Length4 (vec2 p);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\n#define MAX_CAR 20\n\nvec3 qHit, qnHit, bSize;\nvec2 gSize, cEn, cEx, cPos[MAX_CAR], cDir[MAX_CAR];\nfloat dstFar, tCur, nStep, growLim, pathLen, rideHt;\nint idObj, idCap, nCar;\nbool isVis[MAX_CAR], isRide;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p : vec2 (- p.y, p.x)) :\n     ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 p)\n{\n  vec2 ut, e;\n  float dw, s;\n  ut = p * gSize;\n  s = Loadv4 (floor (ut)).x;\n  dw = WallDst (ut, s);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (ut) - e).x == ai) dw = min (dw, WallDst (ut, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, b;\n  vec2 s;\n  float dMin, d;\n  dMin = dstFar;\n  b = bSize;\n  b.xz *= (1. - 0.9 / gSize);\n  q = p;\n  d = SmoothMax (ValMaze (0.5 * q.xz / bSize.xz + 0.5) - 0.13 * (1. + 3. * (q.y - 0.4) *\n     (q.y - 0.4)), abs (q.y - 0.4) - 0.3, 0.05);\n  d = min (d, abs (q.y - 0.1) - 0.01);\n  d = 0.6 * max (d, length (max (abs (q.xz) - b.xz, 0.)) - 0.05);\n  DMIN (1);\n  s = bSize.xz - vec2 (0.4, 4. * bSize.z / gSize.y);\n  q = p - vec3 (s.x, 0.3, s.y);\n  d = max (PrRoundCylDf (q.yzx, 0.42, 0.1, 0.2), 0.34 - length (q.yz));\n  DMIN (2);\n  q = p - vec3 (- s.x, 0.3, - s.y);\n  d = max (PrRoundCylDf (q.yzx, 0.42, 0.1, 0.2), 0.34 - length (q.yz));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 180; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec4 CapsHit (vec3 ro, vec3 rd, float rad, float len)\n{\n  vec3 s, sMin;\n  float dMin, d, a, b, w, drz;\n  dMin = dstFar;\n  a = dot (rd.xy, rd.xy);\n  b = dot (rd.xy, ro.xy);\n  w = b * b - a * (dot (ro.xy, ro.xy) - rad * rad);\n  if (w > 0. && a > 0.) {\n    d = - b - sqrt (w);\n    d /= a;\n    s = ro + d * rd;\n    if (d > 0. && abs (s.z) < len) {\n      dMin = d;\n      sMin = s;\n      qnHit = vec3 (s.xy, 0.);\n    } else {\n      drz = - len * sign (s.z);\n      ro.z += drz;\n      b = dot (rd, ro);\n      w = b * b - (dot (ro, ro) - rad * rad);\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0.) {\n          s = ro + d * rd;\n          dMin = d;\n          sMin = s;\n          sMin.z -= drz;\n          qnHit = s;\n        }\n      }        \n    }\n  }\n  return vec4 (sMin, dMin);\n}\n\nfloat AllCapsHit (vec3 ro, vec3 rd)\n{\n  vec4 ds;\n  vec3 rom, rdm, qHitM, qnHitM;\n  float dMin;\n  dMin = dstFar;\n  for (int k = 0; k < MAX_CAR; k ++) {\n    if (k == nCar) break;\n    if (isVis[k]) {\n      rom = ro;\n      rom.xz = Rot2Cs (rom.xz - cPos[k], cDir[k]);\n      rom.y -= 0.25;\n      rdm = rd;\n      rdm.xz = Rot2Cs (rdm.xz, cDir[k]);\n      ds = CapsHit (rom.zyx, rdm.zyx, 0.12, 0.25);\n      if (ds.w < dMin) {\n        dMin = ds.w;\n        idCap = k;\n        qHitM = ds.xyz;\n        qnHitM = qnHit;\n        qnHitM.xz = Rot2Cs (qnHitM.xz, - cDir[k]);\n      }\n    }\n  }\n  qHit = qHitM.zyx;\n  qnHit = normalize (qnHitM).zyx;\n  return dMin;\n}\n\nvec3 MidLineDist (vec2 utg, float nw)\n{\n  vec4 cb;\n  vec3 cbp[2];\n  vec2 utt, e, ee;\n  float fPair, s;\n  utt = fract (utg + 0.5) - 0.5;\n  cb = mod (floor (nw / vec4 (1., 2., 4., 8.)), 2.);\n  cbp[0] = cb.xyx * cb.zwy;\n  cbp[1] = cb.yzw * cb.zwx;\n  if      (cbp[0].x > 0.) fPair = 0.;\n  else if (cbp[0].y > 0.) fPair = 1.;\n  else if (cbp[0].z > 0.) fPair = 2.;\n  else if (cbp[1].x > 0.) fPair = 3.;\n  else if (cbp[1].y > 0.) fPair = 4.;\n  else if (cbp[1].z > 0.) fPair = 5.;\n  if      (fPair == 0.) s = utt.x;\n  else if (fPair == 1.) s = utt.y;\n  else {\n    e = vec2 (0.5, -0.5);\n    if      (fPair == 2.) ee = e.xx;\n    else if (fPair == 3.) ee = e.xy;\n    else if (fPair == 4.) ee = e.yy;\n    else if (fPair == 5.) ee = e.yx;\n    utt -= ee;\n    s = length (utt) - 0.5;\n  }\n  return vec3 (abs (s), ((fPair <= 1.) ? vec2 (0.) : 0.293 * ee));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, cr, ml;\n  vec2 ut, utg, h, vf;\n  float dstObj, dstCap, nw, s, ss, brLit;\n  bool pathOk;\n  pathOk = (nStep > 6. * growLim || pathLen > 0.);\n  dstObj = ObjRay (ro, rd);\n  if (pathOk) dstCap = AllCapsHit (ro, rd);\n  else dstCap = dstFar;\n  if (min (dstCap, dstObj) < dstFar) {\n    brLit = 0.;\n    if (dstObj < dstCap) {\n      vf = vec2 (0.);\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 1) {\n        if (ro.y > 0.) {\n          ut = 0.5 * (ro.xz / bSize.xz + 1.);\n          utg = gSize * ut;\n          if (ro.y < 0.12) {\n            col4 = vec4 (0.4, 0.3, 0.1, 0.05) * (0.7 + 0.3 * smoothstep (0.13, 0.23,\n               ValMaze (ut)));\n            h = abs (utg - (cEn + vec2 (1.) - vec2 (0.7, 0.)));\n            if (max (h.x, h.y) < 0.3) col4 = vec4 (0.7, 0.7, 0.5, 0.);\n            h = abs (utg - (cEx + vec2 (1.) + vec2 (0.7, 0.)));\n            if (max (h.x, h.y) < 0.3) col4 = vec4 (0.7, 0.7, 0.5, 0.);\n            col4 *= 0.9 + 0.1 * Fbm2 (64. * ro.xz);\n            if (pathOk) {\n              nw = Loadv4 (floor (mod (utg - 0.5, gSize))).y;\n              if (nw >= 32.) {\n                ml = MidLineDist (utg, nw);\n                if (isRide && length (fract (utg + 0.5) - 0.5 - ml.yz) < 0.05) col4.rgb =\n                   mix (col4.rgb, ((length (ml.yz) > 0.) ? vec3 (1., 0., 0.) : vec3 (0., 1., 0.)),\n                   0.6 + 0.4 * sin (4. * pi * (tCur - 0.3 * floor (nw / 32.))));\n                ss = abs (ml.x - 0.11);\n                s = smoothstep (0.015, 0.02, ss);\n                col4.rgb = mix (vec3 (0.9, 0.9, 1.) * (isRide ? 1.5 -\n                   1.3 * smoothstep (0.008, 0.012, ss) : 1.), col4.rgb, s);\n                vf = vec2 (32., 3. * s);\n                for (int k = 0; k < MAX_CAR; k ++) {\n                  if (k == nCar) break;\n                  if (isVis[k]) {\n                    cr.xz = Rot2Cs (ro.xz - cPos[k], cDir[k]);\n                    col4.rgb *= 0.7 + 0.3 * smoothstep (0.05, 0.15,\n                       length (cr.xz - vec2 (clamp (cr.x, - 0.25, 0.25), 0.)));\n                  }\n                }\n              }\n            }\n          } else {\n            col4 = vec4 (0.7, 0.7, 0.5, 0.05);\n            s = 1. - SmoothBump (0.06, 0.08, 0.005, abs (abs (ro.y - 0.41) - 0.27));\n            col4.rgb *= 1.3 - 0.3 * s;\n            vf = vec2 (32., 4. * s);\n            if (isRide) {\n              h = abs (mod (4. * utg + 0.5, 1.) - 0.5);\n              s = Length4 (vec2 (0.25 * min (h.x, h.y), 0.5 * (ro.y - 0.41)));\n              if (s < 0.07) {\n                col4.rgb = mix (HsvToRgb (vec3 (atan (ut.y - 0.5, ut.x - 0.5) / (2. * pi) + 0.5,\n                   0.7, 0.6)) * (1. - 0.4 * smoothstep (0.04, 0.07, s)), col4.rgb,\n                   smoothstep (0.065, 0.07, s));\n                if (s < 0.065) {\n                  col4.a = -1.;\n                  vf = vec2 (0.);\n                }\n              }\n            }\n          }\n        } else col4 = vec4 (0.);\n      } else if (idObj == 2) {\n        col4 = vec4 (0.7, 0.7, 0.5, 0.05);\n        vf = vec2 (32., 0.3);\n      }\n      for (int k = 0; k < MAX_CAR; k ++) {\n        if (k == nCar) break;\n        if (isVis[k]) {\n          cr.xz = Rot2Cs (ro.xz - cPos[k], cDir[k]);\n          cr.x -= 0.35;\n          if (! isRide || k != 0) cr.xz *= 2.3;\n          cr.y = ro.y - 0.25;\n          brLit = max (brLit, (1. - smoothstep (0.5, 1.3, length (cr.xz))) * (1. -\n             smoothstep (0.45 * pi, 0.65 * pi, atan (abs (cr.z), cr.x))) *\n             (0.2 + 0.8 * max (- dot (normalize (ro - vec3 (cPos[k], 0.25).xzy), vn), 0.)) *\n             (1. - smoothstep (0.66, 0.72, ro.y)) / (1. + 0.2 * dot (cr, cr)));\n        }\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    } else if (dstCap < dstFar) {\n      vn = qnHit;\n      if (abs (qHit.x) > 0.2) col4 = (qHit.x > 0.) ? vec4 (0.3, 1., 0.3, 0.2) :\n         vec4 (1., 0.3, 0.3, 0.2);\n      else col4 = vec4 (1., 1., 0.3, 0.2);\n      if (idCap == 0) col4 = mix (vec4 (0.3, 0.3, 1., 0.2), col4,\n         smoothstep (0.02, 0.04, abs (qHit.z)));\n      col4 *= 0.7 + 0.3 * smoothstep (0.05, 0.07, max (abs (qHit.x), abs (qHit.z)));\n      if (qHit.x > 0.35) col4 = vec4 (0.9, 0.9, 0.7, -1.);\n      else if (qHit.x < -0.365) col4 = vec4 (0.8, 0., 0., -1.);\n    }\n    if (col4.a >= 0.) col = mix (col4.rgb * (0.2 + 0.5 * max (vn.y, 0.)),\n       0.5 * vec3 (1., 1., 0.7) * brLit, 0.6);\n    else col = col4.rgb;\n    if (! isRide) col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  } else {\n    if (isRide) col = StarPat (rd, 4.);\n    else col = vec3 (0.1, 0.1, 0.13);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, float rideHt, float rideSpd)\n{\n  vec4 wgBx[3];\n  vec3 col;\n  vec2 ust;\n  float asp;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.48 * asp, 0.46, 0.022, 0.);\n  wgBx[1] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n  wgBx[2] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n  col = vec3 (0.);\n  if (abs (length (0.5 * uv - wgBx[0].xy) - wgBx[0].z) * canvas.y < 1.5)\n     col = vec3 (1., 1., 0.);\n  ust = abs (0.5 * uv - wgBx[1].xy) - wgBx[1].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[1].xy;\n  ust.y -= (rideHt - 0.5) * 2. * wgBx[1].w;\n  if (abs (length (ust) - 0.7 * wgBx[1].z) * canvas.y < 3.)  col = vec3 (0.7, 0.1, 0.7);\n  ust = abs (0.5 * uv - wgBx[2].xy) - wgBx[2].zw;\n  if (abs (max (ust.x, ust.y)) * canvas.y < 1.) col = vec3 (0.8);\n  ust = 0.5 * uv - wgBx[2].xy;\n  ust.y -= (rideSpd - 0.5) * 2. * wgBx[2].w;\n  if (abs (length (ust) - 0.7 * wgBx[2].z) * canvas.y < 3.) col = vec3 (0.1, 1., 0.1);\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat, c4;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa, mMid, ut, mSize, ms;\n  float asp, sr, az, el, zmFac, vuId, regId, rideSpd, tCurM;\n  int wgSel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  gSize = Loadv4 (vec2 (0., 0.)).zw;\n  cEn = Loadv4 (vec2 (1., 0.)).zw;\n  cEx = Loadv4 (vec2 (2., 0.)).zw;\n  stDat.zw = Loadv4 (vec2 (3., 0.)).zw;\n  growLim = stDat.z;\n  pathLen = stDat.w;\n  stDat.zw = Loadv4 (vec2 (4., 0.)).zw;\n  nStep = stDat.z;\n  nCar = int (stDat.w);\n  wgSel = int (Loadv4 (vec2 (6., 0.)).w);\n  stDat.zw = Loadv4 (vec2 (7., 0.)).zw;\n  rideHt = stDat.z;\n  rideSpd = stDat.w;\n  tCurM = Loadv4 (vec2 (8., 0.)).w;\n  bSize = vec3 (0.5 * gSize.x, 0.15, 0.5 * gSize.y);\n  for (int k = 0; k < MAX_CAR; k ++) {\n    if (k == nCar) break;\n    cPos[k] = Loadv4 (vec2 (2. * float (k), 1.)).zw + vec2 (1.) - bSize.xz;\n    cDir[k] = Loadv4 (vec2 (2. * float (k) + 1., 1.)).zw;\n    isVis[k] = (pathLen > 0. && length (cDir[k]) < 1.001);\n  }\n  mPtr = vec4 (Loadv4 (vec2 (5., 0.)).zw, Loadv4 (vec2 (6., 0.)).z, 0.);\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (- asp + mSize.x, 1. - mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuId = 0.;\n  if (pathLen > 0. && max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuId = 1. - vuId;\n  }\n  regId = 0.;\n  if (mPtr.z > 0.) {\n    ms = vec2 ((0.5 + mPtr.x) * asp, 0.5 - mPtr.y) - mSize;\n    if (max (ms.x, ms.y) < 0.) regId = 1.;\n    if (regId == 1.) vuId = 1. - vuId;\n  }\n  if (pathLen > 0. && vuId == 0.) {\n    ro.xz = cPos[0];\n    ro.y = 0.4 + 0.8 * rideHt;\n    ro.xz += 0.001 * length (bSize.xz);\n    az = -0.5 * pi - atan (cDir[0].y, - cDir[0].x);\n    el = -0.18 * pi * rideHt;\n    if (wgSel < 0 && regId == 0. && mPtr.z > 0.) {\n      az += 2. * pi * mPtr.x;\n      el += 0.3 * pi * mPtr.y;\n    }\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    zmFac = 1.6;\n    isRide = true;\n  } else {\n    az = 0.;\n    el = -0.5 * pi;\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    ro = vuMat * vec3 (0.001, 0., -4.) * length (bSize.xz);\n    zmFac = 5.5;\n    isRide = false;\n  }\n  dstFar = 80.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (pathLen > 0.) {\n    if (vuId == 0. && regId == 0.) {\n      if (wgSel < 0 && mPtr.z > 0. && max (abs (uv.x), abs (uv.y)) < 0.03 &&\n         min (abs (uv.x), abs (uv.y)) < 0.003) col = vec3 (0.8, 0.8, 0.1);\n      if (canvas.x < 256. || tCur - tCurM < 5.) {\n        c4 = ShowWg (uv, canvas, rideHt, rideSpd);\n        if (canvas.x >= 256.) c4.a *= (1. - smoothstep (4., 5., tCur - tCurM));\n        col = mix (col, c4.rgb, c4.a);\n      }\n    }\n    if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.)\n       col = vec3 (0.2, 0.2, 0.1);\n  } else {\n    ut = Rot2D (uv, -2. * pi * mod (0.5 * tCur, 1.));\n    if (atan (ut.y, - ut.x) / pi < 0.7) col = mix (col, vec3 (1., 0., 1.),\n       0.3 * (1. - smoothstep (0.02, 0.03, abs (length (ut) - 0.3))));\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Length4 (vec2 p)\n{\n  p *= p;\n  return pow (dot (p * p, vec2 (1.)), 1./4.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Maze Riding\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat Hashff (float p);\nfloat Hashfv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\n\n#define MAX_GSIZE  16.\n#define MAX_CAR    20\n\nvec2 gSize, cPos[MAX_CAR], cDir[MAX_CAR], ev[4], cEn, cEx;\nfloat tCur, nStep, pathLen, growLim, carMove;\nint nCar;\nconst float pi = 3.14159;\n\nfloat WallDst (vec2 p, float a)\n{\n  p = 0.5 - ((a < 0.) ? vec2 (0.) : (fract ((a <= 1.) ? ((a == 0.) ? p : vec2 (- p.y, p.x)) :\n     ((a == 2.) ? - p : vec2 (p.y, - p.x)))));\n  return length (vec2 (p.x, max (0., p.y)));\n}\n\nfloat ValMaze (vec2 p)\n{\n  vec2 e;\n  float dw, s;\n  s = Loadv4 (floor (p)).x;\n  dw = WallDst (p, (s >= 0.) ? s : -1.);\n  for (float ai = 0.; ai < 4.; ai ++) {\n    e = vec2 (0., 1.);\n    e = (ai < 2.) ? ((ai == 0.) ? e : e.yx) : ((ai == 2.) ? - e : - e.yx);\n    if (Loadv4 (floor (p) - e).x == ai) dw = min (dw, WallDst (p, mod (ai + 2., 4.)));\n  }\n  return dw;\n}\n\nfloat MazeInit (vec2 iFrag)\n{\n  float ar;\n  nStep = 0.;\n  pathLen = 0.;\n  growLim = floor (1.7 * max (gSize.x, gSize.y));\n  ar = -1.;\n  cEn = vec2 (0., 1.);\n  cEx = gSize - 2. - vec2 (0., 1.);\n  if (iFrag.y == 0. && iFrag.x < gSize.x - 1.) ar = 1.;\n  else if (iFrag.x == gSize.x - 1. && iFrag.y < gSize.y - 1.) ar = 0.;\n  else if (iFrag.y == gSize.y - 1. && iFrag.x > 0.) ar = 3.;\n  else if (iFrag.x == 0. && iFrag.y > 0.) ar = 2.;\n  if (iFrag.x == cEn.x && iFrag.y > cEn.y) ar = 0.;\n  else if (iFrag.x > cEx.x && iFrag.y <= cEx.y) ar = 2.;\n  if (iFrag.y > 0. && iFrag.y < gSize.y - 1.) {\n    if (Hashff (tCur + 111.1) > 0.5 && iFrag.x == floor (gSize.x / 4.)) ar = 2.;\n    if (Hashff (tCur + 211.1) > 0.5 && iFrag.x == floor (3. * gSize.x / 4.)) ar = 0.;\n  }\n  return ar;\n}\n\nfloat MazeGrow (vec2 iFrag)\n{\n  float ar, ai;\n  ++ nStep;\n  ar = Loadv4 (iFrag).x;\n  if (nStep < growLim && ar < 0.) {\n    ai = floor (4. * Hashfv2 (iFrag + tCur));\n    if (Hashfv2 (iFrag + tCur + 11.1) > 0.3) {\n      if (iFrag.y == 1.) {\n        if (ai == 2.) ai = 0.;\n      } else if (iFrag.y == gSize.y - 2.) {\n        if (ai == 0.) ai = 2.;\n      } else if (iFrag.x == 1.) {\n        if (ai == 3.) ai = 1.;\n      } else if (iFrag.x == gSize.x - 2.) {\n        if (ai == 1.) ai = 3.;\n      }\n    }\n    if (Loadv4 (iFrag + ((ai < 2.) ? ((ai == 0.) ? ev[0] : ev[1]) :\n       ((ai == 2.) ? ev[2] : ev[3]))).x >= 0.) ar = ai;\n  }\n  return ar;\n}\n\nfloat MazeWalls (vec2 iFrag, float nw)\n{\n  vec4 cb, cbf;\n  float ar, nb;\n  cbf = vec4 (1., 2., 4., 8.);\n  cb = vec4 (0.);\n  ar = Loadv4 (iFrag).x;\n  cb.wz += vec2 ((ar == 0.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n  ar = Loadv4 (iFrag + ev[0]).x;\n  cb.wx += vec2 ((ar == 2.) ? 1. : 0., (ar == 1.) ? 1. : 0.);\n  ar = Loadv4 (iFrag + vec2 (1., 1.)).x;\n  cb.yx += vec2 ((ar == 2.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n  ar = Loadv4 (iFrag + ev[1]).x;\n  cb.yz += vec2 ((ar == 0.) ? 1. : 0., (ar == 3.) ? 1. : 0.);\n  if (nStep < growLim) {\n    nw = -1.;\n  } else if (nStep == growLim) {\n    nw = dot (cb, vec4 (1.));\n  } else if (nStep > growLim && nStep < 2. * growLim) {\n    if (nw < 3.) {\n      nb = 0.;\n      for (int k = 0; k < 4; k ++)\n         if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y >= 3.) ++ nb;\n      if (nw + nb == 3.) nw = 4.;\n    } else nw = 4.;\n  } else if (nStep == 2. * growLim) {\n    if (nw < 3.) {\n      nw = 0.;\n      for (int k = 0; k < 4; k ++)\n         if ((cb[k] == 0.) && Loadv4 (mod (iFrag + ev[k], gSize)).y < 3.) nw += cbf[k];\n    } else nw = 0.;\n  }\n  return nw;\n}\n\nfloat MazePath (vec2 iFrag, float nw)\n{\n  vec4 cb, cbi;\n  float dir, nwn;\n  int kIn;\n  if (nw > 0. && nw < 32.) {\n    dir = 0.;\n    cbi = 1. / vec4 (1., 2., 4., 8.);\n    cb = mod (floor (nw * cbi), 2.);\n    if (iFrag.x == cEn.x && iFrag.y == cEn.y) {\n      if (cb[2] > 0.) dir = 1.;\n      nw += 32. * 1.;\n    } else {\n      cbi = cbi.zwxy;\n      for (int k = 0; k < 4; k ++) {\n        if (nw < 32. && cb[k] > 0.) {\n          nwn = Loadv4 (mod (iFrag + ev[k], gSize)).y;\n          if ((nwn - 32.) * mod (floor (nwn * cbi[k]), 2.) > 0.) {\n            nw += 32. * (floor (nwn / 32.) + 1.);\n            kIn = k;\n            break;\n          }\n        }\n      }\n      if (kIn == 0) {\n        if (cb[2] > 0. || cb[3] > 0.) dir = 1.;\n      } else if (kIn == 1) {\n        if (cb[3] > 0. || cb[0] > 0.) dir = 1.;\n      } else if (kIn == 2) {\n        if (cb[1] > 0.) dir = 1.;\n      } else if (kIn == 3) {\n        if (cb[2] > 0.) dir = 1.;\n      }\n    }\n    nw += 16. * (dir - mod (floor (nw / 16.), 2.));\n  }\n  return nw;\n}\n\nvoid PosCars ()\n{\n  vec2 p, p1, p2, s1, s2;\n  float t, ti, pWait, nw;\n  pWait = 0.6;\n  for (int k = 0; k < MAX_CAR; k ++) {\n    if (k == nCar) break;\n    t = carMove + (pathLen + pWait) * float (k) / float (nCar); \n    t = mod (t, pathLen + pWait) + 1.;\n    cDir[k] = vec2 (99.);\n    ti = floor (t);\n    if (ti >= 1. && ti <= pathLen) {\n      p1 = cEn + vec2 (-1., 0.);\n      p2 = cEx + vec2 (1., 0.);\n      for (float iy = 0.; iy < MAX_GSIZE; iy ++) {\n        if (iy == gSize.y - 1.) break;\n        for (float ix = 0.; ix < MAX_GSIZE; ix ++) {\n          if (ix == gSize.x - 1.) break;\n          nw = floor (Loadv4 (vec2 (ix, iy)).y / 32.);\n          if (nw == ti) p = vec2 (ix, iy);\n          else if (ti > 1. && nw == ti - 1.) p1 = vec2 (ix, iy);\n          else if (ti < pathLen && nw == ti + 1.) p2 = vec2 (ix, iy);\n        }\n      }\n      s1 = mix (p1, p, t - ti);\n      s2 = mix (p, p2, t - ti);\n      cPos[k] = 0.5 * (s1 + s2);\n      cDir[k] = vec2 (1., -1.) * normalize (s2 - s1);\n    } else if (t - 1. < pathLen + 0.5 * pWait) {\n      cPos[k] = cEx + vec2 (0.5, 0.);\n      cDir[k] = vec2 (1., 0.);\n    } else {\n      cPos[k] = cEn - vec2 (0.5, 0.);\n      cDir[k] = vec2 (1., 0.);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 wgBx[3], mPtr, mPtrP, stDat, fVal;\n  vec2 canvas, iFrag, um, ud, ust;\n  float asp, rideHt, rideSpd, tCurM;\n  int wgSel, wgReg;\n  bool init;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  gSize = vec2 (MAX_GSIZE);\n  if (fragCoord.x >= max (gSize.x, 2. * float (MAX_CAR)) || fragCoord.y >= gSize.y) discard;\n  ev[0] = vec2 (0., 1.);\n  ev[1] = vec2 (1., 0.);\n  ev[2] = vec2 (0., -1.);\n  ev[3] = vec2 (-1., 0.);\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.48 * asp, 0.46, 0.022, 0.);\n  wgBx[1] = vec4 (0.43 * asp, 0.05, 0.01 * asp, 0.15);\n  wgBx[2] = vec4 (0.48 * asp, 0.05, 0.01 * asp, 0.15);\n  mPtrP.z = Loadv4 (vec2 (6., 0.)).z;\n  init = (iFrame <= 5);\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) < wgBx[0].z) {\n      if (mPtrP.z <= 0.) init = true;\n    }\n  }\n  iFrag = floor (fragCoord);\n  fVal = Loadv4 (iFrag);\n  if (! init) {\n    nStep = Loadv4 (vec2 (4., 0.)).z;\n    init = (mod (nStep + 1., 18000.) == 0.);\n  }\n  wgReg = -2;\n  if (init) {\n    mPtrP = mPtr;\n    nCar = 0;\n    wgSel = -1;\n    rideHt = 0.18;\n    rideSpd = 0.4;\n    carMove = 0.;\n    tCurM = tCur;\n    fVal.x = MazeInit (iFrag);\n  } else {\n    cEn = Loadv4 (vec2 (1., 0.)).zw;\n    cEx = Loadv4 (vec2 (2., 0.)).zw;\n    stDat.zw = Loadv4 (vec2 (3., 0.)).zw;\n    growLim = stDat.z;\n    pathLen = stDat.w;\n    nCar = int (Loadv4 (vec2 (4., 0.)).w);\n    wgSel = int (Loadv4 (vec2 (6., 0.)).w);\n    stDat.zw = Loadv4 (vec2 (7., 0.)).zw;\n    rideHt = stDat.z;\n    rideSpd = stDat.w;\n    stDat.zw = Loadv4 (vec2 (8., 0.)).zw;\n    carMove = stDat.z;\n    tCurM = stDat.w;\n    fVal.x = MazeGrow (iFrag);\n    if (nStep > 2. * growLim) pathLen = floor (Loadv4 (cEx).y / 32.);\n    if (iFrag.x <= gSize.x - 2. && iFrag.y <= gSize.y - 2.) {\n      if (nStep <= 2. * growLim) {\n        fVal.y = MazeWalls (iFrag, fVal.y);\n      } else if (nStep > 2. * growLim && nStep < 6. * growLim && pathLen == 0.) {\n        fVal.y = MazePath (iFrag, fVal.y);\n      }\n    } else {\n      if (nStep < growLim) fVal.y = 0.;\n    }\n    if (nStep > 6. * growLim || pathLen > 0.) {\n      if (nCar == 0) nCar = int (clamp (pathLen / 3.5, 7., float (MAX_CAR)));\n      carMove += 0.03 * rideSpd;\n      PosCars ();\n    }\n  }\n  if (mPtr.z > 0.) {\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[0].xy) < wgBx[0].z) wgReg = 0;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[1].xy) - wgBx[1].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 1;\n    ust = abs (mPtr.xy * vec2 (asp, 1.) - wgBx[2].xy) - wgBx[2].zw;\n    if (max (ust.x, ust.y) < 0.) wgReg = 2;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel >= 0) {\n    if (wgSel == 0) {\n    } else if (wgSel == 1) {\n      rideHt = clamp (0.5 + 0.5 * (mPtr.y - wgBx[1].y) / wgBx[1].w, 0., 1.);\n    } else if (wgSel == 2) {\n      rideSpd = clamp (0.5 + 0.5 * (mPtr.y - wgBx[2].y) / wgBx[2].w, 0., 1.);\n    }\n  }\n  if (iFrag.y == 0.) {\n    if      (iFrag.x == 0.) fVal.zw = gSize;\n    else if (iFrag.x == 1.) fVal.zw = cEn;\n    else if (iFrag.x == 2.) fVal.zw = cEx;\n    else if (iFrag.x == 3.) fVal.zw = vec2 (growLim, pathLen);\n    else if (iFrag.x == 4.) fVal.zw = vec2 (nStep, nCar);\n    else if (iFrag.x == 5.) fVal.zw = mPtr.xy;\n    else if (iFrag.x == 6.) fVal.zw = vec2 (mPtr.z, float (wgSel));\n    else if (iFrag.x == 7.) fVal.zw = vec2 (rideHt, rideSpd);\n    else if (iFrag.x == 8.) fVal.zw = vec2 (carMove, tCurM);\n  } else if (iFrag.y == 1.) {\n    for (int k = 0; k < MAX_CAR; k ++) {\n      if (k == nCar) break;\n      if      (iFrag.x == 2. * float (k)) fVal.zw = cPos[k];\n      else if (iFrag.x == 2. * float (k) + 1.) fVal.zw = cDir[k];\n    }\n  }\n  fragColor = fVal;\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}