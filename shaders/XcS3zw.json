{
    "Shader": {
        "info": {
            "date": "1704104884",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "XcS3zw",
            "likes": 1,
            "name": "perlin rgb constant luma",
            "published": 3,
            "tags": [
                "perlinnoise"
            ],
            "usePreview": 0,
            "username": "HaleyHalcyon",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "#define TAU (6.283185307)\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat reverseSome(uint x) {\n  return float((x ^ x>>5u) & 2u) - 1.;\n}\n\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = 256u + uint(mod(uv.x, 256.));\n  uint y = 256u + uint(mod(uv.y, 256.));\n  time *= reverseSome(x) * reverseSome(y);\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\nfloat perlin(vec2 uv, vec2 loop, float offset) {\n  vec2 i = floor(uv * loop);\n  vec2 f = fract(uv * loop);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i + vec2(0.0,0.0), offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(i + vec2(1.0,0.0), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(i + vec2(0.0,1.0), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(i + vec2(1.0,1.0), offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\nvec3 lut8(vec3 rgb) {\nconst vec3 white = vec3(185, 185, 185) / 255.;\nconst vec3 red = vec3(220, 171, 186) / 255.;\nconst vec3 yellow = vec3(212, 178, 153) / 255.;\nconst vec3 green = vec3(176, 190, 152) / 255.;\nconst vec3 cyan = vec3(142, 196, 184) / 255.;\nconst vec3 blue = vec3(149, 191, 216) / 255.;\nconst vec3 magenta = vec3(192, 179, 217) / 255.;\nconst vec3 black = vec3(185, 185, 185) / 255.;\nreturn mix(\n  mix(\n    mix(black, red, rgb.r),\n    mix(green, yellow, rgb.r),\n  rgb.g),\n  mix(\n    mix(blue, magenta, rgb.r),\n    mix(cyan, white, rgb.r),\n  rgb.g),\n  rgb.b\n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 2.5);\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  \n  vec3 rgb = .5 * sin(vec3(\n    perlin(uv + 0.2, vec2(3), time)\n    + 0.5 * perlin(uv, vec2(7), -2. * time + 0.3),\n    \n    perlin(uv, vec2(3), time + 0.2)\n    + 0.5 * perlin(uv, vec2(7), -2. * time),\n    \n    perlin(uv + vec2(0.54, -0.3), vec2(3), time + 0.4)\n    + 0.5 * perlin(uv, vec2(7), -2. * time + 0.12)\n  ) * 3.5);\n  rgb = rgb + 0.5;\n  // Output to screen\n  fragColor = vec4(\n    lut8(rgb),\n    1.0\n  );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}