{
    "Shader": {
        "info": {
            "date": "1496874013",
            "description": "branch of \nhttps://www.shadertoy.com/view/4lsXDN\nand \nhttps://www.shadertoy.com/view/4sS3zz\nminor edits, more style.\n\nfor a texture, the non analytic differential approximation \nhttps://www.shadertoy.com/view/MdfGWn\nis still better",
            "flags": 0,
            "hasliked": 0,
            "id": "4dffRj",
            "likes": 5,
            "name": "ellipse 1+2b APPROX",
            "published": 3,
            "tags": [
                "ellipse2b"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 628
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/4dffRj\n//mom:  https://www.shadertoy.com/view/4lsXDN\n//dad:  https://www.shadertoy.com/view/4sS3zz\n\n//analytic distance to ellipse.\n//as opposed to a differential estimation of ellipse:\n//  https://www.shadertoy.com/view/MdfGWn\n\n#define zoom 3.\n#define frame(u) zoom*(u-.5*iResolution.xy)/iResolution.y\n\n//ellipse iterations, if(EllipseIter==0) return single pass solution with lots of exp()\n#define EllipseIter 0\n//only for very distant textures it makes sense to use EllipseIter [<8] instead of [0]\n//else [0] is faster and better, because \n//each iteration is 1*dot() 2*div, needs >10 iterations to look decent.\n//0 iterations is 4*sqrt() OR 2*pow()+2sqrt()\n\n#if (EllipseIter>0)\n/*\nComputing the distance to an ellipse \nusing David Eberly's method:\nhttp://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf\niq analytic: \nhttps://iquilezles.org/articles/ellipsedist \nhttps://www.shadertoy.com/view/4sS3zz\n*/\n//good for being an iterative aproach. not worth the loss in precsion.\n//12*dot() 24*div() as bare minimum, not efficient, except for when it looks shitty.\nfloat GetRoot(float r,float a,float b,float g){\n float s=0.,n=r*a,u=b-1.,v=mix(0.,length(vec2(n,b))-1.,step(0.,g));\n for(int i=0;i<EllipseIter;i++){\n  s=.5*(u+v);vec2 t=vec2(n/(s+r),b/(s+1.));g=dot(t,t)-1.;if(g>0.)u=s;else v=s;}return s;}\n//return distance of [u] to ellipse with bounding box [e]\n#endif\nfloat sdEllipse(vec2 u,vec2 e){e=abs(e);\n#if (EllipseIter>0)                           \n e.x=max(1e-3,e.x);//avoid null\n if(e.x<e.y){e=vec2(e.y,-e.x);\n u=vec2(u.y,-u.x);}//90deg rotation.\n u=abs(u); \n if(u.y==0.)return u.x-e.x;//minor lazy fix by ollj for u.y==0;\n vec2 z=u/e;\n float g=dot(z,z)-1.,o=e.x/e.y;o*=o;\n float s=GetRoot(o,z.x,z.y,g);\n vec2 r=u*vec2(o/(s+o),1./(s+1.));\n return length(u-r)*sign(u.y-r.y);}\n#else \n//https://www.shadertoy.com/view/4sS3zz\n//return distance of [u] to ellipse with bounding box [e]\n//is too low precision\n//float sdEllipse( vec2 u, in vec2 e){e=abs(e);u=abs(u); \n u=abs(u);\n if(u.x>u.y){u=u.yx;e=e.yx;}       \n float l=e.y*e.y-e.x*e.x,m=e.x*u.x/l,n=e.y*u.y/l,mm=m*m,nn=n*n,mn=mm*nn;\n float c=(mm+nn-1.)/3.,c3=c*c*c,q=c3+mn*2.,d=c3+mn,g=m+m*nn,o;\n if(d<0.){float p=acos(q/c3)/3.,s=cos(p),t=sin(p)*sqrt(3.);\n  p=sqrt(-c*(s+t+2.)+mm);s=sqrt(-c*(s-t+2.)+mm);o=(s+sign(l)*p+abs(g)/(p*s)-m)/2.;\n }else{               \n  float t=1./3.,h=2.*m*n*sqrt(d),s=sign(q+h)*pow(abs(q+h),t),u=sign(q-h)*pow(abs(q-h),t);  \n  vec2 x=vec2(-s-u-c*4.+2.*mm,(s-u)*sqrt(3.));\n  u=length(x);s=x.y/sqrt(u-x.x);o=(s+2.*g/u-m)/2.;}\n vec2 r=vec2(e.x*o,e.y*sqrt(1.-o*o));return length(r-u)*sign(u.y-r.y);}\n#endif\n\nvoid mainImage( out vec4 O,in vec2 U){\n vec2 u=frame(U),m=frame(iMouse.xy);\n float d=sdEllipse(u,m);\n vec3 r=1.-sign(d)*vec3(.2,.7,1.);\n r*=1.-exp(-2.*abs(d));//darkness\n r*=.8+.2*cos(120.*d);//ripples\n //r=fract(r);\n r=mix(r,vec3(1),1.-smoothstep(0.,.02,abs(d)) );\n O=vec4(r,1.);}\n\n// The MIT License\n// Copyright Â© 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, \n//to any person obtaining a copy of this software \n//and associated documentation files (the \"Software\"), \n//to deal in the Software without restriction, \n//including without limitation the rights to use, \n//copy, modify, merge, publish, distribute, sublicense, \n//and/or sell copies of the Software, \n//and to permit persons to whom the Software is furnished to do so, \n//subject to the following conditions: \n//The above copyright notice \n//and this permission notice shall be included in all copies \n//or substantial portions of the Software. no warranty, no allcaps. \n//what, are you, retarded?",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}