{
    "Shader": {
        "info": {
            "date": "1569489863",
            "description": "i practiced sphere tracing",
            "flags": 0,
            "hasliked": 0,
            "id": "Wdt3Wl",
            "likes": 4,
            "name": "select Dungeon",
            "published": 3,
            "tags": [
                "toon"
            ],
            "usePreview": 0,
            "username": "tono",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "\n#define M(x,y) mod(x,y) - y/2.\n\nconst float pi = acos(-1.);\nconst float pi2 = pi *2.;\nfloat dsphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat dbox(vec3 p,vec3 s)\n{\n\tp = abs(p) - s;\n\treturn max(p.x,max(p.y,p.z));\n}\n\nmat2 rot(float a)\n{\n\tfloat s = sin(a),c = cos(a);\n\treturn mat2(s,c,-c,s);\n}\n\nvec2 pmod(vec2 p , float r)\n{\n\tfloat a = atan(p.x,p.y) + pi/r;\t\n\tfloat n = pi2/r;\n\ta = floor(a/n) * n;\n\treturn p * rot(-a);\n}\n\nvec3 IFS(vec3 p)\n{\n\tfor(int i = 0; i < 4 ; i++)\n\t{\n\t\tp = abs(p) - 1.;\n\t\tp.xz = rot(1.) * p.xz;\n\t\tp.xy = rot(1.) * p.xy;\n\t}\n\treturn p;\n}\n\nfloat dist(vec3 p)\n{\n\t//p = IFS(p);\n\t\n\tvec3 s = vec3(0.5);\n\tfloat bo = dbox(p , s);\n\t\n\tp = M(p,3.);\n\tfor(int i = 0; i < 4 ; i++)\n\t{\n\t\tp = abs(p) - 1.;\n\t\tp.xz *= rot(1.);\n\t\tp.xy *= rot(1.);\n\t}\n\t\n\t\n\tp.yz = pmod(p.yz  , 4.);\n\tp.xy = pmod(p.xy  , 4.);\n\t//float sp = dsphere(p,0.1);\n\t\n\treturn min(bo,dbox(p,s));\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 d = vec3(0.001,0.,0.);\n\t\n\treturn normalize(vec3(\n\t\tdist(p.x + d) - dist(p.x - d),\n\t\tdist(p.y + d.yxz) - dist(p.y - d.yxz),\n\t\tdist(p.z + d.zyx) - dist(p.z - d.zyx)\n\t));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n\treturn ((clamp(abs(fract(h + vec3(0.,2.,1.)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = ( fragCoord.xy * 2.- iResolution.xy )/min(iResolution.x,iResolution.y);\n\tvec3 color = vec3(.0);\n\t\n\tfloat t = iTime*2.;\n\t\n\tp *= rot(t/20.);\n\t\n\tvec3 light = vec3(0.,0.,2.);\n\tvec3 cp = vec3(0.,0.,-10.);\n\tvec3 cd = vec3(0.,0.,1.);\n\tvec3 cu = vec3(0.,1.,0.);\n\tvec3 cs = cross(cd , cu);\n\t\n\tcp += cd * t;\n\tcp += cu * 3.* clamp(cos(t/2.),-0.5,0.5);\n\tcp += cs * 3. * clamp(sin(t/2.),-0.5,0.5);\n\t//cp.xy += rot(t / 20.) * cp.xy;\n\t//cd.xz = rot(t) * cd.xz;\n\t//cu.xy = rot(t) * cu.xy;\n\t\n\t\n\tfloat target = 2.5;\n\t\n\tvec3 rd = normalize(vec3(cu * p.y + cs * p.x + cd * target));\n\t\n\tfloat depth = 0.0;\n\tfloat ac = 0.0;\n\tvec3 normal;\n\tfor(int i = 0; i < 99 ; i++)\n\t{\n\t\tvec3 rp = cp + rd * depth;\n\t\tfloat d = dist(rp);\n\t\t//d = max(d , 0.001);\n\t\tif(d < 0.001)\n\t\t{\n\t\t\tnormal = getNormal(rp);\n\t\t\tbreak;\n\t\t}\t\n\t\tac += exp(-d * 3.);\n\t\tdepth += d;\n\t}\n\t\n\tcolor = vec3(ac/100.);\n\t\n\tfloat h = fract(sin(ac/50.));\n\tfloat s = 1.;\n\tfloat v = 5./ac;\n\t\n\tcolor = hsv(h,s,v);\n\tcolor = color * pow(dot(normal,light),2.);\n\tfragColor = vec4( color, 1. );\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}