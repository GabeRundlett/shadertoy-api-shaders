{
    "Shader": {
        "info": {
            "date": "1671459322",
            "description": "Alternate variant of the ubiquitous R2 sequence, see Common for details\nYields about 2x-3x the amount of precision",
            "flags": 32,
            "hasliked": 0,
            "id": "mts3zN",
            "likes": 10,
            "name": "Better R2 Sequence",
            "published": 3,
            "tags": [
                "goldenratio",
                "lowdiscrepancy",
                "quasirandom"
            ],
            "usePreview": 0,
            "username": "MartyMcFly",
            "viewed": 612
        },
        "renderpass": [
            {
                "code": "/*\n    R2 sequence (http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/)\n    and ~100 shadertoys on the topic\n    \n    Improved variant with different coefficients covers the 0-1 domain more evenly before float\n    precision limits. Each frame, 100 points are added. Left side ends up with more holes that don't\n    disappear, right side is more uniform and has better coverage.\n    \n    Generated pattern is identical (just flipped) so there's no reason NOT to use this over the other.\n    Would be interesting to measure convergence properties with the given precision or if this is just\n    a purely visual difference.\n    \n    A possible total solution could be e.g. to calculate float error and add a second pass of the sequence\n    to cover exactly this width\n    \n*/\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos / iResolution.xy; \n    o = texture(iChannel0, uv);\n    \n    float t = abs(uv.x - 0.5);\n    t /= abs(dFdx(t));\n    t = smoothstep(1.8,2.0,t);\n    \n    //o = mix(o, vec4(1.0), vec4(1.0 - t));   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define NUM_POINTS_PER_FRAME    1000\n#define SAMPLE_SKIP             5000 // 262144//100000 //skip ahead to see problematic areas\n\nvoid mainImage( out vec4 o, in vec2 vpos )\n{\n    vec2 uv = vpos / iResolution.xy;\n    vec2 orig_uv = uv;\n    uv.x *= 2.0;\n    \n    bool side = uv.x > 1.0;    \n    uv.x = fract(uv.x);\n    \n    o = vec4(0.0);\n    \n    float halfaspect = iResolution.x * 0.5 / iResolution.y;\n    float radius2 = 7.0 / (iResolution.x * iResolution.x);    \n    const int N = NUM_POINTS_PER_FRAME;\n    \n    uv.y /= halfaspect;    \n    uv.y += 0.5 * (halfaspect - 1.0);\n    \n    uv = uv * 2.0 - 1.0;\n    uv *= 1.05;\n    uv = uv * 0.5 + 0.5;\n    \n    float border = step(0.5, max(abs(uv.x - 0.5), abs(uv.y - 0.5))) * \n                   step(max(abs(uv.x - 0.5), abs(uv.y - 0.5)), 0.5 + length(fwidth(uv)));\n    \n    o = vec4(border);\n    \n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    \n    if(side) //new\n    {\n        for(int j = 0; j < N; j++)\n        {\n            vec2 p = r2_modified(float(j + iFrame * N + SAMPLE_SKIP), vec2(0.5));  \n            vec2 d = p - uv;\n            d.x *= aspect;\n            o.rgb += smoothstep(radius2 * 2.0, radius2, dot(d, d));    \n        }\n        \n        //o.rgb *= vec3(0.6, 1.0, 0.6);\n    }\n    else //old\n    {\n        for(int j = 0; j < N; j++)\n        {\n            vec2 p = r2_canonical(float(j + iFrame * N + SAMPLE_SKIP), vec2(0.5));   \n            vec2 d = p - uv;\n            d.x *= aspect;\n            o.rgb += smoothstep(radius2 * 2.0, radius2, dot(d, d));    \n        }\n    }\n    \n    \n    o = max(o, texture(iChannel0, orig_uv));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*   \n    \n    Canonical variant (for 2D) uses plastic number as base, as such:\n    \n        xi = frac(0.5 + index / phi)\n        yi = frac(0.5 + index / (phi * phi))  \n\n    or when precalculating the values\n    \n        xi = frac(0.5 + index * 0.754877666)\n        yi = frac(0.5 + index * 0.569840290998) \n    \n    Now, since we are limited by float precision, points for high indices quickly become\n    imprecise. Apart from the integer solutions that others here invented, it would be better \n    to find other values that produce similar (or the same) patterns but are ... smaller so\n    we run out of precision later? Here's how:\n    \n              frac(0.5 + index * (1/phi))  \n    =     1 - frac(0.5 - index * (1/phi)) \n    =     1 - frac(0.5 - index * (1/phi) + index) //any integer can be added in frac / mod 1 \n    =     1 - frac(0.5 + index * (1 - 1/phi))\n    =     1 - frac(0.5 + index * 0.245122333753)\n    \n    which is just the pattern flipped, so we can omit the 1-part without any problem\n    \n    So we can substitute 1/phi and 1/(phi*phi) with 1 minus their value and end up with\n    smaller coefficients:\n    \n        xi = frac(0.5 + index * 0.245122333753)\n        yi = frac(0.5 + index * 0.4301597090025)             \n        \n        \n    Now, this is probably not a new concept, as the vogel spiral uses the same logic.\n    The golden angle isn't 1.618*2pi or 0.618*2phi, it's (1-0.618)*2pi even though all\n    of them produce the same spirals (except flipped). \n    But: smaller coefficients means that problematic float regions are reached after\n    a higher amount of samples, yielding lower quantization error overall. Without\n    sacrificing any ALU or losing any of the precious properties the sequence has.\n    \n    This scales well to higher dimensions as the roots become smaller and thus 1-rcp\n    of them also shrinks.\n\n*/\n\n\n\nvec2 r2_canonical(in float idx, in vec2 seed)\n{    \n    return fract(seed + float(idx) * vec2(0.7548776662467, 0.569840290998));\n}\n\nvec2 r2_modified(in float idx, in vec2 seed)\n{\n    return fract(seed + float(idx) * vec2(0.245122333753, 0.430159709002));\n}\n\nvec2 r2_skippy(in float idx, in vec2 seed)\n{\n     uint w = 4096u;\n     uint i = uint(idx);\n     \n     vec2 phi = vec2(0.245122333753, 0.430159709002); //original phis\n     \n     vec2 phi_skip_w = fract(seed + float(w) * phi);\n     \n     \n     return fract(fract(float(i/w) * phi_skip_w + seed) + float(i%w) * phi + seed);\n     \n     //return fract(seed + float(idx) * vec2(0.245122333753, 0.430159709002));\n}\n\n\nfloat r1_modified(in float idx, in float seed)\n{\n    //normally uses 1/1.61803398875 = 0.61803398875\n    //but just like in vogel spiral, 1-0.61803398875 = 0.38196601125 also works\n    return fract(seed + idx * 0.38196601125);    \n}\n\nvec3 r3_canonical(in float idx, in vec3 seed)\n{    \n    return fract(seed + float(idx) * vec3(0.8191725133961, 0.6710436067038, 0.5497004779019));\n}\n\nvec3 r3_modified(in float idx, in vec3 seed)\n{\n    return fract(seed + float(idx) * vec3(0.180827486604, 0.328956393296, 0.450299522098));\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}