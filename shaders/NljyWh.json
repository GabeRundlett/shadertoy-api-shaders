{
    "Shader": {
        "info": {
            "date": "1649610322",
            "description": "A raymarching distance field render",
            "flags": 0,
            "hasliked": 0,
            "id": "NljyWh",
            "likes": 3,
            "name": "Raymarching Distance Field",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "Decycle",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "float sphereSDF(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.) / k;\n    return min(a, b) - h * h * h * k * 1. / 6.;\n}\n\nfloat worldSDF(vec3 p)\n{\n    const float sqrt3d2 = 0.8660254;\n    float sphere1 = sphereSDF(p, vec3(0.), 1.);\n    float sphere2 = sphereSDF(p, vec3(0., 1.2, 1.), 1.);\n    float sphere3 = sphereSDF(p, vec3(sqrt3d2, 1.2, -0.5), 1.);\n    float sphere4 = sphereSDF(p, vec3(-sqrt3d2, 1.2, -0.5), 1.);\n    \n    float smoothFactor = sin(iTime / 3.) * 2. + 3.;\n\n    float spheres = smin(smin(smin(sphere1, sphere3, smoothFactor), sphere2, smoothFactor), sphere4, smoothFactor);\n\n    float plane = p.y - (-0.5);\n    return smin(spheres, plane, smoothFactor);\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 small_step = vec2(0.001, 0.0);\n    float gradient_x = worldSDF(p + small_step.xyy) - worldSDF(p - small_step.xyy);\n    float gradient_y = worldSDF(p + small_step.yxy) - worldSDF(p - small_step.yxy);\n    float gradient_z = worldSDF(p + small_step.yyx) - worldSDF(p - small_step.yyx);\n\n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 ray_march(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = 0.;\n    const int NUMBER_OF_STEPS = 100;\n    const float MIN_DISTANCE = 0.0001;\n    const float MAX_DISTANCE = 1000.;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; i++)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n        float closest_distance = worldSDF(current_position);\n        if (closest_distance < MIN_DISTANCE)\n        {\n          vec3 light_position = vec3(2., -4., 3.);\n          vec3 light_direction = normalize(current_position - light_position);\n          float diffuse_factor = max(0.0, dot(light_direction, normal(current_position)));\n          return vec3(1.) * float(i) / 100.;\n        }\n        if (closest_distance > MAX_DISTANCE)\n        {\n          return vec3(1.) * float(i) / 100.;\n        }\n        total_distance_traveled += closest_distance;\n    }\n\n    return vec3(1.);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n    mat3 ry = mat3(\n      cos(angle), 0., sin(angle),\n      0., 1., 0.,\n      -sin(angle), 0, cos(angle)\n    );\n    \n    return ry * p;\n}\n\n      \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    float theta = iTime / 2.;\n    \n    vec3 ro = vec3(4. * sin(theta), 0.5, -4. * cos(theta));\n    vec3 rd = vec3(uv.x * iResolution.x / iResolution.y, uv.y, 1.);\n    rd = rotateY(rd, theta);\n    \n    vec3 color = ray_march(ro, rd);\n    fragColor = vec4(color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}