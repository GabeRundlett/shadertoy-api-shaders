{
    "Shader": {
        "info": {
            "date": "1520931598",
            "description": "A parameterized quartic surface:\n\n[url]https://en.wikipedia.org/wiki/Kummer_surface[/url]\n[url]http://mathworld.wolfram.com/KummerSurface.html[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "XsycRh",
            "likes": 7,
            "name": "Kummer Surface I",
            "published": 3,
            "tags": [
                "surface",
                "quartic",
                "algebraic",
                "kummer"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 620
        },
        "renderpass": [
            {
                "code": "//#define FAST\n#define QUALITY\n\n//#define MIRROR\n    \nbool doGamma = true;\nbool doSpecular = true;\nbool doDiffuse = true;\nconst float ambient = 0.5;\nconst float diffuse = 0.5;\nfloat specularPower = 4.0;\n\n\nconst vec3 defaultColor = 0.5*vec3(0.4,0.4,1.0);\nconst vec3 interiorColor = vec3(0.7,1,1);\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst float two31 = 2147483648.0;\nconst float phi = 1.618033;\nconst float phi2 = phi*phi;\nconst float phi4 = phi2*phi2;\n\n\nvec3 light;\nmat3 iMatrix;\n\nfloat Kummer(vec4 P) {\n  float A = sqrt(2.0);\n  float mu2 = 0.334 + 3.0*(1.0-cos(0.2*iTime));\n  float x = P.x; float y = P.y;\n  float z = P.z; float w = P.w;\n  float p = w-z-A*x;\n  float q = w-z+A*x;\n  float r = w+z+A*y;\n  float s = w+z-A*y;\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  float k = x*x + y*y + z*z - mu2*w*w;\n  return k*k-lambda*p*q*r*s;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec4 transform(vec4 p) {\n  float t = 0.1*iTime+1.0;\n  p.xz = rotate(p.xz,t);\n  return p;\n}\n\nfloat Fun(vec4 p) {\n  p = transform(p);\n  return Kummer(p);\n}\n\nvec3 selectColor(vec4 q, vec3 eye, vec3 n, bool interior) {\n#if !defined MIRROR\n    if (interior) return interiorColor;\n  return defaultColor;\n#else\n  // The ShaderToy cubemaps are quite high contrast, which\n  // tends to emphasise edge artefacts, so mute a little.\n  vec3 color = texture(iChannel0,reflect(eye,n)*iMatrix).rgb;\n  return min(vec3(0.75),sqrt(color));\n#endif\n}\n\n// Solution parameters.\n#if defined FAST\nconst int iterations = 100;    // Maximum number of iterations\nconst float maxincrease = 1.1; // Largest allowed step increase.\n#elif defined QUALITY\nconst int iterations = 300;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\n#else\nconst int iterations = 150;    // Maximum number of iterations\nconst float maxincrease = 1.06; // Largest allowed step increase.\n#endif\n\nconst float maxstep = 1.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\n\nvoid solve(out vec4 fragColor, vec4 p0, vec4 r) {\n  float k0 = 0.0, k1;\n  float a0 = Fun(p0), a1;\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec4 p;\n  float expected = 0.0;\n  for (int i = 0; i < iterations; i++) {\n    if (bracketed) {\n      // Once we are bracketed, just use bisection\n      if (k1-k0 < minstep) {\n        found = true;\n        break;\n      }\n      float k2 = (k0 + k1)/2.0;\n      //x = x0+k2*a, y = y0+k2*b, z = z0+k2*c, w = 1.0;\n      p = p0+k2*r;\n      float a2 = Fun(p);\n      if (a0*a2 <= 0.0) {\n        k1 = k2; a1 = a2;\n      } else {\n        k0 = k2; a0 = a2;\n      }\n    } else {\n      k1 = k0 + step;\n      p = p0 + k1*r;\n      a1 = Fun(p);\n      //The idea here is to try and correct the\n      // step size by seeing how close we are to\n      // the curve, but it doesn't seem to work\n      // very well.\n      float q = abs((a1-expected)/(a1+expected));\n      if (false && expected != 0.0 && q > 0.25) {\n        step *= 0.5;\n        expected = a0 + 0.5*(expected - a0);\n      } else if (a0*a1 <= 0.0) {\n        // We can hit exactly 0 - this counts as bracketed.\n        bracketed = true;\n      } else {\n        float step0 = step;\n        step = a1*step/(a0-a1);\n        step = abs(step);\n        step = min(step,maxstep);\n        // Don't grow step by more than a certain amount\n        // A better strategy should be possible\n        // Detect overstepping & retreat maybe.\n        step = max(step,minstep);\n        step = min(step,maxincrease*step0);\n        if (a1 <= a0) expected = 0.0;\n        else expected = a1 + step*(a1-a0)/(k1-k0);\n        k0 = k1; a0 = a1;\n      }\n    }\n  }\n  if (!found) {\n    fragColor = vec4(0,0,0,1);\n    return;\n  }\n\n  // Compute gradient & normal\n  // Should probably scale eps here\n  float eps = 1e-3;\n  vec2 delta = vec2(eps,0.0);\n#if 0\n  p = p0 + k0*r; // Ensure p corresponds to k0 and a0\n  vec3 n = vec3(Fun(p + delta.xyyy), Fun(p + delta.yxyy), Fun(p + delta.yyxy)) - a0;\n#else\n  // Not sure how much difference this makes\n  vec3 n = vec3(Fun(p + delta.xyyy) - Fun(p - delta.xyyy),\n                Fun(p + delta.yxyy) - Fun(p - delta.yxyy),\n                Fun(p + delta.yyxy) - Fun(p - delta.yyxy));\n#endif\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  vec3 eye = r.xyz;\n  // Point normal towards eye\n  if (dot(eye,n) > 0.0) n *= -1.0;\n  vec3 baseColor = selectColor(p,eye,n,a0 < 0.0);\n  vec3 color = baseColor;\n#if !defined MIRROR\n  color *= ambient;\n  float k = dot(light,n);\n  if (doDiffuse && k > 0.0) {\n    color += baseColor*diffuse*k;\n  }\n  if (doSpecular && k > 0.0) {\n    float specular = pow(max(0.0,dot(reflect(light,n),eye)),4.0);\n    color += 0.8*specular*vec3(1);\n  }\n  if (doGamma) {\n    color = sqrt(color);\n  }\n#endif\n  fragColor = vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1,1));\n\n  // Projection parameters\n  float camera = 10.0;\n\n  float scale = 5.0;\n  float x = scale * (fragCoord.x - 0.5*iResolution.x)/iResolution.y;\n  float y = scale * (fragCoord.y - 0.5*iResolution.y)/iResolution.y;\n\n  vec3 p0 = vec3(0.0,0.0,camera);\n  vec3 r = normalize(vec3(x,y,-camera));\n\n  // Rotate camera according to mouse position\n  float xrot = 0.0; // About x-axis\n  float yrot = 0.0; // About y-axis\n  if (iMouse.x > 0.0) {\n    yrot = TWOPI*(iMouse.x-0.5*iResolution.x)/iResolution.x;\n    xrot = TWOPI*(iMouse.y-0.5*iResolution.y)/iResolution.y;\n  }\n  mat3 mx = mat3(1,0,0,\n                 0,cos(xrot),sin(xrot),\n                 0,-sin(xrot),cos(xrot));\n  mat3 my = mat3(cos(yrot),0,sin(yrot),\n                 0,1,0,\n                 -sin(yrot),0,cos(yrot));\n  iMatrix = my*mx;\n\n  p0 = iMatrix*p0;\n  r = iMatrix*r;\n  light = iMatrix*light; // Light moves with camera\n  \n  solve(fragColor,vec4(p0,1),vec4(r,0));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}