{
    "Shader": {
        "info": {
            "date": "1627975396",
            "description": "Playing with transitions between views - in an isometric/domain repetition way. needed to publish so I would stop playing with it and move to something new.",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2XDw",
            "likes": 12,
            "name": "Pill Poppers",
            "published": 3,
            "tags": [
                "pillpoppers"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 318
        },
        "renderpass": [
            {
                "code": "/**\n\n    08/03/21 @byt3_m3chanic\n    Isometric tile pattern, playing with view\n    transitions - wanted something more than a hard\n    cut - came up with this wipe/slide.\n    \n    otherwise cheap refraction and a truchet design.\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n#define PI  3.14159265359\n#define MIN_DIST .0001\n\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\nvoid pmod(inout vec2 p, float rep) \n{\n    float angle = 2.*PI/rep;\n    float a = atan(p.y, p.x) + angle*.5;\n    a = mod(a,angle) - angle*.5;\n    p = vec2(cos(a),sin(a))*length(p);\n} \n//SDF's @iq\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat octa( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//global\nmat2 r45,turn;\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time,tmod,xln=0.,ga1,ga2,ga3,ga4;\n\nconst vec2 sc = vec2(.15), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    \n    p.xy+=vec2(time,5.);\n    \n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/sc;\n    vec3 q = vec3(r.x,p.y,r.y);\n\n    float rnd = hash21(id);\n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n\n    float hgt = 1.75;\n    vec3 fq = vec3(abs(q.x),q.y,abs(q.z));\n    float b3 =  cap(fq-vec3(hsc.x,hgt,hsc.x),.5,hgt);\n    if(b3<res.x) {\n        res = vec2(b3,4.);\n    \thit=p;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    float rt = mod(floor(rnd*10.),4.)+2.;\n    vec3 qt =q-vec3(0,2.,0);\n    qt.yz*=rot(T*rnd);\n    \n    float t1 = torus(qt,vec2(1.56,.025));\n    vec3 qf = qt;\n    qf.xy*=turn;\n    float b1 = min(box(qf,vec3(.55)),t1);\n\n    qt.xz*=turn;\n    pmod(qt.xz,rt);\n    qt.x-=1.5;\n\n    float b2 = octa(qt,.5);\n    b2=max(b2,-t1);\n    b2=min(b1,b2);\n    if(b2<res.x) {\n        res = vec2(b2,2.);\n    \thit=qt;\n        gid=id;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    float d9 = p.y;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gto=vec3(0.,dir,rnd);\n    }\n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist)\n{\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n)\n{\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(1,4,-1);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n\n    float shdw = 1.;\n    for( float t=.05; t < 14.; )\n    {\n        float h = map(p + l*t).x;\n        if( h<MIN_DIST ) { shdw = 0.; break; }\n        shdw = min(shdw, 18.*h/t);\n        t += h * .95;\n        if( shdw<MIN_DIST || t>32. ) break;\n    }\n    diff = mix(diff,diff*shdw,.4);\n\n    vec3 h = vec3(0.800,0.961,0.929);\n    \n    if(m==1.) {\n        hitPoint*=sc.xxx;\n        vec3 b = vec3(0.122,0.341,0.078);\n        vec3 w = vec3(0.329,0.627,0.545);\n        h = b;\n        vec2 grid_uv = fract(hitPoint.xz)-.5;\n        vec2 grid_id = sid;\n        float px = fwidth(hitPoint.x);\n\n        float rnd = sto.z;\n        float dir = sto.y;\n        if(rnd>.5) grid_uv.x*=-1.;\n\n        vec2 d2 = vec2(length(grid_uv-.5), length(grid_uv+.5));\n        vec2 gx = d2.x<d2.y? vec2(grid_uv-.5) : vec2(grid_uv+.5);\n        float blb = length(gx)-.5;\n        float curve =blb;\n        \n        curve=abs(abs(abs(abs(curve)-.05)-.05)-.025)-.0015;\n        curve = smoothstep(.011,.01,curve);\n        h=mix(h,vec3(0.792,0.894,0.929),curve);\n        \n        if(rnd<.5 ^^ dir>0.) blb*=-1.;\n        blb=smoothstep(.01,.011,blb);  \n        h=mix(h,w,1.-blb);\n\n        float cir2 = length(abs(grid_uv)-vec2(.5))-.16;\n        cir2 = smoothstep(.01,.011,abs(abs(abs(cir2)-.05)-.025)-.0025);\n        h=mix(h,vec3(0.792,0.894,0.929),1.-cir2);\n    }   \n\n    if(m==4.) {\n        h= vec3(0.584,0.894,0.525);\n    }\n\n    return (h*diff);\n}\n\nfloat zoom = 13.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    time = T;\n    r45 = rot(45.*PI/180.);\n    turn = rot(time*.75);\n    tmod = mod(time*.5, 10.);\n    float t1 = lsp(3.0, 5.0, tmod);\n    float t2 = lsp(8.0, 10.0, tmod);\n    ga1 = ((t1-t2)*2.2)-1.1;\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    //wipe\n    xln = ga1-(.025*sin(uv.y*25.+T*5.));\n    if(uv.x>xln) zoom *= .5;\n    \n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n    // use x in ry to mouse pan the scene..\n    //float x = M.xy == vec2(0) ? -.78539816339 : - (M.x/R.x * 4. - 2.) * PI *.5;\n    mat2 rx = rot(-0.78539816339);\n    mat2 ry = rot(time*.025);\n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = .725;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x * .725;\n        p += rd * d *k;\n        \n        if (d*d < 1e-6) {\n            hitPoint = hit;\n            sid = gid;\n            sto = gto;\n            \n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            if(m==1.)break;\n            \n            atten *= .65;\n            p += rd*.025;\n            k = sign(map(p).x);\n            \n            vec3 rr = vec3(0);\n            if(m==4.){\n                rd=reflect(-rd,n);\n                p+=n*.1;\n            }else{\n                float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 3.);\n                fresnel = mix(.01, .7, fresnel);\n                rr = refract(rd,n,.4);\n                rd=mix(rr,rd,1.-fresnel);\n     \n            }\n        } \n       \n        if(distance(p,rd)>125.) { break; }\n    }\n    \n    if(uv.x>xln && uv.x-.01<xln)C=vec3(1);\n    C = mix(C,C+.07,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}