{
    "Shader": {
        "info": {
            "date": "1695202322",
            "description": "Ray marching test. The entire scene is defined in `float sdf()`. Closer objects are brighter, ",
            "flags": 0,
            "hasliked": 0,
            "id": "mdfyWB",
            "likes": 1,
            "name": "Test: Ray marching (Mitsync)",
            "published": 3,
            "tags": [
                "test",
                "ray",
                "marching"
            ],
            "usePreview": 0,
            "username": "Mitsync",
            "viewed": 172
        },
        "renderpass": [
            {
                "code": "// MitSync, 2023\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define MARCH_THRESH 0.0001\n#define ITERATIONS 250\n#define REFLECTIONS 3\n#define FOV 0.8\n#define NORMAL_H 0.05\n\nconst vec3 camera_pos = vec3(2.5, 0.0, 0.0);\nconst vec3 camera_dir = vec3(-1.0, 0.0, 0.0);\nconst vec4 amb_light = vec4(0.500,0.500,0.500,1.0);\nconst vec4 sky_color = vec4(0.639,0.682,1.000,1.0);\n\n// Planes are defined in a vec4 as the coefficients abcd in (a*x + b*y + c*z - d = DISTANCE)\nconst vec4[] planes = vec4[]                       (vec4(1.0, 0.0, 0.0, -3.0), vec4(1.0, 0.0, 0.0, 3.0));\n// Spheres are defined in a vec4 as their center position and radius\nconst vec4[] spheres = vec4[]                      (vec4(0.0, 0.0, 0.0, 1.00), vec4(0.0, 1.0, 1.0, 0.5), vec4(0.0, -1.0, 1.0, 0.5),\n                                                    vec4(-1.0, -1.0, -1.0, 0.5), vec4(1.0, 1.0, -1.0, 0.5));\n\n// Colors are defined per primitive (same index) as a vec4 where xyz = albedo and w = specular\nconst vec4[] planes_color = vec4[planes.length()]  (vec4(1.000,1.000,1.000,1.0), vec4(1.000,1.000,1.000,1.0));\nconst vec4[] spheres_color = vec4[spheres.length()](vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0),\n                                                    vec4(0.5, 0.5, 0.5, 1.0), vec4(0.5, 0.5, 0.5, 1.0));\n\nstruct MarchReturn {\n    vec3 pos;\n    vec3 norm;\n    vec3 albedo;\n    float specular;\n};\n\nvec4 col4(in float f) {\n    return vec4(f, f, f, 1.0);\n}\n\nfloat sdf_sphere(in vec3 pos, in vec4 sphere) {\n    return length(pos-sphere.xyz)-sphere.w;\n}\nfloat sdf_plane(in vec3 pos, in vec4 plane) {\n    return abs(dot(pos, plane.xyz)-plane.w);\n}\n// SDF is generated from lists of primitives\nfloat sdf(in vec3 pos) {\n    float d = 9999.;\n    // Loop over all spheres in scene\n    for (int i = 0; i < spheres.length(); i++) {\n        d = min(d, sdf_sphere(pos, spheres[i]));\n    }\n    // Loop over all planes in scene\n    for (int i = 0; i < planes.length(); i++) {\n        d = min(d, sdf_plane(pos, planes[i]));\n    }\n    return d;\n}\n\n// Normal function of scene, computed by derivative of SDF\nvec3 normal(in vec3 pos) {\n    vec3 norm;\n    norm.x = sdf(pos + vec3(NORMAL_H, 0.0, 0.0));\n    norm.y = sdf(pos + vec3(0.0, NORMAL_H, 0.0));\n    norm.z = sdf(pos + vec3(0.0, 0.0, NORMAL_H));\n    return normalize(norm);\n}\n\n// Color function of scene, alpha is shininess\nvec4 color(in vec3 pos) {\n    // If we ask the color of air, return a hot magenta to indicate something went wrong\n    if (sdf(pos) > MARCH_THRESH) return vec4(1.0, 0.0, 1.0, 0.0);\n    \n    for (int i = 0; i < spheres.length(); i++) {\n        if (sdf_sphere(pos, spheres[i]) <= MARCH_THRESH) return spheres_color[i];\n    }\n    // Loop over all planes in scene\n    for (int i = 0; i < planes.length(); i++) {\n        if (sdf_plane(pos, planes[i]) <= MARCH_THRESH) return planes_color[i];\n    }\n    \n    //vec4 col = pos.y > 0. ? vec4(0.5, 0.5, 0.0, 1.0) : vec4(0.0, 0.5, 0.5, 1.0);\n    //vec4 col = vec4(abs(pos/2.), 1.0);\n    vec4 col = vec4(normal(pos), 1.0);\n    //vec4 col = vec4(0.5, 0.5, 0.5, 0.3);\n    \n    // Everything further than the camera is a shiny checkerboarded mirror\n    //vec4 mirror = vec4(vec3(mod(floor(pos.y)+floor(pos.z), 2.0) == 1. ? 1.0 : 0.5), 1.0);\n    vec4 mirror = vec2(0.5, 1.0).xxxy;\n    return (abs(pos.x) > camera_pos.x) ? mirror : col;\n}\n\nvec4 raycast(in vec3 pos, in vec3 dir) {\n    // Total distance of ray, set to 0.0 if we didn't hit anything.\n    float total_distance = 0.0;\n    float d = 0.0;\n    for (int j = 0; j < ITERATIONS; j++) {\n        d = sdf(pos);\n        // If we're shooting off\n        if (d > 100.) {\n            total_distance = 0.0;\n            break;\n        }\n        // If we've hit something, we're done\n        if (d < MARCH_THRESH) break;\n        // March one step forward\n        pos += dir * d;\n        total_distance += d;\n    }\n    return vec4(pos, total_distance);\n}\n\nvec4 march(in vec3 pos, in vec3 dir) {\n    // List of hits and how many there are (always at most REFLECTIONS)\n    vec4[REFLECTIONS] hit_col_list;\n    float[REFLECTIONS] hit_angle_list;\n    int hits = 0;\n    \n    float tot_d = 0.0;\n    \n    // Reused variable\n    vec4 raycast_results;\n    \n    for (int i = 0; i < REFLECTIONS; i++) {\n        raycast_results = raycast(pos, dir);\n        // If we didn't hit anything, no more reflections\n        if (raycast_results.w == 0.0) break;\n        tot_d += raycast_results.w;\n        \n        // Store color, we use this later to calculate final color backwards\n        hit_col_list[i] = color(raycast_results.xyz);\n        hit_angle_list[i] = -dot(normal(raycast_results.xyz), dir);\n        hits++;\n        // If the object we hit isn't reflective, no more reflections\n        if (hit_col_list[i].w < 0.01) break;\n        \n        // Reflect and march a tiny bit forward because otherwise we get stuck\n        pos = raycast_results.xyz;\n        dir = reflect(dir, normal(pos));\n        pos += dir * 0.001;\n    }\n    \n    // Calculate color by following the reflections backwards\n    vec4 ray_color = sky_color;\n    for (int i = hits-1; i >= 0; i--) {\n        ray_color = (amb_light * hit_col_list[i] * hit_angle_list[i]) + (ray_color * hit_col_list[i] * hit_col_list[i].w);\n    }\n    \n    //ray_color = color(pos);\n    //return col4(tot_d/20.);\n    return vec4(ray_color.xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates ((0,0) is center, y goes from -1 to 1, aspect ratio preserved)\n    vec2 uv = ((2.0 * fragCoord)-iResolution.xy) / iResolution.y;\n    vec2 mouse_uv = ((2.0 * iMouse.xy)-iResolution.xy) / iResolution.y;\n\n    // Calculate direction of ray through this pixel (not accurate but good enough for now)\n    vec3 dir = camera_dir + vec3(0.0, FOV*(uv));\n\n    // March the ray and output returned color\n    fragColor = march(camera_pos - 2.*vec3(0.0, mouse_uv), normalize(dir));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}