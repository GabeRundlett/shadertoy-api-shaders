{
    "Shader": {
        "info": {
            "date": "1629166385",
            "description": "Idea/Technique taken from @NuSan, in his \"wireframe window\" shader \t[url]https://www.shadertoy.com/view/7tjSWt[/url]\nI wanted to highlight this technique because I thought it was so cool. ",
            "flags": 0,
            "hasliked": 0,
            "id": "7sdGRr",
            "likes": 52,
            "name": "Wireframe Rendering Trick",
            "published": 3,
            "tags": [
                "3d",
                "sdf",
                "wireframe"
            ],
            "usePreview": 0,
            "username": "Tater",
            "viewed": 1545
        },
        "renderpass": [
            {
                "code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.1415926535\n\n//This technique will eat steps like nothing else if you have a complex scene, but it does\n//look nice\n#define STEPS 128.0\n\n#define MDIST 50.0\n\nfloat box( vec3 p, vec3 b ){\n  vec3 d = abs(p)-b;\n  return max(d.x,max(d.y,d.z));\n}\nfloat octa( vec3 p, float s){\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*-tan(5.0*pi/6.0);\n}\n\n//Standard SDF scene with material IDs\nvec2 map(vec3 p){\n    vec2 a = vec2(1),b = vec2(2);\n    float t = iTime;\n    vec3 po = p;\n    \n    //Box\n    p.x+=9.0;\n    p.xy*=rot(t);\n    p.yz*=rot(t);\n    p.zx*=rot(t);\n    a.x = box(p, vec3(1.5));\n    //Onion the box\n    a.x = abs(abs(a.x)-0.4)-0.2;\n    \n    //Octahedron Thing\n    p = po;\n    p.xy*=rot(-t);\n    p.yz*=rot(-t);\n    p.zx*=rot(t);\n    \n    b.x = octa(p,4.0);\n    b.x = max(b.x,box(p,vec3(4.0-(sin(t)*0.5+0.5)*2.0)));\n    a = (a.x<b.x)?a:b;\n    \n    //Exploding Cube\n    p = po;\n    p.x-=9.0;\n    p.xy*=rot(-t);\n    p.yz*=rot(t);\n    p.zx*=rot(-t);\n    float off = 0.8*min(2.5*(sin(t)*0.5+0.5),1.5);\n    \n    p= abs(p)-off*0.9;\n    p= abs(p)-off*1.3;\n    \n    b.x =  box(p,vec3(0.75));\n    b.y = 3.0;\n    a = (a.x<b.x)?a:b;\n    return a; \n}\n\n//Not all normal functions work the same, @totetmatt also suggested this one\n//which works as well.\n\n/*\n#define q(s) s*map(p+s).x\nvec3 norm(vec3 p,float e){vec2 nv=vec2(e,-e); return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\n*/\n\nvec3 norm(vec3 p, float s) {\n  vec2 off=vec2(s,0);\n  return normalize(\n   vec3(map(p+off.xyy).x, map(p+off.yxy).x, map(p+off.yyx).x)\n  -vec3(map(p-off.xyy).x, map(p-off.yxy).x, map(p-off.yyx).x));\n}\n\n//When I first saw NuSan's shader from the nevoke pre-jam I didn't notice\n//he was actually rendering the wireframe of objects and not just the edge.\n//I've tried to come up with a way to render SDF wireframes more than once\n//so seeing such an easy way to do it feels like a christmas present\n\n//Brief Explination based on my understanding of how this works:\n//Hit an object, calculate it's edge with FMS_Cat edge technique,\n//March through the inside of the object, then after hitting the inside \n//calculate the edge again and combine it with previous edges\n\n//Technically the rendered lines are like 90 degree corners,\n//so if they are very thick or the angles are shallow you will \n//be able to tell that they aren't a consistent width, but the \n//effect is still quite good imo.\n\n\nvoid render( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    vec3 ro = vec3(0,0,-16.5);\n    vec3 lk = vec3(0,0,0.0);\n    vec3 f = normalize(lk-ro);\n    vec3 ra = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*0.9+uv.x*ra+uv.y*cross(f,ra);\n    \n    //s (sign) variable will be used to keep track of if we are marching inside\n    //or outside an object\n    \n    //In NuSan's original shader he didn't used this, and instead added\n    //the abs() of the distance to keep marching through objects\n    //This way has the benefit of being able to converge to the surface before\n    //continuing which makes the lines a bit crisper, but costs some steps & performance\n    float s=1.0;\n    \n    float rayDist,shad;\n    vec3 p = ro;\n    vec2 d;\n    bool hit = false;\n    vec3 al;\n    \n    //Raymarch loop\n    for(float i =0.0; i<STEPS; i++){\n\n        //Set current point to based on rayDistance\n        p = ro+rd*rayDist;\n        \n        //Get scene dist and material ID\n        d = map(p);\n       \n        //Converge onto the surface (Seems large epsilon values work better)\n        if(abs(d.x)<0.01){\n        \n            //Determine wireframe/material color whenever an object is hit\n            if(d.y == 1.0)al = vec3(1.000,0.659,0.976);\n            if(d.y == 2.0)al = vec3(0.016,1.000,1.000);\n            if(d.y == 3.0)al = vec3(1.000,0.647,0.325);\n            \n            //Calculate how big the normal sample offset difference should be\n            //based on ray distance, so the wireframe is the same thickness\n            //everywhere. \n            \n            //You can remove the \"rayDist\" term and the wireframes will get thinner\n            //further away which sometimes looks better but you will need to increase\n            //the initial value considerably \n            float edge = 0.003*rayDist*clamp(800.0/iResolution.x,1.0,2.5);\n            \n            //Edge detection, not sure exactly how this works but I think FMS_Cat\n            //was the first one to use this trick. \n            \n            //You take length of the difference of two normalize vectors, the bigger \n            //the difference in offset of the normal the thicker the edge will be. \n            float edgeAmount = length(norm(p, 0.015)-norm(p, edge));\n            \n            //Add the detected edge, I use smoothstep here to make\n            //The edge a bit crisper but it's not nessecary.\n            \n            //Multiply this value by a lower number to give the wireframe\n            //a trasparent effect (helps a lot in complex scenes) \n            col += smoothstep(0.0,0.1, edgeAmount)*0.25;\n            \n            //The magic bit, after we detect an edge invert the s (sign) value,\n            //and keep marching through the object but now with an inverted\n            //distance field, so the edge detection gets run every time we hit\n            //any sufrace, effectively creating a wireframe instead of just edges\n            s*=-1.0;\n            d.x = 0.01*s;\n            \n            //Quick iteration based fake ao to get shading\n            if(!hit){\n                shad = i/STEPS;\n                hit = true;\n            }\n        }\n        //A maximum distance break is pretty required since the rays will never hit anything\n        if(rayDist>MDIST) break;\n        \n        //Add the current scene distance to the ray length, with the s (sign) value\n        //so we always march through objects, some understepping also helps remove \n        //artifacts.\n        rayDist+=d.x*s*0.825;\n        \n        //Alternatively you can remove the s (sign) term from everywhere in the shader\n        //and replace this bit with\n        //rayDist+=abs(d.x);\n       \n    }\n    //Grab the wireframe color that came out of the ray marcher\n    vec3 wire = col;\n    \n    //Color the wireframe\n    wire = clamp(wire,0.0,1.0)*al;\n    \n    //Quick iteration shading\n    shad = pow(1.0-shad,2.0);\n    if(hit)col = vec3(shad)*sqrt(al);\n    \n    //Mix between shaded and wireframe scene\n    col = mix(col,wire,clamp(1.0-pow(sin(t*0.5),3.0),0.0,1.0));\n    \n    fragColor = vec4(col,1.0);\n}\n//My quick copy paste AA\n//If you can afford the performance it looks a lot better with AA (change AA to 2.0);\n#define AA 1.0\n#define ZERO min(0.0,iTime)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = 1.0/AA;\n    vec4 col = vec4(0);\n    \n    if(AA==1.0) {render(col,fragCoord); fragColor = col; return;}\n    \n    for(float i = ZERO; i <AA; i++){\n        for(float j = ZERO; j <AA; j++){\n            vec4 col2;\n            vec2 coord = vec2(fragCoord.x+px*i,fragCoord.y+px*j);\n            render(col2,coord);\n            col.rgb+=col2.rgb;\n            //If the shader uses accumulation effects they need to be reset here\n        }\n    }\n    col/=AA*AA;\n    fragColor = vec4(col);\n}\n\n\n//Fabrice's magic AA\n/*\nvoid mainImage(out vec4 O, vec2 U) {\n    render(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { render(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}\n*/\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}