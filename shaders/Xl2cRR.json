{
    "Shader": {
        "info": {
            "date": "1507175347",
            "description": "continuation of \nhttps://www.shadertoy.com/view/4lscW2\nadded VR and mouse input.\nremoved fisheye cam",
            "flags": 1,
            "hasliked": 0,
            "id": "Xl2cRR",
            "likes": 3,
            "name": "horizon mouse VR",
            "published": 3,
            "tags": [
                "reflection",
                "shadow",
                "water",
                "mirror",
                "vr",
                "horizon",
                "dynamiceps",
                "edynvr"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1066
        },
        "renderpass": [
            {
                "code": "//self  : https://www.shadertoy.com/view/4lscW2\n//parent: https://www.shadertoy.com/view/4td3Dj\n//many minor improvements. I twiddledand learned a few things\n//hard to describe your progress when you basically just try somewhat random ideas\n//and only let the apparently better ones progress.\n\n//the MAX_ limit range definitions only set upper bounds.\n//that are reached exponentially, so their size barely matters.\n//\n//MAX_SHADOW_REFLECTIONS sets how many reflections will have shadows calculated for them\n#define MAX_SHADOW_REFLECTIONS 2.0\n//with 2.0, a reflection in a reflection has shadows in it. usually enough.\n//\n///MAX_DIST can easily be 1000000. but may crash in higher resolutions\n#define MAX_DIST          100.\n//note to self , with synamiceps log() , \"MAX_DIST\" changed its meaning \n// into something that is just not \"maximum distance\" of anything non fuzzyanymore.\n\n//MAX_STEPS can easily be 1000000. but may crash in higher resolutions\n#define MAX_STEPS         200.\n//MAX_HARD can be 200 to 2000, depending on hardware, but may crash in higher resolutions\n#define MAX_HARD  700\n//this is the absolute upper limit of steps per ray, including all its reflections.\n//the hardlimit is only reached in extreme cases, \n//like when the camera POSITION is already close to a surface!\n\n\n//every second pixel is skipped and left black. +20% more fps on older hardware?\n//#define doLazyDither\n//not worth it.\n\n#define doOcclusionShaddow\n//AO really helps the projection, because it is full of mirrors, confusing without AO\n#define doOcclusionAmbient\n\n#define sat(a) clamp(a,.0,1.)\n\n/*\nThis revision adds 2 LOD modes to how it approaches the surface of a gradient.\nIn a sense, this makes it similar to heavily mixing 2 LOD renders of \"spyro the dragon\"; .\n Close distance has epsilon increase over     distance² , good for mirror, bad for horizon\n Far   distance has epsilon increase over log(distance²), too much distortion for mirrors\nA lot of twiddilng is involved to make the 2 \"overlap\" nicely.\n \"overlap\" in the sense that, a ray may bounce 5 times,\n  and all accumulating precision errors of many rough estimates must be kept small.\n*/\n\n/*\nhard bugs:\n distance to sinusoidial floow is not lipschitz continuousö\n maybe add any texturing to this bland method-demo.\n It could need more parameters to the shadow function \n  to make it look better close up than a far.\n I have incomplete plans to include [Cauchy distribution] \n  to move shadowSamlingPoints closer to the camera.\n \n Not sure why, but shadertoy makes the color depth in reflections within reflections \n  look a lot lower than other boilerplates.\n this is likely a precision issue, unlikely a conversion error.\n*/\n\n\n/*\n Older notes from the parent version:\n\n by ollj\n goal is to allow for high render distance and high detail close to the camera\n goal is to allow for hall of mirror reflections for as long as there are steps left, \n  scatterable non-fake reflections.\n goal is to see the shadow in the reflection of a revflection of a reflection...\n goal is to have any fragment converge in the same linear time\n  where closer surfaces simply get more detail/reflections.\n Idealy a top down perspective gets the same fps than a set with an infinite horizon!\n practically, there is still a difference of 60to5 fps, but i am slowly getting to 40to40; ..\n Ambient Occlusion calculatons are draining most resources.\n\nBelow methods causes raymarching to converge more linearily\n for many very different fragments of very different scenes\n  While it also \"warps space\" towards the ray, the more steps have been taken.\n Surfaces close to the camera have low epsilon, high precision, lots of reflections.\n Surfaces far from the camera have less precision, less reflections, higher epsilon\n Surfaces/hallways that are nearrly coplanar to a ray \n  no longer have the problem of \"running out oof steps\" AT ALL.\n\nLONG RENDER DISTANCE;\nHeuristic root solving either converges too slowly or too quickly.\nif (converges too quickly) you could have more detail == larger distances instead.\nIdeally you want to modify them so that all possible cases converge roughly equally.\nThis is achieved by defining MAX_DIST and MAX_STEPS as non-static float pools\n that diminish with each raymarchng step,\nIf (any pool drains below 0) the raymarching ends before MAX_HARD iterations.\n heuristic root solving is eigher likely [too divergend] or [converging too slowly]\n these 2 extremes are constrained by draining MAX_DIST and MAX_STEPS.\nDoing many small steps drains the 2 pools reciprocally-DIFFERENTLY from, the other \n than doing many large steps!\nBoth with one (reciprocal) factor, both pools converge \"much more equally\" \n depending on \"scene openness\" because they drain by the same factor.\n\nRECURSIVE REFLECTION;\nIf (a ray hits a reflective wall) it keeps raymarching a bounched ray.\n The loop sums up a total color as sum of all reflected rays.\nA reflected ray makes up a smaller fraction of the total color.\nIf (that fraction is too small) no morere flecting of this ray happens,\nFinally, the last reflected fraction of a color is added; \n if (we run out of steps) that is \"sky\" or \"ground\" color.\nTodo, make that =mix(SkyOrGroundColor,gradientColor,reasonablyScaledDistanceToGradient)\n\nBALLACHE OF PRECISION\n (nearby) reflections need high precision of they distort too much.\n DynamicEps methods insist on low precision, tent to be very \"noisy\"\n Depending on a points distance to camera, \n  it use a differet (conditions) to determine if (a point is near a surface).\n p+=SurfaceNormal; is a necessary compromise between fast and good recursive reflections.\n*/\n\n\n#define PI acos(-1.)  \n#define PIB asin(1.)\n\n#define skyColor       vec3(.2,.5,1.)\n#define shadowColor    vec3(.2,.2,.5)\n#define groundColor    vec3(.6,1.,.7)\n#define buildingsColor vec3(.8,.7,.2)\n#define redColor       vec3(.9,.2,.7)\n//these colors visually make sense for contrast, even for red-green blindness.:\n//shadows are blue\n//ground is greener\n//floating objects are red\n//near ground objects are yellow\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n//these defines are not too practiical:\n#define fovyCoefficient 1.\n#define shadowHardness 3.\n#define time iTime\n\n//i lost my latest cleaned up iprved version of this, \n//leaving us with this older messier version.\n\n//the ugliest thing here is that,\n//if a reflected ray runs out of steps/distance, it aborts\n//meaning it is the last reflection\n//but without dithering this looks a bit ugly\n//\n//in other versions i added fake dithering by modifying RayDirection by +=0.001\n//for each step.\n//this warps space a bit (speudo randomly), which is still fine, we call this \"gravity\" , ya know?\n\n//the main trick here is that some cases are better for (nearby) reflections \n//while others are better for ling distance surfaces.\n//and all combinations can be made almost linearily convergent.\n//the problem here is that it only starts to look good \n//with at least 500 itterations of raymarchoing\n//too much for the average 2014 hardware in useful resolutions/framerates\n\nfloat CubeDistance2 (in vec3 point, in vec3 size){return length(max(abs(point)-size,0.));}\nfloat sdHexPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*.866025+q.y*.5,q.y)-h.x);}\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ){\n    vec3 q = mod(point, repetition)-.5*repetition;return q;}\nfloat CubeRepetition(in vec3 point, in vec3 repetition ){\n  point.x+=sin(point.y*.11+time*5.);\n  point.z+=cos(point.y*.11);\n  vec3 q = mod(point,repetition)\n  -0.5*repetition;q.y = point.y;\n  return sdHexPrism(q.zxy,vec2(10.,50));\n  return CubeDistance2 ( q, vec3 (10., 50.+sin(time)*15.,10.));}\nfloat PlaneDistance(in vec3 point,in vec3 normal,in float pDistance){return dot(point-(normal * pDistance), normal);}\nfloat modA(float x){return mod(time*.1+x+55.,230.)-55.;}\nfloat fSphere       (vec3 p,float r){return length(p)-r;}\nfloat SphereDistance(vec3 point, vec3 center, float radius){\n  point.z = modA(point.z);point.x = modA(point.x);\n  return fSphere(point-center,radius);}\nfloat RedDistance(in vec3 position){return SphereDistance(position,vec3(0.,66.,0.),30.);}\nfloat BuildingsDistance(in vec3 position){\n  return min(CubeRepetition(position                                ,vec3(80.,0., 90.)),\n\t         CubeRepetition(position+vec3(350.,sin(time)*30.,0.) ,vec3(90.,0.,100.)));}\nfloat GroundDistance(in vec3 position){return PlaneDistance(position,vec3(0.,1.,0.),0.);}\n//merging distance functions above to distanceField function below:\nfloat df(in vec3 position, out int mtl){\n    float radial=length(vec2(position.x,position.z));\n\tfloat radialSine=sin(radial*.05-time*2.)*5.;\n    float gndDistance=position.y-radialSine+6.;\n    float bldDistance=BuildingsDistance(position);\n    float redDistance=RedDistance      (position);\n                       float closest=gndDistance;mtl=   GROUND_MTL;\n    if (bldDistance<closest){closest=bldDistance;mtl=BUILDINGS_MTL;}\n    if (redDistance<closest){closest=redDistance;mtl=      RED_MTL;}\n    return closest;}\n//end of sdf geometry;\n\n//iqs famous softshadow, set to low quality\nfloat SoftShadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations ){\n    float penumbraFactor=1.0;vec3 sphereNormal;float t=mint;\n    for(int s=0;s<20;++s){if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t ));\n        if( nextDist < 0.001 ){return 0.0;}\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;}return penumbraFactor;}\n\n//distance fog is no longer needed, is a relict here.\nvoid applyFog( in float distance, inout vec3 rgb ){\n    //float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    //vec3 fogColor = vec3(0.9,0.95,1);\n    //if(fogAmount<.6)rgb= vec3(1.,1.,0.);\n    //else rgb=clamp(rgb,0.,1.);\n    //rgb=mix(skyColor,rgb,fogAmount);\n}\n//for mad()-awareness.\nfloat mad (float b,float c,float d){return b*c+d;}\n\n//this is based on old code, with inefficient material handling:\nvec3 MaterialColor(int mtl){\n    if(mtl==      SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==   GROUND_MTL) return groundColor;\n    if(mtl==      RED_MTL) return redColor;\n    return vec3(1.0,1.0,1.0);}\nfloat AmbientOcclusion(vec3 p,vec3 n,float d,float s){float r=1.;int t;\n  for(int i=0;i<5;++i){if(--s<0.)break;r-=(s*d-(df(p+n*s*d,t)))/pow(2.,s);}return r;}\n \n//i think THIS version of the shader solved all issues of normals, even normals with small epsilon?\n//by using a different dynamiceps close to the camera than faraway from the camera.\n//and by doing some epsilon twiddeling on the gradient itself.\n//i was tweaking this only to notice that e=0.1 is pretty much the best working value for the scenes scaling.\nvec3 ComputeNormal(vec3 pos, int material,float eps){int d;float e=.1;\n  return vec3(df(vec3(pos.x+e,pos.y  ,pos.z  ),d)-df(vec3(pos.x-e,pos.y  ,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y+e,pos.z  ),d)-df(vec3(pos.x  ,pos.y-e,pos.z  ),d)\n             ,df(vec3(pos.x  ,pos.y  ,pos.z+e),d)-df(vec3(pos.x  ,pos.y  ,pos.z-e),d));}\n\n\n//if (near surface) do surface things\n//[p]Position [d]RayDirection [c]colorAccumulator [e]epsilon [m]materialID \n//[s]shadowReflections \n//this function gets a LOT of revision.\n//it was tricky to seperate it from the loop that it is in, to more easily modify it.\n//this is all about making code easier to edit, and not about fast parsing.\nvec3 onSurface(inout vec3 p,inout vec3 d,vec3 c,\n    int m, float e,inout float s,     inout float sg    ){\n    vec3 n=ComputeNormal(p,m,e);n=normalize(n);\n      vec3 col=MaterialColor(m);\n      if(s>.0){//if we stil calculate shadows (for this reflection)\n\t\tvec3 lightpos = vec3(250.0*sin(time*.005), 400.0 + 40.0 *cos(time*.002), 250.0*cos(time*.005));\n        lightpos=lightpos-p;vec3 lightVector=normalize(lightpos);float lightdist=length(lightpos);\n     p+=n;//this is important for good reflections but \n    // it has side effects:\n    //the gradient is measured with the same offset from surface (good)\n    //the reflection happens at that offset, which leads to a [fold] of reflection space!\n    // and to a \"holographic mirror\"\n    //as if the surface has a thickness of +1.\n    //which is not too useful for fract(), adding differentials of -1 to compensate.\n        float shadow = SoftShadow(p, lightVector, 0.3, lightdist,shadowHardness);    \n        #ifdef doOcclusionShaddow\n        if(m==BUILDINGS_MTL){col=mix(shadowColor,col,sat(p.y/7.));}\n\t\tfloat attenuation=sat(dot(n,lightVector));\n\t\tshadow=min(shadow,attenuation);col=mix(shadowColor,col,shadow);\n        #endif\n        #ifdef doOcclusionAmbient\n        float AO=AmbientOcclusion(p,n,1.,7.);col=mix(shadowColor,col,AO);\n        #endif\n         s--;}\n      float refl=.34;//surface reflectiveness\n      if (m==GROUND_MTL)refl=.3;//ground has other reflectiveness\n      c=mix(c,col,sg);//mix the color of the current ray (reflection) with the accumulated total color to be returned.\n      sg=sg*refl;if(sg<.01)return c;\n      d=d-(n*1.5*(dot(d,n)));//direction gets reflected at surface normal. \n        //*1.5 factor means we WILL likely overstp within reflections, accumulatively for each reflection.\n        //this is a reasonable fps booster for less quality in reflections.\n return c;\n}\n\n//the raimarch loop gets complicated\n//, with  \"reflections till the horizon\" and \"dual dynamicEps\"\n/*dynamiceps Raymarching;\n- started with the idea of draining 2 pools, instead of one.\n- - Let [ee] be an epsilon that increments with each step\n     or that is = log(squaredDistanceToCamera/lastStelLength)\n- - there are 2 modes for epsilon increments.\n- - - the log(squared) mode is worse fror precision of reflections\n- - - the     squared  mode is worse for long distances.\n- - - we use [b] to switch between these modes.\n- - Let n be the distance to a surface, the gradient at p.\n- - maxDist-=ee/n; drains slower for many long steps, (substract normalized gradient)\n     This allows for much larger render distance (initial motivation for this)\n- - maxSteps-=ee*n; dains slower on many short step distances of near-parallel/orbital rays,.\n     This allows for smaller epsilon (secondary motivation for this)\n- - if(one of the pools is draind) assume that our epsilon is good enough.\n- - both pools drain speed (very likely) converges quickly.\n*/\n//main raymarching loop with maxDistance and MaxSteps and epsilon changed a bit.\n//if (hits a surface) reflect!\n//returns color of fragment.\n//[o]RayOrigin [t]RayDirection \nvec3 RayMarch(vec3 o,vec3 t)\n{int mtl=0\n;vec3 hitColor\n;vec3 r;\n  float sg=1.;\n  float n= 1.;\n  float s=MAX_SHADOW_REFLECTIONS;\n  float maxDist =MAX_DIST;\n  float maxSteps=MAX_STEPS;\n  #ifndef DynamicEpsLog\n    maxSteps*=4.;//simpler steps, but more steps\n  #endif\n  int hardLimit =MAX_HARD;\n  float e     =.01;\n //main raymardching loop accumulates a color. can do so over many reflections.\n //the maximum number of sphere-tracking steps is MAX_HARD;\n //the maximum number of reflections is MAX_HARD;\n //the maximum number of surfaces that get shadow and AO calculated for them is MAX_SHADOW_REFLECTIONS\n //because AO is an inner lop, and it makes sense to constrain the O(n*m) compleity\n //by limiting m<=MAX_SHADOW_REFLECTIONS, with n==MAX_HARD;\n for(int ever=0;ever<MAX_HARD;ever++){//the ride (n)ever ends! unless [hardlimit<0] triggers a return. this lets me drain hardlöimit in the loop-\n    n=df(o,mtl);\n   float ee=mad(n,.000001,e*1.00001);\n   float l=dot(o,o);\n   o+=t*n;\n   bool b=l<MAX_DIST;//could be =sqrt(l)*2.<MAX_DIST; makes not much of a difference.here\n   if(b)e=ee;               //for long view distance\n   if(b)b=.0<log(l/n*1e-7);//for long view distance\n   else b=n+.5<e*60.;      //for better close up shadows (+<.6 for sharper corners)\n   if(b){hardLimit--;r=onSurface(o,t,r,mtl,e,s,sg);}\n   maxSteps -=ee*n;\n   maxDist  -=ee/n;\n//i am sure this can be improved a lot. but benchmarking this on different scenes takes time.\n//and i lack the theoretical undertanding to model many cases to an optimum.\t\n      if(\n         maxSteps<0.1\n       ||maxDist<=0.\n       ||hardLimit<=0\n      ){\n\t   return mix(r,skyColor,sg);//overwrite horizon noise with sky\n}\n    \n  }\n    //there are some rays that needed more than MAX_HARD steps\n    //but also never exhausted any countdown.\n    //ths hints at lipschitz discontinuity, likely due to fisheye lens transform.\n    //evaluating rays that got lost in discontinuities is never pretty.\n    //trying my best here\n    //return vec3(3);//highlight what never got near a surface\n    r=onSurface(o,t,r,mtl,e,s,sg);\n    return mix(r,skyColor,sg);//overwrite horizon noise with sky\n;}\n\n\n#define zFar 20.*iResolution.y\n\n//Outoput,Uv,[A]=RayOrigin,[D]=RayDirection\nvoid mainVR(out vec4 O,in vec2 U,in vec3 A,in vec3 D){\n float nearestD=zFar;vec3 color=vec3(0);\n A.y+=1.;//+height of eyes above ground.\n float my=iMouse.y/iResolution.y;\n A.y+=1999.*max((my-.4),.0);\n D *=vec3(-1,1,-1);//A *=vec3(-1,1,-1);//flipping rays instead of flipping set\n float f=.0,d=.01;\n int mat,dd;\n vec3 p=A;//p gets modified in this loop, and used after it, parallel to A\n O=vec4(RayMarch(A,D),1.);\n;}\n\n#define u2(a) ((a)*2.-1.)\n\nvoid mainImage(out vec4 O,in vec2 U){\n const vec3 cameraPos=vec3(0);//camPos is simple offset\n const float rad=360./acos(-1.),dar=acos(-1.)/180.;\n vec2 m=u2(iMouse.xy/iResolution.xy); \n m=PI*mix(vec2(1.-m.x,m.y*.35),vec2(1,0),step(iMouse.z,.0));\n vec2 fov=vec2(25.);fov.x=atan(tan(fov.y/rad)*iResolution.x/iResolution.y)*rad;\n mat3 cam;\n cam[0]=vec3(cos(m.x),0,sin(m.x));//camera.right\n m.x=m.x+PI*.5;\n cam[1]=vec3(cos(m.x)*cos(m.y),sin(m.y),sin(m.x)*cos(m.y));//cameraFwd\n //cam[2]=-cross(cam[0],cam[1]));//camUp\n fov=(2.*U/iResolution.xy-1.)*sin(fov*dar)/sin(PI*.5-fov*dar);\n cam[0]=cameraPos-cam[1]+fov.x*cam[0]-fov.y*cross(cam[0],cam[1]);\n cam[1]=normalize(cam[0]-cameraPos);\n // scene is accidentally backwards, ugh\n cam[1]*=vec3(-1,1,-1);cam[0]*=vec3(-1,1,-1);\n mainVR(O,U,cam[0],cam[1]);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}