{
    "Shader": {
        "info": {
            "date": "1595379612",
            "description": "Prototype o scene used in \"Digiverse\"\nhttp://www.pouet.net/prod.php?which=76719",
            "flags": 32,
            "hasliked": 0,
            "id": "4sGfz1",
            "likes": 20,
            "name": "Digiverse - Planet",
            "published": 3,
            "tags": [
                "retro",
                "planet",
                "synthwave"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 707
        },
        "renderpass": [
            {
                "code": "float alpha;\n#define res iResolution\n\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.0003*8./6.,.04, 0);\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n//  based on simplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    vec4 col=texture(tex,uv);\n    float a = col.a;\n\n\tfor (int j=0;j<96;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (col.a > .9) {            \n\t\t\tbloom += col;  \n            \n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = \n        texture(iChannel0,uv) \n    \t+ texture(iChannel0,uv + pixel.xz) * .5\n        + texture(iChannel0,uv + pixel.zx) * .5\n        + texture(iChannel0,uv - pixel.xz) * .5\n        + texture(iChannel0,uv - pixel.zx) * .5;\n    \n    dof(iChannel0,uv, 3., orgColor / 3.);\n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., 1. - pow(abs(texture(iChannel0,uv).w - .5) * 2., 2.)),        \t\t\n            0.,\n            1.\n        )\n    );\n\n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., pow(length(uv -.5) * 1.8, 1.)),\n            0.,\n            1.\n        )\n    );\n \t\n    fragColor = mix(orgColor, bloom / 40., .5);    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define getNormal getNormalHex\n#define FAR 2900.\n#define INFINITY 1e32\n\n//#define FOG 1.\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n#define PI 3.14159265\n#define PHI (1.618033988749895)\n\nvec3 ro;\n \n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\n// \t3D noise function (IQ)\nfloat n(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(1,18,8);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    // linear\n    //p=p*p*(3.-2.*p);  \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    \n    return mix(h.x,h.y,p.z); \n}\n\n// \t3D noise function (IQ)\nfloat rand(vec3 p){ \n    float n = sin(dot(p, vec3(234, 7, 157)));    \n    return fract(length(vec3(123123, 2097152, 262144)*n)); \n}\n\nfloat Noise3D(vec3 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float x0 = mix(rand(i + e.xxx), rand(i + e.yxx), f.x);\n    float x1 = mix(rand(i + e.xyx), rand(i + e.yyx), f.x);\n    float x2 = mix(rand(i + e.xxy), rand(i + e.yxy), f.x);\n    float x3 = mix(rand(i + e.xyy), rand(i + e.yyy), f.x);\n    \n    float y0 = mix(x0, x1, f.y);\n    float y1 = mix(x2, x3, f.y);\n    \n    float val = mix(y0, y1, f.z);\n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat SmoothNoise(vec3 p)\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float val = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {   \n        amp *= 0.5;\n        val += amp * Noise3D(freq * p - float(i) * 11.7179);\n        freq *= 2.0;\n    }\n    \n    return val;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,0., 1.),\n\tlightDir;\n\nvec4 lightColour = normalize(vec4(0.0, .0, .0, 1.) ); \n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec4 color;  \n    vec3 space;\n    float mirror;\n    float i;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nfloat opS2( float d1, float d2 ){\t\n    if (-d2 > d1) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    \n    geometry box, s;\n    \n    float nn = n(vec3(p.x * abs(.01 ), p.z * 0.01, 0.)) * (max(4., abs(p.x * .01)));\n    //nn = min(nn, 8.);\n    nn *= smoothstep(0., 1., iTime) / 2.;\n    nn *= smoothstep(0., 1., abs(p.x) * .002);\n    \n    nn *= sin(p.x * .004);\n\n    p.y += 71.;\n    p.y *= .46;\n    p.y -= mix(0., 50., nn);\n\n    s.dist = fBox(p, vec3(1e9, .2, 1e9));\n    s.color = vec4(0.0, 0., .0,0.);\n    \n    s.specular = .5;\n    s.diffuse = 1.5;\n    s.materialIndex = 0.;\n    s.glow = 0.;\n    \n    bp.x += 175.;\n    \n    vec2 gr = pMod2(bp.xz, vec2(800.));\n    \n    bp += rand(gr.xyy) * 200.;\n    \n    box = s;\n    box.color = vec4[](\n        vec4(1., 0., 0., 0.),\n        vec4(0., 0.8, 1., 0.)\n    )[int(floor(rand(gr.xyx) + .5))];\n    \n    box.diffuse = 1.;\n    box.specular = 0.0;\n    box.materialIndex = 1.;\n    box.dist = fBox(bp, vec3(20., 3320., 20.));\n    box.glow = 1.;\n    \n    s = geoU(s, box);   \n    \n    return s; \n}\n\n// \tstandard sphere tracing inside and outside\ngeometry trace(vec3 ro,vec3 rd) \n{\n    geometry mp = map(ro);\n    mp.glow = 0.;\n    float minDist = INFINITY;\n    float function_sign=(mp.dist<0.)?-1.:1.;\n    float precis=.001;\n    float h=precis*1.;\n    float t=-0.0;\n    \n\tfor(int i=0;i<170;i++) \n\t{\n        if(abs(h)<precis||t>FAR)break;\n\t\tmp = map(ro+rd*t);\n        mp.i = float(i);\n        h=function_sign*mp.dist;\n        t+=h * .4;\n\t}\n    mp.dist = t;\n    return mp;\n}\n\nvec4 clouds(vec3 rd, vec3 ro) {\n    vec2 uv = rd.xz / rd.y * .4;\n   \n    vec4 clouds = vec4(\n        SmoothNoise(rd * 3.) * vec4(0., 0., 1., 1.) + \n        SmoothNoise(rd) * vec4(1., 1., 0., 1.)\n\t\n\n    ) - rd.y;\n \treturn clouds * max(1., rd.y) * 1.;\n}\n\nfloat SphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec4 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = 0.;\n    float sunAmount = max(dot(rd, lightDir), 1.);\n    float v = pow(1. - max(rd.y, 0.0), 12.);\n    vec4 cl = mix(vec4(1., 0., 0., 1.), vec4(0., 0., 1., 1.), rd.y);\n    vec4 sky = mix(cl, vec4(.0, .0, 0., 1.), v);\n \tvec3 lightColour = vec3(.1, .2, .3);\n    \n    sky += cl * sunAmount * sunAmount + vec4(1., 1., 0., 1.) *  min(pow(sunAmount, 120.0) * sunSize, 1. * sunSize);\n    \n    vec3 moon = vec3(0., 0., 22000. + iTime * 320.);\n    \n    float planetDist = SphereIntersect(ro, rd, vec4(moon, 17000.));\n\n    sky += clouds(rd, ro);\n    \n    \n    vec3 moo = ro + planetDist * rd;\n    vec3 nor = normalize(moo-moon);    \n\n    if (planetDist > 0.) {\n        vec3 nr = nor;\n        vec3 lp = normalize(light);\n\n\t\tpR(nr.xy, .3);\n        pR(nr.xz, iTime * .1);\n        \n\t\tpR(nr.xz, n(nr * 10. - nr.yxz * 3.) * 2.);\n        moo = mix(vec3(1., 1., 1.), vec3(1., .5, 0.), n(nr * vec3(.2, 9., .5) * 11.));            \n\n        sky.rgb = moo * pow(abs(dot(rd, lp)), 3.);        \n    } else {\n\t\tsky += clouds(rd, ro);\n\t}\n    \n    sky += clouds(rd, ro);\n    \n    return clamp(sky, 0.0, 1.0) ;\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 ld = lp;\n    float lDist = max(length(ld / 2.), 0.01);\n    ld /= lDist;\n\n    float diff = max(dot(sn, ld), obj.diffuse);\n    float spec = pow(max(dot(reflect(ld, sn), rd), 1.), obj.specular);\n    \n    vec4 objCol = obj.color;\n\n    return objCol * (diff) + spec * .001;\n}\n\n//\tnormal calculation\nvec3 normal(vec3 pos)\n{\n    float eps=0.01;\n\tfloat d=map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    float \n        mat = 0.,\n        camShY = 0.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 2.4;\n    light = vec3(20.,40., 132.);        \n    \n    vec3 \n        vuv = vec3(0., 1., 0. );\n    \t\n    ro = vec3(0., -50., 0. + iTime * 320.);\n    \n    vec3 vrp =  vec3(0., 0., 120.) + ro;\n    vec3 vpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),        \n    \trd = normalize(vec3(uv * 2., 1.)),        \n        hit;\n    \n    vec3 oro = ro;\n       \n    vec4 sceneColor = vec4(0., 0., 0., 0.);\n    \n    geometry tr = trace(ro, rd);    \n    geometry otr = tr;\n    \n    hit = ro + rd * tr.dist;\n    \n    vec3 ohit = hit;\n    float odist = tr.dist;\n    vec3 sn = normal(hit);\t\n\t\n\tvec4 sky = Sky(rd, true, normalize(light), ro) * 1.;\n    vec4 osky = sky;\n    float glow = 0.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n\t    glow = tr.glow;\n        \n        if (tr.materialIndex == 0.) {\n            sceneColor = mix(\n                vec4(1., 1., 1., 1.),\n                sceneColor,\n                smoothstep(.0, .075, abs(fract(ohit.x * .01) * 2. - 1.)) *                \n                smoothstep(.0, .075, abs(fract(ohit.z * .003) * 2. - 1.)) \n            );\n            sceneColor += length(cross(sn, normal(sn.zyx + 1.5)) * .5);\n        }\n        \n        sceneColor.a = pow(abs(sceneColor.a - .5) * 1.2, 4.) * 9.;\n\t\t\n        if (tr.materialIndex == 0.) {\n            sceneColor *= 1.-max(0., dot(sn, -light)) * .01;\n\t\t\trd = reflect(-rd, sn);\n            sceneColor += Sky(rd, true, normalize(light), ro) * .1 * sn.y;\n        }\n        \n        sceneColor = mix(sceneColor, sky, otr.dist / FAR/ 4.);\n    } else {\n        sceneColor = sky;\n    }\n \t\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0));\n    fragColor.a = glow;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.5));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}