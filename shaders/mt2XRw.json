{
    "Shader": {
        "info": {
            "date": "1675980548",
            "description": "Replicating the 'Japanese Ornamental design' (fig.17, pg.6) from paper by Rinus Roelofs:\n[url]http://www.archive.bridgesmathart.org/2007/bridges2007-81.pdf[/url]\n\nmouse x:\n  Pattern sizing\n\ntab:\n  See how pattern is constructed (mouse works here too)",
            "flags": 16,
            "hasliked": 0,
            "id": "mt2XRw",
            "likes": 14,
            "name": "Japanese Ornamental Tiling",
            "published": 3,
            "tags": [
                "escher",
                "hexagon",
                "tiling",
                "construction"
            ],
            "usePreview": 0,
            "username": "eo",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "/*\nReplicating a pattern found in \"Entwined Circular Rings\" by Rinus Roelofs:\nhttp://www.archive.bridgesmathart.org/2007/bridges2007-81.pdf\n\nHeavily relied on TheArtOfCode youtube video for hex tiling explanation:\nhttps://www.youtube.com/watch?v=VmrIDyYiJBA\n*/\n\nconst vec3 fg_color = vec3(0.9, 0.75, 0.6);\nconst vec3 bg_color_l = vec3(0.55, 0.25, 0.6);\nconst vec3 bg_color_r = vec3(0.9, 0.45, 0.1);\n\n\nvec3 draw_construction(vec2 uv, float circle_size_01) {\n\n    /*\n    Alternate coloring function, shows a simple animation\n    of how the tiling pattern is constructed.\n    It's basically two overlapping patterns of 3 circles,\n    see the comments/animation timing for more details\n    */\n\n    // Set up time steps/frames for animating construction\n    float t = mod(iTime*1.25, 9.0);\n\n    // Set important sizing\n    const float radial_offset = root3;\n    float circle_radius = mix(1.0, 1.5, circle_size_01);\n    \n    // Switch to full tiled view\n    if (t > 6.0)\n        uv = hex_uv(uv, 1.0).xy;\n    \n    // Get pattern sdfs\n    float bot_sdf = tricircle_sdf(uv, radial_offset, 0.0, circle_radius);\n    float top_sdf = tricircle_sdf(uv, radial_offset, 1.0, circle_radius);\n    float hex_sdf = 1.0 - hex_edge_dist(uv);\n    \n    // For convenience\n    float bot_edge = 1.0 - get_edge_outline(bot_sdf, 0.1);\n    float top_edge = 1.0 - get_edge_outline(top_sdf, 0.1);\n    float hex_edge = 1.0 - get_edge_outline(hex_sdf+0.05, 0.1);\n    float hex_mask = step(hex_edge_dist(uv), 1.0);\n    \n    // Pick colors (switch to white at end for clarity)\n    bool is_not_last_frame = t < 8.0;\n    vec3 bot_col = is_not_last_frame ? vec3(0,1,0) : vec3(1);\n    vec3 top_col = is_not_last_frame ? vec3(1,0,0) : vec3(1);\n    \n    // 'Bottom' circle pattern\n    vec3 col = vec3(0);\n    if (t > 1.0)\n        col = mix(col, bot_col, bot_edge) * step(bot_sdf, 0.0);\n    \n    // 'Top' circle pattern\n    if (t > 2.0)\n        col = mix(col, top_col, top_edge);\n    \n    // Cut away 'bottom' pieces outside of top circles\n    if (t > 3.0)\n        col *= step(top_sdf, 0.0);\n    \n    // Draw hex boundary\n    if (t > 4.0 && t < 7.0)\n        col = mix(col, vec3(1,1,1), hex_edge);\n    \n    // Cut away out-of-hex parts\n    if (t > 5.0)\n        col *= hex_mask;\n    \n    return vec3(col);\n}\n\nvec3 get_tile_color(vec4 uvid, float circle_size_01, vec3 bg_color) {\n\n    /*\n    Function which colors in a single (hex) tile. Caller of function\n    is responsible for tiling the uv coords.\n    \n    Most of the complexity comes from adding noise to the shadowing,\n    and then layering everything in the right order.\n    \n    For a better idea of how the pattern is made, see the\n    construction animation (press tab on viewer)\n    */\n\n    // For convenience\n    vec2 uv = uvid.xy;\n    vec2 noise_uv = (hash22(bg_color.xy*uv*500.5) - 0.5);\n    float noise_id = hash12(uvid.zw * 123.56) + 1.0;\n    float radial_falloff = 1.0 - length(uv + noise_uv*0.55) * two_over_root3;\n\n    // Set important sizing\n    const float radial_offset = root3;\n    float circle_radius = mix(1.0, 1.5, circle_size_01);\n    \n    // Get circle patterns used to contruct tiling\n    float bot_sdf = tricircle_sdf(uv, radial_offset, 0.0, circle_radius);\n    float top_sdf = tricircle_sdf(uv, radial_offset, 1.0, circle_radius);\n    \n    // Create binary masks\n    float top_mask = float(top_sdf > 0.0);\n    float bot_mask = float(bot_sdf > 0.0) * (1.0 - top_mask);\n\n    // Set up coloring\n    vec3 shadow_color = mix(fg_color, bg_color, 0.75);\n    vec3 edge_color = bg_color * 0.75;\n    float edge_thick = 0.04;\n    \n    // Get top-over-bottom shadowing maps (kind of mangled)    \n    float shadow_scale = mix(0.75, 2.0, circle_size_01);\n    float bot_shadow = clamp01(hex_edge_dist((uv + noise_uv)*shadow_scale));\n    float top_shadow = clamp01((root3 - bot_shadow)*shadow_scale);\n    \n    // Layer bottom circles over a background color, with edge line & shadow\n    vec3 col = mix(bg_color, fg_color, bot_mask);\n    col = mix(shadow_color, col, max(bot_shadow, 1.0 - bot_mask));\n    col = mix(edge_color, col, get_edge_outline(bot_sdf, edge_thick));    \n    \n    // Layer top circle pattern over lower pattern, with edge line & shadow\n    col = mix(col, fg_color, top_mask);\n    col = mix(shadow_color, col, max(top_shadow, 1.0-top_mask));\n    col = mix(edge_color, col, get_edge_outline(top_sdf, edge_thick));\n    \n    // Add random highlights for better contrast\n    float radial_highlight = mix(1.0, 0.9 + noise_id * 0.2, radial_falloff * top_mask);\n    col *= radial_highlight;\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Set up full-canvas coordinate spaces\n    vec2 uv_01 = fragCoord.xy / iResolution.xy;\n    vec2 uv = get_centered_unstretched_uvs(fragCoord, iResolution);\n    \n    // Set up background coloring\n    float bg_fade = 0.5*(1.0 + smoothstep(0.4, 0.6, 1.0 - length(uv_01 - 0.5)));\n    vec3 bg_color = mix(bg_color_l, bg_color_r, uv_01.x) * bg_fade;\n    \n    // Turn tiling on/off, for debugging\n    float tile_scale = 7.;\n    float mask = 1.0;\n    if (tile_scale < 1.1) {\n        mask = step(hex_edge_dist(uv), 1.0);\n        tile_scale = 1.0;\n    }\n    \n    // Handle mouse interaction\n    float is_mouse_down = clamp(iMouse.z, 0., 1.);\n    float default_circle_size = 0.3;\n    float mouse_circle_size = mix(0.1, 0.7, get_mouse_x_norm(iMouse, iResolution));\n    float circle_size = mix(default_circle_size, mouse_circle_size, is_mouse_down);\n    \n    // Switch between showing pattern vs. construction animation\n    vec3 col;\n    bool show_construction = get_key_toggle(iChannel0, KEY_tab);\n    if (show_construction) {\n        col = draw_construction(uv*tile_scale, circle_size);\n    } else {\n        vec4 uv_hextile = hex_uv(uv, tile_scale);\n        col = get_tile_color(uv_hextile, circle_size, bg_color);\n    }    \n    fragColor = vec4(col * mask, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define TWOPI 6.28318530718\n#define root3 1.732050808\n#define root3_over_2 0.866025404\n#define two_over_root3 1.154700538\n#define one_over_root3 0.577350269\n\n#define KEY_tab   9\n\n\n// -------------------------------------------------------------------------------\n// Noise functions\n\n// From Dave_Hoskins: https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n// -------------------------------------------------------------------------------\n// Helpers functions\n\nfloat clamp01(float value) {\n    return clamp(value, 0.0, 1.0);\n}\n\nfloat get_mouse_x_norm(vec4 mouse, vec3 res) {\n\n    /* Grab mouse x position, between 0 and 1, with some dead space on edges */\n\n    float is_mouse_down = clamp(mouse.z, 0., 1.);\n    float mouse_x_norm = clamp(2.0*mouse.x / res.x - 0.5, 0., 1.);\n    float default_mouse_not_down = 1.0;\n    return mix(default_mouse_not_down, mouse_x_norm, is_mouse_down);\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nvec2 get_centered_unstretched_uvs(vec2 fragCoord, vec3 iResolution) {\n\n    /*\n    - Center of the screen maps to (0,0)\n    - Top & bottom have y values: +1 & -1, respectively\n    - Left & right have x values of -/+ the aspect ratio (ex. 16/9)\n    */\n\n    return (2.0*fragCoord - iResolution.xy) / iResolution.y;\n}\n\nvec2 get_xy_from_polar(float r, float theta) {\n    return vec2(r*cos(theta), r*sin(theta));\n}\n\nfloat get_edge_outline(float sdf, float thickness) {\n    return smoothstep(-thickness*0.75, 0.0, abs(sdf) - thickness);\n}\n\n\n// -------------------------------------------------------------------------------\n// Circle sdfs\n\nfloat circle_sdf(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\n\nfloat offset_circle_sdf(vec2 uv, float radial_distance, float angle_radians, float circle_radius) {\n    vec2 xy_offset = get_xy_from_polar(radial_distance, angle_radians);\n    return circle_sdf(uv - xy_offset, circle_radius);\n}\n\nfloat tricircle_sdf(vec2 uv, float radial_offset, float angle_offset, float circle_radius) {\n    \n    float angle_step = TWOPI / 6.0;\n    \n    float c1 = offset_circle_sdf(uv, radial_offset, (angle_offset + 0.0)*angle_step, circle_radius);\n    float c2 = offset_circle_sdf(uv, radial_offset, (angle_offset + 2.0)*angle_step, circle_radius);\n    float c3 = offset_circle_sdf(uv, radial_offset, (angle_offset + 4.0)*angle_step, circle_radius);\n    \n    return min(c1, min(c2, c3));\n}\n\n\n// -------------------------------------------------------------------------------\n// Hex-specific functions\n\n/*\nSee TheArtOfCode/BigWings youtube videos for better explanations of hex stuff:\nhttps://www.youtube.com/watch?v=VmrIDyYiJBA\n*/\n\nfloat hex_edge_dist(vec2 uv) {\n\n    /*\n    Get distance to edges from uv point (0, 0),\n    output is scaled so edges are at a distance of 1.0\n    */\n    \n    // Define edge normal vectors\n    vec2 slant_normal = normalize(vec2(1.0, root3));\n    vec2 vert_normal = normalize(vec2(1.0, 0.0));\n    \n    // Mirror the uv in x & y, so we only have to figure out positive quadrant\n    vec2 mirrored_uv = abs(uv);\n    \n    // Find linear distance to both hex edges\n    float lindist_to_slanted_edge = dot(mirrored_uv, slant_normal);\n    float lindist_to_vertical_edge = dot(mirrored_uv, vert_normal);\n    \n    // Scale so that the distance to edges ends up being 1.0\n    float edge_dist = max(lindist_to_slanted_edge, lindist_to_vertical_edge);\n    edge_dist *= two_over_root3;\n    \n    return edge_dist;\n}\n\n\nvec4 hex_uv(vec2 uv, float tile_scale) {\n\n    /*\n    Makes staggered repeating uv pattern like:\n    .... ⬡⬡⬡ ...\n    ... ⬡⬡⬡⬡ ...\n    .... ⬡⬡⬡ ...\n    \n    Also returns unique 2D ids for each tile\n    Returns vec4: [uv x, uv y, id x, id y]\n    */\n\n    // Get tile steps\n    // x-direction: step full width once, which is twice the inner radius = 2 * √3 / 2 = √3\n    // y-direction: step full height + half height, which is 3 times outer radius = 3 * 1 = 3\n    vec2 grid_step = vec2(root3, 3.0);\n    vec2 half_step = grid_step * 0.5;\n    \n    // Create 2 grids using hex steps,\n    // one grid is off a half step to account for staggered rows\n    vec2 uv_tiled = uv * tile_scale;\n    vec2 odd_grid = mod(uv_tiled, grid_step) - half_step;\n    vec2 even_grid = mod(uv_tiled - half_step, grid_step) - half_step;\n    \n    // Make uvs by picking uvs from whichever grid is closest\n    float pick_even_row = float(length(even_grid) < length(odd_grid));\n    vec2 hex_grid = mix(odd_grid, even_grid, pick_even_row);\n    \n    // Bundle ids with output (useful for adding per-tile noise/effects)\n    // (note, the ids are not integers/nice numbers!)\n    vec2 id = round(hex_grid - uv_tiled);\n    return vec4(hex_grid, id);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}