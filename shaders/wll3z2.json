{
    "Shader": {
        "info": {
            "date": "1557002798",
            "description": "Wibbly wobbly, jelly on an infinite plate lmaoooo",
            "flags": 0,
            "hasliked": 0,
            "id": "wll3z2",
            "likes": 1,
            "name": "Wobbly Jellyland",
            "published": 3,
            "tags": [
                "raymarching",
                "implicitsurface"
            ],
            "usePreview": 0,
            "username": "MrsBeanbag",
            "viewed": 463
        },
        "renderpass": [
            {
                "code": "//uncomment this line to get mouse control rofl\n//#define MOUSE_CONTROL\n\n// ray marching\nconst int max_iterations = 128;\nconst float grad_step = 0.0001;\nconst float min_dist = 0.002;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 diffuse_colour = vec3(0.0);\nvec3 final_diff_colour = vec3(0.0);\n\nconst vec3 sky_colour = vec3(0.2, 0.1, 0.4);\nconst vec3 clouds_colour = vec3(1.0);\nconst vec3 sun_pos = normalize(vec3( 20.0, 30.0, 30.0 ));\n\n\nvec4 dist_sin(vec3 p, vec2 k, float a, float t) {\n    float kx = dot(k, p.xz) + t;\n    float d = a * sin(kx);\n    vec2 g = k * (a * cos(kx));\n    return vec4(g.x, 0.0, g.y, d);\n}\n\nvec4 sea(vec3 p) {\n\n    diffuse_colour = vec3(1.0, 0.7, 0.2);\n    vec4 h = vec4(0.0);\n    h += dist_sin(p, vec2(0.112, 0.215), 2.0, iTime * 0.23);\n    h += dist_sin(p, vec2(-0.163, 0.243), 1.7, iTime * 1.8);\n    h += dist_sin(p, vec2(-0.378, -0.317), 1.0, iTime * 2.1);\n    h += dist_sin(p, vec2(0.433, -0.451), 1.8, iTime * 3.6);\n    \n    h.w += p.y;\n    h.y = 1.0;\n    \n    // technique from\n    // https://iquilezles.org/articles/distance\n    h.w /= length(h.xyz);\n\n    return h;\n}\n\nfloat dist_field(vec3 p) {\n    return sea(p).w;\n}\n\nvec3 skybox(vec3 dir) {\n    float horizon = smoothstep(0.0, 0.25, dir.y);\n    float cloud = mix(0.8, 0.0, horizon);\n    return mix(sky_colour, clouds_colour, cloud);\n}\n\nvec3 gradient(vec3 p) {\n    return sea(p).xyz;\n}\n\n// parallel light source\nvec3 shading( vec3 v, vec3 n, vec3 dir, vec3 eye ) {\n\tfloat diffuse  = max( 0.0, dot( sun_pos, n ) );\n\tfloat shininess = 80.0;\n\t\n\tvec3 ref = reflect( dir, n );\n\tfloat specular = max( 0.0, dot( sun_pos, ref ) );\n\t\t\n\tspecular = pow( specular, shininess );\n\t\t\n\treturn final_diff_colour * diffuse + vec3(specular);\n}\n\n// ray marching\nvec3 ray_marching(vec3 o, vec3 dir) {\n    vec3 colour = vec3(0.0);\n    vec3 acc_refl = vec3(1.0);\n\n    // give the ray a bit of a head start by jumping\n    // straight to the upper bounding plane!\n    float t = 0.0;\n\n    vec3 v;\n    for (int i = 0; i < max_iterations; i++) {\n       \tfloat d = dist_field(v = o + dir * t);\n\n        if (abs(d) <= min_dist) {\n            break;\n        }\n        // sometimes it seems to overestimate the distance,\n        // so i put this fudge factor in, rofl\n\t\tif ((t+=d*0.8) >= clip_far) {\n            return skybox(dir);\n\t    }\n    }\n\tfinal_diff_colour = diffuse_colour;\n    \n    vec3 n = normalize( gradient(v) );\n\n    if (dot(n, sun_pos) < 0.0) {\n        return colour;\n    }\n\n    // shadows\n    t = 0.1;\n    for (int i = 0; i < max_iterations; i++) {\n        vec3 r = v + sun_pos * t;\n\t\tif (r.y > 6.5) {\n\t\t    colour += shading( v, n, dir, o );\n            break;\n\t    }\n\n        float d = dist_field(r);\n        if (d <= min_dist) {\n            break;\n        }\n        t+=d;\n    }\n    return colour;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nconst vec2 spin = vec2(0.005, 0.0041);\nconst float radius = 120.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// rotate camera\n#ifdef MOUSE_CONTROL\n\tmat3 rot = rotationXY( vec2(PI, -PI) * ((iMouse.xy - iResolution.xy)/iResolution.xy).yx );\n#else\n\tmat3 rot = rotationXY( vec2( -0.5, iTime * 0.1 ) );\n#endif\n\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 0.0 );\n\teye = rot * eye;\n    eye.y += 20.0;\n\n    // default ray dir\n\tvec3 dir = rot * ray_dir( 60.0, iResolution.xy, fragCoord.xy);\n\tvec3 color = ray_marching(eye, dir);\n\n    fragColor = vec4(color, 1.0);\n    return;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}