{
    "Shader": {
        "info": {
            "date": "1605836433",
            "description": "No context regular 6-gons and one black square animation",
            "flags": 0,
            "hasliked": 0,
            "id": "WscfWS",
            "likes": 4,
            "name": "Rotated Scaled Regular 6-gons",
            "published": 3,
            "tags": [
                "pattern"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 351
        },
        "renderpass": [
            {
                "code": "// Copyright Â© 2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.1415926536;\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\n\n// the thickness of lines\nconst float THICKNESS = 0.015;\n\n// The outer rotation polygon is N-GON.\nconst int N = 6;\n// the frequancy of waves (Hz)\nconst float FREQ = 1.75;\n// circumradius\nconst float RADIUS = 0.5;\n// the omega of the center rectangle\nconst float OMEGA_RECT = PI / 2.4;\n// the length of the edges of the center rectangle\nconst float L_RECTANGLE = 0.17;\n// If there are not enough waves, make this integer higher.\nconst int REPEAT = 3;\n\nconst float THETA = PI / float(N);\n// the cosine of PI / N.\nconst float COS = cos(THETA);\n// the rotation matrix generate polygon\nconst mat2 ROT = mat2(cos(THETA), sin(THETA), -sin(THETA), cos(THETA));\n// the omega of the outer polygon\nconst float OMEGA = THETA * FREQ;\n// inner radius\nconst float INNER_RADIUS = COS * RADIUS;\n/// velocity of wave\nconst float VELO = pow(cos(THETA) + sin(THETA) / tan(THETA * float(N / 2 - 1)), float(N));\n\nmat2 rot(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nvec2 uv_coord(vec2 coord) {\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0, 1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    return 2.0 * coord / iResolution[min_idx] - aspect_vec;\n}\n\nfloat line(vec2 uv, vec2 pt0, vec2 pt1) {\n    vec2 a = uv - pt0;\n    vec2 b = pt1 - pt0;\n    float t = dot(a, b) / dot(b, b);\n    vec2 h = a - t * b;\n    if (0.0 < t && t < 1.0) {\n        float x = 1.0 - 4.0 * dot(h, h) / (THICKNESS * THICKNESS);\n        return smoothstep(0.0, 1.0, x);\n    }\n    return 0.0;\n}\n\nfloat regpolygon(vec2 uv, vec2 pt, int n) {\n    vec2 pt0 = pt;\n    mat2 rot = rot(2.0 * PI / float(n));\n    float score = 0.0;\n    for (int i = 0; i < n; i++) {\n        vec2 pt1 = rot * pt0;\n        score = max(score, line(uv, pt0, pt1));\n        pt0 = pt1;\n    }\n    return score;\n}\n\nfloat radiation(vec2 uv, vec2 pt, int n) {\n    mat2 rot = rot(2.0 * PI / float(n));\n    float score = 0.0;\n    for (int i = 0; i < n; i++) {\n        score = max(score, line(uv, pt, vec2(0.0)));\n        pt = rot * pt;\n    }\n    return score;\n}\n\nfloat circle(vec2 uv, float r) {\n    float x = r - length(uv);\n    x = 1.0 - 4.0 * x * x / (THICKNESS * THICKNESS);\n    return smoothstep(0.0, 1.0, x);\n}\n\nbool in_rectangle(vec2 uv, vec2 pt) {\n    return abs(uv.x) < abs(pt.x) && abs(uv.y) < abs(pt.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    float step = 0.0;\n\n    vec2 rect_vert = vec2(L_RECTANGLE * cos(iTime * OMEGA_RECT), L_RECTANGLE);\n    if (in_rectangle(uv, rect_vert)) {\n        fragColor = vec4(BLACK, 1.0);\n        return;\n    }\n    \n    vec2 pt0 = vec2(cos(OMEGA * iTime), sin(OMEGA * iTime)) * RADIUS;\n    step = max(step, regpolygon(uv, pt0, N));\n    step = max(step, radiation(uv, pt0, N));\n    step = max(step, radiation(uv, ROT * pt0 * COS, N));\n\n    vec2 pt1 = vec2(cos(OMEGA * iTime), -sin(OMEGA * iTime)) * RADIUS;\n    step = max(step, regpolygon(uv, pt1, N));\n    step = max(step, radiation(uv, pt1, N));\n    step = max(step, radiation(uv, ROT * pt1 * COS, N));\n\n    step = max(step, circle(uv, INNER_RADIUS));\n\n    vec2 pt2 = vec2(1.0, 0.0);\n    for (int i = 0; i < N / 2 * REPEAT; i++) {\n        float rep = float(REPEAT);\n        float c0 = pow(VELO, rep * fract((iTime - float(2 * i) / FREQ) * OMEGA / PI / rep));\n        step = max(step, regpolygon(uv, pt2 * RADIUS * c0, N));\n        float c1 = pow(VELO, rep * fract((iTime - float(2 * i + 1) / FREQ) * OMEGA / PI / rep));\n        step = max(step, regpolygon(uv, ROT * pt2 * RADIUS * c1, N));\n    }\n    fragColor = vec4(WHITE * step, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}