{
    "Shader": {
        "info": {
            "date": "1556484501",
            "description": "infLight",
            "flags": 48,
            "hasliked": 0,
            "id": "wtX3DM",
            "likes": 1,
            "name": "InfLightVYZJIZ",
            "published": 3,
            "tags": [
                "inflight"
            ],
            "usePreview": 0,
            "username": "vyzjiz",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ---- SPHERE TRACING ----\n\nTraceResult enhancedSphereTrace(in Ray ray, in SphereTraceDesc params,in float omega)\n{\n    TraceResult traceRes = TraceResult(ray.Tmin, 0);\n\t\n    float previousRadius = sdf(ray.P + traceRes.T * ray.V);\n    float dist = previousRadius;\n    float currentRadius = sdf(ray.P + (traceRes.T + previousRadius) * ray.V);\n\tfloat nextRadius = 10000.0;\n    traceRes.T += previousRadius;\n    int i = 2; \n    \n    do\n    {\n        dist = currentRadius + omega * currentRadius * (dist - previousRadius + currentRadius) / \n            (dist + previousRadius - currentRadius);\n        nextRadius = sdf(ray.P + (traceRes.T + dist) * ray.V);\n        \n        if (dist > currentRadius + nextRadius)\n        {\n            dist = currentRadius;\n            nextRadius = sdf(ray.P + (traceRes.T + dist) * ray.V); \n        }\n        \n        traceRes.T += dist;\n        previousRadius = currentRadius;\n        currentRadius = nextRadius;\n        i++;\n    } \n    while \n    (\n\t\ttraceRes.T < ray.Tmax &&       \t\t\t\t// Stay within bound box\n\t\tnextRadius > params.epsilon * traceRes.T &&\t// Stop if cone is close to surface\n\t\ti < params.maxiters\t        \t\t\t\t// Stop if too many iterations\n\t);\n    \n    traceRes.flags =  int(traceRes.T >= ray.Tmax)\n              | (int(nextRadius <= params.epsilon* traceRes.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return traceRes;\n}\n\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)),sdf(p+vec3(0,eps,0)),sdf(p+vec3(0,0,eps)));\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)),sdf(p-vec3(0,eps,0)),sdf(p-vec3(0,0,eps)));\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz, 1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.0 ,0.0, 0.0, 1.0);\n}\nvec4 hitColor(Ray ray,float t,in float omega, in int algorithm)\n{\n    vec3 lightPos=vec3(10.0 ,10.0 ,10.0);\n    \n    vec3 rayPV = ray.P + ray.V * t;\n    vec3 normalizeLPR = normalize(lightPos - rayPV);\n    \n    Ray shadowRay = Ray(rayPV, 0.05, normalizeLPR, distance(rayPV, lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.03, 128);\n    TraceResult result = enhancedSphereTrace(shadowRay, params, omega);\n    \n    if(bool(result.flags & 1))\n        return vec4(vec3(1, 1, 1) * max( dot ( normal (ray.P + ray.V*t), normalizeLPR), 0.0), 1.0);\n    else if(bool(result.flags & 2))\n        return vec4 (vec3(0, 0, 0), 1.0);\n    else\n    \treturn vec4 (vec3(1, 0, 0), 1.0);\n}\n\nvec4 lightInf(Ray ray,float t,in vec3 prevColor, in float counter,in float omega)\n{\n    Ray lineRay = Ray(vec3(-10.0, 10.0 ,10.0), 0.0, vec3(1.0, 0.0, 0.0), 0.0);\n    vec3 rayPV = ray.P + ray.V*t;\n    vec3 lightPos= lightPath(lineRay,10.0,counter);\n    vec3 normalizeLPR = normalize(lightPos - rayPV); //The vector from the point to the light source\n    Ray shadowRay = Ray(rayPV, 0.05, normalizeLPR, distance(rayPV, lightPos));\n    SphereTraceDesc params = SphereTraceDesc(0.01, 128);\n    TraceResult traceRes  = enhancedSphereTrace(shadowRay, params, omega);\n    \n    vec3 normSurf = normal(ray.P + ray.V * t);  \n  \n    int i = 1;\n    \n    if(prevColor == vec3(0, 0, 0))\n    \ti =  2;\n    else if(prevColor == vec3(1, 0, 0))\n    \ti =  0;\n\n    \n    if(bool(traceRes.flags & 1) && bool(i & 1))\n        return vec4(vec3(0.5, 0.5, 0.5)*max(dot(normSurf, normalizeLPR), 0.0) / counter + prevColor, 1.0);\n    else if(bool(traceRes.flags & 1) && !bool(i & 1))\n        return vec4(vec3(0.2, 1, 0.2) * max( dot(normSurf, normalizeLPR), 0.0)/counter, 1.0);\n    else if(!bool(traceRes.flags & 1) && bool(i & 1))\n        return vec4(prevColor, 1.0);\n    else if(bool(traceRes.flags & 2) || bool(i & 2))\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    else\n    \treturn vec4(1.0, 0.0, 0.0, 1.0);\n\n}\n\n// ---- CAMERA and EVENTs ----\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.0)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.5;\n    if (isKeyHeld(KeyLeft )) eye -= u;\n    if (isKeyHeld(KeyRight)) eye += u;\n    if (isKeyHeld(KeyUp   )) eye += w;\n    if (isKeyHeld(KeyDown )) eye -= w;\n    \n    if(iMouse.z >= 0.0)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.0)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 rayFst; \n    vec2 raySnd; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, rayFst, raySnd);\n    int infiniteLight = 1;\t//0: not inf\n    \t\t\t\t\t\t//1: iterative rendering\n        \n    // epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n    \n    //Iterative light source\n    float frameCounter = texelFetch(iChannel0, ivec2(0,0),0).x;\n    vec4 texelFetchV = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    \n    if(rayFst == texelFetch(iChannel0, ivec2(0,0), 0).yzw && \n       raySnd == texelFetch(iChannel0, ivec2(1,0), 0).zw && \n       iMouse.z <= 0.0)\n        frameCounter += 1.0;\n    else\n        frameCounter = 0.0;\n    \n    // Raytrace\n    TraceResult traceRes;\n    float omega;\n\tif(frameCounter < 1.0 || infiniteLight == 0)\n    {\n        omega = 0.9;\n        traceRes = enhancedSphereTrace(ray, params,omega);\n    }\n    else\n       traceRes.T = texelFetchV.w; \n   \n   \tif(infiniteLight == 1 && frameCounter > 0.)\n        fragColor =  lightInf(ray, traceRes.T, texelFetchV.xyz,frameCounter,omega);\n    else\n    {\n        if(bool(traceRes.flags & 1)) \n            fragColor = missColor(ray);  \n        else if(bool(traceRes.flags&2))\n           fragColor = hitColor(ray, traceRes.T, omega, 2);\n        else \n            fragColor = errorColor(ray, traceRes.T);\n    }\n\n    fragColor.w = traceRes.T;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n    {\n        fragColor.yzw = rayFst;\n        fragColor.x = frameCounter;\n    }\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = raySnd;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//This file contains the code for the scene\n\nconst float pi = 3.1415926535897932384626433832795;\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n// SHAPE FORMULAS\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n    \nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n    \n    \nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdfAxis(vec3 p)\n{\n    return sqrt(p.x*p.x + p.z*p.z);\n}\n\nvec3 lightPath(in Ray ray, in float step_, in float counter)\n{\n    return ray.P + (step_ * counter * ray.V);\n}\n\n\n// signed distance functions\n\nfloat sdf(in vec3 p)\n{\n    p+=vec3(0, 0, 10);\n    \n    float sdBOX = sdBox(p - vec3(2, 0, 0),vec3(1, 1, 1));\n    float sdfAXS = sdfAxis(p);\n    \n    return min( min (sdBOX, sdSphere(p, 1.0)), p.y + 4.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}