{
    "Shader": {
        "info": {
            "date": "1552901366",
            "description": "Music : https://soundcloud.com/nablast/le-chant-des-druides \nYoutube : https://youtu.be/R5zneS95Nfo\n\nVariant without music : https://www.shadertoy.com/view/4d2BRy \n\nOriginal technique is https://www.shadertoy.com/view/ld2BWw + conformal deformations",
            "flags": 96,
            "hasliked": 0,
            "id": "wsBXR1",
            "likes": 19,
            "name": "Nablast - Chant Des Druides VIZU",
            "published": 3,
            "tags": [
                "music",
                "spiral",
                "complex",
                "infinite",
                "clip",
                "track",
                "vizu",
                "musicclip"
            ],
            "usePreview": 0,
            "username": "ttoinou",
            "viewed": 1534
        },
        "renderpass": [
            {
                "code": "\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = tanh(texture(iChannel0,fragCoord/iResolution.xy)*2.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n\nfloat fft(float x)\n{\n    return max( texture(iChannel1,vec2(x,.25)).x - .2 , .0 )*2.;\n}\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z , float k ) { return polar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    float nbPoles = 2.;\n    vec2 ret = vec2(1.,0.);\n    \n    for(float i = 0. ; i < nbPoles ; i += 1. )\n    {\n        ret = cmul(ret,uv - polar(deformation_pole.x,2.*PI*i/nbPoles));\n    }\n    \n    //return cdiv( ret/nbPoles , uv );\n    return cdiv( ret/nbPoles , cmul(uv,uv) );\n    \n   // uv = cdiv( cmul( uv + deformation_pole , uv - deformation_pole ) , cmul( uv , uv ) );\n    //uv = cdiv(vec2(1.,0.),uv);\n    //return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat mmod(float x,float y)\n{\n    return mod(mod(x,y)+y,y);\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    col.r *= .8 + fft(.5);\n    col = mix( col , vec3( dot(col,vec3(.3,.5,.2)) ) ,-max( fft(.4) + fft(.6)+ fft(.8) , 1.5 ) + .5 );\n\n    float freq = mmod(Tri.ID/sqrt(17.),1.)*.9+.1;\n    col *= pow( 1.2*max( fft( freq ) - .25 , 0. ) , 2. );\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*.3); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 8.;\n    //vec3 coeffs = vec3( 1. , tan(PI/2. - TriangleAngle) , tan(TriangleAngle) ) ;//vec3(1.);\n    vec3 coeffs = vec3( 1.4 );\n    //coeffs.xy -= normalize(uv_s);\n    coeffs.xy += polar(1. ,  atan(uv_s.y , uv_s.x) ); //  + vec2( fft(.3),fft(.9) )\n    \n    vec2 TriCenterMix =\n          (Tri.A * coeffs.x + Tri.B * coeffs.y + Tri.C * coeffs.z)\n        / (coeffs.x + coeffs.y + coeffs.z);\n    \n    \n    \n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col;//mix(vec3(1.),col,1./(1. + dot(uv_s,uv_s)/1e7 ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    #define TO01(a,b,x,k) smoothstep(.0,1.,(x-a)/(b-a)*k)\n    float music1 = TO01( .3,.6, texture(iChannel1,vec2(.6,.0)).x ,2.);\n    float music2 = TO01( .55,.7, texture(iChannel1,vec2(.17,.25)).x,2. );\n  //music2 = 1.;\n    \n    //fragColor = vec4(music1);return;\n    //fragColor = vec4(music2);return;\n    \n    TriangleAngle = PI * mix(\n        1./3.9 ,\n        1./2.4 , // cannot go lower than this value :-( \n        //iMouse.x/iResolution.x\n        sqrt( -cos(iTime/17.*PI )*.5 +.51 ) \n    );\n    //= atan(2.); // Pinwheel\n    //= PI/3.; // Equerre \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n   \n    \n    \n    angleShift = -iTime/sqrt(3.);\n    logZoom = iTime*sqrt(2.6);//  - music2*.1;\n    \n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    viewportMagnify = 1./mix(4. , 1. , -cos(iTime*PI/17.)*.5 + .5 );\n    uv *= viewportMagnify;\n    \n    vec2 uv_s = deformation(uv);\n    \n    \n    fragColor.rgb = color(uv_s ) * (1.+ 7.*vec3(music1,music1*.7,music1*.3));\n    fragColor.rgb = fragColor.rgb*(.3 + fft(.05)*2.);\n    fragColor = clamp(mix( fragColor , \n                        texture(iChannel0,fragCoord/iResolution.xy)\n                        ,.05 + music2*.35 ),0.,1.);\n}\n\n\n/*\n\n#define SHOW_DUAL_POINTS 1\n#define SHOW_SEGMENTS 1\n\n#define PI 3.14159265359\n\nfloat fft(float x)\n{\n    return max( texture(iChannel1,vec2(x,.25)).x - .2 , .0 )*2.;\n}\n        \nvec2 polar( float k , float t )\n{\n  return k*vec2(cos(t),sin(t));\n}\n\nvec2 cmuli( vec2 z )  { return vec2( -z.y , z.x ); }\nvec2 cconj( vec2 z )  { return vec2( z.x , -z.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cexp( vec2 z ) { return polar(exp(z.x) , z.y ); }\nvec2 clog( vec2 z ) { return vec2( log(length(z)) , atan(z.y , z.x) ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 cpow( vec2 z , float k ) { return polar(pow(length(z),k) , k*atan(z.y,z.x) ); }\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n    \n    float r;\n    float ID;\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n\n        \n\n// Base Triangle\nEquerre Tri;\n\nfloat TriangleAngle;\n//float k = 1./(1. - sqrt(3.)*.5);\nfloat RadiusCoeff;\nfloat AngleCoeff;\nfloat k;\n\nvec2 A,B,C,D,E,F,G,H;\nbool AB,BC,CD,DA;\n\n\nfloat logZoom = 0.;\nfloat angleShift = 0.;\n\n#define POINT_SPIRAL(n,m) (polar( pow(k,(n + logZoom)/2.) , (n)*AngleCoeff + m*PI/2. - angleShift ))\n// why nPI/3 and not nPI/6 ???????????????????????????\n\nvoid ComputeSpiralPoints(float r)\n{\n    A = POINT_SPIRAL(r,0.);\n    B = POINT_SPIRAL(r,1.);\n    C = POINT_SPIRAL(r,2.);\n    D = POINT_SPIRAL(r,3.);\n    \n    E = POINT_SPIRAL(r+1.,3.);\n    F = POINT_SPIRAL(r+1.,0.);\n    G = POINT_SPIRAL(r+1.,1.);\n    H = POINT_SPIRAL(r+1.,2.);\n}\n\n\nbool FindEquerre(float r,vec2 uv)\n{\n    ComputeSpiralPoints(r);\n    \n    AB = !pointsOnSameSideOfLine(uv,C,A,B);\n    BC = !pointsOnSameSideOfLine(uv,D,B,C);\n    CD = !pointsOnSameSideOfLine(uv,A,C,D);\n    DA = !pointsOnSameSideOfLine(uv,B,D,A);\n    \n    Tri.r = r;\n    bool ret = true;\n    \n    if(AB && !BC)\n    {\n        Tri.A = B;\n        Tri.B = E;\n        Tri.C = F;\n        Tri.ID = r*4.+0.;\n    }\n    else if(BC && !CD)\n    {\n        Tri.A = C;\n        Tri.B = F;\n        Tri.C = G;\n        Tri.ID = r*4.+1.;\n    }\n    else if(CD && !DA)\n    {\n        Tri.A = D;\n        Tri.B = G;\n        Tri.C = H;\n        Tri.ID = r*4.+2.;\n    }\n    else if(DA && !AB)\n    {\n        Tri.A = A;\n        Tri.B = H;\n        Tri.C = E;\n        Tri.ID = r*4.+3.;\n    }\n    else\n    {\n        //return AB || BC || CD || DA;\n        ret = false;\n    }\n    \n    return ret;\n}\n\nvec2 deformation_pole = vec2(.5,.0);\n\nvec2 deformation( vec2 uv )\n{\n    float nbPoles = 2.;\n    vec2 ret = vec2(1.,0.);\n    \n    for(float i = 0. ; i < nbPoles ; i += 1. )\n    {\n        ret = cmul(ret,uv - polar(deformation_pole.x,2.*PI*i/nbPoles));\n    }\n    \n    //return cdiv( ret/nbPoles , uv );\n    return cdiv( ret/nbPoles , cmul(uv,uv) );\n    \n   // uv = cdiv( cmul( uv + deformation_pole , uv - deformation_pole ) , cmul( uv , uv ) );\n    //uv = cdiv(vec2(1.,0.),uv);\n    //return uv;\n    //return clog( uv + deformation_pole ) - clog( uv - deformation_pole );\n    //return cexp( cdiv( uv + deformation_pole , clog( uv - deformation_pole ) ) );\n}\n\nvec2 deformation_inverse(vec2 def )\n{\n    return cdiv(2.*deformation_pole,def -  vec2(1.,0.)) + deformation_pole;\n}\n\nfloat mmod(float x,float y)\n{\n    return mod(mod(x,y)+y,y);\n}\n\nvec3 color(vec2 uv_s)\n{\n    float r = floor( log(dot(uv_s,uv_s))/log(k) - logZoom );\n    \n    \n    if( !FindEquerre(r+1.,uv_s) )\n    {\n        // inside circle\n        FindEquerre(r,uv_s);\n    }\n    \n    vec3 col = hash3point(vec2(Tri.ID,Tri.ID*Tri.ID));\n    \n    col.r *= .8 + fft(.5);\n    col = mix( col , vec3( dot(col,vec3(.3,.5,.2)) ) ,-max( fft(.4) + fft(.6)+ fft(.8) , 1.5 ) + .5 );\n\n    float freq = mmod(Tri.ID/sqrt(17.),1.)*.9+.1;\n    col *= pow( 1.2*max( fft( freq ) - .25 , 0. ) , 2. );\n\n    float scale = 1./viewportMagnify/(1. + dot(uv_s,uv_s)*.3); // LOG correction\n    vec3 EquerreColor = vec3(0.0,0.0,0.0);\n    \n    \n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) col = mixColorLine(uv_s,col,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    \n    scale /= 8.;\n    //vec3 coeffs = vec3( 1. , tan(PI/2. - TriangleAngle) , tan(TriangleAngle) ) ;//vec3(1.);\n    vec3 coeffs = vec3( 1.4 );\n    //coeffs.xy -= normalize(uv_s);\n    coeffs.xy += polar(1. ,  atan(uv_s.y , uv_s.x) ); //  + vec2( fft(.3),fft(.9) )\n    \n    vec2 TriCenterMix =\n          (Tri.A * coeffs.x + Tri.B * coeffs.y + Tri.C * coeffs.z)\n        / (coeffs.x + coeffs.y + coeffs.z);\n    \n    \n    \n   // TriCenterMix = Tri.B;\n    \n    #if SHOW_DUAL_POINTS==1\n        col *= 3.*(.5 + coeffDistPoint(uv_s,TriCenterMix,scale));\n        //col *= 1. - coeffDistPoint(uv_s,TriCenterMix,scale);\n    #endif\n    \n    return col;//mix(vec3(1.),col,1./(1. + dot(uv_s,uv_s)/1e7 ));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    #define TO01(a,b,x,k) smoothstep(.0,1.,(x-a)/(b-a)*k)\n    float music1 = TO01( .2,.6, texture(iChannel1,vec2(.6,.0)).x ,2.);\n    float music2 = TO01( .5,1., texture(iChannel1,vec2(.16,.25)).x,2. );\n   //music1 = .0;\n    \n    //fragColor = vec4(music1);return;\n    //fragColor = vec4(music2);return;\n    \n    TriangleAngle = PI * mix(\n        1./3.9 ,\n        1./2.4 , // cannot go lower than this value :-( \n        //iMouse.x/iResolution.x\n        sqrt( -cos(iTime/17.*PI )*.5 +.51 ) \n    );\n    //= atan(2.); // Pinwheel\n    //= PI/3.; // Equerre \n   \n    \n    \n    angleShift = -iTime/sqrt(3.);\n    logZoom = iTime*sqrt(2.6)  - music2*.2;\n    \n    RadiusCoeff = 1. / ( 1./tan(TriangleAngle) - 1. );\n    k = 1. + 2.*(RadiusCoeff * (1. + RadiusCoeff ) );\n    \n    AngleCoeff = asin( - RadiusCoeff / sqrt(k) );\n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    //uv *= mat2(cos(iTime/6.+vec4(0.,1.6,-1.6,0.)));\n    \n    \n    viewportMagnify = 1./mix(4. , 1. , -cos(iTime*PI/17.)*.5 + .5 );\n    uv *= viewportMagnify;\n    \n    vec2 uv_s = deformation(uv);\n    \n    \n    \n    \n    fragColor.rgb = color(uv_s ) * (1.+ 2.*vec3(music1,music1*.7,music1*.2));\n\n    fragColor.rgb = clamp(fragColor.rgb*(.3 + fft(.05)*2.) , 0. , 1. );\n    fragColor = clamp(mix( fragColor , \n                        texture(iChannel0,fragCoord/iResolution.xy)\n                        ,.33),0.,1.);\n    \n}\n\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 18102,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/nablast/le-chant-des-druides"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}