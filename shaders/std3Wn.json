{
    "Shader": {
        "info": {
            "date": "1636018100",
            "description": "An endless weaving highway, with no exits. Mouse controls zoom.",
            "flags": 0,
            "hasliked": 0,
            "id": "std3Wn",
            "likes": 39,
            "name": "Weaving Bridges",
            "published": 3,
            "tags": [
                "2d",
                "mouse",
                "road",
                "car",
                "weave"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 638
        },
        "renderpass": [
            {
                "code": "// Cole Peterson (Plento)\n\n// An endless weaving highway, with no exits. Mouse controls zoom.\n\n#define R iResolution.xy\n#define m ((iMouse.xy - .5*R.xy) / R.y)\n#define ss(a, b, x) smoothstep(a, b, x)\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define w_scale 5.\n#define car_size vec2(0.07, 0.1)\n\n// Dave Hoshkin\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hsh(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// Standard perlin\nfloat perlin(vec2 p){\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hsh(i);\n    float b = hsh(i+vec2(1., .0));\n    float c = hsh(i+vec2(0. ,1 ));\n    float d = hsh(i+vec2(1., 1. ));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// box sdf\nfloat box( in vec2 p, in vec2 b, float r){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// is a cell be flipped or not\nbool flipped(vec2 id){\n    float rnd = hash12(id*200.);\n    if(rnd > .5) return true;\n    \n    return false;\n}\n\n\nvec3 car(vec3 col, vec2 uv, vec2 uid){\n    uv.y *= .6; // stretch in direction of travel so they have more room to move in their cell\n    \n    float spd = iTime*.1;\n    \n    // Repeated uvs for cars (We only draw one)\n    vec2 cm = vec2(0., spd );\n    vec2 cv = fract((uv-cm)*w_scale*2.)-0.5;\n    vec2 id = floor((uv-cm)*w_scale*2.);\n    float idc = floor((uv.x-cm.x)*w_scale);\n    \n    // Switch direction \"randomly\"\n    if(cos(idc*2.) > 0.){\n        cm = vec2(0., -spd );\n        cv = fract((uv-cm)*w_scale*2.)-0.5;\n        id = floor((uv-cm)*w_scale*2.);\n    }\n    \n    if(int(id.y) % 7 == 0) return col; // Leave some cells empty\n    \n    // Make cars move down road in somewhat non uniform way\n    float t = id.y*114. + id.x*116.;\n    vec2 p = vec2(.0, .3*cos(iTime*1. + t));\n    \n    // Adjust car position based on side of road\n    if(int(id.x) % 2 == 0) p.x -= .2; \n    else p.x += .2;\n    \n    cv += p;\n    float cars = ss(.01, .0, box(cv, car_size, .03)); // Car mask\n    \n    // Car color\n    float ct = (id.x*3. + id.y*5.);\n    vec3 carCol = .5+.26*cos(vec3(4., 2., 1.)*ct + vec3(3., 4., 7.));\n    carCol *= max(ss(-.1, .21, abs(cv.y + .07)), .45);\n    carCol += .16*ss(0.055, 0.01, abs(cv.y));\n    \n    // Randomly add some variation\n    if(cos(ct) > 0.){\n        carCol *= max(abs(cos(ct)), .6);\n        carCol = mix(carCol, .6*vec3(.75, .85, .99), .7*ss(.3, .2, abs(cv.y*2. - .38)));\n    }\n   \n    // Shadow under car\n    float shdw = max(ss(-.08, .08, box(cv-vec2(0., .01), car_size+vec2(.015, .01), .03)), .3);\n    \n    return mix(col * shdw, carCol, cars) + vec3(0., 0., 0.);\n}\n\n\nvec3 road(vec2 uv, float y){\n    float rd = ss(.02, .00, abs(uv.x)); // road mask\n    rd *= ss(.25, .35, abs(fract(y*14.)-.5)); // road line\n    float bdg = ss(.35, .37, abs(uv.x)); // bridge mask\n    float shdw = ss(.49, .18, abs(uv.x)); // bridge shadow\n    \n    float nse = perlin(uv*45.); // perlin noise\n    float rc = clamp(nse*.4, .22, .24); // road color\n    float bc = clamp(nse, .46, .5); // bridge color\n    return mix(shdw * mix(vec3(rc), vec3(1), rd), vec3(bc), bdg);\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 cv = uv;\n    uv *= 0.99 + (1.3+.2*sin(iTime*.7))*0.77;\n    \n    if(iMouse.z > 0.)\n        uv *= max(0.3, (m.y+.4)*2.5);\n    \n    uv*=rot(-0.3);\n    uv += iTime*.1;\n   \n    // Road uvs\n    vec2 ruv = fract(uv*w_scale)-.5;\n    vec2 id = floor(uv*w_scale);\n    \n    vec3 col = vec3(1);\n    \n    // rotate uv 90 degree based on cell\n    float rnd = hash12(id*200.);\n    if(flipped(id)){\n        ruv = vec2(ruv.y, -ruv.x);\n        uv = vec2(uv.y, -uv.x);\n    }\n    \n    // cell containing current pixel flipped status\n    bool me = flipped(id);\n    \n    // main color\n    col = road(ruv, uv.y);\n    col = car(col, uv, id);\n    \n    // neighbooring cells flipped?\n    bool lft = flipped(id + vec2(-1., 0.));\n    bool rgt = flipped(id + vec2(1., 0.));\n    bool up = flipped(id + vec2(0., 1.));\n    bool dwn = flipped(id + vec2(0., -1.));\n    \n    // Add a shadow based on surrounding cells\n    if(me && !lft) col *= ss(.78, .12, (ruv.y));\n    if(me && !rgt) col *= ss(.78, .12, (-ruv.y));\n    if(!me && up) col *= ss(.78, .12, (ruv.y));\n    if(!me && dwn) col *= ss(.78, .12, (-ruv.y));\n    \n    col = pow(col*1.2, vec3(1.1));\n    \n    // intro thingy\n    float r = min(iTime, 3.);\n    if(iTime < 3.) col *= ss(r, r-.01, length(cv));\n    f = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}