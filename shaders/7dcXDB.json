{
    "Shader": {
        "info": {
            "date": "1633863097",
            "description": "This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.",
            "flags": 0,
            "hasliked": 0,
            "id": "7dcXDB",
            "likes": 24,
            "name": "Hyperbolic tilings: intro",
            "published": 3,
            "tags": [
                "2d",
                "tiling",
                "hyperbolic",
                "poincare"
            ],
            "usePreview": 0,
            "username": "neozhaoliang",
            "viewed": 1023
        },
        "renderpass": [
            {
                "code": "/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the total number of reflections\nfloat count;\n\n// compute cos(PI / x) using Vinberg's convention for inf.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float lw = 0.002;\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, lw));    \n    ln = min(ln, lBox(p, vec2(0), m0, lw));\n    ln = min(ln, length(p-C.xy) - C.z - lw);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, lw));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}