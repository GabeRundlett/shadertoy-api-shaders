{
    "Shader": {
        "info": {
            "date": "1639411749",
            "description": "My second 4D raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "fttXzj",
            "likes": 5,
            "name": "Hello 4D Repetition Cube",
            "published": 3,
            "tags": [
                "4d"
            ],
            "usePreview": 0,
            "username": "IWBTShyGuy",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright © 2021 IWBTShyGuy \n\n#define AA 2\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec4 p, vec4 b ) {\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\nfloat cellDist(in vec4 p, in vec4 q, in float t) {\n    p = fract(q + vec4(0, 0, 0, 1.0e-4)) + p - q;\n    return sdBox(p - vec4(0.5, 0.5, 0.5, 0.5), vec4(0.15));\n}\n\nfloat sDist(in vec4 p, in vec4 dir, in float t) {\n    float dist = cellDist(p, p, t);\n    if (floor(p) != floor(p + dist * dir)) {\n        dist = min(dist, cellDist(p, p + dist * dir, t));\n    }\n    return dist;\n}\n\nvec4 calcNormal(in vec4 p, in vec4 dir, in float t) {\n    const vec2 e = vec2(1.0e-4, 0);\n    return normalize(vec4(\n        cellDist(p + e.xyyy, p, t) - cellDist(p - e.xyyy, p, t),\n        cellDist(p + e.yxyy, p, t) - cellDist(p - e.yxyy, p, t),\n        cellDist(p + e.yyxy, p, t) - cellDist(p - e.yyxy, p, t),\n        cellDist(p + e.yyyx, p, t) - cellDist(p - e.yyyx, p, t)\n    ));\n}\n\nconst float FAR = 12.0;\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 dir = vec4(\n        cos(iTime * 0.1),\n        sin(iTime * 0.1),\n        cos(iTime * 0.06),\n        sin(iTime * 0.06)\n    );\n    Camera camera = newCamera(\n        vec4(0, 0, 0, fract(iTime * 0.3)),\n        normalize(dir),\n        vec4(0, 1, 0, 0),\n        vec4(\n            -sin(iTime * 0.1),\n            cos(iTime * 0.1),\n            -sin(iTime * 0.06),\n            cos(iTime * 0.06)\n        ),\n        PI / 4.0,\n        iResolution.x / iResolution.y\n    );\n    Ray ray = cameraRay(camera, fragCoord / iResolution.xy);\n\n    float dist = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec4 p = ray.origin + dist * ray.direction;\n        float dist0 = sDist(p, ray.direction, iTime);\n        if (dist0 < 1.0e-6 || dist > FAR) break;\n        dist += dist0;\n    }\n\n    vec3 col = vec3(0);\n    if (dist < FAR) {\n        vec4 p = ray.origin + dist * ray.direction;\n        vec4 normal = calcNormal(p, vec4(0), iTime);\n        float c = -dot(normal, ray.direction);\n        c = mix(c, 0.0, smoothstep(0.0, 1.0, dist / FAR));\n        col += c * ((fract(p.wxy) - 0.5) / 0.3 + 0.5);\n    }\n\n    fragColor = vec4(pow(col, vec3(0.4545)), 1);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    \n// smart anti-aliasing\n// reference: https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\n// If defined, visualize anti-aliased pixels.\n//#define VISUALIZE_AA\n#ifdef AA\n    if (fwidth(length(O.xyz)) > 0.1) {\n\n        O.xyz = pow(O.xyz, vec3(2.2));\n        vec4 o;\n#if (AA == 2)\n        for (int k = 0; k < 4; k++) {\n              mainImage0(o,U + (vec2(k % 2, k / 2) - 0.5) / 1.5);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 5.0;\n#elif (AA == 3)\n        for (int k = 0; k < 9; k += k == 3 ? 2 : 1 ) {\n              mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.0);\n              O += pow(o, vec4(2.2));\n        }\n        O /= 9.0;\n#endif\n#ifdef VISUALIZE_AA\n        O = vec4(1);\n    } else {\n        O = vec4(0,0,0,1);\n#endif\n        O.xyz = pow(O.xyz, vec3(0.4545));\n    }\n#endif\n    O.w = 1.0;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// 4D toolkit\n//\n// The MIT License\n// Copyright © 2021 IWBTShyGuy \n//\n\nconst float PI = 3.141592653;\n\nvec4 three_cross(in vec4 a, in vec4 b, in vec4 c) {\n    return vec4(\n        -determinant(mat3(a.yzw, b.yzw, c.yzw)),\n        determinant(mat3(a.zwx, b.zwx, c.zwx)),\n        -determinant(mat3(a.wxy, b.wxy, c.wxy)),\n        determinant(mat3(a.xyz, b.xyz, c.xyz))\n    );\n}\n\nstruct Camera {\n    vec4 position;\n    vec4 direction;\n    //@ upper direction of camera\n    //@ not need to perp to `direction`\n    vec4 up_direction;\n    //@ normal of the hyperplane\n    //@ not have to be normalized\n    //@ assumed being perp to `direction`.\n    vec4 tactile;\n    float fov;\n    //@ x / y\n    float aspect;\n};\n\nCamera newCamera(\n    in vec4 position,\n    in vec4 direction,\n    in vec4 up_direction,\n    in vec4 tactile,\n    in float fov,\n    in float aspect\n) {\n    Camera camera;\n    camera.position = position;\n    camera.direction = direction;\n    camera.up_direction = up_direction;\n    camera.tactile = tactile;\n    camera.fov = fov;\n    camera.aspect = aspect;\n    return camera;\n}\n\nstruct Ray {\n    vec4 origin;\n    vec4 direction;\n};\n\n// uv: fragCoord / iResolution.xy\nRay cameraRay(in Camera camera, in vec2 uv) {\n    uv = uv * 2.0 - 1.0;\n    float h = tan(camera.fov * 0.5);\n    float w = h * camera.aspect;    \n    vec4 right = -normalize(three_cross(camera.direction, camera.up_direction, camera.tactile));\n    vec4 up = -normalize(three_cross(right, camera.direction, camera.tactile));\n    vec4 direction = normalize(right * w * uv.x + up * h * uv.y + camera.direction);\n    Ray ray;\n    ray.origin = camera.position;\n    ray.direction = direction;\n    return ray;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}