{
    "Shader": {
        "info": {
            "date": "1475176036",
            "description": "Improved version of [url=https://www.shadertoy.com/view/ldl3W8]Inigo Quilez's implementation[/url]: 32 iterations vs 34, plus approx. variants with 18 and 25 iterations.\nAlso in [url=http://polycu.be/edit/?h=Gbhigy]PolyCube[/url] with EvalDraw controls.",
            "flags": 0,
            "hasliked": 0,
            "id": "llG3zy",
            "likes": 49,
            "name": "Faster Voronoi Edge Distance",
            "published": 3,
            "tags": [
                "2d",
                "voronoi",
                "worley"
            ],
            "usePreview": 1,
            "username": "tomkh",
            "viewed": 6850
        },
        "renderpass": [
            {
                "code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2016\n\n// Based on https://www.shadertoy.com/view/ldl3W8 by Inigo Quilez\n// And his article: https://iquilezles.org/articles/voronoilines\n\n// This is based on Inigo Quilez's distance to egdes,\n// except I consider here faster variants:\n// * 3x3 scan at the cost of small inaccuracies\n// * 4x4 scan in the second pass that has no accuracy-loss to IQ's version\n// * 4x4 in both passes that is more accurate than original IQ's version\n//   (and still has less iterations 32=4*4*2 vs 34=3*3+5*5)\n\n// Original IQ's algorithm is flawed (mathematically incorrect)\n// i.e. for all possible hash functions, as in this counter-example:\n// https://www.shadertoy.com/view/4lKGRG\n\n// Basically in the original IQ's implementation,\n// he was storing closest cell \"mg\" in the first pass\n// and using it for the second pass.\n// If we want 3x3 scan in the second pass it is enough to continue search\n// from the same (current fragment) cell and limit search space\n// to only neighbouring cells (thus \"mg\" can be ignored).\n// In fact, searching around \"mg\" makes it worse (see my illustration below).\n// For 4x4 variant we have to set the center of search \n// based on which half of the current fragment cell we are in.\n// Note: \n//   The second pass scan area has nothing to do with the position\n//   of the closest point.\n//   Here is an illustration of my improved algorithm:\n//   http://ricedit.com/second_order_voronoi_03.png\n\n// Pick approximation level:\n//   0 = 3x3 scan for both passes (occasional issues, but the fastest)\n//   1 = 3x3 + 4x4 scan (good in most cases, if every cell has diameter < 1)\n//   2 = 4x4 scan for both passes (improved accuracy)\n//   3 = 3x3 + 5x5 scan (original IQ's)\n#define SECOND_PASS 2\n\n#define ANIMATE\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .5\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\nvec2 hash2(vec2 p)\n{\n    #if 0\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #ifdef ANIMATE\n       o = 0.5 + ANIMATE_D*sin( iTime + o*6.2831853 );\n    #endif\n   return o;\n}\n\n#if SECOND_PASS == 0\n//---------------------------------------------------------------\n// Fastest version with 3x3 scan in the second pass\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits only neighbouring cells\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#elif SECOND_PASS == 1\n//---------------------------------------------------------------\n// Approximation with 4x4 scan in the second pass\n// Good enough in most cases\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n    \n    // Set center of search based on which half of the cell we are in,\n    // since 4x4 is not centered around \"n\".\n    vec2 mg = step(.5,f) - 1.;\n\n    //----------------------------------\n    // second pass: distance to borders,\n    // visits two neighbours to the right/down\n    //----------------------------------\n    md = 8.0;\n    for( int j=-1; j<=2; j++ )\n    for( int i=-1; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#elif SECOND_PASS == 2\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mr;\n\n    float md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n#else\n//---------------------------------------------------------------\n// Slowest with 5x5 scan in the second pass\n// Original Implementation by Inigo Quilez \n// as in https://www.shadertoy.com/view/ldl3W8\n//---------------------------------------------------------------\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\tvec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n//---------------------------------------------------------------\n#endif\n\nvec3 plot( vec2 p, float ss )\n{\n    vec3 c = voronoi( p );\n    \n    // Colors:\n    vec3 interior = vec3(.2,.8,1.);\n    vec3 border = vec3(.2,.8,.4);\n    vec3 point = vec3(1.,.7,0.);\n    \n    float d = length(c.yz);\n    vec3 col =\n        mix(\n            mix(\n                c.x*2.*(sin(c.x*120.)*.1+.9)*interior,\n                border,\n                smoothstep(.08,.06,c.x)\n            )*min(1.,d*9.),\n            point,\n            smoothstep(.07,.05,d)\n        );\n    if (iMouse.z > 0.) // show grid\n    {\n\t\tvec2 g = abs(fract(p)-.5);\n        col = mix(col,vec3(.8),smoothstep(.5-ss*1.5,.5,max(g.x,g.y)));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*4. + 4.; // scale differently for fullscreen\n\tfloat ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}