{
    "Shader": {
        "info": {
            "date": "1602344393",
            "description": "gpu version of https://diglib.eg.org/bitstream/handle/10.1111/cgf13951/v39i2pp545-554.pdf?sequence=1&isAllowed=y\ndistance falloff is cutted in this version.\nThe bound of    gradient d(delta(e)) dot u   is estimated by 3 points.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdKczW",
            "likes": 45,
            "name": "Segment Tracing (SDF Only)",
            "published": 3,
            "tags": [
                "raytracing",
                "metaball",
                "tracing",
                "segment"
            ],
            "usePreview": 0,
            "username": "yuchengzhong",
            "viewed": 3126
        },
        "renderpass": [
            {
                "code": "#define SSAA\nconst int SSAA_Cnt = 1;\n#define showCost\n\n#define eps 0.0001\n#define size vec3(2.0,2.0,2.0)\n#define roundr 0.25\n#define global_k 1.25\n#define Lipschitz_GridSize 0.3\n#define Lipschitz_GridSize2 1.0\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat opTwist(vec3 p)\n{\n    float t = iTime;\n    float k = 0.55*sin(2.0*t); // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdRoundBox(q,size,roundr);\n}\nfloat scene(vec3 pos)\n{\n    float dist = 0.0;\n    dist = opTwist(pos);\n    return dist;\n}\n\nvec3 calcGradient( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn ((vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)))/(2.0*eps));\n}\nvec3 calcGradientCheap( in vec3 pos ,in float original)\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn (vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n           -vec3(original))/(eps);\n}\nvec2 sceneK(vec3 start,vec3 end,vec3 dir)\n{\n    float dist = 0.0;\n    dist = scene(start);\n    \n    vec3 gs = calcGradient(start);\n    vec3 ge = calcGradient(end);\n    //vec3 gs = calcGradientCheap(start,dist);\n    //vec3 ge = calcGradientCheap(end,dist);\n    float fds = abs(dot(gs,dir));\n    float fde = abs(dot(ge,dir));\n    float lam = max(fds,fde);\n    \n    \n    return vec2(lam,dist);\n}\n//more accurate\nvec2 sceneK2(vec3 start,vec3 end,vec3 dir)\n{\n    vec3 center = start+end;\n    center *=0.5;\n    float dist = 0.0;\n    dist = scene(start);\n    vec3 gs = calcGradient(start);\n    vec3 ge = calcGradient(end);\n    vec3 gc = calcGradient(center);\n    float fds = abs(dot(gs,dir));\n    float fde = abs(dot(ge,dir));\n    float fdc = abs(dot(gc,dir));\n    float lam = max(fds,fde);\n    lam = max(fdc,lam);\n    \n    \n    return vec2(lam,dist);\n}\nvec2 calcIntersection( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;//min max intersect\n\tfloat t = mint;\n\n\tfor(int i=0;i<512;i++)\n\t{\n\t\tfloat d = scene(ro+rd*t);\n\t\tif (d < 0.0)\n        {\n\t\t\treturn vec2(t,float(i));\n        }\n        float ts = max(abs(d)/global_k, eps);\n\t\tt += ts;\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec2 calcIntersection2( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;\n\tfloat t = mint;\n\tfloat c = 2.0;\n\tfloat ts = (maxt - mint);\n    ts = min(ts,Lipschitz_GridSize);\n\tfor(int i=0;i<512;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK(pt,pts,rd);\n\t\tfloat dist = data.y;\n\t\tif (dist < 0.0)\n        {\n\t\t\treturn vec2(t,float(i)*2.0);\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(dist) / max(k,0.01);\n\t\ttk = max(abs(dist)/global_k,min(tk, ts));\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        ts = min(ts,Lipschitz_GridSize);\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\n\nvec2 calcIntersection3( in vec3 ro, in vec3 rd )\n{\n    float mint = 5.0;\n    float maxt = 15.0;\n\tfloat t = mint;\n\tfloat c = 2.0;\n\tfloat ts = (maxt - mint);\n    ts = min(ts,Lipschitz_GridSize2);\n\tfor(int i=0;i<512;i++)\n\t{\n        vec3 pt = ro+rd*t;\n\t\tvec3 pts = ro+rd*(t + ts);\n        vec2 data = sceneK2(pt,pts,rd);\n\t\tfloat dist = data.y;\n\t\tif (dist < 0.0)\n        {\n\t\t\treturn vec2(t,float(i)*3.0);\n        }\n\t\tfloat k = data.x;\n\t\tfloat tk = abs(dist) / max(k,0.01);\n\t\ttk = max(abs(dist)/global_k,min(tk, ts));\n\t\tts = tk;\n\t\tif(tk >= 0.0)\n\t\t{\n\t\t\tt += max(tk, eps);\n\t\t}\n\t\tts = tk * c;\n        ts = min(ts,Lipschitz_GridSize);\n        if(t > maxt)\n        {\n            break;\n        }\n\t}\n\treturn vec2(-1.0,0.0);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    const vec3 v1 = vec3(1.0,0.0,0.0);\n    const vec3 v2 = vec3(0.0,1.0,0.0);\n    const vec3 v3 = vec3(0.0,0.0,1.0);\n\treturn normalize((vec3(scene(pos + v1*eps),scene(pos + v2*eps),scene(pos + v3*eps))\n                     -vec3(scene(pos - v1*eps),scene(pos - v2*eps),scene(pos - v3*eps)))/(2.0*eps));\n}\nvec3 illuminate( in vec3 pos , in vec3 camdir )\n{\n    return calcNormal(pos)*0.5+0.5;\n}\n\nvec3 background( vec3 rd )\n{\n\treturn texture(iChannel0, rd).rgb * texture(iChannel0, rd).rgb;\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 colAcc = vec3(0.0,0.0,0.0);\n    \n    float t = 1.5*iTime;\n    vec3 campos = vec3(10.0*sin(t*0.3),3.5*sin(t*0.5)+6.0,-10.0*cos(t*0.3));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n    #ifdef SSAA\n    for(int i=-SSAA_Cnt;i<SSAA_Cnt;i++)\n    {\n    for(int j=-SSAA_Cnt;j<SSAA_Cnt;j++)\n    {    \n    vec2 xy = (fragCoord.xy+0.5*(vec2(i,j)+vec2(0.5,0.5))/float(SSAA_Cnt) - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    #else\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y); \n    #endif\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n        float dist = 0.0;\n    float times = 256.0;\n    if(fragCoord.x/iResolution.x>0.501)\n    {        \n        vec2 data = calcIntersection(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else if(fragCoord.x/iResolution.x<0.499)\n    {\n        vec2 data = calcIntersection3(campos, camdir);\n        dist = data.x;\n        times = data.y;\n    }\n    else\n    {\n        dist = -2.0;   \n    }\n    if (dist==-1.0)\n    {\n        col = background(camdir);\n    }\n    else if(dist == -2.0)\n    {\n        col = vec3(1.0,0.0,0.0);   \n    }\n    else\n    {\n    \tvec3 inters = campos + dist * camdir;\n    \tcol = illuminate(inters, camdir);\n    }\n    \n    float bannerHeight = 0.2;\n    float bannerOffset = 0.5*sin(iTime);\n    if(fragCoord.y/iResolution.y<0.5 +bannerOffset+ bannerHeight && fragCoord.y/iResolution.y>0.5+bannerOffset - bannerHeight)\n    {\n        #ifdef showCost\n        col = mix(vec3(0.0,1.0,0.0),vec3(1.0,0.0,0.0),times/64.0);   \n        #endif\n    }\n        col = pow(col, vec3(0.8));\n        colAcc+=col;\n        \n    #ifdef SSAA\n    }\n    }\n\tfragColor = vec4(colAcc/float(4*SSAA_Cnt*SSAA_Cnt),1.0);\n    #else\n    fragColor = vec4(colAcc,1.0);\n    #endif\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}