{
    "Shader": {
        "info": {
            "date": "1665626590",
            "description": "More specific sources in the code.\n\nReel on IG: https://www.instagram.com/reel/Cjqqkhtjtl-/?utm_source=ig_web_copy_link\n\nSorry, my code is reused and needs refactoring.",
            "flags": 0,
            "hasliked": 0,
            "id": "cdlGRn",
            "likes": 9,
            "name": "cakeeeee",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 164
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 2; // sqrt(samples per pixel)\n\n//*******************************************************//\n\n// Light structs\n\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness;\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n    if (isPointLight) {\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n    return light;\n}\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    bool hasFresnel;\n    int id;\n    vec3 groundBounceClr;\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.hasFresnel = false;\n    mat.id = -1;\n    mat.groundBounceClr = vec3(0.0);\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n// SMOOTH MIN from Inigo Quilez\nfloat smoothmin(in float a, in float b, in float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smoothmax\nfloat smoothmax(float a, float b, float k) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//*******************************************************//\n\nfloat sdCake(in vec3 pt, out Material mat) {\n    mat.id = 0;\n    float res = length(pt.xz) - 2.2 - 0.4*smoothstep(2.5, 0.0, pt.y);\n    res = smoothmax(res, pt.y - 2.5, 0.6);\n    res = smoothmax(res, -pt.y-0.2, 0.2);\n    return res;\n}\n\nfloat sdCherries(in vec3 pt, in float rad, out Material mat) {\n    mat.id = 1;\n    float angBetween = 6.283185/9.0; // two PI divided by num of cherries\n    float sec = round(atan(pt.z, pt.x)/angBetween);\n    float rot = sec * angBetween;\n    vec3 p = pt - vec3(0, 2.85, 0);\n    p *= vec3(1, 1.1, 1);\n    p.xz = mat2(cos(rot), -sin(rot), \n                 sin(rot), cos(rot))*p.xz;\n    float res = length(p - vec3(1.5, 0.0, 0.0)) - rad;\n    return res;\n}\n\nfloat sdPlate(in vec3 pt, out Material mat) {\n    mat.id = 2;\n    mat.ref = vec3(0.1, 0.1, 0.2);\n    // outer\n    float res = length(pt.xz) - 3.1;\n    res = smoothmax(res, abs(pt.y) - 0.05, 0.03);\n    // inner\n    float inner = length(pt.xz) - 2.9;\n    inner = smoothmax(inner, abs(pt.y - 0.03) - 0.03, 0.03); \n    res = smoothmax(res, -inner, 0.05);\n    return res;\n}\n\nfloat sdFrosting(in vec3 pt, out Material mat) {\n    mat.id = 3;\n    float ang = atan(pt.z, pt.x);\n    float a = 2.4;\n    float res = length(pt.xz) - a - 0.05*sin(15.0 * ang);\n    vec3 p = pt - vec3(0, 2.6 - 0.7*smoothstep(a-0.3, a+0.1, length(pt.xz)), 0);\n    res = smoothmax(res, abs(p.y) - 0.2, 0.2);\n    // cherries cut out\n    Material m;\n    res = smoothmax(res, -sdCherries(pt, 0.24, m), 0.08);\n    return res*0.35;\n}\n\n\n\n//*******************************************************//\n\n// SDF SCENE\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res = MAX_DIST;\n    \n    // default\n    mat = defaultMaterial();\n    \n    // plate\n    Material plateMat = defaultMaterial();\n    float plate = sdPlate(pt, plateMat);\n    \n    // cake\n    Material cakeMat = defaultMaterial();\n    float cake = sdCake(pt, cakeMat);\n    \n    // frosting\n    Material frostingMat = defaultMaterial();\n    float frosting = sdFrosting(pt, frostingMat);\n    \n    // cherries\n    Material cherriesMat = defaultMaterial();\n    float cherries = sdCherries(pt, 0.23, cherriesMat);\n    \n    if (cake < res) {\n        res = cake;\n        mat = cakeMat;\n    }\n    \n    if (frosting < res) {\n        res = frosting;\n        mat = frostingMat;\n    }\n    \n    if (cherries < res) {\n        res = cherries;\n        mat = cherriesMat;\n    }\n    \n    mat.hasFresnel = true;\n    \n    if (plate < res) {\n        res = plate;\n        mat = plateMat;\n        mat.hasFresnel = false;\n    }\n\n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1;\n            mat.ref = vec3(0.0);\n            mat.hasFresnel = false;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 200 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.00005 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow (has tint)\n    vec3 shadow = light.isPointLight ? vec3(1.0) : vec3(1.0, 0.8, 0.9) * softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n\n    // COLORS\n    vec3 skyClr = vec3(0.55, 0.25, 0.55);\n    \n    // KEY LIGHT\n    Light sun = createLight(pt, false, 1.0, 10.9, normalize(vec3(10, 12.5, 3)), vec3(9, 8, 9)+5.0*skyClr);\n    \n    // background color\n    vec3 clr = skyClr;\n\n    if (mat.id == -1) {\n        // return background if too far (id is -1.0)\n        return clr;\n    } else if (mat.id == 0) {\n        // cake\n        mat.clr = vec3(0.06, 0.06, 0.02);\n    } else if (mat.id == 1) {\n        // cherry\n        mat.clr = vec3(0.15, 0.02, 0.01)*0.9;\n        mat.shininess = 100.0;\n        mat.dif = 0.3;\n        mat.amb = 0.0;\n        mat.spec = 10.0;\n    } else if (mat.id == 2) {\n        // plate\n        mat.clr = vec3(0.04, 0.05, 0.1);\n        mat.dif = 0.5;\n        mat.shininess = 20.0;\n        mat.spec = 20.0;\n    } else if (mat.id == 3) {\n        // frosting\n        mat.clr = vec3(0.05, 0.02, 0.01) * 0.07;\n    }\n    \n    clr = mat.clr;\n    \n    // LIGHTS\n   \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor);\n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr; // sky diffuse\n\n    clr *= light * occ;\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    Material mat;\n\n    float d = castRay(ro, rd, mat);\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    vec3 clr = calcClr(ro, rd, d, nor, mat);\n    \n    bool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n    if (mat.hasFresnel || willReflect) {\n    \n        int bounces = 1;\n        vec3 ref = vec3(0.0);\n        float fresnel = 0.4 * uclamp(pow(1.0 - dot(nor, -rd), 5.0));\n        \n        // if the material will reflect\n        if (willReflect) {\n            // if reflective and doesn't have fresnel\n            if (!mat.hasFresnel) ref = mat.ref;\n            // if reflective with fresnel\n            else ref = fresnel * mat.ref;\n        } else {\n            ref = vec3(fresnel);\n        }\n        \n        // bouncing around for fresnel and reflection\n        vec3 fil = vec3(1.0);\n        if (fresnel > 0.0) {\n            for (int i = 0; i < bounces; i++) {\n                fil *= ref;\n                // to intersection point and reflect\n                ro += rd*d + nor*EPSILON*3.0;\n                rd = reflect(rd, nor);\n                // find new point\n                d = castRay(ro, rd, mat);\n                nor = calcNormal(ro + rd*d);\n                // add color\n                clr += fil * calcClr(ro, rd, d, nor, mat);\n                if (mat.id == -1) break;\n            }\n        }\n        \n    }\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 res = iResolution.xy;\n    \n    // target\n    vec3 target = vec3(0, 0.5, 0);\n    // ray origin\n    float r = 5.5;\n    float t = iTime * 0.2;\n    vec3 ro = vec3(r * cos(t), 3.7, r * sin(t));\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - res) / min(res.x, res.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            clr += render(ro, rd);\n        }\n    }    \n    \n    clr /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}