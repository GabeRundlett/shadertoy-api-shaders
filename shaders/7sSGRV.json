{
    "Shader": {
        "info": {
            "date": "1617642719",
            "description": "Value noise is ugly, but i couldnt find any other decent noise that would be fast enough.",
            "flags": 0,
            "hasliked": 0,
            "id": "7sSGRV",
            "likes": 47,
            "name": "A Lonely Cloud",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "CustomPhase",
            "viewed": 9768
        },
        "renderpass": [
            {
                "code": "#define CAMERA_DISTANCE 2.4\n#define CAMERA_SPIN_SPEED 0.13\n#define FOV_MULTIPLIER 0.8\n#define SUN_DIR normalize(vec3(1,0.8,0))\n#define SUN_COLOR vec3(2,1.6,0.9)*2.3\n#define SCATTERING_MULTIPLIER 0.0\n#define CLOUD_SIZE vec3(2.6,1.1,2.6)\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat rayPlaneIntersect(vec3 ro, vec3 rd, vec3 center, vec3 normal) {\n    float denom = dot(normal, rd);\n    if (abs(denom) > 0.0001f) // your favorite epsilon\n    {\n        float t = dot(center - ro, normal) / denom;\n        return t; // you might want to allow an epsilon here too\n    }\n    return -1.;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.-1.;\n}\n\nvec3 skyColor(vec3 viewDir, vec3 camPos) {\n    float horizonNoise = smoothstep(-0.2, 0.9, noise(viewDir * vec3(8,36,8))+noise(viewDir * vec3(28,56,28))*0.5);\n    float skyExtinction1 = exp(-max(0., abs(viewDir.y)*28. - horizonNoise*1.8));\n    float skyExtinction2 = exp(-max(0., abs(viewDir.y)*12. - horizonNoise*0.5));\n    vec3 sky =  vec3(7.5, 7.2, 7.2) * \n                mix(vec3(0.12, 0.85, 1.0) * 1.0, vec3(1), skyExtinction1) * \n                mix(vec3(0.5, 0.25, 0.52) * 0.5, vec3(1), skyExtinction2);\n    sky += vec3(3, 2, 0.5) * pow(clamp(dot(viewDir, SUN_DIR), 0., 1.), 4.);\n    sky += vec3(50, 40, 2) * smoothstep(0.991, 0.997, dot(viewDir, SUN_DIR)) * 0.3;\n    float groundD = rayPlaneIntersect(camPos, viewDir, vec3(0,-50,0), vec3(0,1,0));\n    vec3 groundPoint = camPos + viewDir * groundD;\n    float groundNoise = smoothstep(-0.5, 0.5, noise(groundPoint*0.07)*0.99 + noise(groundPoint*0.69)*0.3);\n    vec3 groundColPre = mix(vec3(0.3, 0.4, 0.6), vec3(0.45, 0.62, 0.68), groundNoise);\n    vec3 groundCol = mix(groundColPre, vec3(0.79, 1.28, 1.85), 1.-exp(-max(groundD,0.)*0.003));\n    vec3 ground = groundCol * ((1.0-pow(abs(viewDir.y),0.5))*0.8+0.2);\n    return mix(ground, sky, smoothstep(-0.04, 0.1, viewDir.y))*0.65;\n}\n\nvec3 ambientContribution(vec3 normal) {\n    vec3 ground = vec3(0.36, 0.6, 0.65)*0.4;\n    //ground *= smoothstep(-1., 0., normal.y)*0.5+0.5;\n    return mix(ground, vec3(0.4,0.8,1.1), pow(smoothstep(-1., 1., normal.y),1.0));\n}\n\nfloat density(vec3 pos) {\n    vec3 normDist = pos / (CLOUD_SIZE*0.5);\n    float topClip = smoothstep(-0.0, 1., normDist.y);\n    float sideClipX = smoothstep(0.60-topClip*0.6, 1., abs(normDist.x));\n    float sideClipZ = smoothstep(0.60-topClip*0.6, 1., abs(normDist.z));\n    float bottomClip = smoothstep(-0.5, -1.0, normDist.y);\n    float freq = 3.9;\n    float sum = 0.;\n    float amp = 0.5;\n    float d1 = distance(normDist * vec3(1.0,0.9,1.0), vec3(0, -0.65, 0) * vec3(1.0,0.8,1.0));\n    float d2 = distance(normDist * vec3(1.6,1.0,1.6), vec3(-0.3, 0.2, 0.3));\n    float dens = 1.-opSmoothUnion(\n        pow(d1*1.1, 1.2),\n        pow(d2*1.1, 1.4),\n        0.5\n    );\n    pos += vec3(1,0,2);\n    for (int i = 1; i<4; i++) {\n        float timeOffs = iTime * (1.+float(i)*1.0)*0.4;\n        if (i==1) timeOffs = 0.;\n        vec3 sineCoeff = vec3(\n            pos.z*2.4*freq,\n            pos.x*2.6*freq + timeOffs,\n            pos.y*2.8*freq\n        );\n        vec3 randOffs = sin(sineCoeff);\n        dens += (abs(noise(pos * freq + vec3(i)*167. + randOffs*0.022*freq))-0.48) * amp;\n        freq *= 2.1;\n        amp *= 0.5;\n    }\n    return  max(0., \n                0.0 + dens*0.8 - \n                pow(sideClipX,10.5)*0.4 - \n                pow(sideClipZ, 10.5)*0.4 - \n                pow(topClip,13.5)*0.3 - \n                pow(bottomClip,25.)*0.5\n            );\n}\n\nfloat blueNoise(vec2 pixelPos) {\n    const float c_goldenRatioConjugate = 0.61803398875f; // also just fract(goldenRatio)\n    float val = textureLod(iChannel0, pixelPos / 1024.0f, 0.).r;\n    int frame = iFrame % 64;\n    val = fract(val + float(frame) * c_goldenRatioConjugate);\n    return val;\n}\n\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float camX = cos(iTime*CAMERA_SPIN_SPEED+2.0); \n    float camZ = sin(iTime*CAMERA_SPIN_SPEED+2.0);\n\n    float camYOffs = sin(iTime*0.3)*0.28;\n    vec3 cameraPos = normalize(vec3(camX,camYOffs-0.03,camZ))*CAMERA_DISTANCE;\n    vec3 cameraDir = -normalize(cameraPos+vec3(0.,cameraPos.y*0.30+0.11,0.));\n    vec3 cameraRight = normalize(cross(vec3(0,1,0), cameraDir));\n    vec3 cameraUp = normalize(cross(cameraDir, cameraRight));\n    \n    vec3 viewDir = normalize(cameraDir + cameraUp*uv.y*FOV_MULTIPLIER + cameraRight*uv.x*FOV_MULTIPLIER);\n    \n    float ao = 1.0;\n    \n    vec3 final = skyColor(viewDir, cameraPos);\n    \n    vec3 sunUp = normalize(cross(SUN_DIR, vec3(0,1,0)));\n    vec3 sunRight = normalize(cross(SUN_DIR, sunUp));\n    sunUp = normalize(cross(SUN_DIR, sunRight));\n    \n    vec2 box = intersectAABB(cameraPos, viewDir, -CLOUD_SIZE*0.5, CLOUD_SIZE*0.5); \n    vec3 hitPoint = cameraPos + viewDir*box.x;\n    \n    if (box.x<=box.y) {\n        float lightDirMult = 0.9 + blueNoise(fragCoord+50.)*0.2;\n        hitPoint += viewDir * blueNoise(fragCoord+123.) * 0.2;\n        //lightDirMult = 1.;\n        vec4 volume = vec4(0);\n        const float marchStep = 0.07;\n        for(int i = 0; i<32; i++) {\n            vec3 p = hitPoint + viewDir*float(i)*marchStep;\n            if (distance(p, cameraPos)>box.y) break;\n            float dens = density(p);\n            float light = 0.0;\n            vec3 lightP = p;\n            float lightStepInc = 2.0;\n            float lightStep = 0.002;\n            for (int n = 0; n<8; n++) {\n                float lightDens = density(lightP);\n                light += lightDens * lightStep * 20.;\n                float randUp = (blueNoise(fragCoord + vec2(n)*50.)*2.-1.) * SCATTERING_MULTIPLIER;\n                float randRight = (blueNoise(fragCoord + vec2(n)*88.)*2.-1.) * SCATTERING_MULTIPLIER;\n                vec3 scatterVec = normalize(SUN_DIR + sunUp*randUp + sunRight*randRight);\n                lightP += scatterVec * lightStep * lightDirMult;\n                if  (\n                        abs(lightP.y)>CLOUD_SIZE.y*0.5 ||\n                        abs(lightP.x)>CLOUD_SIZE.x*0.5 ||\n                        abs(lightP.z)>CLOUD_SIZE.z*0.5 \n                    ) break;\n                lightStep *= lightStepInc;\n            }\n            \n            light = exp(-light*light*12.0);\n            \n            //Ambient\n            /**/\n            float amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 120.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 151.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 199.)*2.0-1.0\n                    ))*0.10*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            float ambSoft = exp(-amb*5.0)*0.9+0.1;\n            vec3 ambient = mix(vec3(0.15, 0.25,0.55), vec3(0.58,0.85,1.02), ambSoft);\n            \n            amb = 0.;\n            for (int a = 1; a<2; a++) {\n                vec3 ambP = p + \n                    normalize(vec3(\n                        blueNoise(fragCoord + vec2(a) * 150.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 81.)*2.0-1.0,\n                        blueNoise(fragCoord + vec2(a) * 149.)*2.0-1.0\n                    ))*0.05*(1.+float(a)*0.4);\n                amb += density(ambP);\n            }\n            ambient *= exp(-amb*3.0)*0.8+0.2;\n            \n            vec3 newColor = vec3(0.7, 0.85, 1) * (light * SUN_COLOR + ambient*1.6);\n            volume.rgb += (1.0 - volume.a) * dens * newColor;\n            volume.a += (1.0 - volume.a) * dens;\n        }\n        if (volume.a > 0.001) volume.rgb /= volume.a;\n        final = mix(final, volume.rgb, clamp(volume.a*1.3, 0., 1.));\n    }\n\n    // Output to screen\n    uv.y *= 1.6;\n    float vignette = exp2(-length(uv*uv*uv*uv*0.6));\n    fragColor = vec4(aces_tonemap(final) * vignette,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}