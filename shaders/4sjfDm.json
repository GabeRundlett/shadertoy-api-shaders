{
    "Shader": {
        "info": {
            "date": "1500922236",
            "description": "Magic crystals have contaminated this land, spawning terrible beasties. Explore using your scrying map to locate the 13 crystals and absorb their power.\nMove: WASD or cursors. Click = ranged attack. Spacebar = local attack.\nBest run in full screen.",
            "flags": 48,
            "hasliked": 0,
            "id": "4sjfDm",
            "likes": 27,
            "name": "[SH17B] Adventure Game",
            "published": 3,
            "tags": [
                "2d",
                "game",
                "text",
                "adventure",
                "sh17b"
            ],
            "usePreview": 1,
            "username": "TekF",
            "viewed": 2358
        },
        "renderpass": [
            {
                "code": "// Looks better with anti aliasing, but it might hurt frame rate\n//#define ANTI_ALIASING\n\n// data indices\n#define MAP_SIZE ivec2(128,128)\n#define PLAYER_POS_MAP (MAP_SIZE/2)\n// enemies get a whole row (with a blank row above the map to hide a glitch in scene rendering!)\n#define ENEMY_DATA_Y (MAP_SIZE.y+1)\n#define MAX_ENEMIES 16\n#define PLAYER_DATA ivec2(MAP_SIZE.x,0)\n#define PLAYER_STATS ivec2(MAP_SIZE.x+1,0)\n#define ATTACK_DATA ivec2(MAP_SIZE.x+2,0)\n#define INVENTORY_DATA ivec2(MAP_SIZE.x+3,0)\n\n#define EQ2(a,b) ((a).x==(b).x && (a).y==(b).y)\n#define LT2(a,b) ((a).x<(b).x && (a).y<(b).y)\n\n#define Get(index) texelFetch(iChannel0,index,0)\n\nivec2 ToView( vec2 a )\n{\n    return ivec2((a/iResolution.xy - vec2(.5))*vec2(MAP_SIZE));\n}\n\nconst ivec2 collectibles[] = ivec2[](\n        // position x, y\n        ivec2(180,100),\n        ivec2(100,400),\n        ivec2(303,233),\n        ivec2(327,228),\n        ivec2(300,570),\n        ivec2(300,800),\n        ivec2(529,481),\n        ivec2(300,700), // hard to get to\n        ivec2(690,100),\n        ivec2(620,440),\n    \tivec2(695,770),\n        ivec2(965,875),\n        ivec2(970,700) // furthest away, via top right (hardest enemies should go there)\n    );\n\n\nconst vec4 collectiblesPowerUp[] = vec4[](\n        // magic, health, magic regen, health regen\n    \t// 100,100,.1,.02\n        vec4(20,0,0,0),\n        vec4(0,20,0,0),\n        vec4(15,15,0,0),\n        vec4(0,10,.05,0),\n        vec4(30,0,0,0),\n        vec4(0,0,0,.02),\n        vec4(-1,0,0,0), // extra life\n        vec4(0,25,.05,0),\n        vec4(-1,0,0,0),\n        vec4(35,0,0,0),\n    \tvec4(0,30,0,0),\n        vec4(0,0,.1,.02),\n        vec4(0,0,.1,.02)\n    );\n\nfloat ShootTest( vec2 uv, vec2 dir )\n{\n    float d = dot(dir,uv);\n//    return d > .0 && d < 40. && sqrt(dot(uv,uv)-d*d) < 3.;\n    float perp2 = max(.0,dot(uv,uv)-d*d);\n    float par = max(-d+2.,.0) + max(d-40.,.0);\n    return sqrt( par*par + perp2 ) - 3.;\n}\n       \n\n//--end of shared--\n\n\n// char is 0xVU, where V and U are the row and column of the character\n// Prints character in the range [(0,0),(.5,1)]\nfloat PrintCharacter( in int char, in vec2 uv )\n{\n    uint idx = uint(char);\n    vec2 charp = vec2( idx&0xFU, idx>>4U );\n\n//    uv = clamp(uv,vec2(0),vec2(.5,1));\n    if ( min(uv.x,uv.y) < .0 || max(uv.x-.5,uv.y-1.) > .0 )\n        return 0.;\n    uv.x += .25;\n//    return step(textureLod(iChannel0, (uv+charp)/16., .0).w,.5);\n//    return smoothstep(.53,.47,textureLod(iChannel1, (uv+charp)/16., .0).w );\n//    return textureLod(iChannel0, (uv+charp)/16., .0).x;\n    return 1.-textureLod(iChannel1, (uv+charp)/16., .0).w;\n}\n\n// prints a float in a box from (0,0) to (length*.5,1)\nfloat PrintInt( in int value, in vec2 uv )\n{\n    float o = .0;\n    int v;\n    bool y = false;\n    if ( value < 0 ) { o += PrintCharacter( 0xDD, uv ); uv.x -= .5; value = -value; }\n    v = (value/100000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1000000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/100000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1000)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/100)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/10)%10; if ( y || v != 0 ) { o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5; y = true; }\n    v = (value/1)%10; o += PrintCharacter( 0xC0 + v, uv ); uv.x -= .5;\n    return o;\n}\n\nbool InBox( ivec2 p, ivec2 a, ivec2 b )\n{\n/*    p = abs(2*p-a-b)-abs(a-b);\n    return p.x < 0 && p.y < 0; // will have 1-pixel error on odd-width/height*/\n    ivec2 i = min(a,b);\n    ivec2 j = max(a,b);\n    return p.x >= i.x && p.y >= i.y && p.x < j.x && p.y < j.y;\n}\n\n\nvec4 GameLose( vec2 u, vec4 o )\n{\n    o = vec4(dot(o,vec4(.2126,.7152,.0722,0)));\n    \n    const int string[] = int[]( 0x50, 0xB7, 0xB1, 0xBD, 0xB5, 0x50, 0xBF, 0xA6, 0xB5, 0xA2,0x50 );\n    \n    u -= .5;\n    u.y *= 9./16.;\n    u *= 256.;\n    \n    //u.y -= iFrame/2; u.y = (u.y%40)+20;\n\n    vec2 uv = u / 10. - vec2(-float(string.length())*.25,-.5);\n    float t = 0.;\n    for ( int i=0; i < string.length(); i++ )\n    {\n        t += PrintCharacter( string[i], uv ); uv.x -= .5;\n    }\n    return mix( o*.3, vec4(1,0,0,1), smoothstep(.48,.52,t) );\n}\n\n\nvec4 GameWin( vec2 u, vec4 o )\n{\n    o = vec4(dot(o,vec4(.2126,.7152,.0722,0)))*vec4(.3);\n    \n    u -= .5;\n    u.y *= 9./16.;\n    \n    float idim = .01;\n    for ( int i=0; i < collectibles.length(); i++ )\n    {\n        float a = (float(iFrame)*.003+float(i)/float(collectibles.length()))*6.283;\n        vec2 iuv = u-vec2(cos(a),sin(a))*(.13+.12*sin(float(iFrame)*.01));\n//        iuv.y /= 2.;//iResolution.x/iResolution.y;\n        iuv.y -= idim;\n        float r = dot(abs(iuv),vec2(1));\n        if ( r < idim )\n        {\n            o = vec4(float((iFrame+i)%9+3*int(-sign(iuv.x)))/8.,float((iFrame+i)%11+5*int(sign(iuv.y)))/10.,1,1);\n        }\n    }\n    \n    u *= 256.;\n\n    float t = 0.;\n\n    const int string[] = int[]( 0xA7, 0xB5, 0xBC, 0xBC, 0x50, 0xB4, 0xBF, 0xBE, 0xB5, 0xD1 );\n    vec2 uv = u / 14. - vec2(-float(string.length())*.25,.2);\n\n    float a = .0;\n    for ( int i=0; i < string.length(); i++ )\n    {\n        a += PrintCharacter( string[i], uv ); uv.x -= .5;\n    }\n    t += smoothstep(.487,.513,a);\n    \n    // Capitals 0xB1 to 0xAA, Lowercase 0x91 to 0x8A, numerals 0xC0 to 0xC9\n    const int string2[] = int[]( 0xA9, 0x9F, 0x85, 0x50, 0x96, 0x9F, 0x85, 0x9e, 0x94, 0x50, 0x91, 0x9C, 0x9C );\n    uv = vec2(u) / 10. - vec2(-float(string2.length())*.25,-.9);\n    a = .0;\n    for ( int i=0; i < string2.length(); i++ )\n    {\n        a += PrintCharacter( string2[i], uv ); uv.x -= .5;\n    }\n    t += smoothstep(.48,.52,a);\n\n    const int string3[] = int[]( 0x84, 0x98, 0x95, 0x50, 0x93, 0x82, 0x89, 0x83, 0x84, 0x91, 0x9C, 0x83, 0xDE );\n    uv = vec2(u) / 10. - vec2(-float(string2.length())*.25,-2.);\n    a = .0;\n    for ( int i=0; i < string3.length(); i++ )\n    {\n        a += PrintCharacter( string3[i], uv ); uv.x -= .5;\n    }\n    t += smoothstep(.48,.52,a);\n\n    o = mix( o, 1.-o, t );\n    \n    return o;\n}\n\n\n\nfloat Hash( ivec2 uv )\n{\n    uint n = uint(uv.x) + uint(uv.y)*1024U;\n    \n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float( n & 0x7fffffffU)/float(0x7fffffff);\n}\n\n\n\n// Render the main game view\nvec4 RenderGame( vec2 _uv )\n{\n    //ivec2 iuv = ivec2(uv); <- bad, it means art style changes with resolution => do it all in floats\n    vec2 uv = _uv/iResolution.xy; // ignore aspect ratio! The gameis stylised to look good around 16:9.\n    ivec2 mu = ivec2(uv*vec2(MAP_SIZE));\n\n    vec4 playerData = Get(PLAYER_DATA); // position, magic level, health\n    vec2 playerHeading = sign(playerData.xy);\n    playerData.xy = abs(playerData.xy);\n    playerData.xy = floor(playerData.xy+.5);\n    ivec4 playerStats = ivec4(Get(PLAYER_STATS)); // max magic level, max health, magic regen rate, health regen rate\n    vec4 attackData = Get(ATTACK_DATA);\n    ivec4 inventoryData = ivec4(Get(INVENTORY_DATA)); // bitmask of collectibles, [bitmask of equipment, number of potions, number of lives]\n\n    \n    // map\n    vec4 o = Get(mu);\n    \n    vec2 groundTexel = 1./vec2(4.,2.);\n    ivec2 groundUV = ivec2(((uv-.5)*vec2(MAP_SIZE)+playerData.xy)/groundTexel);\n    float dither = Hash(groundUV);\n    \n    float gridDither = float( ((groundUV.x&1)*2+(groundUV.y&1)*3)&3 )/3.;\n\n    \n    // palette\n    const vec4 ground1a[]\t\t= vec4[]( vec4(.8,.7,.5,1), vec4(0,.4,.1,1), vec4(1), vec4(.2) );\n    const vec4 ground2a[]\t\t= vec4[]( vec4(.68,.52,.38,1), vec4(.1,.5,.0,1), vec4(.8), vec4(.3) );\n    const vec4 shortgrassa[]\t= vec4[]( vec4(.5,.6,.3,1), vec4(.5,.6,.3,1), vec4(.4,.3,.2,1), vec4(.6) );\n    const vec4 grassa[]\t\t= vec4[]( vec4(.5,.9,.3,1), vec4(.5,.5,.1,1), vec4(.4,.4,.2,1), vec4(.5,.2,.3,1) );\n\n    // blend the colours\n    ivec2 muv = mu+ivec2(playerData.xy);\n    \n/*\t// noisy blend - cool but kinda ugly\n\tivec2 bary = (muv+ivec2((vec2(Hash(muv),Hash(muv+40))-.5)*100.)) / ivec2(512,512);\n    int biome = bary.x+bary.y*2;\n    vec4 ground1 = ground1a[biome];\n    vec4 ground2 = ground2a[biome];\n\tvec4 shortgrasscol = shortgrassa[biome];\n    vec4 grasscol = grassa[biome];*/\n    \n    // smoother blend\n    vec2 biomeBlend = (vec2(muv)*(60./61.) + (11./61.)*vec2(-muv.y,muv.x)-vec2(512,620))/vec2(200,100)+.5;\n    biomeBlend = smoothstep( .0, 1., biomeBlend );\n    \n    float quantization = 8.;\n    biomeBlend = floor(biomeBlend*quantization+vec2(Hash(muv),Hash(muv+40)))/quantization;\n    vec4 ground1 = mix( mix( ground1a[0], ground1a[1], biomeBlend.x ), mix( ground1a[2], ground1a[3], biomeBlend.x ), biomeBlend.y );\n    vec4 ground2 = mix( mix( ground2a[0], ground2a[1], biomeBlend.x ), mix( ground2a[2], ground2a[3], biomeBlend.x ), biomeBlend.y );\n\tvec4 shortgrasscol = mix( mix( shortgrassa[0], shortgrassa[1], biomeBlend.x ), mix( shortgrassa[2], shortgrassa[3], biomeBlend.x ), biomeBlend.y );\n    vec4 grasscol = mix( mix( grassa[0], grassa[1], biomeBlend.x ), mix( grassa[2], grassa[3], biomeBlend.x ), biomeBlend.y );\n    \n    if ( o.z < .07 )\n    {\n        // WATER\n        \n        // create height\n\t\tfloat dy = 1.;\n        vec4 t = Get(ivec2(uv*vec2(MAP_SIZE)+vec2(0,dy))); // vertical side\n        o = ground1*.7;\n        \n        if ( t.z < .07 )\n        {\n            // water surface\n        \tt = Get(ivec2(uv*vec2(MAP_SIZE)+vec2(0,dy*2.))); // reflection of vertical side\n        \to = mix( vec4(.2,.4,.7,1), mix( vec4(.0), ground1, .3 ), step(.07,t.z)*.4 );\n            \n            // ripples\n            o = mix( o, vec4(.4,.6,.8,1), max(.0,fract((uv.y+playerData.y/float(MAP_SIZE.y))*20.-iTime*.3+2.*Hash(ivec2(mu.x+int(playerData.x),0)))*4.-3.) );\n        }\n    }\n    else\n    {\n        // GROUND\n        // read map with bilinear filtering\n        vec3 a = texture(iChannel2,vec2(groundUV)*groundTexel/iChannelResolution[2].xy).xyz;\n        \n        // earth\n        float earth = (dot(a,vec3(1,0,0))-.1)*5.;\n        o = mix( ground1, ground2, step(gridDither,earth) );\n\n\t    float dither2 = Hash(groundUV+ivec2(0,-1));\n        float blade = min(dither,dither2);\n\n        float shortgrass = dot(a,vec3(0,0,1))-.1;\n        o = mix( o, shortgrasscol*(1.-.5*(shortgrass-blade)/max(.001,shortgrass)), step(blade,shortgrass) );\n        \n\t    float dither3 = Hash(groundUV+ivec2(0,-2));\n        blade = min(blade,dither3);\n        \n        float grass = dot(a,vec3(0,1,0))*.5-.1;\n        \n\t    float shadow = Hash(groundUV+ivec2(-1,0));\n        o = mix( o, o*.7, step(shadow,grass) );\n        \n        o = mix( o, grasscol*(1.-.5*(grass-blade)/max(.001,grass)), step(blade,grass) );\n    }\n    \n    \n    // player character\n    const vec2 pdim = vec2(.008,.03);\n    vec2 puv = uv-vec2(.5,.5);\n    vec2 p;\n    \n    // player shadow\n    p = puv-vec2(pdim.x,0);\n    p.y *= 2.;\n    o *= .6+.4*smoothstep( .8, 1.5, length(p)/(pdim.x*1.5) );\n\n    // enemy shadows\n    for ( int i=0; i < MAX_ENEMIES; i++ )\n    {\n        vec4 enemyData = Get(ivec2(i,ENEMY_DATA_Y));\n        enemyData.xy = floor(enemyData.xy+.5);\n        vec2 euv = uv-((enemyData.xy-playerData.xy)/vec2(MAP_SIZE)+.5);\n        if ( enemyData.w > 0.\n            && length(euv) < .05 )\n        {\n            //o = vec4(1,1.-enemyData.w,.2,1);\n            vec2 edim = vec2(.01,.017) * enemyData.z;\n            float eh = .03;\n\n            // shadow\n            p = euv-vec2(edim.x,0);\n            p.y *= 2.;\n            o *= .6+.4*smoothstep( .8, 1.5, length(p)/edim.x );\n        }\n    }\n\n\n    // collectibles & their shadows (can draw together because they're never close enough to have shadow sorting errors)\n    for( int i=0; i < collectibles.length(); i++ )\n    {\n        vec2 iuv = uv-((vec2(collectibles[i].xy)-playerData.xy)/vec2(MAP_SIZE)+.5);\n        iuv.y /= 2.;//iResolution.x/iResolution.y;\n        if ( (inventoryData.x & (1<<i)) == 0 )\n        {\n            // shadow\n            float idim = .01;\n            p = iuv-vec2(idim,0);\n            p.y *= 4.;\n            o *= .6+.4*smoothstep( .7, 1.4, length(p)/idim );\n\n            // item\n            iuv.y -= idim;\n            float r = dot(abs(iuv),vec2(1));\n            if ( r < idim )\n            {\n                o = vec4(float(iFrame%9+3*int(-sign(iuv.x)))/8.,float(iFrame%11+5*int(sign(iuv.y)))/10.,1,1);\n            }\n        }\n    }\n    \n    \n    // death sequence\n    if ( playerData.w < .0 )\n    {\n        o = vec4(dot(o,vec4(.2126,.7152,.0722,0)))*(vec4(.3)+vec4(.3,-.2,-.2,0)*(.5+.5*cos(playerData.w*6.283/30.)));\n    }\n    \n\n    // player legs\n    vec2 pldim = vec2(.003,.015);\n    vec2 gait = vec2(.005,.004);\n    vec2 walk = gait*sin(playerData.xy*6.283/vec2(12,8));\n    p = puv-vec2(0,pldim.y+gait.y*.5);\n    float ls = smoothstep(.02,.005,puv.y);\n    if ( abs(p.x-walk.x) < pldim.x && abs(p.y-walk.y) < pldim.y )\n        o = vec4(.1,.5,1,1) * (.5+.5*ls*(.8+.2*walk.y/gait.y));\n    if ( abs(p.x+walk.x) < pldim.x && abs(p.y+walk.y) < pldim.y )\n        o = vec4(.1,.5,1,1) * (.5+.5*ls*(.7+.3*walk.y/gait.y));\n    \n    // face behind\n    vec2 pfdim = vec2(.006,.01);\n    if ( playerHeading.y > .0 )\n    {\n        p = puv - vec2(0,pdim.y*2.-pfdim.y+.002) - playerHeading*vec2(.006,0);\n        if ( length(p/pfdim) < 1. )\n        {\n            o = vec4(.8,.6,.5,1);\n            \n            if ( length(p/pfdim-vec2(playerHeading.x*.1+.35,-.2)) < 1. )\n                o *= .6;\n        }\n    }\n    \n    // body\n    vec2 pbdim = pdim*vec2(1,.75);\n    p = puv-vec2(0,pdim.y*2.-pbdim.y);\n//    if ( abs(p.x) < pbdim.x && abs(p.y) < pbdim.y )\n    if ( p.y > -pbdim.y && length( vec2(p.x,max(.0,p.y))/pbdim ) < 1. )\n        o = vec4(0,.125,1,1) * mix(1.,.6,(p.x/pbdim.x)*.5+.5);\n    \n    // face in front\n    if ( playerHeading.y < .0 )\n    {\n        p = puv - vec2(0,pdim.y*2.-pfdim.y-.004) - playerHeading*vec2(.006,0);\n        if ( length(p/pfdim) < 1. )\n        {\n            o = vec4(.8,.6,.5,1);\n            \n            if ( length(p/pfdim-vec2(-playerHeading.x*.1-.35,.2)) > 1. )\n                o *= .6;\n            \n            // eyes\n            if ( Hash(ivec2(iFrame/4,0)) > .005 )\n            {\n                vec2 pe = p;\n                pe.x = abs(pe.x-.001*playerHeading.x);\n                pe.y /= 2.;\n                if ( length(pe-vec2(.0025,0)) < .0015 )\n                {\n                    o = vec4(0);//.5,1,1,1);\n                }\n                if ( length(pe-vec2(.0025,.001)) < .0005 )\n                {\n                    o = vec4(1);\n                }\n            }\n        }\n    }\n\n    // hat\n    p = puv - vec2(0,pdim.y*2.-pfdim.y-.001) - playerHeading*vec2(.006,.003);\n    if ( p.y > .007 && ( ( p.y < .01 && abs(p.x) < .01 )|| -abs(p.x)-p.y*.2 > -.008 ) )\n    {\n        o = abs(p.y-.014)<.003 ? vec4(.5,.8,1,1) : vec4(0,.1,.8,1);\n        o *= 1.-.4*(p.x-p.y*.2+.005)/.01;\n    }\n\n    \n    // enemies (hovering)\n    for ( int i=0; i < MAX_ENEMIES; i++ )\n    {\n        vec2 edim = vec2(.01,.017);\n        float eh = .03;\n\n        vec4 enemyData = Get(ivec2(i,ENEMY_DATA_Y));\n        enemyData.xy = floor(enemyData.xy+.5);\n        vec2 euv = uv-((enemyData.xy-playerData.xy)/vec2(MAP_SIZE)+.5);\n        euv.y -= eh;\n        \n        edim *= enemyData.z;\n        \n        if ( enemyData.w > 0.\n            && length(euv) < .05*enemyData.z )\n        {\n            // health: 1->yellow, 2->orange, 3->red, 4->purple, 5->blue\n            // is it quicker to just do an array lookup\n            vec4 bodyCol = clamp( vec4(2.5,1.2,-1.5,1) + vec4(-.5,-.4,.5,0)*enemyData.w, .0, 1. );\n            \n            // body\n            p = euv - vec2(0);\n            if ( length(p/edim) < 1. )\n            {\n                // eye\n\t            float t = length(p/edim-vec2(0,-.2))*sqrt(enemyData.z); // smaller eye on bigger enemies\n                o = (t > .5 || Hash(ivec2(i,iFrame/8)) < .01) ? bodyCol : t > .2 ? vec4(1) : vec4(0);\n                \n                // shading\n                if ( length(p/edim-vec2(-.2,.2)) > .8 )\n                    o *= .8;\n            }\n            \n            // wings\n            euv.x = abs(euv.x); // just make one\n            p = euv/edim - vec2(.7,.7);\n            if ( ((i+iFrame)&4) == 0 ) p = p.yx; // \"rotate\" wings!\n            if ( p.x > .0 && p.y > .0 && p.x < 1. && p.y < .3 )\n                o = vec4(.3,.1,.5,1);\n        }\n    }\n\n    \n    // magic effects\n    if ( attackData.x < 15. )\n    {\n        float s = ShootTest((uv-.5-vec2(0,pdim.y))*vec2(MAP_SIZE),attackData.zw);\n        if ( s < .0 )\n        {\n            o += vec4(.5,1.-attackData.x/5.,1,0)*max(.0,-s+sin(length(uv)*30.-2.*float(iFrame))-1.);\n        }\n    }\n\n    if ( attackData.y < 10. )\n    {\n        vec2 buv = uv-vec2(.5);\n        if ( buv.y > .0 ) buv.y *= 9./16.;\n        float l = length(buv*vec2(MAP_SIZE))/(20.-attackData.y);\n        if ( l < 1. ) o = mix(vec4(0,-1,-3,1),vec4(10,4,1,1),1.-attackData.y/10.);\n    }\n    \n    \n    return o;\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 _u )\n{\n    ivec2 u = ToView(_u);\n    vec2 uv = _u/iResolution.xy; // ignore aspect ratio! The gameis stylised to look good around 16:9.\n    \n    vec4 playerData = Get(PLAYER_DATA); // position, magic level, health\n    vec2 playerHeading = sign(playerData.xy);\n    playerData.xy = abs(playerData.xy);\n    playerData.xy = floor(playerData.xy+.5);\n    vec4 playerStats = Get(PLAYER_STATS); // max magic level, max health, magic regen rate, health regen rate\n    vec4 attackData = Get(ATTACK_DATA);\n    ivec4 inventoryData = ivec4(Get(INVENTORY_DATA)); // bitmask of collectibles, [bitmask of equipment, number of potions, number of lives]\n    \n    // rotated grid anti-aliasing\n#ifdef ANTI_ALIASING\n    vec4 d = vec4(-.125,-.375,.125,.375);\n    o = vec4(0);\n    o += pow( RenderGame( _u + d.xy ), vec4(2.2));\n    o += pow( RenderGame( _u + d.yz ), vec4(2.2));\n    o += pow( RenderGame( _u + d.zw ), vec4(2.2));\n    o += pow( RenderGame( _u + d.wx ), vec4(2.2));\n    o /= 4.;\n    o = pow( o, vec4(1./2.2) );\n#else\n    o = RenderGame( _u );\n#endif\n\n    // detect game end states and show end screens\n\tif ( inventoryData.y <= 0 && iFrame > 0 )\n    {\n        o = GameLose(uv,o);\n        return;\n    }\n    \n    if ( inventoryData.x == (1<<collectibles.length())-1 )\n    {\n        o = GameWin(uv, o);\n        return;\n    }\n    \n\n    int hudMagnification = int(iResolution.y/float(MAP_SIZE.y));\n    ivec2 screenPos = ivec2(_u)/hudMagnification;;\n    \n    // HUD\n    ivec2 bl = screenPos;\n    ivec2 tr = ivec2(iResolution.xy)/hudMagnification - screenPos;\n    vec4 hud = vec4(0); // premultiplied alpha\n    \n    // energy bars\n    if ( InBox(bl,ivec2(4,4),ivec2(4.+playerStats.x*.5,8)) ) hud = (bl.x-4 <= int(playerData.z*.5)) ? vec4(0,0,1,1) : vec4(0,.2,.5,1)*.2;\n    if ( InBox(bl,ivec2(4,10),ivec2(4.+playerStats.y*.5,14)) ) hud = (bl.x-4 <= int(playerData.w*.5)) ? vec4(1,0,0,1) : vec4(.5,0,0,1)*.2;\n    \n    // collectibles\n    if ( InBox(tr,ivec2(4,4),ivec2(4+collectibles.length()*5,8)) )\n    {\n        int idx = (tr.x-4)/5;\n        if ( ((tr.x-4)%5) != 0 )\n        \thud = (inventoryData.x & (1<<idx)) == 0 ? vec4(1)*.2: vec4(1);\n    }\n    \n    // collectible map\n    ivec2 m = tr-ivec2(4,10);\n    if ( InBox(m,ivec2(0),ivec2(32)) )\n    {\n        m = 31-m; // flip it back around\n\n        hud = textureLod(iChannel2,vec2(m)/31.,4.);\n//        hud = texture(iChannel2,(31.-(iResolution.xy - _u)/float(hudMagnification)+vec2(4,10))/31.);\n        \n        if ( hud.z < .07 )\n            hud = vec4(.4,.6,1,1);\n        else\n        {\n            // show the biomes\n            vec4 biome = mix(\n                \t\t\tmix(\n                                vec4(.9,.8,.6,1),\n                                vec4(.1,.5,.2,1),\n                                smoothstep(13.,19.,float(m.x))),\n                \t\t\tmix(\n                                vec4(1),\n                                vec4(.3,.3,.3,1),\n                                smoothstep(13.,19.,float(m.x))),\n                \t\t\tsmoothstep(14.5,17.5,float(m.y))\n                \t\t);\n            hud = mix( hud, biome, .5 );\n        }\n        \n        hud *= .7; // fade alpha & colour\n        \n        if ( EQ2(m,ivec2(32.*playerData.xy/iChannelResolution[2].xy)) )\n        \thud = vec4(0,1,0,1);\n\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \t EQ2(m,32*collectibles[i].xy/ivec2(iChannelResolution[2].xy)) )\n            {\n                hud = vec4(1);\n            }\n        }\n    }\n    \n    // lives\n    if ( InBox(tr,ivec2(4,44),ivec2(4,44)+ivec2(17,5)) )\n    {\n        ivec2 uu = tr - ivec2(4,44);\n        int life = uu.x/6;\n        uu.x = uu.x%6;\n\n        const int heartShape[] = int[] ( 0x0a, 0x1f, 0x1f, 0x0e, 0x04 );\n        \n\t\tfloat flash = 1.;\n        if ( playerData.w < .0 && int(inventoryData.y) == life+1 )\n        {\n            flash = (iFrame&8) == 0 ? .0 : 1.;\n        }\n            \n        if ( (heartShape[uu.y]&(1<<uu.x)) != 0 )\n            hud = int(inventoryData.y) > life ? vec4(1,0,0,1)*flash : vec4(1,0,0,1)*.0;\n    }\n    \n\n/*    // Debug Text\n    vec2 l = _u;\n    l.y -= iResolution.y;\n    l /= 16.;\n    l.y += 1.; hud += vec4(1,1,0,1) * smoothstep(.47,.53,PrintInt( int(playerData.x), l ));\n    l.y += 1.; hud += vec4(1,1,0,1) * smoothstep(.47,.53,PrintInt( int(playerData.y), l ));*/\n    \n\n    o = o*(1.-hud.a) + hud; // premultiplied alpha\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// data indices\n#define MAP_SIZE ivec2(128,128)\n#define PLAYER_POS_MAP (MAP_SIZE/2)\n// enemies get a whole row\n#define ENEMY_DATA_Y (MAP_SIZE.y+1)\n#define MAX_ENEMIES 16\n#define PLAYER_DATA ivec2(MAP_SIZE.x,0)\n#define PLAYER_STATS ivec2(MAP_SIZE.x+1,0)\n#define ATTACK_DATA ivec2(MAP_SIZE.x+2,0)\n#define INVENTORY_DATA ivec2(MAP_SIZE.x+3,0)\n\n#define EQ2(a,b) ((a).x==(b).x && (a).y==(b).y)\n#define LT2(a,b) ((a).x<(b).x && (a).y<(b).y)\n\n#define Get(index) texelFetch(iChannel0,index,0)\n\nivec2 ToView( vec2 a )\n{\n    return ivec2((a/iResolution.xy - vec2(.5))*vec2(MAP_SIZE));\n}\n\nconst ivec2 collectibles[] = ivec2[](\n        // position x, y\n        ivec2(180,100),\n        ivec2(100,400),\n        ivec2(303,233),\n        ivec2(327,228),\n        ivec2(300,570),\n        ivec2(300,800),\n        ivec2(529,481),\n        ivec2(300,700), // hard to get to\n        ivec2(690,100),\n        ivec2(620,440),\n    \tivec2(695,770),\n        ivec2(965,875),\n        ivec2(970,700) // furthest away, via top right (hardest enemies should go there)\n    );\n\nconst vec4 collectiblesPowerUp[] = vec4[](\n        // magic, health, magic regen, health regen\n    \t// 100,100,.1,.02\n        vec4(20,0,0,0),\n        vec4(0,20,0,0),\n        vec4(15,15,0,0),\n        vec4(0,10,.05,0),\n        vec4(30,0,0,0),\n        vec4(0,0,0,.02),\n        vec4(-1,0,0,0), // extra life\n        vec4(0,25,.05,0),\n        vec4(-1,0,0,0),\n        vec4(35,0,0,0),\n    \tvec4(0,30,0,0),\n        vec4(0,0,.1,.02),\n        vec4(0,0,.1,.02)\n    );\n\nfloat ShootTest( vec2 uv, vec2 dir )\n{\n    float d = dot(dir,uv);\n//    return d > .0 && d < 40. && sqrt(dot(uv,uv)-d*d) < 3.;\n    float perp2 = max(.0,dot(uv,uv)-d*d);\n    float par = max(-d+2.,.0) + max(d-40.,.0);\n    return sqrt( par*par + perp2 ) - 3.;\n}\n       \n\n//--end of shared--\n\n\n#define K(a) texelFetch(iChannel1,ivec2(a,0),0).x\n\n#define SHOOT_COST 20.\n#define BLAST_COST 90.\n\nuint g_randCount = 0U;\n\nfloat Rand( int index )\n{\n    uint n = g_randCount + uint(iFrame)*20U + uint(index)*400U; //20U = more than number of calls per frame\n    g_randCount++;\n    \n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float( n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat Rand() { return Rand(0); }\n\nvoid mainImage( out vec4 o, in vec2 _index )\n{\n    ivec2 index = ivec2(_index);\n    \n    // leave data intact unless we have something we need to do to it\n    o = Get(index);\n\n    vec4 playerData = Get(PLAYER_DATA); // position, magic level, health\n    vec2 playerHeading = sign(playerData.xy);\n    playerData.xy = abs(playerData.xy);\n    vec4 playerStats = Get(PLAYER_STATS); // max magic level, max health, magic regen rate, health regen rate\n    vec4 attackData = Get(ATTACK_DATA); // magic cool-down, ...\n    ivec4 inventoryData = ivec4(Get(INVENTORY_DATA)); // bitmask of collectibles, [bitmask of equipment, number of potions, number of lives]\n\n    if ( iFrame == 0 )\n    {\n        playerData = vec4(32,-32,100,100);\n        playerStats = vec4(100,100,.1,.02);\n        attackData = vec4(1000,1000,0,0);\n        inventoryData = ivec4(0,3,0,0);\n    }\n\n    \n    if ( inventoryData.y <= 0\n    \t|| ( inventoryData.x == (1<<collectibles.length())-1 ) )\n    {\n        // game has ended, do nothing\n        return;\n    }\n    \n    \n    \n    bool alive = playerData.w >= .0;\n    \n    // INPUTS\n    \n    // how much should we move this frame?\n    ivec2 delta = ivec2( K(39)-K(37), K(38)-K(40) ); // cursors\n    delta |= ivec2( K(68)-K(65), K(87)-K(83) ); // WASD\n    \n    if ( (iFrame&1) != 0 // slow down player\n        || !alive ) // don't move when you're dead\n        delta = ivec2(0);\n    \n    // collisions - yes, we need this for every pixel (could maybe do another buffer if it was expensive)\n//    if ( Get(PLAYER_POS_MAP+delta).z < .07 ) delta = ivec2(0);\n    if ( Get(PLAYER_POS_MAP+ivec2(delta.x,0)).z < .07 ) delta.x = 0;\n    if ( Get(PLAYER_POS_MAP+delta).z < .07 ) delta.y = 0;\n    \n    \n    ivec2 qqq = ToView(iMouse.zw) + ivec2(0,-4); // offset for player height\n    vec2 rangedAttack = normalize(vec2(qqq)+vec2(0,.001));\n    bool shooting = alive && LT2( abs(qqq), MAP_SIZE/2 ) && attackData.x > 20.0 && playerData.z >= SHOOT_COST;\n    bool blasting = alive && K(32) != .0 && attackData.y > 20.0 && playerData.z >= BLAST_COST;\n    \n    \n    // move player here, because everything needs to agree about player's position\n    // other player stats just get updated if we're on the player data/stat pixels\n    playerData.xy += vec2(delta);\n    \n    // death state\n    bool respawn = false;\n    if ( !alive )\n    {\n        playerData.w += 1.;\n        if ( playerData.w > -1. )\n        {\n            respawn = true;\n        }\n    }\n    \n    if ( EQ2( index, PLAYER_DATA ) )\n    {\n        if ( alive ) // don't update player state while dead!\n        {\n            // test for enemy collisions\n            float damage = 0.;\n            for ( int i=0; i < MAX_ENEMIES; i++ )\n            {\n                vec4 enemyData = Get(ivec2(i,ENEMY_DATA_Y));\n                if ( enemyData.w > 0.\n                   && length(playerData.xy-enemyData.xy) < 3.\n                   && ((iFrame+i)&7) == 0 )\n                {\n                    damage += 3.*enemyData.z*enemyData.z; // small enemies are really weak, big ones are really strong\n                }\n            }\n\n            playerData.w += (damage == .0) ? playerStats.w: -damage;\n            if ( playerData.w < .0 ) playerData.w = -180.;\n\n            // use magic\n            playerData.z += blasting ? -BLAST_COST : shooting ? -SHOOT_COST : min(attackData.x,attackData.y) < 30.0 ? .0 : playerStats.z;\n\n            playerData.zw = min( playerData.zw, playerStats.xy );\n            \n            // refill health & magic when get a crystal\n            for( int i=0; i < collectibles.length(); i++ )\n            {\n                if ( (inventoryData.x & (1<<i)) == 0 &&\n                    length(playerData.xy - vec2(collectibles[i].xy)) < 3. )\n                {\n                    if ( collectiblesPowerUp[i].x >= .0 )\n                    {\n                        playerStats += collectiblesPowerUp[i];\n                    }\n                    playerData.zw = playerStats.xy;\n                }\n            }\n        }\n\n        if ( respawn )\n        {\n            playerData.zw = playerStats.xy;\n        }\n        \n        playerHeading *= step(.0,playerHeading*vec2(delta))*2.-1.; // flip direction of player if movement is opposite direction\n        playerHeading = step(.0,playerHeading)*2.-1.; // force it to be -1 or 1\n        \n        playerData.xy *= playerHeading;\n        \n        o = playerData;\n    }\n    \n    if ( EQ2( index, PLAYER_STATS ) )\n    {\n        // apply power-ups\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \tlength(playerData.xy - vec2(collectibles[i].xy)) < 3. )\n            {\n                if ( collectiblesPowerUp[i].x >= .0 )\n                {\n                \tplayerStats += collectiblesPowerUp[i];\n                }\n            }\n        }\n        \n    \to = playerStats;\n    }\n    \n    if ( EQ2( index, ATTACK_DATA ) )\n    {\n        attackData.x = shooting ? 0. : attackData.x+1.; // shoot cooldown\n        attackData.y = blasting ? 0. : attackData.y+1.; // blast cooldown\n        if ( shooting ) attackData.zw = rangedAttack; // last attack direction\n    \to = attackData;\n    }\n    \n    if ( EQ2( index, INVENTORY_DATA ) )\n    {\n        for( int i=0; i < collectibles.length(); i++ )\n        {\n            if ( (inventoryData.x & (1<<i)) == 0 &&\n            \tlength(playerData.xy - vec2(collectibles[i].xy)) < 3. )\n            {\n                inventoryData.x |= 1<<i;\n                \n                if ( collectiblesPowerUp[i].x < .0 )\n                {\n                    inventoryData.y++; // extra life\n                }\n            }\n        }\n        \n        if ( respawn )\n        {\n            inventoryData.y--; // lose a life\n        }\n        \n        o = vec4(inventoryData);\n    }\n        \n    if ( index.y == ENEMY_DATA_Y )\n    {\n        vec4 enemyData = Get(index);\n\n        // enemy data: xy = pos, w = health/dead/blank\n        if ( enemyData.w <= .0 )\n        {\n            if ( index.x < MAX_ENEMIES && !EQ2(delta,ivec2(0)) ) // can we create an enemy?\n            {\n                // decide whether to spawn an enemy in this slot\n                /*don't want rate of spawning affected by number of slots\n                and we have no atomic state\n                => have to scan to test if this is the first empty slot\n                - alternatively we could shift everything down every time an enemy dies - but that's a similar problem*/\n\n                // Am I the first empry slot?\n                int i=0;\n                for ( ; i < MAX_ENEMIES; i++ )\n                {\n                    if ( Get(ivec2(i,ENEMY_DATA_Y)).w <= 0. || i == index.x )\n                        break;\n                }\n\n                if ( i == index.x )\n                {\n                    // I'm the first empty slot, decide whether to spawn an enemy\n                    float spawnChance = Rand();\n\t\t\t\t\tif ( spawnChance <= 3./20. ) // enemies/framesOfMovement\n                    {\n                        // put it on one of the sides we're moving toward\n                        //enemyData.xy = playerData.xy + vec2(sign(delta)*(MAP_SIZE/2-1));\n                        enemyData.xy = vec2(Rand(),Rand())*vec2(MAP_SIZE);\n                        // flatten to leading edge in direction of travel\n\t\t\t\t\t\tenemyData.xy -= vec2(MAP_SIZE/2);\n\n                        enemyData.xy += dot(vec2(MAP_SIZE/2)*sign(vec2(delta))-enemyData.xy,vec2(delta))*vec2(delta);\n\t\t\t\t\t\t\n                        enemyData.xy += vec2(MAP_SIZE/2);\n                        enemyData.xy += playerData.xy-vec2(PLAYER_POS_MAP);\n\n                        \n                        // vary difficulty/variety across map\n                        vec2 region = enemyData.xy / iChannelResolution[2].xy;\n                        float difficulty = smoothstep(.2,1.2,region.x+region.y*.5);\n                        \n\t\t\t\t\t\tif ( spawnChance > (1.+difficulty*2.)/20. // enemies/framesOfMovement\n\t               \t\t\t|| min(region.x,region.y) < .0 || max(region.x,region.y) >=  1. )\n                        {\n                            // abort creation\n                            enemyData = vec4(0);\n                        }\n                        else\n                        {\n                            // enemy type\n                            // tie probabilities to region, and health to size\n                            // so we never get purple flies, or blue normals, and get only 1 enemy type in start area\n                            float size = floor(2.99*Rand());\n                            if ( difficulty < .1 ) size = 1.; // no flies\n                            if ( difficulty < .5 ) size = min( size, 1. ); // no tanks\n\n                            enemyData.z = exp2(size-1.); // size & attack strength: .5 = small & fast, 2. = big and slow\n                            enemyData.w = size + floor(2.*difficulty + 1.99*Rand()); // health: 1 = yellow, 2 = orange, 3 = red, 4 = purple, 5 = blue\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            vec2 enemyPosView = enemyData.xy-playerData.xy;\n            \n            // take damage\n            if ( shooting && ShootTest(enemyPosView,rangedAttack) <= enemyData.z*2. )\n                enemyData.w -= 1.;\n            if( blasting && length(enemyPosView) < 20. )\n                enemyData.w -= 3.;\n            \n            // move enemy\n            if ( max(abs(enemyPosView.x),abs(enemyPosView.y)) > float(MAP_SIZE/2+1) )\n            {\n                enemyData = vec4(0); // cull\n            }\n            else\n            {\n                if ( length(enemyPosView) < 20.+16.*enemyData.z )\n                {\n                    // track player\n                    if ( ((iFrame+index.x)&(int(4.*enemyData.z)-1)) == 0 ) // don't step them all on the same frame\n                    {\n                        //enemyData.xy += sign(playerData.xy-enemyData.xy); // integer movement\n                        // or do float movement to get betater-looking direction\n                        enemyData.xy -= normalize(enemyPosView);\n                    }\n                }\n                else\n                {\n                    // idle\n                    if ( ((iFrame+index.x)&15) == 0 )\n                    {\n                        enemyData.xy += floor(2.999*vec2(Rand(index.x),Rand(index.x)))-1.;\n                    }\n                }\n            }\n        }\n                        \n//if ( iFrame == 0 && index.x == 0 ) enemyData = vec4(48,48,0,1);\n        \n        if ( respawn )//playerData.w < .0 )\n            enemyData = vec4(0); // kill all enemies\n        \n\t\to = enemyData;\n    }\n    \n    if ( LT2( index, MAP_SIZE ) )\n    {\n        if ( delta.x != 0 || delta.y != 0 )\n        {\n            // scroll map\n            o = Get(index+delta); // this will over/underflow but we'll fix that next\n        }\n        \n        if (\n            iFrame < 60 || // wait until textures are loaded\n//            respawn || // redraw after death (teleport)\n            ( index.x == 0 && delta.x < 0 ) ||\n            ( index.y == 0 && delta.y < 0 ) ||\n            ( index.x == MAP_SIZE.x-1 && delta.x > 0 ) ||\n            ( index.y == MAP_SIZE.y-1 && delta.y > 0 )\n            )\n        {\n            ivec2 uv = index+ivec2(playerData)-PLAYER_POS_MAP;\n            \n        \t// redraw this pixel\n            o = texelFetch(iChannel2,uv,0);\n            \n            // fade the edge to make everything water\n            uv = abs(uv - ivec2(iChannelResolution[2].xy)/2);\n            uv = abs(uv - ivec2(iChannelResolution[2].xy)/2);\n            o *= smoothstep(0.,10.,float(min(uv.x,uv.y)));\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}