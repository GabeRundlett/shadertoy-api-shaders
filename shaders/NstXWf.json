{
    "Shader": {
        "info": {
            "date": "1634099498",
            "description": "Kind of like a 2016 Shane shader or some sort of knock-off.",
            "flags": 32,
            "hasliked": 0,
            "id": "NstXWf",
            "likes": 14,
            "name": "Segment Simplex Grid #3",
            "published": 3,
            "tags": [
                "simplex"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "/*\n\nCode (or the logic) is a mess, \nhopefully only for now.\n\nfeatures of this shader:\n\n- Shane's Lighting\n\n- A slight tweak to the geometry on one of the 3\ninner triangles in each regular triangle based on\nbarycentric coordinates\n\n- pushing the geometry of the regular triangles out\nfrom the center based on the barycentric coordinates\n\n- tri planar texturing\n\n- accentuating the edges of the barycentric \ninner triangles based on some hacky logic.\n\n\n\n*/\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    //some sort of adhoch antialiasing based on\n    //an anisotrpic effect by:ulianlumia\n    //unstable universe - https://www.shadertoy.com/view/wtlfz8\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(0.);\n    float f = length(uv  - 0.6);\n    \n    fragColor.xyz += T(uv + f*0.002).xyz;\n    fragColor.xyz += T(uv -f*0.002).xyz;\n    fragColor.xyz += T(uv-f*0.003).xyz;\n    fragColor.xyz /= 3.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi acos(-1.)",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define FAR 30.\n\n/*\n\nCode (or the logic) is a mess, \nhopefully only for now.\n\nfeatures of this shader:\n\n- Shane's Lighting\n\n- A slight tweak to the geometry on one of the 3\ninner triangles in each regular triangle based on\nbarycentric coordinates\n\n- pushing the geometry of the regular triangles out\nfrom the center based on the barycentric coordinates\n\n- tri planar texturing\n\n- accentuating the edges of the barycentric \ninner triangles based on some hacky logic.\n\n\n\n*/\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    p/=1.9;\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n \n    return f*1.3;\n}\n\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nvec3 snoise3( in float x )\n{\n#if 1    \n    return -1.0 + 2.0*textureLod( iChannel2, vec2(x,4.5)/256.0, 0.0 ).xyz;\n#else    \n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return -1.0 + 2.0*mix( hash3(p+0.0), hash3(p+1.0), f );\n#endif    \n}\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat seggy( vec3 P, vec3 A, vec3 B){\n    \n    //dist auf line segment zu punkt\n    //nahrest dist auf line zu punkt\n    //P = A + t*(B-A);\n    //dot((P-P3),(B-A)) = 0\n    //(A+t*(B-A)-P3)*(B-A)) = 0;\n    //A*(B-A)+t*(B-A)*(B-A)-P3*(B-A) = 0\n    //A*(B-A) - P3*(B-A) + t*(B-A)*(B-A)\n    //(A-P3)*(B-A) + t*(B-A)*(B-A)\n    //t = dot((A-P3),(B-A)) / dot((B-A),(B-A));\n    vec3 AP = P-A;\n    vec3 BA = B-A;\n    \n    float t = clamp(dot(AP,BA)/\n                    dot(BA,BA), \n                    0., 1.);\n                    \n    vec3 P3 = A + t*BA;                \n    float dist = length(P - P3) - 0.02;\n    return dist;\n}\n\n\nvec2 planeVonTri(vec3 p, vec3 A, vec3 B, vec3 C){\n    \n    vec3 BA = A - B;\n    vec3 CA = A - C;\n    vec3 n  = normalize(cross(BA,CA));\n    //where is the intersection of line and plane?\n    //plane = dot(n,P) = 0\n    //line = ro + rd*t = P\n    float t = dot(n,p-A);\n    \n    //dist from point to line AB, BC, and CA\n    float dAB = length(cross(p-A, B-A));\n    float dBC = length(cross(p-B,C-B));\n    float dCA = length(cross(p-C, A-C));\n\n    //I'm pretty certain there is an easier way to do this\n    //I'l have to experiment with it later\n    float edgeLines = min(\n        abs(dAB - dBC)/(1.-float(dCA < min(dAB,dBC))),\n    min(abs(dBC - dCA)/(1.-float(dAB < min(dBC,dCA))),\n        abs(dCA - dAB)/(1.-float(dBC < min(dCA,dAB)))\n        ));\n\n                      \n    float bumpLines = min(dAB,min(dBC,dCA));\n    \n    float oppLines = max(dAB,max(dBC,dCA));\n    float distCenter = bumpLines;\n    float planeHeight = t - distCenter/2.;\n    if(distCenter == dAB) planeHeight += sin(distCenter*100.)/400. ;\n \n return vec2(planeHeight, edgeLines*2.);\n \n}\n\n\nmat2 rot(float a){\n    float cs = cos(a),si = sin(a);\n    return mat2(cs, si, -si, cs);\n}\n\n\nfloat objectID = 0.;\nfloat glow = 0.;\n\n//FROM DAVE HOSKINS\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//FROM DAVE HOSKINS\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nvec3 objColGlobal = vec3(0.);\n\nfloat map(vec3 p){\n\n    p*= 0.9;\n    p.xz *= mat2(1.1547, 0., 1.1547*0.5,1.);\n    float sphere_radius = 0.35;\n    vec3 sp = p;\n    float alle = 100.;\n\n    \n    sp.xz = fract(p.xz)-0.5;\n    vec2 id = floor(p.xz);\n    float ball_gross = fract(sin(dot(vec2(12.55,74.2),id))*452354.);\n    float t = 0.;//iTime;\n    \n    float gross = 1.3;\n    \n    float height = fbm4(id+t)*gross;\n    float heightL = fbm4((id + vec2(0.,1.))+t)*gross;\n    float heightR = fbm4((id + vec2(0.,-1.))+t)*gross;\n    float heightV = fbm4((id + vec2(-1.,0.))+t)*gross;\n    float heightH = fbm4((id + vec2(1.,0.))+t)*gross;\n    \n    \n    float k = seggy(sp, vec3(0.,height,0.), vec3(-1.,heightV,0.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0., heightL,1.0));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(0.,heightR,-1.));\n    alle = smin(alle, k, 0.);\n    k = seggy(sp, vec3(0.,height,0.), vec3(1.0,heightH,0.0));\n    alle = smin(alle, k, 0.);\n    \n\n    \n    vec3 st = p;\n    \n    //HERE:\n    //I create a new shifted coord system so that I can get \n    //that pesky diagonal segment\n    st.xz = fract(p.xz-0.5)-0.5;\n    vec2 id2 = floor(p.xz-0.5);\n    \n    \n    //for floor here, actually:\n    //the mid point is the + 0.5,0.5\n    //the bottom is 0,0 because that is the floor value, id\n    //and the top would have to be + 1.,1.\n    \n    float heightDB = fbm4(id2 +t)*gross;\n    float heightDT = fbm4(id2 + vec2(1.) +t)*gross;\n    \n    /////\n    float heightTLT = fbm4(id2 + vec2(0.,1.) +t)*gross;\n    float heightBRB = fbm4(id2 + vec2(1.,0.) +t)*gross;\n    \n    //float heightMD = fbm4(id2 - vec2(0.5))*gross;\n    \n    //THE DIAGONAL\n    k = seggy(st, vec3(-0.5, heightDB, -0.5), \n                  vec3( 0.5, heightDT,  0.5) );\n                  \n    alle = smin(alle, k, 0.);\n    \n    //check which side of the diagonal of the square we are on\n    //and make a plane with the three coordinates of that triangle\n    \n    vec2 pl = st.x < st.z \n    \n                         ?\n                        \n               planeVonTri(st,\n                     vec3( 0.5, heightDT,  0.5),\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3(-0.5, heightTLT, 0.5) )\n                     \n                         : \n                        \n               planeVonTri(st,\n                     //you need to have this exact order for A,B and C!\n                     vec3(-0.5, heightDB, -0.5),\n                     vec3( 0.5, heightDT,  0.5),\n                     \n                     vec3( 0.5, heightBRB, -0.5) );\n    \n    //calculate colors\n    float colID = hash12(floor(p.xz - 0.5)*80. + sign(st.x-st.z)*80.)+0.2;\n    objColGlobal = vec3(colID*0.1,colID*0.4,colID)/1.;\n    objColGlobal = mix(objColGlobal, \n                   vec3(0.3,0.6,1.)*1., \n                   smoothstep(0.03,0.02,pl.y)*5.);\n    \n    //kind of a Shane x Nusan hybrid ID check\n    if(pl.x < 0.005){\n       // glow += 0.0001/pow(pl,0.2);\n        objectID = 1.;   \n    }\n   if(objColGlobal.x > 1. && objectID == 1.) objectID = 2.;//glow += 0.005/pow(pl.x,2.)*0.003;\n    alle = min(alle, pl.x );\n\n   //\n   //alle = min(alle, length(st)-0.15);\n    return alle;// min(alle, sp.y+0.7-fbm4(p.xz));\n    \n}\n\n//FROM SHANE\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n//FROM SHANE\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 14; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//FROM SHANE?\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nvec3 triPlanar(vec3 p, vec3 n){\n\n    n = max(abs(n), 0.001);\n    float sum = n.x+n.y+n.z;\n    n = n/sum;\n    \n    vec3 tex = texture(iChannel1,p.xy).rgb * n.z +\n               texture(iChannel1,p.yz).rgb * n.x + \n               texture(iChannel1,p.xz).rgb * n.y ;\n                    \n    return tex;\n}\n\n//FROM SHANE!\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = objectID == 1.? \n    objColGlobal*triPlanar(sp,sn).x :\n    vec3(.3,0.18,0.04)*0.7;\n    if(objectID == 2.) objCol = vec3(0.3,0.6,1.)*.9;\n    //objCol = objectID == 2. ? vec3(1.) : \n      //    objCol;//getObjectColor(sp);\n   // if(objectID == 2.) objCol = vec3(1.);\n    \n    float specFact = objectID == 1. ? 8. : 2.;\n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff*8. ) + vec3(.8, .5, .2)*spec*specFact) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, pow(t/FAR,5.));\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n   // sceneCol = glow*0.2;\n    sceneCol = mix(sceneCol, vec3(0.), fogF); \n\n   // sceneCol = mix(sceneCol, sceneCol, clamp(.2-fogF,0.,1.)); \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.yz *= rot(-0.5);\n\n    // Some cheap camera movement, for a bit of a look around. I use this far\n    // too often. I'm even beginning to bore myself at this point. :)\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 4. + sin(iTime)*0.1, -4.5 + iTime*2.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., 3.5);\n    \n    vec3 sceneColor;\n    float t = trace(ro, rd);\n    //sceneColor = mix(sceneColor, vec3(0.3,0.051,0.), clamp(pow(t/FAR, 20.),0.,1.));\n    if(t < FAR){\n    ro += rd*t;\n    vec3 sn = getNormal(ro);\n    sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n    \n    sceneColor *= sh;\n\n    }\n    else{\n    \n    sceneColor = vec3(0.);\n    }\n   \n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0;\n    \n    vig = pow(vig, 0.15);\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor*vig, 0., 1.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}