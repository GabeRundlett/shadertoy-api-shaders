{
    "Shader": {
        "info": {
            "date": "1564737184",
            "description": "gerstner test",
            "flags": 0,
            "hasliked": 0,
            "id": "WtSXzz",
            "likes": 22,
            "name": "gerstner test",
            "published": 3,
            "tags": [
                "raymarching",
                "gerstner"
            ],
            "usePreview": 0,
            "username": "dagbrynildsentholander",
            "viewed": 826
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\n\tprecision mediump float;\n#endif\n\n// resolution in pixels\nuniform vec2 resolution;\n\n//affine transformation matrix of eye in camera space\nuniform mat4 eye;\n\nfloat pi = 3.14159;\n\nvec3 lightdir = vec3(1,-.4,1);\nvec3 lightcol = vec3(1, .85, .8);\n\nfloat noise(vec2 p)\n{\n    return fract(sin(p.x*16.+p.y*6463.)*200.);\n}\n\nfloat valueNoise(vec2 p)\n{\n    vec2 id = floor(p*10.);\n    vec2 ld = fract(p*10.);\n    \n    ld = ld*ld*(3.-2.*ld);\n    \n    float bl = noise(id);\n    float br = noise(id+vec2(1., 0.));\n    float b = mix(bl, br, ld.x);\n    \n    float tl = noise(id+vec2(0., 1.));\n    float tr = noise(id+vec2(1., 1.));\n    float t = mix(tl, tr, ld.x);\n    \n    float bt = mix(b, t, ld.y);\n    \n    return bt;\n}\n\nfloat wave(vec3 p, float a, float wavelength, vec2 dir) \n{\ndir = normalize(dir) ;\nfloat k = 2.*pi/wavelength;\nfloat c = sqrt(9.8 / k);\nfloat f = k*(dot(dir, p.xz) -(iTime*c));\n\nreturn a*sin(f-2.*a*cos(f));\n} \n\nfloat map(vec3 p)\n{\n   float base = 0.;\n   base += wave(p,0.8, 40., vec2(1,1) );\n   base += wave(p, 0.6, 30., vec2(0.8,1)); \n   base += wave(p, 0.08, 20., vec2(1,.8));\n    base += wave(p, 0.08, 10., vec2(.9,.9));\n     base += wave(p, 0.03, 5., vec2(1,.9));\n    base += wave(p, 0.04, 8., vec2(1,.9));\n    base += .015*sin((p.x+p.z*.5) *1.);\n   base += .01*sin((p.z+p.x*.5) *2.);\n   base +=.003*sin((p.x+.8+p.z)*3.);\n   return base -p.y;\n}\n\nvec3 getNormal(vec3 position) {\n    vec3 e = vec3(0.03,0.0,0.0);\n\n    return -normalize(vec3(\n       map(position + e.xyz) - map(position - e.xyz),\n       map(position + e.yxz) - map(position - e.yxz),\n       map(position + e.yzx) - map(position - e.yzx)));\n} \n\nvec2 ray(vec3 ro, vec3 rd, float dt, float mind, float maxd) \n{\n   float i = mind;\n   //float wi = 0.;\n   float lastVal = 0.;\n   //float lastValW = 0.;\n   vec3 p = ro+rd*i;\n   \n   while(i < maxd) \n   {\n      float val = map(p);\n      //float valW = waterHeight(p);\n      if(val>0.0 )\n         return vec2(i-(abs(val)/(abs(val)+abs(lastVal)))*dt, 0.);\n         \n      i += dt;\n      //if(waterHeight(p)>0.0) \n         //wi+=dt;\n      p = ro + rd*i;\n      dt *= 1.02;\n      lastVal = val;\n      //lastValW = valW;\n   } \n   return vec2(80., 0.);\n} \n\nvec3 drawSky(vec3 ro, vec3 rd) \n{\n   vec3 base = mix(vec3(.75,.5,.55),vec3(.6,.62,.8),rd.y*2.);\n   base += vec3(.9,.3,.2)*clamp(pow(1.-rd.y, 3.)*dot(rd,-normalize(lightdir)),0.,1.);\n   float sunDot = clamp(dot(rd, -normalize(lightdir)), 0. ,1. );\n   base +=.2*sunDot*vec3(.8,.5,.45);\n   base +=.4*pow(sunDot,25.)*lightcol;\n   base += .5*pow(sunDot, 64.)*lightcol;\n   base += 10.*pow(sunDot, 512.)*lightcol;\n   base -=.3*pow(valueNoise(rd.xz/rd.y/30.), 5.) *clamp(rd.y*5.,0.,1.);\n   base -=.7*pow(valueNoise(rd.xz/rd.y/40.), 3.) *clamp(rd.y*5.,0.,1.);\n   return base;\n} \n\nvec3 drawWater(vec3 ro, vec3 rd, float d, float ud) \n{\n   vec3 p = ro + rd*d;\n   vec3 normal = getNormal(p);\n   vec3 reflCol = drawSky(p, reflect(rd, normal) );\n   vec3 base = mix(reflCol, mix(vec3(.15,.2,.4)*.5, vec3(.4,.7,.8), clamp((p.y/1.5+.5) * dot(-rd, lightdir) ,0.,1.)) ,pow(dot(rd, -normal),1.));\n  \n   return base;\n}\n\nvec3 drawLand(vec3 ro, vec3 rd, float d) \n{\n   vec3 p = ro + rd*d;\n   vec3 normal = getNormal(p);\n   vec3 reflCol = drawSky(p, reflect(rd, normal) );\n   vec3 base = vec3((dot(normal, -lightdir)+1.)/2.);\n  \n   return base;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\t vec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 eyep = vec3(sin(iMouse.x/iResolution.x*2.), iMouse.y/iResolution.y, cos(iMouse.x/iResolution.x*2.))*10.;//eye[3].xyz;\n  vec3 up = normalize(vec3(0, 1, 0));//eye[1].xyz;\n  vec3 forward = normalize(-eyep);//normalize(vec3(sin(iMouse.x/250.), 0, cos(iMouse.x/250.)));//eye[2].xyz;\n  vec3 right = -cross(forward, up);//eye[0].xyz;\n\n  //ray.direction = normalize(eye * vec4(uv.x,uv.y,-1.,1.)).xyz\n  vec3 rd = normalize(forward + ((right * uv.x) + (up * uv.y)));\n  vec3 ro = eyep;\n\n  vec2 rayResult = ray(ro, rd, 0.2, 0.5, 80.);\n  vec3 finalColor = mix(drawWater(ro, rd, rayResult.x, rayResult.y) , drawSky(ro, rd), pow(rayResult.x/80., 4.) ) ;\n  fragColor = vec4(finalColor.xyz, 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}