{
    "Shader": {
        "info": {
            "date": "1495767973",
            "description": "Korean version of https://www.shadertoy.com/view/Md23DV ",
            "flags": 0,
            "hasliked": 0,
            "id": "XtySDz",
            "likes": 9,
            "name": "Shadertoy 튜토리얼 한글번역",
            "published": 3,
            "tags": [
                "tutorial",
                "korean"
            ],
            "usePreview": 0,
            "username": "ho4040",
            "viewed": 1829
        },
        "renderpass": [
            {
                "code": "/*\n원문 : https://www.shadertoy.com/view/Md23DV \n번역 : General Choi (github: ho4040)\n\n안녕하세요, 한달전에 GLSL을 시작했습니다. GPU를 이용한 빠른 리얼타임 그래픽들이 놀랍네요.\n쉐이더를 작성하는 것을 배우고 싶으신 분들께 이 튜토리얼은 좋은 시작점이 될 겁니다.\n단어에러나 코딩에러가 있다면 고쳐주세요. :-)\n\n*/\n\n// 아래 번호를 바꾸고 다시 컴파일하면 튜토리얼을 선택할 수 있습니다.\n#define TUTORIAL 0\n\n/* 튜토리얼 목록\n 1 빈 화면.\n 2 균일 색상.\n 3 GLSL 벡터\n 4 RGB 색상 모델과 벡터의 요소들\n 5 좌표계\n 6 해상도와 프레임 사이즈 \n 7 좌표게 변환\n 8 수평선, 수직선\n 9 VISUALISING THE COORDINATE SYSTEM\n10 MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n11 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n12 DISK\n13 FUNCTIONS\n14 BUILT-IN FUNCTIONS: STEP\n15 BUILT-IN FUNCTIONS: CLAMP\n16 BUILT-IN FUNCTIONS: SMOOTHSTEP\n17 BUILT-IN FUNCTIONS: MIX\n18 ANTI-ALIASING WITH SMOOTHSTEP\n19 FUNCTION PLOTTING\n20 COLOR ADDITION AND SUBSTRACTION\n21 COORDINATE TRANSFORMATIONS: ROTATION\n22 COORDINATE TRANSFORMATIONS: SCALING\n23 SUCCESSIVE COORDINATE TRANSFORMATIONS\n24 TIME, MOTION AND ANIMATION\n25 PLASMA EFFECT\n26 TEXTURES\n27 MOUSE INPUT\n28 RANDOMNESS\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// 빈화면.\n//\n// \"main\" 함수는 쉐이더 효과를 출력하기 위해서 매초 마다 수십회 호출됩니다. \n// 컴퓨터 시스템은 초당 60 프레임(60FPS)을 출력하려고 노력합니다.\n// 하지만 GLSL 스크립트가 계산이 빡세지면 이 숫자는 더 낮아질 수 있습니다.\n// (FPS는 화면 아래쪽 정보 바 에 표시됩니다.)\n//\n// 우리가 아무것도 안할거기 때문에 이 쉐이더는 그냥 검은 화면을 보여줍니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif TUTORIAL == 2\n// 균일 색상\n//\n// \"fragColor\" 는 쉐이더의 출력입니다.\n// 이 값이 화면에 보여지는 이미지를 결정하게 됩니다.\n// 이 쉐이더는 이 값을 노란색으로 지정합니다.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1.0, 1.0, 0.0 ,1.0);\n}\n\n\n#elif TUTORIAL == 3\n// GLSL 벡터들\n// \n// \"fragColor\" 는 vec4 객체에 할당되어야 합니다.\n// 이건 0~1 사이 실수 값이 담긴 4개 짜리 배열 입니다.\n// 앞에 3 개의 숫자는 색상을 지정 하고 4번째 숫자는 \n// 불투명도(opactiy) 를 지정 합니다.\n// (당장은 4 번째 투명도 값은 아무런 효과도 없습니다.)\n// 하나의 vec2 객체는 4개의 float 을 인자로 받아 생성되거나.\n// 아래처럼, vec3 와 float. 2개의 인자를 생성자 인자로 받아 생성됩니다.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Here we are seperating the color and transparency parts\n\t// of the vec4 that represents the pixels.\n\tvec3 color = vec3(0.0, 1.0, 1.0);\n\tfloat alpha = 1.0;\n\t\n\tvec4 pixel = vec4(color, alpha);\n\tfragColor = pixel;\n}\n\n#elif TUTORIAL == 4\n// RGB 색상 모델 과 벡터의 구성요소들\n//\n// 벡터를 초기화 하고나면, 각 요소들은 \".\" 표현을 이용해서 접근 할 수 있습니다.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// 색상 하나는 3개의 숫자(0부터 1사이 값)로 표현됩니다. \n// 이 모델은 순수한 빨강, 초록, 파랑 색의 빛을 각각 강도를 달리 하여 합한 것으로 취급합니다.\n// \n// 만약에 저처럼 디자인 스킬이 후지고, 색상의 조합이 간지나게 만들기가 힘들다면\n// 이 웹사이트들을 참고해보세요 여러가지 색상 조합을 살펴 볼 수 있습니다.\n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 아래 숫자들을 바꿔가며 놀아보세요:\n\tfloat redAmount = 0.6; // 빨간색의 세기\n\tfloat greenAmount = 0.2; // 초록색의 세기\n\tfloat blueAmount = 0.9; // 파란색의 세기\n\t\n\tvec3 color = vec3(0.0); \n\t\n\t// 이건 인자 하나만 쓰는 세번째 벡터 생성 방법입니다.\n\t// \"vec3(x)\" 은 \"vec3(x, x, x)\" 랑 똑같습니다.\n\t// 이 벡터는 아래 방법으로 초기화 했습니다.\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 5\n// 좌표계\n//\n// \"fragCoord\", \"fragment coordinate\" 는 입력 변수입니다.\n// 이걸 통해서 지금 계산하는 값이 어느 위치에 보여줄 픽셀인지 알 수 있습니다.\n// 이 좌표계의 중심은 좌측 하단 이고 오른쪽 상단이 값이 증가하는 방향입니다.\n// \n// main 함수는 는 화면의 모든 픽셀에 대응되어서 실행이 됩니다.\n// 각 호출에서 \"gl_FragCoord\"는 각 픽셀의 위치에 해당합니다.\n//\n// GPUs 는 여러개의 코어를 가지고 있어서 동시에 병렬 호출되어고 여러개의\n// 픽셀이 동시에 계산되는게 가능합니다.\n// 따라서 CPU에서 하나 하나씩 계산하는 것보다 빠른 속도를 보여줄 수 있습니다.\n// 하지만 이 때문에 여기에는 중요한 제약이 따라옵니다.\n// 하나의 픽셀값은 다른 픽셀값에 의해서 결정 될 수 없습니다. (각 픽셀이 동시에 병렬로 \n// 계산이 되기 때문에 어떤 픽셀이 먼저 계산 될지 알 수 엇습니다.)\n// 픽셀의 출력은 픽셀의 좌표에 의해 결정됩니다. (그리고 추가 다른 인풋들)\n// 이것이 쉐이더 프로그래밍에서 가장 중요한 차이점입니다. 이 것을 아마 계속 마주치게 될 것 입니다.\n//\n// 균일 색상이 아닌 뭔가를 그려보도록 하죠.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// 생상을 선택합니다.\n\tvec3 color1 = vec3(0.886, 0.576, 0.898);\n\tvec3 color2 = vec3(0.537, 0.741, 0.408);\n\tvec3 pixel;\n\n\t// x 좌표가 100 보다 크면 color1을 찍습니다.\n\t// 아니면 color 2를 찍습니다.\n\tfloat widthOfStrip = 100.0;\n\tif( fragCoord.x > widthOfStrip ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 6\n// 해상도, 프레임 사이즈\n//\n// 브라우저 크기를 조절하거나 풀스크린모드로 갔다가 돌아오면\n// 첫번째 색과 두번째색 폭의 비율이 달라지는 걸 볼 수 있습니다.\n// 이건 화면 비율에 따라서 값을 지정하지 않고 몇 픽셀인지 절대값을 지정하기 때문입니다.\n// \n// 우리가 두가지 색으로 화면을 이등분 한다고 해보면,\n// 화면 크기를 알기 전까지는 몇 픽셀로 해야할지 결정을 할 수가 없게 됩니다.\n//  \n// 어떻게 화면 크기(폭과 높이)를 픽셀단위로 얻어올까요.\n// 이건 \"iResolution\" 이라는 변수로 주어지게 됩니다.\n// \"iResolution.x\" 는 화면 프레임의 폭\n// \"iResolution.y\" 는 화면 프레임의 높이가 됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(0.741, 0.635, 0.471);\n\tvec3 color2 = vec3(0.192, 0.329, 0.439);\n\tvec3 pixel;\n\n\t// if 문 대신 3항 연산자로 편하게 표현합니다.\n\t// x 좌표가 화면 폭의 절반이 넘어가면 color1을 사용하고\n\t// 아니면 color2를 사용.\n\tpixel = ( fragCoord.x > iResolution.x / 2.0 ) ? color1 : color2;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 7\n// 좌표계 변형\n// 화면 좌표 시스템 보다는 우리가 직접 지정한 좌표계가 \n// 더 편한 경우가 대부분일겁니다.\n//\n// \"fragCoord\"라는 화면의 절대좌표계 대신에\"r\" 이라는 새로운 좌표계를 만들겠습니다.\n// \"r\" 에서는 x값과 y값은 는 0 에서 1 사이 값을 가집니다.\n// x값이 0 이면 좌측끝을 1이면 우측끝을 의미합니다. y 값이 0이면 아래쪽끝을\n// 1이면 위쪽끝을 의미합니다.\n//\n// \"r\" 을 사용하여 화면을 3 둥분 하도록 하겠습니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t\n\t// r 은 vec2 입니다. 이 벡터의 첫번째 값(x값) 픽셀의x값(fragCoord.x)값을 화면폭으로 나눈 값 입니다.\n\t// 벡터의 두번째 값(y값)은 픽셀위치(fragCoord.y) 을 화면 높이로 나눈 값 이니다.\n\n\t// 예를들어, 제 노트북에서는, 전체화면시 화면크기는 \n\t// 1440 x 900 입니다. 그래서 iResolution 은 (1440.0, 900.0) 이 됩니다.\n\t// 한 프레임을 그리기 위해서 1400*1900=1296000 번이나 메인함수가 호출되어야 합니다.\n\t// fragCoord.x 는 0에서 1439 사이의 값을 가질 수 있을 것이교\n\t// fragCoord.y 는 0에서 899, r.x 와 r.y는 0에서 1 사이 값 이 될 것입니다.\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t\n\t// 1:1:1 로 화면비율에 따라서 색을 지정합니다.\n\t// (역주) 원글에 주석이 잘못달려있네요.\n\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// 위처럼 3항 연산자를 이용해서 간단하게 표현도 가능합니다.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 8\n// 수평선과 수직선\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t// 짧은 버젼의 좌표계번환.\n\t// \"aVector.xy\" 은 \"aVector\" 의 처음 두번째 요소로 만들어진 새로운 벡터입니다. \n\t// 그리고 나누기 연산을 벡터끼리 하게되면\n\t// 첫번째 벡터의 각 요소는 두번째 벡터의 각 요소로 나누어 지게 됩니다. (x는 x끼리 y는 y끼리)\n\t// 그래서 이 튜토리얼의 첫번째줄은 이전 튜토리얼의 첫번째 줄과 같습니다.\n\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.216, 0.471, 0.698);\n\tvec3 color2 = vec3(1.00, 0.329, 0.298);\n\tvec3 color3 = vec3(0.867, 0.910, 0.247);\n\t\n\t// 먼저 배경색(backgroundColor)을 지정합니다. 다른 색이 사용되지 않으면 이 색을 사용합니다.\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// 현재 픽셀의 x값이 아래 값들의 사이 값 이라면 color1 을 사용합니다.\n\t// 0.55와 0.54의 차가 라인의 폭을 결정하게 됩니다.\n\t\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif( r.x < rightCoord && r.x > leftCoord ) pixel = color1;\n\t\n\t\n    // 수직선을 다른 방식의 표현한 것 입니다.\n    // x 좌표와 두께 를 이용한 표현:\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(r.x - lineCoordinate) < lineThickness) pixel = color2;\n\t\n\t// 수평선\n\tif(abs(r.y - 0.6)<0.01) pixel = color3;\n\t\n\t// 3번째 수평선이 위의 두 선 위로 어떻게 지나가는지 확인해보세요.\n\t// 마지막으로 \"pixel\" 값이 지정되었기 때문에 제일 위에 놓인 선이 됩니다.\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 9\n// 좌표계 시각화\n//\n// for 루프와 수평선, 수직선을 이용하여 그리드(격자무늬) 그려보도록 하겠습니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// 배경색을 지정하면서 시작합니다. 만약에 다른 값으로 할당 되지 않으면\n\t// 이 색이 화면에 보여지게 됩니다.\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드의 선을 그립니다.\n\t// 루프는 상수 표현으로만 조절 할 수 있어서 'const' 를 사용하게 됩니다.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" 라인 좌표입니다.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// 축을 그립니다.\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 10\n// 좌표계 중심을 프레임중심으로 옮기기\n//\n// [0, iResolution.x]x[0, iResolution.y]영역 대신\n// [0,1]x[0,1]영역을 [-1,1]x[-1,1] 로 맵핑합니다.\n// 이 방법을 쓰면 (0,0)은 왼쪽 하단이 아니고 화면 중앙이 됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tr = 2.0 * r.xy / iResolution.xy;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// 배경색을 지정하면서 시작합니다. 만약에 다른 값으로 할당 되지 않으면\n\t// 이 색이 화면에 보여지게 됩니다.\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드를 출력.\n\t// 이번에는 루프를 이용해 모든 픽셀을 검사하지 않고\n    // 나머지 연산을 이용해서 한번의 계산으로 같은 결과를 얻어보겠습니다. (mikatalk님 감사합니다.)\n\tconst float tickWidth = 0.1;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n    // Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 11\n//좌표계에 화면비율 만들기 1.0\n//\n// 이전 예제에서는 화면에 정사각형이 그려지지 않고 직사각형이 그려지게 됩니다.\n// 이것은 수치적으로는 [0,1]로 두 축이 같지만 물리적 거리는 다르기 때문입니다.\n// 사실 가로가 세로보다 더 큽니다.\n// 따라서 화면비율을 유지하기 위해서는 실제 거리인 \n// [0,iResolution.x] 와 [0, iResolution.y] 를 같은 간격으로 맵핑하면 안됩니다.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// r.x를 iResolution.x 로 나누고 r.y를 iResolution.y로 나누는 것 대신\n\t// 둘다 iResolution.y로 나눕니다.\n\t// 이 방법으로 하면 r.y는 [-1.0, 1.0] 이 되고\n\t// r.x 는 프레임 사이즈에 따라 달라지게 됩니다.\n\t// 전체화면이 아닌 경우에는 r.x 는 [-1.78,1.70] 정도일거고, 제가 가진 노트북 전체화면 모드에선\n\t// [-1.6, 1.6]이 됩니다.(1440./900=1.6)\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// 그리드를 그립니다.\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" 는 라인의 좌표입니다.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// 축을 그립니다.\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 12\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = col1;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = col3;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = col2;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n\n#elif TUTORIAL == 13\n// FUNCTIONS\n//\n// Functions are great for code reuse. Let's put the code for disks\n// into a function and use the function for drawing.\n// There are so many different ways of writing a function to draw a shape.\n//\n// Here we have a void function that does not return anything. Instead,\n// \"pixel\" is taken as an \"inout\" expression. \"inout\" is a unique\n// keyword of GLSL.\n// By default all arguments are \"in\" arguments. Which\n// means, the value of the variable is given to the function scope\n// from the scope the function is called. \n// An \"out\" variable gives the value of the variable from the function\n// to the scope in which the function is called.\n// An \"inout\" argument does both. First the value of the variable is\n// sent to the function as its argument. Then, that variable is\n// processed inside the function. When the function ends, the value\n// of the variable is updated where the function is called.\n//\n// Here, the \"pixel\" variable that is initialized with the background\n// color in the \"main\" function. Then, \"pixel\" is given to the \"disk\"\n// function. When the if condition is satisfied the value of the \"pixel\"\n// is changed with the \"color\" argument. If it is not satified, the\n// \"pixel\" is left untouched and keeps it previous value (which was the\n// \"bgColor\".\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tdisk(r, vec2(0.1, 0.3), 0.5, col3, pixel);\n\tdisk(r, vec2(-0.8, -0.6), 1.5, col1, pixel);\n\tdisk(r, vec2(0.8, 0.0), .15, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// As you see, the borders of the disks have \"jagged\" curves, where\n// individual pixels can be seen. This is called \"aliasing\". It occurs\n// because pixels have finite size and we want to draw a continuous\n// shape on a discontinuous grid.\n// There is a method to reduce the aliasing. It is done by mixing the\n// inside color and outside colors at the border. To achieve this\n// we have to learn some built-in functions.\n\n// And, again, note the order of disk function calls and how they are\n// drawn on top of each other. Each disk function manipulates\n// the pixel variable. If a pixel is manipulated by multiple disk\n// functions, the value of the last one is sent to fragColor.\n\n// In this case, the previous values are completely overwritten.\n// The final value only depends to the last function that manipulated\n// the pixel. There are no mixtures between layers.\n\n\n#elif TUTORIAL == 14\n// BUILT-IN FUNCTIONS: STEP\n//\n// \"step\" function is the Heaviside step function :-)\n// http://en.wikipedia.org/wiki/Heaviside_step_function\n// \n// f(x0, x) = {1 x>x0, \n//            {0 x<x0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6*xMax) { // Part I\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ) { // if the \"variable\" is greater than \"edge\"\n\t\t\tret = 1.0;          // return 1.0\n\t\t} else {                // if the \"variable\" is less than \"edge\"\n\t\t\tret = 0.0;          // return 0.0\n\t\t}\n\t} \n\telse if(r.x < -0.2*xMax) { // Part II\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\tret = step(edge, variable); // step function is equivalent to the\n\t\t                            // if block of the Part I\n\t} \n\telse if(r.x < 0.2*xMax) { // Part III\n\t\t// \"step\" returns either 0.0 or 1.0.\n\t\t// \"1.0 - step\" will inverse the output\n\t\tret = 1.0 - step(0.5, r.y); // Mirror the step function around edge\n\t} \n\telse if(r.x < 0.6*xMax) { // Part IV\n\t\t// if y-coordinate is smaller than -0.4 ret is 0.3\n\t\t// if y-coordinate is greater than -0.4 ret is 0.3+0.5=0.8\n\t\tret = 0.3 + 0.5*step(-0.4, r.y);\n\t}\n\telse { // Part V\n\t\t// Combine two step functions to create a gap\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y));\n\t\t// \"1.0 - ret\" will create a gap\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 15\n// BUILT-IN FUNCTIONS: CLAMP\n//\n// \"clamp\" function saturates the input below and above the thresholds\n// f(x, min, max) = { max x>max\n//                  { x   max>x>min\n//                  { min min>x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 0.25) { // Part I\n\t\tret = p.y; // the brightness value is assigned the y coordinate\n\t\t           // it'll create a gradient\n\t} \n\telse if(p.x < 0.5) { // Part II\n\t\tfloat minVal = 0.3; // implementation of clamp\n\t\tfloat maxVal = 0.6;\n\t\tfloat variable = p.y;\n\t\tif( variable<minVal ) {\n\t\t\tret = minVal;\n\t\t}\n\t\tif( variable>minVal && variable<maxVal ) {\n\t\t\tret = variable;\n\t\t}\n\t\tif( variable>maxVal ) {\n\t\t\tret = maxVal;\n\t\t}\n\t} \n\telse if(p.x < 0.75) { // Part III\n\t\tfloat minVal = 0.6;\n\t\tfloat maxVal = 0.8;\n\t\tfloat variable = p.y;\n\t\tret = clamp(variable, minVal, maxVal);\n\t} \n\telse  { // Part IV\n\t\tfloat y = cos(5.*TWOPI*p.y); // oscillate between +1 and -1\n\t\t                             // 5 times, vertically\n\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\tret = clamp(y, 0.2, 0.8);\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 16\n// BUILT-IN FUNCTIONS: SMOOTHSTEP\n//\n// \"smoothstep\" function is like step function but instead of a\n// sudden jump from 0 to 1 at the edge, it makes a smooth transition\n// in a given interval\n// http://en.wikipedia.org/wiki/Smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\tfloat edge = 0.5;\n\t\tret = step(edge, p.y); // simple step function\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// linearstep (not a builtin function)\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (p.y - edge0)/(edge1 - edge0);\n\t\t// when p.y == edge0 => t = 0.0\n\t\t// when p.y == edge1 => t = 1.0\n\t\t// RHS is a linear function of y\n\t\t// so, between edge0 and edge1, t has a linear transition\n\t\t// between 0.0 and 1.0\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t// t will have negative values when t<edge0 and\n\t\t// t will have greater than 1.0 values when t>edge1\n\t\t// but we want it be constraint between 0.0 and 1.0\n\t\t// so, clamp it!\t\t\n\t\tret = t1;\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// implementation of smoothstep\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t// previous interpolation was linear. Visually it does not\n\t\t// give an appealing, smooth transition.\n\t\t// To achieve smoothness, implement a cubic Hermite polynomial\n\t\t// 3*t^2 - 2*t^3\n\t\tret = t1;\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tret = smoothstep(0.45, 0.55, p.y);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// smootherstep, a suggestion by Ken Perlin\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\t\t\n\t\t// 6*t^5 - 15*t^4 + 10*t^3\n\t\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\t\tret = t1;\n\t\t// faster transition and still smoother\n\t\t// but computationally more involved.\n\t}\t\n\t\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 17\n// BUILT-IN FUNCTIONS: MIX\n//\n// A shader can be created by first constructing individual parts\n// and composing them together.\n// There are different ways of how to combine different parts.\n// In the previous disk example, different disks were drawn on top\n// of each other. There was no mixture of layers. When disks\n// overlap, only the last one is visible.\n//\n// Let's learn mixing different data types (in this case vec3's\n// representing colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow \n\t\n\tvec3 ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\t// implementation of mix\n\t\tfloat x0 = 0.2; // first item to be mixed\n\t\tfloat x1 = 0.7;  // second item to be mixed\n\t\tfloat m = 0.1; // amount of mix (between 0.0 and 1.0)\n\t\t// play with this number\n\t\t// m = 0.0 means the output is fully x0\n\t\t// m = 1.0 means the output is fully x1\n\t\t// 0.0 < m < 1.0 is a linear mixture of x0 and x1\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// try all possible mix values \n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// use the mix function\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = mix(x0, x1, m);\n\t\tret = vec3(val);\t\t\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\t// mix colors instead of numbers\n\t\tfloat m = p.y;\n\t\tret = mix(col1, col2, m);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// combine smoothstep and mix for color transition\n\t\tfloat m = smoothstep(0.5, 0.6, p.y);\n\t\tret = mix(col1, col2, m);\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 18\n// ANTI-ALIASING WITH SMOOTHSTEP\n//\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\tfloat m;\n\t\n\tfloat radius = 0.4; // increase this to see the effect better\n\tif( r.x < -0.5*xMax ) { // Part I\n\t\t// no interpolation, yes aliasing\n\t\tm = step( radius, length(r - vec2(-0.5*xMax-0.4,0.0)) );\n\t\t// if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < -0.0*xMax ) { // Part II\n\t\t// linearstep (first order, linear interpolation)\n\t\tm = linearstep( radius-0.005, radius+0.005, length(r - vec2(-0.0*xMax-0.4,0.0)) );\n\t\t// mix value is linearly interpolated when the distance to the center\n\t\t// is 0.005 smaller and greater than the radius.\n\t\tpixel = mix(col1, bgCol, m);\n\t}\t\n\telse if( r.x < 0.5*xMax ) { // Part III\n\t\t// smoothstep (cubical interpolation)\n\t\tm = smoothstep( radius-0.005, radius+0.005, length(r - vec2(0.5*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < 1.0*xMax ) { // Part IV\n\t\t// smootherstep (sixth order interpolation)\n\t\tm = smootherstep( radius-0.005, radius+0.005, length(r - vec2(1.0*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 19\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 20\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 21\n// COORDINATE TRANSFORMATIONS: ROTATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tvec2 q;\n\tfloat angle;\n\tangle = 0.2*PI; // angle in radians (PI is 180 degrees)\n\t// q is the rotated coordinate system\n\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\n\tret = bgCol;\n\t// draw the old and new coordinate systems\n\tret = mix(ret, col1, coordinateGrid(r)*0.4 );\n\tret = mix(ret, col2, coordinateGrid(q) );\n\t\n\t// draw shapes in old coordinate system, r, and new coordinate system, q\n\tret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\tret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\t// as you see both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\t\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 22\n// COORDINATE TRANSFORMATIONS: SCALING\n//\n// Scaling the coordinate system.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\t\n\t// original\n\tfloat scaleFactor = 2.0; // zoom in this much\n\tret = mix(ret, col1, coordinateGrid(r)/2.0);\n\t// scaled\n\tvec2 q = 0.3*r;\n\tret = mix(ret, col2, coordinateGrid(q));\n\n\tret = mix(ret, col2, disk(q, vec2(0.0, 0.0), 0.1));\t\n\tret = mix(ret, col1, disk(r, vec2(0.0, 0.0), 0.1));\n\t\n\tret = mix(ret, col1, rectangle(r, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\tret = mix(ret, col2, rectangle(q, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\t\n\t// not how the rectangle that are not centered at the coordinate origin\n\t// changed its location after scaling, but the disks at the center\n\t// remained where they are.\n\t// This is because scaling is done by multiplying all pixel\n\t// coordinates with a constant.\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 23\n// SUCCESSIVE COORDINATE TRANSFORMATIONS\n//\n// Drawing a shape on the desired location, with desired size, and\n// desired orientation needs mastery of succesive application of\n// transformations.\n//\n// In general, transformations do not commute. Which means that\n// if you change their order, you get different results.\n//\n// Let's try application of transformations in different orders.\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\n\tfloat angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\tif(p.x < 1./2.) { // Part I\n\t\t// put the origin at the center of Part I\n\t\tr = r - vec2(-xMax/2.0, 0.0); \n\n\t\tvec2 rotated = rotationMatrix*r;\n\t\tvec2 rotatedTranslated = rotated - vec2(0.4, 0.5);\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(rotated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(rotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(rotatedTranslated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t} \n\telse if(p.x < 2./2.) { // Part II\n\t\tr = r - vec2(xMax*0.5, 0.0); \n\n\t\tvec2 translated = r - vec2(0.4, 0.5);\n\t\tvec2 translatedRotated = rotationMatrix*translated;\n\t\t\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(translated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(translated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(translatedRotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\t\t\n\t} \t\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 24\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 25\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(sqrt(r.x*r.x+r.y*r.y) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./10.) { // Part I\n\t\t// vertical waves\n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 2./10.) { // Part II\n\t\t// horizontal waves\n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 3./10.) { // Part III\n\t\t// diagonal waves\n\t\tret = vec3(v3);\n\t}\n\telse if(p.x < 4./10.) { // Part IV\n\t\t// circular waves\n\t\tret = vec3(v4);\n\t}\n\telse if(p.x < 5./10.) { // Part V\n\t\t// the sum of all waves\n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < 6./10.) { // Part VI\n\t\t// Add periodicity to the gradients\n\t\tret = vec3(sin(2.*v));\n\t}\n\telse if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\n\n\n#elif TUTORIAL == 26\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 27\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n#elif TUTORIAL == 28\n// RANDOMNESS\n//\n// I don't know why, but GLSL does not have random number generators.\n// This does not pose a problem if you are writing your code in\n// a programming language that has random functions. That way\n// you can generate the random values using the language and send\n// those values to the shader via uniforms.\n//\n// But if you are using a system that only allows you to write\n// the shader code, such as ShaderToy, then you need to write your own\n// pseuo-random generators.\n//\n// Here is a pattern that I saw again and again in many different\n// shaders at ShaderToy.\n// Let's draw N different disks at random locations using this pattern.\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x), hash(x * 1.1));\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.005, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.y));\n\treturn ret;\n}\n\nfloat plot(vec2 r, float y, float thickness) {\n\treturn ( abs(y - r.y) < thickness ) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec3 white = vec3(1.);\n\tvec3 gray = vec3(.3);\n\tif(r.y > 0.7) {\n\t\t\n\t\t// translated and rotated coordinate system\n\t\tvec2 q = (r-vec2(0.,0.9))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// just the regular sin function\n\t\tfloat y = sin(5.*q.x) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.1));\n\t}\n\telse if(r.y > 0.4) {\n\t\tvec2 q = (r-vec2(0.,0.6))*vec2(1.,20.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\t// take the decimal part of the sin function\n\t\tfloat y = fract(sin(5.*q.x)) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\t\n\telse if(r.y > 0.1) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0.,0.25))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// scale up the outcome of the sine function\n\t\t// increase the scale and see the transition from\n\t\t// periodic pattern to chaotic pattern\n\t\tfloat scale = 10.0;\n\t\tfloat y = fract(sin(5.*q.x) * scale) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.2));\n\t}\t\n\telse if(r.y > -0.2) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0., -0.0))*vec2(1.,10.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\tfloat seed = q.x;\n\t\t// Scale up with a big real number\n\t\tfloat y = fract(sin(seed) * 43758.5453) * 2.0 - 1.0;\n\t\t// this can be used as a pseudo-random value\n\t\t// These type of function, functions in which two inputs\n\t\t// that are close to each other (such as close q.x positions)\n\t\t// return highly different output values, are called \"hash\"\n\t\t// function.\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\n\telse {\n\t\tvec2 q = (r-vec2(0., -0.6));\n\t\t\n\t\t// use the loop index as the seed\n\t\t// and vary different quantities of disks, such as\n\t\t// location and radius\n\t\tfor(float i=0.0; i<6.0; i++) {\n\t\t\t// change the seed and get different distributions\n\t\t\tfloat seed = i + 0.0; \n\t\t\tvec2 pos = (vec2(hash(seed), hash(seed + 0.5))-0.5)*3.;;\n\t\t\tfloat radius = hash(seed + 3.5);\n\t\t\tpos *= vec2(1.0,0.3);\n\t\t\tret = mix(ret, col1, disk(q, pos, 0.2*radius));\n\t\t}\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}