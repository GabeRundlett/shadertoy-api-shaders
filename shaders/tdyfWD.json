{
    "Shader": {
        "info": {
            "date": "1607126479",
            "description": "ddsds",
            "flags": 0,
            "hasliked": 0,
            "id": "tdyfWD",
            "likes": 2,
            "name": "SimpleProceduralPattern",
            "published": 3,
            "tags": [
                "mwat"
            ],
            "usePreview": 0,
            "username": "antoinefortin",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\n\nfloat sphere(vec3  pos, float radius)\n{\t\n    pos.y -= 4.0;\n    vec3 q = pos; \n    float r = 3.0 + sin(iTime + (q.x * 6.));\n   // r += 1.0 + cos(iTime + (q.y * 5.));\n    return length(pos) - radius;\n}\n\nfloat map(vec3 pos)\n{\n    pos.x += cos(sin(iTime));\n    float planeDist = plane(pos);   \n    //pos = mod(pos + 5.0, 10.0) - 5.0;\n\treturn min(planeDist, min(sphere(pos, 4.0), sphere(pos + vec3(1.0, -3., -1.5), 5. + abs(sin(pos.x + pos.x)))));\n    \n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n    ));\n}\n\nvec3 material(vec3 pos)\n{\n    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + iTime))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec3 pos = vec3(0.0, 5.0, -15.0);\n    \n    // Rayon que l'on envoie dans l'espace pour chacuns des pixels\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));    \n    vec3 col = vec3(fract(abs(dir.y * dir.x) * 4.));\n    //col = smoothstep(-4.5, 1.75 * abs(sin(iTime)), col * vec3(.5,.5, 2.));\n    \n    for(int i = 0; i < 256; i++)\n    {\n       \tfloat d/*istance*/ = map(pos); \n       \t//  Point is near enough\n        if(d < 0.001)\n        {\t\n            \n            \n            vec3 nws = computeNormal(pos);\n\t\t\tvec3 lightpos = vec3(5.0,12., -2.);\n            vec3 lColor = vec3(.15, .4, .9);\n           \tvec3 l1 = vec3(dot(normalize(pos + (nws)), normalize(lightpos)));\n\t\t\tvec3 l2 = vec3(dot(normalize(pos + nws * 2.), normalize(lightpos + vec3(-15., 12., -5.))));\n            l2 *= vec3(3.6, .3, .2)/*Color 2*/;\n        \tcol = lColor * (l1 + l2);\n            pos.x += pos.z;\n            col *= abs(cos(iTime) + sin(pos.x * pos.y + cos(pos.z)));\n            col *= clamp(col, 0.1, .5);\n        \tbreak;\n        }\n        pos += d * dir;\n        \n        \n        \n\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(sqrt(col), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}