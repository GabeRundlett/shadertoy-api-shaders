{
    "Shader": {
        "info": {
            "date": "1679260141",
            "description": ".",
            "flags": 96,
            "hasliked": 0,
            "id": "7dBGD1",
            "likes": 26,
            "name": " â™« Blob trap",
            "published": 3,
            "tags": [
                "raymarching",
                "reflections"
            ],
            "usePreview": 0,
            "username": "patu",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "// 2021-04-01 22:28:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k ;\n}\n\n\nfloat hash(float x) {\n \treturn fract(sin(x * 4341.1) * 3123.8);   \n}\n\nfloat hash11(float p)\n{\n\tp = fract(p * .1031);\n\tp *= p + 19.19;\n\tp *= p + p;\n\treturn fract(p);\n}\n\n// method by fizzer\nvec3 hashHs(vec3 n, float seed)\n{\n\tfloat u = hash11(78.233+seed);\n\tfloat v = hash11(10.873+seed);\n\tfloat a = 6.2831853 * v;\n\tu = 2.0*u - 1.0;\n    return normalize(n+vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));    \n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r) {\n \treturn length(p) - r;   \n}\n\nfloat crate(vec3 p, float d) {\n    float sdf = max(-sdBox(p, vec3(11., d, d)), sdBox(p, vec3(10.)));\n    sdf = max(-sdBox(p.zyx, vec3(11., d, d)), sdf);\n\n    return max(-sdBox(p.yxz, vec3(11., d, d)), sdf);;   \n}\n\n\nfloat c = 0.;\nfloat vols[4] = float[](0., 0.,0., 0.);\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat blob(vec3 bp, float r) {\n    vec3 p = bp;\n    \n    bp.xzy *= 0.4;\n    bp.x -= sin(vols[2] * 10.) * 5.;\n    pR(bp.xz, iTime + vols[3] * 2.);\n    pR(bp.yx, iTime * .8 + vols[3] * 12.0);\n    \n    bp.xyz += sin(1.5*bp.yzx + vec2(0., iTime + vols[0]).xxy * 10.);\n    bp.xyz -= sin(1.5*bp.yzx + vec2(0., iTime + vols[0]).yxx * 10.) * 1.5;\n    \n    \n    bp.xzy *= .3;\n    return fSphere(bp, r);\n    \n}\n\nfloat map(vec3 p) {\n    vec3 op = p, op2=p;\n    \n    \n    \n    float sdf = max(0., -sdBox(p, vec3(45.)));\n\n    float a = sdBox(op2 + vec3(0., 31., 0.), vec3(20., 20., 20.));\n\n    sdf = mix(fSphere(op, 7.), blob(op, 1.4), vols[2]);\n\n    sdf = min(sdf, a);\n    \n    pR(op.xz, -iTime * .25);\n    \n    sdf = smin(sdf, crate(op * (1. + vols[0] * .1), 8.6 + vols[0]), 1.9);\n    sdf = min(sdf, -sdBox(p, vec3(45.)));\n    \n    return sdf;\n}\n\nfloat trace(vec3 ro, vec3 rd, int steps) {\n    float d = 1e32;\n    float s = 0.;\n    \n    for (int i = 0; i < steps; i++) {\n    \td = map(ro + rd * s);\n        \n        if (d < 0.001 || d > 30.) break;\n        s += d;\n    }\n    \n    return s;    \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;        \n        t += h;        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.8, 1.0 );\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\n\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i)) * maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nvec3 normals(vec3 p) {\n    vec3 d = vec3(0.001, 0, 0);\n \treturn normalize(\n        vec3(\n        \tmap(p + d.xyy) - map(p - d.xyy),\n            map(p + d.yxy) - map(p - d.yxy),\n            map(p + d.yyx) - map(p - d.yyx)\n        )\n    );\n}\n\nvoid image(out vec4 color, in vec2 uv)\n{\n\t\n    vols = float[](\n        texture(iChannel1, vec2(0.1, .2)).r,\n        texture(iChannel1, vec2(0.6, 0.2)).r,\n        mix(0., texture(iChannel1, vec2(0.2, 1.)).r * 1., min(67., iTime) / 67.), // mix sphere / blob\n        texture(iChannel1, vec2(0.6, 0.2)).r\n    );\n    \n    \n    vec3 \n        vuv = normalize(vec3(0., 1., 0.)),\n    \teyePosition = vec3(sin(iMouse.x / 300.) * 40., 1.,  cos(iMouse.x / 300.) * 40.);\n\n    pR(eyePosition.xz, +iTime* .1);\n    pR(eyePosition.yx, - blob(eyePosition + vols[2], 1.) * .01);\n    vec3\n        vrp = vec3(0.),\n    \tvpn = normalize(vrp - eyePosition),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (eyePosition + vpn),\n    \tscrCoord = (vcv + uv.x * u + uv.y * v),\n    \tviewDirection = normalize(scrCoord - eyePosition);   \n    \n    vec3 ro = eyePosition;\n    vec3 rd = viewDirection;\n    vec4 c, oc = vec4(0.);\n    \n    vec3 LIGHT = vec3(sin(-iTime) * 15., -10., cos(-iTime) * 15.);\n    vec3 nLight = normalize(LIGHT);\n\n    int initialTracingSteps = 99;\n    int tracingSteps = initialTracingSteps;\n    int bounces = 4;\n    \n    for (int bounce = 1; bounce < bounces; bounce++) {\n        \n        float march = trace(ro, rd, tracingSteps);\n\t\ttracingSteps -= initialTracingSteps / bounces;\n        \n        ro += rd * march;\n        vec3 n = normals(ro);\n\t\t\n        c.rgb = vec3(1.);    \n\n        if (ro.y > 10.) {\n            vec3 ro2 = ro;\n            ro2.x += sin(iTime + (vols[1] * ro2.x * .1 + ro2.z * .2) + vols[2] ) * 5.;\n            float stripes = (n.y < .0 && ro.y > 0.) ? (1. * ceil(fract((ro2.z-ro2.x) * .1 + iTime + vols[2]) - .5) * 3.) : 0.;\n            c += stripes * vols[2];            \n        }\n        \n                \n        vec3 op = ro;\n        \n        float bl = mix(fSphere(op, 7.), blob(op, 1.4), vols[2]); // to blob\n        \n        pR(op.xz, iTime * .25);\n        \n        float cr = crate(op * (1. + vols[0] * .1), 8.6 + vols[0]); // to box\n        \n        c.b += mix(1., 0., clamp(bl + cr, 0., 1.)) * 5.;\n        \n        \n        c += pow(max(0., dot(n, nLight)), 5.) * 2.5;\n        c = mix(vec4(.5), c, (1.-(march/ 125.)) * .5);\n\n        //c += (1. / distance(LIGHT, ro)) * 1.;\n        \n        c *= ambientOcclusion(ro, n, 4.2, 1.2);\n\t\t\n        c.b += mix(.1, 0., clamp((bl + cr) * .5, 0., 1.)) * 1.;\n                \n        oc = mix(oc, c, .2 / float(bounce));\n        \n        rd = reflect(rd, n);\n        //rd = refract(rd, normalize(ro), .99);\n        //ro += mix(ro, hashHs(rd / 1., float(99 + bounce)), .1) * .0001;\n        \n        rd.x += hash(ro.x)* .01;\n        rd.y += hash(ro.y)* .01;\n        rd.z += hash(ro.z)* .05;\n        \n        rd = normalize(rd);\n        ro += rd * .01;\n    }\n    \n    uv += 3.;\n    \n    //oc *= 1.+ max(0., pow(abs(dot(viewDirection, nLight)) * 1.001, 124.));\n    //oc = pow(abs(oc), 1. / vec4(1.75)) * .45;\n    \n    color = 1. * max(\n        vec4(0.), \n        vec4(\n            vec3((oc * 3. - length(uv/ 12.)) + hash(rd.x / uv.y + mod(iTime, 1.)) * .001), 1.));\n    \n    //color = oc;\n    color = pow(color * 1., vec4(1.7)) * 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    image(fragColor, uv);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//volume smoothing\n\n#define FALL .001\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float old = texture(iChannel1, uv).r; // previous frame\n    float current =\n            textureLod(iChannel0, vec2(uv.x, ceil(uv.y * 2.) / 2.), 6.).r;\n        \n    float outputColor = old;\n    \n    if (current > old + .1) {\n        outputColor = current;\n    } else {\n        outputColor -= .005;\n    }\n    \n    //outputColor = pow(outputColor, 1.);\n\n    fragColor = vec4(clamp(outputColor, 0., 1.));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 26462,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/neurofunksocietyofpoland/controlless-future-funk-wav"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}