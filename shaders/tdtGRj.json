{
    "Shader": {
        "info": {
            "date": "1568906139",
            "description": "Simple glass mandelbulb, it's very basic but I thought it looked quite nice",
            "flags": 32,
            "hasliked": 0,
            "id": "tdtGRj",
            "likes": 27,
            "name": "Glass mandelbulb",
            "published": 3,
            "tags": [
                "fractal",
                "reflection",
                "refraction",
                "mandelbulb",
                "dof",
                "glass",
                "depthoffield"
            ],
            "usePreview": 0,
            "username": "loicvdb",
            "viewed": 1408
        },
        "renderpass": [
            {
                "code": "#define GoldenAngle 2.39996323\n\n#define DoFSamples 64\n#define Aperture .05\n#define DoFClamping .4\n\nfloat FocalDistance = 2.4;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float time = iTime/2.0;\n    \n    FocalDistance *= 1.0 - sin(pow(abs(sin(time/2.0)), 30.0) * 6.0) *.25;\n    \n    float r, phi;\n    vec3 col = vec3(0);\n    float samples = 0.0;\n    for(int i = 0; i < DoFSamples; i++){\n        r = sqrt(float(i) / float(DoFSamples))*DoFClamping;\n        phi = GoldenAngle * float(i);\n        vec2 d = r * vec2(cos(phi), sin(phi));\n        vec4 p = texture(iChannel0, (fragCoord + d*iResolution.y*Aperture)/iResolution.xy);\n        float dr = min(atan(abs(p.a-FocalDistance), p.a), DoFClamping);\n        float influence = clamp((dr - length(d))*iResolution.y*Aperture + .5, 0.0, 1.0) / (dr*dr+.001);\n        col += influence * p.rgb;\n        samples += influence;\n    }\n    col /= samples;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define Epsilon .002\n#define RenderDistance 3.0\n#define IoR 2.5\n\nfloat Power = 8.0;\n\nvec3 CamPos = vec3(0, -.7, -3);\nvec3 CamRot = vec3(-.1, .1, .3);\nfloat CamFocalLength = 4.;\n\nfloat distanceEstimation(vec3 pos) {\n    float r = length(pos);\n    if(r > 1.5) return r-1.2;\n    vec3 z = pos;\n\tfloat dr = 1.0, theta, phi;\n\tfor (int i = 0; i < 100; i++) {\n\t\tr = length(z);\n\t\tif (r>1.5) break;\n\t\ttheta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nvec3 normalEstimation(vec3 pos){\n   \n  vec3 xDir = vec3(Epsilon, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, Epsilon, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, Epsilon);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\nvec3 background(vec3 dir){\n    return texture(iChannel0, dir).rgb * 1.5;\n}\n\nfloat fresnel(vec3 dir, vec3 normal) {\n  float cosi = dot(dir, normal);\n  float etai = 1.0, etat = IoR;\n  if (cosi > 0.0) {\n    float tmp = etai;\n    etai = etat;\n    etat = tmp;\n  }\n  float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n  if (sint >= 1.0) return 1.0;\n  float cost = sqrt(max(0.0, 1.0 - sint * sint));\n  cosi = abs(cosi);\n  float sqrtRs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n  float sqrtRp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n  return (sqrtRs * sqrtRs + sqrtRp * sqrtRp) / 2.0;\n}\n\nbool hit(inout vec3 pos, in vec3 dir, out vec3 normal){\n    for(int i = 0; i < 500; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon) break;\n        if(dist > RenderDistance) return false;\n        pos += dist*dir;\n    }\n    for(int i = 0; i < 2; i++){\n        float dist = distanceEstimation(pos)-Epsilon;\n        pos += dist*dir;\n    }\n    normal = normalEstimation(pos);\n    return true;\n}\n\nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec3 normal;\n    if(hit(pos, dir, normal)){\n        float fres = fresnel(dir, normal);\n        vec3 reflectCol = background(reflect(dir, normal));\n        vec3 refractCol = background(refract(dir, normal, 1.0/IoR));\n        vec3 col = (1.0-fres)*refractCol + fres*reflectCol;\n        return vec4(col, length(pos-CamPos));\n    }\n   \treturn vec4(background(dir), RenderDistance);\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    float time = iTime/2.0;\n    \n    vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.y;\n    if(sin(time)>0.0) uv.x = -uv.x;\n    \n    CamRot.y += time;\n    CamPos *= rotationMatrix(vec3(0, time, 0));\n    \n    vec3 rayDir = normalize(vec3(uv, CamFocalLength)) * rotationMatrix(CamRot);\n    \n    fragColor = colorAndDepth(CamPos, rayDir);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}