{
    "Shader": {
        "info": {
            "date": "1667088757",
            "description": "A character ported from Rootkids latest intro at TRSAC 2022. We are modelling the \"ragdoll\" with a soft body integrator, and from what you can see from the result, it was perfect for the challenge, right?\n\nInteract with the character by using your mouse.\n",
            "flags": 32,
            "hasliked": 0,
            "id": "cds3Dl",
            "likes": 5,
            "name": "Workplace Hazards",
            "published": 3,
            "tags": [
                "physics",
                "doll"
            ],
            "usePreview": 1,
            "username": "Tapped",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "/*\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\n\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\nvec4 fxaa(sampler2D tex, vec2 uv) {\n    vec4 color;\n    vec2 inverseVP = 1. / vec2(textureSize(tex, 0));\n    vec4 offset = vec4(inverseVP.xy, -inverseVP.xy);\n    vec3 rgbNW = texture(tex, uv + offset.zw).xyz;\n    vec3 rgbNE = texture(tex, uv + offset.xw).xyz;\n    vec3 rgbSW = texture(tex, uv + offset.zy).xyz;\n    vec3 rgbSE = texture(tex, uv + offset.xy).xyz;\n    vec4 texColor = texture(tex, uv);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                    (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n            dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture(tex, uv + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, uv + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, uv + dir * -0.5).xyz +\n        texture(tex, uv + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = fxaa(iChannel0, fragCoord / iResolution.xy);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ##################################################################\n// MERCURY SNIPPET START\n// Snippet from http://mercury.sexy/hg_sdf\n// Brought to you by MERCURY\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n// ##################################################################\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n// ##################################################################\n// MERCURY SNIPPET END\n// ##################################################################\n\n// From IQ: https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n\tvec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n\treturn length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nconst vec3 cam_pos = vec3(0,8,5);\n\nvec3 pose[] = vec3[](\n\tvec3(-.2, 0, -.2), /* leg */\n\tvec3(-.2, .4, 0), /* up leg */\n\tvec3(-.1, 1., .1), /* forearm */\n\tvec3(-.1, 1.2, 0), /* arm */\n\tvec3(.2, 0, -.2), /* leg */\n\tvec3(.2, .4, 0), /* up leg */\n\tvec3(.3, 1., .1), /* forearm */\n\tvec3(.3, 1.2, 0), /* arm */\n\tvec3(0, .9, 0), /* bottom spine */\n\tvec3(0, 1.5, 0), /* top spine */\n\tvec3(0, 1.6, .1) /* neck */\n);\n\nint pose_indices[] = int[](\n\t/* r-leg */\n\t0,\n\t1,\n\t8,\n\n\t/* l-leg */\n\t4,\n\t5,\n\t8,\n\n\t/* spine */\n\t8,\n\t9,\n\t10,\n\n\t/* r-arm */\n\t2,\n\t3,\n\t9,\n\n\t/* l-arm */\n\t6,\n\t7,\n\t9\n);\n\nvec3 char_vertices[11];\nvec4 char_bounding;\n\nstruct SDM {\n\tint   m; // material\n\tfloat d; // distance\n};\n\nvoid load_character(sampler2D char_verts) {\n\tvec3 min_v = vec3(1e5);\n\tvec3 max_v = vec3(-1e5);\n\tfor (int i = 0;i < 11;++i) {\n\t\tchar_vertices[i] = texelFetch(char_verts, ivec2(i, 0), 0).xyz;\n\n\t\tmin_v = mix(min_v, char_vertices[i], lessThan(char_vertices[i], min_v));\n\t\tmax_v = mix(max_v, char_vertices[i], greaterThan(char_vertices[i], max_v));\n\t}\n\n\tchar_bounding = vec4((min_v + max_v)*.5, distance(min_v, max_v)*.5);\n}\n\nmat3 basis_mat(vec3 fwd) {\n\tvec3 up = vec3(0,1,0);\n\tvec3 r = cross(fwd, up);\n\t/*if (length(r) < 1e-4) {\n        r = cross(fwd, vec3(0,.7,.7));\n\t}*/\n\tr = normalize(r);\n\tvec3 u = cross(r, fwd);\n\treturn mat3(\n\t\tvec3(r),\n\t\tvec3(u),\n\t\tvec3(-fwd)\n\t);\n}\n\nSDM sdm_min(SDM a, SDM b) {\n\t\tif (a.d < b.d) return a;\n\t\telse return b;\n}\n\nSDM sdm_paint(SDM base, SDM paint)\n{\n\tif (paint.d < base.d)\n\t\tbase.m = paint.m;\n\n\treturn base;\n}\n\nSDM character(vec3 p, bool with_bounding) {\n\tfloat b = length(p - char_bounding.xyz) - char_bounding.w - 1.8;\n\tif (with_bounding && b > 0.2) {\n\t\treturn SDM(0, b);\n\t}\n\n\tfloat min_d = 1e5;\n\tfor (int line = 0;line < 5;++line) {\n\t\tfor (int x = 0;x < 2;++x) {\n\t\t\tint idx0 = pose_indices[line*3 + x];\n\t\t\tint idx1 = pose_indices[line*3 + x + 1];\n\t\t\tfloat thickness = 0.05;\n\t\t\tif (line == 2)\n\t\t\t\tthickness = 0.1;\n\t\t\tmin_d = fOpUnionSoft(\n\t\t\t\tmin_d,\n\t\t\t\tfCapsule(p, char_vertices[idx0], char_vertices[idx1], thickness)\n\t\t\t, 0.05);\n\t\t}\n\t}\n\tvec3 up = normalize((char_vertices[10] - char_vertices[9]));\n\t\n\tmat3 basis = mat3(basis_mat(up));\n\tvec3 basis_tmp = basis[1];\n\tbasis[1] = -basis[2];\n\tbasis[2] = -basis_tmp;\n\t\n    vec3 p_head = p - up*.2 - char_vertices[10];\n\n\tpR(p_head.xy, 0.3);\n\tpR(p_head.yz, 0.6);\n\n\tconst float fs = 0.6;\n\tp_head = basis * p_head;\n\tmin_d = fOpUnionSoft(min_d, fSphere(p_head, fs*0.4), 0.05);\n\n\n\tvec3 p_mouth = p_head- fs*vec3(0,-0.2,0.35);\n\tpR(p_mouth.yz, 0.5);\n\tvec3 p_eye = p_head;\n\tfloat side = pMirror(p_eye.x, 0.);\n\n\t// SDM head_sdm = SDM(1, fSphere(p_head, .4));\n\tSDM min_sdm = SDM(1, min_d);\n\tfloat wrinkle = 1.2; //noise(vec2(applicationTime*8, 0.1*side));\n\tmin_sdm = sdm_min(min_sdm, SDM(3, fCapsule(p_eye, fs*vec3(0.1, 0.2 + 0.1*wrinkle, 0.3), fs*vec3(0.3,0.3-0.1*wrinkle,0.3), 0.03)));\n\t// min_sdm.d = fOpDifferenceChamfer(min_sdm.d, fSphere(p_eye-vec3(0.0,-0.2,0.3), 0.2), 0.05);\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_eye - fs*vec3(0.15,0.12,0.32), fs*0.09)));\n\tmin_sdm = sdm_paint(min_sdm, SDM(3, fSphere(p_eye - fs*vec3(0.14,0.10,0.38), fs*0.04)));\n\n\tmin_sdm = sdm_paint(min_sdm, SDM(3, sdLink((p_mouth).yxz, fs*0.15, fs*0.01, fs*0.04)));\n\tmin_sdm = sdm_min(min_sdm, SDM(4, sdLink((p_mouth).yxz, fs*0.15, fs*0.06, fs*0.03)));\n\tvec3 p_teeth = p_mouth;\n\t// pModInterval1(p_teeth.x, 0.05, 0, 1);\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_teeth-fs*vec3(0.02,0.03, 0.02), fs*0.02)));\n\tmin_sdm = sdm_min(min_sdm, SDM(0, fSphere(p_teeth-fs*vec3(0.06,0.03, 0.02), fs*0.02)));\n\n\treturn min_sdm;\n}\n\nSDM scene(vec3 p, bool include_character) {    \n    SDM result;\n    SDM room = SDM(0, -fBox(p-vec3(0,5,0), vec3(20,5,20)));\n    float box = fBox(p, vec3(5,.2,5));\n    float box2 = fBox(p - vec3(-5,2,-5), vec3(1,2,1));\n    SDM stuff = SDM(0, fOpUnionStairs(box,box2,5.,6.));\n\n    result = sdm_min(room, stuff);\n\n    result = sdm_paint(result, SDM(2, fBox(p-vec3(0,0,2), vec3(21,2,2))));\n\n    vec3 pole_p = p+vec3(5,0,5);\n    pModGrid2(pole_p.xz, vec2(6,12));\n\n    SDM pole = SDM(0, length(pole_p.xz) - 0.4);\n    pole = sdm_paint(pole, SDM(2, abs(pole_p.y-2.)-.5));\n    result = sdm_min(result, pole);\n    \n    if (include_character) {\n        return sdm_min(result, character(p, true));\n    }\n    return result;\n}\n\nvec3 calc_normal(vec3 p, bool include_character)\n{\n\tvec3 n = vec3(0.0);\n\tfor (int i = min(int(abs(p.x)), 0);i<4;i++)\n\t{\n\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\tn += e*scene(p+e*1e-3, include_character).d;\n\t}\n\treturn normalize(n);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "#define NUM_CONSTRAINT_ITERATIONS 40\n\nvoid dist_constraint(inout vec3 p1, inout vec3 p2, float dist_in_between) {\n    vec3 pp = p2 - p1;\n\n    vec3 n = normalize(pp);\n    float delta_dist = distance(p1, p2) - dist_in_between;\n\n    p1 += n * delta_dist * .5;\n    p2 -= n * delta_dist * .5;\n}\n\nvoid update_collision_constraint(inout vec3 p) {\n  SDM result = scene(p, false);\n  if (result.d < .2) {\n    vec3 normal = calc_normal(p, false);\n    p -= normal*(result.d - .2);\n  }\n}\n\nvoid tendons_hinges(vec3 a, vec3 b, vec3 c, out vec3 h0, out vec3 h1) {\n  vec3 hinge_normal = normalize(cross(normalize(a - b), normalize(c - b)));\n  h0 = b + hinge_normal;\n  h1 = b - hinge_normal;\n}\n\nvec3 positions[11];\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 fc = ivec2(fragCoord);\n    if (fc.y == 0 && fc.x < 11) {\n        float reset = texelFetch(iChannel0, ivec2(12, 0), 0).x;\n        if (reset < .5) {\n            vec3 pos = pose[fc.x] + vec3(0, 1.2, 0);\n            fragColor = vec4(pos, 0);\n        }\n        else {\n            vec3 min_v = vec3(1e5);\n            vec3 max_v = vec3(-1e5);\n            for (int i = 0;i < 11;++i) {\n                positions[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xyz;\n                min_v = mix(min_v, positions[i], lessThan(positions[i], min_v));\n                max_v = mix(max_v, positions[i], greaterThan(positions[i], max_v));\n            }\n            vec3 center = (min_v + max_v)*.5;\n            \n            // Verlet integration\n            vec3 force = vec3(0, -6., 0);\n            \n            float mouse_duration = texelFetch(iChannel0, ivec2(1, 2), 0).z;\n            vec2 delta = iMouse.xy - texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n            if (mouse_duration < .25 && fc.x == 10) {\n                vec3 to_character = normalize(center - cam_pos);\n                mat3 look_at = basis_mat(to_character);\n                force += look_at*vec3(delta.x*15., 0, 0) + vec3(0, delta.y*15., 0);\n            }\n            \n            float drag = 0.99;\n            float dt = iTimeDelta;\n            for (int i = 0;i < 11;++i) {\n                vec3 prev_pos = texelFetch(iChannel0, ivec2(i,1), 0).xyz;\n                positions[i] = positions[i] + (positions[i] - prev_pos)*pow(drag, dt / (1./60.)) + dt*dt*force;\n            }\n        \n            for (int i = 0;i < NUM_CONSTRAINT_ITERATIONS;++i) {\n                for (int line = 0;line < 5;++line) {\n                    vec3 expectedh0;\n                    vec3 expectedh1;\n                    tendons_hinges(pose[pose_indices[line*3]], pose[pose_indices[line*3 + 1]], pose[pose_indices[line*3 + 2]], expectedh0, expectedh1);\n\n                    vec3 h0;\n                    vec3 h1;\n\n                    vec3 a = positions[pose_indices[line*3]];\n                    vec3 b = positions[pose_indices[line*3 + 1]];\n                    vec3 c = positions[pose_indices[line*3+2]];\n                    tendons_hinges(\n                        a,\n                        b,\n                        c,\n                        h0,\n                        h1\n                    );\n\n\n                    dist_constraint(a, h0, distance(pose[pose_indices[line*3]], expectedh0));\n                    dist_constraint(a, h1, distance(pose[pose_indices[line*3]], expectedh1));\n                    positions[pose_indices[line*3]] = a;\n                \n                    for (int x = 0;x < 2;++x) {\n                        int pose_idx0 = pose_indices[line*3 + x];\n                        int pose_idx1 = pose_indices[line*3 + x + 1];\n                        vec3 a = pose[pose_idx0];\n                        vec3 b = pose[pose_idx1];\n                        float dist_in_between = distance(a, b);\n                        dist_constraint(positions[pose_idx0], positions[pose_idx1], dist_in_between);\n                    }\n                }\n                \n                for (int k = 0;k < 11;++k) {\n                    update_collision_constraint(positions[k]);\n                }\n            }\n            \n            fragColor = vec4(positions[fc.x], 0);\n        }\n    }\n    else if (fc.y == 1 && fc.x < 11) {\n        float reset = texelFetch(iChannel0, ivec2(12, 0), 0).x;\n        if (reset < .5) {\n            vec3 pos = pose[fc.x] + vec3(0, 1.2, 0);\n            fragColor = vec4(pos, 0);\n        }\n        else {\n            fragColor = texelFetch(iChannel0, ivec2(fc.x, 0), 0);\n        }\n    }\n    else if (fc.x == 12) {\n        fragColor = vec4(1,0,0,0);\n    }\n    else if (fc.y == 2 && fc.x == 0) {\n        fragColor = iMouse;\n    }\n    else if (fc.y == 2 && fc.x == 1) {\n        vec2 prev_mouse = texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n        vec4 prev_data = texelFetch(iChannel0, ivec2(1, 2), 0);\n        if (prev_mouse == prev_data.xy) {\n            prev_data.z += iTimeDelta;\n        } else {\n            prev_data.z = 0.;\n        }\n        prev_data.xy = prev_mouse;\n\n        fragColor = prev_data;\n    }\n    else {\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ZERO min(int(abs(iResolution.x)), 0)\n#define RAY_MARCH_ITER 120\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat fbm(in vec2 p){\n\tfloat f = 0.0;\n\tf += 0.5000*noise(p); p = p*2.02;\n\tf += 0.2500*noise(p); p = p*2.03;\n\tf += 0.1250*noise(p); p = p*2.01;\n\tf += 0.0625*noise(p);\n\treturn f/0.9375;\n}\n\nvec3 shade(vec2 uv, vec2 dUvX, vec2 dUvY, int material) {\n\tint sizeX = 3;\n\tint sizeY = 3;\n\tvec2 stepSize = 1. / vec2(sizeX, sizeY);\n\tvec3 bg;\n\tif (material == 0)\n\t{\n\t\tbg = vec3(0.9);\n\t}\n\telse if (material == 1)\n\t{\n\t\tbg = vec3(0.9, 0.4, 0.02);\n\t}\n\telse if (material == 2)\n\t{\n\t\tfloat t = uv.x + uv.y;\n\t\tfloat f = smoothstep(0.0,0.2,sin(t*4.));\n\t\tbg = mix(vec3(0.035), vec3(0.9, 0.4, 0.02), f);\n\t}\n\telse if (material == 3)\n\t{\n\t\tbg = vec3(0.03);\n\t}\n\telse if (material == 4)\n\t{\n\t\tbg = vec3(0.8, 0.1, 0.02);\n\t}\n    if (material == 0 || material == 2) {\n        vec3 accum = vec3(0);\n        float low_freq = fbm(uv*.7);\n        float very_high_freq = fbm(uv*50.);\n        float high_freq = fbm(vec2(very_high_freq, uv.x*uv.y));\n        for (int y = ZERO;y < sizeY;++y)\n        for (int x = ZERO;x < sizeX;++x) {\n            vec2 step_size = vec2(x,y)*stepSize;\n            vec2 cell = mod(uv + step_size.x*dUvX + step_size.y*dUvY + .25,vec2(.5))-.25;\n            float t = min(abs(cell.x) - .02, abs(cell.y) - .02);\n            float r = saturate(-t/.02);\n\n            accum += mix(bg, vec3(0), r*0.5);\n            accum += mix(bg, vec3(.1), smoothstep(0.38, 3.4, very_high_freq)*9.);\n            accum += mix(bg, vec3(1.,.13,.06)*.5, max(0., (high_freq * smoothstep(0.5, .8, low_freq))*4.));\n        }\n\n        bg = accum / float(sizeX*sizeY*3);\n    }\n        \n\n\treturn bg;\n}\n\nvec3 box_map(vec3 p, vec3 normal, SDM sdm) {\n    vec3 x = shade(p.yz, dFdx(p.yz), dFdy(p.yz), sdm.m);\n    vec3 y = shade(p.zx, dFdx(p.zx), dFdy(p.zx), sdm.m);\n    vec3 z = shade(p.xy, dFdx(p.xy), dFdy(p.xy), sdm.m);\n    vec3 m = pow(abs(normal), vec3(8.));\n    return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nfloat spot_light(vec3 p, vec3 spotPos, vec3 spotDir, vec2 spotCutOff) {\n\tvec3 fromLight = p-spotPos;\n\tfloat spotAtt = 0.;\n\tfloat spotOuterCutOff = cos(spotCutOff.x);\n\tfloat spotInnerCutOff = cos(spotCutOff.y);\n\tfloat a = dot(spotDir, normalize(fromLight));\n\tif (a < spotOuterCutOff) {\n\t\tspotAtt = 0.;\n\t} else {\n\t\tfloat spotValue = smoothstep(spotOuterCutOff, spotInnerCutOff, a);\n\t\tspotAtt = pow(spotValue, 2.);\n\t}\n\treturn spotAtt;\n}\n\n// Shadow from iq: https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 rp, vec3 rd, float min_t, float max_t, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float t = min_t;\n    for(int i = 0;i < 64;++i)\n    {\n        float d = character(rp + rd*t, false).d;\n        if (d<1e-3)\n            return 0.;\n        float y = d*d/(2.0*ph);\n        float x = sqrt(d*d-y*y);\n        res = min(res, k*x / max(0.0, t-y));\n        ph = d;\n        t += d;\n        if (t >= max_t) {\n            return res;\n        }\n    }\n\n    return res;\n}\n\nfloat plane_density(vec3 rp, vec3 rd, vec4 plane, float density_height, float depth) {\n    float rp_d = dot(rp, plane.xyz);\n    float rd_d = dot(rd, plane.xyz);\n    \n    float t0 = ((plane.w + density_height) - rp_d) / rd_d;\n    float t1 = (plane.w - rp_d) / rd_d;\n    \n    if (t1 < .0 || t0 > depth) return 0.;\n    t0 = max(t0, 0.);\n    t1 = min(t1, depth);\n    \n    // Analytical density: 1 - (y/density_height)^2\n    \n    float i0 = t0*(3.*rp_d*rp_d + 3.*rp_d*rd_d*t0 - 6.*plane.w*rp_d + rd_d*rd_d*t0*t0 - 3.*plane.w*rd_d*t0 - 3.*density_height*density_height + 3.*plane.w*plane.w);\n    float i1 = t1*(3.*rp_d*rp_d + 3.*rp_d*rd_d*t1 - 6.*plane.w*rp_d + rd_d*rd_d*t1*t1 - 3.*plane.w*rd_d*t1 - 3.*density_height*density_height + 3.*plane.w*plane.w);\n    \n    return (i0-i1)*1./(3.*density_height*density_height);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    load_character(iChannel0);\n    vec2 uv = 2.*(fragCoord - iResolution.xy*.5)/iResolution.yy;\n    \n    if (abs(uv.y) > .7) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec3 rp = cam_pos;\n    vec3 fwd = normalize(char_bounding.xyz - rp);\n    mat3 look_at = basis_mat(fwd);\n    vec3 rd = look_at*normalize(vec3(uv, -2.2));\n    rp += fwd*(distance(rp, char_bounding.xyz) - 5.);\n\n    vec3 color = vec3(0);\n    float t = 0.;\n    for (int i = ZERO;i < RAY_MARCH_ITER;++i) {\n        vec3 p = rp + rd * t;\n        SDM sdm = scene(p, true);\n        if (sdm.d < 1e-3 || i + 1 == RAY_MARCH_ITER) {\n            vec3 normal = calc_normal(p, true);\n            vec3 albedo = box_map(p, normal, sdm);\n            vec3 lp = vec3(0, 10, 0);\n            vec3 L = normalize(lp - p);\n            float attenuation = spot_light(p, lp, normalize(char_bounding.xyz - lp), vec2(.15, .05));\n            vec3 radiance = .2*vec3(.63,.98,.95) * attenuation * shadow(p, L, .005, 15., 30.);\n        \n            color = albedo * (.008 + max(dot(normal, L), 0.) * radiance*mix(.88, 1., smoothstep(.0, .3, noise(vec2(iTime, 0)*10.))));\n            break;\n        }\n\n        t += sdm.d;\n    }\n    \n    float mist = pow(saturate(plane_density(rp, rd, vec4(0, 1, 0, 0), .4, t)), 2.);\n    color = mix(color, vec3(0), mist);\n    \n    color = color / (color + 0.155) * 1.019;\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}