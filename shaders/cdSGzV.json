{
    "Shader": {
        "info": {
            "date": "1667918254",
            "description": "3d",
            "flags": 0,
            "hasliked": 0,
            "id": "cdSGzV",
            "likes": 5,
            "name": "Raymarching 2.3",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 258
        },
        "renderpass": [
            {
                "code": "//Thanks to @dean_the_coder for some performance improvements\n#define epsilon 0.01\n#define maxSteps 300\n#define lPos vec3(6, 10, -20)\n#define PI 3.1415926545\n#define degreesToRadians PI/180.0\n#define FOV 90.0*degreesToRadians\n#define fogDensity 10.0\n#define fogColor vec3(0.8)\n\nstruct material{\n    vec3 col;\n    float type;\n    float intensity;\n    float brightness;\n};\n\nstruct SDF{\n    float dist;\n    material mat;\n    int index;\n};\n\nstruct camera{\n    vec3 o;\n    vec3 d;\n};\nfloat random(vec3 p){\n    return fract((sin(p.x*203.24 + 20398.243)*sin(p.y*834.29 + 2382.2033)*sin(p.z*405.09))*20384.043);\n}\n\nfloat noise2(vec2 p){\n    vec2 luv = fract(p);\n    vec2 id = floor(p);\n    luv = luv*luv*(3.0 - 2.0*luv);\n    float bl = random(vec3(id, 1));\n    float br = random(vec3(id + vec2(1, 0), 1));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = random(vec3(id + vec2(0, 1), 1));\n    float tr = random(vec3(id + vec2(1, 1), 1));\n    float t = mix(tl, tr, luv.x);\n    return mix(b, t, luv.y);\n}\n\nfloat noise3(vec3 p){\n    vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = smoothstep(0.0, 1.0, frc);\n    \n    float tlf = random(fc + vec3(0, 1, 0));\n    float trf = random(fc + vec3(1, 1, 0));\n    float blf = random(fc + vec3(0, 0, 0));\n    float brf = random(fc + vec3(1, 0, 0));\n    float tlb = random(fc + vec3(0, 1, 1));\n    float trb = random(fc + vec3(1, 1, 1));\n    float blb = random(fc + vec3(0, 0, 1));\n    float brb = random(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);\n}\n\n\nSDF sphere(vec3 p, float rad, material mat, int index){\n    return SDF(length(p) - rad, mat, index);\n}\n\nSDF boxSDF(vec3 p, vec3 s, material mat, int index){\n    vec3 q = abs(p) - s;\n    return SDF(length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0), mat, index);\n}\n\nSDF yPlane(vec3 p, float y, material mat, int index){\n    return SDF(p.y - y, mat, index);\n}\n\nSDF boxFrameSDF(vec3 p, vec3 s, float sw, float ro, material mat, int index){\n  p = abs(p) - s;\n  vec3 q = abs(p + sw) - sw;\n  return SDF(min(\n      min(\n          length(max(vec3(p.x, q.y, q.z),0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n          length(max(vec3(q.x, p.y, q.z),0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)\n      ),\n      length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0)) - ro, mat, index);\n}\n\nSDF sceneSDF(vec3 p, float type){\n    \n    /*SDF[] scene = SDF[](\n        sphere(p - vec3(2, 1, 5), 1.0, material(vec3(1, 0, 0), 1.0, 0.0, 0.0), 0),\n        sphere(p - vec3(-1, -2, 5), 0.6, material(vec3(1, 1, 0), 1.0, 0.0, 0.0), 1),\n        sphere(p - vec3(0, 0, 5), 1.0, material(vec3(0, 1, 0), 1.0, 0.0, 0.0), 2),\n        sphere(p - vec3(-4, 0, 8), 1.0, material(vec3(0, 1, 1), 1.0, 0.0, 0.0), 2)\n    );\n    \n    //float outputDist = 100000.0;\n    for(int i = scene.length() - 1; i >= 0; i--){\n        float outputDist = min(scene[0].dist, scene[i].dist);\n        //if(type == 0.0){\n            if(outputDist == scene[i].dist){\n                return scene[i];\n            }\n        //}\n    }*/\n    \n    \n    float gf = 0.5;\n    float gh = 1.5;\n    float gv = 0.03;\n    int gd = 4;\n    \n    float gn = noise3((p + vec3(5, sin(iTime*10.0)*0.03, 2))*gf)*gh;\n    for(int i = 0; i < gd; i++){\n        gh /= 2.0;\n        gf *= 2.0;\n        gv *= 2.0;\n        gn += noise3((p + vec3(5.0 + float(i), sin(iTime*10.0)*0.03 + float(i), 2.0 + float(i)))*gf)*gh;\n    }\n    \n    gn /= 2.0;\n    \n    float wf = 10.0;\n    float wh = 0.005;\n    float wv = 0.01;\n    int wd = 2;\n    \n    float wn = noise3((p + vec3(5, iTime*wv, 2))*wf)*wh;\n    for(int i = 0; i < wd; i++){\n        wh /= 2.0;\n        wf *= 2.0;\n        wv *= 2.0;\n        wn += noise3((p + vec3(5.0 + float(i), iTime*wv + float(i), 2.0 + float(i)))*wf)*wh;\n    }\n    \n    wn /= 2.0;\n    \n    //SDF s1 = sphere(p - lPos, 1.0, material(vec3(1), 0.0, 0.9, 0.0), 0);\n    //SDF s2 = sphere(p - vec3(-1, 1.0, 3), 0.6, material(vec3(0, 1, 1), 3.0, 0.6, 0.0), 1);\n    SDF s3 = sphere(p - vec3(0, sin(-iTime*10.0)*0.03, 0), 0.25, material(vec3(0.6, 0.4, 0.2), 1.0, 0.7, 0.0), 1);\n    SDF s4 = yPlane(p, 0.3 - mix(sin(length(p - vec3(0, 0.4, 0))*10.0 - iTime*10.0)*0.01, 0.0, min(length(p - vec3(0, 0.4, 0))/3.0, 1.0)), material(vec3(0, 0.05, 0.1), 3.0, 0.8, 0.0), 2);\n   \n    s3.dist -= gn;\n    \n    //s4.dist -= wn;\n    \n    float closest;\n    \n    if(type == 0.0){\n        closest = min(s3.dist, s4.dist);\n    }else if(type == 1.0){\n        closest = min(s3.dist, s4.dist);\n    }\n    \n    //if(closest == s1.dist){\n        //return s1;\n    //}else if(closest == s2.dist){\n        //return s2;\n    /*}else*/ if(closest == s3.dist){\n        return s3;\n    }else if(closest == s4.dist){\n        return s4;\n    }\n}\n\nbool raymarch(float type, vec3 o, vec3 d, out float t, float eps, out material mat, out int index){\n    t = 0.0;\n    for(int i = 0; i < maxSteps && t <= 30.0; i++){\n        SDF s = sceneSDF(o + d*t, type);\n        t += s.dist;\n        mat = s.mat;\n        index = s.index;\n        if(s.dist < eps*t*0.1 && t > 0.0){\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 getNormals(vec3 h){\n    return normalize(\n        vec3(\n            sceneSDF(vec3(h.x + epsilon, h.yz), 0.0).dist - sceneSDF(vec3(h.x - epsilon, h.yz), 0.0).dist,\n            sceneSDF(vec3(h.x, h.y + epsilon, h.z), 0.0).dist - sceneSDF(vec3(h.x, h.y - epsilon, h.z), 0.0).dist,\n            sceneSDF(vec3(h.xy, h.z + epsilon), 0.0).dist - sceneSDF(vec3(h.xy, h.z - epsilon), 0.0).dist\n        )\n    );\n}\n\nfloat getLighting(vec3 h, vec3 lpos, material hitMat, int ii){\n    float brightness = 1.0;\n    \n    vec3 n = getNormals(h);\n    vec3 lRay = normalize(lpos - h);\n    \n    if(hitMat.type != 0.0){\n        float lt;\n        material lMat;\n        int i;\n        \n        bool rl = raymarch(1.0, h + n*0.007, lRay, lt, 0.001, lMat, i);\n        brightness = max(dot(n, lRay), 0.01);\n        \n        if(rl && i != ii){\n            brightness -= 0.6;\n        }\n    }else{\n        brightness = 1.0;\n    }\n    return brightness;\n}\n\nvec3 reflectRay(vec3 h, vec3 d){\n    vec3 n = getNormals(h);\n    return d - 2.0*n*dot(n, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float f = 1.0/tan(FOV/2.0);\n    \n    mat3 projection;\n    projection[0] = vec3(1, 0, 0);\n    projection[1] = vec3(0, 1, 0);\n    projection[2] = vec3(0, 0, f);\n    \n    vec3 col = fogColor;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    camera cam = camera(vec3(2.5, 3, -6), vec3(20, 20, 0));\n    \n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, cos(cam.d.x*degreesToRadians), -sin(cam.d.x*degreesToRadians));\n    xRotation[2] = vec3(0, sin(cam.d.x*degreesToRadians), cos(cam.d.x*degreesToRadians));\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cos(cam.d.y*degreesToRadians), 0, -sin(cam.d.y*degreesToRadians));\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sin(cam.d.y*degreesToRadians), 0, cos(cam.d.y*degreesToRadians));\n    \n    vec3 d = normalize(vec3(uv, 1.0)*projection*xRotation*yRotation);\n    vec3 o = cam.o;\n    \n    float t;\n    material mat;\n    int si;\n    \n    bool rs = raymarch(0.0, o, d, t, epsilon, mat, si);\n    \n    if(rs){\n        mat.brightness = getLighting(o + d*t, lPos, mat, si);\n        \n        if(mat.type == 1.0){\n            col = mix(mat.col*mat.brightness, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n        }else if(mat.type == 0.0){\n            col = mat.col;\n        }else if(mat.type == 3.0){\n            float rt;\n            material rmat;\n            int ri;\n            vec3 rd = reflectRay(o + d*t, d);\n            \n            vec3 n = getNormals(o + d*t);\n            \n            bool rr = raymarch(0.0, (o + d*t) + n*0.02, normalize(rd), rt, epsilon, rmat, ri);\n            \n            if(rr){\n                //mat.brightness = getLighting(o + d*t, lPos, mat, si);\n                float reflectLighting = getLighting((o + d*t) + normalize(rd)*rt, lPos, rmat, ri);\n                col = mix(mix(rmat.col*reflectLighting, mat.col*mat.brightness, mat.intensity), fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }else{\n                col = mix(mix(fogColor, mat.col, mat.intensity)*mat.brightness, fogColor, min(t/(1.0/(fogDensity*0.004)), 1.0));\n            }\n        }\n    }\n    \n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}