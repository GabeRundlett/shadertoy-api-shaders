{
    "Shader": {
        "info": {
            "date": "1705159477",
            "description": "Non-photo-realistically rendered scene using Raymarching and SDFs, inspired from Genshin Impact's main menu and 'slumbering court' locale.",
            "flags": 32,
            "hasliked": 0,
            "id": "clVyzW",
            "likes": 19,
            "name": "Shimenawa",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "sdf",
                "cloud",
                "hdr",
                "rope"
            ],
            "usePreview": 1,
            "username": "skittss",
            "viewed": 375
        },
        "renderpass": [
            {
                "code": "//============================================================================================\n//  Author's Note:\n//  作者の一言\n//\n//    !! Alternate colour schemes can be found in common ^^\n//    !! Common（共通のページ）で配色を変えりできます。^^\n//\n//    This shader has served as my learning playground for raymarching.\n//      It is by no means perfect, but I hope you enjoy it as much as I enjoyed making it.\n//    このシェーダーを作ることでレイマーチングの基本を学びました。\n//      決して完璧じゃありませんが、見て楽しんでください。\n//    \n//    Also, apologies for the long compile time! I tried to make it as quick as possible.\n//    長いコンパイル時間にすみません。なるべく短くしようとしました。\n//\n//============================================================================================\n/*                                  \n\n                                                 ████                                               \n                   ██                            █████                              █████████       \n       █████      ██████             ███         ████████              ████   ██  █████   █████     \n      ███████     ███████           ██████  ██████████                 █████  ██  ████████████      \n        █████    ███████             █████    █ ██████████            ██████████  ███████████       \n                ██  █████            █████   ██ █████  █████         █████    ███ ██████████        \n              ███   ████████               █  ██ ███████████        ████████  ███████████           \n     █████  ████████████████        ██████ ██  █████████████       ██████████    ██████ █████       \n   █████████████████████          ████████ ████ ██████████            ██████    ███████ ██████      \n    ████████   ██ ███████          █████     ███████  ████           ███████ █████████ ██████       \n      █  ██     ██████████            ████    █  ████████████         ██████████ ██████████         \n     █  ██   ███████████               ██████████████████████          ███ ███████████   ██         \n     █ ███  ███   ████             ███████████   ███  █               █ ███ █   ██████     ██       \n    █ ███       ███████ █████      ████████      ███  █              █  ███      █████      ███     \n    ████   ████████████████████      ██ ████████ ██        ██         ████      ████████████████    \n    ███  ████████          ████               █████████████████         ████           █████████    \n                                                                                                    \n\n    注連縄 (Shimenawa) by Henry A.                 (Self: https://www.shadertoy.com/view/clVyzW)\n    \n    --LAYOUT------------------------------------------------------------------------------------\n    \n      COMMON: Colour schemes, Rendering settings, SDF primitives, Intersectors, and util funcs.\n       \n    BUFFER B: Perlin-Worley texture atlas generation for clouds. \n              (Source: https://www.shadertoy.com/view/3sffzj)\n              \n    BUFFER C: Scene rendering\n   \n    BUFFER D: HDR Bloom pass\n    \n       IMAGE: LDR Post processing (Tonemap, Gamma correction, etc.)\n       \n    --------------------------------------------------------------------------------------------\n    \n*/\n\n// Post processing\n\n#define colorRange 1.0\n\n// ACES for that sweet film look ;)\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// GT Tonemapper from \"HDR theory and practice\", Hajime Uchimura:\n//  Curve Visualisation: https://www.desmos.com/calculator/gslcdxvipg\n//  GT tonemap is more linear in LDR colour space so can be easier to work with.\nvec3 gt_tonemap(vec3 x) {\n    const vec3 P = vec3(GT_MAX_BRIGHTNESS           );\n\tconst vec3 a = vec3(GT_CONTRAST                 );\n\tconst vec3 m = vec3(GT_LINEAR_OFFSET            );\n\tconst vec3 l = vec3(GT_LINEAR_LENGTH            );\n\tconst vec3 c = vec3(GT_BLACK_TIGHTNESS_CURVATURE);\n\tconst vec3 b = vec3(GT_BLACK_TIGHTNESS_OFFSET   );\n    \n    vec3 l0 = ((P - m) * l) / a;\n    vec3 L0 = m - m / a;\n    vec3 L1 = m + (1.0 - m) / a;\n    vec3 S0 = m + l0;\n    vec3 S1 = m + a * l0;\n    vec3 C2 = (a * P) / (P - S1);\n    vec3 CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(vec3(0.0), m, x);\n    vec3 w2 = step(m + l0, x);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(x / m, c) + b;\n    vec3 S = P - (P - S1) * exp(CP * (x - S0));\n    vec3 L = m + a * (x - m);\n\n    return T * w0 + L * w1 + S * w2;\n}\n\nvec3 bloom_mipmap(float mipmap_exp, vec2 offset, vec2 uv) \n{\n    // This reverse mapping is inaccurate, and causes slight edge bleeding T^T\n    float ds_factor = exp2(mipmap_exp);\n    offset.x += mipmap_exp * BLOOM_MIPMAP_NUDGE + 1.0 - 2.0 / ds_factor; // Simplification of 1 - 1/(2^(n-1))\n    \n    return texture(iChannel1, uv / ds_factor + offset).rgb;\n}\n\nvec3 get_bloom(vec2 uv)\n{ \n    vec3 blur  = bloom_mipmap(1.0, vec2(0.0), uv);\n         blur += bloom_mipmap(2.0, vec2(0.0), uv);\n         blur += bloom_mipmap(3.0, vec2(0.0), uv);\n         blur += bloom_mipmap(4.0, vec2(0.0), uv);\n         blur += bloom_mipmap(5.0, vec2(0.0), uv);\n    \n    return blur * colorRange;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = HDR_MAX_COL * texture(iChannel0, uv).rgb;\n    vec3 bloom_map = HDR_MAX_COL * texture(iChannel1, uv).rgb;\n    vec3 bloom = get_bloom(uv);\n    \n    // HDR Post-processing\n    #if POSTPROCESS\n    col = col + BLOOM_INTENSITY * bloom; // Bloom\n    #endif\n    \n    // Tonemap\n    #ifdef USE_ACES_TONEMAP\n    col = aces(col);\n    #elifdef USE_GT_TONEMAP\n    col = gt_tonemap(col);\n    #endif\n    \n    col = pow(col, vec3(GAMMA)); // Gamma\n\n    // LDR Post-processing\n    #if POSTPROCESS\n    col = CONTRAST * (col - vec3(0.5)) + vec3(0.5);  // Contrast\n    col = BRIGHTNESS + col;                          // Brightness\n    col = TINT * col;                                // Colour tint\n    \n    #ifdef VIGNETTE\n    col *= 0.8 + 0.3*sqrt( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) ); // Vignette\n    #endif\n    \n    #endif\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*                                  \n\n                                                 ████                                               \n                   ██                            █████                              █████████       \n       █████      ██████             ███         ████████              ████   ██  █████   █████     \n      ███████     ███████           ██████  ██████████                 █████  ██  ████████████      \n        █████    ███████             █████    █ ██████████            ██████████  ███████████       \n                ██  █████            █████   ██ █████  █████         █████    ███ ██████████        \n              ███   ████████               █  ██ ███████████        ████████  ███████████           \n     █████  ████████████████        ██████ ██  █████████████       ██████████    ██████ █████       \n   █████████████████████          ████████ ████ ██████████            ██████    ███████ ██████      \n    ████████   ██ ███████          █████     ███████  ████           ███████ █████████ ██████       \n      █  ██     ██████████            ████    █  ████████████         ██████████ ██████████         \n     █  ██   ███████████               ██████████████████████          ███ ███████████   ██         \n     █ ███  ███   ████             ███████████   ███  █               █ ███ █   ██████     ██       \n    █ ███       ███████ █████      ████████      ███  █              █  ███      █████      ███     \n    ████   ████████████████████      ██ ████████ ██        ██         ████      ████████████████    \n    ███  ████████          ████               █████████████████         ████           █████████    \n                                                                                                    \n\n    注連縄 (Shimenawa) by Henry A.                 (Self: https://www.shadertoy.com/view/clVyzW)\n    \n    --LAYOUT------------------------------------------------------------------------------------\n    \n      COMMON: Colour schemes, Rendering settings, SDF primitives, Intersectors, and util funcs.\n       \n    BUFFER B: Perlin-Worley texture atlas generation for clouds. \n              (Source: https://www.shadertoy.com/view/3sffzj)\n              \n    BUFFER C: Scene rendering\n   \n    BUFFER D: HDR Bloom pass\n    \n       IMAGE: LDR Post processing (Tonemap, Gamma correction, etc.)\n       \n    --------------------------------------------------------------------------------------------\n    \n*/\n\n//========================================================\n// COLOUR SCHEMES :)\n//   0 = day, 1 = sunset, 2 = night\n#define COLOUR_SCHEME 0\n//========================================================\n// RENDERING PARAMS\n\n// Use stars on certain colour schemes\n#define STARS\n\n// Use orbit controls (debug cam - click and drag.)\n//#define USE_ORBIT_CAMERA\n\n// Increasing max steps can help render objects at oblique angles\n#define RAYMARCH_MAX_STEPS 128\n#define BRIDGE_LOD_DIST 800.0;\n\n// Width of SSAA square (e.g. AA = 2 corresponds to 4x SSAA)\n#define AA 1\n#define AO_SAMPLES 64.0\n\n// Cloud settings\n//   Fast Raymarch\n#define CAMERA_RAY_STEPS 32\n#define  LIGHT_RAY_STEPS 8\n//   Slow Raymarch - Less edge noise.\n//#define CAMERA_RAY_STEPS 64\n//#define  LIGHT_RAY_STEPS 12\n\n// Dithering (removes artifacts from discrete ray sampling as a result of large-ish step size)\n#define CLOUD_BLUE_NOISE\n\n// Cast shadows from the background -> the clouds. Very pretty!!! but extremely slow. \n//#define CLOUD_SHADOW_CAST\n\n//========================================================\n// POST-PROCESSING PARAMS\n\n// Toggle - (Gamma and tonemapper always applied)\n#define POSTPROCESS 1\n\n// HDR\n#define EXPOSURE 1.0\n#define BLOOM_INTENSITY 1.1\n#define BLOOM_THRESHOLD 1.3\n\n// Tonemappers\n//#define USE_GT_TONEMAPPER\n#define USE_ACES_TONEMAPPER\n\n// GT Tonemap Params\n#define GT_MAX_BRIGHTNESS 1.00\n#define GT_CONTRAST 1.00\n#define GT_LINEAR_OFFSET 0.22\n#define GT_LINEAR_LENGTH 0.40\n#define GT_BLACK_TIGHTNESS_CURVATURE 1.33\n#define GT_BLACK_TIGHTNESS_OFFSET 0.00\n\n// LDR (post-HDR effects)\n#define GAMMA 0.4545\n#define BRIGHTNESS 0.0\n#define CONTRAST 1.15\n#define TINT vec3(1.0, 1.0, 1.0)\n//#define VIGNETTE\n\n//========================================================\n// MESS WITH THESE AT YOUR OWN PERIL\n\n// Shadertoy does not have arbitrary float buffers, so we have to store HDR values in the range [0, 1].\n//  Hacky solution, but we can divide through by a max HDR value before to compensate with HDR calculations.\n#define HDR_MAX_COL 25.0\n\n#define BLOOM_MIPMAP_NUDGE 0.005\n\n//========================================================\n// Util\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n// https://www.shadertoy.com/view/3sffzj\n// For Perlin-Worley noise\nfloat saturate(float x)\n{\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2)\n{\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\n//========================================================\n// SDFs\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// https://iquilezles.org/articles/distfunctions\n// a and b are start points, with radii provided\nfloat sdCone( vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdInfVerticalCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz - c.xy) - c.z;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(vec3 p, vec3 b, float e)\n{\n    p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule(vec3 p, float r, float h)\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCircleXZ(in vec3 p, in float r, out float t) \n{\n    float closest_p_theta = atan(p.z, p.x) + 3.14159265;\n    t = closest_p_theta / (2.0 * 3.14159265);\n    \n    return length(vec2(p.x, p.z))-r;\n}\n\n// https://www.shadertoy.com/view/msVBzy\nfloat sdPrism(vec3 position, float halfWidth1, float halfWidth2, float halfHeight, float halfDepth) {\n    position.x = abs(position.x);\n    position.x -= 0.5 * (halfWidth2 + halfWidth1);\n    vec2 e = vec2(0.5 * (halfWidth2 - halfWidth1), halfHeight);\n    vec2 q = position.xy - e * clamp(dot(position.xy, e) / dot(e, e), -1.0, 1.0);\n    float d1 = length(q);\n    if (q.x < 0.0) {\n        d1 = max(-d1, abs(position.y) - halfHeight);\n    }\n    float d2 = abs(position.z) - halfDepth;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\n// https://www.shadertoy.com/view/wsSGDG\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 r = 3.0*p - m;\n    vec3 o = min(r, 0.0);\n    o = max(r*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n}\n\n// https://www.shadertoy.com/view/Ntd3DX\n// TODO: this is probably too expensive for its use case\nfloat sdPyramid(vec3 position, float halfWidth, float halfDepth, float halfHeight) {\n    position.y += halfHeight;\n    position.xz = abs(position.xz);\n    vec3 d1 = vec3(max(position.x - halfWidth, 0.0), position.y, max(position.z - halfDepth, 0.0));\n    vec3 n1 = vec3(0.0, halfDepth, 2.0 * halfHeight);\n    float k1 = dot(n1, n1);\n    float h1 = dot(position - vec3(halfWidth, 0.0, halfDepth), n1) / k1;\n    vec3 n2 = vec3(k1, 2.0 * halfHeight * halfWidth, -halfDepth * halfWidth);\n    float m1 = dot(position - vec3(halfWidth, 0.0, halfDepth), n2) / dot(n2, n2);\n    vec3 d2 = position - clamp(position - n1 * h1 - n2 * max(m1, 0.0), vec3(0.0), vec3(halfWidth, 2.0 * halfHeight, halfDepth));\n    vec3 n3 = vec3(2.0 * halfHeight, halfWidth, 0.0);\n    float k2 = dot(n3, n3);\n    float h2 = dot(position - vec3(halfWidth, 0.0, halfDepth), n3) / k2;\n    vec3 n4 = vec3(-halfWidth * halfDepth, 2.0 * halfHeight * halfDepth, k2);\n    float m2 = dot(position - vec3(halfWidth, 0.0, halfDepth), n4) / dot(n4, n4);    \n    vec3 d3 = position - clamp(position - n3 * h2 - n4 * max(m2, 0.0), vec3(0.0), vec3(halfWidth, 2.0 * halfHeight, halfDepth));\n    float d = sqrt(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)));\n    return max(max(h1, h2), -position.y) < 0.0 ? -d : d;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdLink(in vec3 p, in float le, in float r1, in float r2)\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n//========================================================\n// Intersectors\n\n// https://iquilezles.org/articles/intersectors\nvec2 iSphere(in vec3 ro, in vec3 rd, in float rad)\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt(h);\n\treturn vec2( -b-h, -b+h );\n}\n\n// https://www.shadertoy.com/view/3sffzj\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) \n{\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 min_corner, vec3 max_corner)\n{\n    float eps = 1e-4;\n\treturn (p.x > min_corner.x-eps) && (p.y > min_corner.y-eps) && (p.z > min_corner.z-eps) && \n\t\t   (p.x < max_corner.x+eps) && (p.y < max_corner.y+eps) && (p.z < max_corner.z+eps);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*                                  \n\n                                                 ████                                               \n                   ██                            █████                              █████████       \n       █████      ██████             ███         ████████              ████   ██  █████   █████     \n      ███████     ███████           ██████  ██████████                 █████  ██  ████████████      \n        █████    ███████             █████    █ ██████████            ██████████  ███████████       \n                ██  █████            █████   ██ █████  █████         █████    ███ ██████████        \n              ███   ████████               █  ██ ███████████        ████████  ███████████           \n     █████  ████████████████        ██████ ██  █████████████       ██████████    ██████ █████       \n   █████████████████████          ████████ ████ ██████████            ██████    ███████ ██████      \n    ████████   ██ ███████          █████     ███████  ████           ███████ █████████ ██████       \n      █  ██     ██████████            ████    █  ████████████         ██████████ ██████████         \n     █  ██   ███████████               ██████████████████████          ███ ███████████   ██         \n     █ ███  ███   ████             ███████████   ███  █               █ ███ █   ██████     ██       \n    █ ███       ███████ █████      ████████      ███  █              █  ███      █████      ███     \n    ████   ████████████████████      ██ ████████ ██        ██         ████      ████████████████    \n    ███  ████████          ████               █████████████████         ████           █████████    \n                                                                                                    \n\n    注連縄 (Shimenawa) by Henry A.                 (Self: https://www.shadertoy.com/view/clVyzW)\n    \n    --LAYOUT------------------------------------------------------------------------------------\n    \n      COMMON: Colour schemes, Rendering settings, SDF primitives, Intersectors, and util funcs.\n       \n    BUFFER B: Perlin-Worley texture atlas generation for clouds. \n              (Source: https://www.shadertoy.com/view/3sffzj)\n              \n    BUFFER C: Scene rendering\n   \n    BUFFER D: HDR Bloom pass\n    \n       IMAGE: LDR Post processing (Tonemap, Gamma correction, etc.)\n       \n    --------------------------------------------------------------------------------------------\n    \n*/\n\n//==============================================================================================\n//  SOURCE: https://www.shadertoy.com/view/3sffzj\n//  Thank you alro for the noise implementation for the clouds here!\n//==============================================================================================\n\n//Create a Perlin-Worley texture atlas for cloud shape carving.\n//Runs only once in the first frame.\n//Based on https://github.com/sebh/TileableVolumeNoise/blob/master/main.cpp\n\n//The atlas is a 6*6 grid of 32*32 tiles with a single layer of halo cells around each tile. \n\n//TODO: Assumes a size of at least 204 * 204. Make it work with any reasonable resolution.\n\n#define PERLIN_WORLEY 0\n#define WORLEY 1\n\n#define SIZE 8.0\n#define NUM_CELLS 2.0\n\nvec3 modulo(vec3 m, float n) { return mod(mod(m, n) + n, n); }\n\n// 5th order polynomial interpolation\nvec3 fade(vec3 t) { return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0); }\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3)\n{\n    p3 = modulo(p3, SIZE);\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat gradientNoise(vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = fade(f);\n    \n    /*\n    * For 1D, the gradient of slope g at vertex u has the form h(x) = g * (x - u), where u \n    * is an integer and g is in [-1, 1]. This is the equation for a line with slope g which \n    * intersects the x-axis at u.\n    * For N dimensional noise, use dot product instead of multiplication, and do \n    * component-wise interpolation (for 3D, trilinear)\n    */\n    return mix( mix( mix( dot( hash(i + vec3(0.0,0.0,0.0)), f - vec3(0.0,0.0,0.0)), \n              dot( hash(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0)), \n              dot( hash(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0)), u.x), u.y),\n    mix( mix( dot( hash(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0)), \n              dot( hash(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0)), u.x),\n         mix( dot( hash(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0)), \n              dot( hash(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0)), u.x), u.y), u.z );\n}\n\n\nfloat getPerlinNoise(vec3 pos, float frequency)\n{\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\n\tfor(int oct = 0; oct < 3; oct++){\n\n        vec3 p = pos * frequency;\n        float val = 0.5 + 0.5 * gradientNoise(p);\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= 2.0;\n\t}\n\n\treturn saturate(sum / weightSum);\n}\n\nfloat worley(vec3 pos, float numCells)\n{\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++) {\n\t\tfor (int y = -1; y <= 1; y++) {\n\t\t\tfor (int z = -1; z <= 1; z++) {\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - (0.5 + 0.5 * hash(mod(tp, numCells)));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - saturate(d);\n}\n\n//Return the 3D coordinate corresponding to the 2D atlas uv coordinate.\nvec3 get3Dfrom2D(vec2 uv, float tileRows)\n{\n    vec2 tile = floor(uv);\n    float z = floor(tileRows * tile.y + tile.x);\n    return vec3(fract(uv), z);\n}\n\nfloat getTextureForPoint(vec3 p, int type)\n{\n\tfloat res;\n    if(type == PERLIN_WORLEY)\n    {\n        //Perlin-Worley.\n        float perlinNoise = getPerlinNoise(p, SIZE);\n        res = perlinNoise;\n\n        //Special weights from example code.\n        float worley0 = worley(p, NUM_CELLS * 2.0);\n        float worley1 = worley(p, NUM_CELLS * 8.0);\n        float worley2 = worley(p, NUM_CELLS * 14.0);\n\n        float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        res = remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n        \n\t} else {\n\n        //Worley\n        float worley0 = worley(p, NUM_CELLS);\n        float worley1 = worley(p, NUM_CELLS * 2.0);\n        float worley2 = worley(p, NUM_CELLS * 4.0);\n        float worley3 = worley(p, NUM_CELLS * 8.0);\n\n        float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n\t\tfloat FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n\t\tfloat FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n        res = FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n\t}\n    \n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iFrame < 1 || length(texelFetch(iChannel0, ivec2(0), 0).rgba) == 0.0)\n    {\n        vec3 col = vec3(0);\n        //32 with 1 pixel on either side.\n        float tileSize = 34.0;\n        float padWidth = 1.0;\n        float coreSize = tileSize - 2.0 * padWidth;\n        float tileRows = 6.0;\n        float tileCount = tileRows * tileRows;\n        vec2 tile = floor((fragCoord.xy - 0.5) / tileSize);\n\n        bool padCell = false;\n        if (mod(fragCoord.x, tileSize) == 0.5 || \n            mod(fragCoord.x, tileSize) == tileSize - 0.5) padCell = true;\n        if (mod(fragCoord.y, tileSize) == 0.5 ||\n            mod(fragCoord.y, tileSize) == tileSize - 0.5) padCell = true;\n\n        bool startPadX = false;\n        bool endPadX = false;\n        bool startPadY = false;\n        bool endPadY = false;\n\n        if (fragCoord.x == tile.x * tileSize + 0.5) startPadX = true;\n        if (fragCoord.y == tile.y * tileSize + 0.5) startPadY = true;\n        if (fragCoord.x == (tile.x + 1.0) * tileSize - 0.5) endPadX = true;\n        if (fragCoord.y == (tile.y + 1.0) * tileSize - 0.5) endPadY = true;\n\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 pixel;\n        vec2 uv;\n        \n        if(!padCell)\n        {\n            pixel = fragCoord.xy - padWidth - padding;\n            uv = vec2(pixel.xy / coreSize);\n        } else {\n            pixel = fragCoord.xy - padWidth - padding;\n            if (startPadX) pixel.x += coreSize;\t\n            if (startPadY) pixel.y += coreSize;\t\n            if (endPadX)   pixel.x -= coreSize;\t\n            if (endPadY)   pixel.y -= coreSize;\t\n            uv = vec2(pixel.xy / coreSize);\n        }\n        \n        vec3 p_ = get3Dfrom2D(uv, tileRows);\n        vec3 p = p_;\n        p.z /= (tileRows*tileRows);\n\n        // Get Perlin-Worley noise for level l\n        float worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        // Get Worley noise for level l\n        float worleyNoise = getTextureForPoint(p, WORLEY);\n        col.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, tileRows * tileRows);\n        p = p_;\n        p.z /= (tileRows*tileRows);\n\n        // Get Perlin-Worley noise for level l+1\n        worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        // Get Worley noise for level l+1\n        worleyNoise = getTextureForPoint(p, WORLEY);\n        col.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        // Unused cells\n        if(gl_FragCoord.x > tileRows * tileSize || gl_FragCoord.y > tileRows * tileSize)\n        {\n            col = vec3(0);\n        }\n        \n    \tfragColor = vec4(col,1.0);\n        \n    } else {\n        \n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).rgba;\n        \n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*                                  \n\n                                                 ████                                               \n                   ██                            █████                              █████████       \n       █████      ██████             ███         ████████              ████   ██  █████   █████     \n      ███████     ███████           ██████  ██████████                 █████  ██  ████████████      \n        █████    ███████             █████    █ ██████████            ██████████  ███████████       \n                ██  █████            █████   ██ █████  █████         █████    ███ ██████████        \n              ███   ████████               █  ██ ███████████        ████████  ███████████           \n     █████  ████████████████        ██████ ██  █████████████       ██████████    ██████ █████       \n   █████████████████████          ████████ ████ ██████████            ██████    ███████ ██████      \n    ████████   ██ ███████          █████     ███████  ████           ███████ █████████ ██████       \n      █  ██     ██████████            ████    █  ████████████         ██████████ ██████████         \n     █  ██   ███████████               ██████████████████████          ███ ███████████   ██         \n     █ ███  ███   ████             ███████████   ███  █               █ ███ █   ██████     ██       \n    █ ███       ███████ █████      ████████      ███  █              █  ███      █████      ███     \n    ████   ████████████████████      ██ ████████ ██        ██         ████      ████████████████    \n    ███  ████████          ████               █████████████████         ████           █████████    \n                                                                                                    \n\n    注連縄 (Shimenawa) by Henry A.                 (Self: https://www.shadertoy.com/view/clVyzW)\n    \n    --LAYOUT------------------------------------------------------------------------------------\n    \n      COMMON: Colour schemes, Rendering settings, SDF primitives, Intersectors, and util funcs.\n       \n    BUFFER B: Perlin-Worley texture atlas generation for clouds. \n              (Source: https://www.shadertoy.com/view/3sffzj)\n              \n    BUFFER C: Scene rendering\n   \n    BUFFER D: HDR Bloom pass\n    \n       IMAGE: LDR Post processing (Tonemap, Gamma correction, etc.)\n       \n    --------------------------------------------------------------------------------------------\n    \n*/\n\n// TODO:\n//   I had a few more computationally inexpensive ideas for this shader which i'd love to spend more time on, but alas.\n//\n//   - Pillars Rising and Dropping from the background, and potentially bridge segments.\n//   - Shooting Stars\n//   - Finish unused rope suspension code + wave ripples from animation.\n//   \n//================================================================================================================================================\n//--Consts and Debug---------------------------------------------------------------------------------------------------------------\n#define ZERO (min(iFrame,0))\n\n// Mathematical Consts\n#define PHI 1.61803399\n#define PI  3.14159265\n#define TAU 6.28318533\n\n// Debug (Orbital Mouse Controls) camera settings. Enable in common.\n//    Feel free to take a look around the scene from a different view ^^\n#define ORBIT_CAMERA_DIST 1.15\n#define ORBIT_CAMERA_TARGET vec3(0.0, -.1, 0.0)\n\n// Cinematic camera settings\n#define CAMERA_DIST 1.15\n#define CAMERA_TARGET vec3(0.0, -.1, 0.0)\n#define CAMERA_SPEED vec2(0.09, 0.07)\n\n// Debug Rendering settings\n#define RENDER_ROPE\n#define RENDER_PILLARS\n#define RENDER_BRIDGES\n#define RENDER_CLOUDS\n#define RENDER_FOG\n\n//--Bridge Construction Params-----------------------------------------------------------------------------------------------------\nconst float _BelowCloudBottom = 5.0;\nconst float _CloudBottomExtra = 150.0; // For blending into the clouds.\n\nconst float _BridgeStrutInterval = 3.50;\nconst float _BridgeNRep = 3.0;\nconst float _BridgeStrutOffset = 0.8;\nconst float _BridgeStrutThickness = 0.2;\nconst float _BridgeStrutRoundness = 0.01;\n\nconst float _BridgeTopWidth = 0.35;\nconst float _BridgeTopThickness = 0.25;\nconst float _BridgeTopBevelExtrusion = 0.03;\nconst float _BridgeTopBevelThickness = 0.05;\nconst float _BridgeTopRoundness = 0.005;\n\nconst float _BridgeWedgeHeight = 0.3;\nconst float _BridgeWedgeTopWidth = 2.2 * _BridgeStrutThickness;\nconst float _BridgeWedgeBevelHeight = 0.05;\nconst float _BridgeWedgeBevelExtrusion = 0.05;\nconst float _BridgeWedgeBevel2Ratio = 0.618; // height of second bevel along wedge\n\nconst float _BridgeStrutBoxFrameExtrusion = 0.04;\nconst float _BridgeStrutBoxFrameThickness = 0.03;\n\nconst float _BridgeBoxFrameBevelExtrusion = 0.03;\nconst float _BridgeBoxFrameBevelHeight = 0.04;\nconst float _BridgeBoxFrameBevelSep = 0.4;\nconst float _BridgeBoxFrameBevelBottomOffset = 1.618;\n\nconst float _BridgeLinkTopSpacing = 0.4;\nconst float _BridgeLinkThickness = 0.025;\n\nconst float _BridgeMiniStrutInterval = _BridgeStrutInterval / 4.0;\nconst float _BridgeMiniStrutNRep = 13.0;\nconst float _BridgeMiniStrutOffset = _BridgeStrutOffset - 0.5 * _BridgeMiniStrutInterval;\nconst float _BridgeMiniStrutHeight = 0.35;\nconst float _BridgeMiniStrutThickness = 0.075;\nconst float _BridgeMiniStrut_Y_Extrusion = 0.05;\nconst float _BridgeMiniStrut_Z_Extrusion = 0.07;\n\n//--Pillar Construction Params-----------------------------------------------------------------------------------------------------\nconst float _BelowCloudBottomPillar = 10.0;\n\nconst float _PillarRoundness = 0.001;\nconst float _PillarBevelRoundness = 0.01;\nconst float _PillarBevelExtrusion = 0.1;\nconst float _PillarBevelHeight = 0.5*0.075;\nconst float _PillarBevelNRep = 4.0;\n\nconst float _PillarVBevelExtrusion = 0.05;\nconst float _PillarVBevelThickness = 0.05;\nconst float _PillarVBevelRoundness = 0.03;\nconst float _PillarVBevel_N = 16.0; // TODO: High n looks bad at far distances due to aliasing, so LOD this.\n\nconst float _PillarCapHeight  = 0.47;\nconst float _PillarCapExtrusion = 0.45;\n\nconst float _PillarSegHeight = 4.3;\n\nconst float _LittlePillar_H = 1.0;\nconst float _LittlePillar_R = 0.125;\nconst float _LittlePillar_N = 3.0; // smaller numbers (generally odd) give better silhouettes across multiple viewing angles\n\n//--Rope Params--------------------------------------------------------------------------------------------------------------------\nconst vec3 _ShideWindParams = vec3(0.10, 4.0, 1.75); // Wave amplitude, distance modifier (stiffness), anim speed\nconst vec3 _ShideWindParams_s = vec3(0.013, 72.0, 3.5); // Smaller wind ripples\n\nconst vec2 _KiraretanawaWindParamsYZ = vec2(PI / 20.0, 2.3); // Max rot, anim speed\nconst vec2 _KiraretanawaWindParamsYX = vec2(PI / 30.0, 2.0);\n\nconst float _RopeSwaySpeed = 1.1;\nconst float _RopeSwayAmplitude = 0.007;\n\n//--Cloud Params-------------------------------------------------------------------------------------------------------------------\nconst vec3 _CloudSigmaS = vec3(1.0); // Inscattering coeff\nconst vec3 _CloudSigmaA = vec3(0.0); // Absorption coeff\nconst vec3 _CloudSigmaE = max(_CloudSigmaS + _CloudSigmaA, vec3(1e-6)); // Extinction coeff\n\nconst float _CloudWidth = 1500.0;\nconst float _CloudBot = -0.5*_CloudWidth;\nconst float _CloudTop = 10.0;\nconst vec3  _CloudMinCorner = vec3(-_CloudWidth, _CloudBot, -_CloudWidth);\nconst vec3  _CloudMaxCorner = vec3(_CloudWidth, _CloudTop, _CloudWidth);\n\nconst float _CloudDensityMultiplier = 0.075;\n\nconst float _CloudShapeSpeed  = -5.0;\nconst float _CloudShapeSize  = 0.05;\nconst float _CloudShapeStrength  = 0.7;\n\nconst float _CloudDetailSpeed = -10.0;\nconst float _CloudDetailSize = 0.3;\nconst float _CloudDetailStrength = 0.2;\n\n//--Materials----------------------------------------------------------------------------------------------------------------------\n#define MAT_ROPE 1.0\n#define MAT_SHIDE 2.0\n#define MAT_SHIDE_SECONDARY 3.0\n#define MAT_BRIDGE_STONE 4.0\n#define MAT_BRIDGE_BRASS 5.0\n#define MAT_PILLAR_STONE 6.0\n#define MAT_PILLAR_STONE_ALT 7.0\n#define MAT_PILLAR_GOLD  8.0\n#define MAT_PILLAR_GOLD_ALT 9.0\n#define MAT_DEBUG 10000.0\n\n//--Colour Schemes-----------------------------------------------------------------------------------------------------------------\n//----0: Day-------------------------------------------------------------------------------------------------------\n#if COLOUR_SCHEME == 0\n// Sun\nconst vec3  _SunPos  = vec3(30.0, 30.0, 30.0);\nconst float _SunSize = 3.0;\nconst vec3  _SunCol = vec3(0.98, 0.72, 0.31);\nconst float _SunBrightness = 0.9;\nconst float _SunHaloAttenuation = 1.4;\nconst float _SunHaloRadius = 3.0;\n\n// Atmosphere\nconst vec3 _ZenithCol = vec3(0.008, 0.067, 0.188);\nconst vec3 _ZenithBlendCol = vec3(0.157, 0.306, 0.561);\nconst vec3 _HorizonCol = 0.9*vec3(0.922, 0.898, 0.843);\nconst vec3 _NadirCol = _HorizonCol;\n\nconst float _ZenithAttenuation = 7.4;\nconst float _NadirAttenuation  = 1.0;\n\n// Clouds\nconst vec3  _CloudLightCol = _HorizonCol;\n//   Some of the clouds are blown out in this scheme because of this intsensity, but the silhouette remains, so meh.\nconst float _CloudLightIntensity = 65.0; \n\nconst vec3 _CloudAmbientCol = vec3(0.776, 0.890, 0.952);\nconst float _CloudAmbientWeightLow = 0.6;\nconst float _CloudAmbientWeightHigh = 1.5;\n\n// Fog\nconst float _FogDistBias = 1000.0;\nconst vec3  _FogColour = mix(_HorizonCol, _ZenithBlendCol, 0.65);\nconst vec3  _CloudFogColour = _HorizonCol;\nconst float _FogSunIntensity = 0.6;\nconst float _FogSunAttenuation = 6.0;\n\n// Materials\nconst vec3 _AmbientLightCol = _ZenithBlendCol;\n\nconst float _RopeShadowDarkness = 0.2; // higher is lighter\nconst float _RopeShadowAmbientAmt = 0.27;\nconst float _BridgeShadowDarkness = 0.025;\nconst float _BridgeShadowAmbientAmt = 0.45;\nconst float _PillarShadowDarkness = 0.015;\nconst float _PillarShadowAmbientAmt = 0.45;\nconst float _PillarAltShadowDarkness = 0.015;\nconst float _PillarAltShadowAmbientAmt = 0.45;\n\nconst vec3 _MatRope = 0.80*vec3(0.902, 0.714, 0.475);\nconst vec3 _RopeTerminatorLineCol = 0.6 * vec3(0.878, 0.204, 0.02);\n\nconst float _MatShideAmbientCoeff = 0.5;\nconst float _MatShideSSSCoeff = 0.25;\nconst vec3 _MatShide = vec3(1.0, 1.0, 1.0);\nconst vec3 _MatShideSecondary = 0.8*vec3(1.0, 0.242, 0.242);\n\nconst vec3 _MatBridgeStone = 2.0*mix(vec3(0.98, 0.671, 0.329), vec3(0.941, 0.941, 0.866), 0.56);\nconst vec3 _MatBridgeStoneFre = 1.0*vec3(0.00, 0.243, 0.502);\nconst vec3 _MatBridgeBrass = 0.8*vec3(0.840, 0.730, 0.370);\nconst vec3 _MatBridgeBrassSpe = 0.9*_SunCol;\n\nconst vec3 _MatPillarStone = _MatBridgeStone;\nconst vec3 _MatPillarStoneAlt = _MatBridgeStone;\nconst vec3 _MatPillarStoneAltFre = 2.35*vec3(0.00, 0.243, 0.502);\n#endif\n\n//----1: Sunset----------------------------------------------------------------------------------------------------\n#if COLOUR_SCHEME == 1\n// Sun\nconst vec3  _SunPos  = vec3(30.0, 10.0, 30.0);\nconst float _SunSize = 3.0;\nconst vec3  _SunCol = vec3(1.0, 0.529, 0.275);\nconst float _SunBrightness = 0.7;\nconst float _SunHaloAttenuation = 1.0;\nconst float _SunHaloRadius = 3.0;\n\nconst vec3 tst = vec3 (0.051, 0.063, 0.278);\nconst vec3 tst2 = vec3(0.173, 0.173, 0.388);\nconst vec3 tst3 = 1.2*vec3(0.961, 0.586, 0.290);\n\n// Atmosphere\nconst vec3 _ZenithCol = tst;\nconst vec3 _ZenithBlendCol = tst2;\nconst vec3 _HorizonCol = tst3;\nconst vec3 _NadirCol = _HorizonCol;\n\nconst float _ZenithAttenuation = 3.5;\nconst float _NadirAttenuation  = 1.0;\n\n// Clouds\nconst vec3  _CloudLightCol = _HorizonCol;\n//   Some of the clouds are blown out in this scheme because of this intsensity, but the silhouette remains, so meh.\nconst float _CloudLightIntensity = 65.0; \n\nconst vec3 _CloudAmbientCol = vec3(0.902, 0.828, 0.702);\nconst float _CloudAmbientWeightLow = 0.6;\nconst float _CloudAmbientWeightHigh = 1.5;\n\n// Fog\nconst float _FogDistBias = 1000.0;\nconst vec3  _FogColour = mix(_HorizonCol, _ZenithBlendCol, 0.65);\nconst vec3  _CloudFogColour = _HorizonCol;\nconst float _FogSunIntensity = 0.6;\nconst float _FogSunAttenuation = 6.0;\n\n// Materials\nconst vec3 _AmbientLightCol = mix(_ZenithBlendCol, _HorizonCol, 0.3);\n\nconst float _RopeShadowDarkness = 0.2; // higher is lighter\nconst float _RopeShadowAmbientAmt = 0.27;\nconst float _BridgeShadowDarkness = 0.025;\nconst float _BridgeShadowAmbientAmt = 0.45;\nconst float _PillarShadowDarkness = 0.010;\nconst float _PillarShadowAmbientAmt = 0.45;\nconst float _PillarAltShadowDarkness = 0.015;\nconst float _PillarAltShadowAmbientAmt = 0.45;\n\nconst vec3 _MatRope = 0.80*vec3(0.902, 0.714, 0.475);\nconst vec3 _RopeTerminatorLineCol = 0.8 * vec3(0.71, 0.043, 0.043);\n\nconst float _MatShideAmbientCoeff = 0.5;\nconst float _MatShideSSSCoeff = 0.25;\nconst vec3 _MatShide = vec3(1.0, 1.0, 1.0);\nconst vec3 _MatShideSecondary = 0.8*vec3(1.0, 0.242, 0.242);\n\nconst vec3 _MatBridgeStone = 1.5*mix(vec3(0.98, 0.671, 0.329), vec3(0.941, 0.941, 0.866), 0.56);\nconst vec3 _MatBridgeStoneFre = 0.2*vec3(0.71, 0.173, 0.173);\nconst vec3 _MatBridgeBrass = vec3(0.902, 0.729, 0.365);\nconst vec3 _MatBridgeBrassSpe = 1.5*vec3(0.98, 0.714, 0.298);\n\nconst vec3 _MatPillarStone = _MatBridgeStone;\nconst vec3 _MatPillarStoneAlt = _MatBridgeStone;\nconst vec3 _MatPillarStoneAltFre = 3.85*vec3(0.541, 0.159, 0.159);\n#endif\n\n//----2: Night-----------------------------------------------------------------------------------------------------\n#if COLOUR_SCHEME == 2\n// Sun\nconst vec3  _SunPos  = vec3(30.0, 20.0, 30.0);\nconst float _SunSize = 3.0;\nconst vec3  _SunCol = vec3(0.65, 0.8, 1.0);\nconst float _SunBrightness = 0.9;\nconst float _SunHaloAttenuation = 2.0;\nconst float _SunHaloRadius = 2.0;\n\n// Atmosphere\nconst vec3 _ZenithCol = vec3(0.0064, 0.013, 0.02);\nconst vec3 _ZenithBlendCol = _ZenithCol; // No blend\nconst vec3 _HorizonCol = vec3(0.0208, 0.04225, 0.065);\nconst vec3 _NadirCol = vec3(0.0064, 0.013, 0.02);\n\nconst float _ZenithAttenuation = 8.8;\nconst float _NadirAttenuation  = 0.2;\n\n// Clouds\nconst vec3  _CloudLightCol = vec3(0.65, 0.8, 1.0);\nconst float _CloudLightIntensity = 100.0;\n\nconst vec3 _CloudAmbientCol = _HorizonCol;\nconst float _CloudAmbientWeightLow = 4.0;\nconst float _CloudAmbientWeightHigh = 8.0;\n\n// Fog\nconst float _FogDistBias = 800.0;\nconst vec3  _FogColour = _HorizonCol;\nconst vec3  _CloudFogColour = _HorizonCol;\nconst float _FogSunIntensity = 0.22;\nconst float _FogSunAttenuation = 18.0;\n\n// Materials\nconst vec3 _AmbientLightCol = _HorizonCol;\n\nconst float _RopeShadowDarkness = 0.6; // higher is lighter\nconst float _RopeShadowAmbientAmt = 0.2;\nconst float _BridgeShadowDarkness = 0.6;\nconst float _BridgeShadowAmbientAmt = 0.15;\nconst float _PillarShadowDarkness = 0.6;\nconst float _PillarShadowAmbientAmt = 0.15;\nconst float _PillarAltShadowDarkness = 0.5;\nconst float _PillarAltShadowAmbientAmt = 0.15;\n\nconst vec3 _MatRope = 0.80*vec3(0.89, 0.631, 0.341);\nconst vec3 _RopeTerminatorLineCol = 0.5 * vec3(0.859, 0.761, 0.596);\n\nconst float _MatShideAmbientCoeff = 1.0;\nconst float _MatShideSSSCoeff = 0.3;\nconst vec3 _MatShide = vec3(1.0, 1.0, 1.0);\nconst vec3 _MatShideSecondary = vec3(1.0, 1.0, 1.0);\n\nconst vec3 _MatBridgeStone = 0.35*vec3(0.361, 0.329, 0.370);\nconst vec3 _MatBridgeStoneFre = 1.85*vec3(0.00, 0.243, 0.502);\nconst vec3 _MatBridgeBrass = 0.5*vec3(0.840, 0.730, 0.370);\nconst vec3 _MatBridgeBrassSpe = 0.9*_SunCol;\n\nconst vec3 _MatPillarStone = 0.15*vec3(0.969, 0.961, 0.918);\nconst vec3 _MatPillarStoneAlt = 0.6*vec3(0.969, 0.961, 0.918);\nconst vec3 _MatPillarStoneAltFre = 1.35*vec3(0.00, 0.243, 0.502);\n#endif\n\n//--Illumination-------------------------------------------------------------------------------------------------------------------\nconst vec3  _LightDir = normalize(_SunPos);\n\nconst float _HorizonOffset = 0.0;\n\nconst float _RopeExtraShadowBrightness = 0.025; // Set to zero for flat shaded look\n\nconst float _StarDist = 300.0;\nconst float _StarRepetitions = 4.0;\nconst vec3  _StarCol = vec3(1.0);\nconst float _StarIntensityContrast = 2.0; // this is an exponent\nconst float _Star_Y_Cutoff = -0.1; // in range [-1, 1]: normalized ray direction\nconst float _StarHorizonFadeStrength = 0.16;\nconst float _StarSunFadeSrength = 15.0;\nconst float _StarTwinkleSpeed = 1.5;\n\n// SSS Sun Outline\nconst vec3  _OutlineCol = _SunCol;\nconst float _OutlineDotThreshold = 0.95;\nconst float _OutlineRadialAttenuation = 2.0;\nconst float _OutlineMaxDist = 0.05;\nconst float _OutlineAttenuation = 16.0;\nconst float _OutlineExtraThickness = 0.0035;\n\n//==HELPER FUNCS==================================================================================================================================\n\n// Material Selection Helper Funcs\n#define CMP_MAT_LT(a, b) a < (b + 0.5)\n#define CMP_MAT_GT(a, b) a > (b - 0.5)\n\n// material comparisons\nvec2 MIN_MAT(vec2 a, vec2 b) { return (a.x < b.x) ? a : b; }\n\n// util functions for AO\n// https://www.shadertoy.com/view/ld3Gz2\nfloat hash1(float n) { return fract(sin(n)*43758.5453123); }\nfloat hash1(vec2 n)  { return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); }\nfloat hash2(vec2 n)  { return fract(74193.9957812*sin(dot(n,vec2(99.0,33.0)))); }\nfloat hash2(vec3 n)  { return fract(74193.9957812*sin(dot(n,vec3(99.3875,33.19193,57.10632)))); }\nfloat hash3(vec3 n)  { return fract(81537.7754108*sin(dot(n,vec3(26.4332,86.98591,97.68399)))); }\n\nvec3 forwardSF(float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n// Phase function for cloud isotropic scattering\n//  See PBR: From Theory to Implementation, Section 11.3\nfloat henyeyGreenstein(float g, float costh) \n{ \n    return (1.0 / (4.0 * PI)) * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5)); \n}\n\n//==SDF===========================================================================================================================================\n\n//--Shimenawa----------------------------------------------------------------------------------------------------------------------\nfloat sdHalo(in vec3 p, in float r) // Unused\n{\n    // Ring\n    float d = sdTorus(p, vec2(r, 0.008));\n    \n    // Rotational repetition\n    vec3 q = p;\n    float an = TAU/8.0;\n    q.xz *= rot(an);\n    \n    an = TAU/4.0;\n    float sector = round(atan(q.z,q.x)/an);\n    float angrot = sector*an;\n    q.xz *= rot(angrot);\n    //q.x *= 2.0;\n    q.x -= r;\n    \n    // Stones\n    d = min(d, sdOctahedron(q, 0.025));\n    \n    // Cords\n    if (p.y > 0.0) d = min(d, sdInfVerticalCylinder(q, 0.003*vec3(0.0, 0.0, 1.0)));\n    \n    return d;\n}\n\nfloat sdShide(in vec3 p, in int s_n, in float sec_id, out float seg_id)\n{\n    // 紙垂 (Shide) Multiple zig-zag boxes    \n    \n    // Rotate the whole thing 45c\n    p.yz = (p.yz + vec2(p.z, -p.y))*sqrt(0.5); // Shortcut for 45-degrees rotation\n\n    // Dimensions\n    vec3 dim = 0.02 * vec3(0.03, 1.0, 2.0); // 2:1:0.1 ratio\n    vec3 smallDim = dim;\n    smallDim.y /= 2.0;\n    smallDim.z *= 0.9;\n           \n    // Intensity of motion is determined by distance from connection point (to rope)\n    vec3 connectorPos = vec3(0., 2.0 * dim.y, -1.5 * dim.z);\n    float distToConnector = length(connectorPos - p);\n\n    // Thinner box, mount to rope    \n    vec3 thinShidePos = p + vec3(.0, -1.5 * dim.y, 0.9 * dim.z);\n    // Sinusoidal motion for wind\n    thinShidePos.x += _ShideWindParams.x * distToConnector * sin(\n        distToConnector * _ShideWindParams.y + _ShideWindParams.z * iTime + 53.0 * sec_id\n    );\n    float d = sdBox(thinShidePos, smallDim);\n    \n    // Rest of the zig-zag\n    seg_id = 0.0;\n    for (int i=0; i<s_n; i++)\n    {\n        vec3 shidePos = p + vec3(-5.0 * dim.x * mod(float(i+1), 2.0), 2.0 * dim.y * float(i), -dim.z * float(i));\n        shidePos.x += _ShideWindParams.x * distToConnector * sin(\n            distToConnector * _ShideWindParams.y + _ShideWindParams.z * iTime + 53.0 * sec_id\n        );\n        shidePos.x += _ShideWindParams_s.x * distToConnector * sin(\n            distToConnector * _ShideWindParams_s.y + _ShideWindParams_s.z * iTime + 13.0 * sec_id\n        );\n        float d2 = sdBox(shidePos, dim);\n        if (d2 < d) {d = d2; seg_id = float(i+1);}\n    }\n    \n    return d;\n}\n\n// p is position of top, s is scale\nfloat sdKiraretanawa(in vec3 p, in float s, in float connectorOffset, in float id)\n{\n    // TODO: Scaling is done in the SDF calls (i.e. by scaling dimensions by s), \n    //   but could be done by a simple pre-scaling of the domain (i.e. some q = p / s).\n    //   As the same scale is applied to all in the domain repetition, this prescaling wouldn't affect the SDF continuity.\n    \n    // Offset rotation to make object sway\n    p.yz *= rot(_KiraretanawaWindParamsYZ.x * sin(_KiraretanawaWindParamsYZ.y * 0.89 * iTime + 71.0 * id));\n    p.yx *= rot(_KiraretanawaWindParamsYX.x * cos(_KiraretanawaWindParamsYX.y * 0.57 * iTime + 31.0 * id));\n    p.y += connectorOffset;\n        \n    float d = sdCone(p + s * vec3(0., 0.6, 0.), vec3(0.), s * vec3(0.,0.5,0.), s * 0.32, s * 0.1) - s * 0.05;\n    d = min(d, sdCappedCylinder(p, s * 0.06, s * 0.12) - s * 0.015);\n    \n    {\n    // Binding rope, 3 for cost of 1\n    vec3 q = p;\n    q.y = abs(p.y + s * 0.02) - s * 0.0165; // XZ plane symmetry for duplication, and translate downwards\n    q.y = abs(q.y) - s * 0.0165;\n    d = min(d, sdTorus(q, vec2(s * 0.15, s * 0.013)));\n    }\n    \n    // Connecting rope\n    d = min(d, sdCappedCylinder(p - vec3(0.0, connectorOffset/2.0, 0.0), connectorOffset, s * 0.013));\n    \n    return d;\n}\n\n\nfloat sdSwirl(vec3 p, in float r, in float c, in float f, out float id)\n{\n    // Rotate and twist a capsule to make the rope along the x axis\n    float l = TAU * r; // circumference rope length\n    \n    p.yz*=rot(p.x*PI*f); // twisting; 45-deg per x\n    vec2 sector = step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y;\n    p.y = abs(p.y) - 0.02;\n    \n    float d = sdVerticalCapsule(p,c,l); //Potentially better solution exists with capped torus\n    return d;\n}\n\nvec2 sdShimenawa(in vec3 p, in float r, in float c, in float f, out float id)\n{\n    // しめ縄\n    vec2 res = vec2(1e10);\n    \n    // Bounding sphere\n    float d = sdSphere(p, r + 0.2);\n    if (d > 0.5) return vec2(d, 1e10);\n\n    float ring_t = 0.0;\n    float dRing = sdCircleXZ(p, r, ring_t);\n    ring_t = 1.0 - ring_t; // reflect rope direction\n    \n    // TODO: this stretches non rope parts, but is not noticeable at low amplitudes.\n    p.y = p.y + 0.007*sin(2.0*2.0*PI*ring_t+_RopeSwaySpeed*iTime); // Rope sway\n    \n    // Swirly Rope\n    if (dRing < 0.8) // approx bounding ring\n    {    \n        // I'm fairly confident this local-UV transformation messes up the SDF but... oh well.\n        vec3 ring_uv = vec3(ring_t * TAU * r, p.y, dRing);\n        res = vec2(sdSwirl(ring_uv, r, c, f, id), MAT_ROPE);\n    }\n    \n    // Shide\n    {\n    vec3 q = p;\n    const float an = TAU/7.0;\n    float sector = round(atan(p.z,p.x)/an);\n    float angrot = sector*an;\n    q.xz *= rot(angrot);\n    float seg_id;\n    float d = sdShide(q - vec3(r + 0.4*c, -2.3*c, 0.0), 4, sector+1.0, seg_id);\n    float shide_mat = (mod(seg_id, 2.0) == 0.0) ? MAT_SHIDE : MAT_SHIDE + 1.0;\n    res = MIN_MAT(res, vec2(d, shide_mat));\n    }\n    \n    // Cut Ropes\n    {\n    // TODO: This rotation is horrendously jank - I *should* fix it.\n    vec3 q_s = p;\n    \n    // Prerotate offset\n    float an = TAU/14.0;\n    q_s.xz *= rot(an);\n    \n    an = TAU/7.0;\n    float sector = round(atan(q_s.z,q_s.x)/an);\n    float angrot = sector*an;\n    q_s.xz *= rot(angrot);\n    float d = sdKiraretanawa(q_s - vec3(r, -1.4*c, 0.0), 0.14, 0.05, sector+1.0);\n    res = MIN_MAT(res, vec2(d, MAT_ROPE));\n    }\n    \n    #if 0\n    // Suspension (unused, but kinda cool)\n    {\n    // TODO: wave ripple effect on rope from each pull of a suspension rope\n    vec3 q = p;\n    \n    float an = TAU/10.0;\n    q.xz *= rot(an);\n    \n    an = TAU/5.0;\n    float sector = round(atan(q.z,q.x)/an);\n    float angrot = sector*an;\n    q.xz *= rot(angrot);\n    \n    const float halo_speed = 2.0;\n    \n    float hash_id = hash1(sector);\n    float signal_t = 131.3389*hash_id + halo_speed * hash_id * iTime;\n    float signal = sin(signal_t); // periodic signal for movement\n    signal = pow(signal, 6.0); // make movement more sharp\n    float signal_mask = 1.0 - step(1.0, mod(floor(signal_t/PI), 6.0)); // mask out n repetitions\n    signal *= signal_mask; // apply mask;\n    \n    q.y -= 0.12*signal;\n    \n    float d = sdHalo(q - vec3(0.9*r, 0.25, 0.0), 0.1);\n    res = MIN_MAT(res, vec2(d, MAT_SHIDE));\n    \n    }\n    #endif\n    \n    res.x *= 0.8; // Deal with messed up SDF T^T\n    return res;\n}\n\n//--Pillars------------------------------------------------------------------------------------------------------------------------\nvec2 sdPillarSeg( \n    in vec3 p, in float r, in float seg_h,\n    in float seg_n_sep, in float seg_n_bevels, in float n_small_pillars)\n{\n    // Radial scale - 1.0 is base scale, can be changed.\n    //   Want to keep nice ratio between main pillar radius and the size of objects which comprise the gap,\n    //   so scale these objects by a factor in comparison to a base radius which has a aesthetically pleasing ratio.\n    float rs = r / 1.0; \n    \n    // I am so sorry if you happen to unfortunately read this\n    float rs_PillarCapHeight = rs*_PillarCapHeight;\n    float rs_PillarCapExtrusion = rs*_PillarCapExtrusion;\n    float rs_LittlePillar_H = rs*_LittlePillar_H;\n    float rs_LittlePillar_R = rs*_LittlePillar_R;\n    float rs_PillarBevelHeight = rs*_PillarBevelHeight;\n    float rs_PillarBevelExtrusion = rs*_PillarBevelExtrusion;\n    float rs_PillarVBevelExtrusion = rs*_PillarVBevelExtrusion;\n    float rs_PillarVBevelThickness = rs*_PillarVBevelThickness;\n    \n    // TODO: Could LOD this pillar segment.\n    vec2 res = vec2(1e10);\n    \n    float pillar_height = seg_h - 0.5*rs_PillarCapHeight;\n    \n    // Bounding Volume (Exact Cylinder)\n    float d = sdCappedCylinder(p, 2.0*(seg_h + rs_LittlePillar_H) + rs_PillarCapHeight + rs_PillarBevelHeight, r + rs_PillarCapExtrusion);\n    if (d > 1.0) return vec2(d, 1e10);\n    \n    // big cylinder\n    vec3 cyl_base = p + vec3(0.0, 0.5*rs_PillarCapHeight, 0.0);\n    res = MIN_MAT(res, vec2(\n        sdCappedCylinder(cyl_base, pillar_height, r) - _PillarRoundness,\n        MAT_PILLAR_STONE\n    ));\n    \n    // horizontal bevels\n    {\n    vec3 q = cyl_base + vec3(0.0, pillar_height, 0.0);\n    float interval = 2.0*pillar_height / seg_n_sep;\n    float rep_id = clamp(round((q.y / interval)), 0.0, seg_n_sep);\n    q.y -= rep_id * interval;\n    res = MIN_MAT(res, vec2(\n        sdCappedCylinder(q, rs_PillarBevelHeight, r + rs_PillarBevelExtrusion) - _PillarBevelRoundness,\n        MAT_PILLAR_GOLD\n    ));\n    }\n    \n    // vertical bevels (to look like pillar indents)\n    {\n    vec3 q = cyl_base;\n    \n    //   rotatational domain repetition\n    float an = TAU/seg_n_bevels;\n    float sector = round(atan(q.z,q.x)/an);\n    float angrot = an*(sector);\n    q.xz *= rot(angrot);\n    \n    res = MIN_MAT(res, vec2(\n        sdBox(q - vec3(r, 0.0, 0.0), vec3(rs_PillarVBevelExtrusion, pillar_height, rs_PillarVBevelThickness)) - _PillarVBevelRoundness,\n        MAT_PILLAR_STONE\n    ));\n    }\n    \n    // small radial sub-pillars\n    {\n    vec3 q = p;\n    q.y -= seg_h + rs_LittlePillar_H;\n    \n    //   rotatational domain repetition\n    float an = TAU/n_small_pillars;\n    float sector = round(atan(q.z,q.x)/an);\n    float angrot = an*(sector);\n    q.xz *= rot(angrot);\n\n    res = MIN_MAT(res, vec2(\n        sdCappedCylinder(q - vec3(0.7*r, 0.0, 0.0), rs_LittlePillar_H, rs_LittlePillar_R),\n        MAT_PILLAR_STONE\n    ));\n    }\n    \n    // Cone caps\n    {\n    vec3 q = p;\n    q.y -= seg_h - rs_PillarCapHeight;\n    float interval = 2.0*rs_LittlePillar_H + rs_PillarCapHeight;\n    float rep_id = clamp(round((q.y / interval)), 0.0, 1.0);\n    q.y -= rep_id * interval;\n    res = MIN_MAT(res, vec2(\n        sdCone(q, vec3(0.0), vec3(0.0, rs_PillarCapHeight, 0.0), r, r + rs_PillarCapExtrusion) - _PillarRoundness,\n        MAT_PILLAR_STONE\n    ));\n    }\n        \n    return res;\n}\n\nvec2 sdPillar( \n    in vec3 p, in float n_rep, in float r, in float seg_h, \n    in float seg_n_sep, in float seg_n_bevels, in float n_small_pillars)\n{    \n    float rs = r / 1.0; // Factor in radial scale of pillar ( see comment in sdPillarSeg() )\n    float full_pillar_height = 2.0*(seg_h + rs*_LittlePillar_H) + rs*_PillarCapHeight;\n    p.y += _BelowCloudBottomPillar - 0.5 * full_pillar_height;\n    \n    // check i = n'th repetition for current rep's SDF\n    float rep_id = clamp(round((p.y / full_pillar_height)), 0.0, n_rep);\n    p.y -= rep_id * full_pillar_height;\n\n    vec2 res = sdPillarSeg(p, r, seg_h, seg_n_sep, seg_n_bevels, n_small_pillars);\n    \n    if (rep_id < 1.0) return res;\n    \n    // check i = n-1'th repetition to ensure SDF correctness.\n    p.y += full_pillar_height;\n    res = MIN_MAT(res, sdPillarSeg(p, r, seg_h, seg_n_sep, seg_n_bevels, n_small_pillars));\n\n    return res;\n}\n\nvec2 sdPillars(in vec3 p, in vec3 ro)\n{            \n    const vec2 spacing = vec2(145.0);\n    const float len_spacing = length(spacing);\n\n    // Maximum and minimum radial extents of the domain repetition defined by 2 params (r, t)\n    //  TODO: I would like this to be independent of spacing, but it messes with the SDF so i cba\n    const float ring_rad = 2.5;\n    const float ring_thickness = 6.0;\n    const float ext_min = ring_rad - ring_thickness;\n    const float ext_max = ring_rad + ring_thickness;\n    \n    vec2 res = vec2(1e10);\n           \n    vec2 base_id = round(p.xz / spacing);\n    float len_base_id = length(base_id);\n        \n    // Early exit on maximum extent for opt (no more pillars beyond this point so raymarch accuracy not affected)\n    //   Also early exit when y drops below a certain level (i.e. we are in dense cloud)\n    if (len_base_id > ext_max || p.y < 20.0 || p.y > 500.0 ) return vec2(1e10);\n    \n    vec2 o = -sign(ro.xz - spacing * base_id); // cut down on the amount of neighbour comparisons\n    \n    // Fix the Domain Rep SDF by checking closest neighbours\n    for (int i=0; i<2; i++)\n    for (int j=0; j<2; j++)\n    {\n    \n    vec2 id = base_id + o*vec2(i, j);\n    float len_id = length(id);\n    \n    // Cull pillars outside of ring\n    if (len_id > ext_max) continue;\n    \n    float id_hash1 = hash1(id);\n    float id_hash2 = hash2(id);\n        \n    // Near and far heights - for a dynamic scene, make further away pillars *considerably* larger.\n    float far = step(ring_rad, len_id);\n    \n    float height_dev = (far == 1.0) ? 5.0 : 2.0;\n    float height_avg = (far == 1.0) ? 8.0: 5.0;\n    float height_bias = 2.0 * (smoothstep(ext_min, ext_max, len_id) * id_hash1) - 1.0; // generate taller pillars when further away\n    float height = height_avg + height_dev * height_bias;\n    height *= 1.2;\n\n    float nseg = 2.0 + floor(2.0*id_hash2);\n    \n    float quick_hash3 = fract(id_hash1 * id_hash2);\n    float n_pillar = 2.0 + 2.0*floor(2.0 * quick_hash3) + 1.0; // 3 or 5 pillars for better silhouette (even is bad)\n    float h_offset = len_id * 2.0 * quick_hash3;\n    \n    vec3 q = p;\n    q.xz = p.xz - spacing * id;\n    q.xz *= rot(id_hash1 * 2.0 * PI);\n    q.xz += 0.40 * spacing * (sin(131.5 * id.x + 13.8 * id.y + vec2(1.5, 0.0))); // any more spacing than this and the SDF will implode\n    q.y += h_offset;\n\n    // Colour some pillars with alt colour scheme\n    bool alt = quick_hash3 > 0.49 && quick_hash3 < 0.57;\n    float rad_mult = (alt) ? 0.58 : 0.8;\n\n    vec2 tile_res = sdPillar(q, nseg, rad_mult*height, 3.0*height, 4.0, 16.0, n_pillar);\n    if (alt) tile_res.y++;\n\n    res = MIN_MAT( res, tile_res );\n    \n    }\n    \n    // TODO: This is not actually id-based and is in fact just some arbitrary number\n    res.x = max(res.x, abs(len_base_id - ring_rad) - ring_thickness);\n    \n    \n    return res;\n}\n\n//--Bridges------------------------------------------------------------------------------------------------------------------------\nvec2 sdBridgeStrut(in vec3 strut_base, in float h) \n{\n    vec2 res = vec2(1e10);\n    \n    // strut beam\n    vec3 q = strut_base;\n    res = MIN_MAT(res, vec2(\n        sdBox(\n            q, \n            vec3(_BridgeStrutThickness, h, _BridgeStrutThickness)\n        ) - _BridgeStrutRoundness, \n        MAT_BRIDGE_STONE\n    ));\n\n    // strut-bridge connector wedge\n    q = strut_base - vec3(0.0, h - _BridgeWedgeHeight, 0.0);\n    res = MIN_MAT(res, vec2(\n        sdPrism(\n            q,\n            _BridgeStrutThickness, \n            _BridgeWedgeTopWidth, \n            _BridgeWedgeHeight, \n            _BridgeStrutThickness\n        ) - _BridgeStrutRoundness, \n        MAT_BRIDGE_STONE\n    ));\n\n    // wedge bevels\n    //   first wedge\n    q = strut_base - vec3(0.0, h, 0.0);\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(\n            _BridgeWedgeTopWidth + _BridgeWedgeBevelExtrusion, \n            _BridgeWedgeBevelHeight, \n            _BridgeStrutThickness + _BridgeWedgeBevelExtrusion)\n        ) - _BridgeStrutRoundness,\n        MAT_BRIDGE_BRASS\n    ));\n    //   second wedge\n    q.y += 2.0 * _BridgeWedgeHeight * (1.0 - _BridgeWedgeBevel2Ratio);\n    res = MIN_MAT(res, vec2( \n        sdBox(q, vec3(\n            mix(_BridgeStrutThickness, _BridgeWedgeTopWidth, _BridgeWedgeBevel2Ratio) + _BridgeWedgeBevelExtrusion, \n            _BridgeWedgeBevelHeight / 2.0, \n            _BridgeStrutThickness + _BridgeWedgeBevelExtrusion)\n        ) - _BridgeStrutRoundness,\n        MAT_BRIDGE_BRASS\n    ));\n\n    // box frame\n    q = strut_base; q.y += _BridgeWedgeHeight;\n    float box_frame_height = h - _BridgeWedgeHeight;\n    res = MIN_MAT(res, vec2(\n        sdBoxFrame(q, vec3(\n            _BridgeStrutThickness + _BridgeStrutBoxFrameExtrusion, \n            box_frame_height, \n            _BridgeStrutThickness + _BridgeStrutBoxFrameExtrusion\n        ), _BridgeStrutBoxFrameThickness) - _BridgeStrutRoundness,\n        MAT_BRIDGE_STONE\n    ));\n\n    // box frame bevels\n    float box_frame_top_offset = _BridgeWedgeHeight - box_frame_height + _BridgeBoxFrameBevelHeight;\n    // top\n    q = strut_base;\n    q.y += box_frame_top_offset; // translate up along strut\n     // domain repetition (reflection in xz plane), and center about top bevel.\n    q.y = abs(q.y + 0.5 * _BridgeBoxFrameBevelSep) - 0.5 * _BridgeBoxFrameBevelSep;\n    float bevel_width = _BridgeStrutThickness + _BridgeStrutBoxFrameExtrusion + _BridgeBoxFrameBevelExtrusion;\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(\n            bevel_width,\n            _BridgeBoxFrameBevelHeight,\n            bevel_width)\n        ) - _BridgeStrutRoundness,\n        MAT_BRIDGE_BRASS\n    ));\n\n    // bottom\n    q = strut_base;\n    q.y += box_frame_top_offset + _BridgeBoxFrameBevelSep + _BridgeBoxFrameBevelBottomOffset; // translate up along strut\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(\n            bevel_width,\n            _BridgeBoxFrameBevelHeight,\n            bevel_width)\n        ) - _BridgeStrutRoundness,\n        MAT_BRIDGE_BRASS\n    ));\n\n\n    // link\n    q.y -= 0.5 * _BridgeBoxFrameBevelBottomOffset;\n    q.z -= _BridgeStrutThickness + _BridgeLinkThickness;\n    res = MIN_MAT(res, vec2(\n        sdLink(q, 0.65*0.5*_BridgeBoxFrameBevelBottomOffset, 0.10, _BridgeLinkThickness),\n        MAT_BRIDGE_BRASS\n    ));\n    \n    return res;\n}\n\nvec2 sdBridgeStrutLOD(in vec3 strut_base, in float h) \n{\n    vec2 res = vec2(1e10);\n    \n    // strut beam\n    vec3 q = strut_base;\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(_BridgeStrutThickness, h, _BridgeStrutThickness)) - _BridgeStrutRoundness, \n        MAT_BRIDGE_STONE\n    ));\n\n    // strut-bridge connector wedge\n    q = strut_base - vec3(0.0, h - _BridgeWedgeHeight, 0.0);\n    res = MIN_MAT(res, vec2(\n        sdPrism(\n            q, \n            _BridgeStrutThickness, \n            _BridgeWedgeTopWidth, \n            _BridgeWedgeHeight,\n            _BridgeStrutThickness\n        ) - _BridgeStrutRoundness, \n        MAT_BRIDGE_STONE\n    ));\n    \n    return res;\n}\n\nvec2 sdBridgeTop(in vec3 p, in float h, in float l) \n{\n    vec2 res = vec2(1e10);\n    \n    vec3 q = p - vec3(l, _BridgeTopThickness, 0.0);\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(l, _BridgeTopThickness, _BridgeTopWidth)),\n        MAT_BRIDGE_STONE\n    ));\n    // bridge top bevels\n    q.y = abs(q.y) - _BridgeTopThickness + _BridgeTopBevelThickness; // domain repetition\n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(l, _BridgeTopBevelThickness, _BridgeTopWidth + _BridgeTopBevelExtrusion)),\n        MAT_BRIDGE_BRASS\n    ));\n    \n    return res;\n}\n\nvec2 sdBridgeTopStruts(in vec3 p, in float h, in float l)\n{\n    vec2 res = vec2(1e10);\n    \n    // mini struts        \n    //   block\n    vec3 q = p;\n    //      domain repetition (reflection in xz plane), and center about top bevel.\n    q.z = abs(q.z) - _BridgeTopWidth + _BridgeMiniStrutThickness - _BridgeMiniStrut_Z_Extrusion; \n    res = MIN_MAT(res, vec2(\n        sdBox(q, vec3(_BridgeMiniStrutThickness, _BridgeMiniStrutHeight, _BridgeMiniStrutThickness)),\n        MAT_BRIDGE_STONE\n    ));\n\n    //   spike\n    q.y += _BridgeMiniStrutHeight + _BridgeMiniStrutThickness;\n    q.y = -q.y;\n    res = MIN_MAT(res, vec2(\n        sdPyramid(q, _BridgeMiniStrutThickness, _BridgeMiniStrutThickness, _BridgeMiniStrutThickness),\n        MAT_BRIDGE_BRASS\n    ));\n    \n    return res;\n}\n\nvec2 sdBridgeSegment(in vec3 p, in float h, in float l)\n{\n    vec2 res = vec2(1e10);\n            \n    // Transform to correct origin plane in y\n    //p.y += _BelowCloudBottom - h;\n    \n    // Bounding box\n    // TODO: Could create a more exact bounding box here if needed.\n    float d = sdBox(p, vec3(2.0*l, h + _BridgeTopThickness + 0.3, _BridgeTopWidth + 0.05));\n    if (d > 1.0) return vec2(d, 1e10);\n    \n    // Domain repetition for struts - render as many struts as we like for the price of one.\n    vec3 strut_base = p - vec3(_BridgeStrutOffset, 0.0, 0.0);\n    float rep_id = clamp(round((strut_base.x / _BridgeStrutInterval)), 0.0, _BridgeNRep);\n    strut_base.x -= rep_id * _BridgeStrutInterval;\n    \n    res = MIN_MAT(res, sdBridgeStrut(strut_base, h));\n    \n    vec3 top_base = p - vec3(0.0, h, 0.0);\n    res = MIN_MAT(res, sdBridgeTop(top_base, h, l));\n\n    // Domain repetition for struts - render as many struts as we like for the price of one.\n    vec3 mini_strut_base = p - vec3(_BridgeMiniStrutOffset, h + _BridgeMiniStrutHeight - _BridgeMiniStrut_Y_Extrusion, 0.0);\n    rep_id = clamp(round((mini_strut_base.x / _BridgeMiniStrutInterval)), 0.0, _BridgeMiniStrutNRep);\n    mini_strut_base.x -= rep_id * _BridgeMiniStrutInterval;\n\n    res = MIN_MAT(res, sdBridgeTopStruts(mini_strut_base, h, l));\n    \n    return res;\n}\n\nvec2 sdBridgeSegmentLOD(in vec3 p, in float h, in float l)\n{\n    vec2 res = vec2(1e10);\n                \n    // Bounding box\n    // TODO: Could create a more exact bounding box here if needed.\n    float d = sdBox(p, vec3(2.0*l, h + _BridgeTopThickness + 0.3, _BridgeTopWidth + 0.05));\n    if (d > 1.0) return vec2(d, 1e10);\n    \n    // Domain repetition for struts - render as many struts as we like for the price of one.\n    vec3 strut_base = p - vec3(_BridgeStrutOffset, 0.0, 0.0);\n    float rep_id = clamp(round((strut_base.x / _BridgeStrutInterval)), 0.0, _BridgeNRep);\n    strut_base.x -= rep_id * _BridgeStrutInterval;\n    \n    res = MIN_MAT(res, sdBridgeStrutLOD(strut_base, h));\n    \n    vec3 top_base = p - vec3(0.0, h, 0.0);\n    res = MIN_MAT(res, sdBridgeTop(top_base, h, l));\n    \n    return res;\n}\n\nvec2 sdInfiniteBridge(in vec3 p, in vec3 o, in float an, in float h, in float scale)\n{\n    bool use_lod = length(p) > BRIDGE_LOD_DIST;\n\n    // Map bridge to line in XZ plane with line origin (o) and direction in XZ defined by angle from x basis vector (an).\n    // Translate to point on bridge line\n    p -= o;\n    \n    // Rotate domain to fit bridge to desired line\n    p.xz *= rot(an);\n\n    float seg_l = 12.5; \n    p.x = p.x - 2.0*seg_l * round((p.x - seg_l) / (2.0*seg_l));;\n    p.y += _BelowCloudBottom - h;\n\n    p /= scale;\n    h /= scale;\n    \n    vec2 res = use_lod ? \n        sdBridgeSegmentLOD(p, h, seg_l) :\n        sdBridgeSegment(p, h, seg_l);\n        \n    res.x *= scale;\n    \n    return res;\n}\n\n//==ATMOSPHERE==================================================================================================================================\nvec3 stars(in vec3 rd, in float sun_dist)\n{\n    // TODO: Would love some subtle shooting stars here\n\n    // Set up arbitrary skew rotation matrix for repetition\n    const vec3 coeff = vec3(0.6, 0.3, 0.1); // scaling coefficients\n    //   Use first two pythagorean triplets for approximation of matrix rotation values instead of slow cos/sin funcs.\n    const vec4 trig = vec4(3.0/5.0, 4.0/5.0, 5.0/13.0, 12.0/13.0); // cos a, sin a, cos b, sin b\n    //   Stick above into general rotation matrix\n    const mat3 rot_mat = mat3(\n        dot(coeff, vec3(1.0, trig.x, trig.z)), coeff.z*trig.w, coeff.y*trig.y,\n        -trig.w*coeff.z, dot(coeff, vec3(1.0, 1.0, trig.z)), 0.0,\n        -trig.y*coeff.y, 0.0, dot(coeff, vec3(1.0, trig.x, 1.0))\n    );\n\n    float ray_intensity = 0.0; \n    float star_intensity;\n    \n    // Accumulate colour of multiple repetitions\n    vec3 p = rd * _StarDist;\n        \n    if (rd.y < _Star_Y_Cutoff) return vec3(0.0); // Don't render stars far below cloud \n        \n    for (float i = 0.0; i < _StarRepetitions; i++)\n    {\n        vec3 q = fract(p) - 0.5;\n        vec3 id = floor(p);\n        float id_hash = hash2(id);\n        float id_hash2 = hash3(id);\n        star_intensity  = smoothstep(0.25, 0.0, dot(q, q)); // Size\n        star_intensity *= step(id_hash, 0.02-0.002*i*i);  // Distance-based intensity\n        star_intensity *= min(0.25*id_hash + sin(14513.32*id_hash + id_hash2*_StarTwinkleSpeed*iTime), 1.0); // twinkle\n        ray_intensity  += star_intensity;\n        p *= rot_mat; // Rotate star space for repetition\n    }\n    ray_intensity = pow(ray_intensity, _StarIntensityContrast); // Distance intensity contrast\n    \n    // Make star clusters: Density-based intensity modifier.\n    float density = dot(sin(rd*10.55), cos(rd.yxz*4.13)); // Quick high & low density blobs\n    density = mix(smoothstep(-3.4, -0.9, density), smoothstep(-0.3, 1.0, density), 0.5); // Smooth low and high blobs out with smoothstep\n    density = mix(density*density, density, 0.5); // increase blob contrast \n    \n    ray_intensity *= density;\n    \n    // fade off stars near sun and horizon to mimic some sort of camera exposure\n    float horizon_mask = clamp(pow(0.5*(rd.y - _Star_Y_Cutoff) / _StarHorizonFadeStrength, 2.0), 0.0, 1.0);\n    float sun_mask = smoothstep(0.0, 1.0, (clamp((sun_dist - _SunHaloRadius) / _StarSunFadeSrength, 0.0, 1.0)));\n                        \n    ray_intensity *= horizon_mask;\n    ray_intensity *= sun_mask;\n    \n    return clamp(_StarCol * ray_intensity, 0.0, BLOOM_THRESHOLD); // Don't bloom\n}\n\nvec3 sky(in vec3 ro, in vec3 rd) \n{\n    // Make sun always appear as if viewed from a certain point to deal with the fact it\n    //  is infact very close geometrically.\n    vec3 sun_pov_origin = vec3(0.0);\n    float sun_dist = length(_SunPos);\n    float dist = length(_SunPos - (sun_pov_origin + rd * sun_dist)) - _SunSize;\n    dist = dist < 0.0 ? 0.0 : dist;\n    \n    float ry = _HorizonOffset + rd.y;\n        \n    // Atmosphere\n    float zenith  = 1.0 - pow(min(1.0, 1.0 - ry), _ZenithAttenuation);\n    float nadir   = 1.0 - pow(min(1.0, 1.0 + ry), _NadirAttenuation);\n    float horizon = 1.0 - zenith - nadir;\n    \n    vec3 zenith_col = mix(_ZenithBlendCol, _ZenithCol, rd.y);\n    \n    vec3 skycol = zenith * zenith_col + nadir * _NadirCol + horizon * _HorizonCol;\n        \n    // Sun\n    float halo = pow((_SunHaloRadius/dist), _SunHaloAttenuation);\n    vec3 sun = halo * _SunCol;\n    vec3 suncol = 1.0 - exp(-sun);\n    suncol *= _SunBrightness;\n    skycol += suncol;\n        \n    // Stars\n    #if defined(STARS) && COLOUR_SCHEME == 2\n    skycol += stars(rd, dist);\n    #endif\n    \n    return skycol;\n}\n\nvec3 fog(in vec3 col, in float t, in vec3 rd, bool cloud)\n{\n    vec3 fog_col = cloud ? _CloudFogColour : _FogColour; // so the clouds can be blended into the horizon separately.\n    float amt = 1.0 - exp(-t/_FogDistBias);\n    \n    // Add some light scattering from the sun\n    float sun_factor = max(dot(rd, _LightDir), 0.0);\n    if (!cloud) fog_col = mix( fog_col, _FogSunIntensity*_SunCol, pow(sun_factor, _FogSunAttenuation) );\n    \n    return mix(col, fog_col, amt);\n}\n\n// TODO: I don't think this scales well with distance / object size.\nvec3 sunSSSOutline(in vec3 ro, in vec3 rd, in float d)\n{\n    // Create an outline around objects within a certain radius around the sun.\n    //    The view direction dot product can be used to determine the radius.\n    //    Raymarching near misses are used to generate the outline. \n    //   Then, a power curve is used to decay the outline based on distance from the edge of the sun.\n    float rd_dot_sun = dot(rd, normalize(_SunPos - ro));\n    \n    float angle_factor = 1.0 / (1.0 - _OutlineDotThreshold) * (max(0.0, rd_dot_sun - _OutlineDotThreshold));\n    angle_factor = pow(angle_factor, _OutlineRadialAttenuation);\n    \n    // It might be faster to check the dot threshold here when computing the outline if the attenuation power curve is expensive.\n    float a = step(0.001, d); // Stencil for non-edges\n    float b = clamp((d - _OutlineExtraThickness) / _OutlineMaxDist, 0.0, 1.0);\n    \n    return a * angle_factor * _OutlineCol * pow(1.0 - b, _OutlineAttenuation);\n}\n\n//==RENDERING===================================================================================================================================\n\n//--GEOMETRY-----------------------------------------------------------------------------------------------------------------------\n// Note: Splitting SDF & Lighting calculations into fg / bg makes performance and compile time better as \n//            in this scene they do not need to interact with one another.\n//~~~~~(Background)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec2 mapBackground(in vec3 p, in vec3 ro)\n{\n    vec2 res = vec2(1e10); // (Distance, Material)\n    \n    // Pillars\n    #ifdef RENDER_PILLARS\n    res = MIN_MAT(res, sdPillars(p + vec3(0.0, _CloudBottomExtra, 0.0), ro));\n    #endif\n\n    // Static Inf Bridges\n    #ifdef RENDER_BRIDGES\n    {\n    vec3 q = p + vec3(0.0, _CloudBottomExtra, 0.0);\n    res = MIN_MAT(res, sdInfiniteBridge(q, \n        4.0*vec3(-25.0, 0.0, -25.0), \n        -PI / 4.0, \n        _CloudBottomExtra/2.0 + 2.5, \n        7.5));\n        \n    res = MIN_MAT(res, sdInfiniteBridge(q,\n        4.0*vec3(-55.0, 0.0, -50.0),\n        -7.0*PI / 12.0,\n        _CloudBottomExtra/2.0 + 18.5,\n        7.5));\n    }\n    #endif\n    \n    return res;\n}\n\nvec3 calcNormalBackground(in vec3 pos)\n{\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 q = pos + 0.0005*e;\n        n += e*mapBackground(q, q).x;\n    }\n    return normalize(n);\n}\n\nvec3 intersectBackground(in vec3 ro, in vec3 rd)\n{\n    vec3 res = vec3(-1.0, 1e10, -1.0);\n    \n    vec2 tminmax = iSphere( ro, rd, 6000.0 );\n\tif( tminmax.y>0.0 )\n    {\n        // raymarch\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<RAYMARCH_MAX_STEPS && t<tminmax.y; i++ )\n        {\n            vec2 h = mapBackground(ro+t*rd, ro);\n            res.y = max(min(res.y, h.x), 0.0); // Track near misses for strong light outine\n            if( abs(h.x)<0.001 ) { res=vec3(t, res.y, h.y); break; }\n            t += h.x;\n        }\n    }\n    \n    return res; // t, nearest, mat_id\n}\n\n//~~~~~(Foreground)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec2 mapForeground(in vec3 p)\n{\n    vec2 res = vec2(1e10); // (Distance, Material)\n\n    // Rope\n    #ifdef RENDER_ROPE\n    float r_id;\n    res = MIN_MAT(res, sdShimenawa(p, 0.4615, 0.04, 10.0, r_id));\n    #endif\n               \n    return res; // returns (distance, material) pair.\n}\n\nvec3 calcNormalForeground(in vec3 pos)\n{\n    // klems's trick to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*mapForeground(pos+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 intersectForeground(in vec3 ro, in vec3 rd)\n{\n    vec3 res = vec3(-1.0, 1e10, -1.0);\n    \n    vec2 tminmax = iSphere( ro, rd, 0.75 );\n\tif( tminmax.y>0.0 )\n    {\n        // raymarch\n        float t = max(tminmax.x,0.001);\n        for( int i=0; i<RAYMARCH_MAX_STEPS && t<tminmax.y; i++ )\n        {\n            vec2 h = mapForeground(ro+t*rd);\n            res.y = max(min(res.y, h.x), 0.0); // Track near misses for strong light outine\n            if( abs(h.x)<0.001 ) { res=vec3(t, res.y, h.y); break; }\n            t += h.x;\n        }\n    }\n    \n    return res; // t, nearest, mat_id\n}\n\n//--LIGHTING-----------------------------------------------------------------------------------------------------------------------\n\n//~~~~~(Foreground)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// https://iquilezles.org/articles/rmshadows\n// Soft Shadows with backtracking.\nfloat softShadowForeground(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapForeground(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += h;\n\t\tif( abs(res)<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// https://www.shadertoy.com/view/ld3Gz2\n//  AO by (pseudo-random) sampling a number of distances to surfaces in a hemisphere about the normal\nfloat calcAOForeground(in vec3 pos, in vec3 nor)\n{\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<int(AO_SAMPLES); i++ )\n    {\n        vec3 ap = forwardSF( float(i), AO_SAMPLES );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        ao += clamp( mapForeground(pos + nor*0.01 + ap).x*3.0, 0.0, 1.0 );\n    }\n\tao /= AO_SAMPLES;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\n//~~~~~(Background)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// https://iquilezles.org/articles/rmshadows\n// Soft Shadows with backtracking.\nfloat softShadowBackground(in vec3 ro, in vec3 rd, float k)\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = mapBackground(ro + rd*t, ro).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += h;\n\t\tif( abs(res)<0.01 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n// https://www.shadertoy.com/view/ld3Gz2\n//  AO by (pseudo-random) sampling a number of distances to surfaces in a hemisphere about the normal\nfloat calcAOBackground(in vec3 pos, in vec3 nor)\n{\n\tfloat ao = 0.0;\n    for( int i=ZERO; i<int(AO_SAMPLES); i++ )\n    {\n        vec3 ap = forwardSF( float(i), AO_SAMPLES );\n        float h = hash1(float(i));\n\t\tap *= sign( dot(ap,nor) ) * h*0.1;\n        vec3 q = pos+nor*0.01 + ap;\n        ao += clamp( mapBackground(q, q).x*3.0, 0.0, 1.0 );\n    }\n\tao /= AO_SAMPLES;\n\t\n    return clamp( ao*6.0, 0.0, 1.0 );\n}\n\n//--MATERIALS----------------------------------------------------------------------------------------------------------------------\nvec3 shadeForeground(in vec3 ro, in vec3 rd, in float t, in float m) \n{\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalForeground(pos);\n    float shadow = softShadowForeground(pos - 0.01*rd, _LightDir, 10.0); // Sharp\n    float occ = calcAOForeground(pos, nor);\n    shadow = pow(occ, 2.0) * (shadow + _RopeExtraShadowBrightness) / (1.0 + _RopeExtraShadowBrightness);\n\n    if (CMP_MAT_LT(m, MAT_ROPE)) \n    {\n        vec3 base_shadow = mix(_RopeShadowDarkness*_MatRope, _AmbientLightCol, _RopeShadowAmbientAmt);\n        vec3 sss_style_mix = mix(base_shadow, _RopeTerminatorLineCol, min(1.0, 4.0 * shadow));\n        \n        vec3 albedo = mix(sss_style_mix, _MatRope, min(1.0, 2.0 * shadow));\n               \n        return albedo;\n    }\n    else if (CMP_MAT_LT(m, MAT_SHIDE_SECONDARY)) // handle both shide mat variatons here\n    {\n        vec3 mat = (m == MAT_SHIDE) ? _MatShide : _MatShideSecondary;\n        // This simple SSS approximation is good enough for sun -> paper.\n        float tr_range = t / 5.0;\n        float sun_transmission = mapForeground(pos + _LightDir * tr_range).x / tr_range;\n        vec3 sss = _MatShideSSSCoeff*_SunCol * smoothstep(0.0, 1.0, sun_transmission);\n        \n        vec3 base_shadow = mix(0.6*mat, _MatShideAmbientCoeff*_AmbientLightCol, 0.2);\n        \n        return sss + mix(base_shadow, mat, shadow);\n    }\n    \n    // Render normal if no mat\n    vec3 col = vec3(0.0);\n    col = 0.5 + 0.5*nor;\n\n    return 1.2*col;\n}\n\nvec3 shadeBackground(in vec3 ro, in vec3 rd, in float t, in float m) \n{\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormalBackground(pos);\n    float shadow = softShadowBackground(pos - 0.01*rd, _LightDir, 15.0); // Sharp\n    float occ = calcAOBackground(pos, nor);\n    shadow = pow(occ, 2.0) * (shadow + _RopeExtraShadowBrightness) / (1.0 + _RopeExtraShadowBrightness);\n    \n    if (CMP_MAT_LT(m, MAT_BRIDGE_STONE))\n    {\n        float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0 );\n        vec3 base_shadow = mix(_BridgeShadowDarkness*_MatBridgeStone, _AmbientLightCol, _BridgeShadowAmbientAmt);\n        vec3 albedo = _MatBridgeStone + fre *_MatBridgeStoneFre + dot(_LightDir, nor) * _SunCol * 0.15;\n        return mix(base_shadow, albedo, shadow);\n    }\n    else if (CMP_MAT_LT(m, MAT_BRIDGE_BRASS))\n    {\n        float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0 );\n        \n        float ref = dot(rd, reflect(_LightDir, nor));\n        ref = smoothstep(0.5, 0.6, ref);\n        \n        vec3 base_shadow = mix(_BridgeShadowDarkness*_MatBridgeBrass, _AmbientLightCol, _BridgeShadowAmbientAmt);\n        vec3 albedo = _MatBridgeBrass + fre * _SunCol * _SunBrightness + ref * _MatBridgeBrassSpe;\n        \n        return mix(base_shadow, albedo, shadow);\n    }\n    else if (CMP_MAT_LT(m, MAT_PILLAR_STONE))\n    {\n        float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0 );\n        vec3 base_shadow = mix(_PillarShadowDarkness*_MatPillarStone, _AmbientLightCol, _PillarShadowAmbientAmt);\n        vec3 albedo = _MatPillarStone + fre *_SunCol * _SunBrightness + _SunCol * 0.1 * dot(nor, _LightDir);\n        return mix(base_shadow, albedo, shadow);\n    }\n    else if (CMP_MAT_LT(m, MAT_PILLAR_STONE_ALT))\n    {\n        float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0 );\n        vec3 base_shadow = mix(_PillarAltShadowDarkness*_MatPillarStoneAlt, _AmbientLightCol, _PillarAltShadowAmbientAmt);\n        vec3 albedo = mix(base_shadow, _MatPillarStoneAlt, shadow);\n        \n        return mix(albedo, _MatPillarStoneAltFre, fre);\n    }\n    else if (CMP_MAT_LT(m, MAT_PILLAR_GOLD_ALT)) // Covers both alt and non-alt mats.\n    {\n        float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0 );\n        float ref = dot(reflect(rd, nor), normalize(_SunPos - pos));\n        ref = smoothstep(0.7, 0.8, ref);\n        vec3 base_shadow = mix(_PillarShadowDarkness*_MatBridgeBrass, _AmbientLightCol, _PillarShadowAmbientAmt);\n        vec3 albedo = _MatBridgeBrass + fre * _SunCol * _SunBrightness + ref * _MatBridgeBrassSpe;\n        \n        return mix(base_shadow, albedo, shadow);\n    }\n    \n    // Render normal if no mat\n    vec3 col = vec3(0.0);\n    col = 0.5 + 0.5*nor;\n\n    return 1.2*col;\n}\n\n//--CLOUDS-------------------------------------------------------------------------------------------------------------------------\n// Technique from paper: \"Oz: The Great and Volumetric\".\nvec3 multipleOctaveScattering(in float extinction, in float mu, in float step_size)\n{\n    vec3 li = vec3(0.0);\n    const float OCTAVES = 4.0;\n    \n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    \n    float phase;\n    \n    for (float i = 0.0; i<OCTAVES; i++)\n    {\n        phase = mix(henyeyGreenstein(-0.1 * c, mu), henyeyGreenstein(0.3 * c, mu), 0.7);\n        li += b * phase * exp(-step_size * extinction * a);\n        a*=0.25;\n        b*=0.5;\n        c*=0.5;\n    }\n    \n    return li;\n}\n\nbool intersectClouds(in vec3 ro, in vec3 rd, out float t_near, out float isect_dist)\n{\n    // This is the bounding volume for the cloud.\n    vec2 isect = intersectAABB(ro, rd, _CloudMinCorner, _CloudMaxCorner);\n    \n    if (insideAABB(ro, _CloudMinCorner, _CloudMaxCorner)) isect.x = 0.0001;\n        \n    t_near = isect.x;\n    isect_dist = isect.y - isect.x;\n    \n    return isect.x > 0.0 && isect.x < isect.y;\n}\n\n// https://www.shadertoy.com/view/3sffzj\nfloat getPerlinWorleyNoise(vec3 pos)\n{\n    // The cloud shape texture is an atlas of 6*6 tiles (36). \n    // Each tile is 32*32 with a 1 pixel wide boundary.\n    // Per tile:\t\t32 + 2 = 34.\n    // Atlas width:\t6 * 34 = 204.\n    // The rest of the texture is black.\n    // The 3D texture the atlas represents has dimensions 32 * 32 * 36.\n    // The green channel is the data of the red channel shifted by one tile.\n    // (tex.g is the data one level above tex.r). \n    // To get the necessary data only requires a single texture fetch.\n    const float dataWidth = 204.0;\n    const float tileRows = 6.0;\n    const vec3 atlasDimensions = vec3(32.0, 32.0, 36.0);\n\n    // Change from Y being height to Z being height.\n    vec3 p = pos.xzy;\n\n    // Pixel coordinates of point in the 3D data.\n    vec3 coord = vec3(mod(p, atlasDimensions));\n    float f = fract(coord.z);  \n    float level = floor(coord.z);\n    float tileY = floor(level/tileRows); \n    float tileX = level - tileY * tileRows;\n\n    // The data coordinates are offset by the x and y tile, the two boundary cells \n    // between each tile pair and the initial boundary cell on the first row/column.\n    vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n    vec2 pixel = coord.xy + offset;\n    vec2 data = texture(iChannel0, mod(pixel, dataWidth)/iChannelResolution[0].xy).xy;\n    return mix(data.x, data.y, f);\n}\n\nfloat mapCloud(vec3 p) { return 1.0; }\n\n// https://www.shadertoy.com/view/3sffzj\nfloat mapCloudDensity(in vec3 p, out float cloudHeight)\n{  \n    if(!insideAABB(p, _CloudMinCorner, _CloudMaxCorner)) return 0.0;\n    \n    cloudHeight = saturate((p.y - _CloudBot)/(_CloudTop-_CloudBot));\n    float cloud = mapCloud(p);\n\n    //If there are no clouds, exit early.\n    if(cloud <= 0.0) return 0.0;\n\n    //Sample texture which determines how high clouds reach.\n    float height = cloud;\n    \n    //Round the top of the cloud. From \"Real-time rendering of volumetric clouds\". \n    cloud *= saturate(remap(cloudHeight, 0.8*height, height, 1.0, 0.0));\n\n    //Animate main shape.\n    p += vec3(_CloudShapeSpeed * iTime);\n    \n    //Get main shape noise, invert and scale it.\n    float shape = 1.0-getPerlinWorleyNoise(_CloudShapeSize * p);\n    shape *= _CloudShapeStrength;\n\n    //Carve away density from cloud based on noise.\n    cloud = saturate(remap(cloud, shape, 1.0, 0.0, 1.0));\n\n    //Early exit from empty space\n    if(cloud <= 0.0) return 0.0;\n    \n    //Animate details.\n    p += vec3(_CloudDetailSpeed * iTime, 0.0, 0.5 * _CloudDetailSpeed * iTime);\n    \n    float detail = getPerlinWorleyNoise(_CloudDetailSize * p);\n\tdetail *= _CloudDetailStrength;\n    \n\t//Carve away detail based on the noise\n\tcloud = saturate(remap(cloud, detail, 1.0, 0.0, 1.0));\n    return _CloudDensityMultiplier * cloud;\n}\n\nvec3 getCloudLi(in vec3 ro, in vec3 p, in float mu, in vec3 wi) \n{\n    // Sample density of volume between sample point p and the light source (wi = incident light dir).\n    \n    float isect_length = _CloudWidth*1.5;\n    float tnear = 0.0;\n    \n    intersectClouds(p, wi, tnear, isect_length);\n\n    // Similar approach here as with the raymarch into the cloud, we do a fixed number of steps out of the cloud.\n    float ray_density = 0.0;\n    \n    float step_size = isect_length/float(LIGHT_RAY_STEPS);\n    \n    float h_placeholder;\n    \n    for (int i = 0; i<LIGHT_RAY_STEPS; i++)\n    {\n        vec3 q = p + float(i) * wi * step_size;\n        ray_density += mix(1.0, 0.75, mu) * mapCloudDensity(q, h_placeholder);\n    }\n    \n    // The light that reaches the point is then affected by Beer-Powder curve.\n    vec3 beers_law = multipleOctaveScattering(ray_density, mu, step_size);\n    vec3 powder = beers_law * 2.0 * (1.0 - (exp(-step_size * ray_density * 2.0 * _CloudSigmaE)));\n    \n    return mix(powder, beers_law, 0.5 + 0.5 * mu);\n}\n\nvec3 renderClouds(in vec3 ro, in vec3 rd, in float ray_offset, out vec3 ray_transmittance, out float start_t)\n{\n    /*\n    REFERENCE MATERIALS:\n    \n        (VOLUMETRIC CLOUDS) https://www.shadertoy.com/view/3sffzj\n                            https://www.shadertoy.com/view/3dlfWs\n        Geurilla Games: The Real time volumetric cloudscapes of Horizon: Zero Dawn.\n        Phsyically Based Sky, Atmosphere and Cloud Rendering in Frostbite, Sebastien Hillaire.\n        Real-time rendering of volumetric clouds, Fredrik Haggstrom.\n        PBR: From theory to implementation, Section 11.\n    */\n    \n    // We do a raycast through the cloud volume, at each point, figuring out the attenuation of light.\n    \n    ray_transmittance = vec3(1.0);\n    vec3 col = vec3(0.0);\n    \n    float mu = dot(rd, _LightDir);\n    // Forward and backwards scattering\n    float phase_function = mix(henyeyGreenstein(-0.3, mu), henyeyGreenstein(0.3, mu), 0.7);\n    \n    // As we have an SDF for the cloud, we can start the raymarch at the cloud surface,\n    //   instead of doing some sort of variable step size approach.\n    float t = 0.0;\n    float isect_length = 0.0; // length of cloud-ray intersection.\n    bool isect = intersectClouds(ro, rd, t, isect_length);\n    \n    if (!isect) return col;\n        \n    float step_size = isect_length / float(CAMERA_RAY_STEPS);\n    t += step_size * ray_offset;\n    start_t = -1.0;\n\n    const vec3 light_col = _CloudLightCol * _CloudLightIntensity;\n    \n    // raymarch\n    for(int i = 0; i < CAMERA_RAY_STEPS; i++)\n    {    \n        vec3 p = ro + t*rd;\n        \n        float height;\n        float density = mapCloudDensity(p, height);\n        vec3 sigma_s = density*_CloudSigmaS;\n        vec3 sigma_e = density*_CloudSigmaE;\n        \n        if (density > 0.0)\n        {\n            if (start_t < 0.0) { start_t = t; }\n            // Amount of light that reaches the sample point (Li = incident radiance, from rendering eq.)\n            \n            vec3 ambient = mix(_CloudAmbientWeightLow, _CloudAmbientWeightHigh, height)*_CloudAmbientCol;\n            \n            // Shadow casting onto the clouds is possible, but extremely expensive.\n            //   This is even when approximating, as an exact shadow cast should compute the shadow on each light ray sample.\n            #ifdef CLOUD_SHADOW_CAST\n            float shadow = softShadowBackground(p, _LightDir, 10.0);\n            #else\n            float shadow = 1.0;\n            #endif\n\n            vec3 li = ambient + \n                      shadow * light_col * phase_function * getCloudLi(ro, p, mu, _LightDir);\n                        \n            li *= sigma_s; // Which is proportional to cloud density at the point\n            \n            // Beer-Lambert\n            vec3 transmittance = exp(-sigma_e * step_size);\n            \n            // integrate incident radiance for reflected radiance of the ray (pixel colour).\n            col += ray_transmittance * (li - li * transmittance) / sigma_e;\n            // update transmittance for the entire raycast\n            ray_transmittance *= transmittance;\n            \n            // When the transmittance is almost zero, there is no more cloud occluding the sample pt, so early exit the raymarch.\n            if (length(ray_transmittance) <= 0.001) { ray_transmittance = vec3(0.0); break; }\n        }\n        \n        t += step_size;\n    }\n        \n    return col;\n}\n\n//--CAMERA & RAYMARCHING-----------------------------------------------------------------------------------------------------------\nvec3 render(in vec3 ro, in vec3 rd, in vec2 fragCoord) \n{\n    // --SKY----------------------------------------------------------------------\n    vec3 col = sky(ro, rd);\n\n    // --GEOMETRY-----------------------------------------------------------------\n    // Foreground\n    vec3 f_tm = intersectForeground( ro, rd );\n    if( f_tm.x>0.0 )\n    {\n        col = shadeForeground(ro, rd, f_tm.x, f_tm.z);\n    }\n    \n    vec3 min_tm = f_tm;\n    \n    // Background\n    vec3 b_tm = intersectBackground( ro, rd );\n    if ( b_tm.x>0.0 && (f_tm.x<0.0 || b_tm.x<f_tm.x) )\n    {\n        min_tm = b_tm;\n        col = shadeBackground(ro, rd, b_tm.x, b_tm.z);\n    }\n    \n    col += sunSSSOutline(ro, rd, min_tm.y);\n    \n    float min_t = min_tm.x; // track smallest t for fog\n    bool min_is_cloud = false; // Also track if cloud hit so we can select between 2 different fogs (better blending)\n    \n    // --CLOUDS-------------------------------------------------------------------\n    #ifdef RENDER_CLOUDS\n    vec3 cloud_transmittance = vec3(1.0);    \n    float ray_offset = 0.0;\n    \n    #ifdef CLOUD_BLUE_NOISE\n    // Wait for texture to load\n    if(iChannelResolution[1].xy == vec2(1024.0))\n    {\n        float blue_noise = texture(iChannel1, fragCoord / 1024.0).r;\n        ray_offset = fract(blue_noise + float(iFrame%32) * PHI);\n        \n    }\n    #endif\n    \n    float cloud_t;\n    vec3 cloud_col = 0.5 * renderClouds( ro, rd, ray_offset, cloud_transmittance, cloud_t ); \n    \n    if ( min_tm.x < 0.0 || (cloud_t > 0.0 && cloud_t < min_tm.x) )\n    {\n        min_t = cloud_t;\n        min_is_cloud = true;\n        col = cloud_col + col * cloud_transmittance;\n    }\n    #endif\n    \n    #ifdef RENDER_FOG\n    col = fog(col, min_t, rd, min_is_cloud);\n    #endif\n    return col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 tot = vec3(0.0);\n\n    // SSAA\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // camera & movement\n        #ifdef USE_DEBUG_CAMERA\n        vec3 ta = ORBIT_CAMERA_TARGET;\n        #else\n        vec3 ta = CAMERA_TARGET;\n        #endif\n        \n        vec2 m = iMouse.xy / iResolution.xy-.5;\n        vec3 ro; // ray origin\n        #ifdef USE_ORBIT_CAMERA\n        if ( iMouse.x >= 0.0 ) \n        {\n            ro = ORBIT_CAMERA_DIST*vec3(0.8, 0.3, 0.8);\n            ro.yz *= rot(m.y*PI);\n            ro.xz *= rot(-m.x*TAU*2.0);\n            ro += ta;\n        }\n        #else\n        float an_h = 1.37*PI + PHI*CAMERA_SPEED.x*iTime;\n        float an_v = -0.25*PI + (PHI+1.0)*CAMERA_SPEED.y*iTime;\n\n        ro = ta + CAMERA_DIST*vec3( cos(an_h), 0.2*sin(2.0*an_v), sin(an_h) );\n        #endif\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n        \n        vec3 col = render( ro, rd, fragCoord );\n        \n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    tot *= EXPOSURE;\n\n    // fast dithering to remove banding artifacts, particularly from the sun.\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    // Divide through by HDR max so HDR values can be stored in 0->1 float buffer\n    //   There is probably a loss of numerical precision, but oh well.\n    tot /= HDR_MAX_COL;\n        \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*                                  \n\n                                                 ████                                               \n                   ██                            █████                              █████████       \n       █████      ██████             ███         ████████              ████   ██  █████   █████     \n      ███████     ███████           ██████  ██████████                 █████  ██  ████████████      \n        █████    ███████             █████    █ ██████████            ██████████  ███████████       \n                ██  █████            █████   ██ █████  █████         █████    ███ ██████████        \n              ███   ████████               █  ██ ███████████        ████████  ███████████           \n     █████  ████████████████        ██████ ██  █████████████       ██████████    ██████ █████       \n   █████████████████████          ████████ ████ ██████████            ██████    ███████ ██████      \n    ████████   ██ ███████          █████     ███████  ████           ███████ █████████ ██████       \n      █  ██     ██████████            ████    █  ████████████         ██████████ ██████████         \n     █  ██   ███████████               ██████████████████████          ███ ███████████   ██         \n     █ ███  ███   ████             ███████████   ███  █               █ ███ █   ██████     ██       \n    █ ███       ███████ █████      ████████      ███  █              █  ███      █████      ███     \n    ████   ████████████████████      ██ ████████ ██        ██         ████      ████████████████    \n    ███  ████████          ████               █████████████████         ████           █████████    \n                                                                                                    \n\n    注連縄 (Shimenawa) by Henry A.                 (Self: https://www.shadertoy.com/view/clVyzW)\n    \n    --LAYOUT------------------------------------------------------------------------------------\n    \n      COMMON: Colour schemes, Rendering settings, SDF primitives, Intersectors, and util funcs.\n       \n    BUFFER B: Perlin-Worley texture atlas generation for clouds. \n              (Source: https://www.shadertoy.com/view/3sffzj)\n              \n    BUFFER C: Scene rendering\n   \n    BUFFER D: HDR Bloom pass\n    \n       IMAGE: LDR Post processing (Tonemap, Gamma correction, etc.)\n       \n    --------------------------------------------------------------------------------------------\n    \n*/\n\n// Simple buffer pass bloom. \n// Do this step in HDR space to avoid blooming non-bright objects. \n//  Combine 4 mipmap levels for progressive gaussian blur, and apply.\n//  There is some artifacting due to the approximation of gaussian + size.\n\n//  This would benefit greatly from individual buffers for each level + billinear sampling ...Too bad!\n\n#define THRESH vec3(EXPOSURE * BLOOM_THRESHOLD)\n\nvec3 mipmap(float mipmap_exp, vec2 offset, vec2 uv)\n{\n    vec2 pixel_size = 1.0 / vec2(iResolution.x, iResolution.y);\n    float ds_factor = exp2(mipmap_exp);\n\n    offset.x += mipmap_exp * BLOOM_MIPMAP_NUDGE + 1.0 - 2.0 / ds_factor; // Simplification of 1 - 1/(2^(n-1))\n    vec2 scale = ds_factor * pixel_size;\n    vec2 coord = (uv - offset) * ds_factor;\n        \n    // Toggle this line if you use another mipmap on top\n    #if 0\n    if (coord.x > 1.0 || coord.y > 1.0 || coord.x < 0.0 || coord.y < 0.0)\n    #else\n    if (coord.x > 1.0 || coord.x < 0.0)\n    #endif\n        return vec3(0.0);\n    \n    float tot_weight = 0.0;\n    vec3 bloom = vec3(0.0);\n\n    for (int i = -5; i < 5; i++) \n    for (int j = -5; j < 5; j++) \n    {\n        float weight = pow(1.0 - length(vec2(i,j)) * 0.125, 6.0); // Apply pseudo-gaussian weights\n\n        vec2 blur_coord = vec2(i,j) * scale + ds_factor * pixel_size + coord;\n                \n        bloom = max(vec3(0.0), (HDR_MAX_COL * texture(iChannel0, blur_coord, mipmap_exp + 1.0).rgb - THRESH)) * weight + bloom;\n        tot_weight += weight;\n    }\n\n    bloom /= tot_weight;\n\n    return bloom;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 blur = mipmap(1.0, vec2(0.0), uv);\n        blur += mipmap(2.0, vec2(0.0), uv);\n        blur += mipmap(3.0, vec2(0.0), uv);\n        blur += mipmap(4.0, vec2(0.0), uv);\n        blur += mipmap(5.0, vec2(0.0), uv);\n    \n    fragColor = vec4(blur, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}