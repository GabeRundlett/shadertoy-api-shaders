{
    "Shader": {
        "info": {
            "date": "1605841209",
            "description": "This shader renders a superflip move sequence on the rubiks cube! The superflip is a rubiks cube position which requires 20 moves to solve: the highest number of moves any position takes! See Buffer A for how to change which move sequence it renders.",
            "flags": 32,
            "hasliked": 0,
            "id": "3d3fDS",
            "likes": 16,
            "name": "Superflip",
            "published": 3,
            "tags": [
                "3d",
                "cube",
                "rubiks"
            ],
            "usePreview": 0,
            "username": "been_jamming",
            "viewed": 908
        },
        "renderpass": [
            {
                "code": "//Superflip Rubik's Cube\n//By Ben Jones\n//11-19-2020\n\n#define FOV_CONST 0.15\n#define RENDER_DISTANCE 50.0\n#define CUBIE_GAP 0.01\n\n#define DO_LIGHTING\n\n#define DIFFUSE_BRIGHTNESS 15.0\n#define SPECULAR_BRIGHTNESS 45.0\n\n#define BLACK 0\n#define RED 1\n#define ORANGE 2\n#define YELLOW 3\n#define WHITE 4\n#define GREEN 5\n#define BLUE 6\n\ncube global_cube;\n\nconst vec4 sticker_colors[7] = vec4[7](\n\tvec4(0.0125, 0.0125, 0.0125, 1.0),//black\n\tvec4(0.5, 0.0, 0.0, 1.0),//red\n\tvec4(0.9, 0.2, 0.0, 1.0),//orange\n\tvec4(0.7, 0.7, 0.0, 1.0),//yellow\n\tvec4(0.9, 0.9, 0.9, 1.0),//white\n\tvec4(0.0, 0.5, 0.0, 1.0),//green\n\tvec4(0.0, 0.0, 0.7, 1.0));//blue\n\nconst int cubie_colors[156] = int[156](\n\tRED, BLACK, BLUE, BLACK, YELLOW, BLACK,\n\tRED, BLACK, BLUE, BLACK, BLACK, BLACK,\n\tRED, BLACK, BLUE, BLACK, BLACK, WHITE,\n\tRED, BLACK, BLACK, BLACK, YELLOW, BLACK,\n\tRED, BLACK, BLACK, BLACK, BLACK, BLACK,\n\tRED, BLACK, BLACK, BLACK, BLACK, WHITE,\n\tRED, BLACK, BLACK, GREEN, YELLOW, BLACK,\n\tRED, BLACK, BLACK, GREEN, BLACK, BLACK,\n\tRED, BLACK, BLACK, GREEN, BLACK, WHITE,\n\tBLACK, BLACK, BLUE, BLACK, YELLOW, BLACK,\n\tBLACK, BLACK, BLUE, BLACK, BLACK, BLACK,\n\tBLACK, BLACK, BLUE, BLACK, BLACK, WHITE,\n\tBLACK, BLACK, BLACK, BLACK, YELLOW, BLACK,\n\tBLACK, BLACK, BLACK, BLACK, BLACK, WHITE,\n\tBLACK, BLACK, BLACK, GREEN, YELLOW, BLACK,\n\tBLACK, BLACK, BLACK, GREEN, BLACK, BLACK,\n\tBLACK, BLACK, BLACK, GREEN, BLACK, WHITE,\n\tBLACK, ORANGE, BLUE, BLACK, YELLOW, BLACK,\n\tBLACK, ORANGE, BLUE, BLACK, BLACK, BLACK,\n\tBLACK, ORANGE, BLUE, BLACK, BLACK, WHITE,\n\tBLACK, ORANGE, BLACK, BLACK, YELLOW, BLACK,\n\tBLACK, ORANGE, BLACK, BLACK, BLACK, BLACK,\n\tBLACK, ORANGE, BLACK, BLACK, BLACK, WHITE,\n\tBLACK, ORANGE, BLACK, GREEN, YELLOW, BLACK,\n\tBLACK, ORANGE, BLACK, GREEN, BLACK, BLACK,\n\tBLACK, ORANGE, BLACK, GREEN, BLACK, WHITE);\n\ncube get_cubie(int cubie_id){\n\tcube out_cube;\n\n\tout_cube.center = texelFetch(iChannel0, ivec2(cubie_id, 0), 0).xyz;\n\tout_cube.orientation = texelFetch(iChannel0, ivec2(cubie_id, 1), 0);\n\tout_cube.size = 1.0/3.0 - CUBIE_GAP;\n\n\treturn out_cube;\n}\n\nint get_cubie_color(int cubie_id){\n\treturn int(texelFetch(iChannel0, ivec2(cubie_id, 0), 0).w);\n}\n\nray get_camera_ray(vec2 pixel){\n\tfloat least_side;\n\t\n\tpixel -= vec2(0.5);\n\tleast_side = min(iResolution.x, iResolution.y);\n\treturn ray(vec3(0), vec3(FOV_CONST*pixel.x*iResolution.x/least_side, FOV_CONST*pixel.y*iResolution.y/least_side, FOV_CONST));\n}\n\nbool lit(vec3 p, vec3 light, vec4 orientation){\n\tray r;\n\tvec3 intersect_pos;\n\tint side;\n\tvec2 face_pos;\n\tint i;\n\tbool is_lit = true;\n\t\n\tp = p + (light - p)*0.01;//We don't want the ray to collide with the original surface\n\tr = ray(p, light - p);\n\tfor(i = 0; i < 26; i++){\n\t\tintersect_pos = ray_cube_intersect(rotate_cube(get_cubie(i), orientation), r, side, face_pos);\n\t\tis_lit = (is_lit && side == -1);\n\t}\n\n\treturn is_lit;\n}\n\n//Beveled edges for the stickers!\nvec4 get_color(int cubie, int side, vec2 face_pos, out float k_a, out float k_d, out float k_s){\n\tfloat edge_dist;\n\tint sticker_color;\n\t\n\tsticker_color = cubie_colors[get_cubie_color(cubie)*6 + side];\n\n\tif(sticker_color != BLACK &&\n\t\t((abs(face_pos.x) < 0.7 && abs(face_pos.y) < 0.8)\n\t   || (abs(face_pos.x) < 0.8 && abs(face_pos.y) < 0.7)\n\t   || dot(abs(face_pos) - vec2(0.7, 0.7), abs(face_pos) - vec2(0.7, 0.7)) < 0.01)){\n\t\tk_a = 1.0;\n\t\tk_d = 1.0;\n\t\tk_s = 0.05;\n\t\treturn sticker_colors[sticker_color];\n\t} else {\n\t\tk_a = 1.0;\n\t\tk_d = 0.5;\n\t\tk_s = 0.9;\n\t\treturn sticker_colors[BLACK];\n\t}\n}\n\nvec3 less_than(vec3 f, float val){\n\treturn vec3(\n\t\t(f.x < val) ? 1.0:0.0,\n\t\t(f.y < val) ? 1.0:0.0,\n\t\t(f.z < val) ? 1.0:0.0);\n}\n\nvec3 linear_to_srgb(vec3 rgb){\n\trgb = clamp(rgb, 0.0, 1.0);\n\t\n\treturn mix(pow(rgb, vec3(1.0/2.4))*1.055 - 0.055, rgb*12.92, less_than(rgb, 0.0031308));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tray camera_ray;\n\tvec3 intersect_pos;\n\tvec3 intersect_normal;\n\tvec3 reflect_vec;\n\tvec3 current_color;\n\tvec4 orientation;\n\tvec3 light_pos = vec3(2.0, 2.0, -1.0);\n\tvec2 face_pos;\n\tint side;\n\tfloat best_dist = RENDER_DISTANCE;\n\tvec3 best_intersect_pos = vec3(0.0);\n\tvec2 best_face_pos = vec2(0.0);\n\tint best_index = 0;\n\tint best_side = -1;\n\tvec4 best_orientation;\n\tfloat intersect_dist;\n\tint i;\n\tcube current_cubie;\n\tvec3 light_vec;\n\tfloat k_a;\n\tfloat k_d;\n\tfloat k_s;\n\tfloat diffuse_portion;\n\tfloat specular_portion;\n\tfloat brightness;\n\t\n\torientation = create_orientation(vec3(sin(iTime/20.0), cos(iTime/17.0), -cos(iTime/3.0)), iTime/10.0);\n\t//Comment the above and uncomment the below for a camera which doesn't rotate.\n\t//orientation = vec4(1.0, 0.0, 0.0, 0.0);\n\t//orientation = create_orientation(vec3(0, 1, 0), 0.5);\n\tcamera_ray = get_camera_ray(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y));\n\tfor(i = 0; i < 26; i++){\n\t\tcurrent_cubie = rotate_cube(get_cubie(i), orientation);\n\t\tintersect_pos = ray_cube_intersect(current_cubie, camera_ray, side, face_pos);\n\t\tintersect_dist = dot(intersect_pos, intersect_pos);\n\t\tbest_intersect_pos = side != -1 && intersect_dist < best_dist ? intersect_pos : best_intersect_pos;\n\t\tbest_face_pos = side != -1 && intersect_dist < best_dist ? face_pos : best_face_pos;\n\t\tbest_index = side != -1 && intersect_dist < best_dist ? i : best_index;\n\t\tbest_side = side != -1 && intersect_dist < best_dist ? side : best_side;\n\t\tbest_orientation = side != -1 && intersect_dist < best_dist ? current_cubie.orientation : best_orientation;\n\t\tbest_dist = min(best_dist, intersect_dist);\n\t}\n\n\tcurrent_color = get_color(best_index, best_side, best_face_pos, k_a, k_d, k_s).xyz;\n\tbrightness = k_a/16.0;\n\t\n\tif(best_side != - 1){\n#ifdef DO_LIGHTING\n\t\tif(lit(best_intersect_pos, light_pos, orientation)){\n\t\t\tintersect_normal = apply_orientation(intersect_normals[best_side], best_orientation);\n\t\t\tlight_vec = normalize(best_intersect_pos - light_pos);\n\t\t\treflect_vec = reflect(light_vec, intersect_normal);\n\t\t\t\n\t\t\tdiffuse_portion = max(dot(intersect_normal, light_vec), 0.0)*k_d;;\n\t\t\tspecular_portion = diffuse_portion > 0.0 ? max(dot(-1.0*normalize(best_intersect_pos), normalize(reflect_vec)), 0.0) : 0.0;\n            specular_portion = pow(specular_portion, 128.0)*k_s;\n\t\t\t\n\t\t\tbrightness += DIFFUSE_BRIGHTNESS/dot(best_intersect_pos - light_pos, best_intersect_pos - light_pos)*diffuse_portion;\n\t\t\tbrightness += SPECULAR_BRIGHTNESS/dot(best_intersect_pos - light_pos, best_intersect_pos - light_pos)*specular_portion;\n        }\n#else\n        brightness += k_a*15.0/16.0;\n#endif\n\t\tfragColor = vec4(linear_to_srgb(current_color*brightness), 1.0);\n\t} else {\n\t\tfragColor = vec4(linear_to_srgb(texelFetch(iChannel1, ivec2(fragCoord), 0).xyz), 1.0);\n\t}\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Maintains the cube's rotated state\n\n#define PI 3.1415927\n#define FACE 0\n\n#define RIGHT 0\n#define LEFT 1\n#define FRONT_I 2\n#define BACK_I 3\n#define UP 4\n#define DOWN 5\n#define DELAY 6\n#define RIGHT_I 7\n#define LEFT_I 8\n#define FRONT 9\n#define BACK 10\n#define UP_I 11\n#define DOWN_I 12\n\n\n//Here you can modify the moves that the shader does.\n//The shader does one move every second and repeats when it gets to the end of the list.\n//You can use the DELAY move to add one-second pauses.\n#define NUM_MOVES 34\n\nint moves[NUM_MOVES] = int[NUM_MOVES](\n\tRIGHT_I,\n\tUP,\n\tUP,\n\tBACK,\n\tLEFT_I,\n\tFRONT,\n\tUP_I,\n\tBACK,\n\tDOWN,\n\tFRONT,\n\tUP,\n\tDOWN_I,\n\tLEFT,\n\tDOWN,\n\tDOWN,\n\tFRONT_I,\n\tRIGHT,\n\tBACK_I,\n\tDOWN,\n\tFRONT_I,\n\tUP_I,\n\tBACK_I,\n\tUP,\n\tDOWN_I,\n\tDELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY, DELAY);\n\ncube cubies[26] = cube[26](\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(2.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0),0.0),\n\tcube(vec3(0.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(0.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, 0.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + 2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + 0.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0),\n\tcube(vec3(-2.0/3.0, -2.0/3.0, 4.0 + -2.0/3.0), vec4(1.0, 0.0, 0.0, 0.0), 0.0));\n\nint animation_frame;\n\nint face_cubies[63] = int[63](\n\t0, 1, 2, 3, 4, 5, 6, 7, 8,\n\t17, 18, 19, 20, 21, 22, 23, 24, 25,\n\t2, 5, 8, 11, 13, 16, 19, 22, 25,\n\t0, 3, 6, 9, 12, 14, 17, 20, 23,\n\t0, 1, 2, 9, 10, 11, 17, 18, 19,\n\t6, 7, 8, 14, 15, 16, 23, 24, 25,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1);\n\nvoid write_initial_positions(out vec4 fragColor, ivec2 coords){\n\tif(coords.y == 0 && coords.x < 26){\n\t\tfragColor = vec4(cubies[coords.x].center, coords.x);\n\t} else if(coords.y == 1 && coords.x < 26){\n\t\tfragColor = cubies[coords.x].orientation;\n\t} else {\n\t\tfragColor = vec4(0.0);\n\t}\n}\n\nvec3 face_normals[13] = vec3[13](\n\tvec3(1, 0, 0),\n\tvec3(-1, 0, 0),\n\tvec3(0, 0, 1),\n\tvec3(0, 0, -1),\n\tvec3(0, 1, 0),\n\tvec3(0, -1, 0),\n\tvec3(0, 0, 0),\n\tvec3(-1, 0, 0),\n\tvec3(1, 0, 0),\n\tvec3(0, 0, -1),\n\tvec3(0, 0, 1),\n\tvec3(0, -1, 0),\n\tvec3(0, 1, 0));\n\nbool cubie_in_face(int cubie, int face){\n\treturn cubie == face_cubies[face*9] ||\n\t\t   cubie == face_cubies[face*9 + 1] ||\n\t\t   cubie == face_cubies[face*9 + 2] ||\n\t\t   cubie == face_cubies[face*9 + 3] ||\n\t\t   cubie == face_cubies[face*9 + 4] ||\n\t\t   cubie == face_cubies[face*9 + 5] ||\n\t\t   cubie == face_cubies[face*9 + 6] ||\n\t\t   cubie == face_cubies[face*9 + 7] ||\n\t\t   cubie == face_cubies[face*9 + 8];\n}\n\nvoid fix_cubie_position(out vec4 fragColor, vec4 info, ivec2 coords){\n    float cubie_num;\n    vec3 cubie_center;\n    vec4 cubie_info;\n    vec4 orientation;\n    \n    if(coords == ivec2(0, 2)){\n        fragColor = vec4((animation_frame + 1)%NUM_MOVES, 0.0, 0.0, 0.0);\n    } else if(cubie_in_face(coords.x, moves[animation_frame]%7)){\n        if(coords.y == 0){\n            cubie_info = info;\n        } else {\n            cubie_info = texelFetch(iChannel0, ivec2(coords.x, 0), 0);\n        }\n        orientation = create_orientation(face_normals[moves[animation_frame]], -PI/2.0);\n        cubie_center = apply_orientation(cubie_info.xyz - vec3(0.0, 0.0, 4.0), orientation);\n        cubie_num = round(-cubie_center.z*3.0/2.0 - cubie_center.y*9.0/2.0 - cubie_center.x*27.0/2.0 + 13.0);\n        cubie_num = cubie_num > 12.0 ? cubie_num - 1.0 : cubie_num;\n        if(coords.y == 0){\n            fragColor = vec4(cubies[coords.x].center, texelFetch(iChannel0, ivec2(cubie_num, 0), 0).w);\n        } else if(coords.y == 1){\n            fragColor = normalize(texelFetch(iChannel0, ivec2(cubie_num, 1), 0));\n        }\n    } else {\n        fragColor = texelFetch(iChannel0, coords, 0);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tivec2 coords;\n\tfloat frame_time;\n\tvec2 frame_info;\n\tbool on_face;\n\tfloat delta;\n\tvec3 center;\n\tvec4 orientation;\n\n\tcoords = ivec2(fragCoord);\n\t\n\tif((coords.x >= 26 || coords.y > 1) && coords != ivec2(0, 2)){\n\t\tdiscard;\n\t}\n\t\n\tif(iFrame == 0){\n\t\twrite_initial_positions(fragColor, coords);\n\t\treturn;\n\t}\n\n\tfragColor = texelFetch(iChannel0, coords, 0);\n\tframe_info = texelFetch(iChannel0, ivec2(0, 2), 0).xy;\n\tanimation_frame = int(frame_info.x);\n\tframe_time = frame_info.y;\n\tif(frame_time == 1.0){\n\t\tfix_cubie_position(fragColor, fragColor, coords);\n\t\treturn;\n\t}\n\tdelta = iTimeDelta;\n\tif(frame_time + delta > 1.0){\n\t\tdelta = 1.0 - frame_time;\n\t\tif(coords == ivec2(0, 2)){\n\t\t\tfragColor = vec4(animation_frame, 1.0, 0.0, 0.0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif(coords == ivec2(0, 2)){\n\t\tfragColor = vec4(animation_frame, delta + frame_time, 0.0, 0.0);\n\t\treturn;\n\t}\n\n\ton_face = cubie_in_face(coords.x, moves[animation_frame]%7);\n\tif(on_face && coords.y == 0){\n\t\tcenter = fragColor.xyz;\n\t\tcenter = apply_orientation(center - vec3(0.0, 0.0, 4.0), create_orientation(face_normals[moves[animation_frame]], delta*PI/4.0));\n\t\tfragColor = vec4(center + vec3(0.0, 0.0, 4.0), fragColor.w);\n\t} else if(on_face && coords.y == 1){\n\t\torientation = fragColor;\n\t\torientation = compose_orientation(create_orientation(face_normals[moves[animation_frame]], delta*PI/4.0), orientation);\n\t\tfragColor = orientation;\n\t} else\n\t\tfragColor = texelFetch(iChannel0, coords, 0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Procedural \"lights in the distance\"\n\n#define PI 3.1415927\n#define NUM_CIRCLES 15\n#define RADIUS 0.35\n\nvec3 get_random_continuous_vec(float id, float scale){\n\treturn vec3(sin(mod(id*1013.0 + iTime*scale, 2.0*PI)), cos(mod(id*4079.0 + iTime*scale, 2.0*PI)), cos(mod(id*7237.0 + iTime*scale, 2.0*PI)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tint i;\n\tfloat min_side;\n\tvec2 rand_vec;\n\tfloat dist;\n\tvec3 total = vec3(0.0);\n\tfloat rad;\n\t\n\tmin_side = min(iResolution.x, iResolution.y);\n\tfor(i = 0; i < NUM_CIRCLES; i++){\n\t\trand_vec = get_random_continuous_vec(float(i), 0.01).xy;\n\t\trand_vec = vec2(rand_vec.x*iResolution.x/min_side, rand_vec.y*iResolution.y/min_side);\n\t\tdist = distance(fragCoord/min_side, rand_vec);\n\t\trad = clamp((RADIUS - dist)/RADIUS, 0.0, 1.0);\n\t\ttotal += rad*(get_random_continuous_vec(float(i + NUM_CIRCLES), 0.05)*0.5 + vec3(1.0)*0.5);\n\t}\n\t\n\tfragColor = vec4(total*0.075, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "struct cube{\n\tvec3 center;\n\tvec4 orientation;\n\tfloat size;\n};\n\nstruct ray{\n\tvec3 p;\n\tvec3 vec;\n};\n\t\nvec3 intersect_normals[6] = vec3[6](\n\tvec3(-1, 0, 0),\n\tvec3(1, 0, 0),\n\tvec3(0, -1, 0),\n\tvec3(0, 1, 0),\n\tvec3(0, 0, -1),\n\tvec3(0, 0, 1));\n\nvec4 create_orientation(vec3 axis, float angle){\n\tfloat len;\n\tvec4 outvec;\n\t\n\tlen = length(axis);\n\taxis *= sin(angle)/len;\n\toutvec.yzw = axis;\n\toutvec.x = cos(angle);\n\t\n\treturn outvec;\n}\n\nvec4 inverse_orientation(vec4 orientation){\n\treturn vec4(orientation.x, -orientation.yzw);\n}\n\nvec4 compose_orientation(vec4 a, vec4 b){\n\tvec4 outvec;\n    mat4 comp_matrix;\n    \n    comp_matrix[0] = b.xyzw;\n    comp_matrix[1] = b.yxwz*vec4(-1.0, 1.0, -1.0, 1.0);\n    comp_matrix[2] = b.zwxy*vec4(-1.0, 1.0, 1.0, -1.0);\n    comp_matrix[3] = b.wzyx*vec4(-1.0, -1.0, 1.0, 1.0);\n    return comp_matrix*a;\n}\n\nvec3 apply_orientation(vec3 p, vec4 o){\n\tvec4 v;\n\t\n\tv.x = 0.0;\n\tv.yzw = p.xyz;\n\treturn compose_orientation(compose_orientation(o, v), inverse_orientation(o)).yzw;\n}\n\nray apply_orientation_ray(ray r, vec4 o){\n\treturn ray(apply_orientation(r.p, o), apply_orientation(r.vec, o));\n}\n\ncube rotate_cube(cube c, vec4 o){\n\tc.center -= vec3(0.0, 0.0, 4.0);\n\tc.center = apply_orientation(c.center, o);\n\tc.orientation = compose_orientation(o, c.orientation);\n\tc.center += vec3(0.0, 0.0, 4.0);\n\treturn c;\n}\n\n//Gets the intersection data between a ray and a cube\nvec3 ray_cube_intersect(cube c, ray r, out int side, out vec2 face_pos){\n\tray translated_ray;\n\tfloat d = 10000.0;\n\tfloat t = 0.0;\n\tvec2 comps;\n\tbool best;\n\t\n\tside = -1;\n\t\n\ttranslated_ray = ray(r.p - c.center, r.vec);\n\ttranslated_ray = apply_orientation_ray(translated_ray, inverse_orientation(c.orientation));\n\t\n\tt = (c.size - translated_ray.p.x)/translated_ray.vec.x;\n\tcomps = t*translated_ray.vec.yz + translated_ray.p.yz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 0 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : vec2(0.0);\n\t\n\tt = (-c.size - translated_ray.p.x)/translated_ray.vec.x;\n\tcomps = t*translated_ray.vec.yz + translated_ray.p.yz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 1 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (c.size - translated_ray.p.y)/translated_ray.vec.y;\n\tcomps = t*translated_ray.vec.xz + translated_ray.p.xz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 2 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (-c.size - translated_ray.p.y)/translated_ray.vec.y;\n\tcomps = t*translated_ray.vec.xz + translated_ray.p.xz;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 3 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (c.size - translated_ray.p.z)/translated_ray.vec.z;\n\tcomps = t*translated_ray.vec.xy + translated_ray.p.xy;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 4 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\t\n\tt = (-c.size - translated_ray.p.z)/translated_ray.vec.z;\n\tcomps = t*translated_ray.vec.xy + translated_ray.p.xy;\n\tbest = t > 0.0 && t < d && abs(comps.x) < c.size && abs(comps.y) < c.size;\n\tside = best ? 5 : side;\n\td = best ? t : d;\n\tface_pos = best ? comps : face_pos;\n\n\tface_pos /= c.size;\n\t\n\treturn d*r.vec + r.p;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}