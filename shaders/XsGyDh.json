{
    "Shader": {
        "info": {
            "date": "1521989632",
            "description": "A raytraced scene featuring a refracted quartic surface with hacky jittered shadows. :)",
            "flags": 32,
            "hasliked": 0,
            "id": "XsGyDh",
            "likes": 121,
            "name": "Raytraced Quartic Surface",
            "published": 3,
            "tags": [
                "raytrace",
                "surface",
                "quartic",
                "tile",
                "refract",
                "godray"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 3351
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRaytraced Quartic Surface\n\t-------------------------\n\n\tMattz's quartic solvers inspired me to put this together, and Ninjakoala's refined\n\tquartic solver enabled me to port it to Shadertoy. :) I coded up a generalized quartic \n\tsurface intersection many years ago, and didn't particularly enjoy the experience, so \n\thaven't been in a hurry to port it to the pixel shader environmnet. :)\n\t\n\tFor the most part, I did this for academic purposes. I like raytracing, but I find it \n\ta bit limiting. It appears that everyone else does too, because raytraced triangulated \n\tscenes aside, I seldom see anything more than basic primitives rendered. This is \n\tunderstandable, since surfaces described by higher order equations require far more \n\tcalculation.\n\n\tFor that reason, there's not a lot of raytraced quartic code out there, but now there's\n\ta reference on Shadertoy... I don't have a great deal of interest in it myself, but I \n\tfigured the raytracing crowd might find it novel having something to render other than \n\tspheres and cylinders. :)\n\n\tAnother reason I avoid realtime raytraced scenes is the hard shadows. With this example,\n\tI partly got around the problem by employing a cheap jittering trick, which I wouldn't \n\trecommend, but I think I got away with it here... kind of. :)\n\n\tI applied some geometric tiling and a simple radial blur, in a half hearted attempt to \n\tmake up for the fact that this is a pretty uninspiring lacklustre scene. :)\t\n\n\tBy the way, I hurriedly hacked together the reflection\\refraction loop as an \n\tafterthought. It's not entirely physically accurate, since it lacks proper stack logic, \n\tbut other than that, it seems to be about right. However, if anyone spots any errors \n\t(incorrect normal direction, calculation, etc), feel free to let me know.\n\n\n \tQuartic examples:\n\n\tEllipse / quartic - mattz\n\thttps://www.shadertoy.com/view/4dVcR1\n\n\tCubic bezier - Signed Distance - NinjaKoala\n\thttps://www.shadertoy.com/view/4sKyzW\n\n    \n\tRaytracing examples for grown ups. :D\n\tActually, they might be raymarched, but either way. :)\n\n\tstochastic path tracer v1 - otaviogood\n\thttps://www.shadertoy.com/view/4ddcRn\n\n\n\tSpectral Path Tracer Test - P_Malin\n\thttps://www.shadertoy.com/view/4s3cRr\n\n\t\n\n\n\n\tFull Scene Radial Blur\n\t----------------------\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps://www.shadertoy.com/view/MdG3RD\n\n\tRadial Blur - IQ\n\thttps://www.shadertoy.com/view/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps://www.shadertoy.com/view/lsf3Dn\n\n*/\n\n// The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n// slightly trimmed down version of that. By the way, there are accumulative weighting \n// methods that do a slightly better job, but this method is good enough for this example.\n\n\n// Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 32.; \n\n\n// 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n// Light offset.\n//\n// I realized, after a while, that determining the correct light position doesn't help, since \n// radial blur doesn't really look right unless its focus point is within the screen boundaries, \n// whereas the light is often out of frame. Therefore, I decided to go for something that at \n// least gives the feel of following the light. In this case, I normalized the light position \n// and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    //vec2 u = sin(vec2(1.57, 0) - iTime/2.);\n    //mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(.5, 3., 2.5));\n    //l.xz = a * l.xz;\n    //l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Screen coordinates.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Radial blur factors.\n    //\n    // Falloff, as we radiate outwards.\n    float decay = 0.925; \n    // Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.7; \n    // Sample weight. Decays as we radiate outwards.\n    float weight = 0.05; \n    \n    // Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    // Offset texture position (uv - .5), offset again by the fake light movement.\n    // It's used to set the blur direction (a direction vector of sorts), and is used \n    // later to center the spotlight.\n    //\n    // The range is centered on zero, which allows the accumulation to spread out in\n    // all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    // Dividing the direction vector above by the sample number and a density factor\n    // which controls how far the blur spreads out. Higher density means a greater \n    // blur radius.\n    vec2 dTuv = tuv*density/SAMPLES;\n    \n    // Grabbing a portion of the initial texture sample. Higher numbers will make the\n    // scene a little clearer and brighter.\n    vec4 col = texture(iChannel0, uv.xy)*0.5;\n    \n    // Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    // samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iTime))*2. - 1.);\n    \n    // The radial blur loop. Take a texture sample, move a little in the direction of\n    // the radial direction vector (dTuv) then take another, slightly less weighted,\n    // sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        col += texture(iChannel0, uv) * weight;\n        weight *= decay;\n        \n    }\n    \n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    //col = mix(col, col.xzyw, uv.y);\n    col = mix(col, vec4(0), (1. - pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)));\n\n    \n    // Multiplying the final color with a spotlight centered on the focal point of the radial\n    // blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    // it didn't come from me. :)\n    //col *= (1. - dot(tuv, tuv)*.75);\n    \n    // Smoothstepping the final color, just to bring it out a bit more.\n    //col = smoothstep(0., .5, col);\n    \n    // Bypassing the radial blur to show the scene on its own.\n    //fragColor = sqrt(texture(iChannel0, fragCoord.xy / iResolution.xy));\n    \n    fragColor = sqrt(mix(max(col, 0.), texture(iChannel0, fragCoord.xy / iResolution.xy), .5));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n\tRaytraced Quartic Surface\n\t-------------------------\n\n\tMattz's quartic solvers inspired me to put this together, and Ninjakoala's refined\n\tquartic solver enabled me to port it to Shadertoy. :) I coded up a generalized quartic \n\tsurface intersection many years ago, and didn't particularly enjoy the experience, so \n\thaven't been in a hurry to port it to the pixel shader environmnet. :)\n\t\n\tFor the most part, I did this for academic purposes. I like raytracing, but I find it \n\ta bit limiting. It appears that everyone else does too, because raytraced triangulated \n\tscenes aside, I seldom see anything more than basic primitives rendered. This is \n\tunderstandable, since surfaces described by higher order equations require far more \n\tcalculation.\n\n\tFor that reason, there's not a lot of raytraced quartic code out there, but now there's\n\ta reference on Shadertoy... I don't have a great deal of interest in it myself, but I \n\tfigured the raytracing crowd might find it novel having something to render other than \n\tspheres and cylinders. :)\n\n\tAnother reason I avoid realtime raytraced scenes is the hard shadows. With this example,\n\tI partly got around the problem by employing a cheap jittering trick, which I wouldn't \n\trecommend, but I think I got away with it here... kind of. :)\n\n\tI applied some geometric tiling and a simple radial blur, in a half hearted attempt to \n\tmake up for the fact that this is a pretty uninspiring lacklustre scene. :)\t\n\n\tBy the way, I hurriedly hacked together the reflection\\refraction loop as an \n\tafterthought. It's not entirely physically accurate, since it lacks proper stack logic, \n\tbut other than that, it seems to be about right. However, if anyone spots any errors \n\t(incorrect normal direction, calculation, etc), feel free to let me know.\n\n\n \tQuartic examples:\n\n\tEllipse / quartic - mattz\n\thttps://www.shadertoy.com/view/4dVcR1\n\n\tCubic bezier - Signed Distance - NinjaKoala\n\thttps://www.shadertoy.com/view/4sKyzW\n\n    \n\tRaytracing examples for grown ups. :D\n\tActually, they might be raymarched, but either way. :)\n\n\tstochastic path tracer v1 - otaviogood\n\thttps://www.shadertoy.com/view/4ddcRn\n\n\n\tSpectral Path Tracer Test - P_Malin\n\thttps://www.shadertoy.com/view/4s3cRr\n\n\n*/\n\n\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n////////////////////\n#define eps .000005\n\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there.\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs.y / 2.;\n\n    float D = p*p - coeffs.x;   \n    \n    if (D <= 0.){\n\t\treturn 0;\n    }\n    else {\n\t\troots = vec2(-1, 1)*sqrt(D) - p;\n\t\treturn 2;\n    }\n}\n\n\n// The following is a variation on the standard cubic solver that I see all over the \n// place. I can thank NinjaKoala for his Newton iteration fix. Basically, he's \n// performing an extra numerical analysis step to accommodate for the loss of accuracy\n// this function suffers from when -- and this is just a guess -- switching from \n// \"double\" accuracy to \"float\" accuracy. Either way, it worked for me, and I'm \n// thankful. :)\n//\n// By the way, I trimmed the function down just slightly to repurpose it to my needs,\n// but it still needs a bit of trimming, and so forth, which I'll get to later.\n// In fact, I might rewrite it from scratch when I'm feeling bored enough.\n\n// From Trisomie21. But instead of his cancellation fix I'm using a Newton iteration.\n//\n// Cubic bezier - Signed Distance - NinjaKoala\n// https://www.shadertoy.com/view/4sKyzW\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a/3.;\n\tfloat q = a * (2.*a*a - 9.*b)/27. + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.*p3/27.;\n\tfloat offset = -a/3.;\n    \n\tif(d >= 0.0) { // Single solution.\n\t\t\n        /*\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z)/2.;\n\t\tfloat v = (-q - z)/2.;\n\t\tu = sign(u)*pow(abs(u), 1./3.);\n\t\tv = sign(v)*pow(abs(v), 1./3.);\n\t\tr[0] = offset + u + v;\t\n\t\t*/\n        \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n\n\t\t// CHANGE\n\t\t// Single newton iteration to account for cancellation.\n\t\tfloat f = ((r[0] + a)*r[0] + b)*r[0] + c;\n\t\tfloat f1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\t\tr[0] -= f/f1;\n\n\t\treturn 1;\n\t}\n    \n\tfloat u = sqrt(-p/3.);\n\tfloat v = acos(-sqrt(-27./p3)*q/2.)/3.;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t// Single newton iteration to account for cancellation\n\t// (once for every root).\n\n\tfloat f,f1;\n\tr[0] = offset + u * (m + m);\n\n\tf = ((r[0] + a)*r[0] + b)*r[0] + c;\n\tf1 = (3.*r[0] + 2. * a)*r[0] + b;\n\n\tr[0] -= f / f1;\n\n\tr[1] = offset - u * (n + m);\n\n\tf = ((r[1] + a)*r[1] + b) * r[1] + c;\n\tf1=(3.*r[1] + 2. * a)*r[1] + b;\n\n\tr[1] -= f / f1;\n\n\tr[2] = offset + u * (n - m);\n\n\tf = ((r[2] + a)*r[2] + b)*r[2] + c;\n\tf1 = (3.*r[2] + 2. * a)*r[2] + b;\n\n\tr[2] -= f / f1;\n\n\treturn 3;\n}\n\n\n/*\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n*/\n\n// Cubic bezier - Signed Distance - NinjaKoala\n// https://www.shadertoy.com/view/4sKyzW\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there.\n\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    //  Substitute x = y - A/4 to eliminate cubic term: x^4 + px^2 + qx + r = 0\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t// Doesn't seem to happen for me.\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0] = z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp = vec2(1e8);\n\t\tint old_num = num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                //s[0] = tmp[0];\n                //s[1] = tmp[1];\n                s.xy = tmp.xy;\n            }\n            else{//old_num == 2\n                //s[2] = tmp[0];\n                //s[3] = tmp[1];\n                s.zw = tmp.xy;\n            }\n        }\n    }\n\n    // Resubstitute.\n    s -= a/4.;\n\n    // I seemed to be getting away without doing this, so left it out.\n    /*\n\t//float sub = 1./4.*a;\n\n\t// Single halley iteration to fix cancellation.\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n    */\n\n    return num;\n}\n///////////////\n\n/*//////////////////////////////////////////////\n////////////////////////////////////////////////\n\n    Quartic surface function, with coefficients.\n\n    A400*x^4 + A040*y^4 + A004*z^4 +\n    A310*x^3*y + A301*x^3*z + \n    A031*y^3*z + A130*x*y^3 +\n    A103*x*z^3 + A013*y*z^3 +\n    A220*x^2*y^2 + A022*y^2*z^2 + A202*x^2*y^2 +\n    A211*x^2*y*z + A121*x*y^2*z + A112*x*y*z^2 +\n    A300*x^3 + A030*y^3 + A003*z^3 +\n    A210*x^2*y + A021*y^2*z + A102*x*z^2 +\n    A120*x*y^2 + A012*y*z^2 + A201*x^2*z +\n    A111*x*y*z +\n    A200*x^2 + A020*y^2 + A002*z^2 +\n    A110*x*y + A011*y*z + A101*x*z +\n    A100*x + A010*y + A001*z +\n    A000 = 0\n\n////////////////////////////////////////////////\n//////////////////////////////////////////////*/ \n\n\n#define OUTER\t 1.\t\t// Ray hit primitive\n#define MISS\t 0.\t\t// Ray missed primitive\n#define INNER\t-1.\t\t// Ray started inside primitive\n\nfloat A400, A040, A004;\nfloat A310, A301, A031, A130, A103, A013;\nfloat A220, A022, A202, A211, A121, A112;\nfloat A300, A030, A003;\nfloat A210, A021, A102, A120, A012, A201;\nfloat A111;\nfloat A200, A020, A002;\nfloat A110, A011, A101;\nfloat A100, A010, A001;\nfloat A000;\n\n// Quartic center.\nvec3 qCenter = vec3(0, 0, 0);\n\n// Transform the quartic.\nvec3 transQuartic(in vec3 v){\n    \n    v.xz *= rot2(iTime/2.);\n    v.xy *= rot2(iTime);\n    return v;\n}\n\n// Makeshift inverse trasformation: Note the order of \"v.xy\" and \"v.xz\" compared\n// to the transform written above. I say this because I completely forgot and it cost\n// me an hour trying to figure out why things didn't look right. :)\nvec3 invTransQuartic(in vec3 v){\n    \n    v.xy = rot2(iTime)*v.xy;\n    v.xz = rot2(iTime/2.)*v.xz;\n    return v;\n}\n\n\nvec3 quarticNorm(vec3 p){\n    \n    // Object translation and rotation.\n    p = transQuartic(p - qCenter);\n    \n\n    // Helper variables.\n    vec3 p2 = p*p, p3 = p2*p;\n    \n    // Differentiating the quartic function (see above) describing the surface, then plugging\n    // in the surface point position to produce the normal -- Partial derivatives, and so forth.\n    // It's pretty standard stuff for anyone with a math background, but if it's not, trust me, \n    // it doesn't take long to learn.\n    \n    vec3 n; // Normal.\n\n\tn.x = A100 + 2.*A200*p.x + 3.*A300*p2.x + 4.*A400*p3.x + A110*p.y + 2.*A210*p.x*p.y + \n\t\t  3.*A310*p2.x*p.y + A120*p2.y + 2.*A202*p.x*p2.y + \n\t\t  2.*A220*p.x*p2.y + A130*p3.y + A101*p.z + 2.*A201*p.x*p.z + \n\t\t  3.*A301*p2.x*p.z + A111*p.y*p.z + 2.*A211*p.x*p.y*p.z + A121*p2.y*p.z + \n\t\t  A102*p2.z + A112*p.y*p2.z + A103*p3.z;\n    \n\tn.y = A010 + A110*p.x + A210*p2.x + A310*p3.x + 2.*A020*p.y + 2.*A120*p.x*p.y + \n\t\t  2.*A202*p2.x*p.y + 2.*A220*p2.x*p.y + 3.*A030*p2.y + \n\t\t  3.*A130*p.x*p2.y + 4.*A040*p3.y + A011*p.z + A111*p.x*p.z + \n\t\t  A211*p2.x*p.z + 2.*A021*p.y*p.z + 2.*A121*p.x*p.y*p.z + 3.*A031*p2.y*p.z + \n\t\t  A012*p2.z + A112*p.x*p2.z + 2.*A022*p.y*p2.z + A013*p3.z;\n    \n\tn.z = A001 + A101*p.x + A201*p2.x + A301*p3.x + A011*p.y + A111*p.x*p.y + \n\t\t  A211*p2.x*p.y + A021*p2.y + A121*p.x*p2.y + A031*p3.y + \n\t\t  2.*A002*p.z + 2.*A102*p.x*p.z + 2.*A012*p.y*p.z + 2.*A112*p.x*p.y*p.z + 2.*A022*p2.y*p.z + \n\t\t  3.*A003*p2.z + 3.*A103*p.x*p2.z + 3.*A013*p.y*p2.z + \n\t\t  4.*A004*p3.z; \n    \n    n = normalize(n); // Normalizing.\n    \n\n    // Transform back by the inverse normal, which means getting the order right. I know \n    // this, but it'd been a while... and to cut a long story short, there's about an hour\n    // that I'll never get back again. :D\n    n = invTransQuartic(n);\n    \n   \n    return n; // Return the normal.\n\n}\n\nvec2 quarticIntersect(vec3 ro, vec3 rd){\n    \n   \n\t\n    // There's a lot of variables here. Most of the time, each of the lines\n    // would be set to equal amounts, which means opportunites for trimming \n    // it right back. It's also possible to streamline for particular objects\n    // which would cut the code back even more. For instance, a rounded cube-\n    // looking object would have most variables set to zero, which would\n    // result in a number of zero entries, thus cutting the code -- and \n    // consequently, processing time -- down considerably.\n    \n    A400 = A040 = A004 = 0.;\n    A310 = A301 = A031 = A130 = A103 = A013 = 0.;\n    A220 = A022 = A202 = A211 = A121 = A112 = 0.;\n    A300 = A030 = A003 = 0.;\n\tA210 = A021 = A102 = A120 = A012 = A201 = 0.;\n\tA111 = 0.;\n\tA200 = A020 = A002 = 0.;\n\tA110 = A011 = A101 = 0.;\n\tA100 = A010 = A001 = 0.;\n\tA000 = 0.;\n    \n////   \n    // Here are just a few of an infinitely many possible surfaces. Feel free to\n    // look some up and plug in the figures.\n     \n    // Surface type: 0 to 3\n    #define SHAPE 0 \n    \n    #if SHAPE==0\n    // Goursat wiffle cube, or tangle cube-like surface.\n\tA400 = A040 = A004 = 1.;\n\tA200 = A020 = A002 = -.3;\n\tA000 = .035;\n    #elif SHAPE==1 \n    // Goursat tooth surface.\n\tA400 = A040 = A004 = 1.;\n\tA200 = A020 = A002 = -.2;\n\tA000 = -.03;\n    #elif SHAPE==2 \n\t// Star jack.\n\tA400 = A040 = A004 = 1.;\n\tA220 = -1.45, A202 = 0.45, A022 = -1.45;\n    A000 = -.02; \n    #else\n    // Klein quartic... or thereabouts. :)\n    const float invSc = 4.; // Quarter scale.\n    A400 = A040 = A004 = 1.*invSc*invSc*invSc*invSc;\n    A200 = A020 = A002 = -18.*invSc*invSc;\n\tA220 = A202 = A022 = 3.*invSc*invSc*invSc*invSc;\n    A111 = 6.*invSc*invSc*invSc;\n    A000 = 70.; \n    #endif\n    \n    \n    /////   \n    \n    // Object position and rotation. Standard stuff.\n    ro = transQuartic(ro - qCenter);\n    rd = transQuartic(rd);\n    \n\n    // Some vectors, to save a few calculations later.\n\tvec3 ro2 = ro*ro, ro3 = ro2*ro, ro4 = ro3*ro;\n\tvec3 rd2 = rd*rd, rd3 = rd2*rd, rd4 = rd3*rd;\n    \n    \n    // Look at this mess! I feel sorry for the poor soul who had to crunch this out... It was me, \n    // but it was many years ago, when I had more energy. I'll assume it's correct. :D Book keeping aside, \n    // it's just a lengthy, but simple, bit of processing -- involving expanding a forth degree polynomial, \n    // grouping terms, and so forth.   \n    \n    // Basically, we're solving the general quartic surface function written above by substituting the ray \n    // distance, \"ro + rd*t\" into it, then solving for \"t.\" In other words, we're solving the following:\n    \n    // A400*(ro.x + rd.x*t)^4 + A040*(ro.y + rd.y*t)^4 + A004*(ro.z + rd.z*t)^4 + ... + A000 = 0.;\n    \n    // After a lot of frustrating expanding and grouping terms, you'll arrive at a function in the form:\n    \n    // C4*t^4 + C3*t^3 + C2*t^2 + C1*t + C0 = 0;\n    \n    // From there, you can solve for t by plugging the coefficients into a function that's built for that \n    // kind of thing, namely, a quartic solver, which is just an application of computing science and math. \n    // The one I'm using is based off a function that has been around for a long time, but has been refined \n    // slightly by Shadertoy user, NinjaKoala.\n    \n    float coeff[5];  // Coefficients storage.\n    \n    // Addendum: My original calculations were correct, but I made a few transcription errors moving the code \n    // from my old C++ project to Shadertoy -- I used a hacky \"find and replace\" method... Terrible. :D \n    // Thankfully, MLA noticed and was kind enough to provide me with the corrected coefficient calculations. \n    // Unlike myself, his coding methodology isn't still stuck in the 90s, so he was clever enough to use \n    // software to do it. :)\n    //\n    // MLA's brief notes: The full set from Sage -- I wouldn't want to do this by hand.\n    coeff[4] = A400*rd4.x + A310*rd3.x*rd.y + A220*rd2.x*rd2.y + A130*rd.x*rd3.y +\n               A040*rd4.y + A301*rd3.x*rd.z + A211*rd2.x*rd.y*rd.z + A121*rd.x*rd2.y*rd.z +\n               A031*rd3.y*rd.z + A202*rd2.x*rd2.z + A112*rd.x*rd.y*rd2.z + A022*rd2.y*rd2.z +\n               A103*rd.x*rd3.z + A013*rd.y*rd3.z + A004*rd4.z; \n\n    coeff[3] = 4.0*A400*ro.x*rd3.x + A310*rd3.x*ro.y + 3.0*A310*ro.x*rd2.x*rd.y +\n               2.0*A220*rd2.x*ro.y*rd.y + 2.0*A220*ro.x*rd.x*rd2.y + 3.0*A130*rd.x*ro.y*rd2.y +\n               A130*ro.x*rd3.y + 4.0*A040*ro.y*rd3.y + A301*rd3.x*ro.z + A211*rd2.x*rd.y*ro.z +\n               A121*rd.x*rd2.y*ro.z + A031*rd3.y*ro.z + 3.0*A301*ro.x*rd2.x*rd.z + A211*rd2.x*ro.y*rd.z +\n               2.0*A211*ro.x*rd.x*rd.y*rd.z + 2.0*A121*rd.x*ro.y*rd.y*rd.z + A121*ro.x*rd2.y*rd.z +\n               3.0*A031*ro.y*rd2.y*rd.z + 2.0*A202*rd2.x*ro.z*rd.z + 2.0*A112*rd.x*rd.y*ro.z*rd.z +\n               2.0*A022*rd2.y*ro.z*rd.z + 2.0*A202*ro.x*rd.x*rd2.z + A112*rd.x*ro.y*rd2.z +\n               A112*ro.x*rd.y*rd2.z + 2.0*A022*ro.y*rd.y*rd2.z + 3.0*A103*rd.x*ro.z*rd2.z +\n               3.0*A013*rd.y*ro.z*rd2.z + A103*ro.x*rd3.z + A013*ro.y*rd3.z + 4.0*A004*ro.z*rd3.z +\n               A300*rd3.x + A210*rd2.x*rd.y + A120*rd.x*rd2.y + A030*rd3.y + A201*rd2.x*rd.z +\n               A111*rd.x*rd.y*rd.z + A021*rd2.y*rd.z + A102*rd.x*rd2.z + A012*rd.y*rd2.z + A003*rd3.z;               \n\n    coeff[2] = 6.0*A400*ro2.x*rd2.x + 3.0*A310*ro.x*rd2.x*ro.y + A220*rd2.x*ro2.y +\n               3.0*A310*ro2.x*rd.x*rd.y + 4.0*A220*ro.x*rd.x*ro.y*rd.y + 3.0*A130*rd.x*ro2.y*rd.y +\n               A220*ro2.x*rd2.y + 3.0*A130*ro.x*ro.y*rd2.y + 6.0*A040*ro2.y*rd2.y +\n               3.0*A301*ro.x*rd2.x*ro.z + A211*rd2.x*ro.y*ro.z + 2.0*A211*ro.x*rd.x*rd.y*ro.z +\n               2.0*A121*rd.x*ro.y*rd.y*ro.z + A121*ro.x*rd2.y*ro.z + 3.0*A031*ro.y*rd2.y*ro.z +\n               A202*rd2.x*ro2.z + A112*rd.x*rd.y*ro2.z + A022*rd2.y*ro2.z + 3.0*A301*ro2.x*rd.x*rd.z +\n               2.0*A211*ro.x*rd.x*ro.y*rd.z + A121*rd.x*ro2.y*rd.z + A211*ro2.x*rd.y*rd.z +\n               2.0*A121*ro.x*ro.y*rd.y*rd.z + 3.0*A031*ro2.y*rd.y*rd.z + 4.0*A202*ro.x*rd.x*ro.z*rd.z +\n               2.0*A112*rd.x*ro.y*ro.z*rd.z + 2.0*A112*ro.x*rd.y*ro.z*rd.z + 4.0*A022*ro.y*rd.y*ro.z*rd.z +\n               3.0*A103*rd.x*ro2.z*rd.z + 3.0*A013*rd.y*ro2.z*rd.z + A202*ro2.x*rd2.z +\n               A112*ro.x*ro.y*rd2.z + A022*ro2.y*rd2.z + 3.0*A103*ro.x*ro.z*rd2.z +\n               3.0*A013*ro.y*ro.z*rd2.z + 6.0*A004*ro2.z*rd2.z + 3.0*A300*ro.x*rd2.x +\n               A210*rd2.x*ro.y + 2.0*A210*ro.x*rd.x*rd.y + 2.0*A120*rd.x*ro.y*rd.y + A120*ro.x*rd2.y +\n               3.0*A030*ro.y*rd2.y + A201*rd2.x*ro.z + A111*rd.x*rd.y*ro.z + A021*rd2.y*ro.z +\n               2.0*A201*ro.x*rd.x*rd.z + A111*rd.x*ro.y*rd.z + A111*ro.x*rd.y*rd.z +\n               2.0*A021*ro.y*rd.y*rd.z + 2.0*A102*rd.x*ro.z*rd.z + 2.0*A012*rd.y*ro.z*rd.z +\n               A102*ro.x*rd2.z + A012*ro.y*rd2.z + 3.0*A003*ro.z*rd2.z + A200*rd2.x +\n               A110*rd.x*rd.y + A020*rd2.y + A101*rd.x*rd.z + A011*rd.y*rd.z + A002*rd2.z; \n\n    coeff[1] = 4.0*A400*ro3.x*rd.x + 3.0*A310*ro2.x*rd.x*ro.y +\n               2.0*A220*ro.x*rd.x*ro2.y + A130*rd.x*ro3.y + A310*ro3.x*rd.y +\n               2.0*A220*ro2.x*ro.y*rd.y + 3.0*A130*ro.x*ro2.y*rd.y + 4.0*A040*ro3.y*rd.y +\n               3.0*A301*ro2.x*rd.x*ro.z + 2.0*A211*ro.x*rd.x*ro.y*ro.z + A121*rd.x*ro2.y*ro.z +\n               A211*ro2.x*rd.y*ro.z + 2.0*A121*ro.x*ro.y*rd.y*ro.z + 3.0*A031*ro2.y*rd.y*ro.z +\n               2.0*A202*ro.x*rd.x*ro2.z + A112*rd.x*ro.y*ro2.z + A112*ro.x*rd.y*ro2.z +\n               2.0*A022*ro.y*rd.y*ro2.z + A103*rd.x*ro3.z + A013*rd.y*ro3.z + A301*ro3.x*rd.z +\n               A211*ro2.x*ro.y*rd.z + A121*ro.x*ro2.y*rd.z + A031*ro3.y*rd.z + 2.0*A202*ro2.x*ro.z*rd.z +\n               2.0*A112*ro.x*ro.y*ro.z*rd.z + 2.0*A022*ro2.y*ro.z*rd.z + 3.0*A103*ro.x*ro2.z*rd.z +\n               3.0*A013*ro.y*ro2.z*rd.z + 4.0*A004*ro3.z*rd.z + 3.0*A300*ro2.x*rd.x +\n               2.0*A210*ro.x*rd.x*ro.y + A120*rd.x*ro2.y + A210*ro2.x*rd.y + 2.0*A120*ro.x*ro.y*rd.y +\n               3.0*A030*ro2.y*rd.y + 2.0*A201*ro.x*rd.x*ro.z + A111*rd.x*ro.y*ro.z +\n               A111*ro.x*rd.y*ro.z + 2.0*A021*ro.y*rd.y*ro.z + A102*rd.x*ro2.z + A012*rd.y*ro2.z +\n               A201*ro2.x*rd.z + A111*ro.x*ro.y*rd.z + A021*ro2.y*rd.z + 2.0*A102*ro.x*ro.z*rd.z +\n               2.0*A012*ro.y*ro.z*rd.z + 3.0*A003*ro2.z*rd.z + 2.0*A200*ro.x*rd.x + A110*rd.x*ro.y +\n               A110*ro.x*rd.y + 2.0*A020*ro.y*rd.y + A101*rd.x*ro.z + A011*rd.y*ro.z +\n               A101*ro.x*rd.z + A011*ro.y*rd.z + 2.0*A002*ro.z*rd.z + A100*rd.x + A010*rd.y + A001*rd.z;                \n\n    coeff[0] = A400*ro4.x + A310*ro3.x*ro.y + A220*ro2.x*ro2.y + A130*ro.x*ro3.y +\n               A040*ro4.y + A301*ro3.x*ro.z + A211*ro2.x*ro.y*ro.z + A121*ro.x*ro2.y*ro.z +\n               A031*ro3.y*ro.z + A202*ro2.x*ro2.z + A112*ro.x*ro.y*ro2.z + A022*ro2.y*ro2.z +\n               A103*ro.x*ro3.z + A013*ro.y*ro3.z + A004*ro4.z + A300*ro3.x + A210*ro2.x*ro.y +\n               A120*ro.x*ro2.y + A030*ro3.y + A201*ro2.x*ro.z + A111*ro.x*ro.y*ro.z + A021*ro2.y*ro.z +\n               A102*ro.x*ro2.z + A012*ro.y*ro2.z + A003*ro3.z + A200*ro2.x + A110*ro.x*ro.y +\n               A020*ro2.y + A101*ro.x*ro.z + A011*ro.y*ro.z + A002*ro2.z + A100*ro.x + A010*ro.y + A001*ro.z + \n               A000;\n        \n    \n    // Plug the coefficents into Ninja Koala's refined quartic formula, which itself was based on a formula \n    // written many years ago.\n    //\n    // By the way, it'd be more efficient to use a vec4 for the coefficients above, then divide the results \n    // by the last term, but probably less readable. \n    //\n    vec4 roots;// = vec4(1e8);\n    vec4 coeff4 = vec4(coeff[0], coeff[1], coeff[2], coeff[3])/coeff[4];\n    //\n    // The function returns the number of roots (intersections) and stores the solutions (distances to \n    // intersections) to the equation in \"roots.\" Depending on the surface, up to four solutions \n    // (intersections) are possible. Obviously, we want the closest one to the jump-off point.\n\tint nroots = solve_quartic(coeff4, roots);\n    \n    \n    // If you were only interested in an outer hit point (no refraction), you'd only need to return the \n    // minimum distance, so the following wouldn't be necessary.\n\n    // Super lazy distance ordering. Since there are only 4 roots stored in a vec4, I should probably perform \n    // some swizzling, or something.\n\tfor(int i=0; i<nroots; i++){\n        for(int j = i + 1; j<nroots; j++){\n            if(roots[i]>roots[j]){\n                float temp = roots[i];\n                roots[i] = roots[j];\n                roots[j] = temp;\n            }\n        }\n\t}\n\n\t// Obtaining the closest hit point (if applicable), and determining whether the ray has hit the outer \n    // surface or inner surface.\n    float t = 1e8, retval=0., t0;\n\n\tfor(int k = 0; k<nroots; k++){\n        t0 = roots[k]; \n        if (t0>0. && t0<t){\n            t = t0;\n            retval = ((k&1)==0)? OUTER : INNER;\n            break;\n        }\t  \n\t}   \n    \n    // Return the nearest surface distance, and it's classification (outer, inner, no hit).\n    return vec2(t, retval);\n    \n    \n    \n}\n\n// Plane normals.\nvec3 planeNorm(vec3 p, float id){\n   \n    if(id<1.5) return normalize(vec3(0, 0, -1));\n    else return normalize(vec3(0, 1, 0));\n    \n}\n\n// Plane intersection. Old formula, and could do with some tidying up.\nvec2 planeIntersect(vec3 ro, vec3 rd, vec3 n, float d){\n\n    float t = 1e8, retval = 0.;\n\n\tfloat ndotdir = dot(rd, n);\n    \n\tif (ndotdir < 0.){\n\t\n\t\tfloat dist = (d - dot(n, ro))/ndotdir;\t\n \t\t\t\n\t\tif (dist>0. && dist<t){\n\t\t//if ((dist < t)){\n\t\t\tt = dist;\n\t\t\tretval = 1.;\n\t\t}\n\t}\n    \n    return vec2(t, retval);\n\n}\n\n// Scene normal logic.\nvec3 getNorm(vec3 p, float id){\n    \n    vec3 n;\n    \n    if(id<.5) n = quarticNorm(p);\n    else n = planeNorm(p, id);\n    \n    return n;\n    \n    \n}\n\n// Intersection logic for all objects.\nvec3 intersect(vec3 ro, vec3 rd){\n    \n    vec2 qI = quarticIntersect(ro, rd);\n    vec2 pI = planeIntersect(ro, rd, normalize(vec3(0, 0, -1)), -4.5);\n    vec2 pI2 = planeIntersect(ro, rd, normalize(vec3(0, 1, 0)), -1.5);\n    \n    //pI.x += 1e8;\n    //qI.x += 1e8;\n    \n    return qI.x<pI.x && qI.x<pI2.x? vec3(qI, 0.): pI.x<pI2.x? vec3(pI, 1.) : vec3(pI2, 2.);\n    \n    \n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// 2D distance formula.\nfloat dist(vec2 p, vec2 b){\n    \n    //return sdBox(p, b);\n    \n    p = abs(p);\n    p -= b;\n    return smax(p.x, p.y, .125);\n    \n}\n\n// vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(41, 289)))*43758.5453); }\n\n\n/*\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(1, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n*/\n\n// IQ's unsigned box formula.\nfloat sBoxS(in vec2 p, in vec2 b, float r){\n  p = abs(p) - b + r;\n  //return max(p.x, p.y);\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - r;\n}\n\n// Custom box divide formula: I wrote this from scratch, and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to take a space and position preserving approach, which should make\n// it much easier to work with. The routines I've come across don't do that. :)\n//\n// The idea is simple, in theory, and the solution was simple, but as usual, I had\n// to make way too many mistakes to get there. Basically, you start in one of the\n// corners of the grid square, produce a random number, then split space vertically \n// or horizontally, according to the random factor. For instance, if the random number\n// is \".6,\" then split the space in a 60% to 40% ratio, update postions (depending\n// which side of the line you're on), reduce the space dimensions accordingly, etc.\n//\n// Simple, right? It should have been. :D Anyway, it's done now, so feel free to\n// use it for whatever you want.\n//\nfloat boxDivide(in vec2 p, in float sc){\n\n    p *= .25;\n    p += .5;\n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    //const float sc = 1.;\n    p *= sc;\n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n    \n    // Vertical offset. \n    //#define VERT_OFFSET\n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 4;\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i = min(0, iFrame); i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.45 + (1. - .45)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        \n        // Minimum width... Thrown in at the last minute to enforce a\n        // minimum box size. There are probably better ways, but it works\n        // well enough.\n        const float mW = .125;\n        if(l.x<mW && l.y<mW) break;\n        if(l.x<mW && r2>.5) { r2 = 0.; }// r = .5;\n        if(l.y<mW && r2<=.5) { r2 = 1.; }\n        \n        //if(hash21(ip + 113.523 + l.yx + float(i)/float(iNum))<.3) continue;\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n              // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n        }\n        \n        // There are many ways to vary the line width.\n        #ifdef VARIABLE_LINE_WIDTH\n        l *= 1. - r*.03;\n        //l *= 1. - length(l)*.02;\n        //l *= .986;\n        #endif\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimenting, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    float d = sBoxS(p - s - l/2., l/2., .06*sqrt(rf));// + .001*sc;\n    \n   \n    \n    // Smoothing factor.\n    float sf = 1./450.*sc;//1./iResolution.y*sc;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    //vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n     \n     \n    // Center, space preserving dots.\n    // Just the center dot.\n    //float d2 = length(p - s - l/2.) - .004/sc;\n    // Splitting space to produce four rivot-looking dots.\n    //p = abs(p - s - l/2.) - l/2. + .015;\n    //float d2 = length(p) - .004/sc;\n    \n    // Very subtle bump element for some highlighting.\n    sf *= 4.;\n    float b = mix(0., 1., 1. - smoothstep(0., sf, d + .014*sc)); \n    //b = mix(b, 0., 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    //b = mix(b, 0., 1. - smoothstep(0., sf, d2)); // Rounded pavers.  \n    \n    b += min(-d*8., .05);\n      \n    // Return the bump value.\n    return b; \n    \n}\n\n\n// Bump function logic. Rushed, as you can see. \nfloat bumpFunc(vec3 p, vec3 n, float id){\n    \n    float c;\n    \n    if(id<.5){\n        \n        c = 0.;\n        \n        /*\n        p = transQuartic(p - qCenter);\n        c = n3D(p*4.);\n        c = sin(c*6.283*8.)*.5 + .5;\n\t\t*/\n       \n    }\n    else {\n\n        // 2D vector setup. Use XY for the back plane, or XZ for the ground plane.\n        // There's some lining up as well.\n        vec2 q;\n        if(id<1.5) q = p.xy - vec2(10.5, .5 + .75-.125);\n        else q = p.xz - vec2(10.5, 1);\n        \n        c = boxDivide(q, 1.);\n        \n        \n        // Hacky brick-like skirting. There'd be better ways to go about it, that's for sure.\n        float lns = clamp(-cos((p.x - 1.5)*6.283*.5)*48. + 47.9, 0., 1.);\n        if(id<1.5 && p.y<-.75-.125) c = (p.y>-.8-.125) ? 0.: p.y<-1.4? 0.: lns;\n\n    }\n\n\n    \n    return c;//smoothstep(0.05, .4, c);\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 bumpMap(in vec3 p, in vec3 n, float bumpfactor, float id){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpFunc(p, n, id);                 \n    vec3 grad = (vec3(bumpFunc(p - e.xyy, n, id),\n                      bumpFunc(p - e.yxy, n, id),\n                      bumpFunc(p - e.yyx, n, id) )-ref)/e.x;                     \n          \n    grad -= n*dot(n, grad);          \n                      \n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n, float id){\n    \n    if(id<.5){\n        p = transQuartic(p - qCenter);\n        n = transQuartic(n);\n    }\n    else p += .2;\n    \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n    \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 bumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf, float id){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n, id), tex3D(tx, p - e.yxy, n, id), tex3D(tx, p - e.yyx, n, id));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n, id), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Unit ray setup -- with a bit of rotation.\n    vec3 rd = normalize(vec3(uv, .9));\n    rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));\n    \n    // Moving the ray around a bit. A proper camera setup would be better,\n    // but this will do.\n    float swiv = sin(iTime/3.);\n    float swiv2 = cos(iTime/3.);\n    rd.xz *= rot2(-.35 + swiv*.1);\n    rd.yz *= rot2(-.05 + swiv2*.025);\n    \n    \n    // Ray origin, or camera position, if you prefer.\n    vec3 ro = vec3(1., 0, -2.);\n    \n    // Moving the camera and the object back and forth for something to do. :)\n    ro.x -= swiv*.35;\n    //qCenter.xz -= vec2(swiv, -.5 + swiv2*.5)*.25;\n    \n    // Some randomness -- Used to jitter the light. Mostly for the shadows, but I get it'll\n    // give a jittery lighting effect too. If that wasn't desirable, you could set up a\n    // non jittering light, and an extra jittery light.\n    float hash = fract(sin(dot(rd + fract(iTime)*vec3(.9, .7, .8), vec3(1, 157, 113)))*43758.5453);\n    \n    // Jittery lights for a poor man's path tracing effect. :D\n    vec3 lp = ro + vec3(0, 1.5, 1.65)*1.*(1.05 - hash*.1);\n    vec3 lp2 = ro + vec3(0, 1.5, 1.65)*.95*(.95 + hash*.1);\n    \n    \n    // Ray bounces, passes, etc. Probably the minimum necessary. Change the number to\n    // something like 2 or 3 to see the difference.    \n    const int sNum = 5;\n    \n    // Some multiple bounce varibles.\n    float total = 0., totAtten = 1.;\n    \n    // Accumulative color.\n    vec3 aCol = vec3(0);\n    \n    // Refraction ration. solid glass, or near enough. If you don't like the glassy ray bending,\n    // you could bring the figure down closer to one for that air effect.\n    float refRatio = 1./1.5;\n    \n    // More loop utils First distance.\n    //float fDist = 0.;\n    //float grad = rd.y*.5 + .5;\n    \n    // Was going to be used for makeshift stencil buffer shadow blurring, but I went with another method.\n    //float gSh = 0.; \n    \n    //#define MAX_DIST 20. // Necessary, if there's a horizon involved.\n    \n    // The mulitple ray-bounce loop. Hacked together on the fly, so it needs some restructuring, etc.\n    for (int i = min(0, iFrame); i<sNum; i++){\n        \n        \n        // The ridiculously bloated intersection formula. Thankfully, it's only called once.\n        // That's the payoff... although it's diminishing returns, if you ask me. :)\n        // vec3 t = vec3(distance, hitInnerOuter, objectID);\n        vec3 t = intersect(ro, rd);\n        //t.x = min(t.x, MAX_DIST);\n        \n        \n        /*\n        if(i==0) {\n            fDist = t.x;\n            gSh = 1.;\n        }\n\t\t*/\n        \n        // Initialize the bounce-pass color to zero.\n        vec3 col = vec3(0);\n        \n        \n    \n        if(t.y!=0.){\n\n            // Hit point for this pass.\n            vec3 sp = ro + t.x*rd;\n\n            // Unit light direction vector, surface to light distance and attenuation.\n            vec3 ld = lp - sp;\n            float lDist = max(length(ld), .0001);\n            float atten = 1./(1. + lDist*lDist*.25);\n           \tld /= lDist;\n\n            // Hit point normal -- oriented depending on whether you've hit and inner or outer surface.\n            vec3 sn = sign(t.y)*getNorm(sp, t.z);\n            //sn *= sign(dot(sn, -rd));; // If you didn't have inner outer access. \n            \n  \n            // Bump mapping. Only on the first pass to save cycles.\n            float bf = .002;\n            if(t.z>.5) bf = .25;\n            if(i==0) sn = bumpMap(sp, sn, bf, t.z);///(1.+ t.x*t.x*.1));\n            \n\n            // Texture-based bump mapping. Not used here.\n            float txSc = .25;\n            if(t.z<.5) txSc = 1.;\n        \t//if(i==0 && t.z>.5) sn = bumpMap(iChannel0, sp*txSc, sn, .005, t.z);\n\n            \n            // Shadows. It's faster to just render it on the first pass, but I thought I'd live\n            // dangerously and render them on subsequent passes also. :D\n            float sh = 1.;\n            vec3 t2 = intersect(sp + sn*.0015, ld);\n\t\t\t//\n            if(t2.y != 0. && t2.x<lDist) sh = t2.z<.5? .4 : .5;\n            \n            \n            // Blending in another jittered shadow sample on the first pass for\n            // a slightly softer look... Yeah, I know. Lamest soft shadows ever. :D\n            if(i==0){\n                float sh2 = 1.;\n                vec3 ld2 = lp2 - sp;\n                float lDist2 = max(length(ld), .0001);\n            \tvec3 t3 = intersect(sp + sn*.0015, ld2);\n            \n                 if(t3.y != 0. && t3.x<lDist2){\n                     sh2 = t3.z<.5? .4 : .5;\n                 }\n            \n            \tsh = mix(sh, sh2, .5);\n            }\n            \n            //if(i==0) gSh = sh;\n            \n            // Texture value at the surface. Manipulate it depending on which surface has been hit.         \n\t\t\tvec3 tx = tex3D(iChannel0, sp*txSc, sn, t.z);\n            if(t.z<.5) tx = smoothstep(.05, .5, tx)*2.; // Quartic texel.\n            else {\n                \n                tx = vec3(1.1, .8, .6)*smoothstep(-.05, .7, tx)*1.75; // Wall texels.\n                \n                if(t.z > 1.5) tx *= vec3(1.2, 1, .8);  // Back wall.                  \n                else if(sp.y<-.775-.125 && sp.y>-1.45) tx *= vec3(1.1, 1, .9)*1.5; // Back wall skirting strip.\n \n            }\n            \n            \n            vec3 refl = reflect(rd, sn);\n\n            float diff = max(dot(ld, sn), 0.);\n            // Specular lighting.\n            float spec = pow(max( dot( reflect(-ld, sn), -rd), 0.), 32.);\n            \n            // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        \tfloat fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 2.);\n             \n\n\t\t\t// Combining the terms above and applying them to the quartic object first, then the walls.\t\n            if(t.z<.5) col = 4.*tx*vec3(1, .9, .8)*(diff*diff*.3 + .1 + vec3(1, .35, .2)*spec*32. \n                             + vec3(.25, .5, 1)*fre*4.);\n            else col = tx*(diff*diff*vec3(.7, 1, 1.4) + .1 + vec3(1, .7, .5)*spec*2.5 + vec3(.25, .5, 1)*fre*fre*3.);\n\n            \n            // Applying the bump shade to the walls to darken the crevices more.\n            if(t.z>.5) col *= bumpFunc(sp, sn, t.z)*.6 + .4;\n            \n            \n            // Attenuation and shadowing for this pass.\n            col *= atten*sh; // Normal-based coloring: (sn.yzx*.2 + .9);\n\n            \n            \n\t\t\t// Once the color has been determined for this pass, decide where the next ray is going by\n            // changing the unit direction vector at the surface. First determine whether refraction is\n            // possible. By the way, some reflection is usually observed with every surface hit, but we \n            // need a stack for that, and I was too lazy to set one up. I will next time though.\n            vec3 refr = refract(rd, sn, refRatio);\n            if (dot (refr, refr) < .001 || t.z>.5) { // Is refraction a viable option.\n                \n                // Refraction not possible, so reflect. \n\t\t\t\trd = refl;\n           \t\t// break;\n            }        \n            else {\n                // Refract, then invert the refractive index for the next refractive pass, which will be \n                // from the inner part of the object to an object outside. As you know, the refractive\n                // index of medium A to medium B is the inverse of medium B to medium A.\n                rd = refr;\n                refRatio = 1./refRatio;\n            }\n            //rd = refl; // Debug, for relective passes only.\n            \n            // The old surface hit point becomes the new jump off point (ray origin) for the next pass.\n            // It's also necessary to bump the ray off the surface just a fraction to avoid intersecting\n            // with the new hit point itself. I used to make that mistake all the time. :)\n            ro = sp - sign(t.y)*sn*.001;\n\n        }\n        //else break;\n        \n        \n        // If you didn't have the back wall, you'd want something like this to fog\n        // out the horizon.\n        //col = mix(col, vec3(1, .9, .8)*grad/32., smoothstep(0., .95, t.x/MAX_DIST));\n        \n       \n        \n        // There are different ways to blend successive passes. This is one of them.\n        aCol = mix(aCol, col, totAtten);\n        \n        // Additive blending is another.\n        //aCol += col*totAtten;\n        \n        \n        \n        // Sometimes useful when using additive blending.\n        //total += totAtten;\n        // Toning down the contribution of the next pass -- Analogous to applying layers.\n        totAtten *= .866025; // Using sqrt(3)/2. to give the impression that something clever is going on. :D\n        \n         \n        // If there's no hit, or we hit a wall, break from the loop.\n        if(t.y==0. || t.z>.5) break;\n        \n    }\n    \n    // If using additive blending, which we're not for this example.\n    //aCol /= float(sNum);//total;    \n    \n    // A colder looking scene. Sometimes global coloring can add a little more scene consistency.\n    //aCol *= vec3(.7, 1, 1.4);\n    \n    \n    \n\n    //aCol = mix(aCol, vec3(.7, 1, .9)*grad, smoothstep(0., .95, fDist/10.));\n    //smoothstep(0., .95, fDist/10.)//1.-1./(1. + fDist*fDist*.05)\n\n    // A bit of temperal blurring. Not absolutely necessary, but figured why not? :)\n    uv = fragCoord/iResolution.xy;\n    aCol = mix(texture(iChannel1, uv).xyz, aCol, 1./3.);\n\n    // Output to screen\n    fragColor = vec4((max(aCol, 0.)), 1); // gSh\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}