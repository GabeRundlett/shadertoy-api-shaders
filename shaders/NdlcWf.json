{
    "Shader": {
        "info": {
            "date": "1642809886",
            "description": "Continuing to experiment with raymarching. I'm going to be using this as a template for exploring 3D data and graphs.",
            "flags": 0,
            "hasliked": 0,
            "id": "NdlcWf",
            "likes": 6,
            "name": "Rubber 3",
            "published": 3,
            "tags": [
                "3d"
            ],
            "usePreview": 0,
            "username": "ersh",
            "viewed": 256
        },
        "renderpass": [
            {
                "code": "#define LIMITED_BY    2    // 0: infinite;  1: circle;  2: square\n#define COLOR         0\n#define MESH          1\n#define MESH_COLOR    0\n#define SCALE         3.\n#define MAXDIST       10.\n#define STEP          0.1\n\n//https://graphtoy.com/?f1(x,t)=sin(x+t)*sin(x/5-t*4)&v1=false&f2(x,t)=f1(x/2,t/2)*1.3-f1(x-1,t-5)&v2=false&f3(x,t)=f2(x/2,t/2)*1.3-f1(x-1,t-5)&v3=false&f4(x,t)=f3(x,t)*(0.5+f1(x-3,t*3-5)/2)&v4=true&f5(x,t)=&v5=false&f6(x,t)=&v6=false&grid=true&coords=0,0,21.258732000000105\nfloat f1(float x, float t) { return sin(x+t)*sin(x/5.-t*4.); }\nfloat f2(float x, float t) { return f1(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f3(float x, float t) { return f2(x/2.,t/2.)*1.3-f1(x-1.,t-5.); }\nfloat f4(float x, float t) { return f3(x,t)*(0.5+f1(x/3.4-3.,t*2.-5.)/2.); }\n\nvec3 col(float x, float side) {\n#if COLOR\n  return vec3(clamp(x/2.+0.5,0.,1.), side, clamp(0.5-x/2.,0.,1.));\n#else\n  return vec3(clamp(1.-side, 0., 0.8));\n#endif\n}\n\nfloat h(vec2 p, float t) {\n    return\n        f4(p.x, t) + f4(p.y + 42.123, t/1.321+31.32) +\n        f4(p.x, t) * f4(p.y + 42.123, t/1.321+31.32)/3.;\n}\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n//#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))             // rotation hack                  \n\n#define PI       3.1415926\n#define R        iResolution\n#define H(pos)   h((pos)*SCALE, iTime)/5.\n#define INTERP_MIX(PREV, TARGET, CUR)   (TARGET-PREV)/(CUR-PREV)\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec3 D = normalize(vec3(I+I, -4.*R.y) - vec3(R.xy, 0.));    // ray direction\n    vec3 p = vec3(0,0,7);                                       // current ray pos\n\n    mat2 rot_yz, rot_xy;            // rotations\n    if (iMouse.z < 0.5) {\n      rot_yz = rot(-PI*(0.35 + (sin(iTime/6.)+1.)*0.06));\n      rot_xy = rot(PI/3. + iTime/10.);\n    } else {\n      vec2 M = (iMouse.xy / R.xy * vec2(1., -0.5) + vec2(0.5, 0.)) * 2. * PI;\n      rot_yz = rot(M.y);\n      rot_xy = rot(M.x);\n    }\n    p.yz *= rot_yz;  p.xy *= rot_xy;\n    D.yz *= rot_yz;  D.xy *= rot_xy;\n\n    // Walk the ray\n    float height, diff;\n    float heightprev = H(p.xy), diffprev = 0.;\n    vec3 pprev = p;\n    float dist, stp = STEP;      // distance traveled, step\n    for (dist = 0.;  dist < MAXDIST;  dist += stp, p += stp*D) {\n        height = H(p.xy);\n        diff = p.z - height;\n        if (\n#if LIMITED_BY == 1\n            length(p.xy) < 2. &&\n#elif LIMITED_BY == 2\n            abs(p.x) < 2. && abs(p.y) < 2. &&\n#endif\n            diff * diffprev < 0.)\n        {\n            // Crossed the surface\n            break;\n        }\n        heightprev = height;\n        pprev = p;\n        diffprev = diff;\n    }\n\n    if (dist < MAXDIST) {    // Crossed the surface\n        // interpolate the exact intersection pos\n        float interp = INTERP_MIX(diffprev, 0., diff);\n        vec3 pexact = mix(pprev, p, interp);\n        float heightexact = H(pexact.xy);\n\n        // sign: +1 = looking top-down, -1 = looking down-up\n        float sgn = sign(diffprev);\n\n        vec3 c = col(heightexact*2., (-sgn+1.)/4.) * (1.-(1. - sgn)/3.);\n#if MESH\n        //vec2 mesh = fract(pexact.xy*5.);\n        float mesh_thick = 0.015;      // 0.5 max\n        float mesh_density = 3.;      // 0.5 max\n        vec2 mesh = max(vec2(0), abs(fract(pexact.xy*mesh_density)-vec2(0.5)) - vec2(0.5*(1.-2.*mesh_thick)))/mesh_thick;\n        c = mix(c, vec3(MESH_COLOR), max(mesh.x, mesh.y));\n#endif\n\n        // Angle for shading\n        //float surface_angle = atan((heightexact - H((pexact.xy+vec2(0.001)))) / 0.0014);\n        vec2 shade = vec2(1,0) * rot_xy;\n        float surface_angle = atan((heightexact - H((pexact.xy + shade*0.001))) / 0.001);\n        c += sgn*(surface_angle/3.);\n\n        O = vec4(c * (MAXDIST - dist)/MAXDIST * 2., 0.);\n    } else {\n        O = vec4(0);\n    }\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}