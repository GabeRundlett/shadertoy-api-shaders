{
    "Shader": {
        "info": {
            "date": "1623457434",
            "description": "Trying to see if I can accelerate ray-casting a complicated model by using low-res multiple passes.\n\nSwiping mouse left/right turns optimization off (orange) or on (not orange)",
            "flags": 32,
            "hasliked": 0,
            "id": "7tl3Wf",
            "likes": 7,
            "name": "multipass optimization play",
            "published": 3,
            "tags": [
                "multipassopt"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 288
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float speed_test = step(2.0 * iMouse.x - 0.5 * iResolution.x, fragCoord.x);\n    \n    vec3 orig = get_orig(iTime);\n    vec3 dir = get_ray(fragCoord, iResolution.xy, iTime);\n\n    \n    vec4 col = texture(iChannel0,  0.25 * uv);\n    \n    float dist = float_from_col(col);\n    \n    float dist_refined = raymarch(orig, dir, speed_test * dist, 1.0e-4);\n    \n    \n    if (dist_refined > MAX_DIST) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    \n    \n    vec3 loc = orig + dir * dist_refined;\n    \n    vec3 light = get_light(iTime);\n    \n    float dist_from_light = length(loc - light);\n    \n    vec2 light_uv = light_ray_to_uv(loc - light, iResolution.xy, iTime);\n    float light_dist_from_tex = float_from_col(texture(iChannel1, light_uv));\n    float dist_from_light_to_surf = raymarch(light, normalize(loc - light),\n                                             speed_test * 0.5 * light_dist_from_tex, 1.0e-4);\n    float subsurf = max(0.0, dist_from_light - dist_from_light_to_surf);\n    \n        \n    vec3 spectrum =  60.0 * vec3(0.05, 0.25, 0.85);\n    \n    \n    float metal = smoothstep(0.3, 0.2, engine_check(loc));\n\n    if (metal > 0.5) {\n      spectrum = spectrum * 0.001;\n    }\n\n    vec3 subsurf_bright = spectrum / (spectrum + subsurf);\n    \n    vec3 normal = sdf_normal(loc);\n    vec3 bounce = normalize(reflect(dir, normal));\n    \n    float dot_light = dot(normalize(light - loc), bounce);\n    vec3 refl_bright = smoothstep(vec3(0.8, 0.85, 0.9), vec3(1.0), vec3(dot_light));\n    float diffuse = 0.2 + max(0.0, dot(normalize(light - loc), normal));\n\n    if (metal > 0.5) {\n      diffuse = 0.2 + 1.0 * max(0.0, dot_light); //  + 0.1 * sin(20.0 * bounce.y);\n    }\n    \n    vec3 color1 = 0.75 * subsurf_bright * diffuse + 0.5 * refl_bright + 0.15 * subsurf_bright;\n    vec3 color2 = 0.75 * smoothstep(0.95, 1.0, refl_bright) + 0.25 * (0.5 + 0.5 * bounce);\n    \n    float material = smoothstep(0.05, 0.1, 2.0 * cockpit_check(loc)); \n    // material = 0.0;\n    // Output to screen\n    fragColor = vec4(mix(color2, color1, material) + mix(vec3(1., 0.5, 0.), vec3(0.), speed_test), 1.0);\n   // fragColor = fragColor + 200.0 * texture(iChannel1,  0.5 * uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_DIST 20.0\n\nmat3 global_twist = mat3(1.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\nvoid set_twist(in float time) {\n  float ct = cos(0.5 * time);\n  float st = sin(0.5 * time);\n  global_twist = mat3(ct, st, 0.0, -st, ct, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 get_orig(in float time) {\n  return vec3(0.0, 4.0, -8.0);\n}\n\nvec3 get_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  return normalize(tilt * vec3(uv, 1.7));\n}\n\nvec3 get_light(in float time) {\n  vec3 pt = get_orig(time);\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * pt;\n}\n\nvec3 get_light_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  vec3 dir = normalize(tilt * vec3(uv, 0.45));\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * dir;\n}\n\nvec2 light_ray_to_uv(in vec3 ray, in vec2 resolution, in float time) {\n  // will break if time starts to matter, makes assumptions\n  const mat3 inv_light = mat3(0.6, 0.0, -0.8, 0.0, 1.0, 0.0, 0.8, 0.0, 0.6);\n  const mat3 inv_tilt = mat3(1.0, 0.0, 0.0,\n                             0.0, 0.8660254, -0.5,\n                             0.0, 0.5, 0.8660254);\n  vec3 xformed =  inv_tilt * (inv_light * ray);\n  vec2 uv = 0.45 * xformed.xy/xformed.z;\n  uv *= max(resolution.x, resolution.y)/resolution.xy;\n  uv = 0.5 * uv + 0.5;\n  return clamp(0.25 * uv, 0.0, 0.25);\n}\n\nfloat calc_stop_per_d(in float scale, in vec2 resolution) {\n  float per_pix_at_plane = 2.0 / max(resolution.x, resolution.y);\n  return per_pix_at_plane / (scale * 1.7);\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_isect(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}\n\nfloat checked_smooth_diff(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, b, k);\n}\n\nfloat super_egg(in vec3 pt) {\n  vec3 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 1.0;\n}\n\nfloat semi_egg(in vec3 pt) {\n  return super_egg(vec3(pt.x, length(pt.yz), 0.0));\n}\n\nfloat car_core(in vec3 pt) {\n  return super_egg(pt / vec3(9.0, 4.0, 1.0));\n}\n\nfloat cockpit(in vec3 pt) {\n  return checked_smooth_isect(semi_egg((pt.yzx - vec3(0.,1.75, 4.)) / vec3(3., 2., 7.)),\n                              semi_egg((pt.yzx - vec3(0., 1.5, 3.)) / vec3(4., 3., 5.)),\n                              0.25);\n} \n\nfloat car(in vec3 pt) {\n  return checked_smooth_min(car_core(pt), cockpit(pt), 1.25);\n}\n\nfloat engines(in vec3 pt) {\n  return min(semi_egg((pt + vec3(9., 4.75, -2.3)) / vec3(6.0, 1.0, 1.0)),\n             semi_egg((pt + vec3(9.0, -4.75, -2.3)) / vec3(6., 1., 1.)));\n}\n\nfloat box(in vec3 pt_min, in vec3 pt_max, in vec3 pt) {\n  vec3 dists = max(pt_min - pt, pt - pt_max);\n  return max(dists.x, max(dists.y, dists.z));\n}\n\nfloat wings(in vec3 pt) {\n  float unboxed = checked_smooth_diff(\n    -min(-super_egg((pt + vec3(5., 0., -2.)) / vec3(9., 5., 2.)),\n         super_egg((pt + vec3(2., 0., -2.1)) / vec3(8.75, 4.25, 1.6))),\n    super_egg((pt + vec3(4., 0., -4.5)) / vec3(3., 12., 3.)),\n    1.0);\n    \n    return checked_smooth_isect(box(vec3(-9.5, -5., -5.), vec3(-3., 5., 5.), pt),\n                                unboxed, 1.);\n}\n\nfloat sdf(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  float carval =  min(car(p), engines(p));\n  return checked_smooth_min(carval, wings(p), 0.5);\n}\n\nfloat cockpit_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_diff(cockpit(p), car_core(p), 0.25);\n}\n\nfloat engine_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_min(engines(p), max(3.0 - p.z, wings(p)), 0.5);\n  // return checked_smooth_min(engines(p), wings(p), 0.5);\n  // return engines(p);\n}\n\nvec3 sdf_normal(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 0.001;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir,\n               in float start_d, in float stop_per_d) {\n  float along = start_d;\n  for (int i = 0; i < 256; ++i) {\n    vec3 pt = orig + along * dir;\n    float d = sdf(pt);\n    if (along > MAX_DIST || abs(d) < stop_per_d * max(along, 1.0)) {\n      return along;\n    }\n    along = along + 0.25 * d;\n  }\n  return along;\n}\n\nfloat float_from_col(in vec4 rgba) {\n  return 256.0 * rgba.r + rgba.g + 0.00390625 * (rgba.b + 0.00390625 * rgba.a);\n}\n\n\n\nvec4 col_from_float(in float val) {\n  vec4 result;\n  result.r = mod(0.00390625 * val, 1.0);\n  val = val - 256.0 * result.r;\n  result.g = mod(val, 1.0);\n  val = val - result.g;\n  val = val * 256.0;\n  result.b = mod(val, 1.0);\n  val = val - result.b;\n  val = val * 256.0;\n  result.a = mod(val, 1.0);\n  return result;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n    vec3 orig = get_orig(iTime);\n    vec3 dir = get_ray(4.0 * fragCoord, iResolution.xy, iTime);\n    float dist_out = MAX_DIST + 1.0;\n    if (4.0 * fragCoord.x < iResolution.x && 4.0 * fragCoord.y < iResolution.y) {\n      dist_out = raymarch(orig, dir, 0.0, calc_stop_per_d(0.03125, iResolution.xy));\n    }\n    fragColor = col_from_float(dist_out);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n\n    vec3 orig = get_light(iTime);\n    vec3 dir = get_light_ray(4.0 * fragCoord, iResolution.xy, iTime);\n    float dist_out = MAX_DIST + 1.0;\n    if (4.0 * fragCoord.x < iResolution.x && 4.0 * fragCoord.y < iResolution.y) {\n      dist_out = raymarch(orig, dir, 0.0, calc_stop_per_d(0.125, iResolution.xy));\n    }\n    fragColor = col_from_float(dist_out);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}