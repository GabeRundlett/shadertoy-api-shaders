{
    "Shader": {
        "info": {
            "date": "1705617402",
            "description": "Analytical bounding volumes expansion (blue) of primitive SDFs so that they can perfectly bound their smooth-union (white). Red background where the the smooth-union is imperfect. Only \"Circular\" has local support at the expense of breaking ramyarchers.",
            "flags": 0,
            "hasliked": 0,
            "id": "DlVcW1",
            "likes": 41,
            "name": "Smooth-minimum Bounds",
            "published": 3,
            "tags": [
                "2d",
                "sdf",
                "smin"
            ],
            "usePreview": 0,
            "username": "iq",
            "viewed": 1792
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Comparison of most smin() pressented in this article:\n// https://iquilezles.org/articles/smin/\n//\n// ** Note that all smooth minimum functions are normalized so\n//    that the blending parameter k corresponds to the maximum\n//    thickness of the blended region. This makes them more or\n//    less interchangeable and allows for easy bounding volume\n//    computation (in cyan).\n//\n// ** Mouse click - shows in dark the areas in the plane where\n//    the smin() has taken over the regular union/min() of the\n//    two source SDFs, a and b. This means that a ray marching\n//    through the dark orange regions will travel at a reduced\n//    speed compared to speed of a perfect SDF raymarcher (the\n//    \"Speed of Light\").\n//\n// ** The Circular Geometrical smin (bottom right) is the only\n//    locally supported smin(), which is great. But it is also\n//    the only smin() over-estimating distances, making it not\n//    the best candidate for vanilla raymarching and collision\n//    detection.\n\nfloat smin( float a, float b, float k, int type )\n{\n    // Quadratic\n    if( type==0 )\n    {\n        k *= 4.0;\n        float h = max(k-abs(a-b),0.0);\n        return min(a, b) - h*h*0.25/k;\n    }\n    // Cubic\n    if( type==1 )\n    {\n        k *= 6.0;\n        float h = max( k-abs(a-b), 0.0 )/k;\n        return min( a, b ) - h*h*h*k*(1.0/6.0);\n    }\n    // Quartic\n    if( type==2 )\n    {\n        k *= 16.0/3.0;\n        float h = max( k-abs(a-b), 0.0 )/k;\n        return min( a, b ) - h*h*h*(4.0-h)*k*(1.0/16.0);\n    }\n    // Circular\n    if( type==3 )\n    {\n        k *= 1.0/(1.0-sqrt(0.5));\n        float h = max( k-abs(a-b), 0.0 )/k;\n        return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n    }\n    // Exponential\n    if( type==4 )\n    {\n        return -k*log2( exp2( -a/k ) + exp2( -b/k ) );\n    }\n    // Sigmoid\n    if( type==5 )\n    {\n        k *= log(2.0);\n        float x = b-a;\n        return a + x/(1.0-exp2(x/k));\n    }\n    // SquareRoot\n    if( type==6 )\n    {\n        k *= 2.0;\n        float x = b-a;\n        return 0.5*( a+b-sqrt(x*x+k*k) );\n    }\n    // Circular Geometrical\n    if( type==7 )\n    {\n        k *= 1.0/(1.0-sqrt(0.5));\n        return max(k,min(a,b))-length(max(vec2(k-a,k-b), 0.0));\n    }\n}\n\n// primitives\nfloat sdBox(  in vec2 p, in vec2  b ) { vec2 q = abs(p)-b; return min(max(q.x,q.y),0.0) + length(max(q,0.0)); }\nfloat sdDisk( in vec2 p, in float r ) { return length(p)-r; }\n\n// return SDF, non-smooth SDF, and difference\nvec3 map( in vec2 p, float w, int type )\n{\n    float d1 = sdBox( p-vec2(0.4,0.3), vec2(0.1,0.3) );\n    float d2 = sdDisk(p-vec2(-0.3,-0.2+0.25*sin(iTime)), 0.25 );\n    \n    return vec3( smin(d1,d2,w,type), min(d1,d2), d1-d2 );\n}    \n\nfloat print( in float sdf, inout vec2 p, in int str[12])\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nbool isNotLowerBound( in vec2 p, float d, float blend_width, int tile )\n{\n    float ss = sign(d);\n    const int num = 512;\n    for( int i=0; i<num; i++ )\n    {\n        float an = 6.283185*float(i)/float(num);\n        vec2 cs = vec2(cos(an),sin(an));\n        if( map( p+cs*d*0.99, blend_width, tile ).x*ss<0.0 )\n        {\n            return true;\n        }\n    }\n    return false;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool interact = iMouse.z>0.001;\n    \n    // 4x2 tiling of space\n    vec2 res = vec2(iResolution.x/4.0,iResolution.y/2.0);\n    vec2 fpid = floor(fragCoord/res);\n    vec2 fmid = floor(iMouse.xy/res);\n    vec2 px = fragCoord - fpid*res;\n    vec2 mx = iMouse.xy - fmid*res;\n    int  tile = (1-int(fpid.y))*4 + int(fpid.x);\n\n    // blend thickness\n    float blend_width = 0.2;\n    \n    // normalized pixel coordinates\n    vec2 p = (2.0*px-res)/res.y;\n    vec2 m = (2.0*mx-res)/res.y;\n    \n    // distance\n    vec3 d = map( p, blend_width, tile );\n   \n    // coloring\n    vec3 col = (d.x>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.6,1.0,1.3);\n    if( interact && d.x < d.y ) col -= 0.1;\n    if( !interact && d.y < 0.0 ) col.y += 0.2;\n    if( interact && isNotLowerBound(p,d.x, blend_width, tile) ) \n    col = vec3(1.0,0.0,0.5);\n    col *= 1.0 - exp2(-10.0*abs(d.x));\n    col *= 0.75 + 0.25*smoothstep(-0.5,0.5,cos( ((d.x>0.0)?100.0:200.0)*d.x));\n    if( !interact )\n    col = mix( col, vec3(0.8), 1.0-smoothstep(0.002*res.y, 0.005*res.y, abs(d.y)/fwidth(d.y)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.002*res.y, 0.005*res.y, abs(d.x)/fwidth(d.x)) );\n\n    // interactivity\n    if( interact )\n    {\n        float md = map( m, blend_width, tile ).x;\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(md))-0.005));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // draw voronoi regions\n    if( false )\n    {\n        col = mix( col, vec3(1,1,0), 1.0-smoothstep( 0.008, 0.012, abs(d.z)) );\n    }\n\n    // draw bounding box expansion isoline\n    if( !interact )\n    {\n        float bd = d.y - blend_width;\n        col = mix(col, vec3(0.0,1.0,1.0), 1.0-smoothstep(0.005, 0.010,abs(bd)) );\n    }\n\n    // draw text\n    {\n        const float text_scale = 0.15;\n        vec2 q = (p-vec2(-0.85,-0.95))/text_scale;\n        float text = 1e20;\n             if( tile==0 ){text = print(text,q,int[](81,117, 97,100,114,97,116,105,99,0,0,0));}\n        else if( tile==1 ){text = print(text,q,int[](67,117, 98,105,99,0,0,0,0,0,0,0));}\n        else if( tile==2 ){text = print(text,q,int[](81,117, 97,114,116,105,99,0,0,0,0,0));}\n        else if( tile==3 ){text = print(text,q,int[](67,105,114,99,117,108,97,114,0,0,0,0));}\n        else if( tile==4 ){text = print(text,q,int[](69,120,112,111,110,101,110,116,105,97,108,0));}\n        else if( tile==5 ){text = print(text,q,int[](83,105,103,109,111,105,100,0,0,0,0,0));}\n        else if( tile==6 ){text = print(text,q,int[](83,113,117,97,114,101,32,114,111,111,116,0));}\n        else if( tile==7 ){text = print(text,q,int[](67,105,114,99,117,108,97,114,32,0,0,0));\n                           text = print(text,q,int[](71,101,111,109,101,116,114,105,99,97,108,0));}\n        col = mix(col,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        col = mix(col,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n    }\n \n    // draw grid\n    vec2 grid = smoothstep( 0.005, 0.010, abs(px)/res.y );\n    col *= min(grid.x,grid.y);\n\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}