{
    "Shader": {
        "info": {
            "date": "1593687435",
            "description": "variant of [url]https://shadertoy.com/view/tt2yRz[/url]\n\n(un)comment line  29 for const/adaptive disc size",
            "flags": 0,
            "hasliked": 0,
            "id": "wtSyzh",
            "likes": 12,
            "name": "Logarithmic Moebius Transform 12",
            "published": 3,
            "tags": [
                "zoom",
                "spiral",
                "mobius",
                "transform",
                "logarithm",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/tt2yRz\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, D,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n#if 1\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U))*vec2(.5, -.5) + iTime/8.\n        + a * vec2(6, 1); // n    \n#else\n    U.x +=.022; U *= vec2(1.5,1);                             // test in the plane\n    if(u.x/R.y>sqrt(3.)/2.) return;\n#endif\n  //D  = vec2(10,14.82)/1.43;// /(.5+iMouse.x/R.x);\n    D  = vec2(21./3., 2./sqrt(3.)*9.);                        // thanks Shane !\n    mat2 M = mat2(1,0,.5,sqrt(3.)/2.);\n    U = U*D * M;                                              // triangular mesh\n    float dx=0.,dy=0.,dax=dFdx(a),day=dFdy(a);                // manage jump trough poles arc\n    if (abs(dax) > .5) dx=-sign(dax);\n    if (abs(day) > .5) dy=-sign(day);\n    D = vec2(6,1)*D * M;\n    vec2 dFdx = dFdx(U)+D*dx, dFdy = dFdy(U)+D*dy;\n  //z = fwidth(U);\n    z = abs(dFdx)+abs(dFdy);\n    M = inverse(transpose(mat2(dFdx, dFdy)))*30./R.y;         // Jacobian to go back to screen\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.), v,                           // parallelogram = 2 triangles\n          i = mod( I.x + I.y , 3.), id; \n    I += i==0.? vec2(0) : i==1. ? vec2(1) : vec2(s,1.-s);  id = I.x +7.81*I.y;\n    vec4 V = vec4( 1.-2.*abs(U.x-U.y) , abs(U*2.-1.) , 0 );\n    v = V[i<2. ? 2-int(i+s)%2 : 0 ];\n    U = i==0. ? U : i==1. ? 1.-U : s==0.?vec2(U.x,U.y-1.):vec2(1.-U.x,-U.y);\n    U *= M;                                                  // undistort disc constante size\n    U *= 1.9 / length(vec4(M));                              // adaptive size\n // U *= inverse(mat2(1,0,.5,sqrt(3.)/2.));\n // O  = smoothstep(.7,-.7,(length(U)-.8)/( abs(z.x-z.y)>1.?.1:z.y*2.))\n    O  = smoothstep(.7,-.7,(length(U)-.8)/(z.y*2.))\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n    if (fract(iTime/6.)<.4) O += smoothstep(-.7,.7, (v-.95)/(z.y*4.));  // draw AA tiles\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}