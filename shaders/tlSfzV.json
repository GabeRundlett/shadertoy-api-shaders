{
    "Shader": {
        "info": {
            "date": "1599334098",
            "description": "Gardner's textured ellipsoids fake volumetric via procedural silhouettes [url]https://www.shadertoy.com/view/XsfXW8[/url]\nTop: This can be used for nice outlying (and pseudo antialiasing (left).  (pseudo since it still hides background).\nBottom: out glow.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlSfzV",
            "likes": 10,
            "name": "ray-tracing silhouette: AA, glow",
            "published": 3,
            "tags": [
                "raymarching",
                "antialiasing",
                "glow",
                "outline",
                "tuto",
                "silhouette"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;            // normalized centered coords\n    vec3  D = normalize( vec3( U, -1 ) ),    // ray direction\n          p = vec3(0,0,15),                  // ray origin\n          S = vec3(0),                       // sphere center\n          L = normalize(vec3(2,3,1)),        // light dir\n         SO = p-S, N;                        // sphere center to origin\n    \n    // solve ray(l) on sphere: || (O+l.D) - C ||² = r² -> degree 2 equation\n    float r = 9., b = dot(SO,D), c = dot(SO,SO) - r*r, d = b*b-c;\n    \n    O = mix(vec4(0,1,1,1),vec4(0,0,.1,1),sqrt(u.y/R.y));  // background\n    if (d>0.) {                              // --- if hit: \n        d = -b-sqrt(d);                      // distance to sphere\n        p += d * D;                          // hit point\n        N = ( p - S ) / r;                   // normal\n        d = max(0.,dot(N,L));                // diffuse amount\n        c = max(0.,dot(N,-D));               // facing amount ( 0 on silhouette )\n        vec4 C = vec4(1,0,0,0) * (.02 + d ); // ambiant + diffuse color\n        c = pow(1.-c,10.);                   // silhouette mask\n        U.x > 0. ? O = C + c                 // right: white silhouette\n                 : O = mix( C, O, c );       // left: antialiased silhouette\n    } else {                                 // --- no hit:  \n        d = -dot(SO,D); p += d * D; //closest point on ray: solve derivative(ray-sphere dist) = 0\n        d = length(p-S) - 9.;                // closest distance to sphere\n        if ( U.y < 0. )                      // bottom: show glow\n            O += U.x > 0. ? //smoothstep(1.,0.,d)   // bottom: glow\n                             pow(max(0.,1.-d),10.)  // like inner silhouette\n                          :  1./(d*d);              // variant          \n    }\n    O = pow(O, vec4(1./2.2) );               // to sRGB\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}