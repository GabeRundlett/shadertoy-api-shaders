{
    "Shader": {
        "info": {
            "date": "1578178574",
            "description": "First in my weekly shader series for 2020. Let's see where this takes us! ",
            "flags": 0,
            "hasliked": 0,
            "id": "wtK3Rz",
            "likes": 3,
            "name": "The Second After Midnight",
            "published": 3,
            "tags": [
                "time",
                "clock",
                "challenge",
                "weekly"
            ],
            "usePreview": 0,
            "username": "angelo12",
            "viewed": 462
        },
        "renderpass": [
            {
                "code": "/*\n    Sunday Shader: 1/52 \"The second after Midnight\"\n    New years resolution: make a shader every week & upload them on Sunday.\n    Yeah this one is pretty simple but you gotta start somewhere.\n    Suggestions, feedback & help is always welcome :D\n\n\tAngel Ortiz\n*/\n\n#define INV_GAMMA 0.454545\n#define AA 4\n#define M_PI 3.1415926535\n\n#define CLOCKFACE_ID 1.0f\n#define CLOCKFACE_RADIUS 0.35f\n\n#define BOX_ID 2.0f\n#define BOX_SIZE vec2(0.0025, 0.17)\n\n#define ONETOZERO(num) (num + 1.0f) / 2.0f\n#define DEBUGCOL vec3(1.0, 0.0,1.0)\n\n/*Game Plan:\n    Todo\n\n    In progress\n\n    Done\n    - [x] Draw clock face\n    - [x] Mark the 12 hours \n    - [x] Background\n    - [x] Clock hands\n    - [x] Moving the clock hands\n\n    Maybe next time\n    [ ] Draw Roman Numerals\n    [ ] Fireworks from behind the clock\n    [ ] Buildings w/ lights\n    [ ] Hand strikes twelve\n*/\n\nfloat\nsdCircle(vec2 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat\nsdBox(vec2 pos, vec2 sizes)\n{\n    return length(max(abs(pos) - sizes, vec2(0.0)));\n}\n\nfloat\nMap(vec2 uv) \n{\n    float res = -1.0;\n\n    vec2 trans = vec2(0.0, -0.12);\n    vec2 bigHand = uv - vec2(0.0, 0.12) - trans;\n    float a = M_PI* (-iTime / 60.0);\n    mat2 rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    bigHand = bigHand * (rot) + trans  ;\n\n    trans = vec2(0.0, -0.09);\n    vec2 littleHand = uv - vec2(0.0, 0.09) - trans;\n    a = M_PI* (-iTime / (60.0 * 60.0));\n    rot = mat2(cos(a), sin(a), -sin(a), cos(a));\n    littleHand = littleHand * (rot) + trans;\n\n    //If you're inside the sdf, return it's ID\n    res = (sdCircle(uv - vec2(0.0, 0.0), CLOCKFACE_RADIUS) <= 0.0) ? CLOCKFACE_ID : res;  \n    res = (sdBox(bigHand, BOX_SIZE) <= 0.0) ? BOX_ID : res;  \n    res = (sdBox(littleHand, vec2(0.0025, 0.12)) <= 0.0) ? BOX_ID : res;  \n    res = (sdCircle(uv - vec2(0.0, 0.0), 0.01) <= 0.0) ? 3.0f : res;  \n\n    return res;\n}\n\nvec3\nShading(vec2 uv, float id)\n{\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n\n    vec3 col;\n    //Default case\n    if (id  == -1.0f)\n    {\n        bool inRadius = r > 0.36 && r < 0.37;\n        bool inAngle = true;\n        bool inCircle = inRadius && inAngle;\n\n        if (inCircle)\n        {\n            col = vec3(0.831, 0.686, 0.216);\n        }\n        else \n        {\n            col = vec3(0.5)* (uv.y + 0.3);\n            col = pow(col, vec3(2.0));\n        }\n\n    }\n\n    if (id == BOX_ID)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n\n    if (id == CLOCKFACE_ID)\n    {\n        col = vec3(1.0, 0.95, 0.85);\n\n\n        //Tick markers\n        {\n            bool inRadius = r > 0.26 && r < 0.325;\n            if (cos(a * 12.0) > 0.97 && inRadius)\n            {\n                col = vec3(0.0);\n            }\n        }\n\n    }\n\n    return col;\n}\n\nvec3\nRender(vec2 uv)\n{\n    //Geometry\n    float id = Map(uv);\n\n    //Shading\n    vec3 col = Shading(uv,id);\n\n    return col;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPos)\n{\n    vec3 tot;\n\n    //Supersampling AA\n#if AA > 1\n    for(int i = 0; i < AA; ++i)\n    for(int j = 0; j < AA; ++j)\n    {\n        vec2 offset = vec2(i, j) / float(AA) - 0.5;\n        vec2 uv = ((fragPos + offset) - 0.5*iResolution.xy) / iResolution.y;\n#else\n        vec2 uv = ((fragPos) - 0.5*iResolution.xy) / iResolution.y;\n#endif\n\n        //Rendering\n        vec3 col = Render(uv);\n\n        //Gamma correction\n        col = pow(col, vec3(INV_GAMMA));\n        tot += col;\n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}