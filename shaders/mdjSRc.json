{
    "Shader": {
        "info": {
            "date": "1670688021",
            "description": "Project a 3d ray to octahedral map, useful when you need to do raymarching on the octahedral map",
            "flags": 0,
            "hasliked": 0,
            "id": "mdjSRc",
            "likes": 12,
            "name": "ProjectRayOnOctahedralMap",
            "published": 3,
            "tags": [
                "projection",
                "octahedron",
                "octahedral"
            ],
            "usePreview": 0,
            "username": "EvilRyu",
            "viewed": 303
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A simple visualizer\n// Project a ray from world space to octahedral map, useful when you need to do raymarching on the octahedral map\n// Update: added projecting a sphere to the octahedral map\n\nvec3 gRayStart;\nvec3 gRayEnd;\n\nvec3 gSpherePos;\nfloat gSphereRadius;\n\nvoid updateRayAndSphere()\n{\n    gRayStart = vec3(-5., -1., -1.) + cos(iTime);\n    gRayEnd = vec3(5., 1., 2.) + sin(iTime);\n    \n    gSpherePos = vec3(10., .2, 1.) + sin(iTime);\n    gSphereRadius = 2.;\n}\n\n// octahedral mapping: https://jcgt.org/published/0003/02/01/\nvec2 signNotZero(vec2 v)\n{\n    return vec2(v.x >= 0. ? 1. : -1., v.y >= 0. ? 1. : -1.);\n}\n\nvec2 encodeOct(vec3 v)\n{\n    v.xy /= dot(abs(v), vec3(1));\n    if(v.z <= 0.)\n    {\n       v.xy = (1. - abs(v.yx)) * signNotZero(v.xy);\n    }\n    return v.xy;\n}\n\nvec3 decodeOct(vec2 octUv) \n{\n    vec3 v = vec3(octUv, 1.0 - dot(abs(octUv), vec2(1)));\n    if (v.z < 0.) \n    {\n        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n    }\n    return normalize(v);\n}\n\n\nmat3 cam(vec3 ro, vec3 ta)\n{\n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    return mat3(r,u,f);\n}\n\nfloat deSegment(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat map(vec3 p)\n{\n    float d = deSegment(p, gRayStart, gRayEnd, 0.05);\n    d = min(d, length(p - gSpherePos) - gSphereRadius);\n    return d;\n}\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float t = 0.1;\n    float d = 1e10;\n    for(int i = 0; i < 128; ++i)\n    {\n        if(d < 0.001 || t > 100.)\n            break;\n            \n        d = map(ro + t * rd);\n        t += d;\n    }\n    \n    return t;\n}\n\n// the 3d scene\nvec3 renderLeftScreen(vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    \n    // xy: left bottom coord\n    // zw: right top coord\n    vec4 viewport;\n    //viewport.xy = vec2(0., iResolution.y/4.);\n    //viewport.zw = vec2(viewport.xy + iResolution.xy / 2.1);\n    viewport.xy = vec2(0., (iResolution.y - iResolution.x/2.1)/2.);\n    viewport.zw = vec2(viewport.xy + iResolution.xx / 2.1);\n    if(any(lessThan(fragCoord, viewport.xy)) || any(greaterThan(fragCoord, viewport.zw)))\n        return col;\n        \n    vec2 uv = (fragCoord - viewport.xy) / vec2(viewport.z - viewport.x, viewport.w - viewport.y);\n\n    vec2 p = uv * 2. - 1.;\n    p.x *= (viewport.z - viewport.x) / (viewport.w - viewport.y);\n    \n    float time = iTime * 2.;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0);\n    vec3 ta = vec3(cos(0.1*time + 7.0*mo.x), -5.*(mo.y*2. - 1.), sin(0.1*time + 7.0*mo.x) )*-3.;\n    vec3 rd = normalize(cam(ro, ta) * vec3(p.x, p.y, 2.3));\n    \n    col = texture(iChannel0, rd).rgb;\n    \n    float t = intersect(ro, rd);\n    \n    if(t < 100.)\n    {\n        col = vec3(1., 0., 0.);\n    }\n\n    return col;\n}\n\nfloat deSegment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n\treturn length(pa - ba * h);\n}\n\nvec3 addLine(vec3 acc, vec2 p, vec2 a, vec2 b, vec3 col)\n{\n    return mix(col, acc, smoothstep(0.01, 0.02, deSegment(p, a, b)));\n}\n\n\n// https://www.shadertoy.com/view/XtVcDh\nvec3 cuteSort(vec3 n)\n{\n   float a = min(min(n.x,n.y),n.z);\n   float b = max(max(n.x,n.y),n.z);\n   return vec3(a, n.x+n.y+n.z-a-b, b);\n}\n\n// 3d line projects to at most 4 segments\nvoid getRaySegments(vec3 rayOrg, vec3 rayEnd, out float rayT[5])\n{\n    vec3 rayDir = rayEnd - rayOrg;\n    float maxDist = length(rayDir);\n\n    rayDir /= maxDist;\n\n    rayT[0] = 0.;\n    rayT[4] = maxDist;\n\n    vec3 distToPlanes = rayOrg / -max(vec3(1e-5), rayDir);\n    distToPlanes = cuteSort(distToPlanes);\n\n    for(int i = 0; i < 3; ++i)\n    {\n        rayT[i + 1] = clamp(distToPlanes[i], 0., maxDist);\n    }\n}\n\n\n// the octahedral map\nvec3 renderRightScreen(vec2 fragCoord)\n{\n     vec3 col = vec3(0.);\n    \n    // xy: left bottom coord\n    // zw: right top coord\n    vec4 viewport;\n    viewport.xy = vec2(iResolution.x - iResolution.x / 2., (iResolution.y - iResolution.x/2.1)/2.);\n    viewport.zw = vec2(viewport.xy + iResolution.xx / 2.1);\n    if(any(lessThan(fragCoord, viewport.xy)) || any(greaterThan(fragCoord, viewport.zw)))\n        return col;\n        \n    vec2 uv = (fragCoord - viewport.xy) / vec2(viewport.z - viewport.x, viewport.w - viewport.y);\n\n    vec2 p = uv * 2. - 1.;\n    \n    vec3 v = decodeOct(p);\n    \n    col = texture(iChannel0, v).rgb;\n\n    // draw the boundaries of different faces\n    col = addLine(col, p, vec2(-1.,0.), vec2(1., 0.), vec3(1., .8, 0.));\n    col = addLine(col, p, vec2(0.,-1.), vec2(0., 1.), vec3(1., .8, 0.));\n    col = addLine(col, vec2(abs(p.x)-1.,1.-abs(p.y)), vec2(-1.,0.), vec2(0., 1.), vec3(1., .8, 0.));\n    \n    // project ray in world space to octahedral map\n    float rayT[5];\n    getRaySegments(gRayStart, gRayEnd, rayT);\n    \n    vec3 rayDir = normalize(gRayEnd - gRayStart);\n    \n    vec3 rayStart = gRayStart, rayEnd;\n    vec2 rayStartUv = encodeOct(normalize(gRayStart)), rayEndUv;\n    \n    for(int i = 1; i < 5; ++i)\n    {\n        rayEnd = gRayStart + rayT[i] * rayDir;\n        rayEndUv = encodeOct(normalize(rayEnd));\n    \n        col = addLine(col, p, rayStartUv, rayEndUv, vec3(1., 0., 0.));\n        \n        rayStart = rayEnd;\n        rayStartUv = rayEndUv;\n    }\n    \n    // draw the projected sphere\n    float sphereDist = length(gSpherePos);\n    if(dot(normalize(gSpherePos), v) > (sphereDist / sqrt(gSphereRadius * gSphereRadius + sphereDist * sphereDist)))\n        col = mix(col, vec3(1., 0., 1.), 1.);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    updateRayAndSphere();\n    \n    vec3 col = renderLeftScreen(fragCoord);\n    col += renderRightScreen(fragCoord);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}