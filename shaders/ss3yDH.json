{
    "Shader": {
        "info": {
            "date": "1653383178",
            "description": "Wanted to learn how to do a ray sphere intersectioin. This could be handy in realtime applications for raymarching because you know the total distance that is traveled trough the spher (x1 + x2)\n\nYou can stop the movement with the SphereMove define",
            "flags": 0,
            "hasliked": 0,
            "id": "ss3yDH",
            "likes": 2,
            "name": "2D Ray-Sphere Intersections",
            "published": 3,
            "tags": [
                "2d",
                "sphere",
                "intersections"
            ],
            "usePreview": 0,
            "username": "djancool",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "#define SphereMove 1\n\n// https://www.shadertoy.com/view/tsj3Rd\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    // Find vectors pa and ba:\n    vec2 pa = p-a, ba = b-a;\n    // Compute the dot product of vectors and divide to get the ratio\n    // Clamp the ratio between 0.0 and 1.0\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    // Return the distance from the given point to the nearest point on line ab\n    return length(pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 mousePosOld = abs(iMouse.zw) / iResolution.y;\n    vec2 mousePosCur = iMouse.xy / iResolution.y;\n    \n    vec2 ro = mousePosOld;\n    vec2 rd = normalize(mousePosCur - mousePosOld);\n\n\n    float gradient = sin(uv.x * 1.57) * sin(uv.y * 3.14);\n    gradient = pow(gradient, 0.1);\n    vec3 outputCol = vec3(0.2, 0.2, 0.2) * gradient;\n    \n    // Ray colors\n    vec3 C_ROtX1 = vec3(1);\n    vec3 C_Sphere = vec3(0.1, 0.9, 0.1);  // Sphere color\n    vec3 C_ROtSO = vec3(0.9, 0.1, 0.1);   // Ray origin to sphere centre\n    vec3 C_SOtT = vec3(0.1, 0.1, 0.9);    // Sphere centre to closest point on ray\n    vec3 C_X1tT = vec3(0.5, 0.1, 1.0);    // First part of ray inside of sphere\n    vec3 C_TtX2 = vec3(1.0, 0.1, 0.5);    // Second part of ray inside of sphere\n    vec3 C_SOtX1 = vec3(0.3, 0.3, 0.3);   // Ray hit to sphere centre\n\n\n\n    // Ray Direction\n    float line = sdLine(uv, mousePosOld, mousePosOld + rd * 2.0);\n    //if(line < 0.007) outputCol = vec3(0.9, 0.9, 0.9);\n\n\n    //// Sphere ////\n    #if SphereMove\n    vec2 spherePos = vec2(0.8885, 0.5) + vec2(sin(iTime), cos(iTime)) * 0.1;\n    #else\n    vec2 spherePos = vec2(0.8885, 0.5);\n    #endif\n    float sphereRad = 0.3;\n    float sphereSDF = length(uv - spherePos) - sphereRad;\n    if(sphereSDF < 0.0 && sphereSDF > -0.01) outputCol = C_Sphere;\n    \n    \n    //----RO to Sphere Origin\n    float lineROtS = sdLine(uv, mousePosOld, mousePosOld + (spherePos - mousePosOld));\n    if(lineROtS < 0.003) outputCol = C_ROtSO;\n    \n    \n    //// Closest point from sphereOrigin to RD line ////\n    // t is the distance along RD where the closest point is\n    float t = dot(spherePos - mousePosOld, rd);\n    // position of t along RD\n    vec2 tpos = mousePosOld + rd * t;\n    // distance from centre of sphere to closest point of RD / tpos // Blue line\n    float tdis = distance(tpos, spherePos);\n    // render line from sphere origin to tpos // Blue line\n    float lineT = sdLine(uv, tpos, tpos + (spherePos - tpos));\n    // Check if the ray is insie the spher\n    if(sphereRad > tdis) // inside\n    {\n        if(lineT < 0.003) outputCol = C_SOtT;\n    }\n    else                 // outside\n    {\n        if(line < 0.003) outputCol = C_ROtX1;\n    }\n    \n    // hit points of sphere\n    // calculate tpos to sphere hit distance based on triangle\n    float x1 = sqrt( sphereRad*sphereRad - tdis*tdis);\n    float tx1 = t - x1;\n    float tx2 = t + x1;\n    vec2 tx1Pos = mousePosOld + rd * tx1;\n    vec2 tx2Pos = mousePosOld + rd * tx2;\n    \n    \n    // Visual line of the triangle exaction\n    float lineTris = sdLine(uv, spherePos, tx1Pos);\n    if(lineTris < 0.003) outputCol = C_SOtX1;\n    \n    \n    // Line from RO to x1\n    float lineX1 = sdLine(uv, mousePosOld, tx1Pos);\n    if(lineX1 < 0.004) outputCol = C_ROtX1;\n\n    \n    // Line from x1 to tpos\n    float lineX1tTPOS = sdLine(uv, mousePosOld + rd * t, tx1Pos);\n    if(lineX1tTPOS < 0.004) outputCol = C_X1tT;\n    \n    // Line from tpos to x2\n    float lineTPOStX2 = sdLine(uv, mousePosOld + rd * t, tx2Pos);\n    if(lineTPOStX2 < 0.004) outputCol = C_TtX2;\n    \n    // Line conitues from x2\n    float lineX2rd = sdLine(uv, mousePosOld + rd * tx2, tx1Pos + rd * 2.0);\n    if(lineX2rd < 0.004) outputCol = C_ROtX1;\n\n\n\n    // Output to screen\n    fragColor = vec4(outputCol, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}