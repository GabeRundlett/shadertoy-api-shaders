{
    "Shader": {
        "info": {
            "date": "1584189342",
            "description": "A simple path tracer",
            "flags": 32,
            "hasliked": 0,
            "id": "3dlcR8",
            "likes": 2,
            "name": "Bela's Path Tracer",
            "published": 3,
            "tags": [
                "raymarching",
                "ray",
                "marching",
                "raymarcher",
                "raymarcher",
                "tracing",
                "montecarlo",
                "tracer",
                "marcher",
                "path",
                "raymarcing",
                "patchtracer"
            ],
            "usePreview": 0,
            "username": "bela333",
            "viewed": 319
        },
        "renderpass": [
            {
                "code": "//Text rendering: https://www.shadertoy.com/view/4sBfRd\n#define C(c) U.x+=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 color = texture(iChannel0, uv);\n    float previous_frame = -texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    color = pow(color, vec4(1./3.))-0.5;\n    //color = color;\n    fragColor = clamp(color, 0.0, 1.0);\n    vec4 O = vec4(0.0);\n    vec2 U = ( uv - vec2(.985, 0.))*64.0/4.;\n    int f = abs(iFrame-int(previous_frame));\n    while(f > 0){\n        int v = f%10+48;\n    \tC(v);\n        f /= 10;\n    }\n    C(32);C(58);C(115);C(101);C(108);C(112);C(109);C(97);C(83);\n    fragColor -= O.xxxx;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (float st){\n\treturn random(vec2(st, st*1749.));\n}\n\nfloat random (vec4 st) {\n    float a = dot(st.xy, vec2(62.007, 95.311));\n    float b = dot(st.zw, vec2(13.611, 1.335));\n    return random(vec2(a, b));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Fork of \"Bela's Ray Marcher\" by bela333. https://shadertoy.com/view/3dlGDX\n// 2020-03-13 21:43:36\n\n//TODO: Refine\n#define PI 3.14159265359\n#define MAX_STEPS 255.0\n#define MAX_DISTANCE 100.0\n#define EPSYLON 0.0002\n#define SKY_COLOR vec4(135., 206., 235., 255.)/255.\n\n\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){ \n\treturn length(p-center)-radius;\n}\n\nfloat planeSDF(vec3 p, float yPos){\n\treturn abs(p.y-yPos)-EPSYLON*4.;\n}\n\nfloat cube2SDF(vec3 p, float size){\n\treturn length(max(min(p, size),-size)-p);\n}\n\nfloat cubeSDF(vec3 p, vec3 center, float size){\n\treturn cube2SDF(p-center, size);\n}\n\n//Modified version of iq's box SDF\nfloat backdropSDF( vec2 p, float b )\n{\n  return -(length(max(p,0.0)) + min(max(p.x,p.y),0.0));\n}\n\nvec3 random_point_on_sphere(vec4 seed){\n\tfloat u = random(seed) * 2. * PI;\n    float v = acos(2.*random(seed*2.) - 1.);\n    \n    return vec3(\n    \tcos(u)*sin(v),\n    \tsin(u)*sin(v),\n        cos(v)\n    );\n}\n\nvec3 random_point_on_hemisphere(vec3 n, vec4 seed){\n\tvec3 p = random_point_on_sphere(seed);\n    return dot(n, p) > 0. ? p : -p;\n}\n\nvoid get_closer(float dist, int target_mat, inout float o, inout int material){\n    if(dist < o){\n        material = target_mat;\n    }\n    o = min(o, dist);\n}\n\nfloat getSDF(vec3 p, inout int material){\n    const float drop_radius = 0.5;\n    float backdrop = backdropSDF(-p.zy+vec2(-.5, drop_radius-.5), 1.0)+drop_radius;\n    float cube = cubeSDF(p, vec3(0., 0., 0.), 0.5);\n    float lamp = sphereSDF(p, vec3(1.0, 2., 1.), .5);\n    lamp = min(lamp, sphereSDF(p, vec3(-1.0, 2., 1.), .5));\n    float sphere = sphereSDF(p, vec3(0.0, 1.0, 0.0), .5);\n    \n    float o = backdrop;\n    material = 3;\n    get_closer(lamp, 2, o, material);\n    get_closer(cube, 4, o, material);\n    get_closer(sphere, 5, o, material);\n\treturn o;\n}\n\nvec3 get_color(int material, vec3 normal, out vec3 emit, inout vec3 dir, vec4 seed, vec3 wi){\n    switch(material){\n        //Lamp\n        case 2:\n        \tdir = vec3(0.0);\n        \tconst float blueness = 1.125;\n        \temit = vec3(.878, .941, blueness)*100./blueness;\n        \treturn vec3(0.);\n        //Backdrop\n        case 3:\n        \tdir = random_point_on_hemisphere(normal, seed);\n        \temit = vec3(0.);\n        \treturn vec3(.769, .949, .306);\n        //Box\n        case 4:\n        \tdir = random_point_on_hemisphere(normal, seed);\n        \temit = vec3(0.);\n        \treturn vec3(1.0);\n        case 5:\n        \tdir = -reflect(wi, normal);\n        \temit = vec3(0.);\n        \treturn vec3(1.0);\n    }\n}\n\n\nvec3 approximateNormal(vec3 p){\n\t//float defaultDist = getSDF(p);\n    vec2 sub = vec2(0, EPSYLON);\n    int m = -1;\n\tvec3 normal = vec3(\n    \tgetSDF(p+sub.yxx, m) - getSDF(p-sub.yxx, m),\n        getSDF(p+sub.xyx, m) - getSDF(p-sub.xyx, m),\n        getSDF(p+sub.xxy, m) - getSDF(p-sub.xxy, m)\n    );\n    return normalize(normal);\n}\n\nbool castRay(inout vec3 from, vec3 dir, inout int material){ \n\tfloat allDistance = 0.;\n    float i = 0.;\n    float dist;\n    for(i = 0.; i < MAX_STEPS; i++){ \n        vec3 p = from + dir*allDistance;\n    \tdist = getSDF(p, material);\n        //float localAngle = atan(allDistance, dist);\n        allDistance += dist;\n        if(allDistance > MAX_DISTANCE || dist < EPSYLON) break;\n    }\n    from = from + dir*allDistance;\n    if(dist > EPSYLON){\n    \treturn false;\n    }\n    return true;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n\n\nvec3 sample_(inout vec3 from, inout vec3 dir, vec4 seed, inout vec3 emit){\n    vec3 wi = -dir;\n    int material = -1;\n\tbool result = castRay(from, dir, material);\n    vec3 normal = approximateNormal(from);\n    \n    if(!result){\n    \temit=vec3(0.)*1.0;\n        return vec3(0.0);\n    }\n    vec3 color = get_color(material, normal, emit, dir, seed, wi);\n    from += dir * EPSYLON*5.;\n    return color * dot(dir, normal);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 0.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    //iMouse.zw\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.)-.1;\n    float updown = mouse.y*PI*.25;\n    vec2 plane = vec2(cos(mouse.x*PI), sin(mouse.x*PI))*cos(updown);\n    vec3 movement = vec3(plane.x, sin(updown), plane.y)*2.;\n    cameraPos += movement;\n    //cameraPos *= 2.5;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 seed = vec3(uv, iTime);\n    vec2 aafc = fragCoord + vec2(random(vec4(seed, 0.0)), random(vec4(seed, 179.0)))-.5;\n    //vec2 aafc = fragCoord;\n    vec2 aauv = aafc/iResolution.xy;\n    \n\t\n    vec2 screenPos = aauv*2.0-1.0;\n    \n    \n    vec2 convScreenPos = screenPos;\n    convScreenPos.x *= iResolution.x/iResolution.y;\n    \n    vec3 gridPoint = vec3(convScreenPos, .875);\n    gridPoint = normalize(gridPoint);\n    gridPoint = calcLookAtMatrix(cameraPos, target, 0.0)*gridPoint;\n    //gridPoint += cameraPos;\n    vec3 color = vec3(1.0);\n    vec3 emit = vec3(0.0);\n    for(float i = 0.; i < 4.; i++){\n        vec3 emit_color = vec3(0.0);\n    \tvec3 sample_color = sample_(cameraPos, gridPoint, vec4(seed, i), emit_color);\n        emit += color * emit_color;\n        color *= sample_color;\n        if(length(gridPoint) == 0.){break;}\n    }\n    emit = max(emit, 0.0);\n    vec4 previous = texture(iChannel0, uv);\n    float previous_frame = -texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    \n    if(iFrame==0){\n    \tprevious_frame = 0.;\n    }\n    \n    if(iMouse.w > 0.5){\n    \tprevious_frame = float(iFrame);\n    }\n    \n    if(fragCoord.x <= 2. && fragCoord.y <= 2.){\n    \tfragColor = vec4(-previous_frame, 0., 0., 1.);\n        return;\n    }else if(iMouse.w > 0.5){\n    \tfragColor = vec4(emit, 1.0);\n        return;\n    }\n    \n    fragColor = (previous*(float(iFrame)-previous_frame)+vec4(emit, 1.0))/(float(iFrame)-previous_frame+1.);\n    //fragColor = -(previous+vec4(emit, 1.0));\n    //fragColor = vec4(emit, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}