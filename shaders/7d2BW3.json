{
    "Shader": {
        "info": {
            "date": "1647347401",
            "description": "A fast Voronoi function. I don't know if something like this already exists but I needed it for a project and though I might as well share it. I am sure it can be optimised further.",
            "flags": 0,
            "hasliked": 0,
            "id": "7d2BW3",
            "likes": 0,
            "name": "Fast Voronoi/Cell Noise",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "fast"
            ],
            "usePreview": 0,
            "username": "Dragonpeak",
            "viewed": 262
        },
        "renderpass": [
            {
                "code": "//A fast Voronoi function. \n//I don't know if something like this already exists but I needed it for a project and though I might as well share it.\n//I am sure it can be optimised further.\n\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec2 rand2(vec2 v)\n{\n    //random vec2 from 0 to 1 on each component. uses pcg2d, above for hashing.\n    //multiplies the input vec2 by a large value and then converts it to a uvec2 for the hash function\n    //divides the hash output by the max int to get it into the 0-1 range\n    return vec2(pcg2d(uvec2(v*87198.5193)))/float(0xffffffffu);\n}\n\nvec2 get_point_in_cell(vec2 cell, float offset)\n{\n    //gets a random point in the input cell, offset can be incremented to generate multiple different points in the cell\n    //the point is generated within a 0-1 square which is then offset by the cell\n    return rand2(cell+offset*165.426812)+cell;\n}\n\nfloat get_min_dist_in_cell(vec2 uv, vec2 cell, int amt)\n{\n    // gets the distance to the closest point in the cell from the input point\n    // amt controls the number of points in the cell which are then generated using the above function\n    float dist = 999999.;\n    for(int i = 0; i < amt; i++)\n    {\n        \n        dist = min(dist, distance(uv, get_point_in_cell(cell, float(i))));\n    }\n    return dist;\n}\n\nfloat fast_voro(vec2 uv, int points_per_cell)\n{\n    //fast voronoi or worley like noise function \n    //checks the cell of the input point and all adjacent cells to find the smallest distance to a point \n    //using more points per cell can improve the variance of the noise but will also slow the generation as it has to check points_per_cell*9 points\n    // at 1 ppc only 9 distance calculations are needed while at 10 ppc 90 calculations are required, for example\n    float dist = 9999.;\n    vec2 current_cell = floor(uv);\n    \n    for(int x = -1; x <= 1; x++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            dist = min(dist, get_min_dist_in_cell(uv, current_cell+vec2(x,y), points_per_cell));\n        }\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv*=10.;\n\n    float dist = fast_voro(uv, 1);\n\n    // Output to screen\n    fragColor = vec4(vec3(dist),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}