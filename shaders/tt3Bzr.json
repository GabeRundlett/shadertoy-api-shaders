{
    "Shader": {
        "info": {
            "date": "1612091609",
            "description": "I found iq's polyAbs() here.\nhttps://www.shadertoy.com/view/3sVBRG\nI turned it into a boolean function and did some testing and found it useful, so I wanted to share it.\nI think it will be especially useful when modeling organic shapes.\nmouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "tt3Bzr",
            "likes": 7,
            "name": "UnionPoly",
            "published": 3,
            "tags": [
                "boolean"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 428
        },
        "renderpass": [
            {
                "code": "const float MIN_DIST = .001;\nconst float MAX_DIST = 100.;\nconst int ITR = 100;\nconst float INV_ITR = (1./float(ITR));\n\n// I found iq's polyAbs() at:\n// https://www.shadertoy.com/view/3sVBRG\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat opUnionPoly(float a, float b, float m, float n){\n    float x = abs(a-b);\n    // iq's polyAbs:\n    if( x<m ){\n        float xa = 2.0*n - m;\n        float xb = 2.0*m - 3.0*n;\n        float t = x/m;\n        x = (xa*t + xb)*t*t + n;\n    }\n\treturn (a+b-x)*.5;\n}\n\nfloat sdSphere(vec3 p)\n{\n    return length(p)-2.;\n}\n\nfloat sdCapsule(vec3 p, float r, float c)\n{\n    return mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\n\nfloat map(in vec3 p)\n{\n    R(p.xz,iTime*.3);\n\tfloat d = sdSphere(p);\n    p.x = abs(p.x);\n    p.x-=2.;\n    R(p.xy,PI*.5);\n    \n    float m = s2u(sin(iTime*.8))*2.+.25;\n    float n = s2u(cos(iTime))*2.;\n    if(iMouse.z>0.){\n        m = iMouse.x/iResolution.x*2.;\n        n = iMouse.y/iResolution.y*2.;\n    }\n\n    d = opUnionPoly(d, sdCapsule(p, .6, 2.), m, n);\n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec3 e = vec3(0, 1,-1)*MIN_DIST;\n    return normalize(vec3(map(p+e.yxx)-map(p+e.zxx),map(p+e.xyx)-map(p+e.xzx),map(p+e.xxy)-map(p+e.xxz)));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = 0.;\n    for(int i=0; i<ITR; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p)*.5;\n        if(d<=MIN_DIST) break;\n        t += d;\n        if(t < MIN_DIST) break;\n        if(t >= MAX_DIST) return MAX_DIST;\n    }\n    return t;\n}\n\nvec3 render(in vec2 fragCoord){\n      vec2 uv = fragCoord/iResolution.xy;\n      uv = uv*2.-1.;\n      uv.y *= iResolution.y/iResolution.x;      \n\n      vec3 ro = vec3(0,3,-12);\n      vec3 rd = normalize(vec3(uv-vec2(0,.55), 2));\n      float d = march(ro, rd);\n      \n      vec3 col = vec3(0);\n      \n      if(d<MAX_DIST){\n          vec3 p = ro + rd * d;\n          vec3 n = normal(p);\n          dbg_3V( n*.5+.5 );\n          \n          float l = max(0., dot(n,vec3(.5,1,-.5)));\n          col = vec3(.8)*l;\n      }\n      col = pow(col, vec3(.45));\n      return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = render(fragCoord);\n    fragColor = vec4(col,1.0);\n    drawDebug(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.\n#define ZERO min(0,iFrame)\n#define PI 3.14159265\n#define HALF_PI 1.5707963267948966\n#define PI2 (2.0*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define sat(x) clamp(x, 0.0, 1.0)\n\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n// . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\nvec4 dbC=vec4(0);\nvoid dbg_1F(float v){dbC=vec4(v,v,v,1);}\nvoid dbg_2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid dbg_3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(dbC,vec4(.4545));}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}