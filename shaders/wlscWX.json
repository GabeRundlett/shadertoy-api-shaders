{
    "Shader": {
        "info": {
            "date": "1593433426",
            "description": "An offset grid of square-based pyramids whose tips have been offset according to an underlying directional noise field. The faux lighting is provided via bump mapping. No raymarching was harmed during the making of this example. :)",
            "flags": 0,
            "hasliked": 0,
            "id": "wlscWX",
            "likes": 56,
            "name": "Pyramid Pattern",
            "published": 3,
            "tags": [
                "square",
                "bump",
                "pattern",
                "pyramid"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 1542
        },
        "renderpass": [
            {
                "code": "/*\n\n\tPyramid Pattern\n\t---------------\n\t\n    An animated pyramid pattern, which is based on old code that I \n    quickly repurposed after looking at Oggbog's \"Flipping triangles\" \n    example.\n\n\tI've departed from the original considerably, but it's essentially \n    the same thing. The pyramid centers have been offset in correlation \n    with a directional gradient that indexes an underlying noise \n    function. I've applied some exaggerated bumped highlighting to give \n    the pattern a sharp abstract scaly appearance.\n\n    The cells are arranged in a square grid with each alternate row \n    offset by half a cell to give a more distributed feel. In fact, I \n    almost coded a hexagonal version, but figured this had more of an \n    angular feel.\n\n\tI've commented the code, but there's nothing in here that's\n\tparticularly taxing on the brain. If I had it my way, I'd code \n    simple little geometric patterns all day, since it's kind of \n    therapeutic, but I've got some so-called hard stuff to get back\n\tto... Well, it's hard for me anyway. :)\n     \n\n\n\t// Here's a much simpler version.\n    Offset Pyramid Squares - Shane\n\thttps://www.shadertoy.com/view/tlXcDs\n\n    // Great motion: I sometimes go overboard with bells and \n    // whistles, whereas this is elegantly simple.\n\tPyramid torsion - AntoineC\n    https://www.shadertoy.com/view/lsVczK\n\n\t// Inspired by:\n    Flipping triangles - Oggbog\n\thttps://www.shadertoy.com/view/ttsyD2\n\n\n*/\n\n// Offsetting alternate rows -- I feel it distributes the effect more,\n// but if you prefer more order, comment out the following:\n#define OFFSET_ROW\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    //return sin( p*6.2831853 + iTime ); \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    // Cell ID and local coordinates.\n    vec2 i = floor(p); p -= i;\n    \n    // Four corner samples.\n    vec4 v;\n    v.x = dot(hash22B(i), p);\n    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22B(i + 1.), p - 1.);\n\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n    \n    // Bilinear interpolation -- Along X, along Y, then mix.\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n// Two layers of noise.\nfloat fBm(vec2 p){ return n2D3G(p)*.66 + n2D3G(p*2.)*.34; }\n\n\nfloat bMap(vec2 p){\n    \n    // Put the grid on an angle to interact with the light a little better.\n    p *= rot2(-3.14159/5.);\n   \n    #ifdef OFFSET_ROW\n    // Tacky way to construct an offset square grid.\n    if(mod(floor(p.y), 2.)<.5) p.x += .5;\n    #endif\n\n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Recording the cell ID.\n    cellID = ip;\n\n    // Transcendental angle function... Made up on the spot.\n    //float ang = dot(sin(ip/4. - cos(ip.yx/2. + iTime))*6.2831, vec2(.5));\n    \n    // Noise function. I've rotated the point around a bit so that the \n    // objects hang down due to gravity at the zero mark.\n    float ang = -3.14159*3./5. + (fBm(ip/8. + iTime/3.))*6.2831*2.;\n    // Offset point within the cell. You could increase this to cell edges\n    // (.5), but it starts to look a little weird at that point.\n    vec2 offs = vec2(cos(ang), sin(ang))*.35;\n     \n    // Linear pyramid shading, according to the offset point. Basically, you\n    // want a value of zero at the edges and a linear increase to one at the \n    // offset point peak. As you can see, I've just hacked in something quick \n    // that works, but there'd be more elegant ways to achieve the same.\n    if(p.x<offs.x)  p.x = 1. - (p.x + .5)/abs(offs.x  + .5);\n    else p.x = (p.x - offs.x)/(.5 - offs.x);\n\n    if(p.y<offs.y) p.y = 1. - (p.y + .5)/abs(offs.y + .5);\n    else p.y = (p.y - offs.y)/(.5 - offs.y);\n\n    // Return the offset pyramid distance field. Range: [0, 1].\n    return 1. - max(p.x, p.y);\n}\n\n\n// Standard function-based bump mapping function, with an edge value \n// included for good measure.\nvec3 doBumpMap(in vec2 p, in vec3 n, float bumpfactor, inout float edge){\n    \n    // Sample difference. Usually, you'd have different ones for the gradient\n    // and the edges, but we're finding a happy medium to save cycles.\n    vec2 e = vec2(.025, 0);\n    \n    float f = bMap(p); // Bump function sample.\n    float fx = bMap(p - e.xy); // Same for the nearby sample in the X-direction.\n    float fy = bMap(p - e.yx); // Same for the nearby sample in the Y-direction.\n    float fx2 = bMap(p + e.xy); // Same for the nearby sample in the X-direction.\n    float fy2 = bMap(p + e.yx); // Same for the nearby sample in the Y-direction.\n    \n    vec3 grad = (vec3(fx - fx2, fy - fx2, 0))/e.x/2.;   \n    \n    // Edge value: There's probably all kinds of ways to do it, but this will do.\n    edge = length(vec2(fx, fy) + vec2(fx2, fy2) - f*2.);\n    //edge = (fx + fy + fx2 + fy2 - f*4.);\n    //edge = abs(fx + fx2 - f*2.) + abs(fy + fy2 - f*2.);\n    //edge /= e.x;\n    edge = smoothstep(0., 1., edge/e.x);\n     \n    // Applying the bump function gradient to the surface normal.\n    grad -= n*dot(n, grad);          \n    \n    // Return the normalized bumped normal.\n    return normalize( n + grad*bumpfactor );\n\t\n}\n\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Resolution and aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Unit direction vector. Used for some mock lighting.\n    vec3 rd = normalize(vec3(uv, .5));\n    \n    // Scaling and tranlation.\n    const float gSc = 10.;\n    vec2 p = uv*gSc + vec2(0, iTime/2.);\n    vec2 oP = p; // Saving a copy for later.\n    \n    \n    // Take a function sample.\n    float m = bMap(p);\n    \n    vec2 svID = cellID;\n  \n    // Face normal for and XY plane sticking out of the screen.\n    vec3 n = vec3(0, 0, -1);\n    \n    // Bump mapping the normal and obtaining an edge value.\n    float edge = 0., bumpFactor = .25;\n    n = doBumpMap(p, n, bumpFactor, edge);\n   \n    // Light postion, sitting back from the plane and animated slightly.\n\tvec3 lp =  vec3(-0. + sin(iTime)*.3, .0 + cos(iTime*1.3)*.3, -1) - vec3(uv, 0);\n    \n    // Liight distance and normalizing.\n    float lDist = max(length(lp), .001);\n    vec3 ld = lp/lDist;\n    // Unidirectional lighting -- Sometimes, it looks nicer.\n    //vec3 ld = normalize(vec3(-.3 + sin(iTime)*.3, .5 + cos(iTime*1.3)*.2, -1));\n\t\n\t// Diffuse, specular and Fresnel.\n\tfloat diff = max(dot(n, ld), 0.);\n    diff = pow(diff, 4.);\n    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 16.);\n\t// Fresnel term. Good for giving a surface a bit of a reflective glow.\n    float fre = min(pow(max(1. + dot(n, rd), 0.), 4.), 3.);\n    \n\n    // Applying the lighting.\n    vec3 col = vec3(.15)*(diff + .251 + spec*vec3(1, .7, .3)*9. + fre*vec3(.1, .3, 1)*12.);\n    \n    \n    // Some dodgy fake reflections. This was made up on the fly. It's no sustitute for reflecting\n    // into a proper back scene, but it's only here to add some subtle red colors.\n    float rf = smoothstep(0., .35, bMap(reflect(rd, n).xy*2.)*fBm(reflect(rd, n).xy*3.) + .1);\n    col += col*col*rf*rf*vec3(1, .1, .1)*15.;\n    \n    /*\n    // Random blinking lights. Needs work. :)\n    float rnd = hash21(svID);\n    float rnd2 = hash21(svID + .7);\n    rnd = sin(rnd*6.2831 + iTime*1.);\n    col *= mix(vec3(1), (.5 + .4*cos(6.2831*rnd2 + vec3(0, 1, 2)))*6., smoothstep(.96, .99, rnd));\n    */\n    \n     // Using the distance function value for some faux shading.\n    float shade = m*.83 + .17;\n    col *= shade;\n    \n    // Apply the edging from the bump function. In some situations, this can add an\n    // extra touch of dimension. It's so easy to apply that I'm not sure why people \n    // don't use it more. Bump mapped edging works in 3D as well.\n    col *= 1. - edge*.8;\n    \n    // Apply a cheap but effective hatch function.\n    float hatch = doHatch(oP/gSc, iRes);\n    col *= hatch*.5 + .7;\n    \n    // Just the distance function.\n    //col = vec3(m);\n\n/*\n    // Adding in a couple of fake spot lights.\n    // Interesting... but not for this example. :)\n    float x = iResolution.x/iResolution.y/2.;\n    vec2 uv2 = uv - vec2(-x, .5);\n    uv2 *= rot2(cos(iTime)*.5 - .5);\n    float light = abs(uv2.x) - .25*(-uv2.y*1.5);\n    float atten = 1. - 1./(1. + pow(max(uv2.y*.5 + .5, 0.), 2.)*16.);\n    col = mix(col, col*vec3(1, .3, .1)*8., (1. - smoothstep(0., .05, light))*atten);\n \n    uv2 = uv - vec2(x, .5); \n    uv2 *= rot2(sin(-iTime)*.5 + .5);\n    light = abs(uv2.x) - .25*(-uv2.y*1.5);\n    atten = 1. - 1./(1. + pow(max(uv2.y*.5 + .5, 0.), 2.)*16.);\n    col = mix(col, col*vec3(.1, .4, 1)*8., (1. - smoothstep(0., .05, light))*atten);\n*/  \n  \n    // Subtle vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    // Colored variation.\n    //col = mix(col*vec3(.25, .5, 1)/8., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n    \n\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}