{
    "Shader": {
        "info": {
            "date": "1587658223",
            "description": "Simple-ish volume raymeracher. Use the mouse to move the camera around.\n\nSet PERFORMANCE_MODE 1 if you want to run this on slower hardware (laptop or phone)",
            "flags": 0,
            "hasliked": 0,
            "id": "tsScDG",
            "likes": 158,
            "name": "Volumetric Raymarching Sample",
            "published": 3,
            "tags": [
                "volume"
            ],
            "usePreview": 1,
            "username": "suyoku",
            "viewed": 9981
        },
        "renderpass": [
            {
                "code": "// Created by Christopher Wallis\n#define PI 3.14\n\n#define NUM_LIGHTS 3\n#define NUM_LIGHT_COLORS 3\n\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LIGHT_BASE_MATERIAL_ID 1\n#define NUM_MATERIALS (LIGHT_BASE_MATERIAL_ID + NUM_LIGHTS)\n\n#define PERFORMANCE_MODE 0\n\n#define INVALID_MATERIAL_ID int(-1)\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define MAX_SDF_SPHERE_STEPS 15\n#define ABSORPTION_COEFFICIENT 0.5\n#define CAST_VOLUME_SHADOW_ON_OPAQUES 1\n\n#if PERFORMANCE_MODE\n#define MAX_VOLUME_MARCH_STEPS 20\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 4\n#define ABSORPTION_CUTOFF 0.25\n#define MARCH_MULTIPLIER 1.8\n#define LIGHT_ATTENUATION_FACTOR 2.0\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 10\n#else\n#define MAX_VOLUME_MARCH_STEPS 50\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 25\n#define ABSORPTION_CUTOFF 0.01\n#define MARCH_MULTIPLIER 1.0\n#define LIGHT_ATTENUATION_FACTOR 1.65\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 25\n#endif\n\n#define UNIFORM_FOG_DENSITY 0\n#define UNIFORM_LIGHT_SPEED 1\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 70, -165),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n\nvec3 GetLightColor(int lightIndex)\n{\n    switch(lightIndex % NUM_LIGHT_COLORS)\n    {\n        case 0: return vec3(1, 0.0, 1.0);\n        case 1: return vec3(0, 1.0, 0.0);\n    }\n    return vec3(0, 0.0, 1.0);\n}\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    const float lightMultiplier = 17.0f;\n#if UNIFORM_LIGHT_SPEED\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHT_COLORS);\n    float radius = 18.5f;\n#else\n    float theta = iTime * 0.4 * (float(lightIndex) + 1.0f);\n    float radius = 19.0f + float(lightIndex) * 2.0;\n#endif\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 6.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * lightMultiplier;\n    orbLight.Radius = 0.8f;\n\n    return orbLight;\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1.0 / pow(distanceToLight, LIGHT_ATTENUATION_FACTOR);\n}\n    \n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 Translate(vec3 pos, vec3 translate)\n{\n    return pos -= translate;\n}\n\n// Taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 origin, float s )\n{\n  p = Translate(p, origin);\n  return length(p)-s;\n}\n\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\nstruct Material\n{\n    vec3 albedo;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        materials[LIGHT_BASE_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LIGHT_BASE_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos)\n{    \n    // Fuse a bunch of spheres, slap on some fbm noise, \n    // merge it with ground plane to get some ground fog \n    // and viola! Big cloudy thingy!\n    vec3 fbmCoord = (pos + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;\n    float sdfValue = sdSphere(pos, vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), 5.6);\n    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), 5.6), 3.0f);\n    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(5.0 * sin(iTime), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);\n    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(0, 0.4, 0)), 22.0);\n    return sdfValue;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, float maxT)\n{\n    // Precision isn't super important, just want a decent starting point before \n    // ray marching with fixed steps\n\tfloat precis = 0.5; \n    float t = 0.0f;\n    for(int i=0; i<MAX_SDF_SPHERE_STEPS; i++ )\n    {\n\t    float result = QueryVolumetricDistanceField( rayOrigin+rayDirection*t);\n        if( result < (precis) || t>maxT ) break;\n        t += result;\n    }\n    return ( t>=maxT ) ? -1.0 : t;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvec3 GetAmbientLight()\n{\n\treturn 1.2 * vec3(0.03, 0.018, 0.018);\n}\n\nfloat GetFogDensity(vec3 position, float sdfDistance)\n{\n    const float maxSDFMultiplier = 1.0;\n    bool insideSDF = sdfDistance < 0.0;\n    float sdfMultiplier = insideSDF ? min(abs(sdfDistance), maxSDFMultiplier) : 0.0;\n \n#if UNIFORM_FOG_DENSITY\n    return sdfMultiplier;\n#else\n   return sdfMultiplier * abs(fbm_4(position / 6.0) + 0.5);\n#endif\n}\n\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetLightVisiblity(in vec3 rayOrigin, in vec3 rayDirection, in float maxT, in int maxSteps, in float marchSize)\n{\n    float t = 0.0f;\n    float lightVisibility = 1.0f;\n    float signedDistance = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {                       \n        t += max(marchSize, signedDistance);\n        if(t > maxT || lightVisibility < ABSORPTION_CUTOFF) break;\n\n        vec3 position = rayOrigin + t*rayDirection;\n\n        signedDistance = QueryVolumetricDistanceField(position);\n        if(signedDistance < 0.0)\n        {\n            lightVisibility *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n        }\n    }\n    return lightVisibility;\n}\n\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.009;\n    return Luminance(color) < minValue;\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDirection = (GetLight(lightIndex).Position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n\n        float lightVisiblity = 1.0;\n        #if CAST_VOLUME_SHADOW_ON_OPAQUES\n        if(!IsColorInsignificant(lightColor))\n        {\n            const float shadowMarchSize = 0.65f * MARCH_MULTIPLIER;\n            lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_OPAQUE_SHADOW_MARCH_STEPS, shadowMarchSize); \n        }\n        #endif\n        \n        color += lightVisiblity * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightVisiblity * lightColor * Diffuse(normal, lightDirection, material.albedo);\n    \n    }\n    color += GetAmbientLight() * material.albedo;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    float depth = LARGE_NUMBER;\n    vec3 opaqueColor = vec3(0.0f);\n    \n    vec3 normal;\n    float t;\n    int materialID = INVALID_MATERIAL_ID;\n    t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID, normal);\n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        // Defer lighting calculations after volume lighting so we can \n        // avoid doing shadow tracing on opaque objects that aren't visible anyways\n        depth = t;\n    }\n    \n    float volumeDepth = IntersectVolumetric(rayOrigin, rayDirection, depth);\n    float opaqueVisiblity = 1.0f;\n    vec3 volumetricColor = vec3(0.0f);\n    if(volumeDepth > 0.0)\n    {\n        const vec3 volumeAlbedo = vec3(0.8);\n        const float marchSize = 0.6f * MARCH_MULTIPLIER;\n        float distanceInVolume = 0.0f;\n        float signedDistance = 0.0;\n        for(int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n        {\n            volumeDepth += max(marchSize, signedDistance);\n            if(volumeDepth > depth || opaqueVisiblity < ABSORPTION_CUTOFF) break;\n            \n            vec3 position = rayOrigin + volumeDepth*rayDirection;\n\n            signedDistance = QueryVolumetricDistanceField(position);\n\t\t\tif(signedDistance < 0.0f)\n            {\n                distanceInVolume += marchSize;\n                float previousOpaqueVisiblity = opaqueVisiblity;\n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n                float absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;\n                \n                for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    \t\t\t{\n                    float lightVolumeDepth = 0.0f;\n                    vec3 lightDirection = (GetLight(lightIndex).Position - position);\n                    float lightDistance = length(lightDirection);\n                    lightDirection /= lightDistance;\n                    \n                    vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n                    if(IsColorInsignificant(lightColor)) continue;\n                    \n                    const float lightMarchSize = 0.65f * MARCH_MULTIPLIER;\n                    float lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_VOLUME_LIGHT_MARCH_STEPS, lightMarchSize); \n                    volumetricColor += absorptionFromMarch * lightVisiblity * volumeAlbedo * lightColor;\n                }\n                volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();\n            }\n        }\n    }\n    \n    if( materialID != INVALID_MATERIAL_ID && opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            opaqueColor = min(material.albedo, vec3(1.0));\n        }       \n        else\n        {\n    \t    vec3 reflectionDirection = reflect( rayDirection, normal);\n\t        CalculateLighting(position, normal, reflectionDirection, material, opaqueColor);\n        }\n    }\n    \n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 100.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    return iMouse.x / iResolution.x;\n}\n\nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    fragColor=vec4( GammaCorrect(clamp(color, 0.0, 1.0)), 1.0 );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}