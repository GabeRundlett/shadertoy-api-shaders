{
    "Shader": {
        "info": {
            "date": "1484183487",
            "description": "Dancing,Stickman",
            "flags": 64,
            "hasliked": 0,
            "id": "XtyXzD",
            "likes": 5,
            "name": "Dancing Stickman",
            "published": 3,
            "tags": [
                "dancing",
                "stickman"
            ],
            "usePreview": 1,
            "username": "voz",
            "viewed": 777
        },
        "renderpass": [
            {
                "code": "//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define FAR (PI*2.0)\n\n//-----------------UTILITY MACROS-----------------\n\n#define time ((sin(float(__LINE__))/PI/GR+1.0)*iTime+1000.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.0, .5, x))\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan(uv.y, uv.x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define hash(p) (fract(sin(vec2( dot(p,vec2(127.5,313.7)),dot(p,vec2(239.5,185.3))))*43458.3453))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rormal(x) (normalize(sin(vec3(time, time/GR, time*GR)+seedling)*.25+.5))\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define circle(x) (vec2(cos((x)*PI), sin((x)*PI)))\n#define saw(x) fract( sign( 1.- mod( abs(x), 2.) ) * abs(x) )\n\nfloat last_height = 0.0;\n\nmat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat sdSphere(vec3 rp, vec3 bp, float r) {\n    return length(bp - rp) - r;\n}\n\nfloat sdCapsule(vec3 rp, vec3 a, vec3 b, float r) {\n    vec3 pa = rp - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n\nconst int NUM_ANGLES = 5;\nconst int ELBOWS = 0;\nconst int WRISTS = 1;\nconst int FINGERS = 2;\nconst int KNEES = 3;\nconst int ANKLES = 4;\n// stance structure:\n//{\n//\tvec4(leftLegOmega, leftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftElbowOmega, relativeLeftElbowTheta, relativeRightElbowOmega, relativeRightElbowTheta)),\n//\tvec4(relativeLeftWristOmega, relativeLeftWristTheta, relativeRightWristOmega, relativeRightWristTheta)),\n//\tvec4(relativeLeftFingersOmega, relativeLeftFingersTheta, relativeRightFingersOmega, relativeRightFingersTheta)),\n//\tvec4(leftLegOmega, LeftLegTheta, rightLegOmega, rightLegTheta)),\n//\tvec4(relativeLeftKneeOmega, relativeLeftKneeTheta, relativeRightKneeOmega, relativeRightKneeTheta)),\n//\tvec4(relativeLeftAnkleOmega, relativeLeftAnkleTheta, relativeRightAnkleOmega, relativeRightAnkleTheta)),\n//}\n//\nvec4  stance[NUM_ANGLES];\nfloat shoulderRot = 0.0;\nfloat hipRot = 0.0;\nfloat lean = 0.0;\n\n//body joints\nvec3 head = vec3(0.0);\n\nvec3 bSpine = vec3(0.0);\nvec3 uSpine = vec3(0.0);\n\nvec3 leftShoulder = vec3(0.0);\nvec3 rightShoulder = vec3(0.0);\n\nvec3 leftElbow = vec3(0.0);\nvec3 rightElbow = vec3(0.0);\n\nvec3 leftWrist = vec3(0.0);\nvec3 rightWrist = vec3(0.0);\n\nvec3 leftFinger = vec3(0.0);\nvec3 rightFinger = vec3(0.0);\n\nvec3 leftHip = vec3(0.0);\nvec3 rightHip = vec3(0.0);\n\nvec3 leftKnee = vec3(0.0);\nvec3 leftAnkle = vec3(0.0);\n\nvec3 rightKnee = vec3(0.0);\nvec3 rightAnkle = vec3(0.0);\n\nconst vec3 downY = vec3(0.0, -1.0, 0.0);\nfloat minY = 0.0;\n\nvoid load_stance() {\n    \n    head = vec3(0.0, GR/E, 0.0);\n    \n    ///////////////////////////////////////////////////////////////\n    //Spine////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = head/GR;\n    uSpine = -bSpine;\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulders////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    leftShoulder = bSpine+vec3(1.0, 0.0, 0.0)/E;\n    rightShoulder = bSpine-vec3(1.0, 0.0, 0.0)/E;\n    \n    ///////////////////////////////////////////////////////////////\n    //Elbows///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftElbow = downY/GR;\n\n    float leftArmOmega = stance[ELBOWS].x;\n    float leftArmTheta = stance[ELBOWS].y;\n    \n    hangingLeftElbow = rotatePoint(rotatePoint(hangingLeftElbow, vec3(1.0, 0.0, 0.0), leftArmOmega), vec3(0.0, 0.0, 1.0), leftArmTheta);\n    \n    leftElbow = leftShoulder+hangingLeftElbow;\n        \n    vec3 hangingRightElbow = downY/GR;\n    \n    float rightArmOmega = stance[ELBOWS].z;\n    float rightArmTheta = stance[ELBOWS].w;\n    \n    hangingRightElbow = rotatePoint(rotatePoint(hangingRightElbow, vec3(1.0, 0.0, 0.0), rightArmOmega), vec3(0.0, 0.0, -1.0), rightArmTheta);\n    \n    rightElbow = rightShoulder+hangingRightElbow;\n    \n    ///////////////////////////////////////////////////////////////\n    //Wrists///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftWrist = downY/E;\n\n    float leftForeArmOmega = leftArmOmega+stance[WRISTS].x;\n    float leftForeArmTheta = leftArmTheta+stance[WRISTS].y;\n    \n    straightLeftWrist = rotatePoint(rotatePoint(straightLeftWrist, vec3(1.0, 0.0, 0.0), leftForeArmOmega), vec3(0.0, 0.0, 1.0), leftForeArmTheta);\n    \n    leftWrist = leftElbow+straightLeftWrist;\n        \n    vec3 straightRightWrist = downY/E;\n    \n    float rightForeArmOmega = rightArmOmega+stance[WRISTS].z;\n    float rightForeArmTheta = rightArmTheta+stance[WRISTS].w;\n    \n    straightRightWrist = rotatePoint(rotatePoint(straightRightWrist, vec3(1.0, 0.0, 0.0), rightForeArmOmega), vec3(0.0, 0.0, -1.0), rightForeArmTheta);\n    \n    rightWrist = rightElbow+straightRightWrist;\n    \n    ///////////////////////////////////////////////////////////////\n    //Fingers//////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    vec3 straightLeftFingers = downY/PI/E;\n\n    float leftFingersOmega = leftForeArmOmega+stance[FINGERS].x;\n    float leftFingersTheta = leftForeArmTheta+stance[FINGERS].y;\n    \n    straightLeftFingers = rotatePoint(rotatePoint(straightLeftFingers, vec3(1.0, 0.0, 0.0), leftFingersOmega), vec3(0.0, 0.0, 1.0), leftFingersTheta);\n    \n    leftFinger = leftWrist+straightLeftFingers;\n        \n    vec3 straightRightFingers = downY/PI/E;\n    \n    float rightFingersOmega = rightForeArmOmega+stance[FINGERS].z;\n    float rightFingersTheta = rightForeArmTheta+stance[FINGERS].w;\n    \n    straightRightFingers = rotatePoint(rotatePoint(straightRightFingers, vec3(1.0, 0.0, 0.0), rightFingersOmega), vec3(0.0, 0.0, -1.0), rightFingersTheta);\n    \n    rightFinger = rightWrist+straightRightFingers;\n    \n    \n    ///////////////////////////////////////////////////////////////\n    //Hips/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    leftHip = uSpine+vec3(circle(hipRot), 0.0).xzy/E/GR;\n    rightHip = uSpine-vec3(circle(hipRot), 0.0).xzy/E/GR;\n    ///////////////////////////////////////////////////////////////\n    //Knees////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 hangingLeftKnee = downY/GR;\n\n    float leftKneeOmega = stance[KNEES].x;\n    float leftKneeTheta = stance[KNEES].y;\n    \n    hangingLeftKnee = rotatePoint(rotatePoint(hangingLeftKnee, vec3(1.0, 0.0, 0.0), leftKneeOmega), vec3(0.0, 0.0, 1.0), leftKneeTheta);\n    \n    leftKnee = leftHip+hangingLeftKnee;\n        \n    vec3 hangingRightKnee = downY/GR;\n    \n    float rightKneeOmega = stance[KNEES].z;\n    float rightKneeTheta = stance[KNEES].w;\n    \n    hangingRightKnee = rotatePoint(rotatePoint(hangingRightKnee, vec3(1.0, 0.0, 0.0), rightKneeOmega), vec3(0.0, 0.0, -1.0), rightKneeTheta);\n    \n    rightKnee = rightHip+hangingRightKnee;\n    \n    ///////////////////////////////////////////////////////////////\n    //Ankles///////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    vec3 straightLeftAnkle = downY/GR;\n\n    float leftAnkleOmega = leftKneeOmega+stance[ANKLES].x;\n    float leftAnkleTheta = leftKneeTheta+stance[ANKLES].y;\n    \n    straightLeftAnkle = rotatePoint(rotatePoint(straightLeftAnkle, vec3(1.0, 0.0, 0.0), leftAnkleOmega), vec3(0.0, 0.0, 1.0), leftAnkleTheta);\n    \n    leftAnkle = leftKnee+straightLeftAnkle;\n        \n    vec3 straightRightAnkle = downY/GR;\n    \n    float rightAnkleOmega = rightKneeOmega+stance[ANKLES].z;\n    float rightAnkleTheta = rightKneeTheta+stance[ANKLES].w;\n    \n    straightRightAnkle = rotatePoint(rotatePoint(straightRightAnkle, vec3(1.0, 0.0, 0.0), rightAnkleOmega), vec3(0.0, 0.0, -1.0), rightAnkleTheta);\n    \n    rightAnkle = rightKnee+straightRightAnkle;\n    \n    ///////////////////////////////////////////////////////////////\n    //Lean/////////////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    bSpine = rotatePoint(bSpine, vec3(1.0, 0.0, 0.0), lean);\n    head = rotatePoint(head, vec3(1.0, 0.0, 0.0), lean);\n    \n    leftShoulder = rotatePoint(leftShoulder, vec3(1.0, 0.0, 0.0), lean);\n    rightShoulder = rotatePoint(rightShoulder, vec3(1.0, 0.0, 0.0), lean);\n    leftElbow = rotatePoint(leftElbow, vec3(1.0, 0.0, 0.0), lean);\n    rightElbow = rotatePoint(rightElbow, vec3(1.0, 0.0, 0.0), lean);\n    leftWrist = rotatePoint(leftWrist, vec3(1.0, 0.0, 0.0), lean);\n    rightWrist = rotatePoint(rightWrist, vec3(1.0, 0.0, 0.0), lean);\n    leftFinger = rotatePoint(leftFinger, vec3(1.0, 0.0, 0.0), lean);\n    rightFinger = rotatePoint(rightFinger, vec3(1.0, 0.0, 0.0), lean);\n    \n    ///////////////////////////////////////////////////////////////\n    //Shoulder Rotation////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n\n    leftShoulder = rotatePoint(leftShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightShoulder = rotatePoint(rightShoulder, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftElbow = rotatePoint(leftElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightElbow = rotatePoint(rightElbow, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftWrist = rotatePoint(leftWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightWrist = rotatePoint(rightWrist, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    leftFinger = rotatePoint(leftFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    rightFinger = rotatePoint(rightFinger, rotatePoint(downY, vec3(1.0, 0.0, 0.0), lean), shoulderRot);\n    \n    ///////////////////////////////////////////////////////////////\n    //Hip Rotation/////////////////////////////////////////////////\n    ///////////////////////////////////////////////////////////////\n    \n    \n    //MIN calc\n \tfloat lowestY = min(min(min(min(min(min(min(min(min(min(min(min(min(min(min(bSpine.y, uSpine.y),\n                                                                            leftShoulder.y),\n                                                                        rightShoulder.y),\n                                                                    leftElbow.y),\n                                                                rightElbow.y),\n                                                            leftWrist.y),\n                                                        rightWrist.y),\n                                                    leftFinger.y), \n                                                rightFinger.y), \n                                            leftHip.y), \n                                        rightHip.y), \n                                    leftKnee.y), \n                                leftAnkle.y),\n                            rightKnee.y),\n                        rightAnkle.y);\n    minY = min(lowestY, minY);\n}\n\nfloat dfScene(vec3 rp) {\n    \n    float msd = 99.0;\n    \n    //hip\n    msd = min(msd, sdSphere(rp, leftHip, 0.06));\n    msd = min(msd, sdSphere(rp, rightHip, 0.06));\n    msd = min(msd, sdCapsule(rp, leftHip, rightHip, 0.02));\n    //left thigh\n    msd = min(msd, sdSphere(rp, leftKnee, 0.05));\n    msd = min(msd, sdCapsule(rp, leftHip, leftKnee, 0.02));\n    //left shin\n    msd = min(msd, sdSphere(rp, leftAnkle, 0.04));\n    msd = min(msd, sdCapsule(rp, leftKnee, leftAnkle, 0.015));\n    //right thigh\n    msd = min(msd, sdSphere(rp, rightKnee, 0.05));\n    msd = min(msd, sdCapsule(rp, rightHip, rightKnee, 0.02));\n    //right shin\n    msd = min(msd, sdSphere(rp, rightAnkle, 0.04));\n    msd = min(msd, sdCapsule(rp, rightKnee, rightAnkle, 0.015));\n    //spine\n    msd = min(msd, sdSphere(rp, bSpine, 0.04));\n    msd = min(msd, sdSphere(rp, uSpine, 0.04));\n    msd = min(msd, sdCapsule(rp, bSpine, uSpine, 0.02));\n    //shoulder\n    msd = min(msd, sdSphere(rp, leftShoulder, 0.05));\n    msd = min(msd, sdSphere(rp, rightShoulder, 0.05));\n    msd = min(msd, sdCapsule(rp, leftShoulder, rightShoulder, 0.02));\n    //left upper arm\n    msd = min(msd, sdSphere(rp, leftElbow, 0.04));\n    msd = min(msd, sdCapsule(rp, leftShoulder, leftElbow, 0.02));\n    //left lower arm\n    msd = min(msd, sdSphere(rp, leftWrist, 0.03));\n    msd = min(msd, sdCapsule(rp, leftElbow, leftWrist, 0.015));\n    //left finger\n    msd = min(msd, sdSphere(rp, leftFinger, 0.015));\n    msd = min(msd, sdCapsule(rp, leftWrist, leftFinger, 0.01));\n    //right upper arm \n    msd = min(msd, sdSphere(rp, rightElbow, 0.04));\n    msd = min(msd, sdCapsule(rp, rightShoulder, rightElbow, 0.02));\n    //right lower arm\n    msd = min(msd, sdSphere(rp, rightWrist, 0.03));\n    msd = min(msd, sdCapsule(rp, rightElbow, rightWrist, 0.015));\n    //right finger\n    msd = min(msd, sdSphere(rp, rightFinger, 0.015));\n    msd = min(msd, sdCapsule(rp, rightWrist, rightFinger, 0.01));\n    //head\n    msd = min(msd, sdSphere(rp, head, 0.15));\n    \n    return msd;\n}\n\nvec3 surfaceNormal(vec3 p) { \n    vec2 e = vec2(5.0 / iResolution.y, 0);\n\tfloat d1 = dfScene(p + e.xyy), d2 = dfScene(p - e.xyy);\n\tfloat d3 = dfScene(p + e.yxy), d4 = dfScene(p - e.yxy);\n\tfloat d5 = dfScene(p + e.yyx), d6 = dfScene(p - e.yyx);\n\tfloat d = dfScene(p) * 2.0;\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n//IQ\nfloat calcAO(vec3 pos, vec3 nor) {   \n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.05*float(i);\n        vec3 aopos = pos + nor*hr;\n        occ += smoothstep(0.0, 0.7, hr - dfScene(aopos)) * sca;\n        sca *= 0.97;\n    }\n    return clamp(1.0 - 3.0 * occ , 0.0, 1.0);\n}\n\n//main march\nvec3 marchScene(vec3 ro, vec3 rd) {\n    \n    vec3 pc = vec3(0.0); //returned pixel colour\n    float d = 0.0; //distance marched\n    vec3 rp = vec3(0.0); //ray position\n    vec3 lp = normalize(vec3(5.0, 8.0, -3.0)); //light position\n   \n    for (int i = 0; i < 32; i++) {\n        rp = ro + rd * d;\n        float ns = dfScene(rp);\n        d += ns;\n        if (ns < 1.0/MAX_DIM || d > FAR) break;\n    }\n    \n    if (d < FAR) {\n\n        vec3 sc = vec3(1.0, 0.0, 0.0); //surface colour\n        vec3 n = surfaceNormal(rp);\n        float ao = calcAO(rp, n);\n        \n        float diff = max(dot(n, lp), 0.0); //diffuse\n\t    pc = sc * 0.5 + diff * sc * ao;\n        float spe = pow(max(dot(reflect(rd, n), lp), 0.), 16.); //specular.\n        pc = pc + spe * vec3(1.0);\n    }\n    \n    return pc;\n}\n\nconst int numWeights = 512;\n\nvec3 weights[numWeights];\n\nfloat lowAverage()\n{\n    const int iters = numWeights;\n    float product = 1.0;\n    float sum = 0.0;\n    \n    \n    for(int i = 0; i < iters; i++)\n    {\n        float sound = texture(iChannel0, vec2(float(i)/float(iters), 0.25)).r;\n        \n        product *= sound;\n        sum += sound;\n        \n        weights[i].r = sound;\n    }\n    for(int i = 0; i < iters; i++)\n        weights[i].gb = vec2(sum/float(iters), pow(product, 1.0/float(iters)));\n    return max(sum/float(iters), pow(product, 1.0/float(iters)));\n}\n\nvoid dance1()\n{\n    float height = max(lowAverage(), last_height)-1.0/60.0;\n    float beat = clip(height);\n\n    last_height = height;\n    \n\tfloat twist = time;\n    \n    stance[KNEES].xz = vec2(saw(beat*2.0));\n    stance[ANKLES].xz = -stance[KNEES].xz*2.0;\n    \n    vec2 twistCircle = circle(twist*GR);\n    \n    stance[ELBOWS].x = twistCircle.x*beat;\n    stance[ELBOWS].y = twistCircle.x/PI*beat;\n    stance[ELBOWS].z = twistCircle.y*beat;\n    stance[ELBOWS].w = twistCircle.y/PI*beat;\n    \n    stance[WRISTS].x = (stance[ELBOWS].x*.5+.5)*beat;\n    stance[WRISTS].z = (stance[ELBOWS].z*.5+.5)*beat;\n    \n    shoulderRot = sin(PI+twist*PI*3.0)/PI/GR*beat;\n    hipRot = sin(twist*PI*3.0)/PI/GR*beat;\n    lean = -(stance[KNEES].x+stance[KNEES].z)/PI;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    dance1();\n    \n    load_stance();\n    \n    //coordinate system\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0.0, minY+1.25, -3.5);\n    \n    //rotate camera\n    ro.yz *= rot(sin(iTime) * 0.25);\n    rd.yz *= rot(sin(iTime) * 0.25); \n    ro.xz *= rot(iTime * 0.5);\n    rd.xz *= rot(iTime * 0.5);\n    //*/\n    \n    fragColor = vec4(marchScene(ro, rd), 1.0);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 6707,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/little_rea/you-oughta-know-alanis"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}