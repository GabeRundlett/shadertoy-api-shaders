{
    "Shader": {
        "info": {
            "date": "1457085279",
            "description": "more tiles in full screen.\n\nuncomment for animation.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldGGDt",
            "likes": 21,
            "name": "illusion 10",
            "published": 3,
            "tags": [
                "illusion"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1059
        },
        "renderpass": [
            {
                "code": "// ref: http://wonderfulengineering.com/20-images-that-will-confuse-your-brain-warning-some-people-will-feel-dizzy-watching-these-images/\n// https://www.google.co.nz/search?q=Spine+Drift+illusion&tbm=isch\n\n#define m .12 // trimming border margin \n#define I .25 // contrast\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    O = O-O+ .5;\n    vec2 R = iResolution.xy;    float N = R.y > 512. ? 2. : 1.,\n          a = 0.1;//*sin(3.*iDate.w);            // tilting angle\n\n\tU = 12.*N*(U-R/2.)/R.y;                      // tiles\n    vec2 uv = abs(U);                    // coordinates, to define areas\n    U = fract(U/2.)*2.;\n    vec2 t = floor(U); U = fract(U)-.5;  // t = group of 4 tiles (color pattern)\n\n    if (uv.x>8.*N+m || uv.y>5.*N+m) return;      // outer belt\n    if (uv.x<5.*N-m && uv.y<3.*N-m)              // inner area\n     { if (uv.x>4.*N+m || uv.y>2.*N+m)  return;} // inner belt\n       //  else a = -a;\n\telse U = vec2(-U.y,U.x);             // outer area as symetric orientation\n    \n    vec2 V = .5-abs(U);                  // distance to tile borders\n    float e = 2.*mod(t.x+t.y,2.)-1.,     // color checker\n          d = sign(U.x*U.y),             // corner consistancy for dots\n          f = sign(U.x-U.y);             // border consistancy for lines\n    O += I*d*e*sin(4.*3.1416*(U.x-U.y))*exp(-dot(V,V)/.01);                // spots at nodes\n\n    float c = cos(a), s=sin(a);            // mat (c,-s,s,c)  for squares\n    V = .5-abs( mat2(c,-s,-s,c)*U );       // distance to rotated tile borders\n \tO +=  I*f*e*vec4(smoothstep(R.y>300.?.03:.06,.0,min(V.x,V.y)));        // lines\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}