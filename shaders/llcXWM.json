{
    "Shader": {
        "info": {
            "date": "1480256166",
            "description": "I originally planed to add a radiolaria model in the middle, and experiment with refraction, but this looks pretty nice so those plans can wait until next time.\n\nI've had to limit the step distance as the chamfers are causing a lot of overshoots :(",
            "flags": 0,
            "hasliked": 0,
            "id": "llcXWM",
            "likes": 91,
            "name": "Iridescent crystals",
            "published": 3,
            "tags": [
                "dodecahedron",
                "iridescence",
                "facet"
            ],
            "usePreview": 0,
            "username": "tdhooper",
            "viewed": 3692
        },
        "renderpass": [
            {
                "code": "#define MODEL_ROTATION vec2(.122, .5)\n\n// 0: Defaults\n// 1: Model\n#define MOUSE_CONTROL 1\n\n// Comment out for faster rendering\n#define ENABLE_CHAMFER\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n\n// --------------------------------------------------------\n// IQ\n// https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// MAIN\n// --------------------------------------------------------\n\nfloat time;\n\nstruct Model {\n    float dist;\n    vec3 colour;\n    float id;\n};\n\n    \nfloat quadrant(float a, float b) {\n\treturn ((sign(a) + sign(b) * 2.) + 3.) / 2.;\n}\n\n// Nearest icosahedron vertex and id\nvec4 icosahedronVertex(vec3 p) {\n    vec3 v1, v2, v3, result, plane;\n    float id;\n    float idMod = 0.;\n\tv1 = vec3(\n    \tsign(p.x) * PHI,\n        sign(p.y) * 1.,\n        0\n    );\n\tv2 = vec3(\n    \tsign(p.x) * 1.,\n        0,\n        sign(p.z) * PHI\n    );\n\tv3 = vec3(\n    \t0,\n        sign(p.y) * PHI,\n        sign(p.z) * 1.\n    );\n    plane = normalize(cross(\n        mix(v1, v2, .5),\n        cross(v1, v2)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v1;\n        id = quadrant(p.y, p.x);\n    } else {\n    \tresult = v2;\n        id = quadrant(p.x, p.z) + 4.;\n    }\n    plane = normalize(cross(\n        mix(v3, result, .5),\n        cross(v3, result)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v3;\n        id = quadrant(p.z, p.y) + 8.;\n    }\n    return vec4(normalize(result), id);\n}\n\nvec3 rand(vec3 seed){\n    return fract(mod(seed, 1.) * 43758.5453);\n}\n\nvec3 jitterOffset(float seed) {\n\treturn normalize(rand(vec3(seed, seed + .2, seed + .8)) - .5);\n}\n\nvec3 jitterVec(vec3 v, float seed, float magnitude) {\n\treturn normalize(v + jitterOffset(seed) * magnitude);\n}\n\nfloat alias(float t, float resolution) {\n\treturn floor(t * resolution) / resolution;\n}\n\n#ifdef ENABLE_CHAMFER\n\tconst float chamfer = .003;\n#else\n\tconst float chamfer = .0;\n#endif\n\nfloat fCrystalShard(vec3 p, float size) {\n    float d;\n    float width = size * .04 + .07;\n    vec3 o = normalize(vec3(1,0,-.04));\n\n    pModPolar(p.xy, 5.);\n    float part1, part2;\n    \n    p.y = abs(p.y);\n\n    part1 = fPlane(p, vec3(1,0,-.04), -width);\n\n    pR(p.xy, TAU/5.);\n    part2 = fPlane(p, vec3(1,0,-.04), -width);\n    \n    d = max(part1, part2);\n\td = fOpIntersectionChamfer(part1, part2, chamfer);\n\n    return d;\n}\n\nfloat fCrystalCap(vec3 p, float id, float side) {\n    float jitter = id + side * .1;\n    vec3 o = normalize(vec3(1,0,.55));\n\tfloat angle = TAU / 3.;\n    float d, part;\n\n    d = fPlane(p, jitterVec(o, jitter + .3, .1), 0.);\n    \n    pR(p.xy, angle);\n    part = fPlane(p, jitterVec(o, jitter + .5, .1), 0.);\n    d = fOpIntersectionChamfer(d, part, chamfer);\n\n    pR(p.xy, angle);\n    part = fPlane(p, jitterVec(o, jitter + .9, .1), 0.);\n    d = fOpIntersectionChamfer(d, part, chamfer);\n    \n    return d;\n}\n\nfloat fCrystal(vec3 p, float id, float focus) {\n    \n    float size = sin(time * TAU * 4. + focus * 5. + id) * .5 + .5;\n    float size2 = cos(time * TAU * 2. + focus * 5. + id) * .5 + .5;\n    \n    size = alias(size, 2.);\n    size2 = alias(size2, 2.);\n    \n    float height = size2 * .1 + .35;\n    float offset = .9;\n    float d;\n\n    float shard = fCrystalShard(p, size);\n    \n    p.z -= offset;\n    float side = sign(p.z) * .5 + .5;\n    p.z = abs(p.z);\n    p.z -= height;\n\n    float cap = fCrystalCap(p, id, side);\n    d = fOpIntersectionChamfer(shard, cap, chamfer);\n\n\treturn d;\n}\n\nModel model(vec3 p) {    \n\tfloat d = 1000.;\n   \tvec3 col = vec3(0);\n\tvec3 dir = normalize(vec3(\n    \t0,\n        -PHI,\n        -1\n    ));\n    \n    vec4 iv = icosahedronVertex(p);\n    vec3 v = iv.xyz;\n    float id = iv[3] / 12.;\n    \n    p *= orientMatrix(v, vec3(0,0,1));\n    pR(p.xy, id);\n    \n    pR(p.xy, time * TAU);\n    \n    float focus = dot(v, dir) * .5 + .5;\n\n    d = fCrystal(p, id, focus);\n        \n    return Model(d, col, 1.);\n}\n\n\n\n// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\nconst float MAX_TRACE_DISTANCE = 30.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n// Default is 1, reduce to fix overshoots\n#ifdef ENABLE_CHAMFER\n\tconst float FUDGE_FACTOR = .5;\n#else\n\tconst float FUDGE_FACTOR = 1.;\n#endif\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n\t\tcy, -sy * -sx, -sy * cx,\n\t\t0, cx, sx,\n\t\tsy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n    \tvec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n\t    \txy.x = mouse.x;\n    \t\txy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n    \treturn m1;\n    } else {\n    \treturn m2;\n    }\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\n\n\nModel map( vec3 p ){\n    Model res = Model(1000000., vec3(0), 0.);\n    p *= modelRotation();\n    res = opU(res, model(p));\n   \treturn res;\n}\n\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g)\n{\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB)\n{\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\nstruct Hit {\n    float len;\n    vec3 colour;\n    float id;\n};\n\nHit calcIntersection( in vec3 ro, in vec3 rd ){\n\n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n    float res = -1.0;\n    float id = -1.;\n    vec3 colour;\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n\n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n        Model m = map( ro+rd*t );\n        h = m.dist;\n        t += h * FUDGE_FACTOR;\n        id = m.id;\n        colour = m.colour;\n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n\n    return Hit( res , colour , id );\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 3.;\n    camRoll = 0.;\n    camTar = vec3(0);\n    camPos = vec3(0,.1,-dist);\n    pR(camPos.yx, time*TAU*1.);\n    camPos += camTar;\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n\nvec3 render( Hit hit , vec3 ro , vec3 rd ){\n\n    vec3 bg = vec3(0.);\n    vec3 color = bg;\n\n    if (hit.id == 1.) {\n    \tvec3 pos = ro + rd * hit.len;\n        vec3 norm = calcNormal( pos );\n        vec3 ref = reflect(rd, norm);\n        vec3 lig = normalize(vec3(.5,1,-.5));\n        vec3 dome = vec3(0,1,0);\n        vec3 eye = vec3(0,0,-1);\n\n        vec3 perturb = sin(pos * 10.);\n        color = spectrum( dot(norm + perturb * .05, eye) * 2.);\n\n        float specular = clamp(dot(ref, lig), 0., 1.);\n        specular = pow((sin(specular * 20. - 3.) * .5 + .5) + .1, 32.) * specular;\n        specular *= .1;\n        specular += pow(clamp(dot(ref, lig), 0., 1.) + .3, 8.) * .1;\n\n        float shadow = pow(clamp(dot(norm, dome) * .5 + 1.2, 0., 1.), 3.);\n        color = color * shadow + specular;\n\n        float near = 2.8;\n        float far = 4.;\n        float fog = (hit.len - near) / (far - near);\n        fog = clamp(fog, 0., 1.);\n        color = mix(color, bg, fog);\n    }\n\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 3.;\n    time = mod(time, 1.);   \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = calcIntersection( camPos , rd  );\n\n    vec3 color = render( hit , camPos , rd );    \n    color = linearToScreen(color);\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}