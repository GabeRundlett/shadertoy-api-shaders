{
    "Shader": {
        "info": {
            "date": "1676125872",
            "description": "A semi-regular 3,3,4,3,4 extruded tiling of the plane.",
            "flags": 32,
            "hasliked": 0,
            "id": "DllSWB",
            "likes": 80,
            "name": "Semi-regular 3,3,4,3,4 Extrusion",
            "published": 3,
            "tags": [
                "pattern",
                "tile",
                "extrude",
                "snub",
                "semiregular",
                "33434"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1155
        },
        "renderpass": [
            {
                "code": "/*\n\n    Semi-regular 3,3,4,3,4 Extrusion\n    --------------------------------\n\n    Rendering the buffer.\n \n    See Buffer A for an explanation.\n    \n*/\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 3.9, coc = 1.65;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n/*\n// Very basic bloom function.\nvec4 bloomBlur(sampler2D iCh, vec2 p){\n    \n    vec4 c = vec4(0);\n\n    const int n = 2;\n    for(int j = -n; j<=n; j++){\n        for(int i = -n; i<=n; i++){\n            c +=  texture(iCh, p + vec2(i, j)/iResolution.xy*2., 1.);\n        }\n    }\n    \n    return c/float((n*2 + 1)*(n*2 + 1));\n   \n}\n*/\n\n\n// This is not a great bokeh function example, but it'll do. It's an amalgamation\n// of old blur and DOF functions with a couple of borrowed lines from Dave Hoskins's \n// much nicer Fibonacci based \"Bokeh disc\" function, which you can find here:\n// https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\n//\nvec3 bokeh(sampler2D iCh, vec2 uv, float radius){\n\n\tvec3 tot = vec3(0), sum = vec3(0);\n\n     // Focal point and circle of confusion.\n    const float focD = 2.15, coc = .6;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float r = (clamp(l/coc, 0., 2.)) + .05;\n     \n\n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){ \n              \n            // If we're not inside the circle, continue.\n            //if(length(vec2(i, j))>float(n)) continue; \n        \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            //vec3 c = texture(iCh, uv + vec2(i, j)/vec2(800, 450)*r, r*.7).xyz; \n            vec3 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7).xyz;\n            // Based on Dave Hoskins's tweak. I've tried my own, and they don't seem to\n            // work as well. If you know of better ways, feel free to let me know.\n            c *= sqrt(c)*4.;\n            vec3 bokeh = pow(c, vec3(4));\n            tot += c*bokeh;\n            sum += bokeh;\n        }\n    }\n    \n\treturn tot/sum;\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Just the unprocessed texture on it's own.\n    //vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Cheap 25 tap depth of field function.\n    vec3 col = DpthFld(iChannel0, uv);\n    \n    \n    // Worst bokeh algorithm ever. :)\n    vec3 bokCol = bokeh(iChannel0, uv, 1.).xyz;\n    col = mix(col, bokCol, .5);\n     \n    /*\n    // Bloom. Too much here.\n    vec3 bloom = bloomBlur(iChannel0, uv).xyz;\n    vec3 bloomLight = vec3(1, .9, .7);\n    col += pow(bloom, 2./bloomLight)*2.;//*.35;\n    */\n    \n         \n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Semi-regular 3,3,4,3,4 Extrusion\n    --------------------------------\n    \n    This is a semi-regular 3,3,4,3,4 tiling in variable height extruded form. I like \n    the overlapping elliptical nature of the pattern. The 2D version isn't what I'd \n    call common in the real world, but thanks to math people who like to code, you'll \n    see it a lot in the 2D graphics world. Oddly enough, the extruded quasi 3D form \n    is not common at all. In fact, I couldn't find an example anywhere. I've noticed \n    this for virtually all semi-regular tilings, which I find perplexing for various \n    reasons... I'll put it down to the mysteries of the graphics world. :)\n    \n    Anyway, I have an almost unhealthy compulsion to drag a 2D pattern off the plane, \n    so I'm slowly growing a collection of extruded semi-regular arrangements on \n    Shadertoy. Like the previous pattern, I coded it up quickly in order to get the \n    job done, so I'd imagine there'd be better ways to do it.\n    \n    I wasn't feeling very creative when it came to presentation, so I attempted to \n    dress the scene up with a few graphics cliches and post processing. Post\n    processing algorithms are mostly common sense, and easy to put together, provided\n    you can use a lot of samples. Unfortunately, slower machines don't like that, so\n    I've attempted to write some lower sampled ones, which are not ideal. They're\n    OK for this... Kind of. The 25 tap DOF isn't too bad, but the hacky bokeh routine\n    is not my best work. :) By the way, if you know of ways to make those functions\n    better, feel free to let me know.\n    \n    \n    \n    Related examples:\n    \n    // I like this example, since it's a simple 2D semi-regular tiling \n    // visual reference. The floret pattern is contained in it somewhere.\n    Wythoff Uniform Tilings + Duals - Fizzer \n    https://www.shadertoy.com/view/3tyXWw\n    \n    // Hyperbolic semi-regular tilings. A really nice example. As an aside,\n    // I have an extruded hyperbolic regular tiled example somewhere.\n    Wythoffian Tiling Generator - mla\n    https://www.shadertoy.com/view/wlGSWc\n    \n    // An unlisted 2D parallelogram grid example that, hopefully, will \n    // show roughly how the pattern was made.\n    Parallelogram Grid - Shane \n    https://www.shadertoy.com/view/dlBSRG\n    \n    \n*/\n\n\n#define FAR 40.\n\n// Animate the pattern. By rotating respective tile angles, it's possible\n// to change the packing arrangement.\n//#define ANIMATE\n\n\n#ifndef ANIMATE\n// I didn't arrange for holes to work during animation -- I may fix that later. You \n// can comment out the following line and override the holes entirely, if desired.\n#define HOLES\n#endif\n\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n}\n\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n\n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .015;\n    vec2 w = vec2( sdf, abs(pz) - h - sf/2.);\n  \treturn min(max(w.x, w.y), 0.) + length(max(w + sf, 0.)) - sf;\n    */\n}\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat getTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n// Pylon height function.\nfloat hMap(vec2 p){\n    return hash21(p)*.1 + .025;// + (dot(sin(p.xy*2. - cos(p.yx*4.)*2.), vec2(.25)) + .5)*.15;     \n}\n\nvec4 gVal;\n//vec3 glow, lCol; // Global glow and glow color variables.\n\n\nfloat m(vec3 p){\n   \n \n    // The floor.\n    float fl = -p.z;\n    \n    \n    \n    // The semi-regular 3,3,4,3,4 extrusion. By the way, for anyone not familiar with\n    // the nomenclature process, choose any vertex, then count the number of shapes\n    // that surround it -- In this case, you'll see that it is five. Now list the number\n    // of vertices for each shape, then put them in order from smallest (including repeats)\n    // to largest. In this case it'll be, triangle, triangle, square, triangle, square,\n    // which have vertex numbers, 3,3,4,3,4. Simple... Well, I get it wrong all the time,\n    // but it's still a simple process. :D\n    \n    // Scaling variables.\n    float sc = 1./4.5, s = sc*2.;\n    \n    #ifdef ANIMATE\n    // Variable angle. This will work, but the holes will need to be removed.\n    float ang = atan(1., 2.)*(cos(iTime*.5)*.5 + .25);//\n    #else\n    // The angle necessary to make the squares and equilateral triangles pattern...\n    // I can't remember how I came up with it... I probably used math. :D\n    float ang = atan(1., 4.);\n    #endif\n    // h = 1./cos(ang) = R*(1. + sqrt(3.)/2.);\n    // => R = 1./cos(ang)/(1. + sqrt(3.)/2.);\n    //float dim = 1./sin((3.14159/2. + ang))/4.;\n    \n    // The dimensions of the two squares and the two skewed squares (parallelograms).\n    // The two parallelograms are split along the diagonal to form triangles.\n    float dim = 1./cos((ang))/2.;\n    float dim2 = dim*cos(ang*2.);\n    mat2 matA = r2(ang);\n    mat2 matB = r2(-ang);\n    \n    float d = 1e5;\n    const mat4x2 offs = mat4x2(vec2(-.25), vec2(-.25, .25), vec2(.25), vec2(.25, -.25));\n    \n    // Rendering four objects per pass, two of which are split down the center, so \n    // that's six all up.\n    for(int i = min(0, iFrame); i<4; i++){\n    \n        // Local coordinats and ID.\n        vec2 q = p.xy;\n        vec2 iq = floor(q/s - offs[i]) + .5; // Local tile ID.\n        \n        // Correct positional individual tile ID.\n        vec2 idi = (iq + offs[i])*s;\n        \n        q -= idi; // New local position.\n        \n        \n        // Rotating q by two different matrices. Mixing the coordinates will produce\n        // two squares and two skewed parallelograms, which will be split across the\n        // diagonal to form triangles.\n        vec2 qA = matA*q, qB = matB*q;\n\n        // This forms the 2D coordinates for four parallelograms -- Two are mutually\n        // perpendicular (qr = qA and qr = qB), so remain square. The other two\n        // coordinate sets are mixed, so will be skewed... It's a simple trick that I\n        // take for granted in situation like this, and is handy to know.\n        vec2 qr = vec2((i==0 || i ==3)? qA.x : qB.x, i<2? qA.y : qB.y);\n        \n         \n        // Edge width and smoothing factor.\n        const float ew = .003, sm = .035; \n        float dm = ((i&1)==0)? dim : dim2;\n        qr = abs(qr) - dm*sc + sm + ew;\n        // 2D parallelogram (or square) distance. Most certainly not a correct distance,\n        // field but it passes the visual test, so it's fine for this demonstration.\n        float d2 = min(max(qr.x, qr.y), 0.) + length(max(qr, 0.)) - sm; \n       \n       \n        vec2 tOffs = i==1 || i==2? vec2(1) : vec2(-1, 1);\n        vec2 idOffs = tOffs*(.7071 + sin(ang)*dim)/4.;\n        \n        float d3, h;\n        \n        if(i==0 || i==2){\n            // The two squares.\n            \n            if(i==0) tOffs *= 0.;\n            \n            #ifdef HOLES\n            // Bore out random holes.\n            if(hash21(idi + .03)<.35){ \n                float hlSz = (hash21(idi - tOffs*s/2. + .04)*.2 + .2)*sc;\n                 d2 = max(d2, -(d2 + hlSz));//abs(d2 + .125) - .125;  \n                //d2 = max(d2, -(length(q) - hlSz/2.5));//abs(d2 + .125) - .125;  \n            }\n            #endif\n        \n           \n            h = hMap(idi - tOffs*s/2.); // Prism height.\n            d3 = opExtrusion(d2, p.z + h/2., h/2.);  // Prism.\n            d3 += d2*.1; // Face slope. \n        }\n        else {\n            \n        \n            // Splitting the parallelograms across the diagonal to \n            // create two triangles.\n            \n            // Triangle dividing line.\n            float triLn;\n            if(i==1) triLn = distLineS(q, vec2(-1, 1)*dim*sc/2., vec2(1, -1)*dim*sc/2.);\n            else triLn = distLineS(q, vec2(0), vec2(1)*dim*sc/2.);\n            \n            float d2B = smax(d2, triLn + ew, sm);\n            d2 = smax(d2, -triLn + ew, sm);\n            \n            \n            #ifdef HOLES\n             // Bore out random holes.\n            if(hash21(idi - tOffs*s/4. + .03)<.35){ \n                float hlSz = (hash21(idi - tOffs*s/4. + .04)*.25 + .25)*sc;\n                //d2 = max(d2, -(d2 + hlSz));//abs(d2 + .125) - .125;  \n                //d2 = max(d2, -(length(q - r2(dir*3.14159/4.)*vec2(sc*.31, 0)) - hlSz/4.));\n                //d2 = max(d2, -(length(q - tOffs*(.7071 + sin(ang)*dim)*sc/4.) - hlSz/3.5));\n                \n                // Triangle holes.\n                vec2 qrr = q - tOffs*(.7071 + sin(ang)*dim)*sc/4.;\n                qrr *= r2(3.14159 - tOffs.x*ang);\n                d2 = max(d2, -getTri(qrr,  hlSz/2.5));\n                 \n            }\n            \n            if(hash21(idi + tOffs*s/4. + .03)<.35){ \n                float hlSz = (hash21(idi + tOffs*s/4. + .04)*.25 + .25)*sc;\n                //d2B = max(d2B, -(d2B + hlSz));//abs(d2 + .125) - .125; \n                //d2B = max(d2B, -(length(q - r2(-dir*3.14159/4.)*vec2(sc*.31, 0).yx) - hlSz/4.));\n                //d2B = max(d2B, -(length(q + tOffs*(.7071 + sin(ang)*dim)*sc/4.) - hlSz/3.5));\n\n                // Triangle holes.\n                vec2 qrr = q + tOffs*(.7071 + sin(ang)*dim)*sc/4.;\n                qrr *= r2(-tOffs.x*ang);\n                d2B = max(d2B, -getTri(qrr,  hlSz/2.5));\n                \n            }\n            #endif\n           \n            // The two triangle prisms on either side of the split.\n            h = hMap(idi - tOffs*s/4.);\n            d3 = opExtrusion(d2, p.z + h/2., h/2.);\n            float hB = hMap(idi + tOffs*s/4.);\n            float d3B = opExtrusion(d2B, p.z + hB/2., hB/2.);\n            d3 += d2*.1;\n            d3B += d2B*.1;\n            \n            // Determine the minimum triangle prism distance.\n            if(d3B<d3){            \n                idi -= tOffs/4.;\n                d3 = d3B;\n                d2 = d2B;\n                h = hB;            \n            }\n            else {\n                idi += tOffs/4.;\n            }\n            \n        \n        }\n \n        // Closest of all the prisms.\n        if(d3<d){\n        \n           d = d3; // Set the new minimum.\n           \n           // Saving the 2D face distance, height, and ID\n           // for this particular prism.\n           gVal = vec4(d2, h, idi);\n        \n        } \n        \n        //if(d<-1e5) break;\n    \n    }\n    \n    // Check to see if the floor is closer.\n    if(fl<d) gVal = vec4(-1);\n    \n    /*\n    // Glow calculations.\n    lCol = vec3(0);\n    if((d)<.25 && d<fl && hash21(gVal.zw + .13)>=.7){\n       float rnd = hash21(gVal.zw);\n       vec3 gCol = .5 + .45*cos(6.2831*rnd/8. + (vec3(0, 1.2, 2) + .5)*1.5 + 1.5);\n       lCol = gCol*smoothstep(0., .5, -(gVal.x));\n    }    \n    */\n    \n    // Minimum scene distance.\n    return min(fl, d);\n    \n}\n\n\n// Basic raymarcher.\nfloat tr(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    // Adding some jitter to the jump off point to alleviate banding.\n    float t = hash31(fract(ro/7.319) + rd)*.1, d;\n    \n    //glow = vec3(0);\n    \n    for(int i = min(0, iFrame); i<96; i++){\n    \n        d = m(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n         // Accumulate the glow color.\n        //glow += lCol;///(1. + t);\n        \n        // Note that the ray is capped (to .1). It's slower, but is necessary for the\n        // glow to work. I guess it could also help with overstepping the mark a bit.\n        t += min(d*.7, .1); \n    }\n\n    return min(t, FAR);\n}\n\n// fb39ca4's inverse mix function.\n// Inverse mix takes a value between \"a\" and \"b\" and maps it to zero to one range.\nfloat invMix(float a, float b, float x) {\n\tx = (x - a)/(b - a);\n    return x*x; // Returning the square for darker tones... My tweak, and not correct.\n}\n\n// IQ's soft shadow function.\nfloat sha(vec3 ro, vec3 lp, vec3 n, float k) {\n\t\n    // Use penumbra modifications.\n    #define PENUM\n    \n\t// More would be nicer. More is always nicer, but not always affordable. :)\n    const int iter = 32; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.; // Initialize the shadow to 1., or no shadow.\n    float t = 0.;//hash31(fract(ro/7.319) + n)*.01; // Scene distance.\n    float maxD = max(length(rd), .0001); // Max light distance.\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= maxD; // Normalize.\n\t\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. \n    // Obviously, the lowest number to give a decent shadow is the best one to choose. \n\tfor (int i = 0; i<iter; i++) {\n \t \n\t\tfloat d = m(ro + rd*t); // Distance to the scene.\n        #ifdef PENUM\n        // This is a tweak I found in fb39ca4's Loxodrom example. It makes sense,\n        // but I'd need to investigate further. The shadows are more succint, but lighter.\n        // https://www.shadertoy.com/view/MsX3D2\n\t\tfloat penumbraDist = t/k;\n\t\tshade = min(shade, invMix(-penumbraDist, penumbraDist, d));\n\t\tt += min((d + penumbraDist)*.5, .2);\n        #else\n        // IQ's simpler calculation. If feel the shade itself is more constistant, but\n        // the shape isn't perfect. Emulating soft shadows isn't easy, if not impossible.\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        t += clamp(d, .005, .2);\n        #endif\n\t\t\n        // Early exit, and not exceeding the maximum light distance.\n        if(d<0. || t>maxD) break;\n\t}\n    \n    #ifdef PENUM\n    // Another one of fb39ca4's additions. Penumbra stuff. :) \n    shade = max(shade, 0.)*2. - 1.;\n\treturn ((sqrt(1. - shade*shade)*shade + asin(shade)) + 3.14159265/2.)/3.14159265;\n    #else\n    return max(shade, 0.);\n    #endif\n    \n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n){\n\n\tfloat sca = 5., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.1/5.;        \n        float d = m(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        //if(occ>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n/*\n// Standard normal function.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), \n                          m(p + e.yxy) - m(p - e.yxy),\t\n                          m(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nr(in vec3 p) {\n\t\n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += m(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n \nvoid mainImage(out vec4 c, vec2 u){\n\n    \n    // Unit direction vector, camera (moving along Z), and point light (above the camera).\n    // A \"to\" and \"from\" camera system is better, and only requires a few more lines, but\n    // we're keeping things simple.\n    vec3 r = normalize(vec3(u - iResolution.xy*.5, iResolution.y)), \n         o = vec3(0, iTime/6., -1.25), l = o + vec3(-.25, 4.75, -.5);\n    \n    // Rotating the unit direction ray, for a bit of visual interest.\n    r.xz = r2(.35)*r.xz;\n    r.yz = r2(.75)*r.yz;\n    r.xy = r2(-.5)*r.xy;\n\n    // Raymarching.\n    float t = tr(o, r);\n      \n    // Save the distance function prism information.\n    vec4 svVal = gVal;\n    \n    // Scene color, initialized to zero.\n    c = vec4(0);\n    \n    // If we've hit an object, light it up.\n    if(t<FAR){\n    \n        // Hit point and normal.\n        vec3 p = o + r*t, n = nr(p);\n        \n        // Shadow and ambient occlusion.\n        float sh = sha(p, l, n, 8.);\n        float ao = cao(p, n);\n      \n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), .001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n  \n        // Diffuse, half vector specular, and reflective specular.\n        float dif = max(dot(l, n), 0.); //dif = pow(dif, 4.)*2.;\n        float speR = pow(max(dot(normalize(l - r), n), 0.), 16.);\n        float spe = pow(max(dot(reflect(l, n), r), 0.), 5.);\n        \n        // Schlick approximation. I use it to tone down the specular term.\n\t\tfloat Schlick = pow(1. - max(dot(r, normalize(r + l)), 0.), 5.);\n\t\tfloat freS = mix(.7, 1., Schlick);  //F0 = .2 - Glass... or close enough. \n        \n\n        // Scene object color.\n        \n        // Coloring the grid objects.\n        float rnd = hash21(svVal.zw);\n        c = .5 + .45*cos(6.2831*rnd/8. + (vec4(0, 1.2, 2, 0) + .5)*1.5 + 2.25);\n        \n        // Giving the foreground prisms a different color, just for fun.\n        c = mix(c.yxzw, c, smoothstep(0., 1., t/3. - .1));\n        \n        // Setting most of the prisms to grey.\n        if(hash21(svVal.zw + .13)<.75){ \n            c = mix(c, vec4(.2)*dot(c, vec4(.299, .587, .114, 0)) + .15, .95);\n            //glow *= 0.;\n        }\n        \n        // One flat color, if you'd prefer that.\n        //c = vec4(.45, .15, 1, 0); \n\n        // Extra shading.\n        c *= hash21(svVal.zw + .143)*.5 + .5;\n        \n        \n        // Floor.\n        if(abs(svVal.y + 1.)<.001) c = vec4(.05);\n        \n        \n        // Adding some texture.\n        vec3 tx = tex3D(iChannel1, p - vec3(0, 0, svVal.y*2.), n);\n        c.xyz *= (tx*3. + .2);\n         \n        // Cheap specular reflections.\n        vec3 rf = reflect(r, n); // Surface reflection.\n        vec4 rTx = texture(iChannel0, rf); rTx *= rTx;\n        c += (c*.6 + .4)*speR*rTx*1.5;\n        \n        \n        if(svVal.y > 0.){\n            // Face edge distance.\n            float d = max(abs(svVal.x), abs(p.z + svVal.y));\n            c = mix(c, c*.1, 1. - smoothstep(0., .006, d - .002));\n        }\n        \n        // Glow. Not used here.\n        //c.xyz += c.xyz*glow*24.;\n        \n        \n         \n        // Applying diffuse lighting, ambient lighting, and attenuation.\n        c.xyz = c.xyz*(dif*sh + vec3(1, .9, .7)*spe*freS*4.*sh + .35)*1./(1. + d*d*.125)*ao;\n        \n    }\n    \n    // Applying fog: This fog begins at 90% towards the horizon.\n    c = mix(clamp(c, 0., 1.), vec4(0), smoothstep(0., .9, t/FAR));\n    \n    // Clamp.\n    c = vec4(clamp(c.xyz, 0., 1.), t);\n    \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but minor temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel2, ivec2(u), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    c = mix(preCol, c, blend);\n    \n    \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}