{
    "Shader": {
        "info": {
            "date": "1619800451",
            "description": "This is test of my instancing ray tracer, In the scene there is 475 objects. the Instancing speeds it up about 4 times for 9 instances, i still am optimizing the compile time.",
            "flags": 32,
            "hasliked": 0,
            "id": "fdjXzD",
            "likes": 5,
            "name": "Instance ray tracing",
            "published": 3,
            "tags": [
                "instance"
            ],
            "usePreview": 0,
            "username": "me_123",
            "viewed": 476
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 d = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = vec4(d.xyz/d.w, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define initInst temp t = temp(0.0, vec3(0), vec3(0.8)); state s=state(maxDist, normal, color);\n#define setObject if (t.tmp != -1.0&&t.tmp<s.d0) {s.d0 = t.tmp;s.normal = t.normal;s.color=t.color;}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nconst float maxDist = 1000.;\nvec2 box(in vec3 ro, in vec3 rd, in vec3 boxSize, out vec3 normal) {\n    boxSize /= 2.0;\n    ro += boxSize;\n\tvec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return vec2(-1.0);\n    normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2(tN, tF);\n}\nbool bound(in vec3 ro, in vec3 rd, in vec3 boxSize) {\n    boxSize /= 2.0;\n    ro += boxSize;\n\tvec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return false;//return vec2(-1.0);\n    return true;\n}\nstruct TRI {\n\tvec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\nvec3 tri(in vec3 ro, in vec3 rd, in TRI a) {\n\tvec3 v1v0 = a.v1-a.v0;\n\tvec3 v2v0 = a.v2-a.v0;\n\tvec3 rov0 = ro-a.v0;\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, rd);\n    float d = 1./dot(rd, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot(q, v1v0);\n    float t = d*dot(-n, rov0);\n    if (u<0. || u>1.0||v<0.0||(u+v)>1.0) t = -1.0;\n    return vec3(t, u, v);\n}\nmat2 rot(in float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n//Instances\nstruct hit {\n\tfloat dist;\n    vec3 normal;\n    vec3 color;\n};\nstruct temp {\n\tfloat tmp;\n    vec3 normal;\n    vec3 color;\n};\nstruct state {\n\tfloat d0;\n    vec3 normal;\n    vec3 color;\n};\nfloat hitAC(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    bool boundHit = bound(ro-vec3(0.02, 0.36, 0.02), rd, vec3(0.33, 0.5, 0.33));\n    if (!boundHit) return -1.0;\n    initInst\n\tt.color = vec3(0, 0.8, 0);\n    t.tmp = box(ro+vec3(0.0, 0.03, 0.0), rd, vec3(0.28, 0.03, 0.28), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.016, 0.015, 0.016), rd, vec3(0.32, 0.044, 0.32), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.0075, 0.245, 0.0075), rd, vec3(0.3, 0.23, 0.3), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(0.01615, 0.285, 0.01615), rd, vec3(0.323, 0.04, 0.323), t.normal).x; setObject;\n    t.tmp = box(ro-vec3(-0.1, 0.360, -0.1), rd, vec3(0.087, 0.076, 0.087), t.normal).x; setObject;\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}\nfloat hitR1(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    bool boundHit = bound(ro-vec3(0.0, 0.3, 0.0), rd, vec3(1.5, 0.4, 1.5));\n    if (!boundHit) return -1.0;\n    initInst;\n\tt.color = vec3(0.8, 0, 0);\n    t.tmp = box(ro, rd, vec3(0.1, 0.2, 1.5), t.normal).x; setObject;\n    t.tmp = box(ro, rd, vec3(1.5, 0.2, 0.1), t.normal).x; setObject;\n    t.tmp = box(ro+vec3(0.0, 0.0, 1.4), rd, vec3(1.5, 0.2, 0.1), t.normal).x; setObject;\n    t.tmp = box(ro+vec3(1.4, 0.0, 0.0), rd, vec3(0.1, 0.2, 1.5), t.normal).x; setObject;\n    mat2 r = rot(-0.1);\n    ro.xz *= r;\n    rd.xz *= r;\n    t.tmp = hitAC(ro-vec3(-0.8, -0.05, -0.2), rd, t.normal, t.color); setObject\n    t.tmp = hitAC(ro-vec3(-0.4, -0.05, -0.2), rd, t.normal, t.color); setObject\n    t.color = vec3(0, 0.8, 0);t.tmp = box(ro-vec3(-0.495, 0.29, -0.3), rd, vec3(0.5, 0.0393, 0.1), t.normal).x; setObject\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}\nfloat hitHouse(in vec3 ro, in vec3 rd, out vec3 normal, out vec3 color) {\n    //19 objects\n    ro.y -= 4.2;\n\tbool boundHit = bound(ro-vec3(0.0, 1.4, 0.0), rd, vec3(1.5, 7., 1.5));\n    if (!boundHit) return -1.0;\n    initInst\n\tt.color = vec3(0.8);\n    t.tmp = box(ro, rd, vec3(1.5, 5.2, 1.5), t.normal).x; setObject\n    t.tmp = box(ro-vec3(-0.18, 0.123, -0.18), rd, vec3(1.18, 0.123, 1.18), t.normal).x; setObject\n    t.tmp = box(ro-vec3(-0.18, 0.123, -0.18), rd, vec3(1.18, 0.123, 1.18), t.normal).x; setObject\n    t.tmp = box(ro-vec3(0.0, 0.9, 0.0), rd, vec3(1.5, 0.815, 1.5), t.normal).x; setObject\n    t.tmp = hitR1(ro-vec3(0.0, 1.0, 0.0), rd, t.normal, t.color); setObject\n    normal = s.normal;\n    color =  s.color;\n\treturn s.d0;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const float camSize = 10.0;\nconst int size = 2;\nstruct hitt {\n\tfloat dist;\n    vec3 normal;\n    vec3 p;\n    vec3 color;\n};\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nhitt hitScene(in vec3 ro, in vec3 rd) {\n    ro.y -= 1.0;\n    float d0 = 100000.;\n    vec3 tmpNormal = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 tmpColor = vec3(0);\n    vec3 color = vec3(0);\n    //A grid of 5x5 house instances\n    for (int x = -size; x < size+1; x += 1) {\n        for (int y = -size; y < size+1; y += 1) {\n            float b = hitHouse(ro+vec3((hash(vec2(x+5, y+1))-0.5)*1., 0, (hash(vec2(x+20, y+20))-0.5)*1.)+vec3(x*3, 0, y*3), rd, tmpNormal, tmpColor);//box(ro+vec3(float(x), 0.0, float(y)), rd, vec3(0.1, 2.0, 0.1)).x;\n            if (b != -1.0 && b < d0) {d0 = b;normal = tmpNormal;color=tmpColor;}\n        }\n    }\n    float g = box(ro-vec3(50., -1, 50.), rd, vec3(100, 0.1, 100), tmpNormal).x;\n    if (g != -1.0 && g < d0) {d0 = g;normal=tmpNormal;color=vec3(1.0, 0.5, 0.5);}\n    if (d0 > maxDist-1.0) hitt(-1., vec3(0), vec3(0), vec3(0));\n    return hitt(d0, normal, ro+rd*d0, color);\n}\nvec3 rus(vec2 seed) {\n    float u = hash(seed);\n    float v = hash(seed+2.);\n    float theta = u * 2.0 * 3.1415;\n    float phi = acos(2.0 * v - 1.0);\n    float r = pow(hash(seed+1.), 0.33333333);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r * sinPhi * cosTheta;\n    float y = r * sinPhi * sinTheta;\n    float z = r * cosPhi;\n    return (vec3(x, y, z));\n}\nvec3 sky(in vec3 rd) {\n    return vec3(1);\n}\nvec3 color(in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 v = vec3(1.0);\n    for (int i = 0; i < 10; i += 1) {\n    \thitt h = hitScene(ro, rd);\n        if (h.dist >= maxDist) {\n        \tv *= sky(rd);\n            break;\n        }\n        ro = (ro+rd*h.dist)+(h.normal*0.001);\n        vec3 target = h.normal+(rus(uv));\n        rd = target;\n        v *= (h.color);\n    }\n\treturn vec3(v);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = (iMouse.xy/iResolution.xy)-0.5;\n    if (iFrame == 0) mouse = vec2(0, 5);\n    float r = iResolution.x/iResolution.y;\n    mouse *= (r)*1.;\n    float seed = (sin(iTime)*100.);\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    uv += (vec2(hash(uv+seed), hash(uv+1.0+seed))-0.5)/iResolution.xy;\n    vec3 ro = vec3(sin(mouse.x*5.)*camSize, mouse.y*camSize, cos(mouse.x*5.)*camSize);\n    vec3 at = vec3(0.0, 0.0, 0.0);\n    at += vec3(-0.75, 6., -0.75);\n    ro += vec3(-0.75, 6., -0.75);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n    vec3 col = color(ro, rd, uv+seed);\n    if (iMouse.z < 1.0) {\n        vec4 old = texture(iChannel0, (fragCoord.xy/iResolution.xy));\n        fragColor = vec4(((col)+old.xyz),old.w+1.);\n    } else {\n        fragColor = vec4(col,1.0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}