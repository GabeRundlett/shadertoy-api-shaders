{
    "Shader": {
        "info": {
            "date": "1726232400",
            "description": "originals https://www.shadertoy.com/view/MfjfzW",
            "flags": 0,
            "hasliked": 0,
            "id": "X3fcD7",
            "likes": 3,
            "name": " colorful Kaleidoscope 7",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 82
        },
        "renderpass": [
            {
                "code": "float de(vec3 p)\n{\nvec3 q=vec3(p.x,0.3*sin(10.0*(1.0+p.x)+iTime),0.3*cos(p.x));\n\nfloat d1=length(vec2(length(p.xz)-0.5,p.y))-0.05;\nfloat d2=length(vec2(length(p.xy)-0.5,p.z))-0.05;\nfloat d3=length(vec2(length(p.yz)-0.5,p.x))-0.05;\nreturn min(min(d1,d2),d3);\n}\n#define EPS  0.001\nfloat tr(in vec3 p,in vec3 dir, out vec3 target)\n{\nfloat td=0.0;\nfor(int i=0;i<50;i++){\nfloat d=de(p);\ntd+=d;\np+=d*dir;\nif(d<EPS){\ntarget=p;\nreturn td;\n}\n}\nreturn td;\n}\nvec4 mul4(vec4 a,vec4 b)\n{\nreturn vec4(cross(a.xyz,b.xyz)+a.w*b.xyz+b.w*a.xyz,a.w*b.w-dot(a.xyz,b.xyz));\n}\nvec3 rot(vec3 p,vec3 dir,float ang)\n{\nfloat cosha=cos(ang*0.5),sinha=sin(ang*0.5);\n\nvec4 rot=vec4(sinha*dir,cosha);\nvec4 q=mul4(rot,vec4(p,0.0));\nrot.zyx=-rot.xzy;\nq=mul4(q,rot);\nreturn q.xyz;\n}\nvec3 roty(float a,vec3 p)\n{\nmat2 m=mat2(cos(a),-sin(a),sin(a),cos(a));\nvec2 xz=m*p.xz;\nreturn vec3(xz.x,p.y,xz.y);\n}\nvec3 rotdir=normalize(vec3(1.0,1.0,1.0)),light=normalize(vec3(-1.0,1.0,4.0)),eye=vec3(0.0,0.0,8.0);\n#define resolution iResolution.xy\n#define time iTime\nvec3 rotdir2=normalize(vec3(1.0,0.0,1.0)),light2=normalize(vec3(-1.0,1.0,4.0)),eye2=vec3(0.0,0.0,8.0);\nvec2 rotate(vec2 p, float a)\n{\nreturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n \n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n));\n}\n \n// 2D random numbers\nvec2 rand2(in vec2 p)\n{\nreturn fract(vec2(sin(p.x * 1.32 + p.y * 54.077), cos(p.x * 91.32 + p.y * 9.077)));\n}\n \n// 1D noise\nfloat noise1(float p)\n{\nfloat fl = floor(p);\nfloat fc = fract(p);\nreturn mix(rand(fl), rand(fl + 31.0), fc);\n}\n \n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x)\n{\nvec2 p = floor(x);\nvec2 f = fract(x);\n\nvec2 res = vec2(8.0);\nfor(int j = -1; j <= 1; j ++)\n{\nfor(int i = -1; i <= 2; i ++)\n{\nvec2 b = vec2(i, j);\nvec2 r = vec2(b) - f + rand2(p + b);\n\n// chebyshev distance, one of many ways to do this\nfloat d = max(abs(r.x), abs(r.y));\n\nif(d < res.x)\n{\nres.y = res.x;\nres.x = d;\n}\nelse if(d < res.y)\n{\nres.y = d;\n}\n}\n}\nreturn res.y - res.x;\n}\n#define flicker (noise1(time * 2.0) * 0.9 + 0.5)\n\nmat2 rotate(float a) {\nfloat c = cos(a),\ns = sin(a);\nreturn mat2(c, -s, s, c);\n}\n#define PI 3.14159265359\n\nvec3 pal2( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 4.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal2( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\nvec2 uv3 = (2. * gl_FragCoord.xy - resolution) / resolution.y;\nvec3 col3;\nvec3 target2;\n    vec3 p2=vec3(uv3,1.0);\n\np2=rot(-p2,rotdir2,-time);\n    eye2=rot(-eye2,rotdir2,-time);\nvec3 dir2=normalize(p2-eye2);\nfloat d2=tr(p2,dir2,target2);\n    float d0a=de(target2);\n    float dxa=de(vec3(target2.x+EPS,target2.y,target2.z))-d0a;\n    float dya=de(vec3(target2.x,target2.y+EPS,target2.z))-d0a;\nvec3 col=vec3(0.);\nif(d2<2.0){\nvec3 norm2=normalize(vec3(dxa,dya,EPS));\n\nlight2=rot(light2,rotdir2,time);\nlight2 = reflect(-light,norm2);\nfloat l2=dot(light2,norm2);\nl2+=pow(l2,80.0);\ncol3 = vec3(l2);\n}\n       \n        vec3 color = vec3(0.);\nvec3 rd = vec3(uv, -1.);\n\nfloat s = .5;\nfor (int i = 0; i < 8; i++) {\nrd = abs(rd) / dot(rd, rd); // kali iteration!! Thanks Kali\nrd -= s;\n\n\ns *= .8;\nfloat b = .005;\ncolor.gb += .014 / max(abs(rd.x*.8), abs(rd.y*.8));\ncolor.rb += .015 / max(abs(rd.y*0.6), abs(rd.z*0.6));\ncolor.rg += .01 / max(abs(rd.x), abs(rd.z));\n/*color.gb += smoothstep(.5 + b, .5, max(abs(uv.x), abs(uv.y))) *\nsmoothstep(.45, .45 + b, max(abs(uv.x), abs(uv.y)));*/\n}\ncolor *= 0.4;\n       \n       \n        vec2 uv2 = gl_FragCoord.xy / resolution.xy;\nuv2 = (uv - 0.5) * 2.0;\nvec2 suv = uv2;\nuv2.x *= resolution.x / resolution.y;\n        vec3 col2;\nvec3 target,p=vec3(uv,1.0);\np=rot(p,rotdir,time);\neye=rot(eye,rotdir,time);\nvec3 dir=normalize(p-eye);\nfloat d=tr(p,dir,target),d0=de(target),dx=de(vec3(target.x+EPS,target.y,target.z))-d0,dy=de(vec3(target.x,target.y+EPS,target.z))-d0;\nvec3 col4=vec3(0.);\nif(d<3.0){\nvec3 norm=normalize(vec3(dx,dy,EPS));\n\nlight=rot(light,rotdir,time);\nlight = reflect(-light,norm);\nfloat l=dot(light,norm);\nl+=pow(l,80.0);\ncol = vec3(l);\n}\n   \n\nfloat v = 0.0;\n\n\n\n//uv += time * 0.01;\nuv.x += sin(time) * 0.1;\n\n// add some noise octaves\nfloat a = 0.6, f = 1.0;\n\nfor(int i = 0; i < 5; i ++) // 4 octaves also look nice, its getting a bit slow though\n{\nfloat v1 = voronoi(uv * f + 1.0);\nfloat v2 = 0.0;\n\n// make the moving electrons-effect for higher octaves\nif(i > 0)\n{\n// of course everything based on voronoi\nv2 = voronoi(uv * f * 1.5 + 5.0 + time);\n\nfloat va = 0.0, vb = 0.0;\nva = 1.0 - smoothstep(0.0, 0.1, v1);\nvb = 1.0 - smoothstep(0.0, 0.08, v2);\nv += a * pow(va * (0.5 + vb), 2.0);\n}\n\n// make sharp edges\nv1 = 1.0 - smoothstep(0.0, 0.3, v1);\n\n// noise is used as intensity map\nv2 = a * (noise1(v1 * 5.5 + 0.1));\n\n\nif(i == 0)\nv += v2 * flicker;\nelse\nv += v2;\n\nf *= 3.0;\na *= 0.7;\n}\n \n\nv *= exp(-0.6 * length(suv)) * 0.8;\n\n\nvec3 cexp = vec3(1.0, 1., 1.0);\ncexp *= 1.3;\n col4 = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\ncol3*=col4*2.*vec3(0.4,0.3,1.);\ncol*=col4*2.*vec3(0.0,1.3,0.);\n\n\n    uv.x *= iResolution.x / iResolution.y;\n     uv.xy*=mat2(cos(iTime),sin(iTime), -sin(iTime), cos(iTime));\n    // Parameters for the Venus flower\n    float earthRadius = 0.4+cos(iTime);\n    float venusRadius = 0.28+sin(iTime);\n    float earthPeriod = 1.0;\n    float venusPeriod = 0.615;  // Approximate ratio of Venus' orbital period to Earth's\n       float d3;\n    // Visualization parameters\n    float lineIntensity = 0.00005;  // Reduced from 0.0003\n    float lineWidth = 10.0;  // Adjust for thicker or thinner lines\n    float fadeSpeed = 50.0;  // Speed of pattern build-up\n    \n    vec3 col5 = vec3(0.0);\n    \n    // Calculate the number of steps based on current time\n    float maxSteps = 1000.0;\n    float steps = min(iTime * fadeSpeed, maxSteps);\n    \n    // Draw the path\n    for (float i = 0.0; i < steps; i += 2.5)\n    {\n        float t = i / maxSteps * 10.0 * PI;  // 8 cycles for a complete flower\n        \n        vec2 earthPos = vec2(\n            earthRadius * cos(2.0 * PI * t / earthPeriod),\n            earthRadius * tan(2.0 * PI * t / earthPeriod)\n        );\n        \n        \n        vec2 venusPos = vec2(\n            venusRadius * tan(2.0 * PI * t / venusPeriod),\n            venusRadius * sin(2.0 * PI * t / venusPeriod)\n        );\n         \n        vec2 p = venusPos + earthPos;\n  \n        \n       d3 = length(uv - p);\n        \n        col5 += lineIntensity / (d3* d3 + 0.000021) * lineWidth; // Adjusted accumulation\n          \n    }\n    col5 *= spectrum(d3 * 1. - .6);\n    // Tone mapping to prevent oversaturation\n    col5 = 1.0 - exp(-col5 * 0.7);\n    \n\n    fragColor= vec4(col3+col+color*col5*0.5, 0.);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}