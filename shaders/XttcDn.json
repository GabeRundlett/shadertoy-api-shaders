{
    "Shader": {
        "info": {
            "date": "1533991924",
            "description": "Meditating on the way home from work.",
            "flags": 96,
            "hasliked": 0,
            "id": "XttcDn",
            "likes": 9,
            "name": "[SH18] Commute",
            "published": 3,
            "tags": [
                "human",
                "sh18"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 700
        },
        "renderpass": [
            {
                "code": "/*\n\nHUMAN SDF SCULPT + PROCEDURAL TEXTURES\n\nI gave up on this one after a few days because I felt like it wasn't going anywhere, but\nI jumped back on to add some polish on the last couple of days before the deadline just\nso I have something to enter. I really wanted to find a way to make something more\nrealistic looking, but I think there's a limit to what I can do fully procedurally.\n\n*/\n\n\nconst float zoom = 2.; // should look more natural with a longer zoom\n\n\n// smooth abs\nfloat sabs( float a, float r )\n{\n    return length(vec2(a,r))-r*.2; // offset it a little to fight shrinkage!\n}\n\nfloat smax( float a, float b, float r )\n{\n    // average of a and b, plus smooth-abs of half the difference between them\n    return (a+b)/2. + sabs( (a-b)/2., r );\n}\n\nfloat smin( float a, float b, float r )\n{\n    return (a+b)/2. - sabs( (a-b)/2., r );\n}\n\n\n// From my Humanoid Silhouettes shader\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1)*23.+phase)*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    torso = smax( torso, uv.y-1.5, .2/4. );\n    torso = smax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = smin(head,neck,.04);\n    f = smin(f,torso,.02/4.);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = smin(f,leg,.2*Rand(2)/4.);\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n\nfloat SDF_Character( vec3 _pos )\n{\n    float breathe = (.5+.5*sin(iTime*2.));\n               \n\t#define plane(n,p) (dot(pos-p,normalize(n)))\n    #define sphere(c,r) (length(pos-c)-r)\n    #define cylinder(a,p,r) (sqrt(dot(pos-p,pos-p) - dot(pos-p,a)*dot(pos-p,a)/dot(a,a))-r)\n    \n    // horizontal symmetry (smooth so no crease, though this makes coords near the seam a bit squishy)\n    vec3 pos = _pos;\n    pos.x = sabs( plane(vec3(1,0,0),vec3(0)), .05 );\n// actually may want to replace this with abs^ - cannot get the right softness for everything, so just force me to use flat planes on seam\n    \n    float f =\n    smin(smin(\n        // head\n        smax(smax(smax(smax(\n            // front\n            smax(smax(smax(\n                smin(smin(\n                    smax(\n                        // cheek/forehead plane\n                        plane(vec3(.5,0,-1),vec3(0)),\n                        // chin indent\n                        plane(vec3(.5,-.2,-1),vec3(0,-.1,0)),\n                    \t.003\n                    ),\n                    // nose\n                    smax(\n                        plane(vec3(0,-1,-.5),vec3(0,.03,-.16)),\n                        plane(vec3(1,.1,-.2),vec3(0,.03,-.16)),\n                        .004\n                    ), .004 ),\n                    // mouth bulge\n                    sphere(vec3(.03,-.087,.035),.02), .006\n                    //smax(\n/*                        sphere(vec3(.03,-.09,.02),.02\n                    ), .0001*/\n                ),\n                // mouth\n                -smax(\n                    //-sphere(vec3(.03,-.09,.02),.02*abs(sin(iTime*4.))), \n                    //cylinder(vec3(0,),vec3(.03,-.09,.02),.02),\n                    plane(vec3(-.1,.5,1),vec3(0,-.09,.018)),\n                    plane(vec3(-.0,-.5,1),vec3(0,-.09,.018)),\n                    .0005\n                ), .0005),\n\t\t\t\t// cheek indent\n\t\t\t\t-sphere(vec3(.13,-.08,-.03),.095+.007*breathe), .003),\n                // eye socket\n                -sphere(vec3(.08,0,.0),.05), .003\n            ),\n            // side\n            plane(vec3(1,-.3,-.1),vec3(.11,0,0)), .02 ),\n            // top\n            plane(vec3(.5,1,0),vec3(0,.2,0)), .04 ),\n\t\t\tsmin(\n\t            // jaw\n            \tplane(vec3(.5,-1,.4),vec3(0,-.18,0)),\n                // neck\n                cylinder(vec3(0,1,-.1),vec3(0,-.15,.2),.08),\n                .03\n            ), .003 ),\n            // back of head\n            plane(vec3(0,0,1),vec3(0,0,.3)), .06 ),\n        \n        // torso\n        smax(smax(smax(\n            // chest\n            plane(vec3(.1,.2,-1),vec3(0,-.15,.1)),\n\t\t\t// back\n            plane(vec3(.1,.5,1),vec3(0,-.15,.25)), .01 ),\n            // top of shoulders\n            plane(vec3(.2,1,0),vec3(0,-.15,.1)), .04 ),\n            // side of shoulders\n            plane(vec3(1,0,0),vec3(.28,-.15,.1)), .04 ),\n        \n        .01 ),\n         \n         // eyes\n         sphere(vec3(.05,0,.065),.018), .002\n         \n    );\n    \n    // add some bulge to the hat\n    pos = _pos;\n    float haty = pos.y+pos.z*.4-.08; // not an exact match to texture but good enough\n    f -= .01*smoothstep(.0,.02,haty)*(.2+texture(iChannel1,pos.xyz*15./32.).r);\n\n    return f;\n}\n\n\nfloat SDF_Cushions( vec3 pos )\n{\n    return\n        smax(\n            abs(fract((pos.x-.3)/.6)-.5)*.6-.28,\n            smax(\n                abs(pos.y+.4)-.2,\n                abs(dot(pos,normalize(vec3(0,-.1,1)))-.38)-.05,\n                .015\n\t\t\t),\n            .015\n    \t);\n}\n\n\nfloat SDF_Background( vec3 pos )\n{\n/*\n    vec3 windowPos = pos + dir*max((.4-pos.z)/dir.z,-(2.-pos.z)/dir.z);\n    windowPos.y = abs(windowPos.y-.15)-.2;\n    windowPos.x = abs(fract(windowPos.x/1.6+.5)*1.6-.8)-.55;\n    float windows = ((windowPos.x>0.&&windowPos.y>0.)?length(windowPos.xy):max(windowPos.x,windowPos.y))\n        \t\t\t\t//^ I feel like there's a way to do this without the conditional\n        \t\t\t- .1;\n*/\n    \n    vec3 apos = abs(pos-vec3(0,-.1,-.8));\n    return\n        min(//min(\n            smin(\n                smax(\n                    max(\n                        // outside of train\n                        max(apos.y-1.05,apos.z-1.25),\n                        // inside\n                        -max(apos.y-1.,apos.z-1.2)\n                    ),\n                    // window hole\n                    -smax(abs(fract(pos.x/1.6+.5)*1.6-.8)-.65,abs(pos.y-.15)-.3,.02),\n                    .002\n                ),\n                // plastic form around seats\n                smax(\n                    smax(\n\t                    abs(fract((pos.x-.3)/.6)-.5)*.6-.298,\n                        pos.y+.18,\n                        .005\n                    ),\n                    max(\n                        // outside of train\n                        max(apos.y-1.05,apos.z-1.25),\n                        - (dot(pos,normalize(vec3(0,-.1,1)))-.38)\n                    ),\n                    .002\n                ),\n                .002\n            ),\n            SDF_Cushions(pos)\n//            ),length(pos-vec3(.0,-.25,-.15))-.05\n        );\n}\n\n\nfloat SDF( vec3 pos )\n{\n    float f = SDF_Character(pos);\n\n\tf = min(f,SDF_Background(pos));\n\n    return f;\n}\n\nfloat Trace( vec3 start, vec3 dir, float minT, float maxT, float pixelScale )\n{\n    float epsilon = pixelScale*1.;\n    \n    float t = minT;\n    \n    float dist;\n    for ( int i=0; i < 250; i++ ) // this can be really big as long as epsilon is high enough\n    {\n        dist = SDF( start + t*dir );\n        if ( dist < epsilon*t || t > maxT ) return t;\n        t += dist;\n    }\n    \n    if ( dist < 0.1 && t < maxT )\n    {\n        t += dist;\n        float dist2 = SDF( start + t*dir );\n        \n        // try to guess where the surface might be, by extrapolating as if SDF is planar here\n        t += max(0.,dist2*dist/(dist-dist2)); //(dist-dist2)/dist = change in df / distance stepped, so divide DF by this to find distance we should step\n        \n        return t;\n    }\n    \n    return maxT; // todo: maybe return best-guess t when we run out of iterations?\n}\n\n\nvec3 GetNormal( vec3 pos, float sampleSpacing )\n{\n    vec2 d = vec2(-1,1)*sampleSpacing;\n    \n    return normalize(\n        SDF( pos + d.xxx )*d.xxx +\n        SDF( pos + d.yyx )*d.yyx +\n        SDF( pos + d.yxy )*d.yxy +\n        SDF( pos + d.xyy )*d.xyy\n        );\n}\n\n\nvec3 Sky( vec3 ray, float blur )\n{\n    vec3 col = vec3(.5,.6,.7);\n\n    // correct blur amount for perspective (approx)\n    blur /= abs(ray.z);\n    \n    // view outside train\n    vec2 pray = ray.xy/abs(ray.z);\n    col = mix( vec3(.1,.2,.4), col, smoothstep(-blur,blur,pray.y-.05*sin(ray.x*6.+iTime*.02)) );\n    col = mix( vec3(.1,.2,.3), col, smoothstep(-blur,blur,pray.y+.05-.1*sin(ray.x*3.+iTime*.04)) );\n\n    // buildings - the sides of these don't blur as quickly, so get vertical streaks in blurred reflections\n    float xx = pray.x*32.+iTime*.2;\n    col = mix( vec3(.05,.1,.2), col, smoothstep(-blur,blur,pray.y-.025*sin((floor(xx)+smoothstep(0.,blur,fract(xx)))*2.)) );\n    xx = pray.x*16.+iTime*.4;\n    col = mix( vec3(.05,.08,.16), col, smoothstep(-blur,blur,pray.y+.02-.05*sin((floor(xx)+smoothstep(0.,blur,fract(xx)))*2.)) );\n    xx = pray.x*8.+iTime*.8;\n    col = mix( vec3(.05,.06,.12), col, smoothstep(-blur,blur,pray.y+.06-.1*sin((floor(xx)+smoothstep(0.,blur,fract(xx)))*2.)) );\n    \n    return col;//*1.5;\n}\n\n\nvec3 SampleLight( vec3 pos, vec3 dir, float blur )\n{\n//blur = fract(iTime/5.); // test (this look so cool)\n    vec3 col = Sky( dir, blur );\n    \n    // occlusion for train carraige\n    vec3 windowPos = pos + dir*max((.4-pos.z)/dir.z,-(2.-pos.z)/dir.z);\n    windowPos.y = abs(windowPos.y-.15)-.2;\n    windowPos.x = abs(fract(windowPos.x/1.6+.5)*1.6-.8)-.55;\n    float windows = ((windowPos.x>0.&&windowPos.y>0.)?length(windowPos.xy):max(windowPos.x,windowPos.y))\n        \t\t\t\t//^ I feel like there's a way to do this without the conditional\n        \t\t\t- .1;\n    float blur2 = blur*1. / abs(dir.z);\n    float windowMask = smoothstep( blur2, -blur2, windows );\n    \n    // fade to average colour down the train\n    windowMask = mix( .0, windowMask, smoothstep(.0,blur,abs(dir.z)) );\n    \n    col = mix( vec3(.04,.035,.03)+vec3(.04,.03,.02)*dir.y, col, windowMask );\n\n    // fade to average colour down the train\n    col = mix( col, .2*vec3(.5,.6,.7), pow(smoothstep(0.,1.,abs(dir.x)),1./(blur*blur)) );\n    \n    // add on train's light sources\n    for ( int i=-2; i < 2; i++ )\n    {\n        vec3 lightPos = vec3(float(i)*1.5+.3,.5,-.5);\n        vec3 toLight = lightPos-pos;\n        float lightDist = length(toLight);\n        vec3 lightDir = toLight/lightDist;\n        float shape = pow(max(0.,dot(lightDir,dir)),1./(blur*blur))/blur;\n        \n        // cast a humanoid shadow, from someone moving near the light\n        float t = iTime*.3*(1.+fract(1.618*float(i)));\n        t += sin(t);\n        vec3 pp = pos + vec3(\n            \t\t\t\t1.5*sin(t/1.5+float(i)),\n            \t\t\t\t1.5+.05*sin(t*3.),\n            \t\t\t0);\n        float shadow = Humanoid( vec2( dot(pp,normalize(cross(vec3(0,1,0),lightDir))), pp.y ), float(i) );\n\t\tshadow = smoothstep( -1., 1., shadow*lightDist/.08 );\n        \n        col += .4*vec3(1.,.9,.8) * shadow * shape / (lightDist*lightDist);\n    }\n\n    // add a light for her phone\n    /*{\n        vec3 lightPos = vec3(0,-.2,-.1);\n        vec3 toLight = lightPos-pos;\n        float lightDist = length(toLight);\n        vec3 lightDir = toLight/lightDist;\n        float shape = pow(max(0.,dot(lightDir,dir)),1./(blur*blur))/blur;\n        col += .02*vec3(.6,.8,1) * shape / (lightDist*lightDist);\n    }*/\n    \n/*    // occlusion from passengers\n    vec3 uvw = pos-vec3(1,-1,3.*sin(iTime));// aaaarg this projection's flipping and shit...\n    vec2 uv = uvw.xy-dir.xy*(uvw.z)/abs(dir.z);\n    float sdf = Humanoid( uv, 0. );\n    col *= smoothstep(-blur2,blur2,sdf/4.);*/\n    \n    // occlusion for character\n    \n    return col;\n}\n\n\nstruct HairCard {\n    vec3 centre;\n    float scale;\n    vec3 colour;\n};\n\nconst vec3 hairCol1 = .1*vec3(.15,.04,.015);//vec3(.2,.3,1);\n\nHairCard hairCards[] = HairCard[](\n    \t HairCard( vec3(-.12,.02,.13), 0.021, hairCol1 )\n    \t,HairCard( vec3(-.12,.01,.12), 0.022, hairCol1 )\n    \t,HairCard( vec3(-.11,.0,.10), 0.02, hairCol1 )\n    \t,HairCard( vec3(-.11,.03,.09), 0.021, hairCol1 )\n    \t,HairCard( vec3(-.11,.01,.08), 0.019, hairCol1 )\n    \t,HairCard( vec3(-.12,.02,.075), 0.018, hairCol1 )\n    \t,HairCard( vec3(-.1,.03,.07), 0.02, hairCol1 )\n    \n    \t,HairCard( vec3(.1,-.01,.13), 0.021, hairCol1 )\n    \t,HairCard( vec3(.1,-.02,.12), 0.022, hairCol1 )\n    \t,HairCard( vec3(.11,-.03,.10), 0.02, hairCol1 )\n    \t,HairCard( vec3(.08,.0,.09), 0.021, hairCol1 )\n    \t,HairCard( vec3(.09,-.02,.08), 0.019, hairCol1 )\n    \t,HairCard( vec3(.1,-.0,.075), 0.018, hairCol1 )\n    \t,HairCard( vec3(.08,.01,.07), 0.02, hairCol1 )\n    );\n\n\nvec4 DrawHairCard( HairCard card, int seed, vec3 camPos, vec3 ray, float far )\n{\n    vec3 c = card.centre-camPos;\n    \n    // draw on a concentric sphere round the camera\n    float t = length(c);\n    \n    // alternatively, draw on a plane facing the camera\n    //float t = dot(c,c)/dot(ray,c);\n    \n    if ( t > far ) return vec4(0);\n    \n    vec3 pos = ray*t - c; // position relative to card centre\n    pos /= card.scale;\n    \n    // draw a blob of hair\n    vec4 col = vec4(0);\n    \n    for ( int i=0; i < 3; i++ )\n    {\n        float noise = .5+.5*sin(dot(pos,vec3(2,3,5))+float(seed))*cos(dot(pos,vec3(7,-5,3))-float(seed*5));\n    //    float noise2 = .5+.5*sin(dot(pos,vec3(-2,7,-3))+float(seed))*cos(dot(pos,vec3(-2,-3,5))-float(seed*5));\n        float r = length(pos)+noise*.2;\n        \n        vec3 ccol = card.colour * (smoothstep(-.5,.5,pos.y)*2.+.2);\n        ccol *= float(i+1)/3.;\n        \n        col = mix( col, vec4(ccol,1), smoothstep(.3,.08,abs(r-1.))*(.8+.2*sin(r*50.+10.*pos.y)) );\n    // todo: replace this with a strip of a high-frequency texture\n    // fade as a bias, so we get sticky out bits\n        pos.y += .5;\n        seed += 7;\n    }\n    \n    // soft alpha\n    col *= smoothstep(.0,.01,far-t);\n    \n    return col;\n}\n\n\nvoid DrawHair( inout vec3 colour, float far, vec3 camPos, vec3 ray )\n{\n    // draw a series of hair blits from far to near\n    for ( int i=0; i < hairCards.length(); i++ )\n    {\n        vec4 hairCol = DrawHairCard( hairCards[i], i, camPos, ray, far );\n        colour = colour*(1.-hairCol.a) + hairCol.rgb;\n    }\n}\n\n\n\nvec2 PosToUV( vec3 pos )\n{\n\t//return (pos/.3+.5).yx; // neatly covering head!\n\treturn ((pos+vec3(0,.08,0))/.5+.5).yx; // head & shoulders\n}\n\nfloat SDFMap( vec3 pos )\n{\n    return SDF_Character(pos) - texture(iChannel0,PosToUV(pos)).a;\n}\n\nvec3 GetNormalMap( vec3 pos, float sampleSpacing )\n{\n    vec2 d = vec2(-1,1)*sampleSpacing;\n\n/*this is bad, because it can get normals pointing away from the ray!\n    \n    vec3 norm = vec3(0);\n    \n    norm += SDFMap( pos + d.xxx ) * d.xxx;\n    norm += SDFMap( pos + d.yyx ) * d.yyx;\n    norm += SDFMap( pos + d.yxy ) * d.yxy;\n    norm += SDFMap( pos + d.xyy ) * d.xyy;\n*/\n    \n    vec3 mapNorm = vec3(0);\n    \n    mapNorm += texture( iChannel0, PosToUV( pos + d.xxx ) ).a * d.xxx;\n    mapNorm += texture( iChannel0, PosToUV( pos + d.yyx ) ).a * d.yyx;\n    mapNorm += texture( iChannel0, PosToUV( pos + d.yxy ) ).a * d.yxy;\n    mapNorm += texture( iChannel0, PosToUV( pos + d.xyy ) ).a * d.xyy;\n    \n    vec3 norm = vec3(0);\n    \n    norm += SDF( pos + d.xxx ) * d.xxx;\n    norm += SDF( pos + d.yyx ) * d.yyx;\n    norm += SDF( pos + d.yxy ) * d.yxy;\n    norm += SDF( pos + d.xyy ) * d.xyy;\n\n    norm -= mapNorm-norm*dot(mapNorm,norm)/dot(norm,norm);\n\n// better, but can still get bad normals => maybe just clamp or something?\n// absing ndotr looks pretty bad, clamping looks ok\n    \n    return normalize( norm );\n}\n\n\nstruct MaterialSample\n{\n    vec3 albedo;\n\tvec3 specularColour;\n    float roughness;\n    vec3 normal; // modified from surface normal\n    // todo: subsurface scattering - she's black so I can perhaps get away without this.\n};\n\n    \nMaterialSample BackgroundMaterial( vec3 pos )\n{\n    if ( SDF_Cushions(pos) < .003 )\n    {\n        vec3 pattern = vec3(.03,.05,.15);\n        \n        vec3 uvw = pos/.05;\n        uvw.y += uvw.z*.1; // reduce stretching on the top\n        uvw.x -= pos.x*uvw.z*.1; // reduce stretching on the top\n        uvw = fract(uvw);\n        if ( fract(uvw.x+abs(uvw.y-.333)) < .333 ) pattern = vec3(.4,.05,.02);\n        if ( fract(uvw.x-abs(fract(uvw.y+.333)-.667)-.333) < .333 ) pattern = vec3(.2,.15,.02);\n        \n        vec3 norm = GetNormal(pos,.001);\n        \n        norm.xy += .2*sin(pos.xy*6.283/.003);\n        norm = normalize(norm);\n        \n        return MaterialSample( pattern, vec3(.004), 1., norm );\n    }\n    else\n    {\n    \treturn MaterialSample( vec3(.7), vec3(.004), .2, GetNormal(pos,.001) );\n    }\n}\n\nMaterialSample SampleMaterial( vec3 pos )\n{\n    if ( SDF_Background(pos) < .01 )\n    {\n        return BackgroundMaterial(pos);\n    }\n    \n\tvec4 tap = texture(iChannel0,PosToUV(pos));\n    \n    vec3 normal = GetNormalMap( pos, .0001 ); // todo: add height map to these samples\n    \n    float roughness = tap.z;\n    \n    vec2 colour2D = pow(floor(fract(pos.xy/.1)*3.)/2.,vec2(1)); // 2D colour\n    if ( dot(fract(pos.xy/.1),vec2(1)) < .33 ) colour2D = skinTone;\n//testCol = pow((testCol.x+testCol.y*4.)/5.,1.5)*skinTone/.15; // gradient in skin-tone direction\n    \n    \n    colour2D = tap.xy;\n    \n    vec3 albedo = primaries[0]*colour2D.x + primaries[1]*colour2D.y + primaries[2];\n\n    vec3 spec = vec3(.004);\n    \n//    float rough = .8;\n    \n//    return MaterialSample( vec3(.5), spec, 1., normal ); // white box\n    return MaterialSample( albedo, spec, roughness, normal );\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n/*    float sdf = SDF(vec3((fragCoord-iResolution.xy*.5)/iResolution.y,0));\n    fragColour = vec3(\n        \t\t\t.5+.5*sdf/(abs(sdf)+.005),\n        \t\t\tsmoothstep(.4,.5,abs(fract(sdf/.04+.5)-.5)),\n        \t\t\tsdf*2.+.5\n        \t\t).yxxx;//yxzx;*/\n    \n    vec3 camK = vec3(.1,-.05,1);\n    \n    // add a little movement\n    camK += .03*sin(iTime*vec3(.31,.23,.37));\n    \n    if ( iMouse.z > 0. )\n    {\n\t    float a = -.7*6.283*(iMouse.x/iResolution.x-.5);\n        camK.xz = camK.xz*cos(a) + sin(a)*vec2(-1,1)*camK.zx;\n        camK.y += 2.*(iMouse.y/iResolution.y-.5);\n\t}\n    camK = normalize(camK);\n\n    vec3 camPos = -camK*.55*zoom+vec3(0,-.03,.1);\n    \n    vec3 camI = normalize(cross(vec3(0,1,0),camK));\n    vec3 camJ = cross(camK,camI);\n    \n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.y,zoom);\n    \n    float pixelScale = .2*ray.z / iResolution.y;\n    ray = ray.x*camI + ray.y*camJ + ray.z*camK;\n    ray = normalize(ray);\n    \n    float far = 1e10;\n    float t = Trace( camPos, ray, 0., far, pixelScale );\n    \n    if ( t >= far )\n    {\n        fragColour.rgb = Sky(ray, .001);\n\n    }\n    else\n    {\n        vec3 pos = camPos+t*ray;\n        \n        MaterialSample mat = SampleMaterial(pos);\n\n/*        vec3 light = mix( vec3(.1,.05,.0), vec3(.9,.95,1), max(0.,dot(mat.normal,normalize(vec3(1,3,-2)))) );\n\nLighting:\nhave a \"sample light\" function which takes an angular blur size\nsample specular in reflection direction, reduce blur at shallow angles and modulate by roughness\nsample diffuse in normal direction\nor do directional lights with shadow projection and specular\n*/\n        vec3 light = SampleLight( pos, mat.normal, 1. );\n        \n        fragColour.rgb = mat.albedo;\n        fragColour.rgb *= light;\n        \nfloat skin = smoothstep(.1,.0,abs(dot(mat.albedo-skinAlbedo,vec3(2,4,1)/7.))); // mask the skin by detecting things of similar colour\n        \n        float ndotr = min(0.,dot(mat.normal,ray));\n\n        // fake sheen effect - in reality I guess this would be a non-lambertian reflectance model\n        fragColour.rgb *= 1. - skin*pow(1.+ndotr,1.);\n        \n        vec3 fresnel = mix( mat.specularColour, vec3(1.-.5*mat.roughness), pow(1.+ndotr,5.) );\n        \n// todo, parameterise this\\/\n        vec3 reflection = SampleLight( pos, normalize(reflect(ray,mat.normal)+mat.normal*mat.roughness), mat.roughness );//*abs(dot(ray,mat.normal)) );\n        fragColour.rgb = mix( fragColour.rgb, reflection, fresnel );\n\n        \n/*        // debug colouring: normals + grid\n        vec3 triplanarFade = 1.-smoothstep(.7,.707,abs(norm));\n        vec3 grid = smoothstep(.05*triplanarFade,.1*triplanarFade,abs(fract(pos/.04+.5)*2.-1.));\n        fragColour.rgb = .5+.5*norm;\n        fragColour.rgb *= grid.x*grid.y*grid.z;*/\n    }\n    \n    \n    // add some hair\n    DrawHair( fragColour.rgb, t, camPos, ray );\n    \n\n// test the lighting environment\n//fragColour.rgb = SampleLight( camPos, ray, .01 );\n    \n    fragColour.rgb *= 1.5; // exposure\n    \n    // vignette\n    fragColour.rgb *= smoothstep( .8, 1., dot(camK,ray) );\n    \n    fragColour.rgb = pow( fragColour.rgb, vec3(1./2.2) );\n\n// debug the texture\n//fragColour.rgb = fract(texelFetch(iChannel0,ivec2(fragCoord),0).aaa/.0001);\n    \n    fragColour.a = 0.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 15689,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/outlooks/subwaytrainsoundeffect2"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// character textures\n\n// A = height\n// B = roughness\n// RG = colour, stored as warmness and coolness\n\n// could pack things in a different format, and do manual filtering when read\n// would still want height as float so can read quickly in SDF\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    //todo: only draw on first frame!\n    // DAMN! I need to wait for the textures to load!\n//    if ( iFrame > 0 ) { fragColour = texelFetch(iChannel0,ivec2(fragCoord),0); return; }\n    \n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/(iResolution.xy*.5);\n    // build the map on its side, to better fit the character's face\n\tuv = uv.yx;\n    \n//    fragColour.xy = fract(fragCoord/4.);//-.05+1.1*fragCoord/iResolution.xy);\n    \n    fragColour = vec4(0);\n    \n    float haty = dot(uv,vec2(.1,1))-.1*cos(uv.x/.2);\n    float topy = dot(uv,vec2(.1,-1))-.5;\n    if ( haty > .5 )\n    {\n        float blend = smoothstep(.5,.51,haty);\n        // colour\n        fragColour.xy = mix( fragColour.xy, vec2(.15,.15), blend ); // hat\n        \n        // roughness\n        fragColour.z = 1.;\n\n        // depth\n        fragColour.w = .003*sin(haty/.03+2.);\n        fragColour.w += .0001*(abs(sin(uv.x*6.283/.03))*sin(haty*6.283/.03)); // wool\n        fragColour.w *= blend;\n    }\n    else if ( topy > .0 )\n    {\n        // depth\n        fragColour.w = .0005*clamp((abs(topy-.01)-.01)/-.002,0.,1.);\n        fragColour.w += .0001*(abs(sin(uv.x*6.283/.02))*sin(topy*6.283/.03)); // cotton\n        \n        // roughness\n        fragColour.z = 1.;\n\n        // top\n        \n        fragColour.xy = vec2(.02,.07);\n\n        // camo pattern\n        fragColour.xy = mix( vec2(0), vec2(.2,.4), step(.5,texture(iChannel1,uv/3.+.2).r) );\n        fragColour.xy = mix( fragColour.xy, vec2(.6,1), step(.65,texture(iChannel1,uv/3.).r) );\n        \n        // print\n        vec3 uvw = vec3(uv+uv.yx*vec2(1,-1)*.1+vec2(.05,1),1).zyx;\n        fragColour.xy = mix( vec2(.8,0), fragColour.xy, step(.5,texture(iChannel2,uvw).r+.5*smoothstep(-.1,.1,max(abs(uvw.z)-.5,uvw.y-.4))) );\n    }\n    else\n    {\n        vec4 noise2 = texture(iChannel3,uv*4.);\n        \n        noise2.y = clamp(noise2.y/.7,0.,1.); // remap to use whole range\n        \n        // SKIN\n        \n        // mottled texture\n        vec2 skinVariation = noise2.xx;\n        \n        float cheekMask = smoothstep( 1., 0., length( vec2(abs(uv.x)-.2,uv.y-.1)/vec2(.2,.13) ) );\n        float noseMask = smoothstep( 1., 0., length( vec2(uv.x,uv.y-.22)/vec2(.08,.15) ) );\n        \n        skinVariation = mix( skinVariation, cheekMask*vec2(1,.5), .5 );\n        //skinVariation.y = mix( skinVariation.y, noseMask, .5 );\n        \n\t    fragColour.xy = pow(skinTone,1.25-.35*skinVariation);\n        \n        // roughness\n        fragColour.z = mix(.1,mix(.3,1.,pow(noise2.y,2.)),clamp(noise2.y/.1,0.,1.));\n        fragColour.z = mix( fragColour.z, .1, pow(noseMask,.5) );\n        \n        \n        // eye shadow\n        vec2 eyeuv = vec2(abs(uv.x),uv.y) - vec2(.18,.33);\n        float eyeMask = length(eyeuv/vec2(.08,.04));\n        \n        float eyeShadowMask = smoothstep(1.5,.5,eyeMask);\n        fragColour.xy = mix( fragColour.xy, vec2(0,.2), .3*eyeShadowMask );\n        \n        float glitter = mix(.0001,1.,step(.1,textureLod(iChannel1,uv*20.,0.).r)); // the lighting's at the wrong angle to make this work\n        fragColour.z = mix( fragColour.z, glitter, eyeShadowMask );\n        \n        \n        // eye lashes\n        float e = (1.-.3*eyeMask)*eyeuv.x/.0015;\n        float lashes = 1.-abs(sin(e));\n        \n        lashes *= smoothstep( -.0, -.03, eyeuv.y );\n        lashes *= smoothstep( 1., 1.01, eyeMask ) * smoothstep( 1.6, 1.1, eyeMask );\n        fragColour.xy = mix( fragColour.xy, vec2(.3,.2)*smoothstep( 1.2, 1.4, eyeMask ), lashes );\n        \n        // lipstick\n        vec2 lipuv = uv-vec2(0,-.025);\n        float lipMask = smoothstep(1.,0.,length(lipuv/vec2(.16,.05)));\n        \n        // add lip bumps\n        float a = (.8+.2*lipMask)*uv.x/.004;\n        float ridges = lipMask*abs(sin(a)+sin(a*1.618));\n        fragColour.w += .0001*ridges;\n\n        float lipstickMask = lipMask;\n        lipstickMask -= .05* texture(iChannel1,uv*4.).r;\n        lipstickMask += .1*(ridges-.5);\n        lipstickMask = smoothstep( 0., .3, lipstickMask );\n        \n        fragColour.z = mix( fragColour.z, .001, lipstickMask );\n        \n//        fragColour.xy = mix( fragColour.xy, mix( vec2(0,.1), vec2(.1,.2), min(1.,abs(lipuv.y)/.05)), lipstickMask );\n        fragColour.xy = mix( fragColour.xy, mix( vec2(.1,.0), vec2(.3,.1), min(1.,abs(lipuv.y)/.03)), lipstickMask );\n        \n        // darken under hair\n    }\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "const vec3 skinAlbedo = vec3(.15,.04,.015); //vec3(.05,.02,.01);\n\n        \t// have to be able to linearly combine to get skin tone: vec3(.15,.04,.015)\n        \t// or could have a 3rd value added - pure black is non-essential\n        \t// and needn't be linear, so long as it's fairly monotonic\n//        \tvec3(1,.2667,.1), vec3(0,1.-.2667,.9), vec3(0)\n//#define skinTone vec2(.15,0)\n//        \tvec3(.15,.0,.015)/.15, vec3(.0,.04,.0)/.04, vec3(0) // OOOOOOH! OOH NICE!!\n//#define skinTone vec2(.15,.04)\n//        \tvec3(.15,.030,.0)/.15, vec3(.0,.010,.015)/.015, vec3(0) // better pinks, but dives into oranges - would prefer a pink axis or something\n//#define skinTone vec2(.15,.015)\n//        \tvec3(.135,.025,.0)/.30, vec3(.015,.015,.015)/.030, vec3(0) // greys\n//#define skinTone vec2(.30,.030)\n//        \tvec3(.15,.03,.0)/.30, vec3(.0,.01,.015)/.030, vec3(0) // tweakable blue->teal (shift green values)\n//#define skinTone vec2(.30,.030)\n//        \tvec3(.135,.025,.0)/.30, vec3(.0,.5,.7), vec3(.015,.015,.015) // no black, arbitrary secondary\n//#define skinTone vec2(.30,.0)\n//        \tvec3(.15,.0,.015)/.15, vec3(.0,.15,.135)/.15, vec3(0,.04,0) // \"nice\" - but with better pink by moving green into black\n//#define skinTone vec2(.15,.04)\n//        \tvec3(.15,.0,.0)/.15, vec3(.0,.15,.15)/.15, vec3(0,.04,0) // warmer red, cooler cyan\n//#define skinTone vec2(.15,.04)\n//        \tvec3(.15,.0,.0)/.15, vec3(.0,.0,.015)/.015, vec3(0,.04,0) // OOPS! correct an error in ^, adding too much green - deep blues and purples but no whites\n//#define skinTone vec2(.15,.015)\nconst vec3 primaries[] = vec3[]( vec3(.15,.0,.0)/.15, vec3(.0,.01,.015)/.015, vec3(0,.03,0) ); // ^ add some greens to the blues\nconst vec2 skinTone = vec2(.15,.015);\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}