{
    "Shader": {
        "info": {
            "date": "1583342395",
            "description": "white : sqrt(x)\nred: X0 = approx from halfing the exponant in x mantissa\ngreen: 1 step of ( X + x/X )  / 2  Babylonian series\nblue:   2 steps ( but not sure is still gain on nowdays GPU :-) )\ndark: -log10(rel error) in range [0,10] -> blue = 5 digits or +",
            "flags": 0,
            "hasliked": 0,
            "id": "wlGSRt",
            "likes": 11,
            "name": "sqrt \"fast\" approx",
            "published": 3,
            "tags": [
                "test",
                "float",
                "exponent",
                "mantissa",
                "floatbitstoint",
                "ieee754",
                "ieee754"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2177
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/WtyXzd\n// Babylonian method: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n// converges exponentially fast once \"close enough\" to solution\n// -> use exponant in IEEE float representation for a very good estimate as X0. \n\n#define s(X)  ( X + x/(X) ) /2.  // Babylonian series\n\n  #define C(v) smoothstep( 1.5,0., abs( v - y )/fwidth(y) )\n//#define R(v) smoothstep( 1.5,0., abs( 1e2*(v-sqrt(x)) - y )/fwidth(y) )\n  #define E(v) smoothstep( 1.5,0., abs( -log2(abs( v/sqrt(x)-1.) )/log(10.) -10.*U.y )*R.y/10. )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\n    vec2  R = iResolution.xy,                       \n          U = u / R;\n    float N = 256.,\n          x = N*U.x, y = sqrt(N)*U.y,\n         // --- Good first estimate using exponant in IEEE float representation\n      // X0 = intBitsToFloat( ( ( (floatBitsToInt(x) >> 23) -127 )/2 + 127 ) << 23 ),\n      // X0 = intBitsToFloat( (   (floatBitsToInt(x) >> 24) +64 ) << 23 ),           // Indeed even better than above :-)\n         X0 = intBitsToFloat(     (floatBitsToInt(x) & 0xff000000) / 2 +(1 << 29) ), // Simplified\n      // X0 = intBitsToFloat(      floatBitsToInt(x)               / 2 +(1 << 29) ), // ( less good )\n      // X0 = uintBitsToFloat(    (floatBitsToUint(x) +  0x3F800000u ) / 2u ), // Even faster, see https://www.shadertoy.com/view/wlyXRt\n         X1 = s(X0),  //   iteration 1                                         //              and https://en.wikipedia.org/wiki/Fast_inverse_square_root\n         X2 = s(X1),  //   iteration 2                                         // invSqrt with similar cost: good for normalizations\n         X3 = s(X2);  // ( iteration 3 )\n    \n    O =  C( vec4(X0,X1,X2,X3) ); \n // O.rb += O.a;                    // if you want to display X3 as pink\n    O += C( sqrt(x)  );\n    \n    O.a = 0.;\n    O += E( vec4(X0,X1,X2,X3) )*.5; // -log10( relative error )\n    O.rb += O.a;                    \n    if (mod(u.y,R.y/10.)<1.) O += .2;// ticks per significant bit\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}