{
    "Shader": {
        "info": {
            "date": "1584821748",
            "description": "Connecting points from the spherical Fibonacci sequence",
            "flags": 0,
            "hasliked": 0,
            "id": "3slyDN",
            "likes": 24,
            "name": "Weird line thing",
            "published": 3,
            "tags": [
                "hmmm"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 597
        },
        "renderpass": [
            {
                "code": "#define M_PI 3.141592653\n\nconst float PHI = 0.5*(sqrt(5.) + 1.); \n\nvec2 fibonacci_lattice(int i, int N)\n{\n    return vec2((float(i)+0.5)/float(N), mod(float(i)/PHI, 1.)); \n}\n\nvec3 fibonacci_sphere(int i, int N)\n{\n    vec2 xy = fibonacci_lattice(i, N);\n    vec2 pt = vec2(2.*M_PI*xy.y, acos(2.*xy.x - 1.) - M_PI*0.5);\n    return vec3(cos(pt.x)*cos(pt.y), sin(pt.x)*cos(pt.y), sin(pt.y)); \n}\n\nmat4 getPerspective(float fov, float aspect, float n, float f)\n{   \n    float scale = tan(fov * M_PI / 360.) * n; \n    float r = aspect * scale, l = -r; \n    float t = scale, b = -t; \n\n\t\n    return mat4(2. * n / (r - l), 0, 0, 0,\n                0, 2. * n / (t - b), 0, 0,\n                (r + l) / (r - l), (t + b) / (t - b), -(f + n) / (f - n), -1,\n                0, 0, -2. * f * n / (f - n), 0);\n}\n\nmat4 getRot(vec2 a)\n{\n    \n   mat4 theta_rot = mat4(1, 0, 0, 0,\n                         0, cos(a.y), sin(a.y), 0,\n                         0, -sin(a.y), cos(a.y), 0,\n                         0, 0, 0, 1); \n        \n   mat4 phi_rot = mat4(cos(a.x), sin(a.x), 0, 0,\n        \t\t       -sin(a.x), cos(a.x), 0, 0,\n        \t\t        0, 0, 1, 0,\n                      \t0, 0, 0, 1); \n   return transpose(phi_rot*theta_rot);\n}\n\nmat4 getModel(vec3 dx)\n{\n   return transpose(mat4(1, 0, 0, dx.x,\n        \t   0, 1, 0, dx.y,\n               0, 0, 1, dx.z,\n               0, 0, 0, 1)); ;\n}\n\nvec3 toScreen(vec4 X)\n{\n    return vec3(iResolution.xy*(0.5*X.xy/X.w + 0.5), X.z);\n}\n\nfloat POINT(vec2 pos, float R, vec4 X)\n{\n    R *= iResolution.x;\n    vec3 spos = toScreen(X);\n    return exp(-distance(pos, spos.xy)*spos.z/R);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat interpolate(float val, vec2 p0, vec2 p1) \n{\n    return mix(p0.y, p1.y, (val-p0.x)/(p1.x-p0.x));\n}\n\nfloat interpolate3(vec2 val, vec3 p0, vec3 p1) \n{\n    return mix(p0.z, p1.z, clamp(dot(p1.xy - p0.xy, val - p0.xy)/dot(p1.xy - p0.xy,p1.xy - p0.xy), 0.,1.));\n}\n\nfloat LINE(vec2 pos, float R, vec4 X, vec4 Y)\n{\n    R *= iResolution.x;\n    vec3 spos0 = toScreen(X);\n    vec3 spos1 = toScreen(Y);\n    float d = sdSegment(pos, spos0.xy, spos1.xy)/R;\n    float depth = interpolate3(pos, spos0, spos1);\n    return exp(-d*depth-0.4*depth)+0.03*exp(-d*depth*0.05);\n}\n\n\n//a rainbow colormap from Matlab\n\nfloat base(float x) \n{\n    if ( x <= -0.75 ) return 0.0;\n    else if ( x <= -0.25 ) return interpolate( x, vec2(-0.75, 0.0), vec2(-0.25, 1.) );\n    else if ( x <= 0.25 ) return 1.0;\n    else if ( x <= 0.75 ) return interpolate( x, vec2(0.25, 1.0), vec2(0.75, 0.0) );\n    else return 0.0;\n}\n\nvec3 jet_colormap(float v)\n{\n    return vec3(base(v - 0.5),base(v),base(v + 0.5));\n}\n\nvec3 jet_range(float v, float a, float b)\n{\n    return jet_colormap(2.*clamp((v-a)/(b-a),0.,1.) - 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n \tivec2 p = ivec2(pos.xy);\n    \n    int N = iFrame%128;\n    fragColor.xyz = vec3(0.);\n    \n    mat4 perspec = getPerspective(60., iResolution.x/iResolution.y, 0.001, 10.);\n    vec2 angles = (iMouse.z>0.)?(iMouse.xy/iResolution.xy)*vec2(2.*M_PI, M_PI):vec2(iTime, M_PI*0.5+0.5*sin(iTime));\n    mat4 rot = getRot(angles);\n    mat4 sh = getModel(vec3(0.,0.,-2.));\n    vec4 pd = perspec*sh*rot*vec4(fibonacci_sphere(0, N), 1.);\n    vec4 d;\n    //rasterizer\n    for(int i = 1; i < N; i++)\n    {\n        d = perspec*sh*rot*vec4(fibonacci_sphere(i, N), 1.);\n        \n        fragColor.xyz += 2.*jet_range(sin(0.1*float(i)), -1.25, 1.25)*(LINE(pos, 0.002, d, pd)+0.33*POINT(pos, 0.03, d));     \n    \tpd = d;\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}