{
    "Shader": {
        "info": {
            "date": "1581761315",
            "description": "WIP (remaining bugs, not optimal yet...)\nFast terrain marching using hierarchical quad-tree of min/max values ( obtained for ~free by twisting MIPmap feature ) as bounding box hierarchy / BVH.\nMouse controls camera.\nuncomment line #51 to see cost heatmap.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtdXDj",
            "likes": 27,
            "name": "fast heightfield rendering",
            "published": 3,
            "tags": [
                "video",
                "minmax",
                "gpmipmap",
                "bbox"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1221
        },
        "renderpass": [
            {
                "code": "// minmax quadtree from \"making minmax quadtree for free\"  https://shadertoy.com/view/WdyGWd\n\n#define LOD 4.\n\n#define rot(t) mat2( cos(t+vec4(0,11,33,0)) )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float res = texture(iChannel0, .5/R.xy).a,  // size of texture in channel0\n            r = res / R.y, d;                   // texture res % window res\n\n                                                // test: show texture snippet\n  //if (max(U.x/R.x,U.y/R.y)<.1) { O = .2+texture(iChannel0, U*r/(R.xy*.1)).rrrr; return; }\n      \n    vec3  D = vec3(.7*(U+U-R.xy)/R.y, 1),       // ray direction\n          V,P0,F, p;                            // marching point along ray \n    O-=O;  \n    D.yz *= rot(-1.1);                          // rotation\n    vec2 M = iMouse.xy, T;                      // user rotation\n    if (length(M) > 15.) { \n        M = 2.*M/R.xy - 1.;\n        D.xz *= rot(-M.x*2.);\n        D.yz *= rot(-M.y*1.5);\n    }\n    D = normalize(D);\n    p = vec3(.5,.5,.1);                         // viewpoint\n    r = res;\n    int i=300;                                  // to limit iterations\n    float h = .2;                               // heightfield thickness\n    int l, lM = 6, lm = 0;                      // thinnest LOD\n#define w(l) (float(1<<l)/res)                  // tile width\n    ivec2 _B,B=ivec2(0),B2;\n    do {\n        T = fract(p.xz);                        // pos in texture heightfield\n      //float pix = dFdx(p.x);                  // pixel size [ can't use: cause discontinuities ]\n      //lm = int(log2(pix*res));\n      //[ lM = int(log2(res)) ? but max MIPmap levels are flawn ]\n      //_B=B; B = ivec2(T*res); B2 = ivec2(log2(float(B ^ _B))); // highest tile level change \n      //lM = min(6, max(B2.x,B2.y) );\n        for( l=lM; l>=lm; l--) {    // try LOD from top to bottom [we should resume prev l]\n          //if ( w(l) < pix ) { l=lm-1; break; }// stop LOD at pixel footprint size\n            M.x = h* minLOD(T,l);               // tile min-max heights\n            M.y = h* maxLOD(T,l);\n            F = p/w(l); F.xz = fract(F.xz)*2. - 1.;\n            // forward tile intersection: compute intersection F+kD  with box [-1,1]Â² \n            V = ( sign(D) -  F ) / D,           // see https://www.shadertoy.com/view/WldSWj\n            P0 = p +  min(V.x,V.z) *D/2. *w(l); // [ if D[i] = 0., should use V[1-i] ]\n            if( /*max(p.y,P0.y) < M.x || */ min(p.y,P0.y) > M.y )  break; // tile BB out of ray\n        }     // [ ^^ not working as long as we display columns rather than smooth heightfield ]\n        if (l<lm) break;                        // hit\n        d = length((P0-p).xz);                  // we can march out of this tile\n        d+=.5/res* length(P0-p)/d;              // eps to cross tile border\n\n        p += d*D; \n    } while (p.z<8. && p.y>0. && --i > 0 );     // until ray gets out\n    \n  //p.y = (M.x+M.y)/2.;                         // estimate average height\n  //p.y = textureLod(iChannel0,T*res/R.xy,float(l)).r * h;\n    \n  //O = vec4(float(300-i)/40.); return;         // test: show NB iterations\n  //O = fract(float(300-i)/vec4(40,20,10,1)); return;         // test: show NB iterations\n    O = vec4( l<lm ? 1.8*p.y/h : 0. );          // shade voxel\n    O = mix(vec4(0,0,1,0),O, exp(-.3*abs(p.z)));// fog\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 O, vec2 U )\n{\n    float res = iChannelResolution[0].y,\n          lod = max(0., ceil(log2(res/R.y))); // pixel = lod % texel \n    O.r = length( texelFetch(iChannel0, ivec2(U), int(lod) ).rb ) / 1.3;\n    O.r = max(O.r,.019);              // no denormalized IEEE floats on the GPU ? or in float buffers ?\n    O.r = pow( O.r, 2.2 );            // sRGB to flat (was it necessary ?)\n    O.g = pow( O.r,-POW );            // this approximates MIN\n    O.b = pow( O.r, POW );            // this approximates MAX\n    O.a = res / exp2(lod);            // texture res at pixel lod\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define POW 10.  // the larger the better min/max, but more bigfloats precision issues\n\n#define R  iResolution\n\n#define minLOD(U,l) pow( text(U,l).g, -1./POW ) \n#define maxLOD(U,l) pow( text(U,l).b,  1./POW ) \n#define text(U,l) ( texelFetch(iChannel0, ivec2(U*r)>>l, l) * float(1<<2*l) ) //exp2(2.*float(l)) )\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}