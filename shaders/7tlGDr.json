{
    "Shader": {
        "info": {
            "date": "1622052106",
            "description": "Drawing an ellipse as an affine transformation of a circle.\n\nMouse changes the transformation. 'x' to see untransformed configuration.",
            "flags": 16,
            "hasliked": 0,
            "id": "7tlGDr",
            "likes": 9,
            "name": "Ellipse & Circle",
            "published": 3,
            "tags": [
                "ellipse",
                "affine"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 352
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Drawing an ellipse as an affine transformation of a circle. mla, 2021\n//\n// Mouse changes transformation\n//\n// The inner ellipse is inscribed in the yellow triangle (and passes through\n// the midpoints of its sides, making it Steiner's inellipse) and the triangle\n// is inscribed in the outer ellipse, which is just double the inner. The\n// the sides of the blue parallelogram are also tangent at their midpoints and\n// the cross lines in the parallelogram are conjugate diameters of the ellipse.\n//\n// The whole configuration is just an affine transformation of a circle in a\n// square and an equilateral triangle.\n\n// 'x' to see untransformed configuration.\n// 'h' for extra hyperbolae\n// 'a' for a different regular transformation\n//\n////////////////////////////////////////////////////////////////////////////////\n\nfloat lwidth1 = 0.02;\nfloat lwidth2 = 0.04;\n\nvec3 doline(vec3 col, vec3 linecol, float d) {\n  return mix (linecol, col, mix(0.1,1.0,smoothstep(lwidth1,lwidth2,d)));\n}\n\nvec3 diagram(const vec2 p, const vec2 mouse) {\n  // Main transformation matrix\n  mat2 X = mat2(1,0,0.5,1);\n  // Set from mouse\n  if (iMouse.x > 0.0) X = mat2(0.5,mouse.y,mouse.x,0.5);\n  if (key(CHAR_X)) X = mat2(1,0,1e-5,1); // (Almost) untransformed\n  // Add an extra rotation - this leaves ellipse invariant\n  float t = 0.2*PI*iTime;\n  {\n    mat2 A = mat2(cos(t),sin(t),-sin(t),cos(t));\n    if (key(CHAR_A)) A = mat2(tan(t),0,0,1.0/tan(t));\n    X *= A;\n  }\n  mat2 Xinv = inverse(X);\n  \n  // Equilateral triangle\n  vec2 A = X*vec2(0,2);\n  vec2 B = X*vec2(-sqrt(3.0),-1);\n  vec2 C = X*vec2(+sqrt(3.0),-1);\n  // Midpoints of sides\n  vec2 AB = 0.5*(A+B);\n  vec2 BC = 0.5*(B+C);\n  vec2 CA = 0.5*(C+A);\n  // Square corners\n  vec2 F = X*vec2(1,1);\n  vec2 G = X*vec2(1,-1);\n\n  // Compute vertices & foci of ellipse\n  // See: https://en.wikipedia.org/wiki/Ellipse#General_ellipse_2\n  vec2 f1 = X*vec2(1,0);\n  vec2 f2 = X*vec2(0,1);\n  // Ellipse is p = cos(t)*f1 + sin(t)*f2\n  // Tangent at p = -sin(t)*f1 + cos(t)*f2\n  // So tangent is perpendicular to p when:\n  // (cos(t)*f1 + sin(t)*f2).(-sin(t)*f1 + cos(t)*f2) = 0\n  float t0 = 0.5*atan(2.0*dot(f1,f2)/(dot(f1,f1)-dot(f2,f2)));\n\n  // The four vertices are ±v0, ±v1\n  vec2 v0 = f1*cos(t0)+f2*sin(t0);\n  vec2 v1 = f1*cos(t0+0.5*PI)+f2*sin(t0+0.5*PI);\n\n  // Calculate focus from axes\n  float a2 = 0.25*dot(v0,v0);\n  float b2 = 0.25*dot(v1,v1);\n  float c2 = a2-b2;\n  // Which foci are real?\n  vec2 focus = c2 >= 0.0 ? v0*sqrt(c2/a2) : v1*sqrt(-c2/b2);\n\n  // Do the drawing\n  float var = 0.5+texture(iChannel0,0.25*p).y;\n  lwidth1 *= var;\n  lwidth2 *= var;\n  \n  vec3 col = vec3(1,1,0.8);\n  float d;\n\n  // Axes of ellipse\n  d = 1e8;\n  d = min(d,abs(segment(p,v0,-v0)));\n  d = min(d,abs(segment(p,v1,-v1)));\n  col = doline(col,RED,d);\n\n  d = 1e8;\n  d = min(d,abs(segment(p,A,B)));\n  d = min(d,abs(segment(p,B,C)));\n  d = min(d,abs(segment(p,C,A)));\n  //d = min(d,abs(segment(p,A,BC)));\n  //d = min(d,abs(segment(p,B,CA)));\n  //d = min(d,abs(segment(p,C,AB)));\n  col = doline(col,YELLOW,d);\n\n  // The square\n  d = 1e8;\n  d = min(d,abs(segment(p,F,G)));\n  d = min(d,abs(segment(p,F,-G)));\n  d = min(d,abs(segment(p,-F,G)));\n  d = min(d,abs(segment(p,-F,-G)));\n\n  //d = min(d,abs(segment(p,F,-F)));\n  //d = min(d,abs(segment(p,G,-G)));\n  d = min(d,abs(line(p,X*vec2(0,-1),X*vec2(0,1))));\n  d = min(d,abs(line(p,X*vec2(-1,0),X*vec2(1,0))));\n  col = doline(col,BLUE,d);\n\n  d = 1e8;\n  d = min(d,abs(segment(p,focus,BC)));\n  d = min(d,abs(segment(p,-focus,BC)));\n  col = doline(col,vec3(0.1),d);\n\n  // Implicit function is f(inverse(X)*p) where f is circle function\n  // Gradient is transpose(X)*f'(inverse(X)*p)\n  vec2 p1 = Xinv*p;\n  // Use circle implicit function, but use transpose transform to adjust gradient.\n  // Implicit function is x^2+y^2 = 1, so gradient is (2x,2y)\n  float d2 = dot(p1,p1);\n  d = abs(d2-1.0);\n  d = min(d,abs(d2-4.0)); // Circumellipse\n  vec2 grad = 2.0*p1;\n  grad *= Xinv; // Postmultiply for transpose\n  d /= length(grad);\n  col = doline(col,RED,d);\n  if (key(CHAR_H)) {\n    // Conjugate hyperbolae, tangent to ellipse.\n    d = min(abs(p1.x*p1.y-0.5),abs(-p1.x*p1.y-0.5));\n    d /= length(p1.yx*Xinv);\n    col = doline(col,GREEN,d);\n  }\n  \n  d = length(p);\n  d = min(d,distance(p,focus));\n  d = min(d,distance(p,-focus));\n#if 0\n  d = min(d,distance(p,v0));\n  d = min(d,distance(p,-v0));\n  d = min(d,distance(p,v1));\n  d = min(d,distance(p,-v1));\n#endif\n  d = min(d,distance(p,A));\n  d = min(d,distance(p,B));\n  d = min(d,distance(p,C));\n  //d = min(d,distance(p,AB));\n  //d = min(d,distance(p,BC));\n  //d = min(d,distance(p,CA));\n  d = min(d,distance(p,X*vec2(1,0)));\n  d = min(d,distance(p,X*vec2(-1,0)));\n  d = min(d,distance(p,X*vec2(0,1)));\n  d = min(d,distance(p,X*vec2(0,-1)));\n  col = mix(vec3(0), col, smoothstep(lwidth2,2.0*lwidth2,d));\n  col *= 0.5+0.5*texture(iChannel0,0.25*p).x;\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 2.0;\n  vec2 p = vec2(scale*(2.0*fragCoord-iResolution.xy)/iResolution.y);\n  p *= 1.05;\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0,0)\n    : vec2(scale*(2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  vec3 col = diagram(p,mouse);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.1415927;\n\nvec3 colors[] =\n  vec3[](vec3(0.996078,0.152941,0.0705882),\n         vec3(0.988235,0.376471,0.0392157),\n         vec3(0.984314,0.6,0.00784314),\n         vec3(0.988235,0.8,0.101961),\n         vec3(0.996078,0.996078,0.2),\n         vec3(0.698039,0.843137,0.196078),\n         vec3(0.4,0.690196,0.196078),\n         vec3(0.203922,0.486275,0.596078),\n         vec3(0.00784314,0.278431,0.996078),\n         vec3(0.266667,0.141176,0.839216),\n         vec3(0.52549,0.00392157,0.686275),\n         vec3(0.760784,0.0784314,0.376471),\n         vec3(0.0705882,0.152941,0.996078));\n\n#define RED (colors[0])\n#define REDORANGE (colors[1])\n#define ORANGE (colors[2])\n#define YELLOWORANGE (colors[3])\n#define YELLOW (colors[4])\n#define YELLOWGREEN (colors[5])\n#define GREEN (colors[6])\n#define BLUEGREEN (colors[7])\n#define BLUE (colors[8])\n#define BLUEPURPLE (colors[9])\n#define PURPLE (colors[10])\n#define REDPURPLE (colors[10])\n\n#define DARK(c) (0.5*(c))\n#define LIGHT(c) (0.5+0.5*(c))\n\nconst int CHAR_A = 65;\nconst int CHAR_H = 72;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a;\n  b -= a;\n  float h = clamp(dot(p,b)/dot(b,b), 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  p -= a;\n  b -= a;\n  float h = dot(p,b)/dot(b,b);\n  return length(p-b*h);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}