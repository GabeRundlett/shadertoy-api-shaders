{
    "Shader": {
        "info": {
            "date": "1650211304",
            "description": "4Kb Executable Graphics compo presented at Revision 2022.\n\n(Written for appearance and compression, not performance.)",
            "flags": 0,
            "hasliked": 0,
            "id": "NlScRy",
            "likes": 30,
            "name": "Revised Reality",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "4k",
                "demoscene",
                "4kb",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "dean_the_coder",
            "viewed": 4731
        },
        "renderpass": [
            {
                "code": "// 'Revised Reality' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/NlScRy\n// https://demozoo.org/graphics/307496/\n// https://www.pouet.net/prod.php?which=91388\n//\n// Entered into the Revision 2022 4Kb Executable Graphics compo.\n// (First ever compo entry!)\n//\n// Processed using GLSL Shader Shrinker, and compressed into an exe\n// with Crinkler.\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n#define LIGHT_RGB\tvec3(1.2, 1., 1.)\n#define SPOT_RGB\tvec3(1.56, 1.1, 1.)\n#define SKY_RGB\tvec3(.45, .4, .35) * .05\n#define ISLE_RGB\tvec3(1, 1.4, 0)\n#define R\tiResolution\n#define sat(x)\tclamp(x, 0., 1.)\n#define S(a, b, c)\tsmoothstep(a, b, c)\n#define S01(a)\tS(0., 1., a)\n#define minH(a, b)\t{ float h_ = a; if (h_ < h.x) h = vec2(h_, b); }\n#define MN(a)\td = min(d, a)\n#define Z0\tmin(1., 0.)\n\nvec3 g;\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\n\t// Thanks Shane - https://www.shadertoy.com/view/lstGRB\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat i,\n\t      a = 0.,\n\t      b = .5;\n\tfor (i = Z0; i < 4.; i++) {\n\t\ta += b * n31(p);\n\t\tb *= .5;\n\t\tp *= 2.;\n\t}\n\n\treturn a * .5;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = sat(.5 + .5 * (b - a) / k);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat min2(vec2 v) { return min(v.x, v.y); }\n\nfloat max3(vec3 v) { return max(v.x, max(v.y, v.z)); }\n\nbool intPlane(vec3 ro, vec3 rd, out float t) {\n\tfloat z = -rd.z;\n\tt = (ro.z - 6.) / z;\n\treturn t >= 0. && abs(z) > 1e-4;\n}\n\nmat2 rot(float a) {\n\t// Thanks Fabrice.\n\treturn mat2(cos(a + vec4(0, 11, 33, 0)));\n}\n\nfloat opRep(float p, float c) {\n\tfloat c2 = c * .5;\n\treturn mod(p + c2, c) - c2;\n}\n\nfloat box(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max3(q), 0.);\n}\n\nvec3 rayDir(vec2 uv) {\n\tvec3 f = vec3(.034, .15325, 0.9876),\n\t     r = vec3(0.9994, 0, -0.0344);\n\treturn normalize(f * 1.1 + r * uv.x + cross(f, r) * uv.y);\n}\n\nfloat pie(vec3 q, float t, float r, float a){\n    vec2 p = q.xy,\n         c = vec2(sin(t), cos(t));\n    p *= rot(a * -6.28);\n    p.x = abs(p.x);\n    float l = length(p),\n          m = length(p-c*clamp(dot(p,c),0.0,r)),\n          d = max(l - r,m*sign(c.y*p.x-c.x*p.y));\n    return max(d, r - l - 0.2);\n}\n\nfloat logo(vec3 p) {\n\tp.y += .05;\n\tp.z += .2;\n\tp.xz *= rot(0.2);\n\tp.yz *= mat2(cos(.8 + vec4(0, 11, 33, 0)));\n\n\t// Inner circle.\n\tfloat l = length(p.xy),\n\t      d = abs(l - .3) - .1;\n\tMN(pie(p, .4, .55, .625));\n\n\t// Middle circle.\n\tMN(abs(l - .8) - .05);\n\tMN(pie(p, 1., .85, .05));\n\tMN(pie(p, 1., .85, .4));\n\tMN(pie(p, .6, .85, .8));\n\tMN(pie(p, .3, .72, .4));\n\n\t// Outer circle.\n\tMN(abs(l - 1.2) - .052);\n\tMN(pie(p, .6, 1.25, .7));\n\tMN(pie(p, .07, 1.3, .63));\n\tMN(pie(p, .2, 1.25, .5));\n\n\t// Crop depth.\n\treturn smin(d - 0.01, abs(p.z) - .08, -.04) - .002 * n31(p * 40.);\n}\n\nfloat rip(vec2 p) { return 0.07 * pow(S(0.4, 0.05, length(p * vec2(1, 1.4))), 3.0); }\n\nfloat exit(vec3 p) {\n\tp.x += 0.2;\n\tvec3 q = p;\n\n\t// E\n\tfloat f = box(q, vec3(0.06, 0.14, 0.1));\n\tq.x -= 0.03;\n\tq.y = abs(q.y) - 0.05;\n\tf = max(f, -box(q, vec3(0.06, 0.04, 1.)));\n\n\t// X\n\tq = p;\n\tq.x -= .16;\n\tq.xy = abs(q.xy);\n\tq.xy *= rot(-0.4);\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\n\t// I\n\tq = p;\n\tq.x -= .15 * 2.;\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\n\t// T\n\tq.x -= .14;\n\tf = min(f, box(q, vec3(0.02, 0.15, 0.1)));\n\tq.y -= 0.13;\n\tf = min(f, box(q, vec3(0.06, 0.04, 0.1)));\n\treturn max(f, abs(p.y) - 0.12);\n}\n\nfloat bolt(vec3 p, vec3 b, float m) {\n\tp.x -= m;\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);\n\treturn length(p - b * h) - 0.009;\n}\n\nvec2 map(vec3 p) {\n\t// Screen.\n\tfloat d,\n\t      f = sin(length(p.xy * rot(-0.2) * vec2(15, 55)));\n\tf *= S(2., .5, abs(p.x)) * S(.7, .3, abs(p.y - .1));\n\tf *= .3 + .7 * S(0., .5, p.y);\n\tf *= .0024;\n\tf += rip(p.xy - vec2(-1.15, 0.3));\n\tf += rip(p.xy - vec2(-.72, 0.21));\n\tf += rip(p.xy - vec2(.75, -0.1));\n\tf += rip(p.xy - vec2(1.2, -0.15));\n\tvec2 h = vec2(box(p, vec3(1.8, .9, .1 + f)), 1);\n\n\t// Screen frame.\n\tminH(max(box(p, vec3(1.85, .95, .15)), -box(p, vec3(1.8, .9, 1))), 5);\n\n\t// Logo\n\td = logo(p);\n\tg.x += .0025 / (.11 + d * d * d * d);\n\tminH(smin(d, h.x, .03), 2);\n\n\t// Stage top.\n\tminH(box(p + vec3(0, 1.2, -1), vec3(3, .05, 1)), 5);\n\n\t// Stage bottom.\n\tminH(box(p + vec3(0, 2.2, -1), vec3(2.8, 1, .9)) - .02, 6);\n\n\t// Hall.\n\td = -box(p - vec3(0, 2.15, 0), vec3(12. + sin(p.z * 10.) * .01, 4. + .005 * n31(p * 50.), 19));\n\n\t// Steps.\n\tfloat ns = 0.0002 * n31(p * vec3(1, 300, 1)) + 0.008;\n\tfor (float i = .1; i < .7; i += .1)\n\t\tMN(box(p + vec3(0, 1.2 + i, i - 1.), vec3(.6, .05, 1)) - ns);\n\n\t// Screen stand.\n\tvec3 q = p;\n\tq.x = abs(abs(q.x) - 1.5) - .1;\n\tq.y++;\n\tq.z--;\n\tMN(box(q, vec3(.001, 1, .01)) - .03);\n\tminH(d, -1);\n\n\t// Stage speakers.\n\tq = p;\n\tq.x = abs(q.x);\n\tq -= vec3(2.5, -1.1, .5);\n\tq.xz *= mat2(cos(.5 + vec4(0, 11, 33, 0)));\n\tf = q.z;\n\tq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n\tf = max(box(q, vec3(.3, .2, .2)), -f - .15);\n\tf = smin(f, -box(q + vec3(0.39, -0.14, 0), vec3(.1, 0.02, .06)), -0.02);\n\tns = n31(p * 200.);\n\tminH(f - .01 - ns * 0.0005, 7);\n\n\t// Seats.\n\tif (p.z < 0.0) {\n\t\tq = p;\n\t\tq.x = abs(q.x) - 2.;\n\t\tq.x = abs(q.x) - .4;\n\t\tq.x = abs(q.x) - .4;\n\t\tq.x = abs(q.x) - .2;\n\t\tq.y += 1.8 - .3 * S(2.9, 8.8, trunc((p.z + .2) / -.6));\n\t\tq.z = opRep(q.z, .6);\n\t\tq.z += 0.04 * S(0.0, 0.2, p.y + 1.64);\n\t\tq.z += .12 * cos(q.x * 4.5) - 0.23125;\n\t\tf = box(q - vec3(.14, .2, .14), vec3(.05, .01, .12));\n\t\tf = min(box(q, vec3(.16 - .08 * S(0.28, 0.65, q.y), .45, .005)), f);\n\t\tf += .0006 * ns;\n\t\tf = max(p.z + 1., min(f, box(q - vec3(.14, .05, .14), vec3(.01, .14, .12))) - .02);\n\t\tminH(f * 0.9, 3);\n\n\t\t// Cup holders.\n\t\tq = p;\n\t\tq.x = abs(q.x) - 0.85;\n\t\tq.y += 1.58 - 0.33 * S(2.9, 8.8, trunc(p.z / -.6));\n\t\tq.z = opRep(q.z + 0.3, .6);\n\t\tf = abs(length(q.xz) - 0.05) - 0.002;\n\t\tf = smin(f, (abs(q.y) - 0.02), -0.006);\n\t\tminH(max(p.z + 1., f), 7);\n\t}\n\n\t// Lights.\n\tq = p;\n\tq.x = abs(abs(q.x) - 5.) - 2.5;\n\tq.y -= 6.2;\n\tq.z = opRep(q.z + 2., 8.);\n\tf = length(q - vec3(0, .2, 0)) - .3;\n\tg.x += .002 / (.001 + f * f);\n\tminH(f, 4);\n\n\t// Dolby speakers.\n\tq = p;\n\tq.z = opRep(p.z, 3.2);\n\tq.x = abs(q.x);\n\tq -= vec3(11.9, 4, 1);\n\tf = cos(q.y) * 0.2 + q.y * 0.1;\n\tf += sin(q.y * 50.) * 0.006;\n\tf = box(q, vec3(f * step(q.x, 0.0), .6, .5)) - 0.1;\n\tminH(f, 8);\n\n\t// Isle lights.\n\tq = p;\n\tq.x = abs(q.x);\n\tq += vec3(-0.71, 1.95, 1.85);\n\tq.z = abs(q.z) - .5;\n\tq.z = abs(q.z) - .25;\n\tf = box(q, vec3(0.005, .1, 0.03));\n\tg.y += .000004 / (.0001 + f * f);\n\tminH(f, 9);\n\tif (p.z > 10.0) {\n\t\t// EXITs.\n\t\tq = p;\n\t\tq.y += 0.8;\n\t\tq.z -= 18.8;\n\t\tf = exit(q - vec3(10.4 * sign(p.x), 1.3, 0)); // EXIT words.\n\t\tg.z += .00004 / (.00001 + f * f);\n\t\tminH(f, 9);\n\t\tq.x = abs(q.x) - 10.4;\n\t\tf = box(q, vec3(0.9, 0.95, .1)); // Frame\n\t\tf = min(f, box(q - vec3(0, 1.3, 0), vec3(.4, .15, .05))); // EXIT box.\n\t\tq.yz += 0.1;\n\t\tminH(max(f - 0.02, -box(q, vec3(0.8, 1, 0.2))), 8); // Cut-out.\n\t\tq.x = abs(q.x) - 0.4;\n\t\tq.z -= 0.12;\n\t\tminH(box(q, vec3(0.39, 1, 0.01)), 10); // Doors.\n\t\tq.z += 0.05;\n\t\tf = box(q, vec3(0.32, .01, 0.0));\n\t\tf = min(f, box(q - vec3(0.32, 0.04, 0.05), vec3(0.01, .04, 0.0)));\n\t\tminH(f - 0.03, 7); // Push-bar.\n\t}\n\telse {\n\t\t// Lightning.\n\t\tf = fbm(p * 8.) * .2;\n\t\td = bolt(p + vec3(.71, .75, 1.85), vec3(-1, -2, 1), f);\n\t\tMN(bolt(p + vec3(-.8, .7, .8), vec3(0, -1.2, -0.1), f));\n\t\tminH(d, 11);\n\t\tg.x += (1. + 3. * S(0.07, .0, abs(p.y + 1.0))) * .00005 / (.001 + d * d);\n\t}\n\n\treturn h;\n}\n\nvec3 N(vec3 p) {\n\tfloat h = dot(p, p) * .01;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h).x;\n\t}\n\n\treturn normalize(n);\n}\n\nfloat shadow(vec3 p) {\n\tfloat d,\n\t      s = 1.,\n\t      t = .05,\n\t      mxt = length(p - vec3(1, 1, -3.6));\n\tvec3 ld = normalize(vec3(1, 1, -3.6) - p);\n\tfor (float i = Z0; i < 50.; i++) {\n\t\td = map(t * ld + p).x;\n\t\ts = min(s, 15. * d / t);\n\t\tt += max(.02, d);\n\t\tif (mxt - t < .5 || s < .001) break;\n\t}\n\n\treturn S01(s);\n}\n\nfloat aof(vec3 p, vec3 n, float h) { return sat(map(h * n + p).x / h); }\n\nfloat fog(float d) { return exp(d * -.0035) + 0.1; }\n\nvec3 plasma(vec2 p) {\n\tvec2 c = p + .5 * sin(34. / vec2(3, 5));\n\treturn vec3(sin((sin(p.x * 4.) + sin(sqrt(50. * dot(c, c) + 35.))) * 3.141 - vec2(0, 11)) * .4 + .5, .7);\n}\n\nvec3 flr(vec3 c, vec3 p, inout vec3 n) {\n\tif (p.y > -1.84) return c;\n\tc = vec3(.01, .02, .1) + S(.2, .5, fbm(p * 10.)) * vec3(.1, .2, .1);\n\tp.x = abs(p.x);\n\tif (p.x > 0.715 && p.z < -.82) c = vec3(.01);\n\telse if (p.x > 0.7 && p.z < -.8) {\n\t\tc = vec3(.5);\n\t\tn = mix(n, vec3(0, 1, 0), 0.8);\n\t}\n\n\treturn c;\n}\n\nvec3 lights(vec3 p, vec3 ro, vec3 rd, vec3 n, vec2 h) {\n\tfloat f;\n\tvec2 spe = vec2(10, 1);\n\tvec3 q,\n\t     ld = normalize(vec3(1, 1, -3.6) - p),\n\t     c = vec3(.45, .4, .35) * (.05 + .95 * step(p.y, 6.13)); // Darken ceiling.\n\t// Ceiling grid.\n\tif (min2(fract((p.xz + vec2(0, .5)) * 1.)) < 0.05) c += 0.01;\n\n\t// Colorize walls.\n\tc *= mix(vec3(1, .13, .13), vec3(1), step(abs(p.x), 11.95) * step(p.z, 18.9));\n\n\t// Floor pattern.\n\tc = flr(c, p, n);\n\tif (h.y == 3.) {\n\t\t// Chairs.\n\t\tc = vec3(.6, .07, .01);\n\t\tq = p;\n\t\tq.z += 1.5;\n\t\tq.x = abs(abs(q.x) - 2.) - .8;\n\t\tc += vec3(.48, 0, 0) * SPOT_RGB * S(.6, .5, length(q.xz));\n\t\tspe *= 0.5;\n\t}\n\telse if (h.y > 0.) {\n\t\tif (h.y == 1.) spe = vec2(200, 1);\n\n\t\t// plasma/white logo\n\t\tf = h.y - 1.;\n\t\tif (h.y == 2.) f -= S(-.5 + .3 * n31(p * 10.), -.1, p.z);\n\t\tc = mix(plasma(p.xy), vec3(.85), f);\n\n\t\t// Stage upper.\n\t\tif (h.y == 5.) {\n\t\t\tc *= .005;\n\t\t\tif (n.y >= .99) c += n31(p * 4.6);\n\t\t}\n\n\t\t// Stage lower.\n\t\tif (h.y == 6.) c = vec3(.234, .24, .12) * S(0., .1, fract(p.y * 12.));\n\n\t\t// Stage speakers.\n\t\tif (h.y == 7.) {\n\t\t\tc = vec3(.1);\n\t\t\tspe = vec2(1, 10);\n\t\t}\n\n\t\t// Dolby speakers.\n\t\tif (h.y == 8.) {\n\t\t\tc = vec3(.1 - n31(p * 20.) * 0.03);\n\t\t\tspe = vec2(20, 1);\n\t\t}\n\n\t\tif (h.y == 9.) c = ISLE_RGB;\n\t\tif (h.y == 10.) c = vec3(.3, 0.3, 0.4);\n\t\tif (h.y == 11.) return vec3(.9, .9, 1.);\n\t}\n\n\telse c += S(3., 1.5, length(p)) * S(.2, -.4, p.z) * plasma(p.xz * .4); // Plasma glow onto stage.\n\t// Ceiling light cones.\n\tfloat t;\n\tintPlane(ro, rd, t);\n\tif (t < length(p - ro)) {\n\t\tvec2 q = (ro + rd * t).xy;\n\t\tq.x = abs(abs(q.x) - 5.) - 2.5;\n\t\tq.y -= 6.;\n\t\tf = (S(1., 0., abs(q.x * 1.5) + q.y * .15) + S(1., 0., abs(q.x * 3.))) * S(-3.8, 4., q.y) * S(0.2, 0., q.y);\n\n\t\t// Dust.\n\t\tq *= 3.;\n\t\tvec2 u = floor(q);\n\t\tq = fract(q) - 0.5;\n\t\tq += n31(u.xyy) * 0.4;\n\t\tf += S(0.05 * n31(floor(p * 10.)), 0.0, length(q)) * f;\n\t\tc += SPOT_RGB * f;\n\t}\n    \n    // Darken near camera.\n\tc *= S(-5., -1., p.z);\n\tc *= 0.3 + 0.7 * S(22.1, 19.0, length(p));\n    \n    float _ao = mix(aof(p, n, .2), aof(p, n, 2.), .7);\n    float\n          l1 = sat(.1 + .9 * dot(ld, n)) * (.2 + .8 * shadow(p)),\n          l2 = sat(.1 + .9 * dot(ld * vec3(-1, 1, -1), n)) * .3,\n          l = l1 + (l2 + pow(sat(dot(rd, reflect(ld, n))), spe.x) * spe.y);\n    l *= (1. - S(.7, 1., 1. + dot(rd, n)) * .4);\n\treturn l * _ao * c * LIGHT_RGB;\n}\n\nvec3 scene(vec3 rd) {\n\tvec3 p = vec3(-.2, -.9, -5.8), ro = p;\n\tg = vec3(0);\n\tvec2 h;\n\tfor (float i = Z0; i < 135.; i++) {\n\t\th = map(p);\n\t\tif (abs(h.x) < .0015) break;\n\t\tp += h.x * rd;\n\t}\n\n\tvec3 gg = g.x * SPOT_RGB + g.y * ISLE_RGB + g.z * vec3(.1, 1, .1);\n\treturn mix(SKY_RGB, gg + lights(p, ro, rd, N(p), h), fog(dot(p, p)));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 uv) {\n\tvec2 v = uv.xy / R.xy;\n\tuv = (uv - .5 * R.xy) / R.y;\n\tvec3 c = scene(rayDir(uv));\n\tif (fwidth(c.r) > 0.05) {\n\t\tfor (float dx = Z0; dx <= 1.; dx++)\n\t\t\tc += scene(rayDir(uv + vec2(dx - 0.5, 0) / R.xy));\n\t\tc /= 3.;\n\t}\n\n\tc *= pow(16. * v.x * v.y * (1. - v.x) * (1. - v.y), .4);\n\tfragColor = vec4(pow(sat(c), vec3(.6)), 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}