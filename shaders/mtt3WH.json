{
    "Shader": {
        "info": {
            "date": "1682480316",
            "description": "Graflex lightsaber model.",
            "flags": 0,
            "hasliked": 0,
            "id": "mtt3WH",
            "likes": 0,
            "name": "Graflex",
            "published": 3,
            "tags": [
                "raymarching",
                "lightsaber"
            ],
            "usePreview": 0,
            "username": "hubbe",
            "viewed": 145
        },
        "renderpass": [
            {
                "code": "#define R 0.08\n#define CUTR (R/8.0)\n\nconst float pi = 3.1415926535;\nconst float PI = 3.1415926535;\n\n\nmat3 rotz(float f) {\n    return mat3(cos(f), sin(f), 0,\n                -sin(f), cos(f), 0,\n                0,0,1);\n}\nmat3 roty(float f) {\n    return mat3(cos(f), 0, sin(f),\n    0, 1, 0,\n                -sin(f), 0, cos(f));\n}\nmat3 rotx(float f) {\n    return mat3(1,0,0,\n                0, cos(f), sin(f),\n                0, -sin(f), cos(f));\n}\n\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.x -= clamp( p.x, -h, h );\n  return length( p ) - r;\n}\n\nvec4 opElongate( in vec3 p, in vec3 h) {\n    return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    //vec3 q = abs(p)-h;\n    //return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n\nfloat Clamp(vec3 p) {\n  p= vec3(p.x + 0.03, -p.z, p.y);\n  float dist = 100000.0;\n  // clamp\n  dist = min(dist, sdCappedCylinder(p.yxz, 0.040, 0.051));\n  dist = min(dist, sdBox(p.xyz + vec3(0.0, -0.038, 0.0), vec3(0.051, 0.020, 0.015)));\n  return dist;\n}\n\nfloat RedPill(vec3 p) {\n  p -= vec3(0.143,0,0);\n  if (p.y > 0.0) {\n    p.x-=0.030;\n    p.y = abs(p.y);\n  }\n  float dist = 1000000.0;\n//  dist = min(dist, sdCappedCylinder(p, 0.011, 0.051));\n  dist = min(dist, \n    max(sdSphere(p, 0.053),\n        sdCappedCylinder(p, 0.011, 0.08)));\n  return dist;\n}\n\nfloat Button(vec3 p) {\n  float dist = 1000000.0;\n  dist = min(dist, RedPill(p));\n  p -= vec3(0.143,0,0);\n  if (p.y > 0.0) {\n    p.x-=0.030;\n    p.y = abs(p.y);\n  }\n  dist = min(dist, sdCappedCylinder(p, 0.018, 0.050));\n//  dist = min(dist, sdCappedCylinder(p, 0.011, 0.051));\n  return dist;\n}\n\n// May need to find a better way to model this.\nfloat Cut(vec3 p) {\n  p.x -= 0.350;\n//  p.y -= 0.008;\n  p *= rotz(-0.60);\n  p.x += sin(p.y*50.0)/55.0;\n  return sdBox(p, vec3(0.1, 0.2, 0.1)) * 0.8;\n}\n\nfloat Slots(vec3 p) {\n  float dist = sdBox(p + vec3(-0.259,0.0,0.0), vec3(0.004, 0.1, 0.005));\n  dist = min(dist, sdBox(p + vec3(-0.227,0.0,0.0), vec3(0.020, 0.1, 0.010)));\n  return dist;\n}\n\nfloat Slots2(vec3 p) {\n  p.z = -abs(p.z);\n//  float dist = 100000.0;\n  float dist = sdBox(p + vec3(-0.179,0.055,0.01), vec3(0.010, 0.03, 0.005));\n  p *= rotx(0.95);\n  dist = min(dist, sdCappedCylinder(p+vec3(-0.175,0.040,0), 0.014, 0.02));\n//  dist = min(dist, sdBox(p + vec3(-0.227,0.0,0.0), vec3(0.020, 0.1, 0.010)));\n  return dist;\n}\n\nfloat Pins(vec3 p) {\n  p.z = -abs(p.z);\n  p *= rotx(0.95);\n  p += vec3(-0.175,0.015,0);\n  p.x = abs(p.x);\n  p.x -= 0.005;\n  return sdVerticalCapsule(p.yxz, 0.018, 0.002);\n//  return sdCappedCylinder(p, 0.002, 0.02);\n}\n\nfloat Cylinder(vec3 p) {\n float dist = sdCappedCylinder(p.yxz, 0.038, 0.270);\n  dist = max(dist, -sdCappedCylinder(p.yxz + vec3(0,-0.470,0), 0.036, 0.270));\n  dist = max(dist, -Cut(p));\n  dist = max(dist, -Slots(p));\n  dist = max(dist, -Slots2(p));\n  return dist;\n}\n\nfloat sdCircle(vec2 xy, float r) {\n  return length(xy) - r;\n}\nfloat sdRect(vec2 p, vec2 b) {\n  vec2 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat earsFront(vec2 xy) {\n  xy.x = -abs(xy.x);\n  float dist = sdCircle(xy, 0.027);\n  dist = max(dist, -sdCircle(xy, 0.0265));\n  dist = max(dist, -sdRect(xy + vec2(0.0, -0.030), vec2(0.005, 0.010)));\n  dist = min(dist, sdRect(xy + vec2(0.005, -0.056), vec2(0.0005, 0.030)));\n  return dist;\n}\n\nfloat earsSide(vec2 xy) {\n  xy.x = -abs(xy.x);\n  float dist = sdRect(xy + vec2(0, -0.050), vec2(0.012, 0.030));\n  dist = min(dist, sdRect(xy, vec2(0.016, 0.030)));\n  dist = min(dist, max(\n    sdCircle(xy + vec2(0,-0.069), 0.016),\n    -sdRect(xy + vec2(0.011*2.0, -0.060), vec2(0.011, 0.030))));\n  return dist;\n}\n\nfloat bunnyEars(vec3 p) {\n  p.x -= 0.227;\n  return max(\n      opExtrussion( p.zyx, earsFront(p.zy), 0.1 ),\n      opExtrussion( p, earsSide(p.xy), 0.1 ));\n}\n\nfloat grips(vec3 p) {\n    // 6-symmetry\n    float angle = atan(p.z, p.y);\n    float section = round(angle * 3.0 / pi);\n    float angle2 = section * pi / 3.0;\n    vec3 p2 = p * rotx(angle2);\n\n    // T-track\n    float dist = sdBox(p2.xyz + vec3(0.270-0.092,-0.038,0.0), vec3(0.092, 0.004, 0.013));\n    dist = min(dist, sdBox(p2.xyz + vec3(0.270-0.092,-0.038,0.0), vec3(0.091, 0.012, 0.002)) - 0.001);\n    return dist;\n}\n\nvec3 dorot(vec3 p) {\n   p = p  * roty(-0.4) * rotx(pi/5.0);\n//    p = p  * roty(-0.4) * rotx(pi/7.0);\n//    p = p * roty(-0.05);\n   p *= rotz(iTime*0.1) * rotx(-iTime*0.0123) * roty(iTime*0.09781623);\n    return p;\n} \n\n// bounding box\nfloat bb(vec3 p) {\n  p.y-=0.01;\n  return sdVerticalCapsule(p, 0.25, 0.08);\n}\n\n// Return actual distance, step\nfloat map(vec3 p) {\n    p = dorot(p);\n    \n    \n    float dist = bb(p);\n    if (dist > 0.1) return dist;\n    \n    dist = 100000.0;    \n    dist = min(dist, Cylinder(p));\n    dist = min(dist, Clamp(p));\n    dist = min(dist, Button(p));\n    dist = min(dist, grips(p));\n    dist = min(dist, bunnyEars(p));\n    dist = min(dist, Pins(p));\n\n    return dist;\n}\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nstruct Material {\n  vec3 color;\n  float metallic;\n  float roughness;\n};\n\nMaterial getMaterial(vec3 hp, vec3 ray_dir) {\n    float dist = map(hp);\n    vec3 hpr = dorot(hp);\n\n    if (grips(hpr) == dist) {\n       return Material(vec3(0.01,0.01,0.01), 0.0, 0.4);\n    }\n    \n    if (Pins(hpr) == dist) {\n        return Material(vec3(1.00, 0.71, 0.29), 1.0, 0.2);\n    }\n    \n    if (length(hpr.zy) < 0.036 && abs(hpr.x) < 0.201) {\n      return Material(vec3(0.01,0.01,0.01), 0.2, 0.2);     \n    }\n    \n    if (RedPill(hpr) == dist) {\n      return Material(vec3(0.6,0.1,0.1), 0.5, 0.2);\n    }\n    \n    if (hpr.z < -0.055 && abs(hpr.y) < 0.011) {\n      if (mod(hpr.x+0.2, 0.006) < 0.002) {\n        return Material(vec3(0.3, 0.9, 0.3), 0.0, 0.4);\n      } else {\n        return Material(vec3(1.00, 0.71, 0.29), 1.0, 0.2);\n      }\n    }\n    \n//    return Material(vec3(0.3), 0.9, 0.1);\t\n      vec2 tpos = vec2(dot(hpr, vec3(13.1,1,0.5)), dot(hpr, vec3(7.033,0.1,2.2)));\n    vec3 c = texture(iChannel0, tpos).xyz;\n    return Material(vec3(0.3), 1.0-c.g, c.r*0.8 + 0.1);\n}\n\n\n\n\n// Cast a ray starting at \"from\" and keep going until we hit something or\n// run out of iterations.\nfloat ray(vec3 from, vec3 direction) {\n    // How far we travelled (so far)\n    float travel_distance = 0.0;\n    float last_travel_distance = 0.0;\n    bool hit = false;\n    for (int i = 0; i < 60; i++) {\n        // calculate the current position along the ray\n\t    vec3 position = from + direction * travel_distance;\n        float tmp = map(position);\n\t    float distance_to_closest_object = tmp;\n        float step_size = hit ? tmp : tmp;\n\n        if (distance_to_closest_object < 0.0005) {\n            return travel_distance;\n        }\n        last_travel_distance = travel_distance;\n        \n        // We can safely advance this far since we know that the closest\n        // object is this far away. (But possibly in a completely different\n        // direction.)\n        travel_distance += step_size;\n    }\n \n    return travel_distance;\n}\n\n\nvec3 norm(vec3 pos) {\n    float d = 0.0001;\n    float dist = map(pos);\n    return normalize(vec3(map(pos + vec3(d,0,0)) - dist,\n                          map(pos + vec3(0,d,0)) - dist,\n                          map(pos + vec3(0,0,d)) - dist));\n}\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.001;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = map(origin + direction * t);\n        if (h < 0.0002) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\n\nvoid planet(out vec4 O,vec2 I)\n{\n    vec4 bg = texture(iChannel2, I / iResolution.xy);\n//    O = bg;    return ;\n    vec2 P =(( I / iResolution.x)/0.8+vec2(-0.9, 0.5)) / 1.0;\n    vec3 RR = vec3(P,sqrt(max(1.-dot(P,P),0.)));\n\tO = mix(\n        texture(iChannel1, .001*iTime+.3*RR.xy/sqrt(RR.z))*max(RR.x*.3+RR.y*.9+RR.z*.1+.5,.1),\n            vec4(.6,.4,.3,1)/dot(P,P*.5),pow(1.-RR.z,2.));\n    if (RR.z == 0.0)\n      O = mix(O, bg, min(1.0, max(0.0, pow((dot(P,P)-1.0),0.2))));\n}\n\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xx;\n\n    vec3 camera_position = vec3(0, 0, -3.0);\n    vec3 light_position = vec3(1.1, 1.1, 1.1);\n\n    // Animate\n  // camera_position.z += iTime/2.0 + iTime * iTime / 200.0;\n // camera_position.x += iTime/2.0;\n\n   light_position += camera_position;\n //   camera_position.x += iTime/7.0;\n    \n    // Note that ray_direction needs to be normalized.\n    // The \"1\" here controls the field of view.\n    float zoom = 4.0;\n    \n    // Uncomment this for a very funky zoom effect.\n    // float zoom = sin(iTime / 5.0) + 0.4;\n    vec3 ray_direction = normalize(vec3(uv, zoom));\n        \n    // Cast a ray, see if we hit anything.\n    float travel_distance = ray(camera_position, ray_direction);\n    \n    // If we didn't hit anything, go with black.\n    if (travel_distance > 50.0) {\n        planet(fragColor, fragCoord);\n        return;\n    }\n\n    // Point in space where our ray intersects something.\n    vec3 hit_position = camera_position + ray_direction * travel_distance;\n    \n    \n\n      Material mat = getMaterial(hit_position, ray_direction);\n      \n        vec3 v = normalize(-ray_direction);\n        vec3 n = norm(hit_position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7)); // light direction??\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(ray_direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = mat.color * 0.5;\n     \n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        float linearRoughness = mat.roughness * mat.roughness;\n        vec3 diffuseColor = (1.0 - mat.metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - mat.metallic) + baseColor.rgb * mat.metallic;\n\n        float attenuation = shadow(hit_position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        vec3 color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        float indirectHit = ray(hit_position + r * 0.001, r);\n        vec3 indirectSpecular = vec3(1.8, 0.5, 0.5) + r.y * 3.72;\n        vec3 indirectHitPosition = hit_position + r * indirectHit;\n        if (indirectHit < 1.0) {\n           Material indirectMaterial = getMaterial(indirectHitPosition, r);\n           indirectSpecular = indirectMaterial.color;\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(mat.roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n\n      \n      \n      \n//      fragColor = vec4(mat.color, 1.0);\n//      vec3 light_dir = normalize(light_position - hit_position);\n//      vec3 normal = norm(hit_position);    \n//      vec3 reflection = reflect(ray_direction, normal);\n//      float l2 = max(dot(reflection, light_dir), 0.0);\n//      float spec = pow(l2, 4.0) * 0.3;\n    \n      fragColor = pow(vec4(color, 1.0), vec4(1.0/2.2));\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}