{
    "Shader": {
        "info": {
            "date": "1625688786",
            "description": "I think I finally am getting the hang of integration by substitution. At least well enough to integrate a volumetric light with some inversesquareish falloff :) Move around with the arrow keys and mouse.",
            "flags": 48,
            "hasliked": 0,
            "id": "slXXD4",
            "likes": 18,
            "name": "Analytical Integrated Light",
            "published": 3,
            "tags": [
                "3d",
                "light",
                "volumetric",
                "integration",
                "inversesquare"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 499
        },
        "renderpass": [
            {
                "code": "// Desmos graph (not very functional, just the workthrough):\n// https://www.desmos.com/calculator/lrcijiosth\n//\n// Left: analytically integrated\n// Right: numerically integrated\n//\n// The only difference I notice is that the numerically\n// integrated one flickers as you move the camera due to\n// it missing some areas between steps which creates some\n// inconsistency as the ray moves.\n//\n// Some parts of the calculations look suspiciously\n// like the quadratic formula simplified for a sphere\n// intersection.\n//\n// The functions below are just specializations for different cases.\n// Feel free to use any of them (as long as you give credit of course :)).\n\n// Indefinite integral of the light volume over the ray at t\n// Lighting at distance x is k/(1+(x/d)^2)\n// k: brightness\n// d: spread/diffusion\nfloat integrateLightIndefinite(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    return d * d * k * atan((a * t + b) / h) / h;\n}\n\n// Definite integral of the light volume over any finite segment of the ray (ta to tb)\nfloat integrateLightDefinite(in vec3 ro, in vec3 rd, in float k, in float d, in float ta, in float tb) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    float ah = a / h, bh = b / h;\n    return d * d * k * (atan(ah * tb + bh) - atan(ah * ta + bh)) / h;\n}\n\n// Definite integral of the light volume over a partial view of the ray (0 to t)\nfloat integrateLightPartialView(in vec3 ro, in vec3 rd, in float k, in float d, in float t) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b), r = b / h;\n    return d * d * k * (atan(a * t / h + r) - atan(r)) / h;\n}\n\n// Definite integral of the light volume over the entire view of the ray (0 to ∞)\n// I computed the limit based on the fact that atan() approaches π/2 (90 degrees)\n// as x (the ratio of y over x) goes to infinity\nfloat integrateLightFullView(in vec3 ro, in vec3 rd, in float k, in float d) {\n    float a = dot(rd, rd);\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) + d * d;\n    float h = sqrt(a * c - b * b);\n    return d * d * k * (RHO - atan(b / h)) / h;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    // Camera ray\n    vec2 viewDir = ivec2(iMouse.xy) == ivec2(0) ? vec2(0.0) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TAU * ROTATION_SPEED;\n    mat3 cam = getCamera(viewDir);\n\n    vec3 ro = getPosition();\n    vec3 rd = normalize(cam[0] * uv.x + cam[1] * uv.y + cam[2]);\n\n    // Analytically integrated light on left\n    float k = 0.8, d = 0.6;\n    vec3 lightColor = vec3(1.0, 0.75, 0.15);\n\n    fragColor.rgb += integrateLightFullView(ro, rd, k, d) * lightColor;\n    //fragColor.rgb += integrateLightPartialView(ro, rd, k, d, 1000000.0) * lightColor;\n\n    // Numerically integrated light on right\n    if (uv.x > 0.0) {\n        fragColor = vec4(0.0);\n        float tMax = 100.0;\n        float dt = tMax / 100.0;\n        for (float t=0.0; t < tMax; t += dt) {\n            vec3 p = ro + rd * t;\n            fragColor.rgb += k / (1.0 + dot(p, p) / (d * d)) * dt; // Naive euler integration\n        }\n\n        fragColor.rgb *= lightColor;\n    }\n\n    // Divider\n    float unit = 2.0 / iResolution.y;\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.x) - 0.001));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Constants\n#define TAU 6.28318530718\n#define RHO 1.57079632679\n\n// Camera control\n#define STEP_SIZE 0.1\n#define ROTATION_SPEED 0.5\n\n// Key codes from iq's keyboard input demo (https://www.shadertoy.com/view/lsXGzf):\n#define KEY_UP 38\n#define KEY_DOWN 40\n#define KEY_RIGHT 39\n#define KEY_LEFT 37\n\n#define getPosition() texelFetch(iChannel0, ivec2(0), 0).xyz\n\n#define keyUpPressed() bool(texelFetch(iChannel1, ivec2(38, 0), 0).x)\n#define keyDownPressed() bool(texelFetch(iChannel1, ivec2(40, 0), 0).x)\n#define keyRightPressed() bool(texelFetch(iChannel1, ivec2(39, 0), 0).x)\n#define keyLeftPressed() bool(texelFetch(iChannel1, ivec2(37, 0), 0).x)\n\n// Camera matrix\nmat3 getCamera(in vec2 viewDir) {\n    vec2 c = cos(viewDir); vec2 s = sin(viewDir);\n    return mat3(       c.x, 0.0,         s.x,  // Right\n                s.x * -s.y, c.y, -c.x * -s.y,  // Up\n                s.x *  c.y, s.y, -c.x *  c.y); // Forward\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Camera position buffer\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 5.0, 0.0);\n    if (iFrame > 0) {\n        ivec2 addr = ivec2(fragCoord);\n        if (addr == ivec2(0)) {\n            fragColor = vec4(getPosition(), 1.0);\n\n            vec2 viewDir = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * TAU * ROTATION_SPEED;\n            mat3 cam = getCamera(viewDir);\n\n            if (keyUpPressed()) fragColor.xyz += cam[2] * STEP_SIZE;\n            if (keyDownPressed()) fragColor.xyz -= cam[2] * STEP_SIZE;\n            if (keyRightPressed()) fragColor.xyz += cam[0] * STEP_SIZE;\n            if (keyLeftPressed()) fragColor.xyz -= cam[0] * STEP_SIZE;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}