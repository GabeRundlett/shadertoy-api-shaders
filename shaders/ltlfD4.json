{
    "Shader": {
        "info": {
            "date": "1511952150",
            "description": "Based on https://www.shadertoy.com/view/XllfWH, but extended to arbitrary hyperbola by a coordinate transformation.\n\nOne foci is controlled by the mouse cursor.\n\nOnly guaranteed to work as long as the circles do not overlap.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltlfD4",
            "likes": 0,
            "name": "Unsigned distance to hyperbola2",
            "published": 3,
            "tags": [
                "distance",
                "hyperbola",
                "arbitrary",
                "unsigned"
            ],
            "usePreview": 0,
            "username": "mv",
            "viewed": 592
        },
        "renderpass": [
            {
                "code": "//\n// Extension of https://www.shadertoy.com/view/XllfWH\n//\n// An arbitrary hyperbola placed halfway between two circles\n// is drawn by approximating the (unsigned) distance using\n// a typical Newton-Rhapson iteration scheme. \n//\n//\n// We first translate the coordinates such that the midpoint\n// between the two foci becomes the new origin,\n// then we rotate it so that the two foci lies along the x-axis,\n// and finally we scale such that the foci lies at (Â±1, 0)\n//\n\nfloat dist_circle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nvec3 dist_hyperbola(vec2 p, float a, float c)\n{\n\n    float a2 = a*a;\n    float c2 = c*c;\n    float b2 = c2 - a2;\n    float b = sqrt(b2);\n    \n    float A = a*p.x/(a2 + b2);\n    float B = b*p.y/(a2 + b2);\n    \n    float t = 0.0;\n    \n    int i;\n    for (i = 0; i < 1000;i++) {\n        float ch = cosh(t);\n        float sh = sinh(t);\n        float dt = (ch * sh - A * sh - B * ch) / (ch * ch + sh * sh - A * ch - B * sh);\n        t = t - dt;\n        if (abs(dt) < 1.0e-3) break;\n    }\n    \n    vec2 P = vec2(a*cosh(t), b*sinh(t));\n    \n    return vec3(length(P - p), float(i), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(2.0*fragCoord.xy - iResolution.xy) / iResolution.yy;\n    \n\t// time dependent radii\n    float r1 = 0.5 + 0.4*cos(iTime);\n    float r2 = 0.5 - 0.4*cos(2.0*iTime);\n    \n    // positions, one on the mouse cursor\n    vec2 p2 = 2.0*(2.0*iMouse.xy - iResolution.xy) / iResolution.yy;\n    vec2 p1 = vec2(-1.0, -1.0);\n\t//vec2 p1 = -p2;\n\t//vec2 p1 = vec2(0.0, 0.0);\n    \n\n    // half-distance between points\n    float D = length(p2 - p1)/2.0;\n    \n    // distance to circles based on original coordinates,\n    // but scaled\n    float d1 = dist_circle(uv - p1, r1)/D;\n    float d2 = dist_circle(uv - p2, r2)/D;\n    \n    /*\n\t// midpoint\n    vec2 M = (p1 + p2)/2.0;\n    \n    // cosine and sine of angle with horizontal\n    vec2 cs = (p2-p1)/(2.0*D);\n\n    // translation matrix\n    mat3 T = mat3(vec3( 1.0,  0.0, 0.0),\n                  vec3( 0.0,  1.0, 0.0),\n                  vec3(-M.x, -M.y, 1.0));\n                  \n    // rotation matrix\n\tmat3 R = mat3(vec3(cs.x, -cs.y, 0.0), \n                  vec3(cs.y,  cs.x, 0.0),\n                  vec3(0.0,   0.0,  1.0));\n    \n    // scale matrix\n    mat3 S = mat3(vec3(1.0/D, 0.0,   0.0),\n                  vec3(0.0,   1.0/D, 0.0),\n                  vec3(0.0,   0.0,   1.0));\n    \n    // The composited matrix is:\n    //\n    //         |  c/D  s/D  -Mx*c/D - My*s/D |\n    // S*R*T = | -s/D  c/D   Mx*s/D - My*c/D |\n    //         |   0    0           1       |\n    //\n    // where c = cos(angle), s = sin(angle)\n    //\n    // which boils down to\n    //\n    //       1  | x2-x1  y2-y1  0.5*((x1+x2)*(x1-x2) + (y1+y2)*(y2-y1))\n    //      --- | y1-y2  x2-x1  0.5*((x1+x2)*(y2-y1) + (y1+y2)*(x1-x2))\n    //      D^2 |   0      0                         1\n    //\n    // composited matrix\n    mat3 SRT = S*R*T;\n\n    // transform coordinates such that the hyperbola is \n    // in canonical form\n    uv = (SRT*vec3(uv, 1.0)).xy;\n    */\n    \n    // optimized version of the above\n    vec2 q1 = vec2(-p1.y, p1.x);\n    vec2 q2 = vec2(-p2.y, p2.x);\n\n    uv = vec2(dot(p2-p1, uv) - 0.5*dot(p1+p2, p2-p1), \n              dot(q2-q1, uv) - 0.5*dot(p1+p2, q2-q1))/D/D/2.0;\n    \n    // line thickness and smoothing width\n    float t = 1.0*fwidth(uv.x); \n    float w = 1.0*fwidth(uv.x);\n    \n    // vertex position\n    float a = (r1 - r2)/2.0/D;\n    \n    // same as before\n    \n    // get distance, iterations and parameter of closest point\n    vec3 res = dist_hyperbola(uv, a, 1.0);\n    float d3 = res.x;\n    float iter = res.y;\n    //float t_min = res.z;\n\t\n    float s1 = smoothstep(w/2.0, -w/2.0, abs(d1) - t);\n    float s2 = smoothstep(w/2.0, -w/2.0, abs(d2) - t);\n    float s3 = smoothstep(w/2.0, -w/2.0, abs(d3) - t);\n    \n    vec3 bgColor = vec3(0.5 + 0.5*cos(iter));\n    vec3 circleColor = vec3(0.0, 0.0, 1.0);\n    vec3 hyperbolaColor = vec3(0.0, 1.0, 0.0);\n    \n    vec3 col = bgColor;\n    col = col*(1.0 - s1) + circleColor*s1;\n    col = col*(1.0 - s2) + circleColor*s2;\n    col = col*(1.0 - s3) + hyperbolaColor*s3;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}