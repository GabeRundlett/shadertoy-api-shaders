{
    "Shader": {
        "info": {
            "date": "1725978783",
            "description": "A test to see if I could raymarch through a gyroid. Indeed, I can! This function technically isn't an SDF, but it's close enough to one that if I sacrifice a bit of performance and accuracy I can get away with it.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3XcR7",
            "likes": 11,
            "name": "Gyroid Lattice",
            "published": 3,
            "tags": [
                "raymarching",
                "gyroid"
            ],
            "usePreview": 0,
            "username": "Bingle",
            "viewed": 131
        },
        "renderpass": [
            {
                "code": "// Gyroid Lattice (forked from Raytracing Boilerplate) by Bingle\n/* Axis orientation (from camera view):\n\n             ^ +Y\n             |\n             |\n     +X      |\n     <-------+\n              \\\n               \\| +Z\n              ‾‾\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    cam camera = cam(vec3(0.5*PI,0.0,mod(-PI*iTime,TAU)),normalize(vec3(cos(iTime*PI/3.0)*0.5,sin(iTime*PI/3.0)*0.5,-1)),vec3(0,1,0),0.5); // Modulating Z coordinate prevents precision errors at far distances\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    ray r = getCamRay(camera,uv);\n    \n    for (int i=0;i<500;i++){\n        float dist = SDF(r.pos);\n        r.pos += r.dir*dist*0.9; // Multiply by 0.9 just to give a bit of leeway for the imperfect \"SDF\"\n        if (dist<0.001){\n            vec3 n = normal(r.pos);\n            col = vec3(mix(1.0+dot(r.dir,n),n.y*0.5+0.5,0.4));\n            //col = vec3(n.y*0.5+0.5);//n*0.5+0.5;\n            // I'd love to make the coloring a little more visually appealing, but there isn't much I can really think of to do. Maybe triplanar texturing? Lights? Idk.\n            break;\n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define TAU 6.28318\n\nstruct cam{\n    vec3 pos;\n    vec3 dir;\n    vec3 up;\n    float viewDist;\n};\n\nstruct ray{\n    vec3 pos;\n    vec3 dir;\n};\n\n// Takes UV coords -0.5 to 0.5 (or in whatever centered range really) and returns a ray\nray getCamRay(cam c,vec2 uv){\n    vec3 side = cross(c.dir,c.up);\n    vec3 up = cross(side,c.dir);\n    \n    return ray(c.pos,normalize(c.dir*c.viewDist + side*uv.x + up*uv.y));\n}\n\n// https://www.desmos.com/3d/fdq7k2xgpx\nfloat SDF(vec3 pos){\n    return dot(sin(pos),cos(pos.yzx));\n}\n\nvec3 normal(vec3 P){\n    vec2 h = .0001*vec2(1,-1);\n    return normalize( vec3(h.xxy*SDF(P+h.xxy) + h.xyx*SDF(P+h.xyx) + h.yxx*SDF(P+h.yxx) + h.yyy*SDF(P+h.yyy) ));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}