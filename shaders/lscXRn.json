{
    "Shader": {
        "info": {
            "date": "1457330807",
            "description": "Graphing out the basis functions for b-splines of various degrees.  Press 1 through 4 to choose what degree to see.  Also cycles over time.",
            "flags": 16,
            "hasliked": 0,
            "id": "lscXRn",
            "likes": 9,
            "name": "Uniform B-Spline Basis Functions",
            "published": 3,
            "tags": [
                "2d",
                "graph",
                "basis",
                "bspline"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 997
        },
        "renderpass": [
            {
                "code": "#define AA_AMOUNT (2.0 / (iResolution.x*c_zoom))\n\nconst float c_gamma = 2.2;\n\nconst float c_zoom = 1.0 / 6.0;\nconst vec2 c_cameraoffset = vec2(-0.1, -0.4); \n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\n//-----------------------------------------------------------------------------\nfloat N_i_1 (in float t, in float i)\n{\n    // return 1 if i <= t < i+1, else return 0\n    return step(i, t) * (1.0 - step(i+1.0, t));\n}\n\n//-----------------------------------------------------------------------------\nfloat N_i_2 (in float t, in float i)\n{\n    return\n        N_i_1(t, i)       * (t - i) +\n        N_i_1(t, i + 1.0) * (i + 2.0 - t);\n}\n\n//-----------------------------------------------------------------------------\nfloat N_i_3 (in float t, in float i)\n{\n    return\n        N_i_2(t, i)       * (t - i) / 2.0 +\n        N_i_2(t, i + 1.0) * (i + 3.0 - t) / 2.0;\n}\n\n//-----------------------------------------------------------------------------\nfloat N_i_4 (in float t, in float i)\n{\n    return\n        N_i_3(t, i)       * (t - i) / 3.0 +\n        N_i_3(t, i + 1.0) * (i + 4.0 - t) / 3.0;\n}\n\n//-----------------------------------------------------------------------------\nfloat N_i_5 (in float t, in float i)\n{\n    return\n        N_i_4(t, i)       * (t - i) / 4.0 +\n        N_i_4(t, i + 1.0) * (i + 5.0 - t) / 4.0;\n}\n\n//-----------------------------------------------------------------------------\n// F(x,y)\nfloat F ( in vec2 coords, int degree)\n{                \n\tif (degree == 0)\n\t\treturn N_i_1(coords.x, 0.0) - coords.y;\n    else if (degree == 1)\n        return N_i_2(coords.x, 0.0) - coords.y;\n    else if (degree == 2)\n        return N_i_3(coords.x, 0.0) - coords.y;\n    else if (degree == 3)\n        return N_i_4(coords.x, 0.0) - coords.y;\n    else\n        return N_i_5(coords.x, 0.0) - coords.y;\n}\n\n//-----------------------------------------------------------------------------\n// gradiant function for finding G for a generic function F\nvec2 Grad( in vec2 coords, int degree)\n{\n    vec2 h = vec2( 0.001, 0.0 );\n    return vec2( F(coords+h.xy, degree) - F(coords-h.xy, degree),\n                 F(coords+h.yx, degree) - F(coords-h.yx, degree) ) / (2.0*h.x);\n}\n\n//-----------------------------------------------------------------------------\n// signed distance function for F(x,y)\nfloat SDF( in vec2 coords, int degree)\n{\n    float v = F(coords, degree);\n    vec2  g = Grad(coords, degree);\n    return abs(v)/length(g);\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // set up viewport\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = ((fragCoord.xy / iResolution.xy) + c_cameraoffset);\n    uv.x *= aspectRatio;\n    uv /= c_zoom;\n\n    // default color is white\n    vec3 pixelColor = vec3(1.0,1.0,1.0);\n    \n    // figure out what degree we should be showing\n    int degree = int(mod(iTime, 5.0));\n    if (texture(iChannel0, vec2(KEY_1,0.25)).x > 0.1)\n        degree = 0;\n    else if (texture(iChannel0, vec2(KEY_2,0.25)).x > 0.1)\n        degree = 1;    \n    else if (texture(iChannel0, vec2(KEY_3,0.25)).x > 0.1)\n        degree = 2;   \n    else if (texture(iChannel0, vec2(KEY_4,0.25)).x > 0.1)\n        degree = 3;      \n    else if (texture(iChannel0, vec2(KEY_5,0.25)).x > 0.1)\n        degree = 4;            \n    \n    // draw y axis in black\n    float dist = abs(uv.x - 0.0);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*2.0, dist);\n    pixelColor = mix(pixelColor, vec3(0.0, 0.0, 0.0), dist);\n    \n    // draw y axis tick marks in black and grid lines in light grey\n    dist = abs(mod(uv.y+0.5, 1.0) - 0.5);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*2.0, dist);\n    dist *= step(abs(uv.x - 0.0), 1.0 * c_zoom) * 0.8 + 0.2;\n    pixelColor = mix(pixelColor, vec3(0.0, 0.0, 0.0), dist);        \n    \n    // draw x axis in black\n    dist = abs(uv.y - 0.0);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*2.0, dist);\n    pixelColor = mix(pixelColor, vec3(0.0, 0.0, 0.0), dist);\n    \n    // draw x axis tick marks in black and grid lines in light grey\n    dist = abs(mod(uv.x+0.5, 1.0) - 0.5);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*2.0, dist);\n    dist *= step(abs(uv.y - 0.0), 1.0 * c_zoom) * 0.8 + 0.2;\n    pixelColor = mix(pixelColor, vec3(0.0, 0.0, 0.0), dist);  \n    \n    // draw a green line at y=1.1 showing where the curve is valid from / to\n    dist = abs(uv.y - 1.1);\n    dist = 1.0 - smoothstep(0.0, AA_AMOUNT*2.0, dist);\n    dist *= step(float(degree), uv.x);\n    dist *= step(uv.x, float(degree+1));\n    pixelColor = mix(pixelColor, vec3(0.0, 1.0, 0.0), dist);     \n\n    // draw offsets of the function in grey\n    for (int i = 1; i < 10; ++i)\n    {\n        if (i > degree)\n            break;    \t\n    \tdist = SDF(uv-vec2(float(i),0.0), degree);\n\t\tdist = 1.0 - smoothstep(AA_AMOUNT, AA_AMOUNT*2.0,dist);\n    \tdist *= step(float(i), uv.x);\n    \tdist *= step(uv.x, float(degree+1+i));\n    \tpixelColor = mix(pixelColor, vec3(0.4), dist);         \n    }\n    \n    // draw the function in blue\n    dist = SDF(uv, degree);\n\tdist = 1.0 - smoothstep(AA_AMOUNT, AA_AMOUNT*2.0,dist);\n    dist *= step(0.0, uv.x);\n    dist *= step(uv.x, float(degree+1));\n    pixelColor = mix(pixelColor, vec3(0.0, 0.2, 1.0), dist);     \n    \n    // gamma correct colors\n\tpixelColor = pow(pixelColor, vec3(1.0/c_gamma));\n    fragColor = vec4(pixelColor, 1.0);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}