{
    "Shader": {
        "info": {
            "date": "1627400266",
            "description": "!EPILEPSY WARNING!!!!\n_More options in the defines!_\n\nas per tradition by now- a visualiser on the hexagonally tilled domain i used for the snowflake.\nthe cubes are fake shaded, and the wave is reading the sound data and tuning in to specific frequancies.",
            "flags": 64,
            "hasliked": 0,
            "id": "fl2XRm",
            "likes": 9,
            "name": "Dancing Cube Field (Visualiser)",
            "published": 3,
            "tags": [
                "waves",
                "interactive",
                "cube",
                "hexagon",
                "snowflake",
                "hexagonal",
                "tilling"
            ],
            "usePreview": 0,
            "username": "Pelegefen",
            "viewed": 470
        },
        "renderpass": [
            {
                "code": "//!!!!!!!!EPILEPSY WARNING!!!!!!!FLASHING LIGHTS!!!!!!!!!!\n\n//Made with love by Peleg Gefen <3\n\n//song - Warp9 - Seems Like A Dream\n\n\n\n//----------------------------------DEFINES------------------------------------------------\n\n//#define Time_And_Zoom //SEIZURE INDUCING LOL - Allows you to use the horizontal mouse axis to \"peek into the future\" to\n//see the full evolution of the wave. use the vertical axis for zoom in-and-out\n\n\n//#define Mode2 //Freaky inverted cubes effect\n\n//-----------------------------------------------------------------------------------------\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nfloat freqs[4];\nvec2 rot (vec2 p,float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\n\nfloat hexDist(vec2 p) {\n    p = abs(p);\n    //distance to the diagonal line\n    float c = dot(p, normalize(vec2(1., 1.73)));\n\n    // distance to the vertical line\n    c = max(c, p.x);\n    c += sin(iTime + 4000.) *5. +5.;\n    return c;\n  }\n\nvec4 hexCoords(vec2 uv) {\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - h, r) - h;\n\n    vec2 gv;\n    if(length(a) < length(b))\n      gv = a;\n    else\n      gv = b;\n\n    float y = .5 - hexDist(gv);\n    float x = atan(gv.x, gv.y);\n    vec2 id = uv - gv;\n    return vec4(x, y, id.x, id.y);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    float avgFreq = (freqs[0] +freqs[1] +freqs[2] +freqs[3])/4.;\n    \n    \n\tfloat iTime = iTime * .25;\n\tiTime += 800.;\n\tvec2 uv = (fragCoord.xy-.5*iResolution.xy)\n\t/iResolution.y;\n    \n    \n     vec4 col = vec4(0.);\n     vec2 uv1 = uv;\n     //uv *= 3.;\n     uv *= ( sin(iTime+freqs[0])*8.5+8.5) + 5.;\n     uv -= 8.0;\n\n     uv += vec2(iTime *\t .01);\n\n     #ifdef Time_And_Zoom\n     iTime += iMouse.x * 10.;\n     uv *=  iMouse.y * .007;\n     #else\n     uv -= (iMouse.xy / iResolution.xy ) * 2. ;\n     #endif\n\n     uv += rot(uv , (cos(iTime - (avgFreq * (3.1415*.5)))*.5+.5) );\n\n \n \n     vec4 uvid = hexCoords(uv * 2.);\n     \n     float t = smoothstep(.5,.5\n \t \t,uvid.y \n \t \t* sin(( length(uvid.zw))\n \t \t * iTime *0.1)*.5+.5);\n   \n    \n\tcol = vec4(\n    t * tan(freqs[3])*.5+.5 * sin(freqs[0] * 2.5)*.5+.5\n    , t*cos(freqs[2])*.5+.5* sin(freqs[1] * 5.)*.5+.5\n    , t * sin(freqs[1])*.5+.5 * sin(freqs[2] * 10.)*.5+.5\n    ,1.);\n    \n    col -= vec4(freqs[0],freqs[1],\n         freqs[2],\n         1.);\n         \n         \n         \n\t//lit face\n\tcol += vec4(smoothstep(.99,.991,uvid.x));\n    \n    \n\t//shading\n\tcol += vec4(smoothstep(-1.,-1.,uvid.x)) * .6;\n\n \t \n     float circle = sin(freqs[0]);\n     \n     float triangles = sin(freqs[1] / length(uvid.z/uvid.w))*.5+.5 \n     / cos(freqs[3] * length(uvid.z/uvid.w))*.5+.5 ;\n     \n     triangles = mix(-triangles,triangles,sin(iTime)*.5+.5);\n     \n     \n \t //hexagons shrinking and expanding, wave form\n \t col *= vec4(smoothstep(.000001,.00001\n \t \t,uvid.y \n        \n        #ifdef Mode2\n \t \t* uvid.x\n        #endif\n        * sin((( length(uvid.zw * freqs[1]) * mix(circle,triangles,freqs[3])))*.5+.5\n \t \t * (dot(freqs[1],length(uvid.zw) * .05) ))))* max(freqs[0] , .1) + .3;\n         \n \t col = clamp(col,0.,1.);\n\tfragColor = vec4( col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 27887,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/warp99/warp9-seems-like-a-dream"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}