{
    "Shader": {
        "info": {
            "date": "1464788076",
            "description": "Running a camera through a random debris field.",
            "flags": 0,
            "hasliked": 0,
            "id": "lsySWw",
            "likes": 65,
            "name": "Lunar Debris",
            "published": 3,
            "tags": [
                "field",
                "cellular",
                "tile",
                "flythrough",
                "debris"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 2632
        },
        "renderpass": [
            {
                "code": "/*\n\n\tLunar Debris\n\t------------\n\n\tJust playing around a little more with 3D cellular tiling to create some random rocks floating\n\taround in space. The distance field is analogous to raymarched, mutated Voronoi. \n\n\tCompared to genuine raymarched Voronoi, the framerate isn't too bad, but I think it can be\n\timproved upon. I'll take a closer look at it to see if I can increase it a bit.\n\n\tThe trickiest thing to deal with was not the rocky field itself, but rather negotiating through\n\tit in a way that gives the appearance that the camera is naturally avoiding obstacles. I tried\n\ta few different things but smoothly negating space with a squashed diamond tube seemed to \n\tproduce the desired result. Anyway, the process is simple and is contained in the distance \n\tfunction.\n\n\n\tOther examples:\n\n\t// Very stylish.\n\tDusty Thing - kuvkar\n    https://www.shadertoy.com/view/XlBXRt\n\n\t// Love the way this is done.\n\tMoon Rock - foxes\n\thttps://www.shadertoy.com/view/4s33RX\n\n\n*/\n\n#define PI 3.14159265\n#define FAR 60.\n\n// Uses smooth combinations (smin, smax, etc) to smooth the rock joins.\n#define SMOOTHING \n\n// Rotation matrix.\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(1.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// IQ's smooth minium function. \nvec2 sminP(vec2 a, vec2 b , float s){\n    \n    vec2 h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// IQ's smooth minium function. \nfloat sminP(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Cellular tile setup. Draw four overlapping objects (spheres, in this case) \n// at various positions throughout the tile.\n \nfloat drawObject(in vec3 p){\n  \n    p = fract(p)-.5;\n    return dot(p, p);\n    \n}\n\n   \nfloat cellTile(in vec3 p){\n\n   \n    vec4 v, d; \n    \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(.6, .82, .64));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(.51, .06, .70));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(.12, .62, .64));\n\n\t// Obtaining the minimum distance.\n    #ifdef SMOOTHING\n    v.xy = sminP(d.xz, d.yw, .05); \n    #else\n    v.xy = min(d.xz, d.yw);\n    #endif\n    \n    // Normalize... roughly. Trying to avoid another min call (min(d.x*A, 1.)).\n    #ifdef SMOOTHING\n    return  sminP(v.x, v.y, .05)*2.5; \n    #else\n    return  min(v.x, v.y)*2.5; \n    #endif    \n    \n}\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    \n   \n    //return vec2(0); // Straight.\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n    //return vec2(a*4. -b*1.5, 0.); // Just X.\n    //return vec2(0, b*1.7 + a*1.5); // Just Y.\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function.\nfloat n3D(vec3 p){\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// The debris field. I'll tidy it up later. In general, this is a terrible \n// distance field to hone in on. I'm come back to it later and rework it.\nfloat map(vec3 p){\n    \n    // Warping the whole field around the path.\n    p.xy -= path(p.z);\n    \n    p/=2.;\n    \n    // Mutated, first order cellular object... the rocks.\n    vec3 q = p + (cos(p*2.52 - sin(p.zxy*3.5)))*.2;\n    float sf = max(cellTile(q/5.), 0.); \n    \n    // Mutated squashed diamond tube. Used to run the camera through.\n    p += (cos(p*.945 + sin(p.zxy*2.625)))*.2;\n    #ifdef SMOOTHING\n    float t = .1 - abs(p.x*.05) - abs(p.y);\n    #else\n    float t = .05 - abs(p.x*.05) - abs(p.y);\n    #endif  \n    \n    // Smoothly combine the negative tube space with the rocky field.\n    //p = sin(p*4.+cos(p.yzx*4.));\n    float n = smaxP(t, (.68 - (1.-sqrt(sf)))*2., 1.);// + abs(p.x*p.y*p.z)*.05;\n   \n    // A bit hacky... OK, very hacky. :)\n    return n*3.;\n    \n}\n\n\n\n// Surface bump function. I'm reusing the \"cellTile\" function, but absoulte sinusoidals\n// would do a decent job too.\nfloat bumpSurf3D( in vec3 p, in vec3 n){\n    \n    return (cellTile(p/2.))*.8 + (cellTile(p*1.5))*.2;\n    \n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.0025*(t*.125 + 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.8;\n        \n    }\n\n    return min(t, FAR);\n    \n}\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 6.0;\n\t//const float falloff = 0.9;\n    for( float i=1.; i< nbIte+.5; i++ ){\n    \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(1.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ. In instances where there's no descernible \n// aesthetic difference between it and the six tap version, it's worth using.\nvec3 calcNormal(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n/*\n// Standard normal function. 6 taps.\nvec3 calcNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n*/\n\n// Shadows.\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int shadIter = 24; \n\n    float dist = start;\n    //float stepDist = end/float(shadIter);\n\n    for (int i=0; i<shadIter; i++){\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n        //shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0, 0, iTime*8. + 0.1);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. The positioning is fake. Obviously, the light source would be much \n    // further away, so illumination would be relatively constant and the shadows more static.\n    // That's what direct lights are for, but sometimes it's nice to get a bit of a point light \n    // effect... but don't move it too close, or your mind will start getting suspicious. :)\n \tvec3 lightPos = camPos + vec3(0, 7, 35.);\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\t//lightPos.xy += path(lightPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    // Lens distortion.\n    //vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n    /*    \n    // Mouse controls, as per TambakoJaguar's suggestion.\n    // Works better if the line above is commented out.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n\t*/ \n    \n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);    \n\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = camPos + rd*t;\n        \n        // Voxel normal.\n        //vec3 sn = -(mask * sign( rd ));\n        vec3 sn = calcNormal(sp);\n        \n        // Sometimes, it's necessary to save a copy of the unbumped normal.\n        vec3 snNoBump = sn;\n        \n        // I try to avoid it, but it's possible to do a texture bump and a function-based\n        // bump in succession. It's also possible to roll them into one, but I wanted\n        // the separation... Can't remember why, but it's more readable anyway.\n        //\n        // Texture scale factor.\n        const float tSize0 = 1./2.;\n        // Texture-based bump mapping.\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.1);\n        vec3 tsp =  sp;// + vec3(0, 0, iTime/8.);// + vec3(path(sp.z), 0.)\n\n        // Function based bump mapping. Comment it out to see the under layer. It's pretty\n        // comparable to regular beveled Voronoi... Close enough, anyway.\n        sn = doBumpMap(tsp, sn, .5);\n        \n       \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);//*.75 + .25;\n\n        \n    \t// Light direction vectors.\n\t    vec3 ld = lightPos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\t    \n        \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.007); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light, due to light bouncing around the field, I guess.\n\t    float ambience = 0.25;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n        // Object texturing, coloring and shading.\n\t    vec3 texCol = vec3(.8, .9, 1.);\n\t    texCol *= min(tex3D(iChannel0, sp*tSize0, sn)*3.5, 1.);\n        texCol *= bumpSurf3D(sp, sn)*.5 + .5;\n        \n        // Shadows.\n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n\n        // Final color. Pretty simple.\n        sceneCol = texCol*(diff + spec + ambience);\n        \n        // Adding a touch of Fresnel for a bit of space glow... I'm not so\n        // sure if that's a thing, but it looks interesting. :)\n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 1.)*.5;\n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n\n        \n\t   \n\t\n\t}\n       \n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fog = vec3(.6, .8, 1)/2.*(rd.y*.5 + .5);    \n    sceneCol = mix(sceneCol, fog, smoothstep(0., .95, t/FAR)); // exp(-.002*t*t), etc. fog.zxy\n\n    // Clamp and present the badly gamma corrected pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}