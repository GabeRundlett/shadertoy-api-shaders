{
    "Shader": {
        "info": {
            "date": "1704666512",
            "description": "True 3D or 4D Lyapunov fractal (BCABA or BCADA) rendered using simple ray-marching, chaos=transparent, order=solid, with basic Phong shading. Ref: https://gidden.net/lyapunov\n\n[WIP] Not looking its best; algo was really designed for much higher iters",
            "flags": 0,
            "hasliked": 0,
            "id": "Mfj3WV",
            "likes": 1,
            "name": "4D Lyapunov 3 (capped faces)",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "lyapunov"
            ],
            "usePreview": 0,
            "username": "gid",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "// 3D/4D Markus-Lyapunov fractal, using ray-marching\n//\n// by Tom Gidden <tom@gidden.net> \n//\n// Creative Commons CC BY-SA 4.0\n//\n// Original OpenCL: 2010\n// This version: 2024\n//\n// Adaptation of the familiar 2D Markus-Lyapunovs that render a 2D plane (A,B) where 0 ≤ A ≤ 4, 0 ≤ B ≤ 4\n// and A & B come from a looping sequence of As and Bs, like \"AABAB\".\n//\n// Here, we add third and fourth axes, C (spatial) and D (temporal) on the sequence B,C,A,D,A.\n// Each frame is a 3D \"slice\" of a 4D fractal.\n//\n// Rather than rendering the 2D slice showing colour for both chaos and order (and deep within order),\n// we have to show chaos as transparent and the boundary between chaos and order as a shaded solid.\n// This is done using a simple ray-marcher (like a ray-tracer but without bouncing on reflections)\n//\n// As the \"solid\" areas are fractal, we can't skip through the transparent space quickly,\n// as it's stuffed with tiny pockets of order. Instead, the ray has to march through the\n// space until it hits real order.  Then it refines the location with a back-and-forth,\n// then determines an approximate surface normal for shading.  There's some noise added\n// to the marching to avoid banding and other artefacts (change \"jitter\" in params)\n//\n// This is a rudimentary conversion of CUDA code used to render offline -- seconds per frame, if not more\n// and do it in a relatively efficient way. Getting this stuff to run in real-time involves a significant\n// quality drop.\n//\n// A better render using OpenCL: https://www.youtube.com/watch?v=6JFgkIvIxnM\n// and a playlist of other renders and testing: https://www.youtube.com/playlist?list=PLHAv-hHDbuoIjVlc0APEfLoBr3cyUWMy0\n//\n// For more info: https://gidden.net/lyapunov\n//\n//\n// Incidentally, my apologies for my layman's use of mathematics terminology.\n// Corrections welcome.\n\n\n\n//const int sequence[8] = int[](1, 1, 2, 2, 3, 3, 4, 4); // 4D: AABBCCDD\n//const int sequence[4] = int[](1,2,3,4); // 4D:  ABCD\n\nconst int sequence[5] = int[](2, 3, 1, 4, 1); // 4D: BCADA\n//const int sequence[5] = int[](2, 3, 1, 2, 1); // 3D: BCABA\n\nconst float t1 = 10.0;            // Animation duration\nconst float camPanDegrees = 20.0; // Angle to pan the camera\nconst float camDistance = 8.0;    // Distance of the camera from the point of interest\nconst float camZoom = 0.5;        // Zoom of lens (reciprocal)\nconst vec3 lookAt = vec3(3.0, 3.0, 3.0);  // The point of interest\n\n// Try changing these to o=0.0, d=4.0 to see the full range. A bit too weird for my taste\nconst float originD = 3.25;  // Base value of \"D\" in 4D fractals\nconst float deltaD = 0.5;    // such that D(t) = originD + t*deltaT\n\n\n// Iterations: \n// 1. \"settle\": an initial run of iterations to get started;\n// 2. \"accum\": subsequent iterations that contribute.\n//\n// These numbers should be in the hundreds or more for proper\n// renders.\n\nconst int settle = 5, accum = 10;       // \"Fast\" quality\n//const int settle = 10, accum = 20;    // \"High\" quality\n\n//const int settle = 500, accum = 1000; // Offline rendering. DO NOT USE\n\n\nstruct LyapParams {\n    int settle;             // Initialisation iterations to allow exponent to settle (avoiding noise)\n    int accum;              // Subsequent iterations to accumulate the exponent\n    int stepMethod;         // Ray-marching method. 1=bad, 2=good.\n    float D;                // Value of \"D\" for sequences that include \"D\". Can be tied to time for 4D Lyaps\n    float nearThreshold;    // What constitutes near vs. far, so ray slows down (finer steps) when close.\n    float nearMultiplier;   // And the multiplier when near (um... yeah, bad explanation)\n    float opaqueThreshold;  // Below what exponent constitutes \"order\", ie. opaque\n    float chaosThreshold;   // Below what exponent constitutes \"visible\" chaos, ie. corona\n    float hitOpacity;       // Alpha of a \"solid\" hit, so the first apparent order doesn't stop the ray dead\n    float depth;            // Rough depth of a typical ray, ie. number of expected steps.\n    float jitter;           // Fraction of ray step length to randomise\n    float refine;           // Back-and-forth subdivisions to zero-in on surface (eg. 32)\n    float gradient;         // Fraction of ray length to use for the cardinal box around a hit point to estimate surface normal\n};\n\nLyapParams params = LyapParams(\n    /*settle=*/settle,\n    /*accum=*/accum,\n    /*stepMethod=*/2,\n    /*D=*/originD,          // Will be replaced in main()\n    /*nearThreshold=*/0.5,\n    /*nearMultiplier=*/8.0,\n    /*opaqueThreshold=*/-0.5,\n    /*chaosThreshold=*/-0.25,\n    /*hitOpacity=*/0.25,\n    /*depth=*/128.0,  // should be 512 or more, really!\n    /*jitter=*/0.75,\n    /*refine=*/8.0,  // should be 32 or more\n    /*gradient=*/0.01\n);\n\n\nstruct LyapCam {\n    float M;\n    vec3 C;\n    vec4 Q;\n    vec3 S0;\n    vec3 SDX;\n    vec3 SDY;\n    vec4 ambient;\n    vec4 chaosColor;\n};\n\nLyapCam cam;\n\n\n\n// Calculate camera position and rotation for a given time, 0 ≤ t ≤ 1\nvoid cam_init(float t, float dist) {\n    \n    cam = LyapCam(\n        /*M=*/camZoom,   // \"zoom\"\n        /*C=*/vec3(dist, dist, dist), // Nominal camera location (ie. when t=0.5)\n        /*Q=*/null4,  // will be calculated\n        /*S0=*/null3, // will be calculated\n        /*SDX=*/null3,// will be calculated\n        /*SDY=*/null3,// will be calculated\n        /*ambient=*/vec4(0.001, 0.0, 0.0, 0.0),\n        /*chaosColor=*/vec4(1.0, 0.25, 0.0, 0.2)\n    );\n\n    // Move C on a curved path around target (interesting feature)    \n    vec3 dir = cam.C - lookAt;                // cam relative to lookAt\n    vec3 upIsh = vec3(0.0, 1.0, 0.0);         // roughly up\n    vec3 axis = normalize(cross(dir, upIsh)); // roughly sideways\n    \n    // Get a rotation quat around the axis for the current frame\n    vec4 rot0 = quat_from_axisangle(axis, camPanDegrees/2.0,/*inDegrees=*/true);\n    vec4 rot1 = quat_from_axisangle(axis, camPanDegrees/-2.0,/*inDegrees=*/true);\n    vec4 rotT = quat_nlerp(rot0, rot1, t);\n    \n    // Rotate the relative camera position using the quat\n    vec3 dirT = transform_with_quat(rotT, dir);\n\n    // Move the camera\n    cam.C = lookAt + dirT;\n    \n    // Recalculate the camera's rotation quat to point to lookAt\n    cam.Q = quat_from_vectors(vec3(0.0, 0.0, -1.0), normalize(dirT), 1.0, false);\n\n \n    // Determine the projection frustum vectors: S0 is centre of \"screen\", SDX and SDY\n    // are axis vectors for screen X and screen Y within 3-Lyapunov space\n    cam.S0 = transform_with_quat(cam.Q, vec3(0.0, 0.0, 1.0));\n    cam.SDX = transform_with_quat(cam.Q, vec3(cam.M, 0.0, 0.0));\n    cam.SDY = transform_with_quat(cam.Q, vec3(0.0, cam.M, 0.0));\n}\n\nstruct LyapLight {\n    float M;  // Magnitude / Intensity\n    vec3 C;   // Location of light\n    vec4 Q;   // Direction quat\n    vec3 V;   // Absolute direction vector from Q [via lights_init()]\n    \n    float lightInnerCone, lightOuterCone; // \"Spotlight\" cone\n    float lightRange;  // Range of light.\n\n    vec4 diffuseColor;\n    float diffusePower;\n\n    vec4 specularColor;\n    float specularPower;\n    float specularHardness;\n};\n\nLyapLight lights[2] = LyapLight[](\n    LyapLight(\n        /*M=*/1.0,\n        /*C=*/vec3(5.0, 7.0, 3.0),\n        /*Q=*/vec4(0.710595, 0.282082, -0.512168, 0.391368),\n        /*V=*/vec3(0.0, 0.0, 0.0), // will get recalculated from C,Q\n        /*lightInnerCone=*/0.0,    // will get recalculated from lightRange\n        /*lightOuterCone=*/0.0,    // will get recalculated from lightRange\n        /*lightRange=*/5.0,\n        /*diffuseColor=*/vec4(0.4, 0.45, 0.6, 1.0),\n        /*diffusePower=*/5.0,\n        /*specularColor=*/vec4(0.5, 0.8, 1.0, 1.0),\n        /*specularPower=*/100.0,\n        /*specularHardness=*/500.0\n    ),\n\n    LyapLight(\n        /*M=*/1.0,\n        /*C=*/vec3(3.0, 7.0, 5.0),\n        /*Q=*/vec4(0.039640, 0.840027, -0.538582, -0.052093),\n        /*V=*/vec3(0.0, 0.0, 0.0), // will get recalculated from C,Q\n        /*lightInnerCone=*/0.0,    // will get recalculated from lightRange\n        /*lightOuterCone=*/0.0,    // will get recalculated from lightRange\n        /*lightRange=*/1.5,\n        /*diffuseColor=*/vec4(0.2, 0.25, 0.45, 1.0),\n        /*diffusePower=*/5.0,\n        /*specularColor=*/vec4(0.5, 0.8, 1.0, 1.0),\n        /*specularPower=*/100.0,\n        /*specularHardness=*/500.0\n    )\n);\n\n// Phases\n\nconst int LYAP_NULL = 0;\nconst int LYAP_RUNNING = 1;\nconst int LYAP_OUTOFBOUNDS = 2;\nconst int LYAP_SOLIDATBOUNDS = 3;\n\nstruct LyapPoint {\n    vec3 V;       // direction vector\n    vec3 P;       // Point under consideration: will become the final hit point.\n    vec3 N;       // Surface normal at the hit point.\n\n    float a;      // high-low alpha\n    float c;      // chaos alpha\n    float l;      // Lyapunov exponent\n\n    float t;      // Progress along ray\n    float t0, t1; // t-values of primary intersections of ray against back and front of volume\n    float dt, Ndt, Fdt;  // step delta: current, and \"near\" and \"far\" for different phases.\n\n    int state;    // State of ray\n    bool near;    // Is the ray possibly near a hit?\n};\n\n// The \"interesting\" volume is 0.0 ≤ a,b,c,d ≤ 4.0\nconst float LMIN = 0.0;\nconst float LMAX = 4.0;\n\n\n\n\n// Determine the colour of a point once calculated\n/*RGBA*/ vec4 shade(LyapPoint p) \n{\n    vec4 color;\n    \n    // If the ray immediately hit opacity when entering the cube\n    // then the normal wouldn't be calculated properly by raymarch3\n    // anyway, so it never bothered. Instead, we rely on raymarch0\n    // setting the normal's initial value to the first bound, and\n    // that nothing else should've changed it.\n    if (p.state == LYAP_SOLIDATBOUNDS) {\n        p.a = 1.0;\n        p.t = 0.0;\n        color.xyz += 0.33;\n    }\n    \n    if(isnotfinite(p.t)) {\n        // This is almost definitely the wrong thing to do.\n        return cam.chaosColor / log(p.c);\n    }\n\n    if(p.a == 0.0) {\n        color.w = 0.0;\n        return color;\n    }\n\n    // For each defined light\n    for(int l = 0; l < lights.length(); l++) {\n        vec3 camV;\n        vec3 lightV, halfV;\n        vec4 diffuse, specular, phong;\n        float lightD2, i, j;\n\n        vec3 P = p.P;\n        vec3 N = p.N;\n        //      float a = point.a;\n\n        camV = cam.C - P;\n\n        // Light vector (from point on surface to light source)\n        lightV = lights[l].C - P;\n\n        // Get the length^2 of lightV (for falloff)\n        lightD2 = dot(lightV, lightV);\n\n        // but then normalize lightV.\n        lightV = normalize(lightV);\n\n        // i: light vector dot surface normal\n        i = dot(lightV, N);\n\n        // j: light vector dot spotlight cone\n        j = dot(lightV, lights[l].V);\n        j = -j;\n\n        if(j > lights[l].lightOuterCone) {\n\n            // Diffuse component: k * (L.N) * colour\n            i = clamp(i, 0.0, 1.0);\n            diffuse = lights[l].diffuseColor * (i * lights[l].diffusePower);\n\n            // Halfway direction between camera and light, from point on surface\n            halfV = normalize(camV + lightV);\n\n            // Specular component: k * (R.N)^alpha * colour\n            // R is natural reflection, which is at 90 degrees to halfV (?)\n            // (or is it?  Hmmm.  https://en.wikipedia.org/wiki/Phong_reflection_model)\n            i = clamp(dot(N, halfV), 0.0, 1.0);\n            i = pow(i, lights[l].specularHardness);\n\n            specular = lights[l].specularColor * (i * lights[l].specularPower);\n\n            phong = (specular + diffuse) * lights[l].lightRange / lightD2;\n\n            if(j < lights[l].lightInnerCone)\n                phong *= ((j - lights[l].lightOuterCone) / (lights[l].lightInnerCone - lights[l].lightOuterCone));\n\n            phong += cam.ambient;\n        } else {\n            phong = cam.ambient;\n        }\n\n        color += phong;\n    }\n\n    if(p.c > 0.0)  // Chaos\n        color += vec4(cam.chaosColor.xyz * cam.chaosColor.a / log(p.c), 1.0);\n\n    return color;\n}\n\n// Calculate Lyapunov exponent for sequence where A=P.x, B=P.y, C=P.z, D=d\nfloat lyap4d(vec3 P) \n{\n    float abcd[5] = float[](0.0, P.x, P.y, P.z, params.D);\n\n    int seqi = 0; // Position in the sequence loop\n    const int seqL = sequence.length();\n\n    float r;       // Iteration value\n    float v = 0.5; // Iterating value\n    float l = 0.0; // Result accumulator\n    \n    // Settle by running the iteration without accumulation\n    for(int n = 0; n < params.settle; n++) {\n        r = abcd[sequence[seqi++]];\n        if(seqi >= seqL) seqi = 0;\n        v = r * v * (1.0 - v);\n    }\n    \n    if((v - 0.5 <= -1e-8) || (v - 0.5 >= 1e-8)) {\n        // Now calculate the value by running the iteration with accumulation\n        for(int n = 0; n < params.accum; n++) {\n            r = abcd[sequence[seqi++]];\n            if(seqi >= seqL) seqi = 0;\n            v = r * v * (1.0 - v);\n            r = r - 2.0 * r * v;\n\n            if(r < 0.0)\n                r = -r;\n\n            l += log(r);\n\n            if(isnotfinite(l))\n                return LYAP_INF;\n        }\n    }\n\n    return l / float(params.accum);\n}\n\n\nvoid determinePlaneIntersection(inout LyapPoint p, const int j, const float m)\n{\n    // Find the intersection points of a ray with a plane of a constant value 'm' of\n    // a given axis (x: j==0, y: j==1, z: j==2) ,  If the ray is parallel to the axis, \n    // then the intersection is at ±Infinity, and is ignored.\n    \n    float t;    // Value of 't' in ray equation for intersection point\n    vec3 _P;    // Intersection point\n\n    // The other two axes\n    int k = j==1 ? 0 : 1;\n    int l = j==2 ? 0 : 2;\n    \n    // If the ray isn't running along the j-axis (and thus intersects the planes at ±Infinity)...\n    if (p.V[j] != 0.0) {\n\n        // Calc the value of t where the ray intersects the j-min plane\n        t = (m - cam.C[j]) / p.V[j];\n\n        // Calc the corresponding point for the value t\n        _P = cam.C + p.V * t;\n\n        // If the j-min axis intersection is outside 0<=k<=4, 0<=l<=4, eliminate it.\n        if(_P[k] >= LMIN && _P[k] <= LMAX && _P[l] >= LMIN && _P[l] <= LMAX) {\n\n            // If it's more extreme than either current bound, set it as the new bound.\n            if (t < p.t0) { \n                p.t0 = t; \n                p.P = _P;\n                \n                // Set the normal. On most points, raymarch3 will overwrite this\n                // with the correct normal estimate, but then we hit solid on immediate\n                // entry to the cube, the normal never gets recalculated so we can\n                // store the cube face's normal here to cap off the solid section.\n                p.N = vec3(0.0, 0.0, 0.0);\n                p.N[j] = m==0.0 ? -1.0 : 1.0;\n            }\n            if (t > p.t1) p.t1 = t;\n        }\n    }\n}\n\n\n// New implementation: unrolled, slightly more efficient, buggy\nbool determineBoundsIntersections(inout LyapPoint p) {\n    \n    // Find where the ray intersects the sides of the bounding cube\n    // [0…4, 0…4, 0…4] and determine the smallest and largest finite values of\n    // 't' for the ray equation for these intersections. Any planes that are\n    // parallel to the ray will meet the ray at Infinity.\n    //\n    // Zero, one or two of these intersections will occur at a point\n    // where all x, y and z are between 0 and 4 (ie. inside the cube)\n    //\n    // Actually, all six might occur within the cube, but\n    // only if the points are equal. So, zero, one or two _unique_\n    // intersections will occur. This is because zero, one or two\n    // points on a line intersect a cube.\n    //\n    // So, for each one, eliminate it if the intersection point lies\n    // outside the bounds of the other two axes.\n    //\n    // If it's valid, then find the smallest and largest finite 't' \n    // values for all the intersections.  This identifies which of the \n    // bounding planes the ray hits first and last.  The others can be ignored.\n\n    p.t0 = LYAP_INF;\n    p.t1 = LYAP_NINF;\n\n    // If the ray isn't running along the x-axis (and thus intersects the x-planes at ±Infinity)...\n    determinePlaneIntersection(p, 0, LMIN);\n    determinePlaneIntersection(p, 0, LMAX);\n\n    // If the ray isn't running along the y-axis (and thus intersects the y-planes at ±Infinity)...\n    determinePlaneIntersection(p, 1, LMIN);\n    determinePlaneIntersection(p, 1, LMAX);\n\n    // If the ray isn't running along the z-axis (and thus intersects the z-planes at ±Infinity)...\n    determinePlaneIntersection(p, 2, LMIN);\n    determinePlaneIntersection(p, 2, LMAX);\n\n    // If failed to find a moving ray within the volume, then terminate the ray\n    // before it starts\n    if(p.t1 == 0.0)\n        return false;\n\n    if(p.t0 < 0.0) {\n        p.t0 = 0.0;\n        p.P = cam.C;\n    }\n\n    // At this point, p.P should equal cam.C + p.V * p.t0\n\n    // If only one point matched, then the ray must(?) start in\n    // the volume and exit it, so we can start at zero instead.\n    if(p.t0 == p.t1) {\n        p.t1 = p.t0;\n        p.t0 = 0.0;\n    }\n\n    // So, we start at t=t0\n    p.t = p.t0;\n\n    return true;\n}\n\n// Phase 0: set up the ray\nLyapPoint raymarch0(vec2 uv) \n{\n    LyapPoint p;\n    p.state = LYAP_RUNNING;\n    \n    // Work out the direction vector: start at C (camera), and\n    // find the point on the screen plane (in 3D)\n    p.V = normalize(cam.S0 + cam.SDX * uv.x + cam.SDY * uv.y) / cam.M;\n\n    // float thresholdRange = params.opaqueThreshold - params.nearThreshold;\n\n    // Find where the ray intersects the sides of the bounding cube\n    // [0…4, 0…4, 0…4] and determine the smallest and largest finite values of\n    // 't' for the ray equation for these intersections. Any planes that are\n    // parallel to the ray will meet the ray at Infinity.\n\n    // If the ray does not usefully intersect the volume...\n    if (!determineBoundsIntersections(p)) {\n        p.state = LYAP_OUTOFBOUNDS;\n        return p;\n    }\n\n    // Set the alpha accumulators to zero\n    p.a = 0.0;\n    p.c = 0.0;\n\n    // dt is the amount to add to 't' for each step in the initial\n    // ray progression.  We calculate Fdt for the normal value,\n    // and Ndt for the finer value used when close to the threshold\n    // (ie. under nearThreshold)\n\n    // There are different methods of progressing along the ray.\n\n    switch(params.stepMethod) {\n    case 1:\n        // Method 1 divides the distance between the start and the end of\n        // the ray equally.\n        p.Fdt = (p.t1 - p.t0) / params.depth;\n    break;\n\n    case 2: \n    default:\n        // Method 2 (default) divides the distance from the camera to the\n        // virtual screen equally.\n        p.Fdt = length(p.V) / params.depth;\n    }\n\n    p.dt = p.Fdt;\n    p.Ndt = p.dt / params.nearMultiplier;\n    p.near = false;\n    \n    return p;\n}\n\n// Phase 1: Coarse ray marching\nvoid raymarch1(inout LyapPoint p)\n{\n    // Okay, now we do the initial ray progression: we trace until the\n    // exponent for the point is below a certain value. This value is\n    // effectively the transition between transparent and opaque.\n    \n    // Calculate the exponent at the current point.\n    p.l = lyap4d(p.P);\n    p.a = 0.0;\n\nif (p.l <= params.opaqueThreshold) {\n    p.a = 1.0;\n    p.state = LYAP_SOLIDATBOUNDS;\n    return;\n}\n\n    // While the exponent is above the surface threshold (ie. while the\n    // current point is in \"transparent\" space)...\n    while(p.a <= 1.0)\n    // while (p.l > params.opaqueThreshold)\n    {\n        // Step along the ray by 'dt' plus/minus a certain amount of\n        // jitter (optional). This reduces moire fringes and herringbones\n        // resulting from transitioning through thin sheets. Instead we\n        // get what looks like noise, but is in fact stochastic sampling\n        // of a diaphanous transition membrane.\n\n        if(params.jitter != 0.0) {\n            // We use the fractional part of the last Lyapunov exponent\n            // as a pseudo-random number. This is then added to 'dt', scaled\n            // by the amount of jitter requested.\n            float jit = p.l - trunc(p.l);\n            if(jit < 0.0) jit = 1.0 - jit * params.jitter;\n            else jit = 1.0 + jit * params.jitter;\n\n            if(isfinite(jit)) {\n                p.t += p.dt * jit;\n                p.P += p.V * p.dt * jit;\n            } else {\n                p.t += p.dt;\n                p.P += p.V * p.dt;\n            }\n        } else {\n            // No jitter, so just add 'dt'.\n            p.t += p.dt;\n            p.P += p.V * p.dt;\n        }\n\n        // If the ray has passed the first exit plane, then bugger it.\n        // if (t>t1 || !P.in_lyap_space()) { // Overkill: passing t1 should be the exit of L-space anyway\n        if(p.t > p.t1) {\n            p.state = LYAP_OUTOFBOUNDS;\n            return;\n        }\n\n        // Calculate this point's exponent\n        p.l = lyap4d(p.P);\n\n        // If the ray is still in transparent space, then we may still\n        // want to accumulate alpha for clouding.\n        if(p.l > params.chaosThreshold) {\n            p.c += p.l;\n        } else if(p.l > params.opaqueThreshold) {\n            // Close-to-surface transparent space (?)\n        } else {\n            // Opaque\n            p.a += params.hitOpacity;\n            // p.a += (params.opaqueThreshold-p.l) * params.hitOpacity;\n        }\n\n        if(p.l <= params.nearThreshold && ! p.near) {\n            p.near = true;\n            p.dt = p.Ndt;\n        } else if(p.l > params.nearThreshold && p.near) {\n            p.near = false;\n            p.dt = p.Fdt;\n        }\n    }\n\n    // Clamp alpha between 0 and 1\n    p.a = clamp(p.a, 0.0, 1.0);\n\n    // At this point, the ray has either hit an opaque point, or\n    // has exited Lyapunov space.\n    return;\n}\n\n// Phase 2: Post-hit refinement\nvoid raymarch2(inout LyapPoint p) {\n    // Now we've hit the surface, we now need to hone the intersection point \n    // by reversing back along the ray at half the speed.\n\n    // If we've gone through then sign is 0. 'sign' is\n    // the direction of the progression.\n    bool sign = false;\n    bool osign = sign;\n\n    // Half speed\n    float Qdt = p.dt * - 0.5;\n    vec3 QdV = p.V * Qdt;\n\n    // Set the range of the honing to <t-dt, t>.\n    float Qt1 = p.t;\n    float Qt0 = p.t - p.dt;\n\n    // Honing continues reversing back and forth, halving speed\n    // each time. Once dt is less than or equal to dt/refine,\n    // we stop: it's close enough.\n    float min_Qdt = p.dt / params.refine;\n\n    // While 't' is still in the range <t-dt, t> AND dt is still\n    // of significant size...\n    while(p.t <= Qt1 && p.t >= Qt0 && (Qdt <= - min_Qdt || Qdt >= min_Qdt)) {\n        // Progress along the ray\n        p.t += Qdt;\n        p.P += QdV;\n\n        // Calculate the exponent\n        p.l = lyap4d(p.P);\n\n        // If we've hit the threshold exactly, short-circuit.\n        if(p.l == params.opaqueThreshold) break;\n\n        // Work out whether we reverse or not:\n        osign = sign;\n        sign = (p.l >= params.opaqueThreshold);\n\n        // If we've reversed, then halve the speed\n        if(sign != osign) {\n            Qdt *= - 0.5;\n            QdV *= - 0.5;\n        }\n    }\n\n    // At this point, we should be practically on the surface, rather\n    // than above or through. Anyway, we're close enough.  P is now\n    // our hit point.\n}\n\n// Phase 3: Work out surface normal for shading\nvoid raymarch3(inout LyapPoint p) \n{\n    // Next, we want to find the surface normal at P. A good approximation\n    // is to get the vector gradient by calculating the Lyapunov exponent\n    // at the six cardinal points surrounding P +/- a tiny amount, which\n    // we assume to be small enough that the Lyapunov exponent approximates\n    // to a linear function.\n    //\n    // Find the difference for each axis, and normalize. The result is\n    // pretty close.\n\n    float mag = p.dt * params.gradient;\n\n    p.N = normalize(vec3(\n        lyap4d(vec3(p.P.x + mag, p.P.y, p.P.z)) - lyap4d(vec3(p.P.x - mag, p.P.y, p.P.z)),\n        lyap4d(vec3(p.P.x, p.P.y + mag, p.P.z)) - lyap4d(vec3(p.P.x, p.P.y - mag, p.P.z)),\n        lyap4d(vec3(p.P.x, p.P.y, p.P.z + mag)) - lyap4d(vec3(p.P.x, p.P.y, p.P.z - mag))\n    ));\n\n    // Okay, we've done it. Output the hit point, the normal, the exact\n    // exponent at P (not Really needed, but it does signal a hit failure\n    // when l is NaN), and the accumulated alpha.\n}\n\n// Calculate the direction of each light using their quat-based rotation, and then their light cone.\nvoid lights_init() {\n\n    for (int l=0; l<lights.length(); ++l) {\n        float m = lights[l].M;\n        if (m==0.0) return;\n\n        // Convert the light-local Z direction (0,0,1) to absolute using the light's Q.\n        lights[l].V = normalize(transform_with_quat(lights[l].Q, vec3(0.0, 0.0, 1.0)));\n\n        lights[l].lightInnerCone = dot(lights[l].V, normalize(transform_with_quat(lights[l].Q, vec3(-m, -m, 1.5))));\n        lights[l].lightOuterCone = dot(lights[l].V, normalize(transform_with_quat(lights[l].Q, vec3(-m, -m, 1))));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Animation progress from 0 to 1\n    float t = fract(iTime / t1);\n\n    // Synthesize the \"D\" axis for 4D renders\n    params.D = originD + t*deltaD;\n\n    float dist = camDistance;\n    \n    // Interactivity!!\n    if (iMouse.z > 10.0) {\n        dist = 3.0 + 4.0 * iMouse.y / iResolution.y;\n        t = 1.0 - iMouse.x / iResolution.x;\n    }\n\n    // Initialise the camera location\n    cam_init(t, dist);\n    \n    // Initialise lights.\n    lights_init();\n\n    // Convert to -1 ≤ uv ≤ 1\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n        \n    // Ray march\n    LyapPoint p = raymarch0(uv);\n    if(p.state == LYAP_RUNNING) raymarch1(p);\n    if(p.state == LYAP_RUNNING) raymarch2(p);\n    if(p.state == LYAP_RUNNING) raymarch3(p);\n\n\n    // Convert the abstract point structure -- position, surface normal,\n    // chaos, etc. -- into a colour, using the lights provided.\n    fragColor = shade(p);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nconst float LYAP_INF = 1.0e+30;\nconst float LYAP_NAN = -1.0e+30;\nconst float LYAP_NINF = LYAP_NAN;\nconst float LYAP_EPSILON = 1.0e-29;\n\nbool isNAN(float f) {\n    return f <= LYAP_NAN;\n}\n\nbool isnotfinite(float f) {\n    return f <= LYAP_NAN || f >= LYAP_INF || f <= LYAP_NINF;\n}\n\nbool isfinite(float f) {\n    return f > LYAP_NAN && f < LYAP_INF;\n}\n\n//// Requires #version 330 or greater to work :(\n//\n// const float LYAP_NAN = intBitsToFloat(int(0xFFC00000u));\n// const float LYAP_INF = intBitsToFloat(int(0x7F800000u));\n// const float LYAP_NINF = intBitsToFloat(int(0xFF800000u));\n// const float LYAP_EPSILON = 1.0e-29;\n// \n// bool isNAN(float f) {\n//     return isnan(f);\n// }\n// \n// bool isnotfinite(float f) {\n//     return isnan(f) || isinf(f);\n// }\n// \n// bool isfinite(float f) {\n//     return !isnan(f) && !isinf(f);\n// }\n\n\nvec3 null3 = vec3(0.0, 0.0, 0.0);\nvec4 null4 = vec4(0.0, 0.0, 0.0, 0.0);\n\n\nvec4 quat_from_axisangle(vec3 axis, float ang, bool inDegrees)\n{\n    ang = inDegrees ? (ang*3.1415926f/360.0f) : (ang*0.5f);\n    return normalize(vec4(axis * sin(ang), cos(ang)));\n}\n\nvec4 quat_nlerp(vec4 q0, vec4 q1, float t)\n{\n    if (t==0.0 || (t<LYAP_EPSILON)) {\n        return q0;\n    }\n    else if (t==1.0f || (t>1.0f-LYAP_EPSILON)) {\n        return q1;\n    }\n    else {\n        float dp = dot(q0, q1);\n        float tA = dp>=0.0 ? t : -t;\n        float tI = 1.0f-t;\n        return normalize(vec4(q0*tI + q1*tA));\n    }\n}\n\nvec3 transform_with_quat(vec4 q, vec3 v)\n{\n    return vec3(\n        q.w*q.w*v.x + 2.0*q.y*q.w*v.z - 2.0*q.z*q.w*v.y + q.x*q.x*v.x + 2.0*q.y*q.x*v.y + 2.0*q.z*q.x*v.z - q.z*q.z*v.x - q.y*q.y*v.x,\n        2.0*q.x*q.y*v.x + q.y*q.y*v.y + 2.0*q.z*q.y*v.z + 2.0*q.w*q.z*v.x - q.z*q.z*v.y + q.w*q.w*v.y - 2.0*q.x*q.w*v.z - q.x*q.x*v.y,\n        2.0*q.x*q.z*v.x + 2.0*q.y*q.z*v.y + q.z*q.z*v.z - 2.0*q.w*q.y*v.x - q.y*q.y*v.z + 2.0*q.w*q.x*v.y - q.x*q.x*v.z + q.w*q.w*v.z\n    );\n}\n\nvec4 quat_from_vectors(vec3 v0, vec3 v1, float scale, bool _normalize)\n{\n    vec3 m0 = _normalize ? normalize(v0) : v0;\n    vec3 m1 = _normalize ? normalize(v1) : v1;\n\n    vec3 c = cross(m0, m1);\n    float d = dot(m0, m1);\n    float s = sqrt((1.0 + d) * 2.0);\n    vec4 p = vec4(c / s, s * 0.5);\n    if (scale != 1.0) p *= scale;\n    return p;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}