{
    "Shader": {
        "info": {
            "date": "1523918502",
            "description": "an sdf union function which leaves a margin between the shapes.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldcfzn",
            "likes": 2,
            "name": "padded union",
            "published": 3,
            "tags": [
                "sdf",
                "union",
                "padding"
            ],
            "usePreview": 0,
            "username": "expertmouser",
            "viewed": 442
        },
        "renderpass": [
            {
                "code": "\nvec4 oColor;\nvec2 vTexcoord;\n\n//-----------------------------------------------------------\n\n\nconst float kEpsilon     = 0.0001;\nconst float kMyPI        = 3.14159265359;\nconst float kLargeFloat  = 10000000.0; \nconst float kCloseEnough = 0.005;\nconst float kDegToRad    = (kMyPI * 2.0) / 360.0;\nconst float kRadToDeg    = 360.0 / (kMyPI * 2.0);\nconst vec3  kVecX        = vec3(1.0, 0.0, 0.0);\nconst vec3  kVecY        = vec3(0.0, 1.0, 0.0);\nconst vec3  kVecZ        = vec3(0.0, 0.0, 1.0);\nconst vec3  kVec0        = vec3(0.0);\nconst vec3  kVec1        = vec3(1.0);\n\n      float myTime       = 0.0;\n\n//--------------------------------------------\n// basic math\n\nfloat avg(float a, float b) {\n  return (a + b) * 0.5;\n}\n\nmat2 rot2(float radians) {\n  float c = cos(radians);\n  float s = sin(radians);\n  return mat2(c, s, -s, c);\n}\n\nfloat sdfUnionPadded(float a, float b, float padA, float padB) {\n  // i'm not sure this can be simplified.\n  // it can be expressed as five abs() calls plus some divide by fours,\n  // but i'm hesitant to go there. i suspect min/max are non-branching in GPUs.\n  float sub1 = max(a - padA, -a);\n  float sub2 = max(b - padB, -b);\n  float sub  = min(sub1, sub2);\n  float ret  = max(min(a, b), -sub);\n  return ret;\n}\n\nfloat sdfUnion(float a, float b) {\n  return min(a, b);\n}\n\nfloat sdfIntersect(float a, float b) {\n  return max(a, b);\n}\n\nfloat sdfMinus(float a, float b) {\n  return max(a, -b);\n}\n\n//--------------------------------------------\n// SDF Primititves\n\nfloat sdfCircle(vec2 pnt, vec2 center, float radius) {\n  return length(pnt - center) - radius;\n}\n\nfloat sdfAnulus(vec2 pnt, vec2 center, float radius1, float radius2) {\n  return sdfMinus(\n    sdfCircle(pnt, center, radius2),\n    sdfCircle(pnt, center, radius1));\n}\n\nfloat sdfSquare(vec2 pnt, vec2 center, float shortRadius) {\n  vec2 v = pnt - center;\n  float ret = -kLargeFloat;\n  ret = max(ret,  v.x - shortRadius);\n  ret = max(ret, -v.x - shortRadius);\n  ret = max(ret,  v.y - shortRadius);\n  ret = max(ret, -v.y - shortRadius);\n  return ret;\n}\n\n//--------------------------------------------\n// scene\n\nfloat sdfScene(vec2 pnt) {\n  float t = myTime * 0.51;\n\n  float rad = (sin(t) * 0.5 + 1.0) * 7.0;\n  float pad1 = rad * 0.95 * (sin(t * 0.27) * 0.21 + 0.19);\n  \n  vec2 c1 = vec2(sin(t * 1.0), cos(t * 1.2)) * 10.0;\n  vec2 c2 = vec2(sin(t * 1.3), cos(t * 1.5)) * 10.0;\n  vec2 c3 = vec2(sin(t * 1.6), cos(t * 1.7)) * 10.0;\n\n  float sdfc1 = sdfCircle(pnt, c1, rad);\n  float sdfc2 = sdfAnulus(pnt, c2, rad + 2.0, rad + 6.0);\n  float sdfc3 = sdfSquare(pnt * rot2(t * -0.81), c3, rad);\n\n  float ret;\n  bool usePadded = true;\n  usePadded = int(myTime ) / 4 % 2 == 0;\n  if (usePadded) {  \n    ret = sdfUnionPadded(sdfc1, sdfc2, pad1, pad1);\n    ret = sdfUnionPadded(ret  , sdfc3, pad1, pad1);\n  }\n  else {\n    ret = sdfUnion(sdfc1, sdfc2);\n    ret = sdfUnion(ret  , sdfc3);\n  }\n    \n  return ret;\n}\n\nvec3 background(vec2 pnt) {\n  float t = myTime * 0.221;\n\n  pnt *= 0.9;\n  pnt.y += sin(t * 1.0);\n  pnt *= rot2(t * 0.1);\n  // pnt *= mod(pnt, 0.3)* 9.1;\n  float g = sin(length(pnt) - t * 20.0) * 1.2 + 0.4;\n  float f = 0.0;\n  float r = 0.0;\n  f += sin((pnt * rot2(kDegToRad * (t *   7.0 + g))).x + t * 0.9);\n  f += sin((pnt * rot2(kDegToRad * (t * -11.0 + g))).x + t * 1.0);\n  f += sin((pnt * rot2(kDegToRad * (t * -21.0 + g))).x + t * 1.1);\n  f += sin((pnt * rot2(kDegToRad * (t *  31.0 + g))).x + t * 1.1);\n  f = f * 0.35 + 0.7;\n  f *= f * f;\n  f *= f;\n  f = f * 0.05 + 0.5;\n  vec3 ret = vec3(f);\n  // ret.x += sin(pnt.x) > 0.99 ? 0.1 : 0.0;\n  // ret.x += sin(pnt.y) > 0.99 ? 0.1 : 0.0;\n  return ret;\n}\n\n//--------------------------------------------\n\nvoid otherMain(void)\n{\n  float sceneScale = sin(myTime * 0.1) * 19.0 + 27.0;\n\n  vec2  squareUV = 2.0 * (vTexcoord - 0.5) * iResolution.xy / avg(min(iResolution.x, iResolution.y), avg(iResolution.x, iResolution.y));\n\n  vec2 pnt = squareUV * sceneScale;\n\n  float sdf = sdfScene(pnt);\n  float isdf = min(sdf * 0.3 + 0.7, 1.0);\n  vec3 bg = background(pnt);\n  vec3 itemsColor = vec3(\n    sin(myTime * 0.201) * 0.2 + 0.3,\n    sin(myTime * 0.211) * 0.2 + 0.4,\n    sin(myTime * 0.221) * 0.2 + 0.7\n  );\n  oColor.rgb = bg;\n  oColor.rgb = sdf < 0.0 ? bg * itemsColor * -sdf : bg * isdf;\n\n    \n  oColor.a = 1.0;\n}\n\n\n//---------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vTexcoord = fragCoord / iResolution.xy;\n    myTime = iTime;\n    otherMain();\n    fragColor = oColor;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}