{
    "Shader": {
        "info": {
            "date": "1512755594",
            "description": "A study on symmetry. I used this [url=https://patterninislamicart.com/drawings-diagrams-analyses/5/geometric-patterns-borders/gpb033]pattern[/url] as an inspiration and tried to colorize it.. Fullscreen is better.",
            "flags": 0,
            "hasliked": 0,
            "id": "MlsfRX",
            "likes": 32,
            "name": "Islamic Pattern",
            "published": 3,
            "tags": [
                "2d",
                "pattern",
                "symmetry"
            ],
            "usePreview": 0,
            "username": "rigel",
            "viewed": 1812
        },
        "renderpass": [
            {
                "code": "// Author: Rigel rui@gil.com\n// licence: https://creativecommons.org/licenses/by/4.0/\n// link: https://www.shadertoy.com/view/MlsfRX\n\n\n/*\nA study on symmetry. Took this pattern as a challenge and then tried to colorize it.\nhttps://patterninislamicart.com/drawings-diagrams-analyses/5/geometric-patterns-borders/gpb033\n\nThe plane has four kind of symmetric operations\n- translations\n- rotations\n- reflections\n- glide reflections\n\nThis pattern only have the first three.\nEverything is made of two simple rectangles, with translations, rotations, and\nreflections.\n\n*/\n\n#define TAU 6.2831\n\n// cartesian to polar coordinates\nvec2 toPolar(vec2 uv) { return vec2(length(uv),atan(uv.y,uv.x)); }\n// polar to cartesian coordinates\nvec2 toCarte(vec2 z) { return z.x*vec2(cos(z.y),sin(z.y)); }\n// 2d rotation matrix\nmat2 uvRotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n// A signed distance function for a rectangle\nfloat sdfRect(vec2 uv, vec2 s) { vec2 auv = abs(uv); return max(auv.x-s.x,auv.y-s.y); }\n// To fill an sdf with 0's or 1's\nfloat fill(float d, float i) { return abs(smoothstep(.0,.02,d) - i); }\n\n// palette from iq -> https://www.shadertoy.com/view/ll2GD3\nvec3 pal(float d) { return .5 + .5 * cos(TAU*(d+vec3(.0,.10,.20))); }\n\n// This makes a symmetric rotation around the origin.\n// n is the number of slices, and everything is remmapped to the first one.\nvec2 symrot(vec2 uv, float n) { \n    vec2 z = toPolar(uv); \n    return toCarte(vec2(z.x,mod(z.y,TAU / n) - TAU/(n*2.) ));\n}\n\n// This is the fundamental pattern where everything in the plane is remapped\n// with symmetric operations.\nvec3 pattern(vec2 uv) {\n\t\n    // The coordinates for the two rectangles\n\tvec2 uv1 = uv*uvRotate(radians(30.));\n\tvec2 uv2 = uv*uvRotate(radians(-30.));\n\t\n    // The signed distance functions\n\tfloat sdfr1 = sdfRect(uv1,vec2(.1,.7));\n\tfloat sdfr2 = sdfRect(uv2,vec2(.1,.7));\n\t\n    // A fill to keep track of their areas and masks\n\tfloat r1 = fill(sdfr1,1.);\n\tfloat r2 = fill(sdfr2,1.);\n\n\tfloat r1mask = 1.-r1;\n\tfloat r2mask = 1.-r2;\n\n\t// Two waves, they are nothing more than the difference between two sine waves\n\tfloat wave1 = r1 * max(fill(0.05*sin((uv1.y+.5)*TAU+1.57)-uv1.x,0.),\n\t\t\t\t\t\t   fill(uv1.x-0.05*sin((uv1.y+.5)*TAU),0.));\n\t\n\tfloat wave2 = r1mask * r2 * max(fill(0.05*sin((uv2.y+.5)*TAU+1.57)-uv2.x,0.),\n\t\t\t\t\t\t\t\t\tfill(uv2.x-0.05*sin((uv2.y+.5)*TAU),0.));\n\t// The background\n\tvec3 bg = pal(.5-uv.y*.1);\n    // Three circles to make the center flower\n    float circle = length(uv-vec2(.0,.4));\n    bg =  mix(bg, pal(.0), smoothstep(0.4,.0,circle) );\n\tbg =  mix(bg, pal(.5), smoothstep(0.11,.0,circle) );\n\tbg =  mix(bg, pal(.9), smoothstep(0.02,.0,circle) );\n\t\n \t// Composing the rectangles and the waves to set up the foreground\n\tfloat d =  max(min(max(r1mask*r2,r1),wave1),wave2);\n\t\n    // Colorizing the foreground\n\tvec3 fg = mix(pal(.9-uv.y*2.),pal(.15+uv.y*.1),d);\n\t// Adding a black contour to the rectangles \n    fg = mix(fg,vec3(.0),max(r1mask*fill(abs(sdfr2),1.),fill(abs(sdfr1),1.)));\n\t// Adding a faux 3d to the interlace of the rectangles\n    fg = mix(fg,fg*.4,r2*smoothstep(.0,.01,sdfr1)-smoothstep(.0,.1,sdfr1));\n\t\n    // return foreground and background\n    return mix(fg,bg,min(r1mask,r2mask));\n}\n\n// from Shane -> https://www.shadertoy.com/view/llSyDh\n// I've removed the comments. Go to Shane shader to see them.\n// This provides the translation symmetry, remaps everything in the plane to\n// an hexagon centered at [0,0]\nvec2 lattice6(vec2 uv) {\n    const vec2 s = vec2(1, 1.7320508);\n\t\n    vec4 hC = floor(vec4(uv, uv - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(uv - hC.xy*s, uv - (hC.zw + .5)*s);\n\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec2(h.xy) : vec2(h.zw);\n}\n\n// The scene is just symmetry operations\nvec3 scene(vec2 uv) {\n\t\n    // translation symmetry\n\tuv = lattice6(uv)*6.;\n\t\n    // a small alignement because the lattice is pointy hexagon side up\n    // and my pattern is flat topped.\n\tuv *= uvRotate(radians(30.));\n\n    // 6 fold rotations\n\tuv = symrot(uv,6.)-vec2(2.,.0); // 4\n    // 3 fold rotation\n\tuv = symrot(uv,3.)-vec2(1.,0.); // 3\n    // 3 fold rotation\n\tuv = symrot(uv,3.)-vec2(.5,.0); // 2\n\t\n    // reflection on the y axis with a flip on the x to do an interlace\n\tuv = vec2(sign(uv.y)*uv.x,abs(uv.y))-vec2(0.,.4+.05*cos(iTime+uv.x*6.28)); // 1\n    // if you want to see how the pattern is constructed\n    // comment all the lines 1 to 4, and then uncomment one by one 1,2,3,4\n\t\n    // draw the pattern\n\treturn pattern(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ( fragCoord.xy - iResolution.xy*.5)/ iResolution.y ;\n    fragColor = vec4( scene(uv), 1.0 );\n    // uncomment to see the original pattern    \n    //fragColor = vec4( pattern(uv*2.), 1.0 ); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}