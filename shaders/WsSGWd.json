{
    "Shader": {
        "info": {
            "date": "1550322146",
            "description": "Grass shader used in procedural world generation\nhttps://github.com/BynaryCobweb/world/",
            "flags": 0,
            "hasliked": 0,
            "id": "WsSGWd",
            "likes": 15,
            "name": "Grass texture",
            "published": 3,
            "tags": [
                "procedural",
                "texture",
                "grass"
            ],
            "usePreview": 0,
            "username": "BynaryCobweb",
            "viewed": 1791
        },
        "renderpass": [
            {
                "code": "\n#define BLADES_SPACING 0.004\n#define JITTER_MAX 0.004\n// depends on size of grass blades in pixels\n#define LOOKUP_DIST 5\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n#define PI 3.14\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/// 2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 getGrassColor(float x) {\n    vec3 a = vec3(0.2, 0.4, 0.3);\n    vec3 b = vec3(0.3, 0.5, 0.2);\n    vec3 c = vec3(0.2, 0.4, 0.2);\n    vec3 d = vec3(0.66, 0.77, 0.33);\n    vec3 col = a + b * cos(2. * PI * (c * x + d));\n    return col;\n}\n\nfloat getGrassBlade(in vec2 position, in vec2 grassPos, out vec4 color) {\n\t// between {-1, -1, -1} and {1, 1, 1}\n    vec3 grassVector3 = hash32(grassPos * 123512.41) * 2.0 - vec3(1);\n    // keep grass z between 0 and 0.4\n    grassVector3.z = grassVector3.z * 0.2 + 0.2;\n    vec2 grassVector2 = normalize(grassVector3.xy);\n\n    float grassLength = hash12(grassPos * 102348.7) * 0.01 + 0.012;\n\n    // take coordinates in grass blade frame\n    vec2 gv = position - grassPos;\n    float gx = dot(grassVector2, gv);\n    float gy = dot(vec2(-grassVector2.y, grassVector2.x), gv);\n    float gxn = gx / grassLength;\n\n    // TODO make gy depends to gx\n    if (gxn >= 0.0 && gxn <= 1.0 && abs(gy) <= 0.0008 * (1. - gxn * gxn)) {\n        vec3 thisGrassColor = getGrassColor(hash12(grassPos * 2631.6));\n        color = vec4(thisGrassColor * (0.2 + 0.8 * gxn), 1.0);\n    \treturn grassVector3.z * gxn;\n    }\n    else {\n        color = vec4(0., 0., 0., 1.);\n        return -1.0;\n    }\n}\n\nfloat getPoint(in vec2 position, out vec4 color) {\n   \tint xcount = int(1. / BLADES_SPACING);\n    int ycount = int(1. / BLADES_SPACING);\n    int ox = int(position.x * float(xcount));\n    int oy = int(position.y * float(ycount));\n\n    float maxz = 0.0;\n\n    for (int i = -LOOKUP_DIST; i < LOOKUP_DIST; ++i) {\n        for (int j = -LOOKUP_DIST; j < LOOKUP_DIST; ++j) {\n            vec2 upos = vec2(ox + i, oy + j);\n            vec2 grassPos = (upos * BLADES_SPACING + hash22(upos) * JITTER_MAX);\n\n            vec4 tempColor;\n            float z = getGrassBlade(position, grassPos, tempColor);\n\n            if (z > maxz) {\n                maxz = z;\n                color = tempColor;\n            }\n        }\n    }\n    if (maxz == 0.0) {\n        color = vec4(0.);\n    }\n\n    return maxz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/vec2(1200., 1200.);\n    \n    vec4 color;\n    float z = getPoint(uv, color);\n    \n    // Output to screen\n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}