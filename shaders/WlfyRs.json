{
    "Shader": {
        "info": {
            "date": "1592737606",
            "description": "This is a description of a shader",
            "flags": 32,
            "hasliked": 0,
            "id": "WlfyRs",
            "likes": 13,
            "name": "Spherical 360 camera",
            "published": 3,
            "tags": [
                "camera",
                "spherical",
                "360"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 495
        },
        "renderpass": [
            {
                "code": "\n// This is a way to get camera effects like in here: https://youtu.be/xO8nJXu2RUI?t=6\n\n// The function which does the magic is getRdSpherical(vec3 ro,vec2 uv); in Buffer A\n\n\n// it maps uv > polar uv > parametrized sphere\n\n\n\n// This buffer is for post-processing effects\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    \n\tfragColor = vec4(0);\n    // Radial blur\n    float steps = 40.;\n    float scale = 0.00 + pow(dot(uvn,uvn),1.5)*0.1;\n    float chromAb = pow(length(uv - 0.5),1.9)*3.;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){\n        scale *= 0.97;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1.4/iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;\n    \n    fragColor += radial;\n    \n    //fragColor = 1. - fragColor;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), 0.5);\n    fragColor = pow(fragColor, vec4(1. + dot(uvn,uvn))*1. );\n    fragColor = max(fragColor, 0.);\n    //fragColor.b *= 1. + uv.x*0.4;\n    fragColor *= 1. - dot(uvn,uvn)*2.;\n    fragColor = pow(fragColor, vec4(0.4545 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pmod(p,z) mod(p,z) - 0.5*z\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x)) \n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n\nvec3 getRdSpherical(vec3 ro,vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    uv += 0.5;\n    uv.y *= tau/2.;\n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1. + sin(iTime)/2.)*pi);\n    \n    vec3 lookAt = ro + offs;\n    \n    return normalize(lookAt - ro);\n}\n\n\nvec3 glow = vec3(0);\n\nvec3 path (float z){\n    z *= 0.24;\n\treturn vec3(0. + sin(z),0. + cos(z),0.)*0.;\n}\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.y, max(p.z,p.x));\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 map(vec3 p){\n\tvec2 d= vec2(10e7);\n   \n    p -= path(p.z);\n    \n    //p = pmod(p,1.);\n   \n    //p = abs(p);\n    \n    \n    //d.x = min(d.x, abs(p.y - 1.)-0.);\n   \n    \n    //d.x = min(d.x, abs(p.y + 1.2));\n    \n    \n    p.xz = pmod(p.xz,1.);\n   \t\n    \n    vec3 q = p;\n    \n    q.y = pmod(q.y,1.);\n    \n    q = abs(q);\n    p.y = pmod(q.y,1.);\n   \t\n   \t\n    d.x = min(d.x, max(q.x,q.y) - 0.04);\n    d.x = min(d.x, max(q.y,q.z) - 0.03);\n    d.x = min(d.x, length(p.xz) - 0.03);\n    \n    \n    d.x = min(d.x, length(p) - 0.1);\n   \n    \n    \n    d.x = abs(d.x) - 0.00;\n    d.x += 0.001;\n    d.x *= 0.2;\n    \n    return d;\n}\n\nfloat dith;\n\nvec2 march(vec3 ro, vec3 rd, inout vec3 p, inout float t, inout bool hit){\n\tvec2 d = vec2(10e7);\n    \n    p = ro;; t = 0.; hit = false;\n    \n    for(float i = 0.; i < 130.; i++){\n    \td = map(p)*dith;\n        float eps = 0.001;\n        if(d.x < eps){\n            t += 0.0004;\n        }\n        \n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    return d;\n}\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    return normalize(dir + right*uv.x + up*uv.y);\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0.);\n    return -normalize(vec3(\n        map(p - t.xyy).x - map(p + t.xyy).x,\n        map(p - t.yxy).x - map(p + t.yxy).x,\n        map(p - t.yyx).x - map(p + t.yyx).x\n    ));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    dith = mix(0.95,1.,texture(iChannel0,iResolution.xy*(uv + iTime*10.)/256.).x);\n    \n    vec3 col = vec3(0);\n\n\tvec3 ro = vec3(0);\n    \n    ro.z += iTime*1.7;\n    \n    ro += path(ro.z);\n    \n    ro.y += 0.;\n    \n    vec3 lookAt = vec3(0);\n    lookAt.z = ro.z + 2.;\n    lookAt += path(lookAt.z + .5);\n    \n    //vec3 rd = getRd(ro, lookAt,uv);\n  \tvec3 rd = getRdSpherical(ro, uv);\n  \t\n    float v = 1.;\n    \n    \n    vec3 p; float t; bool hit;\n    vec2 d = march(ro, rd, p, t, hit);\n    \n    col += glow*0.001;\n    \n    vec3 fc = pal(0.6,0.5,vec3(1.,0.5,0.4) + cos(uv.yxx)*.8, 1.9  - dot(uv,uv)*0.1,-2.1);\n    fc = max(fc,0.);\n    col = mix(col,fc, smoothstep(0.,1.,t*0.1));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}