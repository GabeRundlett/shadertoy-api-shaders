{
    "Shader": {
        "info": {
            "date": "1718538440",
            "description": "cosmos",
            "flags": 0,
            "hasliked": 0,
            "id": "M3tXRn",
            "likes": 8,
            "name": "other space ",
            "published": 3,
            "tags": [
                "space",
                "galaxy",
                "cosmos",
                "universe"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "/*originals https://www.shadertoy.com/view/wdtczM https://www.shadertoy.com/view/lXK3Dc https://www.shadertoy.com/view/4tyfWy */\n#define PI  3.1415927\n#define TAU 6.2831853\n#define PI2 1.5707963\n#define S 100\n#define D 25.\n\nfloat T, T1; // Simulation time, DS time\n\nmat2 RM(float a) { // Rotation matrix\n    vec2 cs=sin(vec2(PI2,0)+a);\n    return mat2(cs,-cs.y, cs);\n}\n\nfloat smin(float a, float b, float k) { // Smooth minimum (for k>0)\n    return mix(b,a,b=clamp(.5+.5*(b-a)/k, 0., 1.))-k*b*(1.-b);\n}\n\nfloat DS(vec3 p) { // Evolving gyroid-based Dyson sphere\n    if (T1<0.5)\n        return 100.;\n    float sc = .3*T1*T1;\n    p*=sc; p.xz *= RM(T1);\n    return .2*abs(dot(sin(p), cos(p.zxy)))/sc-.0015;            \n}\n\nfloat SD(vec3 p) { // signed distance for stellar system \n    return min( min(smin(abs(length(p)-1.)-.02, DS(p), -.02),      // DS\n                    length(p-.7*vec3(cos(3.*T),0,sin(3.*T)))-.02), // planet\n                length(p)-.06);                                    // star\n}\n\nvec3 Norm(vec3 p) { // Surface normal\n    vec2 e = vec2(.001, 0);    \n    return normalize(SD(p)-vec3(SD(p-e.xyy),SD(p-e.yxy),SD(p-e.yyx)));\n}\n\nvec3 Dir(vec2 uv, vec3 p) { // Ray direction\n    vec3 r = normalize(cross(vec3(0,1,0), p=-normalize(p)));\n    return normalize(p + uv.x*r + uv.y*cross(p,r));\n}\n\nfloat RaM(vec3 ro, vec3 rd) { // Ray march\n\tfloat d, dS=1.;\n    for(int i; i++<S && d<D && abs(dS)>.001; d+=(dS=SD(ro + rd*d)));\n    return d;\n}\n\n// The following MW code is modified from A concept for starmap by @Cewein, \n// https://www.shadertoy.com/view/4csGWr; see comments therein.\n\nvec2 hash22(vec2 p) {\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.+2.*fract(sin(p)*43758.5453123);\n}\n\nfloat noise(in vec2 p) { // based on @drift's www.shadertoy.com/view/4tdSWr\n    const float K1 = .366025404; // (sqrt(3)-1)/2; Perlin-noise consts.\n    const float K2 = .211324865; // (3-sqrt(3))/6;\n    vec2 i = floor(p + (p.x+p.y)*K1);\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.,.0) : vec2(.0, 1.);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1. + 2.*K2;\n    vec3 h = max(.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), .0);\n    h*=h; \n    vec3 n = vec3(dot(a, hash22(i)), dot(b, hash22(i+o)), dot(c, hash22(i+1.)));\n    return dot(h*h*n, vec3(70.));\n}\n\nfloat fbm(vec2 n, float amp, float res) {\n    float tot; \n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    for (int i; i++<17; amp*=res) {\n        tot -= (.2+noise(n))*amp;\n        n = m*n;\n    }\n    return abs(tot);\n}\n\nfloat sdEllipse(vec2 p, vec2 a, vec2 b) { \n    vec2 ab = vec2(length(a), length(b));\n    p = abs(p*mat2(a/ab.x, b/ab.y));\n    vec2 q = ab*(p-ab); // The following is based on @iq (Inigo Quilez)\n    float w = (q.x<q.y) ? PI2:.0;\n    for (int i; i<4; i++) {\n        vec2 cs = vec2(cos(w), sin(w));\n        vec2 u = ab*vec2(cs.x, cs.y);\n        vec2 v = ab*vec2(-cs.y, cs.x);\n        w += dot(p-u, v)/(dot(p-u, u) + dot(v, v));\n    }\n    float d = length(p - ab*vec2(cos(w), sin(w)));\n    p/=ab;\n    return (dot(p, p)>1.0) ? d : -d;\n}\n\nvec4 MW(vec2 uv, vec2 a, vec2 b, vec2 fA, vec2 fB, vec3 fP, vec4 c, float I, vec4 g) {\n    float d = -sdEllipse(uv, a*RM(fA.y)*fA.x, b*RM(fB.y)*fB.x);\n    return mix(c, g, I*smoothstep(-.1, .4, d)*fbm(uv*fP.x, fP.y, fP.z));\n}\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat ridgednoise(vec3 d, int octaves)\n{\n    float outsum = 0.0;\n    float div = 0.5;\n    float divsum = 0.0;\n    \n    for(int i = 0; i != octaves; i++)\n    {\n        outsum += noise(d / div) * div;\n        divsum += div;\n        div *= 0.5;\n    };\n    \n    return 2.0 * (0.5 - abs(0.5 - (outsum / divsum)));\n}\n\nfloat iqnoise(vec3 d, int octaves, int steps)\n{\n    float _out = 0.0;\n    float sign_ = 1.0;\n    for(int i = 0; i != steps; i++)\n    {\n        _out = ridgednoise(d - float(i) / float(steps), octaves);\n        d += _out * sign_;\n        sign_ *= -1.0;\n    }\n#ifdef FRACT_RIDGES\n    return fract(_out * 3.14159265);\n#endif\n    return 2.0 * (0.5 - abs(0.5 - _out));\n}\n\nvec3 coloriqnoise(vec3 d, int octaves, int steps)\n{\n    return normalize(vec3(\n        iqnoise(d, octaves, steps),\n        iqnoise(d - vec3(0.0, 0.0, 0.05), octaves, steps),\n        iqnoise(d - vec3(0.0, 0.0, 0.1), octaves, steps)\n    ));\n}\n\n// #define color\nfloat star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage(out vec4 O,vec2 C) {   \n    O*=0.; T=iTime*0.; T1=T-7.; // simulation time, DS time\n    vec2 R=iResolution.xy, M=iMouse.xy/R, i=.1-.2*M, uv=C/R-.5; uv.y*=R.y/R.x; \n    float fa=1., s=.1, ii=length(i), x=.05*T*ii+.25, dm, c, pa, a, aa, r, j;\n    vec3 p, ro, dir, dr=vec3(1), Or=dr*.7, v; \n    dr.xy = .8*uv*mat2(i,-i.y,i)/ii;\n    ro=vec3(0,0,-5.6); \n      vec2 uv2 = C/iResolution.xy;\n       vec2 uv3 = C/iResolution.xy-0.25;\n          vec2 uv4 = C/iResolution.xy-0.75;\n              vec2 uv5 = C/iResolution.xy-0.25;\n              uv5.y-=.3;\n               uv5.x-=.2;\n    float noise = iqnoise(vec3(p.xy, iTime / 50.0),10,5);\nfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .027)) * 1.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n    dir=Dir(uv, ro); // different origin (ro/Or) and dir (dir/dr) for MW/ISM.\n\n    dir.xy*=mat2(cos(iTime*0.021),sin(iTime*0.021),-sin(iTime*0.021), cos(iTime*0.021));\nvec4 o = O;\nvec2 F= C;\n\n    o-=o;\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <30; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1)*0.5;                     \n    }\nfor (Or+=vec3(2.*x,x,-2); r<23.; r++, fa*=.8, s+=.1) { // ISM\n\n       p = abs(.85-mod(Or+s*dr*.5,1.7));\n   p.xy*=mat2(cos(iTime*0.0121),sin(iTime*0.0121),-sin(iTime*0.0121), cos(iTime*0.0121));\n  \n       for(a=pa=j=0.; j++<10.;) \n       \n           a += abs(pa-(pa=length(p=abs(p)/dot(p,p)-.56)));\n           \n       dm=max(0.,.5-.001*(aa=a*a)); \n       c = .5+1.05*tanh(5.*cos(1e8*s));\n       v += (fa*=r>8.?-.8-dm:1.)+.0006*s*vec3(c,min(0.4,c),1.-c)*a*aa*fa; \n    } \n    O += vec4(.02*mix(vec3(length(v)),v,.5),1)+noise;\n    O*=o;\n   \n\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n\n    O+= MW(0.7*RM(1.1)*dir.xy, vec2(sin(2.5)*.1+.5,0), vec2(0,sin(1.5)*.1+.5), \n           vec2(5.2,.1), vec2(0.2,1.1), vec3(2.,0.9,.7), .103*vec4(0.,0.,1,1), 1.9, \n           vec4(0.3,.3,1.3,0));\n             O+= vec4(star(uv3, anim) * vec3(0.35,0.2,0.25)*0.01, 1.0);\n              O+= vec4(star(uv4, anim) * vec3(0.75,1.2,0.25)*0.01,1.0);\n                 O+= vec4(star(uv5, anim) * vec3(0.05,0.2,0.05)*0.01,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}