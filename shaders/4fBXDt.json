{
    "Shader": {
        "info": {
            "date": "1706939906",
            "description": "Arrows / WASD and Space\n[url=https://www.shadertoy.com/view/4fBXDt]mechanics in 2d[/url]\n[url=https://www.shadertoy.com/view/XfBXDt]mechanics in 3d[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "4fBXDt",
            "likes": 22,
            "name": "SDF Runner 2d",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "/***************************************************************************\n\nSDF Runner !\n2D version for detail on driving mechanics: https://www.shadertoy.com/view/4fBXDt\n3D version for driving around a huge SDF:   https://www.shadertoy.com/view/XfBXDt\n\nBufferA: Handles car dynamics. Very similar code in 2D and 3D versions.\nCommon:  The 'terrain' SDF is defined here,\n         so that it can be used by both BufferA and Image.\nImage:   Rendering.\n\nOrion Elenzil 2024\n\n***************************************************************************/\n\nconst float gZoom       = 1.0 / 50.0;\n      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n\n// align the positive X axis with fwd.\nmat2 matFwdFromX(in vec2 fwd) {\n    vec2 prp = vec2(-fwd.y, fwd.x);\n    return -(mat2(prp.x, fwd.x, prp.y, fwd.y));\n}\n\nvoid drawCar(inout vec3 rgb, in car_t car, in vec2 p, in vec3 col) {\n\n    p -= car.pos.xz;\n    p *= matFwdFromX(car.fwd.xz);\n    float sz = car.siz;\n    \n    float d     = sdTrapezoid(p, 1.0 * sz, 2.0 * sz, 3.0 * sz) - 0.4;\n    float mask  = smoothstep(gAAEps, -gAAEps, d);\n    float shad  = d - 0.4;\n    float c     = mask;\n          d     = abs(d) - gLineWidth;\n          c    *= smoothstep(-gAAEps, gAAEps, d);\n          \n          // eye\n    vec2  q     = p;\n          q.y  += sz * (2.2 + 1.0 * abs(car.str));\n          q.y  -= sz * sat(-car.ths);\n          q.x  -= sz * car.str;\n    float r     = 1.0 - sat(-car.ths) * 0.2;\n          d     = sdDisk(q, 0.8 * sz * r);\n          c    *= smoothstep(-gAAEps, gAAEps, d);\n          \n          // shadow\n          rgb  *= 1.0 - 0.5 * smoothstep(1.0, -1.0, shad);\n          \n          // thrust\n          q     = p;\n          q.y  -= sz * 4.0;\n          d     = sdTrapezoid(q, 2.5 * sz, 1.4 * sz, 0.9 * sz) - 0.2;\n    float cc    = smoothstep(1.0, -1.0, d/(gAAEps * 3.0));\n          rgb   = mix(rgb, vec3(0.0, 0.3, 0.8), cc * sat(car.ths) * 0.4);\n          \n          rgb   = mix(rgb, col * c, mask);\n}\n\n// slow the framerate to test dynamics at different Hz.\nfloat slowDown(float n) {\n    float a = 0.0;\n    for (int m = 0; m < int(n); ++m) {\n        a += pow(float(m), pi);\n    }\n    return a;\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = VIEWFROMSCREEN_DIST(2.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n        \n    RGBA.rgb   = v1 * 0.8;\n    \n //   RGBA.rg   *= sat(slowDown(3e5));\n    \n    for (int n = 0; n < gCarCount; ++n) {\n        if (n != gPlayerCarIndex) {\n            car_t car = readCar(iChannel0, n);\n            drawCar(RGBA.rgb, car, p, v1 * 0.9);\n        }\n    }\n    car_t car = readCar(iChannel0, gPlayerCarIndex);\n    drawCar(RGBA.rgb, car, p, vec3(0.9, 1.0, 0.5));\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(dot2(XY/RES - 0.5) * 1.8, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n\n//--------------------------------------------------------------------------\n// Math\nfloat sqr  (in float a) { return a * a; }\nfloat dot2 (in vec2  v) { return dot(v,v); }\nmat2  rot2 (in float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvec2  rot90(in vec2  v) { return vec2(-v.y, v.x); }\nfloat sat  (in float a) { return clamp(a, 0.0, 1.0); }\n\n//--------------------------------------------------------------------------\n// keyboard conveniences\n//\n#define KEY_IS_DOWN(key, chan) (texelFetch(chan, ivec2(key, 0), 0).r > 0.0)\n#define KEY_MOMENT(key, chan)  (texelFetch(chan, ivec2(key, 1), 0).r > 0.0)\n#define KEY_TOGGLED(key, chan) (texelFetch(chan, ivec2(key, 2), 0).r > 0.0)\n#define KEY_SP (32)\n#define KEY_LF (37)\n#define KEY_UP (38)\n#define KEY_RT (39)\n#define KEY_DN (40)\n#define KEY_0  (48)\n#define KEY_A  (65)\n#define KEY_D  (68)\n#define KEY_S  (83)\n#define KEY_W  (87)\nvoid orKeyPressed(in sampler2D channel, in int key, inout bool value) {\n    value = value || KEY_IS_DOWN(key, channel);\n}\n\n//--------------------------------------------------------------------------\n// signed distance functions\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\n// Isosceles Trapezoid - exact   (https://www.shadertoy.com/view/MlycD3)\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he ) {\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n\n//--------------------------------------------------------------------------\n// ray stuff\n//\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    vec3  amt;   // [0, 1] amount of light left in the ray\n    \n    // if true, this is a ray looking for the light.\n    bool  isLightingRay;\n};\n\nstruct mapSample_t {\n    float dist;\n    uint  mtl;\n};\n#define MST mapSample_t\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  hf_nrm;\n    vec3  of_nrm;\n    MST   ms;\n};\n\nstruct mtl_t {\n    vec3  albedo;\n    float opacity;         // opacity at the surface\n    float ior;\n    vec4  absorption;      // <vec3, permeability>\n};\n\n//--------------------------------------------------------------------------\n// optics\n\n// A modified Schlick's approximation\n// where reflectamount -> 0 as n2 -> n1.\nfloat reflectAmount(float n1, float n2, float incidentDotNormal) {\n    // from https://en.wikipedia.org/wiki/Schlick%27s_approximation \n    float R0 = sqr((n1 - n2) / (n1 + n2));\n    float R  = R0 + (1.0 - R0) * pow(1.0 - incidentDotNormal, 5.0);\n\n    // Schlick's approximation seems invalid when n1 ~= n2.\n    // Compensate with an additional fudge.\n    // https://physics.stackexchange.com/q/794963\n    float ndiffSqr      = sqr(n1 - n2);\n    float elenzilFudge  = ndiffSqr / (ndiffSqr + 0.01);\n    R                  *= elenzilFudge;\n\n    return R;\n}\n\n// n1 == n2          -> no reflection\nvoid thisRayWalksIntoAnInterface(\n    //  direction of the incoming ray.\n    in  vec3  incident,\n    \n    //  surface normal.\n    in  vec3  hit_facing_normal,\n    \n    //  indices of refraction.\n    in  float n1,\n    in  float n2,\n    \n    in  float opacity,\n    \n    //  amount allocated to diffuse lighting\n    out float out_sDiffuse,\n    \n    //  direction and amount for specular reflection\n    out vec4  out_vReflect,\n    \n    //  direction and amount for transmission\n    out vec4  out_vTransmit\n    ) {\n    \n    // 0 = transmit 1 = reflect 1\n    float transmitVsReflect = reflectAmount(n1, n2, dot(incident, -hit_facing_normal));\n    \n    // check for total internal reflection.\n    float eta     = n1 / n2;\n    out_vTransmit.xyz = refract(incident, hit_facing_normal, eta);\n    if (dot(out_vTransmit.xyz, out_vTransmit.xyz) == 0.0) {\n        // total internal\n        transmitVsReflect = 1.0;\n    }\n    \n    float amtDiffuse  = (1.0 - transmitVsReflect) * opacity;\n    float amtReflect  = transmitVsReflect;\n    float amtTransmit =  1.0 - amtDiffuse - amtReflect;\n    \n    out_sDiffuse      = amtDiffuse;\n    out_vTransmit.w   = amtTransmit;\n    out_vReflect.w    = amtReflect;\n    out_vReflect.xyz  = reflect(incident, hit_facing_normal);\n}\n\n//--------------------------------------------------------------------------\n\n// Queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nvoid QClear() {                                    \\\n    gQHead = gQTail = 0u;                          \\\n}                                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n\n//--------------------------------------------------------------------------------\n// CSG Operations.\n// These all mutate the first argument and return void.\n// MST types are used only where sensible.\n\nvoid opUnion(inout float A, in float B) {\n    A = min(A, B);\n}\n\nvoid opUnion(inout MST A, MST B) {\n    if (A.dist > B.dist) {\n        A = B;\n    }\n}\n\nvoid opSub(inout float d1, in float d2) {\n    d1 = max(d1, -d2);\n}\n\nvoid opSub(inout MST ms1, in float d2) {\n    opSub(ms1.dist, d2);\n}\n\nvoid opReplace(inout float d1, in float d2) {\n    opSub(d1, d2);\n    d1 = min(d1, d2);\n}\n\nvoid opReplace(inout MST ms1, in MST ms2) {\n    opSub(ms1.dist, ms2.dist);\n    opUnion(ms1, ms2);\n}\n\n\n//--------------------------------------------------------------------------\n// Car IO\n\nconst int   gCarCount = 17;\nconst int   gPlayerCarIndex = gCarCount / 2;\n\nstruct car_t {\n    vec3  pos;\n    vec3  vel;\n    vec3  fwd;\n    float siz;\n    float str;  // cosmetic steering\n    float ths;  // cosmetic thrust\n};\n\nvoid readCarProp(in sampler2D channel, int carIndex, int propIndex, out vec3 prop, out float misc) {\n    vec4 val = texelFetch(channel, ivec2(propIndex, carIndex), 0);\n    prop = val.xyz;\n    misc = val.w;\n}\n\nvoid writeCarProp(out vec4 RGBA, in vec3 prop, in float misc) {\n    RGBA.xyz = prop;\n    RGBA.w   = misc;\n}\n\ncar_t readCar(in sampler2D channel, int index) {\n    car_t ret;\n    \n    readCarProp(channel, index, 0, ret.pos, ret.siz);\n    readCarProp(channel, index, 1, ret.vel, ret.str);\n    readCarProp(channel, index, 2, ret.fwd, ret.ths);\n    \n    return ret;\n}\n\nvoid writeCar(in int column, inout vec4 RGBA, in car_t car) {\n\n    switch(column) {\n        default:\n            break;\n        case 0:\n            writeCarProp(RGBA, car.pos, car.siz);\n            break;\n        case 1:\n            writeCarProp(RGBA, car.vel, car.str);\n            break;\n        case 2:\n            writeCarProp(RGBA, car.fwd, car.ths);\n            break;\n    }\n}\n\ncar_t newCar(int index) {\n    car_t car;\n    float findex = float(index);\n    float fcount = float(gCarCount);\n    float z      = (findex - (fcount - 1.0)/2.0);\n    \n    car.pos = vX * 0.0 + vZ * z * 90.0 / float(gCarCount + 1);\n    car.fwd = normalize(vX * 4.0 + vZ * z);\n    car.vel = car.fwd * (4.0 - abs(z) * 0.4) * 0.0;\n    car.siz = 1.0 - abs(z) / float(gCarCount + 1);\n    if (index == gPlayerCarIndex) {\n        car.siz    = 1.0 * 0.75;\n        car.pos.x -= 30.0;\n        car.fwd   *= -1.0;\n    }\n    \n    return car;\n}\n\n//--------------------------------------------------------------------------\n// Scene\n\nconst float gMarchEps       = 0.03;\nconst float gNormEps        = gMarchEps * 0.4;\n\nuint gMtlAir   = 0u;\nuint gMtlFloor = 1u;\n\n\nfloat sdPlanet(in vec3 p) {\n    return p.y;\n}\n\nMST sdScene(in vec3 p) {\n    float d = 1e9;\n    \n    opUnion(d, sdPlanet(p));\n    \n    MST ms = MST(d, d > 0.0 ? gMtlAir : gMtlFloor);\n    \n    return ms;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalScene(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+e*gNormEps).dist;\n    }\n    return normalize(n);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 normalPlanet(vec3 p) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdPlanet(p+e*gNormEps);\n    }\n    return normalize(n);\n}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*******************************\n Dynamics\n\ntodo: \n[x] car damping must be exponential\n\n\n\n********************************/\n\n// false to drive all cars yourself\nbool  gAICars    = true;\n\n// \nfloat gCarDmp    =   2.0;\nfloat gCarAcc    =   1.0;\nfloat gCarSpdMax =  40.0;\nfloat gCarTrn    =   3.0;\nfloat gCarDrift  =   0.998;    // 0 to 1\nfloat gCarBrake  =  30.0;\nfloat gBounds    = 150.0;\n\nfloat kUp, kDn, kLf, kRt, kSp;\nvoid readKeyboard() {\n    bool bUp, bDn, bLf, bRt, bSp = false;\n    orKeyPressed(iChannel3, KEY_UP, bUp);\n    orKeyPressed(iChannel3, KEY_W , bUp);\n    orKeyPressed(iChannel3, KEY_LF, bLf);\n    orKeyPressed(iChannel3, KEY_A , bLf);\n    orKeyPressed(iChannel3, KEY_RT, bRt);\n    orKeyPressed(iChannel3, KEY_D , bRt);\n    orKeyPressed(iChannel3, KEY_DN, bDn);\n    orKeyPressed(iChannel3, KEY_S , bDn);\n    bSp = KEY_MOMENT(KEY_SP, iChannel3);\n    \n    kUp = float(bUp);\n    kDn = float(bDn);\n    kLf = float(bLf);\n    kRt = float(bRt);\n    kSp = float(bSp);\n}\n\n// steering: -1 = left     , 1 = right\n// thrust  : -1 = brake    , 1 = go\n// action  :  0 = no action, 1 = action\nvoid processCar(inout car_t car, float steering, float thrust, float action, vec3 otherCars[gCarCount - 1] ) {\n\n    // car \"up\" is the planet normal\n    vec3 carUp  = normalPlanet(car.pos);\n\n    if (action > 0.0) {\n        float speed = length(car.vel);\n        if (speed > 0.0) {\n            car.fwd = car.vel / -speed;\n        }\n        else {\n            car.fwd *= -1.0;\n        }\n    }\n\n    //---------------------------------------------\n    // Steering, aka determine car's \"forward\".\n    // We keep \"forward\" || to the planet surface.\n    \n    // Car \"right\". also || to planet surface.\n    vec3 carRt  = cross(carUp, car.fwd);\n    \n    // Adjust \"forward\" by adding in \"right\" times keyboard input.\n    // For smallish turns, this is fine, no need to actually rotate it.\n    // Not renormalized here because it's renormalized later.\n    car.fwd    += iTimeDelta * carRt * gCarTrn * steering;\n    \n    // Cosmetic steering, has not effect on actual dynamics.\n    car.str    *= pow(0.05, iTimeDelta);\n    car.str     = clamp(car.str + steering * iTimeDelta * 8.0, -1.0, 1.0);\n    \n    // Keep things tidy: force \"forward\" || to surface.\n    car.fwd    -= dot(car.fwd, carUp) * carUp;\n    car.fwd     = normalize(car.fwd);\n    \n    //---------------------------------------------\n    // drifting\n    // velocity without drift\n    vec3 naturalVel = length(car.vel) * car.fwd;\n    car.vel = mix(car.vel, naturalVel, (1.0 - gCarDrift) * pow(2.0, iTimeDelta));\n\n    // damp speed\n    float carSpeedFac = 1.0 / pow(car.siz, 2.0);\n    float decay = 1.0 / (gCarDmp * carSpeedFac + sat(-thrust) * gCarBrake * carSpeedFac);\n    car.vel *= pow(decay, iTimeDelta);\n    \n    // apply thrust\n    carSpeedFac  = 1.0 / pow(car.siz, 1.0);\n    car.vel     += car.fwd * gCarAcc * sat(thrust) * carSpeedFac;\n    \n    // cosmetic thrust\n    car.ths     *= pow(0.05, iTimeDelta);\n    car.ths      = clamp(car.ths + thrust * iTimeDelta * 8.0, -1.0, 1.0);\n    \n    // limit speed\n    float speed = length(car.vel);\n    if (speed > 0.0) {\n        car.vel  = normalize(car.vel) * min(length(car.vel), gCarSpdMax * carSpeedFac);\n    }\n    \n    // update position\n    car.pos += car.vel * iTimeDelta;\n    \n    // separate\n    // super crude collision handling\n    for (int n = 0; n < gCarCount - 1; ++n) {\n        vec3  otherCarPos = otherCars[n];\n        vec3  vMeThem     = otherCarPos - car.pos;\n        float dMeThem     = length(vMeThem);\n        dMeThem -= 2.0;\n        float overlap     = max(0.0, car.siz * 2.0 - dMeThem);\n        vec3  vOffsetPrp  = vMeThem;\n        vOffsetPrp.xz     = rot90(vOffsetPrp.xz);\n        vec3  vOffset     = normalize(vMeThem + vOffsetPrp);\n        car.pos          -= vOffset * overlap / 2.0 * 1.5;\n    }\n    \n    // snap to the proper elevation\n    carUp    = normalPlanet(car.pos);\n    car.pos -= carUp * (sdPlanet(car.pos) - car.siz * 1.2);\n    \n    // don't go out of bounds\n    if (length(car.pos) > gBounds) {\n        car.pos = v0;\n    }\n}\n\nvoid processCarPlayer(inout car_t car, vec3 otherCars[gCarCount - 1]) {\n    float steering = kRt - kLf;\n    float action   = kSp;\n    float thrust   = kUp - kDn;\n    \n    processCar(car, steering, thrust, action, otherCars);\n}\n\n// don't try to reason about this routine, it's an AI black box.\nvoid processCarAI(inout car_t car, in car_t target, vec3 otherCars[gCarCount - 1]) {\n    // car \"up\" is the planet normal\n    vec3 carUp   = normalPlanet(car.pos);\n    // car \"right\". also || to planet surface.\n    vec3 carRt   = cross(carUp, car.fwd);\n    \n    vec3  vCarTrg = target.pos - car.pos;\n    float dCarTrg = length(vCarTrg);\n    vec3  nCarTrg = vCarTrg / dCarTrg;\n    \n    float speed  = length(car.vel);\n    \n    float headed = dot(car.fwd, nCarTrg);\n    bool  seesTarget = headed > 0.3 || dCarTrg < 30.0;\n    \n    float action   = 0.0;\n    float steering = 0.0;\n    float thrust   = 0.0;\n    if (seesTarget) {\n        float flip   = 1.0;\n        if (speed > gCarSpdMax * 0.99 && headed < -0.5) {\n            action =  1.0;\n            flip   = -1.0;\n        }\n    \n        steering = flip * sign(dot(carRt, nCarTrg));\n        if (headed > 0.99) {\n            steering = 0.0;\n        }\n        \n        thrust = 1.0;\n    }\n    \n    // slow down on approach\n    // note thrust needs to be either on or off,\n    // so we use a duty-cycle.\n    float f = smoothstep(15.0, 30.0, dCarTrg);\n    f = fract(iTime * 5.0) < f ? 1.0 : 0.0;\n    thrust *= f;\n    \n    processCar(car, steering, thrust, action, otherCars);\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY ) {\n    ivec2 IJ = ivec2(XY);\n    int carIndex = IJ.y;\n    \n    if (carIndex >= gCarCount || IJ.x > 5) {\n        discard;\n    }\n\n    car_t car;\n    \n    if (iFrame == 0 || (iMouse.z > 0.0 && length(iMouse.zw) < 100.0)) {\n        car = newCar(carIndex);\n    }\n    else {\n        car = readCar(iChannel0, carIndex);\n    }\n    \n    // compose list of all the other cars positions\n    vec3 otherCars[gCarCount - 1];\n    int otherIndex = 0;\n    for (int n = 0; n < gCarCount; ++n) {\n        if (n != carIndex) {\n            otherCars[otherIndex] = readCar(iChannel0, n).pos;\n            otherIndex += 1;\n        }\n    }\n    \n    readKeyboard();\n    \n    if (!gAICars || carIndex == gPlayerCarIndex) {\n        processCarPlayer(car, otherCars);\n    }\n    else {\n        processCarAI(car, readCar(iChannel0, gPlayerCarIndex), otherCars);\n    }\n    \n    writeCar(IJ.x, RGBA, car);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}