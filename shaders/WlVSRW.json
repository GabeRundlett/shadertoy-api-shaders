{
    "Shader": {
        "info": {
            "date": "1582298896",
            "description": "raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVSRW",
            "likes": 30,
            "name": "Sphere and Volumetrics",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "glow"
            ],
            "usePreview": 0,
            "username": "Hei149",
            "viewed": 851
        },
        "renderpass": [
            {
                "code": "#define rotate(angle) mat2(cos(angle), sin(angle), sin(-angle), cos(angle))\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat mat = 0.0;\nfloat glow = 0.0;\nfloat map(vec3 p, bool shadow)\n{\n    p.yz *= rotate(iTime);\n    p.xz *= rotate(iTime);\n    float d = abs(sdSphere(p, 1.0)) - 0.01;\n    vec3 rp = p;\n    for(int i = 0; i < 4; ++i)\n        rp = abs(rp) - 0.2;\n\n    float d1 = sdSphere(rp + vec3(0.0, 0.0, 0.0), 0.15);\n    d = max(d, -d1);\n    d = min(d, abs(sdSphere(p, 4.0) - 0.1));\n    if(shadow){\n       return d;\n    }\n    float d2 = sdSphere(p, 0.1);\n    glow += 0.01 / (0.01 + d2 * d2);\n    if(d < d2)\n    {\n        mat = 0.0;\n        return d;\n    } \n    else{\n        mat = 1.0;\n        return d2;\n    }\n}\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = 0.05;\n    float shadow = 1.0;\n    while(d < maxDist)\n    {\n        float t = map(r0 + d * rd, true);\n        if(t < 0.01) return 0.0;\n        d += t;\n        shadow = min(shadow, 30.0 * (t / d));\n    }\n    return shadow;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy, false) - map(p - e.xyy, false),\n        map(p + e.yxy, false) - map(p - e.yxy, false),\n        map(p + e.yyx, false) - map(p - e.yyx, false)\n    ));\n}\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(13.549, 55.392))) * 312.93);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(0.0, 2.4, -3.0);\n    vec3 tgt = vec3(0.0);\n    vec3 ww = normalize(tgt - r0);\n    vec3 uu = normalize(cross(vec3(0,1,0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x * uu + uv.y * vv + 0.95 * ww);\n    \n    vec3 col = vec3(0.0);\n    float d = 0.0;\n    vec3 p = vec3(0.0);\n    vec3 lp = normalize(vec3(0.0));\n    float matId = 0.0;\n    for(int i = 0; i < 100; ++i)\n    {\n        p = r0 + d * rd;\n        float t = map(p, false);\n        d += t;\n        if(abs(t) < 0.001){\n            vec3 albedo = vec3(1.0);\n            if(matId < 0.5) albedo = vec3(1.0, 0.0, 0.2);\n            vec3 n = norm(p);\n            vec3 ld = normalize(lp - p);\n            vec3 diff = max(dot(n, ld), 0.0) * vec3(0.4, 0.2, 0.8);\n            float shad = shadow(p, ld, 8.0);\n            col += diff * shad;\n            col *= albedo;\n            break;\n        }\n        if(d > 100.0)\n        {\n            break;\n        }\n    }\n\n    const int numIter = 100;\n    vec3 vD = rd;\n    vD = normalize(vD);\n    float stepSize = length(p - r0) / float(numIter);\n    //vec3 vO = r0 + stepSize * vD * rand(uv) * 0.8;\n    vec3 vO = r0 + stepSize * vD;\n    float accum = 0.0;\n    for(int i = 0; i  < numIter; ++i)\n    {\n        vec3 ld = normalize(lp - vO);\n        float shad = shadow(vO, ld, 4.0);\n        float d = dot(vO, vO);\n        accum += (0.01 / d ) * shad;\n        vO += stepSize * vD;\n    }\n    col += glow * vec3(0.4, 0.2, 0.8);\n    col += accum * vec3(0.4, 0.2, 0.8) * 16.0;\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}