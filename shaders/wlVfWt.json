{
    "Shader": {
        "info": {
            "date": "1615371710",
            "description": "Blended 4-point cubic interpolation:\n- Red: Bezier edges / Lagrange mids.\n- Green: Lagrange edges / Hermite mids.\n- Blue: Bezier edges / Hermite mids.\n- White: Lagrange edges & mids.\n\n3 - point cubic interpolation:\n- Gray: Exact Bezier (exact func fit).",
            "flags": 0,
            "hasliked": 0,
            "id": "wlVfWt",
            "likes": 9,
            "name": "Dots & Curves",
            "published": 3,
            "tags": [
                "bezier",
                "curves",
                "spline",
                "vignette",
                "curve",
                "graph",
                "dots",
                "cubic",
                "interpolation",
                "hermite",
                "lagrange"
            ],
            "usePreview": 0,
            "username": "spawner64",
            "viewed": 476
        },
        "renderpass": [
            {
                "code": "// ------------------------------------------------------------------------- //\n//\n// Dots & Curves\n//\n// Hybrid cubic interpolation methods achieved by blending different types of\n// cubic interpolation functions like the Lagrange, Hermite and Bezier\n// interpolations.\n//\n// Additionally, a 3-point exact Bezier function is provided. Called \"exact\"\n// because the function fits perfectly the 3 points (aka the function goes\n// through the 3 points exactly).\n//\n// Blended 4-point cubic interpolation:\n// - Red: Bezier edges / Lagrange mids.\n// - Green: Lagrange edges / Hermite mids.\n// - Blue: Bezier edges / Hermite mids.\n// - White: Lagrange edges & mids.\n//\n// 3 - point cubic interpolation:\n// - Gray: Exact Bezier (exact function fit).\n//\n// Choose your poison.\n//\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/MllSzX\nfloat c_x0 = -1.0;\nfloat c_x1 =  0.0;\nfloat c_x2 =  1.0;\nfloat c_x3 =  2.0;\n\n// https://www.shadertoy.com/view/MllSzX\nvec3 CubicLagrange(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec2 CubicLagrange(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nfloat CubicLagrange(float A, float B, float C, float D, float t) {\n    return\n        A * \n        (\n            (t - c_x1) / (c_x0 - c_x1) * \n            (t - c_x2) / (c_x0 - c_x2) *\n            (t - c_x3) / (c_x0 - c_x3)\n        ) +\n        B * \n        (\n            (t - c_x0) / (c_x1 - c_x0) * \n            (t - c_x2) / (c_x1 - c_x2) *\n            (t - c_x3) / (c_x1 - c_x3)\n        ) +\n        C * \n        (\n            (t - c_x0) / (c_x2 - c_x0) * \n            (t - c_x1) / (c_x2 - c_x1) *\n            (t - c_x3) / (c_x2 - c_x3)\n        ) +       \n        D * \n        (\n            (t - c_x0) / (c_x3 - c_x0) * \n            (t - c_x1) / (c_x3 - c_x1) *\n            (t - c_x2) / (c_x3 - c_x2)\n        );\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec3 CubicHermite(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec3 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec3 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec3 c = -A/2.0 + C/2.0;\n   \tvec3 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n// https://www.shadertoy.com/view/MllSzX\nvec2 CubicHermite(vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n\tfloat t2 = t*t;\n    float t3 = t*t*t;\n    vec2 a = -A/2.0 + (3.0*B)/2.0 - (3.0*C)/2.0 + D/2.0;\n    vec2 b = A - (5.0*B)/2.0 + 2.0*C - D / 2.0;\n    vec2 c = -A/2.0 + C/2.0;\n   \tvec2 d = B;\n    \n    return a*t3 + b*t2 + c*t + d;\n}\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/4ts3DB\nvec2 CubicBezier(in vec2 a, in vec2 b, in vec2 c, in vec2 d, float v1) {\n    float u1 = 1.0 - v1;\n    float u2 = u1*u1;\n    float v2 = v1*v1;\n    float u3 = u2*u1;\n    float v3 = v2*v1;\n    return a*u3 + d*v3 + b*3.0*u2*v1 + c*3.0*u1*v2;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat ExactBezier(float l, float c, float r, float t) {\n    float it = 1.0 - t;\n    float lf = l + t * (r - l);\n    float qf =\n        l * it * it +\n        c * it * t * 2.0 +\n        r * t * t;\n    return qf + qf - lf;\n}\n\n// ------------------------------------------------------------------------- //\n\n// https://www.shadertoy.com/view/Md2cRt\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575);\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat plotPoint(vec2 uv, float x, float y, float radius) {\n    // compute dimension-wise pseudo-distance\n    float xDist = uv.x - x;\n    float yDist = uv.y - y;\n    \n#if 0\n    xDist *= iResolution.x / iResolution.y; // scale by screen height\n#else\n    yDist *= iResolution.y / iResolution.x; // scale by screen width\n#endif\n\n    // compute distance\n    float f = xDist * xDist + yDist * yDist;\n    f = sqrt(f);\n\n    // raise and exponentiate\n    radius *= 1000.0;\n    f *= 1000.0 / radius;\n    f = clamp(f, 0.0, 1.0);\n    f = pow(f, radius * 2.0);\n\n    // invert and return\n    f = 1.0 - f;\n    return f;\n}\n\nfloat plotPoint(vec2 uv, vec2 xy, float radius) {\n    return plotPoint(uv, xy.x, xy.y, radius);\n}\n\nvec3 plotPoint(vec2 uv, float x, float y, float radius, vec3 color) {\n    return plotPoint(uv, x, y, radius) * color;\n}\n\nvec3 plotPoint(vec2 uv, vec2 xy, float radius, vec3 color) {\n    return plotPoint(uv, xy.x, xy.y, radius) * color;\n}\n\n// ------------------------------------------------------------------------- //\n\nfloat blendingFunction(float t) {\n    float f = 1.5 - abs(1.5 - t * 3.0);\n    f = clamp(f, 0.0, 1.0);\n    f = 1.0 - f;\n    f *= f;\n    f *= f;\n    f = 1.0 - f;\n    return f;\n}\n\n// ------------------------------------------------------------------------- //\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n\n    vec2 a4 = vec2(0.0 / 3.0, 0.5);\n    vec2 b4 = vec2(1.0 / 3.0, 0.5);\n    vec2 c4 = vec2(2.0 / 3.0, 0.5);\n    vec2 d4 = vec2(3.0 / 3.0, 0.5);\n\n    vec2 l3 = vec2(0.0 / 2.0, 0.5);\n    vec2 c3 = vec2(1.0 / 2.0, 0.5);\n    vec2 r3 = vec2(2.0 / 2.0, 0.5);\n\n    // vignette and some dithering noise to fight banding\n    vec3 color = vec3(0.120, 0.140, 0.155) * (2.0 - 2.5 * pow(distance(uv, vec2(0.5, 0.5)), 2.0));\n    color += (rand(uv) - 0.5) * 0.015;\n\n    color += plotPoint(uv, vec2(0.5, 0.5), mix(0.015, 0.1, mouse.y), mix(vec3(0.35, 0, 1), vec3(0.525, 1, 0), mouse.y));\n    //b4 = mouse.y;\n    //c4 = 1.0 - mouse.y;\n    //a4 = mouse.y;\n    //d4 = mouse.x;\n\n    float timeScale = mix(0.025, 3.0, mouse.y);\n    float scaledTime = iTime * timeScale + 186.9;\n\n    {\n        // animate and plot the 4 points\n\n        a4.y = sin(scaledTime * 1.12235431) * 0.5 + 0.5;\n        b4.y = sin(scaledTime * 2.77834539) * 0.5 + 0.5;\n        c4.y = sin(scaledTime * 3.54234271) * 0.5 + 0.5;\n        d4.y = sin(scaledTime * 4.36788523) * 0.5 + 0.5;\n\n        color += plotPoint(uv, a4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, b4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, c4, 0.025, vec3(1, 0, 0));\n        color += plotPoint(uv, d4, 0.025, vec3(1, 0, 0));\n    }\n\n    {\n        // animate and plot the 3 points\n\n        l3.y = a4.y;\n        c3.y = sin(scaledTime * 1.77834539) * 0.5 + 0.5;\n        r3.y = d4.y;\n\n        color += plotPoint(uv, l3, 0.025, vec3(1, 0.0, 0));\n        color += plotPoint(uv, c3, 0.025, vec3(0, 0.5, 1));\n        color += plotPoint(uv, r3, 0.025, vec3(1, 0.0, 0));\n    }\n\n    int numPlotPoints = 50;\n    float invNumPlotPoints = 1.0 / float(numPlotPoints);\n    for (int i = 0; i < numPlotPoints; i++) {\n        float t = float(i) * invNumPlotPoints;\n\n        vec2 blend = vec2(blendingFunction(t));\n        color += plotPoint(uv, t, blend.y, invNumPlotPoints * 0.5, vec3(0.125, 0.125, 0.152));\n\n        float t2 = mix(-1.0, 2.0, t);\n\n        {\n            // although the bezier goes through the edges, when mixed up with hermite it doesn't anymore - worst\n            vec2 xyEdges = CubicBezier(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicHermite(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.0, 0.0, 0.5));\n        }\n\n        {\n            // produces frequencies a lot higher than the nyquist\n            vec2 xyEdges = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicHermite(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.0, 0.5, 0.0));\n        }\n\n        {\n            // lowest overshoot, but less smoother than lagrange / lagrange - some higher-than-nyquist frequencies\n            vec2 xyEdges = CubicBezier(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.5, 0.0, 0.0));\n        }\n\n        {\n            // smoothest - lowest in frequencies, but overshoots\n            // since it's a mix between the same function, can be evaluated just once\n            vec2 xyEdges = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicBezier\n            vec2 xyMids = CubicLagrange(a4, b4, c4, d4, t2); // CubicLagrange or CubicHermite\n\n            vec2 xy = mix(xyEdges, xyMids, blend);\n            color += plotPoint(uv, xy, invNumPlotPoints * 0.5, vec3(0.5, 0.5, 0.5));\n        }\n\n        {\n            // 3 - point exact cubic interpolation\n            float y = ExactBezier(l3.y, c3.y, r3.y, t);\n            color += plotPoint(uv, t, y, invNumPlotPoints * 0.5, vec3(0.25, 0.25, 0.25));\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n// ------------------------------------------------------------------------- //",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}