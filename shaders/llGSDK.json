{
    "Shader": {
        "info": {
            "date": "1485950160",
            "description": "This is a WIP! ;P\n\nThis is a prototype that I would like to implement in a demo that I am working on.\nI am performing a raycast to a plane and then sampling some noise from the intersection point.\n\nThanks @iq for the noise functions!",
            "flags": 0,
            "hasliked": 0,
            "id": "llGSDK",
            "likes": 2,
            "name": "Clouds cover",
            "published": 3,
            "tags": [
                "noise",
                "raycast",
                "cloud"
            ],
            "usePreview": 1,
            "username": "piluve",
            "viewed": 859
        },
        "renderpass": [
            {
                "code": "/*\n\t..::Clouds cover nachocpol@gmail.com::..\n\t\n\tThis is a WIP! ;P\n\n\tThis is a prototype that I would like to implement in a \n\tdemo that I am working on.\n\tI am performing a raycast to a plane and then sampling some noise from the \n\tintersection point.\n\n\tThanks @iq for the noise functions!\n*/\n\nfloat hash(vec3 p) \n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n/*\n\tFractal noise 7 iter [0,1]\n*/\nfloat fractn(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n    f += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p); p = 2.0 * p;\n    f += 0.015625 * noise(p); p = 2.0 * p;\n    f += 0.0078125 * noise (p); p = 2.0 * p;\n    \n    return f;\n}\n\nstruct Plane\n{\n    vec3 Point;\n    vec3 Normal;\n};\n\nfloat iPlane( vec3 ro, vec3 rd, Plane plane)\n{\n    float hit = 0.0;\n    float dotP = dot(rd,plane.Normal);\n    if(dotP == 0.0)\n    {\n        return hit;\n    }\n    \n    float distToHit = dot(plane.Point - ro, plane.Normal) / dotP;\n    if(distToHit < 0.0)\n    {\n        return hit;\n    }\n    \n    hit = distToHit;\n    return hit;\n}\n\n/*\n\tWe perform a set of samples from the point that we hit the cloud\n\tby a distance. The returned value will tell us how \"thick\" each cloud\n\tis so we can simulate light absorption.\n\tWith 16 samples we can see some banding.\n\tIf I increase the samples my WebGl just crashes :C\n*/\nfloat scattering(vec3 ro,vec3 rd)\n{\n    const int samples = 16;\n    float sampleDist = 1.0;\n    float acum = 0.0;\n    for(int i = 0; i < samples; i++)\n    {\n        float idx = float(i) / float(samples);\n        acum += fractn(ro + (rd * (idx * sampleDist)));\n    }\n    return acum / float(samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = (fragCoord.xy/iResolution.xy) - 0.5;\n    \n    // Colors\n    vec3 color = vec3(0.0,0.0,0.0); \n    vec3 skyColor = mix(vec3(1.0,1.0,1.0),vec3(0.5,0.8,0.98),sqrt(uv.y + 0.5));\n    color = skyColor;\n    \n    // Plane clouds\n    Plane clouds;\n    clouds.Point = vec3(0.0,200.0,0.0);\n    clouds.Normal = vec3(0.0,1.0,0.0);\n    \n    // Setup camera\n    vec3 camUp = vec3(0,1,0);\n    vec3 camFront = vec3(0,0.1,1);\n    vec3 camRight = vec3(1,0,0);\n    vec3 camPos = vec3(0,0,-1) * 0.0;\n    vec3 camRay = camUp * uv.y + camRight * uv.x + camFront;\n    \n\t// Check clouds intersection\n    float id = 0.0;\n    float dPlane = iPlane(camPos,camRay,clouds);\n    vec3 cloudColor = vec3(0.0,0.0,0.0);\n    if(dPlane > 0.0)\n    {\n        // Sample noise and modulate noise\n        vec3 pos = camPos + (camRay * dPlane);\n        vec2 off = vec2(iTime,iTime) * vec2(-10,0);\n        float n = fractn(vec3(pos.x + off.x,pos.y,pos.z + off.y) *0.002);\n        n = smoothstep(0.2,1.0,n);\n        cloudColor = mix(skyColor,vec3(1.0,1.0,1.0),n);\n        \n        // Fade with distance\n        float alpha = abs(1.0 - clamp(dPlane/5000.0,0.0,1.0));\n        cloudColor = mix(skyColor,cloudColor,alpha);\n        \n        // Cloud Scattering\n        float scat = scattering(vec3(pos.x + off.x,pos.y,pos.z + off.y) *0.002,camRay);\n        scat = smoothstep(0.0,0.7,scat);\n        color = mix(skyColor,cloudColor * scat,alpha);\n\n    }\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}