{
    "Shader": {
        "info": {
            "date": "1499531192",
            "description": "It is a dummy implementation of inverse kinematic.\nMouse is enabled.\n\nTODO: improve performance",
            "flags": 32,
            "hasliked": 0,
            "id": "Xdjfz1",
            "likes": 11,
            "name": "Inverse kinematics",
            "published": 3,
            "tags": [
                "2d",
                "ik",
                "tentacle",
                "inversekinematic"
            ],
            "usePreview": 0,
            "username": "Zabidon",
            "viewed": 886
        },
        "renderpass": [
            {
                "code": "// License: Do What The F**k You Want To But It's Not My Fault Public License v1 (WTFNMFPL-1.0)\n// Created by Osipov Kirill --- zabidon, KirillD503\n\n// Main logic is in Buf A.\n// If you change something in Buf A, it is better to press \"Reset time\" button.\n\n// You can change the next line and same line in the Buf A pass\n#define SEGMENT_COUNT 10\n\n// Don't change the next line\n#define STORE_SIZE 3\n\n// You can comment the next line and same line in the Buf A pass\n#define FOLLOW_CIRCLE\n\n\n//============================================================\n// BEGIN UTIL\n//============================================================\n\nvec4 load_vec4(int var_id);\nvoid save_vec4(int var_id, vec4 val, inout vec4 fragColor, vec2 fragCoord);\n\n#define texel_size iChannelResolution[0].xy\n\nvec4 load_vec4(int var_id) {\n  float id = float(var_id);\n  vec2 var_coord = (vec2(\n          mod(id, iChannelResolution[0].y),\n          floor(id / iChannelResolution[0].y)\n  \t\t) + 0.5) / texel_size;\n  return texture(iChannel0, var_coord);\n}\n\nvoid save_vec4(int var_id, vec4 val, inout vec4 fragColor, vec2 fragCoord) {\n  float id = float(var_id);\n  vec2 d = abs(fragCoord - vec2(\n          mod(id, iChannelResolution[0].y),\n          floor(id / iChannelResolution[0].y)\n  \t\t) - 0.5);\n  if (max(d.x, d.y) < 0.5)\n      fragColor = val;\n}\n\nfloat circle(vec2 pos, float radius, vec2 uv) {\n    float d = length(uv - pos);\n    return smoothstep(d, d + 0.01, radius);\n}\n\n//============================================================\n// END UTIL\n//============================================================\n\n//============================================================\n// BEGIN SEGMENT\n//============================================================\n\nstruct Segment {\n  vec2 a;\n  vec2 b;\n\n  vec4 color;\n  float angle;\n  float len;\n  float radius;\n  int index;\n};\n\nfloat get_segment_intensity(inout Segment s, vec2 p)\n{\n    vec2 pa = p - s.a, ba = s.b - s.a;\n    float h = length(pa - ba * clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0 ));\n    return smoothstep(s.radius, 0.5 * s.radius, h);   \n}\n\nSegment load_segment(int id) {\n    Segment s;\n    \n    vec4 a_b = load_vec4(STORE_SIZE * id + 1);\n    s.a = a_b.xy;\n    s.b = a_b.zw;\n\n    s.color = load_vec4(STORE_SIZE * id + 2);\n    \n    vec4 angle_len_radius = load_vec4(STORE_SIZE * id + 3);\n    s.angle = angle_len_radius.x;\n    s.len = angle_len_radius.y;\n    s.radius = angle_len_radius.z;\n  \n    s.index = id;\n    \n    return s;\n}\n\nvoid save_segment(Segment s, inout vec4 fragColor, vec2 fragCoord) {\n    save_vec4(STORE_SIZE * s.index + 1, vec4(s.a, s.b), fragColor, fragCoord);\n    save_vec4(STORE_SIZE * s.index + 2, s.color, fragColor, fragCoord);\n    save_vec4(STORE_SIZE * s.index + 3, vec4(s.angle, s.len, s.radius, 1.), fragColor, fragCoord);\n}\n\n//============================================================\n// END SEGMENT\n//============================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord + fragCoord - iResolution.xy) / iResolution.y;\n    \n\tfragColor = vec4(0);\n    \n    for (int i = 0; i < SEGMENT_COUNT; i++) {\n        Segment s = load_segment(i);\n    \n \t\tfloat intensity = get_segment_intensity(s, uv);\n   \t\tfragColor = mix(fragColor, s.color, intensity);\n    }\n    \n#ifdef FOLLOW_CIRCLE\n    if (iMouse.z < 0.1) {\n        vec2 circle_pos = vec2(sin(iTime / 2. + 1.), sin(iTime / 3.));\n        float intensity = circle(circle_pos, 0.03, uv);  \n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 0.0), intensity);\n    }\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// License: Do What The F**k You Want To But It's Not My Fault Public License v1 (WTFNMFPL-1.0)\n// Created by Osipov Kirill --- zabidon, KirillD503\n\n// You can change the next two lines\n#define LENGTH 0.1\n#define SEGMENT_COUNT 10\n\n// Don't change the next line\n#define STORE_SIZE 3\n\n\n// You can comment the next line\n#define SMOOTH_MOVEMENT\n#ifdef SMOOTH_MOVEMENT\n# define VELOCITY 0.5\n#endif\n\n\n// You can comment the next line\n#define FIXED\n\n// You can comment the next line and same line in the Image pass\n#define FOLLOW_CIRCLE\n\n//============================================================\n// BEGIN UTIL\n//============================================================\n\n#define texel_size iChannelResolution[0].xy\n\nvec4 load_vec4(int var_id) {\n  float id = float(var_id);\n  vec2 var_coord = (vec2(\n          mod(id, texel_size.y),\n          floor(id / texel_size.y)\n  \t\t) + 0.5) / texel_size;\n  return texture(iChannel0, var_coord);\n}\n\nvoid save_vec4(int var_id, vec4 val, inout vec4 fragColor, vec2 fragCoord) {\n  float id = float(var_id);\n  vec2 d = abs(fragCoord - vec2(\n          mod(id, iChannelResolution[0].y),\n          floor(id / iChannelResolution[0].y)\n  \t\t) - 0.5);\n  if (max(d.x, d.y) < 0.5)\n      fragColor = val;\n}\n\nint get_var_id_by_uv(vec2 uv) {\n\treturn int((iChannelResolution[0].y * uv.x + uv.y));\n}\n\n//============================================================\n// END UTIL\n//============================================================\n\n//============================================================\n// BEGIN SEGMENT\n//============================================================\n\nstruct Segment {\n  vec2 a;\n  vec2 b;\n\n  vec4 color;\n  float angle;\n  float len;\n  float radius;\n  int index;\n};\n\nvoid follow_segment(inout Segment s, vec2 target) {\n    vec2 dir = target - s.a;\n    s.angle = atan(dir[1], dir[0]);\n    s.a = target - s.len * normalize(dir);\n}\n\nvoid update_segment(inout Segment s) {\n    s.b = s.a + vec2(s.len * cos(s.angle), s.len * sin(s.angle));\n}\n\nSegment load_segment(int id) {\n    Segment s;\n    \n    vec4 a_b = load_vec4(STORE_SIZE * id + 1);\n    s.a = a_b.xy;\n    s.b = a_b.zw;\n\n    s.color = load_vec4(STORE_SIZE * id + 2);\n    \n    vec4 angle_len_radius = load_vec4(STORE_SIZE * id + 3);\n    s.angle = angle_len_radius.x;\n    s.len = angle_len_radius.y;\n    s.radius = angle_len_radius.z;\n  \n    s.index = id;\n    \n    return s;\n}\n\nvoid save_segment(inout Segment s, inout vec4 fragColor, vec2 fragCoord) {\n    save_vec4(STORE_SIZE * s.index + 1, vec4(s.a, s.b), fragColor, fragCoord);\n    save_vec4(STORE_SIZE * s.index + 2, s.color, fragColor, fragCoord);\n    save_vec4(STORE_SIZE * s.index + 3, vec4(s.angle, s.len, s.radius, 1.), fragColor, fragCoord);\n}\n\n//============================================================\n// END SEGMENT\n//============================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfragColor = vec4(0);\n\n    Segment segs[SEGMENT_COUNT];\n \n    // update\n    vec2 last_pos;\n    for (int i = 0; i < SEGMENT_COUNT; i++) {\n        Segment s;\n        if (iFrame < 10) {\n            s.radius = 0.02;\n            s.color = vec4(1.0);\n            s.len = LENGTH;\n            s.index = i;\n            s.radius = 0.01;\n            s.radius = float(i) / float(SEGMENT_COUNT) * 0.01 + 0.01;\n        } else {\n            s = load_segment(i);\n            if (i == 0) {\n                vec2 target;\n#ifdef FOLLOW_CIRCLE\n                if (iMouse.z > 0.) {\n                    target = (iMouse.xy + iMouse.xy - iResolution.xy)/ iResolution.y;\n                } else {\n                \ttarget = vec2(sin(iTime / 2. + 1.), sin(iTime / 3.));\n                }\n#else\n                target = (iMouse.xy + iMouse.xy - iResolution.xy)/ iResolution.y;\n#endif\n\n#ifdef SMOOTH_MOVEMENT\n                vec2 trans = target - s.b;\n                if (length(trans) > iTimeDelta * VELOCITY) {\n                    vec2 dir = normalize(trans);\n                    follow_segment(s, s.b + dir * iTimeDelta * VELOCITY);\n                } else\n#endif\n                    follow_segment(s, target);\n            } else {\n                follow_segment(s, last_pos);\n            }\n\n            last_pos = s.a;\n        }\n        \n        segs[i] = s;\n    }\n    \n    // save\n    vec2 end_pos = segs[SEGMENT_COUNT - 1].a; \n    for (int i = 0; i < SEGMENT_COUNT; i++) {    \n#ifdef FIXED       \n        segs[i].a -= end_pos;\n#endif\n        update_segment(segs[i]);\n        save_segment(segs[i], fragColor, fragCoord);\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}