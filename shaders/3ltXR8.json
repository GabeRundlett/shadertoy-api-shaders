{
    "Shader": {
        "info": {
            "date": "1580909132",
            "description": "An experiment of photorealism and progressive rendering on a still life subject.\n- Drag the mouse for interactive mode\n- Press 'S' or reset timer to restart slideshow mode (It needs to be manually restarted when going fullscreen)\nMore infos in comments.",
            "flags": 112,
            "hasliked": 0,
            "id": "3ltXR8",
            "likes": 70,
            "name": "A cup of coffee (Progressive)",
            "published": 3,
            "tags": [
                "coffee",
                "refraction",
                "bokeh",
                "sampling",
                "ibl",
                "pbr",
                "progressive",
                "ashtray"
            ],
            "usePreview": 1,
            "username": "PixelPhil",
            "viewed": 1854
        },
        "renderpass": [
            {
                "code": "//\n// A cup of coffee by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Music: A cup of coffee - DJ Okawari\n\n// For this shader, I started with music as an inspiration. I wanted to present a\n// still life scene with as much photorealism I could cram in a shader. I started with\n// a porcelain cup reusing the PBR stuff I coded for my Piranah Plant shader, then came\n// the metal jug and the ashtray. Because the ashtray looked silly I tried to make it\n// transparent. That's the moment I fell into the rabbit hole... It proved to be a much harder\n// problem to solve and my first implementation with true refraction (quasi unlimited glass\n// layer traversal) ended up compiling in over two minutes on my laptop (which is my benchmark\n// for lousy performances). I ended up hacking things up and simplifying it down to 20s by\n// removing everything unnecessary from the SDF. The big Aha! moment was when I realized\n// that things improved dramatically when tracing opaque objects and transparent ones\n// separately and compositing the result afterward. Although it feels like more work\n// it compiles much faster and, to my surprise, also performs better as well.\n// To reach < 10s I had to sacrifice a few instances of nice Voronoise for some ugly\n// texture noise... oh well...\n\n// I seized the opportunity of rendering a 'static' scene to implement a progressive\n// rendering scheme and rely heavily on jittering for anything from soft shadows to\n// anti-aliasing or glossy reflexions.\n\n// The meat of the code is all in buffer A. If you feel like toying, you will find there\n// defines to play with.\n\n//\n// DISCLAIMER: Smoking is a bad habit that may cause cancer and many health issue\n// it is neither advised nor encouraged by this shader.  ;)\n//\n\n\n// This buffer does only final frame compositing\n\n#define KEN_BURNS_ZOOM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Fetch the secret top ixel and determine if slideshow mode is on\n    vec4 mixData = texture(iChannel0, vec2(0,0));\n    bool SlideShow = (mixData.z > 0.0);\n    \n    float fade = 1.0;\n    \n    vec2 uvs = fragCoord.xy / iResolution.xy;\n    \n    if (SlideShow)\n    {\n        // For a better thumbnail the time is offset by 5s\n        float time = iTime;\n        if (iResolution.x <= 300.0) time -= 5.0;  \n            \n        // In slideshow mode determine the moment in the slide we are in\n        float frameTime = time * 0.1;\n        float frameRatio = 1.0 - fract(frameTime);\n        \n        // Add a fade to black to hide the integration under the rug\n        fade  = smoothstep(0.01, 0.15, frameRatio);\n        fade *= smoothstep(0.99, 0.95, frameRatio);\n        \n        \n        // Add a Ken burns zoom for a bit of dynamism\n        #ifdef KEN_BURNS_ZOOM\n        float zoom = 1.0 - frameRatio * frameRatio * 0.1;\n        uvs = vec2(0.5) + (uvs - vec2(0.5)) * zoom;\n        #endif\n    }\n\n\t// The image is read in the buffer in linear space\n    // it is only encoded into gamma space before being presented\n    vec4 linearImage = textureLod(iChannel1, uvs, 0.0);\n    vec3 col = pow(linearImage.rgb * fade,vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 21117,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/juailes/dj-okawari-a-cup-of-coffee"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\nfloat Voronoi( in vec2 x, float u)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float va = 1000.0;\n    \n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = sqrt(d);\n        va = min(va, w);\n    }\n\n    return va;\n}\n\n\n\n// A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    //diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define  PROGRESSIVE_RENDERING\n\n// Uncomment one of those lines to focus on a different target in interactive mode\n//#define  ASHTRAY\n//#define  CENTER\n\n// Uncomment this line for a different artistic statement\n//#define MATCAP\n\n// Yan can play with that quantity for a smoother or sharper DOF\n#define BOKEH 0.02\n\n\n\n#define MAX_DST 200.0\n#define MIN_DST 0.004\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define TABLE\t\t \t0.0\n#define COFEE\t\t\t2.0\n#define STEEL\t\t\t3.0\n#define BURNT_TIP\t\t4.0\n#define ASH\t\t\t\t5.0\n#define SUGAR\t\t\t6.0\n#define MILK\t\t\t7.0\n#define CIGARETTE1\t\t8.0\n#define CIGARETTE2\t\t9.0\n#define PAPER\t\t\t10.0\n\n#define GLASS \t\t\t11.0\n\n\n\n// all matrices and offsets that needs to be pre-computed\n// in order to keep the SDF relatively straightforward\nstruct SceneSetup\n{\n    mat4 cup;\n    mat4 spoon;\n    mat4 ashtray;\n    mat4 cig1;\n    mat4 cig2;\n    mat4 jug;\n    mat4 sugar;\n    \n    vec3 noise;\n};\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec4 albedo;\n    float metalness;\n    float roughness;\n    float occlusion;\n};\n\n    \n// Procedural wood veins with optionnal grain\nvoid WoodMaterial(vec3 pos, out PBRMat mat, bool simpler)\n{\n    vec2 p = (pos.xz + pos.yy);\n    float wood = VoroNoise(p * vec2(0.01, 0.08), 0.5, 1.0);\n    \n    wood = fract(wood * 3.0);\n    \n    float wood2 = fract(wood * 10.0);\n    \n    p *= vec2(3.0, 6.0);\n    \n    float noise = 0.5;\n    \n    if (!simpler)\n    {\n        noise = (Noise2(p) + Noise2(p * 2.0)) * 0.5;\n    }\n    \n    wood = wood * 0.5 + wood2 * 0.3 +  noise * 0.2;\n    \n    vec3 woodColor = mix(vec3(0.52, 0.38, 0.25), vec3(0.7, 0.58, 0.4), wood);\n    \n    mat = PBRMat(vec4(woodColor, 1.0), 0.4, noise * 0.3, 1.0); \n}\n\n// Ash material\nvoid AshMaterial(vec3 pos, out PBRMat mat, bool simpler)\n{\n    float noise = VoroNoise(pos.xz * 4.0, 1.0, 0.3);\n    noise = 1.0 - (noise * noise) * 0.75;\n    \n    if (!simpler)\n    {\n       noise -= VoroNoise(pos.xz * 10.0, 1.0, 0.3) * 0.2;\n    }\n    \n    mat = PBRMat(vec4(vec3(noise), 1.0), 0.0, 1.0, 1.0); \n}\n\n// Cigarette material\nvoid CigMaterial(vec3 pos, mat4 cigMat, out PBRMat mat, bool simpler)\n{\n\tvec3 cigPos = (cigMat * vec4(pos, 1.0)).xyz;\n    \n    if (cigPos.y < 4.5) // At the filter\n    {   \n        vec3 filterColor = vec3(0.9, 0.55, 0.01);\n        \n        if (!simpler) // in reflexions the dots are not computed\n        {\n            // Get the cylindrical texture coordinates\n            float angle = atan(-cigPos.z, cigPos.x); \n            vec2 uv = vec2(angle, -cigPos.y);\n            \n            // Add some noise to the domain for more irregular shapes\n            uv = uv * 1.5 + vec2(VoroNoise(uv * 3.0, 1.0, 1.0) * 0.6, 0);\n\n\t\t\t// Threshold a voronoi distance to prodice dots\n            float noise = S(0.2, 0.21, Voronoi(uv, 1.0));\n\n            // Blend two colors\n            filterColor = mix(vec3(0.98, 0.7, 0.01), vec3(0.9, 0.55, 0.01), noise);\n        }\n        \n        mat = PBRMat(vec4(filterColor, 1.0), 0.2, 0.7, 1.0); \n    }\n    else if (cigPos.y < 4.7)\n    {\n        // This is the golden ring of the filter\n    \tmat = PBRMat(vec4(1, 0.7, 0, 1.0), 1.0, 0.0, 1.0);\n    }\n    else\n    {\n        // Te rest is white\n\t\tmat = PBRMat(vec4(0.95, 0.95, 0.95, 1.0), 0.0, 0.5, 1.0); \n    }\n}\n\nvoid CofeeMaterial(vec3 pos, out PBRMat mat, SceneSetup setup)\n{\n    vec3 cofeeCol = vec3(0.15, 0.01, 0.1);\n    \n    pos = (setup.cup * vec4(pos, 1.0)).xyz;\n    \n\tif (pos.y > 5.25)\n    { \n\t\t// Foam\n        float fl = max(0.0, length(pos.xz + vec2(-1.8, 1.5)));\n\n        float foam = S(3.0, 6.0, fl);\n        float foam2 = S(10.0, 3.0, fl);\n        \n        vec3 foamHue = mix(vec3(0.9, 0.7, 0.4), vec3(0.9, 0.8, 0.75) * 0.8, foam2);\n        \n        vec3 foamColor = mix(cofeeCol, foamHue, foam);;\n        \n        mat = PBRMat(vec4(foamColor, 1.0), 0.5, foam, 1.0);\n    }\n    else\n    {\n    \tmat = PBRMat(vec4(cofeeCol, 1.0), 0.5, 0.0, 1.0);\n    }\n}\n\n// Computes a PBR Material from material ID and world position\nvoid GetMaterial(float id, vec3 pos, SceneSetup setup, out PBRMat mat, bool simpler)\n{   \n\n    mat = PBRMat(vec4(1, 0, 0, 1.0), 0.6, 1.0, 0.5); // Default material is red plastic\n    #ifdef MATCAP\n    return;\n    #else\n    \n    \n    if \t\t(id == TABLE\t\t) { WoodMaterial(pos, mat, simpler); } \n    //else if (id == PORCELAIN\t) { mat = PBRMat(vec4(0.9, 0.9, 0.9, 1.0), 0.7, 0.0, 4.0); }\n    else if (id == COFEE\t\t) { CofeeMaterial(pos, mat, setup); }\n    else if (id == STEEL\t\t) { mat = PBRMat(vec4(0.75, 0.75, 0.75, 1.0), 0.95, 0.0, 1.0); }\n    else if (id == GLASS \t\t) { mat = PBRMat(vec4(0, 0, 0, 0.05), 2.0, 0.0, 1.0); }\n    else if (id == ASH\t\t\t) { AshMaterial(pos, mat, simpler); }\n    else if (id == SUGAR\t\t) { mat = PBRMat(vec4(0.8, 0.8, 0.8, 1.0), 0.2, 0.9, 6.0); }\n    else if (id == MILK\t\t\t) { mat = PBRMat(vec4(1, 1, 1, 1.0), 0.0, 0.0, 3.0); }\n    else if (id == CIGARETTE1\t) { CigMaterial(pos, setup.cig1, mat, simpler); }\n    else if (id == CIGARETTE2\t) { CigMaterial(pos, setup.cig2, mat, simpler); }\n    else if (id == PAPER\t\t) { mat = PBRMat(vec4(1, 1, 1, 1.0), 0.3, 1.0, 1.0); }\n    else if (id == BURNT_TIP\t) { mat = PBRMat(vec4(0, 0, 0, 1.0), 0.2, 1.0, 1.0); }\n    \n    #endif\n    \n  \treturn;\t\n}\n\n// Build all the matrices and offsets necessary to compute the SDF\n// leaving all that in would lead to bad perfs and insane compile times\nvoid buildSetup(out SceneSetup res, vec3 target)\n{\n\n    res.cup = translate(target);\n    \n    res.spoon = rotationX(-1.5) *\n        \t\trotationY(-1.0) *\n                translate(vec3(2.0, -0.48, 9.0)) * res.cup;\n    \n    res.ashtray = rotationY(-0.5) * \n        \t\t  translate(vec3(-10.0, -5.0, -20.0)) * res.cup; \n \n    res.cig1 =  rotationX(1.8)*\n                translate(vec3(0.0, 1.0, 10.0)) *\n                res.ashtray;\n\n    mat4 swizzle = \tmat4( 1, 0, 0, 0,\n                          0, 0, 1, 0,\n                          0, 1, 0, 0,\n                          0, 0, 0, 1);\n    \n    res.cig2 =  rotationZ(-2.5)*\n                translate(vec3(-3, -4.0, 3.5)) *\n        \t\tswizzle *\n                res.ashtray;\n    \n    res.jug =  rotationY(3.5) * translate(vec3(18.0, -0.6, -8)) * res.cup;\n        \n    res.sugar = rotationY(2.0) * translate(vec3(-6.2, -0.4, 4.3)) * res.cup;\n}\n\n// A cigarete ditance function with material ids\nvec2 dstCigarette(vec3 pos, float len, float id)\n{\n    vec2 cig = vec2(length(pos.xz) - 0.8, id); // infinite cylinder\n    \n    cig = combineMax(cig, vec2(-pos.y, PAPER)); // cut at the tip of the filter with paper material\n    \n     // cut irregularly at the end with burt black material\n    cig = combineMax(cig, vec2(pos.y - len + (sin(pos.x * 10.0) + sin(pos.y * pos.z)) * 0.029, BURNT_TIP));\n    \n    return cig;\n}\n\n// I use the noise texture mainly to reduce compile time under 10s on my less capable computer\nvec3 TextureNoise(vec2 uvs)\n{\n    return textureLod(iChannel3, uvs, 0.0).rgb;\n}\n\n// SDF of the scene\n// There is a neat trick here to bring back compile time from 30 to 10s\n// When OpaqueOnly is set to true only the opaque obects are returned\n// When it is set to false only glass is returned\n// This produces two simpler SDFs that end up being much more efficient to trace\n// on their own and doing compositing afterward rather than tracing a more complicated\n// one that would include both\nvec2 SDF(vec3 pos, SceneSetup setup, bool opaqueOnly)\n{\n    vec2 res;\n    \n\n    vec3 cupPos = (setup.cup * vec4(pos, 1.0)).xyz;\n    \n    // cup starts with the coumpound of a round cylinder and round cone\n    float cup = sdRoundedCylinder(cupPos, 2.0, 0.25, 0.0);\n    float cupsp = sdRoundCone(cupPos - vec3(0, 4.5,0), 6.2, 7.4, 10.0 );\n   \tcup = smin(cup, cupsp, 1.0);\n    \n    \n    // is a reduced version of the cup's hull cut at a level\n    float coffee = cup + 0.5;\n\tcoffee = smax(coffee, cupPos.y - 5.5, 0.3);\n    \n    // Cup is hollowed with onioning and cut open\n    cup = abs(cup) - 0.5; \n    cup = smax(cup, cupPos.y - 8.0, 0.6) * 0.5;\n    \n    // The plate starts with a rounded cylinder stretched in x and z\n    vec3 platePos = cupPos * vec3(0.35, 1.0, 0.35);\n    float plate = sdRoundedCylinder(platePos  - vec3(0, 1.0,0), 2.0, 2.0, 0.0);\n    \n    // hollowed with onioning and cut \n    plate = abs(plate) - 0.1;\n    plate = smax(plate, cupPos.y - (1.0), 0.4);\n    \n    // a torus is added at the base of the cup for extra detail\n    plate = smin(plate, sdTorus(cupPos - vec3(0, -0.8, 0), vec2(5.1, 0.3)), 0.6);\n    plate *= 0.35; // Adjusts for ray tracing misses\n    \n    \n    // Then handle is an elongated torus that is scaled along x on the liower left quarter  \n    vec3 handlePos = cupPos.xzy - vec3(8.1, 0.0, 4.5);\n    float scale = 1.0;\n    \n    if (handlePos.x < 0.0 && handlePos.z < 0.0)\n    {\n        scale = 0.6;\n        handlePos.x *= scale;\n    }\n    handlePos.y = max(0.0, abs(handlePos.y) - 0.5);\n    float handle = sdTorus(handlePos, vec2(2.2, 0.45));\n    \n     \n    res = vec2(coffee, COFEE); // combine coffee in the final result\n    \n    // The table is a rounded cylinder\n    vec3 tablePos = cupPos - vec3(-15.0, -3.0, 43.0);\n    float table = sdRoundedCylinder(tablePos, 30.0, 1.0, 1.0);\n    \n    // It has a foot (check it out ;) ) that is an infinite cylinder cut a level\n    float tablefoot = max(tablePos.y, length(tablePos.xz) - 4.5);\n    \n    res = combineMin(res, vec2(table, TABLE)); // table is combines in the final result\n    \n\n\n    vec3 sponPos = (setup.spoon * vec4(pos, 1.0)).xyz;\n    \n    // The spoon starts with a 2D disk sdf with a top half stretched\n    if (sponPos.y > 0.0) sponPos.y *= 0.7;\n    sponPos.x *= 1.1;\n    float len = length(sponPos.xy);\n    float spoon = len - 2.8; \n    \n    // The handle starts with a trapezoid sdf with it's tip smoothly clamped\n   \tif (sponPos.y < 0.0)\n    {\n        float handle = abs(sponPos.x) - 0.5 + sponPos.y * 0.04;\n        handle = smax(handle,  -16.0 - sponPos.y, 1.0);\n        \n        spoon = smin(spoon, handle, 1.5);\n    }\n    \n    // That resulting 2D shape is the used to stencil cut a combination of distances\n    // function to describe the curvature of the handle and the spoon itself\n    float d = (len / 3.0);\n    d = smin(d * d, 1.0, 0.2);\n    \n    float k = abs(sponPos.x);\n    \n    float bend = S(-1.8, -4.5, sponPos.y);\n    k = k* k * 0.2;\n    k *= bend;\n    \n    spoon = smax(spoon, -0.1 + abs(sponPos.z -  bend * 0.5 - d + k), 0.05);\n    \n    // It is super non-euclidean and honestly I couldn't believe I would get away with it\n    // but it turned out that just adjusting the ray marching step a bit produced a clean result\n    spoon *= 0.5;\n    \n\n    vec3 ashtrayPos = (setup.ashtray * vec4(pos, 1.0)).xyz; \n    \n    \n\t// Ashtray, like many other things, starts with a rounded cylinder\n    float ashtray = sdRoundedCylinder(ashtrayPos - vec3(0, -0.7,0), 4.5, 0.6, 4.0);\n    \n\n   \tif (ashtray - 4.0 > 0.0) //Bounding volume optimisation for the ashtray\n   \t{\n        ashtray = ashtray - 3.5;\n    }\n    else\n    {\n\t\t// The cigarette holder holes are cut with an infinite cylingder\n        // elongated on y with a central domain symmetry\n        \n        vec3 cylPos = abs(ashtrayPos);\n        if (cylPos.x > cylPos.z) cylPos.xz = cylPos.zx;\n        cylPos.y = max(0.0, abs(cylPos.y) - 1.0);\n        float cyl = length(cylPos.yx) - 1.0;    \n        \n        ashtray = abs(ashtray) - 0.8;\t\t\t\t// Hollwed with onioning\n        ashtray = smax(ashtray, ashtrayPos.y, 0.5); // Cut open\n        ashtray = smax(ashtray, -cyl, 0.35);\t\t// Removed holder holes\n        \n        // The ash level is a combination of the squared central ditance to the ashtray\n        // and some arbitrary sines\n        float l = length(ashtrayPos.xz) / 5.0;\n        l = l * l * 0.7;\n        float ash = ashtrayPos.y + 3.5 + sin(ashtrayPos.x * 0.3 - 0.4)  + sin(ashtrayPos.z * 0.76) * 0.25 + l;\n        ash = smax(ash, -ashtrayPos.y - 4.75, 0.25);\n        \n        if (ash - 1.0 > 0.0) // Do not compute details of the ash unless very close\n        {\n            ash -= 0.5;\n        }\n        else\n        {\n            // VoroNoise is more pleasing to the eyes but adds 2s to compile time on my PC Laptop per call in the SDF\n        \t// ash += VoroNoise(ashtrayPos.xz * 2.5, 1.0, 0.55) * 0.6;\n            ash += TextureNoise(ashtrayPos.xz * 2.5 / 64.0).r * 0.9;\n        \tash *= 0.6;\n        }\n        \n        \n        vec3 cig2Pos = (setup.cig2 * vec4(pos, 1.0)).xyz;\n\n        // The second cigarette is crushed, so I mess with it's domain\n        cig2Pos.x += abs(sin(pos.x)) * 0.3;\n            \n        vec2 cig2 = dstCigarette(cig2Pos, 6.0, CIGARETTE2);\n        \n        // Put all that trash together\n        res = combineMin(res, vec2(ash, ASH));\n        res = combineMin(res, cig2);\n    }\n    \n    \n    // Leave the first cigarette out of the Ashtray bound optimisation as it is on the edge\n    // and prone to raycast misses\n    vec3 cig1Pos = (setup.cig1 * vec4(pos, 1.0)).xyz;\n\tvec2 cig1 = dstCigarette(cig1Pos, 14.0, CIGARETTE1);\n    res = combineMin(res, cig1);\n   \n\n    // See comments on top of the function\n    // When opaqueOnly is set to false, ignore the glass entierly\n    // The compiler will strip it out\n    if (!opaqueOnly)\n    {\n        cup = smin(handle,cup, 0.5);\n        cup = min(ashtray,cup);\n        cup = min(plate,cup);\n\n        // When opaqueOnly is set to true, just return the glass\n        // The compiler will strip out all dead code and produce a lightweight SDF\n        return vec2(cup, GLASS);\n    }\n\n\n    \n    vec3 jugPos = (setup.jug * vec4(pos, 1.0)).xyz;\n    //jugPos -= vec3(-18, 0.6, 8);\n    //jugPos = (rotationY(3.5) * vec4(jugPos, 0.0)).xyz;  \n    \n    float jug = sdRoundCone( jugPos - vec3(0, 0, 0), 4.0, 3.0, 10.0 );\n    \n    \n    if (jug - 7.0 > 0.0) // Bounding box optimisations for the milk jug\n    {\n        jug = jug - 4.3;\n    }\n    else\n    {\n        // The spout is an infinite cylinder bent and scale on the x axis\n        vec2 spoutPos = jugPos.xz;\n        spoutPos.x *= 0.7;\n        spoutPos.x += jugPos.y * 0.23;\n\n        // combines with the jug body\n        jug = smin(jug, length(spoutPos) - 1.0, 0.2);\n\n        jug = smax(jug, -jugPos.y - 1.5, 1.0); // cut below\n\n        jug = abs(jug) - 0.1;  // hollowed with onioning\n\n        jug = smax(jug, jugPos.y - 8.5, 0.1); // cut above\n        jug *= 0.8; // adjust for raycast misses\n\n\t\t// The Handle is an elongated, hollowed cylinder bent with some domain distortion\n        vec3 jugHandlePos = jugPos - vec3(5.0, 4.5, 0);\n\n        //jugHandlePos.x -= jugHandlePos.y * 0.1;\n        jugHandlePos = max(vec3(0.0), abs(jugHandlePos) -vec3(jugPos.y * 0.1 + 0.25, 2.3, 0.0));\n\n        float jughandle = abs(length(jugHandlePos.xy) - 0.6) - 0.1;\n\n        jughandle = smax(jughandle, abs(jugHandlePos.z) - 0.6, 0.1);\n\n        jug = min(jug, jughandle);\n\n        // Got milk?\n        float milk = sdRoundedCylinder(jugPos - vec3(0.0, 4.0, 0), 1.5, 0.35, 0.0);\n        res = combineMin(res, vec2(milk, MILK));\n    }\n\n    // Integrate everything steel in the final result\n    res = combineMin(res, vec2(min(min(spoon, jug), tablefoot), STEEL));\n    \n    // Sugar is a rounded bow with added noise\n    vec3 sugarPos = (setup.sugar * vec4(pos, 1.0)).xyz;\n    float sugar = sdRoundBox(sugarPos, vec3(1.8, 0.6, 0.9), 0.3);\n    \n    if (sugar - 0.5 < 0.0)\n    {\n        // Changed to bring back compile time under 10s on my laptop\n        //sugar += VoroNoise((sugarPos.xz + sugarPos.yx)  * 6.0, 1.0, 0.5) * 0.1;   \n        sugar += TextureNoise((sugarPos.xz + sugarPos.yx)  * 8.0 / 64.0).r * 0.1;\n        sugar *= 0.7;\n    }\n    \n\tres = combineMin(res, vec2(sugar, SUGAR)); // Finally add sugar :D\n\n\treturn res;\n}\n\n\n// Like the SDF, normals can be computed with glass or solid objects\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos, SceneSetup ps, bool opaqueOnly)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps, opaqueOnly).x;\n    }\n    return normalize(n);\n}\n\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, SceneSetup ps, bool opaqueOnly)\n{\n    vec2 dst = vec2(5.0, 0.0);\n\n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps, opaqueOnly);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\nfloat shadow(vec3 pos, vec3 normal, vec3 lPos, SceneSetup ps)\n{       \n#ifdef PROGRESSIVE_RENDERING\n    lPos += ps.noise * 8.0; // In progressive mode, the light position is jittered for smooth shadows\n#endif\n    \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += normal * MIN_DST * 40.0;\n    \n    \n    vec2 ray =  castRay(pos, dir, MAX_DST, MIN_DST * 10.0, ps, true);\n    if (ray.x < MAX_DST) return 0.0; // if it crosses something opage shadow is full\n    \n    ray =  castRay(pos, dir, MAX_DST, MIN_DST * 10.0, ps, false);\n    if (ray.x < MAX_DST) return 0.45; // if it crosses something transparent shadow is partial\n    \n    // No shadow\n    return 1.0;\n}\n\n// Convert the St Peters Basilica red ambiance to something more blueinsh and desaturated\nvec3 AmbianceLight(vec3 texColor)\n{\n    vec3 color = texColor.bgr; // swizzle to change red to blue\n    float gs = dot(color, vec3(0.33)); // grayscale value\n    color = mix(color, vec3(gs), 0.5); // desaturate\n    return color * color; // convert to linear space\n}\n\nvec3 SkyDomeBlurry(vec3 rayDir, float lod)\n{\n    rayDir.z = -rayDir.z;\n    return AmbianceLight(textureLod(iChannel2, rayDir.xyz,  lod).rgb);\n}\n\nvec3 SkyDomeSharp(vec3 rayDir)\n{\n    rayDir.z = -rayDir.z;\n    return AmbianceLight(textureLod(iChannel2, rayDir.xyz,  0.0).rgb);\n}\n\n// Simplified render within reflection\nvec3 ReflectionLight(vec3 pos, vec3 n, float matId, vec3 rayDir, SceneSetup setup)\n{\n     PBRMat mat;\n     \n     GetMaterial(matId, pos, setup, mat, true); // Comput material\n     mat.albedo.rgb *= mat.albedo.rgb; \n\n     // Fresnel\n     float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n     // Just some basic facing ratio and environment lighting\n     vec3 col = fresnel * mat.albedo.rgb;\n    \n     if (mat.roughness < 0.5)\n     {\n         vec3 refDir = reflect(rayDir, n);\n         col += SkyDomeSharp(refDir) * fresnel * 0.6;\n     }\n    \n\t return col;\n}\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float lightRadius, float fresnel, SceneSetup ps, bool AddEnv)\n{\n    //Basic lambert shading stuff\n    \n    vec3 key_Dir = lightPos - pos;\n    float key_len = length(key_Dir);\n    \n    float atten = sat(1.0 - key_len / lightRadius);\n    atten *= atten;\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir)) * atten;\n    float key_shadow = shadow(pos, normal, lightPos, ps); \n    \n    float diffuseRatio = key_lambert * key_shadow;\n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo.rgb, mat.metalness);\n    \n    vec3 col = mat.albedo.rgb * key_diffuse * min(1.0, 2.0 - mat.metalness * 2.0);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * atten * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n    //Optionnal environment reflection (only for key light)\n    if (AddEnv)\n    {\n       vec3 hitPos = pos + normal * MIN_DST * 40.0;\n       \n#ifdef PROGRESSIVE_RENDERING\n       refDir = normalize(refDir + (ps.noise * mat.roughness * 0.5));\n#endif\n        \n       // Cast two rays\n       // One with only opage objects\n       vec2 hitOpaque = castRay(hitPos, refDir, MAX_DST, MIN_DST * 5.0, ps, true);\n       // One with oly transparent ones\n       vec2 hitGlass  = castRay(hitPos, refDir, MAX_DST * 0.5, MIN_DST * 5.0, ps, false);\n        \n       vec3 refCol;\n       \n       if (hitOpaque.x < MAX_DST)\n       {\n           // If opaque did hit we reflect that\n           vec3 refPos = hitPos + refDir * hitOpaque.x;\n           vec3 refN = calcNormal(refPos, ps, true);\n           refCol = ReflectionLight(refPos, refN, hitOpaque.y, refDir, ps);\n       }\n       else\n       {\n           // otherwise we reflect the skydome\n           refCol = SkyDomeSharp(refDir);\n       }\n        \n        \n       if (hitGlass.x < MAX_DST * 0.5 && hitGlass.x < hitOpaque.x)\n       {\n           // If the glass is before the solid hit then we reflect that too\n           vec3 refPos = hitPos + refDir * hitGlass.x;\n           vec3 refN = calcNormal(refPos, ps, false);\n           refCol += ReflectionLight(refPos, refN, hitGlass.y, refDir, ps);\n       }\n\n       col += f * refCol * specRatio;\n    }\n    \n    return max(vec3(0), col);\n}\n\n// Shades and integrate a surface point from its position, normal and material id\nvec3 IntegrateSurface(vec3 col, vec3 pos, vec3 n, float matId, vec3 rayDir, SceneSetup setup)\n{ \n     PBRMat mat;\n     \n     GetMaterial(matId, pos, setup, mat, false);\n     \n     mat.albedo.rgb *= mat.albedo.rgb; // Convert albedo to linear space\n\n     vec3 ambient = SkyDomeBlurry(n, 5.0);\n     ambient *= mat.occlusion * 0.5;\n    \n     col = mix(col, mat.albedo.rgb * ambient, mat.albedo.a);\n     \n     // Fresnel\n     float fresnel = pow(1.0 - sat(dot(n, -rayDir)), 1.0);\n\n     // Add both light contributions\n\t vec3 key_LightPos = vec3(10.0, 24.0, -13.0);\n     col += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.0), 1000.0, fresnel, setup, true);\n                  \n     vec3 fill_LightPos = vec3(-20.0, 15.0, 20.0);\n     col += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(1.0), 1000.0, fresnel, setup, false);\n\n\treturn col;\n}\n\n\n// Render a ray including refraction of glass\nvec4 renderRefract(vec3 camPos, vec3 rayDir, SceneSetup setup)\n{\n\n    // Cast to rays on on solid things on on glass only\n    vec2 hitSolid = castRay(camPos, rayDir, MAX_DST, MIN_DST, setup, true);\n    vec2 hitGlass = castRay(camPos, rayDir, MAX_DST * 0.5, MIN_DST, setup, false);\n    \n    // I know it seems weird, but it's much more efficient to proceed this way and\n    // to trace both rays from the camera on two much simpler SDFs\n    \n    vec3 solidPos;\n    vec3 solidRayDir;\n    float solidMat;\n    \n    vec3 glassPos;\n    vec3 glassNormal;\n    bool needGlass = false;   \n    bool needSolid = false;\n    bool needSky = false;\n    \n    vec3 skyDir = rayDir;\n    \n    if (hitGlass.x < hitSolid.x && hitGlass.x < MAX_DST * 0.5)\n    {\n        // Glass is before anything solid\n        \n        // wee keep track of the glass surface\n        needGlass = true;\n        glassPos = camPos + rayDir * hitGlass.x;\n        glassNormal = calcNormal(glassPos, setup, false);\n        \n        // refract the ray and shoot again in the opage SDF\n        vec3 dir2 =  normalize(rayDir - glassNormal * 0.5);\n        \n        vec2 hitRefract = castRay(glassPos, dir2, MAX_DST, MIN_DST, setup, true);\n        \n        if (hitRefract.x < MAX_DST)\n        {\n            // Refraction hit! that's the opaque surface we'll shade\n            needSolid = true;\n            solidPos = glassPos + dir2 * hitRefract.x;\n            solidMat = hitRefract.y;\n        }\n        else\n        {\n            // It's a miss, we need to refract the sky dome\n            needSky = true;\n            skyDir = dir2;\n        }       \n    }\n    else\n    {\n        // No glass here\n        if (hitSolid.x < MAX_DST)\n        {\n            // a solid his si confirmed, we'll render that\n            needSolid = true;\n            solidPos = camPos + rayDir * hitSolid.x;\n            solidRayDir = rayDir;\n            solidMat = hitSolid.y;\n        }\n        else\n        {\n            // No hit, the skydome is straight ahead\n            needSky = true;\n            skyDir = rayDir;\n        }\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (needSky) // Render the skydome if needed\n    {\n        col =  SkyDomeBlurry(skyDir, 0.0); \n    }\n    \n\n    if (needSolid) // Render the opaque surfaces if needed\n    {\n        col = IntegrateSurface(col, solidPos, calcNormal(solidPos, setup, true), solidMat, rayDir, setup);\n    }\n\n\n    if (needGlass) // Render glass if needed\n    {\n        col = IntegrateSurface(col, glassPos, glassNormal, GLASS, rayDir, setup);\n    }\n\n  \n    return vec4(col, 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    if(mouse.x<.001) mouse = vec2(0.37, 0.4);\n    \n    \n    // There's a hidden pixel in the corner of the frame that store\n    // xy: previous mouse position\n    // z: 0 -> Interactive Mode / 0.1 and above -> Slideshow frame tick\n    // w: Integration amount for progressive rendering convergence\n    vec4 mixData = texture(iChannel0, vec2(0,0));\n    \n    bool SlideShow = (mixData.z > 0.0);\n    \n    if (iTime < 0.1) // When time is reset we turn off progressive integration for a while\n    {\n        mixData.xy = mouse; // Set the mouse pos\n        mixData.a = 1.0;    // Integrate 100%\n        mixData.z = 0.1;    // Force SlideShow mode\n    }\n    \n    float finalMix = mixData.a;\n    \n    // Compute the index of the Slide of the diaporama we are showing\n    \n    float time = iTime;\n    if (iResolution.x <= 300.0) time -= 5.0; // For a better thumbnail the time is offset by 5s\n    \n    float frameTime = time * 0.1;\n    float frameId = floor(frameTime);\n        \n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        // We are rendering the secret control pixel\n        \n        // Update the pixel with up to date info\n        fragColor.xy = mouse;\n        fragColor.z = mixData.z;\n        \n        vec2 mouseDiff = mixData.xy - mouse;\n        \n        float diffSq = dot(mouseDiff, mouseDiff);\n        if (diffSq > 0.00001)\n        {\n            // If the mouse has moved\n           \tfragColor.a = finalMix = 1.0; // Restart integration\n            fragColor.z = 0.0; // Turn off Slideshow mode\n            \n        }\n        else\n        {\n            // For the mage integral to quickly converge to the average of all the computed \n            // frames the blending ratio must follow the sequence 1; 1/2; 1/3; 1/4 etc...\n#ifdef PROGRESSIVE_RENDERING\n            float div = 1.0 / finalMix; // current divisor\n            fragColor.a = max(0.01, 1.0 / (div + 1.0)); // new divisor (never less than 1%)\n            \n            if (SlideShow)\n            {\n                float frame = 0.1 + mod(frameId, 5.0) * 0.1; // Compute the slideshow 'tick'\n\n                if (abs(mixData.z - frame) > 0.01) // If we just chnanged Slide\n                {\n                    // Restart integration from scratch for the new frame to converge quickly\n                    fragColor.a = finalMix = 1.0;\n                    fragColor.z = frame; // Record the change for next frame\n                }       \n            }\n#else\n            fragColor.a = 1.0; // No integration when turned off\n#endif\n\n        }\n        \n        return;\n    }\n    \n    vec3 target;\n    vec2 viewAngle;\n        \n    if (SlideShow)\n    {\n\t\t// In slideshow mode\n        float viewPoint = mod(frameId, 3.0);\n        vec4 ranges;\n        \n        // Round robin on the 3 targets\n        if (viewPoint == 0.0)\n        {\n            // Coffee cup\n            target = vec3(0.0);\n            ranges = vec4(-1.3, 1.8, -0.2, -0.8);\n        }\n        else if (viewPoint == 1.0)\n        {\n            // Ashtray\n            target = vec3(10.0, 0.0, 20.0);\n            ranges = vec4(0.15, 2.0, -0.2, -1.2);\n        }\n        else\n        {\n            // Composition center\n            target = vec3(0.0, 0.6, 10);\n            ranges = vec4(-1.0, 1.8, -0.2, -0.5);\n        }\n        \n        \n        // Shuffle the view angle from pre-determined ranges\n        float v = mod(frameId + 1.0, 6.0) / 5.0;\n        float h = mod((frameId + 1.0) * 3.0, 7.0) / 6.0;\n        \n        float vert = mix(ranges.z, ranges.w, v);\n        float horiz = mix(ranges.x, ranges.y, h);\n\n        \n        viewAngle = vec2(horiz, vert);\n        // In slideshow mode the camera rotates very slowly to create some sort of subliminal parralax\n        viewAngle.x += fract(frameTime) * 0.06;\n    }\n    else\n    {\n        // In intergactive mode aim at a fixed point an orient the view with the mouse\n        target = vec3(0.0);\n    \n        #ifdef ASHTRAY\n        target = vec3(10.0, 0.0, 20.0);\n        #endif\n\n        #ifdef CENTER\n        target = vec3(0.0, 0.6, 10);\n        #endif\n        \n        viewAngle = vec2((-mouse.x - 0.6) * pi2, (mouse.y - 0.65) * halfPi);\n    }\n       \n    \n\n    SceneSetup setup;\n    \n    \n    // Build matrices\n    buildSetup(setup, target);\n    \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y; \n\n    // Compute Camera\n    vec3 camPos = vec3(0.0, 2.0, -50.0);\n    \n    vec3 camDir = vec3(0.0, 0.0,  1.0);\n    \n    // Get some 3D noise to jitter some stuff\n    vec2 noiseUv = uv + vec2(mod(iTime, 45.0), 0.0);\n    setup.noise = hash3(noiseUv) - vec3(0.5); // vec3(n, n2, fract((n + n2) * 456.345));\n    \n    // Jitter the ray direction at sub-pixel level for perfect AA\n    #ifdef PROGRESSIVE_RENDERING\n    vec2 aa = setup.noise.xy * 0.5 / iResolution.y;\n    #else\n    vec2 aa = vec2(0);\n    #endif\n    \n    vec3 rayDir = camDir + vec3(uv * 0.45 + aa , 0.0) ;\n    \n    \n    \n   \tvec3 res = vec3(0.0);\n\n    // Slightly jitter the camera around the focal point for depth of field\n    #ifdef PROGRESSIVE_RENDERING\n    viewAngle += setup.noise.xy * BOKEH;\n    #endif\n    \n    \n    // Orient the camera\n    mat4 viewMat = rotationY(viewAngle.x) * rotationX(viewAngle.y);\n    \n    camPos = (viewMat * vec4(camPos, 1.0)).xyz;\n    rayDir = (viewMat * vec4(rayDir, 0.0)).xyz;\n    \n\n    // Render the pixel\n    res = renderRefract(camPos, rayDir, setup).rgb;\n\n    // Integrate the new pixel with the previous frame.\n    // The integration is done in linear space for the result to be gamma correct.\n    #ifdef PROGRESSIVE_RENDERING\n    vec3 prevFrame = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0).rgb;\n    res = mix(prevFrame, res, finalMix);\n    #endif\n    \n\n    // Output to buffer\n    fragColor = vec4(res.rgb,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// This buffer backs up the current frame and litens to the 'S' key\n// To restart the slideshow. That's about it\n\n#define KEY_S 83.0\n\n\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel1, uv).r;\n\n        return key > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 inputTex =  textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.0);\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        // In the secret pixel\n        \n        if (isPressed(KEY_S))\n        {\n            inputTex.z = 0.1; // Restart slideshow\n            inputTex.a = 1.0; // Reset integration\n        }\n        \n        if (iResolution.x <= 300.0 && inputTex.z == 0.0)\n        {\n            inputTex.z = 0.1; // Force Slideshow mode in the thumbnail\n        }\n    }\n    \n    fragColor = inputTex;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}