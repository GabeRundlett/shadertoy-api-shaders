{
    "Shader": {
        "info": {
            "date": "1588101022",
            "description": "License CC0\nCoded while listening to some 1970s Tangerine Dream. Big thanks to ollj for introducing me to SABS.\nCode not very elegant and contains repeated concepts but I liked the result\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3dfBWH",
            "likes": 6,
            "name": "The Rorsach Mask",
            "published": 3,
            "tags": [
                "2d",
                "sabs"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 455
        },
        "renderpass": [
            {
                "code": "// License CC0\n//  Coded while listening to some 1970s Tangerine Dream. Big thanks to ollj for introducing me to SABS\n//  Code not very elegant and contains repeated concepts but I liked the result\n//  Colors are better in non-chromium browsers\n\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n#define TTIME       ((iTime-232.0)*TAU)\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n\nvec2 hash(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n  const float K1 = .366025404;\n  const float K2 = .211324865;\n\n  vec2 i = floor (p + (p.x + p.y)*K1);\n    \n  vec2 a = p - i + (i.x + i.y)*K2;\n  vec2 o = step (a.yx, a.xy);    \n  vec2 b = a - o + K2;\n  vec2 c = a - 1. + 2.*K2;\n\n  vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n  vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),dot (b, hash (i + o)), dot (c, hash (i + 1.)));\n\n  return dot (n, vec3 (70.));\n}\n\nfloat fbm(vec2 pos, float tm) {\n  vec2 offset = vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float aggr = 0.0;\n    \n  aggr += noise(pos);\n  aggr += noise(pos + offset) * 0.5;\n  aggr += noise(pos + offset.yx) * 0.25;\n  aggr += noise(pos - offset) * 0.125;\n  aggr += noise(pos - offset.yx) * 0.0625;\n    \n  aggr /= 1.0 + 0.5 + 0.25 + 0.125 + 0.0625;\n    \n  return (aggr * 0.5) + 0.5;    \n}\n\nvec3 lightning(vec2 pos, float offset, float dl) {\n  vec3 col = vec3(0.0);\n  vec2 f = 10.0*SCA(PI/2.0 + TTIME/1000.0);\n    \n  float width = 0.003*dl;\n    \n  for (int i = 0; i < 2; i++) {\n    float btime = TTIME/35.0 + float(i);\n    float rtime = TTIME/40.0 + float(i) + 10.0;\n    float d1 = abs(offset * width / (0.0 + offset - fbm((pos + f) * 3.0, rtime)));\n    float d2 = abs(offset * width / (0.0 + offset - fbm((pos + f) * 2.0, btime)));\n    col += vec3(d1 * vec3(0.1, 0.3, 0.8));\n    col += vec3(d2 * vec3(0.7, 0.3, 0.5));\n  }\n    \n  return clamp(col, 0.0, 1.0);;\n}\n\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat tile0(vec2 p, float hwidth, float lwidth) {\n  float c0 = circle(p - vec2(hwidth), hwidth);  \n  float c1 = circle(p + vec2(hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n  c1 = abs(c1) - lwidth;\n\n  float d = c0;\n  d = min(d, c1);\n\n  return d;\n}\n\nfloat tile1(vec2 p, float hwidth, float lwidth) {\n  p = abs(p);\n  float c0 = circle(p - vec2(hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat tile2(vec2 p, float hwidth, float lwidth) {\n  // Empty cell\n  return hwidth*4.0;\n}\n\nfloat tile3(vec2 p, float hwidth, float lwidth) {\n  p = abs(p);\n  float c0 = abs(p.x) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat tile4(vec2 p, float hwidth, float lwidth) {\n  p.x = abs(p.x);\n  float c0 = circle(p - vec2(hwidth, hwidth), hwidth);  \n  c0 = abs(c0) - lwidth;\n\n  float d = c0;\n\n  return d;\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\n\nfloat tile(vec2 p, vec2 n, float hwidth, float lwidth) {\n  float rnd = rand(n);\n\n  vec2 ap = abs(p);\n\n  vec2 pp = toPolar(p);\n  pp.y -= float(int(mod(1000.0*rnd, 4.0)))*PI/2.0;  \n  p = toRect(pp);\n\n  float d = 0.0;  \n  \n  if (rnd > 0.95) {\n    d =  tile0(p, hwidth, lwidth);\n  } else if (rnd > 0.85) {\n    d = tile0(p, hwidth, lwidth);\n  } else if (rnd > 0.75) {\n    d =  tile3(p, hwidth, lwidth);\n  } else if (rnd > 0.65) {\n    d =  tile1(p, hwidth, lwidth);\n  } else {\n    d =  tile0(p, hwidth, lwidth);\n  }\n\n  float da1 = circle(ap - vec2(hwidth, 0.0), lwidth);  \n  float da2 = circle(ap - vec2(0.0, hwidth), lwidth);  \n\n  float da = min(da1, da2);\n\n  return min(d, da);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat df(vec2 p) {\n  float hwidth = 1.0;\n  float lwidth = 0.25;\n  vec2 n = mod2(p, vec2(hwidth*2.0));  \n  float d = tile(p, n, hwidth, lwidth);\n  \n  return d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 coordinateTransform(vec2 p) {\n  p.x = SABS(p.x, 0.1);\n  p *= 5.0;\n  rot(p, TTIME/100.0);\n  vec2 sp = toSmith(p);\n  float x = 3.;\n  sp.x += x;\n  sp.y += x;\n  p = fromSmith(sp);\n  return p;\n}\n\nvec4 dCoordinateTransform(vec2 p) {\n  vec4 nor;\n  vec2 eps = vec2(0.0001, 0.0);\n  \n  nor.xy = (coordinateTransform(p + eps.xy) - coordinateTransform(p - eps.xy));\n  nor.zw = (coordinateTransform(p + eps.yx) - coordinateTransform(p - eps.yx));\n  \n  return nor/eps.x;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n \n \n  float z = 0.5;\n    \n  vec3 col = vec3(0.0);\n \n  vec4 dp = dCoordinateTransform(p);\n  float dl = length(dp);\n  p = coordinateTransform(p);\n  p.y += TTIME/200.0;\n \n  float d = df(p/z)*z;\n\n  float pp = 0.3;\n  vec3 li = lightning(p, tanh(pow(max(d, 0.0), pp)), 20.0*pow(1.5*dl, pp));\n  col = 1.0 - li;\n  \n  float f = tanh(0.01*dl);\n  col = pow(col, vec3(1.0 - f))*vec3(1.2, 0.7, 0.5);\n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(0.), f);\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}