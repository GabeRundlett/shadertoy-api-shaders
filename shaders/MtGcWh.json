{
    "Shader": {
        "info": {
            "date": "1535954416",
            "description": "This is an experiment in generating noise that looks like eroded terrain.\n\ncomment \"#define HEIGHTMAP\" to see 3D visualization. \nUncomment \"#define SHADED\" to apply basic lighting and colour to the heightmap",
            "flags": 32,
            "hasliked": 0,
            "id": "MtGcWh",
            "likes": 85,
            "name": "Eroded Terrain Noise",
            "published": 3,
            "tags": [
                "noise",
                "raytrace",
                "derivative",
                "erosion"
            ],
            "usePreview": 0,
            "username": "clayjohn",
            "viewed": 7767
        },
        "renderpass": [
            {
                "code": "/*\n==========================================================================================\n\nThis shader is the result of a long time dreaming of a noise function that looked like \neroded terrain, complete with branching structure, that could be run in a single pass \npixel shader. I wanted to avoid anything simulated because then you cannot easily make\ninfinite terrains. \n\nA word about the method used. I found guil's excellent \"Gavoronoise\" shader awhile back, \nit is has a beautiful wavy look. I noticed that the direction of the waves was a based on\nmouse input. So I combined it with iq's wonderful gradient noise with analytical \nderivatives. First I generate a heightmap with normals using FBM noise, based on the iq's \ngradient noise. Then I use the curl of the derivatives to choose the direction for input \nto guil's gavoronoise. This creates the effect of erosion running down the sides of hills.\nLastly, I compute the analytic derivatives of the erosion noise and add the curl of it to\nthe curl of the hills normals for each iteration, that way each layer of the erosion noise\nchanges direction based on the previous layer, creating a branching effect.\n\nThe noise and normals are generated in Buffer A. Image is just used to display the output.\n\nTo see what the heightmap looks like as a terrain comment out line 31. I have not done\nanything to prettify the output, it is just a heightmap with simply phong shading.\n\nCredit to user guil for \"Gavoronoise\" (https://www.shadertoy.com/view/llsGWl) and to iq \nfor \"Noise - Gradient - 2D - Deriv\" (https://www.shadertoy.com/view/XdXBRH)\n\n==========================================================================================\n*/\n\n\n#define HEIGHTMAP\n//#define SHADED\n\nfloat map(vec2 x) {\n    return texture(iChannel0, x).x;\n}\n\nfloat march(vec3 ro, vec3 rd )\n{\n\tfloat maxd = 1.5;\n    float t = 0.001;\n    for( int i=0; i<1400; i++ )\n    {\n        vec3 p = ro+rd*t;\n\t    float h = map(p.xz);\n        bool b = p.x<0.0||p.x>1.0||p.z>1.0;\n        if (b) t=2.0;\n        \n        if( h>p.y || t>maxd) break;\n        t+=0.001;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nfloat lerp (float a, float b, float c) {\n    //float x = (c - a) / (b - a);\n    //return min(1.0, max(0.0, x));\n    return pow(smoothstep(b-0.01, b, c), 0.25);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0.5, 1.0, -0.1);\n    vec3 rd = normalize(vec3(uv*2.0-1.0-vec2(0.0, 0.7), 1.0));\n    float t = march(ro, rd);\n    vec3 col = vec3(0.6, 0.3, 0.1);\n    if (t<0.0) {\n     col = vec3(0.6, 0.8, 1.0);   \n    } else {\n        vec3 pos = ro+rd*t;\n        vec3 n = texture(iChannel0, pos.xz).xyz*2.0-1.0;\n        vec3 sun = normalize(vec3(0.3, 0.8, 0.2));\n        \n        n = normalize(vec3(n.y, 0.6, n.z));\n        float b = dot(sun, n);\n      \n        col *= vec3(b);\n        \n    }\n    #ifdef HEIGHTMAP\n\tfragColor = texture(iChannel0, uv).xxxw;\n    //uncomment if you want to see the heightmap with normals\n    //fragColor = texture(iChannel0, uv).xyzw;\n    #else\n\tfragColor = vec4(col,1.0);\n    #endif\n    #ifdef SHADED\n    //Color inputs matching https://github.com/dandrino/terrain-erosion-3-ways\n    vec4 colors[5] = vec4[](vec4(0.00, 0.15, 0.3, 0.15),\n    \t\t\t   \t vec4(0.4, 0.3, 0.45, 0.3),\n    \t\t\t     vec4(0.5, 0.5, 0.5, 0.35),\n    \t\t\t     vec4(0.6, 0.4, 0.36, 0.33),\n        \t\t\t vec4(0.7,1.0, 1.0, 1.0));\n    col = texture(iChannel0, uv).xyz;\n    vec3 outcol = colors[0].yzw;\n    outcol = mix(outcol, colors[1].yzw, lerp(colors[0].x, colors[1].x, col.x));\n    outcol = mix(outcol, colors[2].yzw, lerp(colors[1].x, colors[2].x, col.x));\n    outcol = mix(outcol, colors[3].yzw, lerp(colors[2].x, colors[3].x, col.x));\n    outcol = mix(outcol, colors[4].yzw, lerp(colors[3].x, colors[4].x, col.x));\n\n\tfragColor = vec4(outcol*dot(vec3(0.5, 0.9, 0.1), normalize(vec3(col.y*2.0-1.0, 0.6, col.z*2.0-1.0))), 1.0);\n    #endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//Copyright 2020 Clay John\n\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software \n//and associated documentation files (the \"Software\"), to deal in the Software without restriction, \n//including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n//and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do \n//so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included in all copies or \n//substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT \n//NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n//IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \n//WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n//SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n#define PI 3.14159265358979\n\n\nvec2 hash( in vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// from https://www.shadertoy.com/view/XdXBRH\n//name:Noise - Gradient - 2D - Deriv\n//Author: iq\n//License: MIT\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n\n// code adapted from https://www.shadertoy.com/view/llsGWl\n// name: Gavoronoise\n// author: guil\n// license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//Code has been modified to return analytic derivatives and to favour \n//direction quite a bit.\nvec3 erosion(in vec2 p, vec2 dir) {    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;\n    vec3 va = vec3(0.0);\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) {\n\t\tfor (int j=-2; j<=1; j++) {\t\t\n        \tvec2 o = vec2(i, j);\n        \tvec2 h = hash(ip - o)*0.5;\n            vec2 pp = fp +o - h;\n            float d = dot(pp, pp);\n            float w = exp(-d*2.0);\n            wt +=w;\n            float mag = dot(pp,dir);\n            va += vec3(cos(mag*f), -sin(mag*f)*(pp+dir))*w;\n        }\n    }\n    return va/wt;\n}\n\n\n//This is where the magic happens\nvec3 mountain(vec2 p, float s) {\n    //First generate a base heightmap\n    //it can be based on any type of noise\n    //so long as you also generate normals\n    //Im just doing basic FBM based terrain using\n    //iq's analytic derivative gradient noise\n    vec3 n = vec3(0.0);\n    float nf = 1.0;\n    float na = 0.6;\n    for (int i=0;i<2;i++) {\n       n+= noised(p*s*nf)*na*vec3(1.0, nf, nf);\n       na *= 0.5;\n       nf *= 2.0;\n    }\n    \n    //take the curl of the normal to get the gradient facing down the slope\n    vec2 dir = n.zy*vec2(1.0, -1.0);\n    \n    //Now we compute another fbm type noise\n    // erosion is a type of noise with a strong directionality\n    //we pass in the direction based on the slope of the terrain\n    //erosion also returns the slope. we add that to a running total\n    //so that the direction of successive layers are based on the\n    //past layers\n    vec3 h = vec3(0.0);\n    float a = 0.7*(smoothstep(0.3, 0.5,n.x*0.5+0.5)); //smooth the valleys\n    float f = 1.0;\n    for (int i=0;i<5;i++) {\n        h+= erosion(p*f, dir+h.zy*vec2(1.0, -1.0))*a*vec3(1.0, f, f);\n        a*=0.4;\n        f*=2.0;\n    }\n    //remap height to [0,1] and add erosion\n    //looks best when erosion amount is small\n    //not sure about adding the normals together, but it looks okay\n    return vec3(smoothstep(-1.0, 1.0, n.x)+h.x*0.05, (n.yz+h.yz)*0.5+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord/iResolution.xy*4.0;\n    uv.x += iTime;\n\t\n    float s = 0.1;//scaling factor for heightmap\n    \n    vec3 h = mountain(uv*4.0, s);\n    fragColor = vec4(h.xyz,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}