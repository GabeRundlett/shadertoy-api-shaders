{
    "Shader": {
        "info": {
            "date": "1707589643",
            "description": "A useful yet imperfect implementation (it breaks if the endpoints are too close).",
            "flags": 0,
            "hasliked": 0,
            "id": "4Xf3W7",
            "likes": 3,
            "name": "Oriented Uneven Dogbone",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "sdf",
                "dogbone"
            ],
            "usePreview": 0,
            "username": "haplodev",
            "viewed": 163
        },
        "renderpass": [
            {
                "code": "// BSD Zero Clause License (0BSD)\n// Copyright © 2024 haplodev\n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n// Based on\n// \"DogBone 2D SDF\" (Copyright © 2019 Martijn Steinrucken - MIT License) https://www.shadertoy.com/view/wld3D4\n// \"Oriented Box - distance 2D\" (Copyright © 2019 Inigo Quilez - MIT License) https://www.shadertoy.com/view/stcfzn\n// \"Uneven Capsule - distance 2D\" (Copyright © 2018 Inigo Quilez - MIT License) https://www.shadertoy.com/view/4lcBWn\n\nfloat cross_2d(in vec2 v1, in vec2 v2) {\n\treturn v1.x * v2.y - v1.y * v2.x;\n}\n\n// https://stackoverflow.com/a/43384516\nbool within(in vec2 op, in vec2 os, in vec2 oe) {\n\t// Check if op lies between os and oe\n\t\n\t//    s     e\n\t//    |    /\n\t//    | p /\n\t//    |  /\n\t//    | /\n\t//    |/\n\t//    o\n\t\n\tfloat c_se = cross_2d(os, oe);\n\t\n\tif (c_se >= 0.0) {\n\t\treturn (cross_2d(os, op) >= 0.0 && cross_2d(op, oe) >= 0.0);\n\t\n\t} else {\n\t\treturn !(cross_2d(os, op) >= 0.0 || cross_2d(op, oe) >= 0.0);\n\t\n\t}\n}\n\n// https://www.petercollingridge.co.uk/tutorials/computational-geometry/circle-circle-intersections/\nvec2 circle_circle_intersection(in vec2 v1, in float r1, in float r2, in float l, in float sb) {\n\tfloat a = (r1 * r1 - r2 * r2 + l * l) / (2.0 * l);\n\tfloat h = sqrt(r1 * r1 - a * a);\n\treturn v1 + vec2(a, h * sb);\n}\n\nfloat sd_oriented_uneven_dogbone(in vec2 p, in vec2 v1, in vec2 v2, in float r1, in float r2, in float b) {\n\t// p = sample point\n\t// v1 = first endpoint position\n\t// v2 = second endpoint position\n\t// r1 = first endpoint radius\n\t// r2 = second endpoint radius\n\t// b = bulge (> 0 = concave, 0 = straight, < 0 = convex)\n\t\n\tif (abs(b) < 1e-3) b = 1e-3; // prevent division by 0\n\tfloat sb = sign(b);\n\t\n\tfloat l = length(v2 - v1); // distance between endpoints\n\tvec2 d = (v2 - v1) / l; // direction between endpoints\n\t\n\tp = mat2(vec2(d.x, -d.y), vec2(d.y, d.x)) * (p - (v1 + v2) * 0.5); // center and orient\n\tp.y = abs(p.y); // mirror y-axis\n\t\n\tfloat hl = l * 0.5; // half-distance between endpoints\n\t\n\t// update endpoints\n\tv1 = vec2(-hl, 0.0);\n\tv2 = vec2(hl, 0.0);\n\t\n\t// tangent circle radius and position\n\tfloat r3 = (hl * hl - r1 * r2) / ((r1 + r2) * b);\n\tvec2 v3 = circle_circle_intersection(v1, abs(r1 + r3), abs(r2 + r3), l, sb);\n\t\n\t// signed distance circles\n\tfloat d1 = length(p - v1) - r1;\n\tfloat d2 = length(p - v2) - r2;\n\tfloat d3 = r3 * sb - length(p - v3);\n\t\n\t// return the tangent circle if p is contained by v1, v3 and v2,\n\t// otherwise return the endpoints\n\treturn within(p - v3, v1 - v3, v2 - v3) ? d3 * sb : min(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n\tp *= 1.6;\n\tm *= 1.6;\n\t\n\tfloat t = iTime* 0.5;\n\tfloat e = 2.75 + 0.25 * sin(t);\n\t\n\tvec2 v1 = cos(t + vec2(0.0, 1.0));\n\tvec2 v2 = cos(t + vec2(0.0, e) + e);\n\tfloat r1 = 0.3 - 0.1 * sin(1.0 + 2.0 * t);\n\tfloat r2 = 0.3 + 0.1 * sin(1.0 + 2.0 * t);\n\t\n\tfloat b = 0.5; //sin(t);\n\t\n\tfloat d = sd_oriented_uneven_dogbone(p, v1, v2, r1, r2, b);\n\t\n\tvec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n\tcol *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(120.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\t\n\tif (iMouse.z > 0.001) {\n\t\td = sd_oriented_uneven_dogbone(m, v1, v2, r1, r2, b);\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) - abs(d)) - 0.0025));\n\t\tcol = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}