{
    "Shader": {
        "info": {
            "date": "1719082593",
            "description": "Adding up millions of individual bitplanes and looking at any divergence. You can also benchmark performance by letting it run at ~50k iterations per frame and seeing how close you are to 60fps",
            "flags": 0,
            "hasliked": 0,
            "id": "sdtczr",
            "likes": 13,
            "name": "Hash benchmark (and comparison)",
            "published": 3,
            "tags": [
                "hash",
                "benchmark",
                "pcg",
                "wellons"
            ],
            "usePreview": 0,
            "username": "nimitz",
            "viewed": 249
        },
        "renderpass": [
            {
                "code": "// Hash benchmark by nimitz (twitter: @stormoid) 2022\n// https://www.shadertoy.com/view/sdtczr\n\n//The MIT License\n//Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n    Trying to come up with a decent way of testing hash quality (and performance) directly in shadertoy\n    This is is a combination of the visualizaing bitplanes method by Hornet https://www.shadertoy.com/view/lt2yDm\n    and iterating *many* time to find divergence in the sum.\n    \n    This allows to sort out weak hashes from decent ones. But it is still not equivalent to more robust\n    testings methods that look for a wide array of potential flaws.\n    \n    Showing many hashes from \"Hash Functions for GPU Rendering \" https://www.shadertoy.com/view/XlGcRh\n    \n    Feel free to suggest ways to modify this technique to make it more sensitive to flaws!\n    \n    Performance numbers in achieved fps at 50k iteration are shown as a rough guide, milage may vary form gpu to gpu\n*/\n\n/*\n    Top Hashes for quality:\n        wellons, wellons2D, wellonsFast2D, pcg\n        \n    Top hashes for speed:\n        faster, hash_Tong\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uint bit = uint(8.0 * uv.x) + 8u*uint(4.0 * uv.y);\n    float rz = 0.;\n    \n    //const uint num = 1000000u; // 1 Million sample per pixel, better for testing quality\n    const uint num = 50000u; // 50k for performance testing\n    \n    //Swizzling the coordinates can show \"hidden\" artifacts\n    //fragCoord.xy = fragCoord.yx;\n    \n    // Hashes are sorted by perceived quality from this test\n    // Not sure if pcg or wellons2D is higher quality, both are pretty fast and very high quality\n    \n    for(uint  i=0U; i<num; i++)\n    {\n        uvec2 offs = uvec2(1u, i*(6551U)); // Needs to be higher than one screen\n        //uvec2 offs = uvec2(100000u, i*(6551U)); //Alternate X offset\n       \n       // Sorted in order of quality\n       \n       // High quality\n       //uint hash = wellons(uvec2(fragCoord) + offs);  //(15.8 FPS, ran twice for 2d)\n       //uint hash = wellons2D(uvec2(fragCoord) + offs); //Looks pretty much perfect to me (24.5 FPS)\n       //uint hash = wellonsFast2D(uvec2(fragCoord) + offs);  //Can't find artifacts (30 FPS!)\n       //uint hash = pcg(uvec2(fragCoord) + offs); //Maybe some barely noticable artifacts? (23 FPS)\n       //uint hash = XXhash(uvec2(fragCoord) + offs); //(12 FPS, ran twice for 2d)\n       //uint hash = pcgFast(uvec2(fragCoord) + offs); //Maybe slight artifacts? (26 FPS)\n       \n       // Some artifacts\n       //uint hash = murmurHash12(uvec2(fragCoord) + offs); //Seeing artifacts in the 21st bitplane! (24.5 FPS)\n       //uint hash = murmurAlt(uvec2(fragCoord) + offs); //Seeing artifact in the 21st bitplane! (24 FPS)\n       uint hash = faster(uvec2(fragCoord) + offs);  // Artifacts on ~8 bottom bits (34 FPS)\n       //uint hash = iqint3(uvec2(fragCoord) + offs); //Top bits are ok  (31 FPS)\n       \n       // Clearly biased\n       //uint hash = superfast(uvec2(fragCoord) + offs); //Top 6 bits are bad (18 FPS)\n       //uint hash = iqhash(uvec2(fragCoord) + offs); //Some artifacts even with added finalizer (25 FPS)\n       //uint hash = pcg_incorrect(uvec2(fragCoord) + offs).x; //Much lower quality than pcg (25 FPS)\n       //uint hash = hash_Tong(uvec2(fragCoord) + offs);  //Not so bad, considering speed (40 FPS)\n       //uint hash = iqint1(uvec2(fragCoord) + offs); //Top bits are ok (27 FPS, ran twice for 2D)\n       //uint hash = fastest(uvec2(fragCoord) + offs); //Don't use this for quality (54 FPS!)\n       //uint hash = hash11(uvec2(fragCoord) + offs);    //WebGL 2 Hash without sine by Dave_Hoskins ((33 FPS)\n       //uint hash = webgl1(uvec2(fragCoord) + offs); //Slow and very bad (13 FPS)\n       \n       hash = (hash >> bit)&1U;\n       rz += float(hash);\n    }       \n            \n    rz /= float(num);\n    rz = smoothstep(0.498,0.502,rz);\n    fragColor = vec4(vec3(rz), 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//---------------2D (faster than hashing twice) hashes---------------\n\n// Chris Wellons: https://nullprogram.com/blog/2018/07/31/\n// Triple/Slower version Modified for 2D input\nuint wellons2D(uvec2 n)\n{\n    uint x = n.x;\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= n.y;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n//Potentally a bit lower quality, faster\n//Highly recommended, maybe use \"faster\" if speed is a concern\nuint wellonsFast2D(uvec2 p)\n{\n    p *= uvec2(1597334673U, 3812015801U);\n    uint x = (p.x^p.y)*0xed5ad4bbU;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// Based on: Simplest Fastest 2D Hash by James_Harnett (https://www.shadertoy.com/view/MdcfDj)\n// Modified with a pcg step to be higher quality, while still remaining very fast\n// My recommendation for a pretty fast yet good quality hash\nuint faster(uvec2 p)\n{\n\tp *= uvec2(1597334673U, 3812015801U);\n    uint h = (p.x^p.y)*1597334673U;\n    return ((h>>uint((h>>28) + 4u))^h)*277803737u;\n}\n\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 p)\n{\n    p *= uvec2(73333,7777);\n    p ^= (uvec2(3333777777)>>(p>>28));\n    uint n = p.x*p.y;\n    return n^(n>>15);\n}\n\n// My implementation of 2d pcg, many implementations on shadertoy miss the PCG step which is crucial to its quality\n// slightly slower than pcgFast, but a bit higher quality\nuint pcg(uvec2 p)\n{\n    p = 1103515245U*((p.xy >> 1U)^(p.yx)); // Mixing the input\n    uint h = (p.x^p.y)*747796405u;\n    return ((h>>uint((h>>28) + 4u))^h) * 277803737u; // Pcg step: pre-Xor, shift by a value determined by the top bits\n}\n\n// A bit faster faster than pcg, still good quality\nuint pcgFast(uvec2 p)\n{\n    uint h = p.x*747796405u + 2891336453u; // Lcg step\n    h = ((h>>uint((h>>28) + 4u))^h)*2246822519U; // Pcg step: pre-Xor, shift by a value determined by the top bits\n    h += p.y*3266489917U + 1103515245U; // Add second input\n    h = ((h >> uint((h >> 28) + 4u)) ^ h) * 277803737u; \n    return ((h>>uint((h>>28) + 4u))^h)*277803737u;\n}\n\n// Modified for 2D input\n// Really not a bad hash overall with the extra finalizer\nuint iqhash(uvec2 p)\n{\n    p = 1103515245U*((p.xy >> 1U)^(p.yx));\n    uint h32 = 2246822519U*(p.x^(p.y >> 15));\n    return h32^(h32 >> 16);\n}\n\n//From https://www.shadertoy.com/view/XlGcRh\n// Often seen misimplementation of pcg, missing the crucial pcg step\nuvec2 pcg_incorrect(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    return v;\n}\n\n//https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n//another murmur implementation\nuint murmurAlt(uvec2 p) \n{\n    p *= 1540483477u;\n    p = (p^(p>>24u))*1540483477u;\n    uint h = 1540483477u*(668265263U^p.x);\n    h = h^p.y;\n    h = 1540483477u*(h^(h>>13u));\n    return h^(h>>15u);\n}\n\n// Simplest Fastest 2D Hash by James_Harnett (https://www.shadertoy.com/view/MdcfDj)\n// Super fast, great when high quality is not needed\nuint fastest(uvec2 p)\n{\n\tp *= uvec2(1597334673U, 3812015801U);\n\tuint h = (p.x^p.y)*1597334673U;\n\treturn h;\n}\n\nuint hash_Tong(uvec2 q)\n{\n\tq *= uvec2(1597334677U, 3812015801U);\n    uint n = q.x ^ q.y;\n    n = n * (n ^ (n >> 15));\n    return n;\n}\n\n\n// SuperFastHash, adapated from http://www.azillionmonkeys.com/qed/hash.html\nuint superfast(uvec2 data)\n{\n    uint hash = 8u, tmp;\n\n    hash += data.x & 0xffffu;\n    tmp = (((data.x >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    hash += data.y & 0xffffu;\n    tmp = (((data.y >> 16) & 0xffffu) << 11) ^ hash;\n    hash = (hash << 16) ^ tmp;\n    hash += hash >> 11;\n\n    /* Force \"avalanching\" of final 127 bits */\n    hash ^= hash << 3;\n    hash += hash >> 5;\n    hash ^= hash << 4;\n    hash += hash >> 17;\n    hash ^= hash << 25;\n    hash += hash >> 6;\n\n    return hash;\n}\n\n// WebGL1 style hash (slower and poor quality)\nuint webgl1(uvec2 q)\n{\n    vec2 p = vec2(q)/1e6;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return uint(fract((p3.x + p3.y) * p3.z)*1000000000.);\n}\n\n//---------------1D (hashing twice to get 2d)---------------\nuint iqint1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint iqint1(uvec2 x)\n{\n    return iqint1( x.x + iqint1(x.y) );\n}\n\n//Hash without Sine 2 (WebGL 2) https://www.shadertoy.com/view/XdGfRR\nuint hash11(uint q)\n{\n\tuvec2 n = q * uvec2(1597334673U, 3812015801U);\n\tq = (n.x ^ n.y) * 1597334673U;\n\treturn q;\n}\n\nuint hash11(uvec2 x)\n{\n    return hash11( x.x + hash11(x.y) );\n}\n\n// Chris Wellons: https://nullprogram.com/blog/2018/07/31/\n// as seen in: \"Best\" Integer Hash  https://www.shadertoy.com/view/WttXWX\n// and \"Wang, Jenkins & Other Hashes \" https://www.shadertoy.com/view/ttVGDV\n// Very high quaklity and fast!\nuint wellons(uint x)\n{\n#if 1\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n#else\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n#endif\n}\n\nuint wellons(uvec2 x)\n{\n    return wellons( x.x + wellons(x.y) );\n}\n\nuint XXhash(uint buf)\n{\n    const uint seed = 44U;\n    const uint c1 = 2654435761U;\n    const uint c2 = 2246822519U;\n    const uint c3 = 3266489917U;\n    const uint c4 = 668265263U;\n    const uint c5 = 374761393U;\n    uint n = seed + c5;\n    n += buf * c3;\n    n = ((n << 17) | (n >> (32 - 17))) * c4;\n\n    n ^= n >> 15;\n    n *= c2;\n    n ^= n >> 13;\n    n *= c1;\n    n ^= n >> 16;\n\n    return n;\n}\n\nuint XXhash(uvec2 x)\n{\n    return XXhash( x.x + XXhash(x.y) );\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}