{
    "Shader": {
        "info": {
            "date": "1574142408",
            "description": "repeating fire made with repeating fractal noise (made from repeating gradient noise made from repeating white noise)\nhttps://twitter.com/c010011012/status/1200632543961174016",
            "flags": 0,
            "hasliked": 0,
            "id": "3dySDm",
            "likes": 13,
            "name": "Aquafire",
            "published": 3,
            "tags": [
                "fire"
            ],
            "usePreview": 0,
            "username": "cmarangu",
            "viewed": 1130
        },
        "renderpass": [
            {
                "code": "// infinite blu fire\n// need to add text\n\n\n// useful white noise lattice points\n// same for the same values of ix and iy\n\n// yea i basically spammed random stuff\nfloat wnoise (float ix, float iy) {\n    // ix %= 10;\n    // iy %= 5;\n    // return ((600+ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n    \n    ix = mod(ix, 10.);\n    iy = mod(iy, 5.);\n    return mod((600.+ix*iy*12453.+136.*pow(ix+15., mod(iy, 16.) )+\n                sin(iy*1600.)*1376.+ix*656.+iy*75.), 1000.)/1000.;\n    \n}\n\nfloat gnoise (float px, float py) {\n    float mx = fract(px);\n    float my = fract(py);\n    px = floor(px);\n    py = floor(py);\n    // mx = 3.*my*my-2.*mx*mx*mx;\n    return mix(\n        mix(wnoise(px, py), wnoise(px+1., py), mx),\n        mix(wnoise(px, py+1.), wnoise(px+1., py+1.), mx),\n        my\n    );\n}\n\nfloat fnoise (float px, float py) {\n    float s = 0.;\n    float a = .5;\n    float f = 1.;\n    for (int i=0; i<4; ++i) {\n        s += a*gnoise(px*f, py*f);\n        a *= .5;\n        f *= 2.;\n    }\n    return s;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float arg = mod(float(iFrame), 50.)/50.;\n    float px, py, fi=0., r=0., g=0., b=0.;\n    px = (uv.x-.5)*iResolution.x/iResolution.y+.5;\n    py = 1.-uv.y;\n    fi = .1/((fnoise(px*9., py*9.+arg*5.)*( \n        .03+0.*length(vec2(px-.5, py/2.-.5))*.15+\n        0.1/(pow(py, 1.1)+0.1)\n    )))-0.5;\n    // fi = fnoise(px*7, py*7);\n    if (fi <= 0.) {\n        r = 0.;\n        g = 0.;\n        b = 100./255.;\n    }\n    else if (0. < fi && fi < .7) {\n        r = 0.;\n        g = fi/.7;\n        b = 100./255.+155./255.*fi/.7;\n    }\n    else if (true) {\n        r = 1.;\n        g = 1.;\n        b = 1.;\n    }\n    fragColor = vec4(r, g, b, 1.);\n}\n\n\n\n\n\n\n\n\n/*\n// Old code for \"lit texture\"\n// \"Sneaky 2D texture generated using 3D lighting methods\"\nvec3 sund () {\n    return normalize(\n        vec3(\n            cos(iTime),\n            sin(iTime),\n            -1.\n         )\n    );\n}\n\nfloat rand (float x, float y) {\n    x = mod(x, 20.)+3.;\n    y = mod(y, 20.)+3.;\n    // return mod(x*x*256.+y*x*y*30.+256., 1200.)/1200.;\n    return mod(245.+x*y+x*200.+floor(y)*20.*x*x, 1200.)/1200.;\n}\n\nfloat ease (float t) {\n    return 3.*t*t-2.*t*t*t;\n}\n\nfloat lerp (float a, float b, float t) {\n    return a+(b-a)*ease(t);\n}\n\nfloat gnoise (vec2 px) {\n    float mx = mod(px.x+1e3, 1.);\n    float my = mod(px.y+1e3, 1.);\n    px.x = floor(px.x);\n    px.y = floor(px.y);\n    float tr = rand(px.x+1., px.y);\n    float tl = rand(px.x, px.y);\n    float bl = rand(px.x, px.y+1.);\n    float br = rand(px.x+1., px.y+1.);\n    return lerp(\n        lerp(tl, tr, mx),\n        lerp(bl, br, mx),\n        my\n    );\n}\n\nfloat fnoise (vec2 px) {\n    //return (\n    //    gnoise(px/4.)*1.+\n    //    gnoise(px/6.)*1.+\n    //    gnoise(px/10.)*2.+\n    //    gnoise(px/20.)*2.\n    //)/6.;\n    // learned this here\n    // https://thebookofshaders.com/13/\n    float sum = 0.;\n    float amp = .5;\n    float freq = .07;\n    for (int i=0; i<4; ++i) {\n        sum += gnoise(px*freq)*amp;\n        amp *= .5;\n        freq *= 2.;\n    }\n    return sum;\n}\n\nfloat SDF (vec2 px) {\n    // return sqrt(px.x*px.x+px.y*px.y);\n    return lerp(fnoise(vec2(px.x*.4, px.y*.5)*60.*4.*3.), fnoise(px*60.*2.), .5+.5*sin(iTime) );\n}\n\nvec3 dSDF (vec2 px) {\n    // so btw 2D so change in z does not affect shape...\n    float inf = 1e-3;\n    float SDFp = SDF(px);\n    return normalize(\n        vec3(\n            SDF(vec2(px.x+inf, px.y))-SDFp,\n            SDF(vec2(px.x, px.y+inf))-SDFp,\n            inf\n        )\n    );\n}\n\nvec3 TEX (vec2 px, vec3 d) {\n    float SDFp = SDF(px);\n    vec3 dSDFp = dSDF(px);\n    vec3 TEXp = vec3(0., 0., 0.);\n    // TEXp += mod(floor(px.x*7.)+floor(px.y*7.), 2.)*.5;\n    // diffuse\n    TEXp += .8*(dot(dSDFp, sund())*.5+.5);\n    TEXp += .2*clamp(dot(dSDFp, sund()), 0., 1.);\n    TEXp = vec3(0., 1., .9)*TEXp;\n    // speculsr\n    TEXp += .5*pow(clamp(-dot(reflect(d, dSDFp), sund()), 0., 1.), 12.);\n    TEXp = clamp(TEXp, 0., 1.);\n    \n    return TEXp;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    vec3 retina = TEX(screen, normalize(vec3(screen.x, screen.y, .25)) );\n    // retina = vec3(fnoise(screen*60.*4.));\n    fragColor = vec4(retina, 1.);\n}\n*/\n\n\n\n\n\n\n\n/*\n// Old code: Original code to generate this shader on\n// https://www.khanacademy.org/computer-programming/new/pjs\n// infinite blu fire\n// need to add text\n// useful white noise lattice points\n// same for the same values of ix and iy\nvar wnoise = function(ix, iy) {\n    // ix %= 10;\n    iy %= 5;\n    return ((600+ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n};\nvar gnoise = function(px, py) {\n    var mx = px%1;\n    var my = py%1;\n    px = floor(px);\n    py = floor(py);\n    // mx = 3*my*my-2*mx*mx*mx;\n    return lerp(\n        lerp(wnoise(px, py), wnoise(px+1, py), mx),\n        lerp(wnoise(px, py+1), wnoise(px+1, py+1), mx),\n        my\n    );\n};\nvar fnoise = function(px, py) {\n    var s = 0;\n    var a = 0.5;\n    var f = 1;\n    for (var i=0; i<4; ++i) {\n        s += a*gnoise(px*f, py*f);\n        a *= 0.5;\n        f *= 2;\n    }\n    return s;\n    // return noise(px, py);\n};\nvar imgs = [];\nvar FRAMES = 50;\nvar C = 0;\nvar index = 0;\nvar draw = function() {\n    if (C < FRAMES) {\n        var arg = (C%FRAMES)/FRAMES;\n        if (!this.loadPixels) {\n            return;\n        }\n        this.loadPixels();\n        var pix = this.imageData.data;\n        var px, py, fi=0, r=0, g=0, b=0;\n        for (var jndex=0; jndex<1000; ++jndex) {\n            px = (index%width)/width;\n            py = floor(index/width)/height;\n            fi = 0.1/((fnoise(px*9, py*9+arg*5)*( \n                dist(px, py/2, 0.5, 1/2)*0.15+\n                0.1/(pow(py, 1.1)+0.1)\n            )))-0.5;\n            // fi = fnoise(px*7, py*7);\n            if (fi <= 0) {\n                r = 0;\n                g = 0;\n                b = 100;\n            }\n            else if (0 < fi && fi < 0.7) {\n                r = 0;\n                g = 255*fi/0.7;\n                b = 100+100*fi/0.7;\n            }\n            else if (fi) {\n                r = 255;\n                g = 255;\n                b = 255;\n            }\n            pix[index*4] = r;\n            pix[index*4+1] = g;\n            pix[index*4+2] = b;\n            ++index;\n            if (index >= width*height) {\n                break;\n            }\n        }\n        this.updatePixels();\n        if (index >= width*height) {\n            index = 0;\n            imgs[C] = get(0, 0, width, height);\n            C++;\n\t    println(floor(C/FRAMES*100)+\"%\");\n        }\n    }\n    else {\n        image(imgs[C%FRAMES], 0, 0);\n        C++;\n    }\n};\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}