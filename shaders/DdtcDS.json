{
    "Shader": {
        "info": {
            "date": "1695417346",
            "description": "200x100x100 Fluid simulation... ",
            "flags": 0,
            "hasliked": 0,
            "id": "DdtcDS",
            "likes": 40,
            "name": "Wind Tunnel Simulation",
            "published": 3,
            "tags": [
                "fluid"
            ],
            "usePreview": 1,
            "username": "wyatt",
            "viewed": 414
        },
        "renderpass": [
            {
                "code": "vec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\n\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\n\nvec3 normal (vec3 p) {\n    vec2 e = vec2(1e-4,0);\n    return normalize(vec3(\n        map(p+e.xyy,iTime)-map(p-e.xyy,iTime),\n        map(p+e.yxy,iTime)-map(p-e.yxy,iTime),\n        map(p+e.yyx,iTime)-map(p-e.yyx,iTime)\n    ));\n}\nMain {\n     if(iFrame%2>0) discard;\n    vec3 p = vec3(0,-.2,-2.);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1.5));\n    float t = .2+.2*sin(.178*iTime);\n    if (iMouse.z>0.) {\n        t = 3.*iMouse.y/R.y-1.;\n        p.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        d.yz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n        t = 3.*iMouse.x/R.x-1.;\n    }\n    p.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    d.xz *= mat2(cos(t),sin(t),-sin(t),cos(t));\n    float m = 0.;\n    float xy = iPlane(p,d,vec3(0,0,1));\n    vec3 p_xy = p + d*xy;\n    float xz = iPlane(p-vec3(0,-.7,0),d,vec3(0,1,0));\n    vec3 p_xz = p + d*xz;\n    for (float i = 0.; i < 100.; i++) {\n        m += map(p+m*d,iTime);\n    }\n    if (m < 100.) {\n        vec3 no = normal(p+m*d);\n        Q = vec4(.5)-.5*dot(no,.5*vec3(1,-1,1));\n        Q *= sin(-2.+7.*length(T(((p+(m-.05)*d+no*.01)*.5+.5)*R3-.1,0).xyzw-vec4(vel,0,0,0))+vec4(1,2,3,4));\n    } else Q = vec4(0);\n    {\n        vec4 txz =  T((p_xz*.5+.5)*R3-.5,2);\n        vec4 txy = T((p_xy*.5+.5)*R3-.5,2);\n        vec4 txz_v =  T((p_xz*.5+.5)*R3-.5,0);\n        vec4 txy_v = T((p_xy*.5+.5)*R3-.5,0);\n        txz += abs(txz_v-vec4(vel,0,0,0));\n        txy += abs(txy_v-vec4(vel,0,0,0));\n        if (xz>0.&&p_xz.y>-1.&&p_xz.y<1.&&p_xz.x>-1.&&p_xz.x<2.&&p_xz.z>-1.&&p_xz.z<1.) \n            Q = mix(Q,txz,.25+.25*sign(m-xz));\n       if (xy>0.&&p_xy.y>-1.&&p_xy.y<1.&&p_xy.x>-1.&&p_xy.x<2.&&p_xy.z>-1.&&p_xy.z<1.) \n            Q = mix(Q, txy,.25+.25*sign(m-xy));\n    }\n    //Q = abs(texture(iChannel0,d));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U) \n\n\n    #define vel .2\n\n#define R3 vec3(100,100,100)\n#define R2 vec2(1000,1000)\nvec2 _3D (vec3 u) {\n    u = clamp(u,vec3(0),R3-1.);\n    u = floor(u);\n    return .5+u.xy+R3.xy*vec2(mod(u.z,R2.x/R3.x),floor(u.z*R3.x/R2.x));\n}\nvec3 _3D (vec2 u) {\n    u = floor(u);\n    return .5+vec3(mod(u,R3.xy),floor(u.x/R3.x)+R2.x/R3.x*floor(u.y/R3.y));\n}\n\n\n\n\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\nfloat cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n        \n        \n        \n        \n        \nfloat wheels (vec3 p, float s) {\n    vec3 q = p;\n    p = abs(p)-vec3(.3,0,.3);\n    s *= 2.*sign(-q.z);\n    \n    if (q.x<0.) p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    return max(cylinder(p,.1,.1),-cylinder(p-vec3(0,.0,0),.07,.15));\n}\nfloat map (vec3 p, float time) {\n    float d = 1e9;\n    float s = .1*sin(.2*time);\n    p.z += s;\n    p.y += 1.;\n    p *= .8;\n    p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    float w = wheels(p-vec3(0,.2,0),.2*cos(.2*time));\n    d = min(d,roundBox(p-vec3(0,.3,0),vec3(1.,.2,.6),.02));\n    d = min(d,triPrism(p,vec2(-.3,.4),vec2(-.1,.4),vec2(-.1,.6),.45));\n    d = min(d,roundBox(p-vec3(.02,.5,0),vec3(.25,.2,.45),.02));\n    d = max(d,min(w-.06,-roundBox(p-vec3(.3,.4,0),vec3(.3,.14,.45),.02)));\n    d = min(max(d,-w+.05),w);\n    p.z = abs(p.z);\n    d = min(d,roundBox(p.zyx-vec3(.3,.44,-.25),vec3(.1,.05,.01),.01));\n    return d/.8-.014;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "int face (vec3 dir){\n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        return 0;\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        return 1;\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        return 2;\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        return 3;\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        return 4;\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        return 5;\n    } else return -1;\n}\nvec4 H (vec2 U, int i) {\n    ivec3 p = ivec3(U,i);\n    vec2 x = vec2(p-512) + 0.5;\n    vec3 d;\n           if (p.z==0){     d = vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     d = vec3( x.x, 512, x.y);\n    } else if (p.z==2){     d = vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     d = vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     d = vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     d = vec3(-x.x,-x.y,-512);\n    } else d = vec3(0);\n    return texture(iChannel0,d);\n}\nvec4 G (vec3 V, int i) {\n    if (V.x>R3.x) V.x-= R3.x, i+=1;\n    return H(_3D(V),i); \n}\nvec4 T (vec3 u, int i) {\n    u -= .5;\n    vec3 f = floor(u);\n    vec3 c = ceil(u);\n    vec4 _000 = G(f,i);\n    vec4 _001 = G(vec3(f.xy,c.z),i);\n    vec4 _010 = G(vec3(f.x,c.y,f.z),i);\n    vec4 _011 = G(vec3(f.x,c.yz),i);\n    vec4 _100 = G(vec3(c.x,f.yz),i);\n    vec4 _101 = G(vec3(c.x,f.y,c.z),i);\n    vec4 _110 = G(vec3(c.xy,f.z),i);\n    vec4 _111 = G(c,i);\n    vec4 _00 = mix(_000,_001,fract(u.z));\n    vec4 _01 = mix(_010,_011,fract(u.z));\n    vec4 _10 = mix(_100,_101,fract(u.z));\n    vec4 _11 = mix(_110,_111,fract(u.z));\n    vec4 _0 = mix(_00,_01,fract(u.y));\n    vec4 _1 = mix(_10,_11,fract(u.y));\n    return mix(_0,_1,fract(u.x));\n}\nvec4 F (vec3 u, int i) {\n    if (iFrame%4==0) {\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        return T(u,i);\n    } else {\n        return G(u,i);\n    }\n}\nvoid mainCubemap( out vec4 Q, in vec2 U, in vec3 _, in vec3 d )\n{\n    int f = face(d);\n    if (f < 2) {\n        vec3 V = _3D(U)+R3.x*vec3(f,0,0);\n        Q = F(V,0);\n        float k = 1./6.;\n        vec4\n            x_ = F(V+vec3(-1,0,0),0),\n            _x = F(V+vec3(+1,0,0),0),\n            y_ = F(V+vec3(0,-1,0),0),\n            _y = F(V+vec3(0,+1,0),0),\n            z_ = F(V+vec3(0,0,-1),0),\n            _z = F(V+vec3(0,0,+1),0);\n        if (iFrame%2==0)\n            Q.w -= .1*(Q.w-k*(_x.w+x_.w+_y.w-y_.w+_z.w-z_.w))+.5*(_x.x-x_.x+_y.y-y_.y+_z.z-z_.z) ;\n        else \n            Q.xyz -= .5*vec3(_x.w-x_.w,_y.w-y_.w,_z.w-z_.w);\n\n        Q.xyz *= smoothstep(-.01/R3.x,0.,map( (V+.5)/R3*2.-1. ,iTime));\n\n        if (V.y < 1.  || R3.y - V.y < 1. ) Q .y =0.;\n        if (V.z < 1.|| R3.z - V.z < 1.) Q.z = 0.;\n\n\n        if (V.x < 1.) Q.x = vel;\n        if (R.x - V.x < 1.) Q.x = vel;\n\n\n        if (iFrame < 1) {\n\n            Q = vec4(vel,0,0,0);\n\n        }\n     } else {\n         vec3 V = _3D(U)+R3.x*vec3(f-2,0,0);\n         if (map( (V+.5)/R3*2.-1. ,iTime) < 0.) Q = vec4(1.5,.9,.2,1);\n         else if (V.x < 1.) Q = 2.*vec4(.5+.5*sign(cos(.4*V.y)*cos(.4*V.z)-.5));\n         else if (iFrame < 1) Q = vec4(0);\n         else if (iFrame % 8 == 0) {\n         vec3 u = V;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n        u -= .5*G(u,0).xyz;\n        u -= .5*T(u,0).xyz;\n            Q = T(u,2);\n         } else {\n             Q = G(V,2);\n         }\n     }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}