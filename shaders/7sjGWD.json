{
    "Shader": {
        "info": {
            "date": "1617489626",
            "description": "Demonstration of Gradient Interval Arithmetic https://www.shadertoy.com/view/WsKyDW - sphere tracing left, segment tracing right",
            "flags": 0,
            "hasliked": 0,
            "id": "7sjGWD",
            "likes": 10,
            "name": "GIA demo",
            "published": 3,
            "tags": [
                "raymarching",
                "antialiasing",
                "silhouette",
                "conservative",
                "refinement"
            ],
            "usePreview": 0,
            "username": "paniq",
            "viewed": 754
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////\n\n// GIA scalar for rays (1D)\nstruct gia1 {\n    float f0; // sample of f(0)\n    vec2 f1; // interval of f(1) / f'(0)\n};\n    \nstruct gia1x2 {\n    gia1 x;\n    gia1 y;\n};\n\nstruct gia1x3 {\n    gia1 x;\n    gia1 y;\n    gia1 z;\n};\n\n//////////////////////////////////////////////////////////\n\ngia1 gia_const(float x) {\n    return gia1(x, vec2(x));\n}\n\ngia1x3 gia_const(vec3 v) {\n    return gia1x3(gia_const(v.x), gia_const(v.y), gia_const(v.z));\n}\n\ngia1 gia_neg(gia1 x) {\n    return gia1(-x.f0, -x.f1.yx);\n}\n\nvec2 ia_sort(vec2 ia) {\n    return (ia.x > ia.y)?ia.yx:ia;\n}\n\nvec2 ia_merge(vec2 a, vec2 b) {\n    return vec2(min(a.x, b.x), max(a.y, b.y));\n}\n\ngia1 gia_add(gia1 a, gia1 b) {\n    return gia1(a.f0 + b.f0, a.f1 + b.f1);\n}\n\ngia1 gia_add(gia1 a, float b) {\n    return gia1(a.f0 + b, a.f1 + b);\n}\n\ngia1x3 gia_add(gia1x3 a, vec3 b) {\n    return gia1x3(gia_add(a.x, b.x), gia_add(a.y, b.y), gia_add(a.z, b.z));\n}\n\ngia1 gia_sub(gia1 a, gia1 b) {\n    return gia1(a.f0 - b.f0, a.f1 - b.f1.yx);\n}\n\ngia1 gia_sub(float a, gia1 b) {\n    return gia1(a - b.f0, a - b.f1.yx);\n}\n\ngia1 gia_sub(gia1 a, float b) {\n    return gia1(a.f0 - b, a.f1 - b);\n}\n\ngia1x2 gia_sub(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_sub(a.x,b.x),gia_sub(a.y,b.y));\n}\n\ngia1x3 gia_sub(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1x3 gia_sub(gia1x3 a, vec3 b) {\n    return gia1x3(gia_sub(a.x,b.x),gia_sub(a.y,b.y),gia_sub(a.z,b.z));\n}\n\ngia1 gia_max(gia1 a, gia1 b) {\n    vec2 f0_f1min = ((a.f0 > b.f0)?vec2(a.f0, a.f1.x):vec2(b.f0, b.f1.x));\n    return gia1(f0_f1min[0], vec2((a.f0 == b.f0)?max(a.f1.x,b.f1.x):f0_f1min[1], max(a.f1.y, b.f1.y)));\n}\n\ngia1 gia_max(gia1 a, float b) {\n    vec2 f0_f1min = ((a.f0 > b)?vec2(a.f0, a.f1.x):vec2(b));\n    return gia1(f0_f1min[0], vec2((a.f0 == b)?max(a.f1.x,b):f0_f1min[1], max(a.f1.y, b)));\n}\n\ngia1x2 gia_max(gia1x2 a, gia1x2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x2 gia_max(gia1x2 a, vec2 b) {\n    return gia1x2(gia_max(a.x,b.x),gia_max(a.y,b.y));\n}\n\ngia1x3 gia_max(gia1x3 a, gia1x3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1x3 gia_max(gia1x3 a, vec3 b) {\n    return gia1x3(gia_max(a.x,b.x),gia_max(a.y,b.y),gia_max(a.z,b.z));\n}\n\ngia1 gia_min(gia1 a, gia1 b) {\n    return gia_neg(gia_max(gia_neg(a), gia_neg(b)));\n}\n\ngia1 gia_min(gia1 a, float b) {\n    return gia_neg(gia_max(gia_neg(a), -b));\n}\n\ngia1 gia_clamp(gia1 x, float mn, float mx) {\n    return gia_min(gia_max(x, mn), mx);\n}\n\ngia1 gia_abs(gia1 a) {\n    float f1min = (a.f0 > 0.0)?a.f1.x:-a.f1.y;\n    return gia1(abs(a.f0), vec2((a.f0 == 0.0)?max(a.f1.x,-a.f1.y):f1min, max(a.f1.y, -a.f1.x)));\n}\n\ngia1x3 gia_abs(gia1x3 a) {\n    return gia1x3(gia_abs(a.x),gia_abs(a.y),gia_abs(a.z));\n}\n\ngia1 gia_sign(gia1 a) {\n    // approximate hack. needs a clear head.\n    float s0 = sign(a.f0);\n    vec2 s1 = sign(a.f1);\n    if ((s0 == s1.x) && (s1.x == s1.y))\n        return gia1(s0, s1);\n    vec2 b = (s0 * a.f1 - abs(a.f1 - a.f0)) / a.f0;\n    b = (b.x < b.y)?b:b.yx;\n    return gia1(s0, ia_merge(b, vec2(min(s0,s1.x),max(s0,s1.y))));\n}\n\nvec2 minmax(vec3 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),f[2]),\n            max(max(f[0],f[1]),f[2])); \n}\n\nvec2 minmax(vec4 f) {\n\treturn \n        vec2(min(min(f[0],f[1]),min(f[2],f[3])),\n            max(max(f[0],f[1]),max(f[2],f[3]))); \n}\n\ngia1 gia_mul(gia1 a, gia1 b) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxyy * b.f1.xyxy);\n    // bound f'(0)\n    vec2 ff0 = minmax((b.f0*(a.f1 - a.f0)).xxyy + (a.f0*(b.f1 - b.f0)).xyxy);    \n\tfloat f0 = a.f0 * b.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\ngia1 gia_mul(gia1 a, float b) {    \n    vec2 q = a.f1.xy * b;\n    return gia1(a.f0 * b, (b < 0.0)?q.yx:q);\n}\n\ngia1x2 gia_mul(gia1 a, vec2 b) {\n    return gia1x2(gia_mul(a, b.x), gia_mul(a, b.y));\n}\n\ngia1x3 gia_mul(gia1 a, vec3 b) {\n    return gia1x3(gia_mul(a, b.x), gia_mul(a, b.y), gia_mul(a, b.z));\n}\n\ngia1 gia_pow2(gia1 a) {\n    // bound f(1)\n    vec2 f1 = minmax(a.f1.xxy * a.f1.xyy);\n    // bound f'(0)\n    vec2 ff0a = a.f0*(a.f1 - a.f0);\n    vec2 ff0 = minmax(ff0a.xxy + ff0a.xyy);\n\tfloat f0 = a.f0 * a.f0;\n    return gia1(f0, ia_merge(f0 + ff0, f1));\n}\n\nfloat safeinv(float x) {\n    return (x == 0.0)?0.0:1.0/x;\n}\n\ngia1 gia_sqrt(gia1 a) {\n    float d = sqrt(a.f0);\n    vec2 ia_f = sqrt(max(vec2(0.0),a.f1));\n    vec2 ia_g = 0.5 * (a.f1 - a.f0) * safeinv(d);    \n    return gia1(d, ia_merge(ia_g + max(0.0, d), ia_f));\n}\n\ngia1 gia_dot(gia1x2 a) {\n    return gia_add(gia_pow2(a.x),gia_pow2(a.y));\n}\n\ngia1 gia_dot(gia1x3 a) {\n    return gia_add(gia_add(gia_pow2(a.x),gia_pow2(a.y)),gia_pow2(a.z));\n}\n\ngia1 gia_dot(gia1x2 a, vec2 b) {\n    return gia_add(gia_mul(a.x, b.x),gia_mul(a.y, b.y));\n}\n\ngia1 gia_length(gia1x2 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_length(gia1x3 v) {\n    return gia_sqrt(gia_dot(v));\n}\n\ngia1 gia_mix (gia1 a, gia1 b, gia1 x) {\n    return gia_add(a, gia_mul(gia_sub(b,a),x));\n}\n\ngia1 gia_smin( gia1 a, gia1 b, float k ) {\n    gia1 h = gia_clamp(gia_add(gia_mul(gia_sub(b, a),0.5 / k),0.5), 0.0, 1.0 );\n    return gia_sub(gia_mix( b, a, h ), gia_mul(gia_mul(h, gia_add(gia_neg(h), 1.0)), k));\n}\n\n#define MAX_STEPS 50\n\n// undef to disable hole, then parameter s.w not needed\n// #define CONVEX\n\n// sdUberprim with precomputed constants\ngia1 sdUnterprim(gia1x3 p, vec4 s, vec3 r, vec2 ba, float sz2) {\n    gia1x3 d = gia_sub(gia_abs(p), s.xyz);\n    gia1 q = gia_sub(gia_add(gia_length(gia_max(gia1x2(d.x,d.y), vec2(0.0))), gia_min(gia_max(d.x,d.y),0.0)), r.x);\n    // hole support: without this line, all results are convex\n#ifndef CONVEX    \n    q = gia_sub(gia_abs(q), s.w);\n#endif\n    \n    gia1x2 pa = gia1x2(q, gia_sub(p.z, s.z));\n    gia1x2 diag = gia_sub(pa, gia_mul(gia_clamp(gia_dot(pa,ba), 0.0, 1.0), vec2(r.z,sz2)));\n    gia1x2 h0 = gia1x2(gia_max(gia_sub(q, r.z),0.0),gia_add(p.z, s.z));\n    gia1x2 h1 = gia1x2(gia_max(q,0.0),gia_sub(p.z, s.z));\n    \n    return gia_sub(gia_mul(gia_sqrt(gia_min(gia_dot(diag),gia_min(gia_dot(h0),gia_dot(h1)))),\n        gia_sign(gia_max(gia_dot(pa,vec2(-ba.y, ba.x)), d.z))), r.y);\n}\n\n// s: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\ngia1 sdUberprim(gia1x3 p, vec4 s, vec3 r) {\n    // these operations can be precomputed\n    s.xy -= r.x;\n#ifdef CONVEX  \n    r.x -= r.y;\n#else\n    r.x -= s.w;\n    s.w -= r.y;\n#endif\n    s.z -= r.y;\n    vec2 ba = vec2(r.z, -2.0*s.z);\n    return sdUnterprim(p, s, r, ba/dot(ba,ba), ba.y);\n}\n\n// example parameters\n#define SHAPE_COUNT 9.0\nvoid getfactor (int i, out vec4 s, out vec3 r) {\n    //i = 4;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec3(0.0);\n    } else if (i == 1) { // cylinder\n        s = vec4(1.0);\n        r = vec3(1.0,0.0,0.0);\n    } else if (i == 2) { // cone\n        s = vec4(0.0,0.0,1.0,1.0);\n        r = vec3(0.0,0.0,1.0);\n\t} else if (i == 3) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 4) { // sphere\n        s = vec4(1.0);\n        r = vec3(1.0,1.0,0.0);\n    } else if (i == 5) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 6) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec3(1.0,0.25,0.0);\n    } else if (i == 7) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(1.0,0.1,0.0);\n    } else if (i == 8) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec3(0.1,0.1,0.0);\n\t}\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.1) * 0.7;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\ngia1 doobject (gia1x3 p, float k) {\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    \n    vec4 sa,sb;\n    vec3 ra,rb;\n    getfactor(s1,sa,ra);\n    getfactor(s2,sb,rb);\n    \n    return sdUberprim(gia1x3(p.z,p.y,p.x), mix(sa,sb,u), mix(ra,rb,u));\n}\n\ngia1 doModel( gia1x3 p ) {\n    float k = iTime*0.5;\n    gia1 d = doobject(gia_sub(p, vec3(0.0,0.0,-0.5)), k);\n    gia1 d2 = doobject(gia_sub(p, vec3(0.0,0.0,0.5)), k + 1.0);\n    \n    return gia_smin(d, d2, 0.4);\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    float t = 0.0;\n\tfloat res = -1.0;\n    steps = 0;\n    float tc = (bias > 0.0)?0.0:1.0;\n    for( int i=0; i<MAX_STEPS; i++ ) {\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;        \n\t    float h = doModel( gia_const(ro+rd*t) ).f0;\n        t = (t + h)*A;\n    \tif((h <= limit) || (t > maxd)) {\n            break;\n        }\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nfloat calcIntersectionGIA( in vec3 ro, in vec3 rd, vec2 pixel, float bias, out int steps )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tfloat aperture = max(pixel.y,pixel.x) / sqrt(2.0);        // aperture of cone\n    float C = sqrt(aperture*aperture + 1.0);\n    // radius of sphere at t=1\n    float R = aperture/C;\n    // constant adjustment factor for t so that the cone sphere touches the distance radius\n    float A = C / (C + bias*aperture);\n    // for a better demo of how the above factors work, see https://www.shadertoy.com/view/4lfBWH\n    \n    const float E = 2.718282;\n    \n    float t = 0.0;\n    float td = 1.0 / (E*E);\n\tfloat res = -1.0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        //float x = float(i)/float(N);\n        steps = i;\n\t\tfloat limit = bias*R*t;\n        // add small bias to reduce iteration count\n        limit += 1e-03*t;                \n        gia1 g = doModel(gia_add(gia_mul(gia1(t, vec2(t + td)),rd),ro));\n    \tif((g.f0 <= limit) || (t > maxd)) {\n            break;\n        }\n        float stepsz = max(td / (g.f0 + max(0.0, -g.f1.x)), 1.0);\n        t += stepsz * g.f0;\n    }\n    \n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( gia_const(pos + v1*eps) ).f0 + \n\t\t\t\t\t  v2*doModel( gia_const(pos + v2*eps) ).f0 + \n\t\t\t\t\t  v3*doModel( gia_const(pos + v3*eps) ).f0 + \n\t\t\t\t\t  v4*doModel( gia_const(pos + v4*eps) ).f0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nbool dorender( out float dist, out int steps, out vec3 position, in vec2 fragCoord, in vec2 resolution, in float bias)\n{\n    vec2 p = (-resolution.xy + 2.0*fragCoord.xy)/resolution.y;\n    vec2 m = (-resolution.xy + 2.0*iMouse.xy)/resolution.y;\n\n    //-----------------------------------------------------\n    // camera1\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, 0.0 );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n    float w = (iMouse.z > 0.5)?m.x:0.0;\n\n\t// raymarch\n    float t;\n    if (p.x < w) {\n        t = calcIntersection( ro, rd, 1.0 / resolution, bias, steps );\n    } else {\n        t = calcIntersectionGIA( ro, rd, 1.0 / resolution, bias, steps );\n    }    \n    dist = t;\n    if( t>-0.5 )\n    {\n        // geometry\n        position = ro + t*rd;\n        return true;\n\t}\n    return false;\n}\n\nvec3 hue2rgb (float hue) {\n    return clamp(abs(mod(hue * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0,0.0,1.0);\n}\n\n// maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue (float n)  {\n    return hue2rgb((1.0 - clamp(n,0.0,1.0)) * 0.66667);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    float dist;\n    float dist_inner;\n    float dist_outer;    \n    \n    vec2 resolution = iResolution.xy;\n    vec3 pos;\n    int steps;\n    bool hit = dorender(dist, steps, pos, fragCoord, resolution, 1.0);\n\n    fragColor = vec4(vec3(0.0),1.0);\n#if 0\n    if (hit) {\n        vec3 nor = calcNormal(pos);\n        fragColor = vec4((nor*0.5+0.5)*0.5,1.0);\n    }   \n#else\n    vec3 c2 = normhue(float(steps)/float(MAX_STEPS));\n    ivec3 p = ivec3(pos*10.0);\n    c2 = mix(c2, vec3(float((p.x ^ p.y ^ p.z) % 3)/2.0), 0.1);\n    \n    fragColor = vec4(c2,1.0);\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 25,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}