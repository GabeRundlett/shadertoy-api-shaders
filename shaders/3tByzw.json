{
    "Shader": {
        "info": {
            "date": "1593908657",
            "description": "Trying out some transformation matrices + using SDFs to fake lighting and shadow/AO. \nThe marble has a specular and bottom reflection made with offset'd SDFs as well. \nGot here experimenting with fake 3D. There are probably better ways to do this.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tByzw",
            "likes": 15,
            "name": "Bouncing Marble",
            "published": 3,
            "tags": [
                "3d",
                "checkerboard",
                "ball",
                "bounce",
                "marble",
                "flyby"
            ],
            "usePreview": 0,
            "username": "koo1ant",
            "viewed": 828
        },
        "renderpass": [
            {
                "code": "#define t iTime\n#define resolution iResolution\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\n// Fake a bouncing ball in screen-space UV\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.8; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 + ((t * 12.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 + spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv) {\n    // Sine checkers\n    p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y);\n    p *= 1.-smoothstep(0.0, 10., length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = t; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    ground(p, pv);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += 0.1;\n    color.b += 0.05;\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}