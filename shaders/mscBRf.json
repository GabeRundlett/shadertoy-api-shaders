{
    "Shader": {
        "info": {
            "date": "1697458800",
            "description": "Mouseable balls in transparent box with obstacles",
            "flags": 32,
            "hasliked": 0,
            "id": "mscBRf",
            "likes": 29,
            "name": "Balls In Motion 2",
            "published": 3,
            "tags": [
                "dynamics",
                "collisions"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Hopefully the behavior looks natural (the physical model is used for\n  studying granular flow, so minimal strange artifacts).\n  Mouse does various things...\n\n  No. 39 in \"Ball Dynamics\" series\n    \"Balls Falling\"             (NsKGR3) - others listed here\n    \"Rock the Balls\"            (7ltXWX)\n\n  No.94 in \"Physical Dynamics\" series\n    \"Grid-Surfing Balls\"        (mlVGWy) - others listed here\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec3 OrAng (vec3 p);\nvec3 OrAngT (vec3 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nmat3 QtToRMat (vec4 q);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec4 Loadv4 (int idVar);\n\nvec3 ltPos, vnBall, hbSize, blkAng, vnBlk;\nfloat dstFar, hbMarg, baseRad, baseUp;\nint nFrame, nBall, idObj, idBall, txOff;\nconst int idFrm = 1, idFrmEx = 2, idAx = 3, idObs = 4, idBas = 5, idFlr = 6;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d, tr, f, b;\n  dMin = dstFar;\n  p.y -= baseUp;\n  q = abs (OrAng (p));\n  sLen = vec4 (hbSize - hbMarg - 0.1, 0.);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww + 0.05, 0.1),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw + 0.05, 0.1)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz + 0.05, 0.1));\n  DMIN (idFrm);\n  b = length (hbSize.xy - hbMarg);\n  f = 0.5 * (baseUp - 0.05);\n  tr = 0.25;\n  sLen.xyz = vec3 (b + 6. * tr, f - tr, hbSize.z - hbMarg + 2. * tr);\n  d = PrCylDf (vec3 (q.xy, abs (q.z) - sLen.z + tr), 0.8 * tr, tr);\n  DMIN (idAx);\n  if (abs (q.x) < abs (q.y)) q.xy = q.yx;\n  d = PrRoundBoxDf (vec3 (abs (q.x) - (hbSize.x - hbMarg - 1.9), q.yz),\n     vec3 (2. - hbMarg, 0.1, hbSize.z - hbMarg - 0.3), 0.1);\n  DMIN (idObs);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  q.yz = Rot2D (q.yz, blkAng.x);\n  d = min (PrRoundBoxDf (vec3 (q.xy, abs (q.z) - sLen.z),\n     vec3 (b + 4. * tr, tr, tr) - 0.1, 0.1),\n     PrRoundBoxDf (vec3 (abs (q.x) - b - 3. * tr, q.yz),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  DMIN (idFrmEx);\n  d = PrCylDf (vec3 (abs (q.x) - b - 4.5 * tr, q.yz).yzx, 0.8 * tr, tr);\n  DMIN (idAx);\n  q = p;\n  q.xz = Rot2D (q.xz, blkAng.y);\n  d = PrRoundBoxDf (vec3 (abs (q.xz) - sLen.xz, q.y + sLen.y).xzy,\n     vec3 (tr, f, tr) - 0.1, 0.1);\n  d = min (d, PrRoundBoxDf (vec3 (abs (q.x) - sLen.x, abs (q.y + sLen.y) - sLen.y, q.z),\n     vec3 (tr, tr, sLen.z + tr) - 0.1, 0.1));\n  d = min (d, PrRoundBoxDf (vec3 (q.xz, q.y + 2. * sLen.y).xzy,\n     vec3 (sLen.x, tr, tr) - 0.1, 0.1));\n  DMIN (idFrmEx);\n  d = PrCylDf (vec3 (q.xz, q.y + 2. * sLen.y), 2. * tr, 1.4 * tr);\n  DMIN (idAx);\n  q = p;\n  q.y -= - 2. * f - 0.05;\n  d = PrRoundCylDf (q.xzy, baseRad, 0.1, 0.15);\n  DMIN (idBas);\n  p.y += baseUp;\n  q = p;\n  d = q.y;\n  DMIN (idFlr);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dMax)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.001 || d > dMax) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    if (p.w > 0.) {\n      u = ro - p.xyz;\n      rad = 0.46 * p.w;\n      b = dot (rd, u);\n      w = b * b - dot (u, u) + rad * rad;\n      if (w > 0.) {\n        d = - b - sqrt (w);\n        if (d > 0. && d < dMin) {\n          dMin = d;\n          vnBall = (u + d * rd) / rad;\n          idBall = n;\n        }\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    u = ro - p.xyz;\n    rad = 0.49 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (txOff + 4 * idBall + 2));\n  return step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nfloat BlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u;\n  float dMin, dn, df;\n  dMin = dstFar;\n  v = ro / rd;\n  tp = (hbSize - hbMarg - 0.04) / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    vnBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return dMin;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, rob, rdb, vn, ltDir;\n  float dstBall, dstObj, db, att, nDotL, sh;\n  rob = OrAng (ro - vec3 (0., baseUp, 0.));\n  rdb = OrAng (rd);\n  db = BlkHit (rob, rdb);\n  dstBall = (db < dstFar) ? BallHit (rob, rdb) : dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == idFrm) col4 = vec4 (0.85, 0.8, 0.8, 0.1);\n      else if (idObj == idFrmEx) col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n      else if (idObj == idAx) col4 = vec4 (0.8, 0.7, 0.7, 0.1);\n      else if (idObj == idObs) col4 = vec4 (0.75, 0.7, 0.7, 0.1);\n      else if (idObj == idBas) col4 = vec4 (0.6, 0.6, 0.65, 0.05);\n      else if (idObj == idFlr) col4 = vec4 (0.6, 0.4, 0.1, 0.05);\n    } else {\n      ro += dstBall * rd;\n      vn = OrAngT (vnBall);\n      col4 = vec4 (HsvToRgb (vec3 (fract (33. * float (idBall) / float (nBall) +\n         0.5 * BallChqr (idBall, vnBall)), 0.8, 1.)), 0.2);\n    }\n    ltDir = normalize (ltPos - ro);\n    att = smoothstep (0., 0.01, dot (ltDir, normalize (ltPos)) - 0.95);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstBall && idObj <= idObs) nDotL *= nDotL;\n    sh = ObjSShadow (ro, ltDir, dstFar);\n    sh = min (sh, 0.5 + 0.5 * BallHitSh (OrAng (ro - vec3 (0., baseUp, 0.)), OrAng (ltDir), 80.));\n    col = att * (col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * nDotL) + col4.a * step (0.95, sh) * pow (max (0.,\n       dot (ltDir, reflect (rd, vn))), 32.));\n  } else {\n    col = vec3 (0.);\n  }\n  if (db < min (dstObj, dstFar)) {\n    ro = rob + db * rdb;\n    if (dstObj < dstBall) col *= 0.95;\n    vn = OrAngT (vnBlk);\n    col = mix (col, vec3 (0.5) * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.), pow (1. - abs (dot (rd, vn)), 5.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 stDat;\n  vec3 wgBx;\n  vec2 cVec, w;\n  float mPtrz;\n  int wgSel;\n  wgBx = vec3 (1.4, 0., 0.25);\n  stDat = Loadv4 (2);\n  mPtrz = stDat.z;\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (3);\n  cVec = stDat.xy;\n  w = uv -  wgBx.xy;\n  col = mix (vec3 (0.35), col, 0.5 + 0.5 * smoothstep (4., 6., PrRoundBox2Df (w,\n     vec2 (wgBx.z), 0.03) * canvas.y));\n  col = mix (vec3 (0., 1., 1.), col, smoothstep (3., 4., abs (length (w) - wgBx.z) * canvas.y));\n  if (length (w) < wgBx.z) col = mix (vec3 (0., 1., 1.), col,\n       smoothstep (3., 4., Minv2 (abs (w) * canvas.y)));\n  if (length (cVec) < 1.) col = mix (vec3 (1., 1., 0.), col,\n     smoothstep (10., 15., length (w - cVec * wgBx.z) * canvas.y));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat;\n  vec3 col, ro, rd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  asp = canvas.x / canvas.y;\n  txOff = 4;\n  stDat = Loadv4 (0);\n  hbSize = stDat.xyz;\n  baseRad = 1.8 * hbSize.x;\n  stDat = Loadv4 (1);\n  blkAng = stDat.xyz;\n  nBall = int (stDat.w);\n  stDat = Loadv4 (3);\n  el = stDat.z;\n  az = stDat.w;\n  zmFac = 6. - 5. * el;\n  el = 0.2 * (el + 0.05 * pi) - 0.05 * pi;\n  vuMat = StdVuMat (el, az);\n  hbMarg = 0.4;\n  baseUp = 1.1 * length (hbSize - hbMarg) + 0.1;\n  ro = vuMat * vec3 (0., 1., - 12. * hbSize.x);\n  ro.y += baseUp;\n  dstFar = 20. * length (hbSize);\n  ltPos = 100. * vec3 (0.4, 1., -1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col = ShowWg (uv, canvas, col);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec3 OrAng (vec3 p)\n{\n  p.xz = Rot2D (p.xz, blkAng.y);\n  p.yz = Rot2D (p.yz, blkAng.x);\n  p.xy = Rot2D (p.xy, blkAng.z);\n  return p;\n}\n\nvec3 OrAngT (vec3 p)\n{\n  p.xy = Rot2D (p.xy, - blkAng.z);\n  p.yz = Rot2D (p.yz, - blkAng.x);\n  p.xz = Rot2D (p.xz, - blkAng.y);\n  return p;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, gVec;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    diamN = p.w;\n    if (diamN > 0.) {\n      rmN = p.xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      diamAv = 0.5 * (diam + diamN);\n      if (n != mId && rSep < diamAv) {\n        fc = fOvlap * (diamAv / rSep - 1.);\n        vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n        wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n        dv = vm - vmN;\n        h = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * h, 0.);\n        am += fc * dr;\n        dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n        ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n      }\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 b, s;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 0.1);\n  b = hbSize.xy - 2.;\n  s = sign (rm.xy) * vec2 (-1., 1.);\n  dr.z = 0.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dr.xy = s * ((k == 0) ? max (vec2 (b.x - abs (rm.x), abs (rm.y)) - vec2 (2., 0.1), 0.) :\n       - max (vec2 (abs (rm.x), b.y - abs (rm.y)) - vec2 (0.1, 2.), 0.));\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  diam = p.w;\n  if (diam > 0.) {\n    rm = p.xyz;\n    p = Loadv4 (txOff + 4 * mId + 1);\n    vm = p.xyz;\n    qm = Loadv4 (txOff + 4 * mId + 2);\n    wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n    ms = diam * diam * diam;\n    am = vec3 (0.);\n    wam = vec3 (0.);\n    PairInt (mId, rm, vm, wm, diam, am, wam);\n    BdyInt (rm, vm, wm, diam, am, wam);\n    ObsInt (rm, vm, wm, diam, am, wam);\n    am -= grav * gVec + fDamp * vm;\n    wam -= fDamp * wm;\n    vm += dt * am / ms;\n    rm += dt * vm;\n    wm += dt * wam / (0.2 * ms * diam);\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n  w = hbSize.xy - 2. - abs (rm.xy);\n  if (length (max (vec2 (w.x, abs (rm.y)) - vec2 (2., 0.1), 0.)) < 1. ||\n      length (max (vec2 (w.y, abs (rm.x)) - vec2 (2., 0.1), 0.)) < 1.) diam = -1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng, wgBx, mVec;\n  vec2 iFrag, canvas, ust, mt, cVec;\n  float el, az, mPtrPz, asp, diam;\n  int mId, pxId, wgSel, wgReg, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (ivec2 (16), 2);\n  txOff = 4;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  wgReg = -2;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  dt = 0.01;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    nBall = nbMax;\n    wgSel = -1;\n    el = -0.05 * pi;\n    az = 0.;\n    blkAng = vec3 (0.);\n    cVec = vec2 (0.);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nBall = int (stDat.w);\n    stDat = Loadv4 (2);\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (3);\n    cVec = stDat.xy;\n    el = stDat.z;\n    az = stDat.w;\n  }\n  wgBx = vec3 (1.4, 0., 0.25);\n  if (mPtr.z > 0.) {\n    mt = 2. * mPtr.xy * vec2 (asp, 1.) - wgBx.xy;\n    if (length (mt) < wgBx.z) {\n      cVec = mt / wgBx.z;\n      wgReg = 0;\n    }\n    if (mPtrPz <= 0.) wgSel = wgReg;\n  } else {\n    cVec = vec2 (0.);\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    blkAng.x = -1.3 * pi * cVec.y * smoothstep (0.15, 0.2, abs (cVec.y));\n    blkAng.z = -1.3 * pi * cVec.x;\n  } else {\n    blkAng.z = mod (blkAng.z + 0.0003 * pi, 2. * pi);\n  }\n  if (mPtr.z > 0. && wgSel < 0) {\n    blkAng.y = -2. * pi * mPtr.x;\n    el = clamp (pi * mPtr.y, -0.45 * pi, 0.03 * pi);\n  } else {\n    el = 0.98 * (el + 0.05 * pi) - 0.05 * pi;\n    blkAng.xy *= 0.98;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, float (nBall));\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 3) stDat = vec4 (cVec, el, az);\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Balls In Motion 2\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nvec4 QtMul (vec4 q1, vec4 q2);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nvec3 hbSize, gVec;\nivec3 nbEdge;\nfloat nStep, fOvlap, fricN, fricS, fricT, dt;\nint nFrame, nBall, txOff;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvoid PairInt (int mId, vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, dv;\n  float diamN, rSep, diamAv, h, fc, ft;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (txOff + 4 * n);\n    diamN = p.w;\n    if (diamN > 0.) {\n      rmN = p.xyz;\n      dr = rm - rmN;\n      rSep = length (dr);\n      diamAv = 0.5 * (diam + diamN);\n      if (n != mId && rSep < diamAv) {\n        fc = fOvlap * (diamAv / rSep - 1.);\n        vmN = Loadv4 (txOff + 4 * n + 1).xyz;\n        wmN = Loadv4 (txOff + 4 * n + 3).xyz;\n        dv = vm - vmN;\n        h = dot (dr, dv) / (rSep * rSep);\n        fc = max (fc - fricN * h, 0.);\n        am += fc * dr;\n        dv -= h * dr + cross ((diam * wm + diamN * wmN) / (diam + diamN), dr);\n        ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n        am -= ft * dv;\n        wam += (ft / rSep) * cross (dr, dv);\n      }\n    }\n  }\n}\n\nvoid BdyInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec4 drw;\n  vec3 dr, dv;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 1.);\n  drw = vec4 ((hbSize - abs (rm)) * (1. - 2. * step (0., rm)), 0.);\n  for (int nf = VAR_ZERO; nf < 3; nf ++) {\n    dr = (nf == 1) ? drw.wyw : ((nf == 0) ? drw.xww : drw.wwz);\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid ObsInt (vec3 rm, vec3 vm, vec3 wm, float diam, inout vec3 am, inout vec3 wam)\n{\n  vec3 dr, dv;\n  vec2 b, s;\n  float rSep, diamAv, h, fc, ft;\n  diamAv = 0.5 * (diam + 0.1);\n  b = hbSize.xy - 2.;\n  s = sign (rm.xy) * vec2 (-1., 1.);\n  dr.z = 0.;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dr.xy = s * ((k == 0) ? max (vec2 (b.x - abs (rm.x), abs (rm.y)) - vec2 (2., 0.1), 0.) :\n       - max (vec2 (abs (rm.x), b.y - abs (rm.y)) - vec2 (0.1, 2.), 0.));\n    rSep = length (dr);\n    if (rSep < diamAv) {\n      fc = fOvlap * (diamAv / rSep - 1.);\n      dv = vm;\n      h = dot (dr, dv) / (rSep * rSep);\n      fc = max (fc - fricN * h, 0.);\n      am += fc * dr;\n      dv -= h * dr + cross (wm, dr);\n      ft = min (fricT, fricS * abs (fc) * rSep / max (1e-3, length (dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross (dr, dv);\n    }\n  }\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec4 p;\n  vec3 am, wam;\n  float fDamp, grav, ms;\n  fOvlap = 500.;\n  fricN = 5.;\n  fricT = 5.;\n  fricS = 0.5;\n  fDamp = 0.002;\n  grav = 1.;\n  p = Loadv4 (txOff + 4 * mId);\n  diam = p.w;\n  if (diam > 0.) {\n    rm = p.xyz;\n    p = Loadv4 (txOff + 4 * mId + 1);\n    vm = p.xyz;\n    qm = Loadv4 (txOff + 4 * mId + 2);\n    wm = Loadv4 (txOff + 4 * mId + 3).xyz;\n    ms = diam * diam * diam;\n    am = vec3 (0.);\n    wam = vec3 (0.);\n    PairInt (mId, rm, vm, wm, diam, am, wam);\n    BdyInt (rm, vm, wm, diam, am, wam);\n    ObsInt (rm, vm, wm, diam, am, wam);\n    am -= grav * gVec + fDamp * vm;\n    wam -= fDamp * wm;\n    vm += dt * am / ms;\n    rm += dt * vm;\n    wm += dt * wam / (0.2 * ms * diam);\n    qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n  }\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float diam)\n{\n  vec3 e;\n  vec2 w;\n  float mIdf;\n  e = vec3 (nbEdge);\n  mIdf = float (mId);\n  rm = 0.95 * (floor (vec3 (mod (mIdf, e.x), mod (mIdf, e.x * e.y) / e.x,\n     mIdf / (e.x * e.y))) - 0.5 * (e - 1.));\n  vm = 2. * normalize (vec3 (Hashff (mIdf + 0.1), Hashff (mIdf + 0.4), Hashff (mIdf + 0.7)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf + 0.2), Hashff (mIdf + 0.5), Hashff (mIdf + 0.8)));\n  qm = EulToQt (e);\n  wm = 2.5 * e;\n  diam = 1. - 0.2 * Hashff (mIdf + 0.1);\n  w = hbSize.xy - 2. - abs (rm.xy);\n  if (length (max (vec2 (w.x, abs (rm.y)) - vec2 (2., 0.1), 0.)) < 1. ||\n      length (max (vec2 (w.y, abs (rm.x)) - vec2 (2., 0.1), 0.)) < 1.) diam = -1.;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p, qm;\n  vec3 rm, vm, wm, blkAng, wgBx, mVec;\n  vec2 iFrag, canvas, ust, mt, cVec;\n  float el, az, mPtrPz, asp, diam;\n  int mId, pxId, wgSel, wgReg, nbMax;\n  bool doInit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nbEdge = ivec3 (ivec2 (16), 2);\n  txOff = 4;\n  nbMax = nbEdge.x * nbEdge.y * nbEdge.z;\n  if (iFrag.x >= txRow || pxId >= 4 * nbMax + txOff) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  if (pxId >= txOff) mId = (pxId - txOff) / 4;\n  else mId = -1;\n  asp = canvas.x / canvas.y;\n  wgReg = -2;\n  doInit = false;\n  if (nFrame <= 1) doInit = true;\n  dt = 0.01;\n  if (doInit) {\n    hbSize = 0.7 * vec3 (nbEdge) + 0.5;\n    nStep = 0.;\n    nBall = nbMax;\n    wgSel = -1;\n    el = -0.05 * pi;\n    az = 0.;\n    blkAng = vec3 (0.);\n    cVec = vec2 (0.);\n  } else {\n    stDat = Loadv4 (0);\n    hbSize = stDat.xyz;\n    nStep = stDat.w;\n    ++ nStep;\n    stDat = Loadv4 (1);\n    blkAng = stDat.xyz;\n    nBall = int (stDat.w);\n    stDat = Loadv4 (2);\n    mPtrPz = stDat.z;\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (3);\n    cVec = stDat.xy;\n    el = stDat.z;\n    az = stDat.w;\n  }\n  wgBx = vec3 (1.4, 0., 0.25);\n  if (mPtr.z > 0.) {\n    mt = 2. * mPtr.xy * vec2 (asp, 1.) - wgBx.xy;\n    if (length (mt) < wgBx.z) {\n      cVec = mt / wgBx.z;\n      wgReg = 0;\n    }\n    if (mPtrPz <= 0.) wgSel = wgReg;\n  } else {\n    cVec = vec2 (0.);\n    wgSel = -1;\n    wgReg = -2;\n  }\n  if (wgSel == 0) {\n    blkAng.x = -1.3 * pi * cVec.y * smoothstep (0.15, 0.2, abs (cVec.y));\n    blkAng.z = -1.3 * pi * cVec.x;\n  } else {\n    blkAng.z = mod (blkAng.z + 0.0003 * pi, 2. * pi);\n  }\n  if (mPtr.z > 0. && wgSel < 0) {\n    blkAng.y = -2. * pi * mPtr.x;\n    el = clamp (pi * mPtr.y, -0.45 * pi, 0.03 * pi);\n  } else {\n    el = 0.98 * (el + 0.05 * pi) - 0.05 * pi;\n    blkAng.xy *= 0.98;\n  }\n  gVec = vec3 (0., Rot2D (vec2 (1., 0.), blkAng.x));\n  gVec.xy = Rot2D (gVec.xy, blkAng.z);\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, diam);\n    else Step (mId, rm, vm, qm, wm, diam);\n  }\n  if      (pxId == 0) stDat = vec4 (hbSize, nStep);\n  else if (pxId == 1) stDat = vec4 (blkAng, float (nBall));\n  else if (pxId == 2) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 3) stDat = vec4 (cVec, el, az);\n  else if (pxId >= txOff) {\n    mId = pxId - (txOff + 4 * mId);\n    p = (mId <= 1) ? ((mId == 0) ? vec4 (rm, diam) : vec4 (vm, 0.)) :\n       ((mId == 2) ? qm : vec4 (wm, 0.));\n  }\n  Savev4 (pxId, ((pxId >= txOff) ? p : stDat), fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = m1[0][0];\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (mod (p, 2. * pi)) * cHashM);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}