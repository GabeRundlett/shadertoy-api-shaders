{
    "Shader": {
        "info": {
            "date": "1556048862",
            "description": "[url=http://www.lps.ens.fr/~ninio/index.html]Jacques Ninio[/url]'s famous illusion.\nmouse for different styles.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ttf3Dr",
            "likes": 9,
            "name": "Ninio's Extinction Illusion",
            "published": 3,
            "tags": [
                "grid",
                "illusion",
                "dots",
                "ninio",
                "extinction"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 452
        },
        "renderpass": [
            {
                "code": "// drawing Ninio's extinction illusion\n// see http://www.lps.ens.fr/~ninio/index.html\n// mouse for different styles.\n \n#define NUM_REPS  5.0\n#define BAR_WIDTH 0.1\n#define PI        3.14159265359\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    float refDim = min(iResolution.x, iResolution.y);\n    vec2 UV = XY / refDim;\n    UV -= 0.5;\n    UV *= NUM_REPS;\n    float b = 1.0;\n    \n    // i can't decide which style is 'better', so offering both.\n    bool invert1 = iMouse.z > 0.0;\n    bool invert2 = iMouse.x > iResolution.x / 2.0;\n    bool extras1 = iMouse.y > iResolution.y / 2.0;\n    \n    float c;\n\tfloat d;\n    vec2 fr;\n    \n    float mc = cos(-PI / 4.0);\n    float ms = sin(-PI / 4.0);\n    mat2 r45 = mat2(mc, ms, -ms, mc);\n    \n    // diagonals\n    fr = mod(UV * r45 * sqrt(2.0), 1.0);\n    c = abs(fr.x - 0.5) * 2.0;\n    c = 0.5 + 0.5 * smoothstep(1.0 - BAR_WIDTH * 0.9, 1.0 - BAR_WIDTH, c);\n    b = min(b, c);\n    c = abs(fr.y - 0.5) * 2.0;\n    c = 0.5 + 0.5 * smoothstep(1.0 - BAR_WIDTH * 0.9, 1.0 - BAR_WIDTH, c);\n    b = min(b, c);\n\n    // straights\n    fr = mod(UV, 0.5);\n    c = abs(fr.x - 0.25) * 4.2;\n    c = 0.5 + 0.5 * smoothstep(1.0 - BAR_WIDTH * 0.9, 1.0 - BAR_WIDTH, c);\n    b = min(b, c);\n    c = abs(fr.y - 0.25) * 4.2;\n    c = 0.5 + 0.5 * smoothstep(1.0 - BAR_WIDTH * 0.9, 1.0 - BAR_WIDTH, c);\n    b = min(b, c);\n    \n    // dots\n    fr = mod(UV + 1.0, 2.0);\n    d = length(fr - 1.0) / BAR_WIDTH * 2.0;\n    if (invert2) {\n\t    c = smoothstep(1.5, 1.0, d / 1.3);\n\t\tb = min(b, 1.0 - c);\n\t    c = smoothstep(1.0, 1.5, d / 0.8);\n\t\tb = max(b, 1.0 - c);\n    }\n    else {\n\t    c = smoothstep(1.5, 1.0, d / 1.3);\n\t\tb = max(b, c);\n\t    c = smoothstep(1.0, 1.5, d / 0.8);\n\t\tb = min(b, c);\n    }\n\n    // extra stuff to attrack the eye to empty nexus\n    // i think this detracts frtom the effect.\n    if (extras1) {\n        fr = mod(UV + 0.0, 2.0);\n        d = length(fr - 1.0) / 0.25;\n        d = abs(1.0 - d);\n        c = 1.0 * smoothstep(0.15, 0.05, d);\n        b = max(b, c);\n    }\n\n    if (invert1) {\n        b = 1.0 - b;\n    }\n\n    \n    RGBA = vec4(vec3(b), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}