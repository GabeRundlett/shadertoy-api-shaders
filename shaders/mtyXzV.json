{
    "Shader": {
        "info": {
            "date": "1686209387",
            "description": "Simple, readable demo of how to add antialiasing to your shader using a box filter algorithm. Careful, as this method is computationally expensive -- running your shader code n^2 times as AA_STAGES increases.\nExample: https://www.shadertoy.com/view/DlVSWD",
            "flags": 0,
            "hasliked": 0,
            "id": "mtyXzV",
            "likes": 8,
            "name": "shadertoy-antialias-demo",
            "published": 3,
            "tags": [
                "tutorial",
                "demo",
                "antialias"
            ],
            "usePreview": 0,
            "username": "LydianLights",
            "viewed": 454
        },
        "renderpass": [
            {
                "code": "// ====== MAIN SHADER CODE ====== //\n// Everything you'd normally put in your shader goes here\n// This just draws some rings on a checkerboard\nconst float PI = 3.1415927;\nvec3 mainPass(in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 rotUV = uv * mat2(cos(PI / 5.0), sin(PI / 5.0), -sin(PI / 5.0), cos(PI / 5.0));\n    rotUV.y += 0.1 * iTime;\n    rotUV = fract(1.5 * rotUV);\n    \n    float d0 = abs(step(rotUV.x, 0.5) - step(rotUV.y, 0.5));\n    \n    vec3 color = vec3(d0);\n   \n    float d1 = length(uv);\n    d1 = step(d1, 0.5) * step(0.3, d1);\n    if (d1 > 0.0) color = vec3(1.0, 0.25, 0.25);\n    \n    float d2 = length(uv - vec2(1.1, 0.0));\n    d2 = step(d2, 0.5) * step(0.3, d2);\n    if (d2 > 0.0) color = vec3(0.25, 1.0, 0.25);\n    \n    float d3 = length(uv + vec2(1.1, 0.0));\n    d3 = step(d3, 0.5) * step(0.3, d3);\n    if (d3 > 0.0) color = vec3(0.25, 0.25, 1.0);\n   \n    return color;\n}\n\n\n// ====== ANTIALIASING ====== //\n// Basically this calls your shader multiple times with a random subpixel offset and averages the results\n// Quick and easy to implement, but does have performance implications for intense shaders\n\n// Function for getting 2d noise\n// see https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 antialias(in vec2 fragCoord)\n{\n    // Set the number of AA passes here\n    // Note that your shader code is called n^2 times, so be careful\n    // Higher values have diminishing returns anyway\n    const float AA_STAGES = 2.0;\n    \n    // These constants don't need changing\n    const float AA_TOTAL_PASSES = AA_STAGES * AA_STAGES + 1.0;\n    const float AA_JITTER = 0.5;\n    \n    // Run the shader multiple times with a random subpixel offset each time and average the results\n    vec3 color = mainPass(fragCoord);\n    for (float x = 0.0; x < AA_STAGES; x++)\n    {\n        for (float y = 0.0; y < AA_STAGES; y++)\n        {\n            vec2 offset = AA_JITTER * (2.0 * hash22(vec2(x, y)) - 1.0);\n            color += mainPass(fragCoord + offset);\n        }\n    }\n    return color / AA_TOTAL_PASSES;\n}\n\n\n// ====== GAMMA CORRECTION ====== //\n// Helps with color mixing -- good to have by default in almost any shader\n// See https://www.shadertoy.com/view/lscSzl\nvec3 gamma(in vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\n\n// ====== FINAL RENDERING ====== //\n// All the code here is just to show the comparison\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float sliderX = iMouse.z > 0.0 ? iMouse.x : iResolution.x / 2.0;\n    \n    vec3 base = mainPass(fragCoord);\n    vec3 antialiased = antialias(fragCoord);\n    \n    vec3 color = fragCoord.x < sliderX ? base : antialiased;\n    if (abs(fragCoord.x - sliderX) < 4.0)\n    {\n        color = vec3(0.5);\n    }\n    \n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}\n\n// This is all you would need in a normal shader:\n/*\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = antialias(fragCoord);\n    color = gamma(color);\n    fragColor = vec4(color, 1.0);\n}\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}