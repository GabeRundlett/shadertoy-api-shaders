{
    "Shader": {
        "info": {
            "date": "1537931430",
            "description": "A modified version of the known mandelbulb",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdyDH",
            "likes": 26,
            "name": "Melting Mandelbulb",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "mandelbrot",
                "mandelbulb",
                "melting",
                "gold"
            ],
            "usePreview": 0,
            "username": "pedrolb",
            "viewed": 1060
        },
        "renderpass": [
            {
                "code": "// CONSTANTS\n//\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.005;\n//const float Power = 4.0;\nconst float Bailout = 2.0;\nint MAX_ITERATIONS = 10;\nfloat SCALE = 2.0;\n\n\n// HERE WE DEFINE CAMERA PROPERTIES\n//\nfloat camFOV = 45.0;\nvec3 cameraPos = vec3(0.0, 0.0, -5.5);\nmat3x3 camMatrix = mat3x3(\n    vec3(1.0, 0.0, 0.0), // right vec\n    vec3(0.0, 1.0, 0.0), // up vec\n    vec3(0.0, 0.0, 1.0) // forward vec\n);\n\n\n// TRANSFORM A SCREEN PIXEL IN A VECTOR IN THE WORLD\n//\nvec3 ScreenPointToWorld (vec2 screenPoint) // Don't consider camera position, it needs to be added if needed\n{\n\tvec2 xyWorld = screenPoint - iResolution.xy / 2.0;\n    float zWorld = abs(iResolution.x / 2.0) / tan(radians(camFOV / 2.0));\n    \n    return normalize(camMatrix * vec3(xyWorld, zWorld));\n}\n\n\n// VOLUME DISTANCE FUNCTION\n//\nfloat Distance (vec3 pos)\n{\n    float Power = 8.0;// mix(6.0, 9.0, (sin(iTime) + 1.0) / 2.0);\n    \n    mat3x3 rotMatrix = mat3x3(\n    \tvec3(cos(iTime * 0.5), -sin(iTime * 0.5), 0.0),\n        vec3(sin(iTime * 0.5), cos(iTime * 0.5), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    \n    mat3x3 rotMatrix2 = mat3x3(\n    \tvec3(cos(iTime * 0.5), 0.0, -sin(iTime * 0.5)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(sin(iTime * 0.5), 0.0, cos(iTime * 0.5))\n    );\n    \n    mat3x3 rotMatrix3 = mat3x3(\n    \tvec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(iTime * 0.5), -sin(iTime * 0.5)),\n        vec3(0.0, sin(iTime * 0.5), cos(iTime * 0.5))\n    );\n    \n    vec3 z = rotMatrix * rotMatrix2 * rotMatrix3 * (pos + vec3(0.0, 0.0, 1.0));\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < MAX_ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n// SURFACE NORMAL\n//\nvec3 Normals(vec3 p)\n{\n    return normalize(vec3(\n        Distance(vec3(p.x + EPSILON, p.y, p.z)) - Distance(vec3(p.x - EPSILON, p.y, p.z)),\n        Distance(vec3(p.x, p.y + EPSILON, p.z)) - Distance(vec3(p.x, p.y - EPSILON, p.z)),\n        Distance(vec3(p.x, p.y, p.z + EPSILON)) - Distance(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n// RETURNS THE DISTANCE FROM THE CAMERA OF THE CLOSEST POINT TO THE SURFACE\n//\nfloat RayMarchingClosestPoint(vec3 camPos, vec3 lookDir, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float distToSurface = Distance(camPos + lookDir * depth);\n        if(distToSurface < EPSILON)\n        {\n            return depth;\n        }\n        depth += distToSurface;\n        if(depth >= end)\n        {\n        \treturn end;    \n        }\n    }\n    return end;\n}\n\n\n// CONTRIBUTION FOR EACH LIGHT USING PHONG\n//\nvec3 LightContribution(\n    vec3 diffuseColor, \n    vec3 specularColor, \n    vec3 ambientColor,\n    float glossiness,\n    vec3 normal,\n    vec3 viewDir,\n    vec3 surfacePos,\n    vec3 lightColor,\n    float lightIntensity,\n    vec3 lightPos\n)\n{\n    vec3 N = normal;\n    vec3 V = -viewDir;\n    vec3 L = normalize(lightPos - surfacePos);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = max(0.0, dot(L, N));\n    float dotRV = max(0.0, dot(R, V));\n    float dotVN = 1.0 - max(0.0, dot(V, N));\n    \n    return \n        (lightIntensity * lightColor *\n            (dotLN * diffuseColor\n             + (1.0 - mix(0.1, 1.0, dotVN * dotVN)) * specularColor * pow(dotRV, glossiness)\n             + texture(iChannel0, R).rgb * dotVN * dotVN * 0.3)\n        );\n}\n\n\n// MAIN\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = ScreenPointToWorld (fragCoord);\n    float dist = RayMarchingClosestPoint(cameraPos, viewDir, MIN_DIST, MAX_DIST);\n    \n    vec3 col = mix(vec3(0.02), vec3(0.2, 0.16, 0.1), pow(dot(viewDir, vec3(0.0, 0.0, 1.0)), 30.0));\n    \n    if(dist <= MAX_DIST - EPSILON)\n    {\n        vec3 surfPos = cameraPos + viewDir * dist;\n        vec3 surfNormals = Normals(surfPos);\n        \n        col = LightContribution(\n            vec3(0.05, 0.05, 0.015), //vec3 diffuseColor, \n            vec3(0.99, 0.65, 0.34), //vec3 specularColor, \n            vec3(0.05, 0.05, 0.05), //vec3 ambientColor,\n            15.0, //float glossiness,\n            surfNormals, //vec3 normal,\n            viewDir, //vec3 viewDir,\n            surfPos, //vec3 surfacePos,\n            vec3(1.0, 1.0, 1.0), //vec3 lightColor,\n            3.0, //float lightIntensity,\n            vec3(5.0, 5.0, -5.0) //vec3 lightPos\n        );\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}