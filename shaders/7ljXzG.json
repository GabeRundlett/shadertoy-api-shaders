{
    "Shader": {
        "info": {
            "date": "1627979235",
            "description": "Wave pattern projected on cave walls",
            "flags": 0,
            "hasliked": 0,
            "id": "7ljXzG",
            "likes": 5,
            "name": "Wave Cave",
            "published": 3,
            "tags": [
                "tunnel",
                "wave",
                "cave",
                "project"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 321
        },
        "renderpass": [
            {
                "code": "// \"Wave Cave\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Wave pattern (from \"Wave Room 2\") projected on cave walls (from \"Nautilus\" series)\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirToRMatT (vec3 vd, vec3 vu);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, gloPos;\nfloat tCur, dstFar, cvSize;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\nvec3 TrkPath (float t)\n{\n  return vec3 ((4.7 * sin (t * 0.15 / cvSize) + 2.7 * cos (t * 0.19 / cvSize)) * cvSize, 0., t);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float s, d;\n  p.x -= TrkPath (p.z).x;\n  p /= cvSize;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.5 * cvSize * (length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 320; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.01, -0.01);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dLim)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, h);\n    if (sh < 0.05 || d > dLim) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht, tWav;\n  tWav = 0.2 * tCur;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = 0; j < 3; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 2.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (normalize (vec3 (-0.2 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 hn4;\n  vec3 vn, col, bgCol, ltVec;\n  vec2 u;\n  float dstObj, wGlow, sh, atten, ltDist;\n  dstObj = ObjRay (ro, rd);\n  wGlow = mix ((0.9 + 0.1 * sin (8. * pi * tCur)) * pow (max (dot (rd, normalize (gloPos - ro)), 0.), 1024.),\n     0., smoothstep (-0.2, 0.2, length (gloPos - ro) - dstObj));\n  bgCol = vec3 (0., 0.1, 0.1);\n  col = bgCol;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    ltVec = ltPos - dstObj * rd;\n    ltDist = length (ltVec);\n    atten = (1. - smoothstep (0.1, 0.6, ltDist / dstFar)) / (1. + 0.002 * pow (ltDist, 1.5));\n    ltVec /= ltDist;\n    vn = ObjNf (ro);\n    u = vec2 (atan (vn.x, vn.z) + pi, tan (2. * atan (0.5 * asin (vn.y)))) / (2. * pi);\n    hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n    vn = vn * DirToRMatT (normalize (hn4.xyz), vec3 (0., 1., 0.));\n    vn = VaryNf (16. * ro, vn, 0.2);\n    sh = ObjSShadow (ro, ltVec, ltDist);\n    col = mix (vec3 (0.3, 0.9, 0.7), vec3 (0.2, 0.6, 0.9), smoothstep (0.6, 0.7, hn4.w));\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, ltVec), 0.)) +\n       0.3 * step (0.95, sh) * pow (max (dot (reflect (ltVec, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.45, 0.95, dstObj / dstFar)) * atten;\n  }\n  col += wGlow * vec3 (0.5, 0.5, 0.);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, t, dVu;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = pi * mPtr.y;\n  }\n  cvSize = 7.;\n  tCur = mod (tCur, 1800.);\n  t = 3. * tCur;\n  dVu = 2. * SmoothBump (0.25, 0.75, 0.15, mod (tCur / 40., 1.)) - 1.;\n  ro = TrkPath (t + 3. * cvSize * dVu);\n  ro.x += 2. * (1. - abs (dVu));\n  ro.y = 2. + 2. * (1. - abs (dVu));\n  vd = TrkPath (t) - ro;\n  vuMat = StdVuMat (el + atan (vd.y, length (vd.xz)), az + atan (vd.x, vd.z));\n  gloPos = TrkPath (t + 10. * cvSize);\n  zmFac = 1.5;\n  rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac,\n     uv.y, zmFac));\n  ltPos = vuMat * vec3 (0., 0.5, 0.);\n  dstFar = 50. * cvSize;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nmat3 DirToRMatT (vec3 vd, vec3 vu)\n{\n  vec3 vc;\n  float s;\n  vc = cross (vu, vd);\n  s = length (vc);\n  if (s > 0.) vc /= s;\n  return mat3 (vc, cross (vd, vc), vd);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}