{
    "Shader": {
        "info": {
            "date": "1577720093",
            "description": "...movin down the road in my V-8 ford,\ni had a shine on my boots, i had my sideburns lowered...\n\nuse ASDW or cursor keys to drive. +/- to zoom (not much of a simulation for now - just driving/steering)\n",
            "flags": 48,
            "hasliked": 0,
            "id": "tltGWj",
            "likes": 85,
            "name": "zztop '33 ford eliminator",
            "published": 3,
            "tags": [
                "simulation",
                "car",
                "zztop",
                "ford",
                "eliminator"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 4644
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n//#define RENDERED_REFECTIONS\n#define SHADOW\n#define SCRATCHES\n//#define STREET\n#define RENDER_GLASS\n//#define WET_ASPHALT\n//#define RENDER_BBOX\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#define BG 0.\n#define CARBODY 1.\n#define TIRE 2.\n#define RIM 3.\n#define HEADLIGHTS 4.\n#define FLOOR 5.\n#define GRILL 6.\n#define RUMPF 7.\n#define INTERIOR 8.\n#define GLASS 9.\n#define WATER 10.\n#define CHASSIS 11.\n#define GUMMI 12.\n#define DESERT 13.\n\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_TIRE       Material(vec3(.15,.15,.15),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(1,1,1),           1.,   0.2, vec2(1,.01))\n#define MAT_HEADLIGHTS Material(vec3(.8),              1.,   0.2, vec2(1,.01))\n#ifdef WET_ASPHALT\n#define MAT_FLOOR      Material(vec3(.35),            -0.05, 0.0, vec2(1,.01))\n#else\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#endif\n#define MAT_GRILL      Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_RUMPF      Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_WATER      Material(vec3(.1),             -1.,   0.0, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.4),              0.5,  1.0, vec2(1,.01)*.5)\n#define MAT_GUMMI      Material(vec3(.3),             -0.1,  1.0, vec2(1,.01))\n#define MAT_DESERT     Material(vec3(.58,.55,.53)*.85,-0.2,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[14] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_TIRE      ,\nMAT_RIM       ,\nMAT_HEADLIGHTS,\nMAT_FLOOR     ,\nMAT_GRILL     ,\nMAT_RUMPF     ,\nMAT_INTERIOR  ,\nMAT_GLASS     ,\nMAT_WATER     ,\nMAT_CHASSIS   ,\nMAT_GUMMI     ,\nMAT_DESERT\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==TIRE)         return MAT_TIRE      ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==HEADLIGHTS)   return MAT_HEADLIGHTS;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==GRILL)        return MAT_GRILL     ;\n    if(mtl==RUMPF)        return MAT_RUMPF     ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==WATER)        return MAT_WATER     ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==DESERT)       return MAT_DESERT    ;\n}\n#endif\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// envoronment just a sky and some floor grid...\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    d=max(d,distTorus(p.yzx,r*.75,r*.38));\n    d=max(d,-length(p.yz)+r*.61);\n    float dx=.07;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.015));\n    return d;\n}\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    p=abs(p);\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,1.1*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.1*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.4*r),.005);\n    d=-smin(-d,sdRoundedCylinder(p,.77*r,.01,.8*r),.005);\n    d=min(d,sdCone(p.xzy-vec3(0,0,-.2*r),cos(1.1-vec2(0,1.57))));\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    mang=mod(ang0,PI2/12.);\n    ang=ang0-mang+PI2/12.*.5;\n    d=-smin(-d,(length(p.xz-.58*r*cos(ang-vec2(0,1.57)))-.1*r),.005);\n    mang=mod(ang0,PI2/24.);\n    ang=ang0-mang+PI2/24.*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.73*r*cos(ang-vec2(0,1.57)))-.035*r)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,-.06,.07);\nconst vec3 bbsize=vec3(ALLW*1.12,3.63,1.5);\nconst vec3 bbpos1=vec3(0,-.0,-.11);\nconst vec3 bbsize1=vec3(ALLW*1.12,3.73,1.13);\nconst vec3 bbpos2=vec3(0,.23,.47);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#define USE_SIMDATA\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\nvec2 distCar(vec3 p)\n{\n    vec3 p0rot=p;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));\n    float d=1000., d_mat=1001., mat=-1.;\n    SET_PREV_MAT(BG);\n    p*=2.;\n    if(p.x<0.) p.x=-p.x;\n    vec3 p0=p;\n    //d=min(d,length(p)-.5);\n    p=p0+vec3(0,.1,0);\n    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, \n                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, \n                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),\n                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;\n    p=p0-vec3(0,.5,.87);\n    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.05+p.y*.07-p.y*p.y*.08+p.z*.0, \n                                       1.2-p.z*.3,\n                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),\n                               .33+.15*p.y )*.7;\n    d=min(d,dcabin);\n    // rear front screen\n    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);\n    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;\n    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...\n    float sy=step(0.,p.y);\n    float dfrontscr=sdRoundRect( p.xz-vec2(0,sy*.1), vec2(RUMPFW*.4-sy*.2,.14-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;\n    dfrontscr=max(dfrontscr,-(drumpf-.07));\n    d=-smin(-d,dfrontscr,.03);\n    //d+=rille(dfrontscr-.03,.007);\n    // side screens\n    p=p0-vec3(0,.23,.96);\n    vec3 sidebox=vec3(2.,.35-p.z*.1,.105+p.y*.008-.05*p.y*p.y*step(0.,p.z))*2.;\n    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;\n#if 0\n    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .13+.04*p.y )*.7;\n    //p.z+=.25;\n    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;\n    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.59), sidebox.yz+vec2(0,.59), .13+.04*p.y )*.7;\n#else\n    // not sure if even making 2 rects at once is really faster...\n    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;\n    float dsidescr=dssdoor.x;\n    float ddoor=dssdoor.y;\n#endif\n    ddoor-=.07;\n    p=p0-vec3(0,-2.05,.77)*1.;\n    p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));\n    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;\n    float dhood   =sdRoundRect( p.yz,vec2(.9,1.),.18)*.7;\n    d=-smin(-d,dsidescr,.05);\n    //d=-smin(-d,abs(dsidescr-.03),.02);\n    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);\n    p=p0;\n    p-=vec3(0,0,-.77);\n    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);\n    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);\n    p.z+=dz1+dz2;\n    p-=vec3(0,-.07,0);\n    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,\n    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),\n    //                            .16 )*.7;\n    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,\n                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),\n                                .16 )*.7;\n    float ss=1.-smoothstep(-3.,-1.8,p.y);\n    float fz0=p.z-dz1*(exp2(-ss*7.));\n    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);\n    dfender=max(dfender,-(fz0)*.7);\n    d=min(d,dfender);\n    SET_PREV_MAT(CARBODY);\n    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);\n    drumpf+=rille(dhood,.005);\n    //side stripe\n    p=p0+vec3(0,.1,0);\n    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));\n    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);\n    d=smin(d,drumpf,.03);\n    //d=-smin(-d,abs(ddoor),.01);\n    //d-=clamp(abs(ddoor)-.005,-0.02,0.);\n    d+=rille(ddoor,.005);\n    SET_PREV_MAT(RUMPF);\n    d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));\n    SET_PREV_MAT(TIRE);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);\n    SET_PREV_MAT(GUMMI);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);\n    SET_PREV_MAT(GRILL);\n    float z=p.z+.2;\n    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );\n    d=-smin(-d,dgrillhole,.04);\n    SET_PREV_MAT(CARBODY);\n    //SET_PREV_MAT(TIRE);\n\n    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);\n    p.x=mod(p.x+.005,.025)-.0125;\n    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3(0,.7,.87-.2);\n    d=max(d,-dcabin-.06);\n    SET_PREV_MAT(INTERIOR);\n    \n#ifdef RENDER_GLASS\n    // window glass\n    //if(enable_glass)\n    {\n        d=min(d,dcabin+.035+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n#endif\n    \n    #define PF (vec3(ALLW*.39,-1.43,-.33)*2.)\n    #define PR (vec3(ALLW*.48,1.23,-.35)*2.)\n    vec3 pf=p0-PF;\n    vec3 pr=p0-PR;\n    \n    // check tire only once\n    //bool rear = (dot(pr,pr)<dot(pf,pf));\n    float rear = step(0.,p0rot.y);\n    float left = step(0.,p0rot.x);\n    float leftSgn=sign(p0rot.x);\n    p=mix(pf,pr,rear); float siz=mix(.62,.7,rear);\n    \n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));\n#if 0\n    p+=vec3(.07,0,0);\n    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));\n    p-=vec3(.07,0,0);\n#else\n    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??\n    p=transformVecByQuat(p+vec3(.07,0,0),q)-vec3(.07,0,0);\n#endif\n\n#ifdef USE_SIMDATA\n    float rot=WheelRot.x;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n\n    d=min(d, distTire(p,siz));\n    SET_PREV_MAT(TIRE);\n    d=min(d, distRim(p,siz));\n    SET_PREV_MAT(RIM);\n    \n    p=p0;\n    float xx=p.x*p.x;\n    p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;\n    d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));\n    d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);\n    d=min(d,dDirLine(pf,vec3(-.3,.1,-.14),vec3(-.0,1,0.05),1.5)-.02);\n    SET_PREV_MAT(CHASSIS);\n    \n    p=p0-vec3(.37,-1.57,0.1)*2.;\n    float d1=1000.;\n    d1=min(d1, length(p)-.11*2.1);\n    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);\n    d=min(d,d1);\n    SET_PREV_MAT(HEADLIGHTS);\n    \n    #ifdef RENDER_BBOX\n    //if(enable_glass)\n    {\n        p=p0;\n        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n    #endif\n    \n    return vec2(d*.5,mat);\n}\n\nbool enable_car=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=.8*textureLod(iChannel0,p.xy*.00006*RND_SC,0.)+.4*textureLod(iChannel0,p.xy*.00012*RND_SC,0.);\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    return rTerr.x*min(pp*pp,40.);\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p+translate*offs,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(iChannel1,ivec2(3,0),0);\n    vec3 offs=texelFetch(iChannel1,ivec2(0,0),0).xyz;\n    offs.z=-hTerr(-offs);\n    q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)-offs*translate;\n#else\n    return p;\n#endif\n}\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    if(enable_car)\n    {\n        vec2 dm=distCar(carTrafo(p));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;\n    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;\n    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;\n    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;\n    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;\n    float rm=r3.y*1.+r4.y*.5+r5.y*.25;\n    float rm2=r3.z*.7+r4.z*.5;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    #ifdef STREET\n    float streetstep=smoothstep(4.5,5.5,abs(p.x-2.));\n    #else\n    float streetstep=0.;\n    #endif\n    d=min(d,p.z\n    +.66\n    #ifndef STREET\n    -hTerr(p)\n    #endif\n    //+.015*(r3.y-.2)\n    #ifdef WET_ASPHALT\n    +lorentz(-rm/.06/r2.x)*.05*(r2.x+.3)\n    #else\n    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035\n    #endif\n    );\n    SET_PREV_MAT(FLOOR);\n    \n    #ifdef STREET\n    d=min(d,p.z\n    +.73\n    +r2.z*.1+r.z*.01\n    -streetstep*.2\n    -hTerr(p)\n    );\n    SET_PREV_MAT(DESERT);\n    #endif\n    #ifdef WET_ASPHALT\n    d=min(d,p.z+.665+pp*16./*-.02*/);\n    SET_PREV_MAT(WATER);\n    if(mat==FLOOR) d-=r.x*.0035;\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad()\nvec3 getGrad(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\n/// klems' getGrad - slightly modified to avoid div by 0\nvec3 getGrad2(vec3 p,float delta)\n{\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    // btw very interesting function that...\n    vec4 n = vec4(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += delta;\n        n[i] = dist(s.xyz);\n    }\n    n-=n.w;\n    return n.xyz/(length(n.xyz)+.0001); // added some small epsilon to avoid division by 0\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=1000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=0;i<150;i++)\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.8;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n        if (d>300.) break;\n    }\n    return clamp(dmin/length(pmin-p0)/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=getAO(pos,n);\n    ao=sqrt(ao);\n    ao=ao*.7+.3;\n\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.85+.15;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    vec4 zzt=vec4(0);\n    {\n        vec3 p=carTrafo(pos);\n    #ifndef ZZT_AS_TEX\n \t    float sp=sign(p.x); // windows not able to compile if i substitute this directly below... [rolleyes]\n        zzt=zztop((p.yz*8.5*vec2(sp,1)-vec2(sp,.9))*vec2(1,1.-.15*p.y),sp);\n    #else\n        vec2 uv=(vec2(-1,1)*(p.yz*8.5-vec2(1,.9))*vec2(1,1.-.15*p.y)/11.+.75)*.5;\n        uv=clamp(uv,0.,1.);\n        zzt=texture(iChannel1,uv);\n    #endif\n    }\n    if(mat==RUMPF) { \n        col=mix(col,zzt.xyz,zzt.w);\n        if(zzt.xyz==vec3(1)) { fres=.6; col*=.0; }\n    }\n    //col-=n*.05;\n    \n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol,glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    if(iMouse.x<1.) { th=1.45; ph=-iTime*.25; }\n    th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=carTrafoInv(pos,1.);\n    dir=carTrafoInv(dir,0.);\n\n    if(iMouse.x<1.)\n    {\n    pos=getCamAnimPos(iTime);\n    dir=normalize(getCamAnimDir(iTime));\n    vec3 right=normalize(cross(dir,vec3(0,0,1)));\n    vec3 up=cross(right,dir);\n    dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    \n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    float fres=0., ao=0.;\n    fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    /*fres=abs(dot(dir,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;*/\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n    #endif\n    \n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    \n\tfragColor.w=1.;\n}\n\n#if 0\nvoid mainImageXX( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    float snum=0.;\n    for(int i=0;i<max(int(snum),1);i++)\n    {\n        enable_glass=true;\n        vec4 col=vec4(0);\n        vec2 r = (texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(i*5+iFrame*13,0)+.1,256.0))&255,0).xy-.5)*1.;\n        //vec2 r = getRand(i+int(fragCoord.x+fragCoord.y*iResolution.x)).xy-.5;\n        mainImageS(col,fragCoord+r*((snum>0.)?1.:0.3));\n        fragColor+=col;\n        vec4 r2=texture(iChannel0,fragCoord/Res0*.707+iTime*4.5+float(i)*.1)-.5;\n        fragColor+=.05*r2;\n    }\n    fragColor/=floor(max(snum,1.));\n}\n#endif\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some minimal driving sim (not much physics involved here, just simple driving/steering)\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#define keyTex iChannel1\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_A (texture(keyTex,vec2((65.5+ 0.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_W (texture(keyTex,vec2((65.5+22.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_R (texture(keyTex,vec2((65.5+17.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_S (texture(keyTex,vec2((65.5+18.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_D (texture(keyTex,vec2((65.5+ 3.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_F (texture(keyTex,vec2((65.5+ 5.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_PLUS  (texture(keyTex,vec2((187.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_MINUS (texture(keyTex,vec2((189.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_LEFT  (texture(keyTex,vec2(( 37.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_RIGHT (texture(keyTex,vec2(( 39.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_DOWN  (texture(keyTex,vec2(( 40.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_UP    (texture(keyTex,vec2(( 38.5)/256.0,(0.5+0.0)/3.0)).x)\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    #ifdef ZZT_AS_TEX\n    vec2 uv = fragCoord.xy / Res0;\n    fragColor = zztop((uv*2.-.75)*11.,-1.);\n    #endif\n\n    vec3 pos  =texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    vec3 vel  =texelFetch(iChannel0,ivec2(1,0),0).xyz;\n    vec3 omega=texelFetch(iChannel0,ivec2(2,0),0).xyz;\n    vec4 quat =texelFetch(iChannel0,ivec2(3,0),0);\n    float SteerAng =texelFetch(iChannel0,ivec2(4,0),0).x;\n    float camDist =texelFetch(iChannel0,ivec2(4,0),0).y;\n    vec4 wheelRot =texelFetch(iChannel0,ivec2(5,0),0);\n    float phi=quat.x;\n    \n    float dt=iTimeDelta;\n    \n    float axDist=3.5;\n    vec3 rearAxPos = vec3(0,1.7,0);\n    \n    //quat=vec4(0,0,0,1);\n    vec3 bx=transformVecByQuat(vec3(1,0,0),quat);\n    vec3 by=transformVecByQuat(vec3(0,1,0),quat);\n    \n    vel+=KEY_W*by*.25;\n    vel-=KEY_S*by*.25;\n    vel+=KEY_UP*by*.25;\n    vel-=KEY_DOWN*by*.25;\n    vel*=.99;\n    if(vel!=vec3(0)) vel-=normalize(vel)*.05;\n    if(length(vel)<.1) vel=vec3(0);\n    SteerAng*=.91;\n    SteerAng-=KEY_A*.05;\n    SteerAng+=KEY_D*.05;\n    SteerAng-=KEY_LEFT*.05;\n    SteerAng+=KEY_RIGHT*.05;\n    camDist*=(1.-.02*KEY_PLUS);\n    camDist*=(1.+.02*KEY_MINUS);\n    \n    vec3 dax=transformVecByQuat(rearAxPos,quat);\n\n    bool noSteer =  (abs(SteerAng)<.0001);\n    float r=axDist/tan(SteerAng);\n    if(noSteer) r=10000.;\n    vec3 c=pos-dax+bx*r;\n    vec3 ang=cross(-vel*dt,pos-c)/dot(pos-c,pos-c);\n    vec4 dquat=angVec2Quat(ang);\n    float wheelRadius=0.3;\n    wheelRot+=-dot(vel,by)*dt/wheelRadius;\n    \n    if(isnan(dquat.x)) dquat=vec4(0,0,0,1);\n    if(isnan(dquat.y)) dquat=vec4(0,0,0,1);\n    if(isnan(dquat.z)) dquat=vec4(0,0,0,1);\n    if(isnan(dquat.w)) dquat=vec4(0,0,0,1);\n    if(noSteer) dquat=vec4(0,0,0,1);\n    pos=c+transformVecByQuat(pos-c,dquat);\n    if(noSteer) pos+=vel*dt;\n    vel=transformVecByQuat(vel,dquat);\n    quat=multQuat(quat,dquat);\n    \n    if(iFrame==0)\n    {\n        pos=vec3(0,0,0);\n        vel=vec3(0,0,0);\n        quat=vec4(0,0,0,1);\n        SteerAng=0.;\n        wheelRot=vec4(0);\n        camDist=1.;\n    }\n    \n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor = vec4(pos,1.0);\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor = vec4(vel,1.0);\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor = vec4(omega,1.0);\n    if (ivec2(fragCoord)==ivec2(3,0)) fragColor = vec4(quat);\n    if (ivec2(fragCoord)==ivec2(4,0)) fragColor = vec4(SteerAng,camDist,0,1);\n    if (ivec2(fragCoord)==ivec2(5,0)) fragColor = vec4(wheelRot);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop ford eliminator\n\n// helper functions\n\n//uncomment to precalc logo as texture\n//#define ZZT_AS_TEX\n\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n/////////////// iq's distance funs\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )  // variation - eval 2 boxes at once\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )   // variation - clamped box\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n#if 0\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    //vec3 n=cross(cross(dir,p),dir);\n    //return length(p-dot(p,n)*n/dot(n,n))<size.y;\n\n    //return true;\n    \n    size*=.5;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    \n    vec3 s=sign(dir);\n    vec3 invdir=1./dir;\n\n    tmin  = (-size.x*s.x - p.x) * invdir.x; \n    tmax  = ( size.x*s.x - p.x) * invdir.x; \n    tymin = (-size.y*s.y - p.y) * invdir.y; \n    tymax = ( size.y*s.y - p.y) * invdir.y; \n \n    if ((tmin > tymax) || (tymin > tmax)) return false; \n    if (tymin > tmin) tmin = tymin; \n    if (tymax < tmax) tmax = tymax; \n \n    tzmin = (-size.z*s.z - p.z) * invdir.z; \n    tzmax = ( size.z*s.z - p.z) * invdir.z; \n \n    if ((tmin > tzmax) || (tzmin > tmax)) return false; \n    if (tzmin > tmin) tmin = tzmin; \n    if (tzmax < tmax) tmax = tzmax; \n \n    return true; \n}\n#endif\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nfloat zmask(vec2 p)\n{\n    float skew=1.;\n    p.x += skew*p.y;\n    return step(p.y,step(-.35,p.x)-.5+.1)\n          -step(p.y,step( .35,p.x)-.5-.1);\n}\n\nvec4 zztop(vec2 p, float s_)\n{\n    float s=-1.;\n    p.x=-p.x;\n    vec2 p0=p;\n    p0*=-s_;\n    float s1=step(-12.6+2.9+2.9*s,-s_*((p.x)+s*.17*p0.y));\n    float z1 = zmask(p0+vec2(.25,.1))*step(-3.5,-p0.x-p0.y)*s1;\n    float d1=-.25*p.y+z1;\n    float z2 = zmask(p0-vec2(.25,.1))*step(-6.,-p0.x-p0.y)*s1;\n    float d2=.25*p.y+z2;\n    float bgm=step(0.,-s_*s*p.x)*step(-.7,-abs(p.y));\n    p.y=abs(p.y);\n    bgm=max(bgm,step(.5,exp(-(p.y-.8)*(p.y-.8)/.017)));\n    bgm*=step(-29.,-s_*(s*(p.x)-30.*p0.y));\n    bgm*=step(-15.,-s_*(s*(p.x)+15.*p0.y));\n    bgm*=step(-12.75,-s_*(-s*(p.x)-.17*p0.y));\n    vec4 bg=vec4(.5);\n    bg=clamp(bg,0.,1.);\n    vec4 col=vec4(.5,0,0,1);\n    if(d2<d1) col=vec4(1,.8,0,1);\n    col = mix(vec4(bgm),col,max(z1,z2));\n    col.w=max(bgm,max(z1,z2));\n    return col;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}