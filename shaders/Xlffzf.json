{
    "Shader": {
        "info": {
            "date": "1512632694",
            "description": "Variant of [url]https://www.shadertoy.com/view/Xtlfz2[/url]\n\nThis one is a surface discovered by Oliver Labs. The texturing is done by central projection onto an octahedron.",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlffzf",
            "likes": 10,
            "name": "Labs Surface",
            "published": 3,
            "tags": [
                "texturing",
                "surface",
                "algebraic",
                "labs"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 735
        },
        "renderpass": [
            {
                "code": "//#define FAST\n#define QUALITY\n\n//#define MIRROR\n    \nbool doGamma = true;\nbool doSpecular = true;\nbool doDiffuse = true;\nconst float ambient = 0.5;\nconst float diffuse = 0.5;\nfloat specularPower = 4.0;\n\n\nconst vec3 defaultColor = vec3(0.7,1.0,1.0);\n\nconst float PI =  3.141592654;\nconst float TWOPI = 2.0*PI;\nconst float two31 = 2147483648.0;\nconst float phi = 1.618033;\nconst float phi2 = phi*phi;\nconst float phi4 = phi2*phi2;\n\n\nvec3 light;\nmat3 iMatrix;\n\n// Quaternion multiplication as a matrix.\n// w coordinate is real element of quaternion\nmat4 qmat(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y, x, \n               z, t,-x, y,\n              -y, x, t, z,\n              -x,-y,-z, t );\n}\n\nfloat Sphere(vec4 p) {\n  vec4 a = vec4(1.0,1.0,1.0,-2.0);\n  return dot(a*p,p);\n}\n\nfloat T6(float x) {\n   return -1.0+x*x*(18.0+x*x*(-48.0+x*x*32.0));\n}\n\nfloat Chmutov6(vec4 p) {\n  p *= 0.5;\n  float x = p.x; float y = p.y;\n  float z = p.z; float w = p.w;\n  return T6(x)+T6(y)+T6(z)+1.0;\n}\n\n// The following functions for various surfaces are\n// taken from Abdelaziz Nait Merzouk's Fragmentarium\n// shaders.\n// https://plus.google.com/114982179961753756261\n\nfloat Labs(vec4 p) {\n  float x = p.x;\n  float y = p.y;\n  float z = p.z;\n  float w = p.w;\n  // float a = -0.140106854987125;//the real root of 7*a^3+7*a+1=0\n  // Constants\n  float a1= -0.0785282014969835;//(-12./7.*a-384./49.)*a-8./7.;\n  float a2= -4.1583605922880200;//(-32./7.*a+24./49.)*a-4.; \n  float a3= -4.1471434889655100;//(-4.*a+24./49.)*a-4.;\n  float a4= -1.1881659380714800;//(-8./7.*a+8./49.)*a-8./7.; \n  float a5= 51.9426145948147000;//(49.*a-7.)*a+50.;\n  float x2 = x*x,y2 = y*y,z2 = z*z,w2 = w*w;\n  float r2= x2+y2;\n  float U = (z+w)*r2+(a1*z+a2*w)*z2+(a3*z+a4*w)*w2;\n  U = (z+a5*w)*U*U;\n  float P = x*((x2-3.0*7.0*y2)*x2*x2+(5.0*7.0*x2-7.0*y2)*y2*y2);\n  P += z*(7.0*(((r2-8.0*z2)*r2+16.0*z2*z2)*r2)-64.0*z2*z2*z2);\n  return U-P;\n}\n\nfloat Endrass8(vec4 p){\n  float x = p.x;\n  float y = p.y;\n  float z = p.z;\n  float w = p.w;\n  float x2 = x*x,y2 = y*y,z2 = z*z,w2 = w*w;\n  float r2 = x2+y2;\n  float U = 64.0*(x2-w2)*(y2-w2)*((x+y)*(x+y)-2.0*w2)*((x-y)*(x-y)-2.0*w2);\n  float V = -4.0*(1.0+sqrt(2.0))*r2*r2+(8.0*(2.0+sqrt(2.0))*z2+2.0*(2.0+7.0*sqrt(2.0))*w2)*r2;\n  V = V + z2*(-16.0*z2+8.0*(1.0-2.0*sqrt(2.0))*w2) - (1.0+12.0*sqrt(2.0))*w2*w2;\n  return V*V-U;\n}\n\nfloat Barth10(vec4 p){//decic\n  float r2 = dot(p.xyz,p.xyz);\n  vec4 p2 = p*p;\n  float r4 = dot(p2.xyz,p2.xyz);\n  vec4 p4 = p2*p2;\n  return (8.0*(p2.x-phi4*p2.y)*(p2.y-phi4*p2.z)*(p2.z-phi4*p2.x)*(r4-2.0*((p.x*p.y)*(p.x*p.y)+(p.x*p.z)*(p.x*p.z)+(p.y*p.z)*(p.y*p.z)))+(3.0+5.0*phi)*(r2-p2.w)*(r2-p2.w)*(r2-(2.0-phi)*p2.w)*(r2-(2.0-phi)*p2.w)*p2.w);\n}\n\n//   Dodecics\nfloat Sarti12(vec4 p){\n  vec4 p2 = p*p;\n  vec4 p4 = p2*p2;\n  float l1 = dot(p2,p2);\n  float l2 = p2.x*p2.y+p2.z*p2.w;\n  float l3 = p2.x*p2.z+p2.y*p2.w;\n  float l4 = p2.y*p2.z+p2.x*p2.w;\n  float l5 = p.x*p.y*p.z*p.w;\n  float s10 = l1*(l2*l3+l2*l4+l3*l4), s11 = l1*l1*(l2+l3+l4);\n  float s12=l1*(l2*l2+l3*l3+l4*l4),    s51=l5*l5*(l2+l3+l4),  s234=l2*l2*l2+l3*l3*l3+l4*l4*l4;\n  float s23p=l2*(l2+l3)*l3,   s23m=l2*(l2-l3)*l3; \n  float s34p=l3*(l3+l4)*l4,       s34m=l3*(l3-l4)*l4; \n  float s42p=l4*(l4+l2)*l2,       s42m=l4*(l4-l2)*l2;\n  float Q12=dot(p,p); Q12=Q12*Q12*Q12; Q12=Q12*Q12; \n  float S12=33.*sqrt(5.)*(s23m+s34m+s42m)+19.*(s23p+s34p+s42p)+10.*s234-14.*s10+2.*s11-6.*s12-352.*s51+336.*l5*l5*l1+48.*l2*l3*l4;\n  return 22.*Q12-243.*S12;\n}\n\nfloat Kummer(vec4 P) {\n  float A = sqrt(2.0);\n  float mu2 = 0.334 + 3.0*(1.0-cos(0.2*iTime));\n  float x = P.x; float y = P.y;\n  float z = P.z; float w = P.w;\n  float p = w-z-A*x;\n  float q = w-z+A*x;\n  float r = w+z+A*y;\n  float s = w+z-A*y;\n  float lambda = (3.0*mu2-1.0)/(3.0-mu2);\n  float k = x*x + y*y + z*z - mu2*w*w;\n  return k*k-lambda*p*q*r*s;\n}\n\nvec4 transform(vec4 p) {\n  //return p;\n  float k = 0.1*iTime;\n  mat4 m = qmat(vec4(0.0,0.0,sin(k),cos(k)));\n  p = m*p;\n  return p;\n}\n\nfloat Fun(vec4 p) {\n  p = transform(p);\n  //return Sphere(p);\n  return Labs(p);\n  //return Endrass8(p);\n  //return Barth10(p);\n  //return Sarti12(p);\n  //return Chmutov6(p);\n  //return Kummer(p);\n}\n\nconst int ctype = 1;\n\nvec3 selectColor(vec4 q, vec3 eye, vec3 n) {\n  q = transform(q);\n  //if (colorswap) q = ctransform(q, 1.570796);\n  //if (coffset != 0.0) q = ctransform(q,coffset);\n\n#if 1\n  float x = q.x, y = q.y, z = q.z, w = q.w;   \n    float uxfact = 1.0;\n    float uoffset = 0.0;\n    float voffset = 0.0;\n    // Octamap\n    vec3 c = normalize(vec3(1.0,1.0,1.0));\n    vec3 u = normalize(cross(c,vec3(0.0,1.0,0.0)));\n    vec3 v = normalize(cross(c,u));\n    // Taking abs of all coordinates reflects everything\n    // into main octant.\n    vec3 p = vec3(abs(x/w),abs(y/w),abs(z/w));\n    //vec3 p = normalize(vec3(abs(x),abs(y),abs(z)));\n    p /= 1.0/dot(p,c); // Central projection\n    vec2 texCoords = uxfact*vec2(dot(p,u)+uoffset,dot(p,v)+voffset);\n    vec3 col = texture(iChannel0,texCoords).rgb;\n    return col;\n#elif !defined MIRROR\n  return defaultColor;\n#else\n  // The ShaderToy cubemaps are quite high contrast, which\n  // tends to emphasise edge artefacts, so mute a little.\n  vec3 color = texture(iChannel0,reflect(eye,n)*iMatrix).rgb;\n  return min(vec3(0.75),sqrt(color));\n#endif\n}\n\n// Solution parameters.\n#if defined FAST\nconst int iterations = 100;    // Maximum number of iterations\nconst float maxincrease = 1.1; // Largest allowed step increase.\n#elif defined QUALITY\nconst int iterations = 300;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\n#else\nconst int iterations = 150;    // Maximum number of iterations\nconst float maxincrease = 1.06; // Largest allowed step increase.\n#endif\n\nconst float maxstep = 1.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\n\nvoid solve(out vec4 fragColor, vec4 p0, vec4 r) {\n  float k0 = 0.0, k1;\n  float a0 = Fun(p0), a1;\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec4 p;\n  float expected = 0.0;\n  for (int i = 0; i < iterations; i++) {\n    if (bracketed) {\n      // Once we are bracketed, just use bisection\n      if (k1-k0 < minstep) {\n        found = true;\n        break;\n      }\n      float k2 = (k0 + k1)/2.0;\n      //x = x0+k2*a, y = y0+k2*b, z = z0+k2*c, w = 1.0;\n      p = p0+k2*r;\n      float a2 = Fun(p);\n      if (a0*a2 <= 0.0) {\n        k1 = k2; a1 = a2;\n      } else {\n        k0 = k2; a0 = a2;\n      }\n    } else {\n      k1 = k0 + step;\n      p = p0 + k1*r;\n      a1 = Fun(p);\n      //The idea here is to try and correct the\n      // step size by seeing how close we are to\n      // the curve, but it doesn't seem to work\n      // very well.\n      float q = abs((a1-expected)/(a1+expected));\n      if (false && expected != 0.0 && q > 0.25) {\n        step *= 0.5;\n        expected = a0 + 0.5*(expected - a0);\n      } else if (a0*a1 <= 0.0) {\n        // We can hit exactly 0 - this counts as bracketed.\n        bracketed = true;\n      } else {\n        float step0 = step;\n        step = a1*step/(a0-a1);\n        step = abs(step);\n        step = min(step,maxstep);\n        // Don't grow step by more than a certain amount\n        // A better strategy should be possible\n        // Detect overstepping & retreat maybe.\n        step = max(step,minstep);\n        step = min(step,maxincrease*step0);\n        if (a1 <= a0) expected = 0.0;\n        else expected = a1 + step*(a1-a0)/(k1-k0);\n        k0 = k1; a0 = a1;\n      }\n    }\n  }\n  if (!found) {\n    fragColor = vec4(0,0,0,1);\n    return;\n  }\n\n  // Compute gradient & normal\n  // Should probably scale eps here\n  float eps = 1e-3;\n  vec2 delta = vec2(eps,0.0);\n#if 0\n  p = p0 + k0*r; // Ensure p corresponds to k0 and a0\n  vec3 n = vec3(Fun(p + delta.xyyy), Fun(p + delta.yxyy), Fun(p + delta.yyxy)) - a0;\n#else\n  // Not sure how much difference this makes\n  vec3 n = vec3(Fun(p + delta.xyyy) - Fun(p - delta.xyyy),\n                Fun(p + delta.yxyy) - Fun(p - delta.yxyy),\n                Fun(p + delta.yyxy) - Fun(p - delta.yyxy));\n#endif\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  vec3 eye = r.xyz;\n  // Point normal towards eye\n  if (dot(eye,n) > 0.0) n *= -1.0;\n  vec3 baseColor = selectColor(p,eye,n);\n  vec3 color = baseColor;\n#if !defined MIRROR\n  color *= ambient;\n  float k = dot(light,n);\n  if (doDiffuse && k > 0.0) {\n    color += baseColor*diffuse*k;\n  }\n  if (doSpecular && k > 0.0) {\n    float specular = pow(max(0.0,dot(reflect(light,n),eye)),4.0);\n    color += 0.8*specular*vec3(1);\n  }\n  if (doGamma) {\n    color = sqrt(color);\n  }\n#endif\n  fragColor = vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  light = normalize(vec3(0.5,1,1));\n\n  // Projection parameters\n  float camera = 10.0;\n\n  float scale = 5.0;\n  float x = scale * (fragCoord.x - 0.5*iResolution.x)/iResolution.y;\n  float y = scale * (fragCoord.y - 0.5*iResolution.y)/iResolution.y;\n\n  vec3 p0 = vec3(0.0,0.0,camera);\n  vec3 r = normalize(vec3(x,y,-camera));\n\n  // Rotate camera according to mouse position\n  float xrot = 0.0; // About x-axis\n  float yrot = 0.0; // About y-axis\n  if (iMouse.x > 0.0) {\n    yrot = TWOPI*(iMouse.x-0.5*iResolution.x)/iResolution.x;\n    xrot = TWOPI*(iMouse.y-0.5*iResolution.y)/iResolution.y;\n  }\n  mat3 mx = mat3(1,0,0,\n                 0,cos(xrot),sin(xrot),\n                 0,-sin(xrot),cos(xrot));\n  mat3 my = mat3(cos(yrot),0,sin(yrot),\n                 0,1,0,\n                 -sin(yrot),0,cos(yrot));\n  iMatrix = my*mx;\n\n  p0 = iMatrix*p0;\n  r = iMatrix*r;\n  light = iMatrix*light; // Light moves with camera\n  \n  solve(fragColor,vec4(p0,1),vec4(r,0));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}