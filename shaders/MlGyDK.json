{
    "Shader": {
        "info": {
            "date": "1537732768",
            "description": "Experimenting with transparent materials.\n\nRefraction from tdhooper's Dispersion: https://www.shadertoy.com/view/XlscDH\nThe heart comes from iq: https://www.shadertoy.com/view/4lK3Rc",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGyDK",
            "likes": 2,
            "name": "Dark HeartBeat",
            "published": 3,
            "tags": [
                "refraction",
                "glass",
                "heart"
            ],
            "usePreview": 0,
            "username": "cold_code",
            "viewed": 720
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2018 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nconst vec3[4] palette = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\nconst vec3[4] spectrum = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                 vec3(1.0, 1.0, 1.0), vec3(0.0, 0.33, 0.67));\nconst float _2PI = 6.28318;\nconst float _PI_2 = 1.570796;\n\nstruct Hit {\n  float dist;\n  int object;\n  vec3 normal;\n  vec3 pos;\n};\n\nstruct Material {\n  bool transparent;\n  float refractiveIndex;\n  vec3 color;\n  float dispersion;\n};\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t, in vec3[4] pal) {\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nMaterial getMaterial(int object) {\n  switch (object) {\n  case 0:\n    return Material(false, 0., vec3(0.), 0.);\n  case 1:\n    return Material(true, 1. / 1.6, vec3(0.), .85);\n  case 2:\n    return Material(false, 0.,\n                    pal(_2PI * sin(iTime * _2PI / 100.) + 1., palette), 0.);\n  }\n}\n\nstruct Shape {\n  float dist;\n  int object;\n};\n\nShape opU(Shape h1, Shape h2) {\n  if (h1.dist < h2.dist) {\n    return h1;\n  }\n  return h2;\n}\n\n// https://www.shadertoy.com/view/4lK3Rc\nShape sdHeart(vec3 p) {\n  vec3 q = p * 50.;\n  float r = 15.;\n  q.y -= r;\n  float ani = pow(0.5 + 0.5 * sin(_2PI * iTime + q.y / 25.0), 4.0);\n  q *= 1.0 - 0.2 * vec3(1.0, 0.5, 1.0) * ani;\n  q.y -= 1.5;\n  q.x = abs(q.x);\n  q.y = 4. + 1.2 * q.y - q.x * sqrt(max((20. - q.x) / 15., 0.));\n  q.z *= 2.0 - q.y / 15.;\n  float d = sqrt(q.x * q.x + q.y * q.y + q.z * q.z) - r;\n  d /= 3.;\n  d /= 100.;\n  vec3 normal = normalize(p);\n  return Shape(d, 1);\n}\n\nShape sdCylinder(vec3 p, float r) {\n  float d = length(p.xz) - r;\n  vec3 normal = normalize(p * vec3(1., 0., 1.));\n  return Shape(d, 2);\n}\n\nShape repCylinder(vec3 p, in vec3 c) {\n  vec3 q = mod(p, c) - .5 * c;\n  return sdCylinder(q, .1);\n}\n\nHit map(in vec3 pos) {\n  Shape res = sdHeart(pos - vec3(0., 2., 0.));\n  res = opU(res, repCylinder(pos - vec3(0., .0, 0.), vec3(4., 0., 4.)));\n\n  return Hit(res.dist, res.object, vec3(0.), pos);\n}\n\nvec3 calcNormal(in vec3 pos) {\n  vec3 eps = vec3(0.005, 0.0, 0.0);\n  return normalize(vec3(map(pos + eps.xyy).dist - map(pos - eps.xyy).dist,\n                        map(pos + eps.yxy).dist - map(pos - eps.yxy).dist,\n                        map(pos + eps.yyx).dist - map(pos - eps.yyx).dist));\n}\n\nHit castRay(vec3 ro, vec3 rd) {\n  float precis = .0005;\n  float sceneDist = 2. * precis;\n  float maxRayDist = 20.;\n  Hit rayHit = Hit(0., 0, vec3(0.), ro);\n\n  for (int i = 0; i < 128; ++i) {\n    if (sceneDist < precis || rayHit.dist > maxRayDist)\n      break;\n    rayHit.pos = ro + rd * rayHit.dist;\n    Hit lhit = map(rayHit.pos);\n    sceneDist = lhit.dist;\n    rayHit.dist += sceneDist;\n    rayHit.object = lhit.object;\n  }\n  if (rayHit.dist > maxRayDist) {\n    rayHit.dist = maxRayDist;\n    rayHit.object = 0;\n    rayHit.normal = vec3(0.);\n  }\n\n  rayHit.normal = calcNormal(rayHit.pos);\n  return rayHit;\n}\n\n#define DISPERSION_SAMPLES 40.\n#define REFRACTION_BOUNCES 3.\n\nHit marchTransparent(Hit hit, float wavelength, Material mat, vec3 rd,\n                     vec3 nor) {\n  vec3 rayDirection = rd;\n  vec3 normal = nor;\n  Material material = mat;\n  for (float i = 0.; i < REFRACTION_BOUNCES; ++i) {\n    if (!material.transparent) {\n      return hit;\n    }\n    // Adjust refractive index for wavelength and dispersion amount\n    float refractiveIndex = material.refractiveIndex;\n    float riMin = refractiveIndex;\n    float riMax = refractiveIndex * (1. + mat.dispersion);\n    refractiveIndex = mix(riMin, riMax, wavelength);\n    refractiveIndex = 1. / refractiveIndex;\n\n    vec3 rayDirection = refract(rayDirection, normal, refractiveIndex);\n\n    // Move away from the surface before marching\n    float separation = 0.01;\n    float startDistance = separation / abs(dot(rayDirection, normal));\n\n    vec3 rayOrigin = hit.pos + startDistance * rayDirection;\n    hit = castRay(rayOrigin, rayDirection);\n    material = getMaterial(hit.object);\n  }\n}\n\n// https://www.shadertoy.com/view/XlscDH\n#define WAVELENGTH_BLEND_MULTIPLIER 100.\nvec3 shadeTransparent(Hit hit, Material mat, vec3 rd, vec3 nor) {\n  float wavelength;\n  vec3 sampleColor;\n  vec3 color = vec3(0);\n\n  // March for each wavelength and blend together\n  for (float r = 0.; r < DISPERSION_SAMPLES; r++) {\n    wavelength = r / DISPERSION_SAMPLES;\n    Hit hit2 = marchTransparent(hit, wavelength, mat, rd, nor);\n    sampleColor = getMaterial(hit2.object).color * pal(wavelength, spectrum);\n    // I don't have a model for correctly blending wavelengths together\n    // so there's a fudge multiplier to stop the result going grey\n    sampleColor /= DISPERSION_SAMPLES / WAVELENGTH_BLEND_MULTIPLIER;\n    color += sampleColor;\n  }\n\n  return color;\n}\n\n// https://www.shadertoy.com/view/Xs3GRB\nvec3 sky_color(vec3 ray_dir, vec3 light_dir) {\n  float d = max(0., dot(ray_dir, light_dir));\n  float d2 = light_dir.y * .7 + .3;\n  vec3 base_col;\n  base_col = mix(vec3(.3), vec3((ray_dir.y < 0.) ? 0. : 1.), abs(ray_dir.y));\n  return base_col * d2;\n}\n\nconst float fog_density = .15;\n\nvec3 render(vec3 ro, vec3 rd, vec3 ta) {\n  Hit hit = castRay(ro, rd);\n  vec3 nor = hit.normal;\n  Material mat = getMaterial(hit.object);\n  if (hit.object == 2)\n    return vec3(0.);\n  vec3 col = vec3(0.);\n  if (!mat.transparent) {\n    col = mat.color;\n  } else {\n    col = shadeTransparent(hit, mat, rd, nor);\n  }\n  vec3 lig = rd;\n  vec3 fog_color = sky_color(rd, lig);\n\n  float dif = clamp(dot(nor, -lig), 0.0, 1.0);\n  vec3 lin = vec3(0.);\n  lin += dif;\n\n  float fog_dist = hit.dist;\n  float fog = 1.0 - 1.0 / exp(fog_dist * fog_density *\n                              pow(dot(normalize(ta - ro), rd), 50.));\n  col *= lin;\n  col = mix(col, fog_color, fog);\n\n  return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = normalize(cross(cu, cw));\n  return mat3(cu, cv, cw);\n}\n\nfloat gain(float x, float k) {\n  float a = 0.5 * pow(2.0 * ((x < 0.5) ? x : 1.0 - x), k);\n  return (x < 0.5) ? a : 1.0 - a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n  float mouse =\n      _2PI * gain(fract(iTime / 5.),\n                  2.); // 7. * iMouse.x / iResolution.x; // - vec2(.5);\n  float r = 2.5;\n\n  vec3 ro = vec3(r * sin(mouse), 2., r * cos(mouse));\n  vec3 ta = vec3(0., 2.50, 0.);\n  mat3 ca = setCamera(ro, ta, 0.);\n  vec3 rd = ca * normalize(vec3(uv.xy, 3.5));\n\n  fragColor = vec4(render(ro, rd, ta), 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}