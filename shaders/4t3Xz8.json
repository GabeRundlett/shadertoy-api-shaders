{
    "Shader": {
        "info": {
            "date": "1478061386",
            "description": "The Best Shader Among My Other Shaders That I Am Making: Ice Ambience!\n10/20/2018\n - Changed lighting, noise, and ice bergs. It's sort of ugly but not too bad.\ndo you like the crystal shards for 4.0?",
            "flags": 56,
            "hasliked": 0,
            "id": "4t3Xz8",
            "likes": 12,
            "name": "Ice Ambience v.3.4",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "raycasting",
                "ambient",
                "snow",
                "virtualreality"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 1679
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = vec4(0.);\n    //vec2 offset = vec2(0.01, 0.);\n    vec2 offset = vec2(cos(iTime*2.)/100., sin(iTime*2.)/100.);\n    col.r = texture(iChannel0, uv+offset.xy).r;\n    col.g = texture(iChannel0, uv).g;\n    col.b = texture(iChannel0, uv+offset.yx).b;\n    //uv = uv * 2.0 - 1.0;\n    float duc = distance(uv, vec2(0.5))/sqrt(0.5)/5.;\n    duc *= duc/2.;\n    vec4 col1 = texture(iChannel0, uv+vec2(duc,0.00))+\n        texture(iChannel0, uv+vec2(0.000,duc))+\n        texture(iChannel0, uv+vec2(duc,duc))+\n        texture(iChannel0, uv+vec2(0.00,0.0));\n    col1 /= 4.;\n    col = mix(col, col1, 0.5);\n    fragColor = col;\n    fragColor *= smoothstep(0., 1., (iTime-0.5));\n    fragColor += vec4(clamp(texture(iChannel1, uv).r,0.,1.))/8.;\n    //fragColor = texture(iChannel2, uv);\n//fragColor = vec4(iMouse.zw/iResolution.xy, 0., 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\nMusic made in MuseScore by me\n\nNote name to note number code via Javascript: (also made by me, can use in console to make your own music)\n\n\tfunction noteToNum(ns) {\n\t    var o = parseInt(ns.charAt(ns.length-1));\n\t\tvar f = 1+12*o;\n\t\tvar m = 'c c# d d# e f f# g g# a a# b'.split(' ');\n\t\tvar t = ns.substring(0, ns.length-1).toLowerCase();\n\t\treturn f+m.indexOf(t)-9;\n\t}\n\ne.g. noteToNum('A4') -> 49\n     noteToNum('D3') -> 30\n\n*/\n\nstruct sEnvelopeADSR {\n    float attackTime;\n    float decayTime;\n    float releaseTime;\n    float sustainAmp;\n    float startAmp;\n    float triggerOnTime;\n    float triggerOffTime;\n    bool noteOn;\n};\nfloat getEnvAmpADSR(sEnvelopeADSR env, float rt){\n    float amp = 0.0;\n    if(env.noteOn) {\n    \tif(rt <= env.attackTime) amp = rt / env.attackTime * env.startAmp;\n        if(rt > env.attackTime && rt <= env.decayTime+env.attackTime) amp = (rt - env.attackTime) / env.decayTime * (env.sustainAmp - env.startAmp) * env.startAmp;\n    \tif(rt > env.attackTime + env.decayTime) amp = env.sustainAmp;\n    } else {\n        amp = (rt - env.triggerOffTime) / env.releaseTime * -env.sustainAmp + env.sustainAmp;\n        if(amp < 0.0001) amp = 0.;\n    }\n    return amp;\n}\n\nsEnvelopeADSR expenv = sEnvelopeADSR(0.6, 0.6, 0.2, 0.9, 0.01, 0., 0., true);\n//sound -> TAU * freq * time\n#define TAU 6.28318\n\nfloat note(int numa) {\n    float num = float(numa);\n    // formula from https://en.wikipedia.org/wiki/Piano_key_frequencies\n    float power = (num-49.)/12.;\n    float factor = pow(2., power);\n    return factor*440.;\n}\n\n//Moonlight Sonata but its really short and bad\n\nint[] righthand = int[] (36, 41, 44, 36, 41, 44, 36, 41, 44, 36, 41, 44,\n                      36, 41, 44, 36, 41, 44, 36, 41, 44, 36, 41, 44,\n                      37, 41, 44, 37, 41, 44, 37, 42, 46, 37, 42, 46,\n                      36, 40, 46, 36, 41, 44, 36, 41, 43, 34, 40, 43);\n\nint[] lefthand = int[] (17, 17,\n                        15, 15,\n                        13, 10,\n                        12, 12,\n                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n                        0,0,0,0,0,0,0,0);\n//Something\n/*\nint[] lefthand = int[] (15, 34, 39, 27, 34, 39, 13, 30, 34, 13, 30, 34,\n                        11, 27, 30, 23, 27, 30, 10, 26, 29, 10, 26, 34,\n                        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\nint[] righthand = int[] (59, 58, 56, 58, 56, 54, 51, 54, 58, 63, 58, 54,\n                         65, 58, 54, 58, 63, 58, 61, 58, 54, 58, 61, 49,\n                         59, 58, 56, 58, 56, 54, 51, 54, 58, 66, 63, 58,\n                         65, 62, 58, 62, 58, 53, 65, 62, 58, 62, 65, 70);\n*/\n\n\n//int[] music = int[] (50, 40, 30, 20, 10);\n\n\nfloat playMusic(float t, float rtime, int[48] m, int noteoffset, float speed) {\n    int fTime = int(floor(t));\n    int noteNumber = m[fTime]+noteoffset;\n    float freq = note(noteNumber);\n    //float modt = mod(rtime*2., 20.);\n    float modt = mod(t/speed, 1.);\n    float pres = sin(TAU*freq*modt);\n    return pres;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //1. = 100%\n    float volume = 0.1;\n    float res = playMusic(mod(time/3., 8.), time, lefthand, 12, 1./3.);\n    float res1 = playMusic(mod(time*2., 48.), time, righthand, 0, 2.);\n    return vec2((res+res1)*volume);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            },
            {
                "code": "\n\n\n\n\n//#define MEDIUMD\n//#define HIGHD\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1, 1, 1); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1, 1, 1), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1, 1, 1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(.5, .5, .5, .5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0, 0, 0, 0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(.5, .5, .5, .5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0, 0, 0, 0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\nfloat size = 4.;\nfloat VoxelSize            = 0.5;  \nconst vec4 CLOUD_COLOR     = vec4(0.5, 0.3, 0.1, 1.0);\nconst vec4 CC              = CLOUD_COLOR + 0.3;\n\nfloat Hash(vec2 p)\n{\n    float h = dot(p, vec2(17.1, 311.7));\n    return 1.0 - 2.0 * fract(sin(h) * 4358.5453);\n}\n\nfloat Noise(vec2 p, float x)\n{\n    vec2 i = sin(floor(p))*x;\n    i += floor(p)*(1.0-x);\n    vec2 f = fract(p);\n    vec2 u = (f * f * (3.0 - 2.0 * f));\n    \n    return mix(mix(Hash(i + vec2(0.0, 0.0)),\n                   Hash(i + vec2(1.0, 0.0)), u.x),\n               mix(Hash(i + vec2(0.0, 1.0)),\n                   Hash(i + vec2(1.0, 1.0)), u.x), u.y);\n \n}\n\nvec2 VecNoise(vec2 point)\n{\n    vec2 res;\n    res.x = Noise(point,0.0);\n    res.y = Noise(point + vec2(iTime),0.0);\n    return res;\n}\n\n\n\nfloat FbmNoise(vec2 p)\n{\n  const float octaves = 8.0;\n  const float lacunarity = 2.0;\n  const float H = 0.5;\n\n  float value = 0.0, k = 0.0;\n  for (float i = 0.0; i < octaves; ++ i) {\n    value += Noise(p,0.0) * pow(lacunarity, -H * i);\n    p *= lacunarity;\n    ++k;\n  }\n\n  float remainder = fract(octaves);\n  if (remainder >= 0.0) {\n    value -= remainder * Noise(p,0.0) - pow(lacunarity, -H * k);\n  }\n  return value;\n}\nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n// 2d noise function\n/*\nfloat noise(vec2 p)\n{\n  return textureLod(iChannel0,p*vec2(1./256.),0.0).x;\n}\n*/\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n// Fractional Brownian motion\nfloat fbm( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.1;\n  f += 0.2500*noise( p ); p = m*p*1.2;\n  f += 0.1666*noise( p ); p = m*p;\n  f += 0.0834*noise( p );\n  return f;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\n// Fractional Brownian motion\n/*float fbm( vec2 p )\n{\n  float f = 0.5000*noise( p ); p = m2*p;\n  f += 0.2500*noise( p ); p = m2*p;\n  f += 0.1666*noise( p ); p = m2*p;\n  f += 0.0834*noise( p );\n  return f;\n}*/\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n\n    return (a*t + b)*t*t + n;\n}\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\nfloat expStep( float x, float k, float n )\n{\n    return exp( -k*pow(x,n) );\n}\nfloat parabola( float x, float k )\n{\n    return pow( 4.0*x*(1.0-x), k );\n}\n\t\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n//Use These Functions Above & Below In Such A Way To Shape -- iq\nfloat sdPlane( vec3 p )\n{\n\treturn p.y-noise(p/4.+iTime)/4.-noise(p.zyx/7.+iTime/1.5)/4.-(sin(p.x-iTime*7.)/3.+sin(p.z+iTime/3.)/19.)/8.;\n    if(p.y <= 0.0) return p.y;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-r;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat hash3(vec3 p)\n{\n    float h = dot(p, vec3(17.1, 311.7, 606.3));\n    return -1.0 + 2.0 * fract(sin(h)*4358.5453);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\nfloat blend (float a, float b, float k) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\nfloat maxComp(vec2 a)\n{\n    return max(a.x,a.y);\n}\nfloat maxComp(vec3 a)\n{\n    return max(max(a.x,a.y),a.z);\n}\nfloat maxComp(vec4 a)\n{\n    return max(max(a.x,a.y),max(a.z, a.w));\n}\nvec2 blend(vec2 x, vec2 y, float k)\n{\n    float f = (x.x<y.x) ? x.y : y.y;\n    return vec2(blend(x.x, y.x, k),f);\n}\nvec2 map(vec3 pos)\n{\n    //float roundness = .15;\n  \t//float rot = 1.;\n\t//vec2 k = vec2(0.0);\n    //vec2 j = k-k;\n    //float size = .5;\n    \n    //float scale = 1. / ( 3. - clamp( pos.y, 1., 7. ) );\n    //scale = 1.;\n    \n    vec2 x;\n    //float iGlobalTim = iTime;\n    vec3 p = vec3(pos.x, pos.y+0.2, pos.z);\n    float d1;\n    //Putting An Object:\n    p = vec3(pos.x, pos.y+2., pos.z);\n    #ifdef HIGHD\n    p += fbm(p+iTime/4.)/4.;\n    #endif\n    #ifdef MEDIUMD\n    p += texture(iChannel0, p.xz/16.+iTime/16.).r/8.;\n    #endif\n    x = vec2(sdPlane(p), 1.9);\n    p = vec3(pos.x, pos.y+0.5, pos.z);\n    //d1 = sdTorus(p, vec2(VoxelSize*8., VoxelSize));\n    /*p = vec3(pos.x+21., pos.y+2.257+(sdPlane(p)/4.), pos.z-28.);\n    p.xz *= rotate2d(32.);\n    d1 = sdRoundBox(p, vec3(VoxelSize*32., VoxelSize*4., VoxelSize*56.), 0.05);\n    x = blend(vec2(d1, 1.1), x, 0.11);*/\n    /*\n\tp = vec3(pos.x-21., pos.y+2.257, pos.z-28.);\n    p.xz *= rotate2d(15.);\n    p += fbm(p)/4.;\n    d1 = sdRoundBox(p, vec3(VoxelSize*3., VoxelSize*4., VoxelSize*6.), 0.05);\n    x = blend(vec2(d1, 1.1), x, 0.11);\n\t*/\n    p = vec3(pos.x-10., pos.y+2.257, pos.z-10.);\n    p.xz *= rotate2d(-15.);\n    p.xy *= rotate2d(0.01);\n    p += fbm(p)/4.;\n    d1 = sdRoundBox(p, vec3(VoxelSize*20., VoxelSize*4., VoxelSize*20.), 0.05);\n    x = blend(vec2(d1, 1.1), x, 0.11);\n    \n    //p = vec3(pos.x-5., pos.y+2.257, pos.z+1.);\n    //p.xy *= rotate2d(-15.);\n    //p += fbm(p)/4.;\n//d1 = sdHexPrism(p, vec2(VoxelSize*12.,VoxelSize*6.));\n    //x = blend(vec2(d1, 1.1), x, 0.11);\n    \n    /*\n    p = vec3(pos.x+8., pos.y+2.257, pos.z+10.);\n    p.zy *= rotate2d(3.141592/2.);\n    p += fbm(p)/4.;\n    d1 = sdHexPrism(p, vec2(VoxelSize*18.,VoxelSize*30.));\n    x = blend(vec2(d1, 1.1), x, 0.11);\n*/\n\n\n    return x;\n    \n}\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 125.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir,\n               in vec3 rayOri,\n               float  b)  // sun light direction\n{\n    float fogAmount = 1.0-exp(-distance*b);\n    fogAmount += 1.0 - exp(-distance*b*b);\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.8, 1.0) +cos(rd.y);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if(m >= 1.0 && m <= 1.9) {\n            float customNoise = cnoise(pos);\n            col = vec3(customNoise/12.+0.8);\n            //col += vec3(customNoise/6.);\n            //col.b -= customNoise/6.;\n            ref -= vec3(cnoise(rd));\n        }\n        if(m == 1.1 || m == 1.8) {\n            col = vec3(FbmNoise(pos.xz+pos.y))-2.0;\n            //ref -= vec3(cnoise(rd));\n        }\n        // lighitng        \n        //ref -= vec3(cnoise(rd));\n        float occ = calcAO( pos, nor );\n\t\t//vec3  lig = normalize( vec3(sin(iTime/4.),0.1,cos(iTime/4.)) );\n        vec3 lig = normalize( vec3(1.0, 0.1, 0.2) );\n        //vec3 lig = vec3(0.);\n        //vec3 lig1 = normalize( vec3(0., 0.3, 0.2)/3. )/3.;\n        vec3 lig1 = vec3(0.);\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        amb += cnoise(rd);\n        float dif = clamp( dot( nor, lig+lig1 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x+-lig1.x,0.0,-lig.z+-lig1.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig+lig1 ), 0.0, 1.0 ),16.0);\n        vec3 p = pos;\n        dif *= softshadow( pos, lig+lig1, 0.2, 2.5 );\n        dom *= softshadow( pos,\n                          ref\n                          , 0.2, 2.5 );\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n        col += vec3(cnoise(rd));\n        \n    \tcol = applyFog(col, 0.2, rd, lig, ro, t);\n        //col = applyFog(col, 0.2, rd, lig1, ro, t);\n        if(t > 1.) //if t > 0.5 then add some nice atmosphere.\n        {\n            amb += 0.5 * clamp(abs(dot(nor.x+nor.z, fre)), 0.0, 1.0)*(pos.x-pos.z);\n            lin += 0.20*amb*vec3(0.50,0.20,1.00)*dif;\n            //amb += 0.5 * clamp(abs(dot(nor.x+nor.z, fre)), 0.0, 1.0)*(pos.x-pos.z);\n            //lin += 1.00*amb*vec3(1.00,1.00,0.70)*dif;\n            col = col * lin;\n        }\n        //fog\n        col = mix(col, vec3(1.0, 1.0, 1.0), 1.0-exp(-0.0002*t*t));\n        col.r *= 0.8;\n        col.g *= 0.9;\n        col.b *= 1.01;\n        //col = col / lin;\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 2.2;\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    //nnp.x += iTime;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    //mo = texture(iChannel2, vec2(1.,0.)).xy;\n    mo.y = 0.5-mo.y;\n\tfloat time = 15.0 + iTime;\n    vec2 con = mo-mo;\n    con *= 2.;\n    \n    vec3 usp = texture(iChannel2,vec2(0.)).xyz;\n    //vec3 usp = vec3(iTime, 0.0, 0.0);\n    \n    if(keyClick(KEY_C*256.)) fov = 4.4;\n    \n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x)+con.x, 1.0 + 3.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 1.5, 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.1);\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,fov) );\n\n    // render\t\n    vec3 col = render( ro+usp, rd );\n\n\tcol = pow( col, vec3(1.0/2.2) );\n    \n    //vec2 mp = p/4.;\n    //vec2 p3 = mp*mp*mp;\n    //col *= smoothstep(12., .05, dot(p3*p3,p3*p3)*10.)*0.4+0.6;\n    col *= 1.+col/8.;\n    col += texture(iChannel3,  vec2(p.x+iTime*30.,p.y-iTime)).r/20.;\n    col -= texture(iChannel3, vec2(p.x+iTime, p.y-iTime)).r/30.;\n\n    fragColor=vec4( col, 1.0 );\n    vec2 uv = 2.0*fragCoord/iResolution.xy - 1.0;\n    fragColor -= max(dot(uv,uv)-0.9,0.)/5.;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//\"Glass\" code from https://www.shadertoy.com/view/XltfRl\n\n\n#define WATER_SPEED 4.\n//water current direction\n#define WATER_ROT 0.\n\n#define NO_COLOR_SCATTERING\n\n//not rlly a quaternion its a vec2\nvec2 getWaterRotQuaternion() {\n    float radian = WATER_ROT*3.14159/180.;\n    return normalize(vec2(cos(radian),sin(radian)));\n}\n\nfloat desaturate(vec3 c) {\n    return (c.r+c.g+c.b)/2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    \n\tvec4 col = texture(iChannel0, p);\n    float mouseX = iMouse.x/iResolution.x;\n    \n\tif(p.x > 0.) \n\t{\n        vec2 waterRotation = getWaterRotQuaternion();\n        #ifdef NO_COLOR_SCATTERING\n        col.r = texture(iChannel0, p+desaturate(texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).rgb)/160.).r;\n        col.g = texture(iChannel0, p+desaturate(texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).rgb)/160.).g;\n        col.b = texture(iChannel0, p+desaturate(texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).rgb)/160.).b;\n        #else\n\t\tcol.r = texture(iChannel0, p+texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).r/160.).r;\n        col.g = texture(iChannel0, p+texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).g/160.).g;\n        col.b = texture(iChannel0, p+texture(iChannel1, p+iTime*waterRotation*WATER_SPEED/8.).b/160.).b;\n        #endif\n\t}\n\t\n    fragColor = pow(col,vec4(1./1.1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Noise created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Made more readable and understandable by Manuel Riecke/API_Beast\n\nvec2 rand2(vec2 p)\n{\n\tvec2 q = vec2(dot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat rand(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(419.2,371.9))) * 833458.57832);\n}\n\nfloat iqnoise(in vec2 pos, float irregular, float smoothness)\n{\n\tvec2 cell = floor(pos);\n\tvec2 cellOffset = fract(pos);\n\n\tfloat sharpness = 1.0 + 63.0 * pow(1.0-smoothness, 4.0);\n\t\n\tfloat value = 0.0;\n\tfloat accum = 0.0;\n\t// Sample the surrounding cells, from -2 to +2\n\t// This is necessary for the smoothing as well as the irregular grid.\n\tfor(int x=-2; x<=2; x++ )\n\tfor(int y=-2; y<=2; y++ )\n\t{\n\t\tvec2 samplePos = vec2(float(y), float(x));\n\n  \t\t// Center of the cell is not at the center of the block for irregular noise.\n  \t\t// Note that all the coordinates are in \"block\"-space, 0 is the current block, 1 is one block further, etc\n\t\tvec2 center = rand2(cell + samplePos) * irregular;\n\t\tfloat centerDistance = length(samplePos - cellOffset + center);\n\n\t\t// High sharpness = Only extreme values = Hard borders = 64\n\t\t// Low sharpness = No extreme values = Soft borders = 1\n\t\tfloat samplex = pow(1.0 - smoothstep(0.0, 1.414, centerDistance), sharpness);\n\n\t\t// A different \"color\" (shade of gray) for each cell\n\t\tfloat color = rand(cell + samplePos);\n\t\tvalue += color * samplex;\n\t\taccum += samplex;\n\t}\n\n\treturn value/accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 3.;\n    float x = 0.7;\n    fragColor = vec4((iqnoise(uv+iTime*16.*vec2(1.,0.3), 1., 4.)-x)*(1./(1.-x)));\n    //if(iqnoise(uv+iTime, 1., 4.) > x) fragColor = vec4(iqnoise(uv+iTime, 1., 4.));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//Shader of Pol Jeremias has this list. Pretty sure this isn't copyrighted.\n// Keyboard constants definition\nconst float KEY_BSP   = 8./256.0;\nconst float KEY_SP    = 32./256.0;\nconst float KEY_LEFT  = 37./256.0;\nconst float KEY_UP    = 38./256.0;\nconst float KEY_RIGHT = 39./256.0;\nconst float KEY_DOWN  = 40./256.0;\nconst float KEY_A     = 65./256.0;\nconst float KEY_B     = 66./256.0;\nconst float KEY_C     = 67./256.0;\nconst float KEY_D     = 68./256.0;\nconst float KEY_E     = 69./256.0;\nconst float KEY_F     = 70./256.0;\nconst float KEY_G     = 71./256.0;\nconst float KEY_H     = 72./256.0;\nconst float KEY_I     = 73./256.0;\nconst float KEY_J     = 74./256.0;\nconst float KEY_K     = 75./256.0;\nconst float KEY_L     = 76./256.0;\nconst float KEY_M     = 77./256.0;\nconst float KEY_N     = 78./256.0;\nconst float KEY_O     = 79./256.0;\nconst float KEY_P     = 80./256.0;\nconst float KEY_Q     = 81./256.0;\nconst float KEY_R     = 82./256.0;\nconst float KEY_S     = 83./256.0;\nconst float KEY_T     = 84./256.0;\nconst float KEY_U     = 85./256.0;\nconst float KEY_V     = 86./256.0;\nconst float KEY_W     = 87./256.0;\nconst float KEY_X     = 88./256.0;\nconst float KEY_Y     = 89./256.0;\nconst float KEY_Z     = 90./256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n//FabriceNeyret https://www.shadertoy.com/view/llySRh\n#define keyToggle(ascii)  ( texelFetch(iChannel1,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\n#define keyPress(ascii)   ( texelFetch(iChannel1,ivec2(ascii,1),0).x > 0.)\n\n\nconst float mEPSILON = 0.0001;\nconst float PI = 3.14159265358979;\n//const float playerSpeed = 0.2;\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//STORAGE BUFFER\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 rotVector( vec2 rd, vec2 b ) {\n    float sgn = sign(rd.x);\n    sgn = sgn >= 0. ? 1. : -1.;\n    float rdeg = (PI/2.-PI/2.*sgn)+atan(rd.y/rd.x);\n    return mat2(cos(rdeg), sin(rdeg), -sin(rdeg), cos(rdeg))*vec2(b.x, b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 2.2;\n    float playerSpeed = 5.;\n    \n    vec3 finalColCode = vec3(0.);\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    //nnp.x += iTime;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo.y = 0.5-mo.y;\n\tfloat time = 15.0 + iTime;\n    vec2 con = mo-mo;\n    con *= 2.;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uuv = fragCoord/iResolution.xy*256.;\n    //vec4 lastStorage = texture(iChannel0, uv);\n    \n    vec3 usp = texture(iChannel0,uv).xyz;\n    vec3 mor = texture(iChannel0,uv).xyz;\n    \n    if(keyClick(KEY_C*256.)) fov = 4.4;\n    \n\t// camera\t\n\tvec3 ro = vec3( 5.*cos(0.1*time + 6.0*mo.x)+con.x, 1.0 + 3.0*mo.y,5.*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0., 1.5, 0. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.1);\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,fov) );\n    \n    if(uv.x < 0.5) {\n        \n        vec3 pusp = vec3(0.);\n        if(keyClick(KEY_W*256.)) pusp.xz += iTimeDelta*playerSpeed*vec2(1.,0.);\n        if(keyClick(KEY_A*256.)) pusp.xz += iTimeDelta*playerSpeed*vec2(0.,-1.);\n        if(keyClick(KEY_S*256.)) pusp.xz += iTimeDelta*playerSpeed*vec2(-1.,0.);\n        if(keyClick(KEY_D*256.)) pusp.xz += iTimeDelta*playerSpeed*vec2(0.,1.);\n        pusp.xz = rotVector(rd.xz, pusp.xz);\n        usp = usp.xyz+pusp.xyz;\n        finalColCode = usp;\n    } else if(uv.x > 0.7) {\n        //if(iTime == 0.) mor.xy = mo;\n        //if(iMouse.z >= 0. && mor.z == 0.) {\n        //    mor.xy += mo;\n        //}\n        mor.xy = mo;\n        //mor.xy += mo;\n        //mor.z = iMouse.z;\n        finalColCode = mor;\n    }\n    \n    fragColor = vec4(finalColCode,0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}