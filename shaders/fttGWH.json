{
    "Shader": {
        "info": {
            "date": "1636164244",
            "description": "Recreation of\nhttps://www.youtube.com/watch?v=aVTalm2VjDc\nStill like the original much more :|",
            "flags": 48,
            "hasliked": 0,
            "id": "fttGWH",
            "likes": 28,
            "name": "BeyondBeliefs",
            "published": 3,
            "tags": [
                "particles",
                "musicvideo",
                "reproduction"
            ],
            "usePreview": 0,
            "username": "stephenl7797",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R;\n#if 0\n    vec4 c = IC2(ivec2(fragCoord));\n    fragColor = c;\n#else\n    // If dense area, then blur.\n    float density = 0.;\n    vec4 c0 = IC2(ivec2(fragCoord));\n    ivec2 fc = ivec2(fragCoord);\n    \n    vec4 avg = vec4(0.);\n    avg.a = 0.;\n    \n    for (int i=-1;i<2;i++) {\n        for (int j=-1;j<2;j++) {\n\n            vec2 uv1 = uv+vec2(float(i)*1.25,float(j)*1.25)/R.xy;\n            vec4 s = C2(uv1);\n            \n            density += length(s.rgb);\n        }\n    }\n    \n    density = density / (sqrt(3.) * 9.);\n    \n    float density2 = pow(density / .97, 2.);\n    \n        \n    // This doesn't work well. It'd be better to use multiple buffers\n    // to do a larger radius more efficiently.\n    // Also, perhaps blurring in a time averaged buffer would help propagate\n    // the blur and highlights, which would be nice.\n    \n    //for (int i=-2;i<5;i++) { for (int j=-2;j<5;j++) {\n    //for (int i=-3;i<7;i++) { for (int j=-3;j<7;j++) {\n    for (int i=-1;i<2;i++) { for (int j=-1;j<2;j++) {\n            vec2 uv1 = uv+vec2(float(i)*2.15,float(j)*2.15)/R.xy;\n            float d = length(vec2(i,j));\n            //float d = float(i*i+j*j);\n            float w = exp(-d / (density*density*density * 8.15));\n            vec4 s = C2(uv1) * w;\n            s.a = w;\n            avg += s;\n        }\n    }\n    //avg.rgb = c0.rgb; avg.a = 1.;\n    \n\n    \n    fragColor = avg / avg.a;\n    \n    \n    fragColor.rgb += density2;\n    \n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define C2(uv) texture(iChannel2, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n#define IC2(p) texelFetch(iChannel2, (p), 0)\n#define IC3(p) texelFetch(iChannel3, (p), 0)\n\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\nvec2 proj(vec3 p, vec2 RR, float tt) {  \n    //p.z += RR.x * 3.8;\n    //p.z /= RR.x * 2.6;\n\n    //if (p.z < .0) return vec2(9999.,9999.);\n\n    return (p.xy / p.z) * RR.yy * .5 + RR.xy * .5;\n}\nvec3 proj_d(vec3 p, vec2 RR, float tt) { \n    //p.z += RR.x * 3.8;\n    //p.z /= RR.x * 2.6;\n\n    //if (p.z < .0) return vec2(9999.,9999.);\n\n    return vec3(p.xy/p.z,p.z) * vec3(RR.yy*.5,1.) + vec3(RR.xy,0.) * .5;\n}\n\n\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\nfloat rand31(vec3 p) { return fract(\n    473.1*sin(2.3+117.31*p.y+p.x*229.13+p.z*9.2)); }\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}\nfloat noise31(vec3 x) {\n    float o = (0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        float v  = rand31(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n\n}\n\nfloat phase_at(vec3 p, float iTime) {\n    iTime -= 7.5;\n    return fract(iTime * 2.) * .3 + .7 * noise31(-1. + p.xyz * .01 + vec3(0., 0., iTime * .65));\n    return noise31(-1. + p.xyz * .01 + vec3(0., 0., iTime * .65));\n}\n\nvec3 cmap(float t) {\n    //vec3 speed = vec3(.3, .562*t, .55) * 3. * 3.141;\n    //vec3 mult  = vec3(1.);\n    //vec3 bias  = vec3(-.1, .1, .9);\n    //vec3 shft  = vec3(.7, .35, .2) * 6.282;\n    //vec3 c = cos(speed*t+shft) * mult + bias;\n    \n    t = (t - .1) / .9;\n    vec3 cc[6];\n    cc[0] = vec3(0.980, 0.952, 0.819);\n    cc[1] = vec3(0.849, 0.658, 0.249);\n    cc[2] = vec3(0.933, 0.401, 0.149);\n    cc[5] = vec3(0.656, 0.849, 0.933);\n    cc[4] = vec3(0.590, 0.684, 0.997);\n    cc[3] = vec3(0.411, 0.476, 0.591);\n    int i = int(t*6.);\n    int j = int(t*6.+1.) % 6;\n    //int h = int(t*6.-1.) % 6;\n    //if ((t*6.-1.) < 0.) h = 6;\n    vec3 c = vec3(0.);\n    float tt = 1.-fract(t*6.);\n    //c  = mix(cc[h], cc[i], fract(t*6.)) * (1.-tt); \n    c += mix(cc[i], cc[j], fract(t*6.));// * tt;\n    \n    return c;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Particle Sim.\n\n// Currently, I spawn particles with z range [200-300],\n// but opacity fades in after coming forward under 200.\n// This gives the spatial clustering effect and appears to be what's done in the video.\n// However it wastes a lot of particles and time.\n// Perhaps instead I could spawn closer and use rejection sampling to\n// get the clustering from the start?\n\n\nvec3 initParticle(vec2 fc) {\n    vec3 p = (rand23(fc) - .5) * vec3(R.xy*.95,10.) + vec3(0.,0.,205.); // z : [200-300]\n    \n    //vec3 p = (rand23(fc) - .5) * vec3(R.xy*1.15,20.) + vec3(0.,0.,205.); // z : [200-300]\n    //if (abs(pow(noise31(vec3(p.xy*.05-100.,iTime*.01)),1.) - fc.x/R.x) > .05) p = vec3(-9999.);\n    // Well this is like rejection sampling over time, not as efficient as a loop over random positions tho\n    if (abs(pow(noise31(vec3(p.xy*.005-100.,fc.x*.007+iTime*.02)),1.)) < .72) p = vec3(-9999.,-9999.,1.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 old = IC0(ivec2(fragCoord));\n    \n    //if (old.w < 0. || iFrame == 0 || IC3(ivec2(0,82)).r > 0.5) {\n    //if (iFrame==0) {\n    vec2 po = proj(old.xyz, R, iTime);\n    bool bad = abs(po.x - R.x/2.) > R.x/1.8 || abs(po.y - R.y/2.) > R.y/1.8 || po.x < -8500.;\n    //bad = false;\n    // Wipe away by phase.\n    if (bad || abs(old.w-fract(iTime * .12 + fragCoord.x/R.x * .51)) < .006 || iFrame == 0 || texelFetch(iChannel3, ivec2(82, 0), 0).r > .5) {\n          old.xyz = initParticle(fragCoord);\n        //old.w = .5 + rand11(fragCoord.x*1000.+fragCoord.y);\n        //old.w = noise31(-1. + old.xyz * .015 + vec3(0., 0., iTime * 4.95));\n        old.w = phase_at(old.xyz,iTime);\n        //old.w = rand31(-22. + old.xyz * .04 + vec3(0., 0., iTime * 222.5));\n    }\n\n    vec4 vel = vec4(0.);\n    vec3 t0 = vec3(0., 0., iTime * .21 + old.z*.0001);\n    float CHAOS = .0001; // Add random offset to noise sample func\n    vel.xyz = (noise33(fragCoord.xyx*CHAOS + old.xyz * .001 + t0)-.5) +\n              (noise33(old.xyz * .0108 + 200. + t0*1.25)-.5) * .675;\n    vel.z = (vel.z * .21) + -.16;\n    vel.xy  *= 1.5;\n    vel.w = .0003; // Phase moves a little.\n    \n    //vel *= pow(.4 + rand31(old.xyz*.01),2.);\n    // Move different colors at different speeds at different times.\n    vel *= pow(.7 + .62*abs(fract(iTime*.4)-old.w), 1.);\n    \n    //vel.w = -1. / 60.;\n    vec4 new = old + vel;\n    new.w = fract(new.w);\n\n    //new.z = 200.;\n    fragColor = new;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Particle Tracking.\n\n// TODO:\n// Have two seperate groups of two tracked particles.\n// One on the entire set.\n// One only on the first 1/100th.\n// That way we can shade both at a high LoD and a low.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec4 old = IC0(ivec2(fragCoord));\n    vec2 q0[4];\n    q0[0] = proj(IC1(unhashXY(int(old.x),IR)).xyz, R,iTime);\n    q0[1] = proj(IC1(unhashXY(int(old.y),IR)).xyz, R,iTime);\n    q0[2] = proj(IC1(unhashXY(int(old.z),IR)).xyz, R,iTime);\n    q0[3] = proj(IC1(unhashXY(int(old.w),IR)).xyz, R,iTime);\n    vec4 d = vec4(length(fragCoord - q0[0]),\n                  length(fragCoord - q0[1]),\n                  length(fragCoord - q0[2]),\n                  length(fragCoord - q0[3]));\n    vec4 new = old;\n    \n    //int MAX_PARTICLE_CNT = IR.x * IR.y;\n    int MAX_PARTICLE_CNT = IR.x * IR.y / 1;\n    int MAX_PARTICLE_CNT_2 = IR.x * IR.y / 100;\n\n    #if 1\n    \n    // Random.\n    int samples = 12;\n    for (int i=0; i<samples; i++) {\n        // I think these hash functions are bad.\n        int rr = int(iFrame*977*samples + i*3373 + int(fragCoord.x*202.537 + fragCoord.y*492.233)) % MAX_PARTICLE_CNT;\n        //int rr = int(iTime*997.3 + fragCoord.x*222.3 + fragCoord.y*127.3) + (i)*97;\n        int ry = (rr / IR.x);\n        int rx = rr % IR.x;\n        \n        vec4 q1 = IC1(ivec2(rx,ry));\n        q1.xy = proj(q1.xyz, R,iTime);\n        float d1 = length(fragCoord - q1.xy);\n        \n        \n        if (d1 <= d[0]) {\n            if (d1<d[0]) {\n            new[3] = new[2], d[3] = d[2];\n            new[2] = new[1], d[2] = d[1];\n            new[1] = new[0], d[1] = d[0];\n            }\n            new[0] = hashXY(ivec2(rx,ry), IR); d[0] = d1;\n        } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n            new[3] = new[2], d[3] = d[2];\n            new[2] = new[1], d[2] = d[1];\n            }\n            new[1] = hashXY(ivec2(rx,ry), IR); d[1] = d1;\n        } else if (d1 <= d[2]) {\n            if (d1<d[2])\n            new[3] = new[2], d[3] = d[2];\n            new[2] = hashXY(ivec2(rx,ry), IR); d[2] = d1;\n        } else if (d1 <= d[3]) {\n            new[3] = hashXY(ivec2(rx,ry), IR); d[3] = d1;\n        }\n        \n    }\n    \n    \n    // Neighbor.\n    ivec2 fc = ivec2(fragCoord);\n    for (int i = 0; i < 4; i++) {\n        ivec2 fc1 = fc+ivec2(i==0?-1:i==1?1:0, i==2?-1:i==3?1:0);\n        if (fc1.x < 0 || fc1.y < 0 || fc1.x >= IR.x || fc1.y >= IR.y) continue;\n        vec4 neigh = IC0(fc1); \n        \n        for (int j=0; j<4; j++) {\n            ivec2 ixy = unhashXY(int(neigh[j]), IR);\n            vec4 qnew = IC1(ixy);\n            qnew.xy = proj(qnew.xyz, R,iTime);\n\n            float d1 = length(qnew.xy - fragCoord);\n\n            if (d1 <= d[0]) {\n            if (d1<d[0]) {\n                new[3] = new[2], d[3] = d[2];\n                new[2] = new[1], d[2] = d[1];\n                new[1] = new[0], d[1] = d[0];\n                }\n                new[0] = neigh[j], d[0] = d1;\n\n            } else if (d1 <= d[1]) {\n            if (d1<d[1]) {\n                new[3] = new[2], d[3] = d[2];\n                new[2] = new[1], d[2] = d[1];\n                }\n                new[1] = neigh[j]; d[1] = d1;\n            } else if (d1 <= d[2]) {\n            if (d1<d[2])\n                new[3] = new[2], d[3] = d[2];\n                new[2] = neigh[j]; d[2] = d1;\n            } else if (d1 <= d[3]) {\n                new[3] = neigh[j], d[3] = d1;\n            }\n        }\n    }\n    \n    #else\n    \n    IMPLEMENT THE TWO GROUP THING\n    \n    #endif\n\n\n    if (iFrame == 0) new = vec4(0.);\n\n    fragColor = new;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Time Filtered main image.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //vec3 col1 = cmap(uv.x);    fragColor.rgb = col1;    return;\n\n    \n    vec4 ids = IC0(ivec2(fragCoord));\n    vec4 qq[4];\n    qq[0] = IC1(unhashXY(int(ids.x),IR));\n    qq[1] = IC1(unhashXY(int(ids.y),IR));\n    qq[2] = IC1(unhashXY(int(ids.z),IR));\n    qq[3] = IC1(unhashXY(int(ids.w),IR));\n    vec3 q[4];\n    for (int i=0; i<4; i++) q[i] = proj_d(qq[i].xyz, R, iTime);\n    vec4 d = vec4(length(fragCoord - q[0].xy),\n                  length(fragCoord - q[1].xy),\n                  length(fragCoord - q[2].xy),\n                  length(fragCoord - q[3].xy));\n                  \n  vec4 old = IC2(ivec2(fragCoord));\n\n              \n    \n    vec4 dp = d + fract(ids[0] * .577) * 1.;\n    \n    // Nice: by making the particles large and weighing opacity\n    // by relative distances, we can get the puffy textured particles\n    // like in the video.\n    \n    vec4 col = vec4(0.);\n    for (int i=0; i<4; i++) {\n        float di = d[i];\n        float sz = fract(ids[i] * .177) * 92.5 + 4.;\n        \n        // Anything behind 300: invisible. Smoothly fade in from 220\n        float opacity = clamp(.1 + fract(ids[0]*.311) * .35 + 1. / sqrt(sz), 0., 1.) * smoothstep(199.,190.,q[i].z);\n        //opacity = .1 + fract(ids[i] *  .3937) * .95;\n        \n        \n        //opacity = step(100., q[i].z);\n        if (di < sz) {\n            float phase = qq[i].w;\n            col.rgb += opacity * cmap(phase) / (dp[i]);\n            col.a += opacity * q[i].z / 4.;\n        }\n    }\n    col.rgb /= (1./dp[0]+1./dp[1]+1./dp[2]+1./dp[3]);\n    //col.r = pow(col.r, .7); col.b = pow(col.b, .7); col.g = pow(col.g, .7);\n    \n    //col.rgb *=  d[3]\n    float attrib = .12+fract(ids[0] * .111)*1.2; // Controls spikiness.\n    d *= .05 * (attrib);\n    d.rgb += .05 / attrib;\n    float denom = .051 + fract(ids[0]*.177) * .35;\n    d.yzw   =  0.01 / (denom + d.yzw);\n    //col.rgb *= vec3(1. / d[2], 1. / d[1], 1. / d[0]) * d[3];\n    col.rgb *= sqrt(d[3]) / (d[0]);\n    \n    // Mix a lot of new when bright, and keep old if not bright.\n    float alpha = length(col.rgb) * .16 + .02;\n    col.rgb = col.rgb * alpha + old.xyz * (1.-alpha);\n    col.a = col.a * .1 + old.a * .9;\n    \n    //col.rgb *= .98 + .5 * sqrt(sqrt(d[0]*d[1]*d[2]*d[3]));\n    \n\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}