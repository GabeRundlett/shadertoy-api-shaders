{
    "Shader": {
        "info": {
            "date": "1651994088",
            "description": "I am learning how to do a ray marching here",
            "flags": 0,
            "hasliked": 0,
            "id": "NtBfWz",
            "likes": 0,
            "name": "Ray marching hype",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "tovaris",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "\nstruct Sphere {\n   vec3 center;\n   float radius;\n   vec3 color;\n};\n\n\nstruct LineSegment {\n    vec3 pos;\n    vec3 dir;\n    float thickness;\n};\n\nconst vec3 noHit = vec3(-1.0, -1.0, -1.0);\n\nfloat dToSphere(in vec3 p, Sphere s) {\n   return length(p - s.center) - s.radius;\n}\n\nfloat dToLineSegment(in vec3 p, LineSegment l) {\n   vec3 d = l.dir;\n   vec3 o = l.pos;\n   float w = l.thickness;\n   float t = (p.x * d.x - o.x * d.x +\n              p.y * d.y - o.y * d.y +\n              p.z * d.z - o.z * d.z) / (d.x * d.x + d.y * d.y + d.z * d.z);\n  \n   float dst = 10000.f;\n  \n   if (t > 1.0) {\n       dst = length(p - (o + d)) - w * (1.0 / t);\n   } else if (t < 0.0) {\n       dst = length(p - o) - w;\n   }\n   else {\n       dst = length(p - (o + d * t)) - w * (-1.0 / t);\n   }\n   \n   \n   return dst;\n}\n\nfloat dToScene(in vec3 p) {\n    \n    float d;\n    \n    float displacement = sin(3.0 * p.x) * 0.25 + sin(4.0 * p.y) * 0.4;\n    d = dToSphere(p, Sphere(vec3(-2.5, -1.0, 0.0), 1.0, vec3(1.0))) + displacement;\n    \n    d = min(d, dToLineSegment(p, LineSegment(vec3(0.0, -3.0, 0.0), vec3(0.0, 2.0, 0.0), 0.5)));\n    \n    return d;\n\n}\n\nvec3 sceneNormal(in vec3 p) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = dToScene(p + small_step.xyy) - dToScene(p - small_step.xyy);\n    float gradient_y = dToScene(p + small_step.yxy) - dToScene(p - small_step.yxy);\n    float gradient_z = dToScene(p + small_step.yyx) - dToScene(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 march_ray(in vec3 start, in vec3 dir) {\n   \n   const int MAX_STEPS = 64;\n   const float FAR_CLIP_PLANE = 1000.0;\n   const float MIN_DIST_TO_HIT = 0.0001;\n   vec3 light_position = vec3(2.0, -5.0, 3.0);\n   vec3 cToLight = normalize(light_position - start);\n   \n   dir = dir / length(dir);\n   float acc_distance = 0.0;\n   float d = FAR_CLIP_PLANE;\n   \n   float backColorValue = max(0.0, dot(dir, cToLight));\n   vec3 backColor = backColorValue * vec3(0.3568627450980392, 0.5372549019607843, 0.8313725490196079);\n   vec3 ray = noHit;\n   \n   for (int i = 0; i < MAX_STEPS; ++i) {\n       vec3 p = dir * acc_distance + start;\n       \n       float d = min(d, dToScene(p));\n       \n       if (d <= MIN_DIST_TO_HIT) {\n           \n           vec3 direction_to_light = normalize(p - light_position);\n           vec3 normal = sceneNormal(p);\n\n           float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n        \n           return vec3(1.0, 0.0, 1.0) * diffuse_intensity;\n       }\n       \n       acc_distance += d;\n       \n       if (acc_distance > FAR_CLIP_PLANE) {\n           break;\n       }\n   }\n   \n    \n   return backColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.x * 2.0 - 1.0;\n    \n    vec3 camera = vec3(0.0, 0.0, -5.0);\n    \n    vec3 direction = vec3(uv, 1.0);\n    vec3 ray = march_ray(camera, direction);\n  \n    fragColor = vec4(ray, 1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}