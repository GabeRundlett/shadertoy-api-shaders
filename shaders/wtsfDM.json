{
    "Shader": {
        "info": {
            "date": "1596923547",
            "description": "The weatherman is hard at work (also has bad handwriting). Press 1, 2 or 3 to change the weather.",
            "flags": 48,
            "hasliked": 0,
            "id": "wtsfDM",
            "likes": 36,
            "name": "The Weatherman",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf"
            ],
            "usePreview": 1,
            "username": "nlight",
            "viewed": 768
        },
        "renderpass": [
            {
                "code": "// Copyright 2020 Alexander Dzhoganov\n//\n// MIT License\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n// and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n *\n * Just another raymarched SDF that I spent way too much time on.\n * Press 1, 2 or 3 to change the weather.\n *\n * List of features:\n * \n * - Approximate line-segment lights\n * - Physically-based metallic/roughness materials\n * - Glossy reflections\n * - Procedural volumetric clouds\n * - Soft-shadows\n * - Ambient occlusion\n * - Temporal AA\n *\n * Some of the lighting math is probably wrong. I have included references and links to papers\n * and articles so if you are trying to reimplement something in your own renderer it'd be prudent to double check there.\n * The code is mostly well-commented but even where it isn't I have tried to keep it as clean and readable as possible.\n * Some things have been butchered to keep compile times down and might be hard to parse, apologies for that :(\n *\n * Thanks to everyone making so much cool stuff and publishing it for us all to learn from.\n * A lot of ideas and code have been borrowed from other shaders on this site and it has been\n * immensely helpful. Special thanks to Inigo Quilez for all the articles and code.\n * \n * Incomplete list of techniques used in making this:\n *\n * - Cook-Torrance lighting model\n * Joey de Vries, https://learnopengl.com/PBR/Theory\n *\n * - SDFs for various shapes by Inigo Quilez\n * https://iquilezles.org/articles/distfunctions\n * https://www.shadertoy.com/view/Xds3zN\n *\n * - SDF soft-shadows by Inigo Quilez\n * https://iquilezles.org/articles/rmshadows\n * https://www.shadertoy.com/view/lsKcDD\n *\n * - Ambient occlusion by Inigo Quilez\n * https://www.shadertoy.com/view/XttSz2\n *\n * - Tetrahedron normals technique by Inigo Quilez\n * https://iquilezles.org/articles/normalsSDF\n *\n * - Real-time line-segment lights\n * https://www.elopezr.com/rendering-line-lights/\n * https://www.shadertoy.com/view/tl2GD3\n *\n * - Procedural volumetric clouds\n * Haggstrom 2018, \"Real-time rendering of volumetric clouds\"\n * http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n *\n * - Temporal anti-aliasing\n * Lei Yang, Shiqiu Liu, Marco Salvi 2020, \"A Survey of Temporal Antialiasing\n * Techniques\" - http://behindthepixels.io/assets/files/TemporalAA.pdf\n *\n * More links and references in the code comments.\n * All the code is under the MIT license unless explicitly specified otherwise in the comments.\n * \n */\n\n// The code below just does the final HDR to LDR tonemapping.\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n  color = aces(color);\n  color = pow(color, vec3(1.0 / 2.2));\n  fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef saturate\n#define saturate(X) clamp(X, 0.0, 1.0)\n#endif\n\n// Hack to prevent loop unrolling.\n#define ZERO float(min(0, iFrame))\n#define UZERO uint(min(0, iFrame))\n\n// Various noise functions\n//\n// Simplex noise from https://github.com/ashima/webgl-noise\n// Copyright © 2011 Ashima Arts\n//\n// Worley noise from https://github.com/Erkaman/glsl-worley\n// Copyright © Stefan Gustavson\n//\n// Value noise with gradients from https://www.shadertoy.com/view/XdXBRH\n// Copyright © 2017 Inigo Quilez\n//\n// All noise functions are licensed under the MIT License\n//\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\nfloat hash(float n) { return fract(sin(n) * 753.5453123); }\nvec2 hash(vec2 x) {\n  const vec2 k = vec2(0.3183099, 0.3678794);\n  x = x * k + k.yx;\n  return -1.0 + 2.0 * fract(16.0 * k * fract(x.x * x.y * (x.x + x.y)));\n}\nvec2 hash22(vec2 p) {\n  p = mod(p, 5.0);\n  float n = sin(dot(p, vec2(41.0, 289.0)));\n  return fract(vec2(8.0, 1.0) * 262144.0 * n);\n}\n\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626,\n                      0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod289(i);\n  vec3 p =\n      permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(\n      0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i = floor(v + dot(v, C.yyy));\n  vec3 x0 = v - i + dot(i, C.xxx);\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min(g.xyz, l.zxy);\n  vec3 i2 = max(g.xyz, l.zxy);\n\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +\n                           vec4(0.0, i1.y, i2.y, 1.0)) +\n                   i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_);\n\n  vec4 x = x_ * ns.x + ns.yyyy;\n  vec4 y = y_ * ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4(x.xy, y.xy);\n  vec4 b1 = vec4(x.zw, y.zw);\n\n  vec4 s0 = floor(b0) * 2.0 + 1.0;\n  vec4 s1 = floor(b1) * 2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3(a0.xy, h.x);\n  vec3 p1 = vec3(a0.zw, h.y);\n  vec3 p2 = vec3(a1.xy, h.z);\n  vec3 p3 = vec3(a1.zw, h.w);\n\n  // Normalise gradients\n  vec4 norm =\n      taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m =\n      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n  m = m * m;\n  return 42.0 *\n         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n\n// 2D value noise with derivatives\n// https://iquilezles.org/articles/gradientnoise\nvec3 noised(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n\n  vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n  vec2 du = 30.0 * f * f * (f * (f - 2.0) + 1.0);\n\n  vec2 ga = hash(i + vec2(0.0, 0.0));\n  vec2 gb = hash(i + vec2(1.0, 0.0));\n  vec2 gc = hash(i + vec2(0.0, 1.0));\n  vec2 gd = hash(i + vec2(1.0, 1.0));\n\n  float va = dot(ga, f - vec2(0.0, 0.0));\n  float vb = dot(gb, f - vec2(1.0, 0.0));\n  float vc = dot(gc, f - vec2(0.0, 1.0));\n  float vd = dot(gd, f - vec2(1.0, 1.0));\n\n  return vec3(va + u.x * (vb - va) + u.y * (vc - va) +\n                  u.x * u.y * (va - vb - vc + vd), // value\n              ga + u.x * (gb - ga) + u.y * (gc - ga) +\n                  u.x * u.y * (ga - gb - gc + gd) + // derivatives\n                  du * (u.yx * (va - vb - vc + vd) + vec2(vb, vc) - va));\n}\n\nfloat fbm(vec2 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += snoise(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\nfloat fbm(vec3 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += snoise(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\nfloat worley(vec2 P) {\n  const float K = 0.142857142857;\n  const float K2 = 0.0714285714285;\n  const float jitter = 0.8;\n  vec2 Pi = mod289(floor(P));\n  vec2 Pf = fract(P);\n  vec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n  vec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n  vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n  p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n  vec4 ox = mod(p, 7.0) * K + K2;\n  vec4 oy = mod(floor(p * K), 7.0) * K + K2;\n  vec4 dx = Pfx + jitter * ox;\n  vec4 dy = Pfy + jitter * oy;\n  vec4 d = dx * dx + dy * dy;\n  d.xy = (d.x < d.y) ? d.xy : d.yx;\n  d.xz = (d.x < d.z) ? d.xz : d.zx;\n  d.xw = (d.x < d.w) ? d.xw : d.wx;\n  d.y = min(d.y, d.z);\n  d.y = min(d.y, d.w);\n  return sqrt(d.xy).x;\n}\n\nvec3 worley_dist(vec3 x, vec3 y, vec3 z) { return x * x + y * y + z * z; }\n\nfloat worley(vec3 P) {\n  const float jitter = 0.8;\n  float K = 0.142857142857;     // 1/7\n  float Ko = 0.428571428571;    // 1/2-K/2\n  float K2 = 0.020408163265306; // 1/(7*7)\n  float Kz = 0.166666666667;    // 1/6\n  float Kzo = 0.416666666667;   // 1/2-1/6*2\n\n  vec3 Pi = mod(floor(P), 289.0);\n  vec3 Pf = fract(P) - 0.5;\n\n  vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n  vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n  vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n  vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n  vec3 p1 = permute(p + Pi.y - 1.0);\n  vec3 p2 = permute(p + Pi.y);\n  vec3 p3 = permute(p + Pi.y + 1.0);\n\n  vec3 p11 = permute(p1 + Pi.z - 1.0);\n  vec3 p12 = permute(p1 + Pi.z);\n  vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n  vec3 p21 = permute(p2 + Pi.z - 1.0);\n  vec3 p22 = permute(p2 + Pi.z);\n  vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n  vec3 p31 = permute(p3 + Pi.z - 1.0);\n  vec3 p32 = permute(p3 + Pi.z);\n  vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n  vec3 ox11 = fract(p11 * K) - Ko;\n  vec3 oy11 = mod(floor(p11 * K), 7.0) * K - Ko;\n  vec3 oz11 = floor(p11 * K2) * Kz - Kzo; // p11 < 289 guaranteed\n\n  vec3 ox12 = fract(p12 * K) - Ko;\n  vec3 oy12 = mod(floor(p12 * K), 7.0) * K - Ko;\n  vec3 oz12 = floor(p12 * K2) * Kz - Kzo;\n\n  vec3 ox13 = fract(p13 * K) - Ko;\n  vec3 oy13 = mod(floor(p13 * K), 7.0) * K - Ko;\n  vec3 oz13 = floor(p13 * K2) * Kz - Kzo;\n\n  vec3 ox21 = fract(p21 * K) - Ko;\n  vec3 oy21 = mod(floor(p21 * K), 7.0) * K - Ko;\n  vec3 oz21 = floor(p21 * K2) * Kz - Kzo;\n\n  vec3 ox22 = fract(p22 * K) - Ko;\n  vec3 oy22 = mod(floor(p22 * K), 7.0) * K - Ko;\n  vec3 oz22 = floor(p22 * K2) * Kz - Kzo;\n\n  vec3 ox23 = fract(p23 * K) - Ko;\n  vec3 oy23 = mod(floor(p23 * K), 7.0) * K - Ko;\n  vec3 oz23 = floor(p23 * K2) * Kz - Kzo;\n\n  vec3 ox31 = fract(p31 * K) - Ko;\n  vec3 oy31 = mod(floor(p31 * K), 7.0) * K - Ko;\n  vec3 oz31 = floor(p31 * K2) * Kz - Kzo;\n\n  vec3 ox32 = fract(p32 * K) - Ko;\n  vec3 oy32 = mod(floor(p32 * K), 7.0) * K - Ko;\n  vec3 oz32 = floor(p32 * K2) * Kz - Kzo;\n\n  vec3 ox33 = fract(p33 * K) - Ko;\n  vec3 oy33 = mod(floor(p33 * K), 7.0) * K - Ko;\n  vec3 oz33 = floor(p33 * K2) * Kz - Kzo;\n\n  vec3 dx11 = Pfx + jitter * ox11;\n  vec3 dy11 = Pfy.x + jitter * oy11;\n  vec3 dz11 = Pfz.x + jitter * oz11;\n\n  vec3 dx12 = Pfx + jitter * ox12;\n  vec3 dy12 = Pfy.x + jitter * oy12;\n  vec3 dz12 = Pfz.y + jitter * oz12;\n\n  vec3 dx13 = Pfx + jitter * ox13;\n  vec3 dy13 = Pfy.x + jitter * oy13;\n  vec3 dz13 = Pfz.z + jitter * oz13;\n\n  vec3 dx21 = Pfx + jitter * ox21;\n  vec3 dy21 = Pfy.y + jitter * oy21;\n  vec3 dz21 = Pfz.x + jitter * oz21;\n\n  vec3 dx22 = Pfx + jitter * ox22;\n  vec3 dy22 = Pfy.y + jitter * oy22;\n  vec3 dz22 = Pfz.y + jitter * oz22;\n\n  vec3 dx23 = Pfx + jitter * ox23;\n  vec3 dy23 = Pfy.y + jitter * oy23;\n  vec3 dz23 = Pfz.z + jitter * oz23;\n\n  vec3 dx31 = Pfx + jitter * ox31;\n  vec3 dy31 = Pfy.z + jitter * oy31;\n  vec3 dz31 = Pfz.x + jitter * oz31;\n\n  vec3 dx32 = Pfx + jitter * ox32;\n  vec3 dy32 = Pfy.z + jitter * oy32;\n  vec3 dz32 = Pfz.y + jitter * oz32;\n\n  vec3 dx33 = Pfx + jitter * ox33;\n  vec3 dy33 = Pfy.z + jitter * oy33;\n  vec3 dz33 = Pfz.z + jitter * oz33;\n\n  vec3 d11 = worley_dist(dx11, dy11, dz11);\n  vec3 d12 = worley_dist(dx12, dy12, dz12);\n  vec3 d13 = worley_dist(dx13, dy13, dz13);\n  vec3 d21 = worley_dist(dx21, dy21, dz21);\n  vec3 d22 = worley_dist(dx22, dy22, dz22);\n  vec3 d23 = worley_dist(dx23, dy23, dz23);\n  vec3 d31 = worley_dist(dx31, dy31, dz31);\n  vec3 d32 = worley_dist(dx32, dy32, dz32);\n  vec3 d33 = worley_dist(dx33, dy33, dz33);\n\n  vec3 d1a = min(d11, d12);\n  d12 = max(d11, d12);\n  d11 = min(d1a, d13); // Smallest now not in d12 or d13\n  d13 = max(d1a, d13);\n  d12 = min(d12, d13); // 2nd smallest now not in d13\n  vec3 d2a = min(d21, d22);\n  d22 = max(d21, d22);\n  d21 = min(d2a, d23); // Smallest now not in d22 or d23\n  d23 = max(d2a, d23);\n  d22 = min(d22, d23); // 2nd smallest now not in d23\n  vec3 d3a = min(d31, d32);\n  d32 = max(d31, d32);\n  d31 = min(d3a, d33); // Smallest now not in d32 or d33\n  d33 = max(d3a, d33);\n  d32 = min(d32, d33); // 2nd smallest now not in d33\n  vec3 da = min(d11, d21);\n  d21 = max(d11, d21);\n  d11 = min(da, d31); // Smallest now in d11\n  d31 = max(da, d31); // 2nd smallest now not in d31\n  d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n  d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n  d12 = min(d12, d21);                        // 2nd smallest now not in d21\n  d12 = min(d12, d22);                        // nor in d22\n  d12 = min(d12, d31);                        // nor in d31\n  d12 = min(d12, d32);                        // nor in d32\n  d11.yz = min(d11.yz, d12.xy);               // nor in d12.yz\n  d11.y = min(d11.y, d12.z);                  // Only two more to go\n  d11.y = min(d11.y, d11.z);                  // Done! (Phew!)\n  return sqrt(d11.x);                         // F1\n}\n\nfloat fbm_worley(vec3 p, uint octaves) {\n  float a = 1.0;\n  float n = 0.0;\n  for (uint i = 0u; i < octaves; i++) {\n    n += worley(p) * a;\n    p *= 2.0;\n    a *= 0.5;\n  }\n\n  return n;\n}\n\n// Hybrid multi-fractal noise from Musgrave, \"Procedural Fractal Terrains\"\n// https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/MusgraveTerrain00.pdf\nfloat hmf(vec2 p, uint iters) {\n  const float ex[6] =\n      float[6](0.803851, 0.6461764, 0.5194296, 0.4175439, 0.3356431, 0.2698071);\n  float n = 1.0;\n  float w = n;\n\n  for (uint i = 0u; i < iters; i++) {\n    p *= 1.95;\n    w *= (1.0 - abs(snoise(p))) * ex[i];\n    n += w;\n  }\n\n  return n;\n}\n\n// Ray-AABB intersection test\nvec2 intersectRayBox(vec3 ro, vec3 rd, vec3 bmin, vec3 bmax) {\n  vec3 tMin = (bmin - ro) / rd;\n  vec3 tMax = (bmax - ro) / rd;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  return vec2(tNear, tFar);\n}\n\n// Point-AABB intersection test\nfloat pointInsideBox(vec3 p, vec3 bmin, vec3 bmax) {\n  vec3 s = step(bmin, p) - step(bmax, p);\n  return s.x * s.y * s.z;\n}\n\n// Generate points on a hemisphere\n// i is the index of the current point\n// n is the total number of points\nvec3 forwardSF(float i, float n) {\n  const float PI = 3.141592653589793238;\n  const float PHI = 1.618033988749894848;\n  float phi = 2.0 * PI * fract(i / PHI);\n  float zi = 1.0 - (2.0 * i + 1.0) / n;\n  float sinTheta = sqrt(1.0 - zi * zi);\n  return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, zi);\n}\n\n// Remaps value V from range L0-H0 to range LN-HN\nfloat remap(float v, float l0, float h0, float ln, float hn) {\n  return ln + (v - l0) * (hn - ln) / (h0 - l0);\n}\n\n// Unpacks a 4-component vector of floats in range [0..1] from a 32-bit uint.\n// Can use unpackUnorm4x8() instead if available.\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml\nvec4 unpackUint4x8(uint x) {\n  return vec4(uvec4(x, x >> 8, x >> 16, x >> 24) & 0xFFu) / 255.0;\n}\n\n// Packs a 4-component vector of floats in range [0..1] into a 32-bit uint.\n// Can use packUnorm4x8() instead if available.\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/unpackUnorm.xhtml\nuint packUint4x8(vec4 v) {\n  uint x = 0u;\n  v = saturate(v) * 255.0;\n  x |= uint(v.x);\n  x |= uint(v.y) << 8;\n  x |= uint(v.z) << 16;\n  x |= uint(v.w) << 24;\n  return x;\n}\n\n//\n// Various 2D and 3D SDF modelling functions from\n// https://iquilezles.org/articles/distfunctions\n// https://iquilezles.org/articles/distfunctions2d\n// Code and examples at https://www.shadertoy.com/view/Xds3zN\n//\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n//\n\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\nfloat ndot(in vec2 a, in vec2 b) { return a.x * b.x - a.y * b.y; }\n\nfloat sdSphere(vec3 p, float s) { return length(p) - s; }\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdBoundingBox(vec3 p, vec3 b, float e) {\n  p = abs(p) - b;\n  vec3 q = abs(p + e) - e;\n  return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) +\n                     min(max(p.x, max(q.y, q.z)), 0.0),\n                 length(max(vec3(q.x, p.y, q.z), 0.0)) +\n                     min(max(q.x, max(p.y, q.z)), 0.0)),\n             length(max(vec3(q.x, q.y, p.z), 0.0)) +\n                 min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\nfloat sdQTorus(vec3 p, vec2 t) {\n  p -= vec3(t.x, 0.0, 0.0);\n  return max(sdBox(p + vec3(t.x, 0.0, t.x), vec3(t.x)), sdTorus(p, t));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb) {\n  p.x = abs(p.x);\n  float k = (sc.y * p.x > sc.x * p.y) ? dot(p.xy, sc) : length(p.xy);\n  return sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nfloat sdCone(in vec3 p, in vec2 c, float h) {\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h * vec2(c.x / c.y, -1.0);\n\n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n  float k = sign(q.y);\n  float d = min(dot(a, a), dot(b, b));\n  float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p, n) + h;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h) {\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0 * min(dot(k.xy, p.xy), 0.0) * k.xy;\n  vec2 d = vec2(length(p.xy - vec2(clamp(p.x, -k.z * h.x, k.z * h.x), h.x)) *\n                    sign(p.y - h.x),\n                p.z - h.y);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n  vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n  return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nvec3 opBend(vec3 p, float k) {\n  float c = cos(k * p.x);\n  float s = sin(k * p.x);\n  mat2 m = mat2(c, -s, s, c);\n  vec3 q = vec3(m * p.xy, p.z);\n  return q;\n}\n\nfloat sdCircle(vec2 p, float r) { return length(p) - r; }\n\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdUnevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1 - r2) / h;\n  float a = sqrt(1.0 - b * b);\n  float k = dot(p, vec2(-b, a));\n  if (k < 0.0)\n    return length(p) - r1;\n  if (k > a * h)\n    return length(p - vec2(0.0, h)) - r2;\n  return dot(p, vec2(a, b)) - r1;\n}\n\nfloat sdHexagram(in vec2 p, in float r) {\n  const vec4 k = vec4(-0.5, 0.8660254038, 0.5773502692, 1.7320508076);\n  p = abs(p);\n  p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n  p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n  p -= vec2(clamp(p.x, r * k.z, r * k.w), r);\n  return length(p) * sign(p.y);\n}\n\nfloat sdHexagon(in vec2 p, in float r) {\n  const vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n  p = abs(p);\n  p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n  p -= vec2(clamp(p.x, -k.z * r, k.z * r), r);\n  return length(p) * sign(p.y);\n}\n\nconst uint handwritingSDF[] = uint[](\n    213760u, 1125122048u, 3u, 286265872u, 4369u, 0u, 286331152u, 273u,\n    1125196304u, 323310932u, 609576530u, 1262352u, 19009536u, 36831232u,\n    148801u, 22508544u, 2454800u, 1982857216u, 37u, 1145259330u, 38028373u,\n    1145185074u, 1413825604u, 78916u, 1985242672u, 898140296u, 1469684085u,\n    3569203u, 342245888u, 628363264u, 2390097u, 22639616u, 4687120u,\n    2555510784u, 268435510u, 2290509940u, 628656264u, 2289325940u, 2290649224u,\n    153720u, 2574686289u, 913868937u, 2326366870u, 39364421u, 647591200u,\n    1201025024u, 21469522u, 22643728u, 39355408u, 2859732992u, 805306695u,\n    2274912150u, 897021815u, 2289396118u, 2004392328u, 158071u, 2054596689u,\n    860111957u, 2843039911u, 628799575u, 917284673u, 1504203264u, 342472786u,\n    22578192u, 57238272u, 2308317184u, 1375732312u, 1147762328u, 1395934260u,\n    1145407879u, 1145411668u, 158068u, 2037815361u, 805306643u, 2806138774u,\n    916244567u, 917289315u, 1790538768u, 915970131u, 22578193u, 343429632u,\n    2006401280u, 1947206249u, 291014009u, 1947205632u, 288786280u, 270964545u,\n    227699u, 2037819457u, 805306371u, 2519811990u, 1487583319u, 917150342u,\n    2055767600u, 1753647172u, 22578195u, 629620736u, 1703502592u, 2251293561u,\n    21468760u, 2251292672u, 3638599u, 2529072u, 293219u, 2054662225u,\n    842211876u, 2537637782u, 2038929495u, 917006504u, 2305201985u, 2305132612u,\n    22578230u, 1201025024u, 1399424289u, 2555450760u, 860194902u, 2287014451u,\n    39351349u, 2529072u, 858028386u, 2305271891u, 1181116006u, 2556643222u,\n    2556794966u, 916997785u, 2287307107u, 2537916485u, 22578264u, 1485115392u,\n    1111988034u, 2036540807u, 2004322661u, 2019767911u, 57173333u, 2528816u,\n    1986431330u, 3110578295u, 1201248665u, 1753634710u, 2537916772u, 915883130u,\n    2538961524u, 1965393990u, 21529977u, 1769144320u, 539330916u, 1485129622u,\n    2290649477u, 2307278728u, 343578760u, 3577376u, 2576984418u, 2842143129u,\n    895907720u, 1184458646u, 1948551523u, 915882584u, 2844297878u, 1377142615u,\n    21530264u, 2019688448u, 268659078u, 1184323717u, 1145395078u, 2006402116u,\n    629765735u, 3642912u, 1449630034u, 2555876950u, 824390726u, 1201166230u,\n    1662286179u, 1184387655u, 2522245015u, 806717272u, 21534870u, 2554396672u,\n    83864u, 1166567539u, 17900935u, 897082129u, 915882803u, 3642912u,\n    574003537u, 2287506722u, 805306405u, 1770342294u, 822376804u, 1721258275u,\n    2233611384u, 269846377u, 21543284u, 2519728128u, 9866u, 1684576338u,\n    286331768u, 39351569u, 1216684032u, 4691489u, 2529361u, 2555938064u,\n    841027877u, 2573420438u, 227686u, 1989693696u, 1929380440u, 2463593u,\n    21538897u, 2501902336u, 5242u, 1950852929u, 1413830009u, 3573300u,\n    1769213952u, 4756770u, 2529345u, 2555937808u, 1716868166u, 2807187350u,\n    223609u, 2543341824u, 1375732039u, 2459512u, 21534256u, 1947205632u, 600u,\n    2234947120u, 2290649241u, 1341271u, 1751318528u, 21529874u, 2529088u,\n    2539156480u, 2290649208u, 2519812246u, 223592u, 2274902272u, 1073741862u,\n    2459511u, 21525520u, 1375731712u, 54u, 1680172320u, 1717986918u, 152918u,\n    1464926208u, 4613138u, 1336624u, 1967547136u, 1432774519u, 1678788197u,\n    153173u, 1717972992u, 536870932u, 1332309u, 3494400u);\n\nfloat sampleHandwriting(uvec2 uvp) {\n  uint index = uvp.x / 8u + uvp.y * 16u;\n  uint mask = handwritingSDF[index];\n  return float((mask >> ((uvp.x & 0x7u) * 4u)) & 0xFu) * (1.0 / 15.0);\n}\n\nfloat handwritingTexture(vec2 uv) {\n  const uvec2 tt = uvec2(1u, 0u);\n  const vec2 size = vec2(127.0, 15.0);\n  const vec2 texelSize = vec2(1.0) / vec2(128.0, 16.0);\n  vec2 f = fract(uv * size);\n  uvec2 uvp = uvec2(abs(mod(uv, 1.0)) * size);\n\n  // bilinear filtering\n  float tl = sampleHandwriting(uvp);\n  float tr = sampleHandwriting(uvp + tt.xy);\n  float bl = sampleHandwriting(uvp + tt.yx);\n  float br = sampleHandwriting(uvp + tt.xx);\n  return mix(mix(tl, tr, f.x), mix(bl, br, f.x), f.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Generates the terrain heightmap on the first frame and caches it. The\n// heightmap itself is just a combination of different noises. Note the usage of\n// hybrid multi-fractal noise from Musgrave, \"Procedural Fractal\n// Terrains\". You can get the paper from here:\n// https://www.classes.cs.uchicago.edu/archive/2015/fall/23700-1/final-project/MusgraveTerrain00.pdf\n//\n// Also noteworthy is the slight domain distortion of the input UVs. You can\n// find more info about that at https://iquilezles.org/articles/warp\n\n// Because the alpha channel of this is otherwise unused, we use it to store\n// and update some persistent state with keyboard inputs.\n//\n\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n\nbool isKeyPressed(int key) {\n  return texelFetch(iChannel1, ivec2(key, 1), 0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / vec2(textureSize(iChannel0, 0));\n\n  // The code below deals with the persistent state (called global_State in the main code).\n  // The state consists of 4x uint8's packed in a uint and converted to 0..1 floats on read.\n  // The fields are described in the Buffer C shader.\n  vec4 pixel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n  if (all(equal(ivec2(fragCoord), ivec2(0)))) {\n    vec4 state = unpackUint4x8(floatBitsToUint(pixel.a));\n    if (iFrame == 0 || state.z < 0.1 || state.z > 0.7) {\n      state = vec4(0.4, 0.0, 0.4, 0.0);\n    }\n\n    state.xy = saturate(mix(state.xy, state.zw, 0.05));\n    \n    if (isKeyPressed(KEY_1)) {\n      state.zw = vec2(0.15, 0.0);\n    }\n\n    if (isKeyPressed(KEY_2)) {\n      state.zw = vec2(0.45, 0.1);\n    }\n\n    if (isKeyPressed(KEY_3)) {\n      state.zw = vec2(0.7, 1.0);\n    }\n\n    pixel.a = uintBitsToFloat(packUint4x8(state));\n    fragColor = vec4(0.0, 0.0, 0.0, pixel.a);\n    return;\n  }\n\n  // Hack to get the terrain buffer to redraw when the screen is resized.\n  if (dot(iResolution.xy, iResolution.xy) == pixel.a) {\n    fragColor = pixel;\n    return;\n  }\n    \n  // Terrain generation routine\n  // Several hybrid multi-fractal noises combined with some FBMs of Simplex noise\n  // and some Worley noise for good measure.\n  // I haven't tweaked this a lot but the initial results came out ok so eh.\n  uv += 14.0;\n\n  float h = 0.475;\n  uv.x += fbm(uv * 0.5, 5u) * 0.03;\n  uv.y += fbm(uv * 0.5 + vec2(117.0, 19.0), 5u) * 0.02;\n\n  h += hmf(uv * 0.9, 5u) * 0.25;\n  h *= clamp(hmf(uv * 1.1 + vec2(81.0, 63.0), 5u) - 0.5, 0.0, 1.0);\n  h -= (fbm(uv * 3.0, 4u) + 0.15) * 0.1;\n  h -= worley(uv * 4.0) * 0.2;\n  h += (1.0 - abs(fbm(uv * 8.0, 5u))) * 0.05;\n  h += fbm(uv * 48.0, 2u) * 0.01;\n\n  h = h * pow(abs(h), 0.11);\n\n  // free gradients, hooray\n  vec2 grad = vec2(dFdx(h), dFdy(h));\n\n  fragColor = vec4(h, grad, dot(iResolution.xy, iResolution.xy));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Here we generate the 3D texture used for the clouds. The output buffer is\n// unfortunately 2D so we slice it up and pick the correct slice during\n// sampling. This is not ideal as we lose on some nice free filtering. In a\n// production renderer the output buffer here would be a 3D texture.\n\n// The generation consists of combining several FBMs of Simplex (or\n// Perlin) and Worley noises and is described by Haggstrom 2018, \"Real-time\n// rendering of volumetric clouds\". You can get the paper from\n// http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 resolution = min(iResolution.xy, vec2(1024.0));\n\n  float sliceSize = iResolution.x < 500.0 ? 32.0 : 128.0;\n  float numSlices = floor(min(resolution.x, resolution.y) / sliceSize);\n  float totalSlices = numSlices * numSlices;\n\n  vec2 curSlice = floor(fragCoord / sliceSize);\n  if (curSlice.x > numSlices || curSlice.y > numSlices) {\n    return;\n  }\n\n  vec2 curOffset = fract(fragCoord / sliceSize) * sliceSize;\n  curOffset.x -= iTime * 1.5;\n  curOffset.y += sin(iTime * 0.1) * 2.0;\n\n  float curZ = (curSlice.x + curSlice.y * numSlices) / totalSlices;\n\n  vec3 p = vec3(curOffset, curZ * sliceSize * 0.25);\n  if (iResolution.x < 500.0) {\n    p *= 4.0;\n  }\n    \n  float s = (fbm(p * 0.025, 4u) + 1.0);\n  float w = 1.0 - fbm_worley(p * 0.025, 4u);\n\n  float n1 = saturate((s + w) * 0.5);\n  float n2 = saturate(1.0 - fbm_worley(p * 0.1, 3u) + 0.5);\n  float n3 = saturate(1.0 - fbm_worley(p * 0.2, 3u) + 0.5);\n  float n4 = saturate(1.0 - fbm_worley(p * 0.4, 3u) + 0.5);\n  fragColor = vec4(n1, n2, n3, n4);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ENABLE_CLOUDS 1\n#define ENABLE_SHADOWS 1\n#define ENABLE_AMBIENT_OCCLUSION 1\n#define ENABLE_REFLECTIONS 1\n\n#define DEBUG 0 // Set to 1 to enable the debug visualization.\n\n// Only one of these can be active at a time.\n#define DEBUG_ALBEDO 0\n#define DEBUG_NORMALS 1\n#define DEBUG_MATERIALS 0\n\n/*\n * Shading and lighting calculations\n */\n\n// The code below implements the Cook-Torrance microfacet\n// lighting model for line-segment lights.\n// Most of the implementation is taken from from Joey de Vries's excellent\n// https://learnopengl.com/PBR/Theory so check it out for the full explanation.\n// The line-segment lights are borrowed from:\n// https://www.elopezr.com/rendering-line-lights/\n//\n// All lighting calculations are in world space.\n\n// This struct stores the necessary information to light a non-reflective\n// surface. The fields are purposefully laid out in a packed 128-bit order.\n// No field should cross a 16 byte boundary otherwise the compiler will either need to\n// emit extra code for each access or add padding between the fields and waste cache space.\nstruct SurfaceData {\n  vec3 albedo;     // surface albedo RGB (diffuse color)\n  float metallic;  // metallic factor\n  vec3 position;   // world-space position\n  float roughness; // roughness factor\n  vec3 normal;     // world-space normal\n  float emissive;  // emissive intensity (multiplied by the albedo)\n  vec3 viewDir;    // normalized world-space view direction\n};\n\n// Additional data needed for lighting reflective surfaces\nstruct ReflectiveSurfaceData {\n  vec3 f0;         // reflectance at normal incidence (fresnel coefficient)\n  float roughness; // extra roughness value for calculating reflections\n  float strength;  // reflection strength\n};\n\n// This struct describes a single light source.\n// In our case the lights are geometrically represented as lines so we store\n// the start and end points instead of a single position.\n// If castShadows is false then the light won't be considered for shadowing\n// calculations. While physically incorrect this allows us to use extra lights\n// to fake environment illumination.\nstruct LightData {\n  vec3 start;       // world-space start of the line segment\n  vec3 end;         // world-space end of the line segment\n  vec3 color;       // light color\n  float intensity;  // light intensity\n  bool castShadows; // whether the light casts shadows\n};\n\n// The parameters of all the lights in the scene\nconst LightData SCENE_LIGHTS[] =\n    LightData[](LightData(vec3(-5.75, 3.65, 1.0),  // line-segment start\n                          vec3(-3.0, 3.65, -1.25), // line-segment end\n                          vec3(1.0),               // color\n                          30.0,                   // intensity\n                          true                     // cast shadows?\n                          ),\n                LightData(vec3(-8.0, 6.0, 12.0), // line-segment start\n                          vec3(8.0, 6.0, 12.0),  // line-segment end\n                          vec3(1.0),             // color\n                          30.0,                  // intensity\n                          false                  // cast shadows?\n                          ),\n                LightData(vec3(8.0, 5.0, -6.0), // line-segment start\n                          vec3(8.0, 5.0, 6.0),  // line-segment end\n                          vec3(1.0),            // color\n                          20.0,                 // intensity\n                          false                 // cast shadows?\n                          ));\n\n// The camera parameters\nconst vec3 CAMERA_POSITION = vec3(4.0, 9.5, 22.0);\nconst vec3 CAMERA_LOOK_AT = vec3(-3.1, 0.25, 0.0);\nconst float CAMERA_FOV = 37.0;\n\n// The AABB of the cloud volume\nconst vec3 CLOUDS_MIN = vec3(-2.0, 0.0, -2.0);\nconst vec3 CLOUDS_MAX = vec3(2.0, 3.0, 2.0);\n\nconst float PI = 3.14159265359;\n\n// Shlick's approximation of the fresnel term (the ratio between specular and\n// diffuse reflection).\n// cosTheta is the angle between the view direction and the light direction.\n// f0 is the surface reflectance at normal (zero degree) incidence.\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nvec3 fresnelSchlick(float cosTheta, vec3 f0) {\n  return f0 + (1.0 - f0) * pow(max(0.0, 1.0 - cosTheta), 5.0);\n}\n\n// The math behind the next three functions is described in \"Microfacet Models\n// for Refraction through Rough Surfaces\".\n// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf.\n\n// Trowbridge-Reitz/GGX normal distribution function\nfloat distributionGgx(vec3 n, vec3 h, float roughness) {\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float ndoth = max(dot(n, h), 0.0);\n  float ndothSq = ndoth * ndoth;\n\n  float num = a2;\n  float denom = (ndothSq * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n  return num / denom;\n}\n\nfloat geomSchlickGgx(float ndotv, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n  float num = ndotv;\n  float denom = ndotv * (1.0 - k) + k;\n  return num / denom;\n}\n\nfloat geomSmith(vec3 n, vec3 v, vec3 l, float roughness) {\n  float ndotv = max(dot(n, v), 0.0);\n  float ndotl = max(dot(n, l), 0.0);\n  float ggx2 = geomSchlickGgx(ndotv, roughness);\n  float ggx1 = geomSchlickGgx(ndotl, roughness);\n  return ggx1 * ggx2;\n}\n\n// Calculates the most representative diffuse point for a line-segment light\n// given a world position.\nvec3 diffuseMRP(vec3 p, vec3 lineStart, vec3 lineEnd) {\n  float a = length(lineStart - p);\n  float b = length(lineEnd - p);\n  float t = saturate(a / (b + a));\n  return lineStart + (lineEnd - lineStart) * t;\n}\n\n// Calculates the most represenative specular point for a line-segment light\n// given a world position and the reflection vector between the view direction\n// and surface normal.\nvec3 specularMRP(vec3 p, vec3 lineStart, vec3 lineEnd, vec3 r) {\n  vec3 pa = lineStart - p;\n  vec3 ab = lineEnd - lineStart;\n\n  float t_num = dot(r, pa) * dot(ab, r) - dot(ab, pa);\n  float t_denom = dot(ab, ab) - dot(ab, r) * dot(ab, r);\n  float t = saturate(t_num / t_denom);\n  return lineStart + ab * t;\n}\n\n// Physically correct inverse-square falloff\n// https://en.wikipedia.org/wiki/Inverse-square_law\nfloat invSqFalloff(vec3 p, vec3 lightPos) {\n  vec3 d = lightPos - p;\n  return 1.0 / dot(d, d);\n}\n\n// Calculates the direct illumination on a surface by a single line-segment\n// light according to the Cook-Torrance model.\n// https://learnopengl.com/PBR/Theory does a great job of explaining this\n// function line by line so I won't bother. One noteworthy difference is the\n// almost trivial change to use approximate line-segment lights instead of point lights.\nvec3 light(const SurfaceData surf, const LightData lightData) {\n  vec3 f0 = vec3(0.04);\n  f0 = mix(f0, surf.albedo, surf.metallic);\n\n  vec3 specMRP = specularMRP(surf.position, lightData.start, lightData.end,\n                             reflect(surf.viewDir, surf.normal));\n\n  vec3 l = normalize(specMRP - surf.position);\n  vec3 h = normalize(surf.viewDir + l);\n  vec3 f = fresnelSchlick(max(dot(h, surf.viewDir), 0.0), f0);\n  float ndf = distributionGgx(surf.normal, h, surf.roughness);\n  float g = geomSmith(surf.normal, surf.viewDir, l, surf.roughness);\n  vec3 num = ndf * g * f;\n  float ndotv = max(dot(surf.normal, surf.viewDir), 0.0);\n  float denom = 4.0 * ndotv * max(dot(surf.normal, l), 0.0);\n  vec3 specular = num / max(1e-10, denom);\n\n  vec3 kS = f;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - surf.metallic;\n\n  vec3 diffMRP = diffuseMRP(surf.position, lightData.start, lightData.end);\n\n  float ndotl = max(dot(surf.normal, normalize(diffMRP - surf.position)), 0.0);\n  vec3 radiance = lightData.color * lightData.intensity * ndotl;\n\n  vec3 color =\n      (kD * surf.albedo / PI) * radiance * invSqFalloff(surf.position, diffMRP);\n  color += specular * radiance * invSqFalloff(surf.position, specMRP);\n  return color;\n}\n\n// Stores the persistent global state.\n// x - current cloud coverage\n// y - current cloud density\n// z - target cloud coverage\n// w - target cloud density\nvec4 global_State;\n\n// Procedural clouds based on Haggstrom 2018, \"Real-time rendering of volumetric\n// clouds\". You can get the paper from\n// http://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n\n// Sample the 3D clouds texture which is actually a 2D texture so we have to do\n// some math on each sample and we lose out on filtering. Unfortunate.\nvec4 cloudsTexture(vec3 p) {\n  float sliceSize = iResolution.x < 500.0 ? 32.0 : 128.0;\n  vec2 texSize = vec2(textureSize(iChannel2, 0));\n  float numSlices = floor(min(1024.0, min(texSize.x, texSize.y)) / sliceSize);\n  float sliceIndex = floor(p.y * (numSlices * numSlices));\n  float sliceY = floor(sliceIndex / numSlices);\n  float sliceX = floor(sliceIndex - sliceY * numSlices);\n  vec2 uv = (vec2(sliceX, sliceY) + p.xz) * (sliceSize / texSize);\n  return texelFetch(iChannel2, ivec2(uv * texSize), 0);\n}\n\n// Shape-altering height-function from the paper\nfloat cloudsHeight(float ph, float gc) {\n  const float stopHeight = 1.12;\n\n  float height = saturate(remap(ph, 0.0, 0.07, 0.0, 1.0));\n  height *= saturate(remap(ph, stopHeight * 0.2, stopHeight, 1.0, 0.0));\n  height = pow(height, saturate(remap(ph, 0.65, 0.95, 1.0, (1.0 - 0.25 * gc))));\n  return height;\n}\n\n// Density-altering height-function from the paper\nfloat cloudsDensity(float ph) {\n  float density = ph;\n  density *= saturate(remap(ph, 0.0, 0.2, 0.0, 1.0));\n  density *= 32.0;\n  density *= mix(1.0, saturate(remap(pow(ph, 0.5), 0.4, 0.95, 1.0, 0.2)), 0.25);\n  density *= saturate(remap(ph, 0.9, 1.0, 1.0, 0.0));\n  return density;\n}\n\n// Returns the density of the clouds volume at point P as a vec2 (sigmaS, sigmaE).\nvec2 sampleClouds(vec3 p) {\n  // Transform p to \"cloud space\" [0..1] in all directions\n  p -= CLOUDS_MIN;\n  p /= CLOUDS_MAX - CLOUDS_MIN;\n\n  // Sample the clouds texture.\n  vec4 n = cloudsTexture(p.xzy);\n\n  // Combine the 4 channels into a density value.\n  float sn =\n      remap(n.r, dot(n.gba, vec3(0.625, 0.25, 0.125)) - 1.0, 1.0, 0.0, 1.0);\n\n  // ph is the percentage height in cloud space [0..1]\n  float ph = saturate(p.y * 1.4 - 0.6);\n  float sn2 = sn;\n    \n  // Read the global cloud coverage from the pertsistent state.\n  float gc = global_State.x;\n\n  // Function 11 from the paper\n  sn *= cloudsHeight(ph, gc);\n  float wm = max(0.8, saturate(gc - 0.5) * 2.0);\n  sn = saturate(remap(sn, 1.0 - gc * wm, 1.0, 0.0, 1.0));\n  sn *= cloudsDensity(ph);\n\n  return vec2(sn, max(0.000001, global_State.y * 1.25 + sn));\n}\n\n// Traces a shadow ray through the volume, returns the shadowing amount [0..1].\nfloat traceVolumeShadow(vec3 worldPos, vec3 lightDir, float stepSize) {\n  const float numSteps = 6.0;\n\n  float shadow = 1.0;\n  for (float t = ZERO; t < numSteps; t += 1.0) {\n    worldPos += lightDir * stepSize;\n    shadow *= exp(-sampleClouds(worldPos).y * stepSize);\n  }\n\n  return shadow;\n}\n\n// Rayleight scattering phase function\n// https://en.wikipedia.org/wiki/Rayleigh_scattering\nfloat rayleighScattering(vec3 inDir, vec3 outDir) {\n  float cosAngle = dot(inDir, outDir) / (length(inDir) * length(outDir));\n  float nom = 3.0f * (1.0f + cosAngle * cosAngle);\n  float denom = 16.0f * 3.141592f;\n  return nom / denom;\n}\n\n// Traces a ray through the volume and returns computed scattering and extinction.\n// Scattering is a combination of in- and out-scattering where the\n// out-scattering is computed iteratively by calling traceVolumeShadow() at each step,\n// the in-scattering is simulated via a phase function. I've chosen to only add Rayleigh scattering\n// as it's cheap to compute. Check the paper for a more sophisticated scattering algorithm.\nvec4 traceVolume(vec3 ro, vec3 rd, float maxDist, const LightData lightData,\n                 float jitter) {\n  const uint numSteps = 32u;\n  // Multiply the light intensity by this value as an artistic choice,\n  // otherwise the clouds look too dark for the scene lighting.\n   \n  const float intensityMultiplier = 4.0;\n  float stepSize = maxDist / float(numSteps);\n\n  // Extinction factor. Start from one and decrease it at each step by \n  // a function of the computed cloud density at that position.\n  float extinction = 1.0;\n  vec3 scattering = vec3(0.0);\n  rd *= stepSize;\n    \n  // Add some jitter to smooth out discretization artifacts.\n  // If numSteps is high enough this probably won't be necessary.\n  ro += rd * jitter;\n\n  for (uint t = UZERO; t < numSteps; t++) {\n    vec2 density = sampleClouds(ro);\n\n    if (density.x > 0.001) {\n      // Compute the most representative point on the line-segment\n      // to use as the light position.\n      vec3 lightPos = diffuseMRP(ro, lightData.start, lightData.end);\n        \n      // Compute the light direction.\n      vec3 lightDir = normalize(lightPos - ro);\n\n      float e = exp(-density.y * stepSize);\n\n      // S is the scattering contribution for the current step\n      vec3 S = lightData.color * lightData.intensity * intensityMultiplier;\n        \n      // Multiply by the current density.\n      S *= density.x;\n        \n      // Apply light falloff.\n      S *= invSqFalloff(ro, lightPos);\n        \n      // Compute in-scattering.\n      S *= rayleighScattering(-lightDir, -rd);\n        \n      // Compute out-scattering.\n      S *= traceVolumeShadow(ro, lightDir, 0.1);\n        \n      // Final scattering calculation.\n      S = (S - S * e) / density.y;\n\n      // Add to total scattering scaled by the current extinction.\n      scattering += extinction * S;\n      \n      // Scale the current extinction by the computed extinction for this step.\n      extinction *= e;\n    }\n\n    // Optimization to skip some steps if the extinction gets too low.\n    if (extinction < 0.001) {\n      break;\n    }\n\n    ro += rd;\n  }\n\n  // Artistic choice to multiply the scattering by a constant tint color.\n  scattering *= vec3(1.2, 1.2, 1.25) * 0.92;\n  return vec4(scattering, max(0.0, extinction));\n}\n\n// SDF and material definitions\n\n#define MISSING_MATERIAL 0u\n#define BOX_MATERIAL 1u\n#define COFFEE_CUP_MATERIAL 2u\n#define PAPER_MATERIAL 3u\n#define PENCIL_BODY_A_MATERIAL 4u\n#define PENCIL_BODY_B_MATERIAL 5u\n#define PENCIL_TIP_MATERIAL 6u\n#define LAMP_MATERIAL 7u\n#define LAMP_EMISSIVE_MATERIAL 8u\n#define FLOOR_MATERIAL 9u\n#define WALL_A_MATERIAL 10u\n#define WALL_B_MATERIAL 11u\n#define CRT_DEVICE_MATERIAL 12u\n#define CRT_SCREEN_MATERIAL 13u\n#define TERRAIN_MATERIAL 14u\n#define TERRAIN_WATER_MATERIAL 15u\n#define BUTTONS_BODY_MATERIAL 16u\n#define BUTTONS_1_MATERIAL 17u\n#define BUTTONS_2_MATERIAL 18u\n#define BUTTONS_3_MATERIAL 19u\n\nvoid sdCup(vec3 p, inout float minT, inout uint materialId) {\n  // coffee cup - made up of a rounded cylinder subtracted by another smaller\n  // rounded cylinder and a deformed capped torus for the handle\n  vec3 pCup =\n      mat3(-0.65364, 0.0, -0.75680, 0.0, 1.00, 0.0, 0.75680, 0.0, -0.65364) *\n      (p + vec3(5.75, -1.0, -4.25));\n  float tmp = sdRoundedCylinder(pCup, 0.4, 0.05, 0.95);\n\n  if (tmp > 4.0) {\n    return;\n  }\n\n  vec3 pCloud =\n      mat3(1.0, 0.0, 0.0, 0.0, 0.0008, 1.0, 0.0, -1.0, 0.0008) *\n      opBend(mat3(1.0, 0.0, 0.0, 0.0, 0.0008, -1.0, 0.0, 1.0, 0.0008) *\n                 (pCup + vec3(0.0, 0.0, 0.92)),\n             0.6);\n  const float c = 0.3;\n  const vec3 l = vec3(0.0, 2.0, 0.0);\n\n  if (tmp < 0.01) {\n    tmp = max(\n        tmp,\n        -max(sdPlane(pCloud, vec3(0.0, 0.0, 1.0), -0.13),\n             min(sdBox(pCloud + vec3(0.0, -0.04, 0.1), vec3(0.4, 0.15, 0.3)),\n                 min(sdSphere(pCloud + vec3(0.1, -0.275, 0.05), 0.265),\n                     min(sdSphere(pCloud + vec3(-0.16, -0.26, 0.05), 0.25),\n                         min(sdSphere(pCloud + vec3(-0.325, -0.06, 0.05), 0.25),\n                             sdSphere(pCloud + vec3(0.325, -0.06, 0.05),\n                                      0.25)))))));\n\n    tmp = min(\n        tmp, max(-sdPlane(pCloud, vec3(0.0, 0.0, 1.0), -0.12),\n                 min(sdBox(opBend(pCloud + vec3(0.0, -0.025, -0.15), 4.0),\n                           vec3(0.12, 0.015, 0.05)),\n                     min(sdSphere(pCloud + vec3(0.16, -0.2, -0.15), 0.045),\n                         sdSphere(pCloud + vec3(-0.16, -0.2, -0.15), 0.045)))));\n  }\n\n  tmp = opSmoothSubtraction(\n      sdRoundedCylinder(pCup + vec3(0.0, -0.05, 0.0), 0.37, 0.025, 0.925), tmp,\n      0.05);\n\n  tmp = opSmoothUnion(\n      tmp,\n      sdCappedTorus(\n          mat3(0.0008, 1.0, 0.0, -1.0, 0.0008, 0.0, 0.0, 0.0, 1.0) *\n              (vec3(1.0, 1.25, 1.0) *\n               ((pCup - clamp(pCup, -0.09, 0.08) + vec3(-0.65, -0.05, 0.0)))),\n          vec2(0.95, 0.05), 0.65, 0.05),\n      0.1);\n  if (tmp < minT) {\n    materialId = COFFEE_CUP_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdPencil(vec3 p, inout float minT, inout uint materialId) {\n  // pencil - a hex prism and a cone, a smaller slightly offset cone is used\n  // for the smaller metallic part of the tip\n  vec3 pPencil =\n      mat3(0.0707, 0.0, 0.9975, 0.0, 1.0, 0.0, -0.9975, 0.0, 0.0707) *\n      (p + vec3(3.25, 0.043 - 0.0925, -5.98));\n  float tmp = sdHexPrism(pPencil, vec2(0.04, 1.25));\n\n  if (tmp > 0.2) {\n    return;\n  }\n\n  if (tmp < minT) {\n    materialId = PENCIL_BODY_A_MATERIAL;\n    minT = tmp;\n  }\n\n  pPencil = (mat3(1.0, 0.0, 0.0, 0.0, 0.0707, -0.9975, 0.0, 0.9975, 0.0707) *\n             mat3(0.0008, 0.0, -1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0008)) *\n            (p + vec3(4.71, 0.025 - 0.0925, -5.89));\n  tmp = min(tmp, sdCone(pPencil, vec2(0.39, 1.95), 0.22));\n  tmp = max(tmp, sdPlane(pPencil, normalize(vec3(1.0, 1.0, 0.0)), 0.03));\n  if (tmp < minT) {\n    minT = tmp;\n    materialId = PENCIL_BODY_B_MATERIAL;\n  }\n\n  tmp = min(tmp, sdCone(pPencil, vec2(0.39, 1.95), 0.1) - 0.0000001);\n  tmp = max(tmp, sdPlane(pPencil, normalize(vec3(1.0, 1.0, 0.0)), 0.03));\n  if (tmp < minT) {\n    minT = tmp;\n    materialId = PENCIL_TIP_MATERIAL;\n  }\n}\n\nvoid sdLamp(vec3 p, inout float minT, inout uint materialId, bool shadowRay) {\n  // lamp - several 1/4ths of a torus connected by 90 degree flips\n\n  if (distance(p, vec3(-6.0, 2.0, 0.0)) > 6.0) {\n    return;\n  }\n\n  vec3 pLamp = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n               (p + vec3(4.5, 0.0, 0.0));\n\n  const vec3 oo = vec3(1.0, -1.0, 0.0);\n  float tmp =\n      max(sdPlane(pLamp, vec3(0.0, 0.95, 0.0), -0.75),\n          sdLink(oo.yyx * (pLamp + vec3(-0.0025, -1.2, 0.0)), 0.505, 0.6, 0.099));\n  tmp = opSmoothUnion(tmp, sdBox(pLamp, vec3(1.25, 0.125, 1.25)) - 0.025, 0.1);\n\n  const vec2 sz = vec2(1.0, 0.1);\n\n  tmp = min(tmp, sdQTorus(oo.yxy * (pLamp + vec3(0.597, -0.742, 0.0)).zxy, sz));\n  tmp = min(tmp, sdQTorus(oo.yyx * (pLamp + vec3(0.595, -1.74, 1.0)).xyz, sz));\n  tmp = min(tmp, sdQTorus(oo.xyx * (pLamp + vec3(1.55, -1.74, 2.0)).yzx, sz));\n  tmp = min(tmp, sdQTorus(oo.xyy * (pLamp + vec3(2.55, -2.7, 2.0)).zxy, sz));\n  tmp = min(tmp, sdQTorus(oo.yxx * (pLamp + vec3(1.55, -3.7, 0.0)).zyx, sz));\n\n  if (tmp < minT) {\n    materialId = LAMP_MATERIAL;\n    minT = tmp;\n  }\n\n  if (!shadowRay) {\n    tmp = sdCappedCylinder(oo.yxx * (pLamp + vec3(-0.2, -3.7, 0.01)).yxz, 0.1,\n                           1.75) +\n          0.012;\n    if (tmp < minT) {\n      materialId = LAMP_EMISSIVE_MATERIAL;\n      minT = tmp;\n    }\n  }\n}\n\nvoid sdCrtDevice(vec3 p, inout float minT, inout uint materialId) {\n  // crt device\n  vec3 pDevice = p + vec3(10.0, -3.0, 3.0);\n  float tmp = sdBox(pDevice, vec3(3.0, 3.0, 2.0));\n\n  if (tmp > 7.5) {\n    return;\n  }\n\n  tmp = max(-sdBox(pDevice + vec3(0.0, 0.0, -3.3), vec3(2.7)), tmp);\n  if (tmp < minT) {\n    materialId = CRT_DEVICE_MATERIAL;\n    minT = tmp;\n  }\n\n  tmp = min(sdBox(pDevice + vec3(0.0, 0.0, -1.0), vec3(2.3, 2.3, 0.5)) - 0.4,\n            tmp);\n  if (tmp < minT) {\n    materialId = CRT_SCREEN_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdTerrainBox(vec3 p, inout float minT, inout uint materialId) {\n  const vec3 boxSize = (CLOUDS_MAX - CLOUDS_MIN) * 0.5;\n\n  float tmp = sdBoundingBox(p - vec3(0.0, 1.5, 0.0), boxSize, 0.05);\n  if (tmp < minT) {\n    materialId = BOX_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdTerrain(vec3 p, inout float minT, inout uint materialId) {\n  // miniature terrain\n  const vec3 cMin = CLOUDS_MIN;\n  const vec3 cMax = CLOUDS_MAX;\n  const vec3 boxSize = (cMax - cMin) * 0.5;\n\n  if (abs(p.x) > 3.5 || abs(p.z) > 3.5) {\n    return;\n  }\n\n  ivec2 uv = ivec2(((p.xz - cMin.xz) / (cMax.xz - cMin.xz)) *\n                   vec2(textureSize(iChannel3, 0)));\n  float tmp = p.y - texelFetch(iChannel3, uv, 0).r;\n\n  tmp =\n      max(tmp, sdBox(p - vec3(0.0, 1.0, 0.0), vec3(boxSize.x, 1.0, boxSize.z)));\n\n  if (tmp < minT) {\n    materialId = TERRAIN_MATERIAL;\n    minT = tmp;\n  }\n\n  tmp = sdBox(p - vec3(0.0, 0.375, 0.0),\n              vec3(boxSize.x - 0.01, 0.3, boxSize.z - 0.01));\n  if (tmp < minT) {\n    materialId = TERRAIN_WATER_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdRoom(vec3 p, inout float minT, inout uint materialId) {\n  // floor\n  float tmp = sdPlane(p + vec3(0.0, 0.124, 0.0), vec3(0.0, 1.0, 0.0), -0.12);\n\n  // tmp = max(tmp, sdPlane(p, vec3(0.0, 0.0, -1.0), -3.45));\n  if (tmp < minT) {\n    materialId = FLOOR_MATERIAL;\n    minT = tmp;\n  }\n\n  // wall\n  tmp = sdPlane(p, vec3(0.0, 0.0, 1.0), 5.5);\n  if (tmp < minT) {\n    materialId = WALL_B_MATERIAL;\n    minT = opSmoothUnion(tmp, minT, 0.01);\n  }\n\n  tmp = sdBox(p + vec3(0.0, -2.0, 5.15), vec3(20.0, 0.5, 0.05));\n  if (tmp < minT) {\n    materialId = WALL_A_MATERIAL;\n    minT = tmp;\n  }\n}\n\nvoid sdPaper(vec3 p, inout float minT, inout uint materialId) {\n  // paper - just a very thin box\n  vec3 pPaper = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n                (p + vec3(3.5, 0.0, -6.0));\n  float tmp = sdBox(pPaper, vec3(2.1, 0.001, 2.97));\n  if (tmp < minT) {\n    materialId = PAPER_MATERIAL;\n    minT = tmp;\n  }\n}\n\nuint getActiveButton() {\n  return global_State.z < 0.2 ? 1u : (global_State.w < 0.1 ? 2u : 3u);\n}\n\nvoid sdButtons(vec3 p, inout float minT, inout uint materialId) {\n  vec3 pButtons =\n      mat3(0.9950, 0.0, -0.0998, 0.0, 1.0000, 0.0, 0.0998, 0.0, 0.9950) *\n      (p + vec3(-0.15, 0.0, -5.0));\n  float tmp = sdBox(pButtons, vec3(1.9, 0.25, 0.65));\n\n  if (tmp > 0.4) {\n    return;\n  }\n\n  if (tmp < minT) {\n    materialId = BUTTONS_BODY_MATERIAL;\n    minT = tmp;\n  }\n\n  uint activeButton = getActiveButton();\n\n  float yOffset = float(activeButton == 1u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(1.25, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_1_MATERIAL;\n    minT = tmp;\n  }\n\n  yOffset = float(activeButton == 2u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(0.0, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_2_MATERIAL;\n    minT = tmp;\n  }\n\n  yOffset = float(activeButton == 3u) * 0.03;\n  tmp = sdRoundBox(pButtons + vec3(-1.25, -0.15 + yOffset, 0.0),\n                   vec3(0.45, 0.15, 0.45), 0.035);\n  if (tmp < minT) {\n    materialId = BUTTONS_3_MATERIAL;\n    minT = tmp;\n  }\n}\n\n// The signed distance function representing the static geometry in the scene.\n// Takes a world space position and returns the signed distance to the closest\n// surface as well as its material ID. The shadowRay boolean is a hack\n// to skip the rendering of the rather solid geometry enclosing the light\n// source for shadow rays (or the whole scene will be in shadow).\nfloat sceneSDF(vec3 p, out uint materialId, bool shadowRay) {\n  float minT = 1e7;\n  materialId = MISSING_MATERIAL;\n  sdRoom(p, minT, materialId);\n\n  // A pseudo-kdtree check. Use some hardcoded planes to split the scene so\n  // approximately the same amount of pixels lie on each side of the plane.\n  // The checks have trivial cost compared to calculating the objects\n  // so this is a huge performance win (assuming the compiler actually emits a branch).\n  // Unfortunately, positioning the planes so they don't mess up the distance field\n  // is not straightforward as the problem is both scene and view- dependent.\n  // A more sophisticated approach would somehow account for the split planes in the raymarching algorithm.\n\n  float d = dot(vec4(p, 1.0), vec4(0.0, 0.0, 1.0, -3.1));\n  float d2 = dot(vec4(p, 1.0), vec4(1.0, 0.0, 0.0, 2.5));\n  float d3 = dot(vec4(p, 1.0), vec4(0.0, 1.0, 0.0, -0.5));\n\n  if (d3 < 0.0) {\n    sdPaper(p, minT, materialId);\n\n    if (d > 0.0) {\n      sdPencil(p, minT, materialId);\n      sdButtons(p, minT, materialId);\n    }\n  }\n\n  if (d > 0.0) {\n    if (d2 < 0.0) {\n      sdCup(p, minT, materialId);\n    }\n  } else {\n    if (d2 > 0.0) {\n      sdTerrain(p, minT, materialId);\n    } else {\n      sdLamp(p, minT, materialId, shadowRay);\n      sdCrtDevice(p, minT, materialId);\n    }\n  }\n\n  if (d2 > 0.0) {\n    sdTerrainBox(p, minT, materialId);\n  }\n\n  return minT;\n}\n\n\n// Material definition for the piece of paper\nvoid paperMaterial(inout SurfaceData surfData) {\n  const vec3 paperSize = vec3(2.1, 0.0, 2.97);\n\n  vec3 offset = mat3(0.7648, 0.0, 0.6442, 0.0, 1.0, 0.0, -0.6442, 0.0, 0.7648) *\n                    (surfData.position + vec3(3.5, 0.0, -6.0)) -\n                paperSize * 0.5;\n  // get UVs in the local space of tha paper\n  vec2 uv =\n      vec2(dot(offset, vec3(1.0, 0.0, 0.0)), dot(offset, vec3(0.0, 0.0, 1.0)));\n\n  uv /= paperSize.xz;\n\t\n  // draw the horizontal lines\n  float lines = smoothstep(0.0, 0.01, mod(uv.y, 0.05));\n  surfData.albedo = mix(vec3(0.25, 0.25, 0.8), vec3(1.0), 0.75 + 0.25 * lines);\n\n  uv += vec2(0.75, 1.03);\n  if (uv.y > 0.1) {\n    uv.y -= 0.1;\n  } else {\n    uv.x += 0.1;\n    uv.x *= step(0.185, uv.x);\n    uv.x *= 1.0 - step(0.315, uv.x);\n  }\n\n  uv.y *= 128.0 / 22.0;\n  uv *= 2.0;\n\n  // sample the handwriting texture\n  float sdf = 0.0;\n  if (uv.x > 0.0 && uv.y > 0.0 && uv.x < 1.0 && uv.y < 1.0) {\n    sdf = handwritingTexture(uv);\n    sdf = smoothstep(0.35, 0.65, sdf);\n    sdf = saturate(sdf);\n  }\n\n  surfData.albedo *= 1.0 - sdf;\n  surfData.metallic = mix(0.0, 0.15, sdf);\n  surfData.roughness = mix(0.99, 0.4, sdf);\n}\n\n// The material of the CRT screen\nvoid crtScreenMaterial(inout SurfaceData surfData) {\n  const vec3 deviceOffset = vec3(10.0, -3.0, 3.0);\n\n  vec2 uv = vec2(dot(surfData.position + deviceOffset, vec3(1.0, 0.0, 0.0)),\n                 dot(surfData.position + deviceOffset, vec3(0.0, 1.0, 0.0)));\n\n  const float radius = 6.0;\n  const float angle = 1.75;\n\n  float vignette = 1.0 - sqrt(pow(uv.x, 2.0) + pow(uv.y, 2.0));\n  float d = 0.0;\n\n  float time = iTime * 0.02;\n  uv *= 0.3;\n  uv *= mat2(cos(time), -sin(time), sin(time), cos(time));\n\n  float dist = length(uv);\n  float percent = (radius - dist) / radius;\n  float theta = percent * percent * (angle * 8.0);\n  float s = sin(theta);\n  float c = cos(theta);\n  uv = vec2(dot(uv, vec2(c, -s)), dot(uv, vec2(s, c)));\n  uv += 0.5;\n\n  d += abs(fbm(uv * 2.0, 5u) + 0.7) * (1.0 - smoothstep(0.0, 0.75, dist));\n\n  surfData.albedo = mix(vec3(0.156), vec3(0.0, 1.0, 0.2), saturate(d * 0.8)) *\n                    saturate(vignette + 2.5);\n  surfData.metallic = 0.0;\n  surfData.roughness = 0.01;\n  surfData.emissive = 0.25;\n}\n\n// The miniature terrain material\nvoid terrainMaterial(inout SurfaceData surfData) {\n  float h = max(0.0, surfData.position.y - 0.75);\n\n  vec3 albedo;\n  if (h < 0.5) {\n    albedo = mix(vec3(0.1, 0.2, 0.15), vec3(0.53, 0.64, 0.48),\n                 smoothstep(0.1, 1.0, h * 2.0));\n  } else {\n    albedo = vec3(0.9);\n  }\n\n  surfData.albedo = albedo;\n  surfData.roughness = 0.95;\n}\n\n// Miniature terrain water material\nvoid terrainWaterMaterial(inout SurfaceData surfData) {\n  const vec3 colorA = vec3(0.4, 0.6, 0.86);\n  const vec3 colorB = vec3(0.25, 0.25, 0.55);\n\n  float fresnel =\n      pow((1.0 - saturate(dot(surfData.normal, surfData.viewDir))), 0.3);\n\n  surfData.albedo = mix(colorA, colorB, fresnel);\n\n  if (dot(surfData.normal, vec3(0.0, 1.0, 0.0)) > 0.95) {\n    vec3 n = noised(surfData.position.xz * 36.0 + vec2(iTime * 0.3, 0.0));\n    surfData.normal = normalize(vec3(n.y, 2.0, n.z));\n  }\n\n  surfData.roughness = 0.3;\n}\n\n// The materials of the change weather buttons\nvoid buttonsMaterial(inout SurfaceData surfData, uint buttonId) {\n  bool isActive = buttonId == getActiveButton();\n  vec3 offset =\n      mat3(0.9950, 0.0, -0.0998, 0.0, 1.0000, 0.0, 0.0998, 0.0, 0.9950) *\n      (surfData.position + vec3(-0.15, 0.0, -5.0));\n  offset.x -= buttonId == 1u ? -1.25 : (buttonId == 2u ? 0.0 : 1.25);\n  vec2 uv = vec2(dot(offset, vec3(1.0, 0.0, 0.0)),\n                 dot(offset, vec3(0.0, 0.0, -1.0))) *\n            (1.0 / 0.9);\n\n  // The icons are just 2D SDFs in UV space.\n  float icon = 1e20;\n  if (buttonId == 1u) {\n    icon = max(-sdHexagon(uv, 0.25), sdHexagram(uv, 0.19));\n    icon = min(icon, sdCircle(uv, 0.2));\n  } else {\n    uv += buttonId == 2u ? vec2(-0.1, 0.15) : vec2(0.0, -0.1);\n\n    icon = sdCircle(uv + vec2(0.2, 0.1), 0.1);\n    icon = min(sdCircle(uv + vec2(-0.2, 0.1), 0.1), icon);\n    icon = min(sdCircle(uv + vec2(0.15, -0.05), 0.125), icon);\n    icon = min(sdCircle(uv + vec2(0.0, -0.075), 0.15), icon);\n    icon = min(sdCircle(uv + vec2(-0.15, -0.05), 0.1), icon);\n    icon = min(sdBox(uv + vec2(0.0, 0.1), vec2(0.2, 0.1)), icon);\n\n    if (buttonId == 2u) {\n      uv += vec2(0.15, -0.175);\n      float tmp = max(-sdHexagon(uv, 0.25), sdHexagram(uv, 0.19));\n      tmp = min(tmp, sdCircle(uv, 0.2));\n      icon = min(icon, max(-icon, tmp));\n    } else {\n      icon = min(sdUnevenCapsule(uv + vec2(0.0, 0.45), 0.03, 0.005, 0.1), icon);\n      icon =\n          min(sdUnevenCapsule(uv + vec2(0.15, 0.375), 0.03, 0.005, 0.1), icon);\n      icon =\n          min(sdUnevenCapsule(uv + vec2(-0.15, 0.36), 0.03, 0.005, 0.1), icon);\n    }\n  }\n\n  float darken = pow(1.0 - dot(uv, uv), 1.7);\n  surfData.albedo =\n      mix(vec3(0.35), vec3(0.9), smoothstep(0.0, 0.02, abs(icon))) *\n      saturate(darken + 0.5);\n  surfData.roughness = 0.9;\n  surfData.emissive = isActive ? 0.45 * saturate(darken + 0.25) : 0.0;\n}\n\n// Fills the surface data struct given a material ID.\n// The more complex materials have been moved into their own functions to\n// keep the code cleaner. Note this has no effect on the emitted assembly as\n// function calls don't exist neither does a stack so everything is always\n// inlined by the compiler regardless.\nvoid fillSurfaceData(uint materialId, inout SurfaceData surfData) {\n  switch (materialId) {\n  case MISSING_MATERIAL:\n    surfData.albedo = vec3(1.0, 0.0, 1.0);\n    break;\n  case BOX_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.roughness = 0.9;\n    break;\n  case COFFEE_CUP_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.roughness = 0.23;\n    break;\n  case PAPER_MATERIAL:\n    paperMaterial(surfData);\n    break;\n  case PENCIL_BODY_A_MATERIAL:\n    surfData.albedo = vec3(214.0, 148.0, 8.0) / 255.0;\n    surfData.roughness = 0.5;\n    break;\n  case PENCIL_BODY_B_MATERIAL:\n    surfData.albedo = vec3(252.0, 215.0, 163.0) / 255.0;\n    surfData.roughness = 0.9;\n    break;\n  case PENCIL_TIP_MATERIAL:\n    surfData.albedo = vec3(0.25);\n    surfData.metallic = 0.3;\n    surfData.roughness = 0.1;\n    break;\n  case LAMP_MATERIAL:\n    surfData.albedo = vec3(0.955, 0.637, 0.538);\n    surfData.metallic = 0.7;\n    surfData.roughness = 0.65;\n    break;\n  case LAMP_EMISSIVE_MATERIAL:\n    surfData.albedo = SCENE_LIGHTS[0].color;\n    surfData.emissive = SCENE_LIGHTS[0].intensity * 0.05;\n    break;\n  case FLOOR_MATERIAL:\n    surfData.albedo =\n        textureLod(iChannel1, mod(surfData.position.xz * 0.25, 1.0), 0.0).rgb;\n        \n    // albedo from sRGB to linear space\n    surfData.albedo = pow(surfData.albedo, vec3(2.2));\n    surfData.metallic = 0.0;\n    surfData.roughness = 0.5;\n    break;\n  case WALL_A_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.metallic = 0.3;\n    surfData.roughness = 0.5;\n    break;\n  case WALL_B_MATERIAL:\n    surfData.albedo = vec3(0.5);\n    surfData.metallic = 0.45;\n    surfData.roughness = 0.8;\n    break;\n  case CRT_DEVICE_MATERIAL:\n    surfData.albedo = vec3(0.05);\n    surfData.metallic = 0.75;\n    surfData.roughness = 0.9;\n    break;\n  case BUTTONS_BODY_MATERIAL:\n    surfData.albedo = vec3(1.0);\n    surfData.metallic = 0.0;\n    surfData.roughness = 0.35;\n    break;\n  case CRT_SCREEN_MATERIAL:\n    crtScreenMaterial(surfData);\n    break;\n  case TERRAIN_MATERIAL:\n    terrainMaterial(surfData);\n    break;\n  case TERRAIN_WATER_MATERIAL:\n    terrainWaterMaterial(surfData);\n    break;\n  case BUTTONS_1_MATERIAL:\n  case BUTTONS_2_MATERIAL:\n  case BUTTONS_3_MATERIAL:\n    buttonsMaterial(surfData, materialId - BUTTONS_1_MATERIAL + 1u);\n    break;\n  }\n}\n\n// Fills the ReflectiveSurfaceData for a material with enabled reflections\nvoid fillReflectiveSurfaceData(uint materialId,\n                               inout ReflectiveSurfaceData reflData) {\n  switch (materialId) {\n  default:\n    reflData.strength = 0.0;\n    break;\n  case COFFEE_CUP_MATERIAL:\n    reflData.f0 = vec3(0.01);\n    reflData.roughness = 0.85;\n    reflData.strength = 0.75;\n    break;\n  case CRT_SCREEN_MATERIAL:\n    reflData.f0 = vec3(0.08);\n    reflData.roughness = 0.0;\n    reflData.strength = 0.1;\n    break;\n  }\n}\n\n// Approximates the surface normal at a given world point via the tetrahedron\n// normals technique described in detail here:\n// https://iquilezles.org/articles/normalsSDF\n// Gives comparable results to central differences but it saves us a\n// bunch of calls to sceneSDF(), great!\nvec3 getSceneNormal(vec3 p) {\n  const float h = 0.005;\n\n  uint materialId;\n  vec3 n = vec3(0.0);\n  for (uint i = UZERO; i < 4u; i++) {\n    vec3 e =\n        0.5773 *\n        (2.0 * vec3((((i + 3u) >> 1) & 1u), ((i >> 1) & 1u), (i & 1u)) - 1.0);\n    n += e * sceneSDF(p + e * h, materialId, false);\n  }\n\n  return normalize(n);\n}\n\n// Core raymarching routine. Pretty standard stuff, steps through a ray in\n// world space by sampling the distance field for a fixed number of steps.\n// Returns the distance to the closest surface as well as its material ID.\nfloat traceSceneRay(vec3 ro, vec3 rd, out uint materialId) {\n  const uint numSteps = 48u;\n  const float eps = 0.0002;\n\n  float t = 0.0;\n  for (uint i = UZERO; i < numSteps; i++) {\n    float dist = sceneSDF(ro + rd * t, materialId, false);\n    if (dist < eps) {\n      break;\n    }\n\n    t += dist;\n  }\n\n  return t;\n}\n\n// SDF soft shadows\n// https://iquilezles.org/articles/rmshadows\nfloat traceShadowRay(vec3 worldPos, vec3 normal, vec3 lightPos) {\n  const uint numSteps = 48u;\n  const float bias = 0.002;\n  const float k = 13.0;\n\n  vec3 p = worldPos;\n  p += normal * bias;\n\n  vec3 lightDir = lightPos - worldPos;\n  float ld = length(lightDir);\n  lightDir /= ld;\n\n  uint materialId;\n  float t = 0.0;\n  float ph = 1e20;\n  float shadow = 1.0;\n  for (uint i = UZERO; i < numSteps; i++) {\n    float dist = sceneSDF(p + lightDir * t, materialId, true);\n    float distSq = dist * dist;\n    float y = distSq / (2.0 * ph);\n    float d = sqrt(distSq - y * y);\n\n    shadow = min(shadow, (k * d) / max(0.0, t - y));\n    t += dist;\n    if (shadow < 0.01 || t >= ld) {\n      break;\n    }\n  }\n\n  if (pointInsideBox(worldPos, CLOUDS_MIN, CLOUDS_MAX) != 0.0) {\n    float cloudsShadow = traceVolumeShadow(worldPos, lightDir, 0.25);\n    shadow = min(shadow, cloudsShadow);\n  }\n\n  return max(0.01, shadow);\n}\n\n// Ambient occlusion technique\n// from https://www.shadertoy.com/view/XttSz2\nfloat traceAORay(vec3 worldPos, vec3 normal) {\n  const float numSteps = 16.0;\n  const float k = 0.5;\n  const float b = 0.02;\n  const float n = 6.0;\n  const float m = 3.25;\n\n  uint materialId;\n  float ao = 0.0;\n  for (float i = ZERO; i < numSteps; i += 1.0) {\n    vec3 ap = forwardSF(i, numSteps);\n    float h = hash(i);\n    ap *= sign(dot(ap, normal)) * h * k;\n    float dist = sceneSDF(worldPos + (normal * b + ap), materialId, true);\n    ao += saturate(dist * n);\n  }\n\n  return saturate(ao * (m / numSteps));\n}\n\n#define PRIMARY_PASS 0u\n#define REFLECTIONS_PASS 1u\n#define GLASS_REFLECTIONS_PASS 2u\n\n// This function calculates the color of a pixel given a camera ray.\n// ro and rd are the ray origin and direction in world space.\n// jitter contains two channels of blue noise\nvec3 tracePrimaryRay(vec3 ro, vec3 rd, vec2 jitter) {\n#if ENABLE_CLOUDS\n  SurfaceData cSurfData;\n  vec4 cloudsColor = vec4(0.0, 0.0, 0.0, 1.0);\n  // compute the intersection with the clouds volume\n  vec2 tClouds = intersectRayBox(ro, rd, CLOUDS_MIN, CLOUDS_MAX);\n\n  // if x < y then the ray intersects the AABB\n  if (tClouds.x < tClouds.y) {\n    // world-space intersection point\n    cSurfData.position = ro + rd * tClouds.x;\n\n    // Calculating the normal of a point on an AABB:\n    // https://blog.johnnovak.net/2016/10/22/the-nim-raytracer-project-part-4-calculating-box-normals/\n    cSurfData.normal = normalize(trunc(\n        ((cSurfData.position - ((CLOUDS_MIN + CLOUDS_MAX) * 0.5)) * 1.0001) /\n        ((CLOUDS_MAX - CLOUDS_MIN) * 0.5)));\n\n    cSurfData.viewDir = -rd;\n    cSurfData.roughness = 0.05;\n\n    float maxDist = tClouds.y - tClouds.x;\n    // Trace the ray through the clouds volume to determine the color\n    // which we blend with the background color later.\n    cloudsColor =\n        traceVolume(cSurfData.position, rd, maxDist, SCENE_LIGHTS[0], jitter.x);\n  }\n#endif\n\n  // Temporary storage for the algorithm in the next loop.\n  SurfaceData surfData;\n  ReflectiveSurfaceData reflData;\n  vec3 color = vec3(0.0);\n  float depth = 0.0;\n\n  // The reason the next loop exists is so we don't inline everything three\n  // times for reflection rays. The code might be a little hard to follow\n  // because of this technicality.\n\n  for (uint pass = UZERO; pass < 3u; pass++) {\n    // For the third and final pass we calculate the reflection rays\n    // from the glass surrounding the cloud volume.\n    if (pass == GLASS_REFLECTIONS_PASS) {\n#if ENABLE_CLOUDS\n      if (tClouds.x >= tClouds.y || tClouds.x >= depth) {\n        continue;\n      }\n\n      surfData = cSurfData;\n      rd = reflect(-cSurfData.viewDir, cSurfData.normal);\n      ro = cSurfData.position + rd * 0.001;\n\n      // f0 for glass is around 0.08 according to\n      // https://refractiveindex.info/\n      reflData.f0 = vec3(0.08);\n      reflData.roughness = 0.0;\n      reflData.strength = 0.2;\n#else\n      continue;\n#endif\n    }\n\n    // Trace the ray through the scene and determine the\n    // view-space depth and material ID.\n    uint materialId;\n    float d = traceSceneRay(ro, rd, materialId);\n    if (d > 40.0 || (pass == REFLECTIONS_PASS && reflData.strength == 0.0)) {\n      continue;\n    }\n\n    if (pass == PRIMARY_PASS) {\n      depth = d;\n    }\n\n    // We have the depth so we can calculate the world position and normal.\n    surfData.position = ro + rd * d;\n    surfData.viewDir = -rd;\n    surfData.normal = getSceneNormal(surfData.position);\n\n    // Fill the surface data struct with the material's properties.\n    fillSurfaceData(materialId, surfData);\n\n    // If any debug visualization is on we return here.\n#if DEBUG && DEBUG_ALBEDO\n    return surfData.albedo;\n#endif\n\n#if DEBUG && DEBUG_NORMALS\n    return surfData.normal * 0.5 + 0.5;\n#endif\n\n#if DEBUG && DEBUG_MATERIALS\n    return vec3(surfData.metallic, surfData.roughness, surfData.emissive);\n#endif\n\n    // Compute the light contribution per light and sum all of them.\n    vec3 tmpColor = vec3(0.0);\n\n    for (uint i = UZERO; i < uint(SCENE_LIGHTS.length()); i++) {\n      LightData lightData = SCENE_LIGHTS[i];\n      vec3 lightContrib = light(surfData, lightData);\n\n#if ENABLE_SHADOWS\n      if (pass == PRIMARY_PASS && lightData.castShadows) {\n        lightContrib *= traceShadowRay(surfData.position, surfData.normal,\n                                       (lightData.start + lightData.end) * 0.5);\n      }\n#endif\n\n      tmpColor += lightContrib;\n    }\n\n    // Add the emissive component if any.\n    tmpColor += surfData.albedo * surfData.emissive;\n\n    // If this is the first pass we compute ambient occlusion,\n    // alphablend the final color with the cloud color and\n    // setup the necessary data for the reflections pass\n    // if the material is reflective.\n    // If not we skip to the 3rd pass (glass reflections).\n    if (pass == PRIMARY_PASS) {\n      color += tmpColor;\n\n#if ENABLE_AMBIENT_OCCLUSION\n      float ao = traceAORay(surfData.position, surfData.normal);\n      color *= pow(vec3(ao), vec3(1.0, 1.1, 1.1));\n#endif\n\n#if ENABLE_CLOUDS\n      // If this pixel contains the cloud volume\n      // alphablend its contribution with the scene color.\n      if (tClouds.x < tClouds.y && tClouds.x < d) {\n        color = color * cloudsColor.a + cloudsColor.rgb;\n      }\n#endif\n\n#if ENABLE_REFLECTIONS\n      // Fill the reflection data for this material.\n      fillReflectiveSurfaceData(materialId, reflData);\n        \n      // If the material is not reflective just bail here.\n      if (reflData.strength == 0.0) {\n        continue;\n      }\n\n      // Compute the reflection direction.\n      rd = reflect(-surfData.viewDir, surfData.normal);\n      \n      // Reflection origin with a small bias to save on some very small ray steps.\n      ro = surfData.position + rd * 0.001;\n\n      // Perturb the ray directions for surfaces with glossy reflections.\n      if (reflData.roughness != 0.0) {\n        // Compute basis vectors by crossing the ray direction with an arbitrary vector.\n        vec3 tangent = cross(rd, vec3(0.0, 1.0, 0.0));\n        vec3 binormal = cross(rd, tangent);\n        // offset = random value * roughness\n        vec2 offset = jitter * reflData.roughness * 0.1;\n        // perturb the ray\n        rd += tangent * offset.x + binormal * offset.y;\n        rd = normalize(rd);\n      }\n#endif\n    } else {\n#if ENABLE_REFLECTIONS\n      // Calculate the angle between the surface normal and the view direction.\n      float ndotv = max(0.0, dot(surfData.normal, surfData.viewDir));\n      // Compute fresnel factor based on f0 and angle.\n      vec3 f = fresnelSchlick(ndotv, reflData.f0);\n      // Additively blend the reflection with the current color.\n      color += tmpColor * f * reflData.strength;\n#endif\n    }\n  }\n\n  // Set the pixel to bright magenta if any of the components are NaN so you\n  // can catch mistakes in lighting code quickly. In production code you'd set\n  // the color to something neutral for the scene.\n  if (any(isnan(color))) {\n    color = vec3(1.0, 0.0, 1.0);\n  }\n\n  return color;\n}\n\n// Calculates the ray direction in view space for a pixel given the camera's\n// field of view and the screen size in pixels.\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\n// Calculates the camera (inverse view) matrix given a target position, the\n// camera position and a reference direction.\nmat3 cameraMatrix(vec3 eye, vec3 center, vec3 up) {\n  // Based on gluLookAt man page\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat3(s, u, -f);\n}\n\n\n// Shader entry point\n// Calculates the ray direction for the current pixel. Calls the primary ray\n// tracing routine and blends the result with the TAA history buffer.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Read the persistent state from 0,0 of the terrain texture.\n  global_State =\n      unpackUint4x8(floatBitsToUint(texelFetch(iChannel3, ivec2(0), 0).a));\n\n  vec2 resolution = iResolution.xy;\n\n  vec2 uv = fragCoord;\n\n  // We do temporal anti-aliasing by jittering the input UVs and\n  // blending the current pixel with its value from history. This gets us\n  // really nice antialiasing for static objects. Due to the nature of the\n  // scene we can get away with not doing any history validation and\n  // reconciliation. Check out this paper for a survey\n  // of more sophisticated techniques for dealing with TAA artifacts:\n  // http://behindthepixels.io/assets/files/TemporalAA.pdf.\n\n#if !DEBUG\n  uv += saturate(texelFetch(iChannel0,\n                            ivec2(uvec2(uv) % 1024u + uvec2(iFrame, 23u) % 64u),\n                            0)\n                     .rg);\n#endif\n\n  // the ray origin is the world space position of the camera\n  vec3 ro = CAMERA_POSITION;\n\n  // get a ray direction in view space based on the current pixel UVs\n  vec3 rd = rayDirection(CAMERA_FOV, resolution.xy, uv);\n\n  // calculate the camera (i.e. inverse view) matrix for this frame\n  mat3 camera =\n      cameraMatrix(CAMERA_POSITION, CAMERA_LOOK_AT, vec3(0.0, 1.0, 0.0));\n\n  // transform the ray direction from view space to world space\n  rd = camera * rd;\n\n  // sample the blue noise texture for jitter values used later on\n  vec2 jitter =\n      texelFetch(iChannel0,\n                 ivec2(uvec2(uv) % 1024u + uvec2(73u, iFrame) % 128u), 0)\n          .rg;\n\n  // trace a ray and output the color for this pixel\n  vec3 color = tracePrimaryRay(ro, rd, jitter);\n  fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 prevColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  vec4 color = texelFetch(iChannel1, ivec2(fragCoord), 0);\n  fragColor = mix(color, prevColor, iFrame == 0 ? 0.0 : 0.97);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}