{
    "Shader": {
        "info": {
            "date": "1703977617",
            "description": "SDF blur using fibonacci points in a sphere\nChange #define iterations 55 at line 39",
            "flags": 0,
            "hasliked": 0,
            "id": "mdc3RS",
            "likes": 13,
            "name": "SDF blur - Brute force",
            "published": 3,
            "tags": [
                "sdfblur"
            ],
            "usePreview": 0,
            "username": "PauloFalcao",
            "viewed": 294
        },
        "renderpass": [
            {
                "code": "// Brute force SDF blur\n// By PauloFalcao\n//\n// SDF blur using fibonacci points in a sphere\n// Change #define iterations 55 at line 39\n// \n// Since I learned how to do raymarching, I've wanted to do SDFs blur\n// I have some posts on Pouet about it in 2011\n//   - https://www.pouet.net/topic.php?post=367378\n//   - https://www.pouet.net/topic.php?post=367436\n// But the truth is that I've never managed to make something interesting\n// Is it even possible?\n// This why is one of the possible \"brute force\" ones.\n// Sampling the SDF in a sphere in a Fibonacci point distribution.\n// It's brute force, but you can create some interesting things with it.\n// Try changing iterations it to a low value, and you'll get some crystal-like forms! :)\n//\n// I also have a node for this in my MaterialMaker raymarching lib\n// https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//Test Object\nfloat sdf_a(vec3 p){\n  float b=sdBox(p,vec3(1.3,1.3,1.3));\n  float s=length(p)-1.5;\n    \n  return max(b,-s);\n}\n\n\n#define iterations 55\n// blur obj is sdf_a\n// b is the blur amount\n// f is just the bounding object size\n//   so it only blurs when close to the object\nfloat blursdf3d(/*obj vec3->float*/in vec3 p,in float b,float f){\n    /*obj vec3->float = sdf_a*/\n\tfloat a=0.0;\n\tfloat d=sdf_a(p);\n\tif (d<b*f){\n        /*iterations*/\n\t\tfor(int i=0;i<iterations;i++){\n\t        float y=1.0-2.0*(float(i)/float(iterations));\n\t        float r=sqrt(1.0-y*y);\n\t        float t=2.39996322973*float(i);\n\t\t\ta+=sdf_a(p+vec3(cos(t)*r,y,sin(t)*r)*b);\n\t\t}\n\t} else{\n\t\treturn d;\n\t}\n\treturn a/float(iterations);\n}\n\n\n//Object Color\nvec3 tex3d_a(vec3 p){\n    return vec3(1.0,0.0,0.0);\n}\n\n//Floor\nfloat sdf_b(vec3 p){\n    return max(p.y+2.0,length(p)-8.0);\n}\n\n//Floor color\nvec3 tex3d_b(vec3 p){\n    p*=2.0;\n\tvec2 w=max(abs(dFdx(p.xz)),abs(dFdy(p.xz)))+1e-5;\n\tif (max(w.x,w.y)>0.5) {\n\t\treturn vec3(mod(floor(p.x)+floor(p.z),2.0));\n\t}\n\tvec2 i=((1.-abs(2.*fract((p.xz+.5*w)/2.)-1.))-(1.-abs(2.*fract((p.xz-.5*w)/2.)-1.)))/w;\n\treturn vec3(.5-.5*i.x*i.y);\n}\n\n\n//Rotation\nvec2 rot(vec2 p,float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\n//Combine the 2 SDFs\nvec2 sdf(vec3 p) {\n\n    vec3 p_obja=p;\n    //Rotate the object sdfa\n    p_obja.yz=rot(p_obja.yz,sin(iTime*0.5)*2.0);\n    p_obja.xz=rot(p_obja.xz,sin(iTime*0.2)*0.5);\n    p_obja.xy=rot(p_obja.xy,sin(iTime*0.03)*2.0);\n\n    float sdfa=blursdf3d(p_obja,sin(iTime)*0.1+0.15,0.1);\n\tfloat sdfb=sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n\n//definition\nvec3 raymarch(vec2 uv,vec3 camera,float cameraZoom,vec3 lookAt,\n    float cameraDistance,vec3 sun, float ambLightIntensity,\n    float lightPow,float lightSpecular,float reflection);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //setup uv\n    vec2 uv=fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n\n    //rendering parameters\n    vec3 camera=vec3(sin(sin(iTime*0.3)*0.5+0.5)*4.0,2.0,cos(cos(iTime*0.2)*0.5+0.5)*4.0);\n    float cameraZoom=1.5;\n    vec3 lookAt=vec3(0.0,0.0,0.0);\n    float cameraDistance=1.1;\n    vec3 sun=vec3(0.0,2.0,2.5);\n    float ambOcclusion=1.0;\n    float shadowIntensity=1.0;\n    float ambLightIntensity=0.25;\n    float lightPow=128.0;\n    float lightSpecular=0.7;\n    float reflection=0.2;\n    vec3 col = raymarch(uv,camera,cameraZoom,lookAt,cameraDistance,sun,\n        ambLightIntensity,lightPow,lightSpecular,reflection);\n\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n\n//************************* Rendering framework ****************************************\n\nvec3 normal(vec3 p){  \n  const vec2 e=vec2(0.001,-0.001);\n  float x=sdf(p+e.xyy).x;\n  float y=sdf(p+e.yxy).x;\n  float z=sdf(p+e.yyx).x;\n  return normalize(vec3(x-y-z,-x+y-z,-x-y+z)+sdf(p+e.xxx).x);\n}\n\nvoid march(inout float d,out vec3 p,out vec2 dS,in vec3 ro,in vec3 rd){\n    for (int i=0; i < 100; i++) {\n    \tp = ro + rd*d;\n        dS = sdf(p);\n        d += dS.x;\n        if (d > 20.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n\nvec3 hdri(vec3 p,float v) {\n\treturn pow(texture(iChannel0, p).xyz, vec3(2.2))\n    + pow(texture(iChannel0, p).xxx, vec3(16.0)) * v;\n}\n\nvec3 raymarch(\n        vec2 uv,\n        vec3 camera,\n        float cameraZoom,\n        vec3 lookAt,\n        float cameraDistance,\n        vec3 sun,\n        float ambLightIntensity,\n        float lightPow,\n        float lightSpecular,\n        float reflection) {\n\tvec3 cam=camera*cameraZoom;\n\tvec3 ray=normalize(lookAt-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(ray,cX));\n\tvec3 rd = normalize(ray*cameraDistance+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0.);\n\tvec2 dS=vec2(0.);\n\tmarch(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.);\n\tvec3 objColor=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\tvec3 light=normalize(sun);\n\tif (d<20.0) {\n\t    vec3 n=normal(p);\n\t\tfloat l=clamp(dot(-light,-n),0.,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.,1.0);\n\t\tcolor=max(ambLightIntensity,l)*objColor+pow(r,lightPow)*lightSpecular;\n\t\t//reflection\n        d=0.01;\n\t\tmarch(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0.);\n\t\tif (d<20.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?tex3d_a(p):tex3d_b(p);\n\t\t\tn=normal(p);\n\t\t\tl=clamp(dot(-light,-n),0.,1.);\n\t\t\tobjColorRef=max(l,ambLightIntensity)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=hdri(ref.zyx,1.0);\n\t\t}\n\t\tcolor=mix(color,objColorRef,reflection);\n\t} else {\n\t\tcolor=hdri(rd.zyx,0.0);\n\t}\n\treturn color;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}