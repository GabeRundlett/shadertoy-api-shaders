{
    "Shader": {
        "info": {
            "date": "1514551136",
            "description": "Convolutional surfaces test",
            "flags": 0,
            "hasliked": 0,
            "id": "ltSfR1",
            "likes": 1,
            "name": "Convolutional surfaces test",
            "published": 3,
            "tags": [
                "curve",
                "convolution",
                "surface"
            ],
            "usePreview": 0,
            "username": "petrsm",
            "viewed": 195
        },
        "renderpass": [
            {
                "code": "#define NUM_SEGMENTS 5.0f\n#define PI 3.14159265359f\n\n\n//\n// Kernels :\n// '1' - triangle\n// '2' - quartic polynomial\n// '3' - smoothstep\n// '4' - inv linear (1/r)\n// '5' - custom cubic curve\n\n#define KERNEL_TYPE 5\n\n\nvec4 GetCustomPolyCoeffs()\n{    \n\tfloat BEZIER_PT_A\t= 1.0f;\n\tfloat BEZIER_PT_B\t= 1.0f;\n\tfloat BEZIER_PT_C \t= 0.0f;\n\tfloat BEZIER_PT_D \t= 0.0f;\n\n\tfloat CUSTOM_POLY_COEFF_A =  BEZIER_PT_D - 3.0f * BEZIER_PT_C + 3.0f * BEZIER_PT_B - BEZIER_PT_A;\n\tfloat CUSTOM_POLY_COEFF_B =  3.0f * BEZIER_PT_C - 6.0f * BEZIER_PT_B + 3.0f * BEZIER_PT_A;\n\tfloat CUSTOM_POLY_COEFF_C =  3.0f * BEZIER_PT_B - 3.0f * BEZIER_PT_A;\n\tfloat CUSTOM_POLY_COEFF_D =  BEZIER_PT_A;\n    \n    \n    return vec4(CUSTOM_POLY_COEFF_A, CUSTOM_POLY_COEFF_B, CUSTOM_POLY_COEFF_C, CUSTOM_POLY_COEFF_D);\n}\n\n\nfloat GetNrmFactor(float R)\n{\n#if KERNEL_TYPE == 1\n\treturn 1.0 / R;\n    \n#elif KERNEL_TYPE == 2\n    return 15.0f / (16.0 * R);\n    \n#elif KERNEL_TYPE == 3\n    return 1.0 / R;\n    \n#elif KERNEL_TYPE == 4       \n    return 1.0f / 15.0;\n    \n#elif KERNEL_TYPE == 5\n\n\treturn 0.95f / R;\n#else\n    \n    return 1.0;    \n#endif\n}\n\n\nfloat LineConvIntegralM1(vec2 p0, vec2 p1, vec2 p, float r)\n{\n\tvec2\tdiff\t= p - p0;\n\tvec2\tndir\t= normalize(p1 - p0);\n\tfloat\tL\t\t= length(p1 - p0);\n\tfloat\tt0\t\t= dot(diff, ndir);\n    float\td2\t\t= max(dot(diff, diff) - t0 * t0, 0.0);\n\tfloat\tD\t\t= r * r - d2;\n    \n\tif (D > 0.0)\n\t{\n\t\tfloat\tDs\t\t= sqrt(D);\n        float\ttc0\t\t= t0 - Ds;\n        float\ttc1\t\t= t0 + Ds;\n                \n\t\tfloat\ta\t= max(min(tc0, L), 0.0f) - t0;\n\t\tfloat\tb\t= min(max(tc1, 0.0), L) - t0;\n        float\td\t= max(sqrt(d2), 0.001f);\n        \n        float\tres = 2.0 * (b - a) * r - d2 * asinh(b / d) + d2 * asinh(a / d) - b * sqrt(d2 + b * b) + a * sqrt(d2 + a * a);\n        \n\t\treturn res;\n\t}\n\n\treturn 0.0f;\n}\n\nfloat LineConvIntegralM2(vec2 p0, vec2 p1, vec2 p, float r)\n{\n\tvec2\tdiff\t= p - p0;\n\tvec2\tndir\t= normalize(p1 - p0);\n\tfloat\tL\t\t= length(p1 - p0);\n\tfloat\tt0\t\t= dot(diff, ndir);\n    float\td2\t\t= max(dot(diff, diff) - t0 * t0, 0.0);\n\tfloat\tD\t\t= r * r - d2;\n    \n\tif (D > 0.0)\n\t{\n\t\tfloat\tDs\t\t= sqrt(D);\n        float\ttc0\t\t= t0 - Ds;\n        float\ttc1\t\t= t0 + Ds;\n                \n\t\tfloat\ta\t\t= max(min(tc0, L), 0.0f) - t0;\n\t\tfloat\tb\t\t= min(max(tc1, 0.0), L) - t0;\n        \n\t\tfloat\tr2\t\t= r * r;\n\t\tfloat\tr4\t\t= r2 * r2;\t\t\n\t\tfloat\td4\t\t= d2 * d2;\n\n\t\tfloat\ta3\t\t= a * a * a;\n\t\tfloat\tb3\t\t= b * b * b;\n\t\tfloat\ta5\t\t= a3 * a * a;\n\t\tfloat\tb5\t\t= b3 * b * b;\n        \n        float\tres\t= (15.0f * (b - a) * r4 + (30.0f * (a - b) * d2 - 10.0f * b3 + 10.0f * a3) * r2 + 15.0f * (b - a) * d4 + 10.0f * (b3 - a3) * d2 + 3.0f * b5 - 3.0f * a5) / (15.0f * r4);\n        \n\t\treturn res;\n\t}\n\n\treturn 0.0f;\n}\n\nfloat LineConvIntegralM3(vec2 p0, vec2 p1, vec2 p, float r)\n{\n\tvec2\tdiff\t= p - p0;\n\tvec2\tndir\t= normalize(p1 - p0);\n\tfloat\tL\t\t= length(p1 - p0);\n\tfloat\tt0\t\t= dot(diff, ndir);\n    float\td2\t\t= max(dot(diff, diff) - t0 * t0, 0.0);\n\tfloat\tD\t\t= r * r - d2;\n    \n\tif (D > 0.0)\n\t{\n\t\tfloat\tDs\t\t= sqrt(D);\n        float\ttc0\t\t= t0 - Ds;\n        float\ttc1\t\t= t0 + Ds;\n                \n\t\tfloat\ta\t= max(min(tc0, L), 0.0f) - t0;\n\t\tfloat\tb\t= min(max(tc1, 0.0), L) - t0;\n        float\td\t= max(sqrt(d2), 0.001f);\n        \n        float\ta3\t= a * a * a;\n        float\tb3\t= b * b * b;        \n        float\tr3\t= r * r * r;\n        float\td4\t= d2 * d2;\n        \n        float\ttmp0 = 4.0 * (b - a) * r3 + (12.0 * (a - b) * d2 - 4.0 * b3 + 4.0 * a3) * r;\n        float\ttmp1 = -3.0 * d4 * asinh(b / d) + 3.0 * d4 * asinh(a / d);        \n        float\ttmp2 = sqrt(d2 + b * b) * (-5.0 * b * d2 - 2.0 * b3) + sqrt(d2 + a * a) * (5.0 * a * d2 + 2.0 * a3);\n   \n\t    return (tmp0 - tmp1 - tmp2) / (4.0 * r3);\n\t}\n\n\treturn 0.0f;\n}\n\nfloat LineConvIntegralM4(vec2 p0, vec2 p1, vec2 p)\n{\n    vec2 \tdiff \t= p - p0;\n    vec2\tdir\t\t= p1 - p0;\n    float \tt\t\t= dot(dir, diff) / dot(dir, dir);\n    vec2\tlp\t\t= mix(p0, p1, t);\n    \n    \n    float\tsegLen\t= length(p1 - p0);\n    \n    float\ttmpa\t= t * segLen;\n    float\ttmpb\t= (1.0f - t) * segLen;\n    \n    float\ta\t\t= min(tmpa, tmpb);\n    float\tb\t\t= max(tmpa, tmpb);\n    \n    float\td\t\t= length(diff - t * dir);\n    \n    float\ttmp0\t= sqrt(d * d + b * b) + b;\n    float\ttmp1\t= sqrt(d * d + a * a) - a;\n        \n \tfloat\ttmp\t\t= tmp0 / max(tmp1, 0.000001f);\n    \n    return log(tmp);\n}\n\nfloat LineConvIntegralM5(vec2 p0, vec2 p1, vec2 p, float r, float lineT0, float lineT1)\n{\n\tvec2\tdiff\t= p - p0;\n\tvec2\tndir\t= normalize(p1 - p0);\n\tfloat\tL\t\t= length(p1 - p0);\n\tfloat\tt0\t\t= dot(diff, ndir);\n    float\td2\t\t= max(dot(diff, diff) - t0 * t0, 0.0);\n\n    float xx = t0 / L;\n    float tt = lineT0 + (lineT1 - lineT0) * xx;\n    \n        \n\tfloat\tD\t\t= r * r - d2;\n    \n\tif (D > 0.0)\n\t{\n    \n\t\tfloat\tDs\t\t= sqrt(D);\n        float\ttc0\t\t= t0 - Ds;\n        float\ttc1\t\t= t0 + Ds;\n                \n\t\tfloat\tm\t= max(min(tc0, L), 0.0f) - t0;\n\t\tfloat\tn\t= min(max(tc1, 0.0), L) - t0;\n                \n        float\td\t= max(sqrt(d2), 0.001f);\n        float\td4\t= d2 * d2;\n                \n        vec4\tcoeffs = GetCustomPolyCoeffs();\n                \n        float\ta\t= coeffs.x;\n        float\tb\t= coeffs.y;\n        float\tc\t= coeffs.z;\n        float\te\t= coeffs.w;\n                        \n        float\tr2\t= r * r;\n        float\tr3\t= r2 * r;\n        \n        float\tn2\t= n * n;\n        float\tn3\t= n2 * n;\n        \n        float\tm2\t= m * m;\n        float\tm3\t= m2 * m;\n        \n        float\toneOverD = 1.0 / d;\n        float\tv0\t= n * oneOverD;\n        float\tv1\t= m * oneOverD;\n        \n\t\t//\n\t\t// NOTE:\n\t\t//\n\t\t// asinh(v0) - asinh(v1) = \n\t\t// log(v0 + sqrt(1.0f + v0 * v0)) - log(v1 + sqrt(1.0f + v1 * v1)) = \n\t\t// log((v0 + sqrt(1.0f + v0 * v0)) / (v1 + sqrt(1.0f + v1 * v1)))  =\n\t\t// log((v0 + sqrt(v0 * v0 + 1.0f)) * (sqrt(v1 * v1 + 1.0f) - v1))\n\t\t//\n        \n        float\ttmp0 = log((v0 + sqrt(v0 * v0 + 1.0)) * (sqrt(v1 * v1 + 1.0) - v1));\n        \n        float\ttmp1\t= (24.0 * e * r3) * (n - m);\n        float\ttmp1a\t= 12.0 * c * r2;\n        float\ttmp1b\t= tmp1a + (15.0 * a) * d2;        \n        float\ttmp1c\t= 6.0 * a;\n        float\ttmp2 \t= sqrt(n2 + d2) * ( tmp1b * n + tmp1c * n3);\n        float\ttmp3 \t= sqrt(m2 + d2) * ( tmp1b * m + tmp1c * m3);\n        float\ttmp4 \t= tmp1a * d2 * tmp0;\n        float\ttmp5 \t= ((8.0 * b) * (n3 - m3) + (24.0 * b) * d2 * (n - m)) * r;\n        float\ttmp6 \t= (9.0 * a) * d4 * tmp0;\n        float   res     = (tmp1 + tmp2 - tmp3 + tmp4 + tmp5 + tmp6) / (24.0 * r3);\n                \n        return res * tt;\n    }\n    \n    return 0.0f;\n}\n\n\nfloat CatmullRomCurveConvIntegral(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 p, float r)\n{\n\tvec2\tA = 1.5f * p1 - 1.5f * p2 + p3 * 0.5f - p0 * 0.5f;\n\tvec2\tB = p0 - 2.5f * p1 + 2.0f * p2 - p3 * 0.5f;\n\tvec2\tC = (p2 - p0) * 0.5f;\n\tvec2\tD = p1;\n            \n    float \tdT\t= 1.0f / NUM_SEGMENTS;\n    float\tres = 0.0f;\n    \n    \n\tfor (float i = 0.0f; i < NUM_SEGMENTS; i++)\n    {\n        float\tt0 = dT * i;\n\t\tfloat\tt1 = t0 + dT;\n     \n\t\tvec2\tv0\t= ((A * t0 + B) * t0 + C) * t0 + D;\n\t\tvec2 \tv1\t= ((A * t1 + B) * t1 + C) * t1 + D;\n                    \n#if KERNEL_TYPE == 1\n        res += LineConvIntegralM1(v0, v1, p, r);\n        \n#elif KERNEL_TYPE == 2\n        res += LineConvIntegralM2(v0, v1, p, r);        \n        \n#elif KERNEL_TYPE == 3\n        res += LineConvIntegralM3(v0, v1, p, r);\n        \n#elif KERNEL_TYPE == 4\n        res += LineConvIntegralM4(v0, v1, p);\n\n#elif KERNEL_TYPE == 5               \n\t\tres += LineConvIntegralM5(v0, v1, p, r, t0, t1);\n#endif\n               \n    }\n        \n    return max(res, 0.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n\tvec2 uv \t\t= fragCoord.xy / iResolution.xy;\n    vec2 cellSize\t= 1.0f / iResolution.xy;\n#else        \n    vec2 uv \t\t= fragCoord.xy / iResolution.y;\n    vec2 cellSize\t= 1.0f / iResolution.yy;\n#endif\n    \n    \n    vec2 p0 = vec2(-5.0, 1.0);\n    \n#if 1    \n    vec2 p1 = vec2(0.2, 0.1);\n    vec2 p2 = vec2(1.5, 0.9);\n#else\n    vec2 p1 = vec2(0.1, 0.5);\n    vec2 p2 = vec2(0.9, 0.5);    \n#endif    \n    \n    vec2 p3 = vec2(5.0, 1.0);\n    \n    #if 0\n    float s = 0.3f;\n    \n    p0 = (p0 - 0.5f) * s + 0.5f;\n    p1 = (p1 - 0.5f) * s + 0.5f;\n    p2 = (p2 - 0.5f) * s + 0.5f;\n    p3 = (p3 - 0.5f) * s + 0.5f;\n    #endif\n    \n    vec2\tp = uv;    \n    float\tR = 0.1 + (cos(iTime) * 0.5 + 0.5f) * 0.5;\n    \n    float\tnrmFactor = GetNrmFactor(R);    \n\n      \n\tfloat res = CatmullRomCurveConvIntegral(p0, p1, p2, p3, p, R) * nrmFactor;\n    \n\t// for debugging\n\tres = fract(res);    \n        \n    float dx = dFdx(res) / cellSize.x;\n    float dy = dFdy(res) / cellSize.y;\n    \n    vec3 nrm = normalize(vec3(dx, 1.5f / R, dy));\n  \n\n    if (iMouse.z > 0.0)\n    {\n        fragColor = vec4(nrm, 1.0);\n    }\n    else\n    {\n//\t\tres = dot(nrm, normalize(vec3(1.0, 1.0, 1.0)));\n        \n\t\tfragColor = vec4(res, res, res, 1.0);\n    }\n\t\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}