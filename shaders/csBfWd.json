{
    "Shader": {
        "info": {
            "date": "1690237238",
            "description": "as i'm a liunx (and X11) native, i had to...",
            "flags": 0,
            "hasliked": 0,
            "id": "csBfWd",
            "likes": 16,
            "name": "ùïè - X11 fade",
            "published": 3,
            "tags": [
                "x11",
                "xorg",
                "twitterx"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 295
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2033\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// X - X11 - new twitter logo\n\n#define X11 clamp(-cos(iTime*.3)+.5,0.,1.)\n\nfloat linstep(float a, float b, float x) { return clamp((x-a)/(b-a),0.,1.); }\nfloat smin(float a, float b, float k) { return mix(a,b,linstep(-2.*k,2.*k,a-b))-k*linstep(-2.*k,0.,-abs(a+b)); }\nfloat smax(float a, float b, float k) { return -smin(-a,-b,k); }\n\nfloat distX(vec3 p)\n{\n    float W=.8;\n    float D=.15;\n    float H=1.;\n    float w1=.15;\n    float w2=.04;\n    float w3=.03;\n    float sr=.007;\n    float dX11=.015;\n    \n    float d=10000.;\n    \n    float d1,d2,dh,dThick;\n    dh=abs(p.y)-H*.5;\n    dThick=abs(p.z)-D*.5;\n    \n    vec3 Xn;\n    \n    Xn=normalize(vec3(H+.05-X11*.03,W+X11*.03,0));\n    float d10=dot(p,Xn);\n    d1=abs(d10)-w1*.5;\n    d1=smax(d1,dh,sr);\n    \n    Xn=normalize(vec3(-(H-.05+X11*.03),W-X11*.03,0));\n    float d20=dot(p,Xn);\n    d2=abs(d20+X11*(w2+dX11)*.5*sign(d10))-w2*.5;\n    d2=smax(d2,dh,sr);\n    \n    d=smin(d1,d2,sr);\n    d=smax(d,-d1-w3-X11*w1,sr);\n    d=smax(d,dThick,sr);\n    d=smax(d,-abs(d20)+(dX11*(-1.5+2.*X11)),sr);\n    return d;\n}\n\n\nfloat dist(vec3 pos)\n{\n    return min(distX(pos.xzy*vec3(1,1,1)*.75)/.75,pos.z+.7);\n}\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir)\n{\n    float eps=0.001;\n    for(int cnt=0;cnt<100;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir;\n        if(d<eps) { break; }\n    }\n    vec3 n = getGrad(pos,.001);\n    return vec4(n,0.); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-3.5,0);\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=sin(iTime*.5)*.5; th=.3*sin(iTime*.3)-.15; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    \n    // march it...\n   \tvec4 n=march(pos,dir);\n    float bg=n.w;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    R = -((R*rz)*rx).yzx;\n    \n    vec3 c = vec3(1);\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c += n.xyz*.1+.1;\n\n    //  reflection of cubemap\n    c *= texture(iChannel1,R).xyz*1.5+.4;\n    \n    // add some depth darkening\n\tc*=clamp(-dot(dir,pos)*.7+.7, .2, 1.);\n    \n    // apply ambient occlusion\n    c*=ao;\n    \n    // apply background\n    if(bg>=.5) c=vec3(.5,.6,.75)-.17;\n    \n    // vignetting\n    float vign = (1.1-.3*length(sc.xy));\n    \n\tfragColor = vec4(c*vign,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}