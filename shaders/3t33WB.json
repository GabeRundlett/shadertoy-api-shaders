{
    "Shader": {
        "info": {
            "date": "1577390141",
            "description": "Wait for it to converge and there's mouse movement.",
            "flags": 0,
            "hasliked": 0,
            "id": "3t33WB",
            "likes": 4,
            "name": "Day 8 of MDTMJVM",
            "published": 3,
            "tags": [
                "asdg"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 372
        },
        "renderpass": [
            {
                "code": "// Thanks to yx/Luna for showing how to make a twisted torus! \n\n\n\n\n#define fov 0.6\n#define dmin(a, b) (a.x < b.x) ? a : b\n\n#define iTime (iTime*0.5)\n\n#define mx (10.*iMouse.x/iResolution.x)\n\n#define twists -2.\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv) {\n  vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n  vec3 up = normalize(cross(dir, right));\n  \n  return dir*1. + right*uv.x*fov + up*uv.y*fov;\n}\n\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define pi acos(-1.)\n\n#define dmin(a, b) (a.x < b.x) ? a : b // takes 2 vec2, does a minimum of them \n\n#define pmod(p, x) (mod(p,x) - x*0.5)\n\n#define spectra(x,t ) (1. + sin(vec3(0.9,0.1,0.3)*t + x + iTime))\n\n\nfloat sdBox(vec3 p, vec3 r){\n  p = abs(p);\n  p -= r;\n  return max(p.x, max(p.y, p.z));\n}\n\n#define mainW 0.1\nfloat sdTorus(vec3 p){\n    //p = abs(p);\n    float polarPos = atan(p.z, p.x);\n    \n\tvec2 t = vec2(length(p.xz) - 1., p.y);\n    \n    t.xy *= rot(0. + polarPos*twists);\n    float w = mainW;\n    float h = 0.0;\n    float d = abs(t.y) - h;\n    d = max(d, abs(t.x) - w);\n    d = max(d, abs(mod(polarPos,pi/8.) - 0.25) - 0.1);\n    return d/2.;\n}\nfloat sdTorusWalls(vec3 p){\n    //p = abs(p);\n    float polarPos = atan(p.z, p.x);\n    \n\tvec2 t = vec2(length(p.xz) - 1., p.y);\n    \n    //t.yx *= rot(0.4);\n    \n    \n    t.xy *= rot(0. + polarPos*twists);\n    \n    t.y = abs(t.y);\n    t.y -= 0.06;\n    t.x = abs(t.x);\n    t.x -= mainW;\n    float w = 0.01;\n    float h = 0.03;\n    float d = abs(t.y) - h;\n    d = max(d, abs(t.x) - w);\n    \n    d = max(d, abs(mod(polarPos,pi/8.) - 0.25) - 0.2);\n    return d/2.;\n}\n\nfloat sdTorusUpper(vec3 p){\n    //p = abs(p);\n    float polarPos = atan(p.z, p.x);\n    \n\tvec2 t = vec2(length(p.xz) - 1., p.y);\n    \n    //t.yx *= rot(0.4);\n    \n    //t.y = abs(t.y);\n    t.y -= 0.02;\n    t.xy *= rot(0. + polarPos*twists);\n    \n    t.y = abs(t.y);\n    t.y -= 0.1;\n    t.x = abs(t.x);\n    //t.x -= mainW;\n    float w = 0.3;\n    float h = 0.01;\n    float d = abs(t.y) - h;\n    d = max(d, abs(t.x) - w);\n    \n    d = max(d, abs(mod(polarPos,pi/8.) - 0.25) - 0.2);\n    return d/5.;\n}\n\n\nvec2 map(vec3 p){ // gets distance to everything\n  vec2 d = vec2(10e3); // d.x = distance, d.y = id\n\t\n    //p.xy *= rot(0.1);\n   \n  //d = dmin(d,vec2(sdTorus(p), 1.));\n     \n  //d = dmin(d,vec2(sdTorusWalls(p), 1.));\n  \n  float dTorus = sdTorus(p);\n  float dWalls = sdTorusWalls(p);\n  float dUpper = sdTorusUpper(p);\n  //d.x = fOpUnionChamfer(dTorus, dWalls, 0.02);\n  //d = dmin(d, vec2(dWalls, 2.));\n  //d = dmin(d, vec2(dTorus, 1.));\n  d.x = fOpUnionChamfer(dTorus, dWalls, 0.02);\n    if (d.x == dTorus) {\n        d.y = 1.;\n    } else if(d.x == dWalls){\n        d.y = 2.;\n    } else {\n        d.y = 3.;\n    }\n  \n  d = dmin(d, vec2(dUpper, 4.));\n    \n  //d.x *= 0.9;\n  //d.x = max(d.x, -abs(fract(p.y) - 0.5) - 0.2);\n\n  //d.x = length(p) - 1.;\n  \n  return d;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 t = vec2(0.001, 0.);\n  return normalize( - vec3(\n    map(p + t.xyy).x - map(p - t.xyy).x,\n    map(p + t.yxy).x - map(p - t.yxy).x,\n    map(p + t.yyx).x - map(p - t.yyx).x\n  ));\n}\n\n#define zoom 40.\n\n\n\nvec3 glow = vec3(0);\nvec3 glowB = vec3(0);\n#define rotSpeed 1.\nvec4 render(vec2 uv) {\n  vec3 col = vec3 (0);\n  \n  //vec3 ro = vec3(sin(iTime*rotSpeed)*zoom,0,cos(iTime*rotSpeed) * zoom);\n  \n  \n//#define version 1\n//#if version == 1\n  vec3 roA = vec3(0. + cos(iTime)*1.,0.05,0. + sin(iTime)*1.);\n    \n  vec3 lookAtA = vec3(0. + cos(iTime + 0.4)*1.,0.05,0. + sin(iTime + 0.4)*1.);\n    \n  float polarPosA = atan(roA.z, roA.x);\n    \n  uv *= rot(-polarPosA*twists*0.5);\n\n//#elif version == 2\n  vec3 roB = vec3(0. + cos(iTime)*2.,-5. + mx,0. + sin(iTime)*2.);\n    \n  vec3 lookAtB = vec3(0.);\n    \n  float polarPosB = atan(roB.z, roB.x);\n    \n  //uv *= rot(-polarPos*twists);\n    \n//#endif\n    \n  float tMod = clamp(iTime*0.75  - 4., 0., 1.);\n  vec3 ro = mix(roA, roB, tMod);\n  //vec3 rd = mix(rdA, rdB, iTime);\n  vec3 lookAt = mix(lookAtA, lookAtB, tMod);\n  //ro.x =  vec3(0. + cos(iTime)*2.,-2. + mx,0. + sin(iTime)*2.)\n  //ro.z = 160;\n  //vec3 lookAt =  vec3(0,0,0) ;\n  vec3 rd = getRd(ro, lookAt, uv);\n  \n  \n  rd = normalize(rd);\n  vec3 p = ro; \n  float t = 0.;\n  float att = 0.7;\n  bool reflected = false;\n  float tBeforeReflection = 0.;\n    \n  for (int i = 0; i < 300; i++) {\n      vec2 d = map(p);\n      \n      glow += spectra(d.x , 5.);\n      if (!reflected) {\n      glowB += spectra(d.x, 5.);\n      }\n      \n      if (d.x < 0.001) {\n\n        \n        vec3 dirLight = normalize(vec3(4.));\n        //dirLight += vec3(sin(iTime)*10., 0.,0.);\n\n        vec3 n = getNormal(p);\n\n\t\tvec3 h = normalize(dirLight - rd);\n        \n        float diff = max(dot(dirLight, n), 0.);\n        float fres = pow(1. -max(dot(-rd, n), 0.),2.);\n        float spec = max(dot(h, n), 0.);\n \n        //col += fres*diff * vec3(1.) * att;\n          if (d.y == 1.) {\n        \t//col += (fres* vec3(0.1,0.1,0.8)*glow + fres*spec*1.) * att;      \n          } else if (d.y == 3.) {\n          \t//col += diff* vec3(0.1,0.1,0.1) * att + fres*spec*0.2*att;      \n          } else if (d.y == 2.) {\n          \t//col += diff* vec3(1.,1.,0.1) * att + fres*spec*0.14;      \n            //col += diff* vec3(0.,0.2,0.7) * att + fres*spec*0.14;      \n          }\n        \n\n          if (d.y == 4.) { // reflect\n        \tcol += fres*spec * vec3(0.6) * att + spec*0.;    \n            \n            ro = p;\n            reflected = true;\n\t\t\t//rd = reflect(rd,n);\n            rd=refract(rd,n,1.);\n            d.x = 0.5;\n            t = 0.;\n            att *= 0.5;\n          } else if (d.y == 2.) {    \n            col += diff* vec3(1.,0.7,0.7) * att + fres*spec*0.14*att;\n            ro = p;\n            reflected = true;\n\t\t\t//rd = reflect(rd,n);\n            rd=refract(rd,n,1.);\n            d.x = 0.4;\n            t = 0.;\n            att *= 0.9;  \n              \n              \n          } else if (d.y == 3.) {\n            col += diff* vec3(0.1,0.1,0.1) * att + fres*spec*0.2*att;      \n            ro = p;\n            reflected = true;\n\t\t\t//rd = reflect(rd,n);\n            rd=refract(rd,n,1. );\n            d.x = 0.1;\n            t = 0.;\n            att *= 0.02; \n          } else if (d.y == 1.) {\n            col += diff*fres* vec3(0.1,0.1,0.8)*glow * att + fres*spec*0.2*att;      \n            ro = p;\n            reflected = true;\n\t\t\t//rd = reflect(rd,n);\n            rd=refract(rd,n,1.);\n            d.x = 0.1;\n            t = 0.;\n            att *= 0.02; \n          } else {\n          \tbreak; \n          }\n          \n        //col += fres;\n          \n  \t\tcol += glow*0.02*att;\n          \n      }\n      \n      if (d.x > 300.) {\n        //col += vec3(0.1,0.2,0.1);\n        break;\n      }\n\n      if (!reflected) {\n      \ttBeforeReflection += t;\n      }\n      t += d.x;\n      p = ro + rd * t;\n  }\n  //glow = clamp(glow, 0., 1.);\n  col += glowB*0.0013;    \n  //col *= glow*0.04;\n  \n  col *= 0.4;\n  col = pow(col, vec3(1.5,0.8,1.1));\n  col = pow(col, vec3(0.44));\n  return vec4(col, tBeforeReflection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    fragColor = render(uv);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI acos(-1.)\n// From HG SDF library\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n#define bdist smoothstep(0.,1.,depth*0.2 - 10.)*50.\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}