{
    "Shader": {
        "info": {
            "date": "1527776098",
            "description": "mixing effects",
            "flags": 48,
            "hasliked": 0,
            "id": "MdGfzD",
            "likes": 5,
            "name": "Butterfly 02",
            "published": 3,
            "tags": [
                "butterfly"
            ],
            "usePreview": 0,
            "username": "peko",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 b = butterfly(uv, iTime);\n\tfragColor = texture(iChannel0,uv)*(1.0-b*.4)+smoothstep(-1.,0.0, b.a)*0.2;\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 5\n#define angRnd 0.0\n#define posRnd 0.0\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\n\nvec4 randS(vec2 uv){\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc) {\n    float ang2 = angRnd*randS(uv).x*ang;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++) {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    }\n    rot/=float(RotNum);\n    return rot;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / Res.xy;\n    fragColor = texture(iChannel2,uv);\n}\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = fragCoord.xy / Res.xy;\n    vec2 scr=uv*2.0-vec2(1.0);\n    \n    float sc=1.0/max(Res.x,Res.y);\n    vec4 btr = butterfly(uv, iTime);\n    vec2 v = -vec2(btr.x,btr.y)*10.;\n    for(int level=0;level<20;level++) {\n        if ( sc > 0.7 ) break;\n        float ang2 = angRnd*ang*randS(uv).y;\n        vec2 p = vec2(cos(ang2),sin(ang2));\n        for(int i=0;i<RotNum;i++) {\n            vec2 p2=p*sc;\n            float rot=getRot(uv+p2,sc);\n            v+=p2.yx*rot*vec2(-1,1);\n            p = m*p;\n        }\n      \tsc*=2.0;\n    }\n    \n    v.y+=scr.y*0.1;\n    \n    fragColor=texture(iChannel0,fract(uv+v*1.0/Res.x));\n    vec4 tex = texture(iChannel2, uv);\n    float k = 0.0001;\n    fragColor= fragColor*(1.0-k)+tex*k;\n    fragColor.xy-=btr.xy*0.02;\n    //fragColor = btr;\n    if(iFrame<=4 || KEY_I>0.5) init(fragColor,fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvec4 butterfly(vec2 uv, float time) {\n    uv-= 0.5;\n    uv*= 1.5;\n    uv.x*=1.5;\n    uv.x *= 1.0 -sin(time*4.)*.3;\n    vec2 p =uv*20.0;\n\n   \tfloat r = length(p);\n\tfloat t = atan(p.y, p.x);\n    \n    float b = \n        7. - 0.5*sin( 1.*t) \n           + 2.5*sin( 3.*t) \n           + 2.0*sin( 5.*t) \n           - 1.7*sin( 7.*t) \n           + 3.0*cos( 2.*t) \n           - 2.0*cos( 4.*t) \n           - 0.4*cos(16.*t) - r;\n    \n    vec2 g = normalize(p);\n    vec2 c = g*smoothstep(-2.0, 0.0, b);\n    c*=smoothstep(4.0,-3.0, b);\n    return vec4(c, 0.0, b);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}