{
    "Shader": {
        "info": {
            "date": "1704455764",
            "description": "True 3D or 4D Lyapunov fractal (BCABA or BCADA) rendered using simple ray-marching, chaos=transparent, order=solid, with basic Phong shading. Ref: https://gidden.net/lyapunov\n\n[WIP] Not looking its best; algo was really designed for much higher iters",
            "flags": 0,
            "hasliked": 0,
            "id": "4fBGzc",
            "likes": 2,
            "name": "3D/4D Lyapunov fractal",
            "published": 3,
            "tags": [
                "fractal",
                "raymarch",
                "lyapunov"
            ],
            "usePreview": 0,
            "username": "gid",
            "viewed": 230
        },
        "renderpass": [
            {
                "code": "// 3D/4D Markus-Lyapunov fractal, using ray-marching\n//\n// by Tom Gidden <tom@gidden.net> \n//\n// Creative Commons CC BY-SA 4.0\n//\n// Original OpenCL: 2010\n// This version: 2024\n//\n// Adaptation of the familiar 2D Markus-Lyapunovs that render a 2D plane (A,B) where 0 ≤ A ≤ 4, 0 ≤ B ≤ 4\n// and A & B come from a looping sequence of As and Bs, like \"AABAB\".\n//\n// Here, we add third and forth axes, C (spatial) and D (temporal) on the sequence B,C,A,D,A.\n// Each frame is a 3D \"slice\" of a 4D fractal.\n//\n// Rather than rendering the 2D slice showing colour for both chaos and order (and deep within order),\n// we have to show chaos as transparent and the boundary between chaos and order as a shaded solid.\n// This is done using a simple ray-marcher (like a ray-tracer but without bouncing on reflections)\n//\n// As the \"solid\" areas are fractal, we can't skip through the transparent space quickly,\n// as it's stuffed with tiny pockets of order. Instead, the ray has to march through the\n// space until it hits real order.  Then it refines the location with a back-and-forth,\n// then determines an approximate surface normal for shading.  There's some noise added\n// to the marching to avoid banding and other artefacts (change \"jitter\" in params)\n//\n// This is a rudimentary conversion of CUDA code used to render offline -- seconds per frame, if not more\n// and do it in a relatively efficient way. Getting this stuff to run in real-time involves a significant\n// quality drop.\n//\n// A better render using OpenCL: https://www.youtube.com/watch?v=6JFgkIvIxnM\n// and a playlist of other renders and testing: https://www.youtube.com/playlist?list=PLHAv-hHDbuoIjVlc0APEfLoBr3cyUWMy0\n//\n// For more info: https://gidden.net/lyapunov\n//\n\n\nconst int sequence[5] = int[](2, 3, 1, 4, 1); // 4D: BCADA\n//const int sequence[5] = int[](2, 3, 1, 2, 1); // 3D: BCABA\n\nconst float t1 = 10.0;            // Animation duration\nconst float camPanDegrees = 30.0; // Angle to pan the camera\n\n\n// Try changing these to o=0.0, d=4.0 to see the full range. A bit too weird for my taste\nconst float originD = 3.25;  // Base value of \"D\" in 4D fractals\nconst float deltaD = 0.5;    // such that D(t) = originD + t*deltaT\n\n// Iterations: \n// 1. \"settle\": an initial run of iterations to get started;\n// 2. \"accum\": subsequent iterations that contribute.\n//\n// These numbers should be in the hundreds or more for proper\n// renders.\n\nconst int settle = 5, accum = 10;       // \"Fast\" quality\n//const int settle = 10, accum = 20;    // \"High\" quality\n\n//const int settle = 500, accum = 1000; // Offline rendering. DO NOT USE\n\n\nstruct LyapParams {\n    int settle;             // Initialisation iterations to allow exponent to settle (avoiding noise)\n    int accum;              // Subsequent iterations to accumulate the exponent\n    int stepMethod;         // Ray-marching method. 1=bad, 2=good.\n    float D;                // Value of \"D\" for sequences that include \"D\". Can be tied to time for 4D Lyaps\n    float nearThreshold;    // What constitutes near vs. far, so ray slows down (finer steps) when close.\n    float nearMultiplier;   // And the multiplier when near (um... yeah, bad explanation)\n    float opaqueThreshold;  // Below what exponent constitutes \"order\", ie. opaque\n    float chaosThreshold;   // Below what exponent constitutes \"visible\" chaos, ie. corona\n    float hitOpacity;       // Alpha of a \"solid\" hit, so the first apparent order doesn't stop the ray dead\n    float depth;            // Rough depth of a typical ray, ie. number of expected steps.\n    float jitter;           // Fraction of ray step length to randomise\n    float refine;           // Back-and-forth subdivisions to zero-in on surface (eg. 32)\n    float gradient;         // Fraction of ray length to use for the cardinal box around a hit point to estimate surface normal\n};\n\nLyapParams params = LyapParams(\n    /*settle=*/settle,\n    /*accum=*/accum,\n    /*stepMethod=*/2,\n    /*D=*/originD,          // Will be replaced in main()\n    /*nearThreshold=*/0.5,\n    /*nearMultiplier=*/8.0,\n    /*opaqueThreshold=*/-0.5,\n    /*chaosThreshold=*/-0.25,\n    /*hitOpacity=*/0.25,\n    /*depth=*/128.0,  // should be 512 or more, really!\n    /*jitter=*/0.75,\n    /*refine=*/8.0,  // should be 32 or more\n    /*gradient=*/0.01\n);\n\n\nstruct LyapCam {\n    float M;\n    vec3 C;\n    vec4 Q;\n    vec3 S0;\n    vec3 SDX;\n    vec3 SDY;\n    vec4 ambient;\n    vec4 chaosColor;\n};\n\nLyapCam cam;\n\n// Calculate camera position and rotation for a given time, 0 ≤ t ≤ 1\nvoid cam_init(float t) {\n\n    cam = LyapCam(\n        /*M=*/0.45,   // \"zoom\"\n        /*C=*/vec3(4.0, 4.0, 4.0), // Nominal camera location (ie. when t=0.5)\n        /*Q=*/null4,  // will be calculated\n        /*S0=*/null3, // will be calculated\n        /*SDX=*/null3,// will be calculated\n        /*SDY=*/null3,// will be calculated\n        /*ambient=*/vec4(0.001, 0.0, 0.0, 0.0),\n        /*chaosColor=*/vec4(0.0, 0.1, 1.0, 0.1)\n    );\n\n    // Move C on a curved path around 3,3,3 (interesting feature)\n    \n    vec3 lookAt = vec3(3.0, 3.0, 3.0);\n    \n    vec3 dir = cam.C - lookAt;                // cam relative to lookAt\n    vec3 upIsh = vec3(0.0, 1.0, 0.0);         // roughly up\n    vec3 axis = normalize(cross(dir, upIsh)); // roughly sideways\n    \n    // Get a rotation quat around the axis for the current frame\n    vec4 rot0 = quat_from_axisangle(axis, camPanDegrees/2.0, /*inDegrees=*/true);\n    vec4 rot1 = quat_from_axisangle(axis, camPanDegrees/-2.0,/*inDegrees=*/true);\n    vec4 rotT = quat_nlerp(rot0, rot1, t);\n    \n    // Rotate the relative camera position using the quat\n    vec3 dirT = transform_with_quat(rotT, dir);\n\n    // Move the camera\n    cam.C = lookAt + dirT;\n    \n    // Recalculate the camera's rotation quat to point to lookAt\n    cam.Q = quat_from_vectors(vec3(0.0, 0.0, -1.0), normalize(dirT), 1.0, false);\n\n \n    // Determine the projection frustum vectors: S0 is centre of \"screen\", SDX and SDY\n    // are axis vectors for screen X and screen Y within 3-Lyapunov space\n    cam.S0 = transform_with_quat(cam.Q, vec3(0.0, 0.0, 1.0));\n    cam.SDX = transform_with_quat(cam.Q, vec3(cam.M, 0.0, 0.0));\n    cam.SDY = transform_with_quat(cam.Q, vec3(0.0, cam.M, 0.0));\n}\n\nstruct LyapLight {\n    float M;  // Magnitude / Intensity\n    vec3 C;   // Location of light\n    vec4 Q;   // Direction quat\n    vec3 V;   // Absolute direction vector from Q [via lights_init()]\n    \n    float lightInnerCone, lightOuterCone; // \"Spotlight\" cone\n    float lightRange;  // Range of light.\n\n    vec4 diffuseColor;\n    float diffusePower;\n\n    vec4 specularColor;\n    float specularPower;\n    float specularHardness;\n};\n\nLyapLight lights[2] = LyapLight[](\n    LyapLight(\n        /*M=*/1.0,\n        /*C=*/vec3(5.0, 7.0, 3.0),\n        /*Q=*/vec4(0.710595, 0.282082, -0.512168, 0.391368),\n        /*V=*/vec3(0.0, 0.0, 0.0), // will get recalculated from C,Q\n        /*lightInnerCone=*/0.904535,\n        /*lightOuterCone=*/0.816497,\n        /*lightRange=*/5.0,\n        /*diffuseColor=*/vec4(0.40, 0.45, 0.50, 1.0),\n        /*diffusePower=*/5.0,\n        /*specularColor=*/vec4(0.90, 0.90, 0.90, 1.0),\n        /*specularPower=*/10.0,\n        /*specularHardness=*/50.0\n    ),\n\n    LyapLight(\n        /*M=*/1.6772,\n        /*C=*/vec3(3.0, 7.0, 5.0),\n        /*Q=*/vec4(0.039640, 0.840027, -0.538582, -0.052093),\n        /*V=*/vec3(0.0, 0.0, 0.0), // will get recalculated from C,Q\n        /*lightInnerCone=*/0.534489,\n        /*lightOuterCone=*/0.388485,\n        /*lightRange=*/1.5,\n        /*diffuseColor=*/vec4(0.2, 0.25, 0.35, 1.0),\n        /*diffusePower=*/5.0,\n        /*specularColor=*/vec4(0.0, 1.0, 1.0, 1.0),\n        /*specularPower=*/10.0,\n        /*specularHardness=*/100.0\n    )\n);\n\n// Phases\n// (Note, these are mainly from the distributed CUDA-based version. Unnecessary now)\n\nconst int LYAP_NULL = 0;        // Uninitialised\nconst int LYAP_OUTSIDE = 1;     // Ray is outside volume\nconst int LYAP_INITIALIZED = 2; // Ray is starting\nconst int LYAP_MARCH1 = 3;      // Ray is doing initial march\nconst int LYAP_MARCH1_END = 4;  // Ray has completed initial march\nconst int LYAP_MARCH2 = 5;      // Ray has hit and is now going to backtrack/zero-in on hit point\nconst int LYAP_MARCH2_END = 6;  // Ray has completed zero-in\nconst int LYAP_MARCH3 = 7;      // Ray has stopped and needs to identify surface normal using 3D gradient\nconst int LYAP_MARCH3_END = 8;  // Ray has completed surface normal.\n\nstruct LyapPoint {\n    vec3 V;       // direction vector\n    vec3 P;       // Point under consideration: will become the final hit point.\n    vec3 N;       // Surface normal at the hit point.\n\n    float a;      // high-low alpha\n    float c;      // chaos alpha\n    float l;      // Lyapunov exponent\n\n    float t;      // Progress along ray\n    float t0, t1; // t-values of primary intersections of ray against back and front of volume\n    float dt, Ndt, Fdt;  // step delta: current, and \"near\" and \"far\" for different phases.\n\n    int state;    // State of ray\n    bool near;    // Is the ray possibly near a hit?\n};\n\n// The \"interesting\" volume is 0.0 ≤ a,b,c,d ≤ 4.0\nconst float LMIN = 0.0;\nconst float LMAX = 4.0;\n\n\n\n\n// Determine the colour of a point once calculated\n/*RGBA*/ vec4 shade(LyapPoint point) \n{\n    vec4 color;\n    \n    if(point.state == LYAP_OUTSIDE) {\n        // This is almost definitely the wrong thing to do.\n        return cam.chaosColor / log(point.c);\n    }\n\n    if(isLYAP_NAN(point.a)) {\n        color.w = 0.0;\n        return color;\n    }\n\n    // For each defined light\n    for(int l = 0; l < lights.length(); l++) {\n        vec3 camV;\n        vec3 lightV, halfV;\n        vec4 diffuse, specular, phong;\n        float lightD2, i, j;\n\n        vec3 P = point.P;\n        vec3 N = point.N;\n        //      float a = point.a;\n\n        camV = cam.C - P;\n\n        // Light vector (from point on surface to light source)\n        lightV = lights[l].C - P;\n\n        // Get the length^2 of lightV (for falloff)\n        lightD2 = dot(lightV, lightV);\n\n        // but then normalize lightV.\n        lightV = normalize(lightV);\n\n        // i: light vector dot surface normal\n        i = dot(lightV, N);\n\n        // j: light vector dot spotlight cone\n        j = dot(lightV, lights[l].V);\n        j = -j;\n\n        if(j > lights[l].lightOuterCone) {\n\n            // Diffuse component: k * (L.N) * colour\n            i = clamp(i, 0.0, 1.0);\n            diffuse = lights[l].diffuseColor * (i * lights[l].diffusePower);\n\n            // Halfway direction between camera and light, from point on surface\n            halfV = normalize(camV + lightV);\n\n            // Specular component: k * (R.N)^alpha * colour\n            // R is natural reflection, which is at 90 degrees to halfV (?)\n            // (or is it?  Hmmm.  https://en.wikipedia.org/wiki/Phong_reflection_model)\n            i = clamp(dot(N, halfV), 0.0, 1.0);\n            i = pow(i, lights[l].specularHardness);\n\n            specular = lights[l].specularColor * (i * lights[l].specularPower);\n\n            phong = (specular + diffuse) * lights[l].lightRange / lightD2;\n\n            if(j < lights[l].lightInnerCone)\n                phong *= ((j - lights[l].lightOuterCone) / (lights[l].lightInnerCone - lights[l].lightOuterCone));\n\n            phong += cam.ambient;\n        } else {\n            phong = cam.ambient;\n        }\n\n        color += phong;\n    }\n\n    if(point.c > 0.0)  // Chaos\n        color += vec4(cam.chaosColor.xyz * cam.chaosColor.a, 1.0) / log(point.c);\n\n    return color;\n}\n\n// Calculate Lyapunov exponent for sequence where A=P.x, B=P.y, C=P.z, D=d\nfloat lyap4d(vec3 P) \n{\n    float abcd[5] = float[](0.0, P.x, P.y, P.z, params.D);\n\n    int seqi = 0; // Position in the sequence loop\n    const int seqL = sequence.length();\n\n    float r;       // Iteration value\n    float v = 0.5; // Iterating value\n    float l = 0.0; // Result accumulator\n    \n    // Settle by running the iteration without accumulation\n    for(int n = 0; n < params.settle; n++) {\n        r = abcd[sequence[seqi++]];\n        if(seqi >= seqL) seqi = 0;\n        v = r * v * (1.0 - v);\n    }\n    \n    r = LYAP_NAN;\n\n    if((v - 0.5 <= -1e-8) || (v - 0.5 >= 1e-8)) {\n        // Now calculate the value by running the iteration with accumulation\n        for(int n = 0; n < params.accum; n++) {\n            r = abcd[sequence[seqi++]];\n            if(seqi >= seqL) seqi = 0;\n            v = r * v * (1.0 - v);\n            r = r - 2.0 * r * v;\n\n            if(r < 0.0)\n                r = -r;\n\n            l += log(r);\n            // if (r_prev != LYAP_NAN && (r == r_prev || (r < r_prev*(1.0+LYAP_EPSILON) && r > r_prev*(1.0-LYAP_EPSILON))))\n            //     break;\n\n            if(isnotfinite(l))\n                return LYAP_NAN;\n        }\n    }\n\n    return l / float(params.accum);\n}\n\n\n// Phase 0: set up the ray\nLyapPoint raymarch0(vec2 uv) \n{\n    LyapPoint p;\n\n    // Work out the direction vector: start at C (camera), and\n    // find the point on the screen plane (in 3D)\n    p.V = normalize(cam.S0 + cam.SDX * uv.x + cam.SDY * uv.y) / cam.M;\n\n    // float thresholdRange = params.opaqueThreshold - params.nearThreshold;\n\n    // Find start and end point of ray within Lyapunov space cube\n    p.t0 = LYAP_INF;\n    p.t1 = 0.0;\n    // Find ray intersection through entire Lyapunov space cube\n\n    // First, find values for 't' for intersections with the six bounding\n    // planes x=0, x=4, y=0, y=4, z=0, and z=4.  Any planes that are\n    // parallel to the ray will meet the ray at Infinity.\n    float ts[6] = float[](\n        (p.V.x != 0.0) ? ((LMIN - cam.C.x) / p.V.x) : LYAP_INF,\n        (p.V.x != 0.0) ? ((LMAX - cam.C.x) / p.V.x) : LYAP_INF,\n        (p.V.y != 0.0) ? ((LMIN - cam.C.y) / p.V.y) : LYAP_INF,\n        (p.V.y != 0.0) ? ((LMAX - cam.C.y) / p.V.y) : LYAP_INF,\n        (p.V.z != 0.0) ? ((LMIN - cam.C.z) / p.V.z) : LYAP_INF,\n        (p.V.z != 0.0) ? ((LMAX - cam.C.z) / p.V.z) : LYAP_INF\n    );\n\n    // Zero, one or two of these intersections will occur at a point\n    // where all x, y and z are between 0 and 4 (ie. inside Lyapunov\n    // space). Actually, all six might occur within Lyapunov space, but\n    // only if the points are equal. So, zero, one or two _unique_\n    // intersections will occur. This is because zero, one or two\n    // points on a line intersect a cube.\n    //\n    // So, for each one, eliminate it if the intersection point lies\n    // outside the bounds of the other two axes.\n    vec3 _P;\n    if(isfinite(ts[0])) {\n        _P = cam.C + p.V * ts[0];\n        // If the x-min axis intersection is outside 0<=y<=4, 0<=z<=4, eliminate it.\n        if(_P.y < LMIN || _P.y > LMAX || _P.z < LMIN || _P.z > LMAX) ts[0] = LYAP_INF;\n    }\n\n    if(isfinite(ts[1])) {\n        _P = cam.C + p.V * ts[1];\n        // If the x-max axis intersection is outside 0<=y<=4, 0<=z<=4, eliminate it.\n        if(_P.y < LMIN || _P.y > LMAX || _P.z < LMIN || _P.z > LMAX) ts[1] = LYAP_INF;\n    }\n\n    if(isfinite(ts[2])) {\n        _P = cam.C + p.V * ts[2];\n        // If the y-min axis intersection is outside 0<=x<=4, 0<=z<=4, eliminate it.\n        if(_P.x < LMIN || _P.x > LMAX || _P.z < LMIN || _P.z > LMAX) ts[2] = LYAP_INF;\n    }\n\n    if(isfinite(ts[3])) {\n        _P = cam.C + p.V * ts[3];\n        // If the y-max axis intersection is outside 0<=x<=4, 0<=z<=4, eliminate it.\n        if(_P.x < LMIN || _P.x > LMAX || _P.z < LMIN || _P.z > LMAX) ts[3] = LYAP_INF;\n    }\n\n    if(isfinite(ts[4])) {\n        _P = cam.C + p.V * ts[4];\n        // If the z-min axis intersection is outside 0<=x<=4, 0<=y<=4, eliminate it.\n        if(_P.x < LMIN || _P.x > LMAX || _P.y < LMIN || _P.y > LMAX) ts[4] = LYAP_INF;\n    }\n\n    if(isfinite(ts[5])) {\n        _P = cam.C + p.V * ts[5];\n        // If the z-max axis intersection is outside 0<=x<=4, 0<=y<=4, eliminate it.\n        if(_P.x < LMIN || _P.x > LMAX || _P.y < LMIN || _P.y > LMAX) ts[5] = LYAP_INF;\n    }\n\n    // Find the smallest and largest finite 't' values for all the\n    // intersections.  This identifies which of the bounding planes the\n    // ray hits first and last.  The others can be ignored.\n    int i0 = -1, i1 = -1;\n    for(int i = 0; i < 6; i ++) {\n        if(isfinite(ts[i])) {\n            if(i0 == - 1 || ts[i] < p.t0) p.t0 = ts[i0 = i];\n            if(i1 == - 1 || ts[i] > p.t1) p.t1 = ts[i1 = i];\n        }\n    }\n\n    // If both failed, then the ray didn't intersect Lyapunov space at\n    // all, so exit: noise.\n    if(i0 == -1 && i1 == -1) {\n        p.state = LYAP_OUTSIDE;\n        return p;\n    }\n\n    // If only one point matched, then the ray must(?) start in\n    // Lyapunov space and exit it, so we can start at zero instead.\n    else if(i1 == -1 || i0 == i1) {\n        i1 = i0;\n        p.t1 = p.t0;\n        i0 = 0;\n        p.t0 = 0.0;\n    }\n\n    // I'm not sure this is necessary, but just to make sure the\n    // ray doesn't start behind the camera...\n    if(p.t0 < 0.0)\n        p.t0 = 0.0;\n\n    // So, we start at t=t0\n    p.t = p.t0;\n\n    // Find P:  P = C + t.V\n    p.P = cam.C + p.V * p.t;\n\n    // Set the alpha accumulators to zero\n    p.a = 0.0;\n    p.c = 0.0;\n\n    // dt is the amount to add to 't' for each step in the initial\n    // ray progression.  We calculate Fdt for the normal value,\n    // and Ndt for the finer value used when close to the threshold\n    // (ie. under nearThreshold)\n\n    // There are different methods of progressing along the ray.\n\n    switch(params.stepMethod) {\n    case 1:\n        // Method 1 divides the distance between the start and the end of\n        // the ray equally.\n        p.Fdt = (p.t1 - p.t0) / params.depth;\n    break;\n\n    case 2: \n    default:\n        // Method 2 (default) divides the distance from the camera to the\n        // virtual screen equally.\n        p.Fdt = length(p.V) / params.depth;\n    }\n\n    p.dt = p.Fdt;\n    p.Ndt = p.dt / params.nearMultiplier;\n    p.near = false;\n\n    p.state = LYAP_INITIALIZED;\n    \n    return p;\n}\n\n// Phase 1: Coarse ray marching\nvoid raymarch1(inout LyapPoint p)\n{\n    // Okay, now we do the initial ray progression: we trace until the\n    // exponent for the point is below a certain value. This value is\n    // effectively the transition between transparent and opaque.\n    p.state = LYAP_MARCH1;\n\n    // Calculate the exponent at the current point.\n    p.l = lyap4d(p.P);\n    p.a = 0.0;\n\n    // While the exponent is above the surface threshold (ie. while the\n    // current point is in \"transparent\" space)...\n    while(p.a <= 1.0)\n    // while (p.l > params.opaqueThreshold)\n    {\n        // Step along the ray by 'dt' plus/minus a certain amount of\n        // jitter (optional). This reduces moire fringes and herringbones\n        // resulting from transitioning through thin sheets. Instead we\n        // get what looks like noise, but is in fact stochastic sampling\n        // of a diaphanous transition membrane.\n\n        if(params.jitter != 0.0) {\n            // We use the fractional part of the last Lyapunov exponent\n            // as a pseudo-random number. This is then added to 'dt', scaled\n            // by the amount of jitter requested.\n            float jit = p.l - trunc(p.l);\n            if(jit < 0.0) jit = 1.0 - jit * params.jitter;\n            else jit = 1.0 + jit * params.jitter;\n\n            if(isfinite(jit)) {\n                p.t += p.dt * jit;\n                p.P += p.V * p.dt * jit;\n            } else {\n                p.t += p.dt;\n                p.P += p.V * p.dt;\n            }\n        } else {\n            // No jitter, so just add 'dt'.\n            p.t += p.dt;\n            p.P += p.V * p.dt;\n        }\n\n        // If the ray has passed the first exit plane, then bugger it.\n        // if (t>t1 || !P.in_lyap_space()) { // Overkill: passing t1 should be the exit of L-space anyway\n        if(p.t > p.t1) {\n            p.state = LYAP_OUTSIDE;\n            return;\n        }\n\n        // Calculate this point's exponent\n        p.l = lyap4d(p.P);\n\n        // If the ray is still in transparent space, then we may still\n        // want to accumulate alpha for clouding.\n        if(p.l > params.chaosThreshold) {\n            p.c += p.l;\n        } else if(p.l > params.opaqueThreshold) {\n            // Close-to-surface transparent space (?)\n        } else {\n            // Opaque\n            p.a += params.hitOpacity;\n            // p.a += (params.opaqueThreshold-p.l) * params.hitOpacity;\n        }\n\n        if(p.l <= params.nearThreshold && ! p.near) {\n            p.near = true;\n            p.dt = p.Ndt;\n        } else if(p.l > params.nearThreshold && p.near) {\n            p.near = false;\n            p.dt = p.Fdt;\n        }\n    }\n\n    // Clamp alpha between 0 and 1\n    p.a = clamp(p.a, 0.0, 1.0);\n\n    // At this point, the ray has either hit an opaque point, or\n    // has exited Lyapunov space.\n\n    p.state = LYAP_MARCH1_END;\n    return;\n}\n\n// Phase 2: Post-hit refinement\nvoid raymarch2(inout LyapPoint p) {\n    // Now we've hit the surface, we now need to hone the intersection point \n    // by reversing back along the ray at half the speed.\n    p.state = LYAP_MARCH2;\n\n    // If we've gone through then sign is 0. 'sign' is\n    // the direction of the progression.\n    bool sign = false;\n    bool osign = sign;\n\n    // Half speed\n    float Qdt = p.dt * - 0.5;\n    vec3 QdV = p.V * Qdt;\n\n    // Set the range of the honing to <t-dt, t>.\n    float Qt1 = p.t;\n    float Qt0 = p.t - p.dt;\n\n    // Honing continues reversing back and forth, halving speed\n    // each time. Once dt is less than or equal to dt/refine,\n    // we stop: it's close enough.\n    float min_Qdt = p.dt / params.refine;\n\n    // While 't' is still in the range <t-dt, t> AND dt is still\n    // of significant size...\n    while(p.t <= Qt1 && p.t >= Qt0 && (Qdt <= - min_Qdt || Qdt >= min_Qdt)) {\n        // Progress along the ray\n        p.t += Qdt;\n        p.P += QdV;\n\n        // Calculate the exponent\n        p.l = lyap4d(p.P);\n\n        // If we've hit the threshold exactly, short-circuit.\n        if(p.l == params.opaqueThreshold) break;\n\n        // Work out whether we reverse or not:\n        osign = sign;\n        sign = (p.l >= params.opaqueThreshold);\n\n        // If we've reversed, then halve the speed\n        if(sign != osign) {\n            Qdt *= - 0.5;\n            QdV *= - 0.5;\n        }\n    }\n\n    // At this point, we should be practically on the surface, rather\n    // than above or through. Anyway, we're close enough.  P is now\n    // our hit point.\n    p.state = LYAP_MARCH2_END;\n}\n\n// Phase 3: Work out surface normal for shading\nvoid raymarch3(inout LyapPoint p) \n{\n    // Next, we want to find the surface normal at P. A good approximation\n    // is to get the vector gradient by calculating the Lyapunov exponent\n    // at the six cardinal points surrounding P +/- a tiny amount, which\n    // we assume to be small enough that the Lyapunov exponent approximates\n    // to a linear function.\n    //\n    // Find the difference for each axis, and normalize. The result is\n    // pretty close.\n\n    p.state = LYAP_MARCH3;\n\n    float mag = p.dt * params.gradient;\n    vec3 Ps[6] = vec3[](p.P, p.P, p.P, p.P, p.P, p.P);\n    Ps[0].x -= mag;\n    Ps[1].x += mag;\n    Ps[2].y -= mag;\n    Ps[3].y += mag;\n    Ps[4].z -= mag;\n    Ps[5].z += mag;\n\n    float ls[6];\n    for(int i = 0; i < 6; i ++) {\n        ls[i] = lyap4d(Ps[i]);\n    }\n\n    p.N = normalize(vec3(\n        ls[1] - ls[0],\n        ls[3] - ls[2],\n        ls[5] - ls[4]\n    ));\n\n    // Okay, we've done it. Output the hit point, the normal, the exact\n    // exponent at P (not Really needed, but it does signal a hit failure\n    // when l is NaN), and the accumulated alpha.\n\n    p.state = LYAP_MARCH3_END;\n}\n\n// Calculate the direction of each light using their quat-based rotation, and then their light cone.\nvoid lights_init() {\n\n    for (int l=0; l<lights.length(); ++l) {\n        float m = lights[l].M;\n        if (isLYAP_NAN(m)) return;\n\n        // Convert the light-local Z direction (0,0,1) to absolute using the light's Q.\n        lights[l].V = normalize(transform_with_quat(lights[l].Q, vec3(0.0, 0.0, 1.0)));\n\n        lights[l].lightInnerCone = dot(lights[l].V, normalize(transform_with_quat(lights[l].Q, vec3(-m, -m, 1.5))));\n        lights[l].lightOuterCone = dot(lights[l].V, normalize(transform_with_quat(lights[l].Q, vec3(-m, -m, 1))));\n    }\n}\n\nprecision lowp float;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Animation progress from 0 to 1\n    float t = fract(iTime / t1);\n\n    // Synthesize the \"D\" axis for 4D renders\n    params.D = originD + t*deltaD;\n\n    // Initialise the camera location\n    cam_init(t);\n    \n    // Initialise lights.\n    lights_init();\n\n\n    // Convert to -1 ≤ uv ≤ 1\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    \n    // Fix aspect so it's not squished. Better to do a min/max?\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    // Ray march\n    LyapPoint p = raymarch0(uv);\n    if(p.state != LYAP_OUTSIDE) raymarch1(p);\n    if(p.state != LYAP_OUTSIDE) raymarch2(p);\n    if(p.state != LYAP_OUTSIDE) raymarch3(p);\n\n\n    // Convert the abstract point structure -- position, surface normal,\n    // chaos, etc. -- into a colour, using the lights provided.\n    fragColor = shade(p);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define FAKE_NAN_INF 1\n\n#if FAKE_NAN_INF\n\nconst float LYAP_INF = 1.0e+29;\nconst float LYAP_NAN = -1.0e+29;\nconst float LYAP_EPSILON = 1.0e-29;\n\nbool isLYAP_NAN(float f) {\n    return f <= LYAP_NAN;\n}\n\nbool isnotfinite(float f) {\n    return f <= LYAP_NAN || f >= LYAP_INF;\n}\n\nbool isfinite(float f) {\n    return f > LYAP_NAN && f < LYAP_INF;\n}\n\n#else\n\n// Requires #version 330 or greater to work :(\nconst float LYAP_NAN = intBitsToFloat(int(0xFFC00000u));\nconst float LYAP_INF = intBitsToFloat(int(0x7F800000u));\nconst float LYAP_EPSILON = 1.0e-29;\n\nbool isLYAP_NAN(float f) {\n    return isnan(f);\n}\n\nbool isnotfinite(float f) {\n    return isnan(f) || isinf(f);\n}\n\nbool isfinite(float f) {\n    return !isnan(f) && !isinf(f);\n}\n\n#endif\n\nvec3 null3 = vec3(LYAP_NAN, LYAP_NAN, LYAP_NAN);\nvec4 null4 = vec4(LYAP_NAN, LYAP_NAN, LYAP_NAN, LYAP_NAN);\n\n\nvec4 quat_from_axisangle(vec3 axis, float ang, bool inDegrees)\n{\n    ang = inDegrees ? (ang*3.1415926f/360.0f) : (ang*0.5f);\n    return normalize(vec4(axis * sin(ang), cos(ang)));\n}\n\n\nvec4 quat_nlerp(vec4 q0, vec4 q1, float t)\n{\n    if (t==0.0 || (t<LYAP_EPSILON)) {\n        return q0;\n    }\n    else if (t==1.0f || (t>1.0f-LYAP_EPSILON)) {\n        return q1;\n    }\n    else {\n        float dp = dot(q0, q1);\n        float tA = dp>=0.0 ? t : -t;\n        float tI = 1.0f-t;\n        return normalize(vec4(q0*tI + q1*tA));\n    }\n}\n\nvec3 transform_with_quat(vec4 q, vec3 v)\n{\n    return vec3(\n        q.w*q.w*v.x + 2.0*q.y*q.w*v.z - 2.0*q.z*q.w*v.y + q.x*q.x*v.x + 2.0*q.y*q.x*v.y + 2.0*q.z*q.x*v.z - q.z*q.z*v.x - q.y*q.y*v.x,\n        2.0*q.x*q.y*v.x + q.y*q.y*v.y + 2.0*q.z*q.y*v.z + 2.0*q.w*q.z*v.x - q.z*q.z*v.y + q.w*q.w*v.y - 2.0*q.x*q.w*v.z - q.x*q.x*v.y,\n        2.0*q.x*q.z*v.x + 2.0*q.y*q.z*v.y + q.z*q.z*v.z - 2.0*q.w*q.y*v.x - q.y*q.y*v.z + 2.0*q.w*q.x*v.y - q.x*q.x*v.z + q.w*q.w*v.z\n    );\n}\n\nvec4 quat_from_vectors(vec3 v0, vec3 v1, float scale, bool _normalize)\n{\n    vec3 m0 = _normalize ? normalize(v0) : v0;\n    vec3 m1 = _normalize ? normalize(v1) : v1;\n\n    vec3 c = cross(m0, m1);\n    float d = dot(m0, m1);\n    float s = sqrt((1.0 + d) * 2.0);\n    vec4 p = vec4(c / s, s * 0.5);\n    if (scale != 1.0) p *= scale;\n    return p;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}