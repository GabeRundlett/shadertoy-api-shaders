{
    "Shader": {
        "info": {
            "date": "1708645230",
            "description": "Use the mouse to look around",
            "flags": 0,
            "hasliked": 0,
            "id": "l3jGzK",
            "likes": 11,
            "name": "Tunnel with boxes",
            "published": 3,
            "tags": [
                "tunnel",
                "boxes"
            ],
            "usePreview": 0,
            "username": "ianertson",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "float getTunnelAngle(vec3 p) {\n    return sin(p.z*0.1);\n}\n\nfloat tunnelSDF(vec3 p) {\n  float w = 16.0;\n  float h = 8.0;\n  \n  float x = getTunnelAngle(p);\n  p.x += sin(x)*10.;\n  \n  float k = 6.;\n  float top = h - abs(p.y);\n  float side = w - abs(p.x);\n  \n  return smin(top, side, k);\n}\n\nfloat sdf(vec3 p, inout Data data) {\n  float dist = FAR;\n\n  float len = length(p.yx);\n  float n1 = (len < 3.8) ? 0.0 : noise(p, 3.32918, 0.15, 0.02, 6);\n  float tunnel = tunnelSDF(p + 3.0*vec3(n1*2.0-1.0));\n  tunnel /= (1.005+4.0*n1);\n  \n  SAMPLE(Object(ID_TUNNEL, vec3(0.0), vec3(0.0)), tunnel);\n  \n  float id = floor(((p.z/9.0)));\n  float hsh = hash(vec2(id, id), 34.31);\n  float hsh2 = fract(hsh*30.391854);\n  float s = mix(0.8, 1.5, hsh2);\n  p.z = mod(p.z, 9.)-(s*2.)-0.5;\n  Object oBox = Object(ID_BOX, vec3((hsh*2.0-1.0)*8., s - 8.0, 0.0), vec3(cos(hsh*6.28), sin(6.28*hsh), 0.0));\n  float box = boxSDF(transform(p, oBox.p, oBox.q), vec3(s))-0.09;\n  box /= 1.25;\n  SAMPLE(oBox, box);\n\n  return dist;\n}\n\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n  float d = 0.0;\n\n  for (int i = ZERO; i < STEPS; i++) {\n    vec3 p = ro+rd*d;\n    float next = sdf(p, data);\n    if (next >= FAR) return false;\n    if (abs(next) <= (NEAR * (1.0 + abs(d)))) break;\n    d += next;\n  }\n\n  vec3 p = ro+rd*d;\n  vec2 e = vec2(NORMAL_EPSILON, 0.0);\n  vec3 n = normalize(sdf(p, data) - vec3(\n    sdf(p - e.xyy, data),\n    sdf(p - e.yxy, data),\n    sdf(p - e.yyx, data)\n  ));\n\n  data.p = p;\n  data.n = n;\n  data.d = d;\n\n  return true;\n}\n\nfloat getShadow(vec3 ro, vec3 rd, vec3 n) {\n  Data data = NEW_DATA;\n  float NdotL = dot(n, rd);\n  if (NdotL <= 0.00003) return AMBIENT;\n  const int steps = 30;\n  float d = 0.0;\n  float t = NEAR * (1.0 + 2.0*max(0.0, NdotL));\n  float s = 0.0;\n  float k = 0.0;\n\n  for (int i = ZERO; i < steps; i++) {\n    vec3 p = ro+rd*t;//0.999*((t + 00.25*NdotL)*rd);\n    float next = sdf(p, data);\n    if (next >= FAR) return 1.0;\n    if (next < -0.005) break;\n    d += next;\n    t += clamp(next, 0.005, 0.5);\n    k += 1.0;\n  }\n  \n  d /= max(1.0, k);\n\n  s = smoothstep(0.5, 1.0, clamp(1.0-(d / (1.0+d)), 0.0, 1.0));\n  s = 1.0-s;\n  s = exp(s-1.0);\n  return clamp(s, AMBIENT, 1.0);\n}\n\nvec3 getAlbedoBox(inout Data data) {\n\n  vec3 op = data.o.p;\n  vec3 p = data.p;\n  p.z = mod(p.z, 9.)-2.;\n  p -= op;\n  \n  p = pointRot(p, data.o.q);\n  vec3 n = pointRot(data.n, data.o.q);\n  vec2 uv = mix(mix(p.xy, p.yz, (abs(dot(n, vec3(1, 0, 0))))),\n                p.xz,(abs(dot(n, vec3(0, 1, 0)))));\n\n  vec2 id = floor(uv*2.0);\n  return vec3(1.0)*mod(id.x-id.y, 2.0);\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = mix(mix(p.xy, p.yz, round(abs(dot(n, vec3(1, 0, 0))))),\n                p.xz,round(abs(dot(n, vec3(0, 1, 0)))));\n    return vec3(1.0)*noise(uv, 11.58813,  2.5, 0.0, 4);\n}\n\nvec3 getAlbedo(inout Data data) {\n  switch (data.o.id) {\n    case ID_BOX: return getAlbedoBox(data); break;\n    case ID_GROUND: return getAlbedoGround(data); break;\n    case ID_TUNNEL: return getAlbedoGround(data); break;\n  }\n\n  return vec3(0.93);\n}\n\nvec3 forEachLight(Light light, vec3 ro, vec3 rd, Data data, vec3 diffuse) {\n  vec3 p = data.p;\n  vec3 N = data.n;\n  vec3 L = getLightDir(light, p);\n  vec3 att = getLightAtt(light, p, N);\n  vec3 ref = reflect(N, L);\n  float VdotR = max(0.0, dot(rd, ref));\n  float spec = pow(VdotR, 24.0);\n  float shadow = getShadow(data.p, getLightDir(light, data.p), data.n);\n  return ((diffuse + spec) * att) * shadow * shadow;\n}\n\nvec3 scene(vec3 ro, vec3 rd) {\n  #define NUM_LIGHTS 1\n\n  vec3 ld = vec3(0.0, -0.1, 1.);\n  \n  ld = pointRot(ld, vec3(0.0, cos(T-2.251)*0.05, -0.25+(0.5*sin(T)*0.5)));\n  \n  Light lights[NUM_LIGHTS] = Light[](\n    Light(ro, ld, vec3(0.97, 0.79, 0.69), 6.0, LIGHT_DIRECTIONAL)\n  );\n  \n  vec3 col = vec3(0.0);\n  Data data = NEW_DATA;\n\n  if (march(ro, rd, data)) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n      Light light = lights[i];\n      col += forEachLight(light, ro, rd, data, diffuse);\n    }\n  }\n  \n  float depth = data.d / FAR;\n  \n  float k =  noise(rd*depth + 0.06*(ro+rd*depth), 1344.4, 2.2, 0.09, 2);\n  col += smoothstep(0.30, 0.8, depth) *  mix(vec3(1.0), vec3(0.75, 0.71, 0.59), exp(k-1.));\n  col += 0.75*smoothstep(0.7, 0.9, depth);\n  \n  return col;\n}\n\nvoid getRay(vec2 uv, vec4 m, inout vec3 ro, inout vec3 rd) {\n  float Y = 0.5;\n  ro = vec3(0.0, Y, -6.0);\n  rd = normalize(vec3(uv, 1.0));\n  float speed = 4.5;\n\n  if (m.z > 0.01) {\n    ro.yz *= rot(m.y*TAU);\n    ro.xz *= rot(m.x*TAU);\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    ro.z += T*speed;\n  } else {\n    ro.z += T*speed;\n    float angle = getTunnelAngle(ro);\n    rd.xz *= rot(angle*0.5); \n  }\n  \n  \n\n  \n  float angle = getTunnelAngle(ro);\n \n  \n  ro.x -= sin(angle)*7.;\n  \n  ro.y += sin(T*speed)*0.25;\n}\n\n////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 o, in vec2 fc) {\n  vec3 col = vec3(0.0);\n  vec2 uv = (fc-0.5*R.xy)/R.y;\n  vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y,iMouse.zw);\n\n  vec3 ro = vec3(0.0);\n  vec3 rd = vec3(0.0);\n  getRay(uv, m, ro, rd);\n\n\n  col += scene(ro, rd);\n  \n  col += 0.5*col*luma(col);\n  col = aces(col);\n  col = pow(col, vec3(1.0 / 2.2));\n  \n  o = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#ifndef HW_PERFORMANCE\n#define iTime 0.0\n#define iFrame 0\n#endif\n\n\n#define R iResolution.xy\n#define T (iTime+7.04)\n#define M_PI 3.14159265358979323846264338327950288\n#define TAU (M_PI*2.0)\n#define FUI floatBitsToUint\n#define ZERO min(0, iFrame)\n#define NEAR           0.003\n#define NORMAL_EPSILON 0.003\n#define FAR 60.0\n#define STEPS 60\n#define AMBIENT 0.05\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIRECTIONAL 2\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, NEW_OBJECT, NEW_MATERIAL)\n#define NEW_MATERIAL Material(0.0, 0.0, 0.0)\n#define NEW_OBJECT Object(-1, vec3(0.0), vec3(0.0))\n\n#define SAMPLE(OBJ, DIST) if (DIST < dist) { dist = DIST; data.o = OBJ; }\n\n#define ID_BOX 0\n#define ID_GROUND 1\n#define ID_LINE 2\n#define ID_TUNNEL 3\n\n\nmat2 rot(float a) { float s = sin(a); float c = cos(a); return mat2(c, s, -s, c); }\nvec3 aces(vec3 x) { return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.0,1.0); }\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nfloat smin(float a, float b, float k) {float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0); return mix(a, b, h) - k*h*(1.0-h); }\nfloat smax(float a, float b, float k) {return smin(a, b, -k); }\nfloat sabs(in float v, in float k) {return smax(-v, v, k);}\nfloat sclamp(in float v, in float mi, in float ma, in float k) {return smin(smax(v, mi, k), ma, k);}\nfloat sgt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat slt(in float a, in float b, in float s) {float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0); return mix(0.0, 1.0, h*h*(3.0-2.0*h));}\nfloat ssign(float x, float k) { float s = smoothstep(-k, k, x); return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));}\n\n\nvec3 pointRot(vec3 p, vec3 r) {\n    p.yz *= rot(r.z);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.x);\n    return p;\n}\n\nvec3 transform(vec3 p, vec3 t, vec3 q) {\n    p = pointRot(p - t, q);\n    return p;\n}\n\nfloat hash(vec2 ip, float seed) {\n  uvec2 p = FUI(ip); uint s = FUI(seed); uvec2 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y) / float(0xFFFFFFFFU);\n}\n\nfloat hash(vec3 ip, float seed) {\n  uvec3 p = FUI(ip); uint s = FUI(seed); uvec3 k = ~p + ~s;\n  p ^= p << 17U; p ^= p >> 13U; p ^= p << 5U;\n  p += (p ^ k) + p * k; p *= 1013U; p ^= (p >> 4U);\n  return float(p.x * k.y + p.y + p.y * k.x + k.y + p.z * k.y + k.z) / float(0xFFFFFFFFU);\n}\n\nfloat noise(vec2 p, float s) {\n  p += 3.3828714;\n  vec2 id = floor(p); vec2 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  return mix(mix(hash(id+vec2(0,0),s),hash(id+vec2(1,0),s),lv.x),\n             mix(hash(id+vec2(0,1),s),hash(id+vec2(1,1),s),lv.x),lv.y);\n}\n\nfloat noise(vec3 p, float s) {\n  p += 3.3828714;\n  vec3 id = floor(p); vec3 lv = fract(p);lv = lv*lv*(3.0-2.0*lv);\n  float a =  mix(mix(hash(id+vec3(0,0, 0),s),hash(id+vec3(1,0, 0),s),lv.x),\n             mix(hash(id+    vec3(0,1, 0),s),hash(id+vec3(1,1, 0),s),lv.x),lv.y);\n  float b =  mix(mix(hash(id+vec3(0,0, 1),s),hash(id+vec3(1,0, 1),s),lv.x),\n             mix(hash(id+    vec3(0,1, 1),s),hash(id+vec3(1,1, 1),s),lv.x),lv.y);\n  return mix(a, b, lv.z);\n}\n\n\nfloat noise(vec2 p, float s, float freq, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec2 tx = vec2(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec2(sin(n*6.28), cos(n*6.28));\n    \n  }\n  return n / div;\n}\n\nfloat noise(vec3 p, float s, float freq, float warp, const in int oct) {\n  float n = 0.0;\n  float div = 0.0;\n  float amp = 1.0;\n  vec3 tx = vec3(0.0);\n  for (int i = ZERO; i < oct; i++) {\n    n += amp*noise((p+tx)*freq,s);\n    div += amp;\n    amp *= 0.5;\n    freq *= 2.0;\n    tx += warp * vec3(sin(n*6.28), cos(n*6.28), cos(n*6.28));\n    \n  }\n  return n / div;\n}\n\nstruct Light {\n  vec3 p;\n  vec3 dir;\n  vec3 color;\n  float strength;\n  int type;\n};\n\n\n\nvec3 getLightDir(Light light, vec3 p) {\n  switch (light.type) {\n    case LIGHT_AMBIENT: return normalize(light.p); break;\n    case LIGHT_POINT: return normalize(light.p - p); break;\n    case LIGHT_DIRECTIONAL: return normalize(-light.dir); break;\n    default: return normalize(vec3(1, 2, 3)); break;\n  }\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 N) {\n  vec3 L = getLightDir(light, p);\n  float NdotL = max(AMBIENT, dot(N, L));\n  switch (light.type) {\n    case LIGHT_AMBIENT: return NdotL * light.strength * light.color; break;\n    case LIGHT_POINT: return pow(NdotL * light.strength * light.color, vec3(2.0)) / max(0.0000353, pow(distance(light.p, p), 2.0));\n    case LIGHT_DIRECTIONAL: {\n      \n      return light.color * light.strength * NdotL * smoothstep(0.8, 1.0, dot(\\\n                normalize(light.p - p),\n                L\n            )); break;\n    }\n  }\n\n  return vec3(0.5);\n}\n\nstruct Material {\n  float rough;\n  float spec;\n  float z;\n};\n\n\n\nstruct Object {\n  int id;\n  vec3 p;\n  vec3 q;\n};\n\n\n\nstruct Data {\n  vec3 p;\n  vec3 n;\n  float d;\n  Object o;\n  Material m;\n};\n\n\n\n\nfloat boxSDF(vec3 p, vec3 s) {\n  return length(max(abs(p)-s, 0.0));\n}\n\nfloat lineSDF(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - h * ba)-r;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}