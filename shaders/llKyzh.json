{
    "Shader": {
        "info": {
            "date": "1535166169",
            "description": "Thanks iq for the tip.",
            "flags": 96,
            "hasliked": 0,
            "id": "llKyzh",
            "likes": 8,
            "name": "Minimalism",
            "published": 3,
            "tags": [
                "2d",
                "music",
                "audioreactive"
            ],
            "usePreview": 0,
            "username": "felipunkerito",
            "viewed": 823
        },
        "renderpass": [
            {
                "code": "#define STEPS         200\n#define FAR           20.\n#define EPS          1e-2\n#define PI   acos( -1.0 )\n#define TPI      PI * 2.0\n#define TAU  atan(1.0)*8.0\n#define Smooth\n#define AUD texture( iChannel0, vec2( 0.0, 0.25 ) ).a * 0.4\n#define FRE texture( iChannel0, vec2( 0.0, 0.75 ) ).a * 0.4 \n#define WAV texture( iChannel0, vec2( 0.0, 0.55 ) ).a * 0.4 \n#define RESTART 0.1\n#define TIM 0.1\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n} \n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map( vec3 p )\n{\n\n    float pla = p.y + 1.0;\n    \n    p.zx *= rot( AUD + iTime * TIM );\n    p.zy *= rot( FRE + iTime * TIM );\n    p.xy *= rot( WAV + iTime * TIM );\n    \n    vec3 pte = p;\n    \n    for( int i = 0; i < 10; ++i )\n    {\n    \n        pte = abs( pte - 0.05 );\n        //p.y -= 0.1;\n        //p.x -= 0.03;\n        //p.z -=  0.1;\n        pte.xy = pte.yx;\n        pte.xy *= rot( iTime * TIM * 0.2 + AUD );\n        pte.zx *= rot( iTime * TIM * 0.2 + FRE );\n        pte.yz *= rot( iTime * TIM * 0.2 + WAV );\n        \n    }\n    \n    vec3 siz = vec3( 0, 0, 1 );\n    siz.zx *= rot( AUD + iTime * TIM );\n    siz.zy *= rot( FRE + iTime * TIM );\n    siz.xy *= rot( WAV + iTime * TIM );\n    siz += 1.0;\n    \n    float box = sdBox( pte - siz, vec3( 1 ) );\n    \n    vec2 bpi = vec2( smin( box, pla, 2.0 ), 0.0 );\n    \n    return bpi;\n\n}\n\nvec3 norm( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    return normalize( vec3( map( p + e.xyy ).x - map( p - e.xyy ).x,\n                            map( p + e.yxy ).x - map( p - e.yxy ).x,\n                            map( p + e.yyx ).x - map( p - e.yyx ).x\n                          )\n                    );\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = map( ro + rd * t ).x;\n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    \n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t ).x;\n        if( h < EPS ) return 0.0;\n        \n        res = min( res, 8.0 * h / t );\n        \n        t += h;\n    \n    }\n    \n    return res;\n\n}\n\n// XOR's\n\n//Tri-linear Texturing Function\nvec3 t3(sampler2D tex, vec3 p, vec3 n)\n{\n    //p = ( p + 1.0 ) / 2.0;\n    \n    p.zx *= rot( AUD + iTime * TIM );\n    p.zy *= rot( FRE + iTime * TIM );\n    p.xy *= rot( WAV + iTime * TIM );\n    \n    #ifdef Smooth\n \treturn  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n    #else\n    return (texture(tex,p.xy).rgb\n           +texture(tex,p.zy).rgb\n           +texture(tex,p.xz).rgb)/3.0;\n    #endif\n}\n\n// Shane's\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 shad( vec3 ro, vec3 rd )\n{\n    \n\tfloat d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    vec3 lig = normalize( vec3( 1.0, 0.8, 0.6 ) );\n    vec3 blig = vec3( -lig.x, -lig.y, -lig.z );\n    vec3 col = vec3( 0.0 );\n    vec3 ref = reflect( rd, n );\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float bac = max( 0.0, 0.5 + 0.2 * dot( blig, n ) );\n    float dif = max( 0.0, dot( lig, n ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n    float speO = pow( clamp( dot( ref, blig ), 0.0, 1.0 ), 16.0 );\n    \n    col += 0.2 * amb; \n    col += 0.4 * dif;\n    col += 0.2 * bac;\n    col += 0.05 * spe;\n    col += 0.05 * speO;\n    col += 1.0 * sha;\n    \n    vec3 tex = vec3( 0 );\n    p.zx *= rot( AUD + iTime * TIM );\n    p.zy *= rot( FRE + iTime * TIM );\n    p.xy *= rot( WAV + iTime * TIM );\n    float mul = 0.5;\n    float div = 1.0;\n    tex = t3( iChannel0, ( p * mul + div ) * ( div * 0.5 ), n );\n    col += vec3( 0, tex.r * 3.5, 0 );\n    col -= 0.6;\n    col *= 2.0 * 8.0 / ( t * t );\n        \n    col *= sqrt( col ); \n    \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    /*\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture( iChannel0, uv );\n\t*/\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    \n    \n    vec2 mou = iMouse.xy / iResolution.xy;\n    mou.y = clamp( mou.y,-TAU/4.0, 1.5 );\n    \n    vec3 ro = vec3( 0.0 );\n    \n    if( iMouse.z < 0.0 || mou.x == 0.0 )\n    \tro = 7.0 * vec3( sin( iTime * 0.2 ), 0.5, cos( iTime * 0.2 ) );\n    else\n        ro = 7.0 * vec3( sin( mou.x * TPI ), mou.y, cos( -mou.x * TPI ) );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    //vec3 rd = normalize( vec3( uv, -1.0 ) );\n    \n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n    vec3 col = d < EPS ? shad( ro, rd ) : vec3( 0.0 );\n    \n    col *= sqrt( col );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define AUD texture( iChannel0, vec2( 0.0, 0.24 ) ).x * 0.5\n#define WAV texture( iChannel0, vec2( 0.0, 0.75 ) ).x * 0.5\n\nfloat hash( float a )\n{\n\n    return fract( sin( a * 38220.03 ) + 83849.24 );\n\n}\n\nfloat hash( vec2 a )\n{\n\n    return fract( sin( a.x * 3433.8 + a.y * 3843.98 ) * 45933.8 );\n\n}\n\nfloat noise( vec2 uv )\n{\n    \n    vec2 lv = fract( uv );\n    lv = lv * lv * ( 3.0 - 2.0 * lv );\n    vec2 id = floor( uv );\n    \n    float bl = hash( id );\n    float br = hash( id + vec2( 1, 0 ) );\n    float b = mix( bl, br, lv.x );\n    \n    float tl = hash( id + vec2( 0, 1 ) );\n    float tr = hash( id + vec2( 1 ) );\n    float t = mix( tl, tr, lv.x );\n    \n    float c = mix( b, t, lv.y );\n    \n    return c;\n\n}\n\nfloat per( float x )\n{\n\n    float i = floor(x);  // integer\n    float f = fract(x);  // fraction\n    float y = hash(i); //rand() is described in the previous chapter\n    //y = mix(hash(i), hash(i + 1.0), f);\n    y = mix(hash(i), hash(i + 1.0), smoothstep(0.,1.,f));\n    \n    return y;\n\n}\n\nfloat hal( float uy, float dim )\n{\n    \n    uy = per( uy );\n    \n    float mid = smoothstep( dim, dim - 0.05, uy - 0.5 );\n    \n    return mid;\n\n}\n\nfloat lin( float uy, float dim )\n{\n    \n    return hal( uy, dim ) - hal( uy, dim - ( dim / 2.0 ) );\n\n}\n\nfloat loo( vec2 uv, float dim )\n{\n    \n    float sta = -0.4;\n    float fin = 0.5;\n    float tem = abs( fin - sta );\n    float dis = 0.025;\n    float siz = abs( tem / dis );\n    \n    float ser = 0.0;\n    float fre = 0.0;\n    \n    float arr = 0.0;\n    \n    /*\n    \n    for( int i = sta; i < fin; i+=dis )\n    {\n    \n        float wav = texture( iChannel0, vec2( 0.0, 0.1 ) ).x * 0.0001;\n        arr = float( i ) * 0.025 + wav;\n        float m = cos( ( iTime + arr ) + ( uv.x * arr ) * 18.0 ) * hash( arr ) * wav * 145.0;\n    \tfloat y = uv.y + m;\n        ser += lin( y + arr, dim );\n    \n    }\n\t*/\n    \n    /*\n    for( float i = sta; i < fin;  i += dis )\n    {\n    \n        float wav = texture( iChannel0, vec2( 0.0, 0.1 ) ).x * 0.000001;\n        arr = i + wav;\n        float m = cos( ( iTime + arr ) + ( uv.x * arr ) * 18.0 ) * hash( arr ) * wav * 145.0;\n        //float m = per( uv.x + hash( arr ) );\n        float y = ( uv.y + m );\n        ser += lin( y + arr, dim );\n    \n    }\n\t*/    \n\n    /*\n    float m = per( uv.x + iTime );\n    float y = ( m + uv.y );\n    ser = lin( y, dim );\n\t*/\n    \n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    float m = per( noise( uv + AUD * 2.0 + mod( iTime, 10.0 ) ) );\n    float y = ( m + uv.y );\n    ser = lin( y, dim + AUD * 0.05 );\n    \n    float mO = per( noise( uv + WAV * 2.0 + mod( iTime, 10.0 ) ) );\n    float x = ( m + uv.x );\n    ser += lin( x, dim + WAV * 0.05 );\n    \n    return ser;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    //uv -= 0.5;\n\tuv *= 4.0;\n    //uv += 5.0;\n    //uv.y += iTime;\n    \n    float li = loo( uv, 0.1 );\n    \n    //vec3 col = vec3( 0, li, 0 );\n\n    vec3 col = mix( vec3( 0, 0, 0 ), vec3( 1 ), li );\n    \n    // Output to screen\n    fragColor = vec4(col,AUD);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 15922,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/muterecords/plastikman-marbles?in=trold-mand/sets/plastikman"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}