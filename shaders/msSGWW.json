{
    "Shader": {
        "info": {
            "date": "1667585466",
            "description": "A simple Voronoi noise implementation.  All code in this project *should* be commented and easy to understand. Mouse X controls point jitter, mouse Y controls the split effect. Space toggles showing the second closest point/distance",
            "flags": 16,
            "hasliked": 0,
            "id": "msSGWW",
            "likes": 7,
            "name": "Simple voronoi noise",
            "published": 3,
            "tags": [
                "voronoi"
            ],
            "usePreview": 0,
            "username": "fishy",
            "viewed": 186
        },
        "renderpass": [
            {
                "code": "vec2 hash22(vec2 p) //hashwithoutsine; hash functions return a random number based on a non-random input, \n// e.g. a range of numbers 0, 1, 2, and 3 each hashed might return a new sequence 0.5, 0.2, 0.7, and 0.9.\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat voronoi(vec2 p, float jitter, out vec2 f1, out vec3 f2)\n{\n    float r = 100000.0; // A big number\n    vec2 fp = floor(p); // Round the current position down to the nearest whole number\n    f1 = vec2(0);\n    f2 = vec3(0);\n    for(int x = -1; x <= 1; x++) // Loop over the space near the point\n    for(int y = -1; y <= 1; y++) // Same thing\n    {\n        vec2 cell = fp+vec2(x, y); // Get the current square cell\n        vec2 rp = cell+0.5+(hash22(cell)-0.5)*jitter; // Each square cell the point can be in has a single point, offset by a random value times the jitter\n        float d = distance(p, rp); // Get the distance between the random point and the input position\n        if(d < r) // If the distance is the closer than the current closest distance, it becomes the closest distance (along with the position of the point)\n        {\n            f2.z = r;\n            r = d;\n            f2.xy = f1;\n            f1 = rp;\n        }\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Convert coordinates to 0.0 to 1.0 range\n    uv.y *= iResolution.y/iResolution.x; // Scale coordinate so that the tiles don't appear squashed\n    \n    vec2 mouse = iMouse.x == 0.0? vec2(smoothstep(-1., 1., sin(iTime)),smoothstep(-1., 1., cos(iTime))) // Animate mouse x and y when no mouse input (thumbnail) according to a square circle\n                 : iMouse.xy/iResolution.xy; // Otherwise use the actual mouse input if there is some\n    mouse.y *= iResolution.y/iResolution.x; // Scale mouse coordinate so that they match the range of the UV coords\n    \n    vec2 f1; // Functions can sort of \"return\" multiple values by using the \"out\" keyword, so this variable will store the position of the closest point\n    vec3 f2; // Read comment for f1. vec3 because this variable stores both the position and the distance, whereas f1 only stores the position\n    float v = voronoi(uv*10.0, mouse.x, f1, f2); // Evaluate voronoi\n    \n    float space = texelFetch(iChannel0, ivec2(32, 2), 0).r;\n    \n    vec3 col = uv.y < mouse.y? vec3(space > 0.5? (f2.z) : v) : vec3((space > 0.5? f2.xy : f1)/10., 0.0); // Split the screen between showing the distance and the position based on mouse position\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}