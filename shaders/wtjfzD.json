{
    "Shader": {
        "info": {
            "date": "1599245873",
            "description": "teaching myself raymarching",
            "flags": 0,
            "hasliked": 0,
            "id": "wtjfzD",
            "likes": 10,
            "name": "im learning raymarching",
            "published": 3,
            "tags": [
                "learning"
            ],
            "usePreview": 0,
            "username": "TheNosiriN",
            "viewed": 436
        },
        "renderpass": [
            {
                "code": "const int MAX_MARCHING_STEPS = 256;\nconst int MAX_SHADOW_STEPS = 32;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\nconst float PI = 3.1415972;\n\nconst vec3 fogColor = vec3(0.7, 0.8, 1.0);\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\n\n\nfloat plane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat cube(vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n\nvec3 triplanarMap(sampler2D tex, vec3 p, vec3 n, float scale)\n{\n    p *= scale;\n    \n    return  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\nvec3 triplanarNormal(sampler2D tex, vec3 p, vec3 N, float strength, float scale)\n{\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n    \n    vec3 B = vec3(\n        triplanarMap(tex, p+P.xzz, N, scale).r, \n        triplanarMap(tex, p+P.zxz, N, scale).r,\n        triplanarMap(tex, p+P.zzx, N, scale).r\n    ) - triplanarMap(tex, p, N, scale).r;\n    \n    B = (B-N*dot(B,N));\n    return normalize(N+B*strength);\n}\n\nvec3 applyFog(vec3 rgb, float dist)\n{\n    float startDist = 30.0;\n    float fogAmount = 1.0 - exp(-(dist-1.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\n\n\n\n\nfloat sceneSDF(vec3 p)\n{\n    float result = 1e10;\n    \n    float sphereDist = sphere(p, 1.0);\n    float cubeDist = boundingBox(p-1.0, vec3(1.0), 0.1) - 0.1;\n    \n    result = unionSDF(result, sminCubic(sphereDist, unionSDF(sphereDist, cubeDist), 0.5 ));\n    \n    result = unionSDF(result, plane(vec3(p.x, p.y+1.0, p.z), vec3(0.0, 1.0, 0.0), 0.0));\n    \n    return result;\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        vec3 p = eye + depth * marchingDirection;\n        float dist = sceneSDF(p);\n        if (dist < EPSILON * length(p)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nvec3 normal(vec3 p) {\n    vec3 P = vec3(-4, 4, 0) * 0.01;\n\n \treturn normalize(\n        sceneSDF(p+P.xyy) * \n        P.xyy + sceneSDF(p+P.yxy) * \n        P.yxy + sceneSDF(p+P.yyx) * \n        P.yyx + sceneSDF(p+P.xxx) * \n        P.xxx\n    );\n}\n\n\n\n// Cast shadow ray\nfloat shadow(in vec3 eye, in vec3 dir) {\n    float res = 1.0;\n    float t = EPSILON;\n    float ph = 1e10;\n        \n    for( int i=0; i<MAX_SHADOW_STEPS && t < MAX_DIST; i++ )\n    {\n     \tvec3 p = eye + dir * t;\n        float h = sceneSDF(p);\n        if (h < 0.0){ return 0.0; }\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        \n        t += h;\n    }\n\n    return res;\n}\n\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal(p);\n    k_d *= triplanarMap(iChannel0, p, N, 0.5);\n    N = triplanarNormal(iChannel0, p, N, 5.0, 0.5);\n    \n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    vec3 color;\n    \n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        color = lightIntensity * (k_d * dotLN);\n    }\n    color = lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    \n    \n    float fresnelTerm = clamp(dot(V, N), 0.0, 1.0);\n    color = mix(color, pow(color, vec3(2.0)), fresnelTerm);\n    \n    \n    //shadow\n    if (color != vec3(0.0)){\n        color *= shadow(p, normalize(lightPos));\n    }\n    \n    return clamp(color, vec3(0.0), vec3(1.0));\n}\n\n\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(1.0, 0.5, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0,\n                          2.0 * cos(0.37 * iTime));\n    vec3 light2Intensity = vec3(0.4, 0.5, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\nvec3 applyMaterials(float dist, vec3 eye, vec3 worldDir)\n{\n    vec3 col = vec3(0.0);\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = fogColor*0.5;\n    vec3 K_d = vec3(1.0, 1.0, 1.0);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    col = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    col = applyFog(col, length(p));\n    \n    return col;\n}\n\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nvec3 rotateCamera(float len, vec2 m)\n{\n    float phi = m.x * PI * 2.0;\n    if(iMouse.x < 0.5){\n        phi = PI * 0.1;\n    }\n    \n    float psi = m.y * PI;\n    if(iMouse.y < 0.5){\n        psi = 0.33 * PI;\n    }\n    return len * vec3(cos(phi)*sin(psi), cos(psi), sin(phi)*sin(psi));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = rotateCamera(20.0, iMouse.xy/iResolution.xy);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        // Didn't hit anything\n        fragColor = vec4(fogColor, 1.0);\n\t\treturn;\n    }\n    \n    \n    vec3 color = applyMaterials(dist, eye, worldDir);\n    \n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}