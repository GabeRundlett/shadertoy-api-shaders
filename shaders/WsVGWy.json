{
    "Shader": {
        "info": {
            "date": "1570977852",
            "description": "A simple hexagonal grid pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "WsVGWy",
            "likes": 26,
            "name": "Hexagon Grid Pattern",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "hexagon",
                "pattern",
                "art"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 2080
        },
        "renderpass": [
            {
                "code": "/*\n\n\tHexagon Grid Pattern\n\t--------------------\n\n    I see variations on this particular pattern all over the place, and it's pretty\n\teasy to make, so I figured I'd recreate one. If it's not obvious, the idea is to\n\tpartition space into hexagonal cells, then render six smaller overlapping hexagons \n\tin each of the cell's six corners. Commenting in the \"SHOW_GRID\" define should \n    make it more clear. \n\n\tOn a side note, there are countless other interesting hexagonal stock imagery \n    patterns on the internet that I'd love to see on Shadertoy, if anyone feels like \n\tmaking any. :)\n\n\t\n    Other Hexagonal Pattern Examples:\n\n\n\tShadertober Day 10 - Pattern -- BackwardsCap\n\thttps://www.shadertoy.com/view/tsV3Rd\n\n    Hexagon Pattern -- plabatut \n\thttps://www.shadertoy.com/view/Wdt3WN\n\n    Impossible Chainmail -- BigWIngs \n    https://www.shadertoy.com/view/td23zV\n\n*/\n\n//#define SHOW_GRID\n\n#define FLAT_TOP\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.617, 57.743)))*43758.5453); }\n\n\n// Flat top hexagon, or pointed top.\n#ifdef FLAT_TOP\nconst vec2 s = vec2(1.732, 1);\n#else\nconst vec2 s = vec2(1, 1.732);\n#endif\n\n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n    \n    // Flat top and pointed top hexagons.\n    #ifdef FLAT_TOP\n    return max(dot(abs(p.xy), s/2.), abs(p.y*s.y));\n    #else   \n    return max(dot(abs(p.xy), s/2.), abs(p.x*s.x));\n    #endif\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n    \n    vec4 ip = floor(vec4(p/s, p/s - .5));\n    vec4 q = p.xyxy - vec4(ip.xy + .5, ip.zw + 1.)*s.xyxy;\n    return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n    //return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = min(iResolution.y, 800.);\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n    // Scaling and translation.\n    const float sc = 3.;\n    vec2 p = uv*sc - vec2(-1, -.5)*iTime/4.;\n    \n    // Smoothing factor.\n    float sf = 1./res*sc;\n    \n    \n    // Hexagonal grid coordinates.\n    vec4 p4 = getGrid(p);\n    \n    \n    // Hexagon vertex IDs. They're useful for neighboring edge comparisons, etc.\n    // Multiplying them by \"s\" gives the actual vertex postion.\n    #ifdef FLAT_TOP\n    // Vertices: Clockwise from the left.\n\n\tvec2[6] vID = vec2[6](vec2(-1./3., 0), vec2(-1./6., .5), vec2(1./6., .5), \n                          vec2(1./3., 0), vec2(1./6., -.5), vec2(-1./6., -.5)); \n    \n    //vec2[6] eID = vec2[6](vec2(-.25, .25), vec2(0, .5), vec2(.25, .25), \n                         // vec2(.25, -.25), vec2(0, -.5), vec2(-.25, -.25));\n    \n    #else\n    // Vertices: Clockwise from the bottom left. -- Basically, the ones \n    // above rotated anticlockwise. :)\n    vec2[6] vID = vec2[6](vec2(-.5, -1./6.), vec2(-.5, 1./6.), vec2(0, 1./3.), \n                          vec2(.5, 1./6.), vec2(.5, -1./6.), vec2(0, -1./3.));\n     \n    //vec2[6] eID = vec2[6](vec2(-.5, 0), vec2(-.25, .25), vec2(.25, .25), vec2(.5, 0), \n                          //vec2(.25, -.25), vec2(-.25, -.25));\n \n    #endif\n\n   \n    // The scene color.\n    vec3 col = vec3(1);\n\n    \n    // Rendering the six overlapping hexagons within each cell.\n    for(int i = 0; i<6; i++){\n        \n  \n        // Corner hexagon.\n        vec2 q = abs(p4.xy - vID[5-i]*s*.5);\n        float hx = getHex(q) - .265;\n        float oHx = hx;\n\n        // Using the neighboring hexagon to chop out one third. This way, the final\n        // hexagon will look like it's tucked in behind the previous one... Comment\n        // out the third (hx) line to see what I mean. By the way, you don't have to\n        // do this, but I prefer this particular look.\n        q = abs(p4.xy - vID[(5-i + 5)%6]*s/2.);\n        float hx2 = getHex(q) - .27;\n        hx = max(hx, -hx2);\n\n        // Using the triangle wave formula to render some concentric lines on each\n        // hexagon.\n        float pat = (1. - abs(fract(oHx*16. + .2) - .5)*2.) - .55;\n        pat = smoothstep(0., .2, pat);\n        \n        // Rendering the chopped out hexagon and a smaller white center.\n        col = mix(col, vec3(1)*pat, 1. - smoothstep(0., sf, hx));  \n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, max(oHx + .22, -hx2)));\n        // A colorful center, if preferred.\n        //col = mix(col, vec3(1, .05, .1), 1. - smoothstep(0., sf, max(oHx + .22, -hx2))); \n        \n        // Applying a shadow behind the hexagon. I thought it added more visual interest, \n        // but for something like wallpaper, or whatever, you could comment it out.\n        vec3 sh = mix(col, vec3(0), (1. - smoothstep(0., sf, hx)));\n        col = mix(col, sh, (1. - smoothstep(0., sf*8., max(max(hx, hx2), - hx2)))*.5);\n\n    }\n    \n        \n    // Rendering the grid boundaries, or just some black hexagons in the center.\n    float gHx = getHex(p4.xy);\n    \n    #ifdef SHOW_GRID \n    // Grid lines.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(gHx - .5) - .035));  \n    col = mix(col, vec3(1, .05, .1)*1.5, 1. - smoothstep(0., sf, abs(gHx - .5) - .0075));  \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., gHx - .02 - .025))*.5);\n    // Colored center hexagon.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, gHx - .02 - .025));   \n    col = mix(col, vec3(1, .05, .2), 1. - smoothstep(0., sf, gHx - .015));   \n    #else\n    // Small shadowed center hexagon.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., gHx - .02))*.5);   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, gHx - .02));  \n    #endif\n    \n    // Vignette.\n    //uv = fragCoord/iResolution.xy;\n    //col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}