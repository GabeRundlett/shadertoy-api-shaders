{
    "Shader": {
        "info": {
            "date": "1647087405",
            "description": "my first shader at ShaderToy!",
            "flags": 0,
            "hasliked": 0,
            "id": "7dSBDV",
            "likes": 2,
            "name": "my first shader at ShaderToy!",
            "published": 3,
            "tags": [
                "2d",
                "circle"
            ],
            "usePreview": 0,
            "username": "fl0a1e",
            "viewed": 159
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------\n// It's my first shader!\n// \n// create 2D circle\n// And I want to test something in this shader\n// Including SSAA and gamma \n// just for fun\n// ---------------------------------------\n\n#define AA 2\n#define INV_GAMMA 0.454545\n\n#define OUTSIDECIRCLE 0.0f\n#define INSIDECIRCLE 1.0f\n\nfloat sdCircle(vec2 p, float r){\n    return length(p)-r;\n}\n\n\nfloat map(vec2 uv) {\n    float res = -1.0f;\n\n    // distance between uv and O\n    float r = 0.5*abs(sin(iTime))-0.2;\n    res = (sdCircle(uv, r) >= 0.05 && sdCircle(uv, r) <= 0.1) ? OUTSIDECIRCLE : res;\n    res = (sdCircle(uv, r) >= 0.001 && sdCircle(uv, r) <= 0.03) ? INSIDECIRCLE : res;\n\n    return res;\n}\n\n\nvec3 shader(vec2 uv, float flag){\n    // background\n    vec3 col = vec3(.03, .03, .06);\n    \n    // circle\n    if(flag == OUTSIDECIRCLE){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    if(flag == INSIDECIRCLE){\n        col = 0.5 + 0.5*cos(sin(iTime)+uv.xyx+vec3(0,2,4));\n        \n    }\n    return col;\n}\n\n\nvec3 render(vec2 uv){\n    \n    // 2D raymarching(I called so)\n    float flag = map(uv);\n    \n    // shadering\n    vec3 col = shader(uv, flag);\n    \n    // others\n    if(uv.y <= .001 && uv.y >= .0){\n        col = vec3(1,1,1);\n    }\n    if(uv.x <= .001 && uv.x >= .0){\n        col = vec3(1,1,1);\n    }\n    if(sdCircle(uv, .001) <= .005){\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col;\n    \n    // SSAA\n    #if AA > 1\n    for(int i = 0; i < AA; i++)\n        for(int j = 0; j < AA; j++){\n            vec2 offset = (vec2(i,j)/float(AA)) - 0.5;\n\n            // SSAA:1 pixel->AA*AA pixels\n            // move our coordinates to center\n            // Normalized pixel coordinates (from 0 to 1)\n            vec2 uv = ((fragCoord+offset)-0.5*iResolution.xy)/iResolution.x; // fix range of x axis\n            \n    #else\n            vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    #endif\n            // ----------------------------------------------\n            col = render(uv);\n            \n    \n     #if AA>1 \n          // can't be dropped in 3D scene, maybe, because we have sampled a pixel AA*AA times\n          // col /= float(AA*AA);\n        }\n     #endif\n   \n    \n    // gamma\n    col = pow(col, vec3(INV_GAMMA));\n    \n    vec3 tot = col;\n    \n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}