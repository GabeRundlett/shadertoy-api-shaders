{
    "Shader": {
        "info": {
            "date": "1516552090",
            "description": "Here we just add a second light with double shadow.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltjBRK",
            "likes": 1,
            "name": "7. Multilight",
            "published": 3,
            "tags": [
                "multilight"
            ],
            "usePreview": 0,
            "username": "ragotpaul",
            "viewed": 482
        },
        "renderpass": [
            {
                "code": "#define MAX_REFLECT 16\n\nstruct Pixel {\n    vec2 coordinate;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 color;\n    float ka;\n    float kd;\n    float ks;\n    float shininess;\n};\n\nstruct Sphere {\n    float radius;\n    vec3 position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct LightColor {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Light {\n    vec3 position;\n    LightColor color;\n};\n\nstruct Camera {\n    vec3 eye;\n    vec3 front;\n    vec3 up;\n    float fov;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nconst vec3 background = vec3(0.1, 0.2, 0.4);\nconst float infini = 1.0 / 0.0;\nconst float epsilon = 0.0001;\n\nint skyId = 0;\nint sphereId = 1;\nint planeId = 2;\n\nPixel initPixel(in vec3 color, in vec2 fragCoord) {\n    Pixel pixel = Pixel(\n        2.0 * fragCoord.xy / iResolution.xy - 1.0,                          /* coordinate */\n        color                                                                   /* color */\n    );\n    float ratio = iResolution.x / iResolution.y;\n    if (ratio > 1.0) {\n        pixel.coordinate.x *= ratio;\n    } else {\n        pixel.coordinate.y /= ratio;\n    }\n    return pixel;\n}\n\nRay initRay(in Pixel pixel, in Camera camera) {\n    float focal = 1.0 / tan(radians(camera.fov) / 2.0);\n\n    vec3 forward = normalize(camera.front);\n    vec3 side = normalize(cross(forward, camera.up));\n    vec3 up = normalize(cross(forward, side));\n\n    vec3 direction = normalize(pixel.coordinate.x * side - pixel.coordinate.y * up + focal * forward);\n\n    return Ray(\n        camera.eye,                                                             /* origin */\n        direction                                                               /* direction */\n    );\n}\n\nfloat computeSphereIntersection(inout Ray ray, in Sphere sphere) {\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, ray.origin - sphere.position);\n    float c = dot(ray.origin - sphere.position, ray.origin - sphere.position) - sphere.radius * sphere.radius;\n    float t = -1.0;\n    float delta = b * b - 4.0 * a * c;\n    if (delta >= 0.0) {\n        float sqrt_delta = sqrt(delta);\n        float t1 = (- b - sqrt_delta) / (2.0 * a);\n        float t2 = (- b + sqrt_delta) / (2.0 * a);\n        float direction = 1.0;\n        if (t1 > 0.0) {\n            t = t1;\n        } else if (t2 > 0.0) {\n            t = t2;\n            direction = -1.0;\n        } else {\n            return t;\n        }\n        ray.origin = ray.origin + t * ray.direction;\n        ray.direction = normalize(ray.origin - sphere.position) * direction;\n    }\n    return t;\n}\n\nfloat computePlaneIntersection(inout Ray ray, in Plane plane) {\n    float t = -1.0;\n    float d = dot(plane.normal, ray.direction);\n    if (abs(d) <= epsilon) {\n        return t;\n    }\n    t = dot(plane.normal, plane.position - ray.origin) / d;\n    ray.origin = ray.origin + t * ray.direction;\n    ray.direction = -sign(d) * plane.normal;\n    return t;\n}\n\nMaterial computeCheckboard(in vec3 position, in Plane plane) {\n    vec3 side = vec3(1.0, 0.0, 0.0);\n    vec3 axisX = normalize(side - dot(side, plane.normal) * plane.normal);\n    vec3 axisY = normalize(cross(plane.normal, axisX));\n    vec3 vDelta = position - plane.position;\n    float u = dot(vDelta, axisX);\n    float v = dot(vDelta, axisY);\n    if (mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0) {\n        plane.material.color = vec3(0.0, 0.0, 0.0);\n    }\n    return plane.material;\n}\n\nvec3 computePhongShading(in Ray ray, in Ray intersection, in Material material, in Light light, in float shadow_factor) {\n    vec3 L = normalize(light.position - intersection.origin);\n    vec3 R = 2.0 * dot(L, intersection.direction) * intersection.direction - L;\n    vec3 V = -ray.direction;\n\n    vec3 ambient = material.ka * light.color.ambient;\n    vec3 diffuse = material.kd * light.color.diffuse * material.color * max(dot(intersection.direction, L), 0.0);\n    vec3 specular = material.ks * light.color.specular * material.color * pow(max(dot(R, V), 0.0), material.shininess);\n\n    float specular_shadow_factor = shadow_factor < 1.0 ? 0.0 : 1.0;\n\n    return ambient + (diffuse * shadow_factor) + (specular * specular_shadow_factor);\n}\n\nfloat computeNearestIntersection(inout Ray ray, in Sphere sphere, in Plane plane, out int id) {\n    id = skyId;\n    float t = infini;\n    Ray intersection = ray;\n\n    Ray iSphere = ray;\n    float dSphere = computeSphereIntersection(iSphere, sphere);\n    if (dSphere > epsilon && dSphere < t) {\n        id = sphereId;\n        t = dSphere;\n        intersection = iSphere;\n    }\n\n    Ray iPlane = ray;\n    float dPlane = computePlaneIntersection(iPlane, plane);\n    if (dPlane > epsilon && dPlane < t) {\n        id = planeId;\n        t = dPlane;\n        intersection = iPlane;\n    }\n\n    if (id == skyId) {\n        t = -1.0;\n    }\n\n    ray = intersection;\n\n    return t;\n}\n\nfloat computeShadowFactor(inout Ray ray, in Material material, in Sphere sphere, in Plane plane, in Light light) {\n    Ray iShadow = ray;\n    iShadow.origin = ray.origin + epsilon * ray.direction;\n    iShadow.direction = light.position - ray.origin;\n    int id = skyId;\n    float ray_length = computeNearestIntersection(iShadow, sphere, plane, id);\n    if (ray_length > epsilon && ray_length < length(light.position - ray.origin) - epsilon) {\n        return material.ka;\n    }\n    return 1.0;\n}\n\nvoid drawScene(inout Pixel pixel, inout Ray ray, in Sphere sphere, in Plane plane, in Light[2] light) {\n    Ray intersection = ray;\n    Material material_reflect[MAX_REFLECT];\n    int n = 0;\n    int id = skyId;\n    do {\n        float ray_length = computeNearestIntersection(intersection, sphere, plane, id);\n\n        if (id == sphereId) {\n            material_reflect[n] = sphere.material;\n            float shadow_factor = computeShadowFactor(intersection, sphere.material, sphere, plane, light[0]);\n            material_reflect[n].color = computePhongShading(ray, intersection, sphere.material, light[0], shadow_factor);\n            shadow_factor = computeShadowFactor(intersection, sphere.material, sphere, plane, light[1]);\n            material_reflect[n].color += computePhongShading(ray, intersection, sphere.material, light[1], shadow_factor);\n            material_reflect[n].color /= 2.0;\n        } else if (id == planeId) {\n            material_reflect[n] = plane.material;\n            float shadow_factor = computeShadowFactor(intersection, plane.material, sphere, plane, light[0]);\n            material_reflect[n].color = computePhongShading(ray, intersection, computeCheckboard(intersection.origin, plane), light[0], shadow_factor);\n            shadow_factor = computeShadowFactor(intersection, plane.material, sphere, plane, light[1]);\n            material_reflect[n].color += computePhongShading(ray, intersection, computeCheckboard(intersection.origin, plane), light[1], shadow_factor);\n            material_reflect[n].color /= 2.0;\n        } else {\n            material_reflect[n++] = Material(\n                background,\n                0.0,\n                0.0,\n                0.0,\n                0.0\n            );\n            break;\n        }\n        intersection.origin += intersection.direction * epsilon;\n    } while (n++ < MAX_REFLECT);\n\n    for (int i = n-1; i >= 0; --i) {\n        pixel.color *= material_reflect[i].ks;\n        pixel.color += material_reflect[i].color;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Pixel pixel = initPixel(background, fragCoord);\n\n    Camera camera = Camera(\n        vec3(0.0, 0.0,  5.0),                                                   /* eye */\n        vec3(0.0, 0.0, -1.0),                                                   /* front */\n        vec3(0.0, 1.0,  0.0),                                                   /* up */\n        45.0                                                                    /* fov */\n    );\n\n    Ray ray = initRay(pixel, camera);\n\n    Light light[2];\n\n    light[0] = Light(\n        vec3(cos(iTime) * 10.0, 10.0, sin(iTime) * 10.0),                     /* position */\n        LightColor(                                                             /* color */\n            vec3(1.0, 1.0, 1.0),                                                /* ambient */\n            vec3(1.0, 1.0, 1.0),                                                /* diffuse */\n            vec3(1.0, 1.0, 1.0)                                                 /* specular */\n        )\n    );\n\n    light[1] = Light(\n        vec3(sin(iTime) * 10.0, 10.0, cos(iTime) * 10.0),                     /* position */\n        LightColor(                                                             /* color */\n            vec3(1.0, 1.0, 1.0),                                                /* ambient */\n            vec3(1.0, 1.0, 1.0),                                                /* diffuse */\n            vec3(1.0, 1.0, 1.0)                                                 /* specular */\n        )\n    );\n\n    Plane plane = Plane(\n        vec3(0.0, -1.0, 0.0),                                                   /* position */\n        vec3(0.0, 1.0, 0.0),                                                    /* normal */\n        Material(                                                               /* material */\n            vec3(1.0, 1.0, 1.0),                                                /* color */\n            0.1,                                                                /* ka */\n            0.8,                                                                /* kd */\n            0.2,                                                                /* ks */\n            32.0                                                                /* shininess */\n        )\n    );\n\n    Sphere sphere = Sphere(\n        0.5,                                                                    /* radius */\n        vec3(0.0, sin(iTime) + 0.5, 0.0),                                                    /* position */\n        Material(                                                               /* material */\n            vec3(0.2, 0.8, 0.2),                                                /* color */\n            0.1,                                                                /* ka */\n            0.8,                                                                /* kd */\n            0.4,                                                                /* ks */\n            32.0                                                                /* shininess */\n        )\n    );\n\n    drawScene(pixel, ray, sphere, plane, light);\n\n    fragColor = vec4(pixel.color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}