{
    "Shader": {
        "info": {
            "date": "1492562582",
            "description": "click the \"buttons\"\nbuttons that exist in BufA become a Pip-overlay in \"image\".\nthis demo makes 3 lower left corner buttons cause effects in \"Image\"\nlarge red circles only exist in \"Image\"\n\nfor a workaround where keyboard input does not cut it.",
            "flags": 32,
            "hasliked": 0,
            "id": "MsBczy",
            "likes": 2,
            "name": "mouse-keyboard button overlay",
            "published": 3,
            "tags": [
                "mouse",
                "tutorial",
                "keyboard",
                "tiling",
                "ui",
                "overlay",
                "button",
                "tiles",
                "scaling",
                "interface",
                "buttons",
                "pip"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 739
        },
        "renderpass": [
            {
                "code": "//a modifiable number of buttons with effects while klicked\n//\n//for a mouse-keyboard-pictureInPicture-overlay-UserInterface, \n//as workaround for key input failing on shadertoy recently.\n//\n//partitioning the screenspace to equal parts makes more sense here \n//than caring for proper aspect rattio scaling:\n\n//uncomment if you want to debug BuffA\n//#define justshowBufA\n\n//optionally just show what bufA does\n#define c0(p) texture(iChannel0,p/iResolution.xy,-100.)\n#ifdef justshowBufA\nvoid mainImage(out vec4 Out,in vec2 In){Out=c0(In);}\n#else\n\n//////defines.const.start\n//these defines must be the same in multiple Buffers.\n\n//partition must be the same in bufA as in \"image\"\n//gridscale must be the same in bufA as in \"image\"\n//frame(p)  must be the same in bufA as in \"image\"\n//\n//(inverse of) partition.xy of the screen that will be buttons\n#define partition vec2(2,3)\n//#define partition vec2(2,3)*vec2(iResolution.y/iResolution.x,1.)\n//vec2(23)-> half of the left part && third of the lower part will be buttons\n//number of buttons.xy within partition of the view\n#define gridscale vec2(12,5)\n//frame() puts vec2(0) in the bottom left corner\n#define frame(p) (p*gridscale*partition/iResolution.xy)\n  //p.x*(iResolution.x/iResolution.y);//m.x scales by aspect ratio.\n\n//////defines.const.end\n//\n//////defines.mutable.start\n//these defines can be changed.\n\n//buttonDownPos() returns position of an unmasked pushed button at any moment\n//useful for boolean(==) comparators as within isButtonPushed()\n//in this demo, buttonDownPos() is mostly used to shift a point by [buttonDownPos()]\n//buttonDownPos() retuens [NotPushed] while left mouse button is not pushed.\n#define NotPushed         vec2(-1)\n//buttonDownPos() retuens [PushedNotOnButton] while LeftMouse is pushed while not on a button\n#define PushedNotOnButton vec2(-10)\n//values >=vec2(0) create unresolvable ambiguity for NotPushed or PushedNotOnButton\n//... if a button on that position exists.\n\n//////defines.end\n//\n//////framing.start\n\n//there too many ways to approach a mouse-keyboard-pictureInPicture-overlay-UserInterface\n//so i focus on a simple overly explicit first approach. lets see if this goes anywhere.\n//a more brute force method would be an array of individuabbly placeable buttons.\n//but with that flexibility comes a lot of extra code\n//but with that flexibility comes a slower runtime-loop\n//but that would make array functions unintuitive?\n//\n//so i just allow an array of buttons in a partition of the view.\n\n#define InButton(a) bool(floor(a)==floor(u))\n//true if(u.d is on button set by vec2()a.d; \n//checking one dimension (whole columns or line of button)\n#define InButtonX(a) bool(floor(a.y)==floor(u.y))\n#define InButtonY(a) bool(floor(a.x)==floor(u.x))\n//for a is true for a cross of buttons, line OR column of vec2()a\n#define InButtonCross(a) bool(InButtonX(a)||InButtonY(a))\n\n//a mask== list of \"cosses\", lines, columns or individual buttons)\n//to be skipped by  this condition\nbool buttonMask(vec2 u){return(false\n //leftmost bottom-most button is vec2(0,0)!!\n ||InButton(     vec2(2))  //hide button at position(2,2) (2 right, 2 up)\n ||InButton(     vec2(1,2))//hide button at position(1,2)\n ||InButtonCross(vec2(3))//hide a cross of buttons that is over button at position (3,3)\n ||InButtonY(    vec2(7))//hide a cross of buttons that is over button at position (7,7)\n //evil people hide buttons at random with a seed that changes over time.\n ||InButton (    vec2(6,0)+vec2(floor(fract(iTime)*10.))));\n //just to show that buttons can be masked dnamically.\n ;}\n\n//frame2() puts vec2(0) in the screen center.\nvec2 frame2(vec2 p){p/=iResolution.xy;\n  p-=vec2(.5);//move xy=vec2(0,0) to the center of range [0 .. 1].xy\n  p.x*=iResolution.x/iResolution.y;//m.x scales by aspect ratio.\nreturn p;}\n\nbool InOverlay(vec2 u){\n  //if (buttonMask(u))return false;\n  return all(lessThan(floor(u),gridscale));}\n//true if(u is on button set by vec2()a);\n\n#define agtmf any(greaterThan(b/iResolution.xy,vec2(1.)/partition))\n//needed for [b=frame(fragmentCoord)] checks, to paint buttons individually in PaintButtons()\nvec2 buttonPos(vec2 b){\n if(agtmf)return PushedNotOnButton;//error code for \"mouse button down, ouside of pip-buttons.\n //when you want to know what button ON a pip-keyboard was pressed.\n return floor(frame(b));}\n\nvec2 buttonDownPos(){//this u is framed differently!\n if(iMouse.w<0.)return NotPushed;//error code for no mouse button down;\n vec2 b=iMouse.xy;\n return buttonPos(b);}\n\n//function; isButtonPushed() would have had a nice shortcut for some utility,\n//but that part is buggy for too many cases and therefore disabled.\n//what was left of that became just a \"bad shortcut\" with my fix being a detour?\n//\n//if you want to read what button.xy is held down, or move something by that vec2\n//buttonDownPos() function is simpler to use than isButtonPushed()\n//\n//buttonDownPos() does however a lot of (vec2()==vec2()) \n//and some rounding cases may just utterly fail on that.\n\n//return if color.x (red) over buttonn#.xy==1. \nbool isButtonPushed(vec2 a){\n  return (buttonDownPos()==a);\n    //berare that masked buttons can still be pushed, \n    //buttons masked|hidden by buttonMask() still have an effect, if you isist to,\n    //filtering them here is overly excessive.\n    //instead you can just not give masked buttons any effect.\n/*\n//sadly the below shortcut is buggy for too many cases:\n//no clue, likely strange error, hard to find. its an offset thing, likely with \"partition\"\n  vec2 b=vec2(x,y);\n  // b/=fraction-vec2(1);//some shit like that may fix it.\n  //b.x-=1./partition;//something like that may fix this shortcut\n  b*=iResolution.x;\n  b=frame(b);\n  vec4 i=c0(b);\n  if(i.r<1.)return false;return true;//return if red in that pixel is 1.\n/**/\n}\n\n//////framing.end\n//\n//////paintPiP-button.start\n\nvec4 PaintButtons(vec2 u,vec2 In,vec2 m){\n bool but=(iMouse.w>0.);\n //Out=c0(In);return;//copy PiP-overlay from \"BufA\" to \"Image\"\n //above code just copies BuffA.PiP into Image, lazy;\n //below code has the basics to paint over that with custom tiles.\n    \n //in here, treat a button as if it is a monitor, aspect datio set by gridscale*partition\n vec2 s=fract(u)-.5;//center of button is vec2(0)\n      \n //u.x*=(gridscale*partition).y/(gridscale*partition).x;\n //u.x*=iResolution.x/iResolution.y;\n //above 2 lines would adjust aspect ratios to rations of screen AND button\n        \n //d is distance to center of a button, with modified gratient.\n float d=length(s);//distance to center of a button\n //d*=d;\n d=1.-d;\n //d=fract(d*2.);//ugly high contrast\n const float sharpness=.4;//range [0.. .55]\n d=smoothstep(sharpness,1.-sharpness,d);\n      \n vec2 pos=buttonPos(In);\n //pos can be used to index the buttons, to paind them differently.\n //insert here hwow a button looks, depending on its position# .\n vec3 c=vec3(0);\n c.yz=d*(fract(pos*.2)*.8+.2);\n if(InButton(m)&&(but)){\n  //insert here how a button changes while pushed.\n  c.x=1.;//maximize redness;  cheapest highlight ever.\n }return vec4(c,1.);}//copy PiP-overlay from \"BufA\" to \"Image\"\n\n//////paintPiP-button.end\n//\n//////PaintView.start\n\nvec4 PaintView(vec2 u,vec2 In,vec2 m){\n //your shader goes here!!!\n //the demo shader below shows circles that may change, \n //depending on what button is pushed.\n //PaintView() and the circles that it paints, only exist within \"image\":\n const vec2 buttonA=vec2(1,0);\n const vec2 buttonB=vec2(0,1);\n const vec2 buttonC=vec2(1);\n float a=0.;\n float b=0.;\n bool but=(iMouse.w>0.);//(but) is true if left MOUSE is pressed (anywhere)\n if(but){//if(mouseMutton is prssed)\n  bool bC=isButtonPushed(buttonC);\n  a=float(isButtonPushed(buttonA)||bC);\n  b=float(isButtonPushed(buttonB)||bC);\n }  \n vec2 o=vec2(0);\n if(!buttonMask(m))o=buttonDownPos();\n else if (but)o=PushedNotOnButton;\n u=frame2(In)-.05*o;//move circle center by button index, scaled by .05\n float d=length(u);d=fract(d*9.);//.r=red rings [d];\n //(lowest line|column of buttons move by zero though.)\n //buttonDownPos() can be a more efficient method to check what button is pushed.\n //because it returns .xy position of a button.\n //.gb=combined button status [a],[b], for purpose of a simple demo\n return vec4(d,a,b,1);\n}\n\nvoid mainImage(out vec4 Out,in vec2 In){\n vec2 u=frame(In);\n vec2 m=frame(iMouse.xy);\n #define nonPiP Out=PaintView(u,In,m);return;\n #define PiP Out=PaintButtons(u,In,m);return;\n if(InOverlay(u)){//if([u] is inside overlay.\n if(buttonMask(u)){nonPiP;}//draw non-pop-overlay stuff: []-brackets essential due to included \"return\"\n  PiP//else paint PiP-button\n }nonPiP; //else draw non-pop-overlay stuff:\n}//your \"main Shader\" should be contained complerely within the PaintView() function\n//to allow some buttons (or lines|columns) individually to not be rendered\n\n //vec2 n=frame(iMouse.zw);//while(left mouse down), n is were you klicked left mouse\n //shadertoy does not sent any mouse position while mouse buttons are not pushed.\n //I could load a pixel for each button here to load ALL button statuses.\n //but in the end only 1 button is pused at any moment with a mouse,\n //so I just read the same iMouse.xy data that BufA reads, with the same scaling\n\n#endif",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//a modifiable number of butons that will turn white while klicked.\n\n//for a mouse-keyboard-pictureInPicture-overlay-UserInterface, \n//as workaround for key input failing on shadertoy recently.\n\n//partitioning the screenspace to equal parts \n//...makes more sense here than caring for proper aspect rattio scaling:\n\n//you can remove debugGradient when you are got your right grid-scale.\n//the gradient better shows button borders\n//[//#define debugGradient] makes unpressed buttons black in BuffA\n#define debugGradient\n\n//////defines.const.start\n//these defines must be the same in multiple Buffers.\n\n//partition must be the same in bufA as in \"image\"\n//gridscale must be the same in bufA as in \"image\"\n//frame(p)  must be the same in bufA as in \"image\"\n//\n//(inverse of) partition.xy of the screen that will be buttons\n#define partition vec2(2,3)\n//#define partition vec2(2,3)*vec2(iResolution.y/iResolution.x,1.)\n//vec2(23)-> half of the left part && third of the lower part will be buttons\n//number of buttons.xy within partition of the view\n#define gridscale vec2(12,5)\n//frame() puts vec2(0) in the bottom left corner\n#define frame(p) (p*gridscale*partition/iResolution.xy)\n  //p.x*(iResolution.x/iResolution.y);//m.x scales by aspect ratio.\n\n//////defines.const.end\n//\n/////main.start\n\nvoid mainImage(out vec4 Out,in vec2 In){\n vec2 u=frame(In);\n vec2 m=frame(iMouse.xy);\n vec2 n=frame(iMouse.zw);//while(left mouse down), n is were you klicked left mouse\n //shadertoy does not sent any mouse position while mouse buttons are not pushed.\n bool but=(iMouse.w>0.);//but is true if left mouse pressed\n float d=0.;\n if(!any(greaterThan(floor(u),gridscale-vec2(1)))){//if(u) is on a button\n  if(but){//left mouse down\n   d=length(m-u)*4.;//more blue rings\n   if(floor(u)==floor(m)){//[m] is in the same rectangle as [u]\n    Out=vec4(1);return;}//Out=vec4(0);return;}\n   }else{//left mouse NOT down\n    d=length(m-u)*2.;//less blue ringss\n   }\n   u=fract(u);\n   d=fract(d);\n }else{//if(u) is not a button\n  d=length(n-u);\n  //d=fract(d);\n  Out=vec4(1,0,1,1);return;//purple screenspace is not in use \n }\n //button color while not klicked is;\n #ifndef debugGradient\n u=vec2(0.);\n #endif\n Out=vec4(0,u,0);//gradient with local button position\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}