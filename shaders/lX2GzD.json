{
    "Shader": {
        "info": {
            "date": "1708276331",
            "description": "CCO: Phosphorescent Purple Pixel Peaks 4KiB Windows Exe\n\nOur contribution to MountainBytes 2024.\nMusic: Virgill\nMusic player: Pestis\nGLSL: mrange\n\nhttps://demozoo.org/productions/338637/",
            "flags": 96,
            "hasliked": 0,
            "id": "lX2GzD",
            "likes": 145,
            "name": "MountainBytes: PPPP 4KiB Windows",
            "published": 3,
            "tags": [
                "4kib"
            ],
            "usePreview": 1,
            "username": "mrange",
            "viewed": 7228
        },
        "renderpass": [
            {
                "code": "// ----------------------------------------------\n// CC0: Phosphorescent Purple Pixel Peaks\n// ----------------------------------------------\n//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//   release: Phosphorescent Purple Pixel Peaks |\n//      type: Windows 4k intro                  |\n//      date: 17.02.2024                        |\n//     party: Mountainbytes 2024                |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - So, in this release, I set out to   |\n// whip up a terrain marcher in a snug 4KiB     |\n// space. Started with your usual terrain,      |\n// thinking, \"Let's give it a synthwave twist.\" |\n// Now, my previous attempts at a synthwave-    |\n// style terrain marcher were kinda meh, but    |\n// guess what? Lightning struck, and I managed  |\n// to sculpt some visually pleasing mountains.  |\n//                                              |\n// They're not a perfect match for the synthwave|\n// vibe, but hey, check out these transparent,  |\n// glowing ice cream peaks. Cool, right?        |\n//                                              |\n// Big shoutout to Virgill for dropping another |\n// killer tune that totally catches the vibe.   |\n// Sadly, we had to ditch some funky sound      |\n// effects this time aroundâ€”blame it on the     |\n// space crunch. Fingers crossed, next time,    |\n// we'll pack in the funk.                      |\n//                                              |\n// Oh, and a quick nod to sointu by our main    |\n// man Pestis. This nifty tool churns out tunes |\n// that sound fantastic, and even a music novice|\n// like me could tinker around with its         |\n// user-friendly tracker.                       |\n//                                              |\n// We're banking on you having a blast with our |\n// creation, hoping it dishes out that feel-good|\n// synthwave goodness. Cheers!                  |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n// Some commented they don't enjoy the flashes\n//  This is fair and it's not very synthwave-y\n//  So I included this option to drop them\n// #define IDONTLIKETHEFLASHING\n\n#define hifbm iChannel0\n#define lofbm iChannel1\n\nconst float \n  tau       = 2.*pi\n, max_dist  = 14.\n, near_dist = 10.\n, tolerance = 1E-3\n, eps1      = 1E-1\n, path_a    = .2\n, path_b    = 3.\n, minh      = .5\n, maxh      = 2.5\n, wl        = .3\n, innerAdj  = .25\n, ch        = .0175\n, ibpm      = 6./9.\n, per       = 32.*ibpm\n, stp       = 66.\n, lp        = .33*tau/stp\n, fof       = log(20.)\n, rnd       = 123.4\n, period    = 92.\n;\n\nconst vec3\n  sunCol0    = vec3(.3  , .1 , 1)\n, sunCol1    = vec3(.1  , .7 , 1)\n, gridCol0   = vec3(.8  , .1 , 1)\n, gridCol1   = vec3(.1  , .5 , 1)\n, roadGlow   = vec3(1   , .3 , .2)*2E-5\n, bikeFlash  = vec3(.5  , .1 , .2)*5E-4\n, skyCol     = gridCol0/3.\n, innerGlow  = sunCol1*8.\n, absorbCol  = -4.*vec3(.5, 2., 1.)\n, sunDir     = normalize(vec3(0., .2, -1.))\n, upDir      = Units.xyx\n;\n\nconst vec4 \n  planet = vec4(1.25,.5,-1,.45)*1E5\n;\n  \nconst int\n  lo_max_iter = 10\n, hi_max_iter = 90\n;\n\nfloat g_time;\nfloat g_beat;\nfloat g_part;\n\nvec2 segment(vec2 p) {\n  float d0 = length(p);\n  return vec2(p.y>0.?d0:abs(p.x), d0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/spherefunctions/spherefunctions.htm\nfloat raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot(oc, rd);\n  float c = dot(oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  return h>0. ? -b - sqrt(h) :  -1.;\n}\n\n// Camera path\nvec3 cam_path(float z) {\n  return vec3(sin(z*path_a)*path_b, 1.-.4*cos(z*lp), -z);\n}\n\n// Derivate of Camera path, used to determine which direction camera points in\nvec3 dcam_path(float z) {\n  return (cam_path(z+eps1) - cam_path(z-eps1))/(2.*eps1);\n}\n\n// Derivate of Derivate of Camera path, used to determine camera tilt\nvec3 ddcam_path(float z) {\n  return (dcam_path(z+eps1) - dcam_path(z-eps1))/(2.*eps1); \n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash1(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n// Diffuse lighting\nfloat dif(vec3 n, vec3 ld) {\n  return max(dot(n, ld),0.);\n}\n\n// Fake fresnel effect (more reflective at \"edges\")\nfloat fre(vec3 rd, vec3 n, float pwr) {\n  return pow(1.+dot(rd,n), pwr);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = .5*size;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\n//  Soft max function, used in the sun for example to round the edges\nfloat pmax(float a, float b, float k) {\n  float h = clamp(.5+.5*(a-b)/k, 0., 1.);\n  return mix(b, a, h) + k*h*(1.-h);\n}\n\n// Height function for mountains\nfloat hf(sampler2D sampler, vec2 p) {\n  vec3 cam = cam_path(p.y);\n  float f = abs(cam.x+p.x);\n  // Global height function\n  float g = mix(minh, maxh*(.5-.5*cos(lp*p.y)), smoothstep(.3, 2.-.5*sin(lp*p.y), f));\n  p *= .125;\n  p += .5;\n  vec2 n = fract(.5*floor(p));\n  p = fract(p);\n  p.x = n.x == 0. ? p.x : 1.-p.x;\n  p.y = n.y == 0. ? p.y : 1.-p.y;\n  // Combine global height function and mountain FBM\n  return mix(wl-1E-2, g*texture(sampler, p).x, g_part > 1. ?smoothstep(.06, .12, f) : 1.);\n}\n\n// Raymarches against height function\nfloat rayMarch(sampler2D sampler, vec3 ro, vec3 rd, int maxi, float initt, float yadj, float sgn, float wlt) {\n  float t = initt;\n  float stp = .9;\n  float lastt;\n\n  int i;\n\n  for (i = 0; i < maxi; ++i) {\n    if (t > max_dist) {\n      break;\n    }\n    vec3 p = ro+rd*t;\n    if (p.y < wl) {\n      return wlt;\n    }\n\n    float h = hf(sampler, p.xz)-yadj;\n    float d = sgn*(p.y - h);\n\n    if (d < tolerance) {\n      // If we have an intercept we just step back a bit and tries again\n      //  To reduce the potentiel overshoots\n      if (stp >= .125) {\n        stp *= .5;\n        t = lastt;\n      } else {\n        break;\n      }\n    }\n    lastt = t;\n\n    t += max(stp*d, tolerance);\n  }\n\n  return t;\n}\n\nvec3 normal(sampler2D sampler, vec2 p) {\n   return normalize(vec3(\n      hf(sampler, p - Units.zx) - hf(sampler, p + Units.zx)\n    , 2.*Units.z\n    , hf(sampler, p - Units.xz) - hf(sampler, p + Units.xz)\n   ));\n}\n\nfloat lorayMarch(vec3 ro, vec3 rd, float initt, float yadj, float sgn, float wlt) {\n  return rayMarch(lofbm, ro, rd, lo_max_iter, initt, yadj, sgn, wlt);\n}\n\nvec3 lonormal(vec2 p) {\n  return normal(lofbm, p);\n}\n\nfloat hirayMarch(vec3 ro, vec3 rd, float initt, float wlt) {\n  return rayMarch(hifbm, ro, rd, hi_max_iter, initt, 0., 1., wlt);\n}\n\nvec3 hinormal(vec2 p) {\n  return normal(hifbm, p);\n}\n\nfloat sun(vec2 p) {\n  p.y += -.2;\n  float d0 = length(p) - .5;\n  float d2 = p.y;\n  mod1(p.y, ch*6.);\n  float d1 = abs(p.y) -  ch;\n  return pmax(d0, -max(d1, d2), ch);\n}\n\n// The sky\nvec3 skyRender(vec3 ro, vec3 rd) {\n  vec2 sp   = rd.xy*2.;\n  float ds = sun(sp);\n\n  vec3 bscol = mix(sunCol0, sunCol1, clamp(1.4*sp.y, 0., 1.));\n  bscol*=sqrt(bscol*2.);\n\n  // The Sun\n  vec3 col = 1E-2/max(abs(ds), 1E-2)*bscol;\n  col += bscol*smoothstep(3E-3, 0.0, ds);\n\n  float gd = rd.y+5E-3;\n\n  float t = 1.;\n  if (g_part > 2.) {\n      // The City\n      col += 1E-3/max(abs(sp.x*(sp.y*sp.y+1.)), 2E-3)*(0.5+2.*g_beat)*sunCol1;\n      for (float i = 0.; i < 4.; ++i) {\n        vec2 cp = sp;\n        cp *= 1.+.1*i;\n        float cn = mod1(cp.x, .015);\n        float ch = hash1(cn+rnd*i)*smoothstep(32., 4., abs(cn));\n        t = min(t, mix((i+1.)*.125, 1., step(.2*ch, cp.y)));\n      }\n    col *= t;\n  }\n\n  float \n    si = raySphere(ro, rd, planet)\n  ;\n  \n  vec3 \n    spos = ro+rd*si\n  , sn = normalize(spos-planet.xyz+Units.xyx*5E3*sin(1E3*spos.y/1E5))\n  , sr = reflect(rd, sn)\n  ;\n\n  if (si > 0.) {\n    // The Planet\n    float \n        sdif = dif(sn, sunDir)\n      , sspe = 4.*pow(dif(sr, sunDir), 80.)*fre(rd, sn, 4.)\n      ;\n    col = sunCol0*sdif+sunCol1*sspe;\n  }\n  \n  float at = g_time-48.;\n  if (at > 0.) {\n    // The Rocket\n    vec2 rp = rd.xy-vec2(-.4-.2*rd.y*rd.y, 5E-3*(at*at-1.));\n    vec2 dr = segment(rp);\n    float rfo = smoothstep(.4, .0, dr.y);\n    col += 1E-3*(sunCol0)/max(abs(dr.x), 2E-4*(2.-rfo))*rfo;\n    col += 3E-3*sunCol1/abs(dr.y)*hash1(floor(g_time*20.));\n  }\n\n  col *= step(0., gd);\n  // The horizon\n  col += 1E-2/max(sqrt(abs(gd))*(75E-2*rd.x*rd.x+75E-4), 5E-4*(1.+30.*rd.x*rd.x))*(1.+.5*g_beat)*skyCol;\n   \n  return col;\n}\n\n// The ground\nvec3 groundRender(vec3 rd, vec3 pp, float pt) {\n  \n  float \n      gfre  = fre(rd, upDir, 1.)\n    , rp    = pp.x\n    ;\n  rp += cam_path(pp.z).x;    \n\n  // The grid\n  vec2 ggp    = pp.xz;\n  float gcf   = .5+.5*(sin(ggp.x)*sin(ggp.y));\n  ggp         *= 3.;\n  ggp         -= round(ggp);\n  ggp         = abs(ggp);  \n  float ggd   = min(ggp.x, ggp.y) ;\n\n  vec3 gcol = mix(gridCol0, gridCol1, gcf);\n  gcol *= sqrt(gcol)*1E-2;\n\n  float fo = exp(-.5*max(pt-2., 0.));\n  float sm = .025*smoothstep(.6, 1., gfre)+1E-3;\n  float bp = abs(rp)-5E-2;\n  float cp = abs(rp)-25E-3;\n  float cs = sign(rp);\n\n  vec3 pcol = gcol/max(ggd, sm);\n  sm *= 1E-4;\n  if (g_part > 1.) {\n    // The road\n    pcol *= step(0., bp);\n    pcol += roadGlow/max((rp*rp), sm)*smoothstep(.25, .5, sin(20.*pp.z));\n    pcol += .25/max(bp*bp, sm)*roadGlow;\n  }\n\n  float off = pp.z+g_time*3.;\n  float noff = mod1(off, 10.);\n  float hoff = hash1(noff);\n  float ht = hash1(floor(g_time*10.));\n  off += 3.*cs*(hoff-.5);\n  \n  vec2 cp2 = vec2(cp,off);\n  if (g_part > 2.) {\n    // The motorbikes\n    pcol += step(0., off)/max(cp*cp, sm)*smoothstep(2., 0., off)*(cs > 0. ? roadGlow.xzy : roadGlow.zyx)*.25;\n    pcol += ht*ht/max(dot(cp2, cp2), sm)*bikeFlash;\n  }\n  pcol *= fo;\n  return pcol;\n}\n\nvec3 sceneRender(vec3 ro, vec3 rd) {\n  vec3 sky = skyRender(ro, rd);\n\n  float pt = -(ro.y-wl)/rd.y;\n  // Intersect the mountains\n  float gt = hirayMarch(ro, rd, 1E-2, pt);\n\n  vec3 col = vec3(0);\n\n  float ft = max(gt-near_dist, 0.)/(max_dist-near_dist);\n  float fm = exp(-ft*fof);\n\n  vec3 gp = ro+rd*gt;\n  vec3 gn = hinormal(gp.xz);\n  vec3 sn = lonormal(gp.xz);\n  float sdif = dif(sn, sunDir);\n  if (pt > 0. && pt <= gt) {\n    // Hit the ground\n    vec3 pp = ro+pt*rd;\n    vec3 pr = reflect(rd, upDir);\n    float pfre = fre(rd, upDir, 2.);\n    // To find the reflection\n    float pgt = hirayMarch(pp, pr, 5E-2, max_dist); \n  \n    if (pgt < max_dist) {\n      pfre *= .125*smoothstep(2., 4., pgt);\n    }\n\n    // The ground\n    col = groundRender(rd, pp, pt);\n    // The reflection\n    col += skyRender(pp, pr)*pfre;\n  } else if (gt < max_dist) {\n    // The mountains\n    vec3 gr = reflect(rd, gn);\n    vec3 grr = refract(rd, gn, 1.-.025);\n    vec3 sr = reflect(rd, sn);\n\n    // Ray march the inner mountains\n    float nlt = lorayMarch(gp, grr, eps1, innerAdj, 1., max_dist);\n    float rpt = -(gp.y-wl)/grr.y;\n\n    // Compute inner grid\n    vec3 rpp = gp+grr*rpt;\n    vec3 groundCol = groundRender(grr, rpp, rpt+gt); \n    vec3 nlp = gp+grr*nlt;\n\n    float gfre = fre(rd, gn, 8.);\n    float sfre = fre(rd, sn, 2.);\n\n    float sspe = pow(dif(sr, sunDir), 40.);\n    float gspe = pow(dif(gr, sunDir), 100.);\n    if (gp.y > mix(.2, .5, .5+.5*sin(gp.z+1.23*gp.x))+.6/max(sqrt(gn.y), .1)) {\n      // The snow\n      col += sfre*sspe;\n      col += sfre*gspe;\n      col += sdif*sqrt(sunCol1);\n      col += -.125*abs(sn.x*sn.y);\n      col += sqrt(skyCol)/sn.y;\n    } else {\n      if (rpt > 0.) {\n        // The inner grid\n        col += .5*exp(rpt*absorbCol)*groundCol;\n      }\n\n      if (nlt < max_dist) {\n        // Raymarch through the inner mountain\n        float flt = lorayMarch(nlp, grr, 5E-2, innerAdj, -1., max_dist);\n        if (flt >= max_dist) {\n          flt = rpt-nlt;\n        }\n        \n        // The inner glow\n        col = mix(col, innerGlow*exp((1.5-.5*g_beat)*nlt*absorbCol), exp(.25*flt)-1.);\n      }\n      col += gfre*.5*skyRender(gp, gr);\n    }\n  } else {\n    // Sky\n    col = sky;\n  }\n\n  // Apply glow\n  col = mix(sky, col, fm);\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  g_time = mod(TIME, period);\n  float lt = g_time + .25*ibpm;\n  float ct = mod(lt, per);\n  float nt = floor(lt/per);\n  g_part   = nt;\n  // Beats that control mountain and city flashes\n  g_beat   = exp(-2.*mod(ct+ibpm, 2.*ibpm))*mod(nt, 2.);\n\n  float pt  = ct+stp*nt;\n  vec3 ro   = cam_path(pt);\n  vec3 dro  = dcam_path(pt);\n  vec3 ddro = ddcam_path(pt);\n  dro.zy *= rot(-.11);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(upDir+2.*ddro, ww));\n  vec3 vv = cross(ww, uu);\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.*ww);\n\n  vec3 col = sceneRender(ro, rd);\n  // Go black if beyond last part\n  col *= g_part < 4. ? 1. : 0.;\n  float sf = 4.*dot(sunDir, rd);\n\n#ifdef IDONTLIKETHEFLASHING\n  col *= 1.0-exp(-4.*ct);\n  float ft = ct - 31.75*ibpm;\n  if (ft > 0.)\n    col *= exp(-16.*ft);\n#else\n  col += sf*exp(-6.*ct)*sunCol1;\n  float ft = ct - 31.75*ibpm;\n  if (ft > 0.)\n    col += sf*exp(-16.*ft)*sunCol1;\n#endif\n  col = tanh(col)-3E-2*(length(p)+.125);\n  // Fade in\n  col *= smoothstep(0., .25*per, g_time-4.+sf);\n  col *= 1.25;\n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.+2.*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "musicstream",
                        "id": 36086,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/sointu-phosphorescent-purple-pixel-peaks"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ----------------------------------------------\n// CC0: Phosphorescent Purple Pixel Peaks\n// ----------------------------------------------\n//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//   release: Phosphorescent Purple Pixel Peaks |\n//      type: Windows 4k intro                  |\n//      date: 17.02.2024                        |\n//     party: Mountainbytes 2024                |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - So, in this release, I set out to   |\n// whip up a terrain marcher in a snug 4KiB     |\n// space. Started with your usual terrain,      |\n// thinking, \"Let's give it a synthwave twist.\" |\n// Now, my previous attempts at a synthwave-    |\n// style terrain marcher were kinda meh, but    |\n// guess what? Lightning struck, and I managed  |\n// to sculpt some visually pleasing mountains.  |\n//                                              |\n// They're not a perfect match for the synthwave|\n// vibe, but hey, check out these transparent,  |\n// glowing ice cream peaks. Cool, right?        |\n//                                              |\n// Big shoutout to Virgill for dropping another |\n// killer tune that totally catches the vibe.   |\n// Sadly, we had to ditch some funky sound      |\n// effects this time aroundâ€”blame it on the     |\n// space crunch. Fingers crossed, next time,    |\n// we'll pack in the funk.                      |\n//                                              |\n// Oh, and a quick nod to sointu by our main    |\n// man Pestis. This nifty tool churns out tunes |\n// that sound fantastic, and even a music novice|\n// like me could tinker around with its         |\n// user-friendly tracker.                       |\n//                                              |\n// We're banking on you having a blast with our |\n// creation, hoping it dishes out that feel-good|\n// synthwave goodness. Cheers!                  |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  // High resolution FBM\n  //  Used for normal computation and raymarching of the detailed mountain\n  vec3 col = fbm(p, 6);\n  \n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ----------------------------------------------\n// CC0: Phosphorescent Purple Pixel Peaks\n// ----------------------------------------------\n//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//   release: Phosphorescent Purple Pixel Peaks |\n//      type: Windows 4k intro                  |\n//      date: 17.02.2024                        |\n//     party: Mountainbytes 2024                |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - So, in this release, I set out to   |\n// whip up a terrain marcher in a snug 4KiB     |\n// space. Started with your usual terrain,      |\n// thinking, \"Let's give it a synthwave twist.\" |\n// Now, my previous attempts at a synthwave-    |\n// style terrain marcher were kinda meh, but    |\n// guess what? Lightning struck, and I managed  |\n// to sculpt some visually pleasing mountains.  |\n//                                              |\n// They're not a perfect match for the synthwave|\n// vibe, but hey, check out these transparent,  |\n// glowing ice cream peaks. Cool, right?        |\n//                                              |\n// Big shoutout to Virgill for dropping another |\n// killer tune that totally catches the vibe.   |\n// Sadly, we had to ditch some funky sound      |\n// effects this time aroundâ€”blame it on the     |\n// space crunch. Fingers crossed, next time,    |\n// we'll pack in the funk.                      |\n//                                              |\n// Oh, and a quick nod to sointu by our main    |\n// man Pestis. This nifty tool churns out tunes |\n// that sound fantastic, and even a music novice|\n// like me could tinker around with its         |\n// user-friendly tracker.                       |\n//                                              |\n// We're banking on you having a blast with our |\n// creation, hoping it dishes out that feel-good|\n// synthwave goodness. Cheers!                  |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nconst float \n  pi        = acos(-1.)\n;\n\nconst vec3 \n  Units     = vec3(0, 1, 1E-2)\n;\n\nmat2 rot(float a) {\n  float c=cos(a),s=sin(a);\n  return mat2(c,s,-s,c);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash2(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/lsf3WH\n//  Value noise function\nfloat vnoise(vec2 p) {\n vec2 i = floor(p);\n vec2 f = fract(p);\n    \n vec2 u = f*f*(3.-2.*f);\n\n float a = hash2(i);\n float b = hash2(i+Units.yx);\n float c = hash2(i+Units.xy);\n float d = hash2(i+Units.yy);\n   \n float m0 = mix(a, b, u.x);\n float m1 = mix(c, d, u.x);\n float m2 = mix(m0, m1, u.y);\n    \n return m2;\n}\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/fbm/\n//  Scales and rotates and aggregates multiple layers of value noise\n//  to create something that looks like mountains\nvec3 fbm(vec2 p, int ii) {\n  vec2 np = p;\n  vec2 cp = p;\n  float nh = 0.0;\n  float na = 1.0;\n  float ns = 0.0;\n  for (int i = 0; i < ii; ++i) {\n    nh += na*vnoise(np);\n    np += 123.4;\n    np *= 2.11*rot(1.);\n    ns += na;\n    na *= 0.5;\n  }\n  \n  nh /= ns;\n\n  return vec3(nh);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// ----------------------------------------------\n// CC0: Phosphorescent Purple Pixel Peaks\n// ----------------------------------------------\n//  `----- - --- ---------?\\___/?\\/zS!?\\___/?\\/-o\n//                mrange & virgill              |\n//  `----- - --- ------ -----\\___/?\\/!?\\___/?\\/-o\n//                                              |\n//   release: Phosphorescent Purple Pixel Peaks |\n//      type: Windows 4k intro                  |\n//      date: 17.02.2024                        |\n//     party: Mountainbytes 2024                |\n//                                              |\n//                                              |\n//  code: mrange                                |\n//  music: Virgill                              |\n//                                              |\n//                                              |\n// mrange - So, in this release, I set out to   |\n// whip up a terrain marcher in a snug 4KiB     |\n// space. Started with your usual terrain,      |\n// thinking, \"Let's give it a synthwave twist.\" |\n// Now, my previous attempts at a synthwave-    |\n// style terrain marcher were kinda meh, but    |\n// guess what? Lightning struck, and I managed  |\n// to sculpt some visually pleasing mountains.  |\n//                                              |\n// They're not a perfect match for the synthwave|\n// vibe, but hey, check out these transparent,  |\n// glowing ice cream peaks. Cool, right?        |\n//                                              |\n// Big shoutout to Virgill for dropping another |\n// killer tune that totally catches the vibe.   |\n// Sadly, we had to ditch some funky sound      |\n// effects this time aroundâ€”blame it on the     |\n// space crunch. Fingers crossed, next time,    |\n// we'll pack in the funk.                      |\n//                                              |\n// Oh, and a quick nod to sointu by our main    |\n// man Pestis. This nifty tool churns out tunes |\n// that sound fantastic, and even a music novice|\n// like me could tinker around with its         |\n// user-friendly tracker.                       |\n//                                              |\n// We're banking on you having a blast with our |\n// creation, hoping it dishes out that feel-good|\n// synthwave goodness. Cheers!                  |\n//                                              |\n//                                         _  .:!\n//  <----- ----- -  -   -     - ----- ----\\/----'\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  // Low resolution FBM\n  //  Used for snow normal computation and inner glowing mountains\n  vec3 col = fbm(p, 4);\n  \n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}