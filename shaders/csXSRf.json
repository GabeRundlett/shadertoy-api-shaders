{
    "Shader": {
        "info": {
            "date": "1669261945",
            "description": "a regular prism sdf in raymarching.",
            "flags": 0,
            "hasliked": 0,
            "id": "csXSRf",
            "likes": 4,
            "name": "Regular Prism SDF - no exact!",
            "published": 3,
            "tags": [
                "ray",
                "raymarch",
                "sdf",
                "triangle",
                "marching",
                "prism",
                "raymaching",
                "hex",
                "march",
                "regular",
                "trigon"
            ],
            "usePreview": 0,
            "username": "SONENEIS",
            "viewed": 206
        },
        "renderpass": [
            {
                "code": "#define pi 3.141592\n#define tau pi * 2.0\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat sdPrism(vec3 p,float f,vec2 s){\n    float a = atan(p.z,p.x);\n    float b = tau / f;\n    float h = cos(floor(0.5 + a/b) * b-a);\n\tvec2 d = abs(vec2(length(p.xz)*h,p.y)) - s;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p){\n    p.zx *= rot(iTime*2.0);\n    return sdPrism(p.yzx,3.0+floor(iTime*2.0/pi),vec2(0.5,0.25));\n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(-1.0,1.0) * 0.0001;\n\treturn normalize(vec3(\n\t  e.yyx * scene(p + e.yyx) +\n\t  e.xyy * scene(p + e.xyy) +\n\t  e.yxy * scene(p + e.yxy) +\n\t  e.xxx * scene(p + e.xxx)\n\t));\n}\n\nfloat calcAO(vec3 p,vec3 n){\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\n\tfor(int i=0;i<5;i++){\n        float hr = 0.01+0.15*float(i)/4.0;\n        vec3 aopos = n*hr + p;\n        float dd = scene(aopos);\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n\t}\n\n\treturn clamp(1.0-occ*1.5,0.0,1.0);\n}\n\nfloat raymarch(vec3 ro,vec3 rd){\n    float d = 0.0;\n    for(int i=0;i<256;i++){\n        vec3 p = ro+rd*d;\n        float h = abs(scene(p));\n        d += h;\n        if(h < 0.001 || d > 20.0) break;\n    }\n    if(d > 20.0) d = -0.0;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = vec3(0.0);\n\n  vec3 ro = vec3(0.0,0.0,3.0);\n  vec3 rd = normalize(vec3(uv,-2.0));\n\n  float d = raymarch(ro,rd);\n  vec3 pos = ro+rd*d;\n\n   if(d > 0.0 && d < 20.0){\n  \tvec3 nor = calcNormal(pos);\n\n    vec3 lig = normalize(vec3(0.5));\n  \tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n  \tfloat occ = calcAO(pos,nor);\n    vec3 hal = normalize(lig-rd);\n  \tfloat spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n  \tfloat amb = clamp(0.5+0.5*nor.y,0.0,1.0);\n  \tfloat sha = raymarch(pos+nor*0.02,lig);\n  \tif(sha > 20.0) sha = -1.0;\n  \tdif *= step(sha,0.0);\n  \tspe *= dif;\n  \tcol += vec3(0.5,1.0,1.2)*amb*occ;\n  \tcol += vec3(2.8,2.2,1.8) * dif;\n  \tcol *= 0.22;\n  \tcol += vec3(2.8,2.2,1.8) * spe*3.0;\n  }\n\n  col = pow(col,vec3(1.0/2.2));\n\n  fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}