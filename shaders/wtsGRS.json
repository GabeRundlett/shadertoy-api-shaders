{
    "Shader": {
        "info": {
            "date": "1556787376",
            "description": "mouse does things.\n\nthis is just\nhttps://www.shadertoy.com/view/Xt23zG\nwith prefix-structure (to unite with I2AD35...]\nless parametric scene,more segmented in subroutines.",
            "flags": 0,
            "hasliked": 0,
            "id": "wtsGRS",
            "likes": 4,
            "name": "kerning neighborhood hyperplane ",
            "published": 3,
            "tags": [
                "kerning",
                "hyperslice"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 633
        },
        "renderpass": [
            {
                "code": "//self        :https://www.shadertoy.com/view/wtsGRS\n//parent      :https://www.shadertoy.com/view/4tjcWR\n//grandparent :https://www.shadertoy.com/view/Xt23zG\n\n//mod 3d seamless overlapping tile proof of concept tomkh 2017-09\n//self:https://www.shadertoy.com/view/4tjcWR\n//parent:https://www.shadertoy.com/view/Xt23zG\n//was for tomkh's educational purposes\n//Extended from tomkh's previous attempt:llSGRy\n//tomkh@2015\n\n//there was not much to optimize\n//biggest change was to not use global array of m2\n//i did not want to touch the camera and all its rotations\n//a lot is overly explicit,not wwong,just harder to edit.\n\n//this one failed at implementing AO\n\n//show distanceField on plane\nvoid hyperSliceY(inout vec3 a,float T,vec3 t,vec3 u,float d,float l,mat3 tr0,mat3 tr1){\n #if HyperSlicesY>0\n ;v0 mm=(iMouse.y/iResolution.y-.1)*8.\n ;mm=max(0.,mm)\n ;if(t.y*sign(u.y-mm)<.0\n ){v0 d=(u.y-mm)/-t.y\n  ;if(d<l\n  ){v2 h=am(t,d,u)\n   ;h.x=gd(T,h,tr0,tr1)\n   ;v2 b=mx(v2(2,4,6),v2(2,2,4),fract(h.x*5.))*.1\n   ;b=di(b,(ad(ma(.0,h.x),.001)))//;b=min(v2(1),b)  //distant color\n   ;a=mx(a,b,.25)\n   ;l=d;}}\n #endif\n ;}\n\n//case for 1 or0 hyperslices\n//this includes a basic spheretracking raymarcher\nv2 fewSlice(v0 t,v2 u,v2 d,m2 tr0,m2 tr1\n){v0 l,n,e=.001,cShad=0.,cSpec=0.  \n ;v2 p=u,cDiff=v2(1)\n ;for(int k=0;k<ray_steps;++k//rayMarch\n ){n=gd(t,p,tr0,tr1)\n  ;if(n<e||n>dist_max)break\n  ;p=ad(mu(n,d),p)\n  ;l=ad(l,n);}  \n ;shade(iResolution,iMouse,cSpec,cShad,cDiff,d,t,u,n,e,p,tr0,tr1) \n ;v2 a=mx(v2(0,.1,.3),v2(1,1,.9),cShad)*cDiff+v2(1)*cSpec\n ;hyperSliceY(a,t,d,u,n,l,tr0,tr1)\n ;return mx(v2(.8),a,re(ex(ma(.0,l-fog_start)*fog_density)))//fog\n ;}\n\nv2 manySlice(v0 t,v2 u,v2 d//time,rayDirection,Rayorigin\n,m2 tr0,m2 tr1//2 animated rotation matrices\n){v2 a=v2(0,.1,.3)\n ;for(v0 i=4.;i>=.0;i-=.1//i used to be called \"cutPlane\"\n){if(d.y*sg(u.y-i)<.0\n ){v0 n=di(su(i,u.y),d.y)\n ,h=gd(t,am(d,n,u),tr0,tr1)\n   ;v2 b=mu(.1,mx(v2(2,4,6),v2(2,2,4),fr(mu(h,5.))));//distant color\n   ;b=di(b,(ad(ma(.0,h),.05)))\n   ;a=ad(mu(mu(b,.02),mu(i,.25)),a);}}\n   ;return a;}\n\nv2 trace(v0 t,v2 u,v2 d,m2 tr0,m2 tr1  \n #if HyperSlicesY<2\n){return  fewSlice(t,u,d,tr0,tr1);}//raymarch, may contain a single hyperslice.\n #else\n){return manySlice(t,u,d,tr0,tr1);}//trace coplanar hyperslices, no shading.\n #endif\n\nvoid mainImage(out vec4 o,v1 u\n){u=(u.xy-iResolution.xy*.5)/iResolution.x\n ;v0 t=iTime*.25\n ,a=-.2\n #ifdef doMouseLook\n ;a=u2(di(iMouse.x,iResolution.x))\n #endif\n ;a=ad(mu(co(t),.05),a)\n ;v0 c=co(a),s=si(a)\n ;v2 p=cam_dist*v2(s,0,c)\n ,d=no(v2(u,1))\n ;d=v2(d.x*c+d.z*s,d.y,-d.x*s+d.z*c)\n ;a=cam_tilt\n ;c=cos(a)\n ;s=sin(a)\n ;p=v2(p.x,p.y*c+p.z*s,-p.y*s+p.z*c)//smells like 2d rotation\n ;d=v2(d.x,d.y*c+d.z*s,-d.y*s+d.z*c)//smells like 2d rotation\n ;m2 tr0=m2(1),tr1=m2(1)\n #if defined(OVERLAP)\n ;tr0=aatm(t ,no(v2(.5,.2,.3)));\n ;tr1=aatm(t+2.,no(v2(.3,.7,-.2)));\n #endif\n \n ;//o=vec4(trace(t,ne(p),d,tr0,tr1),1)\n ;p=ne(p)\n ;//o=vec4(manySlice(t,p,d,tr0,tr1),1)\n ;//o=vec4( fewSlice(t,p,d,tr0,tr1),1)\n ;o=vec4(mix(manySlice(t,p,d,tr0,tr1)//screenspace smoothstep()\n             ,fewSlice(t,p,d,tr0,tr1)\n             ,smoothstep(0.,1.,u.x*4.+.5)),1)\n  ;}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define VIEW_DIST 3\n//0=short distance\n//1=middle\n//2=far\n\n//VIEW_DIST also modifies distanceFog, which in this demo just hoides Moire.\n\n//HyperSlicesY 2   is easily faster than\n//HyperSlicesY 0   mostly because it skips a lot of shading/AO\n\n//distance between multiple hyperslices\n#define HyperSlicesYdelta .1\n//depth of area that has hyperslices\n#define HyperSlicesY 1\n// 0=no hyperSlices\n// 1= a SPECIAL rasterized single debugPlane hyperSlice\n//>1=[floor(DebugPlane/HyperSlicesYdelta)] hyperSlices (transparent grass)\n//anything >2 just taps into the void,wasting calculation\n//this is due to the rather flat distance field\n//it speeds up the marching to have the camera high above a nearly flat hyperplane.\n//nstead just modify HyperSlicesYdelta\n\n//Enable experimental AO(bad, AO still works)\n#define TEST_AO\n\n//Tile space (tilesize (without kerning)) for kerning\n#define tSpace 2.\n\n//Enable to test overlap(must be less than 0.4):\n#define OVERLAP 0.42\n\n//floorHeight\n#define floor_plane-5.\n\n//rotations in this are overly explicit,therefore camera sucks\n#define doMouseLook\n\n//prefix notation\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define m2 mat3\n\n#if VIEW_DIST==0\n const int ray_steps=80;\n const v0 dist_max=20.0;\n const v0 fog_start=25.0;\n const v0 fog_density=.02;\n const v0 cam_dist=20.0;\n const v0 cam_tilt=-.2;\n#elif VIEW_DIST==1\n const int ray_steps=160;\n const v0 dist_max=20.0;\n const v0 fog_start=25.0;\n const v0 fog_density=.01;\n const v0 cam_dist=30.0;\n const v0 cam_tilt=-.4;\n#else\n const int ray_steps=256;\n const v0 dist_max=400.0;\n const v0 fog_start=100.0;\n const v0 fog_density=.002;\n const v0 cam_dist=80.0;\n const v0 cam_tilt=-.4;\n#endif\n\n\n\n#define u2(a) (su(mu(a,2.),1.))\n\n\n#define dd(a) dt(a,a)\n\n\nv3 ne(v3 a){return -a;}\nv2 ne(v2 a){return -a;}\nv1 ne(v1 a){return -a;}\nv0 ne(v0 a){return -a;}\nv2 ma(v2 a,v2 b){return max(a,b);}\nv1 ma(v1 a,v1 b){return max(a,b);}\nv1 ma(v0 a,v1 b){return max(v1(a),b);}\nv1 ma(v1 a,v0 b){return max(a,v1(b));}\nv0 ma(v0 a,v0 b){return max(a,b);}\nv2 ma(v0 a,v2 b){return max(v2(a),b);}\nv2 ma(v2 a,v0 b){return max(a,v2(b));}\n#define mi(a,b) ne(ma(ne(a),ne(b)))\nv0 ma2(v1 a){return ma(a.x,a.y);}\nv0 ma2(v2 a){return ma(a.x,ma2(a.yz));}\nv0 ma3(v3 a){return ma(ma2(a.xy),ma2(a.zw));}\n#define mi2(a) ne(ma2(ne(a)))\nv2 ab(v2 a){return abs(a);}\nv1 ab(v1 a){return abs(a);}\nv0 ab(v0 a){return abs(a);}\nv0 sg(v0 a){return sign(a);}\n//ab(0)dT=NaN ,has step()==partialDerivative\nv0 sr(v0 a){return sqrt(ab(a));}\n#define srdd(a) sr(dd(a))\n#define le(a)   sr(dd(a))\n//sqrt() is differentiable at 0, but ab(0)dT=NaN  \n\nv2 su(v2 a,v2 b){return a-b;}\nv2 su(v0 a,v2 b){return a-b;}\nv2 su(v2 a,v0 b){return a-b;}\nv1 su(v1 a,v0 b){return a-b;}\nv0 su(v0 a,v0 b){return a-b;}\nv1 su(v0 a,v1 b){return a-b;}\nv1 su(v1 a,v1 b){return a-b;}\n//v2 su(v2 a,v2 b){return a-b;}\n#define ad(a,b) su(a,ne(b))\n\nv0 mu(v0 a,v0 b){return a*b;}\nv1 mu(v1 a,v0 b){return a*b;}\nv1 mu(v0 a,v1 b){return a*b;}\nv1 mu(v1 a,v1 b){return a*b;}\nv2 mu(v0 a,v2 b){return a*b;}\nv2 mu(v2 a,v0 b){return a*b;}\nv2 mu(v2 a,v2 b){return a*b;}\nv2 mu(v2 a,m2 b){return a*b;}\nv2 mu(m2 a,v2 b){return a*b;}\n//v0 mu(v0 a,v0 b,v0 c){return a*b*c;}\n//v0 mu(v0 a,v0 b,v0 c,v0 d){return a*b*c*d;}\n\n#define am(a,b,c) ad(mu(a,b),c)\n\nv2 di(v0 a,v2 b){return a/b;}\nv1 di(v0 a,v1 b){return a/b;}\nv0 di(v0 a,v0 b){return a/b;}\nv1 di(v1 a,v1 b){return a/b;}\nv1 di(v1 a,v0 b){return a/b;}\nv2 di(v2 a,v0 b){return a/b;}\n\nv0 po(v0 a,v0 b){return pow(a,b);}\n\n#define re(a) di(1.,a)\n\nv0 cl(v0 a,v0 b,v0 c){return clamp(a,b,c);}\nv2 cl(v2 a,v0 b,v0 c){return clamp(a,b,c);}\nv2 sa(v2 a){return cl(a,0.,1.);}\nv0 sa(v0 a){return cl(a,0.,1.);}\n\nv0 ex(v0 a){return exp(a);}\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nv1 cs(v0 a){return v1(co(a),si(a));}\n\nv2 fl(v2 a){return floor(a);}\nv1 fl(v1 a){return floor(a);}\nv0 fl(v0 a){return floor(a);}\nv0 fr(v0 a){return fract(a);}\nv1 fr(v1 a){return fract(a);}\nv2 fr(v2 a){return fract(a);}\nv1 mo(v1 a,v1 b){return mod(a,b);}\nv0 mo(v0 a,v0 b){return mod(a,b);}\n\nv2 no(v2 a){return normalize(a);}\n\n\nv2 mx(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv2 mx(v2 a,v2 b,v2 c){return mix(a,b,c);}\n\nv0 dt(v0 a,v0 b){return a*b;}\nv0 dt(v1 a,v1 b){return a.x*b.x+a.y*b.y;}\nv0 dt(v2 a,v2 b){return a.x*b.x+a.y*b.y+a.z*b.z;}\nv0 dt(v3 a,v3 b){return a.x*b.x+a.y*b.y+a.z*b.z+a.w*b.w;}\n\n\n//dBox2()=rounded box\nv0 dBox2(v2 p,v2 b){return le(ma(su(ab(p),b),0.));}\n\nv0 dPipe(v2 p,v0 r,v0 h\n){return le(v1(su(le(p.xz),r),ma(su(ab(p.y),h),0.)));}\n\nv0 dCyl(v2 p,v0 r,v0 h\n){return le(ma(su(v1(le(p.xz),ab(p.y )),v1(r,h)),.0));}\n \nv2 cs2(v0 a){return v2(co(a),0,si(a));}\n\n\n//misc semi dumb stuff\n\nm2 aatm(v0 a,v2 r\n){v0 c=cos(a)\n ;v2 t=(1.-c)*r,u=sin(a)*r;return m2\n (t.x*r.x+c,t.x*r.y+u.z,t.x*r.z-u.y\n ,t.x*r.y-u.z,t.y*r.y+c,t.y*r.z+u.x\n ,t.x*r.z+u.y,t.y*r.z-u.x,t.z*r.z+c);}\n\n\n/**/  //start kerning\n/*\n\nP-----+-----Q\n|  |  |\n|  A--|--B  |\n|  |p |  |  |\n+-----+-----+\n|  |  |  |  |\n|  C--|--D  |\n|  |  |\nR-----+-----S\nSay we want to find DF(p)-a distance field for \"p\",\nand \"p\" is inside ABCD boundary,where A,B,C,D are our tile centers.\nWe have to assume max/min height.\nWe call \"frame\",a bounding area of everything outside PQRS(estimated using max/min height).\nAlgorithm:\nFor \"p\" we evaluate DF for 4 tiles:A,B,C,D\n(possibly with early-out optimization with rough distance estimation)\nand we bound it additionally to distance to PQRS frame.\n\n---comment by ollj:\nabove is neat, has its uses\n,is likely smarter if you want to mix 2 adjacent tiles\n,but i know a better way;\na 2d quater tile is(within)4 larger offset tiles,all seamless.\njust 4x sample 4 exclusive tesselations with offset.\n,whos corners are on the lines or centers of other tesselations.\ngives a cleaner gradient.\n/**/\n\n//march4tap2dkerningIn3d\n//a,b are precalculated rotation martices\n//because kerning must be tested with an animated distance field.\nv0 dist2frame(v2 p,v0 q//dynamic kerning bound\n){p=v2(su(mu(tSpace,su(1.,OVERLAP)),ab(p.xz))\n        ,ma(su(ab(p.y),q),0.));\n ;return le(v1(mi(p.x,p.y),p.z));}\n//evaluate tile contnent (is 4tapped with kerning)\nv0 gt(v0 t,v2 p,v2 q,v1 d//time,localUVcontext, TileIDcontext,tileOffset\n      ,m2 tr0,m2 tr1// 2 precalculated rotation matrices\n){q.xz=ad(q.xz,d)\n ;p.xz=su(p.xz,mu(su(d,.5),tSpace))\n ;t=mu(t,.25)\n ;v0 a=1e32\n ,s=mu(si(ad(q.x,t)),\n       si(am(t,.33,q.z)))\n ,r=mu(ad(.5,OVERLAP),tSpace)\n ;v1 qq=v1(.17,.71)\n ;m2 m=(mo(dt(q.xy,qq),2.)<1.)?tr0:tr1;  \n ;a=su(dPipe(mu(v2(p.x,su(p.y,mu(s,3.)),p.z),m),su(r,.25),.0),.25)\n //;v0 farts=ad(q.x,q.z)\n ;s=su(4.,mu(ab(s),3.9))\n ;v2 u=ad(p,mu(cs2(am(ad(q.x,q.z),3.,mu(t,1.11))),.5))\n ;a=mi(a,su(dBox2(u,v2(.25,s,.25)),.025))\n //;if(a>.3)return a-.1;//simple early-out optimziation\n ;v2 g=v2(.25,0,.25)\n ;g=v2(dBox2(su(u,v2(0,mu(s,.3),0)),g)       \n      ,dBox2(su(u,v2(0,mu(s,.6),0)),g),ad(a,.1))\n ;a=su(mi2(g),.1)\n ;return a;}\n\n//kerning2dMonospaced\nv0 gd(v0 t,v2 p,m2 a,m2 b//time,uv,2 animated rotationmatrices\n){v1 l=di(p.xz,tSpace)\n ;v2 c=v2(fl(l),.0).xzy//tile address\n ;p=v2(mu((fr(l)-.5),tSpace),p.y).xzy//logal coord\n ;v2 r=v2(dist2frame(p,4.25)\n         ,mi(gt(t,p,c,v1(0),a,b),gt(t,p,c,v1(1,0),a,b))\n         ,mi(gt(t,p,c,v1(1),a,b),gt(t,p,c,v1(0,1),a,b)))\n ;r.x=mi2(r)\n ;r.x=mi(r.x,ab(su(p.y,floor_plane)))\n ;return r.x;}\n//normal 6tapped (with 4tapped 2d kerning)\nv2 get_normal(v0 t,v2 p,m2 a,m2 b//time,uv,2 animated matrices\n){v1 e=v1(1e-3,0)\n ;return no(v2(su(gd(t,ad(p,e.xyy),a,b),gd(t,su(p,e.xyy),a,b))               \n              ,su(gd(t,ad(p,e.yxy),a,b),gd(t,su(p,e.yxy),a,b))\n              ,su(gd(t,ad(p,e.yyx),a,b),gd(t,su(p,e.yyx),a,b))));}\n\n/**/ //end__ kerning\n\n\n\n//TODO:implement better AO\nv0 get_ao(v0 t,v2 u,v2 n,m2 tr0,m2 tr1\n #ifndef TEST_AO\n){return 1.;}\n #else\n){u=am(n,.1,u)\n ;v0 d=gd(t,u,tr0,tr1),l=.0\n ;d=mu(d,d);l=ad(l,d)\n ;for(int i=0;i<3;i++//AO loop\n ){u=ad(u,mu(n,d));d=gd(t,u,tr0,tr1);d=mu(d,d);l=ad(l,d);}\n ;return am(sa(l),8.,.5);}\n #endif\n//shading (1 parallelMonochromeSunlight, diffuse, specular, AOshitty)\nvoid shade(vec3 r,vec4 m,inout v0 cSpec,inout v0 cShad,inout v2 cDiff\n,v2 t,v0 T,v2 u,v0 d,v0 e,v2 p\n,m2 tr0,m2 tr1){\n ;if(d<e\n ){v2 n=get_normal(T,p,tr0,tr1)\n  ;if(p.y<ad(floor_plane,mu(e,2.))\n  ){v0 d=di(su(floor_plane,u.y),t.y)\n   ;v1 hit=fl(di(am(t,d,u),tSpace)).xz\n   ;v0 p=mo(ad(hit.x,hit.y),2.)//pattern\n   ;cDiff=mu(mx(v2(2,4,6),v2(4,6,8),p),.1);}//diffuse\n  ;v0 m=(m.x/r.x-.5)+1.\n  ;v2 s=normalize(v2(cos(m),2.,-sin(m)))//v2 s=normalize(v2(.1,1.,-.3));\n  ;cShad=mu(ma(0.,dt(n,s)),get_ao(T,p,n,tr0,tr1))//bad AO only (no shadows)\n  ;cSpec=ma(0.0,dt(n,su(m,mu(mu(dt(n,s),n),2.))))//specular\n  ;cSpec=mu(po(cSpec,32.),.25);}}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}