{
    "Shader": {
        "info": {
            "date": "1679445497",
            "description": "Tokyo DemoFest18",
            "flags": 0,
            "hasliked": 0,
            "id": "dd3SRN",
            "likes": 14,
            "name": "Autumn by Pentan",
            "published": 3,
            "tags": [
                "glsldemo"
            ],
            "usePreview": 0,
            "username": "ford442",
            "viewed": 205
        },
        "renderpass": [
            {
                "code": "vec3 rotX(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x,\n        p.y * sc.y + p.z * sc.x,\n        p.y * -sc.x + p.z * sc.y\n    );\n}\n\nvec3 rotY(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x * sc.y + p.z * sc.x,\n        p.y,\n        p.x * sc.x - p.z * sc.y\n    );\n}\n\nvec3 rotZ(vec3 p, float a) {\n    vec2 sc = sin(vec2(a, a + 1.57079632));\n    return vec3(\n        p.x * sc.y + p.y * sc.x,\n        p.x * -sc.x + p.y * sc.y,\n        p.z\n    );\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 noise(vec2 p) {\n    const vec2 k = vec2(0.0, 1.0);\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 h00 = hash22(i + k.xx);\n    vec2 h01 = hash22(i + k.xy);\n    vec2 h10 = hash22(i + k.yx);\n    vec2 h11 = hash22(i + k.yy);\n    // f = f * f * (3.0 - 2.0 * f);\n    f = f * f * f * (f * (6.0 * f - 15.0) + 10.0);\n    return mix(mix(h00, h10, f.x), mix(h01, h11, f.x), f.y);\n}\n\nvec2 fbm(vec2 p) {\n    mat2 m = mat2(-0.73736887, 0.67549029, 0.67549029, 0.73736887);\n    vec2 f = vec2(0.0);\n    float s = 0.5;\n    for(int i = 0; i < 4; i++) {\n        f += noise(p) * s;\n        s *= 0.5;\n        p = (p + vec2(0.03, 0.07)) * 2.01 * m;\n    }\n    return f;\n}\n\n//\nfloat sdEllipsoid(vec2 p, vec2 r) {\n    float k0 = length(p / r);\n    float k1 = length(p / (r * r));\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdCapsule(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 d = b - a;\n    float l = length(d);\n    d = normalize(d);\n    vec2 v = p - a;\n    float h = min(l, max(0.0, dot(v, d)));\n    return length(v - d * h) - r;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nvec2 leaf(vec2 p) {\n    float d;\n    p.x = abs(p.x);\n    float d0 = max(sdEllipsoid(p, vec2(0.85, 1.0)), -p.y);\n    float d1 = sdCapsule(p, vec2(0.0, 0.7), vec2(0.0, 1.0), 0.02);\n    float d2 = sdEllipsoid(p - vec2(0.8, 0.0), vec2(0.78, 0.3));\n    float d4 = sdCapsule(p, vec2(0.0, 0.1), vec2(0.0, -0.8), 0.02);\n\n    d = -smin(-d0, d1, 0.15);\n    d = -smin(-d, d2, 0.1);\n    d = smin(d, d4, 0.05);\n\n    float r = length(p);\n    float th = asin(p.y / r);\n    float h = (p.y < 0.0)? 1.0 : abs(sin(th * 60.0));\n    h = max(h, 1.0 - pow(length(p) * 2.0, 3.0));\n\n    return vec2(d, h);\n}\n\nvec3 h2c(float h) {\n    const vec3 c0 = vec3(0.18, 0.96, 0.93);\n    const vec3 c1 = vec3(0.14, 0.96, 0.98);\n    vec3 c = mix(c0, c1, h);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat roadh(vec2 p, inout vec4 m) {\n    const float xs = 2.0;\n    p *= vec2(1.0/xs, 1.0);\n    vec2 ip = floor(p);\n    vec2 ap = p + vec2(ip.y * 0.5, 0.0);\n    vec2 fp = fract(ap);\n    float d;\n\n    fp = min(fp, 1.0 - fp) * 2.0;\n    d = min(1.0, min(fp.x * xs, fp.y) * 8.0);\n\n    vec2 n = fbm(p * 8.0);\n    float d0 = n.x;\n    float d1 = 1.0 - min(1.0, n.y * 3.5);\n\n    d -= d0 * 0.2;\n    d -= d1 * 0.4;\n\n    if(m.x > 0.0) {\n        vec2 iap = floor(ap);\n        m.xy = hash22(iap);\n        m.yz = iap;\n    }\n    return d;\n}\n\nvec3 road(vec2 p) {\n    const vec2 eps = vec2(1e-2, 0.0);\n    vec4 m;\n\n    // normal\n    m = vec4(0.0);\n    vec3 n;\n    n.x = roadh(p - eps.xy, m) - roadh(p + eps.xy, m);\n    n.y = roadh(p - eps.yx, m) - roadh(p + eps.yx, m);\n    n.z = eps.x * 3.0;\n    n = normalize(n);\n\n    // main\n    m = vec4(1.0);\n    float d = roadh(p, m);\n\n    float ao = 1.0 - pow(max(0.0, 1.0 - d), 8.0);\n    ao = mix(0.6, 1.0, max(0.0, ao));\n\n    vec3 l = normalize(vec3(0.5, 0.7, 2.0));\n    float dfs = dot(l, n);\n    dfs = mix(0.8, 1.0, pow(clamp(dfs * 3.0, 0.0, 1.0), 4.0));\n\n    vec3 col;\n\n    const vec3 c0 = vec3(0.74, 0.72, 0.49);\n    const vec3 c1 = vec3(0.66, 0.64, 0.42);\n    col = mix(c0, c1, m.x);\n\n    vec2 f = fbm(p * 2.0);\n    //col = f.xxx;\n    const vec3 c2 = vec3(0.73, 0.68, 0.44);\n    col = mix(col, c2, f.x);\n\n    // lit\n    col *= dfs * ao;\n\n    return col;\n}\n\nvec3 spreadleaf(vec2 p, float R) {\n    const int N = 2;\n    vec2 ip = floor(p);\n    float h = -1.0;\n    vec3 col = road(p);\n    vec2 f = fbm(p * 4.0);\n\n    for(int j = -N; j <= N; j++) {\n        float y = float(j);\n        for(int i = -N; i <= N; i++) {\n            float x = float(i);\n            vec2 cp = ip + vec2(x, y);\n            vec2 ch = hash22(cp);\n            cp += (ch * 2.0 - 1.0) * R;\n\n            vec2 lp = cp - p + (f * 2.0 - 1.0) * 0.05;\n            ch = hash22(ch * 123.4567);\n            float angl = ch.x * 6.28318530;\n            lp = rotZ(vec3(lp, 0.0), angl).xy;\n\n            vec2 lfd = leaf(lp * 1.2);\n            col = mix(col, col * vec3(0.4), smoothstep(0.04, -0.02, lfd.x)); // shadow\n            vec3 tint = mix(vec3(0.75, 0.7, 0.6), vec3(1.0), lfd.y);\n            col = mix(col, h2c(ch.y) * tint, smoothstep(0.0, -0.01, lfd.x)); // leaf\n        }\n    }\n\n    return col;\n}\n\nvec3 render(vec2 sp) {\n    vec3 op = vec3(0.0, 0.0, 4.0);\n    vec3 dv = normalize(vec3(sp, -2.0));\n\n    vec3 angle = vec3(\n        0.8 + sin(iTime * 1.2) * 0.02,\n        sin(iTime * 1.5) * 0.05,\n        0.0\n    );\n    op = rotZ(rotY(rotX(op, angle.x), angle.y), angle.z);\n    dv = rotZ(rotY(rotX(dv, angle.x), angle.y), angle.z);\n    op += vec3(0.0, 1.0 + abs(sin(iTime * 6.0)) * 0.06, 0.0);\n\n    vec3 gp = dv * op.y / dv.y;\n    vec3 col;\n    col = spreadleaf(gp.xz * 2.0 + vec2(0.0, -iTime), 0.5);\n\n    vec3 vgn = exp(-pow(length(sp), 2.0) * vec3(0.5, 0.6, 1.0) * 0.2);\n    // col *= vgn;\n    col -= 1.0 - vgn;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 c = render(p);\n    c = pow(clamp(c, 0.0, 1.0), vec3(1.0/1.8));\n    fragColor = vec4(c, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}