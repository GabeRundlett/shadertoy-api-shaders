{
    "Shader": {
        "info": {
            "date": "1719605976",
            "description": "Sources (more in code)\nhttps://shadertoyunofficial.wordpress.com/2019/01/02/programming-tricks-in-shadertoy-glsl/\n\nSooo cool how this video distorted the camera (see raymarchOp function)\nhttps://www.youtube.com/watch?v=khblXafu7iA",
            "flags": 32,
            "hasliked": 0,
            "id": "43dSD2",
            "likes": 1,
            "name": "Learning Agains 3",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "prishainabox",
            "viewed": 39
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;        \n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define AA       1\n#define MAX_DIST 100.0\n#define CAM_DIST 2.0\n#define PI       3.14159\n#define FOV      0.9\n#define CS(a)    vec2( cos(a), sin(a) )\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n\n/***************************************************************************/\n\n// https://www.shadertoy.com/view/4djSRW\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash33(p) fract(sin( (p) * mat3( 127.1,311.7,74.7 , 269.5,183.3,246.1, 113.5,271.9,124.6) ) *43758.5453123)\n\n/***************************************************************************/\n\n// https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n    k *= 4.0;\n    // 0 to 1, spikes when a and b are near\n    float h = max( k-abs(a-b), 0.0); \n    return min(a,b) - h*h/(4.0*k);\n}\n\n// \nfloat smax(float a, float b, float k) {\n    k *= 4.0;\n    float h = max( k-abs(a-b), 0.0);\n    return max(a,b) + h*h/(4.0*k);\n\n}\n\n/***************************************************************************/\n\nfloat sdSphere(in vec3 pt, in float r) {\n    return length(pt) - r;\n}\n\n// https://www.youtube.com/watch?v=8--5LwHRhjk\nfloat sdEllipsoid(in vec3 pt, in vec3 r) {\n    float a = length(pt / r);\n    return (a*a - a) / length(pt / r*r);\n}\n\n// https://www.youtube.com/watch?v=62-pRVZuS5c\nfloat sdBox(in vec3 pt, in vec3 r) {\n    return length(max(abs(pt) - r, vec3(0.0)));\n}\n\n/***************************************************************************/\n\nfloat sdfOp(in vec3 pt) {\n\n    float d = MAX_DIST;\n    float time = iTime;\n    \n    // rotating cube and sphere\n    {\n        float sf = 1.2; //scaling factor\n        vec3 p = pt- vec3(0,0.7,0);\n        p.yz *= rot(PI/4.0 + iTime);    \n        p.xz *= rot(PI/2.0 + iTime);\n\n\n        d =  min( d, sdBox(p*sf, vec3(0.5)) / sf );\n        d = smin( d, sdSphere(pt - 1.6 * vec3(sin(time * 0.7), 0.5, 0.0), 0.5), 0.2);\n    }\n    \n    // repeating cubes\n    {\n        vec3 q = pt - vec3(2, -0.3, 2);\n        vec3 m = vec3(1);\n        q = mod(q, m) - m*0.5;\n        d = smin(d, sdBox(q, vec3(0.1)) - 0.01, 0.1);\n    }\n    \n    // floor\n    {\n        float fl = pt.y + 0.1;// - 0.1*cos(5.0 * atan(pt.z, pt.x));\n        d = smin(d, fl, 0.1);\n    }\n\n    return d;\n\n}\n\n/***************************************************************************/\n\nvec3 calcNormalOp(in vec3 pt) {\n    vec2 h = vec2(0.001, 0);\n    return normalize(vec3(\n        sdfOp(pt + h.xyy) - sdfOp(pt - h.xyy),\n        sdfOp(pt + h.yxy) - sdfOp(pt - h.yxy),\n        sdfOp(pt + h.yyx) - sdfOp(pt - h.yyx)   \n    ));\n}\n\n/***************************************************************************/\n\nfloat raymarchOp(vec3 ro, vec3 rd, float tmin, float tmax, inout int steps) {\n\n    float td = tmin;\n    \n    int i;\n    for (i = 0; i < 80; i++) {\n    \n        vec3 p = ro + rd*td;\n        \n        // weird transform 1 from https://www.youtube.com/watch?v=khblXafu7iA\n        p.xy *= rot(td * 0.15);\n    \n        float d = sdfOp(p);\n        \n        // weird transform 2\n        rd.y += (d) * 0.02;\n        \n        td += d;\n        \n        if (abs(d) < 0.001 || td > tmax) break;\n    \n    }\n    \n    steps = i;\n    return td;\n\n}\n\n/***************************************************************************/\n\nvec3 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n\n    vec3 clr = vec3(1);\n    \n    int steps = 0;\n    float d = raymarchOp(ro, rd, 0.01, MAX_DIST, steps);\n    \n    \n    // vec3 nor = calcNormalOp(ro + rd*d);\n    // clr = nor * 0.5 + 0.5;\n    // clr = vec3(1.0 - d * 0.05 * d);\n    // clr = vec3(smoothstep(25.0, 0.0, d*d));\n    // clr = vec3(d * 0.12);\n    \n    \n    clr = vec3(smoothstep(0.0, MAX_DIST * 0.2, d)) + 0.001*float(steps);\n\n    \n  //if(d > 0.0 && d < MAX_DIST) {\n        // vec3 nor = calcNormalOp(ro + rd*d);\n        //clr += 0.5 * (nor * 0.5 + 0.5);\n  //}\n    \n    \n    clr = pow(clr, vec3(0.4545));\n\n    return clr;\n\n}\n\n/***************************************************************************/\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + FOV * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // if (iFrame != 0) discard;\n\n    float time = iTime;\n    vec2 res = iResolution.xy;\n    vec2 mouse = (iMouse.xy * 2.0 - res.xy) / res.y;\n    \n    // target\n    vec3 target = vec3(0, 0, 0);\n    vec3 ro;\n    \n    // ray origin \n    // float movX = -20.0 * mouse.x/res.x + 10.0;\n    // float movY = -20.0 * mouse.y/res.y + 10.0;\n    // float r = 4.5;\n    // vec3 ro = target + vec3(sin(movX) * r,  movY, cos(movX) * r);\n    // vec3 ro = target + vec3(0, 0, 3);\n    \n    // ray origin - spherical coordinates\n    { \n        float rho   = CAM_DIST; // distance\n        float phi   = max(PI*0.1, (mouse.y * 0.5 + 0.5) * 0.5 * PI);\n        float theta = mouse.x * 2.0 * PI;\n        float rad   = rho * sin(phi);\n        ro = target + vec3( rad * cos(theta), rho * cos(phi), rad * sin(theta) );\n    }\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    #if AA > 1\n    \n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n\n\n        // Normalized pixel coordinates\n        vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n        # else\n        vec2 f = fragCoord;\n        \n    #endif\n    \n        vec2 uv = (2.0 * f - res) / res.y;\n        vec3 rd = setCamera(uv, ro, target);\n\n        // calculate color\n        vec3 c = render(uv, ro, rd);\n\n        clr += c;\n\n    #if AA > 1    \n    \n    }}    \n    \n    clr /= float(AA*AA);\n    \n    #endif\n\n    // Output to screen\n    fragColor = vec4(clr, 1);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}