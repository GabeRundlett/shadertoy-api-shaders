{
    "Shader": {
        "info": {
            "date": "1669906430",
            "description": "An ellipse and a curve derived from the lagrange multiplier with respect to the distance to the mouse point.\nBackground is the visualization of the basins of attraction for an iteration which computes the intersection of both curves.",
            "flags": 0,
            "hasliked": 0,
            "id": "DsjXRh",
            "likes": 5,
            "name": "Ellipse lagrange multiplier",
            "published": 3,
            "tags": [
                "2d",
                "distancefield",
                "distance",
                "curve",
                "implicit",
                "ellipse",
                "lagrange"
            ],
            "usePreview": 0,
            "username": "NinjaKoala",
            "viewed": 227
        },
        "renderpass": [
            {
                "code": "/*\nThe lagrange multiplier is used to optimize some function f(x,y), where all points\nhave to evaluate to zero for another function g(x,y).\n(See https://en.wikipedia.org/wiki/Lagrange_multiplier)\n\nIt can be used to compute the distance of a point p to an implicit curve g(x,y)\nby setting f(x,y) = distance((x,y), p). (Squared distance is a better idea, though ;))\n\nYou get a system of three equations in three variables x,y,位:\n\nx-p.x + 位*diff(g,x) = 0\ny-p.y + 位*diff(g,y) = 0\ng(x,y) = 0\n\nYou can compute the resultant of the first two equations with respect\nto 位 to get another implicit curve g1(x,y) (this is the green one).\n(See https://en.wikipedia.org/wiki/Resultant)\n\nThe intersection of both curves are the points on the ellipse\nwith local minimal distance to p.\n\nYou could compute another resultant to get those intersection points,\nbut here i'm using a simple iterative approach.\n(Gradient descent to both curves alternatingly)\n\nThe blue curve is the ellipse, the green curve the curve derived\nfrom the lagrange multiplier.\n\nIn the background you can see for each pixel where the iteration\nconverges there. (Basins of attraction)\n(This is based on https://www.shadertoy.com/view/3sScWR)\n\n\n\nBy uncommenting the define, you can get the distance to the ellipse\ncomputed this way.\n\nYou could probably get the exact distance by cleverly choosing the starting\npoint of the iteration (or several starting points),\nif you just use the current pixel coordinate (like i do),\nthe distance field is broken in the middle of the ellipse\n\n*/\n//#define SHOW_DISTANCE_FIELD\n\nvec3 bg_col = vec3(1);\nvec3 ellipse_col = vec3(0,0,1);\nvec3 lag_curve_col = vec3(0,1,0);\nvec3 dot_col = vec3(0);\n\nfloat line_width = .001;\nfloat dot_size = .01;\n\nfloat zoom = 2.;\n\nfloat ellipse_param = 3.;\n\nconst int num_iterations = 16;\nint aa = 2;\n\nfloat pi = 3.1415925;\n\nfloat ellipse(vec2 p, out vec2 grad){\n\tgrad = vec2(2,2.*ellipse_param) * p;\n\treturn p.x*p.x + ellipse_param*p.y*p.y - 1.;\n}\n\nfloat lagrange_curve(vec2 p, vec2 p2, out vec2 grad){\n\tgrad = vec2(-2.*p2.y + (2. - 2.*ellipse_param)*p.y, 2.*ellipse_param*p2.x + (2. - 2.*ellipse_param)*p.x);\n\treturn 2.*ellipse_param*p2.x*p.y - 2.*p2.y*p.x + (2. - 2.*ellipse_param)*p.x*p.y;\n}\n\nvec2 iteration(vec2 p, vec2 p2){\n\tfloat p_val1, p_val2;\n\tvec2 p_grad1, p_grad2;\n\n\tp_val1 = ellipse(p,p_grad1);\n\tp -= (p_grad1*p_val1)/dot(p_grad1,p_grad1);\n\n\tp_val2 = lagrange_curve(p,p2,p_grad2);\n\tp -= (p_grad2*p_val2)/dot(p_grad2,p_grad2);\n\n\treturn p;\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n\tmouse -= .5;\n    mouse.x *= iResolution.x/iResolution.y;\n\n\tfloat border = 2./iResolution.y;\n\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tuv *= zoom;\n\tmouse *= zoom;\n\tborder *= zoom;\n\n\tconst mat2 aa_rot = mat2(1.,.5,-.5,1.);\n\n\tvec3 col_sum = vec3(0);\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\taa = 1;\n\tmouse = uv;\n\t#endif\n\n\tvec2 p1;\n\tfor(int x = 0;x<aa;x++){\n\t\tfor(int y = 0;y<aa;y++){\n\t\t\tvec2 aa_offset = (vec2(x,y)-.5*(float(aa)-1.))/float(aa);\n\t\t\taa_offset *= zoom*vec2(aspect_ratio,1)/iResolution.xy;\n\t\t\tp1 = uv+aa_offset;\n\n\t\t\tfor(int i = 0;i<num_iterations;i++){\n\t\t\t\tp1 = iteration(p1, mouse);\n\t\t\t}\n\n\t\t\tcol_sum += pow(to_col(p1),vec3(2.2));\n\t\t}\n\t}\n\n\tbg_col = pow(col_sum/(float(aa)*float(aa)),vec3(1.0/2.2));\n\tbg_col *= .75;\n\n\tvec3 color = bg_col;\n\tfloat dis = 1e38;\n\n\tvec2 ellipse_grad;\n\tfloat ellipse_val = ellipse(uv, ellipse_grad);\n\n\tdis = min(dis, abs(ellipse_val / length(ellipse_grad)) - line_width);\n\tcolor = mix(ellipse_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tvec2 lag_curve_grad;\n\tfloat lag_curve_val = lagrange_curve(uv,mouse,lag_curve_grad);\n\n\tdis = min(dis, abs(lag_curve_val / length(lag_curve_grad)) - line_width);\n\tcolor = mix(lag_curve_col,color,smoothstep(0.,border,dis));\n\tdis = 1e38;\n\n\tdis = min(dis, distance(uv,p1) - dot_size);\n\tcolor = mix(dot_col,color,smoothstep(0.,border,dis));\n\n\t#ifdef SHOW_DISTANCE_FIELD\n\tdis = distance(uv,p1);\n\tfloat sgn = 1.;\n\tcolor = vec3(1.0) - sgn*vec3(0.1,0.4,0.7);\n\tcolor *= 1.0 - exp(-8.0*dis);\n\tcolor *= 0.8 + 0.2*cos(480.0*dis*sgn);\n\tcolor = mix( color, vec3(1.0), 1.0-smoothstep(0.0,0.005,dis) );\n\t#endif\n\n\tfragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}