{
    "Shader": {
        "info": {
            "date": "1497533680",
            "description": "A stereographic projection shader.\n\nUse the mouse to rotate the camera, and click around inside the box to manipulate the orange line. Box controls are:\nx axis: modify the slope of the line in [-1, 1]\ny axis: modify y intercept in [-4, 4]",
            "flags": 32,
            "hasliked": 0,
            "id": "XdffRl",
            "likes": 30,
            "name": "Stereographic Projection & Lines",
            "published": 3,
            "tags": [
                "3d",
                "ui",
                "stereographic"
            ],
            "usePreview": 1,
            "username": "culdevu",
            "viewed": 1500
        },
        "renderpass": [
            {
                "code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tStereographic projections are cool. Lines get turned into circles and all that.\n\n\tPrevious work:  https://www.shadertoy.com/view/XltXzH\n\t\t\t\t\thttps://www.shadertoy.com/view/lt2XDW\n*/\n\n#define PI 3.14159 \n#define inf 80000.\n\n// Plane-Ray intersection\nfloat fp(vec3 p, vec3 r, vec3 n)\n{\n    if (-dot(n, r) < 0.001)\n        return inf;\n    return dot(n, p) / dot(n, r);\n}\nfloat fs(vec3 p, vec3 ray, float rad)\n{\n    float totalL = dot(ray, p);\n    \n    vec3 closestToCenter = ray * totalL;\n    vec3 dO = p - closestToCenter;\n    float O = length(dO);\n    \n    if (O > rad)\n        return inf;\n    \n    float adj = sqrt(rad*rad - O*O);\n    \n    if (totalL - adj < 0.)\n        return inf;\n    return totalL - adj;\n}\n\n// Ulities\nbool xor(bool a, bool b)\n{\n    return (a || b) && (a != b);\n}\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat absCircular(float t)\n{\n    float a = floor(t + 0.5);\n    return mod(abs(a - t), 1.0);\n}\n\n// shoutouts to the amazing tool at\n//   http://dev.thi.ng/gradients/\n// for generating these color palettes\nvec3 color(float t)\n{\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.720);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n    \n    vec3 ret = a + b * cos(2.0 * 3.14159 * (c * t + d));\n    return clamp(ret, 0.0, 1.0);\n}\n\n//---------------------------------------------------\n// Intersection and tracing code\n//---------------------------------------------------\nfloat trace(vec3 o, vec3 ray, out vec3 norm)\n{\n    float d = fp(-o, ray, vec3(0,1,0));\n    \n    float d2 = fs(vec3(0, 1.0, 0) - o, ray, 1.);\n    \n    if (d2 < d)\n    {\n        norm = normalize(o + ray * d2 - vec3(0,1,0));\n        return d2;\n    }\n    \n    norm = vec3(0,1,0);\n    return d;\n}\n\nvec3 sampleColor(vec2 uv)\n{\n    //float mouseU = 2. * PI * 2. * (iMouse.x / iResolution.x - 0.5);\n    //float mouseV = PI * (iMouse.y / iResolution.y);\n    float mouseU = 2. * PI * 2. * (texture(iChannel1, vec2(0.75)).x - 0.5);\n    float mouseV = PI/2. * texture(iChannel1, vec2(0.75)).y;\n    \n    float texU = 2. * (texture(iChannel1, vec2(0.25)).x - 0.5);\n    float texV = 2. * (texture(iChannel1, vec2(0.25)).y - 0.5);\n    vec3 trash;\n    \n    vec3 cam = vec3(0,0,4);\n    vec3 screenPos = vec3(uv, -0.5);\n    \n    pR(cam.yz, mouseV);\n    pR(screenPos.yz, mouseV);\n    \n    pR(cam.xz, mouseU);\n    pR(screenPos.xz, mouseU);\n    \n    vec3 ray = normalize(screenPos);\n    \n    vec3 norm;\n    float d = trace(cam, ray, norm);\n    vec3 pt = cam + ray * d;\n    \n    if (d > inf - 1.)\n    {\n        return vec3(0);;\n    }\n    \n    vec3 ray2 = normalize(pt - vec3(0,2,0));\n    d = trace(pt, ray2, trash);\n    vec3 q = pt + ray2 * d;\n    if (d > inf - 1.)\n        q = pt;\n    \n    vec3 albedo = vec3(1);\n    \n    // colored pattern\n    if (xor(mod(q.x, 2.0) < 1.0, mod(q.z, 2.0) < 1.0))\n        albedo = color(0.4);\n    else\n        albedo = color(0.3);\n    if (texture(iChannel0, vec2(-q.x, q.z) / 16.).x > 0.5)\n        albedo = color(0.2);\n    \n    // minor axes\n    albedo = mix(color(0.1), albedo, pow(smoothstep(0., 0.03, absCircular(q.x)), 3.) );\n    albedo = mix(color(0.1), albedo, pow(smoothstep(0., 0.03, absCircular(q.z)), 3.) );\n    \n    // main axes\n    albedo = mix(color(0.0), albedo, pow(smoothstep(0.0, 0.08, abs(q.x)), 3.0));\n    albedo = mix(color(0.0), albedo, pow(smoothstep(0.0, 0.08, abs(q.z)), 3.0));\n    \n    // the line!\n    {\n        float a = texU;\n        float b = -1.;\n        float d = 4. * texV;\n        \n        vec3 e1 = vec3(-d/a, 0, d/b);\n        vec3 e2 = vec3(0, 2, d/b);\n        vec3 n = normalize(cross(e1, e2));\n        \n        d = dot(n, pt) - n.y * 2.;\n        albedo = mix(color(0.99), albedo, pow(smoothstep(0.0, 0.03, abs(d)), 10.0));\n        \n    }\n    \n    //--------------------------------------------------\n    // Lighting Time\n    //--------------------------------------------------\n    float ambient = 0.1;\n    float ao = smoothstep(0., 1.4, length(q)); // cheapest AO in history\n    \n    // Lighting\n    vec3 light = 2. * vec3(0., 1., 1.);\n    vec3 lightDir = light - pt;\n    float lightIntensity = 5.0;\n    \n    // soft shadows\n    float shadow = 1.;\n    if (pt.y < 0.1)\n    {\n        vec3 nlightDir = normalize(lightDir);\n        float totalL = dot(nlightDir, vec3(0,1,0) - pt);\n    \n        vec3 closestToCenter = nlightDir * totalL;\n        vec3 dO = (vec3(0,1,0) - pt) - closestToCenter;\n        float O = length(dO);\n        shadow = smoothstep(1., 1.1, O);\n    }\n    \n    \n    float illum = shadow * lightIntensity * max(0., dot(norm, normalize(lightDir) )) / length(lightDir);\n    \n    // bad lighting. don't do this at home, kids!\n    illum = illum / (illum + 1.);\n    vec3 final = illum * albedo + ambient * ao * albedo;\n    \n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    vec2 e = vec2(1. / iResolution.y / 1.5, 0.);\n    \n    fragColor  = vec4(sampleColor(uv + e.yy), 1.);\n    fragColor += vec4(sampleColor(uv + e.xy), 1.);\n    fragColor += vec4(sampleColor(uv - e.xy), 1.);\n    fragColor += vec4(sampleColor(uv + e.yx), 1.);\n    fragColor += vec4(sampleColor(uv - e.yx), 1.);\n    fragColor /= 5.;\n    \n    // UI\n    vec2 p = fragCoord / (iResolution.y/4.);\n    p.y -= 3.;\n    if (0. < p.x && p.x < 1. &&\n        0. < p.y && p.y < 1.)\n    {\n        fragColor = mix(vec4(1), fragColor, 0.75);\n        \n        if (p.x > 0.98 || p.y < 0.02)\n            fragColor = vec4(color(0.7), 1.);\n        \n        vec2 q = texture(iChannel1, vec2(0.25)).xy;\n        if (abs(q.x - p.x) < 0.01 || abs(q.y - p.y) < 0.01)\n            fragColor = vec4(color(0.7), 1.);\n    }\n    \n    fragColor = pow(fragColor, vec4(1./2.2));\n    //fragColor = texture(iChannel1, fragCoord.xy / iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 final = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n    \n    if (iMouse.xy == vec2(0))\n    {\n        if (fragCoord.x < iResolution.x/2.)\n        {\n            fragColor = vec4(0.2, 0.8, 0, 1);\n            return;\n        }\n        else\n        {\n            fragColor = vec4(0.07, 0.5, 0, 1);\n            return;\n        }   \n    }\n    \n    if (0. <= iMouse.x && iMouse.x < iResolution.y/4. &&\n        iResolution.y*0.75 < iMouse.y && iMouse.y <= iResolution.y)\n    {\n        if (fragCoord.x < iResolution.x/2.)\n        {\n            final.x = iMouse.x / (iResolution.y/4.);\n            final.y = (iMouse.y - iResolution.y*0.75) / (iResolution.y/4.);\n        }\n    }\n    else if (fragCoord.x >= iResolution.x/2.)\n    {\n        final.x = iMouse.x / iResolution.x;\n        final.y = iMouse.y / iResolution.y;\n    }\n    \n    fragColor = vec4(final, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}