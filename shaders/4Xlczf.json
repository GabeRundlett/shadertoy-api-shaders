{
    "Shader": {
        "info": {
            "date": "1726506528",
            "description": "Made by Rik Riesmeijer based on discoveries by @FabriceNeyret2, see header comments for more info. Does the illusion of motion work here to you? Let me know if I messed up something that breaks it! :)",
            "flags": 0,
            "hasliked": 0,
            "id": "4Xlczf",
            "likes": 1,
            "name": "FBM in @FabriceNeyret2 illusion",
            "published": 3,
            "tags": [
                "fractal",
                "test",
                "fbm",
                "random",
                "illusion",
                "experimental",
                "motion",
                "research",
                "of",
                "fabriceneyret2",
                "martingale",
                "walks"
            ],
            "usePreview": 0,
            "username": "rikr",
            "viewed": 65
        },
        "renderpass": [
            {
                "code": "// Original discovery by @FabriceNeyret2, see the links below for reference:\n// The concept is not mine as said, but feel free to use my code though (CC0)\n\n// Based on the following works by @FabriceNeyret2:\n// Illusion of motion: https://www.shadertoy.com/view/lf2fzw\n// Illusion of motion Gabor variant: https://www.shadertoy.com/view/lcjBz3\n\n// Notice: To me this seems to work, but let me know if my own make-shift noise\n// is not working for you and which (if any) CC0 resource could replace what is broken.\n\n// Hypothesis: (Manner of speaking) Fractal Brownian Motion can be taken in isolation\n// - that is, the paper image can be replaced by pure fbm noise but keeping the random walk -\n// to reproduce the illusion of motion that @FabriceNeyret2 discovered and published here.\n\n// Main idea:\n// We're trying to see if random offsets of 2d monochrome fbm through a span of time\n// will create a 7 dimensional space-time/spectrum fractal that will illude continuous\n// movement which can be seen as a false interpretation by taking a reference point\n// that clearly shows the irratic randomized movements.\n// And here I mean fractal in the sense that as we \"zoom in\" on different parts of\n// time or dimension (given by fbm fractal here) the martingale illusion where the\n// expected color values for each pixel are not dimension dependent.\n// This means that there is a possibility that we are tricked into making a smooth image \n// statistically as probabilistically the expected value is continuous eventhough the\n// image clearly is not (thus we see the red dot that marks the new spot of the offset\n// origin) offsetting randomly (Again).\n\n// For clarity: the dimensions of the complete effect are hard to grasp (7D),\n\n// The dimensions are:\n// rgba (i.e.: electro-magnetic spectral dimensions) and a random walk \n// (i.e., (3d: 2d-space + 1d-time) just like @FabriceNeyret2 made, where\n// it was not easy to see the martingale, so I made the fbm pure version\n// to make the hypothesis easy to reject if false (pure fbm is martingale).\n\n// Methods: All made by myself, this may hinder compatability etc.\n\n// Conclusion: Let me know! Does this look like it is moving to you when it randomly jumps?\n\n// My conclusion: To me it looks like it moves, but my hash function seems\n// to get stuck at times which breaks the illusion for me, overall, I myself would\n// say that the experiment worked.\n\n// Enjoy! :) Made By Rik Riesmeijer, 2024 - Concept by @FabriceNeyret2, links above! :)\n\n// Here we start with 2d and 1d integer hashes for noise.\nivec2 intvec2(int   x) { return ivec2(x, x * 123212321); }\nint   ihash11(int   x) { return (0x37354953 ^ x) * x * (x ^ 0x28433481); }\nivec2 ihash22(ivec2 v) { return (0x37354953 ^ v) * v * (v ^ 0x28433481); }\nint   ihash21(ivec2 v) { return ihash11(v.x ^ ihash11(v.y)); }\nivec2 ihash12(int   x) { return ihash22(intvec2(x)); }\n\n// Floating point interfaces for the integer hashes.\nfloat m11(float x) { return float(ihash11(int(  x))) / float(~0u) + 0.5; }\n//vec2  m22(vec2  v) { return  vec2(ihash22(ivec2(v))) /  vec2(~0u) + 0.5; }\n//float m21(vec2  v) { return float(ihash21(ivec2(v))) / float(~0u) + 0.5; }\nvec2  m12(float x) { return  vec2(ihash12(int(  x))) /  vec2(~0u) + 0.5; }\n#define m21(p)  ( fract(sin( mod( dot( p ,  vec2(12.9898, 78.233) ) , 6.283 ) ) * 3758.5453) )\n#define m22(p)  fract(sin( mod( (p) *  vec2(12.9898, 78.233) , 6.283 ) ) * 3758.5453)\n// Fractal Brownian Motion.\nfloat fbm(vec2 v, float time) {\n    vec2 vs; float fi, si, ti;\n    float cs = cos(0.4), sn = sin(0.4);\n    float res;\n    for(int i = 0; i++ < 6;) {\n        v *= mat2(cs, -sn, sn, cs);\n        fi = float(i);\n        si = exp2(fi);\n        ti = si * si - 2.0;\n        vs = si * v;\n        vec4 b = vec4(floor(vs), ceil(vs));\n        vec2 f = smoothstep(0.0, 1.0, fract(vs));\n        float m = mix(mix(m21(b.xy), m21(b.zy), f.x),\n                      mix(m21(b.xw), m21(b.zw), f.x), f.y);\n        res = si * m / ti + res;\n    }\n    return res;\n}\n\n// Add random walk and a tracker dot.\nvoid mainImage( out vec4 c, in vec2 v ) {\n    v = 6.0 * (v - 0.5 * iResolution.xy) / iResolution.y;\n    v += m22(floor(iTime * 8.0 + 1.0) * vec2(3.1, 3.33)) * 6.0 - 3.0;\n    c = mix( vec4(fbm(v, 0.0)) * 0.5, vec4(1, 0, 0, 1),\n             (0.5 + 0.5 * sin(iTime)) *  smoothstep(0.33, 0.32, length(v)));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}