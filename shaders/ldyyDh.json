{
    "Shader": {
        "info": {
            "date": "1521756622",
            "description": "An attempt to get rid of aliasing in raycasting, using only 1 ray.\nSome artifacts remains, however the image is globaly improved.\nSee program options lines 44 and 62\nSoft shadow & blurred reflection\nMouse enable.\nWhen split screen, left side is AA.",
            "flags": 0,
            "hasliked": 0,
            "id": "ldyyDh",
            "likes": 15,
            "name": "Burial for Aliasing",
            "published": 3,
            "tags": [
                "raytracing",
                "aliasing",
                "shadow",
                "aa"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 978
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Burial for Aliasing\n\n/************************************************************************************************************/\n// This is an attempt to get rid of aliasing in raycasting, maintaining good perfos.\n// Only 1 ray is used (no super sampling).\n// Primitives are modified + sp√©cific process.\n//\n// I add textures for fun, but it's better to de-activate texture to have a better\n// view of the AA. (#define in the header line 46)\n// \n// There are three parts that need to be anti-aliased (AA):\n// 1- the visual outside contour of an object\n// 2- the line created by the intersection of 2 objects\n// 3- the internal lines created by a broken surface in a single object\n//    typically a cube, or a cone/cylinder with a cap.\n//\n// Case 1- the visual outside contour of an object:\n// The max depth reach by the ray into an object is used as a transparency factor.\n// This allow to mix the front object color with the backgroud object.\n// For simplified process and better perfos, only the first (closest) background object is consider.\n// It is a kind of \"first order anti aliasing\".\n// This may generate some artifacts, but not realy noticeable as AA involve only 2 or 3 pixels width.\n//\n// Case 2- the line created by the intersection of 2 objects:\n// Distance between the front and background surface of each interconnected object is the mixing factor.\n//\n// Case 3- Internal lines created by 2 surfaces (cube):\n// This must be done inside the primitive calculation.\n// The hit surface and the closest surface from the hit must be found.\n// The 2 normals are mixed related to the distance between the 2 surfaces.\n// Then the shadowing goes smoothly from a face to another.\n//\n// The objective is to do simple calculation for perfos. Then some aliasing or artifacts remain.\n// Overall smooth image is finally obtained in 90% of time.\n//\n// Shadows are just widely anti-aliased to obtain soft shadows using the same transparency factor.\n//\n// Code and algo can surely be optimized!\n//\n// Ok, now I must go back on my old shader for AA improvement...\n/***************************************************************************************************************/\n\n/***************************  PROGRAM OPTIONS  ***********************/\n\n// - Increase anti-aliasing thickness to enlarge AA\n// this allow to see the \"mixing\" process.\n// TH should be tuned to obtain 2 or 3 pixels width of AA\n//\n// - AA_AREA set in vivid color the AA involved area.\n// (Where d < 1)\n//\n// - SPLIT to split screen. \n\n/******  show Anti-aliased area  ********/\n//#define AA_AREA\n\tconst vec3 AREAcol = vec3(0.,1.,0.);\n\n/******   Anti-aliasing thickness  ******/\n#define TH 5.\n\n/******  Split screen for comparison ****/\n#define SPLIT\n\n/*********************************************************************/\n\n\n/*********************  Add-on process activation  ******************/\n\n#define ACTIVATE_TEXTURE\n\n#define ACTIVATE_SHADOW\n    /***    Shadow softness              ***/\n    #define SH .2\n    /***    Shadow darkness (0 to 1)     ***/\n    #define SC 1.\n\n#define ACTIVATE_REFLECT\n    /***    Reflect softness             ***/\n    #define RF 30.\n    /***    Reflect coef  (0 to 1)       ***/\n    #define RC .3\n\n/********************************************************************/\n\n\n// std needs\n#define PI 3.141592653589793\n#define PIdiv2 1.570796326794897\n#define INFINI 1000.\n\n// objects infos\n#define SKY -1\n#define SPH 1\n#define XCYL 2\n#define ZCYL 3\n#define BOX 4\n#define CONE 5\n\n#define spO vec3(.0)\n#define spR 1.\n#define spCol vec3(1.000,0.839,0.830)\n\n#define cyO vec2(.5)\n#define cyR .4\n#define cyCol vec3(0.928,1.000,0.932)\n\n#define boxO vec3(.0,.1,.1)\n#define boxD vec3(.2,1.2,.82)\n#define boxCol vec3(0.890,0.879,1.000)\n\n#define conO vec3(1.,-.1,.65)\n#define conR .4\n#define conH 1.5\n#define conCol vec3(1.000,0.325,0.402)\n\n\n// Classical raycast parameters\nstruct Type_Param{\tfloat t;\t// distance factor to the object\n            \t\tint hit;\t// ID of hit object\n            \t\tvec3 n;\t\t// normal of hit point\n            \t\tfloat d;\t// max depth reach by ray\n            \t};\n\n\n/************************  Standard cam setting  ************************/\nvec3 getCamPos(in vec3 camTarget){\n    vec3 cam;\n    float \trau = 3.,\n    \t\talpha = iMouse.x/iResolution.x*4.*PI,\n    \t\ttheta = iMouse.y/iResolution.y*PI+(PI/2.0001);\n    if(iMouse.x==0.) cam = rau*normalize(vec3(.2,.4,.5));\n    else cam = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n    \n    vec2 dcam = cam.xy-cyO;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n    if(length(dcam)<=cyR) cam.y = 1.1*sign(dcam.y)*sqrt(cyR*cyR-(dcam.x)*(dcam.x))+cyO.y;\t//  cylinder anti-collision\n    dcam = cam.zy-cyO;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\n    if(length(dcam)<=cyR) cam.y = 1.1*sign(dcam.y)*sqrt(cyR*cyR-(dcam.x)*(dcam.x))+cyO.y;\t//\n    return cam;\n}\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.;\n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\n/**************************  Modified primitives  ***********************/\n\nvec2 sphereImpact(in vec3 pos, in vec3 ray, in vec3 O, in float R, inout vec3 norm ){\n    float d=0., t = INFINI;\n    vec3 a = O - pos;\n    float b = dot(a, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(a,a) - R*R;\n    \td = b*b - c;\n    \tif (d >= 0.){\n        \tfloat sd = sqrt(d);\n            t = b - sd;\n            if (t < 0.001) b + sd;\n            norm = normalize(pos + t*ray - O);\n        }\n    }\n    \n    // The depth reach by the ray depends on the discriminant d.\n    // The depth vary from 0 to large value. We consider transparency factor is d when 0.<d<1.\n    // As AA concern only 1 or 2 pixels, we have to convert d related to 1 pixel.\n    // if object is far, 1 pixel can represent a large amount of sphere radius\n    // d must go from 0 to 1 in a pixel size.\n    d = max(0.,d);\n    return vec2(t, d*iResolution.x/R);\n}\n\nvec2 cylinderImpact(in vec2 pos,in vec2 ray, in vec2 O, in float R, inout vec2 norm){\n    float t=INFINI;\n    vec2 d = pos - O;\n    float a = dot(ray,ray);\n    float b = dot(d, ray);\n    float c = dot(d,d) - R*R;\n    float discr = b*b - a*c;\n    if (discr >= 0.){\n        t = (-b - sqrt(discr))/a;\n        if (t < 0.001) t = (-b + sqrt(discr))/a;\n        if (t < 0.001) t=INFINI;\n\n        norm = normalize(pos + t*ray - O);\n    }\n    discr = max(0.,discr);\n\treturn vec2(t,discr/a*iResolution.x/R);\n}\n\n\nvec2 boxImpact( in vec3 pos, in vec3 ray, in vec3 ctr, in vec3 dim, out vec3 norm) \n{\n    vec3 m = 1.0/ray;\n    vec3 n = m*(ctr-pos);\n    vec3 k = abs(m)*dim;\n\t\n    vec3 t1 = n - k;\n    vec3 t2 = n + k;\n\n\tfloat tmax = max( max( t1.x, t1.y ), t1.z );\n\tfloat tmin = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tmax > tmin || tmin < 0.0) return vec2(INFINI, 0.);\n\n    norm = -sign(ray)*step(vec3(tmax),t1);\n    \n    /********************************** AA process ******************************/\n    /*** visual outside contour ***/\n    // (tmin-tmax) represents the depth reach by the ray into the shape. \n    // larger is the diff between tmax and tmin, deeper into the shape goes the ray\n    // when d is small (<1), we use it as a transparency factor\n    //\n    // As the cube surface is flat and has no thickness (no transparency factor can be used when thickness = 0)\n    // we must apply a correction (corr) when visual angle is flat to emphasis the AA effect.\n    float corr = dot(ray,-norm);\n    corr = (.05+corr)*(1.2-corr*corr*corr);\n    float d = (tmin-tmax)*iResolution.x*corr;\n    \n    #ifdef SPLIT\n    if(gl_FragCoord.x > iResolution.x/2.+2.) return vec2(tmax, d);\n    #endif\n    \n    /*** inside the visual border's shape, where 2 faces connect (crest). ***/\n    // normals must be rotated progressively from one face to the other\n    // so the shading of each face are mixed when distance to the crest is small\n    // half way rotation is done (other half way is done when other face is hit)\n    t1 *= 1.-step(vec3(tmax),t1);\n    float tmed = max( max( t1.x, t1.y ), t1.z );\t// finding 2nd closest hit\n    vec3 norMed = -sign(ray)*step(vec3(tmed),t1);\t// normal of the adjacent face\n    corr = dot(ray,-norMed);\n    corr = (.05+corr)*(1.2-corr*corr*corr);\t\t\t// flat angle correction\n    norm = mix(norMed, norm, .5*min(1.,.5*(tmax-tmed)*corr*iResolution.x/tmax)+.5);\t// mixing the 2 normals\n    \n    d = max(0.,d);\n    return vec2(tmax, d);\n}\n\n// finished cone figure with bottom cap\nvec2 coneImpact(in vec3 pos, in vec3 ray, in vec3 O, in float H, in float R, inout vec3 norm){\n    vec3 tt = vec3(INFINI);\n    float t = INFINI;\n    float tmin,tmed,tmax;\n    vec3 normy = vec3(0.,-1.,0.);\n    float dmin = 0.;\n    vec3 d = O - pos;\n    float Dy = H + d.y;\n    float r2 = R*R/(H*H);\n    float a = dot(ray.xz,ray.xz) - r2*ray.y*ray.y;\n    float b = -dot(d.xz, ray.xz) + r2*Dy*ray.y;\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float disc = b*b - a*c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        tt.xy = (-b + vec2(sqdis,-sqdis))/a;\t\t// cone intercept\n        if(abs(ray.y) > 0.01) tt.z = d.y/ray.y;\t\t// bottom intercept\n        tt += step(tt,vec3(0.))*INFINI; \t\t\t// eliminate neg values\n\t\t\n        \t\t\t\t\t\t\t\t\t\t\t\t/*** AA process ***/\n        tmax = max(max(tt.x,tt.y),tt.z);\t\t\t\t// sort all tt (tmin, tmed, tmax)\n        tmin = min(min(tt.x,tt.y),tt.z);\t\t\t\t// needed for AA\n        vec3 ttemp = step(tt, vec3(tmin))*INFINI + tt;\t//\n    \ttmed = min(min(ttemp.x,ttemp.y),ttemp.z);\t\t//\n        \n        vec2 ofc = Dy - ray.y*tt.xy;\t\t\t\t\t\t// checking upper-lower bounary of the cone\n        tt.xy *= step(vec2(0.),ofc)*step(ofc,vec2(H));\n        tt.xy += step(tt.xy,vec2(0.))*INFINI;\t\t\t\t// eliminate outboud interception of cone\n        \n        tt.z += step(R,length(d.xz-tt.z*ray.xz))*INFINI;\t// eliminate outboud interception of bottom \n        \n        t = min(min(tt.x,tt.y),tt.z);\n        vec3 p = pos+t*ray;\n        \n        /********************************** AA process ******************************/\n        // 2 situations to deal with, depending on cone or bottom hit.\n        if(t != tt.z){\t\t// not bottom, so... cone surface\n        \tnorm = normalize(vec3(p.x-O.x, R*R/(H*H)*(H+O.y-p.y), p.z-O.z));\n            \n            // depth reached by the ray must be consider on the side of the cone or at the connection with the bottom cap\n            // we keep the min.\n            dmin = min( abs(disc/a)/(ofc.y*R/H),\t// distance inside a cone (by the sides)\n                       .5*(tt.z-t) )*iResolution.x;\t// distance at the border of the bottom cut\n            \n            #ifdef SPLIT\n    \t\tif(gl_FragCoord.x < iResolution.x/2.) \n            #endif\n            // mixing the cone and the bottom normals to anti-aliase the crest created by the junction of the two faces.\n            if(tt.x != INFINI) norm = mix(normy, norm, .5*min(1.,.25*abs(tmed-tmin)*iResolution.x/TH)+.5);\n        }\n        else{\t// bottom hit\n            norm = normy;\n            float corr = dot(ray,-norm);\n    \t\tcorr = (.05+corr)*(1.7-corr*corr*corr);\t\t// here we add correction (same issue as the cube flat surface)\n            dmin = .5*(tt.x-t)*corr*iResolution.x;\t\t// depth reach when entering by the bottom (exiting the blind face of the cone)\n            #ifdef SPLIT\n    \t\tif(gl_FragCoord.x < iResolution.x/2.) \n            #endif\n            // finallly, anti-aliase the crest created by the junction of the bottom with the cone.\n            // mixing normals with the bottom and the cone surface.\n            if(tt.x != INFINI) norm = mix( normalize(vec3(pos.x+tmed*ray.x-O.x, 0., pos.z+tmed*ray.z-O.z)) , norm, .5*min(1.,abs(tmed-tmin)*iResolution.x/t)+.5);\n        }\n    }\n    dmin = max(0.,dmin);\n\treturn vec2(t,dmin);\n}\n\n\n/****************************  AA process  ***************************/\n\nvoid setParam(in vec2 i, in int objID, in vec3 norm, in vec3 ray, inout Type_Param STD, inout Type_Param AA){\n    \n    // The setParam() function fills the standard parameters for ray tracing (t, norm, objID) + max depth reach by ray\n    // it fills also the AntiAliasing parameters AA.\n    // AA contains same parameters as STD ones but for the object immediatly behind \n    \n    if(i.x<STD.t){\n        // a closer object is found, the previous object is stored in AA param\n        // the new closest one in STD param\n        AA = STD;\n        float corr = max(.001,dot(ray,-norm));\n        corr = (.05+corr)*(1.7-corr*corr*corr);\n        STD.d = min( (STD.t-i.x)*iResolution.x     *corr,// flat angle correction\n                   \t  i.y);\n        STD.t = i.x;\n    \tSTD.hit = objID;\n        STD.n = norm;\n    }\n    else if(i.x<AA.t){\n        // No closest object hit but closest background one\n        // AA must be updated\n        AA.hit = objID;\n        AA.t = i.x;\n        AA.n = norm;\n    }\n}\n\nvoid trace(in vec3 pos, in vec3 ray, inout Type_Param STD, inout Type_Param AA){\n    // Raytrace all objects\n    // i keep the returned information\n    // i.x is t\n    // i.y is d the max depth reach by ray\n    // The setParam function fills the STD parameters and the AA parameters\n    vec3 norm = vec3(0.);\n    vec2 i;\n    \n    i = boxImpact(pos, ray, boxO, boxD, norm);\n    setParam(i, BOX, norm, ray, STD, AA);\n    \n    i = coneImpact(pos, ray, conO, conH, conR, norm);\n    setParam(i, CONE, norm, ray, STD, AA);\n    \n    i = sphereImpact(pos,ray,spO,spR, norm);\n    setParam(i, SPH, norm, ray, STD, AA);\n    \n    i = cylinderImpact(pos.yz, ray.yz, cyO, cyR, norm.yz);\n    setParam(i, XCYL, vec3(0.,norm.yz), ray, STD, AA);\n    \n    i = cylinderImpact(pos.xy, ray.xy, cyO, cyR, norm.xy);\n    setParam(i, ZCYL, vec3(norm.xy,0.), ray, STD, AA);\n}\n\n// simplified raytrace for shadow\nfloat shadowTrace(in vec3 pos, in vec3 ray){\n    \n    vec3 norm = vec3(0.);\n    vec2 i;\n    float shadow = 0., t = INFINI;\n    \n    // i.y is the depth reach by the ray.\n\t// Depth is used to smooth the shadow.\n    // From all encountered object, the deeper (biggest i.y) value is kept.\n\n    i = boxImpact(pos, ray, boxO, boxD, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = coneImpact(pos, ray, conO, conH, conR, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n\t\n    i = sphereImpact(pos,ray,spO,spR, norm);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = cylinderImpact(pos.yz, ray.yz, cyO, cyR, norm.yz);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    i = cylinderImpact(pos.xy, ray.xy, cyO, cyR, norm.xy);\n\tif(i.x < INFINI) {shadow = max(shadow,i.y), t = min(t,i.x);}\n    \n    \n    #ifdef SPLIT\n    if(gl_FragCoord.x < iResolution.x/2.)\n    #endif\n    \n    shadow /= max(20.,t*SH*iResolution.x);\t// expanding same way as anti-aliasing\n    \n    return min(1.,shadow);\n}\n\nvoid setColor(inout vec3 color, in vec3 pos, in vec3 ray, in vec3 light, in Type_Param PARAM){\n    // Set color to the front object...\n    \n    #ifdef ACTIVATE_TEXTURE\n    vec3 p = pos+PARAM.t*ray;\n    if(PARAM.hit == SKY) return;\n    else if(PARAM.hit == SPH) \n        color = .7*spCol+.3*texture(iChannel0,vec2(atan(p.x,p.z),asin(p.y-spO.y))).rgb;\n    else if(PARAM.hit == XCYL)\n        color = cyCol*(1.- min(vec3(.2),texture(iChannel0, vec2(.5*p.x,atan(p.y,p.z))).rgb));\n    else if(PARAM.hit == ZCYL)\n        color = cyCol*(1.-min(vec3(.2),texture(iChannel0, vec2(.5*p.z,atan(p.x,p.y))).rgb));\n    else if(PARAM.hit == BOX)\n        color = boxCol*texture(iChannel2,vec2(p.x+p.z,p.y+p.x)).rgb;\n    else if(PARAM.hit == CONE)\n        color = .5*(conCol*texture(iChannel3,vec2(.15*atan(p.x-conO.x,p.z-conO.z),p.y)).rgb);\n    \n    #else\n    if(PARAM.hit == SKY) return;\n    else if(PARAM.hit == SPH)  color = spCol;\n    else if(PARAM.hit == XCYL) color = cyCol;\n    else if(PARAM.hit == ZCYL) color = cyCol;\n    else if(PARAM.hit == BOX)  color = boxCol;\n    else if(PARAM.hit == CONE) color = conCol;\n    #endif\n        \n    color *= max(0.,dot(light,PARAM.n));\t\t// light shading\n}\n\nfloat backGround(in vec3 light, in vec3 ray){\t// background lighting\n    float lit = .5*dot(light,ray)+.5;\n    return .5*lit*lit+smoothstep(.99,1.,lit);\n}\n\nvec3 smoothReflect(in vec3 pos, in vec3 ray, in vec3 light, in Type_Param PARAM, in bool Noticeable, in vec3 stepOut){\n    vec3 col = vec3(0.);\n    vec3 p = pos + PARAM.t * ray + stepOut;\t// a little step back to avoid black dithering\n    vec3 refl = reflect(ray,PARAM.n);\n    float bkg = backGround(light,refl);\n    vec3 reflCol = vec3(bkg);\n    vec3 reflColAA = vec3(bkg);\n\n    Type_Param RFL = Type_Param(INFINI, SKY, vec3(0.), 1.);\n    Type_Param RFLAA = Type_Param(INFINI, SKY, vec3(0.), 1.);\n\n    trace(p, refl, RFL, RFLAA);\n    setColor(reflCol, p, refl, light, RFL);\n    setColor(reflColAA, p, refl, light, RFLAA);\n\n    \n    /*** shadow of reflection ***/\n    \n    // the reflection can be under shadow\n    // so we have to extend the ray... only if noticeable!\n    if(Noticeable){\n        if(RFL.t<INFINI){\n            vec3 p2 = p + RFL.t * refl + .001*(RFL.n+RFLAA.n);\n            float shad = shadowTrace(p2, light);\n            reflCol *= 1.-SC*shad;\n        }\n        if(RFLAA.t<INFINI){\n            vec3 p2 = p + RFLAA.t * refl + .01*(RFL.n+RFLAA.n);\n            float shad = shadowTrace(p2, light);\n            reflColAA *= 1.-SC*shad;\n        }\n    }\n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef SPLIT\n    /**/ if(gl_FragCoord.x > iResolution.x/2.) col = RC*reflCol;\n    /**/ else \n    /**/ #endif    \n    /*************************************************************************/\n    \n    col = RC*(reflCol*min(1.,RFL.d/(RFL.t+PARAM.t)/RF) + reflColAA*max(0.,(1.-RFL.d/(RFL.t+PARAM.t)/RF)));\n\n\treturn col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // camera def\n    vec3 camTarget = vec3(0.);\n    vec3 pos = getCamPos(camTarget);\n    vec3 ray = getRay(st, pos,camTarget);\n    \n    vec3 light = normalize(vec3(sin(iTime*.1),.3,cos(iTime*.1)));\n    float bg = backGround(light, ray);// background color\n    vec3 color = vec3(0.);\n    vec3 col = vec3(bg), \tcolAA = vec3(bg);\n    \n    // standard raytrace params (usually used)\n    Type_Param STD = Type_Param(\tINFINI,\t\t// distance to hit: t\n                      \t\t\t\tSKY,\t\t// hit object ID: hit\n                      \t\t\t\tvec3(0.),\t// normal of surface object: n\n                      \t\t\t\t1.\t\t\t// Max depth reach by the ray inside the object: d\n                     \t\t\t);\n    \n    // first order anti-aliasing params\n    Type_Param AA = Type_Param(\t\tINFINI,\t\t// distance to hit: t\n                      \t\t\t\tSKY,\t\t// hit object: hit\n                      \t\t\t\tvec3(0.),\t// normal of surface object: n\n                      \t\t\t\t1.\t\t\t// not used in AA\n                     \t\t\t);\n\n    /***********************  Main process ************************/\n    \n    trace(pos, ray, STD, AA);\n    setColor(col, pos, ray, light, STD); \t\t// Set color to the front object...\n    setColor(colAA, pos, ray, light, AA);\t\t//...and to the first background object (1st order AA)\n    \n    \n\n    /*----------------  All the following (till the dashed line below) -------------*/\t\t\t\t\t \n\t/*\t\t\t\tare visual options. not necessary to understand process         */\n\t/*------------------------------------------------------------------------------*/\n\n    /**************************  Shadow  ***************************/\n    \n    // soft shadow = big anti-aliasing on shadow\n    #ifdef ACTIVATE_SHADOW\n    if(STD.t<INFINI){\n    \tvec3 p = pos + STD.t * ray + .001*(STD.n+AA.n);\t// adding a little step-out\n        float shad = shadowTrace(p, light);\n        col *= 1.-SC*shad;\n    }\n\tif(AA.t<INFINI){\n    \tvec3 p = pos + AA.t * ray + .01*(STD.n+AA.n);\n        float shad = shadowTrace(p, light);\n        colAA *= 1.-SC*shad;\n    }\n    #endif\n    \n    /**************************  reflection  ************************/\n    \n    // reflections are anti-aliased too\n    #ifdef ACTIVATE_REFLECT\n    if(STD.t<INFINI) col += smoothReflect(pos, ray, light, STD, true, .001*(STD.n+AA.n));\t// last parameter used for a little step-out\n    if(AA.t<INFINI) colAA += smoothReflect(pos, ray, light, AA, false, .01*(STD.n+AA.n));\t// to avoid black dithering\n    #endif\n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef AA_AREA\n    /**/ if(STD.hit == BOX){\n    /**/ \t if(floor(abs(STD.n)) == vec3(0.)) col = AREAcol;\n    /**/ }\n    /**/ else if(STD.hit == CONE){\n\t/**/\t if(STD.n.y/length(STD.n.xz)+.001 < conR/conH && STD.n.y != -1.) col = AREAcol;\n    /**/ }\n    /**/ colAA += float(STD.hit != SKY)*AREAcol;\t\t// make visible the AA area involved\n    /**/ #endif\n\t/************************************************************************/\n    \n    /*-----------------------------------------------------------------------------------*/\n    /*\t\t\t\t\t\t\t\t\t end of options \t\t\t\t\t\t\t\t */\n    /*-----------------------------------------------------------------------------------*/\n    \n    \n    float blur = max(1.,.2*STD.t);\t// far distance blur (using enhanced AA depending on distance)\n    \n    // Finally, mix the color of front and background object\n    // depending on ray depth inside the front object (STD.d)\n    color = col*min(1.,STD.d/STD.t/TH/blur) + colAA*max(0.,(1.-STD.d/STD.t/TH/blur));\n\n    \n    \n    /****************************  demo option  ******************************/\n    /**/ #ifdef SPLIT\n    /**/ if(gl_FragCoord.x < iResolution.x/2.) color = col*min(1.,STD.d/STD.t/TH/blur) + colAA*max(0.,(1.-STD.d/STD.t/TH/blur));\n    /**/ else if(gl_FragCoord.x > iResolution.x/2.+2.) color = col;\n    /**/ else color = vec3(0.995,0.829,0.006);\n    /**/ #endif\n\t/************************************************************************/\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}