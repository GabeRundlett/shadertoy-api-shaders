{
    "Shader": {
        "info": {
            "date": "1686071177",
            "description": "The shapes are not actually moving (just changing colors), except for the arrows!\n\n*press space or click mouse to remove the color*\n\nInspired by:\n\nhttps://www.reddit.com/r/OpticalIllusionGifs/comments/13zaowf/no_object_except_for_the_arrows_moves/",
            "flags": 16,
            "hasliked": 0,
            "id": "mtVXzR",
            "likes": 62,
            "name": "Apparent Motion",
            "published": 3,
            "tags": [
                "optical",
                "illusion",
                "opticalillusion",
                "rainbow",
                "motion",
                "opart",
                "reproduction",
                "apparent"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 670
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2023\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Inspired by:\n//\n//      https://www.reddit.com/r/OpticalIllusionGifs/comments/13zaowf/no_object_except_for_the_arrows_moves/\n//\n//  The shapes are not actually moving (just changing colors), except for the arrows!\n//  And the arrows do not slide either...they only flip and rotate.\n//\n//  I actually have no idea why we see the apparent motion...I basically fiddled with\n//  coloring the edges until it looked like it started moving. However it works, this\n//  design does an amazing job magnifying it. Having the bars \"move\" the opposite\n//  direction from the circle keeps balance, which amplifies the motion effect. The \n//  same goes for the rotation of the colors opposing in the inner circle and the\n//  outer bars. It's also very helpful that the arrows alternate directions to relieve\n//  the cognitive \"pressure\" caused by the objects appearing to move towards each other\n//  but not get any closer. The arrows support the motion illusion (by priming your\n//  expectations) but also act as a red herring as you try to figure out what is \n//  happening.\n//\n//  * press space to turn off the colors *\n//\n//  I did experiment with golfing this shader, but the result wasn't very short or\n//  interesting and it was a lot harder to read, so I went with a mostly non-golfed\n//  style. If anyone still wants to golf this I'll still post the results.\n//\n// ---------------------------------------------------------------------------------------\n\n#define PI 3.14159\n\n// from iq: https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat arrows(vec2 u, float t, float a)\n{\n    // control space to rotate/mirror/flip a single arrow as needed\n    float s = 1.;\n    if (t < 10.)\n    {\n        // rotating single arrow\n        u *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    }\n    else\n    {     \n        s = 2.; // correct for minification\n        \n        // four small arrows\n        if (abs(u.y) < abs(u.x))\n        {\n            // left and right arrows\n            u = abs(u.yx) * 2. - vec2(0, .15);\n            u.y = mod(t, 5.) > 2.5 ? -u.y : u.y;\n        }\n        else\n        {\n            // up and down arrows\n            u = abs(u) * 2. - vec2(0, .15);\n            u.y = abs(t - 15.) > 2.5 ? -u.y : u.y;\n        }\n    }\n\n    // draw one arrow\n    float d = sdBox(u, vec2(.01, .04));\n    return min(d, sdEquilateralTriangle(u - vec2(0, .05), .03)) * s;\n}\n\nfloat circle(vec2 p)\n{\n    p = abs(p);\n    float d = abs(length(p) - .2) - .05; // circle shape\n    float a = (trunc(atan(p.y, p.x) * 6. / PI) + .5) * PI / 6.; // angle of nearest hole\n    vec2 x = vec2(cos(a), sin(a)) * .2; // closest hole center\n    return max(d, .042 - length(p - x));\n}\n\nfloat bars(vec2 p)\n{\n    p = abs(p);\n    float d = abs(p.x - .4) - .04; // bar shape\n    return max(d, .035 - length(vec2(p.x - .4, mod(p.y, .16) - .08))); // cut the holes\n}\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define KEY_SPACE 32\n\nvec3 color(float x)\n{\n    vec3 c = sin(x * PI + vec3(0, 1, 2));\n    return keyDown(KEY_SPACE) || iMouse.z > 0. ? vec3(0) : c * c;\n}\n\nvec2 map(vec2 u, float t, float a)\n{\n    float d, c; // distance, color\n    if (length(u) < .3)\n    {\n        if (length(u) < .14)\n        {\n            d = arrows(u, t, a);\n            c = u.x + u.y;\n        }\n        else\n        {\n            d = circle(u);\n            c = atan(u.y, u.x) * .5 / PI;\n        }\n    }\n    else\n    {\n        d = bars(u); // vertical bars\n        float h = bars(u.yx); // horizontal bars\n        \n        if (u.x * u.y > 0. ? d > h || h < 0. : h < d && d > 0.) // overlap bars correctly\n            c = u.x * sign(u.y) + PI * .5;\n        else \n            c = -u.y * sign(u.x);\n            \n        d = min(d, h);\n    }\n\n    return vec2(smoothstep(3./iResolution.y, 0., d), c);\n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    u = (u - .5 * iResolution.xy) / iResolution.y;\n    \n    float t = mod(iTime, 20.);\n    float a = min(mod((trunc(t / 2.5) + smoothstep(2., 2.5, mod(t, 2.5))) * .5, 4.), 1.5) * PI; // arrow angle\n\n    vec2 l = t < 10. ? vec2(sin(a), cos(a)) : // light (?)\n             t < 12.5 ? u * vec2(1, -1) :\n             t < 15. ? u * vec2(-1, 1) :\n             t < 17.5 ? u : -u;\n    \n    vec2 e = vec2(.002 + 1. / iResolution.y, 0);\n    vec2 n = vec2(map(u + e.xy, t, a).x - map(u - e.xy, t, a).x, // normal\n                  map(u + e.yx, t, a).x - map(u - e.yx, t, a).x);\n    vec2 r = map(u, t, a); // density, color\n    \n    O.xyz = mix(vec3(.5), color(iTime * 2. + dot(n, normalize(length(u) > .3 ? -l : l)) * .25 + r.y), r.x);\n    O.a = 1.;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}