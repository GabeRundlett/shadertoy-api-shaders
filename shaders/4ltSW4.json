{
    "Shader": {
        "info": {
            "date": "1479592869",
            "description": "A simple YingYang symbol animated so that white becomes \"Chaos\" and Black becomes \"Order\"",
            "flags": 0,
            "hasliked": 0,
            "id": "4ltSW4",
            "likes": 2,
            "name": "Chaos YingYang",
            "published": 3,
            "tags": [
                "2dsymbolanimated"
            ],
            "usePreview": 0,
            "username": "Shoseki",
            "viewed": 679
        },
        "renderpass": [
            {
                "code": "// First, test if we are within the circle\n// If not, return \"empty\"\n\n// Then, test if we are left\n// If not, return empty\n\n// Ok, we need to segment the image into 4 pieces\n// Left right, top bottom\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ok so UV is the 0.0 - 1.0, 0.0 = 1.0 of the space\n    \n    float minRes = iResolution.x;\n    if (iResolution.y < minRes) minRes = iResolution.y;\n    \n\tvec2 uv = fragCoord.xy / minRes;\n    float degrees = iTime;\n    \n    vec2 uvOffset = vec2(uv.x - (iResolution.x / minRes * 0.5), uv.y - 0.5);\n\n    // Lets rotate according to time    \n    // Rotate around the center, not the bottom left\n    mat2 m;\n    m[0][0] = cos(degrees);\n    m[1][0] = -sin(degrees);\n    m[0][1] = sin(degrees);\n    m[1][1] = cos(degrees);\n    \n    uvOffset = m * uvOffset;\n    \n    float distanceToCenter = sqrt((uvOffset.x * uvOffset.x) + (uvOffset.y * uvOffset.y));\n    \n    // Define the color it would be if it was 100% succesful\n    float r = rand(uv * sin(iTime)), g = rand(uv * cos(iTime)), b = rand(uv * tan(iTime));\n    \n    float brightness = sin(degrees / 10.0);\n    vec4 bgcolor = fragColor = vec4(r * brightness, g * brightness, b * brightness, 1.0);\n    \n    // Ok so we can access uv.x and uv.y as the individual coordinates\n    if (distanceToCenter > 0.5) fragColor = bgcolor;\n    else {\n        \n        // Now we need to start caring whether we are black or white\n        bool black = (uvOffset.x > 0.0);\n        \n        // Now we need to see if we are within the top circle, if so, set it to white\n        vec2 tCircleUV = vec2(0.0, 0.25), bCircleUV = vec2(0.0, - 0.25);\n\n        vec2 tCircleUVOffset = vec2(tCircleUV.x - uvOffset.x, tCircleUV.y - uvOffset.y);\n        vec2 bCircleUVOffset = vec2(bCircleUV.x - uvOffset.x, bCircleUV.y - uvOffset.y);        \n\n        float distanceToTCircleCenter = sqrt((tCircleUVOffset.x * tCircleUVOffset.x) + (tCircleUVOffset.y * tCircleUVOffset.y));\n        float distanceToBCircleCenter = sqrt((bCircleUVOffset.x * bCircleUVOffset.x) + (bCircleUVOffset.y * bCircleUVOffset.y));\n\n        if (distanceToTCircleCenter < 0.25) black = false;\n        if (distanceToBCircleCenter < 0.25) black = true;\n        \n        if (distanceToTCircleCenter < 0.0833333333) black = true;\n        if (distanceToBCircleCenter < 0.0833333333) black = false;\n        \n        // Finally, if we have decided what segment it is in, color\n        if (black) fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        else {\n            \n            \n            // For reference\n            // fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n            fragColor = vec4(r, g, b, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}