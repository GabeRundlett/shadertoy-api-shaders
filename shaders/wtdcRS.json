{
    "Shader": {
        "info": {
            "date": "1609390662",
            "description": "nebula uh oh",
            "flags": 32,
            "hasliked": 0,
            "id": "wtdcRS",
            "likes": 31,
            "name": "Nebula++",
            "published": 3,
            "tags": [
                "nebula"
            ],
            "usePreview": 0,
            "username": "michael0884",
            "viewed": 1066
        },
        "renderpass": [
            {
                "code": "\n// FIXED Fork of \"Spectral Volumetric Nebula\" by Zi7ar21. https://shadertoy.com/view/tl3yD7\n// 2020-12-31 04:56:29\n\n// Fork of \"Fluffy Cloud\" by Zi7ar21. https://shadertoy.com/view/WlcyDn\n// 2020-12-29 04:35:14\n\n// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Spectral Volumetric Nebula --- December 28th, 2020\n// Updated December 28th, 2020 22:15 Mountain Time\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/tl3yD7\n// \n// Fork of \"Fluffy Cloud\" by Zi7ar21.\n// https://www.shadertoy.com/view/WlcyDn\n// December 27th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020 / December 28th, 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n//blue in screen, white in time\nvec4 rand4blue()\n{\n    return texelFetch(iChannel1, shift2(), 0);\n}\n\n// ##### NOISE #####\n// Cyclic Noise from https://www.shadertoy.com/view/wl3czN\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\nvoid cyclicOctave(inout vec3 p, inout float rz, inout float z, inout float trk, inout float dspAmp){\n    p += sin(p.yzx*0.25*trk - trk*6.1 + cos(p*0.1 + 0.5)*1.0)*dspAmp;\n    float ofst = 4.6;\n    vec3 s = sin(p*1.3);\n    rz += smoothstep(-1.1, 0.5, dot(s, cos(p.yzx*0.95+s.xyz+ofst)))*z;\n    dspAmp *= 0.65;\n    z *= 0.45;\n    trk *= 1.45;\n    p *= m3;}\nfloat cyclic3D(vec3 p){\n    vec3 bp = p;\n    float rz = 0.0;\n    vec3 drv = vec3(0.0);  \n    float z = 1.44;\n    float trk= 1.0;\n    float dspAmp = 1.;\n    for (int i = 0; i<=NUM_OCTAVES; i++){\n        cyclicOctave(p, rz, z, trk, dspAmp);}\n    rz -= 1.1;\n    return rz;}\n\n// Nebula Noise\nvec3 nebulanoise(vec3 raypos){\n    float density = max(0.0, cyclic3D(raypos)-distance(raypos, vec3(0.0, 0.0, 0.0)));\n   // vec3 rgb = vec3(clamp(-distance(raypos, vec3(0.0))+1.0, 0.0, 1.0));\n    return vec3(0.239,0.569,1.000)*density;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos, float dither){\n    vec3 LightColor = vec3(0.5);\n    vec3 LightDirection = normalize(vec3(sin(1.),cos(1.), 1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    raypos += dither*LightDirection*STEP_SIZE;\n    for(int i=0; i<MAX_MARCHES; i++)\n    {\n        density = nebulanoise(raypos);\n        vec3 absorbance = exp(-ABSORPTION*density*STEP_SIZE);\n        attenuation *= absorbance;\n        if(length(attenuation) < 0.05) {attenuation *= 0.5; break;}\n        raypos = raypos+(LightDirection*STEP_SIZE);\n     }\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec4 bnoise = rand4blue();\n    vec3 raypos = camerapos + raydir*bnoise.x*STEP_SIZE;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+(raydir*STEP_SIZE);\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = nebulanoise(raypos);\n        vec3 absorbance = exp(-ABSORPTION*density*STEP_SIZE);\n        vec3 transmittance = 1.0-exp(-SCATTERING*density*STEP_SIZE);\n        vec3 directlighting = attenuation*transmittance;\n        if(length(density) > 0.01){\n            directlighting *= directLight(raypos, bnoise.y);\n        }\n        else directlighting *= 0.1;\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = distance(raypos, camerapos);\n        if(distorigin>MAX_DISTANCE || length(attenuation) < 0.1) break;\n    }\n    return outCol;//*attenuation;\n}\n\n// ##### RENDERING #####\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = TEMPORAL_ACCUMULATION*oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Start RNG\n    rng_initialize(fragCoord, iFrame);\n\n    // Camera Orientation\n    vec3 camerapos = vec3(0.0);\n    #ifdef ROTATION_MATRIX\n\t    // Dumb rotation matrix hecking Michael(yeet) made me make\n\t    float xrot = 0.5*iTime+atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0 +2.*pi*iMouse.x/iResolution.x;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    camerapos -=6.*dir*vec3(0,0,1);\n    \n    for(int i = 0; i < SPP; i++)\n    {\n        // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n        vec2 fragCoordDithered = fragCoord+(rand4blue().xy-0.5);\n        vec2 uv = (fragCoordDithered-0.5*iResolution.xy)/iResolution.x;\n        #ifdef ROTATION_MATRIX\n            vec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n        #endif\n        #ifndef ROTATION_MATRIX\n            vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n        #endif\n        vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n        // Output\n        fragColor += vec4(raymarched, 1.0);\n    }\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0.0 ? vec3(0.0) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 24\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 8.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.35\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define SCATTERING 64.0\n#define ABSORPTION 15.0\n\n// Cyclic Noise Octaves, more is more detailed with exponentially deminishing return.\n#define NUM_OCTAVES 8\n\n// Tiles, more means easier on the Hardware\n#define TILES 1 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n//SPP\n#define SPP 1\n\n#define TEMPORAL_ACCUMULATION 0.1\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1);\n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n    \n// Spectral Coloration\nfloat saturate(float x){\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate(vec3 x){\n    return min(vec3(1.0,1.0,1.0), max(vec3(0.0,0.0,0.0),x));\n}\nvec3 bump3y(vec3 x, vec3 yoffset){\n\tvec3 y = vec3(1.0,1.0,1.0) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi6(float w){\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}