{
    "Shader": {
        "info": {
            "date": "1625570381",
            "description": "Reimplementation of AMD FidelityFX CAS. Other upscalers: https://www.shadertoy.com/playlist/WcKXWW",
            "flags": 0,
            "hasliked": 0,
            "id": "ftsXzM",
            "likes": 12,
            "name": "AMD FidelityFX: CAS",
            "published": 3,
            "tags": [
                "cas"
            ],
            "usePreview": 1,
            "username": "goingdigital",
            "viewed": 1367
        },
        "renderpass": [
            {
                "code": "/*\nAMD FidelityFX Contrast Adaptive Sharpening\nhttps://gpuopen.com/fidelityfx-cas/\nPotentially useful to upscale under-resolution renders.\n\nThis is a slimmed down reimplementation based on the paper.\n\nBest viewed in fullscreen.\nDrag left right to change switchover position. CAS on left.\nDrag up and down to set CAS level.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 muv;\n    if (iMouse.z > 0.) {\n        muv = iMouse.xy/iResolution.xy;\n    } else {\n        muv = vec2(.5+.3*sin(iTime*.3),.5);\n    }\n  \n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz;\n\n    // CAS algorithm\n    float max_g = col.y;\n    float min_g = col.y;\n    vec4 uvoff = vec4(1,0,1,-1)/iChannelResolution[0].xxyy;\n    vec3 colw;\n    vec3 col1 = texture(iChannel0, uv+uvoff.yw).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw = col1;\n    col1 = texture(iChannel0, uv+uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv+uvoff.yz).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    col1 = texture(iChannel0, uv-uvoff.xy).xyz;\n    max_g = max(max_g, col1.y);\n    min_g = min(min_g, col1.y);\n    colw += col1;\n    float d_min_g = min_g;\n    float d_max_g = 1.-max_g;\n    float A;\n    if (d_max_g < d_min_g) {\n        A = d_max_g / max_g;\n    } else {\n        A = d_min_g / max_g;\n    }\n    A = sqrt(A);\n    A *= mix(-.125, -.2, muv.y);\n    vec3 col_out = (col + colw * A) / (1.+4.*A);\n    if (uv.x > (muv.x-.002)) {\n        if (uv.x > (muv.x+.002)) {\n            col_out = col;\n        } else {\n            col_out = vec3(0);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col_out,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}