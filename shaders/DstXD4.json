{
    "Shader": {
        "info": {
            "date": "1681133288",
            "description": "Made for Revision 2023: https://demozoo.org/graphics/322470/\nCaelid but fractal\n4K procudural gfx coders, love you all",
            "flags": 32,
            "hasliked": 0,
            "id": "DstXD4",
            "likes": 54,
            "name": "[Revision23] Fracaelid",
            "published": 3,
            "tags": [
                "fractal",
                "flower",
                "tree",
                "mandelbox",
                "apollonian"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 990
        },
        "renderpass": [
            {
                "code": "vec3 tonemap(vec3 x)\n{\n    const float a = 2.51, b = .03, c = 2.43, d = .59, e = .14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    col = tonemap(col);\n    col = pow(col, vec3(.45));\n    col = col * .6 + .4 * col * col * (3. - 2. * col);\n    col *= .5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .1);\n    col = pow(col, vec3(.45));\n    fragColor.xyz=col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Revision 2023 4K Executable Graphics Entry\n\nfloat seed;\n\n#define PI 3.1415926535\n#define HEIGHT(z) sin(z * .2  + 1.) * 2.\n\n#define MAT_TREE_TRUNK 0.\n#define MAT_TREE_LEAVES 1.\n#define MAT_FLOWER 2.\n#define MAT_FLOWER_LEAVES 3.\n#define MAT_GRASSLAND 4.\n#define MAT_WALL 5.\n\nvec3 sunDir = normalize(vec3(-.7, 1, -.1));\nvec3 sunCol = vec3(1.);\n\nvec2 hash21(float p)\n{\n    vec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n    return fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(vec3 p)\n{\n    const vec3 s = vec3(7, 157, 113);\n    vec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p -= ip;\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec3 p)\n{\n    mat3 m = mat3(.0, .8, .6,\n        -.8, .36, -.48,\n        -.6, -.48, .64);\n    float f = 0., s = .5;\n    for (int i = 0; i < 4; ++i)\n    {\n        f += s * noise(p);\n        p = m * p * 2.01;\n        s *= .5;\n    }\n\n    return f;\n}\n\nfloat bump(vec3 p)\n{\n    return fbm(p * vec3(.1, .025, .1) * iResolution.x);\n}\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e = vec2(2. / iResolution.y, 0);\n    vec3 g = vec3(bump(p - e.xyy) - bump(p + e.xyy),\n        bump(p - e.yxy) - bump(p + e.yxy),\n        bump(p - e.yyx) - bump(p + e.yyx)) / (e.x * 2.);\n    g = (g - n * dot(g, n));\n    return normalize(n + g * weight);\n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, .0, 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n\n}\n\n// Used for the wall (y=1.) and the grass like fractal (y=0.)\nfloat mandelBox(vec3 z, float y)\n{\n    // vec4(fixedRadius2, minRadius2, foldingLimit, scale);\n    vec4 params = vec4(2., .1, 1.4, 3.);\n\n    if(y<1.)z.x = mod(z.y + 1., 2.) - 1.;\n    else\n    {\n        params.z = 1.8;\n        params.x = 2.3;\n        if (z.y > -3.16) return 100.;\n        z.z = mod(z.z, 2.) - 1.;\n    }\n    vec3 offset = z;\n    float dr = 1.;\n\n    for (int n = 0; n < 9; ++n)\n    {\n        z.xy *= mat2(.54, .84, -.84, .54);\n\n        z = clamp(z, -params.z, params.z) * 2.0 - z;\n\n        float r2 = dot(z, z);\n        if (r2 < params.y)\n        {\n            float temp = (params.x / params.y);\n            z *= temp;\n            dr *= temp;\n        }\n        else if (r2 < params.x)\n        {\n            float temp = (params.x / r2);\n            z *= temp;\n            dr *= temp;\n        }\n\n        z = params.w * z + offset;\n        dr = dr * abs(params.w) + 1.;\n    }\n    return length(z) / abs(dr);\n}\n\n\nvec3 c = vec3(.808, .22, 2.137);\nfloat fractal(vec3 p)\n{\n    float scale = 1.;\n    vec3 q = p;\n    for(int i=0; i < 14;i++)\n    {\n        float a = 2.;\n        if (i == 3 && q.x<-44.) a = 2.4;\n        p = a*clamp(p, -c, c) - p;\n        float k = max(1. / dot(p, p), .03);\n        p *= k;\n        scale *= k;\n    }\n\n    float l = min(length(p.xz), mandelBox(p*1.8, 0.)/1.8+.01);  // 2.3\n    \n    float rxy = l - .4;\n    float n = l * p.z;\n    rxy = max(rxy, -n / length(p) - .01);\n    return rxy / abs(scale * 1.5);\n}\n\nvec3 fractalMate(vec3 p)\n{\n    vec3 q = p;\n    vec3 acc = vec3(0);\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 p1 = 2. * clamp(p, -c, c) - p;\n        acc += distance(p, p1) * max(1./ dot(p, p), .3);\n        p = p1 * max(1. / dot(p1, p1), .03);;\n    }\n\n    vec3 k = vec3(.3, .2, .2);\n    if (q.z < 4.8) k = vec3(.5, .4, .2);\n    q.xy *= rot(.2);\n    if (q.y < 34. && q.y > -5. && q.z > 4.5 && abs(q.x+32.7)<3.) k = vec3(2,.9,.8);\n    return vec3(.4, .4, .3) + k * cos(3. * acc);\n}\n\n// KIFS fold with id recorded for each folded space, in order to apply some variations\nvec2 fold(vec2 p, float s, out float id)\n{\n    float a = PI / s + atan(p.x, p.y);\n    float n = PI * 2. / s;\n    a = floor(a / n);\n    id = mod(a, s);\n    p *= rot(-a * n);\n    return p;\n}\n\n// Bar but scales differently on the three axis\nfloat dbar2(vec3 p, vec3 a, vec3 b, vec3 r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), .0, 1.);\n    return (length((pa - ba * h) / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\n// Tree branches and leaves (i>=4.)\nvec4 dBranches(vec3 p, float i, float id, float len)\n{\n    p.x += sin(p.y * 4.) * (.2 - .1 * step(4., i)) * (hash21(id * 17. + i + 3.).x * .5 + .5) * smoothstep(.5, 1., p.y);\n    vec3 dir = normalize(vec3(0, 2, -1));\n    float k = .1 - smoothstep(.6, 2.5, p.y) * .07;\n    float l = 3.;\n    if (i >= 4.)\n    {\n        p.x *= .4;\n        p.z += abs(sin(p.x * 25.)) * .05;\n        //p.x += abs(sin(p.y * 30.)) * .005;\n        k = .1 - sin(p.y * 2. + 2.5) * .1;\n        l = 3.;\n    }\n    else if (i > 0.) k *= 0.2;\n    else k -= noise(p*vec3(50,10,50))*.02 - .01;\n\n    float dcap = dbar2(p + vec3(0, 0, len),\n        vec3(0, 0, len),\n        vec3(0, 0, len) + len * l * dir,\n        vec3(k));\n\n    return vec4(p, dcap);\n}\n\nvec2 tree(vec3 z0)\n{\n    z0.xz *= rot(-.2);\n\n    vec4 z = vec4(z0, 1.);\n    vec3 p = z.xyz;\n\n    p.x -= sin(p.y * 2.) * .1;\n    float d = max(abs(p.y - .1) - 1., length(p.xz) - .22 - noise(p.zyx * vec3(50, 10, 50)) * .02 + smoothstep(0., 1.3, p.y) * .3);\n\n    float id = 0., numLayers = 7., mateid = 0.;\n\n    // The position to clone more branches\n    vec4 branchClonePos = z;\n    float branchCloneIndex = 3.;\n    float branchLayer = 4.;\n\n    // The position to clone more leaves\n    vec4 leafClonePos = z;\n    float leafCloneIndex = 4.;\n\n    // 1 iteration of folding is not enough to create thick leaves, so there are numLayers\n    for (float layerIndex = 1., i = 0.; layerIndex <= numLayers; layerIndex += 1.)\n    {\n        for (; i < 5.; i += 1.)\n        {\n            float f = 5. + (layerIndex > 1. ? 4. : 0.);\n            float spread = -.95 - i / 7.;\n\n            if (i == branchCloneIndex)\n                branchClonePos = z;\n\n            if (layerIndex == 1. && i == leafCloneIndex)\n                leafClonePos = z;\n\n\n            z.xz = fold(z.xz, f, id);\n            z.yz *= rot(-spread);\n\n\n            float len = 1. + id / f / 3.;\n            vec4 res = dBranches(z.xyz, i, id, len);\n            float dcap = res.w / z.w;\n\n            // for leaves\n            if (i >= 4.)\n            {\n                float d1 = dcap +.011;\n                if (d1 < d)\n                {\n                    d = d1;\n                    mateid = 1.;\n                }\n            }\n            // for branches\n            else\n            {\n                if (dcap < d)\n                {\n                    d = smin(d, dcap, .05 - .04 * step(2., float(i)));\n                    mateid = 0.;\n                }\n            }\n\n            z.zy += vec2(1., -2.) * len;\n            z *= 2.;\n        }\n\n\n        if (layerIndex < branchLayer)\n        {\n            z = branchClonePos;\n            // place more branches uniformly on the parent branch\n            z.zy -= normalize(vec2(1., -2.)) * (hash21(layerIndex * 17.).x+1.) * branchCloneIndex * 2. / branchLayer;;\n\n            //z *= 4. - branchCloneIndex + 1.;\n            i = branchCloneIndex;\n\n        }\n        else\n        {\n            z = leafClonePos;\n            z.zy -= normalize(vec2(1., -2.)) * (layerIndex - 2.) * leafCloneIndex / (numLayers - branchLayer);//  / (numLeafLayers);\n            i = leafCloneIndex;\n\n            // folding to add more leaves in each layer\n            z.xzy = abs(z.xzy) - 1.;\n        }\n        z.xy *= rot(.2 * (numLayers - layerIndex));\n    }\n\n    return vec2(d * .5, mateid);\n}\n\n// Almost the same with dBranches, but only for flower pedels\nvec4 dPedals(vec3 p, float i, float id, float fid)\n{\n    p.z += sin(p.y * id / 2.) * .05;\n    p.z += sin(p.y * 2.) * (.65 - i / 5.);\n    float k = .1 - sin(p.y * 2. + 2.5) * .1;\n\n    if (i == 1.)\n    {\n        p.z += abs(sin(p.x * 5.)) * .15;\n        p.z += abs(sin((p.y - abs(p.x)) * 15.)) * .01;\n        p.x += sin(p.z * 60.) * .01;\n    }\n\n    float dcap = dbar2(p + vec3(0, 0, 1),\n        vec3(0, 0, 1),\n        vec3(0, 0, 1) + 2.8 * normalize(vec3(0, 2, -1)),\n        vec3(k * (3.-fid), k, .03)) + .01;\n    return vec4(p, dcap);\n}\n\n// Almost the same with tree, but no layers \nvec2 flower(vec3 z0, float fid)\n{\n    z0.xz *= rot(fid);\n    z0.z *= -1.;\n    vec4 z = vec4(z0, 1);\n\n    vec3 p = z.xyz;\n    z.yz *= rot(-.5);\n    p.z -= sin(p.y * 1.5) * .1;\n\n    float mateid = 0.;\n    float d = max(abs(p.y + 1.8) - 2., length(p.xz) - .1 + smoothstep(0., 2., p.y) * 0.1);\n\n    float id = 0., f = 5. + fid * 4., spread = 1.8, dcap, i;\n    //z.xz = mul(rot(fid*.3), z.xz);\n\n    z.xz = fold(z.xz, f, id);\n    z.yz *= rot(spread);\n\n    for (i = 1.; i <= 6.; i += 1.)\n    {\n        vec4 res = dPedals(z.xyz, i, id, fid);\n        dcap = res.w / z.w;\n\n        if (dcap < d)\n        {\n            mateid = i < 2. ? 3. : 2.;\n            d = dcap;\n        }\n\n        z = vec4(z0, 1);\n        z.yz *= rot(-.5);\n        z.xz *= rot(0.3 * i);\n        z.xz = fold(z.xz, 7. + i + fid * 4., id);\n        z.yz *= rot(1.2);// - (i+1.)/100.);\n\n        if (i > 1.)z.zy += vec2(.1 * i, 0);\n        //z.z *= -1.;\n        z *= 1. + i * .5;// + 2.*i - 2.;\n    }\n\n    return vec2(d * .5, mateid);\n}\n\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), .0) + length(max(d, .0));\n}\n\n\nvec2 map(vec3 p)\n{\n    float mateid = 4.;\n\n    vec3 q = p - vec3(.87, 3., 1.82);\n\n    vec2 r0 = tree((q - vec3(.3,.1,2)) * .37); r0.x /= .37;\n    vec2 r1 = flower(1.8*(q + vec3(4.3, 1.8, -7)), 0.); r1.x /= 1.8;\n    vec2 r2 = flower(1.2 * (q + vec3(4.5, -.2, -3)), 1.); r2.x /= 1.2;\n\n\n    // begin: the grass land\n    q = p + vec3(-35, 4.5, 16);\n    q.y += HEIGHT(q.z);\n    vec2 r4 = vec2(fractal(q.xzy), 4.);\n    float s0 = box(p - vec3(6., 5, -23.5), vec3(1.5));\n    r4.x = max(r4.x, -s0);\n    // end: the grass land\n\n    // begin: the wall\n    p.xz *= rot(.1);\n    p.x = -abs(p.x+11.) - 9.8;\n    vec2 r6 = vec2(box(p + vec3(79,0,0), vec3(70, 1e5, 1e5)), 4.);\n\n    if (p.z > 5.)p.y -= sin(p.z * .2 + 3.) * 2.;\n    else p.y -= (abs(fract(p.z * .037) - .5) * 4. - 1.)*.5;\n    vec2 r5 = vec2(max(r6.x, mandelBox((p * .1 - vec3(-3., 3.5+smoothstep(10.,0.,p.z)*.3, 1.)), 2.) / .1), 5.);\n    // end: the wall\n\n\n    vec2 r = r0;\n    if (r1.x < r.x) r = r1;\n    if (r2.x < r.x) r = r2;\n    if (r4.x < r.x) r = r4;\n    if (r5.x < r.x) r = r5;\n\n    return r;\n\n}\n\n\nvec3 getMaterial(float id, vec3 p)\n{\n   if (id == MAT_GRASSLAND)\n    {\n        p = p + vec3(-35, 4.5, 16);\n        p.y += HEIGHT(p.z);\n        vec3 col = fractalMate(p.xzy);\n\n        col = mix(vec3(1.1, .1, 0), col, smoothstep(3.5, 4.9, p.y));\n        col = mix(vec3(.12, .3, .1), col, 1. - smoothstep(5., 25., p.y));\n\n        return col;\n    }\n    else if (id == MAT_TREE_TRUNK)\n    {\n        return  vec3(.169, .114, .081)*2.;\n    }\n    else if (id == MAT_TREE_LEAVES)\n    {\n        return vec3(2, .8, 0);\n    }\n    else if (id == MAT_FLOWER)\n    {\n        return vec3(.9, .1, .1);\n    }\n    else if (id == MAT_FLOWER_LEAVES)\n    {\n        return mix(vec3(.1, .25, .1), vec3(.8),fbm(p*5.)*.5);\n    }\n    else if (id == MAT_WALL)\n    {\n        return vec3(.69, .565, .451);\n    }\n    return vec3(1);\n}\n\nvec3 getNormal(vec3 p, float t)\n{\n    vec3 n = vec3(0);\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * map(p + .001 * e * t).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float s = 1.,t = .001;\n    for(int i = 0; i < 32; i++)\n    {\n        vec2 h = map(ro + rd * t);\n        if (h.y == MAT_FLOWER_LEAVES) h.x *= .35;\n        s = min(s, 16. * h.x / t);\n        if (h.x < 1e-4) break;\n        t += clamp(h.x, .01, .05);\n    }\n    return clamp(s, 0., 1.);\n}\n\nvec2 intersect(vec3 ro, vec3 rd)\n{\n    float rnd = .9 + .1 * hash21(seed++).x;\n    float t = .01;\n    vec2 res = vec2(1e9);\n    bool hit = false;\n    \n    for(int i = 0; i < 1024; ++i)\n    {\n        res = map(ro + t * rd);\n        res.x = abs(res.x) * rnd;\n        float k = res.y == 5. ? 10. : 1.;\n        if (res.x < .0005 * k + .0002 * t)\n        {\n            hit = true;\n            break;\n        }\n        if (t > 100.)\n        {\n            break;\n        }\n        \n        t += res.x;\n    }\n    if (!hit) t = -1.;\n\n    return vec2(t, res.y);\n}\n\nvec3 phongBrdf(vec3 toLight, vec3 toEye, vec3 normal, vec3 pos, vec3 albedo)\n{\n    float fre = .04 + .96 * pow(1. - max(0., dot(toLight, normalize(toLight + toEye))), 5.);\n\n    float spec = fre * 9. * pow(max(0., dot(reflect(-toLight, normal), toEye)), 16.);\n\n    return (.2 * spec + .8 * (1. - fre) * albedo) / PI;\n}\n\nvec3 getHemisphereSampleCosWeighted(vec3 n, vec2 s)\n{\n    vec3 o1 = normalize(abs(n.x) > abs(n.z) ? vec3(-n.y, n.x, 0.0) : vec3(0.0, -n.z, n.y));\n    vec3 o2 = normalize(cross(n, o1));\n    s.x = s.x * 2. * PI;\n    float oneminus = sqrt(1. - s.y);\n    return cos(s.x) * oneminus * o1 + sin(s.x) * oneminus * o2 + s.y * n;\n}\n\n\nfloat mapCloud(vec3 p)\n{\n    p *= .01;\n    return smoothstep(.1, 1., fbm(p * vec3(.5, 1, 1)) + .5 * fbm(p * 2.5));\n}\n\nvec3 renderCloud(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 skycol = vec3(.053, .001, .0001);\n    skycol = mix(skycol, vec3(0), smoothstep(.1, 1., fbm(vec3(uv * vec2(12, 60), 1))));\n\n    vec4 sum = vec4(0, 0, 0, 1);\n\n    float t = (100.0 - ro.y) / rd.y, dt = .2;\n\n    if (t < 0.) return skycol;\n\n    float rnd = .95 + .05 * hash21(seed++).x;\n\n    for (int i = 0; i < 64; ++i)\n    {\n        vec3 p = ro + t * rd;\n        float d = mapCloud(p) * rnd;\n\n        if (d > 0.)\n        {\n            float s = 0.;\n            vec3 st = normalize(p + sunDir);\n            vec3 sp = p;\n            for (int j = 0; j < 10; j++)\n                s += mapCloud(sp += st);\n\n            sum.xyz += exp(-s * .1) * d * vec3(1.5) * sunCol * (1. - d) * sum.a;\n            sum.a *= 1. - d;\n        }\n\n        if (sum.a < .1 || t > 1000.) break;\n\n        t += dt;\n        dt = max(1., .1 * t);\n    }\n    sum.xyz = mix(sum.xyz, skycol, smoothstep(0., 3., t / 800.));\n    return sum.xyz;\n}\n\nvec3 scene(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 throughput = vec3(1.), Lo = vec3(0), pos, q, n, albedo, nextRd, direct;\n\n    vec3 cloud = renderCloud(ro, rd, uv);\n    vec3 sky = cloud * vec3(.585, .014, .0015);;\n    sky = mix(sky, vec3(1, .2, 0), smoothstep(.1,1.,dot(cloud,cloud)));\n    sky = mix(vec3(0,.5,1) * .0005, sky, smoothstep(0.,1.,length((uv-vec2(.3,.4))*vec2(.5,1))-.1));\n\n    // bounces\n    for (int i = 0; i < 3; ++i)\n    {\n        vec2 hit = intersect(ro, rd);\n        q = pos = ro + hit.x * rd;\n\n        if (hit.x < 0.)\n        {\n            Lo = Lo + throughput * sky;\n            break;\n        }\n\n        n = getNormal(pos, hit.x);\n\n        albedo = getMaterial(hit.y, pos);\n\n        q.y -= HEIGHT(q.z);\n\n        float a = 0., b = 0.;\n        if (hit.y == MAT_TREE_TRUNK) a = .2, b = 30.;\n        if (q.y <= .05) a = .5, b = 100.;\n        if(a > 0.)\n            n = bump_mapping(q * a, n, b / max(iResolution.x, iResolution.y));\n\n        if (hit.y == MAT_TREE_LEAVES)\n            sunDir = normalize(vec3(-1, 1, 1));\n\n        float sha = shadow(pos + 0.001 * n, sunDir);\n        if (hit.y == MAT_TREE_LEAVES)\n            sha = smoothstep(.1, .8, sha);\n        \n        direct = (sunCol * phongBrdf(sunDir, -rd, n, pos, albedo) * max(0., dot(n, sunDir)) * sha);\n\n        if (hit.y == MAT_TREE_LEAVES)\n            direct += sunCol * max(0., dot(-n, sunDir)) * albedo * 0.3 *sha;\n\n        Lo += throughput * direct;\n\n        // Further bounces only for tree and flower\n        if (hit.y > MAT_FLOWER) break;\n\n        // Sample brdf\n        nextRd = normalize(getHemisphereSampleCosWeighted(n, hash21(seed++)));\n        float pdf = max(0., dot(n, nextRd)) / PI;\n        if (pdf < .0001) break;\n\n        throughput *= phongBrdf(nextRd, -rd, n, pos, albedo) * max(0., dot(nextRd, n)) / pdf * (hit.y == 0. ? .2 : 1.);\n                                  \n        rd = nextRd;\n        ro = pos + .002 * n;\n    }\n\n    return Lo;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = float(iFrame) + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n\n    vec2 offset = -.5 + hash21(seed++);\n    vec2 p = (fragCoord + offset) / iResolution.xy; \n    p = 2. * p - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // partial rendering, only render 16 scanlines per frame\n    float lineCount = ceil(iResolution.y / 16.);\n    int line = int(fragCoord.y / iResolution.y * lineCount);\n    \n    vec4 prevCol = texelFetch( iChannel0, ivec2(fragCoord), 0);\n    if(iFrame == 0) prevCol = vec4(0);\n    \n    if(line != iFrame % int(lineCount)) \n    {\n        fragColor = prevCol;\n        return;\n    }\n\n    vec3 ro = vec3(-4.76, 4.86, 29.46);\n    vec3 ta = vec3(-4.72, 4.87, 28.46);\n\n    vec3 forward = normalize(ta - ro);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n\n    vec3 rd = normalize(p.x * right + p.y * up + 1.8 * forward);\n\n    // Blend with previous samples\n    fragColor = vec4(mix(prevCol.xyz, scene(ro,rd,p), 1./(prevCol.w+1.)), prevCol.w+1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}