{
    "Shader": {
        "info": {
            "date": "1532085232",
            "description": "gamepad with slightly optimized symmetry for better .\nEach color/pieve also got its own subroutine to more easily take this thing apart.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltdczM",
            "likes": 6,
            "name": "gamepad mildly optimized",
            "published": 3,
            "tags": [
                "symmetry",
                "gamepad"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 510
        },
        "renderpass": [
            {
                "code": "\n//self: https://www.shadertoy.com/view/ltdczM\n//parent: https://www.shadertoy.com/view/ltXcDr\n//3d shape gamepad(symmetry code looks suboptimal)\n\n// CREATED BY KIM BERKEBY,SEP 2017\n\n#define rotate(a)mat2(cos(a),-sin(a),sin(a),cos(a))\n\n // pad top,buttons,cross,cable,sticks,shoulder buttons\n const vec4[10] partColor=vec4[](vec4(.65,0.14,0.14,0.6),// pad top\n vec4(0.5,0.14,.14,0.6),//buttons\n vec4(.3,0.3,0.3,0.5),//cross\n vec4(0.2,0.2,0.2,0.35),//cable\n vec4(.3,0.3,0.3,0.4),//sticks\n vec4(0.5,0.5,.5,0.6),// shoulder buttons\n vec4(.3,0.3,0.3,0.5),// start/select\n vec4(.3,0.3,0.3,0.4),// pad bottom\n vec4(0.5,0.5,.5,0.6),//buttons left\n vec4(.35,.35,.34,0.3));// ground\n\nconst vec3 eps=vec3(0.02,0.0,0.0);\nconst int maxRaySteps=512;\n\n\nstruct RayHit{bool hit;vec3 hitPos;vec3 normal;float dist;float depth;float steps;int hitID;};\n\nRayHit marchResult;\n\n\nfloat sdBox(vec3 p,vec3 b){vec3 d=abs(p)-b;return min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0));}\n\nfloat sdTriPrism(vec3 p,vec2 h){vec3 q=abs(p);return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r\n){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h)-r;}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b\n){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h);}\n\n\nfloat Cable(vec3 p,vec3 a,vec3 b,float r\n){vec3 pa=p-a;b.xz=mix(b.xz,b.xz*rotate(1.1),smoothstep(1.0,6.0,pa.z))\n ;b.xz=mix(b.xz,b.xz*rotate(-1.20),smoothstep(1.0,14.0,pa.z))\n ;b.y=mix(b.y,-1.55,smoothstep(.0,1.0,pa.z))\n ;vec3 ba=b-a\n ;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0)\n ;return length(pa-ba*h)-r;}\n\n\nfloat sdCappedCylinder(vec3 p,vec2 h){vec2 d=abs(vec2(length(p.xz),p.y))-h;return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdEllipsoid(in vec3 p,in vec3 r){return(length(p/r)-1.0)*min(min(r.x,r.y),r.z);}\n\n\nvec3 opRotXY(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.xy*=rotate(rad);return sPos+rayPos;}\nvec3 opRotXZ(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.xz*=rotate(rad);return sPos+rayPos;}\nvec3 opRotYZ(vec3 pos,vec3 rayPos,float rad){vec3 sPos=rayPos-pos;sPos.yz*=rotate(rad);return sPos+rayPos;}\n\n\n\nfloat ControllerBase(vec3 q,float oScale\n){q.x=abs(q.x)\n ;float d=sdCappedCylinder(q-vec3(1.4,-.04,0),vec2(1,.12)*oScale)\n ;d=min(d,sdCappedCylinder(q-vec3(.35,0,-.4),vec2(.5,.08)*oScale))\n ;d=min(d,sdBox(q-vec3(0,0,.2),vec3(1,.08,.7)*oScale))\n ;d=min(d,sdBox(q-vec3(0,0,.2),vec3(.5,.07,.79)*oScale))\n ;d=max(d,-sdBox(q-vec3(0,0,1.1),vec3(.2,1.08,.15)*oScale))\n ;return d;}\n\nfloat ShoulderButtons(in vec3 p,float controllBase,float oScale\n){\n ;vec3 q=p;q.x=abs(q.x)\n ;float d=sdCappedCylinder(q-vec3(1.45,-.1,.10),vec2(1,.12)*oScale)\n ;d=max(d,-sdBox(q-vec3(2.5,0,.42),vec3(.4,1.08,2.9)*oScale))\n ;d=-max(-d,-sdBox(p-vec3(0,-.1,.2),vec3(1.6,.08,.8)*oScale))\n ;d=max(d,-sdBox(p-vec3(0,0,.42),vec3(1.2,1.08,2.9)*oScale))\n ;d=max(d,-sdBox(p-vec3(0,0,-.42),vec3(3.,.68,1.)*oScale))\n ;return d;}\n\n\nint objectID =0;\n\nfloat dd5(vec3 q){//2 analog sticks\n ;q.x=abs(q.x);\n ;float d5=sdEllipsoid(q-vec3(.35,-.35,.50),vec3(.3,.18,.3))\n ;d5=min(d5,sdCappedCylinder(q-vec3(.35,-.35,.5),vec2(.15,.3)))\n ;d5=min(d5,sdEllipsoid(q-vec3(.35,-.05,.5),vec3(.22,.03,.22)))\n ;return d5;}\n\nfloat dd2(vec3 p){// buttons\n ;float d2=sdCappedCylinder(p-vec3(-1.45,-.3,1.40),vec2(.18,.12)) \n ;d2=max(d2,-sdEllipsoid(p-vec3(-1.45,-.16,1.40),vec3(.25,.04,.25)))\n ;d2=max(d2,-sdEllipsoid(p-vec3(-1.90,-.16,1),vec3(.25,.04,.25)))\n ;d2=min(d2,sdCappedCylinder(p-vec3(-1.90,-.3,1.0),vec2(.18,.12)))\n ;return d2;}\n  \nfloat dd3(vec3 p){// cross\n ;float d3=sdEllipsoid(p-vec3(1.55,-.265,1),vec3(.46,.06,.46))\n ;d3=min(d3,sdBox(p-vec3(1.55,-.22,1.0),vec3(.4,.06,.13)))\n ;d3=min(d3,sdBox(p-vec3(1.55,-.22,1.0),vec3(.13,.06,.4)))\n ;d3=max(d3,-sdEllipsoid(p-vec3(1.55,-.2,1.0),vec3(.16,.04,.16)))\n ;vec3 pPos=p-vec3(1.55,-.13,1.25)// calculate button arrows and perform boolean\n ;pPos.xz*=rotate(radians(120.))\n ;pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.55,-.13,.75);pPos.xz*=rotate(radians(300.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.8,-.13,1.);pPos.xz*=rotate(radians(210.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)));pPos=p-vec3(1.3,-.13,1.);pPos.xz*=rotate(radians(30.));pPos.zy*=rotate(radians(90.))\n ;d3=max(d3,-sdTriPrism(pPos,vec2(.15,.05)))\n ;return d3;}\n\nfloat dd7(vec3 p){// start select buttons\n ;float d7=sdCapsule(p-vec3(-.1,-.25,1.4),vec3(0,0,-.15),vec3(-.22,0,.05))\n ;d7=min(d7,sdCapsule(p-vec3(.45,-.25,1.4),vec3(0,0,-.15),vec3(-.22,0,.05)))\n ;return d7-.095;}\n \nfloat dd8(vec3 p){\n ;float d8=ControllerBase(p-vec3(0,-.51,1),1.05)\n ;d8=min(d8,sdCappedCylinder(p-vec3(-1.45,-.25,1),vec2(.765,.03)))\n ;d8=min(d8,sdEllipsoid(p-vec3(-1.45,-.25,1),vec3(.7,.1,.7)))\n ;// button holes\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.45,-.18,1.4),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.45,-.18,.60),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1.9,-.18,1),vec3(.32,.06,.32)))\n ;d8=max(d8,-sdEllipsoid(p-vec3(-1,-.18,1),vec3(.32,.06,.32)))\n ;return d8;}\n \nfloat dd9(vec3 p){\n ;float d9=sdCappedCylinder(p-vec3(-1.45,-.3,.6),vec2(0.18,.12))\n ;d9=max(d9,-sdEllipsoid(p-vec3(-1,-.16,1),vec3(.25,.04,.25)))\n ;d9=min(d9,sdCappedCylinder(p-vec3(-1,-.3,1),vec2(.18,.12)))\n ;d9=max(d9,-sdEllipsoid(p-vec3(-1.45,-.16,.6),vec3(.25,.04,.25)))//2 red buttons,diagonal mirror \n ;return d9;}\n \nfloat dd1(vec3 p){\n ;vec3 q=p;q.x=abs(q.x)\n ;float d=ControllerBase(p-vec3(0,-0.3,1),1.)\n ;d=max(d,-sdCappedCylinder(p-vec3(-1.45,-0.22,1.0),vec2(0.8,0.02)));// button ring\n ;d=max(d,-sdEllipsoid(p-vec3(1.55,-.22,1),vec3(.7,.1,.7)))// cross cutout\n ;d=max(d,-sdEllipsoid(p-vec3(1.55,-.22,1),vec3(1,.03,1)))// cross cutout\n ;d=max(d,-sdCapsule(p-vec3(0,-.4,2.1),vec3(0,0,-.5),vec3(0,0,3.))-.13)// cable input\n ;d=min(d,sdCapsule(p-vec3(0,-.39,2.07),vec3(0,0,-.1),vec3(0,0,-.1))-.11)// cable input\n ;d=max(d,-sdEllipsoid(q-vec3(.35,-.15,.5),vec3(.4,.2,.4)))// analog buttons\n ;d=max(d,-sdCapsule(p-vec3(-.1,-.06,1.4),vec3(0,0,-.15),vec3(-22,0,.05))-.2)// start select cutouts\n ;d=max(d,-sdCapsule(p-vec3(.45,-.06,1.4),vec3(0,0,-.15),vec3(-22,0,.05))-.2)// start select cutouts\n ;return d;}\n\nfloat Map(in vec3 p\n){\n ;float d =dd1(p)\n ;float d2=dd2(p)\n ;float d3=dd3(p)\n ;float d5=dd5(p)\n ;float d6=ShoulderButtons(p-vec3(0,-0.3,1),d,1.)\n ;float d7=dd7(p)\n ;float d8=dd8(p)\n ;float d9=dd9(p) \n ;float d4=sdCapsule(p-vec3(0,-.39,2.07),vec3(0),vec3(0))-.11// cable\n ;d4=min(d4,Cable(p-vec3(0,-.4,2.1),vec3(0,0,-1),vec3(0,0,70),.072))\n \n ;objectID =1 \n ;if(d2<d){objectID =2;d=d2;}\n ;if(d3<d){objectID =3;d=d3;}\n ;if(d4<d){objectID =4;d=d4;}\n ;if(d5<d){objectID =5;d=d5;}\n ;if(d6<d){objectID =6;d=d6;}\n ;if(d7<d){objectID =7;d=d7;}\n ;if(d8<d){objectID =8;d=d8;}\n ;if(d9<d){objectID =9;d=d9;}\n\n\n ;if(p.y+0.75<d){ d=p.y+0.75;objectID =10;}return d;}\n\nvec3 calcNormal(in vec3 pos\n){return normalize(vec3(Map(pos+eps.xyy)-Map(pos-eps.xyy),0.5*2.0*eps.x,Map(pos+eps.yyx)-Map(pos-eps.yyx)));}\n\nfloat SoftShadow(in vec3 origin,in vec3 direction\n){float res=2.0\n ;float t=0.0\n ;float hardness=6.0\n ;for(int i=0;i<64;i++\n){float h=Map(origin+direction*t)\n  ;res=min(res,hardness*h/t)\n  ;t +=clamp(h,0.02,0.10)\n  ;if(h<0.001)break;}return clamp(res,0.0,1.0);}\n\nRayHit March(in vec3 origin,in vec3 direction\n){RayHit result\n ;objectID =0\n ;float maxDist=100.0,precis=0.001\n ;float t=0.0,dist=0.0,distStep=1.0\n ;vec3 rayPos=vec3(0)\n ;for(int i=0;i<maxRaySteps;i++\n){rayPos =origin+direction*t\n  ;dist=Map(rayPos)\n  ;if(abs(dist)<precis||t>maxDist\n ){result.hit=true\n   ;result.depth=t\n   ;result.dist=dist\n   ;result.hitPos=origin+((direction*t)*0.99)\n   ;result.steps=float(i)\n   ;result.hitID=objectID\n   ;break;}\n  ;t+=dist*distStep;}\n if(t>maxDist){result.hit=false;}\n ;return result;}\n\n// Thanks to Inigo Quilez\nmat3 setCamera(in vec3 ro,in vec3 ta,float cr\n){vec3 cw=normalize(ta-ro)\n ;vec3 cp=vec3(sin(cr),cos(cr),0.0)\n ;vec3 cu=normalize(cross(cw,cp))\n ;vec3 cv=normalize(cross(cu,cw))\n ;return mat3(cu,cv,cw);}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord\n){vec2 mo=iMouse.xy/iResolution.xy\n ;vec2 uv=fragCoord.xy/iResolution.xy\n ;vec2 screenSpace=(-iResolution.xy+2.0*(fragCoord))/iResolution.y\n ;float camrot=0.5*iTime\n ;if(iMouse.w>0.1)camrot=0.0\n ;vec3 rayOrigin=vec3(-0.5+3.5*cos(camrot+6.0*mo.x),1.0+2.0,0.5+4.0*sin(camrot+6.0*mo.x))\n ;mat3 ca=setCamera(rayOrigin,vec3(0.0,-0.9,0.5),0.0)\n ;vec3 rayDir=ca*normalize(vec3(screenSpace.xy,2.0))\n ;vec4 color =vec4(0)\n ;marchResult=March(rayOrigin,rayDir)\n ;if(marchResult.hit\n){marchResult.normal=calcNormal(marchResult.hitPos)\n  ;// calculate light and shadows\n  ;vec3 light1=vec3(1.3,3.8,1.0)\n  ;vec3 light2=vec3(-1.,1.,.0)\n  ;vec4 light1Color=vec4(1.0)\n  ;vec4 light2Color=vec4(1.0)\n  ;float diff=clamp(dot(marchResult.normal,normalize(light1)),0.0,1.0)\n  ;float diff2=clamp(dot(marchResult.normal,normalize(light2)),0.0,0.50)\n  ;float shadow=SoftShadow(marchResult.hitPos,normalize(light1))\n  ;float amb=clamp(0.5+0.5*marchResult.normal.r,0.0,1.0)*1.0\n  ;vec3 lin=vec3(0.0)\n  ;lin+=diff*light1Color.rgb*shadow\n  ;lin+=diff2*light2Color.rgb\n  ;lin+=amb*vec3(0.40)\n  ;vec4 col =partColor[marchResult.hitID-1]\n  ;// reflections in floor\n  ;if(marchResult.hitID==10\n ){vec3 refDir=normalize(reflect(rayDir,marchResult.normal))\n   ;RayHit reflectResult=March(marchResult.hitPos+(refDir*0.001),refDir)\n   ;if(reflectResult.hit==true){col=mix(col,col+(col* partColor[reflectResult.hitID-1]),.35);}}\n  ;float rim=clamp(1.0+dot(marchResult.normal,rayDir),0.0,1.0)\n  ;vec4 ref=vec4(.5);//vec4(texture(iChannel0,marchResult.normal+rayDir).rgb,1.0)\n  ;ref +=rim*pow(0.5,2.0)\n  ;ref /=pow(2.0,col.a)\n  ;color=col*vec4(lin,1.0)// apply lightning\n  ;color.rgb=mix((color.rgb+(color.rgb*ref.rgb))*col.a,(color.rgb+vec3(1.4))*col.a,pow(marchResult.normal.r,2.0));}\n ;fragColor=vec4(pow(color.rgb,vec3(1.0/0.9)),1.0)*(0.5+0.5*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.2))\n ;// fragColor=vec4(marchResult.normal,1.0)\n ;}\n\n\n\n/*\nvoid mainImage(out vec4 o,vec2 i \n){o=vec4(fract(iDate.w))\n;}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}