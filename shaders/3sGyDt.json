{
    "Shader": {
        "info": {
            "date": "1603968667",
            "description": "#5 Sky\nmade during the Ink-MAC-tober 2020",
            "flags": 0,
            "hasliked": 0,
            "id": "3sGyDt",
            "likes": 5,
            "name": "upsideDownClouds",
            "published": 3,
            "tags": [
                "raymarching",
                "volumetric",
                "imac"
            ],
            "usePreview": 0,
            "username": "Kaeylos",
            "viewed": 343
        },
        "renderpass": [
            {
                "code": "// inspired by iq, shane and otherds\n// https://www.shadertoy.com/view/XslGRr\n// https://www.shadertoy.com/view/MscXRH\n\n// #define LOW_QUALITY\n#define CLOUDS_LOD\n#define FBM_MAX_ITER  10\n\n#define MOUSE\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t*s*s)/2.); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat max2(vec2 v) { return max(v.x , v.y); }\nfloat max3(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult2(vec2 v) { return v.x*v.y; }\nfloat mult3(vec3 v) { return v.x*v.y*v.z; }\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nfloat density(vec3 pos, int lod) {\n\tvec3 q = pos - vec3(0.1,0.1,0.4)*iTime;\n\tfloat f = fbm(q, 1., lod);\n\tfloat f2 = fbm(q + vec3(100.), 1., lod);\n\treturn f * (smoothstep(1.5, 2., pos.y + f) + 1. - smoothstep(-1., -0.2, pos.y - 1.5*f2));\n    // return clamp( -0.5 - pos.y + 2.*f, 0.0, 1.0 );\n}\n\nvec4 cloudsMarching(vec3 ro, vec3 rd, vec3 bgCol, vec3 sundir, int steps) {\n\n\tfloat t = 0.;\n\tvec4 sum = vec4(0.);\n#ifdef LOW_QUALITY\n\tsteps = steps/2;\n#endif\n\n\tfor(int i=0; i<steps; i++) {\n\t\tvec3 pos = ro + t*rd;\n\t\t// clamp computation space\n\t   \tif( abs(pos.y)>3. || sum.a>0.99 ) break;\n\n#ifdef LOW_QUALITY\n\t\tint lod = 1;\n#else\n#ifdef CLOUDS_LOD\n\t    int lod = int(exp(-0.005*float((i-350))));\n#else\n\t    int lod = 3;\n#endif\n#endif\n\t\tfloat den = density(pos, lod);\n\t   \tif( den>0.01 ) {\n\t\t\t\n\t\t\t// mix color using density\n\t\t\tvec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n\t\t\t\n        \t// fake lighting using diff of density throught ou sunDir\n\t\t\tfloat dif = clamp((den - density(pos+0.3*sundir, lod))/0.3, 0.0, 1.0 );\n\t\t\tvec3 lin = vec3(0.91,0.98,1.1) + vec3(1.0,0.6,0.3)*dif;\n\t\t\tvec3 lightColor = mix(vec3(0.91,0.98,1.1), vec3(0.65,0.55,0.52)*2.4,dif*1.3);\n\t\t\t\n\t\t\tcol.xyz *= lightColor;\n\t\t\t// exponential decresing of density (mixing with bgcol)\n\t\t\tcol.xyz = mix( col.xyz, bgCol, 1.0-exp(-0.002*t*t) );\n\t\t\tcol.w *= 0.5; // reduce density alpha\n\t\t\tcol.rgb *= col.a; // apply alpha\n\t\t\tsum += col*(1.0-sum.a);\n\t\t}\n\t// Enforce minimum stepsize. This is probably the most important part of the procedure.\n#ifdef LOW_QUALITY\n\tt += max(0.1,0.05*t);\n#else\n\tt += max(0.05,0.02*t);\n#endif\n\t}\n\treturn sum;\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvec4 render(vec3 O, vec3 D) {\n\n\tvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\t\n\tvec3 col = vec3(0.67,0.8,0.9) - D.y*0.4*vec3(0.5,0.2,0.8); // background sky color\n\tfloat sun = clamp( dot(sundir,D), 0.0, 1.0);\n\tcol += 0.3*vec3(1.0,.6,0.1)*pow(sun, 10.0); // add sun\n\n    vec4 res = clamp(cloudsMarching(O, D, col, sundir, 150), 0., 1.);\n    col = col*(1.0-res.w) + res.xyz;// clouds\n     \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 ); // sun glare   \n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.5; // zoom\n\n#ifdef MOUSE\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    // camera pos\n    vec3 O = 4.0*normalize(vec3(sin(2.5*m.x+1.), 0.15+m.y*0.15, cos(2.5*m.x+1.)));\n#else\n\tvec3 O = 4.0*vec3(2.5, 0.15, 1.);\n#endif\n    vec3 D = computeCamDir(uv, O, vec3(0., 1., 0.), vec3(0.));\n    \n    fragColor = render(O, D);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}