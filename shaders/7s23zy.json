{
    "Shader": {
        "info": {
            "date": "1618515011",
            "description": "dod",
            "flags": 32,
            "hasliked": 0,
            "id": "7s23zy",
            "likes": 2,
            "name": "dodic",
            "published": 3,
            "tags": [
                "dod"
            ],
            "usePreview": 0,
            "username": "dark_dashas",
            "viewed": 138
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv) / float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv) + texture(iChannel2, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/* tracing functions*/\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)  \n{\n    normal = vec3(0.0, 1.0, 0.0);\n    float t = (-1.25 - pos.y) / dir.y;\n    if (t <= 0.0) return INF;\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) return INF;\n    return t;\n}\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) \n{\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) return INF;\n    float t = (-b - sqrt(D));\n    if (t > 0.0) \n    {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = (-b + sqrt(D));\n    if (t < 0.0) return INF;\n    normal = normalize(pos + t * dir);\n    return t;\n}\nfloat traceTriangle(Triangle t, vec3 origin, vec3 dir, out vec3 norm) \n{\n    vec3 d1 = t.pos[1] - t.pos[0];\n    vec3 d2 = t.pos[2] - t.pos[0];\n    norm = normalize(cross(d1, d2));\n    float normalViewAngle = dot(dir, norm);\n    if (abs(normalViewAngle) < EPS) return INF;\n    float d = dot(t.pos[0] - origin, norm) / normalViewAngle;\n    if (d < 0.0) return INF;\n    vec3 hitPos = origin + dir * d;\n    vec3 toHitVecs[3] = vec3[3](hitPos - t.pos[0], hitPos - t.pos[1], hitPos - t.pos[2]);\n    vec3 edges[3] = vec3[3](t.pos[1] - t.pos[0], t.pos[2] - t.pos[1], t.pos[0] - t.pos[2]);\n    float square = length(cross(edges[0], edges[1]));\n    float testSq[3] = float[3]( length(cross(toHitVecs[0], edges[0])),\n        length(cross(toHitVecs[1], edges[1])), length(cross(toHitVecs[2], edges[2])));\n    if (abs(square - testSq[0] - testSq[1] - testSq[2]) < EPS) return d;\n    return INF;\n}\nfloat traceDod(vec3 pos, vec3 dir, out vec3 norm) \n{\n    vec3 curNorm;\n    float t = INF, curT;\n    for (int i = 0; i < 36; i++) \n    {\n        Triangle curTr;\n        for (int j = 0; j < 3; j++) \n        {\n            curTr.pos[j] = vertList[triagList[i * 3 + j] - 1];\n        }\n        curTr.pos[0].y += 0.4;\n        curTr.pos[1].y += 0.4;\n        curTr.pos[2].y += 0.4;\n        curTr.pos[0].x += 0.25;\n        curTr.pos[1].x += 0.25;\n        curTr.pos[2].x += 0.25;\n        curTr.pos[0].xy = rotate(curTr.pos[0].xy, 0.55);\n        curTr.pos[1].xy = rotate(curTr.pos[1].xy, 0.55);\n        curTr.pos[2].xy = rotate(curTr.pos[2].xy, 0.55);\n        curTr.pos[0].xz = rotate(curTr.pos[0].xz, 0.8);\n        curTr.pos[1].xz = rotate(curTr.pos[1].xz, 0.8);\n        curTr.pos[2].xz = rotate(curTr.pos[2].xz, 0.8);\n        curT = traceTriangle(curTr, pos, dir, curNorm);\n        if (curT < t) \n        {\n            t = curT;\n            norm = curNorm;\n        }\n    }\n    return t;\n}\nfloat tracePod(vec3 pos, vec3 dir, out vec3 norm)\n{\n    vec3 curNorm;\n    float t = INF, curT;\n    for (int i = 0; i < 8; i++) \n    {\n        Triangle curTr;\n        for (int j = 0; j < 3; j++) \n        {\n            curTr.pos[j] = vertListPod[triagListPod[i * 3 + j] - 1];\n        }\n        curT = traceTriangle(curTr, pos, dir, curNorm);\n        if (curT < t) \n        {\n            t = curT;\n            norm = curNorm;\n        }\n    }\n    return t;\n}\n\n\n/*building*/\nfloat MARCH_SIZE = 0.1;\nint MAX_STEPS = 100;\n\nfloat opS( float a, float b )\n{\n    return max( -b, a );\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 calcNormal( in vec3 pos, vec3 b )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdBox( pos + e.xyy, b ) + \n\t\t\t\t\t  e.yyx*sdBox( pos + e.yyx, b ) + \n\t\t\t\t\t  e.yxy*sdBox( pos + e.yxy, b ) + \n\t\t\t\t\t  e.xxx*sdBox( pos + e.xxx, b ) );\n}\nfloat sdBBox(vec3 p) {\n    float d1 = sdBox(p, vec3(0.3, 0.3, 0.3));\n    float d2 = sdBox(p + vec3(0, 0, 0.3), vec3(0.1, 0.1, 0.1));\n    return opS( d1, d2 );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdBBox( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sdBBox( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sdBBox( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sdBBox( pos + e.xxx ) );\n}\nfloat marchBbox(in vec3 ro, in vec3 rd, vec3 b, bool box, out vec3 norm) \n{\n    float dist;\n    float t = EPS;\n    for (int i = 0; i < MAX_STEPS; i++) \n    {\n        float res;\n        if (box) res = sdBox(ro + rd * t, b);\n        else res = sdBBox(ro + rd * t);\n        if(res < EPS || t > INF) {\n            if (box) norm = calcNormal(ro + rd * t, b);\n            else norm = calcNormal(ro + rd * t);\n            break;\n        }\n        t += res;\n    }\n    if (t > INF) return INF;\n    return t;\n}\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.34;\n\t\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\nvec3 calcNormal( in vec3 pos, float h )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sdPyramid( pos + e.xyy, h ) + \n\t\t\t\t\t  e.yyx*sdPyramid( pos + e.yyx, h ) + \n\t\t\t\t\t  e.yxy*sdPyramid( pos + e.yxy, h ) + \n\t\t\t\t\t  e.xxx*sdPyramid( pos + e.xxx, h ) );\n}\nfloat marchPyr(in vec3 ro, in vec3 rd, out vec3 norm) \n{\n    float dist;\n    float t = EPS;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float res = sdPyramid(ro + rd * t, 0.6);\n        if(res < EPS || t > INF) {\n            norm = calcNormal(ro + rd * t, 0.6);\n            break;\n        }\n        t += res;\n    }\n    if (t > INF) return INF;\n    return t;\n}\n\n\n/*lighting*/\nbool isOccluded(vec3 pos, vec3 target)\n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 dodNorm;\n    float dodT = traceDod(pos, dir, dodNorm);\n    if (dodT < dist) return true;\n    \n    vec3 podNorm;\n    float podT = tracePod(pos, dir, podNorm);\n    if (podT < dist) return true;\n    return false;\n}\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) \n{\n    vec3 lighting = texture(iChannel2, normal).rgb;\n    for (int i = 0; i < lightsCounter; i++)\n    {\n        vec3 toLight1 = Lights[i].pos - pos;\n        float distSq1 = dot(toLight1, toLight1);\n        float att1 = isOccluded(pos, Lights[i].pos + randDir * Lights[i].rad) \n                ? 0.0 : Lights[i].intensity / distSq1;\n        lighting += max(0.0, dot(normal, normalize(toLight1))) * att1 * Lights[i].color;\n    }\n    return color * lighting;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy + (randVals.xy - 0.5) * 2.0) / iResolution.x; \n    \n    Lights[0].pos = vec3(-3, 1.5, 2);// + randVals * 0.3; \n    Lights[0].color = vec3(0xf0, 0xea, 0xd2) / 255.0;\n    Lights[0].rad = 0.5;\n    Lights[0].intensity = 15.0;\n    \n    Lights[1].pos = vec3(3, 2, 1);// + randVals * 0.15;\n    Lights[1].color = vec3(0xdd, 0xa1, 0x5e) / 255.0; \n    Lights[1].rad = 0.25;\n    Lights[1].intensity = 10.0;\n    \n    Lights[2].pos = vec3(-2, 1.6, 7);// + randVals * 0.3;\n    Lights[2].color = vec3(0xb5, 0xc9, 0x9a) / 255.0; \n    Lights[2].rad = 0.2;\n    Lights[2].intensity = 15.0;\n    \n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + uv.x * right + uv.y * up); \n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n\n    float n1 = AIR_N;\n    float n2 = DIAMOND_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 10; ++i) \n    {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t) \n        {\n            t = planeT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * viewVec + curPos;\n            colorMult *= vec3(0xe9, 0xf5, 0xdb) / 255.0;\n            color = texture(iChannel1, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        \n        for (int i = 0; i < lightsCounter; ++i) \n        {\n            vec3 lightNorm;\n            float lightT = traceSphere(curPos - Lights[i].pos, curDir, Lights[i].rad, lightNorm);\n            if (lightT < t) \n            {\n                t = lightT;\n                materialType = EMISSION;\n                color = Lights[i].color;\n                normal = lightNorm;\n            }\n        }\n        \n        vec3 dodNorm;\n        float dodT = traceDod(curPos, curDir, dodNorm);\n        if (dodT < t) \n        {\n            t = dodT;\n            normal = dodNorm;\n            if (randVals.x * 0.5 < DIAMOND_R * 3.0) materialType = REFLECTION;\n            else materialType = REFRACTION;\n        }\n        \n        vec3 podNorm;\n        float podT = tracePod(curPos, curDir, podNorm);\n        if (podT < t) \n        {\n            t = podT;\n            normal = podNorm;\n            materialType = REFLECTION;\n            colorMult *= vec3(0xdd, 0xa1, 0x5e) / 255.0; \n        }\n        \n        if (randVals.x < 0.8)\n        {\n            vec3 tmpPos = curPos + randVals * 0.06;\n            vec3 bNorm;\n            float buildingT = marchBbox(tmpPos + vec3(0, -0.3, 0), curDir, vec3(0), false, bNorm);\n            if (buildingT < t) \n            {\n                normal = bNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = texture(iChannel0, worldPos.xy).rgb;\n                t = buildingT;\n                materialType = DIFFUSE;\n            }\n\n            vec3 windowNorm;\n            float windowT = marchBbox(tmpPos + vec3(0, -0.3, 0.2), curDir, \n                    vec3(0.1, 0.1, 0.05), true, windowNorm);\n            if (windowT < t) \n            {\n                normal = windowNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = vec3(0.9, 0.9, 0.5);\n                t = windowT;\n                materialType = EMISSION;\n            }\n\n            vec3 pNorm;\n            float roofT = marchPyr(tmpPos + vec3(0, -0.6, 0), curDir, pNorm);\n            if (roofT < t) \n            {\n                normal = pNorm;\n                vec3 worldPos = t * viewVec + tmpPos;\n                color = texture(iChannel3, worldPos.xy).rgb;\n                t = roofT;\n                materialType = DIFFUSE;\n            }\n        }\n\n        if (t != INF) \n        {\n            vec3 worldPos = t * curDir + curPos;\n            \n            if (materialType == EMISSION) \n            {\n                fragColor.rgb = color * colorMult;\n                break;\n            }\n            else if (materialType == DIFFUSE)\n            {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            }\n            else if (materialType == REFLECTION) \n            {\n                curDir = reflect(curDir,normal);\n                curPos = worldPos + curDir * 1e-3;\n            }\n            else if (materialType == REFRACTION) \n            {\n                curDir = refraction(curDir, normal, n1, n2);\n                curPos = worldPos + curDir * 1e-4;\n                float swap = n1;\n                n1 = n2;\n                n2 = swap;\n            }\n        }\n        else fragColor.rgb = texture(iChannel2, curDir).rgb * colorMult;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define PI 3.14159265359\n#define PHI (1.618033988749895)\n\n\nconst float INF = 1e10;\nconst float EPS = 1e-3;\nvec3 randDir;\nconst vec3 CAMERA_POS = vec3(3, 4, -7);\n\n\n/*materials*/\nconst int EMISSION = 0;   \nconst int DIFFUSE = 1;    \nconst int REFLECTION = 2; \nconst int REFRACTION = 3; \nconst int MINECRAFT = 4;\n\n\n/*refraction*/\nconst float DIAMOND_N = 2.5;\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) normal = -normal;\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0) return reflect(v, normal);\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\n/*figure structures*/\nstruct Sphere {\n    vec3 pos;\n    vec3 color;\n    float rad;\n    float intensity;\n};\nstruct Triangle \n{\n    vec3 pos[3];\n    vec3 normal;\n};\n\n/*podstavka verts*/\nvec3[6] vertListPod = vec3[6](\n  vec3( 0.0, -1,     2.2), \n  vec3( 0.0, -1.25,  2.2), \n  vec3(-1.5, -1,    -0.8), \n  vec3(-1.5, -1.25, -0.8), \n  vec3( 1.5, -1,    -0.8), \n  vec3( 1.5, -1.25, -0.8)\n);\nint[24] triagListPod = int[](\n    1, 3, 5,\n    2, 4, 6,\n    1, 2, 3,\n    2, 3, 4,\n    3, 4, 5,\n    4, 5, 6,\n    1, 2, 5,\n    2, 5, 6\n);\n\n/*pyramide verts\nvec3[4] vertListPyr = vec3[4](\n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n);\nint[18] triagListPyr = int[](\n    \n);\n*/\n\n/*cube verts\nvec3[8] vertListCube = vec3[20](\n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(), \n  vec3(),\n);\nint[36] triagListCube = int[](\n    \n);\n*/\n\n\n/*dodecahedron verts*/\nvec3[20] vertList = vec3[20](\n  //blue\n  vec3( 1.0/PHI, 0.0,  PHI), //up right\n  vec3(-1.0/PHI, 0.0,  PHI), //up left\n  vec3( 1.0/PHI, 0.0, -PHI), //down right\n  vec3(-1.0/PHI, 0.0, -PHI), //down left\n  \n  //green\n  vec3(0.0,  PHI,  1.0/PHI), //up right\n  vec3(0.0, -PHI,  1.0/PHI), //up left\n  vec3(0.0,  PHI, -1.0/PHI), //down right\n  vec3(0.0, -PHI, -1.0/PHI), //down left\n  \n  //pink\n  vec3( PHI,  1.0/PHI, 0.0), //far right\n  vec3(-PHI,  1.0/PHI, 0.0), //far left\n  vec3( PHI, -1.0/PHI, 0.0), //near right\n  vec3(-PHI, -1.0/PHI, 0.0), //near left\n  \n  //orange\n  vec3( 1,  1,  1), \n  vec3( 1,  1, -1),\n  vec3( 1, -1,  1),\n  vec3( 1, -1, -1),\n  vec3(-1,  1,  1),\n  vec3(-1,  1, -1),\n  vec3(-1, -1,  1),\n  vec3(-1, -1, -1)\n  \n);\nint[108] triagList = int[](\n    1, 6, 15,\n    1, 6, 2,\n    2, 19, 6,\n    \n    15, 11, 16,\n    15, 6, 16,\n    6, 16, 8,\n    \n    1, 13, 9,\n    1, 9, 15,\n    15, 9, 11,\n    \n    19, 6, 8,\n    19, 8, 12,\n    12, 8, 20,\n    \n    20, 8, 16, \n    20, 16, 4,\n    16, 4, 3,\n    \n    11, 16, 3,\n    11, 3, 9, \n    3, 9, 14, \n    \n    1, 2, 17, \n    17, 1, 5,\n    1, 5, 13,\n    \n    7, 5, 13,\n    7, 13, 14,\n    13, 14, 9,\n    \n    4, 18, 7,\n    4, 7, 3,\n    3, 7, 14,\n    \n    2, 17, 19, \n    19, 17, 10, \n    10, 12, 19,\n    \n    4, 20, 18, \n    18, 20, 10, \n    20, 10, 12,\n    \n    10, 17, 5,\n    10, 5, 7, \n    10, 18, 7\n);\n\n\n/*light init*/\nconst int lightsCounter = 3;\nSphere Lights[lightsCounter];\n\n\n/*scale functions*/\nvec2 rotate(vec2 a, float b) {\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\n\n/*utils*/\nfloat pow2(float x) \n{\n    return x * x;\n}\nfloat rand(float frame) \n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\nvec3 rgb2hsv(vec3 c) \n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) \n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}