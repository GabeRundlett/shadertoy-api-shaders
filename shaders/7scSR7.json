{
    "Shader": {
        "info": {
            "date": "1632902499",
            "description": "use RIGHT,UP,LEFT arrows to toggle lights\nuse mouse to move the main light and the camera",
            "flags": 16,
            "hasliked": 0,
            "id": "7scSR7",
            "likes": 5,
            "name": "blob field",
            "published": 3,
            "tags": [
                "raymarching",
                "wip"
            ],
            "usePreview": 0,
            "username": "drschizzo",
            "viewed": 286
        },
        "renderpass": [
            {
                "code": "#define lin2sRGB(x) ( x <= .0031308 ? (x)*12.92 : 1.055*pow(x,1./2.4) - .055 )\n\n\nconst float ANIM_SPEED=2.;\n\n\nconst float SEED=3.42;\n\nconst int MAX_STEP=80;\nconst float MIN_DIST=.005;\nconst float MAX_DIST=80.;\n\n\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\n\nstruct Light{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n\nstruct Hit{\n    float dist;\n    vec4 objId;\n    vec3 pos;\n    vec3 normal;    \n};\n\n//  from DAVE HOSKINS\nvec3 N13(float p) {\n    p=p*SEED;\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\nreturn fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nmat2 rotate2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat map01(float min,float max, float val){\n    return val=clamp((val-min)/(max-min),0.,1.);\n}\n\n \n\nvec4 getSphere(float n){\n    float nb=n;\n    float t=iTime/ANIM_SPEED;\n    vec3 p=N13(nb);\n    nb=nb*p.x;\n    float b=4.;\n    float z=-6.+3.*(sin(t*2.+b*float(nb))*0.5+.5);\n    float w=min(b/1.5,1.2)*pow((1.-(-z-3.)/3.),2.);\n    return vec4(p.x*1.5+cos(z*3.+n)*.4,p.y*1.5+sin(z*3.+n)*.4,z,w*1.2);\n    \n}\n\n//from https://iquilezles.org/articles/smin\nvec2 sminN( float a, float b, float k, float n )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n; \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nfloat computeId(vec3 p,vec3 rep){\n   \n    return dot(floor((rep*.5+p)/rep),vec3(1.,10.,100.));\n    \n}\n\n\nHit getDist(vec3 p){\n    float fact=.8;\n\n    vec3 orip=p;\n    \n    vec3 rep=vec3(3.*fact,3.*fact,15.);\n    float idOffset;\n\n    \n    p=mod(p+rep/2.,rep)-rep/2.;\n    \n    \n   \n    float dist=MAX_DIST;\n    int objId=-1;\n    int sphereId=0;\n     \n    \n   vec3 col=vec3(0.);\n    \n    \n    for(float i=-1.;i<=1.;i++){\n        for(float j=-1.;j<=1.;j++){\n            \n            vec3 p1=vec3(orip.x+i*rep.x,orip.y+j*rep.y,orip.z);\n            \n            idOffset=computeId(p1,rep);\n            vec4 sphere=getSphere(idOffset);\n            sphere.x=sphere.x+i*rep.x;\n            sphere.y=sphere.y+j*rep.y;\n           \n            float d1=length(p-sphere.xyz)-sphere.w;\n            //float d1=sdBox(p-sphere.xyz,vec3(sphere.w*fact));\n            col+=N13(idOffset)*pow(max(min(1.-d1,1.),0.),3.);\n\n            dist=sminN(dist,d1,2.*fact,4.).x;\n        }\n    }\n\n    \n    objId=int(idOffset);\n\n    dist*=.5;\n    return Hit(dist,vec4(objId,col),vec3(0),vec3(0));\n}\n\n\n\nvec3 getNormal(vec3 pos){\n    vec2 e=vec2(.05,0);\n    float dist=getDist(pos).dist;\n    vec3 n=vec3(\n        dist-getDist(pos-e.xyy).dist,\n        dist-getDist(pos-e.yxy).dist,\n        dist-getDist(pos-e.yyx).dist);\n    return normalize(n);\n}\n\nHit rayMarch(vec3 o,vec3 ray){\n    float totalDist=0.;\n    Hit hit;\n    for(int i=0;i<MAX_STEP;i++){\n        vec3 p=o+totalDist*ray;\n        hit=getDist(p);\n        totalDist+=hit.dist*2.*(.5+map01(0.,60.,totalDist));\n        if(hit.dist<MIN_DIST||totalDist>MAX_DIST) break ;\n    }\n    if(totalDist<MAX_DIST){\n        vec3 pos=o+ray*totalDist;\n        return Hit(totalDist,hit.objId,pos,getNormal(pos));\n    }\n    else{\n        return Hit(totalDist,vec4(-1),vec3(0),vec3(MAX_DIST));\n    }\n    \n}\n\nvec3 shadePixel(vec3 pos, vec3 n, Light light,vec3 viewDir){\n\n    float intensity=1./pow(length(pos-light.pos),2.)*light.intensity;\n    float diffuse=dot(normalize(light.pos-pos),n);\n    float shadow=1.;//softshadow( pos, light.pos, 0.01, 10., 5.);\n    diffuse=clamp(diffuse,0.,1.)*shadow;\n\n\n    vec3 r=normalize(light.pos-viewDir-pos);\n    float spec=pow(max(dot(n, r),0.), 90.)*shadow;\n    \n    float ret=diffuse;\n    ret +=  spec;\n\n    return ret*intensity*light.color;\n}\n\nfloat getzoffset(){\n   return iTime/ANIM_SPEED*10.;\n}\n\nvec2 getmousePos(){\n    return ((iMouse.xy-.5*iResolution.xy)/iResolution.y);\n\n}\n\n\nvec3 computeLighting(vec3 hitPos,vec3 n,vec3 ray){\n\n  bool disableLight1=texelFetch( iChannel1, ivec2(KEY_LEFT,2),0 ).x>0.;\n    bool disableLight2=texelFetch( iChannel1, ivec2(KEY_RIGHT,2),0 ).x>0.;\n    bool disableLight3=texelFetch( iChannel1, ivec2(KEY_UP,2),0 ).x>0.;\nfloat zoffset=getzoffset();\n\nLight lights[]=Light[](Light(vec3(getmousePos()*20.,30.-zoffset),disableLight3?0.:100.,vec3(1.,1.,1.)),\n                           Light(vec3(-8,3.,8.-zoffset),disableLight1?0.:100.,vec3(1.,.8,0.)),\n                           Light(vec3(8,-3.,8.-zoffset),disableLight2?0.:150.,vec3(0.,0.,1.)));\n\n\n    vec3 col=vec3(0.);\n    for(int i=0;i<3;i++){\n        vec3 shadingColor=shadePixel(hitPos,n,lights[i],ray);\n        \n        col+=shadingColor;\n   }\n   return col;\n}\n\n\n\nvec4 render(inout vec3 ro, inout vec3 ray,inout float fresnel, out bool doreflect){\n\n \n    \n    Hit hit=rayMarch(ro,ray);\n    \n    ro=hit.pos+hit.normal*0.003;\n    ray=reflect(ray,hit.normal);\n    fresnel=1.-dot(hit.normal,ray);\n    \n    vec4 colSphere;\n    \n    //only compute reflexion on close objects\n    if(hit.dist<15.)\n        doreflect=true;\n   \n    if(hit.objId.y!=-1.){\n        vec3 col=computeLighting(hit.pos,hit.normal,ray);\n        vec3 colsp=hit.objId.yzw;\n        colSphere = vec4(col.xyz*colsp,1.0);\n        \n    }\n    \n    return colSphere;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    \n     vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t=iTime/ANIM_SPEED;\n    \n    vec2 mousePos=getmousePos();\n    \n    float zoffset=t*10.;\n    \n    //camera model from https://www.youtube.com/watch?v=PBxuVlp7nuM\n    vec3 camera=vec3(mousePos*8.,30.-zoffset);//-20.*(1.+sin(t)));\n    vec3 lookAt=vec3(mousePos*4.,-zoffset);\n    float zoom=1.;\n    vec3 f=normalize(camera-lookAt);\n    vec3 r=cross(vec3(0,1.,0),f);\n    vec3 u=cross(f,r);\n    \n    vec3 c=camera-f*zoom;\n    vec3 i=c+uv.x*r+uv.y*u;\n    vec3 ray=normalize(i-camera);\n    \n    bool doreflect=false;\n\n    float fresnel=0.;\n    fragColor=render(camera,ray,fresnel,doreflect);\n    if(doreflect){\n    float savefresnel=fresnel;\n    fragColor+=render(camera,ray,fresnel,doreflect)*pow(map01(.3,.7,savefresnel),3.);\n    }\n   //gamma correction\n    fragColor.r=lin2sRGB(fragColor.r);\n    fragColor.g=lin2sRGB(fragColor.g);\n    fragColor.b=lin2sRGB(fragColor.b);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}