{
    "Shader": {
        "info": {
            "date": "1629317501",
            "description": "Visualization of a few 2D coordinate transforms. The original grid is shown on the left.The color signifies the squishing (blue) and stretching (red) of space due to the transformation. Deformation is computed via automatic differentiation ",
            "flags": 0,
            "hasliked": 0,
            "id": "7stGzN",
            "likes": 13,
            "name": "2D Coordinate Transforms",
            "published": 3,
            "tags": [
                "derivative",
                "transform",
                "coordinatetransform",
                "autodiff",
                "jacobian",
                "stretching"
            ],
            "usePreview": 0,
            "username": "sibaku",
            "viewed": 548
        },
        "renderpass": [
            {
                "code": "const float pi = 3.14159265;\n\n// simple check if a point is inside bounding box\nbool inside(vec2 p, vec2 bmin, vec2 bmax) {\n  return !any(lessThan(p, bmin)) && !any(greaterThan(p, bmax));\n}\n\n// distance to the closest 1D line with a given spacing\nfloat sdLines(float p, float spacing) {\n  float pl = floor(p / spacing) * spacing;\n\n  float pr = ceil(p / spacing) * spacing;\n\n  return min(abs(p - pl), abs(p - pr));\n}\n\n// gray value for slightly smooth gridlines\n// takes seperate thickness to try to  counteract distortian\nfloat gridColor(vec2 p, float size, float thicknessx, float thicknessy) {\n  float dl1 = sdLines(p.x, size);\n  float dl2 = sdLines(p.y, size);\n\n  float f1 = smoothstep(thicknessx * 0.25, thicknessx, dl1);\n  float f2 = smoothstep(thicknessy * 0.25, thicknessy, dl2);\n  return f1 * f2;\n}\n\n// simple projection from squashed screen coordinate to a scaled world\nvec2 screen2World(vec2 p, vec2 origin, float unitScale, float aspect) {\n  p = p - origin;\n  p *= unitScale;\n  p.y /= aspect;\n  return p;\n}\n\n// inverse polar transfom for first coordinate\nGNum2 invRPolar(GNum2 x, GNum2 y) {\n  return a_sqrt(add(mult(x, x), mult(y, y)));\n}\n// inverse polar transfom for second coordinate\nGNum2 invThetaPolar(GNum2 x, GNum2 y) { return a_atan2(y, x); }\n\n// to sample original grid we need to compute the inverse transform\n// you can implement some transforms yourself using the autodiff functions\n// derivatives are computed automatically\nvoid invtransform(vec2 p, vec2 bmin, vec2 bdelta, vec2 bmax, float unitScale,\n                  float lineThickness, float aspect, int index, float blend,\n                  out vec2 q, out mat2 J) {\n\n  // center of current box\n  vec2 center = screen2World(bmin + 0.5 * bdelta, bmin, unitScale, aspect);\n\n  // create gradient variable\n  GNum2 x = varG2x(p.x);\n  GNum2 y = varG2y(p.y);\n\n  // coordinate system in center\n  GNum2 cx = sub(x, center.x);\n  GNum2 cy = sub(y, center.y);\n\n  // 5 transforms\n  GNum2 tx[5];\n  GNum2 ty[5];\n\n  // polar coordinates\n  {\n    // scaling to better showcase distortion\n    GNum2 sx = mult(cx, 0.75);\n    GNum2 sy = mult(cy, 0.75);\n    tx[0] = invRPolar(sx, sy);\n    ty[0] = invThetaPolar(sx, sy);\n  }\n\n  // y' = y/(1.5 - sin(2pix))\n  {\n\n    tx[1] = cx;\n    ty[1] = mult(cy, sub(1.5, a_sin(mult(2.0 * pi, cx))));\n  }\n\n  // y' = y*(1 + (2x)^2)\n  {\n    GNum2 xm = mult(x, 2.0);\n\n    tx[2] = x;\n    ty[2] = div(y, add(1.0, mult(xm, xm)));\n  }\n\n  // x' = exp(x)\n  {\n    tx[3] = a_log(x);\n    ty[3] = y;\n  }\n\n  // identity\n  {\n    tx[4] = x;\n    ty[4] = y;\n  }\n\n  // interpolate one function with the next with the given factor\n  // -> nice transitions\n  int idxp = int(mod(float(index + 1), 5.0));\n  GNum2 rx = a_mix(tx[index], tx[idxp], blend);\n  GNum2 ry = a_mix(ty[index], ty[idxp], blend);\n\n  // coordinate in original system\n  q.x = rx.val;\n  q.y = ry.val;\n\n  // Jacobian\n  // since we need extra parameters we have to create the Jacobian by ourself\n  // instead of using the JACOBIAN2 macro\n  J = transpose(mat2(rx.g, ry.g));\n}\n\n// 2D rotation\nmat2 rot(float alpha) {\n  float c = cos(alpha);\n  float s = sin(alpha);\n  return mat2(c, s, -s, c);\n}\n// from\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox(in vec2 p, in vec2 b) {\n  vec2 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n// from\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q) {\n  p.x = abs(p.x);\n  vec2 a = p - q * clamp(dot(p, q) / dot(q, q), 0.0, 1.0);\n  vec2 b = p - q * vec2(clamp(p.x / q.x, 0.0, 1.0), 1.0);\n  float s = -sign(q.y);\n  vec2 d = min(vec2(dot(a, a), s * (p.x * q.y - p.y * q.x)),\n               vec2(dot(b, b), s * (p.y - q.y)));\n  return -sqrt(d.x) * sign(d.y);\n}\n\n// simple SDFs to draw an arrow\nfloat sdArrow(vec2 p, float w, float h) {\n\n  float db = sdBox(p - vec2(-w / 6.0, 0.0), vec2(w * 2.0 / 3.0, h) / 2.0);\n\n  p = p - vec2(w / 6.0, 0.0);\n  p = rot(-pi / 2.0) * p + vec2(0.0, w / 3.0);\n\n  float st = sdTriangleIsosceles(p, vec2(h, w / 3.0));\n\n  return min(db, st);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n  float aspect = iResolution.x / iResolution.y;\n\n  float w = 0.4;\n  float h = w * aspect;\n\n  float borderx = (1.0 - 2.0 * w) / 4.0;\n  float bordery = (1.0 - h) / 2.0;\n\n  vec2 bminA = vec2(borderx, bordery);\n  vec2 bdeltaA = vec2(w, h);\n  vec2 bmaxA = bminA + bdeltaA;\n\n  vec2 bminB = vec2(1.0 - w - borderx, bordery);\n  vec2 bdeltaB = vec2(w, h);\n  vec2 bmaxB = bminB + bdeltaB;\n\n  float unitScale = 1.0 / bdeltaA.x;\n  int numGrid = 10;\n  float gridSize = 1.0 / float(numGrid);\n\n  float lineThickness = gridSize / 10.0;\n\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy;\n\n  vec3 col = vec3(0.4);\n\n  // hopefully colorblind friendly color palette\n  // color for full squish\n  vec3 c0 = vec3(0.0, 66.0, 157.0) / 255.0;\n  // color for no distortion\n  vec3 c1 = vec3(255.0, 255.0, 224.0) / 255.0;\n  // color for full stretch\n  vec3 c2 = vec3(147.0, 0.0, 58.0) / 255.0;\n\n  // arrow in the middle\n  float arrowDist =\n      sdArrow(screen2World(uv - vec2(0.5, 0.5), vec2(0.0), 1.0, aspect),\n              borderx, borderx / 2.0);\n\n  // first box -> original coordinate system\n  if (inside(uv, bminA, bmaxA)) {\n\n    // draw grid\n    col = c1;\n\n    vec2 relA = screen2World(uv, bminA, unitScale, aspect);\n\n    float dl = sdLines(relA.x, gridSize);\n    col *= gridColor(relA, gridSize, lineThickness, lineThickness);\n\n  } else if (inside(uv, bminB, bmaxB)) { // second box -> transformed\n\n    // point position\n    vec2 relB = screen2World(uv, bminB, unitScale, aspect);\n\n    // duration of showing one transform and for blending to the next\n    float durBlend = 3.0;\n    float durShow = 3.0;\n    float dur = durBlend + durShow;\n    float numFuncs = 5.0;\n\n    // compute function offset for time\n    float timeGrid = floor(iTime / dur);\n    int fIndex = int(mod(timeGrid, numFuncs));\n    float inDur = iTime - timeGrid * dur;\n    // start blending to the next after show duration is over\n    float blend = smoothstep(durShow, dur, inDur);\n\n    // inverse transform\n    vec2 relA;\n    mat2 J;\n\n    invtransform(relB, bminB, bdeltaB, bmaxB, unitScale, lineThickness, aspect,\n                 fIndex, blend, relA, J);\n\n    // distance in original system\n    float dl = sdLines(relA.x, gridSize);\n\n    // we want to show the stretch factor of the actual transform given by its\n    // Jacobian determinant as we computed the inverse, we can compute the\n    // original one by 1/det we do not care about reflections here, so we use\n    // the absolute value\n    float dJ = 1.0 / abs(determinant(J));\n\n    // for display show stretching in the intervals:\n    // [0,1) -> squish\n    // [1,2] -> stretch\n    // 1 -> no stretch\n    dJ = clamp(dJ, 0.0, 2.0);\n    if (dJ < 1.0) {\n      col = mix(c0, c1, smoothstep(0.0, 1.0, dJ));\n    } else {\n      col = mix(c1, c2, smoothstep(1.0, 2.0, dJ));\n    }\n\n    // just sampling the lines in the original space will make them small or\n    // large depending on the transforms stretching. Try to counteract that by\n    // computing the stretching of the base unit vectors. For this we need the\n    // original transform, so we invert the Jacobian. As it would get a bit\n    // crowded for many lines with lots of squishing, we only apply the\n    // correction up to a degree\n    mat2 Ji = inverse(J);\n    float thx = lineThickness / max(0.3, length(Ji[0]));\n    float thy = lineThickness / max(0.3, length(Ji[1]));\n\n    // color\n    col *= gridColor(relA, gridSize, thx, thy);\n\n  } else if (arrowDist < 0.0) {\n    // color in the middle arrow\n    col = vec3(1.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//********************************************************************\n//\n// Begin of automatic differentiation header\n// Full code with additional functions (gradients, jacobians, ...) can be found\n// at: https://github.com/sibaku/glsl-autodiff\n//\n//********************************************************************\n\n#ifndef GRADNUM_2_H_\n#define GRADNUM_2_H_\n\n// This file contains methods to compute the gradient of a scalar valued 2 dimensional\n// function using automatic forward differentiation\n\n//--------------------------------\n// Types\n//--------------------------------\n\n// Data type to hold information about a scalar valued 2 dimensional function\n// These should be created by the constG2 (for constants) and varG2 (for variables) helpers\nstruct GNum2\n{\n    // The current value\n    float val;\n    // The current gradient\n    vec2 g;\n};\n\n//--------------------------------\n// Prototypes\n//--------------------------------\n\n/**\n* Creates a constant GNum2\n* @param val The current value of the constant\n*/\nGNum2 constG2(in float val);\nGNum2 varG2(in float val, in int index);\nGNum2 varG2x(in float val);\nGNum2 varG2y(in float val);\nGNum2 add(in GNum2 a, in GNum2 b);\nGNum2 add(in GNum2 a, in float b);\nGNum2 add(in float a, in GNum2 b);\nGNum2 sub(in GNum2 a, in GNum2 b);\nGNum2 sub(in GNum2 a, in float b);\nGNum2 sub(in float a, in GNum2 b);\nGNum2 mult(in GNum2 a, in GNum2 b);\nGNum2 mult(in GNum2 a, in float b);\nGNum2 mult(in float a, in GNum2 b);\nGNum2 neg(in GNum2 a);\nGNum2 div(in GNum2 a, in GNum2 b);\nGNum2 div(in GNum2 a, in float b);\nGNum2 div(in float a, in GNum2 b);\nGNum2 inv(in GNum2 a);\nGNum2 a_pow(in GNum2 a, in GNum2 b);\nGNum2 a_pow(in GNum2 a, in float b);\nGNum2 a_pow(in float a, in GNum2 b);\nGNum2 a_min(in GNum2 a, in GNum2 b);\nGNum2 a_max(in GNum2 a, in GNum2 b);\nGNum2 a_exp2(in GNum2 a);\nGNum2 a_inversesqrt(in GNum2 a);\nGNum2 a_atan(in GNum2 a);\nGNum2 a_sqrt(in GNum2 a);\nGNum2 a_sinh(in GNum2 a);\nGNum2 a_ceil(in GNum2 a);\nGNum2 a_tan(in GNum2 a);\nGNum2 a_asinh(in GNum2 a);\nGNum2 a_asin(in GNum2 a);\nGNum2 a_acosh(in GNum2 a);\nGNum2 a_abs(in GNum2 a);\nGNum2 a_exp(in GNum2 a);\nGNum2 a_cosh(in GNum2 a);\nGNum2 a_floor(in GNum2 a);\nGNum2 a_log(in GNum2 a);\nGNum2 a_atanh(in GNum2 a);\nGNum2 a_log2(in GNum2 a);\nGNum2 a_acos(in GNum2 a);\nGNum2 a_tanh(in GNum2 a);\nGNum2 a_cos(in GNum2 a);\nGNum2 a_sin(in GNum2 a);\nGNum2 a_atan2(in GNum2 y, in GNum2 x);\nGNum2 a_atan2(in GNum2 y, in float x);\nGNum2 a_atan2(in float y, in GNum2 x);\nGNum2 a_mix(in GNum2 a, in GNum2 b, in GNum2 t);\nGNum2 a_mix(in GNum2 a, in GNum2 b, in float t);\nGNum2 a_mix(in GNum2 a, in float b, in GNum2 t);\nGNum2 a_mix(in GNum2 a, in float b, in float t);\nGNum2 a_mix(in float a, in GNum2 b, in GNum2 t);\nGNum2 a_mix(in float a, in GNum2 b, in float t);\nGNum2 a_mix(in float a, in float b, in GNum2 t);\n\n//--------------------------------\n// Macros\n//--------------------------------\n\n#define GRAD2(f,x, y,result)  {     result = f(varG2x(x), varG2y(y)); }\n//--------------------------------\n#define JACOBI2(f1, f2, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI2_VALUE(f1, f2, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI32(f1, f2, f3, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult);     result[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI32_VALUE(f1, f2, f3, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult); \tvalue[2] = gradResult.val; \tresult[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI42(f1, f2, f3, f4, x, y, result)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult);     result[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult);     result[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult);     result[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  \tGRAD2(f4, x, y, gradResult);     result[0][3] = gradResult.g[0]; \tresult[1][3] = gradResult.g[1];  }\n//--------------------------------\n#define JACOBI42_VALUE(f1, f2, f3, f4, x, y, result, value)  {     GNum2 gradResult;  \tGRAD2(f1, x, y, gradResult); \tvalue[0] = gradResult.val; \tresult[0][0] = gradResult.g[0]; \tresult[1][0] = gradResult.g[1];  \tGRAD2(f2, x, y, gradResult); \tvalue[1] = gradResult.val; \tresult[0][1] = gradResult.g[0]; \tresult[1][1] = gradResult.g[1];  \tGRAD2(f3, x, y, gradResult); \tvalue[2] = gradResult.val; \tresult[0][2] = gradResult.g[0]; \tresult[1][2] = gradResult.g[1];  \tGRAD2(f4, x, y, gradResult); \tvalue[3] = gradResult.val; \tresult[0][3] = gradResult.g[0]; \tresult[1][3] = gradResult.g[1];  }\n\n//--------------------------------\n// Implementation\n//--------------------------------\n\nGNum2 constG2(in float val)\n{\n    return GNum2(val, vec2(0.0));\n}\n//--------------------------------\nGNum2 varG2(in float val, in int index)\n{   \n    vec2 g = vec2(0.0);\n    g[index] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 varG2x(in float val)\n{   \n    vec2 g = vec2(0.0);\n    g[0] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 varG2y(in float val)\n{   \n    vec2 g = vec2(0.0);\n    g[1] = 1.0;\n    return GNum2(val, g);\n}\n//--------------------------------\nGNum2 add(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val + b.val, a.g + b.g);\n}\n//--------------------------------\nGNum2 add(in GNum2 a, in float b)\n{\n    return GNum2(a.val + b, a.g);\n}\n//--------------------------------\nGNum2 add(in float a, in GNum2 b)\n{\n    return GNum2(a + b.val, b.g);\n}\n//--------------------------------\nGNum2 sub(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val - b.val, a.g - b.g);\n}\n//--------------------------------\nGNum2 sub(in GNum2 a, in float b)\n{\n    return GNum2(a.val - b, a.g);\n}\n//--------------------------------\nGNum2 sub(in float a, in GNum2 b)\n{\n    return GNum2(a - b.val, -b.g);\n}\n//--------------------------------\nGNum2 mult(in GNum2 a, in GNum2 b)\n{\n    return GNum2(a.val * b.val, \n        a.val*b.g + b.val*a.g\n        );\n}\n//--------------------------------\nGNum2 mult(in GNum2 a, in float b)\n{\n    return GNum2(a.val * b, b*a.g);\n}\n//--------------------------------\nGNum2 mult(in float a, in GNum2 b)\n{\n    return GNum2(a * b.val, a*b.g);\n}\n//--------------------------------\nGNum2 neg(in GNum2 a)\n{\n    return mult(-1.0,a);\n}\n//--------------------------------\nGNum2 div(in GNum2 a, in GNum2 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n\n    return GNum2(a.val / b.val , \n        (b.val*a.g - a.val*b.g)/b2\n    );\n}\n//--------------------------------\nGNum2 div(in GNum2 a, in float b)\n{\n    return GNum2(a.val / b, a.g/b);\n}\n//--------------------------------\nGNum2 div(in float a, in GNum2 b)\n{\n    float b1 = b.val;\n    float b2 = b1*b1;\n\n    return GNum2(a / b.val, \n        -a*b.g/b2\n    );\n}\n//--------------------------------\nGNum2 inv(in GNum2 a)\n{\n    return div(1.0, a);\n}\n//--------------------------------\nGNum2 a_pow(in GNum2 a, in GNum2 b)\n{\n    return a_exp(mult(b,a_log(a)));\n}\n//--------------------------------\nGNum2 a_pow(in GNum2 a, in float b)\n{\n    // constant exponent -> make special case\n    float v = pow(a.val, b); // value f(a(x))\n    float da = b*pow(a.val,b-1.0); // first derivative f'(a(x))\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_pow(in float a, in GNum2 b)\n{\n    return a_exp(mult(b,log(a)));\n}\n//--------------------------------\nGNum2 a_min(in GNum2 a, in GNum2 b)\n{\n    if(a.val < b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nGNum2 a_max(in GNum2 a, in GNum2 b)\n{\n    if(a.val > b.val)\n    {\n        return a;\n    }\n    return b;\n}\n//--------------------------------\nGNum2 a_exp2(in GNum2 a)\n{\n    float v = exp2(a.val); // value f(a(x))\n    float da = log(2.0)*exp2(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_inversesqrt(in GNum2 a)\n{\n    float v = inversesqrt(a.val); // value f(a(x))\n    float da = -0.5/pow(sqrt(a.val),3.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atan(in GNum2 a)\n{\n    float v = atan(a.val); // value f(a(x))\n    float da = 1.0/(1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sqrt(in GNum2 a)\n{\n    float v = sqrt(a.val); // value f(a(x))\n    float da = 0.5/sqrt(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sinh(in GNum2 a)\n{\n    float v = sinh(a.val); // value f(a(x))\n    float da = cosh(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_ceil(in GNum2 a)\n{\n    float v = ceil(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_tan(in GNum2 a)\n{\n    float v = tan(a.val); // value f(a(x))\n    float da = 1.0 + pow(tan(a.val),2.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_asinh(in GNum2 a)\n{\n    float v = asinh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_asin(in GNum2 a)\n{\n    float v = asin(a.val); // value f(a(x))\n    float da = 1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_acosh(in GNum2 a)\n{\n    float v = acosh(a.val); // value f(a(x))\n    float da = 1.0/sqrt(-1.0 + a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_abs(in GNum2 a)\n{\n    float v = abs(a.val); // value f(a(x))\n    float da = a.val < 0.0 ? -1.0 : 1.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_exp(in GNum2 a)\n{\n    float v = exp(a.val); // value f(a(x))\n    float da = exp(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_cosh(in GNum2 a)\n{\n    float v = cosh(a.val); // value f(a(x))\n    float da = sinh(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_floor(in GNum2 a)\n{\n    float v = floor(a.val); // value f(a(x))\n    float da = 0.0; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_log(in GNum2 a)\n{\n    float v = log(a.val); // value f(a(x))\n    float da = 1.0/a.val; // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atanh(in GNum2 a)\n{\n    float v = atanh(a.val); // value f(a(x))\n    float da = 1.0/(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_log2(in GNum2 a)\n{\n    float v = log2(a.val); // value f(a(x))\n    float da = 1.0/(a.val * log(2.0)); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_acos(in GNum2 a)\n{\n    float v = acos(a.val); // value f(a(x))\n    float da = -1.0/sqrt(1.0 - a.val * a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_tanh(in GNum2 a)\n{\n    float v = tanh(a.val); // value f(a(x))\n    float da = 1.0 - pow(tanh(a.val),2.0); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_cos(in GNum2 a)\n{\n    float v = cos(a.val); // value f(a(x))\n    float da = -sin(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_sin(in GNum2 a)\n{\n    float v = sin(a.val); // value f(a(x))\n    float da = cos(a.val); // first derivative f'(a(x))\n\n    return GNum2(v , da * a.g);\n}\n//--------------------------------\nGNum2 a_atan2(in GNum2 y, in GNum2 x)\n{\n    const float pi = 3.14159265; \n    // from https://en.wikipedia.org/wiki/Atan2\n    if(x.val > 0.0)\n    {\n        GNum2 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        GNum2 inner = div(y, add(n,x));\n        \n        return mult(2.0,a_atan(inner));\n        \n    }else if(x.val <= 0.0 && abs(y.val) > 1E-6)\n    {\n        GNum2 n = a_sqrt(add(mult(x,x),mult(y,y)));\n        GNum2 inner = div(sub(n,x),y);\n         return mult(2.0,a_atan(inner));\n    }else if(x.val < 0.0 && abs(y.val) <= 1E-6)\n    {\n        return constG2(pi);\n    }\n    // return 0 for undefined\n    return constG2(0.0); \n}\n//--------------------------------\nGNum2 a_atan2(in GNum2 y, in float x)\n{\n    return a_atan2(y,constG2(x));\n}\n//--------------------------------\nGNum2 a_atan2(in float y, in GNum2 x)\n{\n    return a_atan2(constG2(y),x);\n}\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in GNum2 b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in GNum2 b, in float t)\n{\n    return add(mult(a, 1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in float b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in GNum2 a, in float b, in float t)\n{\n    return add(mult(a, 1.0 - t), b*t);\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in GNum2 b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in GNum2 b, in float t)\n{\n    return add(a * (1.0 - t), mult(b, t));\n}\n\n//--------------------------------\nGNum2 a_mix(in float a, in float b, in GNum2 t)\n{\n    return add(mult(a, sub(1.0, t)), mult(b, t));\n}\n\n\n#endif // GRADNUM_2_H_",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}