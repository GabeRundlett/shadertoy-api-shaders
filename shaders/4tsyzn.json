{
    "Shader": {
        "info": {
            "date": "1503153584",
            "description": "I wanted this to have the feel of a Marvel movie intro, but finding an interesting camera path, and doing 'realistic' shading was hard; so we got neon colours instead ;)",
            "flags": 0,
            "hasliked": 0,
            "id": "4tsyzn",
            "likes": 53,
            "name": "Perpetual mitosis",
            "published": 3,
            "tags": [
                "fractal",
                "zoom",
                "infinite",
                "dodecahedron",
                "neon",
                "subdivide"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 1494
        },
        "renderpass": [
            {
                "code": "/* \n\n\tPerpetual mitosis\n\t-----------------\n\n\tEssentially a fractal dodecahedron, where we animate between each iteration.\n\n*/\n\n\nfloat time;\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n\n// --------------------------------------------------------\n// Config\n// --------------------------------------------------------\n\nfloat stepScale = .275;\nfloat stepMove = 2.;\nfloat stepDuration = 2.;\nfloat ballSize = 1.5;\n\n// How far into the subdivision animation do we start animating\n// the next subdivision\nfloat transitionPoint = .5; \n\n// #define DEBUG_ANIMATION\n\n#ifdef DEBUG_ANIMATION\n    const float initialStep = 0.;\n    const float MODEL_STEPS = 2.;\n#else\n    const float initialStep = 2.;\n    const float MODEL_STEPS = 3.;\n#endif\n\n\n\n// --------------------------------------------------------\n// Rotation controls\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 cameraRotation() {\n    vec2 r = vec2(.66 + .5, 0.) * PI;\n    return sphericalMatrix(r.x, r.y);\n}\n\n\n// --------------------------------------------------------\n// HG_SDF\n// --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float r) {\n    float m = min(a, b);\n    if ((a < r) && (b < r) ) {\n        return min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n    } else {\n     return m;\n    }\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// fCapsule, but with a break at the midpoint\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r, float breakSize) {\n    vec3 m = mix(b, a, .5);\n    float s1 = fLineSegment(p, a, mix(m, a, breakSize));\n    float s2 = fLineSegment(p, b, mix(m, b, breakSize));\n    return min(s1 - r, s2 - r);\n}\n\n// --------------------------------------------------------\n// knighty\n// https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\nstruct Tri {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n    \nstruct TriPlanes {\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n    \n    \nvec3 nc;\nTri triV;\nTriPlanes triP;\n\nint Type = 5;\n\nvoid init() {//setup folding planes and vertex\n    vec3 pab,pbc,pca;\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pab=vec3(0.,0.,1.);\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n\n    // Triangle vertices\n    triV = Tri(pbc, pab, pca);\n    // Triangle edge plane normals \n    triP = TriPlanes( \n        normalize(cross(triV.a, triV.b)),\n        normalize(cross(triV.b, triV.c)),\n        normalize(cross(triV.c, triV.a))\n    );\n}\n\n\nvoid fold(inout vec3 p) {\n    for(int i=0;i<5 /*Type*/;i++){\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p,nc)) * nc;\n    }\n}\n\n\n// --------------------------------------------------------\n// Closest icosahedron vertex\n// Branchless version of the one in\n// https://www.shadertoy.com/view/Mtc3RX\n// --------------------------------------------------------\n\nvec3 icosahedronVertex(vec3 p) {\n    vec3 sp, v1, v2, v3, result, plane;\n    float split;\n    sp = sign(p);\n    v1 = vec3(PHI, 1, 0) * sp;\n    v2 = vec3(1, 0, PHI) * sp;\n    v3 = vec3(0, PHI, 1) * sp;\n    plane = cross(cross(v1, v2), v1 + v2);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(v1, v2, split);\n    plane = cross(cross(result, v3), v3 + result);\n    split = max(sign(dot(p, plane)), 0.);\n    result = mix(result, v3, split);\n    return normalize(result);\n}\n\n\n// --------------------------------------------------------\n// Easing\n// --------------------------------------------------------\n\nfloat hardstep(float a, float b, float t) {\n    float s = 1. / (b - a);\n    return clamp((t - a) * s, 0., 1.);\n}\n\n// https://www.shadertoy.com/view/ldBfR1\nfloat gain(float x, float P) {\n    if (x > 0.5)\n        return 1.0 - 0.5*pow(2.0-2.0*x, P);\n    else\n        return 0.5*pow(2.0*x, P);\n}\n\nfloat gainIn(float x, float P) {\n    return gain(x * .5, P) * 2.;\n}\n\nfloat gainOut(float x, float P) {\n    return 1. - gain(.5 - x * .5, P) * 2.;\n}\n\nfloat gainStep(float start, float end, float x, float e) {\n    return gain(hardstep(start, end, x), e);\n}\n\nfloat gainStep(float x, float e) {\n    return gainStep(0., 1., x, e);\n}\n\nfloat kink(float x, vec2 p, float e1, float e2) {\n    float a = (1. - pow(1. - x / p.x, e1)) * p.y;\n    float b = pow((x - p.x) / (1. - p.x), e2) * (1. - p.y) + p.y;\n    return mix(a, b, step(p.x, x));\n}\n\nfloat wobble(float x, float freq) {\n    float w = sin(x * PI * 2. * freq - PI * .5) * .5 + .5;\n    w *= sin(x * PI + PI * .5) * .5 + .5;\n    return w;\n}\n\nfloat circleEaseIn(float radius, float slope, float x) {\n    float iSlope = 1. - slope;\n    float scale = radius / length(vec2(iSlope, 1.));\n    float u = (iSlope * -scale + radius) * iSlope + slope;\n    float line = (x - slope) / iSlope;\n    float uu = u - scale;\n    float circle = -sqrt(radius * radius - (x - uu) * (x - uu)) + radius;\n    float ramp = mix(0., circle, step(uu, x));\n     \n    // This breaks when x < u, something to do with\n    // 1. - x in circleEaseOut\n    // return mix(max(ramp, 0.), line, step(u, x));\n    \n    if (x < u) {\n        return max(ramp, 0.);\n    } else {\n        return line;\n    }\n}\n\nfloat circleEaseOut(float radius, float slope, float x) {\n    return 1. - circleEaseIn(radius, slope, 1. - x);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Noise\n// --------------------------------------------------------\n\nfloat hash( const in vec3 p ) {\n    return fract(sin(dot(p,vec3(127.1,311.7,758.5453123)))*43758.5453123);\n}\n\n\n// --------------------------------------------------------\n// Animation\n// --------------------------------------------------------\n\nfloat tweakAnim(float x) {\n    return mix(x, kink(x, vec2(.4), 2., .8), .5);\n}\n\n// Get the timeline for a single subdivision iteration step\nfloat animStep(float t, float stepIndex) {\n    float x = t;\n    x *= MODEL_STEPS;\n    x -= stepIndex;\n    x *= transitionPoint;\n    x = tweakAnim(x);\n    return x;\n}\n\nfloat animStep(float t, float stepIndex, float delay) {\n    return animStep(t - delay, stepIndex);\n}\n\nfloat moveAnim(float x) {\n    float a = 1.;\n    float h = 1.;\n    float blend = x;\n    blend = gainStep(-a, a, blend, 2.) * h * 2. - h;\n    blend = gainStep(blend, 1.5);\n    return blend;\n}\n\nfloat scaleAnim(float x) {\n    x /= transitionPoint;\n    float a = 1.;\n    float h = 1.;\n    float blend = x;\n    blend = hardstep(0., .85, x);\n    blend = gainStep(-a, a, blend, 1.2) * h * 2. - h;\n    blend = gainStep(blend, 1.2);\n    return blend;\n}\n\nfloat wobbleScaleAnim(float x) {\n    float blend = scaleAnim(x);\n    x /= transitionPoint;\n    blend -= wobble(hardstep(.6, 2.2, x), 3.5) * .1;\n    return blend;\n}\n\nconst float ANIM_CAM_START = .96;\n\nfloat animCamRotateA(float x) {\n    return mix(gainOut(x, 3.), x, .9);\n}\n\nfloat animCamRotate(float x) {\n    float o = ANIM_CAM_START;\n    return animCamRotateA(mod(x - o, 1.)) + (1. - animCamRotateA(1. - o)) + floor(x - o);    \n}\n\nfloat camZoomInOutA(float x) {\n    float back = -.1;\n    float p = .5;\n    \n    float zIn, zOut;\n\n    zOut = hardstep(0., p + .1, x);\n    zOut = gainOut(zOut, 5.);\n    \n    zIn = hardstep(p - .3, 1., x);\n    zIn = gain(zIn, 1.5);\n    zIn = gainIn(zIn, 2.5);\n\n    return zOut * back + zIn * (1.- back);\n}\n\nfloat camZoomInOut(float x) {\n    float o = ANIM_CAM_START;\n    float y = camZoomInOutA(mod(x - o, 1.)) + (1. - camZoomInOutA(1. - o)) + floor(x - o);\n    y -= .2;\n    return y;\n}\n\nfloat animTimeA(float x) {\n    return circleEaseOut(.25, .3, x);\n}\n\nfloat animTime(float x) {\n    float o = .78;\n    return animTimeA(mod(x - o, 1.)) + (1. - animTimeA(1. - o)) + floor(x - o);\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    float level;\n};\n\nModel makeBounds(float dist) {\n    return Model(dist, 0.);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\n\n// Description of a single ball subdivision animation\n// at a given iteration step\nstruct ModelSpec {\n    float move; // How much the outer ball moves by\n    float sizeScale; // How much to shrink the outer ball\n    float sizeScaleCore; // How much to shrink the inner ball\n    float bounds; // Bounding distance for the model\n    float level; // Iteration/subdivision level for this animation\n};\n\nfloat boundsForStep(vec3 p, float move, float sizeScale, float scale) {\n    float overfit = .3;\n    p /= scale;\n    float d = (length(p) - move - ballSize * sizeScale - overfit);\n    d *= scale;\n    return d;\n}\n\nfloat levelStep(vec3 p, float move, float size, float x) {\n    float transition = smoothstep(0., .1, x);\n    float blend = hardstep(move + size, size, length(p));\n    blend = mix(0., blend, transition);\n    return blend;\n}\n\nModelSpec specForStep(vec3 p, float x, float scale) {\n    float move = moveAnim(x) * stepMove;\n    float sizeScale = mix(1., stepScale, wobbleScaleAnim(x));\n    float sizeScaleCore = mix(1., stepScale, scaleAnim(x));\n    float bounds = boundsForStep(p, move, sizeScale, scale);\n    float level = levelStep(p / scale, move, sizeScale * ballSize, x);\n    return ModelSpec(move, sizeScale, sizeScaleCore, bounds, level);\n}\n\n\nfloat boundsThreshold;\n\n// Animation of the ball subdividing with smooth blending\n// and connective struts that snap\nModel blendedModel(vec3 p, float x, float scale, float level) {\n    ModelSpec spec = specForStep(p, x, scale);\n    level += spec.level;\n    \n    if (spec.bounds > boundsThreshold) {\n        return makeBounds(spec.bounds);\n    }\n    \n    p /= scale;\n    fold(p);\n\n    float move = spec.move;\n    float size = spec.sizeScale * ballSize;\n    float sizeCore = spec.sizeScaleCore * ballSize;\n\n    // Setup smoothing\n\n    float radiusBlend = hardstep(.1, transitionPoint * .8, x);\n    radiusBlend = smoothstep(0., 1., radiusBlend);\n    float radius = mix(0., .4, radiusBlend);\n\n    // Core ball\n\n    vec3 posCore = vec3(0);\n    float d = length(p - posCore) - sizeCore;\n\n    // Setup outer ball\n\n    vec3 posOuter = triV.a * move;\n\n    // Setup connective strut\n\n    float capRadius = 0.04;\n    float gapBlend = hardstep(transitionPoint * .8, transitionPoint, x);\n    float gap = mix(0., 1., gapBlend);\n\n    // Ball and bridge\n\n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n    \n    // First reflection\n\n    vec3 rPlane = triP.bc;\n    p = reflect(p, rPlane);\n    \n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(posOuter, rPlane), capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n\n    // Second reflection\n\n    vec3 rPlane2 = reflect(triP.ca, rPlane);\n    p = reflect(p, rPlane2);\n\n    d = smin(d, fCapsule(p, posCore, posOuter, capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(posOuter, rPlane2), capRadius, gap), radius);\n    d = smin(d, fCapsule(p, posOuter, reflect(reflect(posOuter, rPlane), rPlane2), capRadius, gap), radius);\n    d = smin(d, length(p - posOuter) - size, radius);\n\n    d *= scale;\n\n    return Model(d, level);\n}\n\n\n// Iterates through each subdivision of the ball, restricting the\n// smooth blending method above to just the currently-animated level\nModel iteratedModel(vec3 p) {\n\n    float stepIndex = -initialStep;\n    float prevStepIndex;\n    float x;\n    float scale = 1.;\n    float sizeScale = 1.;\n\n    // Scale at the transition point\n    float midSizeScale = mix(1., stepScale, scaleAnim(transitionPoint));\n    \n    float level = 0.; // Iteration level used for colouring\n    float delayLevel = 0.;\n    vec3 iv;\n    float delay = 0.;\n\n    float coreBoundry;\n    float coreOverstepBounds = 1e12;\n    float coreOverstepBoundsCandidate;\n\n    #ifndef DEBUG_ANIMATION\n        float time = animTime(time);\n    #endif\n\n    for (float i = 1. - initialStep; i < MODEL_STEPS; i++) {\n\n        x = animStep(time, i, delay);\n\n        if (x >= 0.) {\n \n            stepIndex = i;\n            prevStepIndex = stepIndex - 1.;\n\n            scale = pow(midSizeScale, prevStepIndex);\n\n            x = animStep(time, prevStepIndex, delay);\n            ModelSpec spec = specForStep(p, x, scale);\n            level += spec.level;\n\n            coreBoundry = (length(p / scale) - spec.move * .55) * scale;\n            if (coreBoundry > 0.) {\n                iv = icosahedronVertex(p);\n                fold(p);\n                p -= triV.a * spec.move * scale;\n                sizeScale = spec.sizeScale;\n                // Adjust the start time of each ball for some variety\n                delay += hash(iv * 1.5 - spectrum(mod(delayLevel, 3.) / 6.)) * .6;\n            } else {\n                sizeScale = spec.sizeScaleCore;\n                delayLevel += 1.;\n            }\n            \n            coreOverstepBoundsCandidate = coreBoundry + .3 * scale;\n            if (coreOverstepBoundsCandidate > -.0) {\n                coreOverstepBounds = min(coreOverstepBounds, coreOverstepBoundsCandidate);\n            }\n        }\n    }\n\n    x = animStep(time, stepIndex, delay);\n    Model model = blendedModel(p, x, scale * sizeScale, level);\n    \n    if (coreOverstepBounds > boundsThreshold) {\n        model.dist = min(model.dist, coreOverstepBounds);\n    }\n\n    return model;\n}\n\nfloat modelScale;\n\nModel map( vec3 p ){\n    p /= modelScale;\n    boundsThreshold = .1 / modelScale;\n    Model model = iteratedModel(p);\n    model.dist *= modelScale;\n    return model;\n}\n\nvec3 camPos;\nfloat camDist;\nvec3 camTar;\n\n// Return the modelScale for the given subdivision iteration step,\n// such that all steps look the same size\nfloat scaleForStep(float step) {\n    return pow(1./stepScale, step);\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out vec3 camUp) {\n    float x = time;\n\n    camDist = 8.;\n\n    float camZoom = camZoomInOut(x);\n    modelScale = scaleForStep(camZoom * MODEL_STEPS);\n\n    camUp = vec3(0,-1,0);\n    camTar = vec3(0.);\n    camPos = vec3(0,0,camDist);\n        \n    pR(camPos.xz, animCamRotate(x) * PI * 2.);\n\n    #ifdef DEBUG_ANIMATION\n        camDist = 5.;\n        modelScale = 1.;\n        camPos = vec3(0,0,camDist);\n    #endif\n\n    camPos *= cameraRotation();\n}\n\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 30.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Shading\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 background = vec3(.95, .95, 1.);\n\n    if (hit.isBackground) {\n        hit.color = background;\n        return;\n    }\n\n    float glow = 1. - dot(normalize(camPos), hit.normal);\n    glow += .5 * (1. - dot(hit.normal, normalize(hit.pos)));\n    glow *= .5;\n    glow = gainStep(glow, 2.);\n    \n    float level = hit.model.level;\n    vec3 diffuse = spectrum(level / MODEL_STEPS + .1 - 1./3.);\n    diffuse = mix(diffuse * 1., diffuse * 1.5, glow);\n\n    float fog = smoothstep(camDist *.1, camDist, length(camTar - hit.pos)) * .5;\n    fog = mix(fog, 1., smoothstep(0., camDist * 2.5, length(camTar - hit.pos)));\n\n    diffuse = mix(diffuse, background, fog);\n    hit.color = diffuse;\n}\n\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in vec3 up )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,up));\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 1.;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n\n    vec2 p = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n    float loopDuration = 3. * stepDuration;\n\n    time = iTime;\n    time *= 1.5;\n    time = time/loopDuration;\n    time = mod(time, 1.);\n\n    camPos = vec3( 0., 0., 2.);\n    camTar = vec3( 0. , 0. , 0. );\n    vec3 camUp = vec3(0., 1., 0.);\n    doCamera(camPos, camTar, camUp);\n\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camUp );  // 0.0 is the camera roll\n    vec3 rd = normalize( camMat * vec3(p, 2.) ); // 2.0 is the lens length\n    Hit hit = raymarch(CastRay(camPos, rd));\n    vec3 color = render(hit);\n\n    color = linearToScreen(color);\n    fragColor = vec4(color,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}