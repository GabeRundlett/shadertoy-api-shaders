{
    "Shader": {
        "info": {
            "date": "1457452263",
            "description": "This is a test cube field, without any significant coloring. This uses the technique of Raymarching, so thanks to iq for help with that.",
            "flags": 0,
            "hasliked": 0,
            "id": "MdtXzn",
            "likes": 8,
            "name": "Cube Field",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "cube",
                "cubes",
                "field"
            ],
            "usePreview": 0,
            "username": "Mr_E",
            "viewed": 1050
        },
        "renderpass": [
            {
                "code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(0.,0.,0.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(0.,0.,0.)),\n            sdBox(p,vec3(2.6,2.6,2.6)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d1, d1, d1);\n}\n\nvec2 distance_to_obj(in vec3 p) {\n\np = mod(p, 10.) - 5.; // Repeat space.\n\n// Unsigned rounded box.\n// vec3(2.) - Box dimensions, and the last term for roundness.\n\nfloat rBox = length(max(abs(p)- vec3(2.), 0.0)) - 0.2;\n\nreturn vec2(rBox, 1.);\n}\n\n\n// primitive color\nvec3 prim_c(in vec3 p) {\n    //return vec3(0.6,0.6,0.8);\n    return vec3(sin(p.x*p.y*p.z/10.),cos(p.x*p.y*p.z/5.),.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cam_pos = vec3(cos(iTime/5.)*20.0,sin(iTime/5.)*40.0,20.0);\n\n\tvec2 tx = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * tx;\n\n    //camera up vector\n    vec3 vuv = vec3(0,1,1);\n\n    //camera lookat\n    vec3 vrp=vec3(0,1,0);\n\n    vec3 prp = cam_pos;\n    vec3 vpn = normalize(vrp-prp);\n    vec3 u = normalize(cross(vuv,vpn));\n    vec3 v = cross(vpn,u);\n    vec3 vcv = (prp+vpn);\n    vec3 scrCoord = vcv+vPos.x*u*1.0+vPos.y*v*1.0;\n    vec3 scp=normalize(scrCoord-prp);\n\n    //Raymarching\n    const vec3 e=vec3(0.04,0,0.8);\n    const float maxd=200.0;\n    vec2 d=vec2(1.02,1.0);\n    vec3 c,p,N;\n\n    float f=1.0;\n    for(int i=0;i<256;i++) { // Change i value to 256 for 3D-ness and 2 for coolness\n        if ((abs(d.x)<.001) || (f > maxd)) break;\n\n        f+=d.x*0.8;\n        p=prp+scp*f;\n        d = distance_to_obj(p);\n    }\n    if (f<maxd) {\n        c=prim_c(p);\n        vec3 n = vec3(\n            d.x-distance_to_obj(p-e.xyy).x,\n            d.x-distance_to_obj(p-e.yxy).x,\n            d.x-distance_to_obj(p-e.yyx).x\n            );\n        N = normalize(n);\n        \n        float b=dot(N,normalize(prp-p));\n\t\tvec2 xy = fragCoord.xy / iResolution.xy;//Condensing this into one line\n    \txy.y = 1.0 - xy.y;\n    \t\n        vec2 uv = fragCoord.xy/iResolution.xy;\n\t\tvec4 texColor = texture(iChannel0,xy,b);//Get the pixel at xy from iChannel0\n        fragColor = vec4(b);\n        \n        //fragColor = vec4(b, 0.1, b, cos(iTime));//Set the screen pixel to that color\n    } else {\n    fragColor=vec4(0,0,0,1);\n    }\n    fragColor *= 1./(1.+f*f*.001);\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}