{
    "Shader": {
        "info": {
            "date": "1497634955",
            "description": "looks silly whileIi learn...\n\npause time.\ndraw rays by holding down mouse.\n\nI want straight lines to intersect on the circle! \nso far only curved lines intersect (duuuh, its is circle inversion)\nmay not be possible, may be possible. i do not know.",
            "flags": 0,
            "hasliked": 0,
            "id": "MslfRl",
            "likes": 6,
            "name": "circle inversion laser",
            "published": 3,
            "tags": [
                "ray",
                "circle",
                "inversion",
                "claw",
                "intersectionline",
                "sickle"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 671
        },
        "renderpass": [
            {
                "code": "//parent: https://www.shadertoy.com/view/lslfRl\n\n#define camLens 6.\n#define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y \n\n//#define fractit\n\n//#define mixRatio sin(iTime)*.5+.5\n//#define mixRatio 0.\n#define mixRatio 1.\n//#define mixRatio -1.\n//#define mixRatio 2.\n\n//different types of sphere inversios, some are \"one way\" only.\n//#define invert(a) a.x=max(a.x,1./a.x)\n//#define invert(a) a.x=min(a.x,1./a.x)\n#define invert(a) a.x=1./a.x\n\n\n\n/*\nthe idea behind this was my thesis, that turned to be false:\nbecause i treated inersion as if it is refraction.\n\nanyways:\nif(origin is outside of circle)\n...the CUVED lines intersed on the circle.\n...This does not help me now, but looks neat anyways.\n\nbut i got a nice sandbox for textures ou if it.\n\nThis projects onto a UNIT circle, with origin vee2(0,0) and radius float 1.;\nYou want to calculate the NEAREST inttersection of a line and a circle (or sphere...)\nThe classic solution branches a lot, and it swivels near and far intersection.\nThe classic solution is all not too pretty, I despise branhes.\nthere is a simple sub-case: if(rayOrigin is INSIDE the circle)\n- this ray2circle intersection case has NULL branches, always exactly one intersection.\n- a circle inversion projects the if(rayOrigin OUTSIDE OF In the circle)\n- ... into the simpler if(rayOrigin is INSIDE the circle) case.\n- ... and they result in the same rayToCircle intersection point.\nCircle inversion enables to use the same subroutine for 3 cases,wapped in one conditional:\nif (rayIntersectsSphere)==(gSRx()) (function exists below)\n- if(length(origin)< 1.)                return rayinsideSphere()//origin is inside circle\n- if(length(origin)> 1.) circleInvert() return rayinsideSphere()//origin is outside circle\n- if(length(origin)==1.)                return origin;//seems like a shortcut\nThis looks to me like smart clean reusing code.\nA caveat is the atan2() of circleInvert().\n*/\n\n\n//ray [o,d]origin.,direction starts inside sphere [r]radios \n//return intersection of ray from within sphere (is less brancing)\nvec3 rayinsideSphere(float r,vec3 o,vec3 d){\n if(d==vec3(0))return vec3(0);\n float a=dot(d,d);\n float b=2.*dot(d,o);\n float c=dot(o,o)-r*r;\n float e=b*b-4.*a*c;\n //if(disc<0.)return vec3(0);\n e=sqrt(e);\n float q;\n if(b<0.)q=(-b-e)*.5;\n else    q=(-b+e)*.5;\n vec2 t=vec2(q/a,c/q);//t stores 2 intersection distances.\n if(t.x>t.y)t=t.yx;//swivel to make t.x closest intersection.\n t.x=mix(t.x,t.y,step(t.x,0.));//if(t.x>0.)t.x=t.x;else t.x=t.y;\n return o+(t.x*d);}//second life wiki geometric\n/*\n//above and below make me think about sphere inverting below, \n//to become the above, for the case where intersection exists.\n//return intersection of [o]RayOrigin  [d]RayDirection and circle [r]Radius \n//this branches too often\nvec3 gSRxX(float r, vec3 o, vec3 d){\n if(r>length(o))return rayinsideSphere(r,o,d);\n //float t; //o -= Sp;\n if(d==vec3(0))return vec3(0);\n float a=dot(d,d);\n float b=2.*dot(d,o);\n float c=dot(o,o)-r*r;\n float disc=b*b-4.*a*c;\n if(disc<0.)return vec3(0);\n disc=sqrt(disc);\n float q; \n if(b<0.)q=(-b-disc)*.5;\n else    q=(-b+disc)*.5;\n vec2 t=vec2(q/a,c/q);//t stores 2 intersection distances.\n if(t.x>t.y)t=t.yx;//swivel to make t.x closest intersection.\n //there seems to be some sign nonsense going on here.\n //...because this unifies the cases of originInsideCircle and OriginOutsideCircle\n if(t.y<0.)return vec3(0);//both negative, sphere is behind camera.\n t.x=mix(t.x,t.y,step(t.x,0.));//if(t.x>0.)t.x=t.x;else t.x=t.y;\n return o+(t.x*d);}//second life wiki geometric\n*/\n\n//return if(ray intersects sphere) [r]radius [o]RayOrigin [d]RayDirection\nbool gSRx(float r, vec3 o, vec3 d){\n //if(d==vec2(0)) return false;\n float b=2.*dot(d,o);\n if(b*b-4.*dot(d,d)*(dot(o,o)-r*r)<0.)return false;return true;}\n\n#define tau acos(-1.)*2.\n#define Phi (sqrt(5.)*.5+.5)\n#define phi (sqrt(5.)*.5-.5)\n\n\n//return polar of carthesian\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian of polar\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n\n//mirror around half rotated axis.\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//return distance to ray_from_(0,0)_to_(0,infinity)=\"Infinite Line Segment\"\nfloat ils(vec2 u){return mix(length(u),abs(u.y),step(u.x,0.));}\n//return distance to ray from [a] trough [b]\nfloat ils2(vec2 b,vec2 a){vec2 d=b-a;return ils(a*r2(atan(d.y,d.x)));}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\tvec2 u=frame(U);\n    vec2 m=frame(iMouse.xy);\n    vec2 n=frame(iMouse.zw);\n    if(length(m-n)<.1)n.x+=1.;//direction is never vec2(0)\n    if(iMouse.z<=0.){\n     m=vec2(0.,sin(iTime))*Phi;\n     n=vec2(cos(iTime),0.)*phi;\n    m*=2.;\n    n*=2.;\n    }\n    \n\n    u.x+=sin(iTime);\n    u.y+=cos(iTime);    \n    m.x+=sin(iTime);\n    m.y+=cos(iTime);\n    n.x+=sin(iTime);\n    n.y+=cos(iTime);\n    \n    float w=ils2(m-u,n-u);//THIN white line happens before transforming to polar.   \n    float blur = 0.025;\n    float l=smoothstep(-blur,blur,abs(1.-length(u))-blur);\n    //indicate sphere boundary by making points near (l=0) darker. \n    u=c2p(u);\n    m=c2p(m);\n    n=c2p(n);\n    vec2 a=u;if(a.x<1.)a.x=1./a.x;//if(inside unit circle)  do circle inversion\n    vec2 b=u;if(b.x>1.)b.x=1./b.x;//if(outside unit circle) do circle inversion\n    u=mix(a,b,mixRatio);\n    invert(u);\n    //invert(m);\n    //invert(n);\n    w=min(w,ils2(m-u,n-u));\n    \n    u=p2c(u);\n    m=p2c(m);\n    n=p2c(n);   \n    //w=min(w,ils2(m-u,n-u));\n    \n    float g=ils2(m-u,n-u);\n    u.x-=cos(iTime);\n    u.y-=sin(iTime);\n    m.x-=cos(iTime);\n    m.y-=sin(iTime);\n    n.x-=cos(iTime);\n    n.y-=sin(iTime);\n   \n    float c=length(m-u);\n    float d=length(n-u);\n    g=min(g*3.,min(c,d));\n    \n    u=fract(u*camLens);\n    u.x*=.5;\n    #ifdef fractit\n    g=fract(g*5.);\n    #else \n    g=smoothstep(blur,-blur,g-.1);\n    #endif   \n    w=smoothstep(blur,-blur,w-.001);\n    vec3 e=u.x*vec3(1,.5,0)+u.y*vec3(.5,0,1)+g*vec3(0,1,.5)+w*vec3(1,1,1);\n    e=min(e,vec3(l));\n    //BlackredBluePurple->BlackYellowCyanWhite == more contrast on lcd or oled.\n    O = vec4(e,1);\n}\n\n//doto, in3d, via\n//https://en.wikipedia.org/wiki/List_of_common_coordinate_transformations",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}