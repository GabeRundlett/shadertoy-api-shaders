{
    "Shader": {
        "info": {
            "date": "1624065994",
            "description": "Learning cube/bmp mapping surfaces, mapping/finding cube face from @Shane's comments and code. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Nlj3Wm",
            "likes": 9,
            "name": "Dice part IV - [bmp/cube map]",
            "published": 3,
            "tags": [
                "raymarching",
                "cube",
                "cubemap",
                "bumpmap"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "/**\n     _____     __     ______     ______   \n    /\\  __-.  /\\ \\   /\\  ___\\   /\\  ___\\  \n    \\ \\ \\/\\ \\ \\ \\ \\  \\ \\ \\____  \\ \\  __\\    \n     \\ \\____-  \\ \\_\\  \\ \\_____\\  \\ \\_____\\ \n      \\/____/   \\/_/   \\/_____/   \\/_____/   \n                                             \n                                             \n    I got schooled by @Shane on my last shader - I was using geometry\n    to create the dots on the dice objects in the map loop. It works but\n    gets heavy fast from the opertations and marching loop calls.\n\n    I originaly tried to figuring out the surface to cube map thing, thinking\n    drawing would be easier, but quickly I failed from lack of math skills. \n\n    However Shane's comment had the basic formula I had wrong. With\n    some research and understanding of his very cool 'Dice' shader I was able\n    to rework my original code to use this method. I feel that I have almost \n    learned how it all works!\n\n    06/18/2021 @byt3_m3chanic\n    \n    /////////////////////////////////////////////////////////////////////////\n    \n    // Reflection loop based off @BigWings tutorial.\n    // https://youtu.be/beNDx5Cvt7M\n    \n    // Bits and pieces - most folks here prob know this stuff.    \n    // http://web.cs.wpi.edu/~emmanuel/courses/cs4731/A14/slides/lecture21.pdf\n    \n    // @Shane's very cool moving dice shader\n    // https://www.shadertoy.com/view/3sVBDd\n\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    75.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\n//@iq\nfloat cap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat g_hs,s_hs;\nmat2 turn,ria,gia;\n\nvec2 map(vec3 pos, float sg)\n{\n    pos.y-=2.25;\n\n    vec2 res = vec2(1e5,0.);\n    vec3 q = pos-vec3(0.,.75,0.);\n\n    float amount = 16.;\n    //@Shane polar rep\n    float a = atan(q.z, q.x);\n    float ia = floor(a/6.2831853*amount);\n    ia = (ia + .5)/amount*6.2831853;\n    //id cell and wave function\n    float id = -mod(ia,.0);\n    float cy = sin( id*4. + (iTime * .5) * PI) * .95;\n\n    mat2 rxa = rot(ia);\n    q.xz *= rxa;\n    q.xy -= vec2(7.75,-cy);\n  \n    float hs = hash21(vec2(id,3.34));\n    int pk = int(floor(hs*10.));\n\n    //dice rotation\n    vec3 dp = q;\n    dp.yx*=turn;\n    dp.zx*=turn;\n\n    float d1 = box(dp,vec3(.425))-.15;\n    if(d1<res.x)\n    {\n        res = vec2(d1,2.);\n        hit=dp;\n        g_hs=hs;\n        ria=rxa;\n    }\n\n    float bse = cap(pos-vec3(-2.5, .0,-3) ,2.,2.5);\n    bse=min(length( pos-vec3( 2.2,-.4, 3))-2.,bse);\n    if(bse<res.x)\n    {\n        res=vec2(bse,3.);\n    \thit=pos;\n    }\n    \n    float flr = pos.y+2.5;\n    if(flr<res.x)\n    {\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32 ? ray.x*.5 : ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\n// https://learnopengl.com/Advanced-Lighting/Gamma-Correction\nvec3 decodeSRGB(vec3 screenRGB) { return pow(screenRGB, vec3(2.2)); }\n\n// Tri-Planar blending function. GPU Gems 3 - Ryan Geiss:\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), MIN_DIST);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n    //return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\nvec3 getDiceFace(int face, vec3 p)\n{\n    float cir = 0.;\n    if(face==0) {\n        cir = length(abs(p.yz)-.25);\n    }\n    if(face==1) {\n        cir = length(p.zx);\n        cir = min(length(abs(p.zx)-.25),cir);\n    }\n    if(face==2) {\n        cir = length(p.xy-vec2(.25,.25));\n        cir = min(length(p.xy+vec2(.25,.25)),cir);\n    }\n    if(face==3) {\n        cir = length(p.xy-vec2(.25,.25));\n        cir = min(length(p.xy+vec2(.25,.25)),cir);\n        cir = min(length(abs(p.xy)-.25),cir);\n    }\n    if(face==4) {\n        cir = length(abs(p.xz)-.25);\n        cir = min(length(vec2(abs(p.x)-.25,p.z)),cir);\n    }\n    if(face==5) {\n        cir = length(p.zy);\n    }\n\n    cir=smoothstep(.095,.0,cir);\n    \n    return vec3(1.-cir);\n}\n// based on bmp mapping from\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( vec3 p, vec3 n, float bf, float per, int face){\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        getDiceFace(face, p - e.xyy), \n        getDiceFace(face, p - e.yxy), \n        getDiceFace(face, p - e.yyx)\n    );\n    // Converting to greyscale.\n    vec3 g = vec3(0.299, 0.587, 0.114) * m; \n    g = (g - dot(getDiceFace(face, p), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);  \n    // return offset normal\n    return normalize( n + g*bf );\n}\nvec4 FC = vec4(0.322,0.443,0.459,0.);\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,164, 1.);\n\n    hitPoint = hit;\n    s_hs=g_hs;\n    gia=ria;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(10,10,-5);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n        vec3 cuv;\n        int face;\n        vec3 tn = n;\n        if(m==2.){\n            \n            tn = n;\n            tn.xz*=gia;\n\n            tn.yx*=turn;\n            tn.zx*=turn;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n            \n            // set coords\n            if(face==0) cuv = hp.xyz;\n            if(face==1) cuv = hp.xyz;\n            if(face==2) cuv = hp.xyz;\n            if(face==3) cuv = hp.xyz;\n            if(face==4) cuv = hp.zyx;\n            if(face==5) cuv = hp.xyz;\n       \n            // get bump map surface\n            n=doBumpMap( cuv, n, 1., d, face);\n        }\n\n        float diff = clamp(dot(n,l),0.,1.);\n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        \n        //soft shadows\n        float shdw = 1.0;\n        for( float t=.01; t < 22.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h * .95;\n            if( shdw<MIN_DIST || t>64. ) break;\n        }\n        // get diff + shadows\n        diff = mix(diff,diff*shdw,1.-fresnel);\n        // spec\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), (m==2.||m==4.)?24.:64.);\n        \n        // materials and reflections\n        if(m==1.){\n            vec2 f = fract(hitPoint.xz*.15)-.5;\n            if(f.x*f.y>0.){\n                h=decodeSRGB(texture(iChannel0,f*2.).rgb);\n                ref = clamp(h-fresnel,vec3(0),vec3(1));\n            }else{\n                h= vec3(0.467,0.718,0.753);\n                ref = (h*.2)-fresnel;\n            }\n            C = (diff*h)+ min(spec,shdw);\n        }\n        if(m==2.){\n            // get dice face texture\n            h = tex3D(iChannel0,cuv,tn).rgb;\n            ref = h-fresnel;\n            C = (diff*h);\n        }\n        if(m==3.){\n            ref = vec3(.8)-fresnel;\n            C = (diff*h)+ min(spec,shdw);\n        }\n        \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    } else {\n        C = FC.rgb;\n        ref=vec3(.35);\n    }\n\n    C = mix(FC.rgb,C,  exp(-.000025*d*d*d));     \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    turn = rot(T*55.*PI/180.);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,14.);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    //mouse\n    float x = M.xy == vec2(0) ? .5 : .5-(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    if(x<-.005)x=-.005;\n    mat2 rx = rot(x);\n    mat2 ry = rot(y+T*5.*PI/180.);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 3.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.00002*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}