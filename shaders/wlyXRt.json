{
    "Shader": {
        "info": {
            "date": "1583345124",
            "description": "Green : native 1/x, sqrt and 1/sqrt\nRed : approximation by exploiting the logarithmic binary representation of floats\nPurple : red + one Newton iteration",
            "flags": 0,
            "hasliked": 0,
            "id": "wlyXRt",
            "likes": 9,
            "name": "Float bit hacking",
            "published": 3,
            "tags": [
                "fastsqrt",
                "fastinversesqrt",
                "fastinverse"
            ],
            "usePreview": 0,
            "username": "ockiller",
            "viewed": 1322
        },
        "renderpass": [
            {
                "code": "// \"Fast\" inverse, sqrt and 1/sqrt using the fact that the binary representation of a float\n// is like taking its logarithm (it's pretty close).\n//\n// They are the only interesting \"x^exponent\" functions that can be approximated like that\n// as the exponent must be between -1 and 1 to avoid integer overflows.\n//\n//\n// Mathematical explanations\n// -------------------------\n// floatBitsToUint(x) ~= 2^23 * log2(x) + floatBitsToUint(1.0) = logF(x) + 0x3F800000u\n// logF(x) ~= floatBitsToUint(x) - 0x3F800000u\n//\n// uintBitsToFloat(i) ~= exp2((i - 0x3F800000u) / 2^23) = expF(i - 0x3F800000u)\n// expF(i) ~= uintBitsToFloat(i + 0x3F800000u)\n//\n// x^y = expF(y * logF(x)) ~= uintBitsToFloat(y * (floatBitsToUint(x) - 0x3F800000u) + 0x3F800000u)\n//\n//\n// More precision (pun intended)\n// --------------\n// You can tweak the magic constant 0x3F800000u to spread the error more evenly. Then, you can\n// enhance precision with Newton iterations. For the expression y = x^c, we get:\n// y = y - c * (y^(1/c) - x) / y^(1/c - 1)\n// Pretty useless in the general case as it contains operations we wanted to approximate\n// in the first place, but for some exponents c it can be simplified a lot.\n// You can also tweak the coefficients you get in these iterations to get even more precision.\n//\n// Putting all together for c = -0.5, you will end up with the famous \"Quake 3 fast rsqrt\":\n// https://en.wikipedia.org/wiki/Fast_inverse_square_root\n// which is probably the only case where it worked well, at a time where FPUs were slow.\n// Don't expect it to be faster on a GPU or on a modern CPU though.\n\n#define C(v) smoothstep(1.0, 0.0, abs(v - U.y) * R.y / (0.5 * R.x * min(v, fwidth(v)) + 1.0))\n\nfloat inverseNewton(float x, float guess) { return guess * (2.0 - x * guess); }\nfloat sqrtNewton   (float x, float guess) { return 0.5 * (guess + x / guess); } // div :(\nfloat invSqrtNewton(float x, float guess) { return guess * (1.5 - 0.5 * x * guess * guess); }\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, U = u / R;\n    O = vec4(vec3(0.0), 1.0);\n    \n    // 1/x = expF(-logF(x))\n\tfloat fastInverse = uintBitsToFloat(0x7F000000u - floatBitsToUint(U.x));\n//\tfloat fastInverse = uintBitsToFloat(0x7EF40000u - floatBitsToUint(U.x));\n    float fastInverseN1 = inverseNewton(U.x, fastInverse);\n    O.rgb += C(0.2 * vec3(fastInverse, 1.0 / U.x, fastInverseN1));\n   \n    // sqrt(x) = expF(logF(x) / 2)\n\tfloat fastSqrt = uintBitsToFloat((floatBitsToUint(U.x) >> 1) + 0x1FC00000u);\n//\tfloat fastSqrt = uintBitsToFloat((floatBitsToUint(U.x) >> 1) + 0x1FBC0000u);\n    float fastSqrtN1 = sqrtNewton(U.x, fastSqrt);\n    O.rgb += C(vec3(fastSqrt, sqrt(U.x), fastSqrtN1));\n    \n    // 1/sqrt(x) = expF(-logF(x) / 2)\n\tfloat fastInvSqrt = uintBitsToFloat(0x5F400000u - (floatBitsToUint(U.x) >> 1));\n//\tfloat fastInvSqrt = uintBitsToFloat(0x5F3759DFu - (floatBitsToUint(U.x) >> 1));\n    float fastInvSqrtN1 = invSqrtNewton(U.x, fastInvSqrt);\n    O.rgb += C(0.2 * vec3(fastInvSqrt, 1.0 / sqrt(U.x), fastInvSqrtN1));\n\n    O.r += O.b;\n    O.rgb = sqrt(O.rgb);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}