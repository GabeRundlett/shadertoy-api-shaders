{
    "Shader": {
        "info": {
            "date": "1532689276",
            "description": "this shader is identical to its parent, BUT its polar-complex-function subroutines are in a different form. some of these might have better performance.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "4tdcD4",
            "likes": 13,
            "name": "complex transform rainbow",
            "published": 3,
            "tags": [
                "rainbow",
                "complex",
                "polar"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 571
        },
        "renderpass": [
            {
                "code": "\n//parent=https://www.shadertoy.com/view/Mt2GDV\n\n//lots of code from a shader,made by Tapio Saarinen aka twitter user @_ardeej\n//just slightly crunched with minot optimizations\n//some os this is \n//by David Bargo-davidbargo/2015\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// constants\nfloat pi =acos(-1.);\nfloat tau=6.2831853071795864769252867665590057683943387987502116419;\nfloat e  =2.7182818284590452353602874713526624977572470936999595749;//exists as y=exp(1.)???\n#define dd(a)dot(a,a)\nfloat mav(vec2 a){return max(a.x,a.y);}\n\n\n#define dd(a)dot(a,a)\nfloat suv(vec2 a){return a.x+a.y;}\nfloat sub(vec2 a){return a.x-a.y;}\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2\nvec2 cs(float a){return vec2(cos(a),sin(a));}\nvec2 c2p(vec2 a){return vec2(length(a),atan(a.y,a.x));}\nvec2 p2c(vec2 z){return cs(z.x)*z.y;}//polar to cartesian\nmat2 r2(float a){return mat2(cs(a).xyyx*vec4(1,-1,1,1));}\nfloat arg(vec2 z){return atan(z.y,z.x);}//atan2()is aka \"arg,phase\" //length()is aka \"rad,amplitude\"\n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c2(c)=(c.a-c.b*i)\n#define c2(a)c4(anaa(a)).xy\n//#define c2(a)c4(anaa(a)).yx\n//c4(ana1(a)).yx //flawed but cute does vec2(a,1),wich is wrong,should do vec2(a,a)\n//c4(anaa(a)).yx //should do vec2(a,a)\n//#define c2(a)((a)*vec2(1,-1))\n//conjugate(z)is generalized into c2(),to also expand on vec1,must be in [()] for explicit order of operation in complex transforms\n//c2(a)flips horizontally by multiplying with *vec2(1,-1)\n//c2(a.yx).yx ==//a*vec2(-1,1)//sqivel,flip,swivel==flip vertically\n//c4()is 2 complex conjugates in parallel on a vec4.\n\n\n\n\n//real and imaginary parts for polar z\nfloat real(vec2 z){return p2c(z).x;return z.s*cos(z.t);}\nfloat imag(vec2 z){return p2c(z).y;return z.s*sin(z.t);}\n\nvec2 crCo(vec2 a){return sqrt(length(a)+c2(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nvec2 ciCo(vec2 u,vec2 z,float r){return vec2(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\nvec2 perp(vec2 a){return vec2(-a.y,a.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\n//http://wiki.secondlife.com/wiki/Geometric#Line_and_Line.2C_intersection_point\nfloat perpdot(vec2 a,vec2 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nvec2 addc(vec2 a,vec2 b){return a+b;}vec2 subc(vec2 a,vec2 b){return a-b;}///complex addition is trivial\nvec2 mulc(vec2 a,vec2 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nvec2 mulc(vec2 a,vec2 b,vec2 c){return mulc(mulc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nvec2 mulc(vec4 a){return mulc(a.xy,a.zw);}//parallel mult\nvec2 divc(vec2 a,vec2 b){if(a.x==0.)return vec2(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\n//vec2 po2c(vec2 a){return mulc(a,a);return vec2(sub(a*a),2.*a.x*a.y);}//complex square\nvec2 po2c(vec2 c){vec2 d=c*c;return vec2(d.x-d.y,2.*c.x*c.y);}\nvec2 po3c(vec2 z){float p=z.x*z.x,q=z.y*z.y;return z*vec2(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nvec2 recc(vec2 a){if(a.x==0.)return vec2(1e10);return c2(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\n\nvec2 logc(vec2 a){a=c2p(a);a.x=log(a.x);return a;}//return vec2(log(dd(a))*.5,arg(a));}\nvec4 logc(vec4 a){return vec4(logc(a.xy),logc(a.zw));}//parallel logc()\nvec2 logb(vec2 a,vec2 b){return divc(logc(b),logc(a));}//principal branch of the logarithm base b of z,b is complex;\nvec2 logn(vec2 a,float c){return vec2(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\n//vec2 logn(vec2 a,float c){a=c2p(a);return vec2(log(a.x),a.y+c*tau);}//should be the same!\nvec2 lgbn(vec2 a,vec2 b,float c){return divc(logn(b,c),logc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\n\nvec2 expc(vec2 a){return cs(a.y)*exp(a.x);}//pow(exp,a)=pow(eul,a)=pow(eul,a(cos(b)+sin(b)*i))\nvec2 powc(vec2 a,vec2 b){return expc(mulc(b,logc(a)));}//pow(b,z)=exp(b*log(a))//0th==principal   branch of pow(z,W)\nvec2 pown(vec2 w,vec2 z,float c){return expc(mulc(w,logn(z,c)));} //Cth branch of pow(z,w)\nvec2 wrtc(vec2 a,vec2 b){return expc(divc(logc(b),a));}//0th==principal   branch of pow(z,(1/w))\nvec2 wrtn(vec2 a,vec2 b,float c){return expc(divc(logn(b,c),a));}//Cth branch of pow(z,(1/w))\n\nvec2 sqrc(vec2 a){float n=a.x+length(a);return vec2(n,a.y)/sqrt(2.*n);}//sqrt(z)= sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nvec4 sqrc(vec4 a){vec4 c=vec4(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\n//vec2 sqrc(vec2 z){vec2 c=sqrt((length(z)+c2(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\n\nvec2 sinc(vec2 z){return .5*cs(z.x).yx*(exp(z.y)+c2(exp(-z.y)));}//vec2 sinc(vec2 z){return vec2(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  vec2 sinc(vec2 c){vec2 d=exp(c2(c.y));return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 si2c(vec2 c){vec2 d=vec2(exp(c.y),1);return vec2(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nvec2 cosc(vec2 z){return .5*c2(cs(z.x))*(exp(z.y)+c2(exp(-z.y)));}\n//obsoleted vec2 cosc(vec2 z){ return vec2(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted vec2 cosc(vec2 c){vec2 d=exp(c2(c.y));return vec2(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nvec2 ta2c(vec2 c){vec2 d=exp(c2(c.y));float e=cos(c.x),s=(d.x-d.y)*.5;return vec2(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nvec2 tanc(vec2 z){return divc(sinc(z),cosc(z));}//tan(z)=sin(z)/cos(z),complex tangent ==ta2c()\nvec2 cotc(vec2 z){return divc(cosc(z),sinc(z));}//cot(z)=cos(z)/sin(z),complex cotangent\n\n////hyperbolics\n// sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nvec2 sinhc(vec2 z){return .5*cs(z.y)*(exp(z.x)+c2(exp(-z.x)).yx);}//vec2 sinh(vec2 z){ return 0.5*vec2((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//vec2 sinh2c(vec2 z){z=c2(z).yx;return sinc(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)= cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nvec2 coshc(vec2 z){return cosc(c2(z.yx));}//vec2 cosh(vec2 z){ return vec2(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\nvec2 tanhc(vec2 z){return divc(sinh(z),cosh(z));}//tanh(z)=sinh(z)/cosh(z),hyperbolic tangent\nvec2 cothc(vec2 z){return divc(cosh(z),sinh(z));}//coth(z)=cosh(z)/sinh(z),hyperbolic cotangent\nvec2 sechc(vec2 z){return recc(cosh(z));}//sech(z)=1/cosh(z),hyperbolic secant\nvec2 cschc(vec2 z){return recc(sinh(z));}//csch(z)=1/sinh(z),hyperbolic cosecant\n\n//these look stranger than they likely shozld,possibly buggy\nvec2 arsinc(vec2 z){return c2(logc(perp(z)+sqrc(c2(po2c(z.yx)))+vec2(1,0)).yx);}// arsinc(z)=-log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//vec2 arsinc(vec2 z){vec2 a=sqrc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=logc(vec2(-z.y+a.x,z.x+a.y));return vec2(a.y,-a.x);}\nvec2 arcosc(vec2 z){return -c2(logc(z+c2(sqrc(po2c(z.yx)+vec2(1,0)).yx)).yx);}//arcosc(z)= log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//vec2 arcosc(vec2 z){ vec2 a=sqrc(vec2(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=logc(vec2(z.x+a.y,z.y-a.x));return vec2(-a.y,a.x);}\nvec2 csec(vec2 z){return recc(cosc(z));}//sec(z)=1/cos(z),complex __secant==complex inverse of complex cosine\nvec2 ccsc(vec2 z){return recc(sinc(z));}//csc(z)=1/sin(z),complex cosecant==complex inverse of complex __sine\n\n\n\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//\n//arcotc(z)=i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nvec2 arcotc(vec2 z){float r=z.x*z.x+z.y*z.y;return sub2(c4(logc((vec4(z.yx,-z.yx)+vec4(r,0,r,0)).yxzw/r)))*.5;}//vec2 arcotc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=logc(vec2(p+q-z.y,-z.x)/r);vec2 b=logc(vec2(p+q+z.y,z.x)/r);return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//artanc(z)=i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tanhc(artanh(c))has some symmetry,but may still be broken\nvec2 artanc(vec2 z){return sub2(c4(logc(vec4(1,0,1,0)-c2(z.yx).xyxy).yxwz))*.5;}//vec2 artanc(vec2 z){ vec2 a=logc(vec2(1.0+z.y,-z.x));vec2 b=logc(vec2(1.0-z.y,z.x));return vec2(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)=-log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nvec2 arcsec(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=suv(u);return c2(logc(sub2(c4(vec4(z,sqrc(ciCo(u,z,r)).yx)))).yx)+vec2(0.,log(r));}//vec2 arcsec(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r-p+q,2.0*z.x*z.y));a=logc(vec2(z.x-a.y,a.x-z.y));return vec2(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)=-log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nvec2 arccsc(vec2 z){vec2 u=vec2(z.x*z.x,z.y*z.y);float r=suv(u);return c2(logc(z.yx+sqrc(ciCo(u,z,r))).yx)+vec2(0.,log(r));}//vec2 arccsc(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r-p+q,2.0*z.x*z.y));a=logc(vec2(a.x+z.y,a.y+z.x));return vec2(a.y,log(r)-a.x);}\n\n//arcsch(z)=log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),// inverse hyperbolic cosecant\nvec2 arcsch(vec2 z){vec2 u=z*z;float r=suv(u);return logc(c2(z)+sqrc(ciCo(u.yx,z,r)))-vec2(0,log(r));}//vec2 arcsch(vec2 z){ float p=z.x*z.x;float q=z.y*z.y;float r=p+q;vec2 a=sqrc(vec2(r*r+p-q,-2.0*z.x*z.y));a=logc(vec2(a.x+z.x,a.y-z.y));return vec2(a.x-log(r),a.y);}\n\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nvec2 arsinh(vec2 z){return logc(z+sqrc(po2c(z)+vec2(1,0)));}//arsinh(z)=log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nvec2 arcosh(vec2 z){return logc(z+mulc(sqrc(z.xyxy+vec4(1,0,-1,0))));}//arcosh(z)=log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)= log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artanc(c))is uniform ,artanc(artanh(c))is white\nvec2 artanh(vec2 z){float r=1.-suv(z*z);z*=2.;return .5*logc(-vec2(r,z.y)/(r+z.x));}//vec2 artanh(vec2 z){float r=z.x*z.x+z.y*z.y;return logc(vec2(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)=log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nvec2 arcoth(vec2 z){;float r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*logc(vec2(r,z.y)/(r+2.+z.x));}//vec2 arcoth(vec2 z){ float r=z.x*z.x+z.y*z.y;return logc(vec2(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n\n//arsech(z)=log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nvec2 arsech(vec2 z){float r=suv(z*z);return logc(c2(z)+mulc(sqrc(vec4(-r,0,r,0)+c2(z).xyxy)))-vec2(log(r),0);}//ok-ollj\n\n\n\n\nvec2 func(float i,vec2 c){vec2 r\n ///;i=1.\n ;vec2 m=iMouse.xy/iResolution.xy\n //;float t=cos(iTime*2.)*.5+.5\n //;c=vec2(.1);if(mav(abs(sinh2c(c)-sinhc(c)))<.001)c=vec2(0.4)\n //;c=vec2(.1);if(mav(abs(ta2c(c)-tanc(c)))<.001)c=vec2(0.)\n //;if(i==1.)c=mix(sqrc(c),sqrc(c),1.)\n //;if(i==1.)c=mix(sinhc(c),sinh2c(c),t)\n //;if(i==1.)c=arsechO(sinh(c))\n ;if(i==1.)c=cosc((c))\n //;if(i==1.)c=mix(mulc(c,m),mulc(c,m),t)\n //;if(i==1.)c=mix(mulc(c,c),sinc(c),t)\n// ;if(i==1.)c=mix(mulc(c,c),po2c(c),t)\n\n ;else if(i==2.)c=sqrc(divc(logc(vec2(-c.y-6.,c.x)),logc(vec2(-c.y+2.,c.x))));\n else if(i==3.)c=expc(c);\n else if(i==4.)c=tanc(tanc(c));\n else if(i==5.)c=tanc(sinc(c));\n else if(i==6.)c=sqrc(vec2(1.+c.x,c.y))+sqrc(vec2(1.-c.x,-c.y));\n else if(i==7.)c=divc(tanc(po2c(c)),c);\n else if(i==8.)c=sinc(cosc(sinc(c)));\n else if(i==9.)c=recc(vec2(1,0)+expc(vec2(c.y,c.x)));\n else if(i==10.)c=expc(recc(sqrc(-c)));\n else if(i==11.)c=po2c(recc(c));\n else if(i==12.)c=expc(sinc(expc(cosc(c))));\n else if(i==13.)c=divc(sinc(c),c);\n else if(i==14.)c=po2c(c);\n else if(i==15.)c=divc(sinc(c),cosc(po2c(c)));\n else if(i==16.)c=recc(c+vec2(1,0))+recc(c-vec2(1,0));\n else if(i==17.)c=logc(c-recc(c));\n else if(i==18.)c=divc(sqrc(vec2(c.x+1.,c.y)),sqrc(vec2(c.x-1.,c.y)));\n else if(i==19.)c=recc(vec2(1,0)+mulc(c,po2c(po2c(c))));\n /**/\n ;return c;}\n\n//2d rotation by iTime\nvec2 animate(vec2 v){\n float s=sin(iTime),c=cos(iTime);return v*mat2(c,-s,s,c);}\n\n//color space\nvec3 hsv2rgb(in vec3 c){//iq's smooth hsv to rgb\n vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);\n rgb=rgb*rgb*(3.0-2.0*rgb);return c.z*mix(vec3(1),rgb,c.y);}\n\n//for tiling grid,by aiekick https://www.shadertoy.com/view/4lj3Ww\nvec2 gridSize=vec2(5,4);\nvec3 getCell(vec2 s,vec2 h){vec2 c=floor(h*gridSize/s);\n return vec3(c.x,c.y,(gridSize.y-1.-c.y)*gridSize.x+c.x);}\nvec3 getSmallCells(vec2 s,vec2 h){\n vec3 c=getCell(s,h);vec2 g=s/gridSize;float r=g.x/g.y;\n vec2 u=pi*((2.*h-g)/g.y-2.*vec2(c.x*r,c.y));return vec3(c.z,u);}\n\nvoid mainImage(out vec4 O,vec2 In\n){vec2 e=iResolution.xy\n ;vec3 c=iMouse.z>0.\n  ?vec3(getCell(e,iMouse.xy).z,pi*(2.*In-e)/(e.y))//fullscreen cell \n  :getSmallCells(e,In)//tiled cells\n ;vec2 z=animate(func(c.x,c.yz))*2.\n ;float h=atan(z.y,z.x)/(2.*pi)\n ;float l=length(z)\n ;float s=abs(fract(l)-.5)-.25;s=step(0.,s)*s*4.;s=1.-s*s\n ;vec2  r=abs(fract(z)-.5)-.25;r=step(0.,r)*r*4.;r=1.-r*r*r*r\n ;float v=mix(1.,r.x*r.y,s*.5)\n ;O=vec4(hsv2rgb(vec3(h,s,v)),1.);}\n \n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}