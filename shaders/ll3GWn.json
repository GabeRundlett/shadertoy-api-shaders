{
    "Shader": {
        "info": {
            "date": "1468636715",
            "description": "A rocket inside a rocket inside a rocket, slowly climbing into space. But where is the payload? Use the mouse to rotate the camera.",
            "flags": 0,
            "hasliked": 0,
            "id": "ll3GWn",
            "likes": 37,
            "name": "[SH16B] Recursive Rocket",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "space",
                "sh16b"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 1995
        },
        "renderpass": [
            {
                "code": "\n#define DITHER\n\n#define PI 3.14159265359\n#define SCALE 2.5\n#define MARCH_DIST 0.5\n#define MARCH_STEPS 30\n#define sunColor vec3(1.0, 0.9, 0.65)*2.0\n#define nozColor vec3(1.0, 0.3, 0.0)*4.0\n\nfloat fracSequence = 0.0;\nfloat fracFall = 0.0;\nfloat fracTotal = 0.0;\nfloat fracScale = 0.0;\nvec3 nozzlePosition = vec3(0);\nfloat nozzleStrength = 0.0;\nfloat altSpaceFrac = 0.0;\nmat2 altRot = mat2(0);\nmat2 altHeading = mat2(0);\nfloat altAccel = 0.0;\nvec3 sunDir = vec3(0);\nfloat sunStrength = 0.0;\nvec3 backgroundColor = vec3(0);\n\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\n// 1D noise\nfloat hash( in float n ) { return fract(sin(n)*753.5453123); }\n\n// iq's 3D noise\nfloat noise( in vec3 x ) {\n    vec3 f = fract(x);\n    vec3 p = x - f;\n    f = f*f*(3.0 - 2.0*f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0, (uv + 0.5)/256.0, 0.0).rg;\n    return mix(rg.y, rg.x, f.z);\n}\n\n// iq's fog\nvec3 fog( in vec3 rgb, in float dist, in vec3 rayOri, in vec3 rayDir ) {\n    float c = 0.01;\n    float b = 0.3;\n    rayOri -= 8.0;\n    rayOri += altSpaceFrac*9.0;\n    float fogAmount = c * exp(-rayOri.z*b) * (1.0-exp( -dist*rayDir.z*b ))/rayDir.z;\n    fogAmount = clamp(fogAmount, 0.0, 1.0);\n    vec3 fogColor = backgroundColor;\n    return mix( rgb, fogColor, fogAmount );\n}\n\n// fairing shape, [0, 1] -> [0, 1]\nfloat fairingFunc( in float x ) {\n    #define MI 0.4\n    if (x < MI) {\n        float v = 0.75 + x*1.5;\n        return clamp(v, 0.85, 1.0);\n    } else {\n        float xx = (x - MI) / (1.0 - MI);\n        xx *= xx;\n        return max(0.0, 1.0 - xx);\n    }\n}\n\n// rocket distance estimator, returns the distance to the rocket without fairings\nvoid rocketDE( in vec3 p, out float d, out int id, out vec3 texCoord ) {\n    float lenxy = length(p.xy);\n    vec2 ori = p.xy / lenxy;\n    \n    // main fuel tank\n    float tank = lenxy - 0.3;\n    tank = max( tank, abs(p.z - 0.3) - 0.7 );\n    \n    // spherical combustion chamber\n    float engine = length(p + vec3(0.0, 0.0, +0.35)) - 0.27;\n    // add tubes\n    vec2 tubeOffset = p.xy - sign(p.xy) * 0.07;\n    float tube = length(tubeOffset) - 0.05;\n    tube = max( tube, abs(p.z + 0.6) - 0.1 );\n    engine = min(engine, tube);\n    // engine nozzle\n    float nozzle = dot( vec2(0.9701, 0.2425), vec2(lenxy, p.z) );\n    nozzle += sin(p.z*114.0)*0.007; // add some ridges\n    nozzle = max(nozzle, abs(p.z + 0.85) - 0.15);\n    nozzle = max(nozzle, -(length(p + vec3(0.0, 0.0, 1.1)) - 0.26));\n    engine = min(engine, nozzle);\n    \n    texCoord = p;\n    if (tank < engine) {\n        d = tank;\n        id = 1;\n    } else {\n        d = engine;\n        id = 2;\n    }\n}\n\n// falling rocket + falling fairings distance estimator\nvoid rocketAndFairingDE( in vec3 p, in float frac, in float seed,\n                         out float d, out int id, out vec3 texCoord ) {\n    float gravity = frac*frac;\n    vec3 tp = p;\n    \n    // randomize rotation of each rockets\n    tp.xy *= rot( PI*sin(seed*4125.664) );\n    \n    vec3 rp = tp;\n    if (frac > 0.0) {\n        rp.z += gravity*88.0;\n        float randRot = 1.1 * sin(seed*321.81);\n        rp.xz *= rot(frac*2.0*randRot);\n    }\n        \n    // get the distance to the rocket\n    rocketDE(rp, d, id, texCoord);\n    \n    // for each parts of the fairings\n    for (int i = -1; i <= 1; i += 2) {\n        float ii = float(i);\n        float ss = sign(ii);\n        \n        vec3 origin = vec3(0.0, 0.0, 1.0);\n        // add horizontal velocity\n        origin.y += ii*frac*18.0;\n        // then gravity\n        origin.z -= gravity*72.0;\n        \n        vec3 pp = tp - origin;\n        if (frac > 0.0) {\n            // randomize rotation of each fairing parts\n            float randRot = 1.0 + sin(seed*391.81+ii*122.35+154.42)*0.2;\n            float randRot2 = sin(seed*458.91+ii*138.42+284.66);\n            vec3 delt = vec3(0.0, ss*0.1, -0.5);\n            pp += delt; // change center of gravity\n            pp.yz *= rot(frac*-ss*14.0*randRot);\n            pp.xy *= rot(frac*randRot2*4.0);\n            pp -= delt;\n        }\n        \n        float fairDist = length(pp.xy) - fairingFunc(pp.z/1.5)*0.32;\n        fairDist = abs(fairDist)-0.01;\n        fairDist = max(fairDist, -pp.z);\n        fairDist = max(fairDist, pp.z-1.5);\n        fairDist = max(fairDist, -pp.y*ss);\n        \n        if (fairDist < d) {\n            d = fairDist;\n            id = 3;\n            texCoord = pp;\n        }\n    }\n}\n\n// rocket inside a rocket\nvoid fractalRocketDE( in vec3 p, out float d, out int id, out vec3 texCoord ) {\n    p.yz *= altRot;\n    \n    vec3 bottomP = p/fracScale;\n    bottomP.z += fracTotal * 1.45;\n    float bottomSeed = fracSequence;\n    float bottomDist = 0.0;\n    int bottomID = 0;\n    vec3 bottomTexCoord = vec3(0);\n    rocketAndFairingDE(bottomP, fracFall, bottomSeed, bottomDist, bottomID, bottomTexCoord);\n    bottomID = -bottomID; // invert the sign of the bottom rocket\n    bottomDist *= fracScale;\n    \n    float topScale = fracScale / SCALE;\n    vec3 topP = p;\n    topP.z -= (1.0 - fracTotal) * 1.45;\n    topP /= topScale;\n    float topSeed = fracSequence + 1.0;\n    float topDist = 0.0;\n    int topID = 0;\n    vec3 topTexCoord = vec3(0);\n    rocketAndFairingDE(topP, 0.0, topSeed, topDist, topID, topTexCoord);\n    topDist *= topScale;\n    \n    if (bottomDist < topDist) {\n        d = bottomDist;\n        id = bottomID;\n        texCoord = bottomTexCoord;\n    } else {\n        d = topDist;\n        id = topID;\n        texCoord = topTexCoord;\n    }\n}\n\n// normal function\nvec3 normal(vec3 p, int id, vec3 texCoord) {\n    float dist = 0.0;\n    vec3 distV = vec3(0);\n    \n    int tempID = 0;\n    vec3 tempTexCoord = vec3(0);\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n    fractalRocketDE(p, dist, tempID, tempTexCoord);\n    fractalRocketDE(p-e.xyy, distV.x, tempID, tempTexCoord);\n    fractalRocketDE(p-e.yxy, distV.y, tempID, tempTexCoord);\n    fractalRocketDE(p-e.yyx, distV.z, tempID, tempTexCoord);\n    vec3 n = dist-distV;\n    \n    // do normal mapping on the surface of the tank\n    if (id == 1 || id == -1) {\n        n.x += noise(texCoord*80.12)*0.0002 - 0.0001;\n        n.y += noise(texCoord*79.14)*0.0002 - 0.0001;\n        n.z += noise(texCoord*81.19)*0.0002 - 0.0001;\n    }\n    \n\treturn normalize(n);\n}\n\n// light the scene\nvec3 light( in vec3 p, in vec3 n, in vec3 c, in vec3 dir, in float rough, in bool doNoz ) {\n    vec3 pp = p;\n    p.yz *= altRot;\n    float specScale = (rough+1.0)*0.25;\n    \n    float sun = max(0.0, -dot(n, sunDir));\n    float sunSpec = pow(max(0.0, -dot(dir, reflect(sunDir, n))), rough);\n    sun += sunSpec*specScale;\n    sun *= sunStrength;\n    \n    float noz = 0.0;\n    if (doNoz) {\n        vec3 delt = (nozzlePosition - p) / fracScale;\n        vec3 deltN = normalize(delt);\n        vec3 nn = n;\n        nn.yz *= altRot;\n        noz = max(0.0, dot(nn, deltN));\n        float nozSpe = pow(max(0.0, dot(dir, reflect(deltN, nn))), rough);\n        noz += nozSpe*specScale;\n        noz /= dot(delt, delt);\n        noz *= nozzleStrength;\n    }\n    \n    float ao = 0.0;\n    int id = 0;\n    vec3 texCoord = vec3(0.0);\n    fractalRocketDE(pp+n*0.1, ao, id, texCoord);;\n    ao = clamp(ao / 0.1, 0.0, 1.0);\n    \n    vec3 result = c*ao*backgroundColor*0.2;\n    result += c*sun*sunColor;\n    result += c*noz*nozColor;\n    return result;\n}\n\n// density function for the trail\nvec4 density( in vec3 p ) {\n    p.yz *= altRot;\n    \n    // accelerate the smoke along the rocket trajectory\n    vec3 accel = vec3(0.0, 0.0, iTime*16.0);\n    float grav = (fracTotal*fracTotal)*-32.0;\n    \n    vec3 pp = (p-nozzlePosition) / fracScale;\n    vec3 ppp = pp;\n    pp.x += noise(p*1.2+accel)*0.2-0.1;\n    pp.y += noise(p*1.3+accel)*0.2-0.1;\n    pp.z += noise(p*1.6+accel)*0.2-0.1;\n    \n    vec2 cyl = vec2(length(pp.xy), pp.z);\n    \n    // add smoke around the trail\n    float nozzle = dot( vec2(0.9801, 0.1725), cyl );\n    float alphaNozzle = 1.0 - smoothstep(0.0, 0.1, nozzle);\n    alphaNozzle *= 1.0 - smoothstep(0.0, 0.05, pp.z);\n    alphaNozzle *= smoothstep(grav, grav+1.0, pp.z);;\n    alphaNozzle /= fracScale;\n    alphaNozzle *= nozzleStrength;\n    alphaNozzle = clamp(alphaNozzle, 0.0, 1.0);\n    \n    // add some noise\n    float noiseValue = 1.0;\n    noiseValue += noise(p*1.9+accel)*3.0;\n    noiseValue += noise(p*2.2+accel)*1.0;\n    noiseValue += noise(p*4.4+accel)*0.5;\n    noiseValue *= (1.0-altSpaceFrac);\n    noiseValue *= 0.005;\n    noiseValue = clamp(noiseValue, 0.0, 1.0);\n    \n    // add a fire trail\n    ppp.z += 0.05;\n    float len = length(ppp);\n    float theta = acos(-ppp.z / len) / (PI*0.5);\n    float randV = noise(p*4.0+accel);\n    float radius = 1.0 / (theta + 0.01 + randV*0.05);\n    float fire = 1.0 - smoothstep(0.0, 0.1, len - radius * 0.04);\n    fire /= fracScale;\n    fire *= 2.0;\n    fire *= nozzleStrength;\n    fire *= smoothstep(grav-2.0, grav-1.0, pp.z);\n    fire = clamp(fire, 0.0, 1.0);\n    \n    // base color of the smoke\n    vec3 baseColor = mix(vec3(0.5), vec3(0.8), noise(p*2.0+accel));\n    baseColor *= 1.0 - alphaNozzle*0.9; // lighter outside the trail\n    baseColor *= (sunStrength*0.75+0.25); // darker during night\n    baseColor = mix(baseColor, nozColor, fire); // colored fire\n    \n    return vec4(baseColor, max(noiseValue, max(alphaNozzle, fire)));\n}\n\n// background color\nvec3 getBackground( in vec3 dir ) {\n    // rotate stars\n    vec3 ddir = dir;\n    ddir.yz *= altHeading;\n    \n    // add stars\n    float noiseValue = 1.0;\n    noiseValue *= noise( ddir*161.58 );\n    noiseValue *= noise( ddir*323.94 );\n    float stars = noiseValue*1.08;\n    stars *= stars; stars *= stars;\n    stars *= stars; stars *= stars;\n    vec3 starry = mix(vec3(0), vec3(1), stars);\n    // sun\n    float dsun = max(0.0, -dot(sunDir, dir));\n    float sun = smoothstep(0.9996, 0.999956, dsun);\n    starry = mix(starry, sunColor, sun);\n    float factor = pow(dsun, 2000.0);\n    starry += sunColor*sunStrength*0.4*factor;\n    return starry;\n}\n\n// ground color\nvec3 getGroundColor( in vec3 dir ) {\n    vec3 texCoord = dir/(dir.z/(1.0+altSpaceFrac*5.0));\n    texCoord *= 0.01;\n    texCoord.y += altAccel*altSpaceFrac*0.18;\n    texCoord.xy *= rot(5.0832);\n    float backColor = smoothstep(-1.0+altSpaceFrac*0.75, 0.0, dir.z)*0.4+0.6;\n    vec3 groundColor = texture(iChannel2, texCoord.xy).rgb;\n    groundColor = mix(groundColor, backgroundColor, (1.0-sunStrength)*0.7);\n    return mix(groundColor, backgroundColor, backColor);\n}\n\n// texture for the fairings\nvec3 getFairingColor( in vec3 texCoord ) {\n    if (texCoord.z < 0.1) return vec3(0.95, 0.4, 0.0);\n    vec2 grid = vec2(texCoord.z, atan(texCoord.y, texCoord.x) / PI * 0.5 + 0.5);\n    grid *= vec2(2.5, 6.0);\n    grid = floor(grid);\n    float gridValue = mod(grid.x+grid.y, 2.0);\n    if (grid.x > 1.5) gridValue = 1.0;\n    if (abs(texCoord.y) < 0.01) gridValue = 0.0;\n    return mix(vec3(0.4, 0.4, 0.45), vec3(0.6, 0.6, 0.65), gridValue);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // initialize global variables once\n    float timeValue = (iTime-10.0) * 0.05;\n    fracSequence = floor(timeValue);\n\tfracFall = fract(timeValue);\n\tfracTotal = smoothstep(0.0, 0.5, fracFall);\n    fracScale = mix(1.0, SCALE, fracTotal);\n    nozzlePosition = vec3(0.0, 0.0, 1.1 - fracTotal*2.1);\n    nozzleStrength = smoothstep(0.0, 0.02, fracTotal);\n    nozzleStrength *= 1.0 - smoothstep(0.8, 1.0, fracFall);\n    altSpaceFrac = 1.0 - pow(4.2, -iTime*0.01);\n    altRot = rot(PI*0.5*altSpaceFrac);\n    altAccel = iTime*0.07;\n    altAccel *= altAccel;\n\taltHeading = rot(-altAccel*0.09*altSpaceFrac);\n    sunDir = normalize(vec3(-1.4, 3.7, 1.1));\n    sunDir.yz *= altHeading;\n    sunDir.z *= -1.0;\n    sunStrength = 1.0 - smoothstep(-0.15, 0.08, sunDir.z);\n    backgroundColor = mix(vec3(0.2, 0.3, 0.4), vec3(0.5, 0.6, 0.7), sunStrength);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 from = vec3(-14.0 + smoothstep(0.0, 20.0, iTime)*4.0, 0.0, 0);\n\tvec3 dir = vec3(uv.x*0.5, 1.0, uv.y*0.5);\n    dir.y += exp(length(uv)) * 0.15;\n    dir = normalize(dir);\n\tdir.xy *= rot(3.1415*.5);\n    \n    vec2 mouse=(iMouse.xy / iResolution.xy - 0.5) * 0.5;\n\tif (iMouse.z < 1.0) mouse = vec2(0.0);\n    \n    float shake = smoothstep(0.1, 0.3, fracTotal);\n    shake *= 1.0 - smoothstep(0.7, 0.9, fracFall);\n    vec2 rand = vec2(noise(vec3(iTime*15.4, 0.0, 0.0)),\n                     noise(vec3(iTime*17.2, 9.9, 9.9))) * shake;\n    \n    mat2 rotxz = rot(-0.16-mouse.y*5.0 + sin(iTime*0.0645)*0.07 + rand.x*0.01);\n\tmat2 rotxy = rot(0.2+mouse.x*8.0 + sin(iTime*0.0729)*1.1 + rand.y*0.01);\n\t\n    from.xz *= rotxz;\n\tfrom.xy *= rotxy;\n\tdir.xz  *= rotxz;\n\tdir.xy  *= rotxy;\n\n\tfloat totdist = 0.0;\n\tbool set = false;\n\tvec3 norm = vec3(0);\n    float dist = 0.0;\n    int id = 0;\n    vec3 texCoord = vec3(0);\n    \n    // offset starting distance with a dithered value\n    vec2 randVec = vec2(hash(iTime), hash(iTime*1.61541));\n    float dither = texture(iChannel1, fragCoord.xy / 8.0 + randVec).r;\n    fractalRocketDE(from, dist, id, texCoord);\n    #ifdef DITHER\n    totdist += dist*dither;\n    #endif\n    // run sphere tracing to find the rocket surface\n\tfor (int steps = 0 ; steps < 50 ; steps++) {\n\t\tif (set) continue;\n\t\tvec3 p = from + totdist * dir;\n        fractalRocketDE(p, dist, id, texCoord);\n        dist *= 0.75;\n\t\ttotdist += max(0.0, dist);\n\t\tif (dist < 0.01) {\n\t\t\tset = true;\n\t\t\tnorm = normal(p, id, texCoord);\n\t\t}\n\t}\n    \n    // do surface texture/light when an object is found\n    if (set) {\n        vec3 emiss = vec3(0);\n        vec3 color = vec3(0);\n        float rough = 0.0;\n        \n        bool bot = id < 0;\n        int iid = bot ? -id : id;\n        if (iid == 1) {\n            color = vec3(0.5, 0.3, 0.1);\n            rough = 8.0;\n        } else if (iid == 2) {\n            color = vec3(0.05);\n            float nozz = smoothstep(0.6, 1.3, -texCoord.z);\n            if (id > 0) nozz *= smoothstep(0.0, 0.7, fracTotal);\n            emiss = vec3(nozColor) * nozz * 0.4;\n            rough = 16.0;\n        } else if (iid == 3) {\n            color = getFairingColor(texCoord);\n            rough = 3.0;\n        }\n        \n        fragColor.a = 1.0;\n        fragColor.rgb = light( from+dir*totdist, norm, color, dir, rough, bot );\n        fragColor.rgb += emiss;\n    } else {\n        // pass some landscape on the ground\n    \tbackgroundColor = getGroundColor(dir);\n        // get the background otherwise\n        fragColor.rgb = getBackground(dir);\n        totdist = 99999.9;\n    }\n    \n    // modify the background color when looking at the sun\n    float sunLook = max(0.0, dot(dir, -sunDir))*sunStrength;\n    sunLook *= sunLook; sunLook *= sunLook;\n    backgroundColor = mix(backgroundColor, sunColor, sunLook);\n    \n    // apply fog\n    fragColor.rgb = fog( fragColor.rgb, totdist, from, dir);\n    \n    // do volumetric rendering back to front\n    float totdistmarch = MARCH_DIST*float(MARCH_STEPS);\n    totdistmarch = min(totdist, totdistmarch);\n    #ifdef DITHER\n    totdistmarch -= dither*MARCH_DIST;\n    #endif\n    for (int steps = 0 ; steps < MARCH_STEPS ; steps++) {\n        if (totdistmarch < 0.0) continue;\n        \n        vec3 p = from + totdistmarch * dir;\n        vec4 col = density(p);\n        col.a *= MARCH_DIST;\n        \n       \t// apply fog to the color\n        col.rgb = fog( col.rgb, totdistmarch, from, dir );\n        // accumulate opacity\n        fragColor.rgb = fragColor.rgb*(1.0-col.a)+col.rgb*col.a;\n        \n        totdistmarch -= MARCH_DIST;\n\t}\n    \n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.a = 1.0;\n    \n    // vignette\n    fragColor.rgb -= dot(uv, uv)*0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}