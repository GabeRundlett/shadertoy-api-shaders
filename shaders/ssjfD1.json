{
    "Shader": {
        "info": {
            "date": "1646182338",
            "description": "The integers are spread out in the Ulam spiral,\nand then we fade between either the primes or the height of the Collatz conjecture.\n\nResult: the Collatz Conjecture is a better hash than primacy !",
            "flags": 0,
            "hasliked": 0,
            "id": "ssjfD1",
            "likes": 10,
            "name": "Primes Collatz and Ulam",
            "published": 3,
            "tags": [
                "spiral",
                "primes",
                "integer",
                "cantor",
                "integers",
                "ulam",
                "diagonalize"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "// Fork of \"Ulam Spiral & Cantor Diagonal\" by elenzil. https://shadertoy.com/view/fdjBDR\n// 2022-03-02 00:33:47\n\n// Fork of \"Ulam Spiral\" by elenzil. https://shadertoy.com/view/ssjBRm\n// 2022-02-28 00:22:54\n\nint sqr(int n) {\n    return n * n;\n}\n\n// thanks to @Envy24 for optimized version of this routine.\nbool isPrime(int N) {\n    switch (N)\n    {\n    case 0:\n    case 1:\n        return false;\n    case 2:\n    case 3:\n    case 5:\n    case 7:\n        return true;\n    default:\n        break;\n    }\n\n    if ((N & 1) == 0) { return false; }\n\n    int n = 3;\n    bool r = true;\n    int limit = int(sqrt(float(N)));\n\n    do \n    { \n        r = (N % n) != 0;\n        n += 2;\n    } while (r &&\n        n <= limit);\n\n    return r;\n}\n\nint getNForPixel_Cartesian(in ivec2 IJ, int width) {    \n    return IJ.x + (IJ.y * width);\n}\n\nint getNForPixel_Diagnolize(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int i_j = I + J;\n    return (i_j * 1) * i_j / 2 + J + 1;    \n}\n\nint getNForPixel_Spiral(in ivec2 IJ) {\n    int I = IJ.x;\n    int J = IJ.y;\n    \n    int n = 0;\n        \n    // center\n    if (I == 0 && J == 0) {\n        n = 1;\n    }\n    // squares diagonal - bottom right\n    else if (I > 0 && I == -J) {\n        n = sqr((1 - 2 * J));\n    }\n    // right region\n    else if (I > 0 && I >= abs(J)) {\n        n = sqr(2 * I - 1) + I + J;\n    }\n    // top region\n    else if (J > 0 && J >= abs(I)) {\n        n = sqr(2 * J - 1) + 3 * J - I;\n    }\n    // left region\n    else if (I < 0 && J >= I) {\n        n = sqr(-2 * I) - I - J + 1;\n    }\n    // bottom region\n    else {\n        n = sqr( - 2 * J) + I - 3 * J + 3;\n    }\n    \n    return n;\n}\n\nint collatzIters(int n, int maxIters) {\n\n    int count;\n    \n    for (count = 1; count < maxIters && n > 1; ++count) {\n        if (n % 2 == 1)\n        {\n            n = n * 3 + 1;\n        }\n        else\n        {\n            n /= 2;\n        }\n    }\n    \n    return count;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    int pixelsPerPixel = iMouse.z > 1.0 ? 1 : 3;\n    ivec2 IJ_centered = ivec2(XY) / pixelsPerPixel - ivec2(iResolution.xy) / 2 / pixelsPerPixel;\n    ivec2 IJ_cornered = ivec2(XY) / pixelsPerPixel;\n    \n    int n;\n\n    n = getNForPixel_Spiral(IJ_centered);\n\n    float p = isPrime(n) ? 0.0 : 1.0;\n    \n    int maxIters = 500;\n    int ci = collatzIters(n, maxIters);\n    float c = 1.0 - pow(float(ci) / float(maxIters), 0.5);\n\n    vec3 rgb = mix(vec3(p), vec3(c), smoothstep(-0.8, 0.8, sin(iTime / 2.0)));\n    \n\n    \n    RGBA = vec4(rgb, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}