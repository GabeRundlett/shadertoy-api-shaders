{
    "Shader": {
        "info": {
            "date": "1549834783",
            "description": "Inspired by Fabrice's [url]https://www.shadertoy.com/view/3sB3WG[/url] I thought I would do one with the hyperboloid surfaces as well.\n\n[url]http://mathworld.wolfram.com/ConfocalEllipsoidalCoordinates.html[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "3dBGWy",
            "likes": 16,
            "name": "Ellipsoidal Coordinates, Again",
            "published": 3,
            "tags": [
                "quadric",
                "analytic",
                "coordinates",
                "ellipsoidal"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 617
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Ellipsoidal coordinates\n// cf. https://www.shadertoy.com/view/3sB3WG\n//\n// <mouse>: view direction\n// <up>/<down>: zoom in/out\n// 'c': clip at r=10\n// 'r': do rotation\n// 's': slice at z=0\n// '1'-'3': display the three different types of surface\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\n// Lighting\nvec3 light;\nfloat ambient;\nfloat diffuse;\nfloat specular = 0.4;\nfloat specularpow = 4.0;\nvec3 specularcolor = vec3(1);\n\nbool alert = false;\n\nvoid assert(bool t) {\n  if (!t) alert = true;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nbool keypress(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nvec4 store(int i,int j) {\n  return texelFetch(iChannel1, ivec2(i,j),0);\n}\n\nint keycount(int key) {\n  return int(store(0,key).x);\n}\n\n// The Kahan algorithm, for explanation see:\n// https://people.eecs.berkeley.edu/~wkahan/Math128/Cubic.pdf\n\nfloat sgn(float x) {\n  return x < 0.0? -1.0: 1.0; // Return 1 for x == 0\n}\n\nint quadratic(float A, float B, float C, out vec2 res) {\n  float x1,x2;\n  float b = -0.5*B;\n  float q = b*b - A*C;\n  if (q < 0.0) return 0;\n  float r = b + sgn(b)*sqrt(q);\n  if (r == 0.0) {\n    x1 = C/A; x2 = -x1;\n  } else {\n    x1 = C/r; x2 = r/A;\n  }\n  res = vec2(x1,x2);\n  return 2;\n}\n\nint quadratic(vec3 coeffs, out vec2 res) {\n  return quadratic(coeffs[0],coeffs[1],coeffs[2],res);\n}\n  \nvoid eval(float X, float A, float B, float C, float D,\n          out float Q, out float Q1, out float B1,out float C2) {\n  float q0 = A*X;\n  B1 = q0+B;\n  C2 = B1*X+C;\n  Q1 = (q0+B1)*X + C2;\n  Q = C2*X + D;\n}\n\n// Solve: Ax^3 + Bx^2 + Cx + D == 0\n// Find one real root, then reduce to quadratic.\nint cubic(float A, float B, float C, float D, out vec3 res) {\n  float X,b1,c2;\n  if (A == 0.0) {\n    X = 1e8; A = B; b1 = C; c2 = D;\n  } else if (D == 0.0) {\n    X = 0.0; b1 = B; c2 = C;\n  } else {\n    X = -(B/A)/3.0;\n    float t,r,s,q,dq,x0;\n    eval(X,A,B,C,D,q,dq,b1,c2);\n    t = q/A; r = pow(abs(t),1.0/3.0); s = sgn(t);\n    t = -dq/A; if (t > 0.0) r = 1.324718*max(r,sqrt(t));\n    x0 = X - s*r;\n    if (x0 != X) {\n      for (int i = 0; i < 6; i++) {\n        X = x0;\n        eval(X,A,B,C,D,q,dq,b1,c2);\n        if (dq == 0.0) break;\n        x0 -= (q/dq);\n      }\n      if (abs(A)*X*X > abs(D/X)) {\n        c2 = -D/X; b1 = (c2 - C)/X;\n      }\n    }\n  }\n  res.x = X;\n  return 1 + quadratic(A,b1,c2,res.yz);\n}\n\nint cubic(vec4 coeffs, out vec3 res) {\n  float A = coeffs[0], B = coeffs[1], C = coeffs[2], D = coeffs[3];\n  return cubic(A,B,C,D,res);\n}\n\nstruct Surface {\n  int type;\n  vec4 params;\n  vec3 p;\n  int id;\n};\n\nconst int Quadric = 0;\n\nint quadricsurface(Surface surface, vec3 p, vec3 r, out vec4 roots) {\n  // quadric Ap.p - R2 = 0\n  // A(p+tr).(p+tr) - R2 = Ap.p + 2tAp.r + t^2Ar.r - R2\n  // Quadratic with:\n  // a = Ar.r\n  // b = 2Ap.r\n  // c = Ap.p - R2\n  vec3 A = surface.params.xyz;\n  float R2 = surface.params.w;\n  p -= surface.p;\n  vec3 coeffs = vec3(dot(A*r,r),\n                     2.0*dot(A*p,r),\n                     dot(A*p,p) - R2);\n  return quadratic(coeffs,roots.xy);\n}\n\nvec3 quadricnormal(Surface surface, vec3 p) {\n  p -= surface.p;\n  vec3 A = surface.params.xyz;\n  return A*p;\n}\n\nvec3 applylighting(vec3 baseColor, vec3 p, vec3 n, vec3 r) {\n  if (dot(r,n) > 0.0) n = -n; // Face forwards\n  vec3 c = baseColor*ambient;\n  c += baseColor*diffuse*(max(0.0,dot(light,n)));\n  float s = pow(max(0.0,dot(reflect(light,n),r)),specularpow);\n  c += specular*s*baseColor;\n  return c;\n}\n\nstruct Result {\n  vec3 p;\n  vec3 n;\n  vec3 basecolor;\n  float t;\n};\n\n// -l < 1 < -m < 2 < -n < 3\n// l > -1 > m > -2 > n > -3\nvec3 a2b2c2 = vec3(3,2,1);\n\nfloat gridline(vec3 p, int id) {\n  // Solve a cubic to get ellipsoid coordinates.\n  float x2 = p.x*p.x;\n  float y2 = p.y*p.y;\n  float z2 = p.z*p.z;\n  float a2 = a2b2c2.x;\n  float b2 = a2b2c2.y;\n  float c2 = a2b2c2.z;\n  float A = 1.0;\n  float B = (a2+b2+c2) - (x2+y2+z2);\n  float C = (a2*b2 + b2*c2 + c2*a2) - (x2*(b2+c2) + y2*(c2+a2) + z2*(a2+b2));\n  float D = a2*b2*c2-(x2*b2*c2 + a2*y2*c2 + a2*b2*z2);\n  vec3 res;\n  int nroots = cubic(A,B,C,D,res);\n  assert(nroots == 3);\n  // Put in descending, lmn, order.\n  if (res.x < res.y) res.xy = res.yx;\n  if (res.y < res.z) res.yz = res.zy;\n  if (res.x < res.y) res.xy = res.yx;\n  //assert(res.x >= -1.0);\n  //assert(res.y >= -2.0);\n  //assert(res.z >= -3.0);\n  res += vec3(2,2,3);\n  res.x = log(res.x);\n  // Draw some gridlines on surface\n  vec3 t = fract(res*7.0+0.5);\n  t = min(t,1.0-t);\n  t[id] = 10.0; // Bodge to avoid entire surface being in grid.\n  t = min(t,4.0*abs(p)/length(p));\n  float d = min(t.x,min(t.y,t.z));\n  return smoothstep(0.08,0.1,d);\n}\n\nint dosurface(Surface surface, vec3 p0, vec3 r, out vec4 roots) {\n  if (surface.type == Quadric) {\n    return quadricsurface(surface,p0,r,roots);\n  } else {\n    assert(false);\n  }\n}\n  \nvec3 donormal(Surface surface, vec3 p) {\n  if (surface.type == Quadric) {\n    return quadricnormal(surface,p);\n  } else {\n    assert(false);\n  }\n}\n\nbool doclip = false;\nbool doslice = false;\nbool dorotate = false;\n\nbool solve(Surface surface, vec3 p0, vec3 r, float tmin, inout Result result) {\n  vec4 roots;\n  int nroots = dosurface(surface,p0,r,roots);\n  // Find smallest root greater than tmin.\n  float t = result.t;\n  for (int i = 0; i < nroots; i++) {\n    if (roots[i] > tmin && roots[i] < t) {\n      vec3 p = p0+roots[i]*r;\n      if (doclip && dot(p,p) > 10.0) continue;\n      if (doslice && p.z < 0.0) continue;\n      t = roots[i];\n    }\n  }\n  if (t == result.t) return false;\n  vec3 p = p0 + t*r;\n  vec3 n = donormal(surface, p);\n  if (dot(n,r) > 0.0) n = -n;\n  n = normalize(n);\n  vec3 basecolor = abs(n);\n  basecolor *= 0.2+0.8*gridline(p,surface.id);\n  result = Result(p,n,basecolor,t);\n  return true;\n}\n\nvec3 scene(vec3 p0, vec3 r) {\n  // Solve from closest point to origin.\n  // This make p0.r = 0.\n  float tmin = -dot(p0,r);\n  p0 += tmin*r;\n  Result res = Result(vec3(0),vec3(0),vec3(0),1e8);\n\n  float k = 0.5+0.499*sin(0.5*iTime);\n  float l = -2.0+exp(k), m = -2.0+k, n = -3.0+k;\n  Surface surface1 = Surface(Quadric,vec4(1.0/(a2b2c2+l),1),vec3(0),0);\n  Surface surface2 = Surface(Quadric,vec4(1.0/(a2b2c2+m),1),vec3(0),1);\n  Surface surface3 = Surface(Quadric,vec4(1.0/(a2b2c2+n),1),vec3(0),2);\n\n  if (!keypress(CHAR_0+1)) solve(surface1,p0,r,-tmin,res);\n  if (!keypress(CHAR_0+2)) solve(surface2,p0,r,-tmin,res);\n  if (!keypress(CHAR_0+3)) solve(surface3,p0,r,-tmin,res);\n  if (res.t == 1e8) return vec3(0);\n\n  return applylighting(res.basecolor,res.p,res.n,r);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.yz = rotate(p.yz, 0.1*t);\n    p.zx = rotate(p.zx, 0.222*t);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  doclip = !keypress(CHAR_C);\n  dorotate = !keypress(CHAR_R);\n  doslice = keypress(CHAR_S);\n  light = vec3(1,1,-1);\n  ambient = 0.4;\n  diffuse = 1.0-ambient;\n  specular = 0.8;\n  specularpow = 10.0;\n\n  float scale = 1.0;\n  float camera = 6.0;\n  \n  vec2 uv = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  vec3 p = vec3(0.0, 0.0, -camera);\n  p *= 0.1*float(10+keycount(KEY_DOWN)-keycount(KEY_UP));\n  vec3 r = normalize(vec3(uv, 2.0));\n\n  p = transform(p);\n  r = transform(r);\n  r = normalize(r);\n  light = transform(light);\n  light = normalize(light);\n\n  vec3 color = scene(p,r);\n  if (alert) color.x = 1.0;\n  fragColor = vec4(sqrt(color),1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define keystate(k,n) ( texelFetch(iChannel0,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n#if __VERSION__ < 300\n    t = vec4(0);\n#else\n    \n    int i = int(uv.x);\n    int j = int(uv.y);\n    if ( iFrame == 0 ) {\n        t = vec4(0);\n    } else {\n        t = texelFetch(iChannel1,ivec2(i,j),0); // Get current state   \n    }  \n    if (i == 0) {\n        float w1 = keystate(j,2).x;\n        if (w1 != t.w) {\n            t.w = w1;\n            t.x++;\n        }\n    }     \n        \n#endif           \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}