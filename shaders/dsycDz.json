{
    "Shader": {
        "info": {
            "date": "1695979939",
            "description": "Motivated by the palace in Dubrovnik (simplified, symmetrized and wall-free); updated visuals (mouseable)",
            "flags": 32,
            "hasliked": 0,
            "id": "dsycDz",
            "likes": 26,
            "name": "Rector's Palace at Night",
            "published": 3,
            "tags": [
                "shadow",
                "light",
                "architecture"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "// \"Rector's Palace at Night\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Control panel appears when ring (or a hidden control) clicked; panel fades\n  automatically; look around using mouse.\n\n  Sliders control speed (red) and zoom (green).\n  Buttons switch viewer moving/stationary (blue) and night/day (yellow).\n\n  (Update of \"Rector's Palace\")\n\n  No. 84 in \"Architecture\" series\n   \"Pantheon\"                        (Dl2GDt) - earlier listed here\n   \"Roman Disco\"                     (dlXSWn)\n   \"Mriya Over Metropolis\"           (ct2SR1)\n   \"Monorail 2\"                      (msc3zn)\n   \"Mini Metropolis\"                 (msc3W2)\n   \"Truchet Path Journey\"            (mdXyRB)\n   \"Canal Ruins 2\"                   (mdByRm)\n   \"Atlantis 3\"                      (dd2yRG)\n   \"Crystal Canyon\"                  (cs2cDy)\n   \"Ziggurat of Hilbert\"             (mscyWM)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w);\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nvec3 HexGrid (vec2 p);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat IFbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (int idVar);\n\n#define NLIT_MX 5\n\nvec3 qHit, sunDir, vuPos, dukPos, ltPos[NLIT_MX + 1], ltAx;\nvec2 stCent, dukAzCs, dukElCs;\nfloat dstFar, tCur, outWd, corWd, flrHt, trkLen, vuAz, vuEl, extVu,\n   dukVu, dukScl, refSpRad, ntMode;\nint nFrame, idObj, nLit;\nbool isSh;\nconst int idDnFlr = 1, idUpFlr = 2, idRf = 3, idStr = 4, idStWall = 5, idWall = 6, idPil = 7,\n   idBall = 8, idCen = 9, idLit = 10, idMvLit = 11, idDuk = 12;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (nFrame, 0)\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n}\n\nfloat DukDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, dm, h, s;\n  dm = dMin;\n  p /= dukScl;\n  if (0.9 * dukScl * PrSphDf (p, 1.) < dm) {\n    dm /= dukScl;\n    p.xz = Rot2Cs (p.xz, dukAzCs);\n    p.yz = Rot2Cs (p.yz, dukElCs);\n    p.z = - p.z;\n    cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n    h = 0.5;\n    r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n    s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n    d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n    dm = min (dm, d);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.5, 0.3, 0.6);\n    q.yz = Rot2Cs (q.yz, cs);\n    q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n    q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n    r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n    h = 0.07;\n    s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n    d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dm, 0.05);\n    dm = min (dm, d);\n    d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dm, 0.1);\n    dm = min (dm, d);\n    q = p - vec3 (0., 0.65, -0.9);\n    q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n    h = 0.15;\n    r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n    d = PrEllCylDf (q, r, h);\n    q.z -= -0.9 * h;\n    d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dm, 0.01);\n    dm = min (dm, d);\n    q = p;\n    q.x = abs (q.x);\n    d = PrSphDf (q - vec3 (0.26, 0.825, -0.6), 0.125);\n    dm = min (dm, d);\n    dm *= 0.9 * dukScl;\n  }\n  return dm;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 wSz;\n  float dMin, d, a, r, s;\n  dMin = dstFar;\n  q = p;\n  d = PrBoxDf (q, vec3 (outWd + 1., 0.2, outWd + 1.));\n  DMIN (idDnFlr);\n  qq = p;\n  a = (length (qq.xz) > 0.) ? atan (qq.z, - qq.x) : 0.;\n  qq.xz = Rot2D (qq.xz, 2. * pi * (floor (4. * a / (2. * pi) + 0.5) / 4.));\n  q = qq;\n  d = dot (vec2 (qq.y, abs (abs (qq.x) - outWd + corWd)), sin (0.15 * pi + vec2 (0.5 * pi, 0.))) -\n     4. * flrHt + 0.02 * sin (4. * pi * qq.z) - 0.2;\n  d = max (max (d, abs (qq.x + outWd - 2.) - 3.), 4. * flrHt + 0.1 - qq.y);\n  DMINQ (idRf);\n  q.x = abs (q.x) - outWd + corWd;\n  q.y -= 2. * flrHt + 0.15;\n  d = PrBox2Df (q.xy, vec2 (corWd + 0.2, 0.2));\n  DMIN (idUpFlr);\n  q = qq;\n  q.x = abs (abs (q.x) - outWd + corWd) - corWd;\n  q.y -= 2. * flrHt + 0.1;\n  d = PrBox2Df (q.xy, vec2 (0.1, 2. * flrHt));\n  q.yz = mod (q.yz, vec2 (2. * flrHt + 0.2, 2. * corWd)) - vec2 (flrHt + 0.5, corWd);\n  wSz = vec2 (1.7, 1.3);\n  d = SmoothMax (d, - min (min (length (q.yz) - wSz.x, PrBox2Df (vec2 (q.z, q.y + wSz.y), wSz)),\n     PrBoxDf (((qq.x < corWd - outWd) ? vec3 (qq.x + outWd, qq.y - 0.5, abs (qq.z) - 2.) :\n     vec3 (qq.x + outWd - 2. * corWd, q.y + flrHt - 0.1, qq.z + 6.)), vec3 (0.25, 0.5, wSz.x))), 0.01);\n  DMINQ (idWall);\n  if (! isSh) {\n    q.xz = abs (qq.xz);\n    q -= vec3 (outWd - corWd, flrHt - 0.5, 0.5 * outWd);\n    d = max (PrCylDf (q.xzy, 0.2, 0.05), - min (qq.y, 5. * flrHt - qq.y));\n    DMIN (idLit);\n  }\n  q = qq;\n  q.x = abs (q.x + 8.);\n  q -= vec3 (1.6, 0.9, 1.95);\n  d = PrSphDf (q, 0.15);\n  q = qq;\n  q.z = abs (q.z + 6.);\n  q -= vec3 (-15.95, 7.3, 1.6);\n  d = min (d, PrSphDf (q, 0.15));\n  DMIN (idBall);\n  qq -= vec3 (stCent, flrHt + 0.3).xzy;\n  q = qq;\n  q.xz = Rot2D (q.xz, -0.73 * pi);\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) : 0.;\n  q.xz = vec2 (26. * a / (2. * pi), r - 8.);\n  q.xy = Rot2D (q.xy, -0.25 * pi);\n  s = mod (q.x, 0.5 * sqrt (2.));\n  d = max (0.5 * max (q.y + abs (s - 0.25 * sqrt (2.)) - 0.25 * sqrt (2.),\n     max (- q.y - 0.1, abs (q.z) - 1.5)), abs (qq.y + 0.2) - (flrHt + 0.2));\n  DMINQ (idStr);\n  d = max (0.5 * max (abs (q.y - 0.3) - 0.4, abs (abs (q.z) - 1.6) - 0.1),\n     max (max (- qq.x, qq.z), - qq.y - (flrHt + 0.2)));\n  q.x = a;\n  DMINQ (idStWall);\n  q = p;\n  q.xz = abs (mod (q.xz + corWd, 2. * corWd) - corWd) - 0.1;\n  q.y -= 2. * flrHt + 0.1;\n  d = max (PrCylDf (q.xzy, 0.07, 2. * flrHt), PrBoxAn2Df (p.xz, vec2 (outWd - 2.), 3.));\n  DMIN (idPil);\n  q = p;\n  q.xz = abs (q.xz) - (outWd - corWd);\n  q.y -= 4. * flrHt + 1.8;\n  d = PrSphDf (q, 0.2);\n  DMIN (idBall);\n  q = p;\n  q.y -= 0.8;\n  d = PrCylAnDf (q.xzy, 2.4, 0.15, 0.7);\n  DMIN (idCen);\n  if (dukVu > 0.) {\n    d = DukDf (p - dukPos, dMin);\n    DMIN (idDuk);\n  }\n  if (! isSh && ntMode > 0.) {\n    for (int k = 0; k < nLit; k ++) {\n      q = p - ltPos[k];\n      d = PrSphDf (q, 0.1);\n      DMIN (idMvLit);\n    }\n  }\n  if (isSh) {\n    q = p;\n    q.y -= refSpRad;\n    d = PrSphDf (q, refSpRad);\n    DMIN (0);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 qHitT;\n  float sh, d, h;\n  int idObjT;\n  idObjT = idObj;\n  qHitT = qHit;\n  isSh = true;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = SmoothMin (sh, smoothstep (0., 0.05 * d, h), 0.1);\n    d += h;\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  idObj = idObjT;\n  qHit = qHitT;\n  isSh = false;\n  return 0.5 + 0.5 * sh;\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02, 0.03, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.07 * pi * smoothstep (0.4, 0.47, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec4 ObjCol (vec3 ro, vec3 rd, inout vec3 vn)\n{\n  vec4 col4;\n  vec3 rg;\n  vec2 vf;\n  float s;\n  bool fxz;\n  vf = vec2 (0.);\n  if (idObj == idWall) {\n    col4 = vec4 (0.9, 0.8, 0.7, 0.1);\n    if (abs (qHit.x) < 0.095) {\n      col4 *= 0.9;\n      vf = vec2 (64., 1.);\n    } else if (abs (vn.y) < 0.01) {\n      rg = ro;\n      rg.y = mod (rg.y, 2. * flrHt + 0.2);\n      fxz = (abs (vn.x) > 0.99);\n      rg = ShGrid ((fxz ? rg.zy : rg.xy), vec2 (2., 4.), 1);\n      col4 *= rg.y;\n      rg.xz *= sign (fxz ? vn.x : vn.z);\n      if (fxz) {\n        if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n        else vn.xz = Rot2D (vn.xz, rg.x);\n      } else {\n        if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n        else vn.zx = Rot2D (vn.zx, rg.x);\n      }\n      vf = vec2 (32., 1.);\n    }\n  } else if (idObj == idDnFlr) {\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.8, 0.75, 0.7, 0.1);\n    if (vn.y > 0.99) {\n      if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n      else vn.yx = Rot2D (vn.yx, rg.x);\n    }\n    if (length (ro.xz) < 2.5) col4.rgb *= vec3 (0., 0.3, 0.5);\n    s = Maxv2 (abs (ro.xz));\n    if (s < outWd - 2. * corWd)\n       col4.rg *= 0.8 + 0.1 * smoothstep (0.3, 0.4, length (fract (ro.xz) - 0.5));\n    else if (s > outWd) col4.rg *= 0.95;\n    else col4.rgb = mix (vec3 (0.5, 0.5, 0.8), col4.rgb,\n       smoothstep (0.05, 0.07, abs (Truch (ro.xz) - 0.5)));\n    col4.rgb *= rg.y;\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idUpFlr) {\n    rg = ShGrid (ro.xz, vec2 (1.), 0);\n    col4 = vec4 (0.75, 0.65, 0.7, 0.1);\n    if (vn.y > 0.99) {\n      if (rg.x == 0.) vn.yz = Rot2D (vn.yz, rg.z);\n      else vn.yx = Rot2D (vn.yx, rg.x);\n      if (abs (Maxv2 (abs (ro.xz)) - outWd + corWd) < corWd) col4.rgb = mix (vec3 (0.3, 0.7, 0.3),\n         col4.rgb, smoothstep (0.05, 0.07, abs (Truch (2. * ro.xz) - 0.5)));\n    }\n    col4.rgb *= rg.y;\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idRf) {\n    col4 = (vn.y > 0.) ? vec4 (0.8, 0.3, 0., 0.1) : vec4 (0.8, 0.5, 0.4, 0.1);\n    col4 *= 0.6 + 0.4 * smoothstep (0.03, 0.05, abs (fract (2. * qHit.x + 0.5) - 0.5));\n  } else if (idObj == idStr) {\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1) * (0.6 + 0.4 *\n       smoothstep (0.03, 0.05, abs (fract (2. * qHit.z + 0.5) - 0.5)));\n    vf = vec2 (64., 0.5);\n  } else if (idObj == idStWall) {\n    rg = ShGrid (qHit.xy - vec2 (0., 0.1), vec2 (20., 5.), 1);\n    col4 = vec4 (0.8, 0.8, 0.9, 0.1) * rg.y;\n    if (abs (vn.y) < 0.01) {\n      if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n      else vn.xz = Rot2D (vn.xz, - rg.x);\n    }\n    vf = vec2 (32., 1.);\n  } else if (idObj == idPil) {\n    s = fract (4. * mod (ro.y, 2. * flrHt + 0.2));\n    col4 = vec4 (0.7, 0.7, 0.8, 0.1) * (0.8 + 0.2 * smoothstep (0.03, 0.05, abs (s)));\n    vn = normalize (vec3 (vn.xz, -0.3 * (1. - smoothstep (0.05, 0.1, abs (s))) * sign (s))).xzy;\n    vf = vec2 (32., 1.);\n  } else if (idObj == idBall) {\n    col4 = vec4 (1., 1., 0.1, 0.3);\n  } else if (idObj == idCen) {\n    rg = ShGrid (vec2 (atan (ro.z, - ro.x) / pi, ro.y + 0.05), vec2 (16., 4.), 1);\n    col4 = vec4 (0.8, 0.9, 0.7, 0.1) * rg.y;\n    if (vn.y < 0.01) {\n      if (rg.x == 0.) vn = normalize (vec3 (vn.xz, rg.z)).xzy;\n      else vn.xz = Rot2D (vn.xz, - rg.x);\n    }\n    vf = vec2 (32., 1.);\n  } else if (idObj == idLit) {\n    col4 = vec4 (0.9, 0.9, 0.7, -1.);\n  } else if (idObj == idMvLit) {\n    col4 = vec4 (0.9, 0.9, 0.95, -1.);\n  } else if (idObj == idDuk) {\n    s = max (dot (vn, - rd), 0.);\n    col4 = vec4 (0.9 * vec3 (1., 0.9, 0.3) * (0.55 + 0.45 * s) + 0.1 * pow (s, 4.) +\n       4. * pow (max (dot (VaryNf (1024. * ro, vn, 4.), - rd), 0.), 128.), -1.);\n  }\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col4;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd, inout vec3 vn)\n{\n  vec3 col, qh;\n  vec2 vf;\n  vn = vec3 (0., 1., 0.);\n  vf = vec2 (0.);\n  if (length (ro.xz) < 50.) {\n    col = vec3 (0.5, 0.5, 0.55);\n    qh = HexGrid (1.5 * ro.xz);\n    vn.yz = Rot2D (vn.yz, 0.5 * max (length (qh.xy) - 0.3, 0.) *\n       (1. - smoothstep (-0.1, -0.05, rd.y)));\n    vn.zx = vn.z * vec2 (qh.x, - qh.y) / length (qh.xy);\n    vf = vec2 (16., 0.5);\n  } else {\n    col = vec3 (0.4, 0.4, 0.3) * (0.85 + 0.15 * smoothstep (0.3, 0.7, Fbm2 (8. * ro.xz)));\n    vf = vec2 (4., 1.);\n  }\n  vf.y *= 1. - smoothstep (0.3, 0.6, dstGrnd / dstFar);\n  if (vf.y > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 4. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd, a;\n  a = atan (rd.z, - rd.x) / (2. * pi) + 0.5;\n  if (rd.y > -0.02 && rd.y < 0.02 * mix (IFbm1 (16. * (a + 1.)), IFbm1 (16. * a), a)) {\n    col = vec3 (0.3, 0.35, 0.45);\n    if (ntMode > 0.) col *= 0.15;\n  } else {\n    q = 0.02 * (ro.xz + 2. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n    if (ntMode > 0.) col = vec3 (0.1) * col.r + StarPat (rd, 6.);\n  }\n  return col;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w, dMin;\n  dMin = dstFar;\n  b = dot (rd, ro);\n  w = b * b - dot (ro, ro) + rad * rad;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    if (d > 0.) {\n      dMin = d;\n      vn = (ro + d * rd) / rad;\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat GlowCol (vec3 ro, vec3 rd, float dstLim)\n{\n  vec3 dirGlow;\n  float dstGlow, brGlow;\n  brGlow = 0.;\n  for (int k = VAR_ZERO; k < nLit; k ++) {\n    dirGlow = ltPos[k] - ro;\n    dstGlow = length (dirGlow);\n    brGlow += smoothstep (-0.1, 0.1, dstLim - dstGlow) *\n       pow (max (dot (rd, dirGlow), 0.) / dstGlow, 2048.) / dstGlow;\n  }\n  return clamp (brGlow, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, ds4;\n  vec3 col, c, vn, roo, rog, ltDir, ltVec;\n  float dstObj, dstSph, dstGrnd, sh, atten;\n  dukScl = 0.3;\n  refSpRad = 2.1;\n  isSh = false;\n  roo = ro;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    dstObj = ObjRay (ro, rd);\n    if (k == 0) {\n      ds4 = SphHit (ro - vec3 (0., refSpRad, 0.), rd, refSpRad);\n      dstSph = ds4.x;\n      if (dstSph < min (dstObj, dstFar)) {\n        ro += dstSph * rd;\n        rd = reflect (rd, ds4.yzw);\n        ro += 0.01 * rd;\n      } else break;\n    }\n  }\n  rog = ro;\n  sh = 1.;\n  atten = 1.;\n  dstGrnd = dstFar;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n  }\n  if (ntMode > 0.) {\n    ltVec = roo - ro;\n    atten = smoothstep (0.7, 0.85, dot (ltAx, - normalize (ltVec))) / (1. + ((extVu == 0.) ?\n       0.01 : 0.0005) * dot (ltVec, ltVec));\n    ltVec += ltPos[nLit];\n    ltDir = normalize (ltVec);\n  }\n  if (dstObj < dstFar && idObj != idDuk && idObj != idLit || dstGrnd < dstFar || rd.y < 0.)\n     sh = (ntMode == 0.) ? ObjSShadow (ro + 0.01 * vn, sunDir, dstFar) : 1.;\n  if (dstObj < dstFar) {\n    col4 = ObjCol (ro, rd, vn);\n    if (ntMode == 0.) {\n      if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.1 * max (dot (vn, sunDir * vec3 (-1., 1., -1.)), 0.) +\n         0.1 * step (sh, 0.95) * abs (dot (vn, sunDir * normalize (vec3 (-1., 0., -1.)))) +\n         0.8 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n      else col = col4.rgb;\n    } else {\n      if (col4.a >= 0.) {\n        col = atten * (col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n           col4.a * step (0.95, sh) * pow (max (dot (ltDir, reflect (rd, vn)), 0.), 32.));\n      } else {\n        col = col4.rgb * (0.3 + 0.7 * max (- dot (rd, vn), 0.));\n      }\n    }\n  } else if (rd.y < 0.) {\n    col4.rgb = GrndCol (ro, rd, dstGrnd, vn);\n    if (ntMode == 0.) {\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.));\n      col = mix (col, vec3 (0.3, 0.35, 0.45), pow (1. + rd.y, 16.));\n    } else {\n      col = col4.rgb * atten * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.));\n    }\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (ntMode > 0. && (dstObj < dstFar && col4.a >= 0. || dstGrnd < dstFar && rd.y < 0.)) {\n    c = vec3 (0.);\n    for (int k = VAR_ZERO; k < nLit; k ++) {\n      ltVec = ltPos[k] - ro;\n      atten = 1. / (1. + 0.01 * dot (ltVec, ltVec));\n      if (atten > 0.01) {\n        ltDir = normalize (ltVec);\n        sh = ObjSShadow (ro, ltDir, length (ltVec));\n        c += atten * col4.rgb * sh * max (dot (vn, ltDir), 0.);\n      }\n    }\n    col = mix (col, c * vec3 (1.), smoothstep (-0.05, 0.05, Maxv3 (c) - Maxv3 (col)));\n  }\n  if (ntMode > 0.) col = mix (col, vec3 (1., 1., 0.3), min (2. * GlowCol (rog, rd,\n     min (dstObj, dstFar)), 1.));\n  return clamp (col, 0., 1.);\n}\n\nvec4 ShowWg (vec2 uv, vec2 canvas, vec4 parmV)\n{\n  vec4 wgBx[4];\n  vec3 cc[4], col;\n  vec2 ut, ust, c;\n  float vW[2], asp;\n  c = vec2 (1., 0.5);\n  cc[0] = c.xyy;\n  cc[1] = c.yxy;\n  cc[2] = c.yyx;\n  cc[3] = c.xxy;\n  asp = canvas.x / canvas.y;\n  for (int k = 0; k < 2; k ++)\n     wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n  for (int k = 2; k < 4; k ++)\n     wgBx[k] = vec4 ((0.41 + 0.05 * float (k - 2)) * asp, -0.4, 0.02, 0.02);\n  vW[0] = parmV.x;\n  vW[1] = parmV.y;\n  col = vec3 (0.);\n  for (int k = 0; k < 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy;\n    ust = abs (ut) - wgBx[k].zw * vec2 (0.7, 1.);\n    if (Maxv2 (ust) < 0.) {\n      if  (Minv2 (abs (ust)) * canvas.y < 2.) col = 0.3 * cc[k];\n      else col = (mod (0.5 * ((0.5 * uv.y - wgBx[k].y) / wgBx[k].w - 0.99), 0.1) *\n         canvas.y < 6.) ? 0.3 * cc[k] : 0.6 * cc[k];\n    }\n    ut.y -= (vW[k] - 0.5) * 2. * wgBx[k].w;\n    ut = abs (ut) * vec2 (1., 1.5);\n    if (Maxv2 (abs (ut)) < 0.025 && Maxv2 (ut) > 0.02) col = cc[k];\n  }\n  for (int k = 2; k < 4; k ++) {\n    ust = abs (0.5 * uv - wgBx[k].xy) - wgBx[k].zw;\n    if (Maxv2 (ust) < 0.) {\n      col = cc[k];\n      if (Minv2 (abs (ust)) * canvas.y < 2.) col *= 0.6;\n    }\n  }\n  return vec4 (col, step (0.001, length (col)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr, wgBxC, parmV, c4;\n  vec3 ro, rd, col, cw;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, asp, sr, tCurM, cm, dukAz, dukEl;\n  int wgSel;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  dstFar = 120.;\n  SetBldParms ();\n  parmV = Loadv4 (0);\n  zmFac = 1.5 / (1. - 0.8 * parmV.y);\n  extVu = parmV.z;\n  ntMode = parmV.w;\n  stDat = Loadv4 (1);\n  mPtr = vec4 (stDat.xyz, 0.);\n  wgSel = int (stDat.w);\n  stDat = Loadv4 (2);\n  el = - stDat.x;\n  az = - stDat.y;\n  tCur = stDat.z;\n  tCurM = stDat.w;\n  stDat = Loadv4 (3);\n  vuPos = stDat.xyz;\n  stDat = Loadv4 (4);\n  vuAz = stDat.x;\n  vuEl = stDat.y;\n  nLit = int (stDat.w);\n  stDat = Loadv4 (5);\n  dukPos = stDat.xyz;\n  dukPos.y += 1.2;\n  stDat = Loadv4 (6);\n  dukAz = stDat.x;\n  dukEl = stDat.y;\n  dukAzCs = CosSin (- dukAz);\n  dukElCs = CosSin (- dukEl);\n  dukVu = 1.;\n  asp = canvas.x / canvas.y;\n  wgBxC = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n  if (ntMode == 0.) sunDir = normalize (vec3 (0.7, 2., -1.));\n  if (extVu > 0.) {\n    if (false && (mPtr.z <= 0. || wgSel >= 0)) {\n      az -= 0.1 * tCur;\n      el -= 0.1 * pi * (1. + sin (0.03 * pi * tCur));\n    }\n    el -= 0.1 * pi;\n    el = clamp (el, -0.45 * pi, -0.02 * pi);\n    ro = vec3 (0., 2., -60.);\n    zmFac *= 1.5;\n  } else {\n    az -= vuAz;\n    el -= vuEl + 0.1;\n    el = clamp (el, -0.35 * pi, 0.35 * pi);\n    ro = vuPos;\n    ro.y += flrHt + 0.5;\n  }\n  vuMat = StdVuMat (el, az);\n  if (extVu > 0.) {\n    ro = vuMat * ro;\n    if (ntMode > 0.) ltPos[nLit] = vuMat * vec3 (0., 0., 20.);\n  } else {\n    if (ntMode > 0.) ltPos[nLit] = vec3 (0., 0.5, 0.5);\n  }\n  if (ntMode > 0.) {\n    for (int k = 0; k < nLit; k ++) {\n      stDat = Loadv4 (7 + k);\n      ltPos[k] = stDat.xyz;\n      ltPos[k].y += 2.;\n    }\n  }\n  if (ntMode > 0.) ltAx = vuMat * vec3 (0., 0., 1.);\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = vuMat * normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (tCur - tCurM < 7.) {\n    c4 = ShowWg (uv, canvas, parmV);\n    cw = mix (col, c4.rgb, c4.a);\n    cm = 0.2 + 0.8 * smoothstep (6., 7., tCur - tCurM);\n  } else {\n    cw = vec3 (0., 0.7, 0.7);\n    cm = 0.3 + 0.7 * step (2., abs (length (0.5 * uv - wgBxC.xy) - wgBxC.z) * canvas.y);\n  }\n  col = mix (cw, col, cm);\n  if (mPtr.z > 0. && wgSel < 0) {\n    if (Maxv2 (abs (uv)) < 0.05 && Minv2 (abs (uv)) < 0.005)\n       col = mix (col, vec3 (0.1, 1., 0.1), 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrBoxAn2Df (vec2 p, vec2 b, float w)\n{\n  return max (PrBox2Df (p, vec2 (b + w)), - PrBox2Df (p, vec2 (b - w)));\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec3 HexGrid (vec2 p)\n{\n  vec2 q;\n  p -= HexToPix (PixToHex (p));\n  q = abs (p);\n  return vec3 (p, (sqrt3/2.) - q.x + 0.5 * min (q.x - sqrt3 * q.y, 0.));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (mod (dot (p, vec2 (37., 39.)), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (mod (p + vec2 (0., 1.), 2. * pi)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat IFbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 10.;\n  for (int j = 0; j < 3; j ++) {\n    f += floor (a * Noiseff (p));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / (1.75 * a));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Rector's Palace at Night\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\nfloat Maxv2 (vec2 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\n#define VAR_ZERO min (nFrame, 0)\n#define N_POS 30\n#define NLIT_MX 5\n\nvec3 bPos[N_POS + 1];\nvec2 stCent;\nfloat outWd, corWd, flrHt, trkLen, vuAz, vuEl;\nint nFrame;\nconst float txRow = 128.;\nconst float pi = 3.1415927;\n\nvoid SetBldParms ()\n{\n  outWd = 20.;\n  corWd = 2.;\n  flrHt = 3.;\n  stCent = vec2 (-16., 2.);\n}\n\nvoid TrackInit ()\n{\n  float h, b, bo, s1, s2, dc;\n  h = 0.;\n  b = outWd - corWd;\n  bo = outWd - 2. * corWd;\n  s1 = 2.;\n  s2 = 6.;\n  bPos[0] = vec3 (s1, h, - outWd - 8.);\n  bPos[1] = vec3 (s1, h, - b);\n  bPos[2] = vec3 (b, h, - b);\n  bPos[3] = vec3 (b, h, b);\n  bPos[4] = vec3 (- s2, h, b);\n  bPos[5] = vec3 (- s2 - 2., h, s1);\n  h += 2. * flrHt;\n  bPos[6] = vec3 (- bo, h, - s2);\n  bPos[7] = vec3 (- b, h, - s2);\n  bPos[8] = vec3 (- b, h, - b);\n  bPos[9] = vec3 (b, h, - b);\n  bPos[10] = vec3 (b, h, s2);\n  bPos[11] = vec3 (bo, h, s2);\n  h -= 2. * flrHt;\n  bPos[12] = vec3 (s2 + 2., h, - s1);\n  bPos[13] = vec3 (s2, h, - bo + 2.);\n  bPos[14] = vec3 (-7., h, - bo + 2.);\n  bPos[15] = vec3 (-7., h, - s2 - 2.);\n  bPos[16] = vec3 (- s1, h, - s2 - 2.);\n  h += 2. * flrHt;\n  bPos[17] = vec3 (s2, h, - bo);\n  bPos[18] = vec3 (s2, h, - b);\n  bPos[19] = vec3 (- b, h, - b);\n  bPos[20] = vec3 (- b, h, b);\n  bPos[21] = vec3 (- s2, h, b);\n  bPos[22] = vec3 (- s2, h, bo);\n  h -= 2. * flrHt;\n  bPos[23] = vec3 (s1, h, s2 + 2.);\n  bPos[24] = vec3 (b, h, s2);\n  bPos[25] = vec3 (b, h, b);\n  bPos[26] = vec3 (- b, h, b);\n  bPos[27] = vec3 (- b, h, - b);\n  bPos[28] = vec3 (- s1, h, - b);\n  bPos[29] = vec3 (- s1, h, - outWd - 8.);\n  bPos[N_POS] = bPos[0];\n  dc = length (vec2 (0.5 * pi * 8., 2. * flrHt));\n  trkLen = 0.;\n  for (int k = 0; k < N_POS; k ++)\n     trkLen += ((k == 5 || k == 11 || k == 16 || k == 22) ? dc : length (bPos[k + 1] - bPos[k]));\n}\n\nvec3 TrackPos (float tp)\n{\n  vec3 bTrk, p1, p2;\n  float h, dTot, d, dCur, dc, a, t;\n  dc = length (vec2 (0.5 * pi * 8., 2. * flrHt));\n  dCur = mod (tp, trkLen);\n  dTot = 0.;\n  for (int k = VAR_ZERO; k < N_POS; k ++) {\n    d = ((k == 5 || k == 11 || k == 16 || k == 22) ? dc : length (bPos[k + 1] - bPos[k]));\n    if (dCur >=  dTot + d) dTot += d;\n    else {\n      t = (dCur - dTot) / d;\n      if (d == dc) {\n        if (k == 5) {\n          bTrk.xz = stCent;\n          a = -0.5 * t;\n        } else if (k == 11) {\n          bTrk.xz = - stCent;\n          a = 0.5 + 0.5 * t;\n        } else if (k == 16) {\n          bTrk.xz = stCent.yx * vec2 (-1., 1.);\n          a = 0.5 - 0.5 * t;\n        } else if (k == 22) {\n          bTrk.xz = stCent.yx * vec2 (1., -1.);\n          a = 1. + 0.5 * t;\n        }\n        bTrk.y = 2. * flrHt * ((k == 5 || k == 16) ? t : 1. - t);\n        bTrk.xz += 8. * vec2 (cos (pi * a), sin (pi * a));\n      } else bTrk = mix (bPos[k], bPos[k + 1], t);\n      break;\n    }\n  }\n  return bTrk;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 wgBx[5], mPtr, mPtrP, stDat, parmV;\n  vec3 ltPos, p1, p2, vd, vuPos, dukPos;\n  vec2 iFrag, canvas;\n  float tCur, tCurM, tCurP, vW, asp, el, az, spd, vuTr, vuAz, vuEl, ltTr,\n     dukAz, dukEl, extVu, t;\n  int pxId, wgSel, wgReg, kSel, nLit;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 7 + NLIT_MX) discard;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  wgReg = -2;\n  asp = canvas.x / canvas.y;\n  if (nFrame <= 1) {\n    parmV = vec4 (0.15, 0.25, 0., 1.);\n    mPtrP = mPtr;\n    wgSel = -1;\n    el = 0.;\n    az = 0.;\n    tCurM = tCur;\n    tCurP = tCur;\n    vuTr = 0.;\n    ltTr = 0.;\n    nLit = NLIT_MX;\n  } else {\n    parmV = Loadv4 (0);\n    stDat = Loadv4 (1);\n    mPtrP = vec4 (stDat.xyz, 0.);\n    wgSel = int (stDat.w);\n    stDat = Loadv4 (2);\n    el = stDat.x;\n    az = stDat.y;\n    tCurP = stDat.z;\n    tCurM = stDat.w;\n    stDat = Loadv4 (3);\n    vuTr = stDat.w;\n    stDat = Loadv4 (4);\n    nLit = int (stDat.w);\n    stDat = Loadv4 (5);\n    ltTr = stDat.w;\n  }\n  SetBldParms ();\n  if (mPtr.z > 0.) {\n    for (int k = 0; k < 2; k ++)\n       wgBx[k] = vec4 ((0.41 + 0.05 * float (k)) * asp, -0.15, 0.014 * asp, 0.18);\n    for (int k = 2; k < 4; k ++)\n       wgBx[k] = vec4 ((0.41 + 0.05 * float (k - 2)) * asp, -0.4, 0.02, 0.02);\n    wgBx[4] = vec4 (0.48 * asp, -0.46, 0.022, 0.);\n    for (int k = 0; k < 4; k ++) {\n      if (Maxv2 (abs (mPtr.xy * vec2 (asp, 1.) - wgBx[k].xy) - wgBx[k].zw) < 0.) wgReg = k;\n    }\n    if (length (mPtr.xy * vec2 (asp, 1.) - wgBx[4].xy) < wgBx[4].z) wgReg = 4;\n    if (mPtrP.z <= 0.) wgSel = wgReg;\n    if (wgSel >= 0) tCurM = tCur;\n  } else {\n    wgSel = -1;\n    wgReg = -2;\n  }\n  extVu = parmV.z;\n  if (wgSel < 0) {\n    if (mPtr.z > 0.) {\n      az = 2. * pi * mPtr.x * sign (extVu - 0.5);\n      el = pi * mPtr.y * sign (extVu - 0.5);\n    } else {\n      az *= 0.95;\n      el *= 0.95;\n    }\n  } else {\n    if (wgSel < 2) {\n      for (int k = 0; k < 2; k ++) {\n        if (wgSel == k) {\n          kSel = k;\n          vW = clamp (0.5 + 0.5 * (mPtr.y - wgBx[k].y) / wgBx[k].w, 0., 0.99);\n          break;\n        }\n      }\n      if      (kSel == 0) parmV.x = vW;\n      else if (kSel == 1) parmV.y = vW;\n    } else if (mPtrP.z <= 0.) {\n      if      (wgSel == 2) parmV.z = mod (++ parmV.z, 2.);\n      else if (wgSel == 3) parmV.w = mod (++ parmV.w, 2.);\n    }\n  }\n  spd = 10. * parmV.x;\n  vuTr += spd * (tCur - tCurP);\n  ltTr += 3. * (tCur - tCurP);\n  TrackInit ();\n  if (pxId == 3 || pxId == 4) {\n    p1 = TrackPos (vuTr + 2.);\n    p2 = TrackPos (vuTr - 2.);\n    vuPos = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    vuAz = atan (- vd.x, vd.z);\n    vuEl = - asin (vd.y);\n  } else if (pxId == 5 || pxId == 6) {\n    p1 = TrackPos (vuTr + 2. + 10.);\n    p2 = TrackPos (vuTr - 2. + 10.);\n    dukPos = 0.5 * (p1 + p2);\n    vd = normalize (p1 - p2);\n    dukAz = atan (- vd.x, vd.z) + 0.2 * sin (0.5 * pi * tCur);\n    dukEl = - asin (vd.y);\n  } else if (pxId >= 7 && pxId < 7 + nLit) {\n    t = (float (pxId - 7 + 1) / float (nLit + 1)) * trkLen;\n    p1 = TrackPos (ltTr + 2. + t);\n    p2 = TrackPos (ltTr - 2. + t);\n    ltPos = 0.5 * (p1 + p2);\n  }\n  if      (pxId == 0) stDat = parmV;\n  else if (pxId == 1) stDat = vec4 (mPtr.xyz, float (wgSel));\n  else if (pxId == 2) stDat = vec4 (el, az, tCur, tCurM);\n  else if (pxId == 3) stDat = vec4 (vuPos, vuTr);\n  else if (pxId == 4) stDat = vec4 (vuAz, vuEl, 0., float (nLit));\n  else if (pxId == 5) stDat = vec4 (dukPos, ltTr);\n  else if (pxId == 6) stDat = vec4 (dukAz, dukEl, 0., 0.);\n  else if (pxId >= 7 && pxId < 7 + nLit) stDat = vec4 (ltPos, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}