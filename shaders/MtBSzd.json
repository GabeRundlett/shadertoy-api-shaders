{
    "Shader": {
        "info": {
            "date": "1445857187",
            "description": "Ray traced displacement mapping",
            "flags": 0,
            "hasliked": 0,
            "id": "MtBSzd",
            "likes": 52,
            "name": "Displacement Mapping on the fly",
            "published": 3,
            "tags": [
                "raytracing",
                "displacement"
            ],
            "usePreview": 0,
            "username": "koiava",
            "viewed": 5766
        },
        "renderpass": [
            {
                "code": "//Displacement Mapping with ray tracing\n#define PIXEL_SAMPLES 4\n#define MAX_DISPLACEMENT 5.0\n#define DISP_MAP_W 32\n#define DISP_MAP_H 32\n#define SHADOW\n#define LIGHT_SAMPLES 4\n#define GAMMA 2.2\n#define SIN_WAVE\t//comment this to use video as a displacement map\n\nfloat displacementMultiplier;\n\n//used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n\n//********************************************\n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n// Data structures ****************** \nstruct AABB { vec3 min_; vec3 max_; };\nstruct Triangle { vec3 v0; vec3 v1; vec3 v2; };\nstruct Range { float min_; float max_; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n//***********************************\nAABB displacementVolume;// = AABB(vec3(-5.0,-5.0, 0.0), vec3(5.0,5.0, MAX_DISPLACEMENT));\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool rayAABBIntersection( in Ray ray, AABB aabb, out float t_enter, out float t_exit ) {\n    vec3 OMIN = ( aabb.min_ - ray.origin ) / ray.dir;\n    vec3 OMAX = ( aabb.max_ - ray.origin ) / ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    t_exit = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t_enter = max ( MIN.x, max ( MIN.y, MIN.z ) );\n    \n    if ( t_exit <= t_enter )\n        return false;\n    \n    return ( t_exit > t_enter );\n}\n\nvec3 getTriangleNormal(vec3 v0, vec3 v1, vec3 v2) {\n    return normalize(cross(v1-v0,v2-v0));\n}\n\nbool rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, out float t){\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tif (a > -0.00001 && a < 0.00001)\n\t\treturn false;\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tif (u < 0.0 || u > 1.0)\n\t\treturn false;\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\n\tif (v < 0.0 || u + v > 1.0)\n\t\treturn false;\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\t//uv = vec2(u, v);\n\t\n\tif (t > 0.00001) // ray intersection\n\t\treturn true;\n\n\t// this means that there is a line intersection\n\t// but not a ray intersection\n\treturn false;\n}\n\nbool rayQuadIntersect( in Ray ray, vec3 v0, vec3 v1, vec3 v2, vec3 v3, out float t, out vec3 n ) {\n    float tcurrent;\n    t = 10e+10;\n\t\n    //first triangle\n    if ( rayIntersectsTriangle( ray.origin, ray.dir, v0, v1, v2, tcurrent) ) {\n        t = tcurrent;\n        n = getTriangleNormal(v0, v1, v2);\n    }\n    \n    //second triangle\n    if ( rayIntersectsTriangle( ray.origin, ray.dir, v0, v2, v3, tcurrent) ) {\n        if(tcurrent<t) {\n            t = tcurrent;\n        \tn = getTriangleNormal(v0, v2, v3);\n        }\n    }\n    \n    return (t < 10e+10);\n}\n// ***************************************************************************\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n#define PIXEL2UV(x,y) vec2( float(x)/float(DISP_MAP_W), float(y)/float(DISP_MAP_H) )\nfloat getDisplacement(vec2 uv){\n    \n#ifdef SIN_WAVE\n    return (sin(iTime-length(vec2(0.5,0.5) - uv)*20.0)+1.0)/2.0;\n#else\n    return texture( iChannel0, uv ).x;\n#endif\n}\n\nvoid getPixelDisplacements( vec2 uv, out float d1, out float d2, out float d3, out float d4 ) {\n    int px = int(uv.x*float(DISP_MAP_W));\n    int py = int(uv.y*float(DISP_MAP_H));\n\n    d1 = getDisplacement( PIXEL2UV(px  ,py  ) );\n    d2 = getDisplacement( PIXEL2UV(px+1,py  ) );\n    d3 = getDisplacement( PIXEL2UV(px+1,py+1) );\n    d4 = getDisplacement( PIXEL2UV(px  ,py+1) );\n}\n\n#define UVH2POS(aabb,uvd,pos) { vec3 aabbDim = aabb.max_ - aabb.min_; pos = aabb.min_ + uvd*aabbDim; }\n#define POS2UVH(aabb,pos,uvd) { vec3 aabbDim = aabb.max_ - aabb.min_; uvd = (pos-aabb.min_)/aabbDim; }\nbool processVoxel(Ray ray, vec2 p, out float t, out vec3 normal) {\n    //Lookup displacement values\n    vec2 uv = p/vec2(DISP_MAP_W,DISP_MAP_H);\n            \n    float disp[4];\n    getPixelDisplacements( uv, disp[0], disp[1], disp[2], disp[3] );\n    \n   \t//calculate displaced vertices\n   \tint px = int(p.x);\n    int py = int(p.y);\n\n    vec3 corner_uv[4];\n    corner_uv[0] = vec3(PIXEL2UV(px  ,py  ), disp[0]);\n    corner_uv[1] = vec3(PIXEL2UV(px+1,py  ), disp[1]);\n    corner_uv[2] = vec3(PIXEL2UV(px+1,py+1), disp[2]);\n    corner_uv[3] = vec3(PIXEL2UV(px  ,py+1), disp[3]);\n\n    vec3 vertices[4];\n    UVH2POS(displacementVolume,corner_uv[0],vertices[0]);\n    UVH2POS(displacementVolume,corner_uv[1],vertices[1]);\n    UVH2POS(displacementVolume,corner_uv[2],vertices[2]);\n    UVH2POS(displacementVolume,corner_uv[3],vertices[3]);\n\n    float hitDist;\n    vec3 hitN;\n    if( rayQuadIntersect( ray, vertices[0], vertices[1], vertices[2], vertices[3], hitDist, hitN ) ) {\n        t = hitDist;\n        normal = hitN;\n        return true;\n    }\n    \n    return false;\n}\n\nbool processVoxelsOnLine(Ray ray, vec3 p0, vec3 p1, out float t, out vec3 normal) {\n\tint gx0idx = int(floor(p0.x));\n\tint gy0idx = int(floor(p0.y));\n\tint gz0idx = int(floor(p0.z));\n\t\n\tint gx1idx = int(floor(p1.x));\n\tint gy1idx = int(floor(p1.y));\n\tint gz1idx = int(floor(p1.z));\n    \n    int sx = (gx1idx > gx0idx) ? 1 : (gx1idx < gx0idx) ? -1 : 0;\n    int sy = (gy1idx > gy0idx) ? 1 : (gy1idx < gy0idx) ? -1 : 0;\n    int sz = (gz1idx > gz0idx) ? 1 : (gz1idx < gz0idx) ? -1 : 0;\n        \n\tint gx = gx0idx;\n\tint gy = gy0idx;\n\tint gz = gz0idx;\n\t\n\t//Planes for each axis that we will next cross\n    int gxp = gx0idx + (gx1idx > gx0idx ? 1 : 0);\n    int gyp = gy0idx + (gy1idx > gy0idx ? 1 : 0);\n    int gzp = gz0idx + (gz1idx > gz0idx ? 1 : 0);\n    \n\t//Only used for multiplying up the error margins\n\tfloat vx = (p1.x == p0.x)? 1.0 : p1.x - p0.x;\n\tfloat vy = (p1.y == p0.y)? 1.0 : p1.y - p0.y;\n\tfloat vz = (p1.z == p0.z)? 1.0 : p1.z - p0.z;\n\t\n    //Error is normalized to vx * vy * vz so we only have to multiply up\n    float vxvy = vx * vy;\n    float vxvz = vx * vz;\n    float vyvz = vy * vz;\n\t\n\t//Error from the next plane accumulators, scaled up by vx*vy*vz\n\tfloat errx = (float(gxp) - p0.x) * vyvz;\n\tfloat erry = (float(gyp) - p0.y) * vxvz;\n\tfloat errz = (float(gzp) - p0.z) * vxvy;\n\t\n\tfloat derrx = float(sx) * vyvz;\n\tfloat derry = float(sy) * vxvz;\n\tfloat derrz = float(sz) * vxvy;\n    \n    for(int i=0; i<(DISP_MAP_W+DISP_MAP_H); i++) {\n        if( processVoxel(ray, vec2(float(gx),float(gy)), t, normal) ) {\n            return true;\n        }\n\t\t\n\t\tif ((gx == gx1idx) && (gy == gy1idx) && gz == gz1idx)\n            break;\n\n        //Which plane do we cross first?\n\t\tfloat xr = abs(errx);\n\t\tfloat yr = abs(erry);\n\t\tfloat zr = abs(errz);\n        \n        //console.log(\"err\",errx,erry,errz);\n\t\tif ((sx != 0) && (sy == 0 || xr < yr) && (sz == 0 || xr < zr)) {\n\t\t\tgx += sx;\n\t\t\terrx += derrx;\n\t\t} else if (sy != 0 && (sz == 0 || yr < zr)) {\n\t\t\tgy += sy;\n\t\t\terry += derry;\n\t\t} else if (sz != 0) {\n\t\t\tgz += sz;\n\t\t\terrz += derrz;\n\t\t}\n\t}\n    return false;\n}\n\nbool rayIntersectsDisplacement( in Ray ray, out float t, out vec3 normal, out int iter ) {\n    iter = 0;\n    float t1, t2;\n    if( rayAABBIntersection( ray, displacementVolume, t1, t2) ) {\n       \tvec3 hitpos1 = ray.origin + ray.dir*(t1+EPSILON);\t//volume entry point\n        vec3 hitpos2 = ray.origin + ray.dir*(t2-EPSILON);\t//volume exit point\n        \n        //Convert position to parametric coordinates\n        vec3 uvd1, uvd2;\n        POS2UVH(displacementVolume,hitpos1,uvd1);\n        POS2UVH(displacementVolume,hitpos2,uvd2);\n        \n        //pixel coordinates of projected entry and exit point\n        vec3 p0 = uvd1*vec3(float(DISP_MAP_W),float(DISP_MAP_H),1.0);\n        vec3 p1 = uvd2*vec3(float(DISP_MAP_W),float(DISP_MAP_H),1.0);\n        \n        if( processVoxelsOnLine(ray, p0, p1, t, normal) ) {\n            iter = 1;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 getColor(Ray ray) {\n    float t;\n    vec3 n;\n    int iter;\n    if( rayIntersectsDisplacement( ray, t, n, iter ) ) {\n        vec3 p = ray.origin + ray.dir*t;\n        vec3 normal = dot(ray.dir,n)<0.0?n:-n;\n        \n        vec3 lc = normalize(vec3(0.4,0.5,0.3));\n        float a_max = PI/30.0;\n        \n        \n\t\tvec3 Li = vec3(0.0);\n        for(int i=0; i<LIGHT_SAMPLES; i++) {\n            float a = rnd()*a_max;\n            float sina = sin(a);\n        \tfloat cosa = sqrt(1.0-sina*sina);\n            vec3 l = uniformDirectionWithinCone( lc, rnd()*TWO_PI, sina, cosa );\n\n            float dotNL = dot(normal,l);\n            if(dotNL < 0.0) {\n                return abs(dotNL)*vec3(0.01);//fake indirect\n            }\n            \n            Ray shadowRay = Ray( p + normal*EPSILON, l );\n\n#ifdef SHADOW\n            if(rayIntersectsDisplacement( shadowRay, t, n, iter )) {\n            \tLi += vec3(0.003);//fake indirect\n            }else\n#endif\n            {\n            \tLi += max(0.0, dotNL)*vec3(1.0);\n            }\n            \n    \t}\n        \n        return Li*(1.0/float(LIGHT_SAMPLES));\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    vec3 cameraPos = vec3( 6.0 + sin(iTime*0.4), -9.0 + sin(iTime*0.3), 7.0 + sin(iTime*0.4)*5.0 );\n    vec3 cameraTarget = vec3( 0.0, 0.0, 0.0 );\n    \n    displacementVolume.min_ = vec3(-5.0,-5.0, 0.0);\n    displacementMultiplier = (iMouse.w!=0.0)?min(1.0,iMouse.y/iResolution.y):0.4;\n    displacementVolume.max_ = vec3(5.0,5.0, displacementMultiplier*MAX_DISPLACEMENT);\n    \n    Camera camera;\n   \n    initCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 0.0, 1.0 ), radians(40.0), camera );\n\t\n    Ray ray;\n\tvec3 accumulatedColor = vec3( 0.0 );\n\tfor(int si=0; si<PIXEL_SAMPLES; ++si ){\n        vec2 screenCoord = fragCoord.xy + vec2( (1.0/float(PIXEL_SAMPLES))*(float(si)+rnd()), rnd() );\n        ray = genRay( camera, screenCoord );\n        \n        accumulatedColor += getColor( ray );\n\t}\n\t\n\t//devide to sample count\n\taccumulatedColor = accumulatedColor*(1.0/float(PIXEL_SAMPLES));\n\t\n\t//gamma correction\n    accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n    \n\tfragColor = vec4( accumulatedColor,1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}