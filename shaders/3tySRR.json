{
    "Shader": {
        "info": {
            "date": "1582014463",
            "description": "Simple font made from line and arc.\nThe original font geometry (in svg) is here [url]https://github.com/hi-ogawa/python-shader-app/blob/master/misc/la_font[/url].\nHere only upper case alphabets but I implemented all ascii characters.",
            "flags": 0,
            "hasliked": 0,
            "id": "3tySRR",
            "likes": 41,
            "name": "Line/Arc font stroke animation",
            "published": 3,
            "tags": [
                "font"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 1343
        },
        "renderpass": [
            {
                "code": "//\n// Font distance function is defined in \"common\"\n//\n\n\n//\n// Parameters\n//\n\nfloat SCALE_TIME = 8.0;\nfloat LOOP_TIME = 32.0;\nbool  STROKE_MODE = true;\n\n// AA in pixel width\nfloat AA = 2.0;\n\n// isoline effect\nfloat ISOLINE_STEP = 10.0;\nfloat ISOLINE_WIDTH = 1.0;\nfloat ISOLINE_EXTENT = 200.0;\n\n// scene coordinate frame\nconst vec2 FONT_SIZE = vec2(4.0, 7.0);\nconst float NUM_COLUMNS = 10.0;\nconst vec2 BBOX_X = vec2(0.0, FONT_SIZE.x * NUM_COLUMNS) + vec2(-2.0, 2.0);\nconst float BBOX_Y1 = FONT_SIZE.y;\n\n// font width in scene size\nfloat FONT_WIDTH = 0.4;\n\n\n//\n// Implement scene\n//\n\nstruct SceneInfo {\n  float t;\n  float id;\n};\n\nSceneInfo mergeSceneInfo(SceneInfo info, float t, float id) {\n  info.id = info.t < t ? info.id : id;\n  info.t  = info.t < t ? info.t  : t ;\n  return info;\n}\n\nSceneInfo getSceneSdf(vec2 p, float time) {\n  SceneInfo result;\n  result.t = 1e30;\n\n  float index = 0.0;\n  float state = STROKE_MODE ? SCALE_TIME * mod(time, LOOP_TIME) : 1e30;\n  float len = 0.0;\n  float ud;\n  vec2 q;\n  // Loop over FONT_LIST_NAMES (macro defined in \"common\")\n  #define DRAW(NAME)                                                         \\\n      q = vec2(0.5 + mod(index, NUM_COLUMNS), - floor(index / NUM_COLUMNS)); \\\n      ud = NAME(p - FONT_SIZE * q, state -= len, len),       \\\n      result = mergeSceneInfo(result, ud, index++);\n    FONT_LIST_NAMES(DRAW)\n  #undef DRAW\n\n  result.t -= FONT_WIDTH / 2.0;\n  return result;\n}\n\n//\n// Misc\n//\n\nfloat SdfOp_isoline(float sd, float _step, float width) {\n  float t = mod(sd, _step);\n  float ud_isoline = min(t, _step - t);\n  float sd_isoline = ud_isoline - width / 2.0;\n  return sd_isoline;\n}\n\nfloat smoothCoverage(float signed_distance, float width) {\n  return 1.0 - smoothstep(0.0, 1.0, signed_distance / width + 0.5);\n}\n\nvec3 easyColor(float t) {\n  float s = fract(sin(t * 123456.789) * 123456.789);\n  vec3 v = vec3(0.0, 1.0, 2.0) / 3.0;\n  vec3 c = 0.5 + 0.5 * cos(2.0 * M_PI * (s - v));\n  c = smoothstep(vec3(-0.2), vec3(0.8), c);\n  return c;\n}\n\n//\n// Main\n//\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  // \"window -> scene\" transform\n  float xform_s = (BBOX_X[1] - BBOX_X[0]) / iResolution.x;\n  vec2 xform_t = vec2(\n      BBOX_X[0],\n      BBOX_Y1 - (BBOX_X[1] - BBOX_X[0]) * (iResolution.y / iResolution.x));\n\n  vec2 p = frag_coord * xform_s + xform_t;\n  bool mouse_down = iMouse.z > 0.5;\n\n  vec3 color = vec3(1.0);\n  {\n    //\n    // Main rendering\n    //\n    SceneInfo info = getSceneSdf(p, iTime);\n    float fac = smoothCoverage(info.t, AA * xform_s);\n    vec3 c = easyColor(info.id);\n\n    //\n    // Fancy isolines\n    //\n    float sd = info.t / xform_s; // to window sp.\n    float ud = abs(max(0.0, sd));\n    float sd_isoline = SdfOp_isoline(ud, ISOLINE_STEP, ISOLINE_WIDTH);\n    float isoline_fac = smoothCoverage(sd_isoline, AA);\n    float fade_fac = exp(-7.0 * ud / ISOLINE_EXTENT); // n.b. exp(-7) ~ 0.001\n    color = mix(color, c, fade_fac);\n    color = mix(color, c * vec3(0.6), isoline_fac * fade_fac);\n  }\n\n  {\n    //\n    // Coordinate grid\n    //\n    {\n      // Grid\n      float step = 1.0;\n      float w = 1.0 * xform_s;\n      float sd = 1e30;\n      sd = min(sd, SdfOp_isoline(p.x, step, w));\n      sd = min(sd, SdfOp_isoline(p.y, step, w));\n      float fac = smoothCoverage(sd, AA * xform_s);\n      color = mix(color, vec3(0.0), 0.1 * fac);\n    }\n    {\n      // Axis\n      float w = 1.0 * xform_s;\n      float sd = 1e30;\n      sd = min(sd, SdfOp_isoline(p.x, FONT_SIZE.x, w));\n      sd = min(sd, SdfOp_isoline(p.y, FONT_SIZE.y, w));\n      float fac = smoothCoverage(sd, AA * xform_s);\n      color = mix(color, vec3(0.0), 0.4 * fac);\n    }\n  }\n\n  frag_color = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//\n// Sdf routines\n//\n\n#define M_PI 3.14159\n\nfloat Sdf_lineSegment(vec2 p, vec2 v, float t0, float t1) {\n  // assert |v| = 1\n  return distance(p, clamp(dot(p, v), t0, t1) * v);\n}\n\nfloat Sdf_arc(vec2 p, float t0, float t1) {\n  //\n  // \"Arc\" defined as a path of winding map:\n  //   R --> S1\n  //   t |-> (cos(2pi t), sin(2pi t))\n  //\n  // Thus, sign(t1 - t0) gives orientation i.e.\n  //   t1 >= t0  (counter clock wise)\n  //   t0 >= t1  (clock wise)\n  //\n  float t  = atan(p.y, p.x) / (2.0 * M_PI); // in [-0.5, 0.5]\n  float tt = mod(t - t0, 1.0) + t0;         // in [t0, t0 + 1]\n\n  // Check if \"(0, 0) -> p\" crosses arc\n  if ((t0 <= t1 && tt <= t1) || (t1 <= t0 && t1 <= tt - 1.0)) {\n    return abs(length(p) - 1.0);\n  }\n\n  // Otherwise return distance to two endpoints\n  vec2 q1 = vec2(cos(2.0 * M_PI * t0), sin(2.0 * M_PI * t0));\n  vec2 q2 = vec2(cos(2.0 * M_PI * t1), sin(2.0 * M_PI * t1));\n  return min(distance(p, q1), distance(p, q2));\n}\n\n\n//\n// Define font geometry (and stroke progress effect) via macro\n//\n\n#define SDF_FONT(NAME, RULE)     \\\n  float NAME(vec2 p, float state, out float stroke) { \\\n    float ud = 1e30;                                     \\\n    stroke = 0.0;                                        \\\n    RULE                                                 \\\n    return ud;                                           \\\n  }\n\n#define SDF_FONT_LINE(x0, y0, x1, y1) \\\n  {                                                                    \\\n    vec2 v = vec2(x1, y1) - vec2(x0, y0);                              \\\n    float l = length(v);                                               \\\n    float ll = min(state - stroke, l);                                 \\\n    if (ll > 0.0) {                                                    \\\n      ud = min(ud, Sdf_lineSegment(p - vec2(x0, y0), v / l, 0.0, ll)); \\\n    }                                                                  \\\n    stroke += l;                                                       \\\n  }\n\n#define SDF_FONT_ARC(cx, cy, r, t0, t1) \\\n  {                                                                       \\\n    float s = sign(t1 - t0);                                              \\\n    float l = r * 2.0 * M_PI * abs(t1 - t0);                              \\\n    float ll = min(state - stroke, l);                                    \\\n    float tt = ll / (r * 2.0 * M_PI);                                     \\\n    if (tt > 0.0) {                                                       \\\n      ud = min(ud, Sdf_arc((p - vec2(cx, cy)) / r, t0, t0 + s * tt) * r); \\\n    }                                                                     \\\n    stroke += l;                                                          \\\n  }\n\n\n//\n// These macros are generated from (annotated) svg\n//\n\nSDF_FONT(en_A,\n  SDF_FONT_LINE(0, 4, -1, 0)\n  SDF_FONT_LINE(0, 4, 1, 0)\n  SDF_FONT_LINE(-0.75, 1, 0.75, 1))\n\nSDF_FONT(en_B,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 0, -1, 0))\n\nSDF_FONT(en_C,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0))\n\nSDF_FONT(en_D,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_ARC (-1.0, 2.0, 2.0, 0.25, -0.25))\n\nSDF_FONT(en_E,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(-1, 2, 1, 2)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\nSDF_FONT(en_F,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(-1, 2, 1, 2))\n\nSDF_FONT(en_G,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 2)\n  SDF_FONT_LINE(0, 2, 1, 2))\n\nSDF_FONT(en_H,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 2, 1, 2)\n  SDF_FONT_LINE(1, 4, 1, 0))\n\nSDF_FONT(en_I,\n  SDF_FONT_LINE(-0.5, 4, 0.5, 4)\n  SDF_FONT_LINE(0, 4, 0, 0)\n  SDF_FONT_LINE(-0.5, 0, 0.5, 0))\n\nSDF_FONT(en_J,\n  SDF_FONT_LINE(0.5, 4, 1.5, 4)\n  SDF_FONT_LINE(1, 4, 1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.0, -0.5))\n\nSDF_FONT(en_K,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(1, 4, -1, 2)\n  SDF_FONT_LINE(-1, 2, 1, 0))\n\nSDF_FONT(en_L,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\nSDF_FONT(en_M,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 0)\n  SDF_FONT_LINE(0, 0, 1, 4)\n  SDF_FONT_LINE(1, 4, 1, 0))\n\nSDF_FONT(en_N,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 1, 0)\n  SDF_FONT_LINE(1, 0, 1, 4))\n\nSDF_FONT(en_O,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 3)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.25))\n\nSDF_FONT(en_P,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2))\n\nSDF_FONT(en_Q,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, 0.5)\n  SDF_FONT_LINE(-1, 3, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 3)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.25)\n  SDF_FONT_LINE(0, 1, 1, 0))\n\nSDF_FONT(en_R,\n  SDF_FONT_LINE(-1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 4, 0, 4)\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.25, -0.25)\n  SDF_FONT_LINE(0, 2, -1, 2)\n  SDF_FONT_LINE(0, 2, 1, 0))\n\nSDF_FONT(en_S,\n  SDF_FONT_ARC (0.0, 3.0, 1.0, 0.0, 0.75)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.25, -0.5))\n\nSDF_FONT(en_T,\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(0, 4, 0, 0))\n\nSDF_FONT(en_U,\n  SDF_FONT_LINE(-1, 4, -1, 1)\n  SDF_FONT_ARC (0.0, 1.0, 1.0, 0.5, 1.0)\n  SDF_FONT_LINE(1, 1, 1, 4))\n\nSDF_FONT(en_V,\n  SDF_FONT_LINE(-1, 4, 0, 0)\n  SDF_FONT_LINE(0, 0, 1, 4))\n\nSDF_FONT(en_W,\n  SDF_FONT_LINE(-1, 4, -0.5, 0)\n  SDF_FONT_LINE(-0.5, 0, 0, 4)\n  SDF_FONT_LINE(0, 4, 0.5, 0)\n  SDF_FONT_LINE(0.5, 0, 1, 4))\n\nSDF_FONT(en_X,\n  SDF_FONT_LINE(-1, 4, 1, 0)\n  SDF_FONT_LINE(1, 4, -1, 0))\n\nSDF_FONT(en_Y,\n  SDF_FONT_LINE(-1, 4, 0, 2)\n  SDF_FONT_LINE(1, 4, 0, 2)\n  SDF_FONT_LINE(0, 2, 0, 0))\n\nSDF_FONT(en_Z,\n  SDF_FONT_LINE(-1, 4, 1, 4)\n  SDF_FONT_LINE(1, 4, -1, 0)\n  SDF_FONT_LINE(-1, 0, 1, 0))\n\n#define FONT_LIST_NAMES(_) \\\n  _(en_A) \\\n  _(en_B) \\\n  _(en_C) \\\n  _(en_D) \\\n  _(en_E) \\\n  _(en_F) \\\n  _(en_G) \\\n  _(en_H) \\\n  _(en_I) \\\n  _(en_J) \\\n  _(en_K) \\\n  _(en_L) \\\n  _(en_M) \\\n  _(en_N) \\\n  _(en_O) \\\n  _(en_P) \\\n  _(en_Q) \\\n  _(en_R) \\\n  _(en_S) \\\n  _(en_T) \\\n  _(en_U) \\\n  _(en_V) \\\n  _(en_W) \\\n  _(en_X) \\\n  _(en_Y) \\\n  _(en_Z) \\\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}