{
    "Shader": {
        "info": {
            "date": "1552256365",
            "description": "This is an evolution of a shader coded live on twitch by Nusan (https://www.twitch.tv/nusan_fx)\nOriginal shader: https://www.shadertoy.com/view/wd2GDG",
            "flags": 0,
            "hasliked": 0,
            "id": "tdsSW2",
            "likes": 21,
            "name": "NuSan - Rainy Bridge Remix",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "rain",
                "live",
                "twitch"
            ],
            "usePreview": 0,
            "username": "Alkama",
            "viewed": 1289
        },
        "renderpass": [
            {
                "code": "/*\nShader coded live on twitch by NuSan (https://www.twitch.tv/nusan_fx)\nOriginal shader: https://www.shadertoy.com/view/wd2GDG\n\nYou can lower the MARCH_STEPS if too slow\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/RainyBridge.glsl\n*/\n\n#define MARCH_STEPS 100\n#define RAIN_STEPS 50\n#define SHAD_STEP 30\n\n#define time iTime\n\n#define sat(v) clamp(v,0.,1.)\n\nfloat PI = acos(-1.0);\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 s) {\n  vec3 ap = abs(p)-s;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x, max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n  vec3 off = vec3(0.0);\n  off.x += sin(p.z*0.2) + sin(p.z*0.137)*3.0;\n  off.y += sin(p.z*0.5)*0.2 + p.z*0.3;\n  return off;\n}\n\nfloat smin(float a, float b, float h) {\n  float k = clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a, b, k) - k*(1.0-k)*h;\n}\n\nfloat map(vec3 p) {\n  vec3 pw = p;\n  pw.y += .015*pw.z*sin(time*2.+sin(time+pw.x)+sin(-time+pw.y*8.+pw.z)+cos(-time+pw.z*6.));\n  float water = 10.0-pw.y-pw.z*0.3;\n\n  p += tunnel(p);\n\n  vec3 rp = p;\n  float sizerepeat = 2.0;\n  rp.z = (fract(rp.z/sizerepeat-0.5)-0.5)*sizerepeat;\n  \n  rp.yz *= rot(-rp.z*0.2);\n  float bridge = box(rp + vec3(0,-1,0), vec3(1.0,0.2,2.0));\n  \n  vec3 rp4 = rp + vec3(0,-0.8,0);\n  rp4.x += sin(p.z*8.0)*0.05;\n  rp4.y += cos(p.z*7.0)*0.05;\n  float size4 = 0.14;\n  rp4.xz = (fract(rp4.xz/size4-0.5)-0.5)*size4;\n  float bricks = box(rp4, vec3(0.05))-0.015;\n  bricks = max(bricks, bridge - 0.05);\n\n  bridge = smin(bridge, bricks, 0.09);\n\n  rp.x = abs(rp.x) - 1.0;\n  \n  float bar = box(rp + vec3(0,-0.5,0), vec3(0.05,0.05,2.0));\n  vec3 rp2 = rp;\n  float size2 = 0.2;\n  rp2.z = (fract(rp2.z/size2-0.5)-0.5)*size2;\n  bar = min(bar, box(rp2 + vec3(0,-0.8,0), vec3(0.03,0.3,0.03)));\n\n  bridge = min(bridge, bar);\n\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n  float def = sin(rp3.y*17.0+2.0)*0.5+0.5;\n  def = sin(rp3.y*10.0 + def*3.0);\n  def = smoothstep(0.0,1.0,def);\n  def = smoothstep(0.0,1.0,def);\n  float lsize = 0.05 + (def)*0.02;\n  float lamp = max(cyl(rp3.xz + vec2(0,0), lsize), abs(rp3.y)-1.0);\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  top = max(top, -sph(lpos-vec3(0,0.3,0), 0.5));\n\n  lpos.y = max(abs(lpos.y)-0.1,0.0);\n  \n  lpos = abs(lpos)-0.1;\n  lpos.xz *= rot(PI*0.25);\n  bridge = min(bridge, lamp);\n\n  bridge = min(bridge, water);\n\n  return bridge;\n}\n\n\nfloat lighting(vec3 p) {\n  p += tunnel(p);\n\n  float sizerepeat = 2.0;\n  vec3 rp3 = p + vec3(1,0,1.0);\n  float size3 = sizerepeat * 2.0;\n  rp3.z = (fract(rp3.z/size3-0.5)-0.5)*size3;\n\n  vec3 lpos = rp3 + vec3(0,1,0);\n  float top = sph(lpos, 0.3);\n  return sph(lpos, 0.12);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvec3 getlightdir(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(lighting(p)-vec3(lighting(p-off.xyy), lighting(p-off.yxy), lighting(p-off.yyx)));\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*745.523)*7894.552);\n}\n\nfloat rain(vec3 p) {\n  p.y -= time*4.0;\n  p.xy *= 60.0;\n  p.x += sin((p.y+p.x+time)*.05);\n  p.y += rnd(floor(p.x))*80.0;\n  \n  return clamp(1.0-length(vec2(cos(p.x * PI), sin(p.y*0.1) - 1.7)), 0.0, 1.0);\n}\n\nfloat ripple(vec3 p) {\n  float t2 = time*5.0;\n\n  float size3 = 0.2;\n  vec3 rp3 = p * vec3(.5,1.,2.) + vec3(1.,0.,1.0);\n  \n  float id = dot(floor(rp3.xz/size3-0.5), vec2(7.52,5.48));\n  rp3.xz = (fract(rp3.xz/size3-0.5)-0.5)*size3;\n  \n  float r = clamp(1.0-length(rp3.xz)*20.0, 0.0, 1.0);\n  float looplen = 0.5;\n  float off = rnd(id * 75.5238);\n  float fl = 1.0-fract(time*looplen + off);\n  fl = pow(fl,10.0);\n  float r2 = cos(r*10.0 + t2) * fl;\n\n  return r2*r;\n}\n\nfloat ripples(vec3 p) {\n\n  float r = 0.0;\n  for(int i=0; i<5; ++i) {\n    vec3 cur = p + vec3(rnd(float(i)), 0, rnd(float(i)+75.523));\n    cur *= rnd(float(i)+12.71)*0.2+0.8;\n    cur *= 3.0;\n    r += ripple(cur);\n  }\n  return r;\n}\n\nvec3 ripplenorm(vec3 n, vec3 p) {\n\n  vec2 off = vec2(0.01,0.0);\n\n  vec3 rn = normalize(vec3(ripples(p+off.xyy)-ripples(p-off.xyy), 1.9, ripples(p+off.yyx)-ripples(p-off.yyx)));\n  n.xz += .75 * rn.xz * (abs(n.y));\n  return n;\n  \n}\n\nfloat rnd(vec2 uv) {\n  return fract(dot( sin(uv*vec2(784.553) + uv.yx*vec2(546.124)), vec2(7845.523) ));\n}\n\nfloat curve(float t, float r, float p) {\n  float g = t/r;\n  return mix(step(rnd(floor(g)), p), step(rnd(floor(g)+1.0), p), fract(g));\n}\n\nfloat shadow(vec3 s, vec3 r, float maxdist, float rn) {\n  float shad = 1.0;\n  vec3 raystep = r*maxdist/float(SHAD_STEP);\n  vec3 p = s + raystep*rn;\n  for(int i=0; i<SHAD_STEP; ++i) {\n    float d = map(p);\n    if(d<0.01) {\n      shad = 0.0;\n      break;\n    }\n    p += raystep;\n  }\n  return shad;\n}\n\n// Fake noise approximation to Bonzomatic noise texture (by LunaSorcery)\nfloat noise(vec2 a) {\n    float b = 0.;\n    b += texture(iChannel0, a*.25).r*.5;\n    b += texture(iChannel0, a*.5).r*.25;\n    b += texture(iChannel0, a*1.).r*.125;\n    b += texture(iChannel0, a*2.).r*.0625;\n    return b*.75;\n}\n\nvec3 skycolor(vec3 dir) {\n  float noise = noise(vec2(time*.02, 0) + 2.*vec2(3.5*dir.y, ((time*-.05)+2.*atan(dir.x,dir.z)))/PI);\n  noise = 3.*pow(noise,3.);\n  noise *= sat(-dir.y-.2);\n  return vec3(noise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  float ourmoon = sat(\n      smoothstep(.06, .02, length(uv-vec2(-.54,.35))) -\n  \t  smoothstep(.06, .05, length(uv-vec2(-.51,.37)))\n  );\n  \n  vec3 s = vec3(1,sin(time*0.3)*0.2,-3);\n  vec3 t = vec3(0,0,0);\n  vec3 r = normalize(vec3(-uv,0.7));\n  \n  vec3 p = s;\n  float dd=0.0;\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d = map(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n\n  vec3 col = vec3(0.0);\n  vec3 n = norm(p);\n\n  n = ripplenorm(n, p);\n\n  float lightning = curve(time, 0.2, 0.1);\n  float idlightning = 0.0;\n\n  float fog = 1.0-pow(clamp(dd/50.0,0.0,1.0),0.2);\n  vec3 lmoon = normalize(vec3(-8,-3.+5.*floor(10.*mod(lightning,.2)),-3.0 + sin(idlightning)*3.0+5.*floor(3.*mod(lightning,.5))));\n\n  vec3 shad = vec3(.6, .8, 1.) * shadow(p + n * 0.02, lmoon, 3.0, rnd(uv));\n\n  col += lightning * 5.0 * max(0.0, dot(n, lmoon)) * fog * shad;\n\n  vec3 l = -getlightdir(p);\n  float ldist = lighting(p);\n\n  vec3 h = normalize(l-r);\n\n  col += vec3(.7, .3, .2) * max(0.0, dot(n, l)) * fog * 10.0 * (0.4 + 2.0*pow(max(0.0, dot(n,h)),30.0) )/(ldist*ldist*ldist*ldist);\n\n  float at = 0.0;\n  vec3 raining = vec3(0.0);\n  float stepsize = 30.0 / float(RAIN_STEPS);\n  vec3 raystep = r * stepsize / r.z;\n  for(int i=0; i<RAIN_STEPS; ++i) {\n    vec3 raypos = s + raystep * (float(i)+1.0);\n    float tot = length(raypos-s);\n\n    if(tot>dd) break;\n    float fog2 = 1.0-pow(clamp(tot/40.0,0.0,1.0),0.5);\n\n    \n    vec3 ldir = getlightdir(raypos);\n    float l2dist = lighting(raypos);\n    float curlight = 1.0/pow(l2dist,2.0);\n\n    vec3 rainpos = raypos;\n    rainpos.xy *= rot(sin(float(i)*0.2)*0.01 + sin(time)*0.009);\n    rainpos.xy += rnd(float(i))*vec2(7.52,13.84);\n    raining += rain(rainpos) * fog2 * (lightning*0.5 + pow(curlight,2.0));\n\n    at += 0.04*curlight * fog2;\n  }\n  col += at * vec3(.7, .3, .1);\n  col += raining*.3;\n\n  vec3 sc = skycolor(r);\n  sc = ourmoon*.5*vec3(1., .8, .5)*sc + col*sc*vec3(.5, .7, 1.);\n  col += (lightning+.25)*80.*sc;\n  \n  col += pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}