{
    "Shader": {
        "info": {
            "date": "1523460226",
            "description": "Etienne Jacob displaces randomly a grid.\nBut procedural way from pixel uv is the reverse: gives too different look and can't fold. \nHere: trying to solve U = P + noise(P) for P using Newton iterations. WIP.\nWhy doesn't it work ? Help !",
            "flags": 0,
            "hasliked": 0,
            "id": "MdVyDV",
            "likes": 2,
            "name": "Help ! inverse shaking grid 2",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "displacement",
                "perlin",
                "solver",
                "inverse",
                "newton",
                "art",
                "etiennejacob"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 776
        },
        "renderpass": [
            {
                "code": "// tuto by Etienne Jacob https://necessarydisorder.wordpress.com/2017/11/15/drawing-from-noise-and-then-making-animated-loopy-gifs-from-there/\n// -> ref: direct costly displacement U=D(P): https://www.shadertoy.com/view/MdyyWK\n// Usual pixel-procedural displacement P=D(U) is cheap but look bad: https://shadertoy.com/view/MsGyWK\n\n// So I try to inverse U=D(P), with  D(P) = P + k(P).perlin(P)\n// First naive try (folds don't work) here: https://www.shadertoy.com/view/MsVyWV\n// Here, I want to really solve the inverse, using Newton solver. \n// WIP.\n\n// Why doesn't it work ?\n// - grad(fbm) is ok (see tests)\n// - NB: same-time shape is identical to https://www.shadertoy.com/view/MdyyWK\n// - NB: tmp tunings are slow to help convergence\n\n// --- pseudo perlin noise 3D\n\nint MOD = 1;  // type of Perlin noise\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define hash31(p) fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123)\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                       mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), f.y), \n                  mix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                       mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), f.y), f.z);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\nvec3 dnoise3(vec3 p) {  // --- grad(noise)\n    vec3 i = floor(p);\n    vec3 g, f0 = fract(p), f = f0*f0*(3.-2.*f0), df = 6.*f0*(1.-f0); // smoothstep\n#define dmix(a,b,x) x*(b-a)\n    g.x = mix(  mix(dmix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),df.x),\n                    dmix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),df.x), f.y), \n                mix(dmix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),df.x),\n                    dmix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),df.x), f.y), f.z);\n    g.y = mix( dmix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                     mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), df.y), \n               dmix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                     mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), df.y), f.z);\n    g.z = dmix( mix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                     mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), f.y), \n                mix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                     mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), f.y), df.z);\n\treturn 2.*g; // <><><>only MOD=1 <><><>\n}\n\nfloat fbm3(vec3 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 1; i++, p*=2.,a/=2.) \n        p.xy *= R, p.yz *= R,\n        v += a * noise3(p);\n\n    return v/.75;\n}\nvec3 dfbm3(vec3 p) {  // --- grad(fbm) \n    vec3 g = vec3(0),dn;\n    mat2 R = rot(.37);\n    mat3 R3 = mat3(R[0],0, R[1],0, 0,0,1) * mat3(1,0,0, 0,R[0], 0,R[1]),\n         R3t = R3;\n\n    for (int i = 0; i < 1; i++, p*=2., R3t*=R3) \n        p *= R3, //p.xy *= R, p.yz *= R,\n        dn = dnoise3(p),\n        dn = R3t * dn, // dn.xy = R * dn.xy,dn.yz = R * dn.yz, \n        g += dn;\n\n    return .5*g/.75;\n}\n// -------------------------------------\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy, V,V0=vec2(1e9),_V,P;\n    U = ( U+U - R ) / R.y;\n    O -= O;\n    \n#if 0                                     // --- test grad(noise)\n    U *= 2.;\n    O += .5 + 1.*fbm3(vec3(U, 0));\n    vec3 g = .5*dfbm3(vec3(U, 0));\n    //g.xy = .5* vec2(dFdx(O.x),dFdy(O.y))/(4./R.y); // validation: compare to HW gradient\n    O.r = length(g.xy); \n    float v = sin(30.*O.g) ; \n    O = clamp(O,0.,1.) + smoothstep(1.5,0.,abs(v)/fwidth(v));\n    return;\n#endif   \n    \n    float a=1.,d, t = 3.*iTime, K=1.5, S=2.;\n    \n    mat2 I = mat2(1,0, 0,1);    \n#define  F(U) U + K* max(1.-length(U),0.)   \\\n                * vec2(  fbm3(vec3(S*U, t)),  fbm3(vec3(S*U+15., t)) )/S\n#define dF(U) I + K* max(1.-length(U),0.)   \\\n                * mat2( dfbm3(vec3(S*U, t)), dfbm3(vec3(S*U+15., t)) )\n         // NB: dF is approximate: assumes (1.-length(U)) is slow  \n\n    //U = F(U);\n    const int N=7;                        // NxN loop: in case of folds\n    for (int i=0; i<N*N; i++) {           //    solution is not unique \n        V = U + .1*vec2(i%N-N/2,i/N-N/2); //    -> try different starts around.\n        for (int k=0; k< 25; k++) {        // Newton solving of U = F(V) for V\n            // if(abs(determinant(dF(V)))<.01) return;  // local extrema !\n            // d = abs(determinant(dF(V))); a = d>.1 ? 1. : 1.*d; \n            // if (k>1) P = -.01*( F(V) - U )/ (F(V)-(F(_V))), V += P*(V-_V); else // secant\n            V -= .5*( F(V) - U ) * a* inverse( dF(V) );\n            _V = V;\n        }\n        if ( length(V-V0)>.01 && length(F(V)-U) < .1 ) { // if converged (and new)\n                P = sin(60.*V); P = smoothstep(1.5,0.,abs(P)/fwidth(P)); // draw grid\n                //O += P.x+P.y;           // * if you want points \n                if (abs(V.x)<.03) O.r +=P.x; else O += P.x; // draw red/green axes\n                if (abs(V.y)<.03) O.g +=P.y; else O += P.y;\n        };\n        V0 = V;\n    }    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}