{
    "Shader": {
        "info": {
            "date": "1705503462",
            "description": "sum of point charges. Coded while I was supposed to be calculating these in physics class because I was bored :P\n\nyou can move one of the charges with your mouse. \n\nWhich is positive and which is negative? Only the code knows :P",
            "flags": 0,
            "hasliked": 0,
            "id": "4ffXzf",
            "likes": 12,
            "name": "electric fields",
            "published": 3,
            "tags": [
                "tag"
            ],
            "usePreview": 0,
            "username": "01000001",
            "viewed": 192
        },
        "renderpass": [
            {
                "code": "#define saturation .1\n// .7 is nice\n\nconst float scale = 12.;\nconst float pi = 3.1415926;\n\nconst int n = 4;\nvec3 charges[n] = vec3[n](\n\n    vec3(5.5, 5.5, 8),\n    vec3(-5, -5, -8),\n    vec3(15, -5, 8),\n    vec3(-15.5, -5.5, -10)\n\n);\n\nvec2 field(vec2 p){\n\n    vec2 sum = vec2(0);\n    \n    for (int i = n; i-->0;){\n        sum += charges[i].z*normalize(p-charges[i].xy)/(length(p-charges[i].xy)*length(p-charges[i].xy));\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = (2.*U-r)/r.y * scale;\n    \n    vec2 cell = floor(uv);\n    vec2 cuv = (uv-cell) * 2. - 1.;\n\n    if (iMouse.z > 0.) charges[0].xy = (2.*iMouse.xy-r)/r.y * scale;\n    charges[0].z = sin(iTime)*8. + 10.;\n    charges[1].xy = vec2(sin(iTime*.5), cos(iTime*1.2))*5.5;\n    charges[2].xy = vec2(sin(iTime*1.3), cos(iTime*.8))*10.;\n\n    vec2 force = field(cell);\n    float x = smoothstep(.3, .0, \n        abs(dot(normalize(force), cuv*mat2(0,1,-1,0)))     // Create bar\n    )                                                      // Make it look nice\n        * length(force)                                    // brighter at higher force\n        * smoothstep(1., .9, length(cuv))                  // limit length of bars to 1 cell width\n    ;\n    \n    float t = atan(force.x/force.y) + (sign(force.y)>0.?-pi:0.);                            // Angle of bar\n\n    O = vec4(sqrt(x) \n        * mix(vec4(1), (cos(t + vec4(0., 2.*pi/3., 4.*pi/3., 0.))*.5+.5), vec4(saturation)) // Colour based on angle\n    );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}