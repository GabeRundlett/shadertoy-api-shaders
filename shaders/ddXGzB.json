{
    "Shader": {
        "info": {
            "date": "1666307912",
            "description": "A simple Raytracer which only renders Spheres.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ddXGzB",
            "likes": 4,
            "name": "Simple Sphere Raytracer",
            "published": 3,
            "tags": [
                "3d",
                "raytracing",
                "reflection"
            ],
            "usePreview": 0,
            "username": "Kgavaga",
            "viewed": 342
        },
        "renderpass": [
            {
                "code": "// ############### Options ################\nconst bool ANTIALIASING_ENABLED = true;\nconst int DEPTH = 3; // Number of times a ray will be reflected\nconst float START_FOV = 90.0;\nconst float VARIANCE_FOV = 20.0;\nconst float CAMERA_HEIGHT = 2.0;\nconst float RADIUS_OF_CAMERA_ORBIT = 5.0;\nconst float JUMP_HEIGHT = 2.0;\n\nfloat BIG_SPHERE_RADIUS = 1.0;\nfloat SMALL_SPHERE_RADIUS = 0.3;\nfloat MEDIUM_SMALL_SPHERE_RADIUS = 0.4;\nfloat MEDIUM_BIG_SPHERE_RADIUS = 0.7;\n// ######################################## \n\nconst int SPHERE_COUNT = 10; // Number of spheres to render\nconst float NO_COLLISION = -1.0;\n\nvec3 backgroundColor = vec3(0.2,0.2,0.2);\n\nstruct Camera{\n    vec3 position;\n    vec3 rotation;\n    float distanceFromProjectionPlane;\n};\n\nstruct Sphere{\n    vec3 position;\n    float radius;\n    vec3 color;\n    float ambientStrength;\n    float specularStrength;\n    float shininess;\n    float reflectiveness;\n};\n\nstruct Light{\n    vec3 position;\n    vec3 color;\n};\n\n// Calculates the distance from the projection plane (the plane that the camera's rays\n// will be traced through) to the center of the camera's view\nfloat calculateDistanceFromProjectionPlane(float windowRatio, float fov){\n    float tanResult = tan(radians(fov/2.0));\n    float distanceFromPlane = (windowRatio/(tanResult*2.0));\n    return abs(distanceFromPlane);\n}\n\n// Get the 3d rotation matrix for specific yaw, roll and pitch rotations\nmat3 getRotationMatrix(float xRotation, float yRotation, float zRotation){\n    mat3 xRotationMatrix = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(xRotation), -sin(xRotation),\n        0.0, sin(xRotation), cos(xRotation)\n    );\n    mat3 yRotationMatrix = mat3(\n        cos(yRotation), 0.0, sin(yRotation),\n        0.0, 1.0, 0.0,\n        -sin(yRotation), 0.0, cos(yRotation)\n    );\n    mat3 zRotationMatrix = mat3(\n        cos(zRotation), -sin(zRotation), 0.0,\n        sin(zRotation), cos(zRotation), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    return xRotationMatrix*yRotationMatrix*zRotationMatrix;\n}\n\n// Returns a ray going from the camera to the selected pixel\n// The function also accounts for the rotation of the camera\nvec3 getRay(vec2 fragCoord, float windowWidth, float windowHeight, Camera camera){\n    // Calculate the roation matrix based on the rotation off the camera\n    float xRotation = camera.rotation.x;\n    float yRotation = camera.rotation.y;\n    float zRotation = camera.rotation.z;\n    mat3 rotationMatrix = getRotationMatrix(xRotation, yRotation, zRotation);\n    \n    // Calculate the position of the current pixel on the projection plane\n    vec3 pixelPosition = vec3(\n        ((fragCoord.x/windowWidth)-0.5)*windowWidth/windowHeight,\n        (fragCoord.y/windowHeight)-0.5,\n        -camera.distanceFromProjectionPlane\n    );\n    \n    // Rotate the pixel position according to the roation of the camera\n    pixelPosition*=rotationMatrix;\n    return normalize(pixelPosition);\n}\n\n// Calculates the distance to the closest collison with the sphere\n// If there is no collision, the function returns -1.0\nfloat collideWith(Sphere sphere, vec3 rayOrigin, vec3 rayDirection){\n    // Solve the quadratic function\n    float b = 2.0 * dot(rayDirection, rayOrigin - sphere.position);\n    float c = pow(length(rayOrigin - sphere.position), 2.0) - pow(sphere.radius, 2.0);\n    float delta = pow(b, 2.0) - 4.0 * c;\n    if (delta > 0.0){\n        float t1 = (-b - sqrt(delta)) / 2.0;\n        if (t1 > 0.0){\n            // Return the smallest distance (the smallest solution of the quadratic function)\n            return t1;\n        }\n    }\n    return -1.0;\n}\n\n// Calculates the closest point where a ray collides with one of the spheres\n// \"oCollisionPoint\" : Closest collision point\n// \"oClosestSphereIndex\" : Array index of the closest sphere with which the ray collided\n// rayDirection has to be a unit vector\nbool collideWithClosest(Sphere[SPHERE_COUNT] spheres, vec3 rayOrigin, vec3 rayDirection, out int oClosestSphereIndex, out vec3 oCollisionPoint){\n    int closestSphereIndex;\n    float closestDistance = NO_COLLISION;\n    \n    // Iterate through all spheres and check if the sphere is hit by the ray\n    for (int i = 0; i < SPHERE_COUNT; i++){\n        float currentDistance = collideWith(spheres[i], rayOrigin, rayDirection);\n        if (currentDistance != NO_COLLISION && (currentDistance < closestDistance || closestDistance == -1.0)){\n            closestSphereIndex = i;\n            closestDistance = currentDistance;\n        }\n    }\n    \n    // Check if a collision with an object happened\n    if (closestDistance != NO_COLLISION){\n        oClosestSphereIndex = closestSphereIndex;\n        oCollisionPoint = rayOrigin + rayDirection*closestDistance;\n        return true;\n    }\n    return false;\n}\n\n// Checks to see if a collision point is in the shadow of an object\nbool isInShadow(Sphere[SPHERE_COUNT] spheres, vec3 collisionPoint, vec3 objectToLightVector, vec3 lightPosition){\n    int closestSphereIndex = 0;\n    vec3 nearestDistancePoint = vec3(0.0);\n    bool rayToLightCollided = collideWithClosest(spheres, collisionPoint, objectToLightVector, closestSphereIndex, nearestDistancePoint);\n    \n    if (rayToLightCollided){\n        float nearestDistance = length(nearestDistancePoint-collisionPoint);\n        float distanceToLight = length(lightPosition - collisionPoint);\n        if(nearestDistance < distanceToLight){\n            return true;\n        }\n    }\n    return false;\n}\n\n// Calculate diffuse strength\nfloat getDiffuseStrength(vec3 objectToLightVector, vec3 objectNormalVector){\n    return max(0.0,dot(objectToLightVector, objectNormalVector));\n}\n\n// Calculate specular\nfloat getSpecularStrength(vec3 objectToLightVector, vec3 objectNormalVector, vec3 objectToCameraVector, float shininess){\n    float dotProduct = dot(normalize(reflect(-objectToLightVector, objectNormalVector)), normalize(objectToCameraVector));\n    return pow(max(0.0,dotProduct), shininess);\n}\n\n// Calculates the color for a given point \"rayOrigin\" in the 3d space\nvec3 getColor(Sphere[SPHERE_COUNT] spheres, vec3 rayOrigin, vec3 rayDirection, Camera camera, Light light){\n    vec3 color = backgroundColor;\n    float reflectiveness, diffuseStrength, specularStrength = 0.0;\n    \n    // Send out and reflect the ray as many times as its set by \"DEPTH\"\n    for (int depth = 0; depth < DEPTH; depth++){\n        int hitSphereIndex = -1;\n        vec3 collisionPoint = vec3(0.0);\n        bool rayCollided = collideWithClosest(spheres, rayOrigin, rayDirection, hitSphereIndex, collisionPoint);\n\n        if (rayCollided){\n            diffuseStrength, specularStrength = 0.0;\n            \n            vec3 objectNormalVector = normalize(collisionPoint-spheres[hitSphereIndex].position);\n            vec3 objectToLightVector = normalize(light.position - collisionPoint);\n            \n            // Check to see if collisionPoint is in a cast of shadow\n            bool inShadow = isInShadow(spheres, collisionPoint, objectToLightVector, light.position);\n            if(!inShadow){\n                vec3 objectToCameraVector = normalize(camera.position - collisionPoint);\n                \n                // Calculate diffuse and specular strength since collisionPoint is not\n                // located in a cast of shadow\n                diffuseStrength = getDiffuseStrength(\n                    objectToLightVector,\n                    objectNormalVector\n                );\n                specularStrength = getSpecularStrength(\n                    objectToLightVector, \n                    objectNormalVector, \n                    objectToCameraVector, \n                    spheres[hitSphereIndex].shininess\n                );\n            }\n            \n            vec3 sphereColor = spheres[hitSphereIndex].color*light.color*(\n                spheres[hitSphereIndex].ambientStrength + diffuseStrength + spheres[hitSphereIndex].specularStrength*specularStrength\n            );\n            if (depth == 0){\n                color = sphereColor;\n                reflectiveness = spheres[hitSphereIndex].reflectiveness;\n            } else{\n                color += reflectiveness*sphereColor;\n                reflectiveness*= spheres[hitSphereIndex].reflectiveness;\n            }\n            rayOrigin = collisionPoint;\n            rayDirection = reflect(rayDirection, objectNormalVector);\n        }\n    }\n    \n    return color;\n}\n\n// Renders a given pixel with antialiasing\n// This is done by calculating the color of 9 points in close proximity and\n// taking the average color value of all of them.\nvec3 renderWithAntialiasing(vec2 fragCoord, float windowWidth, float windowHeight, Sphere[SPHERE_COUNT] spheres, Camera camera, Light light){\n    vec3 color = vec3(0.0);\n    for(float i = -1.0; i <= 1.0; i++) {\n        for(float j = -1.0; j <= 1.0; j++) {\n            vec3 rayDirection = getRay(\n                fragCoord+vec2(i*0.3, j*0.3),\n                windowWidth,\n                windowHeight,\n                camera\n            );\n    \t\tcolor += getColor(spheres, camera.position, rayDirection, camera, light);\n        }\n    }\n    color /= 9.0;\n    return color;\n}\n\n// Renders a given pixel without antialiasing\nvec3 render(vec2 fragCoord, float windowWidth, float windowHeight, Sphere[SPHERE_COUNT] spheres, Camera camera, Light light){\n    vec3 color = vec3(0.0);\n    vec3 rayDirection = getRay(\n        fragCoord,\n        windowWidth,\n        windowHeight,\n        camera\n    );\n    color = getColor(spheres, camera.position, rayDirection, camera, light);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float windowRatio = iResolution.x/iResolution.y;\n    \n    // Mouse input is able to affect the position of the camera\n    float mouseInput = iMouse.x/100.0;\n    // Fov changes overtime\n    float fov = START_FOV+sin(iTime-mouseInput)*VARIANCE_FOV;\n    float alpha = iTime-mouseInput;\n    // Move camera in circles and adjust the rotation of the camera\n    // to create an orbiting effect\n    Camera camera = Camera(\n        vec3(\n            sin(alpha)*RADIUS_OF_CAMERA_ORBIT,\n            CAMERA_HEIGHT + cos(iTime)*0.01,\n            cos(alpha)*RADIUS_OF_CAMERA_ORBIT\n        ),\n        vec3(\n            sin(alpha)*0.1,\n            alpha, \n            sin(alpha)*0.2\n        ),\n        calculateDistanceFromProjectionPlane(windowRatio, fov)\n    );\n    \n    float BOUNCINESS_SMALL = abs(JUMP_HEIGHT * sin(iTime));\n    float BOUNCINESS_BIG = abs(JUMP_HEIGHT * sin(iTime*1.0*3.0));\n    float BOUNCINESS_MEDIUM_SMALL = abs(JUMP_HEIGHT * sin(iTime*2.0));\n    float BOUNCINESS_MEDIUM_BIG = abs(JUMP_HEIGHT * sin(iTime*1.5));\n    \n    // Create all spheres in the scene\n    Sphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](\n        Sphere( // Bigger Sphere\n            vec3(-1.0, BOUNCINESS_BIG + BIG_SPHERE_RADIUS,0.0),// position\n            BIG_SPHERE_RADIUS,      // radius \n            vec3(0.1,0.3,0.7),      // Color\n            0.1,                    // Strength of the ambient lighting on the sphere\n            0.7,                    // Strength of the specular lighting on the sphere\n            128.0,                  // Exponent for the specular lighting on the sphere\n            0.3                     // Reflectiveness of the sphere\n        ),\n        Sphere( // Small Sphere\n            vec3(1.0,BOUNCINESS_SMALL + SMALL_SPHERE_RADIUS,0.0),\n            SMALL_SPHERE_RADIUS,\n            vec3(0.5,0.1,0.4),\n            0.1,\n            0.7,\n            32.0,\n            0.3\n        ),\n        Sphere( // medium small Sphere\n            vec3(-4.0,BOUNCINESS_MEDIUM_SMALL + MEDIUM_SMALL_SPHERE_RADIUS,2.0),\n            MEDIUM_SMALL_SPHERE_RADIUS,\n            vec3(0.2,0.8,0.2),\n            0.2,\n            0.7,\n            32.0,\n            0.3\n        ),\n        Sphere( // medium big Sphere\n            vec3(0.5,BOUNCINESS_MEDIUM_BIG + MEDIUM_BIG_SPHERE_RADIUS,4.3),\n            MEDIUM_BIG_SPHERE_RADIUS,\n            vec3(0.1,0.1,0.1),\n            0.5,\n            0.7,\n            32.0,\n            1.0\n        ),\n        Sphere( // Floor\n            vec3(0.0,-9000.0,0.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.1\n        ),\n        Sphere( // Ceiling\n            vec3(0.0,9005.0,0.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.1\n        ),\n        Sphere( // Left Wall \n            vec3(-9005.0,0.0,0.0),\n            9000.0,\n            vec3(1.0, 0.0, 0.0),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Right Wall\n            vec3(9005.0,0.0,0.0),\n            9000.0,\n            vec3(0.0, 0.0, 1.0),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Front Wall\n            vec3(0.0,0.0,-9005.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.3\n        ),\n        Sphere( // Back Wall\n            vec3(0.0,0.0,+9015.0),\n            9000.0,\n            vec3(0.9,0.9,0.9),\n            0.1,\n            0.8,\n            128.0,\n            0.5\n        )\n     );\n     \n     // Create the light in the scene\n     Light light = Light(\n         vec3(3.0,3.0,3.0),\n         vec3(1.0,1.0,1.0)\n     );\n\n    // Render the pixel according to the settings\n    vec3 colorOfPixel;\n    if(ANTIALIASING_ENABLED){\n        colorOfPixel = renderWithAntialiasing(fragCoord, iResolution.x, iResolution.y, spheres, camera, light);\n    } else {\n        colorOfPixel = render(fragCoord, iResolution.x, iResolution.y, spheres, camera, light);\n    }\n    \n    fragColor = vec4(colorOfPixel,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}