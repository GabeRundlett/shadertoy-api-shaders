{
    "Shader": {
        "info": {
            "date": "1488911305",
            "description": "//alias to use like if(a>0)return b;else return c; does  NonBranching step()\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//segment distance function,no dot(),no if()-branching:\nreturn ifb(-i.x+1. ,  ifb( i.x , i.y , length(i) ) ,  length(vec2(i.x-1.,i.y)  );",
            "flags": 0,
            "hasliked": 0,
            "id": "MdfcRj",
            "likes": 12,
            "name": "non-dot() non-branching segment",
            "published": 3,
            "tags": [
                "line",
                "rotation",
                "segment",
                "pipeline",
                "frame",
                "branching",
                "linesegment"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1047
        },
        "renderpass": [
            {
                "code": "//self= https://www.shadertoy.com/view/MdfcRj\n\n//this demoes a BRACHLESS signed distance function to a LineSegment\n//that does not use dot() or divide() or clamp(), only step() and abs()\n//and whatever both LineSegment functions use, see below within lSegS() or lSegs()\n//\n//With the difference of not giving segment endpoints,\n//and instead being a rotated scaled point to a static line segment from [0:0] to [1:0]\n//\n//This is possibly less for drawing splines or trees with target coordinates\n//and more for (inverse) kinematic chains were multiple rotations add up.\n//\n//This aims to pilepine the rendering of kiematic chains, for performance.\n\n//my different approach does NOT use dot(p,p)/dot(b,b) as in:\n//return distance of p to LineSegment from a to b:\nfloat segment(vec2 p,vec2 a,vec2 b){vec2 ab=b-a,ap=p-a;\n  return length(ap-ab*clamp(dot(ab,ap)/dot(ab,ab),0.,1.));}\n//return distance of p to endless line trough a and b:\nfloat line(vec2 P,vec2 A,vec2 B){vec2 g=B-A;return abs(dot(normalize(vec2(g.y,-g.x)),P-A));}\n\n//because...\n//when a 2d dot() is slower than a scalar mult() and 2 sub():\n//\n//- the approach below is faster than the above;\n//if you do not have the segment endpoints, but a translated/rotated segment.\n//...otherewise mine just uses an alias for non branching that may be reused elsewere.\n//\n//- it is a pipeline of 2 identical subroutines; ifb( ifb() )\n//...and not parallel processing dot()/dot() ,being divided.\n//and modern GPU keep getting better in pipelines than in parallel.\n//as more parallel processing has more diminishing returns than longer pipelines.\n//as this aims to pilepine the rendering of kiematic chains for performance.\n\n//this is how:\n\n//alias to make branching conditionals be calculated as non branching:\n#define ifb(a,b,c) (b+(c-b)*step(a,0.))\n//ifb(a,b,c) ::is idenfical to:: if(a<0.){return b;}else{return c;} ::but branchless:\n//because: //step(a,b);//if (a<b)return 0.; return 1.; (for each element of a vector)\n//branchless code -> longer pipelines on newer hardware -> likely better performance.\n//branchless code -> +1add +1mult, even slower on older hardware.\n//branchless code -> b & c are both calculated and substracted -> less precision\n//branchless code likely increses  performance when used within an often used sibroutine.\n//branchless code likely decreases performance when used within an higher function that uses subroutines (with branches).\n//::end of \"on making code branchless\"\n\n//distance to line segment that goes from [0:0] to [1:0]\n//point [i] gets scaled, rotated, mirrored outside of this function, not inside of it!\nfloat lSegS(in vec2 i){//thinking in subroutines segmenting problems to smaller ones.\n float L1=length(i               );//distance to left round cap\n float L2=length(vec2(i.x-1.,i.y));//distance right round cap \n //swap to L1 with L2 to see what parts change.\n\n //starting with 2 unpredictable if()-branches, the lazy solution.\n //if(i.x>1.)return L2;\n //if(i.x<0.)return L1;return abs(i.y);//abs(i.y) == distance to middle segment.\n //the second branch transforms to an eqivalent non-branching:\n //return ifb(i.x,abs(i.y),L1);\n \n//the first branch condition is transformed to a <0. comparator:\n//if ( i.x   >1.)return L2;//should be identical to\n//if (-i.x+1.<0.)return L1;//which translates to: ifb(-i.x+1.,L1, [else] )\n//...\n//[else]== return ifb(i.x,abs(i.y),L1);\n\n//both branches above (independently) merge to the non branching variants:\n//float Termfirst  = ifb(-i.x+1.,abs(i.y),L2);\n//float Termsecond = ifb( i.x   ,abs(i.y),L1);\n//here it does not matter what is interted into what (irellevant branch hierarchy/order)\n//but one abs(i.y) gets replaced with the other term:\n//return ifb(-i.x+1., abs(i.y)               ,L2);\n//return ifb(-i.x+1., Termsecond             ,L2);//Termsecond replaces abs(i.y) of TemFirst\n  return ifb(-i.x+1.,ifb( i.x   ,abs(i.y),L1),L2);\n}\n\n//short variant, (not) using one buffer [b].\nfloat lSegs(in vec2 i){\n  float b=i.x-1.;return ifb(-b     ,ifb(i.x,i.y,length(i)),length(vec2(b     ,i.y)));}\n  //             return ifb(-i.x+1.,ifb(i.x,i.y,length(i)),length(vec2(i.x-1.,i.y)));}//without [b]\n\n//return distance to line segment from [0:0] to [1:0]\nfloat lSeg(in vec2 i){\n//return lSegs(i);//short vec2 variant\n  return lSegS(i);//more human readable variant\n}//lSeg() used to do more stuff than degrading to just being a toggle.\n\n\n//Code for visualisation:\n\n#define res iResolution.xy\n//translate fragments to a frame; scale, center, aspectRatio.\nvec2 frame(vec2 a){a=(a-.5*res.xy)/res.y;\n a*=4.;//a=vec2(-a.y,a.x);//rotate 90 deg.\n return a;}//not for horizonral screens where res.x<res.y ??\n\n//seesaw functions for distance visualization:\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\nfloat SeeSaw(float x,float w,float a){return mod(x,w)*a;}\n//set [a]mplitude = 1/[w]avelength\nfloat SeeSaw2(float x,float w){return SeeSaw(x,w,1./w);}\n///return sin(t), shifted to range [0...1]\n//float sinP(float t){return(sin(t)+1.)*.5;}\n\n//2d rotation matrix:\n//#define rot(r) {float s=sin(r);float c=cos(r);mat2(c,-s,s,c);}\n\n//2d \"SINGLE rotation matrix\" that is acttually just mirroring on a half-rotated axis:\n#define r2s(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//its caveat is that applying it multiple times just mirrors the point back and forth.\n//testable in https://www.shadertoy.com/view/MtKGWD\n\nvoid mainImage(out vec4 r,in vec2 i){r.a=1.;\n vec2 p=frame(i);//aspect ratio and zoom of the view to focsus coordinate systems.\n //float dx=res.x/res.y;\n //vec2 mr=iMouse.xy/res.xy;//relative mouse position on the screen\n float s=sin(iTime);\n float t=sin(199.+s*.3)+.5;//swivel over time for 3 color dimensions displaying 3 SDF\n p.x+=s+.5;//move whole distance field (frame) left-right.\n p*=r2s(iTime);//single rotation over time.\n p.x+=.5;//make distance field rotate around segment center\n vec3 c=vec3(lSeg(p));\n //c*=2.;//c+=1.;//scaling the distance, scaling the colors you see to visualize distance.\n c.r=SeeSaw2(c.r,1.);\n c.g=SeeSaw2(c.g,sqrt(5.)*.5-.5);//golden ratio 0.61...\n c.b=SeeSaw2(c.b,asin(1.)*t);    //pi/2         1.57... swiveling over time.\n //log2(3.);//relevant for hexagonal tiling     1.85...\n \n if(abs(c.g)<.1)c*=vec3(.5);//dark border line\n r.rgb=c;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}