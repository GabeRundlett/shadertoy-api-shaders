{
    "Shader": {
        "info": {
            "date": "1676126090",
            "description": "A refractive two way mirrored polyhedron rendered in realtime.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtjSWh",
            "likes": 269,
            "name": "Refractive Polyhedron",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "dof",
                "bokeh",
                "glass",
                "metal",
                "icosahedron",
                "dodecahedron",
                "polyhedron"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 11473
        },
        "renderpass": [
            {
                "code": "/*\n\n\tRefractive Polyhedron\n\t---------------------\n    \n    See Buffer A.    \n\n*/\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(117.619, 57.623)))*43758.5453); } \n\n// Just a very basic depth of field routine -- I find a lot of it is\n// common sense. Basically, you store the scene distance from the camera \n// in the fourth channel, then use it to determine how blurry you want\n// your image to be at that particular distance.\n//\n// For instance, in this case, I want pixels that are 2.25 units away from \n// the camera to be in focus (not blurred) and for things to get more \n// blurry as you move away from that point -- aptly named the focal point \n// for non camera people. :)\n//\n// I based this on old code of mine, but adopted things that I found in \n// IQ and Nesvi7's examples, which you can find here:\n//\n// Ladybug - IQ\n// https://www.shadertoy.com/view/4tByz3\n//\n// Cube surface II - Nesvi7\n// https://www.shadertoy.com/view/Mty3DV\n//\nvec3 DpthFld(sampler2D iCh, vec2 uv){\n\t\n    // Focal point and circle of confusion.\n    const float focD = 1.25, coc = 1.65;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float dof = clamp(l/coc, 0., 2.); \n    \n    // Combine samples. Samples with a larger DOF value are taken further \n    // away from the original point, and as such appear blurrier.\n    vec3 acc = vec3(0);\n\n    for(int i = 0; i<25; i++){\n        // Accumulate samples.\n        acc += texture(iCh, uv + (vec2(i/5, i%5) - 2.)/vec2(800, 450)*dof).xyz;\n        //acc.x *= dof/2.;\n    }\n\n    // Return the new variably blurred value.\n    return acc /= 25.;\n    // Visual debug representation of DOF value.\n    //return vec3(length(dof)*450./2.5);\n}\n\n/*\n// Very basic bloom function.\nvec4 bloomBlur(sampler2D iCh, vec2 p){\n    \n    vec4 c = vec4(0);\n\n    const int n = 2;\n    for(int j = -n; j<=n; j++){\n        for(int i = -n; i<=n; i++){\n            c +=  texture(iCh, p + vec2(i, j)/iResolution.xy*2., 1.);\n        }\n    }\n    \n    return c/float((n*2 + 1)*(n*2 + 1));\n   \n}\n*/\n\n\n// This is not a great bokeh function example, but it'll do. It's an amalgamation\n// of old blur and DOF functions with a couple of borrowed lines from Dave Hoskins's \n// much nicer Fibonacci based \"Bokeh disc\" function, which you can find here:\n// https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec3 bokeh(sampler2D iCh, vec2 uv, float radius){\n\n\tvec3 tot = vec3(0), sum = vec3(0);\n\n     // Focal point and circle of confusion.\n    const float focD = 1.25, coc = 1.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float r = (dot(uv - .5, uv - .5))*8. + .125;//(clamp(l/coc, 0., 2.))*8.;//;\n\n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n \n            //r = mix(dof*dof*2. + .5, 0., step(0., shape(vec2(i, j)) - float(n)));\n            \n            // If we're not inside the circle, continue.\n            //if(length(vec2(i, j))>float(n)) continue; \n           \n            \n            //vec2 offs = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)) + .5;\n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            //vec2 rnd = texture(iChannel1, uv + vec2(i, j)/iResolution.xy).xy - .5; \n            //vec3 c = texture(iCh, uv + (vec2(i, j))/vec2(800, 450)*r, r*.7).xyz; \n            vec3 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7).xyz; \n            vec3 bokeh = pow(c, vec3(6));\n            tot += c*sqrt(c)*bokeh*2.;\n            sum += bokeh;\n        }\n    }\n    \n\treturn tot/sum;\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Coordinates.\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // Just the unprocessed texture on it's own.\n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Cheap 25 tap depth of field function.\n    //vec3 col = DpthFld(iChannel0, uv);\n    \n    \n    // Worst bokeh algorithm ever -- Definitely needs work. :)\n    vec3 bokCol = bokeh(iChannel0, uv, 1.).xyz;\n    col = mix(col, bokCol, .75);\n     \n    \n    // Bloom. Too much here.\n    //vec3 bloom = bloomBlur(iChannel0, uv).xyz;\n    //vec3 bloomLight = vec3(1, .9, .7);\n    //col += pow(bloom, 2./bloomLight)*2.;\n    \n         \n    fragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n\tRefractive Polyhedron\n\t---------------------\n\n    Creating an antialiased, glass and metal, refractive polyhedron in realtime. \n    Rendering a two way mirrored polyhedron is a fairly common graphics exercise, \n    and there are a few examples on Shadertoy already. I put a version of this \n    together directly after looking at Quinchilion's really nice \"Interstellar \n    Icosahedron\" shader. I think it may have been the first one posted on here \n    and is still one of my favorites -- There's a link below for anyone who \n    hasn't seen it.\n    \n    I started with an icosahedron, but changed it to a dodecahedron after looking \n    at Xjorma's recent \"Infinite Dodecahedron\" example. I dropped some more \n    intricate truncated polyhedra into the scene, but I felt the reflections \n    looked too busy, so decided to keep things simple. There's a \"define\" option\n    to render an icosahedron also, for anyone interested.\n    \n    Anyway, since I had absolutely nothing new to add to the reflective polyhedron\n    genre, I thought I'd spend some time prettying it up with some post processing\n    algorithms. I was going to add some glowing tubes, but ran out of steam. I\n    might try that out in cube form at a later date.    \n  \n\n    \n    Useful examples:\n\n\t// Beautiful example. I love the conciseness of the reflective pattern.\n    Interstellar icosahedron - Quinchilion \n\thttps://www.shadertoy.com/view/tlX3WH\n    \n    // Multiple light reflections off the inner faces of a polyhedron.\n    // Rendered with a Belgian theme. :)\n    This Is Not A Reflected Pipe 2 - Dr2 \n    https://www.shadertoy.com/view/Nsd3RN\n    \n    // Multiple reflections on a truncated dodecahedron. I like the\n    // approach Xjorma took, but I had to use a different one.\n    Infinite Dodecahedron - xjorma\n    https://www.shadertoy.com/view/DlfXWS\n \n*/\n\n\n// Pentagon or icosahedron.\n#define PENTAGON\n\n//#define INSIDE_VIEW\n\n// Ray passes: For this example, this is about the minimum I could\n// get away with. However, not all passes are used on each pixel, so\n// it's not as bad as it looks.\n#define PASSES 6\n\n// Far plane, or max ray distance.\n#define FAR 20.\n\n// Minimum surface distance. Used in various calculations.\n#define DELTA .001\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(23.527, 57.683)))*43758.5453); }\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  //return length(max(abs(p) - b + sf, 0.)) - sf;\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(max(p.x, p.y), p.z), 0.) - sf;\n}\n*/\n\n\n///////////\n// The following have come from DjinnKahn's \"Icosahedron Weave\" example, here:\n// https://www.shadertoy.com/view/Xty3Dy\n//\n// Vertices: vec3(0, A, B), vec3(B, 0, A), vec3(-B, 0, A).\n// Face center: (vec3(0, A, B) + vec3(0, 0, A)*2.)/3..\n// Edges: (vec3(0, A, B) + vec3(B, 0, A))/2.,  etc.\n\nconst float PHI = (1. + sqrt(5.))/2.; // 1.618\nconst float A = PHI/sqrt(1. + PHI*PHI); // .85064\nconst float B = 1./sqrt( 1. + PHI*PHI); // .5257\nconst float J = (PHI - 1.)/2.; // .309016994375\nconst float K = PHI/2.; // J + .5\nconst mat3 R0 = mat3(.5,  -K,   J,  K,  J, -.5,  J , .5,  K);\nconst mat3 R1 = mat3( K,   J, -.5,  J, .5,   K, .5 , -K,  J);\nconst mat3 R2 = mat3(-J, -.5,   K, .5, -K,  -J,  K ,  J, .5);\n\n// I wanted all vertices hardcoded. Everything's been projected to the\n// surface of a sphere.\n#ifdef PENTAGON\nconst float size = .5/.85;\n#else\nconst float size = .5;\n#endif\n\nconst vec3 v0 = (vec3(0, A, B))*size; // Already normalized.\nconst vec3 v1 = (vec3(B, 0, A))*size;\nconst vec3 v2 = (vec3(-B, 0, A))*size;\nconst vec3 e0 = (mix(v0, v1, .5));\nconst vec3 e1 = (mix(v1, v2, .5));\nconst vec3 e2 = (mix(v2, v0, .5));\n//const vec3 mid = normalize(vec3(0, A, B + A*2.))/3.; // (v0 + v1 + v2)/3.*size.\nconst vec3 ctr = (v0 + v1 + v2)/3.;//mix(e0, v2, .5);//\nconst mat3 R3 = mat3(-.5, sqrt(.75), 0, K, .467086179481, .356822089773,-J, -.178411044887, .934172358963);\n// A handy matrix that rotates icosahedral vertices into the dual dodecahedron postions. \nconst mat3 R4 = mat3(.587785252292, -K, 0, \n                     -.425325404176, -J, .850650808352, \n                     .688190960236, .5, .525731112119);\nconst vec3 O3 = vec3(B,B/sqrt(3.), sqrt(1. - 4./3.*B*B));                     \nconst vec3 O4 = vec3(A/3./tan(3.14159/5.), A/3., .63147573033330584);\n\n\n\n// The original function -- sans polarity information -- is neat and concise.\nvec3 opIcosahedron(vec3 p){ \n  \n    p = R0*abs(p);\n    p = R1*abs(p);\n    p = R2*abs(p); \n    return abs(p);  \n} \n\n/*\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length(pa);\n}\n*/\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    //p.x = abs(p.x - .015);\n    \n   \n    #ifdef PENTAGON\n    const float n = 12.; //12.\n    float zr = abs(mod(p.z - l*lf, 1./n) - .5/n);\n    float riv = length(vec2(p.y, zr)) - .008;\n    #else\n    const float n = 12.; //12.\n    float zr = abs(mod(p.z - l*lf - .5/n, 1./n) - .5/n);\n    float riv = length(vec2(p.x, zr)) - .008;\n    #endif\n    \n \n    p = abs(p);\n   \n    \n    //float ln = max(length(p.xy) - r, p.z - l*lf);\n    //float ln = max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //float ln = max(max(p.x, p.y) - r, p.z - l*lf);\n    float ln = max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    //float ln = max(max(p.y*.866025 + p.x*.5, p.x) - r, p.z - l*lf);\n    //float ln = max(max(p.x*.866025 + p.y*.5, p.y) - r, p.z - l*lf);\n    \n    return max(ln, -riv);\n    //return min(ln, max(riv, p.y - r - .01));\n}\n\n\n////////////////\n\n// Vector container for the object IDs. We make a note of the individual\n// identifying number inside the main distance function, then sort them\n// outside of it, which tends to be faster.\nvec4 vObjID; \n\n// Object rotation.\nvec3 objRot(vec3 p){\n\n    // Mouse movement.\n    if(iMouse.z>1.){\n        p.yz *= rot2(-(iMouse.y - iResolution.y*.5)/iResolution.y*3.1459);  \n        p.xz *= rot2(-(iMouse.x - iResolution.x*.5)/iResolution.x*3.1459);  \n    } \n\n    //float it = floor(iTime/8.);\n    //float t = abs(fract(iTime/16.) - .5)*2.;\n    //float mv = smoothstep(.35, .65, t)*3.14159;\n    //if(mod(it, 2.)<.5) mv = -mv;\n    p.xy = rot2(3.14159/10.)*p.xy;\n    p.xz = rot2(iTime/8.)*p.xz;  //iTime/4. \n    return p;\n\n}\n\n\n \n// The scene. All of it is pretty standard. To be honest, this was a \n// little rushed, but the field doesn't have a lot going on, so tightening \n// it up wasn't as important as it sometimes is.\nfloat map(vec3 p){\n    \n    // Back wall\n    float wall = -p.z + 1.; // Thick wall: abs(p.z - .2) - .21;\n    // Peturb that back wal to bounce the light off a little more.\n    wall -= dot(sin(p*3. - cos(p.yzx*6. + vec3(iTime/4., .5, iTime/2.))), vec3(.025));  \n    \n\n    // 3D object position.\n    vec3 bq = objRot(p);\n  \n    // Local object cell coordinates.\n    vec3 objP = opIcosahedron(bq);\n    \n    \n    // Render a pentagon or and icosahedron. Thanks to DjinnKahn's original\n    // setup, there is very little calculation necessary at this point.\n    // For a multiple bounce scenario, this is a good thing. :)\n    \n    #ifdef PENTAGON\n    \n    // Lines -- Rendered from an icosahedron perspective, so from the\n    // face centers to the mid-edge points.\n    float line = sdCapsule(objP, (ctr), e0*PHI*PHI/3., .02, .55); \n    // The solid pentagon, which will be turned into a thin outer shell\n    // for the glass. I.e. obj = abs(obj) - w.\n    vec3 pentP = R4*objP - O4*size;\n    float face = length(vec3(max(pentP.x, 0.), max(pentP.y, 0.), pentP.z));\n    \n    #else\n    \n    // Lines.\n    float line = sdCapsule(objP, v0, v1, .02, .55); \n    // The solid icosahedron, which will be turned into a thin outer shell\n    // for the glass. I.e. obj = abs(obj) - w.\n    vec3 icosP = R3*objP - O3*size;\n    float face = length(vec3(max(icosP.x, 0.), max(icosP.y, 0.), icosP.z));\n    line = smax(line, length(p) - size - .02, .01); // Round off the points.\n    \n    #endif\n    \n    \n    // Debug: Take out the metal tubing.\n    //line = 1e5;\n    \n    // Turning the solid object into a thin outer shell.\n    float glass = max(abs(face) - .002, -line);\n     \n    // The lines will be made of metal.\n    float mtl = line; \n   \n   \n    \n    // Storing the object ID.\n    vObjID = vec4(wall, glass, mtl, 1e5);\n    \n    // Returning the closest object.\n    return min(min(wall, glass), mtl);\n \n}\n\n\n \nfloat trace(vec3 ro, vec3 rd, float distanceFactor){\n\n    float tmin = 0.;\n    float tmax = FAR;\n    \n    // IQ's bounding plane addition, to help give some extra performance.\n    //\n    // If ray starts above bounding plane, skip all the empty space.\n    // If ray starts below bounding plane, never march beyond it.\n    const float boundZ = -.6;\n    float h = (boundZ - ro.z)/rd.z;\n    if(h>0.){\n    \n        if( ro.z<boundZ ) tmin = max(tmin, h);\n        else tmax = min(h, FAR);\n    }\n \n    float t = tmin;\n    for(int i = 0; i<72; i++){\n    \n        float d = map(ro + rd*t)*distanceFactor;\n        if( abs(d)<DELTA ) return t;\n        if( t>tmax) break; \n        t += d*.9; \n    }\n\n    return FAR;\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow \n    // test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015; // Bumping the shadow off the hit point.\n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n    \n    //rd = normalize(rd + (hash33R(ro + n) - .5)*.03);\n    \n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        //if (d<0. || t>end) break; \n        // Bounding plane optimization, specific to this example. Thanks to IQ. \n        if (d<0. || t>end || (ro.z + rd.z*t)<-.6) break;\n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        \n        // Deliberately redundant line that may or may not stop the \n        // compiler from unrolling.\n        //if(sca>1e5) break;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n/* \n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to\n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Random hash setup.\nvec2 seed = vec2(.13, .27);\n\nvec2 hash22() {\n    \n    seed += vec2(.723, 643);\n    seed = fract(seed);\n    return fract(sin(vec2(dot(seed.xy, vec2(12.989, 78.233)), dot(seed.xy, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\n\n    float resT = 1e8;\n \n    float iRes = iResolution.y;\n\n    \n    // Screen coordinates.\n    seed += fract(iTime)*113.87;\n\t//vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 uv = (fragCoord - iResolution.xy*.5 + (hash22() - .5)/4.)/iRes;\n\t\n\n    // \"Look At\" position.\n    vec3 lk = vec3(0); \n    \n    // Ray origin.\n    #ifdef INSIDE_VIEW\n    vec3 ro = lk + vec3(cos(iTime/4.)*.05, .1, .1);\n    #else\n    vec3 ro = lk + vec3(cos(iTime/4.)*.1, 0, -1.25);\n    #endif\n  \n    // Light positioning.\n \tvec3 lp = lk + vec3(-.25, .75, -.6); \n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n    \n    mat3 mCam = mat3(rgt, up, fwd);\n\n    // Unit direction ray.\n    //vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    vec3 rd = mCam*normalize(vec3(uv, 1./FOV));\n    \n    \n    // Camera position. Initially set to the ray origin.\n    vec3 cam = ro;\n    // Surface postion. Also initially set to the ray origin.\n    vec3 sp = ro; \n    \n    // Global shadow variable and a reflection power variable. The reflection\n    // power also applies to refracted objects.\n    float gSh = 1.;\n    float objRef = 1.;\n     \n    vec3 col = vec3(0);\n   \n    // The refraction ratio for the glass. Normally, you'd have\n    // different ones for different objects, but we only need one for this example.\n    float refractionRatio = 1./1.5;\n    float distanceFactor = 1.;\n     \n    float alpha = 1.;\n    \n    // Intersection and coloring for each ray and subsequent bounces.\n    for(int j = 0; j<PASSES; j++){\n        \n        // Layer or pass color. Each pass color gets blended in with\n        // the overall result.\n        vec3 colL = vec3(0);\n\n        \n        // Raymarch to the scene.\n        float t = trace(sp, rd, distanceFactor);\n\n        // Objtain the ID of the closest object: With more objects, you'd use a looping\n        // mechanism, but I'd imagine this hideous expression is a little faster.\n        float svObjID = (vObjID.x<vObjID.y && vObjID.x<vObjID.z && vObjID.x<vObjID.w)? 0. : \n                        vObjID.y<vObjID.z && vObjID.y<vObjID.w? 1. : vObjID.z<vObjID.w? 2. :  3.;\n\n        // Advance the ray to the surface. This becomes the new ray origin for the\n        // next pass.\n        sp += rd*t;\n        \n        \n        // If the ray hits a surface, light it up. By the way, it's customary to put \n        // all of the following inside a single function, but I'm keeping things simple.\n        // Blocks within loops used to kill GPU performance, but it doesn't seem to\n        // effect the new generation systems.\n      \n        if(t<FAR){\n         \n         \n            if(j==0){\n                resT = t;\n            }\n\n            \n            // Surface normal. Refractions, and therefore ray traversal inside\n            // of object surfaces are now possible, to the direction of the\n            // normal matters... This is yet one of many things that I forget\n            // when I haven't done this for a while. :)\n            vec3 sn = getNormal(sp)*distanceFactor; // For refractions.\n            \n            \n            // Texture size factor.\n            float sz0 = 2.;\n            /*\n            // Integrating bump mapping -- Not used here. It's possible\n            // to bump map on a pass by pass basis to save cycles.\n            vec3 smSn = sn;\n            sn = texBump(iChannel1, sp*sz0, sn, .007);///(1. + t/FAR)\n            //vec3 reflection = reflect(rd, normalize(mix(smSn, sn, .35)));\n            */\n            \n            \n            vec3 reflection = reflect(rd, sn);\n            vec3 refraction = refract(rd, sn, refractionRatio);\n       \n            \n            vec3 ld = lp - sp; // Point light direction.\n            float lDist = length(ld); // Surface to light distance.\n            ld /= max(lDist, .0001); // Normalizing.\n            \n            \n            // Shadows and ambient self shadowing.\n            //\n            // Shadows are expensive. It'd be nice to include shadows on each bounce,\n            // but it's still not really viable, so we just perform them on the \n            // first pass... Years from now, I'm hoping it won't be an issue.\n            float sh = 1.;\n            #if 0\n            // Shadows on each bounce.\n            sh = softShadow(sp, lp, sn, 12.);\n            gSh = min(sh + .5, 1.); // Adding brightness to the shadow.\n            #else\n            // Shadows on just two bounces.\n            if(j < 2){ \n                sh = softShadow(sp, lp, sn, 12.);\n                gSh = min(gSh, min(sh + .53, 1.)); \n            }\n            #endif\n            \n            float ao = calcAO(sp, sn); // Ambient occlusion.\n            \n\n            float att = 1./(1. + lDist*lDist*.025); // Attenuation.\n\n            float dif = max(dot(ld, sn), 0.); // Diffuse lighting.\n            float spe = pow(max(dot(reflection, ld), 0.), 16.);\n            float speR = pow(max(dot(normalize(ld - rd), sn), 0.), 16.);\n            //float fre = clamp(1. - abs(dot(rd, sn))*.7, 0., 1.); // Fresnel reflection term.\n            \n            // Fresnel.\n            float Schlick = pow(1. - clamp(dot(rd, normalize(rd + ld)), 0., 1.), 5.);\n            float freS = mix(.25, 1., Schlick);  //F0 = .2 - Glass... or close enough.\n            \n            \n            // Object color.\n            vec3 oCol;\n            \n            vec3 txP = objRot(sp);\n            vec3 txN = objRot(sn);\n            \n             \n            if(svObjID == 0.){ // Back wall.\n               \n                // Texturing. \n                //vec3 tx = tex3D(iChannel2, sp/2., sn);\n                vec3 tx = texture(iChannel2, sp.xy/3. + vec2(1, .5)*iTime/72.).xyz; tx *= tx;\n\n                // Background. \n                // It's roughly incorporattes Edwardbraed's simple background here:\n                // https://www.shadertoy.com/view/NslXz4\n                uv.y = abs(uv.y + .125) - .5;\n                float grad = pow(1.0 - length(uv*vec2(iResolution.y/iResolution.x, 1)), 4.);\n                oCol = mix(vec3(.7, .5, 1), vec3(.5, .7, 1), uv.y + .5); \n                oCol *= grad*.95 + .05;\n                oCol *= tx*2.;\n               \n                 \n                // The wall has no reflection of refraction, so setting the\n                // reflective or transmission power to zero will cause the\n                // loop to terminate early, which saves a lot of work.\n                objRef = 0.;\n\n                spe *= freS;\n\n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n            }\n            else if(svObjID == 1.) {  // Glass box.\n            \n                \n\n                // Coloring the glass tubes. Note that we keep the object\n                // color dark, in order to look transparent.\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                \n                // Color.\n                oCol = mix(vec3(.7, .5, 1), vec3(.5, .7, 1), uv.y + .5); \n                oCol *= tx*.1;\n\n               \n                // Faking more reflectivity in the glass.\n                objRef = 1.125; \n                spe = pow(spe, 4.);\n                \n                #ifdef INSIDE_VIEW\n                oCol *= vec3(.8, .6, 1); // Adding a bit more glass color for the inside view.\n                refraction *= 0.; // Turn off refraction inside the object.\n                #else\n                // Reflection only override.\n                if((j>0 && distanceFactor>0.)){ \n                    refraction *= 0.;\n                }\n                #endif\n                \n            }\n            else { // Metallic stuff.            \n            \n               \n                // Joins, tracks and animated metal objects.\n                vec3 tx = tex3D(iChannel1, txP, txN);\n                tx = smoothstep(.0, .5, tx);\n                if(svObjID==3.) oCol = tx*vec3(1, .7, .5);\n                else oCol = tx*vec3(.5)*vec3(1, .95, .9);\n                \n               \n                objRef = .25; // Only a bit of reflectance.\n                \n                // Ramping up the diffuse on the metal joins.\n                dif = pow(dif, 4.)*2.; \n                \n                // Reflection only override. This ensures that no refraction\n                // will occur... It's hacky, but it works. :)\n                refraction *= 0.; \n                \n            }\n            \n            \n            // Cheap specular reflections.\n            vec3 rTx = texture(iChannel3, reflection).xyz; rTx *= rTx;\n            if(svObjID == 0.) rTx *= .25;\n            oCol += (oCol*.75 + .25)*speR*rTx*3.;//*vec3(.85, .7, 1); //*speR\n            \n            // Simple coloring for this particular ray pass.\n            colL = oCol*(dif + .2 + vec3(1, .7, .4)*spe*6.);\n            \n            // Shading.\n            colL *= gSh*ao*att;\n            \n            // Used for refraction (Beer's Law, kind of), but not used here.\n            //if(distanceFactor<0.)  colL *= exp(-colL*t*5.);\n            \n            \n            // Set the unit direction ray to the new reflected or refracted direction, and \n            // bump the ray off of the hit point by a fraction of the normal distance. \n            // Anyone who's been doing this for a while knows that you need to do this to \n            // stop self intersection with the current launch surface from occurring... It \n            // used to bring me unstuck all the time. I'd spend hours trying to figure out \n            // why my reflections weren't working. :)\n \n            // You see this in most refraction\\reflection examples. If refraction is possible\n            // refract, reverse the distance factor (inside to outside and vice versa) and \n            // bump the ray off the surface. If you can't refract (internal reflection, a \n            // non-refractive surface, etc), then reflect in the usual manner. If the surface\n            // neither reflects nor refracts, the object reflectance factor will cause the\n            // loop to terminate... I could check for that here, but I want to keep the \n            // decision making simple.\n            //\n            if (dot (refraction, refraction)<DELTA){\n                rd = reflection;\n                // The ray is just behind the surface, so it has to be bumped back to avoid collisions.\n                sp += sn*DELTA*2.; \n            }   \n            else {\n\n                rd = refraction;\n                distanceFactor = -distanceFactor;\n                refractionRatio = 1./refractionRatio;\n                sp -= sn*DELTA*2.;//1.1;\n            } \n            \n \n        }\n\n        // Fog: Redundant here, since the ray doesn't go far, but necessary for other setups.\n        float td = length(sp - cam); \n        vec3 fogCol = vec3(0);\n        colL = mix(colL, fogCol, smoothstep(0., .95, td/FAR));\n      \n        // This is a more subtle way to blend layers. \n        //col = mix(col, colL, 1./float(1 + j)*alpha);\n        // Additive blend. Makes more sense for this example.\n        col += colL*alpha;///float(PASSES);\n        \n        // If the hit object's reflective factor is zero, or the ray has reached\n        // the far horizon, break. Breaking saves cycles, so it's important to \n        // terminate the loop early when you can.\n        if(objRef < .001 || t >= FAR) break;\n        \n        // Object based breaking. Also possible, but I prefer the above.\n        //if(svObjID == 0.)break; \n        \n        // Decrease the alpha factor (ray power of sorts) by the hit object's reflective factor.\n        alpha *= objRef;\n        \n    }\n    \n    \n    #ifdef INSIDE_VIEW\n    // Vignette.\n    // Using IQ's box formula to produce a more configurable border overlay.\n    // Equivalent to: float bord = sBox(uv, vec2(iResolution.x/iResolution.y, 1)/2.);\n    vec2 d = abs(uv) - vec2(iResolution.x/iResolution.y, 1)/2. + .15;\n    float bord = min(max(d.x, d.y), 0.) + length(max(d, 0.)) - .3;\n    col = mix(col, vec3(0), (1. - smoothstep(0., .05, abs(bord) - .15))*.7);\n    #endif\n    \n    \n    \n\n    \n    fragColor.w = resT;\n     \n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./4.; \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No reprojection or temporal blur, for comparisson.\n    //fragColor = vec4(max(col, 0.), 1);\n    \n    \n   \n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}