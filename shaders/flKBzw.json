{
    "Shader": {
        "info": {
            "date": "1664260693",
            "description": "This is a shader of cubes/spheres, all in boolean.",
            "flags": 0,
            "hasliked": 0,
            "id": "flKBzw",
            "likes": 0,
            "name": "Boolean shapes, hazed",
            "published": 3,
            "tags": [
                "cubes",
                "boolean"
            ],
            "usePreview": 0,
            "username": "Visiware",
            "viewed": 212
        },
        "renderpass": [
            {
                "code": "// License: MIT\n// This shader is ported here for a video: https://www.youtube.com/watch?v=PBI_yvz25aI\n// At first it was written at my local PC as GLSL another version, there may be roughness\n\n#define M_PI 3.1415926535897932384626433832795\n#define M_PI2 (M_PI*2.0)\n\n#define FOV 1.309\n\n#define SMALLADD 0.004\n\nfloat intersectSDF(float distA,float distB) {\n\treturn max(distA,distB);\n}\n\nfloat unionSDF(float distA,float distB) {\n\treturn min(distA,distB);\n}\n\nfloat differenceSDF(float distA,float distB) {\n\treturn max(distA,-distB);\n}\n\n\n\nmat4 TransMatrix(float x,float y,float z) {\n\tmat4 m = mat4(1);\n\t\n\tm[3][0] = x;\n\tm[3][1] = y;\n\tm[3][2] = z;\n\t\n\treturn m;\n}\n\nmat4 RotMatrixY(float angle) {\n\tmat4 m = mat4(1);\n\t\n\tm[0][0] = cos(angle);\n\tm[0][2] = -sin(angle);\n\tm[2][0] = sin(angle);\n\tm[2][2] = cos(angle);\n\t\n\treturn m;\n}\n\n\n\nfloat SphereSDF(vec3 o,vec3 pos,float r) {\n\treturn length(o - pos) - r*r;\n}\n\nfloat CubeSDF(vec3 o,vec3 pos,float size) {\n\tvec3 d = abs(o - pos) - vec3(size,size,size);\n\t\n\tfloat distin = min(max(d.x, max(d.y, d.z)), 0.0);\n\tfloat distout = length(max(d, 0.0));\n\t\n\treturn distin + distout;\n}\n\n\n\nfloat OneObjSDF(vec3 ori,vec3 pos) {\n\treturn differenceSDF(unionSDF(CubeSDF(ori,pos + vec3(0,0,0),1.0),SphereSDF(ori,pos + vec3(0,0,0),1.15)),SphereSDF(ori,pos + vec3(-0.8 - 0.4*sin(float(iFrame%45)/45.0*M_PI2),1.0*sin(float(iFrame%300)/300.0*M_PI2),1.0*sin(float(iFrame%500)/500.0*M_PI2)),0.8));\n}\n\n\nfloat SceneSDF(vec3 ori) {\n\tfloat angle = float(iFrame%100)/100.0*M_PI2;\n\t\n\treturn unionSDF(unionSDF(unionSDF(unionSDF(OneObjSDF(ori,vec3(2.0*cos(angle),2.0*cos(angle + 0.65) + cos(float(iFrame%20)/20.0*M_PI2),30.0*cos(angle + 1.23))),\n\t                                           OneObjSDF(ori,vec3(-5.0*cos(angle + 0.3),23.0*cos(angle + 0.3),23.0*cos(angle + 1.3)))),\n\t                                           OneObjSDF(ori,vec3(-12.3*cos(angle + 1.6),-4.0*cos(angle + 1.12),12.0*cos(angle + 0.54)))),\n\t                                           OneObjSDF(ori,vec3(0,0,0))),\n\t                                           OneObjSDF(ori,vec3(30.0*cos(angle),30.0*sin(angle),30.0*tan(angle))));\n}\n\n#define NORM_EPSILON 0.0001\n\nvec3 SceneNormal(vec3 ori) {\n\treturn normalize(vec3(SceneSDF(vec3(ori.x + NORM_EPSILON,ori.y,ori.z)) - SceneSDF(vec3(ori.x - NORM_EPSILON,ori.y,ori.z)),\n\t                      SceneSDF(vec3(ori.x,ori.y + NORM_EPSILON,ori.z)) - SceneSDF(vec3(ori.x,ori.y - NORM_EPSILON,ori.z)),\n\t                      SceneSDF(vec3(ori.x,ori.y,ori.z + NORM_EPSILON)) - SceneSDF(vec3(ori.x,ori.y,ori.z - NORM_EPSILON))));\n}\n\n#define ITERMAX 200\n\n#define DISTMAX 1000.0\n\n#define EPSILON 0.005\n\nstruct CastRet_t {\n    bool casted;\n    vec3 normal;\n    float minlen;\n};\n\nCastRet_t TraceObjects(vec3 pos,vec3 dir) {\n\tCastRet_t maincast;\n\t\n\tmaincast.normal = vec3(0.0,0.0,0.0);\n\tmaincast.casted = false;\n\tmaincast.minlen = 1000000.0;\n\t\n\t\n\t\n\tvec3 ori = pos;\n\t\n\tfor (int i = 0; i < ITERMAX; i++) {\n\t\tfloat d = SceneSDF(ori);\n\t\t\n\t\tmaincast.minlen = min(maincast.minlen,d);\n\t\t\n\t\tif (d < EPSILON) {\n\t\t\tvec3 epspos = ori - dir*EPSILON;\n\t\t\t\n\t\t\tmaincast.casted = true;\n\t\t\tmaincast.normal = SceneNormal(epspos);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (d > DISTMAX) {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tori += dir*d;\n\t}\n    \n    return maincast;\n}\n\n#define MINCOLOR 0.04\n\nvec3 RaytraceObjects(vec3 pos,vec3 dir) {\n\tvec3 color = vec3(0.0,0.0,0.0);\n    \n    \n    \n    CastRet_t maincast = TraceObjects(pos,dir);\n\t\n\t\n\tif (maincast.casted) {\n\t\tcolor = (maincast.normal + vec3(1.0,1.0,1.0))/2.0;\n\t}\n\telse if (maincast.minlen < 2.0) {\n\t\tfloat c = 1.0*(1.0 - maincast.minlen/2.0);\n\t\tcolor = vec3(c*0.8,c,c);\n\t}\n\t\n\t\n\treturn color;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float x = fragCoord.x;\n\tfloat y = fragCoord.y;\n\t\n    float f0 = -0.2*iMouse.y/iResolution.y + sin(iTime/3.2)/5.0;\n    float f1 = (iMouse.x/iResolution.x + sin(iTime))*20.0;\n    \n    mat4 camera = TransMatrix(-5.0,1.0,12.0)*RotMatrixY(-0.35 + f0)*TransMatrix(0.0,0.0,-2.0 + f1);\n    \n    mat4 camera_notrans = camera;\n    camera_notrans[3][0] = 0.0;\n    camera_notrans[3][1] = 0.0;\n    camera_notrans[3][2] = 0.0;\n    \n\tvec3 pos = (camera*vec4(0.0,0.0,0.0,1.0)).xyz;\n\tvec3 dir = (camera_notrans*normalize(vec4((x - iResolution.x/2.0)/iResolution.x*tan(FOV/2.0)*iResolution.x/iResolution.y,(y - iResolution.y/2.0)/iResolution.y*tan(FOV/2.0),-1.0,1.0))).xyz;\n\t\n\tfragColor = vec4(RaytraceObjects(pos,dir),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}