{
    "Shader": {
        "info": {
            "date": "1540201308",
            "description": "drag mouse\n\nnote how light sources cast a shadow from another light source, tinted by whatever light reaches into the shadow.\nlacks reflections (just add portal-logic and brdf)\nlacks curvature of a fresnelIntegral (extension to brdf or curved spacetime?)\n",
            "flags": 0,
            "hasliked": 0,
            "id": "Xtcfzj",
            "likes": 33,
            "name": "goldenAngle GIllumination bayer",
            "published": 3,
            "tags": [
                "gi",
                "bayer",
                "radiosity",
                "weave",
                "laplachian",
                "crepusculariy",
                "lightshape",
                "softshaddow",
                "lightsdf"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 2434
        },
        "renderpass": [
            {
                "code": "/*\n[lightsdf] samples occlusion diagonally (root of unity?)\n,to estimate non-point-light-emnmitters (like a pseudo-DFT?)\nThis fails for large curvature and convex emmitters\n, but gives you some cheap decent RADiosity almost for free\n, but still looks decent. (roudned corners of convex square emmitter)\n, but it LOD-scales VERY nicely, can be VERY fast and look convincing (see in lowres)\nBayer matrix is used in favor of better (and more dynamic) performance;\n\nmy scaling of bayerMatrix*X/iResolution seems off (semi intentionally)\nmaking the bayer matix exponentially lower res than screenspace resolution.\nthis way it keeps (inverse-)cubic performance on low res\n, while getting exponentially better quality on higher res.\n- this is mostly a lowres-preview opengl-crashing evasion.\n- but also demoes how you could to a buas \n-, by [DistanceToScreenCenter*DistanceToMouseCursor] of [ /XdXBzH ]\n\nthis shader does not rotate bayer matrixces, like [ /ltKcDt ] does.\n- mostly because i tend to not trust complex transforms on bayer-hyperplane moire.\n- but also because this shader samples rotated anyways.\n\nthis shader does not use any frame buffers\n, which should easily get performance/quality a lot higher\n, but also makes the shader a lot less compatible to bufferless canvases.\n*/\n\n//crepuscularity with bayer    (with RADiosity)\n//self   (bayer,instead of hash)            : https://www.shadertoy.com/view/Xtcfzj\n\n//crepuscularity without bayer (with RADiosity)\n//parent (hash instead of bayer)            : https://www.shadertoy.com/view/lldcDf\n//crepuscularity with 3dto2d differenceGrad : https://www.shadertoy.com/view/4lXBW2\n\n//crepuscularity without bayer (no RADiosity? hard to tell.)\n//dr2-noise with a bias for3d derivatives   : https://www.shadertoy.com/view/llXfRs\n//in comparison to slow 3d (crashes opengl) : https://www.shadertoy.com/view/lltfRB\n//\n//crepuscularity with (no RADiosity)\n//crepuscularity with highres Bayer         : https://www.shadertoy.com/view/4dyXWy\n//crepuscularity with highres Bayer2        : https://www.shadertoy.com/view/ltsyWl\n//crepuscularity with only 3 hyperplaneTaps : https://www.shadertoy.com/view/ltKcDt\n\n//compare that to [bayer-toggled bokeh  (no radiosity, no crepuscularity):\n//then you can define \"quality\" depentant on \"eye focus\"\n//- \"eye focus\" is something like DistanceToScreenCenter*DistanceToMouseCursor\n//- scale that gradient by a bayer matrix and use that as if(){} quality-bias\n//- ,that toggles/mixes 4 Crepuscularity/Radiosity/bokeh-compositions, as in\n//- https://www.shadertoy.com/view/XdXBzH\n//this works best for \"bokeh\" as it implies correlated things;focus/peripheralVision\n//,but it should work just as well to set bayer-quality for crepuscularity/radiosity\n\n//number of disagonal casting samples for AO, set <10 to see the idea\n#define SAMPLES 32.\n//bayer scaling\n#define bayerZoom mix(.5,8.,cos(iTime*.0003)*.5+.5)\n//bayer itterations, makes 2^n number of tiles?\n#define iterBayerMat 2\n//2d zoom\n#define ViewZoom 10.\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y//usually first function of mainImage(),not typecast.\n\n\n#define bayer2x2(a)(4-(a).x-((a).y<<1))%4\n\n\n\n#define pi acos(-1.)//trig definition for 3.14...can be better for smarter compilers.\n#define vec1 float\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a)((a)*.5+.5)\n#define u2(a)((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nvec1 miv(vec2 a){return min(a.y,a.x);}vec1 miv(vec3 a){return min(a.z,miv(a.xy));}vec1 miv(vec4 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a)-miv(-a)\n#define cs(a) vec2(cos(a),sin(a))\n\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(vec1 a){return vec3(a);}\nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(vec1 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//hashes are named by output type,NEVER by input type\n//hash1 mirrors at y=x and has strong banding on diagonals.\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hash1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hash2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hash3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hash4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hash1(float n){ return fract(sin(n)*1e4);}\n\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n\n\n\n\n\n\nfloat boxSDF(vec2 p,vec2 s\n){vec2 r=abs(p)-s\n ;return min(max(r.x,r.y),0.)+length(max(r,vec2(0)));}\n\nvec3 colormap(float x\n){//float s=sin(x*6.28)\n ;return vec3(1,vec2(-1,1)*sign(x))*.25+.25;}\n\nvoid AddObj(inout float dist,inout vec3 color,float d,vec3 c\n){if(dist>d){dist=d;color=c;}}\n\nvec4 scene(vec2 u,vec2 m\n){float dist=1e9;\n ;vec3 color=vec3(0)\n ;AddObj(dist,color,boxSDF(u-vec2(-3,1),vec2(1,1)),vec3(.6,.8,1.))\n ;AddObj(dist,color,length(u-vec2(3,1))- 1.,vec3(1,.9,.8))\n ;AddObj(dist,color,length(u-vec2(.3*sin(iTime),-2))- 0.5,vec3(0,.1,0))\n ;AddObj(dist,color,boxSDF(u-m,vec2(1.5,0.1)),vec3(.3,.1,.1))\n ;return vec4(color,dist);}\n\nvec3 trace(vec2 p,vec2 dir,vec2 m\n){for (int a=55;a>0;a-- //more steps make intignificant difference in simple sets\n){vec4 s=scene(p,m)\n  ;if(s.w<1e-1)return s.xyz\n  ;if(s.w>10.)return vec3(0)\n  ;p+=dir*s.w;\n }return vec3(0);}\n\n//return bayer matrix(bitwise operands for speed over compatibility)\nfloat GetBayerFromCoordLevel(vec2 pixelpos//https://www.shadertoy.com/view/XtV3RG\n){ivec2 p=ivec2(pixelpos);int a=0\n ;for(int i=0;i<iterBayerMat;i++\n){a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i)\n ;}return float(a)/float(2<<(iterBayerMat*2-1));}\n\n//float hash1(vec2 _st){return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);}\nvoid mainImage(out vec4 fragColor,vec2 u\n){u=fra(u)//(u-(iResolution.xy*.5))/iResolution.y*ViewZoom\n ;vec2 m=vec2(0)\n ;if(iMouse.z<=0.)m.xy=vec2(.5)+vec2(cos(iTime),sin(iTime*1.61))*.3*ViewZoom\n ;else m=fra(iMouse.xy)\n ;vec3 c=vec3(0)\n ;float phi=sqrt(5.)*.5-.5\n ;for(float i=0.;i<SAMPLES;i++\n){\n  ;float scale=1.//pi //some values make more sense, i have no clue why-\n  //;float t=(i+hash1(u.x-u.y+i+iTime))/SAMPLES*2.*pi\n  ;float t=(i+GetBayerFromCoordLevel(bayerZoom*u*phi*ViewZoom*iResolution.x+i+iTime*1.61)/scale)/SAMPLES*2.*pi*scale\n  ;c+=trace(u,cs(t),m)\n  ;}\n ;c/=SAMPLES\n ;fragColor=vec4(c*2.,1);}\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}