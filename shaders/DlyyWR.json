{
    "Shader": {
        "info": {
            "date": "1700064860",
            "description": "// All work and no play makes Jack a Dull Skull //",
            "flags": 64,
            "hasliked": 0,
            "id": "DlyyWR",
            "likes": 55,
            "name": "DULL SKULL",
            "published": 3,
            "tags": [
                "raymarching",
                "normals",
                "fog",
                "specular",
                "softshadows",
                "diffuse",
                "skeleton",
                "fresnel",
                "skull",
                "bones",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "Kris_Katur",
            "viewed": 1880
        },
        "renderpass": [
            {
                "code": "// \"Dull Skull\"\n// 2023\n// by KÎ›TUR\n// License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n\n/*\n=======================================================================\n\nI plan to spend more time working on this shader; thinking of\nadding a background and finishing up the skeleton later on.\nAny feedback or suggestions on improving performance, whether it's\ntweaking the SDF or enhancing the shading, would be great.\nFeel free to use this shader for your own experiments and development,\nadhering to the specified license. I'd love to see different takes on it!\n  \n=======================================================================\n\nCHOOSE FROM DIFFERENT STYLES HERE\n\n0 = SIMPLE DIFFUSE\n1 = FUNKY FRESNEL & NORMALS\n2 = MORE COMPLEX LIGHTING\n3 = GHOST MODE\n*/\n\n#define SHADE 2\n\n//===================================================================//\n\n#define MAX_STEPS 100\n#define MAX_DIST 15.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n//===================================================================//\n// below by https://iquilezles.org/\n\nfloat sUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat sIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sphere(vec3 p,float s){\n    return length(p)-s;\n}\n\nfloat Ellipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat rBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat Box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat HollowSphere( vec3 p, float r, float h, float t ){\n  float w = sqrt(r*r-h*h);\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// above by https://iquilezles.org/\n//===================================================================//\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// by https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n    \n    float angle = 2.*PI/repetitions,\n          a = atan(p.y, p.x)+angle,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) *r ;\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nmat2 RotSin(float a, float b, float c){\n    mat2 rot = Rot(sin(a)*b+c);\n    return rot;\n}\n\nfloat Bone(vec3 p,vec3 a, vec3 b, float delta, float r, float r2, float bb){\n        float bone = Capsule(p,a,b,(abs((pow(p.z-delta,2.))))*r2+r);\n        p.z -= delta;\n        bone = max(bone,rBox(p,vec3(bb),.0));//bounding box\n        return bone;\n}\n\nfloat Finger(vec3 p, float scale, float iter, float r, float r2, float bb, float angle){\n        vec3 a = vec3(0);\n        vec3 b = vec3(0,0,1)*scale;\n        float delta = (b-a).z;\n        p.yz *= Rot(angle*.3);\n        float fbone = Bone(p,a,b,delta/2.,r,r2,bb);\n        \n        float eps = .1;\n        float dist = (b-a).z;\n        \n        for (float i=min(iTime,0.0);i<iter;i++){\n            a.z = b.z+.08;\n            b.z = a.z+dist;\n            delta = a.z+(dist)/2.;\n            dist -= eps;\n            p.z -= a.z;\n            p.yz *= Rot(angle);\n            p.z += a.z;\n            r -= 0.001;\n            \n            fbone = min(fbone,Bone(p,a,b,delta,r,r2,bb));\n            \n        }\n        \n        return fbone;\n}\n\nfloat SceneSDF(vec3 p){\n    \n    float t = iTime;\n    \n// ||||||||||||||||||||============|||||||||||||||||||| //    \n// ==================== UPPER BODY ==================== //\n// ||||||||||||||||||||============|||||||||||||||||||| //    \n    \n    // ===== SPINE ===== //\n    vec3 p_spine = p;\n        p_spine.y -= sin(t*.1)*.3;\n        p_spine.z -= .6+sin(t*.2)*sin(t*.51);\n        vec3 p_vert = p_spine;\n            vec3 sSpine = vec3(.13,.09,.13);\n    float spine = Ellipsoid(p_vert,sSpine);//vertebrae - no anatomical accuracy, just an indication that there are vertebrae :)\n        for (float i=0.;i<5.;i++){\n            p_vert.y += .22;\n            p_vert.z += i*.09;\n            sSpine += .01;\n            spine = min(spine,Ellipsoid(p_vert,sSpine));  \n        }\n    spine -= sin(29.*p_vert.x)*sin(21.*p_vert.y)*sin(9.*p_vert.z*.003);//deformation\n     \n    // ===== COLLARBONE ===== //\n        float side = sign(p_spine.x);//side definition\n    \n    vec3 p_cbone = vec3(abs(p_spine.x),p_spine.yz);\n        p_cbone += vec3(-.2,1.,.5);\n        p_cbone.xz *= Rot(1.8+sin(t*.09)*.2);\n        p_cbone.yz *= Rot(sin((side-.23)*t*.6)*.2);\n    float cbone = Bone(p_cbone+sin(p_cbone.z*3.)*.1, vec3(0),vec3(0,0,1.6),.8,.04,.04,1.5);\n    \n// ======================  ARMS ====================== //  \n\n    // ===== UPPER ARM ===== //\n        p_cbone.xz *= Rot(-1.8-sin(t*.09)*.2);//invert collarbone transformation\n    vec3 p_uArm = vec3(abs(p_cbone.x)-1.8,p_cbone.y+.1,p_cbone.z+.3);\n        float ruAxz = (side-.59)*t*.3;\n        p_uArm.xz *= RotSin(ruAxz,.2,.35);\n        p_uArm.xy *= RotSin((side-.19)*t*.42,sin(t*.18)*.6,0.2);\n        p_uArm.yz *= RotSin((side+.12)*t*.62,.2,.1);\n        p_uArm.z -= 1.;\n    float uABone = Bone(p_uArm,vec3(0,0,-1),vec3(0,0,1),0.,.06,.09,1.3);//bone sdf\n    float uArm = sSubtraction(Sphere(p_uArm+vec3(.08,-0.,-1.1),.13),uABone,.2);//deformation of front end of bone\n    \n    // ===== LOWER ARM ===== //\n    vec3 p_lArm = vec3(p_uArm.x,p_uArm.y,p_uArm.z-1.1);\n        p_lArm.xz *= RotSin(-ruAxz,.3,-.6);\n        float t1 = t*.6+sin(t*.22);     \n        float rlAxySin = (side+.13)*t1*.5;\n        float rlAxyAmo = p_lArm.z*.3;\n        float rlAxyOff = p_lArm.z*.7;\n        p_lArm.xy *= Rot(-.3);\n        p_lArm.xy *= RotSin(rlAxySin,-rlAxyAmo,-rlAxyOff-.2);//crossing Ulna and Radius\n        p_lArm.z -= 1.;\n    vec3 p_lArmS = vec3(abs(p_lArm.x)-.09,p_lArm.yz);//mirroring single bone\n        p_lArmS.x += (abs(pow(p_lArmS.z+.7,2.)))*.04;//bending bones\n        vec3 a = vec3(.1,0,1), b = vec3(0.,0,-1);\n        float r2=.04, bb = 1.5;\n        float r = .03;\n    float lArm = Bone(p_lArmS,a,b,0.,r,r2,1.2);//lower arm\n    float arm = min(lArm, uArm);//union upper and lower arm\n\n    // ===== HANDS ===== //\n        // CARPUS\n        \n        p_lArm.xy *= RotSin(rlAxySin,rlAxyAmo,rlAxyOff+.2);//inverse the crossing of Ulna and Radius\n    vec3 p_hand = p_lArm;\n        p_hand.z -= 1.1;//translate anchor point\n        float t2 = sin(t1)+(side-.19)*t1;\n        p_hand.xy *= Rot(1.5);\n        p_hand.xy *= RotSin(-rlAxySin,1.,0.);\n        p_hand.yz *= RotSin(t2+1.91,1.,.45);\n        p_hand.xy *= RotSin((side-.32)*t1+.3,.1,.1);\n    float hand = Ellipsoid(p_hand,vec3(.2,.04,.1));//ellipsoid as base\n        hand -= (sin(27.*p_hand.x)+sin(37.*p_hand.z)*sin(19.*p_hand.y))*.015;//deformation of ellipsoid\n        \n        // FINGERS\n    vec3 pf = vec3(p_hand.xy,p_hand.z-.2);;\n        r = .03, r2=.7, bb=.5;\n            \n            // POINT\n    vec3 pf1 = pf;\n        pf1.xz += vec2(.13,.08);\n        pf1.xz *= Rot(-.2);\n        float fpoint = Finger(pf1,.3,3.,r,r2,bb,(sin(cos(t2*.5)+t2-.12)*(sin(t2)*.4+.7)*.6-.7));\n            // MIDDEL\n    vec3 pf2 = pf;\n        pf2.z += .03;\n        pf2.xz *= Rot(0.);\n        pf2.xy *= Rot(.2);\n        float fmiddle = Finger(pf2,.32,3.,r,r2,bb,(sin(cos(t2*.3)+t2-.2)*(sin(t2)*.4+.7)*.7-.9));\n            // RING\n    vec3 pf3 = pf;    \n        pf3.xz -= vec2(.13,-.05);\n        pf3.xz *= Rot(.15);\n        pf3.xy *= Rot(.3);\n        float fring = Finger(pf3,.3,3.,r,r2,bb,(sin(cos(t2*.7)+t2-.4)*(sin(t2)*.3+.7)*.8-1.));//+sin(t*.7+.5)*.3-.3);\n            // PINKY\n    vec3 pf4 = pf;    \n        pf4.xz -= vec2(.23,-.12);\n        pf4.xz *= Rot(.5);\n        pf4.xy *= Rot(.4);\n        float fpinky = Finger(pf4,.25,3.,r,r2,bb,(sin(cos(t2*.9)+t2)*(sin(t2)*.2+.6)*.8-1.));//;+sin(t+.7)*.2-.4);\n            // THUMB\n    vec3 pf5 = pf;\n        pf5.xz += vec2(.22,.2);\n        pf5.xz *= Rot(-1.2);\n        pf5.xy *= Rot(-.6);\n        pf5.yz *= Rot(-.2);\n        float thumb = Finger(pf5,.14,2.,0.035,r2,bb,(sin(t2-.16)*(sin(t2)*.6+.8)*.8-1.));//+sin(t+1.2)*.3-.15)*.8;        \n        \n    float fingers = min(fpoint,min(fmiddle,min(fring,min(fpinky,thumb))));//union all fingers\n    \n    hand = min(hand, fingers);//union fingers and carpus = hand\n    arm = min(hand,min(arm,min(cbone,spine)));//union hand, arm, collarbone and spine\n\n\n// ||||||||||||||||||||||=======|||||||||||||||||||||| //    \n// ====================== SKULL ====================== //\n// ||||||||||||||||||||||=======|||||||||||||||||||||| //\n\n    \n    // ===== HEAD ===== //\n    vec3 p_skull = p_spine-vec3(0,.7,.7);\n        p_skull.xy *= RotSin(t*.1,cos(t*.4)*.4,sin(t*.3)*.4);\n        p_skull.yz *= RotSin(t*.13,cos(t*.27)*.2,sin(t*.23)*.1);\n    vec3 p_head = p_skull;\n        float d = Ellipsoid(p_head,vec3(.9,1.1,1.2));//head base\n        float p_cutb = p_head.y+.7 + sin(p_head.x + sin(cos(p_head.z*1.4)) * 21.)*.02; //bottom cut\n    p_cutb = sUnion(p_cutb, Ellipsoid(p_head-vec3(0,-.3,-.2),vec3(.7)),.0);//head hole\n    p_cutb = sUnion(p_cutb, Ellipsoid(p_head-vec3(0,-.24,.5),vec3(.51)),.1);//head hole front    \n    d = sSubtraction(p_cutb, d,.05); //bottom cut\n        float p_cutf = -p_head.z+1.1; //forehead plane\n    d = sSubtraction(p_cutf, d,.2); //forehead cut\n    d = min(d, spine);\n    \n        // TEMPLES\n        float cuts_temple = Capsule(vec3(-abs(p_head.x),p_head.yz), vec3(-1.,-1,.8), vec3(-1.8,3,.0), .5 );//temple deepenings\n    d = sSubtraction(cuts_temple, d,.3); //temple cuts\n        float bcut_temple = Capsule(p_head, vec3(-2.,-1.1,.6), vec3(2,-1.1,.6), .6 );//side cuts\n    d = sSubtraction(bcut_temple, d,.3); //side cuts \n        \n        // ZYGOMATIC ARCH\n    vec3 p_zyg = vec3(abs(p_skull.x),p_skull.yz);\n        p_zyg.x += sin(p_zyg.z*4.+PI)*.08;\n        p_zyg.y += cos(p_zyg.z*9.)*.03;\n        float zyg = Capsule(p_zyg,vec3(.5,-.3,.8),vec3(.75,-.3,0.1),(p_zyg.z)*.1);\n    d = sUnion(d,zyg,.06);\n    \n    // ===== UPPER JAW ===== //\n    vec3 p_jaw = p_skull-vec3(0,.36,.1);\n        p_jaw.yz *= Rot(PI);\n        p_jaw.y -= sin(p_jaw.x*37.)*.007 - cos(p_jaw.z*59.)*.01;//deformation\n        float ujaw = HollowSphere(p_jaw+vec3(0,-.95,.6),.38,.02,.05 );//jaw sdf\n        float p_cutB = p_skull.z-.6;//cutting plane back\n        ujaw = sSubtraction(p_cutB, ujaw,.05); //jaw back cut\n    vec3 p_jawsc = vec3(abs(p_skull.x),p_skull.yz); //new point def for side cuts\n        p_jawsc.xy *= Rot(-1.);\n        p_jawsc.yz *= Rot(-.4);\n        p_jawsc.y += .3; \n        ujaw = sSubtraction(p_jawsc.y, ujaw,.04); //side cuts\n    d = sUnion(ujaw, d,.1);//union upper jaw and d     \n    d -= sin(10.*p_skull.x)*sin(8.*p_skull.y)*sin(7.*p_skull.z)*.01;//deformation head\n        \n    // ===== EYES ===== // \n    \n        // CHEEKBONES\n    vec3 p_eyesur = p_skull-vec3(0,.3,0);\n        float eyesur = Ellipsoid(vec3(abs(p_eyesur.x),p_eyesur.yz)+vec3(-.34,.5,-.87),vec3(.25,.24,.2));//cheekbones   \n        eyesur += sin(12.*p_skull.x)*sin(9.*p_skull.y)*sin(13.*p_skull.z)*.05;//deformation\n    d = sUnion(eyesur, d,.2);//union cheekbones and d\n   \n        // EYE HOLES\n    vec3 p_eye = p_skull;\n        p_eye += sin(p_eye.x*29.+cos(p_eye.y*32.))*.008; //eye distortion\n        float eye = Ellipsoid(vec3(abs(p_eye.x),p_eye.y-.4,p_eye.z)+vec3(-.29,.49,-1.1),vec3(.21,.25,.25)); // eye ball\n        eye = sUnion(eye,Sphere(vec3(abs(p_skull.x),p_skull.yz)-vec3(.25,0.,.7),.35),.05);// eye hole back\n        eye = sSubtraction(-p_eye.y,eye,.2);\n    d = sSubtraction(eye, d,.05); //eye ball subtraction        \n        \n    // ===== NOSE ===== //\n    \n        // NOSE BONE\n    vec3 p_nbone = p_skull;\n        p_nbone.yz *= Rot(-2.2);\n        float nbone = HollowSphere(p_nbone+vec3(0,-1.,.4),.1,0.08,.04 );\n    d = sUnion(d,nbone,.05);\n    \n        // NOSE HOLE\n    vec3 p_nose = vec3(abs(p_skull.x),p_skull.yz);\n        p_nose.xy *= Rot(-.4);\n        float nose = Ellipsoid(p_nose-vec3(-.1,-.3,1.),vec3(.05,.1,.8));\n    d = sSubtraction(nose, d,.06); //nose subtraction\n        \n    // ===== LOWER JAW ===== //\n        \n        // LOWER JAW TRANSFORMATION\n    vec3 pN = p_skull;\n        pN.z -= .5;\n        pN.y += .4;\n        pN.yz *= RotSin(sin(t*.8),sin(t)*.3+smoothstep(0.,1.,sin(t)*.3),-.3);\n        pN.z += .5;\n        pN.y -= .4;\n        pN -= sin(pN.y*15.)*.001 - cos(pN.z*39.)*.001;//deformation\n        \n        // CHIN\n    vec3 p_ljaw = pN;//chin part\n        p_ljaw.yz *= Rot(TAU);\n        p_ljaw.y *= .8;\n        p_ljaw.y -= cos(pN.x*15.+sin(pN.y*7.)*2.)*.01;\n        float ljaw = HollowSphere(p_ljaw+vec3(0,.77,-.74),.38,0.03,.04 );//chin sdf  \n       ljaw = sSubtraction(p_ljaw.z-.65,ljaw,.1);//back cut\n        \n        // MANDIBLE BACK\n    vec3 p_maB = vec3(abs(pN.x),pN.yz);\n        p_maB.yz *= Rot(-1.3);\n        p_maB.xz *= Rot(-.34);\n        p_maB.xy *= Rot(-.39);\n        p_maB -= vec3(0.85,.0,.63);\n       ljaw = sUnion(ljaw,rBox(p_maB,vec3(0.,smoothstep(0.,6.,abs(-p_maB.z)+.9),.45),.04),.17);//union chin + mandible\n       ljaw = sSubtraction(Ellipsoid(p_maB-vec3(.0,.0,-.55),vec3(.5,.15,.26)),ljaw,.04);//mandible top cut to get a V\n        p_ljaw -= sin(p_ljaw.y*32.)*.001 - cos(p_ljaw.z*29.)*.007;//deformation\n       ljaw = sSubtraction(p_ljaw.y+.93,ljaw,.02);//bottom cut\n\n    d = min(ljaw, d);//union chin and d      \n\n    // ===== UPPER TEETH ===== //\n    vec3 p_tooth = p_skull;\n        p_tooth -= vec3(0,-.77,.7);\n        p_tooth *= vec3(1.2,1,1);\n        pModPolar(p_tooth.xz, 32.0);//alignment polar\n\n        float teeth = Ellipsoid(p_tooth - vec3(0.43, 0., 0.), vec3(0.03, 0.15, 0.045));\n        teeth = max(teeth, -p_skull.y-.73+sin(p_skull.x*32.)*.006);//cut teetch bottom\n        teeth = max(teeth, -p_skull.z+.7);// cut teeth back\n    d = min(d,teeth);\n        \n    // ===== LOWER TEETH ===== //\n    vec3 p_ltooth = pN;\n        p_ltooth -= vec3(0,-.77,.7);\n        p_ltooth *= vec3(1.2,1,1);\n        pModPolar(p_ltooth.xz, 32.0);//alignment polar\n\n        float lteeth = Ellipsoid(p_ltooth - vec3(0.42, 0., 0.), vec3(0.03, 0.15, 0.045));\n        lteeth = max(lteeth, pN.y+.79+sin(p_skull.x*29.)*.004);//cut teeth top\n        lteeth = max(lteeth, -pN.z+.7);// cut teeth back\n    d = min(d,lteeth);\n       \n    d = min(d,arm);//union skull, arm, hand and fingers\n    \n    return d;\n}\n\nvec3 RayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nfloat March(vec3 ro, vec3 rd){\n    float h=0.;\n    for(int i=0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*h;\n        float dS = SceneSDF(p);\n        h += dS;\n        if(h>MAX_DIST||abs(dS)<SURF_DIST) break;\n    }\n    return h;\n}\n\nvec3 CalcNormal (vec3 p){\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*SceneSDF(p+.001*e);\n    }\n    return normalize(n);\n}\n\nfloat Light(vec3 p, vec3 lpos){\n    vec3 pos = vec3(lpos);\n    vec3 l = normalize(pos-p);\n    vec3 n = CalcNormal(p);\n    float dif = clamp(dot(n,l), 0., 1.);\n    float d = March(p+n*SURF_DIST*2.,l);\n    \n    if(d<length(pos-p)) dif *=.1;\n    \n    return dif;\n}\n\n//by https://iquilezles.org/\nfloat CalcAO( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<8; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n//by https://iquilezles.org/\nfloat CalcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t );\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n    }\n    \n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 ComplexLight( in vec3 ro, in vec3 rd, vec3 l, vec3 material){ \n    vec3  col = vec3(0.0);\n    float d = March(ro,rd);\n\n    if( d>-0.5 )\n    {\n        vec3 p = ro + d*rd;\n        vec3 n = CalcNormal(p);\n        vec3 l = normalize(l);\n        vec3 hal = normalize(l-rd);\n        float dif = clamp(dot(n,l),.0,1.)*CalcSoftshadow(p,l,.01,3.);//diffuse\n\t\tfloat spe = pow(clamp(dot(n,hal),0.,1.),16.0)*clamp(1.2+dot(hal,rd),0.,1.);//specular\n\t\tcol = material*dif*30.*spe;\n        float ao = CalcAO(p,n);//ambient occlusion\n\t\tfloat amb = clamp(.5+.5*n.x,0.,1.);//ambient\n        col += material*amb*ao;\n    }\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, sin(iTime*.18)*2.*cos(iTime*.52), 12.5);\n    ro.yz *= Rot(sin(iTime*.41)*.2);\n    ro.xz *= Rot(cos(iTime*.32)*.2);\n    \n    vec3 rd = RayDir(uv, ro, vec3(0,0.,0), 2.);\n    \n    vec3 col = vec3(0);\n    \n    float d = March(ro, rd);\n    \n    if(d<MAX_DIST){ \n        vec3 p = ro + rd*d;\n        vec3 n = CalcNormal(p);\n\n    #if SHADE==0\n    vec3 lpos = vec3(-3,6,6);\n    float dif = Light(p,lpos);\n    col = vec3(dif)*3.+.06;   \n    #endif\n    #if SHADE==1\n    float fresnel = pow(1.+dot(rd, n),3.);\n    col = vec3(fresnel*4.);\n    col *= n*.5+.5;\n    #endif\n    #if SHADE==2\n    vec3 material = vec3(.95,.6,.1);\n    col = ComplexLight( ro, rd, vec3(5,4,3),material);\n    #endif\n    #if SHADE==3\n    col = vec3(1.);\n    #endif\n        \n    }\n\n    col = mix( col, vec3(0), 1.-exp( -0.000002*pow(d,6.)) );//fog    \n    col = pow(col, vec3(.4545)); //gamma correction\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 35233,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/myuu/victors-piano-solo-the-piano-duet-corpse-bride-medley"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}