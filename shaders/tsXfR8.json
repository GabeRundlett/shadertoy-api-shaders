{
    "Shader": {
        "info": {
            "date": "1587664634",
            "description": "First time trying to render an actual raymarching scene. I am still bad at this :(\nDon't look behind the wall. Lots of (lighting) code taken from fruxis: https://www.shadertoy.com/view/ldl3zl , which is awesome, but I am still learning them.",
            "flags": 0,
            "hasliked": 0,
            "id": "tsXfR8",
            "likes": 5,
            "name": "Do You Want To Build A Snowman",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "42yeah",
            "viewed": 492
        },
        "renderpass": [
            {
                "code": "float smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat snowhead(vec3 p, vec3 off) {\n    float body = length(p - off) - 1.0;\n    float head = length(p - vec3(0.0, 1.4, 0.0) - off) - 0.6;\n    return smin(body, head, 0.2);\n}\n\nfloat carrot(vec3 p, vec3 off) {\n    p = p - off;\n    if (length(p) > 1.0) {\n        return 1.0;\n    }\n    float rad = radians(75.0);\n    float q = length(p.xy);\n    return dot(vec2(sin(rad), cos(rad)), vec2(q, p.z));\n}\n\nfloat snoweye(vec3 p, vec3 off) {\n    float left = length(p - vec3(-0.25, 0.0, 0.0) - off) - 0.1;\n    float right = length(p - vec3(0.25, 0.0, 0.0) - off) - 0.1;\n    return min(left, right);\n}\n\nfloat sol(vec3 p) {\n    return p.y;\n}\n\nfloat rect(vec3 p, vec3 b, vec3 off) {\n    vec3 q = abs(p - off) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.1;\n}\n\nfloat window(vec3 p, vec3 off) {\n    return max(rect(p, vec3(2.0, 2.0, 0.1), off),\n        -rect(p, vec3(1.8, 1.7, 1.0), off + vec3(0.0, 0.0, 0.1)));\n}\n\nfloat wall(vec3 p, vec3 windowOff) {\n    if (p.z < -3.0) {\n        return 1.0;\n    }\n    float x = abs(p.x + 3.0) - 0.001;\n    float z = abs(p.z + 3.0) - 0.001;\n    return max(min(x, z),\n        -rect(p, vec3(2.0, 2.0, 1.0), windowOff));\n}\n\nfloat cubic(vec3 p, vec3 off) {\n    float sol = rect(p, vec3(3.0, 0.01, 3.0), off);\n    float plafond = smin(sol, rect(p, vec3(3.0, 0.01, 3.0), off + vec3(0.0, 6.0, 0.0)), 0.1);\n    float wall = smin(plafond, rect(p, vec3(3.0, 6.0, 0.01), off + vec3(0.0, 0.0, -3.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(-3.0, 0.0, 0.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(3.0, 0.0, 0.0)), 0.1);\n    return wall;\n}\n\nfloat lamp(vec3 p, vec3 off) {\n    return rect(p, vec3(0.5, 0.1, 0.4), off);\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = snowhead(p, vec3(0.0, 0.5, 0.0));\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    dist = snoweye(p, vec3(0.0, 2.2, 0.5));\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    dist = carrot(p, vec3(0.0, 1.9, 1.0));\n    if (dist < closest) { closest = dist; id = 3.5; }\n    \n    dist = wall(p, vec3(0.0, 3.8, -4.0));\n    if (dist < closest) { closest = dist; id = 4.5; }\n    \n    dist = window(p, vec3(0.0, 3.8, -3.1));\n    if (dist < closest) { closest = dist; id = 5.5; }\n    \n    dist = cubic(p, vec3(1.0, 0.0, -6.15));\n    if (dist < closest) { closest = dist; id = 6.5; }\n    \n    dist = lamp(p, vec3(1.0, 6.0, -6.15));\n    if (dist < closest) { closest = dist; id = 7.5; }\n    \n    return vec2(closest, id);\n}\n\nvec3 calcNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(p).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(p).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(p).x - map(vec3(p.xy, p.z - epsilon)).x\n    ));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    vec2 dv = vec2(0.0, -1.0);\n    \n    for (int i = 0; i < 300; i++) {\n        vec2 distId = map(ro + rd * dv.x);\n        if (distId.x <= 0.001) {\n            dv.y = distId.y;\n            break;\n        }\n        dv.x += distId.x;\n    }\n    return dv;\n}\n\nvec3 wallColor(vec3 p) {\n    const vec3 base = vec3(0.8, 0.6, 0.7);\n    vec3 f = fract(p);\n    float clamped = length(clamp(p, 0.0, 1.0));\n    return base * (f.y + 0.4);\n}\n\nvec3 carrotColor(vec3 p) {\n    const vec3 base = vec3(1.5, 0.3, 0.0);\n    vec3 f = fract(p * 10.0);\n    vec3 color = base * (1.0 - pow(f.z, 12.0) * 0.3);\n    return color;\n}\n\nvec3 getColor(vec3 p, float id) {\n    if (id <= -0.5) { return vec3(0.0, 0.0, 0.0); }\n    if (id <= 1.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 2.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 3.0) { return vec3(0.1, 0.1, 0.1); }\n    if (id <= 4.0) { return carrotColor(p); } // carrot\n    if (id <= 5.0) { return wallColor(p); } // wall\n    if (id <= 6.0) { return vec3(0.5, 0.2, 0.1); }\n    if (id <= 7.0) { return vec3(2.2, 2.2, 2.2); }\n    if (id <= 8.0) { return vec3(100.0, 100.0, 100.0); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float depth = 0.0001;\n    vec2 dv = vec2(1.0, -1.0);\n\n    for (int i = 0; i < 50; i++) {\n        dv = map(ro + rd * depth);\n        res = min(res, smoothstep(0.0, 1.0, k * dv.x / depth));\n        if (res < 0.0001) { break; }\n        depth += clamp(dv.x, 0.01, 0.06);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat directLighting(vec3 p, vec3 n, vec3 lightPos, vec3 lightDir) {\n    vec3 u = normalize(cross(lightDir, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(u, lightDir);\n    float shadowIntensity = softShadow(p + 0.001 * n, lightDir, 10.0);\n    \n    vec3 toLight = lightPos - p;\n    float attenuation = smoothstep(0.9, 1.0, dot(normalize(toLight), lightDir));\n    \n    return attenuation * shadowIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    const float r = 2.0;\n    vec3 ro = vec3(r * (sin(iTime * 0.3) * 0.5 + 0.5) * 0.9 + r, 3.0 * (sin(iTime * 0.5) * 0.1 + 0.9), r * (cos(iTime * 0.3) * 0.5 + 0.5) + r);\n    vec3 center = vec3(0.0, 2.0 + sin(iTime * 0.2) * 0.8 + 0.2, 0.0);\n    vec3 front = normalize(vec3(center - ro));\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 result = intersect(ro, rd);\n    vec3 pos = ro + rd * result.x;\n    vec3 n = calcNormal(pos);\n    \n    vec3 lightPos = vec3(-1.5, 5.5, -4.65);\n    vec3 lightDir = normalize(lightPos);\n    vec3 hal = normalize(lightDir - rd); // WHAT?\n\n    float ambient = 1.0;\n    float diffuse = max(dot(lightDir, n), 0.0);\n    float attenuation = 0.1 + 0.9 * smoothstep(0.9, 1.0, dot(normalize(lightPos - pos), lightDir));\n    float back = max(dot(n, normalize(vec3(-lightDir.x, 0.0, -lightDir.z))), 0.0);\n    float fr = pow(clamp(1.0 + dot(n , rd), 0.0, 1.0), 3.0);\n    float dome = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float sol = clamp(-n.y * 0.8 + 0.2, 0.0, 0.0) * pow(clamp(1.0 - pos.y, 0.0, 1.0), 2.0);\n    float specular = pow(clamp(dot(n, hal), 0.0, 1.0), 8.0);\n    float shadow = directLighting(pos, n, lightPos, lightDir);\n    \n    vec3 light = vec3(0.0, 0.0, 0.0);\n    light += ambient * vec3(0.03, 0.02, 0.01) * attenuation;\n    light += diffuse * vec3(1.01, 1.0, 1.0) * pow(vec3(shadow), vec3(1.0, 1.0, 1.0)) * attenuation;\n    light += back * vec3(0.42, 0.20, 0.1) * attenuation;\n    light += fr * vec3(3.0, 3.0, 3.0) * attenuation * (0.25 + 0.25 * diffuse);\n    light += dome * vec3(0.15, 0.1, 0.1) * attenuation;\n    light += sol * vec3(0.2, 0.2, 0.2) * attenuation;\n    light += specular * vec3(0.5, 0.5, 0.5) * attenuation;\n    \n    vec3 color = getColor(pos, result.y) * light;\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}