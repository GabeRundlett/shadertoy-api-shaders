{
    "Shader": {
        "info": {
            "date": "1588588750",
            "description": "this is my design for a \"memetic kill agent\", a fictional concept, popularized by the SCP foundation. because it's a little flashy and might be bad for photosensitive people, I've hidden it behind the mouse click.",
            "flags": 32,
            "hasliked": 0,
            "id": "3dXfR2",
            "likes": 8,
            "name": "Memetic Kill Agent (Click2View)",
            "published": 3,
            "tags": [
                "scp",
                "cognitohazard",
                "memetic"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 524
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x=FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\n\nvec2 map(vec2 uv) {\n    return (uv*iResolution.y+0.5*iResolution.xy)/iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec4 color = vec4(0);\n    for (int i = -2; i < 3; i++) {\n    \tfor (int j = -2; j < 3; j++) {\n            vec2 off = vec2(i,j)/iResolution.y/4.*1.5;\n            float dispersion = hash(hash(hash(uv.x,uv.y),iTime),hash(float(i),float(j)))*0.02+1.;\n            float red = texture(iChannel0,map(uv*dispersion*1.03+off)).x;\n            float green = texture(iChannel0,map(uv*dispersion*1.01+off)).y;\n            float blue = texture(iChannel0,map(uv*dispersion*1.0+off)).z;\n    \t\tcolor += pow(vec4(red, green, blue, 1.),vec4(2.));\n        }\n    }\n\n    fragColor.xyz = sqrt(color.xyz/color.w)*0.9+abs(hash(hash(uv.x,uv.y),iTime))*0.1;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x=FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat speed(float x) {\n    return pow(sin(fract(x)*3.14/2.),100.)+floor(x)+x*2.;\n}\n\nfloat noise(vec2 uv) {\n    vec2 crds = smoothstep(vec2(0.),vec2(1.),fract(uv));\n    uv = floor(uv);\n    float h1 = hash(uv.x,uv.y);\n    float h2 = hash(uv.x+1.,uv.y);\n    float h3 = hash(uv.x,uv.y+1.);\n    float h4 = hash(uv.x+1.,uv.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat wild(vec2 uv, float time) {\n    float t = speed(speed(speed(time)*0.4)*0.3);\n    float color = 0.;\n    for (int i = 0; i < 50; i++) {\n        float h1 = hash(float(i), float(i));\n        float h2 = hash(h1, float(i));\n        float h3 = hash(h2, float(i));\n        float h4 = hash(h3, float(i));\n        color += cos(80.*dot(uv, vec2(h1,h2))+t*h4+h3*100.);\n    }\n    int idx = int(floor(t));\n        float h1 = hash(float(idx), float(idx));\n        float h2 = hash(h1, float(idx));\n    vec2 uv2 = uv+floor(time*10.)/10.*vec2(h1,h2);\n    float m1 = noise(uv2*20.+float(idx)*20.)*0.5+0.5;\n    m1 = smoothstep(0.3,0.6, m1);\n    return color*m1*1.5+time*40.;\n}\n\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat cognitohazard(vec2 uv) {\n    float rnd = sin(noise(uv+iTime*8.+5.)*0.1)*0.5+0.5;\n    float t = floor(iTime*10.)/40. + fract(iTime*10.)/40.*rnd;\n    float m1 = noise(uv*10.+floor(iTime)*20.)*0.5+0.5;\n    m1 = smoothstep(0.5,.9, m1);\n    float color = mix(wild(uv,t), wild(uv*0.5+100.,t), m1);\n    float bx = max(abs(uv.x),abs(uv.y));\n    if (bx>0.3 || bx<0.1) {\n        color = 0.;\n    }\n    color = sin(color)*80. < 0. ? 1. : 0.;\n    if (iMouse.z < 0. || iMouse.x == 0.) {\n        color = 0.;\n    }\n    uv = abs(uv);\n    uv = vec2(max(uv.x,uv.y), min(uv.x,uv.y));\n    float ld = linedist(uv, vec2(0), vec2(0.01));\n    if (ld < 0.002) {\n        color = 1.;\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    fragColor.xyz = vec3(cognitohazard(uv));\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}