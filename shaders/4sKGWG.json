{
    "Shader": {
        "info": {
            "date": "1456178088",
            "description": "Come fly with me...",
            "flags": 32,
            "hasliked": 0,
            "id": "4sKGWG",
            "likes": 12,
            "name": "Quadcopter",
            "published": 3,
            "tags": [
                "game",
                "flight",
                "drone",
                "simulator"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 1158
        },
        "renderpass": [
            {
                "code": "// \"Quadcopter\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nDrag the red ring for manual drone control; release to land.\nRed/green circles show direction home and drone position (also given numerically).\nAutomatic (meandering) return home.\nFixed fisheye camera lens.\nTracking camera zoom depends on drone range.\n(No drone rotation in horizontal plane and no inertial effects for simplicity.)\n*/\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nmat3 acMat;\nvec3 acPos, sunDir;\nvec2 aTilt;\nfloat tCur, dstFar;\nint idObj;\nbool camVu, acHide;\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, wd;\n  float sd, f;\n  vec2 e = vec2 (0.01, 0.);\n  if (rd.y >= 0.) {\n    ro.xz += 2. * tCur;\n    sd = max (dot (rd, sunDir), 0.);\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * (1. - max (rd.y, 0.)) +\n       0.1 * pow (sd, 16.) + 0.2 * pow (sd, 256.);\n    f = Fbm2 (0.02 * (ro.xz + rd.xz * (200. - ro.y) / max (rd.y, 0.001)));\n    col = mix (col, vec3 (1.), clamp (0.2 + 0.8 * f * rd.y, 0., 1.));\n  } else {\n    ro -= (ro.y / rd.y) * rd;\n    f = Fbm2 (ro.xz);\n    vn = normalize (vec3 (f - Fbm2 (ro.xz + e.xy), 0.1, f - Fbm2 (ro.xz + e.yx)));\n    col = mix (vec3 (0.4, 0.3, 0.1), vec3 (0.4, 0.5, 0.2), f) *\n         (1. - 0.1 * Noisefv2 (ro.xz));\n    col = mix (vec3 (0.6, 0.3, 0.3), col,\n       smoothstep (0.05, 0.07, mod (ro.x, 2.)) *\n       smoothstep (0.05, 0.07, mod (ro.z, 2.)));\n    col = mix (vec3 (1., 1., 0.), col,\n       smoothstep (0.1, 0.2, abs (length (ro.xz) - 3.)));\n    col = mix (vec3 (1., 1., 0.), col,\n       smoothstep (0.3, 0.4, length (ro.xz)));\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    w = acPos.xz - ro.xz;\n    wd = (length (acPos.xz) > 0.) ? 0.5 * normalize (acPos.xz) : vec2 (0.);\n    col = mix (vec3 (1., 0.2, 0.2), col, 0.3 +\n       0.7 * smoothstep (0.15, 0.17, length (w + wd)));\n    col = mix (vec3 (0.2, 1., 0.2), col, 0.3 +\n       0.7 * smoothstep (0.15, 0.17, length (w - wd)));\n    col = mix (col, 0.95 * vec3 (0.45, 0.55, 0.7), pow (1. + rd.y, 64.));\n  }\n  return col;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin;\n  dMin = dstFar;\n  q = p - acPos;\n  q.yz = Rot2D (q.yz, - aTilt.y);\n  q.yx = Rot2D (q.yx, - aTilt.x);\n  q.xz = abs (q.xz) - 0.7;\n  q.y -= -0.02;\n  return min (dMin, PrCylDf (q.xzy, 0.415, 0.02));\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 50; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 TransObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (TransObjDf (p + e.xxx), TransObjDf (p + e.xyy),\n     TransObjDf (p + e.yxy), TransObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq, iq;\n  float dMin, d;\n  dMin = dstFar;\n  if (! acHide) {\n    qq = p - acPos;\n    qq.yz = Rot2D (qq.yz, - aTilt.y);\n    qq.yx = Rot2D (qq.yx, - aTilt.x);\n    q = qq;\n    q.y -= 0.05;\n    d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    q.y -= 0.07;\n    d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n    if (d < dMin) { dMin = d;  idObj = 2; }\n    q = qq;\n    q.y -= -0.05;\n    d = PrSphDf (q, 0.17);\n    if (d < dMin) { dMin = d;  idObj = 3; }\n    q = qq;\n    q.xz = abs (q.xz) - 0.7;\n    d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    q.xz += 0.4;\n    q.y -= -0.15;\n    d = PrRCylDf (q.xzy, 0.05, 0.03, 0.2);\n    if (d < dMin) { dMin = d;  idObj = 1; }\n    q.y -= 0.2;\n    q.xz += 0.3;\n    q.xz = Rot2D (q.xz, 0.25 * pi);\n    d = min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.));\n    if (d < dMin) { dMin = d;  idObj = 1; }\n  }\n  q = p;\n  iq.xz = floor ((mod (q.xz, 16.) - 8.) / 8.);\n  q.xz = mod (q.xz, 8.) - 4.;\n  q.y -= 0.1;\n  d = (iq.x != iq.z) ? PrBoxDf (q, vec3 (0.3, 0.1, 0.3)) :\n     PrCylDf (q.xzy, 0.4, 0.1);\n  q = p;\n  d = max (d, PrBox2Df (q.xz, vec2 (64.)));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  d = p.y;\n  if (d < dMin) { dMin = d;  idObj = 6; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 roo, rooO, ror, col, vn, iq, iiq;\n  float dstHit, dstPropel, dstHitO, dstPropelO, f;\n  int idObjT;\n  bool isBg, reflArea, isBdy;\n  isBg = true;\n  dstPropel = TransObjRay (ro, rd);\n  acHide = camVu;\n  dstHit = ObjRay (ro, rd);\n  if (dstHit < dstPropel) dstPropel = dstFar;\n  rooO = ro;\n  dstHitO = dstHit;\n  dstPropelO = dstPropel;\n  isBdy = false;\n  if (dstHit < dstFar && idObj == 6) {\n    ror = ro + rd * dstHit;\n    iq.xz = floor ((mod (ror.xz, 16.) - 8.) / 8.);\n    iiq.xz = floor (ror.xz / 8.);\n    f = length (ror.xz - 8. * (iiq.xz + 0.5));\n    reflArea = (max (iiq.x, iiq.z) < 8. && min (iiq.x, iiq.z) > -9. &&\n       iq.x == iq.z && (iiq.x != 0. || iiq.z != 0.) &&\n       (iiq.x != -1. || iiq.z != -1.));\n    isBdy = (reflArea && f > 3.9 && f < 4.);\n    if (reflArea && f < 3.9) {\n      ro += rd * dstHit;\n      rd = reflect (rd, vec3 (0., 1., 0.));\n      ro += 0.01 * rd;\n      roo = ro;\n      dstPropel = TransObjRay (ro, rd);\n      acHide = false;\n      dstHit = ObjRay (ro, rd);\n      if (dstHit < dstPropel) dstPropel = dstFar;\n    }\n  }      \n  if (dstHit < dstFar && idObj != 6) {\n    ro += rd * dstHit;\n    isBg = false;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == 1) objCol = vec4 (0.95, 0.95, 1., 0.8);\n    else if (idObj == 2) objCol = mix (vec4 (0.3, 0.3, 1., 0.2),\n       vec4 (1., 0., 0., 0.2), step (0., sin (10. * tCur)));\n    else if (idObj == 3) objCol = vec4 (0.1, 0.1, 0.1, 1.);\n    else if (idObj == 4) objCol = vec4 (0.8, 0.5, 0.2, 0.2);\n    col = objCol.rgb * (0.3 + 0.7 * max (dot (vn, sunDir), 0.)) +\n       objCol.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  }\n  if (isBg) col = isBdy ? vec3 (0., 0.3, 0.) : BgCol (ro, rd);\n  if (dstPropelO < dstFar) {\n    vn = TransObjNf (rooO + rd * dstPropelO);\n    col = 0.7 * col + 0.3 * max (dot (vn, sunDir), 0.1);\n  }\n  if (dstPropel < dstFar) {\n    vn = TransObjNf (roo + rd * dstPropel);\n    col = 0.7 * col + 0.3 * max (dot (vn, sunDir), 0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n// 7-segment display based on shaders by Andre (Xsy3zG) and eiffie (MdyGWG)\n\nfloat ShowSeg (vec2 q)\n{\n  return ((1. - smoothstep (0.08, 0.11, abs (q.x))) *\n     (1. - smoothstep (0.46, 0.49, abs (q.x) + abs (q.y)))) *\n     (1. - length (q * vec2 (3.8, 0.9)));\n}\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  const vec2 vh = vec2 (0.5, 0.5), vs = vec2 (0.5, -0.5), vo = vec2 (1., 0.);\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  if (iv != -1) {\n    if (iv != 1) {\n      d += (iv != 2 && iv != 3 && iv != 7) ? ShowSeg (q.xy - vh) : 0.;\n      d += (iv != 4) ? ShowSeg (q.yx - vo) : 0.;\n      d += (iv != 4 && iv != 7) ? ShowSeg (q.yx + vo) : 0.;\n    }\n    d += (iv != 5 && iv != 6) ? ShowSeg (q.xy + vs) : 0.;\n    d += (iv != 0 && iv != 1 && iv != 7) ? ShowSeg (q.yx) : 0.;\n    d += (iv == 0 || iv == 2 || iv == 6 || iv == 8) ? ShowSeg (q.xy - vs) : 0.;\n    d += (iv != 2) ? ShowSeg (q.xy + vh) : 0.;\n  } else d += ShowSeg (q.yx);\n  return d;\n}\n\nfloat ShowNum (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (q.x < 0. || q.y < 0. || q.x >= 1. || q.y >= 1.) return s;\n  q.x *= mxChar;\n  sgn = sign (val);\n  val = abs (val);\n  nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n  idChar = mxChar - 1. - floor (q.x);\n  q.x = fract (q.x);\n  v = val / pow (10., mxChar - idChar - 1.);\n  if (sgn < 0.) {\n    if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n    else ++ v;\n  }\n  if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  return s;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, vuMatT;\n  vec4 mPtr;\n  vec3 ro, rd, u, vd, col;\n  vec2 canvas, uv, us, uc, um, mMid, g;\n  float zmFac, asp, aLim, mRad, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  aTilt = Loadv4 (0).xy;\n  mPtr = Loadv4 (1);\n  dstFar = 200.;\n  acPos = Loadv4 (2).xyz;\n  mMid = vec2 (0.75, 0.55) * vec2 (asp, 1.);\n  mRad = 0.4;\n  uc = uv - mMid;\n  camVu = (length (uc) < mRad);\n  if (camVu) {\n    zmFac = 0.7;\n    uv = - (uv - mMid) / mRad;\n    ro = acPos;\n    rd = normalize (vec3 ((1./0.9) * sin (0.9 * uv), zmFac));\n    rd.yz = Rot2D (rd.yz, 0.5 * pi + aTilt.y);\n    rd.yx = Rot2D (rd.yx, aTilt.x);\n  } else {\n    ro = vec3 (0., 10., 15.);\n    vd = acPos - ro;\n    zmFac = 1.6 + 0.1 * length (vd);\n    vd.y *= 1.2;\n    vd = normalize (vd);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n    rd = vuMat * normalize (vec3 (uv, zmFac));\n  }\n  sunDir = normalize (vec3 (1., 2., 1.));\n  col = ShowScene (ro, rd);\n  um = vec2 (0.38, -0.3) * vec2 (asp, 1.);\n  us = 0.5 * uv - um;\n  f = (length (us) - 0.135) * canvas.y;\n  if (abs (f) < 1.5 || f < 0. && min (abs (us.x), abs (us.y)) * canvas.y < 1.)\n     col = vec3 (0., 0.7, 0.);\n  if (f < 0.) col = mix (vec3 (1., 0., 0.), col, step (3.,\n     abs (length (us + (1./5.5) * aTilt) * canvas.y - 10.)));\n  if (camVu && (length (uc) - mRad) * canvas.y > -3.) col = vec3 (0., 0., 1.);\n  if (! camVu) {\n    um = vec2 (0., -0.97) * vec2 (asp, 1.);\n    uc = uv - um;\n    uc = abs (uc) - vec2 (0.22, 0.05);\n    if (max (uc.x, uc.y) < 0.) {\n      uv -= um + vec2 (0.06, -0.02);\n      us = vec2 (0.1, 0.06) * vec2 (asp, 1.);\n      g = floor (-10. * acPos.xz);\n      col = mix (col, vec3 (0., 0., 1.), 0.2);\n      f = ShowNum (uv + vec2 (0.1, 0.), us, 5., g.x) +\n          ShowNum (uv - vec2 (0.1, 0.), us, 5., g.y);\n      col = mix (col, vec3 (1., 0., 0.), f);\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Quadcopter\" by dr2 - 2016\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float pi = 3.14159;\n\nconst float txRow = 32.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) /\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nvec3 acPos, acVel;\nvec2 canvas, aTilt;\nfloat tCur, autoFly;\n\nvoid SetTilt (inout vec2 aTilt, vec4 mPtr)\n{\n  vec2 um, ud;\n  float aLim, asp, s;\n  aLim = 0.7;\n  if (mPtr.z > 0.) {\n    asp = canvas.x / canvas.y;\n    um = vec2 (0.38, -0.3) * vec2 (asp, 1.);\n    ud = mPtr.xy * vec2 (asp, 1.) - um;\n    if (length (ud) < 0.13 + 0.03) {\n      autoFly = - tCur;\n      aTilt = - min (aLim, 5.5 * length (ud)) * normalize (ud);\n    }\n  } else aTilt = vec2 (0.);\n  if (autoFly > 0.) {\n    s = length (acPos.xz);\n    aTilt = clamp (0.2 * (- acPos.xz / s) * smoothstep (3., 4., s) +\n       0.2 * vec2 (sin (0.5 * tCur), - cos (0.5 * tCur)), - aLim, aLim);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, p;\n  vec2 iFrag;\n  float tCurP, dt;\n  int pxId;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4) discard;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  autoFly = 1.;\n  if (iFrame <= 5) {\n    aTilt = vec2 (0.);\n    acPos = vec3 (0., 0.4, 0.01);\n    acVel = vec3 (0.);\n  } else {\n    p = Loadv4 (0);\n    aTilt = p.xy;\n    tCurP = p.z;\n    autoFly = p.w;\n    acPos = Loadv4 (2).xyz;\n    acVel = Loadv4 (3).xyz;\n    SetTilt (aTilt, mPtr);\n    dt = 20. * (tCur - tCurP);\n    acPos.xz += dt * acVel.xz;\n    acVel.xz = 0.15 * aTilt;\n    acPos.xz += dt * acVel.xz;\n    if (autoFly < 0.) {\n      if (length (acVel) < 0.001) acPos.y += 0.05 * (0.4 - acPos.y) * dt;\n      else acPos.y += 0.05 * (8. - acPos.y) * dt;\n      if (tCur + autoFly > 10.) autoFly = 1.;\n    }\n    if (autoFly > 0.) acPos.y += 0.05 * (2. - acPos.y) * dt;\n  }\n  if (pxId == 0) stDat = vec4 (aTilt, tCur, autoFly);\n  else if (pxId == 1) stDat = mPtr;\n  else if (pxId == 2) stDat = vec4 (acPos, 0.);\n  else if (pxId == 3) stDat = vec4 (acVel, 0.);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}