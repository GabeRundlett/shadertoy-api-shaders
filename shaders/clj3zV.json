{
    "Shader": {
        "info": {
            "date": "1673550895",
            "description": "Heavily based off of https://www.shadertoy.com/view/4tcGDr.",
            "flags": 0,
            "hasliked": 0,
            "id": "clj3zV",
            "likes": 0,
            "name": "SDF raymarching w/ materials",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "distancefield"
            ],
            "usePreview": 0,
            "username": "balt",
            "viewed": 157
        },
        "renderpass": [
            {
                "code": "const float EPSILON = 0.001;\nconst int STEPS = 256;\nconst float NEAR_PLANE = 0.0;\nconst float FAR_PLANE = 100.0;\n\n// Utility\n\nfloat lerp(float a, float b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec3 lerp(vec3 a, vec3 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\nvec2 angleToVec2(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Rotation matrices\n\nmat3 rotX(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  1.0,  0.0,  0.0),\n        vec3(  0.0,  v.x, -v.y),\n        vec3(  0.0,  v.y,  v.x)\n    );\n}\n\nmat3 rotY(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  v.x,  0.0,  v.y),\n        vec3(  0.0,  1.0,  0.0),\n        vec3( -v.y,  0.0,  v.x)\n    );\n}\n\nmat3 rotZ(float theta) {\n    vec2 v = angleToVec2(theta);\n    return mat3(\n        vec3(  v.x, -v.y,  0.0),\n        vec3(  v.y,  v.x,  0.0),\n        vec3(  0.0,  0.0,  1.0)\n    );\n}\n\n// Transformations\n\nvec3 screenToCameraRay(float fov, vec2 pos) {\n    vec2 xy = pos - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat3 makeCameraWorldMatrix(vec3 e, vec3 c, vec3 up) {\n    vec3 f = normalize(c - e);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n// Signed Distance Functions - Primitives\n\nstruct sdfOutput {\n    float signedDistance;\n    vec3 diffuseColor;\n    float roughness;\n    float specularStrength;\n};\n\nsdfOutput sphereSDF(vec3 pos, float radius, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        length(pos) - radius, \n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput metaballSDF(vec3 pos, float threshold, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        (-threshold / length(pos)) + 1.0, \n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput boxSDF(vec3 pos, vec3 size, vec3 color, float roughness, float specularStrength){\n    vec3 q = abs(pos) - size;\n    return sdfOutput(\n        length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),\n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput planeSDF(vec3 pos, vec3 normal, vec3 color, float roughness, float specularStrength){\n    return sdfOutput(\n        dot(pos, normal),\n        color, roughness, specularStrength\n    );\n}\n\nsdfOutput coneSDF(vec3 p, vec2 rh, vec3 color, float roughness, float specularStrength){\n    vec2 q = rh.y*vec2(rh.x,-1.0);\n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n    return sdfOutput(\n        sqrt(d)*sign(s),\n        color, roughness, specularStrength\n    );\n}\n\n// Signed Distance Functions - Operations\n\nsdfOutput unionSDF(sdfOutput a, sdfOutput b) {\n    if (a.signedDistance < b.signedDistance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nsdfOutput intersectSDF(sdfOutput a, sdfOutput b) {\n    if (a.signedDistance > b.signedDistance) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nsdfOutput differenceSDF(sdfOutput a, sdfOutput b) {\n    return intersectSDF(a, sdfOutput(\n        -b.signedDistance,\n        b.diffuseColor,\n        b.roughness,\n        b.specularStrength)\n    );\n}\n\nsdfOutput addSDF(sdfOutput a, sdfOutput b) {\n    return sdfOutput(\n        a.signedDistance + b.signedDistance,\n        lerp(a.diffuseColor, b.diffuseColor, 0.5),\n        lerp(a.roughness, b.roughness, 0.5),\n        lerp(a.specularStrength, b.specularStrength, 0.5)\n    );\n}\n\nsdfOutput lerpSDF(sdfOutput a, sdfOutput b, float t) {\n    return sdfOutput(\n        lerp(a.signedDistance, b.signedDistance, t),\n        lerp(a.diffuseColor, b.diffuseColor, t),\n        lerp(a.roughness, b.roughness, t),\n        lerp(a.specularStrength, b.specularStrength, t)\n    );\n}\n\nsdfOutput invertSDF(sdfOutput a) {\n    return sdfOutput(\n        -a.signedDistance,\n        a.diffuseColor,\n        a.roughness,\n        a.specularStrength\n    );\n}\n\n\n\n// Signed Distance Functions - Scene\n\nsdfOutput sceneSDF(vec3 samplePoint) {   \n    return unionSDF(\n        unionSDF(\n        unionSDF(\n        sphereSDF(\n            samplePoint + vec3(2.0, -1.0, 0.0),\n            1.0,\n            vec3(0.2, 0.7, 0.1),\n            0.7,\n            16.0\n        ),\n        boxSDF(\n            rotY(radians(20.0)) * rotX(radians(10.0)) * (samplePoint + vec3(-1.2, 1.0, 2.0)),\n            vec3(1.0),\n            vec3(0.1, 0.6, 1.0),\n            0.7,\n            2.0\n        )),\n        planeSDF(\n            samplePoint + vec3(0.0, 3.0, 0.0),\n            vec3(0.0, 1.0, 0.0),\n            vec3(ceil((sin((rotY(radians(45.0)) * samplePoint).x * 4.0) + sin((rotY(radians(45.0)) * samplePoint).z * 4.0)) / 2.0)),\n            1.0,\n            16.0\n        )),\n        coneSDF(\n            samplePoint + vec3(-3.0, -2.0, -2.0),\n            vec2(0.5, 2.0),\n            vec3(1.0, 0.1, 0.1),\n            0.7,\n            32.0\n        )\n    );\n}\n\n// Signed Distance Function - Calculation\n\nvec3 calcNormal(vec3 pos) {\n    return normalize(vec3(\n        sceneSDF(vec3(pos.x + EPSILON, pos.y, pos.z)).signedDistance - sceneSDF(vec3(pos.x - EPSILON, pos.y, pos.z)).signedDistance,\n        sceneSDF(vec3(pos.x, pos.y + EPSILON, pos.z)).signedDistance - sceneSDF(vec3(pos.x, pos.y - EPSILON, pos.z)).signedDistance,\n        sceneSDF(vec3(pos.x, pos.y, pos.z + EPSILON)).signedDistance - sceneSDF(vec3(pos.x, pos.y, pos.z - EPSILON)).signedDistance\n    ));\n}\n\n// Illumination\n\nconst vec3 GLOBAL_COLOR = vec3(0.0);\nconst vec3 CLEAR_COLOR = vec3(0.0);\nconst vec3 AMBIENT_COLOR = vec3(0.2);\n\nstruct light{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nvec3 lightSDF(vec3 cameraRay, vec3 position, vec3 normal, vec3 diffuse, float roughness, float specularity) {\n    light[] LIGHTS = light[](\n        light(\n            vec3(0.0, 5.0, 0.0),\n            vec3(1.0),\n            20.0\n        )\n    );\n    vec3 finalColor = GLOBAL_COLOR;\n    for (int i = 0; i < LIGHTS.length(); i++) {\n        vec3 lightDir = normalize(LIGHTS[i].position - position);\n        \n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 diffuseLight = diff * LIGHTS[i].color;\n        \n        float lightDistance = distance(position, LIGHTS[i].position); \n        vec3 reflectDir = reflect(lightDir, normal);\n        float spec = pow(max(dot(cameraRay, reflectDir), 0.0), specularity);\n        vec3 specularLight = roughness * spec * LIGHTS[i].color;\n        \n        float lightStrength = (1.0 - (lightDistance / LIGHTS[i].radius));\n        finalColor += diffuse * (diffuseLight * lightStrength) +\n            (diffuse * AMBIENT_COLOR) +\n            specularLight * lightStrength;\n    }\n    \n    return finalColor;\n}\n\n// Main\n\nstruct sdOutput{\n    float depth;\n    sdfOutput sdf;\n};\n\nsdOutput surfaceDist(vec3 camera, vec3 ray) {\n    float depth = NEAR_PLANE;\n    for (int i = 0; i < STEPS; i++) {\n        sdfOutput sdf = sceneSDF(camera + depth * ray);\n        float dist = sdf.signedDistance;\n        if (dist < EPSILON) {\n            return sdOutput(depth, sdf);\n        }\n        depth += dist;\n        if (depth >= FAR_PLANE) {\n            return sdOutput(FAR_PLANE, sdfOutput(0.0, vec3(0.0), 0.0, 0.0));\n        }\n    }\n    return sdOutput(FAR_PLANE, sdfOutput(0.0, vec3(0.0), 0.0, 0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(CLEAR_COLOR, 1.0);\n    vec3 cameraRay = screenToCameraRay(65.0, fragCoord);\n    vec3 cameraFocus = vec3(0.0, (sin(iTime / 2.0) * 1.5), 0.0);\n    vec3 cameraPos = vec3(sin(iTime) * 12.0, 3.0, cos(iTime) * 12.0);\n    mat3 cameraWorldMatrix = makeCameraWorldMatrix(\n        cameraPos,\n        -cameraFocus,\n        vec3(0.0, 1.0, 0.0)\n    );\n    vec3 worldRay = cameraWorldMatrix * cameraRay;\n    sdOutput sdOut = surfaceDist(cameraPos, worldRay);\n    float d = sdOut.depth;\n    vec3 hitPos = cameraPos + d * worldRay;\n    \n    if (d > FAR_PLANE - EPSILON) {\n        return;\n    }\n    \n    vec3 normal = calcNormal(hitPos);\n    // Output to screen\n    fragColor = vec4(lightSDF(worldRay, hitPos, normal, sdOut.sdf.diffuseColor, sdOut.sdf.roughness, sdOut.sdf.specularStrength), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}