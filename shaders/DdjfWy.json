{
    "Shader": {
        "info": {
            "date": "1690091522",
            "description": "SWS3005_05",
            "flags": 32,
            "hasliked": 0,
            "id": "DdjfWy",
            "likes": 3,
            "name": "SWS3005_05",
            "published": 3,
            "tags": [
                "sws300505"
            ],
            "usePreview": 0,
            "username": "afet",
            "viewed": 210
        },
        "renderpass": [
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    vec4 originalColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 blurColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    fragColor = originalColor + blurColor;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\nconst float PI = 3.14159265358979323;\nconst float FOVY = 20.0 * PI / 180.0;\n\n// SDF parameters\nconst float MAX_DIST = 100.0;\nconst int MAX_MARCHING_STEPS = 100;\nconst float EPSILON = 0.001;\nconst float OFFSET_SURFACE = 10.0; // offset for shadow ray and secondary ray\n\n// shadow parameters \n// greater SHADOW_HARDNESS, harder shadow\nconst float SHADOW_HARDNESS = 128.0; \n\n// lava lamp parameters\n// number of lava blobs\nconst uint LAVA_COUNT = 12u;\n\n// normal bump parameters\n// clinderical texture projection is used for normal bump\nconst float THETA0 = -1.7;\nconst float THETA1 = 0.3;\nconst float DELTA_THETA = THETA1 - THETA0;\nconst float HEIGHT0 = 1.175;\nconst float HEIGHT1 = 1.475;\nconst float DELTA_HEIGHT = HEIGHT1 - HEIGHT0;\n\n// scene parameters\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_ITERATIONS = 2;\nconst int NUM_DOTS = 90;\n\n// material id\nconst int LAVA_LAMP_BODY = 1;\nconst int LAVA_LAMP_GLASS = 2;\nconst int LAVA_LAMP_LAVA = 3;\nconst int FLOOR = 4;\nconst int BACKGROUND = 0;\n\n// random number generator\n// generate a random number in [0, 1]\nfloat random(uint seed) {\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    return float(seed) / 4294967295.0;\n}\n\n// data structures\n\nstruct Ray_t {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\nstruct Dot_t {\n    vec2 position; // position in screen space [-1, 1]\n    float radius;  // radius in screen space\n    vec3 color;    // color\n};\n\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nDot_t Dots[NUM_DOTS];\n\nvoid InitScene() {\n\n    float radius = 4.0;\n\n    // Light 0.\n    Light[0].position = vec3(cos(iTime) * radius, 10.0, sin(iTime) * radius);\n    Light[0].I_a = vec3(0.1, 0.1, 0.1);\n    Light[0].I_source = vec3(0.4, 0.4, 0.4);\n\n    // Light 1.\n    Light[1].position = vec3(8.0, 8.0, 6.0);\n    Light[1].I_a = vec3(0.1, 0.1, 0.1);\n    Light[1].I_source = vec3(1.0, 1.0, 1.0);\n\n    // background material.\n    Material[0].k_d = vec3(1.0, 1.0, 1.0);\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.01 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Silver material.\n    Material[1].k_d = vec3(0.5, 0.5, 0.5);\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Silver material.\n    Material[2].k_d = vec3(1.0, 1.0, 1.0);\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = 2.0 * Material[2].k_d;\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 64.0;\n\n     // Lava material.\n    Material[3].k_d = vec3(0.0, 1.0, 0.0);\n    Material[3].k_a = 0.9 * Material[3].k_d;\n    Material[3].k_r = vec3(0.0, 1.0, 0.0);\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n    // floor material.\n    Material[4].k_d = vec3(0.1, 0.1, 0.1);\n    Material[4].k_a = 0.1 * Material[4].k_d;\n    Material[4].k_r = vec3(1.0, 1.0, 1.0);\n    Material[4].k_rg = 0.9 * Material[4].k_r;\n    Material[4].n = 128.0;\n\n    // Dots\n    for (uint i = 0u; i < uint(NUM_DOTS); i++) {\n        float x = random(i) * 4.0 - 2.0 + 0.05 * sin(iTime + random(i) * 100.0) * sin(iTime + random(i) * 200.0);\n        float y = random(i * 2u) * 2.0 - 1.0 + 0.05 * sin(iTime + random(i) * 100.0) * cos(iTime + random(i) * 200.0);\n\n        Dots[i].position = vec2(x, y);\n        Dots[i].radius = random(i * 3u) * 0.06 + 0.03;\n\n        float r = random(i + 4u) * (0.4 - 0.2) + 0.2;\n        float g = random(i + 3u) * (0.8 - 0.4) + 0.4;\n        float b = random(i + 2u) * (1.0 - 0.6) + 0.6;\n        Dots[i].color = vec3(r, g, b);\n    }\n\n}\n\n//=================== Signed Distance Functions primitives ==================\n// reference: https://iquilezles.org/articles/distfunctions\n\n// signed distance functions operations\nfloat sdfUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdfIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\n// signed distance functions for primitives\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h) {\n    return dot(p, n) + h;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h) {\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0)\n        return length(q) - r1;\n    if (k > a * h)\n        return length(q - vec2(0.0, h)) - r2;\n    return dot(q, vec2(a, b)) - r1;\n}\n//===========================================================================\n\n// signed distance function of lava lamp's glass\nfloat sdLavaLampGlass(vec3 p) {\n    // side \n    float d0 = sdRoundCone(p, 0.423, 0.15, 1.6);\n    float d1 = sdPlane(p, vec3(0.0, -1.0, 0.0), 1.2);\n    float d2 = sdPlane(p, vec3(0.0, 1.0, 0.0), -0.0);\n    float d3 = sdfIntersection(d0, -d1, 0.01);\n    return sdfIntersection(d3, -d2, 0.01);\n}\n\n// signed distance function of lava lamp's body\nfloat sdLavaLampBody(vec3 p) {\n    // body shape\n    float d0 = sdRoundCone(p, 0.423, 0.15, 1.6);\n\n    // top\n    float d1 = sdPlane(p, normalize(vec3(0.5, 1.0, 0.5)), -1.3);\n    float d2 = sdfIntersection(d0, d1, 0.02);\n    float d3 = sdPlane(p, vec3(0.0, -1.0, 0.0), 1.2);\n    float d4 = sdfIntersection(d2, d3, 0.01);\n\n    // bottom\n    float d5 = sdPlane(p, vec3(0.0, -1.0, 0.0), -0.3);\n    float d6 = sdfIntersection(d0, d5, 0.025);\n    float d7 = sdPlane(p, vec3(0.0, 1.0, 0.0), -0.0);\n    float d8 = sdfIntersection(d6, d7, 0.01);\n    float d9 = -sdSphere(p - vec3(0.0, 0.3, 0.0), 0.5);\n    float d10 = sdfIntersection(d8, d9, 0.01);\n\n    return min(d4, d10);\n}\n\n// signed distance function of lava lamp's with glass\nfloat sdLavaLamp(vec3 p) {\n    return min(sdLavaLampBody(p), sdLavaLampGlass(p));\n}\n\n// signed distance function of lava lamp's lava\nfloat sdLavaLampLava(vec3 p) {\n    float d = MAX_DIST;\n    for (uint i = 1u; i <= LAVA_COUNT; i++) {\n        vec3 offset = vec3(0.223 * random(uint(i)) * cos(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 0.5), 0.4 * sin(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 1.0) + 0.5, 0.223 * random(uint(i)) * sin(float(i) / float(LAVA_COUNT) * 2.0 * PI + iTime * 0.5));\n\n        float radius = 0.123 * random(uint(i)) / ((abs(offset.y) + 0.95) * (abs(offset.y) + 0.95));\n\n        d = sdfUnion(d, sdSphere(p - offset, radius), 0.2);\n    }\n    return d;\n}\n\n// signed distance function of background\n// the background is a round box\nfloat sdBackground(vec3 p) {\n    return sdRoundBox(p - vec3(-0.0, -0.5, -0.0), vec3(1.1, 0.01, 1.1), 0.08);\n}\n\n// signed distance function of the scene with glass\nfloat sceneSDF(vec3 p) {\n    float d0 = min(sdLavaLamp(p), sdLavaLampLava(p));\n    float d1 = min(d0, sdBackground(p));\n    return d1;\n}\n\n// signed distance function of the scene without glass\nfloat sceneSDFWithoutGlass(vec3 p) {\n    float d0 = min(sdLavaLampBody(p), sdLavaLampLava(p));\n    float d1 = min(d0, sdBackground(p));\n    return d1;\n}\n\n// get normal of the scene\nvec3 getNormal(in vec3 pos, in bool withoutGlass) {\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    if (withoutGlass)\n        return normalize(e.xyy * sceneSDFWithoutGlass(pos + e.xyy * ep) +\n            e.yyx * sceneSDFWithoutGlass(pos + e.yyx * ep) +\n            e.yxy * sceneSDFWithoutGlass(pos + e.yxy * ep) +\n            e.xxx * sceneSDFWithoutGlass(pos + e.xxx * ep));\n    else\n        return normalize(e.xyy * sceneSDF(pos + e.xyy * ep) +\n            e.yyx * sceneSDF(pos + e.yyx * ep) +\n            e.yxy * sceneSDF(pos + e.yxy * ep) +\n            e.xxx * sceneSDF(pos + e.xxx * ep));\n}\n\n// normal bump\nvec3 normalBump(vec3 n, vec3 p) {\n    // normal bump\n    if (p.y <= HEIGHT1 && p.y >= HEIGHT0) {\n        // surface's tangent space\n        vec3 T = normalize(cross(p, n));\n        vec3 B = normalize(cross(n, T));\n\n        // cylindrical texture coordinates\n        vec2 textureCord = normalize(p.xz);\n        float angle = -atan(textureCord.y, textureCord.x);\n\n        if (angle >= THETA0 && angle <= THETA1) {\n            vec2 uv = vec2((angle - THETA0) / DELTA_THETA, (p.y - HEIGHT0) / DELTA_HEIGHT);\n            vec3 tangentSpacePerturbation = texture(iChannel0, uv).xyz * 2.0 - 1.0;\n            n = normalize(vec3(tangentSpacePerturbation.x * T +\n                tangentSpacePerturbation.y * B +\n                tangentSpacePerturbation.z * n));\n\n        }\n    }\n    return n;\n}\n\n// get material index of hit point\nint getMaterialIndex(in vec3 pos, in bool withoutGlass) {\n    // hit lava lamp body\n    if (sdLavaLampBody(pos) < EPSILON) {\n        return LAVA_LAMP_BODY;\n    }\n    // hit lava lamp glass\n    else if (!withoutGlass && sdLavaLampGlass(pos) < EPSILON) {\n        return LAVA_LAMP_GLASS;\n    }\n    // hit lava lamp lava\n    else if (sdLavaLampLava(pos) < EPSILON) {\n        return LAVA_LAMP_LAVA;\n    }\n    // hit floor\n    else if (sdBackground(pos) < EPSILON) {\n        return FLOOR;\n    }\n    return BACKGROUND;\n}\n\n// soft shadow\n// reference: https://iquilezles.org/articles/rmshadows\nfloat softshadow(in Ray_t ray, in bool withoutGlass) {\n    float res = 1.0;\n    float t = EPSILON;\n    for (int i = 0; i < 256 && t < MAX_DIST; i++) {\n        float h = withoutGlass ? sceneSDFWithoutGlass(ray.o + ray.d * t) : sceneSDF(ray.o + ray.d * t);\n        if (h < EPSILON)\n            return 0.0;\n        res = min(res, SHADOW_HARDNESS * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// Phong lighting\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    float shadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    vec3 R = reflect(-L, N);\n    float N_dot_L = max(0.0, dot(N, L));\n    float R_dot_V = max(0.0, dot(R, V));\n    float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n    return light.I_a * mat.k_a +\n        shadow * light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n}\n\n// find intersection between ray and scene\nbool Intersect(in Ray_t ray, in bool withoutGlass, out vec3 pos, out vec3 normal) {\n    float t = 0.0;\n    float d = 0.0;\n\n    // ray marching\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        pos = ray.o + t * ray.d;\n        d = withoutGlass ? sceneSDFWithoutGlass(pos) : sceneSDF(pos);\n        t += d;\n        if (d < EPSILON || t > MAX_DIST)\n            break;\n    }\n\n    // if we hit something\n    if (t >= 0.0 && d < EPSILON) {\n        pos = ray.o + t * ray.d;\n        normal = getNormal(pos, withoutGlass);\n        // normal bump\n        normal = normalBump(normal, pos);\n        return true;\n    }\n\n    return false;\n}\n\n// cast ray\nvec3 castRay(in Ray_t ray, in bool withoutGlass, in bool insideGlass, out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg, out bool hasHitGlass) {\n    hasHit = Intersect(ray, withoutGlass && insideGlass, hitPos, hitNormal);\n    if (!hasHit)\n        return vec3(texture(iChannel1, ray.d)); // environment map\n\n    // shading\n    vec3 color = vec3(0.0);\n    int materialIndex = getMaterialIndex(hitPos, withoutGlass && insideGlass);\n    hasHitGlass = (materialIndex == LAVA_LAMP_GLASS);\n    if (hasHitGlass) {\n        k_rg = Material[materialIndex].k_rg;\n        return color;\n    }\n\n    // for each light source, make a shadow ray.\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 L = normalize(Light[i].position - hitPos);\n        vec3 V = -ray.d;\n        float shadow = softshadow(Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, L), withoutGlass);\n        // if the shadow ray hits something, then the point is in shadow.\n        color += PhongLighting(L, hitNormal, V, shadow, Material[materialIndex], Light[i]);\n    }\n\n    k_rg = Material[materialIndex].k_rg;\n    return color;\n}\n\n// background\nvec3 background(vec2 uv) {\n    for (int i = 0; i < NUM_DOTS; i++) {\n        vec2 dir = uv - Dots[i].position;\n        float distence_squr = dot(dir, dir);\n        float radius_squr = Dots[i].radius * Dots[i].radius;\n        if (distence_squr < radius_squr) {\n            return Dots[i].color;\n        }\n    }\n    return vec3(1.0, 0.6, 0.25);\n}\n\nfloat FresnelTerm(vec3 Normal, vec3 ViewDir, float Power) {\n    return 0.1 + 0.9 * pow((1.0 - clamp(dot(normalize(Normal), normalize(ViewDir)), 0.0, 1.0)), Power);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    // Position the camera.\n    float radius = 7.0 + sin(iTime);\n    float starting_angle = -35.0 / 180.0 * PI;\n    float ending_angle = 125.0 / 180.0 * PI;\n    float time = abs(sin(iTime)) * (ending_angle - starting_angle) + starting_angle;\n    vec3 cam_pos = vec3(cos(time) * radius, 4.5, sin(time) * radius);\n    vec3 cam_lookat = vec3(0.0, 0.6, 0.0);\n    vec3 cam_up_vec = vec3(0.05 * sin(iTime), 1.0, 0.05 * cos(iTime));\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 color_without_glass = vec3(0.0);\n    vec3 color_with_glass = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n    bool isGlass = false;\n    vec3 glassNormal;\n    bool insideGlass = false;\n\n    // ray tracing without glass\n    for (int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit, hasHitGlass;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = castRay(nextRay, true, insideGlass, hasHit, hitPos, hitNormal, k_rg, hasHitGlass);\n\n        color_without_glass += compounded_k_rg * I_local;\n\n        // if miss hitting something on primary ray, then use background color\n        if (!hasHit) {\n            if (level == 0) {\n               // color_without_glass = background(pixel_pos);\n            }\n            break;\n        }\n\n        compounded_k_rg *= k_rg;\n\n        if (hasHitGlass) {\n            nextRay = Ray_t(hitPos - hitNormal * OFFSET_SURFACE * EPSILON, normalize(refract(nextRay.d, hitNormal, 1.1)));\n            insideGlass = !insideGlass;\n        } else {\n            nextRay = Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, normalize(reflect(nextRay.d, hitNormal)));\n        }\n    }\n\n    // ray tracing with glass\n    compounded_k_rg = vec3(1.0);\n    nextRay = pRay;\n    for (int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit, hasHitGlass;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = castRay(nextRay, false, false, hasHit, hitPos, hitNormal, k_rg, hasHitGlass);\n\n        // if we hit the glass, then we need to calculate the fresnel term\n        // and mix the color with the color without glass\n        // this requires the hit point normal of the glass\n        if (level == 0 && hasHitGlass) {\n            isGlass = true;\n            glassNormal = hitNormal;\n        }\n\n        color_with_glass += compounded_k_rg * I_local;\n\n        // if miss hitting something on primary ray, then use background color\n        if (!hasHit) {\n            if (level == 0) {\n               // color_without_glass = background(pixel_pos);\n            }\n            break;\n        }\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t(hitPos + hitNormal * OFFSET_SURFACE * EPSILON, normalize(reflect(nextRay.d, hitNormal)));\n    }\n\n    // mix the color with glass and the color without glass\n    vec3 I_result;\n\n    if (isGlass) {\n        float fresnel = FresnelTerm(glassNormal, -pRay.d, 6.0);\n        I_result = fresnel * color_with_glass + (1.0 - fresnel) * color_without_glass;\n    } else {\n        I_result = color_without_glass;\n    }\n\n    fragColor = vec4(I_result, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nconst float LuminanceThreshold = 0.50;\n\nfloat Luminance(vec3 color) {\n    const vec3 LuminanceWeights = vec3(-0.2, 0.9, -0.2);\n    return dot(LuminanceWeights, color);\n}\n\nvec4 ThresholdImage(in vec2 fragCoord) {\n    // step 1: read from the original image texture\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // step 2: calculate the luminance of the color\n    float luminance = Luminance(color.rgb);\n    // step 3: threshold the luminance\n    if (luminance >= LuminanceThreshold) {\n        return color;\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ThresholdImage(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\nconst int blurFilterWidth = 51;\n\n// Gaussian blur filter\nconst float weight[blurFilterWidth] = float[blurFilterWidth](0.00450533, 0.00527016, 0.00612551, 0.00707425, 0.00811782, 0.0092559, 0.0104862, 0.0118043, 0.0132032, 0.0146738, 0.0162041, 0.0177798, 0.0193843, 0.0209987, 0.0226025, 0.0241736, 0.025689, 0.0271251, 0.0284589, 0.0296678, 0.0307307, 0.0316286, 0.0323451, 0.0328667, 0.0331838, 0.0332901, 0.0331838, 0.0328667, 0.0323451, 0.0316286, 0.0307307, 0.0296678, 0.0284589, 0.0271251, 0.025689, 0.0241736, 0.0226025, 0.0209987, 0.0193843, 0.0177798, 0.0162041, 0.0146738, 0.0132032, 0.0118043, 0.0104862, 0.0092559, 0.00811782, 0.00707425, 0.00612551, 0.00527016, 0.00450533);\n\nvec4 HorizBlurImage(in vec2 fragCoord) {\n    // step 1: map current fragment's coordinates to threshold image's texel coordinates\n    ivec2 pix = ivec2(fragCoord); // current fragment's coordinates\n    int halfWidth = blurFilterWidth / 2;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // step 2: compute convolution\n    for (int i = -halfWidth; i <= halfWidth; i++) {\n        ivec2 offsetPix = pix + ivec2(i, 0); // offset pixel's coordinates\n        color += texelFetch(iChannel0, offsetPix, 0)        // read from threshold image\n        * weight[i + halfWidth]; // read from blur filter\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = HorizBlurImage(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//============================================================================\n// PROJECT ID: SWS3005_05\n//\n// GROUP NUMBER: 05\n//\n// STUDENT NAME: AFEITI, ABUZHAER\n// NUS User ID.: t0929935\n//\n// STUDENT NAME: CHEN JUNHAO\n// NUS User ID.: t0929862\n//\n// STUDENT NAME: LEI ZEYU\n// NUS User ID.: t0930125\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n//=================== Project Description ==================\n// in order to run this project, \n// please download the normal map from the link below and upload it to iChannel0 of Buffer A\n// if you are using Chrome, you can install the extension link below to upload texture to shadertoy\n//\n// project link: https://www.shadertoy.com/view/DdjfWy\n// normal map link: https://www.dropbox.com/scl/fi/38p0tykkh15wihys1oqrp/normal.png?dl=0&rlkey=l3wxhviyciml25in53jptnhl1\n// extension link: https://chrome.google.com/webstore/detail/shadertoy-custom-texures/jgeibpcndpjboeebilehgbpkopkgkjda\n//==========================================================\n\n\nconst int blurFilterWidth = 51;\n\n// Gaussian blur filter\nconst float weight[blurFilterWidth] = float[blurFilterWidth](0.00450533, 0.00527016, 0.00612551, 0.00707425, 0.00811782, 0.0092559, 0.0104862, 0.0118043, 0.0132032, 0.0146738, 0.0162041, 0.0177798, 0.0193843, 0.0209987, 0.0226025, 0.0241736, 0.025689, 0.0271251, 0.0284589, 0.0296678, 0.0307307, 0.0316286, 0.0323451, 0.0328667, 0.0331838, 0.0332901, 0.0331838, 0.0328667, 0.0323451, 0.0316286, 0.0307307, 0.0296678, 0.0284589, 0.0271251, 0.025689, 0.0241736, 0.0226025, 0.0209987, 0.0193843, 0.0177798, 0.0162041, 0.0146738, 0.0132032, 0.0118043, 0.0104862, 0.0092559, 0.00811782, 0.00707425, 0.00612551, 0.00527016, 0.00450533);\n\nvec4 VertBlurImage(in vec2 fragCoord) {\n    // step 1: map current fragment's coordinates to threshold image's texel coordinates\n    ivec2 pix = ivec2(fragCoord); // current fragment's coordinates\n    int halfWidth = blurFilterWidth / 2;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // step 2: compute convolution\n    for (int i = -halfWidth; i <= halfWidth; i++) {\n        ivec2 offsetPix = pix + ivec2(0, i); // offset pixel's coordinates\n        color += texelFetch(iChannel0, offsetPix, 0)        // read from threshold image\n        * weight[i + halfWidth]; // read from blur filter\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = VertBlurImage(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}