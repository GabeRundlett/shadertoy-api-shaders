{
    "Shader": {
        "info": {
            "date": "1642434980",
            "description": "Calculation can be reset by pressing R. Camera can move around with WASD. There is a progress bar, which shows the Global Illumination calculation progress. \n\nFor every pixel 4096 Global Illumination Rays are traced.",
            "flags": 48,
            "hasliked": 0,
            "id": "7dfcRX",
            "likes": 3,
            "name": "Global Illumination in RT",
            "published": 3,
            "tags": [
                "raytracing",
                "gi",
                "globalillumination"
            ],
            "usePreview": 0,
            "username": "Pro_Coder",
            "viewed": 339
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n\n    vec4 dataGI = GET(iChannel1, GI_DATA);\n    vec4 indirectLight = texture(iChannel2, fragCoord/iResolution.xy);\n    int frame = iFrame - int(dataGI.y);\n    int now = frame%(MAX_INDEX+1);\n    \n    float percent = min(1., float(frame)/float(MAX_INDEX));\n    if(percent != 1. && uv.y > 0.95){\n        if(abs(uv.x) < 0.25){\n            \n            float px = (uv.x + 0.25)*2.;\n            \n            if(px <= percent) fragColor = vec4(1.);\n            else fragColor = vec4(vec3(0.0), 1.);\n            return;\n        }\n    }\n    \n    \n    //Screen coordinates from -1 to 1.\n    uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    //output color\n    vec3 col = vec3(0.0);\n\n    world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n    world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    if(isKey(KEY_I, IS_PRESSED, iChannel0)){\n        fragColor = vec4(indirectLight.rgb, 1.);\n        return;\n    }\n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    \n    vec3 light = indirectLight.rgb + state.light;\n    col = state.mat.color * light;\n     \n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define KEYBOARD_CHANNEL iChannel0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(GI_DATA)){\n            vec4 data = GET(iChannel1, GI_DATA);\n            if(isKey(KEY_R, IS_PRESSED, KEYBOARD_CHANNEL)){\n                fragColor = vec4(1., float(iFrame), 0., 0.);\n            }else{\n                fragColor = vec4(0., data.y, 0., 0.);\n            }\n            \n        }\n        else if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(iChannel1, CAM_POS_TEXEL);\n            vec4 vdir = GET(iChannel1, VIEW_DIR_TEXEL);\n            vec3 tdir = cross(WORLD_NORMAL, vdir.xyz);\n            float speed = MOVE_SPEAD;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED, KEYBOARD_CHANNEL)){//forward\n                pos.xyz += vdir.xyz * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED, KEYBOARD_CHANNEL)){//backward\n                pos.xyz -= vdir.xyz * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED, KEYBOARD_CHANNEL)){//left\n                pos.xyz += tdir * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED, KEYBOARD_CHANNEL)){//right\n                pos.xyz -= tdir * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED, KEYBOARD_CHANNEL)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                float angleXZ = atan(viewDirection.x, viewDirection.z);\n                angleXZ -= ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05; \n                viewDirection.xyz = normalize(vec3(sin(angleXZ), viewDirection.y, cos(angleXZ)));\n            }\n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 1.0);\n\n         }    \n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n#define PI 3.1415926\n\n//World stuff\n#define LOOK_AT_POSITION vec3(2.0, -2., 0.0)\n\n#define CAM_START_POS vec3(-4., -2., 1.)\n#define CAM_DIS_TO_SCREEN 1.0\n#define WORLD_NORMAL vec3(0.0, 1.0, 0.0)\n#define MOVE_SPEAD 0.1\n\n//Saving variables\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n#define GI_DATA         ivec2(0, 2) \n\n\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type, sampler2D channel){\n    return texture( channel, vec2(checkKey, type)).r > 0.0;\n}\n\n// ----------------------------------------------- //\n//                                              \n//\n//                    Render\n//\n//\n//\n// ----------------------------------------------- //\n\n//defines the GI ray amount. Set to 4, 8, 12, 16, 20, 24, 28, 32, ... 512, ...\n#define AMOUNT_W 32\n#define AMOUNT_H (AMOUNT_W/4)\n#define MAX_INDEX (AMOUNT_W*AMOUNT_H)\n#define PER_FRAME 2\n\n\n#define EXTRA_BOXES\n//#define SHOW_NORMALS\n#define RENDER_DISTANCE 40.\n#define MAX_STEPS 1000\n#define MIN_DISTANCE 0.00001\n\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n};\n\nstruct Material\n{\n    vec3 color;\n    bool lightSource;\n    vec3 lightColor;\n};\n\n//Objects\n#define NO_HIT_MATERIAL Material(vec3(0.0, 0.5, 1.0), false, vec3(1.0))\n#define NO_HIT_ID 0\n#define UNKNOWN_ID -1\n\n//lights. Must also be added to the lightsources array below!\n#define SPHERE_LIGHT_1\n#define SPHERE_LIGHT_1_MATERIAL Material(vec3(1.0), true, vec3(1.0, 1.0, 0.7))\nconst Sphere sphere_light_1 = Sphere(vec3(0.0, -2.0, 0.0), 0.1);\n//#define SPHERE_LIGHT_2\n#define SPHERE_LIGHT_2_MATERIAL Material(vec3(1.0), true, vec3(0.0, 0.2, 0.0))\nconst Sphere sphere_light_2 = Sphere(vec3(3.0, -2.0, 4.0), 0.1);\n\n\n\n//other scene stuff\n#define BOX_2        \nconst Box box_2 = Box(vec3(1.0, -3.5, -2.), vec3(2., 2., 2.));\n#define BOX_3        \nconst Box box_3 = Box(vec3(2.5, -0.5, 1.), vec3(4., 8., 1.));\n#define GROUND \nconst Box ground_ = Box(vec3(0.0, 5.0, 0.0), vec3(10., 1., 10.));\n#define GREY_WALL \nconst Box grey_wall = Box(vec3(0., 0., 5.), vec3(10., 10., 1.));\n#define RED_WALL \nconst Box red_wall = Box(vec3(5., 0., 0.), vec3(1., 10., 10.));\n#define GREEN_WALL\nconst Box green_wall = Box(vec3(-5., 0., 0.), vec3(1., 10., 10.));\n\n\n\n#define BOX_2_MATERIAL        Material(vec3(0.0, 0.0, 1.0), false, vec3(0.0))\n#define GROUND_MATERIAL       Material(vec3(.5),            false, vec3(0.0))\n#define RED_WALL_MATERIAL     Material(vec3(1., 0., 0.),    false, vec3(0.0))\n#define GREEN_WALL_MATERIAL   Material(vec3(0., 1., 0.),    false, vec3(0.0))\n#define BOX_3_MATERIAL        Material(vec3(.3, .3, .3),    false, vec3(0.0))\n\n\n\n\n//world information and current frame information\nstruct World\n{\n    vec4 camPosition; // cam pos (xyz) and distanceToScreen (w)\n    vec3 viewDirection;\n    vec3 rayDirection;\n} world;\n\n\nstruct LightSource\n{\n    vec3 pos;\n};\n\nconst LightSource lightSources[] = LightSource[](\n                                //LightSource(sphere_light_2.position),\n                                LightSource(sphere_light_1.position)\n                            );\n\nconst Material materials[] = Material[12](\n                              NO_HIT_MATERIAL,      //0\n                              Material(vec3(0.7, 0.1, 0.66), false, vec3(0.0)),      //1\n                              SPHERE_LIGHT_1_MATERIAL,//2\n                              Material(vec3(250./255., 179./255., 27./255.), false, vec3(0.0)),      //3\n                              BOX_3_MATERIAL ,      //4\n                              SPHERE_LIGHT_2_MATERIAL,      //5\n                              GROUND_MATERIAL,      //6\n                              BOX_2_MATERIAL,       //7\n                              GROUND_MATERIAL,      //8\n                              GROUND_MATERIAL,      //9\n                              RED_WALL_MATERIAL,    //10\n                              GREEN_WALL_MATERIAL   //11\n                            );\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nmat3 rotAroundYAxis(float angle){\n   return mat3( cos(angle) , 0.,  sin(angle),\n                0.         , 1.,  0.        ,\n                -sin(angle), 0.,  cos(angle)); \n}\n\nmat3 rotAroundZAxis(float angle){\n   return mat3( cos(angle) , -sin(angle), 0,\n                sin(angle) , cos(angle) , 0.,\n                0.         , 0.         , 1.); \n}\n\n\n// normal - normal vector of surface, must be normalized\n// index - between 0 and MAX_INDEX\n//\n// returns new ray direction\nvec3 getNextGIRayDirection(vec3 normal, int index){\n    mat3 rotateBack;\n    \n    if(abs(normal.y) < 0.99){\n        float angleBetweenXZ = acos(dot(normalize(normal.xz), vec2(1., 0.))) * sign(normal.z == 0.0 ? 1.0 : normal.z);\n        float angleBetweenXY = acos(dot(normal, vec3(0., 1., 0.))); //both must be normalized\n\n        //This matrix can transform the vector (0, 1, 0) into the given normal vector\n        //Note: this doesn't work if the normal vector already is (0, 1, 0)!\n        rotateBack =  rotAroundZAxis(-angleBetweenXY)*rotAroundYAxis(-angleBetweenXZ);\n    }\n    \n    vec3 n = vec3(0., 1., 0.);\n    \n    if(index != AMOUNT_H*AMOUNT_W){    \n        int indexH = index % AMOUNT_H;\n        float xy = float(indexH+1) * (PI / float(AMOUNT_H*2+1)) ;\n        float xz = float(index / AMOUNT_H) * ((PI*2.) / float(AMOUNT_W));\n        n *= rotAroundZAxis(xy);\n        n *= rotAroundYAxis(xz);\n    }\n    \n    //rotate back. If normal.y is 1, we do not need to rotate back. Sometimes we have precision issues\n    //so check against 0.99 instead\n    if(abs(normal.y) < 0.99) n*=rotateBack;\n    else n.y *= sign(normal.y);\n    \n    return n;\n}\n\n//functions\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\n\n\nfloat sdfSphere(vec3 pos, Sphere s){\n    return length(pos - s.position) - s.radius;\n}\n\nfloat sdfBox(vec3 p, Box box){\n    p -= box.center;\n    vec3 d = abs(p) - box.size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\n\nint getDistance(vec3 pos, out float dis){\n    dis = RENDER_DISTANCE * 2.;\n    float sphereLight = 100.;\n    float sphereLight2 = 100.;\n    float box2 = 100.;\n    float ground = 100.;\n    float greyWall = 100.;\n    float redWall = 100.;\n    float greenWall = 100.;\n    \n    #ifdef SPHERE_LIGHT_1\n        sphereLight = sdfSphere(pos, sphere_light_1);   \n        dis = min(dis, sphereLight);\n    #endif\n    \n    #ifdef SPHERE_LIGHT_2\n        sphereLight2 = sdfSphere(pos, sphere_light_2);   \n        dis = min(dis, sphereLight2);\n    #endif\n    \n    #ifdef BOX_2\n        box2 = sdfBox(pos, box_2);\n        //box2 = min(box2, rotTest(pos));\n        dis = min(dis, box2);\n    #endif\n    \n    \n    #ifdef GROUND\n        //dublicate the Ground from the ceiling to the ground\n        ground = sdfBox(vec3(pos.x, abs(pos.y), pos.z), ground_);\n        dis = min(dis, ground);\n    #endif\n    \n    #ifdef GREY_WALL\n        greyWall = sdfBox(vec3(pos.x, pos.y, abs(pos.z)), grey_wall);\n        dis = min(dis, greyWall);\n    #endif\n    \n    #ifdef RED_WALL\n        redWall = sdfBox(pos, red_wall);\n        dis = min(dis, redWall);\n    #endif\n    \n    #ifdef GREEN_WALL\n        greenWall = sdfBox(pos, green_wall);\n        dis = min(dis, greenWall);\n    #endif\n    \n    #ifdef EXTRA_BOXES\n        float b1 = sdfBox(pos - vec3(1.5, 3.5, 1.5), box_2);\n        dis = min(dis, b1);\n\n        float b2 = sdfBox(pos - vec3(-2., 3., -1.), box_2);\n        dis = min(dis, b2);\n    #endif\n    \n    #ifdef BOX_3\n        float box3 = sdfBox(pos, box_3);\n        dis = min(dis, box3);\n    #endif\n         \n    if(dis <= MIN_DISTANCE){\n        if(dis == sphereLight){\n            return 2;\n        }else if(dis == sphereLight2){\n            return 5;\n        }else if(dis == box2){\n            return 7;\n        }else if(dis == ground || dis == greyWall){\n            return 9;\n        }else if(dis == redWall){\n            return 10;\n        }else if(dis == greenWall){\n            return 11;\n        }\n        #ifdef EXTRA_BOXES\n        else if(dis == b1){\n            return 1;\n        }else if(dis == b2){\n            return 3;\n        }\n        #endif\n        #ifdef BOX_3\n        else if(dis == box3){\n            return 4;\n        }\n        #endif\n    }else if(dis > MIN_DISTANCE){\n        return NO_HIT_ID;\n    }\n\n    return UNKNOWN_ID;\n}\n\nfloat getDistance(vec3 pos){\n    float d;\n    getDistance(pos, d);\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nint rayMarch(inout vec3 pos, vec3 rd, float fact, out float dis){\n    \n    int outId;\n    dis = MIN_DISTANCE*90.;\n    float cDis = RENDER_DISTANCE*2.;\n    \n    pos = pos + rd * dis;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n       outId = getDistance(pos, cDis);\n       cDis *= fact;\n       \n       \n       if(cDis <= MIN_DISTANCE){\n           return outId;\n           \n       }else if(dis > RENDER_DISTANCE){\n           return NO_HIT_ID;\n           \n       }\n       \n       dis += cDis;\n       pos = pos + rd * cDis;\n       \n    }\n    \n    return UNKNOWN_ID;\n}\n\n\nvec3 getDirectLight(vec3 p, vec3 normal){\n\n    vec3 outLight = vec3(0.0);\n\n    //tempVars\n    vec3 lightDirection;\n    vec3 pCopy;\n    float lightDis;\n    int id;\n    Material mat;\n\n    for(int i = 0; i < lightSources.length(); i++){\n        lightDirection = normalize(lightSources[i].pos - p);\n        pCopy = p;\n        id = rayMarch(pCopy, lightDirection, 1., lightDis);\n        vec3 dist = lightSources[i].pos - pCopy;\n        if(dot(dist, dist) < 1.){\n            //We hit the actual Lightsource, we wanted to hit.\n            //Note, this does not work, if the lightsources are too big\n            //or to close to each other!\n            mat = materials[id];\n            outLight += mat.lightColor * dot(normal, lightDirection);\n        }\n        \n    }\n    \n    return outLight;\n}\n\n\nstruct State\n{\n    bool isSky;\n    vec3 newPos;\n    vec3 normal;\n    Material mat;\n    vec3 light;\n    float dis;\n};\n\nState stateMarch(vec3 pos, inout vec3 rd){\n    vec3 p = pos;\n    float dis;\n    \n    //hit\n    int hitId = max(0, rayMarch(p, rd, 1., dis)); \n    Material mat = materials[hitId];\n    vec3 normal = getNormal(p);\n    \n    if(hitId == NO_HIT_ID){\n        return State(true, p, vec3(0.), mat, mat.lightColor, dis);\n    }\n           ;\n    vec3 light = getDirectLight(p, normal);\n    \n    return State(false, p, normal, mat, light, dis); \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    //output color\n    vec4 info = texture(iChannel0, fragCoord/iResolution.xy);\n   \n    vec3 col = vec3(0.0);\n\n    world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n    world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    \n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    \n    if(state.isSky) return;\n    \n    col = state.mat.color;\n\n    //Global Illumination\n    vec4 dataGI = GET(iChannel1, GI_DATA);\n    vec3 rayDirectionGI;\n    State stateGI;\n    State stateDL;\n    vec3 lrd;\n    float lightGI = info.w;\n    int frame = iFrame - int(dataGI.y);\n    int now = frame%(MAX_INDEX+1);\n    if(dataGI.x == 1.0){\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }else{\n        if(frame <= MAX_INDEX){\n            \n            for(int i = now; i < (now + PER_FRAME); i++){\n                rayDirectionGI = getNextGIRayDirection(state.normal, i);\n                stateGI = stateMarch(state.newPos, rayDirectionGI);                \n                \n                if(!stateGI.mat.lightSource && !stateGI.isSky) {\n                    //GI ray did not hit a lightSource!\n                    vec3 light = stateGI.light / float(MAX_INDEX*4);\n                    info.rgb += stateGI.mat.color * light;\n                }else if(stateGI.isSky){\n                    info.rgb += stateGI.light / float(MAX_INDEX*4);\n                }else{\n                    //GI ray hit a light source!\n                    //In Theory, it would be possible to calculate the Direct light also with GI,\n                    //but that doesnt really work for me, cause I get a lot of Artifcats\n                    //Maybe it works with a really high amount of GI rays\n                    //Or more GI rays in the direction of the light source\n                    //info.rgb += stateGI.mat.lightColor * dot(stateGI.newPos, stateGI.normal) / float(MAX_INDEX/10);\n                }\n            }\n        }\n    }\n    info.w = lightGI;\n      \n    fragColor = info;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}