{
    "Shader": {
        "info": {
            "date": "1635170671",
            "description": "test of a futuristic force shield",
            "flags": 32,
            "hasliked": 0,
            "id": "sdKXzd",
            "likes": 31,
            "name": "shield field",
            "published": 3,
            "tags": [
                "bloom",
                "shield"
            ],
            "usePreview": 0,
            "username": "mdb",
            "viewed": 1301
        },
        "renderpass": [
            {
                "code": "//apply bloom effect\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec3 bloom(vec2 uv){\n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j){\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j){\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i){\n        vec3 c = texture(iChannel0, uv + vec2(0, i) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n    return final_colour/(Z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n    col += 0.5*bloom(uv);\n    col = clamp(col, 0.0, 1.0);\n    col = col*col*(3.0 - 2.0*col);\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.8 );\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 iSphere(vec3 ro, vec3 rd){\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - 1.0;\n\tfloat delta = b*b - c;\n\tif(delta < 0.0) return vec2(-1.0);\n    return -b + vec2(-1.0, 1.0)*sqrt(delta);\n}\n\nvec4 hexagon( vec2 p ) //from https://www.shadertoy.com/view/Xd2GR3\n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 pi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(pi.x + pi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( pi + ca - cb*ma, e, f );\n}\n\nvec3 trace(vec3 ro, vec3 rd){\n       vec2 sphere = iSphere(ro, rd);\n       float plane = -(ro.y - 0.2)/rd.y;\n       if(plane < 0.0 && sphere.x < 0.0) return vec3(0.1);\n       if((plane > 0.0 && plane < sphere.x)|| sphere.x < 0.0){\n           float d = 0.02/(abs(length(ro + plane*rd) - 1.0)+0.01);\n           return vec3(0.1 + 0.05/(plane+1.0)) + vec3(0.690, 0.494, 0.905)*d;\n       }else{\n           vec3 col = vec3(0.0);\n           vec3 p = ro + sphere.x*rd;\n           vec3 normal = p;\n           vec2 uv = mod(vec2(atan(p.x, p.z)/3.14195+0.5 + iTime*0.05, p.y*0.5+0.5), vec2(1.0));\n           vec4 hexa = hexagon(uv*29.4);\n           \n           float frs = 1.0 + dot(normal, rd);\n           frs = max(frs, 1.0 - abs((p.y - 0.2)*7.0));\n           frs = pow(frs, 3.0)*3.0;\n           col += vec3(0.690, 0.494, 0.905)*frs;\n           col += 7.0*vec3(0.376, 0.333, 0.847)*smoothstep(0.05, 0., hexa.z)*max(0.01, frs);\n           col += vec3(0.121, 0.741, 0.615)*smoothstep(0.3, 0., hexa.z)*max(0.1, frs);\n           col += vec3(0.121, 0.741, 0.615)*0.1;\n           if(sphere.y < plane){\n               p = ro + sphere.y*rd;\n               col += vec3(0.666, 0.996, 0.839)*vec3(0.376, 0.333, 0.847)*pow(max(0.0, 1.0 - abs((p.y - 0.2)*5.0)), 3.0);\n           }\n           \n           if(plane > 0.0){\n               float d = 0.2/(abs(length(ro + plane*rd) - 1.0)+0.1);\n               col += vec3(0.666, 0.996, 0.839)*vec3(0.690, 0.494, 0.905)*d;\n           }\n         \n           return vec3(col);\n       }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0)*1.7;\n    vec3 dir0 = normalize(-camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(dir0, up));\n    up = cross(dir0, right);\n    \n    vec3 ro = camPos;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < AA; i++){\n        for(int j = 0; j < AA; j++){\n           vec3 rd = normalize(dir0 \n                       + up*(uv.y+float(j)/iResolution.y/float(AA))\n                       + right*(uv.x+float(i)/iResolution.x/float(AA)));\n            col += trace(ro, rd); \n        }\n    }\n    col /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//apply bloom effect\nfloat normpdf(in float x, in float sigma){\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //declare stuff\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    \n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        vec3 c = texture(iChannel0, (fragCoord.xy+vec2(i, 0)) / iResolution.xy).rgb;\n        final_colour += kernel[kSize+i]*c;\n  \n    }\n\n\n    fragColor = vec4(final_colour/(Z), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float sigma = 7.0;\nconst int mSize = 30;\n\n#define AA 2",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}