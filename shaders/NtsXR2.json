{
    "Shader": {
        "info": {
            "date": "1626088610",
            "description": "idk why, just saw Kamoshika's toy and had a brief spurt of inspiration which, oddly, actually resulted in working code that's somewhat post-worthy, so enjoy!",
            "flags": 0,
            "hasliked": 0,
            "id": "NtsXR2",
            "likes": 13,
            "name": "Digits7",
            "published": 3,
            "tags": [
                "7segment",
                "digits",
                "print",
                "numeric"
            ],
            "usePreview": 0,
            "username": "spalmer",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "// had some brief spurt of inspiration when looking at this toy\n// Simple 7-segment Numbers by Kamoshika https://shadertoy.com/view/ftsSzB\n// but code is completely original by spalmer.  hope it's useful!\n\n// returns local (non-Euclidean metric) distance to segment edge\nfloat digit7(vec2 q, int n)\n{ // could add a few more 'digit' glyphs for minus sign and decimal point\n\tconst int digitsegs[10] = int[] ( \n\t\t95,10,118,122,43,121,125,26,127,123\n\t\t);\n\tif (n < 0 || n >= digitsegs.length()) return -1.; // just in case, array bound check\n\tint segs = digitsegs[n];\n\tconst ivec2 segpos[7] = ivec2[] ( \n\t\t  ivec2(-1,1), ivec2(1,1), ivec2(-1,-1), ivec2(1,-1) // 4 vertical segments\n\t\t, ivec2(0,2), ivec2(0,0), ivec2(0,-2) // 3 horizontal segments\n\t\t// maybe a period TODO\n\t\t);\n\tfloat d = 3.4e38;\n\tfor (int i = segpos.length(); i-- > 0; ) {\n\t\tif ((segs & (1 << i)) == 0) continue;\n\t\tvec2 p = vec2(segpos[i]); //vec2(.0, .0); \n\t\tp *= vec2(.45, .45);\n\t\tp = q - p; //p -= q; // doesn't matter\n\t\tbool vertical = i < 4;\n\t\t//bool period = false;\n\t\t//bool minus = false;\n\t\tif (vertical) p = p.yx; // rotate some 90degrees\n\t\tp = abs(p);\n\t\tvec2 w = vec2(.35, .0); //vec2(period ? 0. : .35, 0.); //\n\t\tp -= w;\n\t\tp = max(p, vec2(0));\n\t\tfloat dx = (p.x + p.y);\n\t\td = min(d, dx);\n\t}\n\td *= sqrt(.5); // correct for metric\n\treturn d - .05; // seg thickness\n}\n\nvoid digits7(inout vec4 o, vec4 c, vec2 q, vec2 R, uint value)\n{\n\tfloat d = 3.4e38;\n    //value %= 10000u;\n\tfor (int i = 4; i-- > 0; ) {\n\t\td = min(d, digit7(q, int(value%10u)));\n\t\tvalue = value / 10u;\n\t\tq.x += 1.25;\n\t}\n\tfloat a = clamp(.5 - .25 * R.y * d, 0., 1.); // antialias edge\n    a = mix(a, 1., exp2(-2. * max(0., d)) * .3 * (1. - abs(sin(3.14*iTime)))); // glow effect added 2023-3-11\n\to = mix(o, c, a);\n}\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n\tvec2 R = iResolution.xy\n\t, q = (u * 2. - R) * .5 / R.y;\n\to = vec4(0);\n    uint n = uint(10. * iTime); //iFrame / 4); //\n\tdigits7(o, vec4(1.,.0,0,1), q * 4. - vec2(2. + .5*q.y, 0), R, n);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}