{
    "Shader": {
        "info": {
            "date": "1471941280",
            "description": "My attempt to create a solution for volumetric light. Based on attic: https://www.shadertoy.com/view/Mdl3Rr",
            "flags": 0,
            "hasliked": 0,
            "id": "4tc3Wf",
            "likes": 21,
            "name": "Raytraced Volumetrics",
            "published": 3,
            "tags": [
                "noise",
                "raytracer",
                "fbm",
                "shadow",
                "lighting",
                "perlin",
                "volumetric",
                "raytraced",
                "smoke"
            ],
            "usePreview": 1,
            "username": "jackdavenport",
            "viewed": 1604
        },
        "renderpass": [
            {
                "code": "#define VOLUME_SAMPLES 64\n\nstruct Hit { vec3 p; vec3 n; int id; };\n\nHit intersectSphere(vec3 ori, vec3 dir, vec3 p, float r) {\n    \n    float a = dot(dir,dir), b = 2. * dot(dir,ori-p), c = dot(ori-p,ori-p)-(r*r);\n    float d = (b*b)-4.*a*c;\n    float l = (-b-sqrt(d))/(2.*a);\n    \n    vec3 pos = ori+dir*l;\n    return Hit(pos,normalize(pos-p),(d >= 0. && l >= 0.) ? 0 : -1);\n    \n}\nHit intersect(vec3 ori, vec3 dir) {\n\treturn intersectSphere(ori,dir,vec3(0.),1.);   \n}\n\nvec3 getLightVector(vec3 p) {\n\treturn vec3(10.*cos(iTime),0.,3.)-p;\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t  -0.80,  0.36, -0.48,\n\t\t\t  -0.60, -0.48,  0.64 );\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\nfloat fbm (vec3 p)\n{\n\tfloat f;\n\tf  = 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); //p = m*p*2.01;\n\t//f += 0.0625*noise( p );\n\treturn f;\n}\n\nvec3 calcScatter(vec3 ori, vec3 dir, Hit hit, vec2 fc) {\n    vec3 sum = vec3(0.);\n    float maxDst = min(5., distance(ori,hit.p));\n    float weight = 1. / float(VOLUME_SAMPLES);\n    float stepAm = maxDst * weight;\n    vec3 p = ori;\n    \n    p += dir*(noise(vec3(2.*fc,iTime))*.075);\n    for(int i = 0; i < VOLUME_SAMPLES; i++) {\n        vec3 lv = getLightVector(p);\n        vec3 ld = normalize(lv);\n        Hit sh = intersect(p, ld);\n        if(sh.id < 0) {\n       \t\tsum += fbm(p+vec3(iTime,0.,iTime*.2));\n        }\n        p += dir * stepAm;\n    }\n    \n    return sum * weight * .5;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ori = vec3(sin(iTime),0.,-4.+cos(iTime));\n    vec3 dir = vec3(uv, 1.);\n    dir = normalize(dir);\n    \n    vec3 col = vec3(0.);\n    Hit  hit = intersect(ori, dir);\n    if(hit.id == 0) {\n    \tvec3 lv = getLightVector(hit.p);\n        vec3 ld = normalize(lv);\n        vec3  r = normalize(reflect(dir, hit.n));\n        vec2 uv = asin(hit.n.xy) / 3.14159 + .5;\n        \n        vec3 tx = texture(iChannel0, uv).xyz;\n        float d = max(dot(ld,hit.n),0.);\n        float s = pow(max(dot(ld,r),0.),20.+40.*tx.z);\n        col = tx*(.15+d)+s;\n    }\n    \n    col += calcScatter(ori,dir,hit,fragCoord);\n    \n    vec3 lv = getLightVector(ori);\n    vec3 ld = normalize(lv);\n    float s = 1.;\n    if(intersect(ori,ld).id > -1) {\n    \ts = 0.;\n    }\n    col += pow(max(dot(dir,ld), 0.), 90.)*s;\n    \n\tfragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}