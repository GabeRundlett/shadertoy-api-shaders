{
    "Shader": {
        "info": {
            "date": "1688029251",
            "description": "All year long I'm going to just focus on truchet tiles and the likes! ",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2yzc",
            "likes": 17,
            "name": "Year of Truchets #045",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "cube",
                "truchet"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 270
        },
        "renderpass": [
            {
                "code": "/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Year of Truchets #045\n    06/29/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n*/\n\n\n#define R iResolution\n#define T iTime\n#define M iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MIN_DIST    1e-4\n#define MAX_DIST    50.\nfloat tspeed=0.,speed,tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.;\nvec3 hp,hitpoint;\nvec2 gid, sid;\nmat2 grot,srot;\n\nconst float sz = 2.5;\nconst float hf = sz/2.;\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nfloat lsp(float b, float e, float t){return clamp((t-b)/(e-b),0.,1.); }\nfloat eoc(float t){return (t = t-1.)*t*t+1.; }\n\n//@iq sdf's\nfloat box( vec3 p, vec3 b ){ vec3 q = abs(p) - b;return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);}\nfloat box( vec2 p, vec2 b ){vec2 d = abs(p)-b;return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0.);\n    p.z -= T;\n    vec3 q = p;\n    \n    vec2 id = floor((p.xz+hf)/sz);\n    p.xz = mod(p.xz+hf,sz)-hf;\n    \n    float h = hash21(vec2(id.x,0));\n    float f = hash21(id);\n\n    float s = .5+.5*sin((h+id.y*2.5)*.5+T);\n    s += .5+.5*cos((h+id.x*2.5)*.5+T);\n    \n    p.y -= 1.75+s;\n    grot = rot(f*PI-speed);\n    p.zy *= grot;\n    \n    float d = box(p,vec3(.5));\n    if(d<res.x) {\n        res = vec2(d,2);\n        hp = p+id.x+id.y;\n        sid = id;\n    }\n    \n    float fl = q.y;\n    if(fl<res.x) {\n        res = vec2(fl,1);\n        hp = q;\n    }\n    \n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t *= MIN_DIST;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p) {\n    float d = 0., m = 0.;\n    for(int i=0;i<128;i++){\n        vec2 t = map(p);\n        d += i<64? t.x*.4:t.x*.8;\n        m  = t.y;  \n        p = ro + rd * d;\n        if(t.x<d*MIN_DIST||d>55.) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 getFace(vec3 h, vec2 uv){\n    \n    float px = 10./R.x; \n    vec2 id = floor(uv), q = fract(uv)-.5;\n    float rnd = hash21(id.xy);\n    float sn = hash21(id.yx)*11.;\n    sn = mod(sn,11.);\n    \n    float t1 = lsp(sn,sn+.5,tmod);\n    float t2 = lsp(sn+2.,sn+2.5,tmod);\n    t1 = eoc(t1); t1 = t1*t1*t1;\n    t2 = eoc(t2); t2 = t2*t2*t2;\n    q.xy *= rot((t1+t2)*1.5707);\n\n    if(rnd>.5) q*=rot(1.5707);\n    rnd=fract(rnd*32.232);\n    \n    vec2 q2 = length(q-.5)<length(q+.5)?q-.5 : q+.5;\n    \n    float tk = .1275;\n    float d1 = abs(length(q2)-.5)-tk;\n    float d3 = length(q)-.5;\n    if(rnd>.85) d1 = min(length(q.x)-tk,length(q.y)-tk);\n    d1=max(d1,d3);\n\n    float tt = .5+.5*sin(fract(T*.05)*PI);\n    tt=smoothstep(.7,.8,tt);\n    vec3 cr = mix(vec3(0,.4,.9),vec3(.03),tt);\n    h = mix(h,cr,smoothstep(px,-px,d3));\n    h = mix(h,mix(vec3(0),vec3(1,0,0),t1-t2),smoothstep(px,-px,d1));\n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    tspeed = T*.3;\n    speed = T*.5;\n    tmod = mod(tspeed,14.);\n    // uv ro + rd\n    vec2 uv = (2.* F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,0,11);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse //\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : (M.y/R.y*.25-.125)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x*2.-1.)*PI;\n    mat2 rx = rot(-.68-x), ry = rot(-1.18-T*.06-y);\n    \n    ro.zy *= rx;rd.zy *= rx;\n    ro.xz *= ry;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n\n    vec2 ray = marcher(ro,rd,p);\n    float d = ray.x, m = ray.y;\n    \n    gid = sid;\n    hitpoint = hp;\n    srot = grot;\n    \n    if(d<MAX_DIST) {\n  \n        vec3 n = normal(p,d);\n        vec3 tn = n;\n        vec3 lpos = vec3(-15,15,-15);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.;\n        for( float t=.01;t<16.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 16.*h/t);\n            t += h * .75;\n            if( shdw<MIN_DIST || t>6. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        float spec = .75 * pow(max(dot(normalize(p-ro),reflect(normalize(lpos),n)),0.),24.);\n        vec3 h = vec3(1.);\n        int face;\n        \n        if(m==2.) {\n            vec3 cuv;\n            h = vec3(.01);\n            tn.zy *= srot;\n            //https://www.shadertoy.com/view/3sVBDd\n            //finding the face of a cube using normal\n            vec3 aN = abs(tn);\n            ivec3 idF = ivec3(tn.x<-.25? 0 : 5, tn.y<-.25? 1 : 4, tn.z<-.25? 2 : 3);\n            face = aN.x>.5? idF.x : aN.y>.5? idF.y : idF.z;\n    \n            if(face==0) cuv = hitpoint.yzx;\n            if(face==1) cuv = hitpoint.xzy;\n            if(face==2) cuv = hitpoint.xyz;\n            if(face==3) cuv = hitpoint.xyz;\n            if(face==4) cuv = hitpoint.xzy;\n            if(face==5) cuv = hitpoint.yzx;\n\n            //h = getFace(h, ((cuv.xy+float(face))-.5)*3.);\n            h = getFace(h, (cuv.xy+float(face))*2.);\n        }\n        \n        if(m==1.) {\n            h = vec3(.01);\n            vec2 uv = hitpoint.xz*.5;\n            h=  getFace(h,uv);\n        }\n        \n        C = h * diff;\n\n    }\n\n    C = mix(C,vec3(.005), 1.-exp(-.0006*d*d*d));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}