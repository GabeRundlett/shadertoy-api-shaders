{
    "Shader": {
        "info": {
            "date": "1681983431",
            "description": "First volume rendering",
            "flags": 1,
            "hasliked": 0,
            "id": "DdGSRc",
            "likes": 1,
            "name": "CM_Volume VR",
            "published": 3,
            "tags": [
                "volume",
                "vr"
            ],
            "usePreview": 0,
            "username": "CMH",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "// Author:CMH\n// Title: volumetrics (learning shader from iq's code, thanks iq!)\n\n#define PI 3.141592654\n#define TWOPI 6.283185308\nfloat noise_3(in vec3 p);\t//[0,1]\nvec3 normalMap(vec3 p, vec3 n);\nvec3 FlameColour(float f);\nvec3 viridis_quintic( float x );\nmat3 fromEuler(vec3 ang);\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdBox( vec3 p)\n{\n  vec3 b=vec3(0.4);\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\t//p += 0.015 * (noise_3(p*60.0)*2.0-1.0);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat map(in vec3 p)\n{\nfloat bump=0.01 * (noise_3(p*30.0)*2.0-1.0);\nmat3 rot=fromEuler(vec3(0.0,0.0,iTime*0.5));\nvec3 p1=(p+vec3(0.0,-0.0,1.5))*rot;\nvec3 p2=(p+vec3(1.5,-0.5,0.0))*-rot;\nvec3 p3=(p+vec3(-1.5,-0.8,0.0))*-rot;\nvec3 p4=(p+vec3(0.0,-0.3,-1.5))*rot;\n//return sdSphere(p1+vec3(0.,0.,0.0), 0.5)+bump;\n//return sdTorus(p+vec3(0.,0.,1.5),vec2(0.4,0.2))+bump;\n//return sdBox(p+vec3(0.,0.,1.5),vec3(0.5));\n//return sdBox(p1,vec3(0.4))+bump;\nreturn min(min(min(sdBox(p1),sdBox(p2)),sdBox(p3)),sdBox(p4))+bump;\n//return udRoundBox(p+vec3(0.0,0.0,1.5), vec3(0.3, 0.3, 0.3), 0.1)+bump;\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) \n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.8; //\n\t}\nreturn t;\n}\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0/(4.0 * PI))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//volumetric raymarch\n//https://cglearn.eu/pub/advanced-computer-graphics/volumetric-rendering\n\nfloat density(vec3 p){\n\t//return (1.0-smoothstep(0.,0.1,map(p)))*2.0;\n\treturn (smoothstep(0.,0.1,map(p)))*0.5;\n\t}\n\nvec4 VolumetricRaymarch(vec3 samplePosition, vec3 marchDirection, int stepCount, float stepSize) {\n\tfloat ambientLight=9.;\n\tfloat directLight=15.0;\n\tvec3 l=vec3(0.5,0.3,-0.8)*fromEuler(vec3(0.0,0.0,iTime*0.2));\n\tfloat absorptionCoef=0.01;\n\tfloat scatteringCoef=0.04;\n\tfloat extinctionCoef = absorptionCoef + scatteringCoef;\n\tfloat transmittance = 1.0;\n\tvec3 illumination = vec3(0.0);\n\n    for (int i = 0; i < stepCount; i++) {\n        samplePosition += marchDirection * stepSize;\n        float currentDensity = density(1.0*samplePosition);\n        transmittance *= exp(-currentDensity * extinctionCoef * stepSize);        \n        float inScattering= ambientLight + directLight * HenyeyGreenstein(0.6,dot(-marchDirection,-l));  //directLight * phase(marchDirection, -l)\n        float outScattering = scatteringCoef * currentDensity;\n        vec3 currentLight = vec3(inScattering * outScattering);\n        illumination += transmittance * currentLight * stepSize;\n    }\n    return vec4(illumination, transmittance);\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\nvec3 render( in vec3 RayOri, in vec3 RayDir ){\t\n\t//First Ray\n     vec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\n    //Second Ray\n    float IOR=1.33;\n    vec3 Rd_2=refract(RayDir,n,1.0/IOR);\n\t\t\n//SHADING\n    vec3 result;\n\tresult= VolumetricRaymarch(RayOri, RayDir,32,0.1).xyz;\n\t//result= VolumetricRaymarch(p, Rd_2,32,0.1).xyz;;\n\t//result= FlameColour(clamp(result.x*1.0,0.0,1.0));\n\tresult= viridis_quintic(result.x);\n\treturn result;\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//void main()\n{\nvec2 uv = gl_FragCoord.xy/iResolution.xy;\nuv = uv*2.0-1.0;\nuv.x*= iResolution.x/iResolution.y;\nuv.y*=-1.0;//校正 預設值uv v軸朝下，轉成v軸朝上相同於y軸朝上為正\n//vec2 mouse=(u_mouse.xy/u_resolution.xy)*2.0-1.0;\nvec2 mouse=iMouse.xy/iResolution.xy;\n\n// camera option1  (模型應在原點，適用於物件)\n    //vec3 CameraRot=vec3(0.0, -mouse.y*1.6, -mouse.x*6.28);\n    vec3 CameraRot=vec3(0.0, -0.0, -0.0);\n\tvec3 ro= vec3(0.0, 0.0, 0.0);//CameraPos;\n\tvec3 ta =vec3(0.0, 0.0, -1.0)*fromEuler(CameraRot); //TargetPos; //vec3 ta =float3(CameraDir.x, CameraDir.z, CameraDir.y);//UE座標Z軸在上\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 2.0));//z值越大，zoom in! 可替換成iMouse.z\n\tvec3 RayOri = ro;\n\n\tvec3 col = render(RayOri,RayDir);\n    fragColor = vec4( col, 1.0 );\t\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    //float time = iTime*0.25 + 0.01*iMouse.x;\n    //float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=== 3d noise functions ===\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n//=== flame color ===\n//thanks iq..\n// Smooth HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 hsv2rgb_trigonometric( in vec3 c )\n{\n    vec3 rgb = 0.5 + 0.5*cos((c.x*6.0+vec3(0.0,4.0,2.0))*3.14159/3.0);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 FlameColour(float f)\n{\n\treturn hsv2rgb_smooth(vec3((f-(2.25/6.))*(1.25/6.),f*1.25+.2,f*.95));\n}\n\nfloat saturate( float x ) { return clamp( x, 0.0, 1.0 ); }\nvec3 viridis_quintic( float x )\n{\n\tx = saturate( x );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}