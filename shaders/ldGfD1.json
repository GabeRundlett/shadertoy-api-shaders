{
    "Shader": {
        "info": {
            "date": "1528602356",
            "description": "flimshaw's initial noisecube asked to be more goo'y... at least in my view :) This is the result after playing with it for a bit, orig: https://www.shadertoy.com/view/4sGBD1",
            "flags": 0,
            "hasliked": 0,
            "id": "ldGfD1",
            "likes": 6,
            "name": "flimshaw's noisecube more goo'y",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "phong",
                "spheretracing",
                "goo",
                "blinn",
                "pbr"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 684
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// I couldn't help it and played around with flimshaw's shader...\n//\n//  * https://www.shadertoy.com/view/4sGBD1\n//\n// ... left most of it untouched, but stuffed it all in one file, and\n// tweaked small bits here and there, since I liked the goo'y feel of the\n// initial version. Made it a bit more goo'y.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n#define MAX_STEPS 96\n#define STEP_BIAS .75\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, float d) {\n    vec3 N = normal (p, d*EPSILON, iTime);\n    vec3 L = normalize (lightPos - p);\n    vec3 V = normalize (eye - p);\n    vec3 R = normalize (reflect (-L, N));\n    \n    float dotLN = max (.0, dot(L, N));\n    float dotRV = max (.0, dot(R, V));\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, float d) {\n    const vec3 ambientLight = vec3(.4);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3 (4., 2., -4.);\n    vec3 light1Intensity = vec3 (.7, .6, .5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity, d);\n    \n    vec3 light2Pos = vec3 (3., 2., 2.);\n    vec3 light2Intensity = vec3(.5, .6, .7);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity, d);    \n    return color;\n}\n\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = .0;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n       vec3 p = o + r*t;\n       float d = scene(p, iTime);\n       t += d*STEP_BIAS;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // set up view-ray/\"camera\"\n    vec3 r = normalize (vec3 (uv, .75));\n    vec3 o = vec3 (0.);\n\n    // determine pixel-color\n    float d = trace (o, r);\n    vec3 p = o + r*d;\n    vec3 K_a = vec3 (.2);\n    vec3 K_d = vec3 (1.);\n    vec3 K_s = vec3 (1.);\n    float shininess = 100.;\n    vec3 color = vec3 (.0);\n    if (uv.x < 2.*cos(iTime)) {\n\t\tcolor =  shade (o, r, d, iTime);\n    } else {\n    \tcolor = phongIllumination(K_a, K_d, K_s, shininess, p, o, d);\n    }\n\n    // tone-map, gamma-correct, \"fog\"\n    color = color / (1. + color);\n    color = pow (color, vec3 (1./2.2));\n    color *= 2.3 - d*.5;\n\n    fragColor = vec4 (color, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define EPSILON .001\n\nconst float PI = 3.14159265359;\n\nfloat hashn (vec3 p, float t)\n{\n    p = fract (p*.3183099 + .1);\n    p *= 17.;\n    return max (fract (p.x*p.y*p.z*(p.x + p.y + p.z)), 1. - t);\n}\n\nfloat noise (in vec3 x, in float t)\n{\n    vec3 p = floor (x);\n    vec3 f = fract (x);\n    f = f*f*(3. - 2.*f);\n\t\n    return mix(mix(mix( hashn(p+vec3(0,0,0), t), \n                        hashn(p+vec3(1,0,0), t),f.x),\n                   mix( hashn(p+vec3(0,1,0), t), \n                        hashn(p+vec3(1,1,0), t),f.x),f.y),\n               mix(mix( hashn(p+vec3(0,0,1), t), \n                        hashn(p+vec3(1,0,1), t),f.x),\n                   mix( hashn(p+vec3(0,1,1), t), \n                        hashn(p+vec3(1,1,1), t),f.x),f.y),f.z);\n}\n\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\nfloat sdSphere (in vec3 p, in float radius)\n{\n    return length (p) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat2 r2d (in float degree)\n{\n    float rad = radians (degree);\n    float c = cos (rad);\n    float s = sin (rad);\n\treturn mat2 (c, s, -s, c);\n}\n\nvec3 opTwist (in vec3 p)\n{\n    mat2  m = r2d (p.y*p.x*p.z);\n    vec3  q = vec3 (m*p.xz, p.y);\n    return q;\n}\n\nfloat scene (vec3 p, in float t)\n{\n    vec3 noiseCenter = p;\n    noiseCenter.z -= 2.; \n    vec3 boxCenter = noiseCenter;\n    vec3 ballCenter = noiseCenter + vec3 (.0, .0, 1. + 1.*(.5 + .5*cos(t))); \n\n    noiseCenter += .05*opTwist (.5*p);\n    noiseCenter.xy *= r2d (10.*t);\n    noiseCenter.yz *= r2d (-20.*t);\n    noiseCenter.zx *= r2d (30.*t);\n\n    float variation = 6. + 4.*(.5 + .5*cos (14.*t));\n    vec3 offset = vec3 (-5.,-1., 1.)*t*.5;\n    float structure = noise (3.*noiseCenter + offset, variation) - .65 + (sin (t) + 1.)*.05;\n\n    float box = sdBox (boxCenter, vec3 (6.));\n    float ball = sdSphere (ballCenter, 1.5 + .5*(.5 + .5*cos (t)));\n    ball = min (ball, sdSphere (ballCenter + vec3 (.0, .0, -1.5), 1.5 + .5*(.5 + .5*cos (t))));\n    structure = smax (-ball, structure*.5, .25);\n\n    return smax (box, structure, .25);\n}\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec3 normal (vec3 p, float epsilon, in float t)\n{\n    float d = scene (p, t);\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene(p + e.xyy, t),\n                            scene(p + e.yxy, t),\n                            scene(p + e.yyx, t)) - d); \n}\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in float t)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON, t);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo = vec3 (.4);\n    float metallic = .2;\n    float roughness = .1;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.5, .2, .1);\n    lightColors[1] = vec3 (.1, .3, .5);;\n\n    vec3 lightPositions[2];\n    float c = cos (t);\n    float s = sin (t);\n    lightPositions[0] = vec3 (-.5*c, -.5*s, -.1);\n    lightPositions[1] = vec3 (.5*c, .5*s, 1.);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (.04);\n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3 (.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for (int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize (lightPositions[i] - p);\n        vec3 H = normalize (V + L);\n        float dist = distance (p, lightPositions[i]);\n        float attenuation = 2./(dist*dist);\n        vec3 radiance = lightColors[i]*attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX (N, H, roughness);\n        float G = geomSmith (N, V, L, roughness);\n        vec3 F = fresnelSchlick (max (dot (H, V), .0), F0, roughness);\n\n        vec3 kS = F;\n        kD = vec3 (1.) - kS;\n        kD *= 1. - metallic;\n        \n        vec3 nominator = NDF * G * F;\n        float denominator = 4. * max (dot (N, V), .0) * max (dot (N, L), .0);\n        vec3 specular = nominator / max (denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max (dot (N, L), .0);                \n        Lo += (kD*albedo/PI + specular)*radiance*NdotL;\n    }\n\n    vec3 ambient = kD * albedo;\n\n    return ambient + Lo;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}