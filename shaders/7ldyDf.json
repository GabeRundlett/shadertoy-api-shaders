{
    "Shader": {
        "info": {
            "date": "1660711116",
            "description": "Mandelbrot with blended gradients ported from C (https://github.com/adammaj1/Mandelbrot-set-with-blended-gradients) to GLSL with color palette",
            "flags": 0,
            "hasliked": 0,
            "id": "7ldyDf",
            "likes": 32,
            "name": "Pseudeo 3D mandelbrot",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "mireq",
            "viewed": 938
        },
        "renderpass": [
            {
                "code": "// Mandelbrot set with blended gradients ported to GLSL\n// https://github.com/adammaj1/Mandelbrot-set-with-blended-gradients\n\n// Rendered result: https://youtu.be/iXg-1cvxhr8 \n// Renderer: https://github.com/mireq/Shadertoy-renderer\n\n// Colorscheme 2 is rainbow\n#define COLORSCHEME 1\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#else\n#define AA 1\n#endif\n\n// Color schemes\n#if COLORSCHEME==1\n\n#define INVERTED_GRADIENT\n#define MAXITER_POT 300\n#define MAXITER_NORMAL 500\n\n#else\n\n#define MAXITER_POT 180\n#define MAXITER_NORMAL 300\n\n#endif\n\n// Interation end conditions\n#define ER_POT 100000.0\n#define ER_NORMAL 100.0\n\n// Constants\n#define M_PI 3.1415926535897932384626433832795\n\n// Number of points\n#define NUMBER_OF_POINTS 8\n\n// Coordinates with awesome places and zoom values\nconst vec3 coordinates[NUMBER_OF_POINTS] = vec3[NUMBER_OF_POINTS](\n\tvec3(-0.774693, 0.1242263647, 14.0),\n\tvec3(-0.58013, 0.48874, 14.0),\n\tvec3(-1.77, 0.0, 5.0),\n\tvec3(-0.744166858, 0.13150536, 13.0),\n\tvec3(0.41646, -0.210156433, 16.0),\n\tvec3(-0.7455, 0.1126, 10.0),\n\tvec3(-1.1604872, 0.2706806, 12.0),\n\tvec3(-0.735805, 0.196726496, 15.0)\n);\nconst float centerDuration = 31.0;\nconst float rotationDuration = 53.0;\nconst vec2 defaultCenter = vec2(-0.6, 0.0);\n\n#if COLORSCHEME==1\nconst vec4 insideColor = vec4(0.0, 0.0, 0.0, 1.0);\n#else\nconst vec4 insideColor = vec4(0.1, 0.12, 0.15, 1.0);\n#endif\n\nfloat time = 0.0;\nint centerIndex = 0;\nvec2 currentCenter;\nfloat currentZoom;\n\n\n// Color palettes https://iquilezles.org/articles/palettes/\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n\treturn a + b*cos(2.0*M_PI*(c*t+d));\n}\n\nvec3 awesomePalette(in float t)\n{\n\treturn palette(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.1,0.2));\n}\n\nvec3 rainbow(in float t)\n{\n\treturn palette(t, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));\n}\n\n\n// Complex multiplication\nvec2 cmul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x * b.x - a.y * b.y, a.x * b.y + b.x * a.y);\n}\n\n// Complex c^2\nvec2 cpow2(in vec2 c)\n{\n\treturn vec2(c.x * c.x - c.y * c.y, 2.0 * c.x * c.y);\n}\n\n// Complex division\nvec2 cdiv(in vec2 a, in vec2 b)\n{\n\treturn vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\n// Get rotation matrix\nmat2 rotate(float theta)\n{\n\tfloat s = sin(theta);\n\tfloat c = cos(theta);\n\treturn mat2(c, -s, s, c);\n}\n\n// Potential formula\nfloat potential(in vec2 c)\n{\n\tvec2 z = vec2(0.0, 0.0); // z0\n\tint iter = 0;\n\n\tfor (iter = 0; iter < MAXITER_POT; ++iter) {\n\t\tz = cpow2(z) + c; // z_n+1 = z_n^2 + c\n\t\tfloat absZ = length(z); // |z|\n\t\tif (absZ > ER_POT) {\n\t\t\treturn abs(log(log2(absZ)) - (float(iter) + 1.0) * log(2.0));\n\t\t}\n\t}\n\n\treturn -1.0;\n}\n\n// Reflection formula\nfloat reflection(in vec2 c) {\n\tvec2 z = vec2(0.0, 0.0); // z0\n\tvec2 dc = vec2(0.0, 0.0); // Derivate of c\n\n\tconst float h2 = 1.5; // Height of light\n\tvec2 angle = normalize(vec2(-1.0, 1.0)) * rotate(time / rotationDuration); // Light always from top left\n\n\tfor (int i = 0; i < MAXITER_NORMAL; i++) {\n\t\tdc = 2.0 * cmul(dc, z) + vec2(1.0, 0.0);\n\t\tz = cpow2(z) + c;\n\n\t\tif (length(z) > ER_NORMAL) { // Outside lighting calculation formula\n\t\t\tvec2 slope = normalize(cdiv(z, dc));\n\t\t\tfloat reflection = dot(slope, angle) + h2;\n\t\t\treflection = reflection / (1.0 + h2); // Lower value to max 1.0\n\t\t\tif (reflection < 0.0) {\n\t\t\t\treflection = 0.0;\n\t\t\t}\n\t\t\treturn reflection;\n\t\t}\n\t}\n\n\treturn -1.0;\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Coordinates [-1, 1]\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y) * 2.0;\n\n\t// Mix between base poistion and target position\n\tfloat mixFactor = 1.0 - (0.5 + 0.5 * cos(time / centerDuration * 2.0 * M_PI));\n\n\t// Zoom and position calculation\n\tfloat zoom = exp2(-currentZoom * mixFactor);\n\tfloat maxZoom = exp2(-currentZoom);\n\tvec2 c = mix(currentCenter, defaultCenter, zoom / (1.0 - maxZoom) - maxZoom) + uv * zoom * rotate(time / rotationDuration);\n\n\tfloat pot = potential(c);\n\tfloat ref = reflection(c);\n\n#ifdef INVERTED_GRADIENT\n\tfloat intensity = 1.0 - sqrt(fract(pot));\n\tintensity = mix(intensity, ref, 0.5);\n\t// intensity = 0.8 * (intensity * ref) + 0.2; // Alternative shadows\n#else\n\tfloat intensity = 0.7 * (fract(pot) * ref) + 0.3;\n#endif\n\n#if COLORSCHEME==1\n\tvec3 color = awesomePalette(time / 50.0 + pot / 40.0);\n\tif (ref < 0.0) { // Inner color\n\t\tfragColor = insideColor;\n\t}\n\telse { // Outer color\n\t\t//fragColor = vec4(color * intensity, 1.0);\n\t\t//fragColor = mix(fragColor, vec4(1.0), intensity * 0.3 + clamp(ref - 0.5, 0.0, 1.0) * pow((1.0 - fract(pot)), 30.0));\n\t\tfragColor = vec4(\n\t\t\tcolor * intensity + // Base color\n\t\t\tvec3(intensity) * 0.3 + // Matte white\n\t\t\tclamp(ref - 0.5, 0.0, 1.0) * pow((1.0 - fract(pot)), 30.0), // Specular\n\t\t1.0);\n\t\tfragColor = clamp(fragColor, 0.0, 1.0);\n\t}\n#else\n\tvec3 color = rainbow(pot / 20.0);\n\tif (pot < 0.0) { // Inner color\n\t\tcolor = insideColor.rgb * min((ref + 0.5), 1.0);\n\t}\n\telse { // Outer color\n\t\tcolor = color * intensity;\n\t}\n\tfragColor = vec4(color, 1.0);\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\ttime = iTime + centerDuration / 2.0 - 7.0; // Start with zoom\n\tcenterIndex = int(time / centerDuration) % NUMBER_OF_POINTS; // Seleect current target\n\tcurrentCenter = coordinates[centerIndex].xy;\n\tcurrentZoom = coordinates[centerIndex].z;\n\n\tfragColor = vec4(0.0);\n\n\t// Antialiasing\n\tconst float fraction = 1.0 / float(AA);\n\tconst float fraction2 = fraction / float(AA);\n\tfor (int i = 0; i < AA; i++) {\n\t\tfor (int j = 0; j < AA; j++) {\n\t\t\tvec4 color = vec4(0.0);\n\t\t\tvec2 shift = vec2(\n\t\t\t\tfloat(i) * fraction + float(AA - j - 1) * fraction2,\n\t\t\t\tfloat(j) * fraction + float(i) * fraction2\n\t\t\t);\n\t\t\trender(color, fragCoord + shift);\n\t\t\tfragColor += clamp(color, 0.0, 1.0);\n\t\t}\n\t}\n\n\tfragColor = fragColor / float(AA * AA);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}