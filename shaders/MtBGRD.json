{
    "Shader": {
        "info": {
            "date": "1427512550",
            "description": "Picking uniform points on cube faces and warping through tangent function before projecting to sphere gives a nice even distribution. Computing cell noise directly on the sphere looks nicer (to my eyes) than on a regular 3D lattice.",
            "flags": 16,
            "hasliked": 0,
            "id": "MtBGRD",
            "likes": 169,
            "name": "Spherical voronoi",
            "published": 3,
            "tags": [
                "voronoi",
                "sphere",
                "picking",
                "point"
            ],
            "usePreview": 0,
            "username": "mattz",
            "viewed": 7053
        },
        "renderpass": [
            {
                "code": "/* Spherical voronoi, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n   Keys do things:\n\n     D - toggle demo mode (nothing else does anything until you leave demo mode)\n\n     S - toggle sphere\n     W - toggle warp through tangent function\n     R - toggle randomization\n     P - toggle points\n     G - toggle grid boundaries\n     V - toggle voronoi cell boundaries\n     C - toggle color scheme (random or by cube face)\n     T - toggle voronoi cell texture\n\n     N,M - change number of points \n\n   Much of the code below could be simplified/optimized. \n\n*/\n\n/* Number of points per edge of the cube face (we will have 6*N^2 points) */\nfloat N = 8.0;\n\n/* Bunch o' settings */\nfloat fade_in = 1.0;\nfloat warp_fraction = 1.0;\nfloat randomize_amount = 1.0;\nfloat sphere_fraction = 1.0;\nfloat enable_color = 1.0;\nfloat enable_voronoi_edges = 1.0;\nfloat enable_grid_lines = 1.0;\nfloat enable_points = 1.0;\nfloat color_scheme = 1.0;\nfloat enable_texture = 0.0;\n\n/* Bunch o' other globals. */\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,2.8);\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nconst float dot_size = 0.02;\nconst float dot_step = 0.005;\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* Warp to go cube -> sphere */\nvec2 warp(vec2 x) {\n    return tan(warp_theta*x)/tan_warp_theta;\n}\n\n/* Unwarp to go sphere -> cube */\nvec2 unwarp(vec2 x) {\n    return atan(x*tan_warp_theta)/warp_theta; \n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n/* Just used for visualization to make sure dots are round regardless of \n   whether we are visualizing them on cube or sphere. */\nfloat sphereOrCubeDist(vec3 a, vec3 b) {\n    return mix(length(a-b), sqrt(sphereDist2(a,b)), sphere_fraction);    \n}\n\n\n/* Just used to visualize distance from spherical Voronoi cell edges. */\nfloat bisectorDistance(vec3 p, vec3 a, vec3 b) {\n    vec3 n1 = cross(a,b);\n    vec3 n2 = normalize(cross(n1, 0.5*(normalize(a)+normalize(b))));\n    return abs(dot(p, n2));             \n}\n\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n/* Get index (0-5) for axis. */\nfloat axisToIdx(vec3 axis) {\n    \n    float idx = dot(abs(axis), vec3(0.0, 2.0, 4.0));\n    if (dot(axis, vec3(1.0)) < 0.0) { idx += 1.0; }\n    \n    return idx;\n    \n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool wrapCube(in mat3 PT, \n              inout vec2 uvn,\n              out mat3 PTn) {\n    \n    // new uv location might have gone off edge of cube face\n    // ...see if it has by comparing to clamped version\n    vec2 uvn_clamp = clamp(uvn, -1.0, 1.0);\n    vec2 extra = abs(uvn_clamp - uvn);\n\n    // it doesn't make sense to go over both corners so only allow\n    // overflow/underflow in u or v but not both\n    if (min(extra.x, extra.y) > 0.0) {\n        \n        return false;\n        \n    } else {            \n\n        // check if we have gone off starting face\n        float esum = extra.x + extra.y;\n\n        if (esum > 0.0) {\n            // need to re-establish what face we are on\n            vec3 p = PT * vec3(uvn_clamp, 1.0 - esum);\n            PTn = getPT(p);\n            uvn = (p * PTn).xy;\n        } else {\n            // same as starting face\n            PTn = PT;\n        }\n\n        return true;\n        \n    }\n    \n}\n\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    // get permutation matrix \n    mat3 PT = getPT(pos);\n    \n    // project to cube face\n    vec3 cf = pos * PT; \n    \n    // UV is in [-1, 1] range\n    vec2 uv = cf.xy / cf.z; \n    \n    // unwarp from sphere -> cube (approximtion of atan)\n    uv = unwarp(uv);      \n    \n    // for viz only\n    pos /= (dot(pos, PT[2]));\n    \n    // quantize uv of nearest cell\n    vec2 uv_ctr = (floor(0.5*N*uv + 0.5) + 0.5)*2.0/N;\n    \n    // for drawing grid lines below\n    vec2 l = abs(mod(uv + 1.0/N, 2.0/N) - 1.0/N)*0.5*N;\n\n    // store distance, material & point for 1st, 2nd closest\n    float d1 = 1e4, d2 = 1e4;\n    float m1 = -1.0, m2 = -1.0;\n    vec3 p1 = vec3(0), p2 = vec3(0);\n\n    // for neighbors in 4x4 neighborhood\n    for (int du=-2; du<=1; ++du) {\n        for (int dv=-2; dv<=1; ++dv) {\n            \n            mat3 PTn;\n            \n            // any time you see 2.0/N it maps from [-1, 1] to [0, N]\n            vec2 uvn = uv_ctr + vec2(float(du), float(dv))*2.0/N;\n            \n            if (wrapCube(PT, uvn, PTn)) {\n\n                // now generate a unique id for the cell\n                vec2 ssn = floor((uvn*0.5 + 0.5)*N);\n                float faceid = axisToIdx(PTn[2]);\n                vec3 id = vec3(ssn, faceid);\n                \n                // generate 3 random #'s from id\n                vec3 r = hash33(id);\n                \n                // randomize dot position within cell\n                uvn += (r.xy-0.5)*2.0*randomize_amount/N;\n\n                // random material\n                float mn = mix((faceid+0.5 + 0.5*r.z - 0.25)/6.0, r.z, color_scheme);\n                \n                // warp cube -> sphere\n                uvn = warp(uvn);\n\n                // can save 1 multiplication over general matrix mult.\n                // because we know last coord is 1\n                vec3 pn = PTn[0]*uvn.x + PTn[1]*uvn.y + PTn[2];\n\n                // update distances if closer\n                float dn = sphereDist2(pn, pos);\n \n                if (dn < d1) {\n                    d2 = d1; p2 = p1; m2 = m1;\n                    d1 = dn; p1 = pn; m1 = mn;\n                } else if (dn < d2) {\n                    d2 = dn; p2 = pn; m2 = mn;\n                }\n\n            }\n            \n        }\n            \n    }\n\n    // get distance to voronoi boundary\n    float b = bisectorDistance(pos, p2, p1);\n    \n    // rainbow stained glass texture business\n    m1 = fract(m1 + enable_texture*(0.5*sqrt(N))*(sqrt(d2)-sqrt(d1)));\n    \n    // cell background color\n    vec3 bg = mix(hue(m1), hue(m2), 0.5*smoothstep(0.003, 0.0, b));\n    \n    // gray vs rgb\n    vec3 c = mix(vec3(0.9), bg, enable_color);\n\n    // grid lines\n    float s = mix(0.02, 0.015, sphere_fraction);\n    c = mix(c, vec3(0.7), smoothstep(2.0*s, s, min(l.x, l.y))*enable_grid_lines);\n\n    // voronoi lines    \n    c = mix(c, vec3(0.0), smoothstep(0.01, 0.00, b)*enable_voronoi_edges);\n\n    // draw points\n    c = mix(c, vec3(0.0), smoothstep(dot_step, 0.0, sphereOrCubeDist(pos, p1)-dot_size)*enable_points);\n\n    return vec3(c);\n    \n    \n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\n/* Adapted from https://iquilezles.org/articles/distfunctions */\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\n\n/* Distance function to scene is a single cube/sphere. */\nvec2 map(in vec3 pos) {\t\n\n    float d = mix(sdCube(pos,0.5773), length(pos)-1.0, sphere_fraction);    \n    vec2 rval = vec2(d, 3.0);\n\n    return rval;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n\n/* Pretty basic shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n\n    if (tm.y < 0.0) {\n\n        c = vec3(1.0);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        pos -= n * map(pos).x;\n\n        vec3 color = gcolor(pos);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n\n    }\n\n    return c;\n\n}\n\n\n/* Bunch of ASCII keycodes */\nconst float KEY_C = 67.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_G = 71.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_R = 82.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\nconst float KEY_P = 80.5/256.0;\nconst float KEY_W = 87.5/256.0;\nconst float KEY_V = 86.5/256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n\n/* Adapted from https://github.com/danro/jquery-easing/blob/master/jquery.easing.js */\nfloat easeOutBounce(float t, float d) {\n    if ((t/=d) < (1./2.75)) {\n        return (7.5625*t*t);\n    } else if (t < (2./2.75)) {\n        return (7.5625*(t-=(1.5/2.75))*t + .75);\n    } else if (t < (2.5/2.75)) {\n        return (7.5625*(t-=(2.25/2.75))*t + .9375);\n    } else {\n        return (7.5625*(t-=(2.625/2.75))*t + .984375);\n    }\n}\n\n\n/* Easing function. */\nfloat bounce_in(float lo, float hi, float u) {\n    return u < lo ? 0.0 : u > hi ? 1.0 :  1.0 - easeOutBounce(hi-u, hi-lo);\n}\n\n\n/* Easing function. */\nfloat bounce_out(float lo, float hi, float u) {\n    return u < lo ? 0.0 : u > hi ? 1.0 : easeOutBounce(u-lo, hi-lo);\n}\n\n\n/* ...finally! */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t;\n    \n    /* Do settings depending on whether demo mode. */\n    if (keyState(KEY_D, 1.0) == 1.0) {\n\n        float k = iTime;\n        t = mod(k, 32.0);\n        N = pow(2.0, mod(floor(k/32.0), 2.0)+3.0);\n\n        fade_in = smoothstep(0.0, 4.0, t) * smoothstep(32.0, 30.0, t);\n        enable_grid_lines = smoothstep(4.0, 6.0, t) * smoothstep(18.0, 16.0, t);\n        enable_points = smoothstep(4.0, 6.0, t) * smoothstep(22.0, 20.0, t);    \n        warp_fraction = bounce_out(6.0, 8.0, t);\n        randomize_amount = bounce_in(8.0, 10.0, t);        \n        sphere_fraction = bounce_out(12.0, 14.0, t);\n        enable_color = smoothstep(16.0, 18.0, t);\n        enable_voronoi_edges = smoothstep(20.0, 22.0, t);\n        enable_texture = smoothstep(24.0, 26.0, t);\n\n    } else {\n\n        t = iTime;\n\n        N = pow(2.0, 2.0+keyState(KEY_N, 1.0)+2.0*keyState(KEY_M, 0.0));\n\n        enable_grid_lines = keyState(KEY_G, 0.0);\n        enable_points = keyState(KEY_P, 0.0);\n        warp_fraction = keyState(KEY_W, 1.0);        \n        randomize_amount = keyState(KEY_R, 1.0);\n        sphere_fraction = keyState(KEY_S, 1.0);\n        enable_color = 1.0;\n        color_scheme = keyState(KEY_C, 1.0);\n        enable_voronoi_edges = keyState(KEY_V, 1.0);\n        enable_texture = keyState(KEY_T, 0.0);\n\n    }\n     \n    // For demonstration, warp_theta varies, but it should just be MAGIC_ANGLE for \"production\" code.\n    warp_theta = max(warp_fraction*MAGIC_ANGLE, 0.001);\n    tan_warp_theta = tan(warp_theta);\n\n  \n    /* Handle mouse motion for rotation. */\n    float thetay = (t-7.0) * 0.1;\n    float thetax = (t-7.0) * 0.05;        \n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = mix(vec3(1.0), shade(ro, rd), fade_in);\n\n\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}