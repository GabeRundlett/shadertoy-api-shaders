{
    "Shader": {
        "info": {
            "date": "1717092247",
            "description": "cross eyed 3D ray marching fractal\ninstructions at top of source code.",
            "flags": 48,
            "hasliked": 0,
            "id": "X3t3WX",
            "likes": 3,
            "name": "cycle16",
            "published": 3,
            "tags": [
                "raymarching",
                "3dfractal"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 78
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus\n<Lt,Rt Arrows> : alter value of focused widget\n<X>   : toggle animation\n<I>   : toggle spherical inversion\n<S>   : toggle cross eyed stereo\n<Spc> : reset\n\nNote: X,I and S modes are all off by default\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1 \nHold down <Z> for change Amount * 10. \nHold down both <A><Z> for change Amount * 50. \n\nCross-eyed 3D \nSlightly cross your eyes so that there is a third image in the middle.\nRelax your gaze, and concentrate only on that middle image, which is in 3D.\n\n*/\n\nstruct Dataset {\n    // DE() params\n    vec3 C;\n    float offset,kNum,kMax,iterOffset,kOffset;\n    \n\tint maxsteps;\n    vec3 invpos;\n    float invradius;\n    float invangle;    \n    \n    vec3 camera;\n    vec3 target;    \n    float epsilon;\n    float ambient,contrast,vibrant,dim;\n    float fogDistance,fogAmount,fogColor; // distance = 0.0 -> disable effect\n    \n    vec3 lightColor;\n    vec3 lightPosition;\n    vec3 lightParam; // diffuse, specular, ambient\n\n    vec4 orbitTrap;\n    float Ostrength; // 0.0 -> disable orbit trapping\n    float Ocycle;\n    float OXwt,OXcr; // weight, color code\n    float OYwt,OYcr;\n    float OZwt,OZcr;\n    float OWwt,OWcr;\n    vec3  Ocenter;   // origin offset\n    \n    float parallax;  // adjust for best stereo effect 0 ... 0.2\n\n    // calculated params \n    vec3 direction;\n    vec3 normal;\n    vec3 position;\n    vec3 color;\n    float depth;\n    int iter;\n    \n    int focus,row,displayCount;\n    bool animationEnable,stereoEnable,inversionEnable,juliaEnable;\n    vec3 viewVector,sideVector,topVector;\n};\n\n// --------------------------------------------------------\n\nfloat DE(vec3 p,inout Dataset data) {\n    float iter,k,scale = 1.0;\n    vec3 ot,cc = abs(data.C);\n \n    for(int n=0;n<100;n++) {\n        if(n >= data.maxsteps) break;\n\n        p = 2.0 * clamp(p, -cc,cc) - p;\n\n        iter = float(n) * data.iterOffset;\n        k = max(data.kNum/dot(p,p), (iter * data.kMax));\n\n        scale *= k;\n        k *= (1.0 + data.kOffset);\n        p *= k;\n                \t\t\n\t\tot = p - data.Ocenter;\n\t\tdata.orbitTrap = min(data.orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n\n    float l = length(p.xy);\n    float rxy = l - data.offset;\n    float n = l * p.z;\n    rxy = max(rxy, -n / (length(p))-0.02);\n    return rxy / abs(scale);\n}\n\n// --------------------------------------------------------\n// distance estimation function wrapped by spherical inversion code.\n\nfloat DE_plusSpherical(vec3 pos,inout Dataset data) {\n    if(data.inversionEnable) {\n        pos = pos - data.invpos;\n        float r = length(pos);\n        float r2 = r*r;\n\t\tfloat radius2 = data.invradius * data.invradius;\n        pos = (radius2 / r2) * pos + data.invpos;\n        \n        float an = atan(pos.y,pos.x) + data.invangle;\n        float ra = length(pos.xy);\n        pos.x = cos(an) * ra;\n        pos.y = sin(an) * ra;\n\t\t\t\t\n        float de = DE(pos,data);\n        return r2 * de / (radius2 + r * de);\n    }\n    \n    return DE(pos,data);\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n\tif(weight == 0.0) return vec3(0.0);\n\n\tx = cos(x);\n\t//x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n\tfloat r = (1.0-x)*(1.0-x);\n\tfloat g = x*x;\n\tfloat b = 2.0*(1.0-x)*x;\n\treturn vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor(inout Dataset data) {\n    vec3 orbitColor;\n    \n    if (data.Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(data.Ocycle,generateColor(data.OXwt,data.OXcr), data.orbitTrap.x) * data.OXwt * data.orbitTrap.x +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OYwt,data.OYcr), data.orbitTrap.y) * data.OYwt * data.orbitTrap.y +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OZwt,data.OZcr), data.orbitTrap.z) * data.OZwt * data.orbitTrap.z +\n        orbitTrapCycle(data.Ocycle,generateColor(data.OWwt,data.OWcr), data.orbitTrap.w) * data.OWwt * data.orbitTrap.w;\n    } else {\n        orbitColor =\n        \tgenerateColor(data.OXwt,data.OXcr) * data.OXwt * data.orbitTrap.x +\n        \tgenerateColor(data.OYwt,data.OYcr) * data.OYwt * data.orbitTrap.y +\n        \tgenerateColor(data.OZwt,data.OZcr) * data.OZwt * data.orbitTrap.z +\n        \tgenerateColor(data.OWwt,data.OWcr) * data.OWwt * data.orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\nvec3 phong_contrib(inout Dataset data) { \n\tvec3 L = normalize(data.lightPosition - data.position);\n\tfloat dotLN = dot(L, data.normal);\n\tif (dotLN < 0.0)\n\t\treturn vec3(0, 0, 0);\n\t\t\n\tfloat t1 = data.lightParam.x * dotLN;\n\n\tvec3 V = normalize(data.camera - data.position);\n\tvec3 R = normalize(reflect(-L, data.normal));\n\tfloat dotRV = dot(R, V);\n\n\tif (dotRV < 0.0)\n\t\treturn vec3(data.lightColor * t1);\n\n\tfloat t2 = data.lightParam.y * pow(abs(dotRV), data.lightParam.z);\n\tdata.color += data.lightColor * (t1 + t2);\n}\n\n\nvoid applyColoring(inout Dataset data) { \n    data.color = vec3(data.ambient) + vec3(1.0 - (data.normal * data.vibrant + sqrt(float(data.iter) * data.dim)));\n    data.color = vec3(0.5) + (data.color - vec3(0.5)) * data.contrast;\n    \n    if(length(data.lightColor) > 0.0) \n\t\tphong_contrib(data);\n        \n        \n    if(data.Ostrength > 0.0) {\n        vec3 oColor = getOrbitColor(data);\n        data.color = mix(data.color, oColor, data.Ostrength);\n    }\n}\n\n// --------------------------------------------------------\n// normal vector for 3D coordinate determined by comparing values of neighboring positions\n\nvoid calcNormal(inout Dataset data) {\n    float ex = data.epsilon;\n    float ey = -ex;\n    vec3 pos = data.position;\n    \n    vec3 t1 = vec3( pos[0] + ex, pos[1] + ey, pos[2] + ey); float a1 = DE(t1,data);\n    vec3 t2 = vec3( pos[0] + ey, pos[1] + ey, pos[2] + ex); float a2 = DE(t2,data);\n    vec3 t3 = vec3( pos[0] + ey, pos[1] + ex, pos[2] + ey); float a3 = DE(t3,data);\n    vec3 t4 = vec3( pos[0] + ex, pos[1] + ex, pos[2] + ex); float a4 = DE(t4,data);\n\n    data.normal = normalize(vec3(\n        ex * a1 + ey * a2 + ey * a3 + ex * a4,\n        ey * a1 + ey * a2 + ex * a3 + ex * a4,\n        ey * a1 + ex * a2 + ey * a3 + ex * a4 ));\n}\n\n// --------------------------------------------------------\n\nvoid setDirection(vec2 fragCoord,inout Dataset data) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(data.stereoEnable) {\n        vec3 soffset = data.sideVector * data.parallax;\n\t\txsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n\t\t\tsrcP.x -= xsize;      // base 0  X coordinate\n\t\t\tdata.camera -= soffset;// adjust for right side parallax\n\t\t}\n\t\telse {\n\t\t\tdata.camera += soffset;// adjust for left side parallax\n\t\t}\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    data.direction = normalize(data.viewVector + vPos.x * data.sideVector + vPos.y * data.topVector);\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 12.0;\n\nvoid rayMarch(inout Dataset data) {\n\tvec3 position = data.camera;\n\tfloat distance;\n\tdata.iter = 0;\n\tdata.depth = MIN_DIST;\n   // data.orbitTrap = vec4(10000.);\n\t\n\tfor(int i = 0;i < 100;++i) {\n\t\tdistance = DE_plusSpherical(position,data);\n        if(abs(distance) < MIN_DIST || data.depth > MAX_DIST) break;\n        data.iter += 1;\n\t\t\n        data.depth += distance;\n        position = data.camera + data.direction * data.depth;\n  }\n}\n\n// --------------------------------------------------------\nmakeStr1f(pcx)        _C _x _COL __ _dec(i, 4) _end\nmakeStr1f(pcy)        _C _y _COL __ _dec(i, 4) _end\nmakeStr1f(pcz)        _C _z _COL __ _dec(i, 4) _end\nmakeStr1f(poffset)    _O _f _f _s _e _t _COL __ _dec(i, 4) _end\nmakeStr1f(pkNum)      _k _N _u _m _COL __ _dec(i, 4) _end\nmakeStr1f(pkMax)      _k _M _a _x _COL __ _dec(i, 4) _end\nmakeStr1f(piterOff)   _i _t _e _r _O _f _f _COL __ _dec(i, 4) _end\nmakeStr1f(pkOffset)   _k _O _f _f _s _e _t _COL __ _dec(i, 4) _end\n\nmakeStr1f(pInvposx)   _I _n _v _P _o _s _X _COL __ _dec(i, 4) _end\nmakeStr1f(pInvposy)   _I _n _v _P _o _s _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pInvposz)   _I _n _v _P _o _s _Z _COL __ _dec(i, 4) _end\nmakeStr1f(pInvRadius) _I _n _v _R _a _d _i _u _s _COL __ _dec(i, 4) _end\nmakeStr1f(pInvAngle)  _I _n _v _A _n _g _l _e _COL __ _dec(i, 4) _end\nmakeStr1f(pCamerax)   _C _a _m _e _r _a _X _COL __ _dec(i, 4) _end\nmakeStr1f(pCameray)   _C _a _m _e _r _a _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pCameraz)   _C _a _m _e _r _a _Z _COL __ _dec(i, 4) _end\nmakeStr1f(pTargetx)   _T _a _r _g _e _t _X _COL __ _dec(i, 4) _end\nmakeStr1f(pTargety)   _T _a _r _g _e _t _Y _COL __ _dec(i, 4) _end\nmakeStr1f(pTargetz)   _T _a _r _g _e _t _Z _COL __ _dec(i, 4) _end\n\nvec3 rowColor(inout Dataset data) {\n if(data.row == data.focus) return vec3(0.,1.,0.);\n return vec3(0.8);\n}\n\nvoid displayData(inout Dataset data,inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.33) return; // no printing in that region\n\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 col = vec3(0);    \n\n    const float font_size = 19.0; // Font Size (higher values = smaller font)\n    uv *= font_size;        // Scale font with font_size\n    uv.y -= font_size - 1.; // Start drawing from the top   \n    \n    for(data.row = 0; data.row < 20; ++data.row) {\n       if(data.row >= data.focus-1 && data.row <= data.focus+1) {\n            if(data.row ==  0) col += rowColor(data) * pcx(uv, data.C.x);\n            if(data.row ==  1) col += rowColor(data) * pcy(uv, data.C.y);\n            if(data.row ==  2) col += rowColor(data) * pcz(uv, data.C.z);\n            if(data.row ==  3) col += rowColor(data) * poffset(uv, data.offset);\n            if(data.row ==  4) col += rowColor(data) * pkNum(uv, data.kNum);\n            if(data.row ==  5) col += rowColor(data) * pkMax(uv, data.kMax);\n            if(data.row ==  6) col += rowColor(data) * piterOff(uv, data.iterOffset);\n            if(data.row ==  7) col += rowColor(data) * pkOffset(uv, data.kOffset);\n            if(data.row ==  8) col += rowColor(data) * pInvposx(uv, data.invpos.x);\n            if(data.row ==  9) col += rowColor(data) * pInvposy(uv, data.invpos.y);\n            if(data.row == 10) col += rowColor(data) * pInvposz(uv, data.invpos.z);\n            if(data.row == 11) col += rowColor(data) * pInvRadius(uv, data.invradius);\n            if(data.row == 12) col += rowColor(data) * pInvAngle(uv, data.invangle);\n            if(data.row == 13) col += rowColor(data) * pCamerax(uv, data.camera.x);\n            if(data.row == 14) col += rowColor(data) * pCameray(uv, data.camera.y);\n            if(data.row == 15) col += rowColor(data) * pCameraz(uv, data.camera.z);\n            if(data.row == 16) col += rowColor(data) * pTargetx(uv, data.target.x);\n            if(data.row == 17) col += rowColor(data) * pTargety(uv, data.target.y);\n            if(data.row == 18) col += rowColor(data) * pTargetz(uv, data.target.z);\n        }\n        \n        uv.y += 0.8;  \n    }\n    \n    if(length(col) > 0.)\n    fragColor.xyz = col;\n}   \n\n// animation routines ----------------------------------------\n\nvoid cycleValue(inout float value, float vmin,float vmax, float speed) {\n    float ratio = 0.5 + 0.5 * cos(iTime * speed);  // 0 ... 1\n    value = vmin + (vmax - vmin) * ratio;\n}\n\nvoid cycleValue2(inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = baseValue-deviation + deviation * ratio;\n}\nvoid cycleValue2b(inout float value, float baseValue, float deviation, float speed) {\n    float ratio = 1.0 + sin(iTime * speed);  // 0 ... 2\n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3(inout float value, float baseValue, float amount, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    float deviation = baseValue * amount * 0.5;    \n    value = baseValue-deviation + deviation * ratio;\n}\n\nvoid cycleValue3Vec3(inout vec3 value, vec3 baseValue, float amount, float speed) {\n    for(int i=0;i<3;++i)\n        cycleValue3(value[i],baseValue[i],amount,speed);\n}\n\nvoid moveCamera(inout Dataset data) {\n    const float amt = 0.25;\n    cycleValue2(data.camera.x,0.0,amt, 0.35);\n    cycleValue2b(data.camera.y,0.0,amt, 0.45);\n    cycleValue2(data.camera.z,data.camera.z,0.4, 0.15);\n}\n\nvoid moveTarget(inout Dataset data) {\n    cycleValue2(data.target.x,-1.0,8.0, 0.3);\n    cycleValue2(data.target.y,0.0,8.0, 0.4);\n    cycleValue2(data.target.z,0.0,8.0, 0.5);\n}\n    \nvoid alterLight(inout Dataset data) {\n   cycleValue(data.lightColor.x,0.,5.,0.3);\n   cycleValue(data.lightColor.y,0.,5.,0.4);\n   cycleValue(data.lightColor.z,0.,5.,0.5);\n   \n   const float dist = 1.0;\n   cycleValue(data.lightPosition.x,-dist,dist,0.3);\n   cycleValue(data.lightPosition.y,-dist,dist,0.35);\n   cycleValue(data.lightPosition.z,-dist,dist,0.4);\n   \n   cycleValue(data.lightParam.x,0.,1.,0.2); // diffuse\n   cycleValue(data.lightParam.y,0.,1.,0.3); // specular\n   cycleValue(data.lightParam.z,5.,10.,0.4); // ambient\n}\n\nvoid alterOrbitColors(inout Dataset data) {\n    const float weight = 4.;\n    cycleValue(data.OXwt,-weight,weight,0.2); // weights\n    cycleValue(data.OYwt,-weight,weight,0.3);\n    cycleValue(data.OZwt,-weight,weight,0.5);\n //   cycleValue(data.OWwt,-weight,weight,0.07);\n\n    const float color = 5.0;\n    cycleValue(data.OXcr,-color,color,0.1);  // color code\n    cycleValue(data.OYcr,-color,color,0.2);\n    cycleValue(data.OZcr,-color,color,0.3);\n    cycleValue(data.OWcr,-color,color,0.5);\n    \n    cycleValue(data.Ocenter.x,-1.,1.0,0.3);\n    cycleValue(data.Ocenter.y,-1.,1.0,0.5);\n    cycleValue(data.Ocenter.z,-1.,1.0,0.7);\n}\n\nvoid animateSpecifiedVariables(inout Dataset data) {\n    if(!data.animationEnable) return; \n\n    const float amt = 0.3;\n    cycleValue2(data.C.x,data.C.x,amt,0.1);\n    cycleValue2(data.C.y,data.C.y,amt,0.2);\n    cycleValue2(data.C.z,data.C.z,amt,0.3);\n    \n    cycleValue2(data.offset,data.offset,amt,0.1);\n    cycleValue2(data.kNum,data.kNum,amt,0.2);\n    cycleValue2(data.kMax,data.kMax,amt,0.3);\n     \n    alterLight(data); \n    cycleValue(data.Ostrength,0.01,0.3,0.2);\n    alterOrbitColors(data);\n\n/*\n    cycleValue(data.Ostrength,0.01,0.3,0.2);\n    alterOrbitColors(data);\n\n    alterLight(data); \n    moveCamera(data);\n    moveTarget(data);\n\n    cycleValue3(data.Ocycle,OcycleDefault,1.2,0.1);\n    alterOrbitColors(data);\n\n    cycleValue3(data.Ostrength,OstrengthDefault,1.2,0.1);\n*/\n}\n\n// --------------------------------------------------------\n    \nvoid downloadData(ivec2 address,inout float v1,inout float v2,inout float v3) {\n    vec3 d = fetchData(iChannel0, address).xyz;\n    v1 = d.x; v2 = d.y; v3 = d.z;\n}    \n\nvoid readStoredData(inout Dataset data) {\n    float unused = 0.;\n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    data.focus = int(sd.x);\n    data.displayCount = int(sd.y);\n    data.animationEnable = bool(sd.z == 1.0);\n    \n    downloadData(P0_ADDR,data.C.x,data.C.y,data.C.z);\n    downloadData(P1_ADDR,data.offset,data.kNum,data.kMax);\n    downloadData(P2_ADDR,data.iterOffset,data.kOffset,data.invpos.x);\n    downloadData(P3_ADDR,data.invpos.y,data.invpos.z,data.invradius);\n    downloadData(P4_ADDR,data.invangle,data.camera.x,data.camera.y);\n    downloadData(P5_ADDR,data.camera.z,data.target.x,data.target.y);\n    downloadData(P6_ADDR,data.target.z,unused,unused);\n    \n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    data.inversionEnable = bool(sd.x == 1.0);\n    data.stereoEnable = bool(sd.y == 1.0);\n    data.juliaEnable = bool(sd.z == 1.0);\n    \n    data.viewVector = fetchData(iChannel0, VV_1).xyz;\n    data.sideVector = fetchData(iChannel0, VV_2).xyz;\n    data.topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\nvoid initializedNonStoredData(inout Dataset data) {\n    data.maxsteps = 8;\n    data.orbitTrap = vec4(10000.);\n    data.epsilon = 0.00001; // deviation when calculating normal\n    \n    data.ambient = 0.1;\n    data.contrast = 1.8;\n    data.vibrant = 0.01;\n    data.dim = 0.02;\n\tdata.color = vec3(0,0,0); \n\n    data.fogDistance = -0.017 ; // set to 0.0 to disable fog\n    data.fogAmount = 0.25;\n    data.fogColor = 0.2;\n    \n    data.lightColor = vec3(2.5,1.5,0.5); // set to 0.0 to disable light #1\n    data.lightPosition = vec3(9.,10.,-10.0);\n    data.lightParam = vec3(0.6,0.3,3.);\n    \n    data.Ostrength = OstrengthDefault;\n    data.Ocycle = OcycleDefault;\n    data.OXwt = OXwtDefault;\n    data.OXcr = OXcrDefault;\n    data.OYwt = OYwtDefault;\n    data.OYcr = OYcrDefault;\n    data.OZwt = OZwtDefault;\n    data.OZcr = OZcrDefault;\n    data.OWwt = OWwtDefault;\n    data.OWcr = OWcrDefault;\n    data.Ocenter = OcenterDefault;\n    \n    data.parallax = 0.02; // use smaller values when viewing closeup objects\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Dataset data;\n    readStoredData(data);\n    initializedNonStoredData(data);\n    animateSpecifiedVariables(data);\n\n    setDirection(fragCoord,data);\n\trayMarch(data);\n    \n\tif(data.depth < MAX_DIST) {  \n        data.position = data.camera + data.direction * data.depth;\n        calcNormal(data);\n\t\tapplyColoring(data);\n    }\n\n    if(data.fogDistance != 0.0) {\n        float f = data.depth - data.fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * data.fogAmount);\n            data.color = mix(data.color, vec3(0.2 + f * data.fogColor),f);\n        }\n    }\n\n    fragColor = vec4(data.color,1.0);\n    \n    if(data.displayCount > 0) \n        displayData(data,fragColor,fragCoord);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float cxDefault = 1.5225;\nconst float cyDefault = 0.288;\nconst float czDefault = 1.789;\nconst float offsetDefault = 0.98;\nconst float kNumDefault = 1.777;\nconst float kMaxDefault = 1.973;\nconst float iterDefault = -0.448;\nconst float kOffDefault = 0.001;\n\nconst vec3  cameraDefault = vec3(4.84,0.63,-0.39); \nconst vec3  targetDefault = vec3(4.74,18.61,2.2); \nconst vec3  invposDefault = vec3(0.081,0.2915,0.7482);\nconst float invradiusDefault = 1.3589;\nconst float invangleDefault = 0.9706;\n\nconst float OstrengthDefault = 0.0;\nconst float OcycleDefault = 0.0;\nconst float OXwtDefault = 2.0736677;\nconst float OXcrDefault = -3.9815997;\nconst float OYwtDefault = 2.03396538;\nconst float OYcrDefault = 1.71172849;\nconst float OZwtDefault = -2.74972636;\nconst float OZcrDefault = -0.55577678;\nconst float OWwtDefault = 0.0; \nconst float OWcrDefault = -4.24845531;\nconst vec3  OcenterDefault = vec3(-0.5); \n\n// ========================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\nconst ParamData[] pData = ParamData[]( // 20 entries\n    // p0 ---------------\n    ParamData(cxDefault, -5.0, 5.0, 0.01), \n    ParamData(cyDefault, -5.0, 5.0, 0.01),\n    ParamData(czDefault, -5.0, 5.0, 0.01),\n    // p1 ---------------\n    ParamData(offsetDefault, 0.001, 2.5, 0.1),\n    ParamData(kNumDefault, 0.01, 4., 0.01),\n    ParamData(kMaxDefault, 0.01, 14., 0.005),\n    // p2 ---------------\n    ParamData(iterDefault, -1., 4., 0.01),\n    ParamData(kOffDefault, -0.2, 0.1, 0.001),\n    ParamData(invposDefault.x, -15., 15., 0.01),\n    // p3 ---------------\n    ParamData(invposDefault.y, -15., 15., 0.01),\n    ParamData(invposDefault.z, -15., 15., 0.01),\n    ParamData(invradiusDefault, 0.01, 10., 0.01),\n    // p4 ---------------\n    ParamData(invangleDefault, -5., 5., 0.001), \n    ParamData(cameraDefault.x, -20., 20., 0.01), \n    ParamData(cameraDefault.y, -20., 20., 0.01),\n    // p5 ---------------\n    ParamData(cameraDefault.z, -20., 20., 0.01),\n    ParamData(targetDefault.x, -20., 20., 0.01), \n    ParamData(targetDefault.y, -20., 20., 0.01),\n    // p6 ---------------    \n    ParamData(targetDefault.z, -20., 20., 0.01)\n);\n\nconst int PDATA_SIZE = 19;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR = ivec2(2, 0);\nconst ivec2 P1_ADDR = ivec2(3, 0);\nconst ivec2 P2_ADDR = ivec2(4, 0);\nconst ivec2 P3_ADDR = ivec2(5, 0);\nconst ivec2 P4_ADDR = ivec2(6, 0);\nconst ivec2 P5_ADDR = ivec2(7, 0); \nconst ivec2 P6_ADDR = ivec2(8, 0); \n\nconst ivec2 UNIFORM_1 = ivec2(10, 0);\nconst ivec2 VV_1 = ivec2(11, 0);   // view vectors\nconst ivec2 VV_2 = ivec2(12, 0);\nconst ivec2 VV_3 = ivec2(13, 0);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n\n// ========================================================================\n// EasyText: https://www.shadertoy.com/view/dsGXDt\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel3\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).x * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n\n    (0 _DOT ); // Print a dot\n    \n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const ivec2[] storeAddr = ivec2[]( P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR );\n\nvoid initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<7;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < PDATA_SIZE-1) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE-1) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE-1) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n \nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 camera,target;        \n        camera.xy  = fetchData(iChannel0, P4_ADDR).yz;\n        camera.z = fetchData(iChannel0, P5_ADDR).x;\n        target.xy = fetchData(iChannel0, P5_ADDR).yz;\n        target.z = fetchData(iChannel0, P6_ADDR).x;\n\n        vec3 viewVector = normalize(target - camera);\n        vec3 sideVector = vec3(0.0, 1.0, 0.0);\n        sideVector = cross(sideVector,viewVector);\n        sideVector = normalize(sideVector);\n        vec3 topVector = viewVector;\n        topVector = cross(topVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nvoid alterFocusedVariable(int focus,int axis,inout vec3[10] memory) {\n    if(focus > PDATA_SIZE-1) return;\n    float changeAmount = 0.;\n\n    if(axis == 0) { // arrow keys affect only focused variable \n        if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n        if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n    }\n\n    // mouse affects focused variable and also next one --------------\n    if(iMouse.z > 0.0) { // left mouse button down\n        vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n        if(axis == 0) changeAmount = delta.x;\n        if(axis == 1) changeAmount = -delta.y; // flip Y axis\n     }\n\n    if(changeAmount != 0.) {\n        int focusIndex = focus / 3;  // memory index\n        int focusField = focus % 3;  // x,y,z field within\n        acceleratedValue(changeAmount);\n        memory[focusIndex][focusField] += changeAmount;\n        memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    }\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n           \n    updateViewVectors(fragColor, fragCoord);\n    \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    const vec3 m = vec3(0.);\n    vec3[] memory = vec3[](m,m,m,m,m,m,m,m,m,m);\n           \n    // fetch current values\n    for(int i=0;i<7;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false;\n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n    alterFocusedVariable(focus,  0,memory);\n    alterFocusedVariable(focus+1,1,memory);\n    \n    // output possibly altered values\n    for(int i=0;i<7;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n\n    if(getKeyState(KEY_LEFT) || getKeyState(KEY_RIGHT) || iMouse.z > 0.0) resetDisplayCount = true;\n    \n    // alter focus.  update displayCount. toggle animationEnable -----------------------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        \n        bool kym = getKeyClick(KEY_UP);\n        bool kyp = getKeyClick(KEY_DOWN);\n        \n        if(iFrame % 15 == 0) { // slow down auto repeat of up/dn arrows\n            kym = getKeyState(KEY_UP);\n            kyp = getKeyState(KEY_DOWN);\n        }\n        \n        float focusChange = 0.;\n        if(kym) focusChange = -1.; else\n        if(kyp) focusChange = +1.;\n\n        if(focusChange != 0.) {\n            fragColor.x += focusChange;\n\n            if(fragColor.x < 0.0) fragColor.x = float(PDATA_SIZE-1);\n            if(fragColor.x >= float(PDATA_SIZE)) fragColor.x = 0.0;\n\n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(fragCoord, UNIFORM_1)) {\n        fragColor = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) fragColor.xyz = vec3(0.);\n\n        bool ki = getKeyClick(73); // 'I'\n        bool ks = getKeyClick(83); // 'S'\n        if(ki) fragColor.x = (fragColor.x == 0.) ? 1. : 0.;\n        if(ks) fragColor.y = (fragColor.y == 0.) ? 1. : 0.;\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}