{
    "Shader": {
        "info": {
            "date": "1556881373",
            "description": "move by ESDF keys+mouseDrag\nedited \nhttps://www.shadertoy.com/view/WtfGRj\nand made a bug,that results in 2of3 shadows of 1 object getting the color of the materialID, instead of being a monochrome shadow within a [relativistic diffuse light] function.",
            "flags": 48,
            "hasliked": 0,
            "id": "tlfGRj",
            "likes": 3,
            "name": "RE6bug1 materialColor-ed shadows",
            "published": 3,
            "tags": [
                "time",
                "slow",
                "relativity",
                "lorentz",
                "lightspeed",
                "dilation"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 484
        },
        "renderpass": [
            {
                "code": "/*\nself  : https://www.shadertoy.com/view/WtfGRj\nparent: https://www.shadertoy.com/view/tdfXDl\n/**/\n\n\n\n#define CauseMaterialColoredShadowsBug\n\n\n\n\nvec4 Get(float a\n){return texture(iChannel0,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\n\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\n\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float matID\n){if(matID>7.)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*matID*2.)*fakeOA\n ;}\n\nvoid MarchLight(inout Ray r, float startTime, float maxDist\n){float totalDist = 0.0\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;totalDist += r.dist\n  ;r.b+= r.dir*(r.dist)\n  ;if(abs(r.dist)<rayEps||totalDist>maxDist)break;}}\n  \nvoid MarchPOV(inout Ray r, float startTime\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])//es100 error , no array of class allowed\n  ;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  //\n  // t' = Y(t-v*(x/Y)/c²)\n  // t' = Y(0-v*(x/Y)/c²)\n  // t' = Y(v*x/Y)/c²\n  // t' = vx/c²\n  ;float relativeInstantEvents = SimultaneousEvents*dDirDpos*camDist/(cSpe*cSpe)\n  ;r.time = startTime\n  ;r.time += mix(relativeInstantEvents,photonDelay,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection = (objPos[oBlackHole]-r.b)//es100 error , no array of class allowed\n  ;r.dir+=(1./RayPrecision)*r.dist*normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<rayEps)break\n  ;r.b+= (1./RayPrecision)*(r.dist)*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\n\n\n\n\nvec3 GetDiffuse(Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -r.b)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -r.b//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -r.b)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-r.b)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   \n      #define basicBug\n   \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif\n    \n  #endif\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(r.b,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(r.b,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;cDiff+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n\n/*\n\nvec3 GetDiffuse(Ray r\n){Ray tmpRay = r\n ;vec3 surfPos = r.b\n ;float accretion = vma\n ;vec3 diffuseCol = vec3(0)\n ;//accretion disk\n ;int mat = rayMat\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -surfPos)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -surfPos//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -surfPos)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-surfPos)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = surfPos + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-surfPos) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(surfPos,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(surfPos,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;diffuseCol+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  diffuseCol+(lHalo+accretion)*(1.-diffuseCol);}\n\n*/\n\nvec3 GetSampleColor(vec2 uv\n){Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]//es100 error , no array of class allowed\n ;r.dir = qr(objRot[oCam],r.dir)//es100 error , no array of class allowed\n ;MarchPOV(r,playerTime)\n ;return GetDiffuse(r);}\n\nvoid mainImage( out vec4 o, in vec2 u\n){vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime = Get(ReTime).x\n ;//vec3 LZZ = dpos\n ;//vec3 LZY = vec3(0,1,0)\n ;//vec3 LZX = cross(LZY,normalize(LZZ))\n ;//LZY = cross(LZZ,LZX)\n ;//LZLgthContract = mat3x3(LZX,LZY,LZZ)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;ProcessCamPos(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iChannel0,u/iResolution.xy).rgba );\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\nrelativistic engine, with mutable/slower speedOfLight\n\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n\n\n-See the result of a blinking light, slowly drawing waves on the walls.\n\n\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\n\nblatantly false\n- shadows are unaffected by gravity\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow\n\nDoes not simulate:\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- Mass of object\n/**/\n\n//ESDF keyboard layout is more compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n\n//light settings\n#define cSpe 2.5\n//SpeedOfLight in meter/second\n//divides by /(cSpe*cSpe), so do not make it too large!\n#define cLag 1.\n//PhotonLatency [0..1]; zero=instant vision,makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1.\n//take relative velocity of photons to camera & distort field of view\n\n//optical settings\n#define dopplerFactor .5\n//take player/object/light vel to shift color\n#define repeatDoppler 0\n\n//relativity\n#define LgthContraction  1.\n//shrink map along velocity vector at high speed\n#define TimeDilation 1.\n//speed map frame time at high speed\n#define SimultaneousEvents 1.\n//see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2\n//take light source speed into account and their own time dilation\n\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n\n\n//player and cam\n#define fishEye false\n#define FOV 1.3\n//1.57 = 90\n#define maxSpeed 2.4\n//do not go over speed of light it breaks time & space\n#define thrustForce 15.\n//player acceleration\n\n\n\n#define RayPrecision 1.\n#define maxStepRayMarching 80\n#define MaxRayDist 9.0\n\n\n\n#define rayEps 0.001\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n\n\n#define gravity vec3(0.,-3.,0.)\n\n#define pi acos(-1.)\n\n#define vec1 float\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\nvec3 rainbow(vec1 a,vec1 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(vec1 a,vec1 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(vec1 a){return rainbow(a,1./3.);}\nvec3 rainbow2(vec1 a){return rainbow2(a,1./3.);}\n\n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = o;\n#define endMaterial() } if (o != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\nint nextMat;\nint rayMat;\nint rayObj;\nfloat matSize;\nfloat lastrDist;\nfloat lastrDistObj;\nvec4 volumetricCol;\n\n\n//BuffCoords of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer]\n//- 0<=x<Resolution.xy\n\n#define RePos   0.\n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n#define ReTime  5.\n#define ReCol   6.  //not used by Image\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\nfloat varWdth = 5.;\n//#define ReTraT  9.  \n//float PROPER_D_POS = 8.;\n//float TRAIN_TIME = 9.;\n\n//float varWdth = 5.;\n/*\nfloat POS = 0.;\nfloat D_POS = 1.;\nfloat DD_POS = 2.;\nfloat QUAT = 3.;\nfloat D_QUAT = 4.;\nfloat TIME = 5.;\nfloat COLLISION = 6.;\nfloat CAM_PITCHYAW = 7.;\nfloat PROPER_D_POS = 8.;\nfloat TRAIN_TIME = 9.;\n*/\n\n\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays of structparams: \n#define objNum 7\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n//for below object properties;\nvec4 [objNum] objRot;//rotation\nvec3 [objNum] objPos;//position\nvec3 [objNum] objVel;//velocity\nvec3 [objNum] objSca;//scale\n//float[objNum] objRad;//radius optimization\n//\n//lights have no labels\nvec4 [numLights] oliCol;//colorIntensity;\nvec3 [numLights] oliPos;//position\nfloat[numLights] oliHal;//HaloResult\n//float[numLights] oliSiz;//size\n\n\n\nfloat maxGISize;//what is this?\nfloat lorentzF;\n//mat3x3 LZLgthContract;\nvec3 pos;\n//vec3 dpos;\nfloat playerTime;\n\nint curObj = 0;//es100 error , first class array\nint minObjDepth = -1; \n     \n//Quaternions\n/*\n//asserting that length of quaternions are close to 1\n//we can normalize() by dividing by the squaredLength dot(a,a)! \nvec4 qn(vec4 q){return q/dot(q,q);}\n/**/\nvec4 qn(vec4 q){return q/dot(q,q);}\nvec4 aa2q(float b,vec3 a// b must be normalized!\n){b*=.5;return qn(vec4(a*sin(b),cos(b)));}\n\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nvec4 q2aa(vec4 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nvec4 qm(vec4 a, vec4 b\n){vec4 res= vec4(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return normalize(res);}\nvec3 qr(vec4 q,vec3 v\n){vec3 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n\n//Basic Ray marching primitives\nfloat sphere(vec4 ray,vec3 u, float radius\n){maxGISize = max(maxGISize,radius*ray.w)\n ;return ray.w*(length(ray.xyz-u)-radius);}\n\nfloat cylinderY(vec4 ray,vec3 u, float radius, float height\n){maxGISize=max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xz-u.xz)\n -radius, abs(ray.y-u.y)-height));}\n\nfloat cylinderZ(vec4 ray,vec3 u, float radius, float height\n){maxGISize = max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xy-u.xy)\n -radius, abs(ray.z-u.z)-height));}\n\nfloat cube(vec4 ray, vec3 u, float size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n\nfloat line(vec4 ray, vec3 u, float size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(ray.z,ray.y);}\n\nfloat box(vec4 ray, vec3 u, vec3 size\n){maxGISize = max(maxGISize,length(size)*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n\n//DopplerShift\nfloat GetMatch(vec3 c,vec3 s,float t //col,shiftedFreq,targetFreq\n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;c*=max(max(vec3(0),1.-abs(s)*3.),1.-abs(s-1.)*3.)\n #else\n ;c*=max(vec3(0),1.-abs(s)*3.)\n #endif\n ;return c.x+c.y+c.z;}\n//dopplerShiftFactor\nvec3 dsf(vec3 c,vec3 f//all values of f are identical.\n){f*=vec3(1.,1.257,1.58)\n ;vec3 r=vec3(1,2,4)/3.\n ;return vec3(GetMatch(c,f,0. )+GetMatch(c,f,1.)*.3+GetMatch(c,f,-r.x)*.2\n             ,GetMatch(c,f,r.x) \n             ,GetMatch(c,f,r.y)+GetMatch(c,f,1.)*.5+GetMatch(c,f,r.z)*.25);}\nvec3 dsf(vec3 c,float f){return dsf(c,vec3(f));}\n//vec3 DopplerShift(vec3 c,float s//color,speed\n//){return dsf(c,vec3(cSpe/(cSpe-s*dopplerFactor)));}\n\nvec4 Transform(int i,vec4 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(vec3(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\n\nvoid ProcessCamPos(vec3 u, vec4 rot\n){objPos[oCam]= u\n ;objRot[oCam]=rot;}//es100 error , no array of class allowed\n\nfloat LorentzFactor(float v//velocity\n){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\n\nvec3 dpos;//relevant for each pixel of [RE] and [Image] \n\nvoid ProcessObjectPos(float time\n){objPos[oCubeMy]=vec3(0) \n ;objRot[oCubeMy]=aa2q(time*2.,vec3(0,1,0))//es100 error , no array of class allowed\n ;objSca[oCubeMy]=vec3(.8)//es100 error , no array of class allowed\n ;objPos[oBlackHole]=vec3(5.,sin(time*0.2),-5.)//es100 error , no array of class allowed\n ;objRot[oBlackHole]=aa2q(time*2.,vec3(0,1,0))//es100 error , no array of class allowed\n ;objSca[oBlackHole]=vec3(1)//es100 error , no array of class allowed\n ;objPos[oCubeChil]=vec3(1)//es100 error , no array of class allowed\n ;objRot[oCubeChil]=aa2q(time*1.,normalize(objPos[oCubeChil]))//es100 error , no array of class allowed\n ;//o_myCubeChildren.rot = vec4(0,0,0,1)\n ;objSca[oCubeChil]=vec3(.4)//es100 error , no array of class allowed\n ;float trainV = 2.2\n ;objVel[oTrain]= vec3((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0)//es100 error , no array of class allowed\n ;float trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.//es100 error , no array of class allowed\n ;objPos[oTrain]=vec3(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTrain]=aa2q(pi*.5,vec3(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTrain]= vec3(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;//objects[o_train].b.x = 0.//es100 error , no array of class allowed\n ;objPos[oTunnel]=vec3(0,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTunnel]=aa2q(pi*.5,vec3(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTunnel]=vec3(1.,1.,1)//es100 error , no array of class allowed\n ;objPos[oTunnelDoor]=objPos[oTunnel]//es100 error , no array of class allowed\n ;objRot[oTunnelDoor]=objRot[oTunnel]//es100 error , no array of class allowed\n ;float open = clamp((1.-abs(3.*objPos[oTrain].x))*2.,0.,1.)//es100 error , no array of class allowed\n ;objSca[oTunnelDoor]= vec3(open,open,1);}//es100 error , no array of class allowed\n//es100 error , no array of class allowed\nvoid ProcessLightValue(float t\n){oliPos[0]=vec3(6.,1.,sin(t))\n ;oliCol[0]=3.*vec4(0.2,1.,.2,1)\n ;oliPos[1]=vec3(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*vec4(1,1,0.5,1)\n ;oliPos[2]=vec3(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*vec4(1,.2,1,1);}\nvoid SetTime(float t){ProcessLightValue(t);ProcessObjectPos(t);}//es100 error , no array of class allowed\n\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n#define VOL(func)  if (func < rDist)\n\n//volume marching accumulator, used for blackHoleAccretionDisk\nfloat vma=0.;\n\nfloat map(vec3 pos, int processedMaterial\n){float o = 0. //0. if first operation is a SUB(), 1e10 otherwise\n ;maxGISize = 0.\n ;rayObj = 0\n ;vec4 w = vec4(pos,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(box(w,vec3(0,0,0),vec3(10,2.5,10)))\n ;ADD(cylinderY(w,vec3(-6,0,-2.),0.1,3.))\n ;ADD(cylinderY(w,vec3(5,0,-2.),0.1,3.))\n ;endMaterial()\n     \n     \n ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color\n ;//ADD(box(c,vec3(0,0,0),vec3(1)))\n ;//c.xz = abs(c.xz)\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(sphere(c,vec3(0,0,0),1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;vec4 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(sphere(blackHoleSpace,vec3(0,0,0),.5))\n ;endMaterial()\n ;vec4 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(box(tunnelSpace,vec3(0,.5,0),vec3(.2,.1,1.5)))\n ;ADD(box(tunnelSpace,vec3(0,-.5,0),vec3(.2,.1,1.5)))\n ;endMaterial()\n ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(box(tunnelDoorSpace,vec3(0,0,1.4),vec3(.2,.4,0.1)))\n ;ADD(box(tunnelDoorSpace,vec3(0,0,-1.4),vec3(.2,.4,0.1)))\n ;endMaterial()\n ;vec4 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(box(trainSpace,vec3(0,0,-.8),vec3(.1,.1,.18)))\n ;ADD(box(trainSpace,vec3(0,0,-.4),vec3(.1,.1,.18)))\n ;ADD(box(trainSpace,vec3(0,0,0),vec3(.1,.1,.18)))\n ;ADD(box(trainSpace,vec3(0,0,.4),vec3(.1,.1,.18)))\n ;ADD(box(trainSpace,vec3(0,0,.68),vec3(.1,.1,.06)))\n ;ADD(cylinderZ(trainSpace,vec3(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;float tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0; L<3; L++\n ){\n  ;ADD(sphere(w,oliPos[L]\n              //o_lights[L].b\n              ,0.001))\n  ;\n  ;vec3 relPos = oliPos[L]-pos//o_lights[L].b\n  ;oliHal[L]//o_lights[L].haloResult \n      += o*(0.02/(dot(relPos,relPos)+0.01))\n  ;}\n ;return o;}\n\nvec4 GetNormal(vec3 u\n){vec2 e = vec2(0.003,0.)\n ;float o=map(u,-1)\n ;return vec4(normalize(vec3(map(u+e.xyy,-1)\n                            ,map(u+e.yxy,-1)\n                            ,map(u+e.yyx,-1))-o),o);}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//[RE]= [Relativity Engine] v6\n\n\nvec4 Get(float a\n){return texture(iChannel0,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\n\nfloat keyDif(vec2 a){a/=255.\n ;return texture(iChannel1,vec2(a.x,.2)).x\n        -texture(iChannel1,vec2(a.y,.2)).x;}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\n/*\nbool Processing(float c, float d\n){//float a=d-c*varWdth\n ;//float b=varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (abs(d-c*varWdth-.5*varWdth)*2.<varWdth)//(0.<a&&a<b)\n ;}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingold(float c, float d\n){float a=d-c*varWdth\n ;float b=(c*varWdth+varWdth)-c*varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (0.<a&&a<b);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingolderstill(float c, float d\n){return  (d-c*varWdth>0.)\n        &&(d-c*varWdth<(c+1.)*varWdth-c*varWdth);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)*/\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){if(u.y>10.||u.x>varWdth*10.\n ){o=vec4(0.);return;}\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;vec4 quat = Get(ReQua)\n ;vec4 dquat = Get(ReQuaD)\n ;float time = Get(ReTime).x\n ;float deltaT = min(0.1,iTimeDelta)\n ;float plf = LorentzFactor(length(dpos))\n ;time += deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(time)\n ;ProcessCamPos(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir = normalize(dpos)\n ;vec4 normDist = GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm = normDist.xyz\n ;float proxAlert = normDist.a\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(iMouse.xy-iMouse.zw)/iResolution.yy\n ;if(iMouse.x == 0. && iMouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(iMouse.z <= 0.)joystick = vec2(0)\n ;pitchYaw += joystick*deltaT\n ;pitchYaw.y = clamp(pitchYaw.y,-pi*.45,pi*.45)\n ;quat = aa2q(pitchYaw.x,vec3(0,1,0))\n ;right =qr(quat,vec3(1.,0.,0.))\n ;quat = qm(aa2q(-pitchYaw.y,right),quat)\n ;//quat = MulQuat(aa2q(-deltaT*joystick.x,forward),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))\n //;float thurst=keyDif(vec2(KEY_E,KEY_D)) \n// ;float strafe=keyDif(vec2(KEY_F,KEY_S))\n ;acc+=keyDif(vec2(KEY_E,KEY_D))*groundForwardDir*thrustForce\n ;acc+=keyDif(vec2(KEY_F,KEY_S))*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(Proc(RePos         ,v,w))o=vec4(pos,1.)\n ;if(Proc(RePosD       ,v,w))o=vec4(dpos,1.)\n ;if(Proc(ReQua        ,v,w))o=vec4(quat)\n ;if(Proc(ReQuaD      ,v,w))o=vec4(dquat)\n ;if(Proc(RePosDD      ,v,w))o=vec4(acc,1.)\n ;if(Proc(ReTime        ,v,w))o=vec4(time)\n ;if(Proc(ReCol   ,v,w))o=vec4(proxAlert)\n ;if(Proc(ReCamR,v,w))o=vec4(pitchYaw,0,0);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}