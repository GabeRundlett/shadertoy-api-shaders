{
    "Shader": {
        "info": {
            "date": "1540849135",
            "description": "connotated and mildly crunched/fixed fork of \nhttps://www.shadertoy.com/view/4dfyzf",
            "flags": 0,
            "hasliked": 0,
            "id": "lt3fDS",
            "likes": 73,
            "name": "Procedural Pattern ",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "basic",
                "texture",
                "pattern",
                "collection"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 3414
        },
        "renderpass": [
            {
                "code": "\n//---------------------------------------------------------\n// Shader: 2dProceduralPattern.glsl  by gPlatl\n//\n// A collection of 2d procedural pattern types.\n// Press mouse button and select pattern in x direction & zoom in y direction.\n//\n//   v1.0  2017-02-22  initial release\n//   v1.1  2017-02-24  changed mod(x,1.) => fract(x)\n//   v1.2  2017-03-15  pattern menu added\n//   v1.3  2017-04-11  sine pattern added\n//   v1.4  2017-04-30  brick wall pattern added\n//   v1.5  2017-05-07  GearPattern added\n//   v1.6  2017-05-30  HexagonalTruchetPattern added\n//   v1.7  2017-06-10  QCirclePattern added\n//   v1.8  2017-08-05  StarPattern added\n//   v1.9  2017-09-02  Basketwork Pattern added\n//   v1.10 2018-07-14  Diamond Pattern added\n//   v1.11 2018-09-15  RosettePattern added\n//   v1.12 2018-10-11  Wallpaper70sPattern added\n//   v1.13 2018-10-11  MinimalWeavePattern added\n//\n// tags:   procedural, pattern, 2d, basic, texture, collection\n// note:   procedural pattern routines will return values from 0.0 .. 1.0\n//\n// references:\n//   Procedural Patterns          http://slideplayer.com/slide/6400090/\n//   Antialiasing Proc. Textures  http://www.yaldex.com/open-gl/ch17lev1sec4.html\n//---------------------------------------------------------\n\n#define patternCount 23.0\n\n#define PI 3.141592\n\nbool ANIMATE = true;   // false if mousePressed\n\n#define pi acos(-1.)\n#define dd(a) dot(a,a)\n#define sat(a) clamp(a,0.,1.)\n#define aA(z) (z/min(iResolution.x,iResolution.y))\n\n\nfloat mi(vec2 a){return min(a.x,a.y);}\nfloat mi(vec3 a){return min(a.x,mi(a.yz));}\nfloat ma(vec2 a){return max(a.x,a.y);}\nfloat mu(vec2 a){return a.x*a.y;}\nfloat ad(vec2 a){return a.x+a.y;}\nfloat su(vec2 a){return a.x-a.y;}\nfloat sq2(float a){return a*a;}\n\n\n//i think gears are a VERY special thing, too complex for this SIMPLE patter ncollection\n//gears must be seperate collection because\n//- gears logically overlap, on a lattice this means: https://www.shadertoy.com/results?query=halfspace\n//- polar coordinates invite complex transdorms, including sphere inversion\n//- gears (due to polar complex numbers) quickly extend into 3d and 4d)\nfloat GearPattern(in vec2 uv     // coordinates\n                 ,in float wn    // vertical wheel count\n                 ,in int tn      // tooth count\n                 ,in float time) // rotation time\n{float g = (step(1.0, uv.x * wn) - 0.5) * time;\n  uv = fract(uv * wn) - 0.5;\n  float r = clamp(0.48, 0.4, 0.45 + 0.12*sin(atan(uv.x,uv.y) * float(tn) + g));\n  return smoothstep(r, r + 0.01, 1.1*length(uv));}\n\nfloat CheckerSignMuFract(vec2 u){return sign(mu(.5-fract(u)));}\n\n\n//sat(sin()) or mu(sin()) is pretty lame/inconsistent for patterns\nfloat CheckerSatMuSin(vec2 u){return sat(88.*mu(sin(u*8.)));}//rounded white checkerboard\nfloat Checker1ByMuSin(vec2 u){return 1./mu(sin(u));}\nfloat TartanKaro(  vec2 u){return .5*ad(sat(10.*sin(u)));}\nfloat TartanSquare(vec2 u){return 4.*mu(sat(10.*sin(u)));}\n\nfloat SquareHolePattern(vec2 u\n){u.x=mu(sin(u*2.))\n ;return smoothstep(.1,.0, sq2(u.x)*2.5);}\n\nfloat Grid( vec2 u){\n ;//return ad(abs(fract(u)-.5))//initially was mu(), without -.5 offset, but thats just too trivial\n ;return mi(abs(fract(u)-.5))//, and BrickPattern() without shift\n ;}\n\nfloat BrickPattern(vec2 p\n){//p*=vec2 (1,2)  // scale\n ;vec2 f=floor(p)\n ;p.x-=step(f.y,2.*floor(f.y*.5))*.5// brick shift\n ;p=abs (fract (p + 0.5) - 0.5)\n ;//p=smoothstep (0.03, 0.08, p)\n ;return min(p.x,p.y)\n ;}\n\nvec2 toTri(vec2 u){return vec2(u.x,(u.y*sqrt(3.)+u.x)*.5);}\n\nfloat TrianglePattern(vec2 u){return step(su(fract(toTri(u))),0.);}//non-homogeneous doesnt smoothstep()\n\nfloat RhombStar(vec2 u\n){u.x=sq2(su(fract(toTri(u))))\n ;return step(.25,u.x)//this is less silly\n ;//return smoothstep(.5,.0,u.x)//rather silly (optical illusion) //doesnt mix well with above line)\n ;}\n\nfloat hexBorder(vec2 u//subroutine of HexagonalGrid()\n){\n ;u.x*=sqrt(3.)*2./3.\n ;u.y+= 0.5 * mod(floor(u.x), 2.0)\n ;u = abs(fract(u)-.5)\n ;return abs(max(u.x*1.5+u.y,u.y*2.)-1.)\n ;}//return smoothstep(0., gridThickness,d);\n\nbool fuckme(vec2 a){float b=(1.-a.y)*.5// return hexagonal gridID pattern with 3 colors\n ;return a.y>1.&&(abs(b-a.x+a.y)>-b);}\nbool fuckus(vec2 p){ return 1.>ma(p-p.yx)&&max(-mi(p),ma(p)-2.)<0.;}\nfloat hexId3Hues(in vec2 p\n){p =toTri(p)\n ;p = mod(p,vec2(3))\n ;     if(fuckus(p))return .0\n ;else if(fuckme(p))return .5\n ;else              return 1.\n ;}\n\nfloat hexTruchet(vec2 p//https://www.shadertoy.com/view/Xdt3D8 \n){float s=sqrt(3.)\n ;vec2 h=p+vec2(s,.45)*p.y/3.//hex skew\n ;vec2 f=fract(h);h=floor(h)//fractFloor\n ;float v=fract(ad(h)/3.)//+offsetFract\n ;h+=mix(vec2(step(.3,v)),step(f.yx,f),step(.6,v))//(v<.6)?(v<.3)?h:h++:h+=step(f.yx,f)\n ;p+=vec2(1,2.-sqrt(3.))*h.y*.5-h\n ;v=sign(cos(1234.*cos(h.x+9.*h.y)))//v is -1 or 1, appears a bit random\n ;vec3 a=vec3(dd(p-v*vec2(-2, 0)*.5)\n             ,dd(p-v*vec2( 1, s)*.5)\n             ,dd(p-v*vec2( 1,-s)*.5))\n ;v=(.5-sqrt(mi(a)))*v//all below lines are optional modifiers, each line can be commented out individually\n ;//v*=.5\n ;//v=v+.25 \n ;v=abs(v)\n ;v=1.-(1.-v*2.)\n ;float z=8.\n ;return smoothstep(aA(z),-aA(z),v-(cos(iTime)*(.5-aA(z))+.5))\n ;return v\n ;}\n\n\n//vec2 cs(vec2 u){return vec2(cos(u.x),sin(u.y));}\n\nfloat sinePattern(vec2 p){return sin(p.x*20.+cos(p.y*12.));}//trivial elegance, not normalized, but not noticable\nfloat SinePatternCrissCross(vec2 p){return .5+sinePattern(p)*sinePattern(p.yx);}\n\n\n//euclidean length has p=2, this allows for other p.\nfloat lengthP(in vec2 u, in float p){return pow(pow(abs(u.x),p)+pow(abs(u.y),p),1./p);}\n\n//cute small silly noneuclidean squared-circle, whos corners are dark.\nfloat QCirclePattern(vec2 u){return sin(lengthP(fract(u*4./2.)*2.-1.,4.)*16.);}\n\nfloat StarPattern(vec2 p//ttps://www.shadertoy.com/view/4sKXzy \n){p= abs(fract(p*1.5)-.5)//adorable stars, smoothstep() of it is nice, too.\n ;return max(ma(p),mi(p)*2.);}\n\nfloat weaveSub(vec2 u,float p){return step(.2,abs(fract(u.x)))*(.65+.35*sin(p*(u.y-ceil(u.x))));}\nfloat weave(vec2 u,float r//https://www.shadertoy.com/view/ltXcDn \n){float a=weaveSub(u,pi/r)//step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;u=u.yx;u.y++ //flip//offset\n ;float b=weaveSub(u,pi/r) //step(.2,abs(fract(u.x)))*(.65 +.35*sin(pi*.5*(u.y-ceil(u.x))))\n ;return max (a,b);}\nfloat weave(vec2 u){return weave(u,1.);}\n\nfloat truchetTiny70s(vec2 p,float time// https://www.shadertoy.com/view/ls33DN by Shane\n){p.x*=sign(cos(length(ceil(p))*time))\n ;return cos(min(length(p=fract(p)),length(--p))*44.);}\n\n\nfloat xof(float a,float b){return float(int(a)^int(b));}//typecasting, not doing type float bitwise xor!\nfloat anf(float a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\nfloat anf(int   a,float b){return float(int(a)&int(b));}//typecasting, not doing type float bitwise and!\n\n//https://www.shadertoy.com/view/XtcBWH\nfloat weaveInt(vec2 coord// https://www.shadertoy.com/view/XttBWn\n){ivec2 uv=ivec2(floor(coord*5.))//type float as much as possible by ollj, to lerp.\n ;float a=floor(mod(iTime,7.))*4.\n ;float bg  =.0//backdrop\n ;float warp=.5//horizontal\n ;float weft=1.//vertical      \n ;vec2 f=floor(vec2(uv.xy)*.5)\n ;a=anf(uv.x^uv.y,a)\n ;vec2 h=vec2(xof(float(uv.x),f.x),xof(float(uv.y),f.y))\n ;h=fract(h/2.)*2.\n ;vec3 i=smoothstep(1.,0.,vec3(a,h.xy))//if only these booleans where floats.\n ;float d=mix(weft,bg,i.z)\n ;float e=mix(warp,bg,i.y)\n ;float c=mix(d,e,i.x)//trilin mix\n ;//c=mix(1.,0.,i.x-(i.z+i.y)*.5)//many other options feasible...\n ;return c;}//https://en.wikipedia.org/wiki/Striation         ==ridged\n//likely needs a bokeh-ed soerpinsky: https://www.shadertoy.com/view/MlcfDB\n\nfloat demo(vec2 u){\n   ;return weaveInt(u)\n   ;// return smoothstep(-.1,.1,StarPattern(u)-cos(iTime)*.5-.5)\n        ;}\n\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){\n  float aspect = iResolution.y / iResolution.x;\n  vec2 mpos = iMouse.xy / iResolution.y;\n  vec2 uv = fragCoord.xy / iResolution.y - vec2(0.5);\n\n  float time = iTime\n ;ANIMATE = iMouse.z < 1.0\n ;// get pattern\n ;int pType = int( mpos.x * patternCount * aspect)\n ;if (uv.y<-0.4//menu view\n ){pType = int(fragCoord.xy/iResolution.y*patternCount*aspect);\n  uv *= 28.\n ;}else{\n  ;uv *= (0.2 + mpos.y) * 10.0\n  ;if (ANIMATE   // rotate and scale position\n  ){float ra = time*0.12\n   ;float cost = cos(ra)\n   ;float sint = sin(ra)\n   ;uv = vec2(cost*uv.x + sint*uv.y, sint*uv.x - cost*uv.y)\n   ;uv *= (1.2+0.3*sin(0.5*time))   // scale\n  ;}}\n ;//pType=999\n ;float p // = HexagonalGrid(uv, 0.5, 0.1);\n ;p=demo(uv)\n ;if      (pType == 0) p = hexBorder (uv*1.25)\n ;else if (pType == 1) p = hexBorder(uv*1.25) //HexagonalGrid2() is just BAD, skewed and discontinuous\n ;else if (pType == 2) p = hexId3Hues(uv*2.0)\n ;else if (pType == 3) p = hexTruchet (uv*3.)\n ;else if (pType == 4) p = CheckerSignMuFract(uv)\n ;else if (pType == 5) p = Checker1ByMuSin(uv*8.0)\n ;else if (pType == 6) p = TrianglePattern(uv)\n ;else if (pType == 7) p = RhombStar(uv)\n ;else if (pType == 8) p = TartanKaro(uv)\n ;else if (pType == 9) p = TartanSquare(uv)\n ;else if (pType ==10) p = SquareHolePattern(uv)  \n ;else if (pType ==11) p = sinePattern(uv)\n ;else if (pType ==12) p = Grid(uv)\n ;else if (pType ==13) p = BrickPattern(uv)\n //;else if (pType ==13) p = BrickPattern2(uv)//is just a much worse variant of BrickPattern()\n ;else if (pType ==14) p = GearPattern(uv, 1.5, 12, iTime * 6.5)\n ;else if (pType ==15) p = QCirclePattern(uv)\n ;else if (pType ==16) p = StarPattern(uv)\n ;else if (pType ==17) p = weave(uv)\n ;else if (pType ==18) p = weave(uv,2.)\n ;else if (pType ==19) p = weave(uv,3.)\n ;else if (pType ==20) p = weave(uv,4.)\n //;else if (pType ==19) p = DiamondPattern(uv)    //is just a distorted grid()\n //;else if (pType ==20) p = triRosettePattern(uv) //disqualified, for looping a wallpaper-group:\n ;else if (pType ==21) p = truchetTiny70s(uv, iTime*0.1)\n ;else if (pType ==22) p = weaveInt(uv)\n ;else                 p = demo(uv)\n ;vec4 color1 = vec4 (0.2+0.2*sin(time)\n                     ,0.2+0.2*sin(time*0.789)\n                     ,0.2+0.2*sin(time*0.665), 1.0)\n ;vec4 color2 = vec4 (0.9)\n ;//fragColor = mix(color1, color2, p)\n ;fragColor = vec4(p)\n ;}\n\n\n//disqualified, for looping a wallpaper-group: https://en.wikipedia.org/wiki/Wallpaper_group\n//i haver standards, and looping trough a kifs is WAY below that.\n#define DumbEnoughToLoopAWallpaperGroup(U) .004/abs(length(mod(U,d+d)-d)-d.x)\nfloat triRosettePattern(vec2 p//https://www.shadertoy.com/view/4lGyz3\n){vec2 d=vec2(sqrt(3.),3)/3.\n ;vec4 O=vec4(0)\n ;for(; O.a++ < 4.; O += DumbEnoughToLoopAWallpaperGroup(p) +DumbEnoughToLoopAWallpaperGroup(p += d*.5))p.x+=d.x\n ;return O.x;}\n\n\n//---------------------------------------------------------\n// return antialiased hexagonal grid color\n//---------------------------------------------------------\n/* //this one is just lazy and bad!\nfloat HexagonalGrid2 (in vec2 position)\n{\n  vec2 pos = position ;\n  pos.x *= 1.1;\n  pos.y += 0.5 * mod(floor(pos.x), 2.0);\n  pos = abs(fract(pos) - 0.5);\n  float d = abs(max(pos.x*2.5 + pos.y, pos.y*3.0) - 1.0);\n  return smoothstep(0.30, .1, d);\n;}\n*/\n\n/*\n// return brick wall pattern\nfloat BrickPattern2(in vec2 p){//brickpattern2 is just a the dumb cousin of BrickPattern()\n    const float vSize = 0.30;\n  const float hSize = 0.05;\n  p.y *= 2.5;    // scale y\n  if(mod(p.y, 2.0) < 1.0) p.x += 0.5;\n  p = p - floor(p);\n  if((p.x+hSize) > 1.0 || (p.y < vSize)) return 1.0;\n  return 0.0;\n}*/\n\n/*\nfloat DiamondPattern(vec2 u//https://www.shadertoy.com/view/lsVczV\n){u=abs(fract(u)-.5)\n ;return (ma(u));}//without distortions and cosine/smoothstep/scaling, this is just a grid()\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}