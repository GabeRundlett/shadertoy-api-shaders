{
    "Shader": {
        "info": {
            "date": "1675436777",
            "description": "GLSL Partiel 2023 \nJade (Hyunsun) Park\n\nBased on @Shane's Lunar Debris\nUsing Voronoi Algorithm (https://thebookofshaders.com/12/?lan=kr)",
            "flags": 0,
            "hasliked": 0,
            "id": "DtlXWf",
            "likes": 5,
            "name": "Rock'n blob",
            "published": 3,
            "tags": [
                "voronoi",
                "rock"
            ],
            "usePreview": 0,
            "username": "sanivel",
            "viewed": 307
        },
        "renderpass": [
            {
                "code": "// ATI Jade (Hyunsun) Park\n// Based on @Shane's Lunar Debris\n\n#define PI 3.14159265\n#define FAR 60.\n#define SMOOTHING \n\n// Rotation matrix\nconst mat2 rM = mat2(.7071, .7071, -.7071, .7071); \nmat2 rot2( float a )\n{ \n    vec2 v = sin(vec2(1.570796, 0) + a);\t\n    \n    return mat2(v, -v.y, v.x); \n}\n\n// Texture blending \nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{ \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y \n        + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// Smooth\nfloat smaxP(float a, float b, float s)\n{   \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    \n    return mix(b, a, h) + h*(1.0-h)*s;\n}\nvec2 sminP(vec2 a, vec2 b , float s)\n{    \n    vec2 h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    \n    return mix(b, a, h) - h*(1.0-h)*s;\n}\nfloat sminP(float a, float b , float s)\n{    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// Rock \nfloat drawObject(in vec3 p)\n{  \n    p = fract(p)-.5;\n    \n    return dot(p, p);    \n}  \nfloat cellTile(in vec3 p)\n{ \n    vec4 v, d; \n    \n    d.x = drawObject(p - vec3(iTime*0.3));\n    p.xy *= rM;\n    d.y = drawObject(p - vec3(iTime*0.1));\n    p.yz *= rM;\n    d.z = drawObject(p - vec3(iTime*0.1));\n    p.zx *= rM;\n    d.w = drawObject(p - vec3(iTime*.2));\n\n    #ifdef SMOOTHING\n    v.xy = sminP(d.xz, d.yw, .3); \n    #else\n    v.xy = min(d.xz, d.yw);\n    #endif\n    \n    #ifdef SMOOTHING\n    return  sminP(v.x, v.y, .05)*5.0; \n    #else\n    return  min(v.x, v.y)*2.5; \n    #endif        \n}\n\n// Path\nvec2 path(in float z)\n{  \n\n    float a = sin(z * 0.11);\n    float b = cos(z * 0.14);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5); \n}\n\n// Noise\nfloat n3D(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    return mix(h.x, h.y, p.z);\n}\n\n// Field\nfloat map(vec3 p)\n{   \n    p.xy -= path(p.z);\n    \n    p/=2.;\n    \n    vec3 q = p + (cos(p*2.52 - sin(p.zxy*3.5)))*.2;\n    float sf = max(cellTile(q/5.), 0.); \n    \n    p += (cos(p*.945 + sin(p.zxy*2.625)))*.05;\n    #ifdef SMOOTHING\n    float t = .1 - abs(p.x*.05) - abs(p.y);\n    #else\n    float t = .05 - abs(p.x*.05) - abs(p.y);\n    #endif  \n\n    float n = smaxP(t, (.68 - (1.-sqrt(sf)))*2., 1.);\n   \n    return n*1.;   \n}\n\n// Surface\nfloat bumpSurf3D( in vec3 p, in vec3 n)\n{ \n    return (cellTile(p/2.))*.8 + (cellTile(p*1.5))*.2;   \n}\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor)\n{\n    const vec2 e = vec2(0.001, 0);\n    float ref = bumpSurf3D(p, nor);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy, nor),\n                      bumpSurf3D(p - e.yxy, nor),\n                      bumpSurf3D(p - e.yyx, nor) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\t\n}\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf)\n{\n    const vec2 e = vec2(0.1, 0);\n       \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), \n                   tex3D(tx, p - e.yxy, n), \n                   tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.3)*m;\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; \n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf );   \n}\n\n// Raymarch\nfloat trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++)\n    {\n        h = map(ro+rd*t);\n        if(abs(h)<0.0025*(t*.125 + 1.) || t>FAR) break;\n        t += h*.8;      \n    }\n\n    return min(t, FAR);   \n}\n\n// Ambient occlusion\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 0.0, l;\n    const float maxDist = 2.;\n\tconst float nbIte = 2.0;\n    for( float i=1.; i< nbIte+.5; i++ )\n    {  \n        l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist; \n        ao += (l - map( p + n*l ))/(1.+ l);\n    }\n\t\n    return clamp(1.- ao/nbIte, 0., 1.);\n}\n\n// Normal\nvec3 calcNormal(in vec3 p)\n{\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) \n                    + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Shadow\nfloat shadows(in vec3 ro, in vec3 rd, in float start, in float end, in float k)\n{\n    float shade = 3.0;\n    const int shadIter = 36; \n\n    float dist = start;\n\n    for (int i=0; i<shadIter; i++)\n    {\n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        dist += clamp(h, 0.02, 0.2);\n        \n        if ((h)<0.001 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera\n\tvec3 lookAt = vec3(0, 0, iTime*2.0 + 0.1);\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.1);\n\n    // Light position\n \tvec3 lightPos = camPos + vec3(0, 14, 35.0);\n\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n    \n    // Ray\n    float FOV = PI/3.;\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n\trd.xy = rot2( path(lookAt.z).x/16. )*rd.xy;\n\n\tfloat t = trace(camPos, rd);    \n\n    // Scene Color\n    vec3 sceneCol = vec3(0);\n\t\n\tif(t<FAR)\n    {\n\t    vec3 sp = camPos + rd*t;\n        vec3 sn = calcNormal(sp);\n        vec3 snNoBump = sn;\n        \n        const float tSize0 = 1./2.;\n\t    sn = doBumpMap(iChannel0, sp*tSize0, sn, 0.1);\n        vec3 tsp =  sp;\n\n        sn = doBumpMap(tsp, sn, .5);\n          \n\t    float ao = calculateAO(sp, sn);\n        \n\t    vec3 ld = lightPos-sp;\n\n\t    float lDist = max(length(ld), 0.001);\n    \t\n\t    ld /= lDist;\n\n\t    float atten = 1./(1. + lDist*.007);\n    \t\n\t    float ambience = 0.25;\n    \t\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.);\n    \n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 1.);\n\n\t    vec3 texCol = vec3(.8, .9, 1.);\n\t    texCol *= min(tex3D(iChannel0, sp*tSize0, sn)*3.5, 1.);\n        texCol *= bumpSurf3D(sp, sn)*.5 + .5;\n        \n        float shading = shadows(sp + sn*.005, ld, .05, lDist, 8.);\n\n        sceneCol = texCol*(diff + spec + ambience);\n        \n        sceneCol += texCol*vec3(.8, .95, 1)*pow(fre, 1.)*.5;\n\n        sceneCol *= atten*shading*ao;\n\n\t\n\t}\n       \n    // Fog\n    vec3 fog = vec3(0.666, 0.21256, 0.345664)/2.*(rd.y*0.5 + 0.5);    \n    sceneCol = mix(sceneCol, fog, smoothstep(0.0, 0.95, t/FAR));\n\n    // Interaction with Sound\n    int s;\n    float fData = texelFetch( iChannel1, ivec2(s,0), 0 ).x;\n    float wave = texelFetch( iChannel1, ivec2(s,1), 0 ).x;\n    vec3 mCol = vec3( fData, 2.0*fData*(1.0-fData), 1.0-fData ) * fData;   \n\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0.0, 1.0))+mCol, 1.0);\n\t\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}