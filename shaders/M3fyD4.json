{
    "Shader": {
        "info": {
            "date": "1726168597",
            "description": "rings",
            "flags": 1,
            "hasliked": 0,
            "id": "M3fyD4",
            "likes": 0,
            "name": "Rot Ring",
            "published": 3,
            "tags": [
                "3d",
                "lookingglass"
            ],
            "usePreview": 0,
            "username": "bigdra50",
            "viewed": 57
        },
        "renderpass": [
            {
                "code": "\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define resolution iResolution \n#define  time iTime\n#define mouse iMouse \n\n\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define EPS 0.0001\n\nvec3 lightDir = normalize(vec3(1.,1., 1));\n\nfloat dRing(vec3 p, float exR, float inR, float thick){\n\tfloat sdf2d = abs(length(p.xy)-exR)-inR;\n\tfloat d = abs(p.z)-thick;\n\treturn max(sdf2d, d);\n}\nfloat map(vec3 p){\n\tvec3 q=p,r = p;\n\tp.xy *= rot(time*.5);\n\tp.xz *= rot(time*.3);\n\tfloat ring1 = dRing(p, .8, .09, .1);\n\tq.xy *= rot(time*-1.3);\n\tq.xz *= rot(time*-1.);\n\tfloat ring2 = dRing(q, .62, .07, .1);\n\tr.yz *= rot(time*2.);\n\tr.xz *= rot(time*-2.);\n\tfloat ring3 = dRing(r, .47, .06, .1);\n\treturn min(ring1, min(ring2, ring3));\n}\n\nvec3 getNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tmap(p)-map(vec3(p.x-EPS, p.yz)),\n\t\tmap(p)-map(vec3(p.x, p.y-EPS, p.z)),\n\t\tmap(p)-map(vec3(p.xy, p.z-EPS))\n\t\t));\n}\n\t\n\n\n\nvec4 render(in vec3 ro, in vec3 rd) {\n\n\tvec3 col = vec3(.1);\n\tvec3 cur = ro;\n\n\tfor(int i = 0; i <99;i++){\n\t\tfloat d = map(cur);\n\t\tif(d < EPS){\n\t\t\tvec3 normal = getNormal(cur);\n\t\t\tcol = vec3(.6, .68, .8);\n\t\t\tcol+= dot(normal, lightDir)+vec3(.1);\n\t\t\tbreak;\n\t\t}\n\t\tcur += rd*d;\n\t}\n\n\treturn vec4( col, 1.0 );\n\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    fragColor = vec4(render(ro + vec3(0, 0, 9), rd));\n}\n//void mainImage(out vec4 fragColor, in vec2 fragCoord){\n//    fragColor = render(fragCoord);\n//}\n\n\n#define QAA\t2                                     \n\nconst float\tsideAngle = radians(35.0);\nconst float\thorizontalAngle = radians(14.0);\nconst float\tcameraSize = 2.0;\nconst float\taspectRatio = 0.75;\nconst vec3  \tVROffset = vec3(0, 0, 9);\nfloat quiltColumns\t=\t11.;\nfloat quiltRows\t\t=\t6.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4\taccColor = vec4(0.);\n    for( int m = 0; m < QAA; m++ )\n    for( int n = 0; n < QAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = (vec2(float(m), float(n)) / float(QAA) - 0.5) / iResolution.xy                                                                                 ;\n\t\t\n\t\tvec2\tcoord = (fragCoord / iResolution.xy  + o) * vec2(quiltColumns,quiltRows);\n\t\tvec2\tfract = fract(coord);\n\t\tvec2\tfloor = floor(coord);\n\t\tfloat\timageId = floor.x + floor.y * quiltColumns;\n\t\tfloat\tvalueId = imageId / (quiltColumns * quiltRows - 1.);\n\t\tfloat\tdist = (cameraSize / 2.) / tan(horizontalAngle / 2.);\n\t\tfloat\tminCam = -(cameraSize / 2.) - tan(sideAngle / 2.) * dist;\n\t\t\n\t\tvec3\tcamPos = mix(vec3(minCam,0,dist),vec3(-minCam,0,dist),valueId);\n\t\tvec3\tscreenPos = vec3((fract.x-0.5)*cameraSize,(fract.y-0.5)*cameraSize/aspectRatio,0);\n\t\t\n\t\tvec3\tdir = normalize(screenPos - camPos);\n\t\tvec4\tcolor;\n\t\tmainVR(color, fragCoord, camPos - VROffset, dir);\n\t\taccColor += clamp(color, 0.0, 1.0);\n\t}\n\tfragColor = accColor / float(QAA*QAA);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}