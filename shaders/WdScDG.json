{
    "Shader": {
        "info": {
            "date": "1587221148",
            "description": "Created for the Revision 2020 animated gif competition. You can enable DOF and shadows in the common tab if you have a powerful GPU.",
            "flags": 32,
            "hasliked": 0,
            "id": "WdScDG",
            "likes": 80,
            "name": "Bloom [skull]",
            "published": 3,
            "tags": [
                "zoom",
                "flower",
                "loop",
                "skull",
                "succulent"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 1611
        },
        "renderpass": [
            {
                "code": "/*\n\n    Bloom\n    -----\n\n\tCreated for the Revision 2020 animated gif competition, achieving 1st place.\n\tAs this gets rendered to a gif, image quality is given much more importance\n\tthan rendering speed and code size; so yes, this is a lot of code, it takes\n\ta long time to compile, and it runs slow.\n\n\tI’ve disabled shadows and the depth of field pass so this has a chance of\n\trunning, if you have a powerful GPU, you can enable them with the defines\n\tin common.\n\n\tMakes use of a few things I’ve worked on recently:\n\n\t\t* Uses a pseudo-3d texture to cache the skull distance function\n\t\t  https://www.shadertoy.com/view/WljSWz\n\n\t\t* Smooth fractal zoom to an arbitrary point and rotation\n\t\t  https://www.shadertoy.com/view/wslyzH\n\n\t\t* Parametric succulent model\n\t\t  https://www.shadertoy.com/view/WtGXWm\n\n\tThe skull was modelled on this https://sketchfab.com/3d-models/visible-interactive-human-exploding-skull-252887e2e755427c90d9e3d0c6d3025f,\n\tusing a method of overlaying my sdf model on the polygon model, and\n\tadjusting positions/sizes until the surfaces were close enough. It’s a slow\n\tand tedious process, I wouldn’t recommend it! I actually ran out of time to\n\tmodel the zygomatic arch.\n\n\tThis photo by Scott Webb was my colour reference:\n\thttps://www.pexels.com/photo/photo-of-succulent-plants-1903969/\n\n\tSpecial thanks to yx for giving me some serious competition with her entry:\n    http://moonbase.lgbt/misc/yx-hexahedral-recurrence.gif\n\n*/\n\n\n// http://tuxedolabs.blogspot.com/2018/05/bokeh-depth-of-field-in-single-pass.html\n\nvec2 uPixelSize; //The size of a pixel: vec2(1.0/width, 1.0/height)\nfloat uFar = .32; // Far plane\n\nconst float GOLDEN_ANGLE = 2.39996323;\nconst float MAX_BLUR_SIZE = 30.;\nconst float RAD_SCALE = .2; // Smaller = nicer blur, larger = faster\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale) {\n    float coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nfloat dbg;\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale) {\n    vec4 centerTex = texture(iChannel0, texCoord);\n    float centerDepth = centerTex.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = centerTex.rgb;\n    \n    #ifdef DISABLE_DOF\n    \treturn color;\n    #endif\n\n    float tot = 1.0;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE) {\n        dbg += 1.;\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * uPixelSize * radius;\n        vec4 sampleTex = texture(iChannel0, tc);\n        vec3 sampleColor = sampleTex.rgb;\n        float sampleDepth = sampleTex.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        //if (sampleSize < centerSize) break;\n        if (sampleDepth > centerDepth) {\n            sampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n        \n        // modification: exit early when we're in focus\n        if (centerDepth < uFar / 3. && m == 0.) break;\n    }\n    return color /= tot;\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uPixelSize = vec2(.002) / (iResolution.xy / iResolution.y);\n\n    float focusA = .03 * 2.;\n    float focusAStart = .25;\n    float focusAEnd = .65;\n\n    float focusB = .045 * 2.;\n    float focusBStart = .65;\n    float focusBEnd = 1.;\n\n    float time = loopTime(iTime);\n    float blend = smoothstep(focusAStart, focusAEnd, time) - smoothstep(focusBStart, focusBEnd, time);\n    float focus = mix(focusB, focusA, blend);\n\n    dbg = 0.;\n    vec3 col = depthOfField(uv, focus, .05);\n\n    // fix banding\n    vec4 grain = texture(iChannel1, fragCoord.xy / iChannelResolution[1].x);\n\tcol += (grain.x * 2. - 1.) * .002;\n    \n    col = pow( col, vec3(0.4545) ) * sign(col);\n    col = aces(col);\n\n    fragColor = vec4(col, 1);    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define DISABLE_DOF\n#define DISABLE_SHADOWS\n\nfloat loopTime(float iTime) {\n\treturn mod(iTime / 3. + .35, 1.);\n}\n\n// '3D' Texture Utils\n// https://www.shadertoy.com/view/WljSWz\n//--------------------------------------------------------\n\nvec2 texSubdivisions = vec2(8,2);\n\n#define MIRROR\n#define SCALE (vec3(4.1,1.8,1.75))\n#define OFFSET vec3(.95, .05, .05)\n\nint faceIdFromDir(vec3 v) {\n    vec3 va = abs(v);\n    int id = 0;\n    float m = va.x;\n    if (va.y > m) id = 1, m = va.y;\n    if (va.z > m) id = 2;\n    if (v[id] < 0.) id += 3;\n    return id;\n}\n\nvec3 dirFromFaceId(vec2 uv, int id) {\n    vec3 dir = vec3(.5, .5 - uv.yx);\n    dir = normalize(dir);\n    if (id == 4) dir.yz *= -1.;\n    if (id > 2) dir.xz *= -1., id -= 3;\n    if (id == 1) return (dir * vec3(1,-1,-1)).zxy;\n    if (id == 2) return (dir * vec3(1,1,-1)).zyx;    \n    return dir;\n}\n\nvec3 texToSpace(vec2 coord, int c, int id, vec2 size) {\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n    vec2 subCoord = floor(coord / subSize);\n    float z = 0.;\n    z += float(id) * 4. * sub.y * sub.x; // face offset\n    z += float(c) * sub.y * sub.x; // channel offset\n    z += subCoord.y * sub.x; // y offset\n    z += subCoord.x; // x offset\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    z /= zRange;\n    vec2 subUv = mod(coord / subSize, 1.);\n    vec3 p = vec3(subUv, z);\n    p = p * 2. - 1.; // range -1:1\n    return p;\n}\n\nmat4 texToSpace(vec2 coord, int id, vec2 size) {\n    return mat4(\n        vec4(texToSpace(coord, 0, id, size), 0),\n        vec4(texToSpace(coord, 1, id, size), 0),\n        vec4(texToSpace(coord, 2, id, size), 0),\n        vec4(texToSpace(coord, 3, id, size), 0)\n    );\n}\n\nvec4 spaceToTex(vec3 p, vec2 size) {\n    p = clamp(p, -1., 1.);\n    p = p * .5 + .5; // range 0:1\n\n    vec2 sub = texSubdivisions;\n    vec2 subSize = floor(size / sub);\n\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float i = round(p.z * zRange);\n\n    vec2 coord = p.xy * subSize;\n\n    int faceId = int(floor(i / (4. * sub.y * sub.x)));\n    float channel = mod(floor(i / (sub.x * sub.y)), 4.);\n    float y = mod(floor(i / sub.x), sub.y);\n    float x = mod(i, sub.x);\n    \n    coord += vec2(x,y) * subSize;\n\tcoord /= size;\n    \n    vec3 dir = dirFromFaceId(coord, faceId);\n\n    return vec4(dir, channel);\n}\n\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat mapTex(samplerCube tex, vec3 p, vec2 size) {\n    #ifdef MIRROR\n        p.x = clamp(p.x, -.95, .95);\n    #endif\n    vec2 sub = texSubdivisions;\n    float zRange = sub.x * sub.y * 4. * 6. - 1.;\n    float z = p.z * .5 + .5;\n    float zFloor = (floor(z * zRange) / zRange) * 2. - 1.;\n    float zCeil = (ceil(z * zRange) / zRange) * 2. - 1.;\n    vec4 uvcA = spaceToTex(vec3(p.xy, zFloor), size);\n    vec4 uvcB = spaceToTex(vec3(p.xy, zCeil), size);\n    float a = texture(tex, uvcA.xyz)[int(uvcA.w)];\n    float b = texture(tex, uvcB.xyz)[int(uvcB.w)];\n    return mix(a, b, range(zFloor, zCeil, p.z));\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n// Big un-optimised distance function, mekes heavy use\n// of HG_SDF, smooth min, and IQ's accurate ellipse distance\n\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat smin2(float a, float b, float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat smax2(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat smin3(float a, float b, float k){\n    return min(\n        smin(a, b, k),\n        smin2(a, b, k)\n    );\n}\n\nfloat smax3(float a, float b, float k){\n    return max(\n        smax(a, b, k),\n        smax2(a, b, k)\n    );\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nvec3 pRx(vec3 p, float a) {\n    pR(p.yz, a); return p;\n}\n\nvec3 pRy(vec3 p, float a) {\n    pR(p.xz, a); return p;\n}\n\nvec3 pRz(vec3 p, float a) {\n    pR(p.xy, a); return p;\n}\n\n\nfloat vmin(vec2 v) {\n    return min(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCorner(vec3 p, float r) {\n    vec3 d = p + r;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0))) - r;\n}\n\nfloat fCorner(vec2 p, float r) {\n    vec2 d = p + r;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0))) - r;\n}\n\n\n// iq https://www.shadertoy.com/view/MldfWn\nfloat sdEllipse( vec2 p, in vec2 ab )\n{\n    p = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\n    float l = ab.y*ab.y - ab.x*ab.x;\n    \n    float m = ab.x*p.x/l; \n    float n = ab.y*p.y/l; \n    float m2 = m*m;\n    float n2 = n*n;\n    \n    float c = (m2 + n2 - 1.0)/3.0; \n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n    \n    return length(r-p) * sign(p.y-r.y);\n}\n\n// symmetric ellipsoid - EXACT distance\nfloat sdEllipsoidXXZ( in vec3 p, in vec2 r ) \n{\n    return sdEllipse( vec2( length(p.xy), p.z ), r );\n}\n\nfloat sdEllipsoidXXZPill(vec3 p, vec2 r) {\n    p.z = min(p.z, 0.);\n    return sdEllipsoidXXZ(p, r);\n}\n\nfloat fCone(vec3 p, float angle) {\n    vec2 c = vec2(length(p.xz), p.y);\n    pR(c, angle);\n    return length(max(c, vec2(0))) + vmax(min(c, vec2(0)));\n}\n\nfloat fPillHalf(vec3 p) {\n    p.y = min(p.y, 0.);\n    return length(p);\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n    return length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    return fLineSegment(p, a, b) - r;\n}\n\n// curve the x axis around the y axis\nvoid pCurve(inout vec3 p, float r) {\n    p.z -= r;\n    r = abs(r);\n    p = vec3(atan(p.x, -p.z) * r, p.y, length(p.xz) - r);\n}\n\nfloat fMaxillaCore(vec3 p) {\n    float d = 1e12;\n    vec3 pp = p;\n\n    // Core\n    p = pRx(p - vec3(0,.33,-.32), .3);\n    d = length(p.xz) - .18;\n    d = smax(d, -(length((p - vec3(0,0,.1)).xz) - .1), .1);\n    d = smax(d, p.y - .02, .1);\n    d = smax(d, -p.y - .1, .1);\n    p = pp;\n\n    // Gum\n    p = pRx(p - vec3(0,.42,-.29), .4);\n    d = smin(d, sdEllipsoidXXZ(p, vec2(.2, .27)), .07);\n    p = pp;\n\n    // Gum back inner\n    p = pRx(p - vec3(0,.42,-.29), .1);\n    float gumback = pRy(p, .55).z - .01;\n    gumback = smin(gumback, pRy(p, -.55).z - .08, .04);\n    d = smax(d, gumback, .08);\n    p = pp;\n\n    // Gum back outer\n    p = p - vec3(.17,.3,-.24);\n    float part = dot(p, normalize(vec3(1,-.2,1)));\n    d = smax(d, part, .03);\n    p = pp;\n\n    return d;\n}\n\nfloat fMaxillaBottom(vec3 p) {\n    float b = p.z + .15;\n    p = pRx(p - vec3(0,.42,-.29), .42);\n    pCurve(p.zxy, -.8);\n    float d = p.y;\n    return min(d, -b);\n}\n\nfloat fSocketBump(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.13,.04,-.35), .2);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.19,.13));\n    p = pp - vec3(.14,.15,-.35);\n    d = smin(d, sdEllipsoidXXZ(p, vec2(.19,.16)), .07);\n    p = pp - vec3(.24,.03,-.38);\n    d = smin(d, length(p) + .005, .15);\n    return d;\n}\n\nfloat fSocketInset(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.16,.08,-.4), .3);\n    p.z = max(p.z, 0.);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.08,.05));\n    p = pRz(pp - vec3(.18,.15,-.4), .2);\n    d = smin(d, sdEllipsoidXXZ(p.xzy, vec2(.042,.02)), .16);\n    p = pp - vec3(.235,.1,-.43);\n    d = smin(d, length(p) - .023, .08);\n    p = pp - vec3(.26,.11,-.36);\n    d = smax(d, dot(p, normalize(vec3(1,.2,1))) + .01, .04);\n    return d;\n}\n\nfloat fSocket(vec3 p) {\n    vec3 pp = p;\n    p = pRz(pp - vec3(.15,.06,-.38), .7);\n    float d = sdEllipsoidXXZ(p.xzy, vec2(.11,.08));\n    p = pRz(pp - vec3(.15,.16,-.38), -.15);\n    d = smin(d, sdEllipsoidXXZ(p.xzy, vec2(.08,.03)), .1);\n    p = pp - vec3(.26,.11,-.36);\n    d = smax(d, dot(p, normalize(vec3(1.5,.2,1))) + .01, .04);\n    return d;\n}\n\nfloat fNoseShape(vec3 p) {\n    p = pRz(p, -.4);\n    return sdEllipse(p.xy - vec2(-.055, 0), vec2(.1,.18));\n}\n\nfloat fNose(vec3 p) {\n    p = pRx(p - vec3(.0,.25,-.5), .4);\n    float d = smax(fNoseShape(p), fNoseShape(p * vec3(-1,1,1)), .02);\n    d = smax(d, p.y-.09, 0.04);\n    d = smax(d, -sdEllipse(p.xy - vec2(0,.18), vec2(.02,.1)), 0.03);\n    d = max(d, -p.z-.15);\n    d = smax(d, p.z-.05, .05);\n    return d;\n}\n\nfloat fNoseCut(vec3 p) {\n    float r = .3;\n    p = pRy(pRx(p - vec3(0,.49,-.57), -.45), .35);\n    return length(p.yz + vec2(0,r)) - r;\n}\n\nfloat fArchhole(vec3 p) {\n    p = pRz(pRy(p - vec3(.3,.15,-.25), -.4), .3);\n    vec3 pp = p;\n    p -= vec3(.045,0,0);\n    float d = dot(p, normalize(vec3(1,0,-.12))) + .01;\n    p = pp - vec3(0,0,-.085);\n    d = smax(d, -dot(p, normalize(vec3(0,-.14,1))), .05);\n    p = pRy(pRz(pRx(pp - vec3(.035,.1,-.08), -.29), -.2), .6);\n    float h = .1;\n    p.z += .013;\n    p.z -= h;\n    d = smin(d, sdEllipse(p.xz, vec2(.03, h)), .04);\n    p = pp - vec3(.015,-.29,0);\n    d = smax(d, -dot(p, normalize(vec3(-.1,1,.35))), .1); // top\n    p = pp - vec3(-.05,0,-.05);\n    d = smax(d, dot(p, normalize(vec3(-1,-.05,-.4))) - .005, .05);\n    p = pp - vec3(-.038,-.1,.05);\n    d = smax(d, dot(p, normalize(vec3(-.8,-.21,.08))) - .005, .03);\n    p = pRz(pRy(pp - vec3(0,-.084,.25), .4), -.27);\n    d = smax(d, -(length(p.zy) - .16), .15);\n    p = pp - vec3(0,.2,.04);\n    d = smax(d, dot(p, normalize(vec3(-.2,.8,1))), .05);\n    p = pp;\n    d = smax(d, p.y-.25, .1);\n    return d;\n}\n\nfloat sdSkull(vec3 p) {\n\n    p.x = abs(p.x);\n    vec3 pp = p;\n    float d = 1e12;\n    float back = sdEllipsoidXXZ(p - vec3(0,-.11,.16), vec2(.4, .32));\n    d = min(d, back);\n    float base = length(p - vec3(0,-.08,.25)) - .15;\n    d = smin(d, base, .3);\n    float baseside = length(p - vec3(.2,.1,.25)) - .05;\n    d = smin(d, baseside, .25);\n    float forehead = sdEllipsoidXXZ(pRx(p - vec3(0,-.15,-.14), .5), vec2(.35, .44) * .97);\n    d = smin(d, forehead, .22);\n    float foreheadside = length(p - vec3(.17,-.13,-.3)) - .05;\n    d = smin(d, foreheadside, .25);\n    float socketbump = smin(fSocketBump(p), fSocketBump(p * vec3(-1,1,1)), .15);\n    d = smin(d, socketbump, .09);\n\n    p = pRx(p - vec3(0,.23,-.45), -.55);\n    float bridge = sdEllipse(p.xz, vec2(.06, .15));\n    bridge = max(bridge, -p.y-.3);\n    d = smin(d, bridge, .1);\n    p = pp;\n\n    p = pRy(pRx(p - vec3(.22,.3,-.4), .4), -.1);\n    float cheek = smax(sdEllipsoidXXZ(p.zyx, vec2(.02, .05)), -p.z, 0.05);\n    d = smin(d, cheek, 0.1);\n    p = pp;\n    float maxilla = fMaxillaCore(p);\n    d = smin(d, maxilla, .08);\n    float foramen = fCone(pRx(pRy(p - vec3(.17,.27,-.465), .5), -.5) * vec3(1,-1,1), .6);\n    foramen = smax(foramen, p.y-.45, .1);\n    d = smax(d, -foramen - .01, .05);\n\n    float socketinset = smin(fSocketInset(p), fSocketInset(p * vec3(-1,1,1)), .2);\n    d = smax(d, -socketinset, .12);\n    float socket = fSocket(p);\n    d = smax(d, -socket, .04);\n    float backbump = sdEllipsoidXXZ(pRx(pRy(p - vec3(.27,-.29,.0), -.25), .0), vec2(.1, .5) * .25);\n    d = smin(d, backbump, .34);\n    float topbump = sdEllipsoidXXZ(p - vec3(0,-.33,-.05), vec2(.1, .15) * .5);\n    d = smin(d, topbump, .3);\n\n    float side = sdEllipsoidXXZ(pRz(p - vec3(.2,.05,-.0), .3).yzx, vec2(.1, .05));\n    d = smin(d, side, .25);\n\n    // bridge adjust\n    p = pRx(p - vec3(0,.2,-.5), -.2);\n    d = smin(d, max(length(p.xz) - .03, -p.y-.3), .05);\n    p = pp;\n\n    // canine socket\n    p = pRy(pRz(p - vec3(.14,.55,-.495), -.4), .5);\n    p.x = max(p.x, 0.);\n    float caninesocket = length(p.xz) - .01;\n    caninesocket = smax(caninesocket, -p.y-.2, .01);\n    d = smin(d, caninesocket, .03);\n    p = pp;\n\n    // Nose\n    float nos = fNose(p);\n    d = smin(d, nos-.01, .02);\n    p = pp;\n\n    float nosecut = smin(fNoseCut(p), fNoseCut(p * vec3(-1,1,1)), .04);\n    d = smax(d, -nosecut, .01);\n    p = pp;\n\n    // Nose hole\n    float nosb = fPillHalf((p - vec3(.0,.362,-.54)).xzy) - .005;\n    nosb = max(nosb, p.z+.4);\n    d = smin(d, nosb, .05);\n    d = smax(d, -nos+.005, .02);\n\n    p = pp;\n    d = smax(d, fMaxillaBottom(p), .02);\n    float roof = sdEllipsoidXXZ(p - vec3(0,.47,-.28), vec2(.13, .22));\n    d = smax(d, -roof, .03);\n\n    float temporal = sdEllipsoidXXZ(pRy(pRz(p - vec3(.25,.1,-.03), .2), -.4).yzx, vec2(.18, .08));\n    temporal = smax(temporal, dot(p.zy, normalize(vec2(-.3,1))) - .2, .1);\n    d = smin(d, temporal, .15);\n\n    float archhole = fArchhole(p);\n    d = smax(d, -archhole, .03);\n\n    return d;\n}\n\n\nfloat map(vec3 p) {\n    p -= OFFSET;\n    p /= SCALE;\n   \treturn sdSkull(p);\n\treturn length(p) - .45;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    int id = faceIdFromDir(rayDir);\n    \n    vec2 coord = fragCoord.xy;\n    vec2 size = iResolution.xy;\n    vec2 uv = coord / size;\n    \n    vec4 lastFrame = texture(iChannel0, rayDir);\n    if (lastFrame.x != 0. && iFrame > 2) {\n        fragColor = lastFrame;\n    \treturn;\n    }\n    \n    mat4 space = texToSpace(coord, id, size);\n    vec4 result = vec4(0);\n    \n    for (int i = 0; i < 4; i++) {\n    \tresult.x = map(space[i].xyz);\n        result = result.yzwx;\n    }\n    \n    fragColor = result;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            },
            {
                "code": "#define ZERO (min(iFrame,0))\n#define PI 3.1415926\n#define HALF_PI 1.5707963267948966\n\nmat3 basisMatrix(vec3 forward, vec3 up) {\n    vec3 ww = normalize(forward);\n    vec3 uu = normalize(cross(up,ww));\n    vec3 vv = normalize(cross(ww,uu));\n    return mat3(uu, vv, ww);\n}\n\nmat3 orientMatrix(vec3 up, vec3 forward) {\n    mat3 m = basisMatrix(up, forward);\n    return mat3(m[0], m[2], -m[1]);\n}\n\n\n\n//========================================================\n// Fractal camera loop\n// https://www.shadertoy.com/view/wslyzH\n//========================================================\n\nvec3 stepPosition;\nfloat stepScale;\nmat3 stepRotate;\n\n\n// Quaternions\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 qmul(vec4 q1, vec4 q2) {\n    return vec4(\n        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n        q1.w * q2.w - dot(q1.xyz, q2.xyz)\n    );\n}\nvec3 rotate_vector(vec3 v, vec4 r) {\n    vec4 r_c = r * vec4(-1, -1, -1, 1);\n    return qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\nvec4 rotate_angle_axis(float angle, vec3 axis) {\n    float sn = sin(angle * 0.5);\n    float cs = cos(angle * 0.5);\n    return vec4(axis * sn, cs);\n}\n\nvec3 calcCylinderNormal(vec3 a, vec3 b, vec3 c) {\n    vec3 tangent = a - c;\n    vec3 binormal = cross(a - b, c - b);\n    vec3 normal = normalize(cross(tangent, binormal));\n    return normal;\n}\n\nvec3 calcAxis() {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec3 v2 = v1 + stepRotate * stepPosition;\n    vec3 v3 = v2 + stepRotate * stepRotate * stepPosition;\n    vec3 n0 = calcCylinderNormal(v0, v1, v2);\n    vec3 n1 = calcCylinderNormal(v1, v2, v3);\n\tvec3 axis = normalize(cross(n0, n1));\n    return axis;\n}\n\nmat3 calcAxisMatrix(vec3 axis) {\n    return basisMatrix(axis, vec3(0,1,0));\n}\n\nfloat findAngle(vec2 a, vec2 b, vec2 c) {\n    return acos(dot(normalize(b - a), normalize(c - a)));\n}\n\nfloat calcSpokeAngle(vec2 a, vec2 b, vec2 c) {\n    float angle = findAngle(b, a, c);\n    angle = PI - angle;\n    float side = sign((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x));\n    return angle * -side;\n}\n\nfloat calcSpokeAngle(mat3 mAxis) {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec3 v2 = v1 + stepRotate * stepPosition;\n    vec2 point0 = (v0 * mAxis).xy;\n    vec2 point1 = (v1 * mAxis).xy;\n    vec2 point2 = (v2 * mAxis).xy;\n    float spokeAngle = calcSpokeAngle(point0, point1, point2);\n    return spokeAngle;\n}\n\nvec2 rotate(vec2 p, float a) {\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvec2 calcCenter(vec2 point0, vec2 point1, float scale, float spokeAngle) {\n    float s = scale;\n    float side0 = distance(point0, point1);\n    float angle0 = spokeAngle;\n    float side1 = side0 / sqrt((s * s) - 2. * s * cos(angle0) + 1.);\n    float side2 = s * side1;\n    float angle2 = asin((side2 * sin(angle0)) / side0);\n    vec2 center = vec2(sin(angle2), cos(angle2)) * side1;\n    vec2 v = point1 - point0;\n    center = rotate(center, atan(v.x, v.y));\n    center += point0;    \n    return center;\n}\n\nvec3 calcApex(vec3 axis, mat3 mAxis, float spokeAngle) {\n    vec3 v0 = vec3(0);\n    vec3 v1 = stepPosition;\n    vec2 point0 = (v0 * mAxis).xy;\n    vec2 point1 = (v1 * mAxis).xy;\n    vec2 center2 = calcCenter(point0, point1, stepScale, spokeAngle);\n    vec3 center = vec3(center2, 0) * inverse(mAxis);\n    float v1Height = dot(v1, axis);\n    float v1Radius = distance(center, v1 - axis * v1Height);\n    vec3 apex = center + axis * v1Height * (length(center) / (length(center) - v1Radius));\n    return apex;\n}\n\nvec3 cameraAxis;\nfloat cameraAngle;\nvec3 cameraApex;\n\nvoid cameraPrecalc() {\n    cameraAxis = calcAxis();\n    mat3 mAxis = calcAxisMatrix(cameraAxis);\n    cameraAngle = calcSpokeAngle(mAxis);\n    cameraApex = calcApex(cameraAxis, mAxis, cameraAngle);\n}\n\nfloat tweenCamera(inout vec3 p, float t) {\n    float scale = 1. / pow(stepScale, t);\n    float angle = abs(cameraAngle) * t;\n    vec4 rot = rotate_angle_axis(angle, cameraAxis);\n    p -= cameraApex;\n    p = rotate_vector(p, rot);\n    p /= scale;    \n    p += cameraApex;\n    return scale;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\n// Utils\n// HG_SDF, stack.gl\n//--------------------------------------------------------\n\nfloat easeOutSine(float t) {\n  return sin(t * HALF_PI);\n}\n\nfloat easeOutCirc(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nconst float PHI = 1.61803398875;\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pR2d(vec2 p, float a) {\n    return cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat cmax(float a, float b, float r) {\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nmat3 rotX(float a) {\n\treturn mat3(\n    \t1, 0, 0,\n        0, cos(a), -sin(a),\n        0, sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a) {\n\treturn mat3(\n    \tcos(a), 0, sin(a),\n        0, 1, 0,\n        -sin(a), 0, cos(a)\n    );\n}\n\nmat3 rotZ(float a) {\n\treturn mat3(\n    \tcos(a), -sin(a), 0,\n        sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n// Types\n//--------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 p;\n    bool isBound;\n    int id;\n    bool isBloom;\n    vec2 uv;\n    vec2 cell;\n    float wedges;\n    float slice;\n    float len;\n    float neg; // subtract from distance\n    float crackdepth;\n};\n\nModel newModel() {\n    return Model(1e12, vec3(0), false, 0, false, vec2(0), vec2(0), 0., 0., 0., 1e12, 0.);\n}\n\nModel opU(Model a, Model b) {\n    Model m = a;\n    if (b.d < a.d) {\n        m = b;\n    }\n    m.neg = min(a.neg, b.neg);\n    return m;\n}\n\n\n// Config\n//--------------------------------------------------------\n\nfloat skullOffset;\nfloat skullRadius;\nmat3 skullRotate;\nvec3 bloomPosition;\nmat3 bloomRotate;\nfloat delay;\n\nfloat time;\nbool lightingPass;\n\nfloat boundEps;\nfloat globalScale;\n\nconst float CUTOFF = 3.6; // remove old itrerations when they're out of view\n\nstruct BloomSpec {\n    vec2 density;\n    float thickness;\n    float width;\n    float pointy;\n    float size;\n    bool hideInside;\n};\n\nstruct BloomInstance {\n\tvec3 pos;\n    mat3 rot;\n    float offset;\n    float start;\n    float stop;\n    BloomSpec spec;\n};\n\nBloomInstance[4] bloomInstances;\n\nvoid precalcBloomInstances() {\n\n    bloomInstances[0] = BloomInstance(\n        vec3(-.2,.2,.25), //pos\n        orientMatrix(vec3(-1,.7,.9), vec3(0,1,0)), //rot\n        .02, //offset\n        -.8, //start\n        1., //stop\n        BloomSpec(\n            vec2(.08, 1.), //density\n            .11, //thickness\n            .39, //width\n            .4, //pointy\n            .11, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[1] = BloomInstance(\n        vec3(-.135,.105,.35) * .98, //pos\n        orientMatrix(vec3(-.7,.2,.9), vec3(0,1,0)), //rot\n        .0, //offset\n        -1.1, //start\n        .8, //stop\n        BloomSpec(\n            vec2(.48, 1.8), //density\n            .08, //thickness\n            .45, //width\n            .0, //pointy\n            .07, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[2] = BloomInstance(\n        vec3(.22,.23,.2), //pos\n        orientMatrix(vec3(.5,.3,.2), vec3(1,1,0)) * rotY(.3), //rot\n        .05, //offset\n        -.1, //start\n        1.5, //stop\n        BloomSpec(\n            vec2(.12, 1.45), //density\n            .07, //thickness\n            .17, //width\n            .0, //pointy\n            .14, //size\n            false //hideInside\n        )\n    );\n    \n\tbloomInstances[3] = BloomInstance(\n        vec3(.28,.07,.18) * .85, //pos\n        orientMatrix(vec3(1,-.3,.5), vec3(1,1,0)), //rot\n        .1176, //offset\n        -.5, //start\n        1.5, //stop\n        BloomSpec(\n            vec2(.15, 1.45), //density\n            .15, //thickness\n            .41, //width\n            .0, //pointy\n            .085, //size\n            false //hideInside\n        )\n    );   \n}\n\n\nstruct CrackInstance {\n    vec3 pos;\n    mat3 rot;\n    float start;\n    float stop;\n    vec2 weight;\n\n\tfloat angle;\n    vec2 offset;\n    vec2 size;\n    float lines;\n    float seed;\n};\n\nCrackInstance[7] crackInstances;\n\nvoid precalcCrackInstances() {\n\n    crackInstances[0] = CrackInstance(\n    \tvec3(.28,.1,.15), //pos\n    \torientMatrix(vec3(1,-.1,.2), vec3(1,1,0)) * rotY(2.2) * rotZ(.9), //rot\n    \t-.3, //start\n    \t.7, //stop\n    \tvec2(.001, .03), //weight\n\t\t0., //angle\n    \tvec2(.015,-.02), //offset\n    \tvec2(.15,.03), //size\n    \t18., //lines\n    \t11. //seed\n    );\n\n    crackInstances[1] = CrackInstance(\n    \tvec3(.28,.18,.18)*.98, //pos\n    \torientMatrix(vec3(1,.4,.4), vec3(1,1,0)), //rot\n    \t-.7, //start\n    \t.3, //stop\n    \tvec2(.001, .03), //weight\n\t\t1., //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.03), //size\n    \t13., //lines\n    \t14. //seed\n    );\n    \n    crackInstances[2] = CrackInstance(\n    \tvec3(.28,.18,.18)*.98, //pos\n    \torientMatrix(vec3(1,.4,.4), vec3(1,1,0)), //rot\n    \t-.7, //start\n    \t.3, //stop\n    \tvec2(.001, .03), //weight\n\t\t3.6, //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.03), //size\n    \t16., //lines\n    \t16. //seed\n    );\n    \n    crackInstances[3] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t1., //angle\n    \tvec2(.015,-.02)*1.2, //offset\n    \tvec2(.12,.05)*1.2, //size\n    \t10., //lines\n    \t1. //seed\n    );\n    \n    crackInstances[4] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t3., //angle\n    \tvec2(0), //offset\n    \tvec2(.12,.05)*1.2, //size\n    \t10., //lines\n    \t4. //seed\n    );\n    \n    crackInstances[5] = CrackInstance(\n        bloomInstances[0].pos - bloomInstances[0].rot * vec3(0,0,.02), //pos\n        bloomInstances[0].rot, //rot\n    \t-1., //start\n    \t.0, //stop\n    \tvec2(.001, .03)*1.2, //weight\n\t\t5.5, //angle\n    \tvec2(-.01,.02)*1.2, //offset\n    \tvec2(.08,.02)*1.2, //size\n    \t12., //lines\n    \t3. //seed\n    );\n    \n\n    crackInstances[6] = CrackInstance(\n        vec3(.3,.29,-.03), //pos\n        orientMatrix(vec3(.5,.3,.05), vec3(1,0,1)), //rot\n    \t-.7, //start\n    \t.6, //stop\n    \tvec2(.001, .1), //weight\n\t\t3.2, //angle\n    \tvec2(0), //offset\n    \tvec2(.18,.06), //size\n    \t15., //lines\n    \t17. //seed\n    );\n}\n\n\n// Bloom model\n// https://www.shadertoy.com/view/WtGXWm\n//--------------------------------------------------------\n\nModel leaf(vec3 p, vec3 cellData, float thickness, float pointy, float width, bool shrinkOuter) {\n    \n    vec2 cell = cellData.xy;\n    float cellTime = cellData.z;\n    \n    float d = 1e12;\n    float d2 = 1e12;\n    float slice = 1e12;\n    float wedge, wedges;\n\n    // orient\n    pR(p.xz, -cell.x);\n    pR(p.zy, cell.y);\n\n    vec3 pp = p;\n\n    cellTime = max(cellTime, 0.);\n\n    float core = length(p) - .1;\n\n    float len = max(cellTime*3. - .2, 0.);\n\n    if (shrinkOuter) {\n        len *= mix(.2, 1., rangec(-.5, .0, cell.y));\n    }\n\n    len = pow(len, .33);\n\n    float llen = len;\n\n    Model model = newModel();\n\n    if (cellTime > 0.) {\n\n        // wedge\n        float ins = .25;\n        p.z += ins;\n        vec3 n = normalize(vec3(1,0,.35));\n        wedge = -dot(p, n);\n        wedge = max(wedge, dot(p, n * vec3(1,1,-1)));\n        wedge = smax(wedge, p.z - len*1.12 - ins, len);\n        p.z -= ins;\n\n        // wedge2\n        ins = .2;\n        p.z += ins;\n        n = normalize(vec3(1,0,width));\n        float wedge2 = -dot(p, n);\n        wedge2 = smax(wedge2, dot(p, n * vec3(1,1,-1)), .1);\n        wedge2 = smax(wedge2, p.z - len*.95 - ins, len*.6);\n        p.z -= ins;\n\n        float r = len / 8.;\n\n        float top = p.y - len * .5;\n        float curve = smoothstep(0., .2, cellTime);\n\n        len *= mix(1.5, .65, curve);\n        pR(p.zy, -mix(.2, .7, curve));\n        slice = length(p - vec3(0,len,0)) - len;\n        d2 = abs(slice) - thickness;\n        d2 = max(d2, top);\n        \n        float wedgeT = smax(d2, wedge, thickness);\n        float wedgeT2 = smax(d2, wedge2, thickness);\n        d = mix(wedgeT2, smin(wedgeT, wedgeT2, .01), pointy);\n        wedges = mix(wedge2, wedge2, pointy);\n        \n        p = pp;\n        len = llen;\n        vec2 uv = p.xz / len;\n\n        model.p = p;\n        model.d = d;\n        model.isBloom = true;\n        model.uv = uv;\n        model.cell = cell;\n        model.wedges = mix(wedge2, smin(wedge, wedge2, .01), pointy);\n        model.slice = slice;\n        model.len = len;\n        model.neg = smax(max(slice, top), wedges, .01);\n        return model;\n    }\n\n    model.d = d;\n    model.p = p;\n    return model;\n}\n\nvec3 calcCellData(\n    vec2 cell,\n    vec2 offset,\n    float maxBloomOffset,\n    mat2 transform,\n    mat2 transformI,\n    float stretch,\n    float stretchStart,\n    float stretchEnd,\n    float t,\n    bool hideInside\n) {\n\n    float sz = maxBloomOffset + PI / 2.;\n\n    cell = transform * cell;\n\n    // Snap to cell center\n    cell = round(cell);\n    cell += offset;\n\n    // Hide leaves outside the growth area\n    cell = transformI * cell;\n    cell.y *= stretch / sz / stretchStart;\n    cell.y = max(cell.y, 4.4/stretchEnd); // clamp, not sure why this magic number\n    if (hideInside) {\n        cell.y = min(cell.y, 1.21/stretchStart); // clamp, not sure why this magic number\n    }\n    cell.y /= stretch / sz / stretchStart;\n    cell = transform * cell;\n\n    // Snap after clamp\n    cell = round(cell);\n\n    cell = transformI * cell;\n\n    // calculate cell time\n    float y = cell.y * (stretch / sz);\n    float cellAppearTime = (stretchStart - y) / (stretchStart - stretchEnd);\n    float cellTime = t - cellAppearTime;\n\n    cell.y -= maxBloomOffset;\n\n    return vec3(cell, cellTime);\n}\n\nmat2 phyllotaxis;\nvoid calcPhyllotaxis() {\n    vec2 cc = vec2(5., 8.);\n    float aa = atan(cc.x / cc.y);\n    float scale = (PI*2.) / sqrt(cc.x*cc.x + cc.y*cc.y);\n    mat2 mRot = mat2(cos(aa), -sin(aa), sin(aa), cos(aa));\n    mat2 mScale = mat2(1./scale,0,0,1./scale);\n    phyllotaxis = mRot * mScale;\n}\n\nModel drawBloom(\n    vec3 p,\n    float t,\n    vec2 density,\n    float thickness,\n    float pointy,\n    float width,\n    bool hideInside\n) {\n    pR(p.xz, .7);\n\n    Model model = newModel();\n\n    t = rangec(-.1, 1., t);\n\n    p.y -= mix(0., .25, t);\n\n    vec2 move = vec2(0, t);\n    float stretchStart = density.x;\n    float stretchEnd = density.y;\n    float stretch = mix(stretchStart, stretchEnd, t);\n    float maxBloomOffset = PI / 5.;\n\n    vec2 cell = vec2(\n        atan(p.x, p.z),\n        atan(p.y, length(p.xz)) + maxBloomOffset\n    );\n\n    mat2 mStretch = mat2(1,0,0,stretch);\n    mat2 transform = phyllotaxis * mStretch;\n    mat2 transformI = inverse(transform);\n    bool shrinkOuter = hideInside;\n\n    // compile speed optim from IQ\n    for( int m=ZERO; m<3; m++ )\n    for( int n=ZERO; n<3; n++ )\n    {\n        model = opU(model, leaf(\n            p,\n            calcCellData(cell, vec2(m,n)-1., maxBloomOffset, transform, transformI, stretch, stretchStart, stretchEnd, t, hideInside),\n            thickness,\n            pointy,\n            width,\n            shrinkOuter\n        ));\n    }\n\n    return model;\n}\n\nModel drawBloom(vec3 p, float t, BloomSpec spec) {\n    p /= spec.size;\n    globalScale *= spec.size;\n    Model model;\n    float bound = length(p) - mix(.7, mix(.8, 2.4, spec.width), t);\n    if ( ! lightingPass && bound > boundEps / globalScale) {\n\t\tmodel = newModel();\n        model.d = bound;\n        model.neg = bound;\n        model.isBound = true;\n    } else {\n        model = drawBloom(\n            p,\n            t,\n            spec.density,\n            spec.thickness,\n            spec.pointy,\n            spec.width,\n            spec.hideInside\n        );\n    }\n    model.d *= spec.size;\n    model.neg *= spec.size;\n    globalScale /= spec.size;\n\treturn model;\n}\n\n\n// Crack model\n//--------------------------------------------------------\n\nvec2 hash2(vec2 p) {\n    return textureLod( iChannel1, -(p+0.5)/256.0, 0.).xy;\n}\n\nfloat fLine(vec2 p, vec2 a, vec2 b) {\n\treturn dot(p - a, normalize(b - a) * mat2(0,-1,1,0));\n}\n\nvec2 getPoint(float x, int offset, float seed, vec2 size, vec2 scale) {\n   \tfloat cell = (floor(x / scale.x) + float(offset));\n    float inv = mod(cell, 2.) * 2. - 1.;\n   \tvec2 pos = hash2(vec2(cell, seed));\n    pos.y *= inv;\n    pos.y *= scale.y;\n    float ramp = cell / size.x * scale.x / 2.;\n    pos.y *= 1. - ramp;\n   \tpos += vec2(cell, 0.);\n    pos.x *= scale.x;\n    return pos;\n}\n\nfloat fCrack(vec2 p, vec2 size, float lines, float seed, float weight) {\n    float bound = max(-p.x - weight/2., p.x - size.x * 2.);\n    vec2 scale = vec2(size.x / lines * 4., size.y);\n    \n    if (bound > .01) {\n    \treturn bound;\n    }\n\n    vec2 p0 = getPoint(p.x, -2, seed, size, scale);\n    vec2 p1 = getPoint(p.x, -1, seed, size, scale);\n    vec2 p2 = getPoint(p.x, 0, seed, size, scale);\n    vec2 p3 = getPoint(p.x, 1, seed, size, scale);\n    vec2 p4 = getPoint(p.x, 2, seed, size, scale);\n    \n    float inv = mod(floor(p.x / scale.x), 2.) * 2. - 1.;\n    \n    float d = max(\n        min(\n        \tfLine(p, p0, p1) * inv,\n        \tfLine(p, p1, p2) * inv\n        ),\n        min(\n        \tfLine(p, p2, p3) * inv,\n        \tfLine(p, p3, p4) * inv\n        )\n    ) * inv;\n\n    // use less samples, introduces errors\n    //float d = max(fLine(p, p1, p2) * inv,fLine(p, p2, p3) * inv) * inv;\n\n    float w = weight;\n    \n    float weightRamp = (1. - p.x / size.x / 2.);\n    weight *= weightRamp;\n    d = (abs(d) - weight);\n    d = max(d, bound);\n        \n    return d;\n}\n\n\n// Skull model\n//--------------------------------------------------------\n\nModel sdSkull(vec3 p) {\n    Model model = newModel();\n    float rad = .3;\n    float bound = fBox(p - vec3(0,-.13,-.02), vec3(.45,.43,.54) - rad) - rad;\n    bound = smin(bound, fBox(p - vec3(0,.29,-.4), vec3(.25,.2,.18)), .2);\n    if ( ! lightingPass && bound > boundEps / globalScale) {\n        model.d = bound;\n        model.isBound = true;\n        return model;\n    }\n\n    p.x = -abs(p.x);\n    p += OFFSET / SCALE;\n    p *= SCALE;\n    model.d = mapTex(iChannel0, p, iChannelResolution[0].xy);\n\n    if (lightingPass && bound > .01) {\n        model.d += bound;\n        model.isBound = true;\n        return model;\n    }\n\n    return model;\n}\n\nModel drawSkull(vec3 p, float t) {\n    float scale = 2.5 * skullRadius;\n    p /= scale;\n    globalScale *= scale;\n    Model model = sdSkull((p.xyz * vec3(1,-1,-1)));\n    model.d *= scale;\n    globalScale /= scale;\n    return model;\n}\n\n\n// Composition\n//--------------------------------------------------------\n\nModel drawFinalBloom(vec3 p, float t) {\n    float bt = smoothstep(0., 2., t);\n    bt = easeOutCirc(bt);\n    pR(p.xz, .7 * PI * 2.);\n    Model bloom = drawBloom(\n        p,\n        bt,\n        BloomSpec(\n        \tvec2(.15, 2), //density\n            .05, //thickness\n            .4, //width\n            1., //pointy\n            1.4, //size\n            true //hideInside\n        )\n   \t);\n    bloom.id = 5;\n    return bloom;\n}\n\nfloat fTri(vec2 p, float radius) {\n    radius /= 2.;\n    vec2 a = normalize(vec2(1.6,1.));\n    return max(\n        dot(p, vec2(0,-1)) - radius,\n        max(\n        \tdot(p, a) - radius,\n        \tdot(p, a * vec2(-1,1)) - radius\n        )\n    );\n}\n\nModel skullWithBlooms(vec3 p, float t) {\n    \n    if (t <= .0 || globalScale <= 0.) {\n        return newModel();\n    }\n    \n    Model model = newModel();    \n    Model bloom;\n\n    if (t < CUTOFF) {\n        // skull with sub blooms\n        Model skull = drawSkull(p, t);\n        float skulld = skull.d;\n        skull.crackdepth = max(-skull.d, 0.);\n        float td = t - delay;\n        model = skull;\n        //return skull;\n        \n        vec3 pp = p;\n        \n        // cracks\n        if (skull.d < boundEps / globalScale) {\n\t        CrackInstance ci;\n\t        float cracks = 1e12;\n            float crack;\n            for (int i = ZERO; i < 7; i++) {\n                ci = crackInstances[i];\n                p -= ci.pos;\n                p *= ci.rot;\n                if (i == 6) {\n                \tcrack = min(crack, max(fTri(p.xz, .45), fTri(p.xz * vec2(1,-1), .3)));\n                } else {\n                    crack = 1e12;\n                }\n                pR(p.xz, ci.angle);\n                float blend = smoothstep(ci.start, ci.stop, td);\n                float weight = mix(ci.weight.x, ci.weight.y, blend);\n                float crack = min(crack, fCrack(p.xz - ci.offset, ci.size, ci.lines, ci.seed, weight));\n                crack += (1.-blend) * weight/2.;\n                crack -= min(skull.d * mix(1.5, .2, blend), 0.);\n                crack = max(crack, -(p.y + .25)); // stop it poking through the other side\n                cracks = min(crack, cracks);\n                p = pp;\n            }\n            cracks = max(cracks, -(skulld + .06)); // limit depth\n            skull.d = cmax(skull.d, -cracks, .003);\n      \t}\n        \n        // blooms\n\t    Model blooms = newModel();\n        BloomInstance bi;\n        for (int i = ZERO; i < 4; i++) {\n            bi = bloomInstances[i];\n            float bt = smoothstep(bi.start, bi.stop, td);\n            p -= bi.pos * (1. + bi.offset * bt);\n            p *= bi.rot;\n            bloom = drawBloom(p, bt, bi.spec);\n            bloom.id = i + 1;\n            skull.d = max(skull.d, -bloom.neg);\n            blooms = opU(blooms, bloom);\n            p = pp;\n        }\n\n        model = opU(skull, blooms);\n    }\n\n    return model;\n}\n\nvoid tweenSkull(inout vec3 p, float t) {\n    float skullHeight = mix(.2, skullOffset, easeOutSine(rangec(.55, 1.5, t)));\n    float skullScale = mix(.0, 1., easeOutSine(rangec(.45, 1., t)));\n    p.y -= skullHeight;\n    p *= skullRotate;\n\n    float rt = 1. - easeOutCirc(rangec(.0, 3., t));\n    pR(p.yz, rt * 5.);\n\n    p /= skullScale;\n    globalScale *= skullScale;\n}\n\nvoid stepTransform(inout vec3 p, inout float t) {\n    p -= bloomPosition;\n    p /= stepScale;\n    globalScale *= stepScale;\n    p *= bloomRotate;\n    t -= delay;\n}\n\nModel map(vec3 p) {\n\n    globalScale = 1.;\n    float t = time;\n\n    float off = .73;\n    \n    t += 1.;\n    float camScale = tweenCamera(p, t - (1.-off)/delay);\n    globalScale *= camScale;\n\n    Model model = newModel();\n    Model model2;\n\n    t *= delay;\n    t += off;\n\n    if (t < 2.6) {\n    \tmodel = drawFinalBloom(p, t);\n      \tmodel.d *= globalScale;\n    }\n\n    for (float i = 0.; i < 3.; i++) {\n\n        // scale\n        tweenSkull(p, t);\n\n        if (globalScale <= 0.) {\n\t\t\tbreak;\n        }\n\n        // skull\n        model2 = skullWithBlooms(p, t);\n        model2.d *= globalScale;\n        model = opU(model, model2);\n\n        // translate\n        stepTransform(p, t);\n        \n        // bloom\n        model2 = drawFinalBloom(p, t);\n        model2.d *= globalScale;\n        model2.neg *= globalScale;\n        if ( ! model2.isBound) {\n            model.d = smax(model.d, -model2.neg, .04 * globalScale);\n        }\n        model = opU(model, model2);\n    }\n\n    return model;\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nmat4 cameraMatrix = mat4(\n    -.6729,.6207,.4012,0,\n    .7041,.3737,.6036,0,\n    .2249,.689,-.6883,0,\n    -.02,-.3813,-5.423,1\n);\n\nmat4 view = mat4(\n    -0.6729, 0.6207, 0.4012, 0,\n    0.7041, 0.3737, 0.6036, 0,\n    0.2249, 0.689, -0.6883, 0,\n    -0.02, -0.3813, -5.423, 1\n);\n\n// Shading\n//--------------------------------------------------------\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    #ifdef DISABLE_SHADOWS\n        return 1.;\n    #endif\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=ZERO; i<256; i++ )\n    {\n        float h = map( ro + rd*t ).d;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #ifdef DISABLE_SHADOWS\n        return 1.;\n    #endif\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 worldToCam(vec3 v) {\n    return (vec4(v, 1) * cameraMatrix).xyz;\n}\n\nvec3 doShading(vec3 pos, vec3 rd, Model model) {\n    vec3 col = vec3(.3);\n    float cracksha = rangec(.001, .0, model.crackdepth);\n\tfloat crackocc = rangec(.05, .0, model.crackdepth);\n\n    if (model.isBloom) {\n\t\tcrackocc = 1.;\n        cracksha = 1.;\n        col = vec3(.04,.09,.09);\n        col = mix(vec3(.07,.025,.06), col, smoothstep(-.2, .0, model.wedges) * model.uv.y);\n        if (model.id == 1) {\n            col = vec3(.1,.06,.1);\n            col = mix(col, vec3(.095,.02,.055), smoothstep(-.1, .0, model.wedges) * smoothstep(.5, 1., model.uv.y));\n        }\n        if (model.id == 2) {\n            col = vec3(.04,.07,.09);\n            col = mix(col, vec3(.005,.015,.02), smoothstep(.5, 1.3, model.cell.y));\n        }\n        if (model.id == 3) {\n            col = vec3(.04,.07,.09);\n            col = mix(col, vec3(.2), smoothstep(.4, 1., model.uv.y));\n        }\n        if (model.id == 4) {\n            col = vec3(.11,.05,.1);\n            col = mix(col, vec3(.5), smoothstep(.5, 2., model.cell.y));\n        }\n    }\n\n    vec3 nor = calcNormal(pos);\n    lightingPass = true;\n\n    // IQ's shading, I always find this so nice to work with\n    // https://www.shadertoy.com/view/Xds3zN\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( worldToCam(vec3(.5, 1, .2)) );\n    vec3  lba = normalize( worldToCam(vec3(-.5, -.8, .1)) );\n    vec3  hal = normalize( lig - rd );\n    float amb = sqrt(clamp( 0.5+0.5*worldToCam(nor).y, 0.0, 1.0 ));\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-worldToCam(nor).y,0.0,1.0);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n    occ = mix(1., occ, .8) * mix(1., crackocc, .9);\n\n    float sha = softshadow( pos, lig, 0.001, .9 ) * cracksha;\n    dif *= sha;\n\n    float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n        dif *\n        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n    vec3 lin = vec3(0.0);\n    lin += 3.80*dif*vec3(1.30,1.00,0.70);\n    lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n    lin += 0.55*bac*vec3(0.4,0.25,0.3)*occ;\n    lin += 0.15*fre*vec3(1.00,1.00,1.00)*occ;\n    col = col*lin;\n    col += 7.00*spe*vec3(1.10,0.90,0.70);\n\n    return col;\n}\n\n\n// Debug\n//--------------------------------------------------------\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// Main\n//--------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Config\n\n    skullOffset = 1.8;\n    skullRadius = .3;\n    skullRotate = basisMatrix(vec3(.9,1,.9), vec3(1,0,1));\n\n    bloomPosition = vec3(.8,.8,-.1) * skullRadius * 1.1;\n    bloomRotate = basisMatrix(vec3(-.3,1,0), vec3(1,0,0));\n\n    stepPosition = vec3(0,skullOffset,0) + skullRotate * bloomPosition;\n    stepScale = .15;\n    stepRotate = skullRotate * bloomRotate;\n\n    delay = 1.5;\n\n    cameraPrecalc();\n    calcPhyllotaxis();\n    precalcBloomInstances();\n    precalcCrackInstances();\n\n    time = loopTime(iTime);\n\n    vec3 col;\n    float depth;\n    \n    // Camera\n\n    vec2 p = (-iResolution.xy + 2. * fragCoord) / iResolution.y;\n   \tvec3 eye = -(view[3].xyz) * mat3(view);\n    float fov = 1. / 3.0777;\n    vec3 dir = normalize(vec3(p.x * fov, p.y * fov, -1) * mat3(view));\n\n    // Raymarch (enhanced sphere tracing)\n    // https://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n\n    vec3 camPos = eye;\n    vec3 rayPosition = camPos;\n    vec3 rayDirection = normalize(dir);\n    float rayLength = 0.;\n    float stepLength = 0.;\n\n    bool bg = false;\n    lightingPass = false;\n\n    Model model;\n    Model candidateModel;\n    float error;\n    float candidateError = 1e12;\n    float canidateRayLength;\n    \n    const float MAX_DIST = 16.;\n    const int MAX_STEPS = 100;\n    float debugSteps = 0.;\n    \n    float pixelRadius = fwidth((camPos + rayDirection).x);\n\tfloat overstep = 1.1;\n    float radius;\n    float signedRadius;\n    float previousRadius;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        debugSteps = float(i);\n        \n        rayPosition = camPos + rayDirection * rayLength;\n        boundEps = pixelRadius * rayLength * 2.;\n        model = map(rayPosition);\n        \n        signedRadius = model.d;\n        radius = abs(signedRadius);\n\n        bool overshot = overstep > 1. && ! model.isBound && (radius + previousRadius) < stepLength;\n        if (overshot) {\n            stepLength -= overstep * stepLength;\n            overstep = 1.;\n        } else {\n            stepLength = signedRadius * overstep;\n        }\n\n        previousRadius = radius;\n\n        float error = radius / rayLength;\n        if ( ! model.isBound && ! overshot && error < candidateError) {\n            candidateModel = model;\n            candidateError = error;\n            canidateRayLength = rayLength;\n        }\n\n        if ( ! model.isBound && ! overshot && error < pixelRadius) {\n            break;\n        }\n        \n    \tif (rayLength > MAX_DIST) {\n            bg = true;\n            canidateRayLength = rayLength;\n            break;\n        }\n\n        rayLength += stepLength;\n    }\n    \n    model = candidateModel;\n    rayLength = canidateRayLength;\n\n    vec3 bgCol = vec3(.007,0,.007);\n    col = bgCol;\n\n    if ( ! bg) {\n        col = doShading(rayPosition, rayDirection, model);\n        float fog = 1. - exp((rayLength - 3.) * -.5);\n        col = mix(col, bgCol, clamp(fog, 0., 1.)); \n    }\n    \n    depth = rayLength / MAX_DIST;\n    depth = smin(depth, .8, .1); // stop the DOF 'pop' when background objects are removed\n\n    //col = spectrum(debugSteps / float(MAX_STEPS));\n\t//col = spectrum(depth);\n\n    fragColor = vec4(col, depth);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}