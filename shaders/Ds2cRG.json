{
    "Shader": {
        "info": {
            "date": "1687841202",
            "description": "inspired by sand gardens with patterns in them!",
            "flags": 0,
            "hasliked": 0,
            "id": "Ds2cRG",
            "likes": 4,
            "name": "Disk Jockey",
            "published": 3,
            "tags": [
                "noise",
                "circle"
            ],
            "usePreview": 0,
            "username": "johnCavatelli",
            "viewed": 139
        },
        "renderpass": [
            {
                "code": "float random (in vec2 st) {// 2D Random\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat circle(in vec2 _st, in float _radius, in float _pow){\n    float dist = length( abs(_st)-.5 );\n    if(dist > _radius){return 0.;}\n    float c0 = fract(dist*_pow);\n    float c1 = step(0.5,c0);\n    float offset = sin((iTime * 1.5) + (_pow * _radius));\n    float c2 = noise((_st*90. + offset + (_radius * _pow)));\n    float c3 = 0.5 * c1 + 0.2 * c2 + c0 * 0.6;\n    float c4 = step(0.95, c3);\n    return c4;\n}\n\nvec3 renderWavyCircle(in vec2 _uv, in float _rad,in float _waveMult, in vec2 _translate, inout vec3 _prevCircleColor){\n    vec2 st = _uv + _translate; \n    float r = _rad;\n    if(length( abs(st)-.5) < r && st.x > 0. && st.x < 1.){_prevCircleColor = vec3(0);}\n    vec3 col = vec3(circle(st,r,_waveMult));\n    if(st.x < 0. || st.x > 1.){col = vec3(0.);}\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    uv.x = uv.x / aspect;\n    vec2 ogUV = uv;\n    \n    vec3 c0 = vec3(0);\n    vec3 c0a = renderWavyCircle(ogUV,0.6,10.,vec2(-1.2,0),c0);\n    vec3 c1 = renderWavyCircle(ogUV,0.5,13.,vec2(-0.5,0),c0a) + c0a;\n    vec3 c2 = renderWavyCircle(ogUV,0.5,17.,vec2(0,0.5),c1) + c1;\n    vec3 c3 = renderWavyCircle(ogUV,0.5,27.,vec2(-0.99,0.5),c2) + c2;\n    vec3 c4 = renderWavyCircle(ogUV,0.3,17.,vec2(-1.,-0.2),c3) + c3;\n    vec3 c5 = renderWavyCircle(ogUV,0.5,37.,vec2(0.2,-1.3),c4) + c4;\n    vec3 c6 = renderWavyCircle(ogUV,0.3,27.,vec2(0.4,0.3),c5) + c5;\n    vec3 c7 = renderWavyCircle(ogUV,0.3,17.,vec2(-0.5,-0.5),c6) + c6;\n    vec3 c8 = renderWavyCircle(ogUV,0.2,90.,vec2(-1.3,0.),c7) + c7;    \n    \n    fragColor = vec4( c8,0.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}