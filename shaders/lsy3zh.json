{
    "Shader": {
        "info": {
            "date": "1453239407",
            "description": "remake of http://www.cake23.de/reaction-diffusion-fish-soup.html - drag with the mouse",
            "flags": 32,
            "hasliked": 0,
            "id": "lsy3zh",
            "likes": 84,
            "name": "Coupled Turing Pattern Flow",
            "published": 3,
            "tags": [
                "interactive",
                "warp",
                "feedback",
                "reactiondiffusion"
            ],
            "usePreview": 0,
            "username": "Flexi",
            "viewed": 6522
        },
        "renderpass": [
            {
                "code": "vec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n    vec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n    vec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n    return vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. /  iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n    fragColor = texture(iChannel0, uv);\n\n    vec2 uv_bg = uv\t+ (\t\n        GradientA(uv, pixelSize * 1.5, vec4(0.5, 1, 0, 0), 0)\n        + GradientA(uv, pixelSize * 3., vec4(1, 1, 0, 0), 1)\n    ) * pixelSize * 384.;\n\n    fragColor = mix(vec4(0), vec4(0.25,0.33,0.66,0), BlurA(uv_bg, 2).b*1.6);\n\n    fragColor = mix(fragColor, vec4(0.5,0.4,0.5,0), BlurA(uv, 0).r * (1.- BlurA(uv, 0).g));\n\n    fragColor = mix(fragColor, \n                    mix(vec4(2,2,0,0), vec4(1.,0,0.,0), pow(1.-BlurA(uv, 0).r,2.)), \n                    BlurA(uv + GradientA(uv, pixelSize * 2., vec4(0, 1, 0, 0), 0)*pixelSize*4., 0).g);\n    \n    //fragColor = BlurA(uv, 0); // simple bypass\n    \n    //fragColor = texture(iChannel3, uv); // raw Gaussian pyramid\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define pi 3.141592653589793238462643383279\n#define pi_inv 0.318309886183790671537767526745\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = texture(iChannel3, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\t\nvec2 GradientA(vec2 uv, vec2 d, vec4 selector, int level){\n\tvec4 dX = 0.5*BlurA(uv + vec2(1.,0.)*d, level) - 0.5*BlurA(uv - vec2(1.,0.)*d, level);\n\tvec4 dY = 0.5*BlurA(uv + vec2(0.,1.)*d, level) - 0.5*BlurA(uv - vec2(0.,1.)*d, level);\n\treturn vec2( dot(dX, selector), dot(dY, selector) );\n}\n\nvec2 rot90(vec2 vector){\n\treturn vector.yx*vec2(1,-1);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.1;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    vec2 mouseV = mouseDelta();\n    if(length(mouseV) == 0.){\n        fragColor = BlurA(uv, 0);\n        return;\n    }\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 pixelSize = 1. / iResolution.xy;\n\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    vec2 uvr = uv;\n\tfragColor.r = BlurA(uvr + GradientA(uv, pixelSize*8., vec4(-8.,0.,8.,0.), 2)*pixelSize + rot90(GradientA(uv, pixelSize*4., vec4(-0,0.,16.,0.), 1))*pixelSize, 0).r;\n\tfragColor.r += (BlurA(uv, 2).r - BlurA(uvr, 4).r)*24./256. + 2.5/256. + noise.x*0.5/256.;\n\n\tfragColor.g = BlurA(uvr + GradientA(uv, pixelSize*4., vec4(0.,-2.,-48.*BlurA(uv, 2).b,0.), 1)*pixelSize, 0).g ;\n\tfragColor.g += (BlurA(uv, 1).g - BlurA(uvr, 2).g)*32./256. + 5./256.*(BlurA(uv, 2).b - 0.5) + noise.y*0./256.;\n\n\tfragColor.b = BlurA(uvr + GradientA(uv, pixelSize*3., vec4(0.,0.,4.,0.), 1)*pixelSize, 0).b;\n\tfragColor.b += (BlurA(uv, 0).b - BlurA(uvr, 1).b)*11./256. - 2./256. + noise.z*1./256.;\n\n    fragColor = clamp(fragColor, 0., 1.);\n\n//    fragColor = noise; // reset\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// resolution reduction and horizontal blur\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.05;\n    sum += texture(iChannel3, uv2) * 0.09;\n    sum += texture(iChannel3, uv3) * 0.12;\n    sum += texture(iChannel3, uv4) * 0.15;\n    sum += texture(iChannel3, uv5) * 0.16;\n    sum += texture(iChannel3, uv6) * 0.15;\n    sum += texture(iChannel3, uv7) * 0.12;\n    sum += texture(iChannel3, uv8) * 0.09;\n    sum += texture(iChannel3, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// vertical blur (second pass)\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel2, uv1) * 0.05;\n    sum += texture(iChannel2, uv2) * 0.09;\n    sum += texture(iChannel2, uv3) * 0.12;\n    sum += texture(iChannel2, uv4) * 0.15;\n    sum += texture(iChannel2, uv5) * 0.16;\n    sum += texture(iChannel2, uv6) * 0.15;\n    sum += texture(iChannel2, uv7) * 0.12;\n    sum += texture(iChannel2, uv8) * 0.09;\n    sum += texture(iChannel2, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }  \n    }\n    uv = uv_orig;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}