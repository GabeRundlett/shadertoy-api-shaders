{
    "Shader": {
        "info": {
            "date": "1658413206",
            "description": "Utilizing a 2D simplex grid to produce an animated interlinked three pronged spiral pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "7syfWz",
            "likes": 64,
            "name": "Triangle Grid Spiral Weave",
            "published": 3,
            "tags": [
                "2d",
                "grid",
                "triangle",
                "spiral",
                "bump",
                "weave",
                "triskelion"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 652
        },
        "renderpass": [
            {
                "code": "/*\n\n    Triangle Grid Spiral Weave\n    --------------------------\n    \n    Utilizing a 2D simplex grid to produce an animated interlinked three \n    pronged spiral pattern. I guess another way to put it would be \n    unwrapping a well known icosahedral weave pattern and placing it on a \n    2D plane. :)\n    \n    I love perusing images of various mathematical objects online. Among\n    my favorites are polyhedral weaves. Anyone who's done this will know\n    that descriptions of the construction process are hard to come by, so \n    I'm always left trying to figure it out on my own. Thankfully, I enjoy \n    that kind of thing. Icosahedral based weaves are easier to decipher, \n    since they consist of equilateral spherical triangles, which means you \n    can usually map them to a 2D equilateral triangle grid.\n    \n    With the aforementioned in mind, the purpose of this particular example \n    was to work within the confines of a simple 2D simplex space in \n    preparation for conversion to a 3D icosahedral setting. Rightly or\n    wrongly, I made the decision not to use Bezier curves, since it'd make \n    3D conversion at an acceptable frame rate very difficult.\n    \n    Constructing the spiral objects in each cell using basic distance field\n    shapes -- like circles and triangles -- involved more trial and error \n    than I had hoped, but it turned out to be a relatively simple process \n    in the end.\n    \n    I wasn't going to post a 2D version, but after putting this together, I \n    got bored and added highlights and a few other things until it looked \n    presentable. I'll post the icosaheral version next... unless I get \n    sidetracked with some interesting Shadertoy post. :)\n    \n    \n    \n    Other examples:\n    \n    // A relatively simple 3D weave, and one of the many really \n    // nice Shadertoy examples that slipped under the radar.\n    Moorish Rose - athibaul\n    https://www.shadertoy.com/view/tdVfDz\n\n    // I made a much simpler interlocked 2D hexagonal pattern a while ago.\n    Hexagonal Interlacing - Shane\n    https://www.shadertoy.com/view/llfcWs\n\n\n*/\n\n// Inner object color - Orange: 0, Green: 1.\n#define COLOR 0\n\n// Variable width edges.\n//#define VARIABLE_WIDTH\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smin(vec2 a, vec2 b, float k){\n\n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smax(vec2 a, vec2 b, float k){\n    \n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./3.;\n\nfloat gTri;\n\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n \n    // Vertex IDs for each partitioned triangle.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-.5, .5), vec2(.5, -.5), vec2(.5));\n    }\n    else {\n        vID = vec2[3](vec2(.5, -.5), vec2(-.5, .5), vec2(-.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n    // Specific centered triangle ID.\n    ctr = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.;\n    id += ctr;\n    // Not used here, but for jigsaw pattern creation, etc, the vertex IDs\n    // need to be correctly centered too.\n    //vID[0] -= ctr; vID[1] -= ctr; vID[2] -= ctr; \n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat dist(vec2 p){\n    \n    return length(p);\n    \n    //p = abs(p);\n    //return max(p.y*.8660254 + p.x*.5, p.x);\n\n}\n\n//////////\n// Rendering a colored distance field onto a background. I'd argue that\n// this one simple function is the key to rendering most vector styled\n// 2D Photoshop effects onto a canvas. I've explained it in more detail\n// before. Here are the key components:\n//\n// bg: background color, fg: foreground color, sf: smoothing factor,\n// d: 2D distance field value, tr: transparency (0 - 1).\nvec3 blend(vec3 bg, vec3 fg, float sf, float d, float tr){\n\n     return mix(bg, fg, (1. - smoothstep(0., sf, d))*tr);\n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n \n\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec2 p0, vec2 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Global scaling and translation.\n    float gSc = 1.;\n    // Smoothing factor, based on global scaling.\n    float sf = 1./iResolution.y*gSc;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north easterly (top right) direction. \n    vec2 p = rot2(3.14159/12.)*uv*gSc - vec2(-1, -.57735*0.)*iTime/50.;\n    \n \n    // Global coordinate copy.\n    vec2 oP = p;\n    \n    // Light direction.\n    vec2 ld = normalize(vec2(-1, -1.5));\n\n\n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    vec2[3] v, vID;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    scale = 1./3.;\n    vec4 p4 = getTriVerts(oP, vID, v);\n    p = p4.xy;\n    vec2 triID = p4.zw; \n    \n    // Background cell triangle and highlight triangle sample.\n    vec2 qt = p*vec2(1, gTri);\n    float tr = (max(abs(qt.x)*.8660254 + qt.y*.5, -qt.y));\n    qt = (p - ld*.005)*vec2(1, gTri);\n    float trHi = (max(abs(qt.x)*.8660254 + qt.y*.5, -qt.y));\n     \n\n    \n    // Vertices and corresponding highlight.\n    float vert = 1e5, vertHi = 1e5;\n    vec2[3] mid, midA, midB;\n    float sL = length(v[0] - v[1]);\n    // Larger numbers push the points toward edges, but bring the rings closer.\n    float offs = 1./(8. + sin(iTime/3.)*4.); \n    \n    // Spiral thickness factor.\n    float th = 0.; \n    \n    // Triangle center: Trivial here.\n    vec2 cntr = vec2(0); //(v[0] + v[1] + v[2])/3.;\n \n    \n    // Nearest vertex, and edge mid-points and offsets on either side.\n    for(int i = 0; i<3; i++){\n        \n        int ip1 = (i + 1)%3;\n        \n        // Nearest vertex point.\n        vert = min(vert, length(p - v[i]));\n        vertHi = min(vertHi, length(p - ld*.005 - v[i]));\n        \n        // Mid edge point, and complimentary offsets.\n        mid[i] = mix(v[i], v[ip1], .5);\n        midA[i] = mix(v[i], v[ip1], .5 - offs);\n        midB[i] = mix(v[i], v[ip1], .5 + offs);\n\n    }  \n    \n    \n    // The two cell objects (top and bottom). Each consist of curved \n    // spiral arms attached to a central shape.\n    vec2 obj = vec2(1e5); \n    vec2 objHi = vec2(1e5); \n    \n    // Creating three spiral arms. How you do that is up to you. I've\n    // rendered three arcs centered on the triangle center and cutting\n    // offset mid-points on each edge. I could have taken a faster\n    // polar approach, but was using the process for nonsymmetrical \n    // examples... I won't bore you with the details, suffice to say \n    // that this is not a processor intensive example anyway and I'll \n    // make the conversion later.\n    //\n    for(int i = 0; i<3; i++){\n        \n        int ip2 = (i + 2)%3;\n        \n        // The origin and radius of the circle that will become the\n        // spiral arc for this edge. It's centered just off the midway\n        // point, and its radius is the distance from the triangle cell\n        // center to a point on the other side.\n        vec2 o = midB[i];\n        float r = length(midA[0]);\n        \n        // The bottom arcs.\n        vec2 q = p;\n        float ring = abs(dist(q - o) - r); // Arc, or ring.\n        // Cutting the arc in half by restricting it to one third of the triangle.\n        // By the way, there are only three partitions needed per sample, and I'm \n        // calculating six all up, which is wasteful and lazy, but not too costly.\n        // Either way, I'll fix it up later.\n        ring = max(ring, max(distLineS(q, cntr, mid[i]), \n                             distLineS(q, mid[ip2], cntr))); // \n        obj.x = min(obj.x, ring); // Bottom spiral arm object.\n        \n        // For the top spirals, we reflect across the X-axis -- You can \n        // see this visually. Practically speaking, it means flipping the\n        // X-coordinate and using the same functions again.\n        q *= vec2(-1, 1);\n        ring = abs(dist(q - o) - r);\n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                              distLineS(q, mid[ip2], cntr)));\n        obj.y = min(obj.y, ring); // Top spiral arm object.\n \n        // Highlighting sample calculations. Doing the same as above, but \n        //at a slightly offset position in the direction of the light.\n        q = p - ld*.005;\n        ring = abs(dist(q - o) - r);\n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                             distLineS(q, mid[ip2], cntr)));\n        objHi.x = min(objHi.x, ring);\n \n        q *= vec2(-1, 1); \n        ring = abs(dist(q - o) - r); \n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                             distLineS(q, mid[ip2], cntr)));\n        objHi.y = min(objHi.y, ring);\n        \n      \n    }\n    \n    // Roughly turning the central triangle to coincide with the changing spiral\n    // arm rotation. It's a hack due to the fact that we're not using Bezier curves, \n    // but it's close enough.\n    float angR = -3.14159/10. + angle(midA[0] - cntr, (v[2] - v[1]));//-3.14159/15.\n    // Central triangle, and its offset sample.\n    vec2 trR = rot2(-angR)*p*vec2(1, gTri);\n    vec2 trRRef = rot2(-angR)*(p*vec2(-1, 1))*vec2(1, gTri);\n    vec2 trM = vec2(sdEqTri(trR, sL/6.), sdEqTri(trRRef, sL/6.));\n    trR = rot2(-angR)*(p - ld*.005)*vec2(1, gTri);\n    trRRef = rot2(-angR)*((p - ld*.005)*vec2(-1, 1))*vec2(1, gTri);\n    vec2 trM2 = vec2(sdEqTri(trR, sL/6.), sdEqTri(trRRef, sL/6.));\n\n    // Adding a bit of thickness. Where you apply this depends on the look you're\n    // after. A lot of it is trial and error.\n    obj -= sL/12.;\n    objHi -= sL/12.;\n    \n    // Smoothly blending the spiral arms with a central shape. It's not mandatory,\n    // but it adds visual interest.\n    //\n    // Triangles.\n    obj = smin(obj, trM - sL/16., .03);//*max(1. - length(p)/sL, 0.)\n    objHi = smin(objHi, trM2 - sL/16., .03);//*max(1. - length(p)/sL, 0.)\n    // Circles: Cheap, but not as neat. \n    //obj = smin(obj, vec2(length(p) - sL/7.), .06);\n    //objHi = smin(objHi, vec2(length(p - ld*.005) - sL/7.), .06);\n  \n\n     // Applying extra thickness here put the emphasis on the triangle.\n     obj -= sL/24.;//*max(1. - length(p)/sL*1.4, 0.);\n     objHi -= sL/24.;//*max(1. - length(p - ld*.005)/sL*1.4, 0.);\n\n \n  \n    /*\n    // Degug. Untangling the weave.\n    if(gTri<0.){ \n        float tmp = ln.x; ln.x = ln.y; ln.y = tmp;\n        tmp = lnHi.x; lnHi.x = lnHi.y; lnHi.y = tmp;\n    }\n    */\n    \n    // Directional gradient values for hightlighting.\n    \n    // Pinwheel objects.\n    vec2 b = max(objHi - obj, 0.)/.005;\n    b = pow(b, vec2(4))*2.5;\n    //\n    // Vertex rivot objects.\n    float bVert = max(vertHi - vert, 0.)/.005;\n    bVert = pow(bVert, 4.)*2.5;\n    //\n    // Background triangles.\n    float bTr = max(trHi - tr, 0.)/.005;\n    //bTr = pow(bTr, 4.)*2.5;\n    \n    // Background line pattern.\n    const float lNum = 96.;\n    float lnD = (rot2(6.2831/3.)*oP).x;\n    float tLns = smoothstep(0., sf, (abs(fract(lnD*lNum - .333) - .5)*2. - .333)/lNum/2.);\n   \n    \n    // Background color.\n    vec3 bCol = vec3(.125);\n    // Outer object color.\n    vec3 oCol = vec3(.1); // Outer rim.\n    // Inner object color\n    #if COLOR == 0\n    vec3 oCol2 = vec3(3, .6, .1);  // Orange.\n    #else\n    vec3 oCol2 = vec3(.2, 1.2, .5); // Green.\n    #endif\n    // Mixing the colors a little.\n    //oCol2 = mix(oCol2, oCol2.xzy, length(p)/length(midA[0])/4.);\n    oCol2 = mix(oCol2, oCol2.xzy, dot(sin(uv*3. - cos(uv.yx*6.)), vec2(.1)) + .2);\n    \n      // Bump color.\n    vec3 bumpCol = vec3(.92, .97, 1);\n  \n    // Apply lines to the colors.\n    oCol2 *= tLns*.5 + .5;\n    bCol *= tLns*.5 + .5;\n    \n    // Initiating the scene to the bump mapped triangle grid background.\n    vec3 col = bCol + bumpCol*bTr*.3;\n    \n   \n\n    // Rendering some triangles onto the background, but leaving the edges.\n    col = blend(col, col*2., sf*2., abs(tr - scale/3.) - .004, 1.);\n    col = blend(col, vec3(0), sf, abs(tr - scale/3.) - .002, 1.);\n    \n   \n    \n    // Resolution factor for shadow width -- It's a hack to make sure shadows\n    // have the same area influence at different resolutions. If you think it's\n    // confusing, you'll get no arguments from me. :)\n    float resF = iResolution.y/450.;\n    \n    // Triangle grid vertices.\n    vert -= .035; // Vertex radius.\n    vertHi -= .035;\n    col = blend(col, vec3(0), sf*8.*resF, vertHi, .5); // Drop shadow.\n    col = blend(col, vec3(0), sf, vert, 1.);  // Dark edge.\n    col = blend(col, oCol + bumpCol*bVert*.3, sf, vert + .005, 1.); // Outer.\n    col = blend(col, vec3(0), sf, vert + .018, 1.); // Inner dark edge.\n    col = blend(col, oCol*.7 + bumpCol*bVert*.2, sf, vert + .018 + .005, 1.); // Inner.\n    col = blend(col, col*1.5, sf*1., abs( vert + .018 + .005 - .007) - .002, 1.); // Highlight.\n\n    \n    // The object layers: Shadows, edges, highlights, etc. Start on the outside,\n    // then work inwards adding layers (using the \"blend\" function) as you go.\n    //\n    // Edge thickness factor.\n    \n    #ifdef VARIABLE_WIDTH\n    th = sL/(9.5 + (sin(iTime/4.)*.5 + .5)*10.5); // Variable width edges. \n    #else\n    th = sL/12.; // Constant width.\n    #endif\n\n    // Lower spiral arms.\n    vec3 svCol = col; // For transparency.\n    col = blend(col, vec3(0), sf*12.*resF, objHi.x, .5); // Drop shadow.\n    col = blend(col, vec3(0), sf, obj.x, 1.); // Dark outer edge.\n    col = blend(col, mix(oCol + bumpCol*b.x*.3, svCol, .15), sf, obj.x + .005, 1.); // Outer color.\n    col = blend(col, vec3(0), sf, obj.x + th, 1.); // Dark inner edge.\n    col = blend(col, mix(oCol2 + bumpCol*b.x*.3, svCol, .25), sf, obj.x + th + .005, 1.); // Inner.\n    col = blend(col, col*1.5, sf*1., abs(obj.x + th - .005) - .002, 1.); // Highlight.\n   \n    // The upper spiral arms.\n    svCol = col;\n    col = blend(col, vec3(0), sf*12.*resF, objHi.y, .5);\n    col = blend(col, vec3(0), sf, obj.y, 1.);\n    col = blend(col, mix(oCol + bumpCol*b.y*.3, svCol, .15), sf, obj.y + .005, 1.);\n    col = blend(col, vec3(0), sf, obj.y + th, 1.);\n    col = blend(col, mix(oCol2 + bumpCol*b.y*.3, svCol, .25), sf, obj.y + th + .005, 1.);\n    col = blend(col, col*1.5, sf*1., abs(obj.y + th - .005) - .002, 1.);\n    \n    \n \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}