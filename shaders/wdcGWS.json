{
    "Shader": {
        "info": {
            "date": "1569182839",
            "description": "made at Bring Your Own Beamer / Otaniemi Night of Arts 2019",
            "flags": 0,
            "hasliked": 0,
            "id": "wdcGWS",
            "likes": 4,
            "name": "rainbow ooze",
            "published": 3,
            "tags": [
                "2d"
            ],
            "usePreview": 0,
            "username": "ahihi",
            "viewed": 565
        },
        "renderpass": [
            {
                "code": "// uncomment to use square pattern instead of circles\n//#define SQUARES\n\n#define TAU 6.283185307179586\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\nvec2 polar(vec2 p_rect) {\n    return vec2(atan(p_rect.y, p_rect.x), length(p_rect));\n}\n\nvec2 rect(vec2 p_polar) {\n    return vec2(p_polar.y * cos(p_polar.x), p_polar.y * sin(p_polar.x));\n}\n\nvec2 rotate(float angle, vec2 p) {\n    return rect(polar(p) + vec2(angle, 0.0));\n}\n\nfloat map(float l0, float r0, float l1, float r1, float x) {\n  return (x - l0) / (r0 - l0) * (r1 - l1) + l1;\n}\n\nvec2 map(vec2 l0, vec2 r0, vec2 l1, vec2 r1, vec2 p) {\n  return vec2(map(l0.x, r0.x, l1.x, r1.x, p.x), map(l0.y, r0.y, l1.y, r1.y, p.y));\n}\n\nvec2 map(float l0, float r0, float l1, float r1, vec2 p) {\n  return map(vec2(l0), vec2(r0), vec2(l1), vec2(r1), p);\n}\n\nvec3 rgb2hsl(vec3 rgb) {\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n    float v, m, vm, r2, g2, b2;\n    float h = 0.0;\n    float s = 0.0;\n    float l = 0.0;\n    v = max(max(r, g), b);\n    m = min(min(r, g), b);\n    l = (m + v) / 2.0;\n    if(l > 0.0) {\n        vm = v - m;\n        s = vm;\n        if(s > 0.0) {\n            s /= (l <= 0.5) ? (v + m) : (2.0 - v - m);\n            r2 = (v - r) / vm;\n            g2 = (v - g) / vm;\n            b2 = (v - b) / vm;\n            if(r == v) {\n                h = (g == m ? 5.0 + b2 : 1.0 - g2);\n            } else if(g == v) {\n                h = (b == m ? 1.0 + r2 : 3.0 - b2);\n            } else {\n                h = (r == m ? 3.0 + g2 : 5.0 - r2);\n            }\n        }\n    }\n    h /= 6.0;\n    return vec3(h, s, l);\n}\n\nvec3 hsl2rgb(vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n    float r = l;\n    float g = l;\n    float b = l;\n    float v = (l <= 0.5) ? (l * (1.0 + s)) : (l + s - l*s);\n    if(v > 0.0) {\n        float m, sv;\n        int sextant;\n        float fract, vsf, mid1, mid2;\n        m = l + l - v;\n        sv = (v - m) / v;\n        h *= 6.0;\n        sextant = int(h);\n        fract = h - float(sextant);\n        vsf = v * sv * fract;\n        mid1 = m + vsf;\n        mid2 = v - vsf;\n        if(sextant == 0) {\n            r = v;\n            g = mid1;\n            b = m;\n        } else if(sextant == 1) {\n            r = mid2;\n            g = v;\n            b = m;\n        } else if(sextant == 2) {\n            r = m;\n            g = v;\n            b = mid1;\n        } else if(sextant == 3) {\n            r = m;\n            g = mid2;\n            b = v;\n        } else if(sextant == 4) {\n            r = mid1;\n            g = m;\n            b = v;\n        } else if(sextant == 5) {\n            r = v;\n            g = m;\n            b = mid2;\n        }\n    }\n    return vec3(r, g, b);\n}\n\nvec3 hueshift(float dh, vec3 color) {\n  vec3 hsl = rgb2hsl(color);\n  hsl.x = fract(hsl.x + 1.0 + dh);\n  return hsl2rgb(hsl);\n}\n\nvec2 aspect_correct(float aspect, vec2 p) {\n  return aspect >= 1.0\n    ? vec2(p.x, p.y/aspect)\n    : vec2(p.x*aspect, p.y);\n}\n\nvec2 aspect_decorrect(float aspect, vec2 p) {\n  return aspect >= 1.0\n    ? vec2(p.x, p.y*aspect)\n    : vec2(p.x/aspect, p.y);\n}\n\nbool checkers(vec2 d, vec2 uv) {\n    bool px = mod(uv.x, 2.0*d.x) < d.x;\n    bool py = mod(uv.y, 2.0*d.y) < d.y;\n    return px != py;\n}\n\nbool circlers(vec2 d, float kr, vec2 uv) {\n    float x = fract(uv.x/d.x);\n    float y = fract(uv.y/d.y);\n\n    return distance(vec2(x, y), vec2(0.5)) < 0.5*kr;\n}\n\nfloat quant(float n, float x) {\n    return floor(n * x)/n;\n}\n\nfloat cool_pow(float b, float e) {\n  return (b < 0.0 ? -1.0 : 1.0) * pow(abs(b), e);\n}\n\nvec3 shatter(float time, vec2 xy) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = aspect_correct(aspect, map(vec2(0.0), iResolution.xy, vec2(-1.0), vec2(1.0), xy));\n    vec2 uv_p = polar(uv);\n    uv_p.x += uv_p.x < 0.0 ? TAU : 0.0;\n    \n    float turn = map(0.0, TAU, 0.0, 1.0, uv_p.x);\n    \n    float wob1 = sin(0.47*time) * sin(7.0*uv_p.x + 1.47*time);\n    float wob2 = cos(-0.66*time)  * cos(5.0*uv_p.x - 1.21*time);\n    vec2 uv1_p = uv_p * vec2(1.0, 1.0 + 0.3 * wob1);\n    vec2 uv2_p = uv_p * vec2(1.0, 1.0 + 0.28 * wob2);\n    vec2 uv1 = rect(uv1_p);\n    vec2 uv2 = rect(uv2_p);\n\n    vec2 uv1a = rotate(0.05*time, uv1);\n    vec2 uv1b = rotate(-0.036*time, uv2);\n\n    float hhh = 90.0;\n    float ggg = 4.0;\n    float n1 = quant(ggg, map(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(uv1a * hhh, 0.4*time))));\n    float n2 = quant(ggg, map(-1.0, 1.0, 0.0, 1.0, cnoise(vec3(-0.53*time, uv1b * hhh))));\n    vec3 c1 = vec3(abs(uv1a.x), 1.0-abs(uv1a.x), 0.0) * n1;\n    vec3 c2 = vec3(0.0, 0.0, abs(uv1b.y)) * n2;\n    float kr = 0.5;\n\n    #ifdef SQUARES\n    bool p1 = checkers(vec2(0.012), uv1a + time * vec2(0.005, 0.01));\n    bool p2 = checkers(vec2(0.016), uv1b + time * vec2(-0.004, 0.0065));\n    #else\n    bool p1 = circlers(vec2(0.012), kr, uv1a + time * vec2(0.005, 0.01));\n    bool p2 = circlers(vec2(0.02), kr, uv1b + time * vec2(-0.004, 0.0065));    \n    #endif\n    \n    vec3 color = (p1 != p2) ? c1 : c2;\n    float sh = map(-1.0, 1.0, 0.0, 1.0, wob1) * map(-1.0, 1.0, 0.0, 1.0, wob2);\n    color = hueshift(0.1*time + sh*0.3 + turn, color) * pow(sh, map(-1.0, 1.0, 0.01, 0.15, sin(0.12*time)));\n\n    vec3 color_hsl = rgb2hsl(color);\n    color_hsl.y *= map(0.0, 1.0, 0.25, 1.0, pow(sh, 1.0));\n    color_hsl.z *= map(0.0, 1.0, 0.25, 1.0, pow(sh, 1.0));\n\n    color = hsl2rgb(color_hsl);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n\n    vec2 xy_p = polar(xy - 0.5*iResolution.xy);\n    xy_p.x += 0.00008*xy_p.y * cool_pow(sin(-0.13*iTime), 1.3) * sin(0.89*pow(xy_p.y, 0.5) - 4.0*iTime);\n    xy_p.x += 0.0005*sin(0.23*iTime)*xy_p.y;\n    vec2 xy1 = rect(xy_p) + 0.5*iResolution.xy;\n    \n    vec3 color = shatter(iTime, xy1);\n    fragColor = vec4(color*3.0, 0.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}