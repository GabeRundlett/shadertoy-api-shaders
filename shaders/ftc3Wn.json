{
    "Shader": {
        "info": {
            "date": "1636008823",
            "description": "Very basic design - Going another step into the Quadtree explorations, and who doesn't enjoy love a good log-polar transform! ",
            "flags": 0,
            "hasliked": 0,
            "id": "ftc3Wn",
            "likes": 62,
            "name": "LogPolar QuadTree",
            "published": 3,
            "tags": [
                "warp",
                "log",
                "quadtree"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 1006
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Draft Quadtree [learning number 3]\n    11/4/21 @byt3_m3chanic\n\n    throwing it into a log polar transform.\n    It's hard to make the design more complex and \n    still look good as it scales, but this was \n    just poking around to see what else you can do.\n    \n    @Shane has a good example that explains quadtrees\n    which is what I used to create this shader.\n    https://www.shadertoy.com/view/llcBD7\n \n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\n\nvec3 hue(float t){ \n    const vec3 d = vec3(0.067,0.812,0.910);\n    return .55 + .45*cos(PI2*t*(vec3(.95,.97,.98)*d)); \n}\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec2 vuv= uv*rot(T*.05);\n\n    vuv=vec2(log(length(vuv)), atan(vuv.y, vuv.x))*3.5;\n    vuv.x+=T*.25;\n    \n    float px = fwidth(vuv.x);\n    float level=1.;\n\n    vec3 C = vec3(.0325);\n    float mask = smoothstep(.65,.0,length(uv)-.2);\n    C = mix(C, vec3(.125),mask);\n    \n    for(int k=0; k<5; k++){\n        vec2 id = floor(vuv*level);\n        float rnd = hash21(id);\n        \n        // threshold or if last loop\n        if(rnd>.45||k>3) {\n\n            vec2 p = vuv -(id+.5)/level;\n            rnd = hash21(rnd+id.yx);\n\n            float d = smoothstep(px,-px,length(p)-.455/level);\n            float s = length(p)-.425/level;\n \n            if(rnd<.675) {\n                if(rnd>.2) s=abs(s)-.05/level;\n                s = smoothstep(px,-px,s);\n                C=mix(C,hue((id.y*.05)+float(k+1)*.25),s);\n            } else {\n                C=mix(C,vec3(.2),d);\n                            \n                if(hash21(rnd+id)>.8) {\n                    p*=rot(rnd+T*.5);\n                    vec2 cs = vec2(.3,.075)/level;\n                    float cx=min(box(p,cs.yx),box(p,cs));\n                    C=mix(C,vec3(.8),smoothstep(px,-px,cx));\n                }\n            }\n\n            break;\n        }\n        level*=2.;\n    }\n    \n    C = pow(C, vec3(.4545));        \n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}