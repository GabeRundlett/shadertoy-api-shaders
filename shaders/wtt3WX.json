{
    "Shader": {
        "info": {
            "date": "1577990695",
            "description": "An infinite field of smiling flowers based on the artwork of Takeshi Murakami.\nI hope this brings you joy.\n\nMusic : Towa No Hana (Flowers of Eternity) by Yoko Ishida",
            "flags": 64,
            "hasliked": 0,
            "id": "wtt3WX",
            "likes": 49,
            "name": "Murakami Infinity",
            "published": 3,
            "tags": [
                "procedural",
                "art",
                "flowers",
                "takashi",
                "murakami"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 1659
        },
        "renderpass": [
            {
                "code": "//\n// Murakami Infinity by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// I have recently grown a fascination towards the art of Takashi Murakami, \n// especially his colorful flower series.\n// His vision is, not unlike Andy Warhol, that art can be mass produced with\n// endless variations of a basic concept. This led me to the thinking that, \n// at the extreme, these compositions could be auto-generated.\n//\n// I tried to reproduce Murakami's compositions following rules that are as true as\n// possible to the reference painting.\n//\n// I stuck with the black & white eyes although they are red and blue on most of the\n// paintings because I find them more pleasing this way. I might make a variation someday.\n//\n// The flower is re-created with a serie of ellipses in polar coordinates.\n//\n// I hope this brings you joy.\n\n// p.s : I just realized mhnewman attempted something similar, oh well... ;)\n\n\n#define S(a,b,t) smoothstep(a,b,t)\n\n// An ellipse signed distance function by iq\n// https://iquilezles.org/articles/ellipsedist\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = vec2(abs(z));\n    \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n\n// rotates pos to align the up vector towards up\nvec2 rotUp(vec2 pos, vec2 up)\n{\n    vec2 left = vec2(-up.y, up.x);\n    return left * pos.x + up * pos.y;\n}\n\nconst float pi = 3.1415926;\nconst float pi2 = 6.2831853;\nconst float quadrant = pi / 6.0;\n\nconst float blackLevel = 0.3; // True black is too aggressive\n\n\n\n// The mouth is the intersection of two ellipses, I traced them in photoshop to\n// compute the right radii and offsets\nfloat mouthDst(vec2 uv)\n{\n    return max(sdEllipse(uv - vec2(0.0, -0.17), vec2(0.30, 0.2055)),\n               sdEllipse(uv - vec2(0.0,  0.07), vec2(0.14, 0.2055)));\n}\n\n// For the eye, I use simpler circle distance maths in a scales and rotated space\n// as I don't need an accurate distance function to create an outline\nvec4 eye(vec2 uv, vec2 up, vec2 spot1, vec2 spot2, float scale)\n{\n    uv = rotUp(uv, up);\n    uv.x *= 1.5;\n    \n    float len = length(uv);\n    float len2 = length(uv + spot1);// vec2(0.010, 0.025));\n    float len3 = length(uv + spot2);// vec2(-0.005, -0.017));\n    \n    float aa = scale * 4.0 / iResolution.x;\n    \n    vec4 eye;\n    \n    eye.a = S(0.04 + aa, 0.04, len);\n    \n    eye.rgb = vec3(S(0.014, 0.014 - aa, len2) + S(0.02, 0.02 - aa, len3) + blackLevel);\n    \n    return eye;\n}\n\nconst float cRatio = 1.0 / 255.0;\n\n// I wanted the color palette to be true to the 16 hue rainbow used\n// by Murakami but I didn't manage to reproduce the orange-yellow-green part\n// using simple maths so I defaulted to a palette. Then I realized I couldn't target\n// Webgl < 3.0 (Wich was one of my objectives) with array constructor so I decided\n// to build a function selecting the right color with a dichotomic approch in hope\n// that the compiler will make a decent job of optimizing all those branches.\nvec3 palette(float id)\n{\n\tif (id < 6.0)\n    {\n        //[0 - 5]\n        if (id < 3.0)\n        {   //[0 - 2]\n            if (id < 1.0) return vec3(181.0, 23.0, 118.0) * cRatio;\n            else if (id < 2.0) return vec3(225.0, 27.0, 104.0) * cRatio;\n            else return vec3(230.0, 40.0, 24.0) * cRatio;\n        }\n        else\n        {   //[3 - 5]\n            if (id < 4.0) return vec3(240.0, 110.0, 14.0) * cRatio;\n            else if (id < 5.0) return vec3(253.0, 195.0, 2.0) * cRatio;\n            else return vec3(253.0, 241.0, 121.0) * cRatio;\n        }\n    }\n    else\n    {   //[6 - 11]\n        if (id < 9.0)\n        {   //[6 - 8]\n            if (id < 7.0) return vec3(167.0, 202.0, 56.0) * cRatio;\n            else if (id < 8.0) return  vec3(0.0, 152.0, 69.0) * cRatio;\n            else return vec3(2.0, 170.0, 179.0) * cRatio;\n        }\n        else\n        {   //[9 - 11] The darker color are at the end to be avoided by mod\n            if (id < 10.0) return vec3(25.0, 186.0, 240.0) * cRatio;\n            else if (id < 11.0) return  vec3(0.0, 98.0, 171.0) * cRatio;\n            else return vec3(40.0, 49.0, 118.0) * cRatio;\n        }\n    }\n}\n\n\n\n// Adapted from BigWIngs\nvec4 N24(vec2 t) {\n    float n = mod(t.x * 458.0 + t.y * 127.3, 100.0);\n\treturn fract(sin(n*vec4(123., 1024., 1456., 264.))*vec4(6547., 345., 8799., 1564.));\n}\n\n// That's where the meat of the shader is, drawing a flower\nvec4 flower(vec2 uv, vec2 id, float minSz, float maxSz, float scale)\n{\n    vec4 rnd = N24(id);//mod(id.x, 300.0) * mod(id.y, 500.0) * 13.56);\n    \n    float rdScale = mix(minSz, maxSz, rnd.z);\n    \n    scale *= rdScale; // The border thickness & AA is scale-independant\n    \n    uv.xy *= rdScale;\n    \n    uv.x += 0.1 + rnd.x * 0.5;\n    uv.y += 0.25 + rnd.y * 0.2;\n    uv.y += sin(iTime * mix(0.4, 1.0, rnd.y) + (rnd.w * 45.0)) * 0.2;\n\n    \n    float aa2 = scale * 3.0 / iResolution.x;\n    \n    float centerDst = length(uv);\n    \n    if (centerDst > 0.5) return vec4(0.0);\n    \n    float edge; // Mask for the outline edge\n    \n    vec4 color = vec4(1.0, 1.0, 1.0, 1.0); // Underlying color\n   \n    \n    float thick = 0.002 * scale;\n    \n    if (centerDst < 0.2)\n    {\n        //Face part\n        \n        float thres = 0.2 - thick;\n        \n        // inner part of edge circle surrounding the head\n        edge =  S(thres, thres - aa2, centerDst);\n        \n        float mouth = mouthDst(uv);\n        \n        // edge of the mouth\n        edge *= S(thick, thick + aa2, abs(mouth));\n        \n        // face color\n        float faceRnd = fract(rnd.x * 45.0 + rnd.y * 23.45);\n        if (faceRnd < 0.5) \n        {\n            // Flowers with classic yellow / red faces\n        \tcolor.rgb = (mouth < 0.0) ? vec3(1.0, 0.0, 0.0) : vec3(1.0, 1.0, 0.0); \n        }\n        else\n        {\n            // Flowers with white face / random color mouth\n            float colId = mod(faceRnd * 545.456, 11.0);\n            color.rgb = (mouth < 0.0) ? palette(colId) : vec3(1.0); \n        }\n        \n        // Eyes\n        vec4 eyeImg;\n        if (uv.x > 0.0)\n        {\n           eyeImg = eye(uv - vec2(0.075, 0.095), vec2(-0.7, 1.2),\n                       vec2(0.007, 0.025), vec2(-0.004, -0.019), scale);\n        }\n        else   \n        {\n           eyeImg = eye(uv - vec2(-0.075, 0.095), vec2(0.7, 1.2),\n                       vec2(0.024, 0.010), vec2(-0.016, -0.009), scale);\n        }\n\n        color.rgb = mix(color.rgb, eyeImg.rgb, eyeImg.a);\n    }\n    else\n    {\n        float rot = iTime * rnd.y * 0.5;\n        float angle = fract((atan(uv.x, uv.y) + rot) / pi2);\n    \n        float section = angle * 12.0;\n        float sectionId = floor(section);\n        \n        if (rdScale < 0.86 && rnd.w > 0.55)\n        {\n           // Rainbow flower\n           color.rgb = palette(sectionId);//mod(sectionId + (rnd.x + rnd.y) * 345.456, 12.0));\n        }\n        else if (rnd.y > 0.05)\n        {\n            //Alternating flower\n            if (mod(sectionId, 2.0) == 0.0)\n            {\n                // Color 1\n                float colId = mod((rnd.x + rnd.y) * 345.456, 10.0);\n                color.rgb = palette(colId);\n            }\n            else if (rnd.x > 0.75)\n            {\n                // Color 2\n                float colId = mod((rnd.w + rnd.z) * 545.456, 11.0);\n                color.rgb = palette(colId);\n            }\n            // else, Color2 is white by default\n        }\n\t\t// else, fully white petals\n        \n        if (centerDst < 0.36)\n        {\n            //intermediate part, concentric bars\n            \n            float sectionX = fract(section);\n            float edgeDist = 0.5 - abs(sectionX - 0.5);\n            \n            edgeDist *= centerDst; // Untaper bar space so bars have constant thickness\n            \n            float aa = scale * 7.0 / iResolution.x;\n            float bar = thick * 1.7;\n            edge = S(bar, bar + aa, edgeDist);\n\n            // outer part of edge circle surrounding the head\n            float thres = 0.2 + thick;\n            float head = S(thres, thres + aa2, centerDst);\n            edge *= head;\n        }\n        else\n        {\n            // Petal tips are actually ellipses, they could have been approximated them with\n            // circles but I didn't because I have OCD and I needed the ellipse SDF \n            // for the mouth anyways ;)\n            \n            // Angle to the center of the quadrant\n            float quadAngle = (sectionId + 0.5) * quadrant - rot + pi; \n\n            // Center of the ellipse\n            vec2 petalUp = vec2(-sin(quadAngle), -cos(quadAngle));\n            vec2 petalCenter = petalUp * 0.36;\n\n            // Rotation of the ellipse basis\n            vec2 petalSpace = rotUp(uv - petalCenter, petalUp);\n\n            // Signed distance function of the ellipse\n            float petalDst = sdEllipse(petalSpace, vec2(0.0944, 0.09));\n\n            //border edge and alpha mask\n            float borderIn = S(thick + aa2, thick, petalDst);\n            float borderOut = S(-thick, -thick - aa2, petalDst);\n\n            edge = (borderOut);\n            \n            color.a = borderIn;\n        }\n    }\n    \n    color.rgb = mix(vec3(blackLevel), color.rgb,edge);\n    \n    return color;\n}\n\n\nvec3 flowerLayer(vec2 uv, vec3 bg, float minSz, float maxSz, float scale)\n{\n    vec2 cellId = floor(uv);\n    vec2 cellUv = fract(uv) - vec2(0.5);\n   \n    //Check only 4 cells because the flower function is rather costly\n    for (float x = 0.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = 0.0; y <= 1.0; y += 1.0)\n    \t{\n            vec2 offset = vec2(x, y);\n            \n            vec4 f = flower(cellUv - offset, cellId + offset, minSz, maxSz, scale);\n    \t\tbg = mix(bg, f.rgb, f.a);\n    \t}\n    }\n    \n    return bg;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    float sc = 1.65 + cos(iTime* 0.1) * 0.25;\n    \n    uv.xy *= sc;\n    \n    uv.x += 35.9;\n    uv.y += 45.0;\n    \n \n    float scroll = iTime * 0.25;\n    \n\n   \tfloat t = iTime * 0.23;\n    vec3 col = vec3(0.8) + vec3(0.2) * sin(t + vec3(0.0, pi * 0.5, pi));\n    \n    col = flowerLayer(uv * 4.0 + vec2(scroll, -scroll * 0.3 + 59.0), col, 0.8, 1.0, 2.0 * sc);\n    col = flowerLayer(uv * 3.0 + vec2(scroll, -scroll * 0.2 + 59.0), col, 0.7, 1.25, 1.5 * sc);\n    col = flowerLayer(uv * 2.0 + vec2(scroll, -scroll * 0.1 + 345.0), col, 0.8, 2.0, 1.0 * sc);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 20710,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/anime-easy/ai-yori-aoshi-towa-no-hana"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}