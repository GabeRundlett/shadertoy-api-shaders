{
    "Shader": {
        "info": {
            "date": "1603907245",
            "description": "automatic music score from source music. ( don't expect any accuracy ! )\nFourier analysis (since provided one unusable) + note analysis. efficient warp //ism\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]",
            "flags": 36,
            "hasliked": 0,
            "id": "wdyyWc",
            "likes": 12,
            "name": "Fab27 #inktober2020 \"music\"score",
            "published": 3,
            "tags": [
                "scroll",
                "musical",
                "score"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 940
        },
        "renderpass": [
            {
                "code": "// from v0 https://shadertoy.com/view/wsycDy\n// + half tone = * 2^(1./12.)\n\n#define S(r, v)    clamp(  r - (v) * R.y * scale ,0.,1.)\n#define drawL(f)   S(  1.5, abs( f - y ) )\n#define drawN(f)   clamp( R.x/100. - length( vec2( x*(fract(U.x/x-(speed-1.))-.5), (f - y)* R.y * scale ) *mat2(.7,-.7,1,1) ),0.,1. )\n#define B(f)       O *= 1. - drawL(freq(f))          // lines\n\nfloat line(vec2 p, vec2 a,vec2 b) {                  // https://www.shadertoy.com/view/llySRh\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);  // proj coord on line\n    return length(p - b * h);                        // dist to segment\n}\n\n//  --- read note, get (f,r), draw extra horiz segments\n#define prep_note(i,f,r) {                                  \\\n    f =  note(i+8.*16.-speed-1.); /*  last note =127 */     \\\n    r = 1.;                                                 \\\n    if (f>900.) f/=2., r++;     /* higher range of notes */ \\\n /* if (f<240.) f*=2.;                                      \\\n    if ( f < 290.) B( 262.)/r;  /* horiz extra segments */  \\\n    if ( f < 243.) B( 220.)/r;                              \\\n    if ( f < 204.) B( 185.)/r;                              \\\n    if ( f > 790.) B( 880.)/r;                              \\\n    if ( f > 990.) B(1046.)/r;                              \\\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n // U.y = (exp2(U.y/R.y/scale)-1.)*R.y*scale;        // linearize frequencies\n    float x = R.x/speed, \n          y = U.y/R.y / scale,\n          i = floor( U.x / x ),                      // score slot number\n          l = U.x-x*i;\n    int m = (iFrame+int(i)) % 16;                    // pos in current measure\n    \n    O = vec4(1);                                     // background \n    O.gb -= .5 * texelFetch(iChannel1, ivec2(U), 0).r;\n    \n  // if (i<3.) {} else                               // --- draw key \n    {\n        float f,r, F,r0;                             //  --- draw note\n\n        prep_note(i,f,r);\n        O *= 1. - drawN(freq(f)) / r;                // draw body\n        \n        if (l/x<.3)                                  // continue potential left extra segment\n            prep_note(i-1.,F,r0);                    // prev note\n        \n        if ( y > freq(f) && y < freq(f)+.015 && x-l<2. ) O -= 1./r; // tail\n        \n        //int I = ( iFrame+int(i) ) / 4 * 4;\n        F = note(i-1. +8.*16.-speed-1.) / exp2(r-1.);// prev note\n        if ( (iFrame+int(i)) % 4 > 0  // or m > 0. ?\n            && abs(f/F-1.)<.16 )                     // 2-bar quaver\n            O *=  1. - S( 2., abs( line(vec2(l,y-.0135),vec2(0,freq(F)),vec2(x,freq(f))) - .0015) ) /r;\n    }\n    \n    if (  m == 0                                     // --- measure bars \n        && l<1. && y > freq(330.) && y < freq(699.) ) O *= 0.;\n    \n//        E1       G1       B2       D2       F2     // --- draw lines\n       B(330.); B(392.); B(494.); B(588.); B(699.);\n//  C1, D1,    F1       A2       C2       E2    G2  A3 \n// 262. 294.  350.     440.     523.     660.  784.  880.\n   //  B(165.); B(196.); B(247.); B(294.); B(350.);  // range below\n   //  B(660.); B(784.); B(494.); B(988.); B(1398.); // range up\n\n   // O *= 1. - .5* float ( drawL(freq(440.)) ) ;    // draw ref A\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float scale = 6.,\n      speed = 60.; // max 128\n\n#define R          iResolution.xy\n#define T(U)       texelFetch( iChannel0, ivec2(U), 0 )\n#define freq(f)   ( (f) / (iSampleRate/4.) )  // normalized freq. NB: last FFT value in texture = iSampleRate/4\n#define sound(y)   T(  ivec2( int((y)*512.) %64 , int((y)*512.) /64 ) ).r // read spectrum\n#define note(t)    T( ivec2(64 +(int(t)%8) , int(t)/8) ).r                // read music score",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// === frequency analyse + music score production ===================\n// note that both encodings are done so as to optimize warp parallelism:\n// warps are 4x8 pixels blocks and cost 1 eval :coding data as 1 single line would cost 8 times more\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float f;\n    if (U.x < 64. && U.y < 8.) {      // --- Fourier analysis of signal -------------\n        U -= .5;\n        f = ( U.x + 64.*U.y) /4.;                 // freq to analyze ( optim warps parallelisme )\n        vec2 v = vec2(0.);\n        for (float k = 0.; k  < 512.; k++ )       // compute fourier transform in .g\n            v += sin( f *6.28*k/512.+ vec2(0,1.5708) )\n            * ( 2.* texelFetch(iChannel1, ivec2(k,1), 0).r - 1. );\n\n        O.r = length(v) / 32.;  \n    //  O.r = exp2(length(v)/64.)/2.;\n    //  O.r = (1.- exp2(-length(v)/32.)) *.7+.3;\n    //  O.r = log2(1.+length(v)/32.) *.7+.3;  // <<\n    //  O.r = length(v) *f/64.;  \n    }\n    else if (U.x < 72. && U.y < 16.) { // --- music score ---------------------------\n        U -= .5; U.x -= 64.;\n        if ( U == vec2(7,15) ) {                  // analyse current note   \n            float m = 1., f = 1., v;\n            for (float k=0.; k  < 1489.; k++ ) {  // search note in spectrum\n                v = sound(freq(k));\n             // if ( v > m ) m = v, f = k;        // unweighted max intensity\n                if ( v*k > m*f ) m = v, f = k;    // maxy int weighted by 1/f\n            }\n            O.r = f;\n        }\n        else \n            O.r =  note( U.x + 8.*U.y +1.) ;      // offset with time\n    }\n    else discard;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "music",
                        "id": 13,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3"
                    },
                    {
                        "channel": 2,
                        "ctype": "mic",
                        "id": 32,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/mic.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// --- just to display scrolling spectrum\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float x = R.x/speed, \n          y = U.y/R.y / scale;\n    O = texelFetch(iChannel1, ivec2(U + vec2(x,0)), 0);  \n    if ( U.x < (speed-1.)*x ) return;                   // scroll  \n    O.r =  sound(y);                                    // update right band\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}