{
    "Shader": {
        "info": {
            "date": "1699177790",
            "description": "newton fractal",
            "flags": 0,
            "hasliked": 0,
            "id": "cddBzf",
            "likes": 3,
            "name": "Newton's Fractal test",
            "published": 3,
            "tags": [
                "newtonfractal"
            ],
            "usePreview": 0,
            "username": "Elyades",
            "viewed": 166
        },
        "renderpass": [
            {
                "code": "float PI = 3.14159265358979323846;\nfloat TWOPI = 6.28318530718;\nfloat PIONTWO = 1.57079632679;\n\nfloat atan2(float y, float x)\n{\n    //this computes arctan(y/x)\n    float angle = atan(y,x);\n    if(angle < 0.0){angle+= TWOPI;}\n    return(angle);\n}\n\nfloat norm(vec2 uv)\n{\n    return(float(uv.x*uv.x + uv.y*uv.y));\n}\n\nvec2 times (vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x - z1.y*z2.y , z1.x*z2.y + z1.y*z2.x);\n}\n\nvec2 oneoverz(vec2 uv)\n{\n    float squaremodulus = norm(uv);\n    return( vec2(uv.x/squaremodulus, -uv.y/squaremodulus) );\n}\n\nvec2 exp2d(vec2 uv)\n{\n    return vec2( exp(uv.x)*vec2(cos(uv.y),sin(uv.y)) );\n}\n\nvec2 cos2d(vec2 uv)\n{\n    return(vec2(0.5*( exp2d(times(uv,vec2(0.0,1.0))) + exp2d(times(-uv,vec2(0.0,1.0))))));\n}\n\n\nvec2 sin2d(vec2 uv)\n{\n    return(times(0.5*( exp2d(times(uv,vec2(0.0,1.0))) - exp2d(times(-uv,vec2(0.0,1.0)))),vec2(0.0,1.0)));\n}\n\nvec2 power(vec2 uv, float n)\n{\n    float modulus = length(uv);\n    float angle = atan2(uv.y,uv.x);\n    angle *= n;\n    \n    return( exp(n*log(modulus))*vec2(cos(angle),sin(angle)));\n}\n\nvec3 palette1( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,2.0);\n    vec3 d = vec3(0.0,0.2,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette2( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.33,0.66);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette3( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.0,1.5,1.0);\n    vec3 d = vec3(0.0,0.8,0.0);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette4( float t ) {\n    //by Inigo Quilez\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.0,0.1,0.2);\n\n    return vec3(a + b*cos(6.28318530718*(c*(t) + d)));\n}\n\nvec3 palette5 (float t)\n{\n    float value = 0.61;\n    vec3 a = vec3(value);\n    vec3 b = vec3(1.0-value);\n    vec3 c = vec3(2.0,1.0,1.0);\n    vec3 d = vec3(0.3,0.0,0.0);\n    \n    return (a + b*cos(TWOPI*(c*t + d)));\n}\n\nvec2 square(vec2 uv)\n{\n    return vec2(uv.x*uv.x - uv.y*uv.y, 2.0*uv.x*uv.y);\n}\n\nvec2 cube(vec2 uv)\n{\n    return vec2(uv.x*uv.x*uv.x - 3.0*uv.x*uv.y*uv.y , 3.0*uv.x*uv.x*uv.y - uv.y*uv.y*uv.y);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    float cosine = cos(angle); float sine = sin(angle);\n    return (vec2(cosine*uv.x - sine*uv.y, sine*uv.x + cosine*uv.y));\n}\n\nfloat n = 3.0;\n\nvec3 colorroot(float t, float k)\n{\n    float r = mod(k,3.0);\n    if (r == 0.0){return(palette1(t));}\n    else if(r == 1.0){return(palette2(t));}\n    else {return(palette3(t));}\n}\n\nvec3 colorunity(float t, vec2 znext, float p)\n{\n    for (int k = 0; k < int(p); k++)\n    {\n        if (norm(znext - exp2d(vec2(0.0,TWOPI*float(k)/p))) < 0.1)\n        {\n            return(colorroot(t,float(k)));\n        }\n    }\n}\n\nvec3 colorgeneral(float t, vec2 znext)\n{\n    vec3 col;\n    float iterationCount = t;\n    float scale = 8.0;\n    if (znext.x > 0.0 && znext.y > 0.0){col = palette1(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x > 0.0 && znext.y < 0.0){col = palette2(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x < 0.0 && znext.y > 0.0){col = palette3(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}\n    else if (znext.x < 0.0 && znext.y < 0.0){col = palette4(sqrt(float(iterationCount) + 2.0*norm(znext))/scale);}  \n    return(col);\n}\n\nvec2 function(vec2 uv, vec2 c)\n{\n    //return( power(uv,3.0) + times((c-vec2(1.0,0.0)),uv) - c );\n    float remainder = 0.0;\n    return (remainder*sin2d(uv) - (1.0-remainder)*power(uv,4.0) + c);\n}\n\nvec2 dfunction(vec2 uv,vec2 c)\n{\n    //return(3.0*power(uv,2.0) + c - vec2(1.0,0.0));\n    float remainder = 0.0;\n    return(remainder*cos2d(uv) - 4.0*(1.0-remainder)*power(uv,3.0));\n}\n\nvec2 newtonIteration(vec2 uv, vec2 c)\n{\n    vec2 a = vec2(1.8 - min(0.8,iTime/10.0));\n    uv = uv - a*times(function(uv,c),oneoverz(dfunction(uv,c)));\n    return(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord/iResolution.xy - 0.5)*300.0;\n    uv *= pow(10.0, (-1.5 + 0.4*cos(iTime*5.0))*min(max(iTime-9.0,0.0),1.0));\n    uv += vec2(0.0, 0.0);\n    uv = rotate(uv,max(iTime-8.0,0.0)*2.0);\n    vec2 zcurrent = uv;\n    float tolerance1 = pow(10.0,-10.0);\n    float tolerance2 = pow(10.0,-10.0);\n    vec2 znext = zcurrent;\n    float norm2 = 1.0;\n    int maxIteration = 1000;\n    int iterationCount = 0;\n    //vec2 c = (iMouse.xy/iResolution.xy - 0.5)*8.0;\n    vec2 c = oneoverz(uv);\n    while((norm(function(zcurrent,c)) > tolerance1) && (iterationCount <= maxIteration) )\n    {\n        zcurrent = znext;\n        znext = newtonIteration(zcurrent,c);\n        norm2 = norm(znext - zcurrent);\n        iterationCount += 1;\n    }\n    \n    vec3 col;\n    if(norm2 < tolerance2)\n    {\n        // for roots of unity:\n        //col = colorunity(float(iterationCount),znext,n);\n        // for anything else whose roots we dont know at first (i cba):\n        //col = colorgeneral(float(iterationCount), znext);\n        float scale = 20.0;\n        col = palette5(float(iterationCount)/scale);\n    }\n    \n    else{col = vec3(0.0);}\n    \n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}