{
    "Shader": {
        "info": {
            "date": "1487864719",
            "description": "A simple test on infinite zoom on a noise texture, with visible artifacts (sliding, periodic flashing, loss of contrast, etc.)\n\nUse the mouse to change the number of layers (bottom: high, top: low). Change the commented defines to fix artifacts.",
            "flags": 0,
            "hasliked": 0,
            "id": "4sfcD8",
            "likes": 6,
            "name": "(Bad) infinite zoom on noise",
            "published": 3,
            "tags": [
                "procedural",
                "2d",
                "noise",
                "zoom",
                "artifacts"
            ],
            "usePreview": 0,
            "username": "VinceTavernier",
            "viewed": 648
        },
        "renderpass": [
            {
                "code": "#define t (iTime*0.5) // Animation speed\n#define hmin .05            // Minimum scaling step\n#define h max(.01,abs(hmin+(iMouse.y/iResolution.y)))\n                            // Scale step between layers\n#define H (2.)              // Largest scale possible\n#define s (2.*(H / (2.*4.29193))*(H / (2.*4.29193)))\n                            // Amplitude modulation function 2*sigma^2\n#define mu (.5)             // Mean of input white noise\n#define mu2 (mu*mu)         // Squared mean of input white noise\n#define sigma_f2 (1./12.)   // Variance of input white noise\n\n// Choose between default and exponential *distribution* of\n// scaling coefficients. Default method introduces sliding.\n#define ai_fun ai_fun_def\n//#define ai_fun ai_fun_exp\n\n// Default to standard position mapping. Introduces correlation\n// Only fully random shows no correlation.\n#define pos_fun pos_fun_def\n//#define pos_fun pos_fun_lin\n//#define pos_fun pos_fun_rnd\n\n// Function to compute ai coefficients depending on the scaling.\nfloat ai_fun_def(float sf) {\n\treturn mod(sf - t, H);\n}\n\n// Exponential version of ai coefficient computation\nfloat ai_fun_exp(float sf) {\n\treturn H * exp(-mod(t - sf, H));\n}\n\n// The default position mapping function\nvec2 pos_fun_def(vec2 uv, float ai, float sf) {\n\treturn ai * uv;\n}\n\n// 2nd version: offset the layers by an amount\n// depending on the layer number\nvec2 pos_fun_lin(vec2 uv, float ai, float sf) {\n    return ai * uv + sf;\n}\n\n// The position mapping function with random offset\nvec2 pos_fun_rnd(vec2 uv, float ai, float sf) {\n\treturn ai * uv + iResolution.x*fract(4567.89*sin(765.43*sf*vec2(1,-13.17)+1.));\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n\t// screen-centered coordinates\n\tvec2 uv = (U.xy / iResolution.xy - .5);\n\n\t// Initial acc\n\tO = vec4(0.);\n\n\tfloat a = 0.;\n\t// Add up gaussian-intensity modulated samples of noise\n\tfor (float sf = 0.; sf < H; sf += h)\n\t{\n\t\tfloat k = ai_fun(sf),\n\t\t\t  e = k - 1.,\n\t\t\t  C = exp(-(e*e) / s); // Intensity scaling gaussian\n\n\t\tvec2 P = pos_fun(uv, k, sf);\n\t\tO += C * texture(iChannel0, P).rrrr;\n\t\ta += C;\n\t}\n\tO /= a;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}