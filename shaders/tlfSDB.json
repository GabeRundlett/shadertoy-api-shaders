{
    "Shader": {
        "info": {
            "date": "1564073508",
            "description": "This shader zooms in and out inside a mandelbrot set.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlfSDB",
            "likes": 3,
            "name": "Mandelbrot Set Zoom Animation",
            "published": 3,
            "tags": [
                "julia",
                "mandelbrot",
                "set"
            ],
            "usePreview": 0,
            "username": "BigETI",
            "viewed": 488
        },
        "renderpass": [
            {
                "code": "vec2 complexMultiplication(in highp vec2 left, in highp vec2 right)\n{\n    return vec2((left.x * right.x) - (left.y * right.y), (left.x * right.y) + (left.y * right.x));\n}\n\nfloat sqrMagnitude(in highp vec2 z)\n{\n    return (z.x * z.x) + (z.y * z.y);\n}\n\nvec2 complexPower(in highp vec2 left, in highp vec2 right)\n{\n    float magnitude_squared = sqrMagnitude(left);\n    float l = pow(magnitude_squared, right.x * 0.5) * exp(-right.y * atan(left.y, left.x));\n    float r = (right.x * atan(left.y, left.x)) + (0.5 * right.y * log(magnitude_squared));\n    return vec2(l * cos(r), l * sin(r));\n}\n\nvec3 julia(in highp vec2 position, highp float power)\n{\n    highp vec2 z = vec2(0.0, 0.0);\n    const vec3 colors[30] = vec3[30]\n    (\n        vec3(0.1, 0.0, 0.9),\n        vec3(0.2, 0.0, 0.8),\n        vec3(0.3, 0.0, 0.7),\n        vec3(0.4, 0.0, 0.6),\n        vec3(0.5, 0.0, 0.5),\n        vec3(0.6, 0.0, 0.4),\n        vec3(0.7, 0.0, 0.3),\n        vec3(0.8, 0.0, 0.2),\n        vec3(0.9, 0.0, 0.1),\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.9, 0.1, 0.0),\n        vec3(0.8, 0.2, 0.0),\n        vec3(0.7, 0.3, 0.0),\n        vec3(0.6, 0.4, 0.0),\n        vec3(0.5, 0.5, 0.0),\n        vec3(0.4, 0.6, 0.0),\n        vec3(0.3, 0.7, 0.0),\n        vec3(0.2, 0.8, 0.0),\n        vec3(0.1, 0.9, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.9, 0.1),\n        vec3(0.0, 0.8, 0.2),\n        vec3(0.0, 0.7, 0.3),\n        vec3(0.0, 0.6, 0.4),\n        vec3(0.0, 0.5, 0.5),\n        vec3(0.0, 0.4, 0.6),\n        vec3(0.0, 0.3, 0.7),\n        vec3(0.0, 0.2, 0.8),\n        vec3(0.0, 0.1, 0.9),\n        vec3(0.0, 0.0, 1.0)\n    );\n    for (int i = 0, j; i < 1024; i++)\n    {\n        z = complexPower(z, vec2(power, 0.0)) + position;\n        if (sqrMagnitude(z) > 4.0)\n        {\n            return colors[i % colors.length()];\n        }\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    bool reverse = false;\n    const float max_zoom = 16.0;\n    while (time >= max_zoom)\n    {\n        time -= max_zoom;\n        reverse = !reverse;\n    }\n    time = (reverse ? (max_zoom - time) : time);\n    float zoom = exp(time) * 0.75;\n    vec2 start_center = vec2(0.0, 0.0);\n    vec2 target_center = vec2(-0.745428, 0.113009);\n    float t = clamp(time, 0.0, 1.0);\n    vec2 center = mix(start_center, target_center, t);\n    float power = 2.0;\n    vec2 position = vec2((((fragCoord.x * 3.0 / iResolution.x) - 2.0) / zoom) + center.x, (((fragCoord.y * 2.0 / iResolution.y) - 1.0) / zoom) + center.y);\n    vec2 position_offset = vec2(((((fragCoord.x + 0.5) * 3.0 / iResolution.x) - 2.0) / zoom) + center.x, ((((fragCoord.y + 0.5) * 2.0 / iResolution.y) - 1.0) / zoom) + center.y) - position;\n    vec3 color = julia(position, power);\n    vec3 sum_sub_colors =\n        julia(vec2(position.x + position_offset.x, position.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y), power) +\n        julia(vec2(position.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x, position.y - position_offset.y), power) +\n        julia(vec2(position.x + position_offset.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y + position_offset.y), power) +\n        julia(vec2(position.x + position_offset.x, position.y - position_offset.y), power) +\n        julia(vec2(position.x - position_offset.x, position.y - position_offset.y), power);\n    fragColor = vec4(vec3(sum_sub_colors.x * 0.0625, sum_sub_colors.y * 0.0625, sum_sub_colors.z * 0.0625) + vec3(color.x * 0.5, color.y * 0.5, color.z * 0.5), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}