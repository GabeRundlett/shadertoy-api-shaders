{
    "Shader": {
        "info": {
            "date": "1618066424",
            "description": "Magic Minecraft Cube [Zherdev]\n\nMinecraft sub scene generation is inspired by https://www.shadertoy.com/view/tslGRX\n\nSee it at Github:\nhttps://github.com/Zherdev/shadertoy-magic-cube/",
            "flags": 96,
            "hasliked": 0,
            "id": "7dj3D3",
            "likes": 2,
            "name": "Magic Minecraft Cube [Zherdev]",
            "published": 3,
            "tags": [
                "cube",
                "minecraft",
                "mashgraph",
                "zherdev"
            ],
            "usePreview": 0,
            "username": "s02180426",
            "viewed": 424
        },
        "renderpass": [
            {
                "code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Image\" module - takes mean result from Buffer B and draws it.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 26834,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/minecraft-soundtrack/sweden"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Buffer A\" module - renders image for each frame.\n\n\n// Common ======================================================================\n\nconst float INF = 1e10;\nconst int   LIGHTS_NUM = 2;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nfloat sqr(float v)\n{\n    return v * v;\n}\n\nvec2 getUV(vec2 fragCoord)\n{\n    return (fragCoord - iResolution.xy / 2.0) / iResolution.y;\n}\n\nfloat noise(vec3 v)\n{\n    return textureLod(iChannel0, v, 0.0).x;\n}\n\nfloat noise3(vec3 p)\n{\n    vec3 size = 1.0 / vec3(textureSize(iChannel0, 0));\n    return (\n        noise(p * size * 1.0 + vec3(0.52, 0.78, 0.43)) * 0.5 +\n        noise(p * size * 2.0 + vec3(0.33, 0.30, 0.76)) * 0.25 +\n        noise(p * size * 4.0 + vec3(0.70, 0.25, 0.92)) * 0.125) * 1.14;\n}\n\nfloat rand(float frame)\n{\n    return fract(\n            sin(\n                dot(\n                    vec3(frame),\n                    vec3(12.9899,78.234,45.5433)\n                )\n            ) * 43758.5452);\n}\n\nstruct TraceResult {\n    vec3  vp;\n    vec3  p;\n    vec3  n;\n    float dist;\n    bool  hit;\n};\n\nstruct TraceSubsceneResult {\n    TraceResult globalTrace;\n    TraceResult subTrace;\n    float       sumDist;\n    bool        hit;\n};\n\nstruct RefractionResult {\n    vec3 newDir;\n    bool isReflection;\n};\n\nRefractionResult calcRefraction(vec3 v, vec3 normal, float n1, float n2) {\n    RefractionResult res;\n    \n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    \n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3  tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    \n    if (abs(sinB) > 1.0) {\n        res.newDir = reflect(v, normal);\n        res.isReflection = true;\n        return res;\n    }\n    \n    float cosB = sqrt(1.0 - sinB * sinB);\n    \n    res.newDir = sinB * tang + cosB * normal;\n    return res;\n}\n\n\n// Common ^=====================================================================\n\n// Lights ======================================================================\n\nstruct Light {\n    vec3  pos;\n    vec3  color;\n    float attBase;\n    float radius;\n};\n\nstruct TraceLightResult {\n    float dist;\n    vec3  n;\n    vec3  color;\n    bool  hit;\n};\n\nvec3 calcLight(Light lights[LIGHTS_NUM], vec3 pos, vec3 color, vec3 normal) \n{\n    vec3 sum = vec3(0.0);\n    \n    for (int i = 0; i < LIGHTS_NUM; i++) {\n        Light light = lights[i];\n        vec3 dist = light.pos - pos;\n        float distSq = dot(dist, dist);\n        float att = light.attBase / distSq;\n        sum += max(0.0, dot(normal, normalize(dist))) * light.color * att;\n    }\n    \n    return color * sum;\n}\n\nTraceResult traceLight(Light light, vec3 orig, vec3 dir)\n{\n    TraceResult res;\n    \n    vec3 pos = orig - light.pos;\n    \n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - sqr(light.radius);\n    \n    float D = sqr(b) - a * c;   \n    if (D < 0.0) {\n        return res;\n    }\n    \n    float t1 = -b - sqrt(D);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t2 = -b + sqrt(D);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t = min(t1, t2);\n    if (t == INF) {\n        return res;\n    }\n   \n    res.n = normalize(pos + t * dir);\n    res.dist = t;\n    res.hit = true;\n    return res;\n}\n\nTraceLightResult traceLights(Light lights[LIGHTS_NUM], vec3 orig, vec3 dir) \n{\n    TraceLightResult res;\n    res.dist = INF;\n    \n\n    for (int i = 0; i < LIGHTS_NUM; i++) {\n        Light light = lights[i];\n        TraceResult tLight = traceLight(light, orig, dir);\n        if (tLight.hit && tLight.dist < res.dist) {\n            res.color = light.color;\n            res.n = tLight.n;\n            res.dist = tLight.dist;\n        }\n    }\n    \n    res.hit = res.dist >= 0.0 && res.dist < INF;\n    return res;\n}\n\n// Lights ^=====================================================================\n\n// Cube figure =================================================================\n\nstruct Cube {\n    float size;\n    float reflectN;\n    float reflectR;\n    vec3  color;\n};\n\nfloat traceCubePlane(Cube cube, vec3 normal, vec3 orig, vec3 dir) \n{\n    // normal * (orig + t * dir) + cube.size = 0\n    // t = ?\n    float t = -(dot(normal, orig) + cube.size) / dot(normal, dir);\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    vec3 pos = orig + t * dir;\n    if (abs(pos.x) > cube.size + PRECISION     ||\n            abs(pos.y) > cube.size + PRECISION ||\n            abs(pos.z) > cube.size + PRECISION) {\n        return INF;\n    }\n    \n    return t;\n}\n\nTraceResult traceCube(Cube cube, vec3 orig, vec3 dir) \n{\n    TraceResult res;\n    \n    float dist = INF;\n    vec3 normal;\n    \n    const int planesNum = 6;\n    vec3 planes[planesNum];\n    planes[0] = vec3(1, 0, 0);\n    planes[1] = vec3(-1, 0, 0);\n    planes[2] = vec3(0, 1, 0);\n    planes[3] = vec3(0, -1, 0);\n    planes[4] = vec3(0, 0, 1);\n    planes[5] = vec3(0, 0, -1);\n    \n    for (int i = 0; i < planesNum; i++) {\n        vec3 plane = planes[i];\n        float distToPlane = traceCubePlane(cube, plane, orig, dir);\n        if (distToPlane < dist) {\n            dist = distToPlane;\n            normal = plane;\n        }\n    }\n    \n    res.dist = dist;\n    res.n = -normal;\n    res.hit = dist >= 0.0 && dist < INF;\n    \n    return res;\n}\n\n// Cube figure ^================================================================\n\n// Minecraft ===================================================================\n\nstruct Minecraft {\n    Cube  subscene;\n    float size;\n    float maxHeight;\n};\n\nbool isMinecraftGrassBlock(Minecraft mine, vec3 vp)\n{\n    if (vp.y < mine.maxHeight - 2.0) {\n        const float threshold = 0.75;\n        return noise3(vp * 0.03) + vp.y * -0.015 > threshold;\n    }\n    \n    return false;\n}\n\nTraceResult traceMinecraftGrass(Minecraft mine, vec3 orig, vec3 dir)\n{\n    float maxDist = length(\n            vec2(2.0 * mine.size, 2.0 * mine.size));\n    float dist = maxDist;\n    \n    TraceResult res;\n    res.n = -dir;\n    res.dist = INF;\n\n    vec3 id = 1.0 / dir;\n    vec3 sd = sign(dir);\n    vec3 nd = max(-sd, 0.0);\n    vec3 vp = floor(orig) - nd * vec3(equal(floor(orig), orig));\n    vec3 pos = orig;\n\n    for (int i = 0; i < int(maxDist); i++) {\n        if (dist <= 0.0 || orig.y > mine.maxHeight && dir.y > 0.0) {\n        \tbreak;\n        }\n\n        if (isMinecraftGrassBlock(mine, vp)) {\n\t\t\tres.vp = vp;\n\t\t\tres.p = pos;\n\t\t\tres.dist = maxDist - dist;\n\t\t\tres.hit = true;\n\t\t\treturn res;\n        }\n\n        vec3 n = mix(floor(pos + 1.0), ceil(pos - 1.0), nd);\n\t\tvec3 ls = (n - pos) * id;\n\t\tfloat l = min(min(ls.x, ls.y), ls.z);\n\t\tvec3 a = vec3(equal(vec3(l), ls));\n\n        pos = mix(pos + dir * l, n, a);\n        vp += sd * a;\n        res.n = -sd * a;\n        dist -= l;\n    }\n\n    return res;\n}\n\nvec3 renderMinecraftGrass(Minecraft mine, TraceResult r, vec3 orig, vec3 dir)\n{\n    const vec3 grassBaseColor = vec3(0.5, 0.8, 0.25);\n    const vec3 dirtColor = vec3(0.8, 0.6, 0.4);\n    float texelNoise = textureLod(iChannel0, r.p * 0.5, 0.0).r;\n\n    // Check if block above this is grass (dirt) too.\n    float grassMix = 0.0;\n    if (!isMinecraftGrassBlock(mine, r.vp + vec3(0, 1, 0))) {\n        if (texelNoise * 4.0 + floor(fract(r.p.y) * 16.0) > 15.0) {\n            grassMix = 1.0;\n        } else {\n            grassMix = max(0.0, r.n.y);\n        }\n    }\n\n    vec3 texel = vec3(texelNoise) * 0.3 + 0.75;\n    vec3 grassColor = texel * mix(dirtColor, grassBaseColor, grassMix);\n    return grassColor;\n}\n\nvec3 toMinePos(Minecraft mine, TraceResult tMineCube, vec3 orig, vec3 dir)\n{\n    vec3 mineGlobalPos = orig + tMineCube.dist * dir;\n    vec3 minePos = mineGlobalPos * mine.size / mine.subscene.size;\n    minePos.y -= 10.0;\n    minePos.x += 45.0;\n    return minePos;\n}\n\nbool isMinecraftNoise(\n        Minecraft mine, TraceSubsceneResult t, vec3 orig, vec3 dir)\n{\n    vec3 minePos = toMinePos(mine, t.globalTrace, orig, dir);\n    vec3 globalPos = orig + t.sumDist * dir;\n    return length(globalPos) / mine.subscene.size * 3.5 - \n           minePos.y / mine.size +\n           noise(globalPos) * 2.0 < 5.0;\n}\n\nTraceSubsceneResult traceMinecraftSubscene(Minecraft mine, vec3 orig, vec3 dir)\n{\n    TraceSubsceneResult res;\n    \n    TraceResult tMineCube = traceCube(mine.subscene, orig, dir);\n    res.globalTrace = tMineCube;\n    if (tMineCube.hit) {\n        vec3 minePos = toMinePos(mine, tMineCube, orig, dir);\n        res.subTrace = traceMinecraftGrass(mine, minePos, dir);\n        res.sumDist = tMineCube.dist + res.subTrace.dist / \n                (mine.size / mine.subscene.size);\n        \n        res.subTrace.hit = res.subTrace.hit && isMinecraftNoise(mine, res, orig, dir);\n    }\n    \n    res.hit = res.globalTrace.hit && res.subTrace.hit;\n    \n    return res;\n}\n\nvec3 renderMinecraftSubscene(\n        Minecraft mine, TraceSubsceneResult t, vec3 orig, vec3 dir)\n{\n    vec3 minePos = toMinePos(mine, t.globalTrace, orig, dir);\n    return renderMinecraftGrass(mine, t.subTrace, minePos, dir);\n}\n\n// Minecraft ^==================================================================\n\n// Cylinder figure =============================================================\n\nstruct Cylinder {\n    float radius;\n    float height;\n    vec3  center;\n    vec3  color;\n};\n\nfloat traceCylinderPlane(Cylinder cyl, vec3 normal, vec3 orig, vec3 dir)\n{\n    float d = cyl.height + cyl.center.y;\n    float t = -(dot(normal, orig) + d) / dot(normal, dir);\n    if (t < 0.0) {\n        return INF;\n    }\n    \n    vec3 pos = orig + t * dir;\n    if (length(pos.xz - cyl.center.xz) > cyl.radius) {\n        return INF;\n    }\n    \n    return t;\n}\n\nvec3 calcCylSideNormal(Cylinder cyl, float dist, vec3 orig, vec3 dir)\n{\n    vec3 pos = orig + dist * dir;\n    vec3 normal = normalize(vec3(pos.x, 0.0, pos.z));\n    return normal;\n}\n\nfloat traceCylinderSide(Cylinder cyl, vec3 orig, vec3 dir)\n{\n    // length((orig + t * dir).xy) = cyl.radius\n    // t = ?\n    \n    float a = sqr(length(dir.xz));\n    float b = 2.0 * dot(dir.xz, orig.xz);\n    float c = sqr(length(orig.xz)) - sqr(cyl.radius);\n    float D = sqr(b) - 4.0 * a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    \n    float t1 = (-b + sqrt(D)) / (2.0 * a);\n    if (t1 < 0.0) {\n        t1 = INF;\n    }\n    \n    float t2 = (-b - sqrt(D)) / (2.0 * a);\n    if (t2 < 0.0) {\n        t2 = INF;\n    }\n    \n    float t = min(t1, t2);\n    vec3 pos = orig + t * dir;\n    if ((pos.y > cyl.center.y + cyl.height) ||\n             (pos.y < cyl.center.y - cyl.height)) {\n        return INF;\n    }\n    return t;\n}\n\nTraceResult traceCylinder(Cylinder cyl, vec3 orig, vec3 dir)\n{\n    TraceResult res;\n    \n    float dist = INF;\n    vec3 normal;\n    \n    vec3 plane = vec3(0, -1, 0);\n    float toPlane = traceCylinderPlane(cyl, plane, orig, dir);\n    if (toPlane < dist) {\n        dist = toPlane;\n        normal = -plane;\n    }\n    \n    float toSide = traceCylinderSide(cyl, orig, dir);\n    if (toSide < dist) {\n        dist = toSide;\n        normal = calcCylSideNormal(cyl, dist, orig, dir);\n    }\n    \n    res.dist = dist;\n    res.n = normal;\n    res.hit = dist >= 0.0 && dist < INF;\n    \n    return res;\n}\n\n// Cylinder figure ^============================================================\n\n// Main ========================================================================\n\nmat3 mainCamera(vec3 cameraPos, vec3 lookAtPoint)\n{\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat2 mainRotate(float angle) {\n    float s = sin(angle);\n    float cs = cos(angle);\n    \n    return mat2(\n                cs, -s, \n                s,  cs\n            );\n}\n\nvec3 renderMainFrag(vec2 uv, vec2 fragCoord)\n{\n    vec3 lp = vec3(0);\n    vec3 orig = vec3(0, 1.3, 3.5);\n    orig.xz *= mainRotate(PI / 6.0);\n    \n    mat3 camera = mainCamera(orig, lp);\n    vec3 dir = camera * normalize(vec3(uv, -1));\n    \n    vec3 randVals = vec3(\n            rand(float(iFrame)), \n            rand(float(iFrame + 5)), \n            rand(float(iFrame + 15)));\n\n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float nPrev = AIR_N;\n    float GLASS_R = sqr(AIR_N - GLASS_N) / sqr(AIR_N + GLASS_N);\n    \n    // Light setup =============================================================\n    Light lights[LIGHTS_NUM];\n    \n    lights[0].pos = vec3(1.8, 1.5, 1.8);\n    lights[0].color = vec3(1, 1, 1);\n    lights[0].attBase = 20.0;\n    lights[0].radius = 0.3;\n    \n    lights[1].pos = vec3(-3.5, 0.5, -1.0);\n    lights[1].color = vec3(1.1, 0.6, 0.6);\n    lights[1].attBase = 10.0;\n    lights[1].radius = 0.2;\n    // Light setup ^============================================================\n\n    // Figures setup ===========================================================\n    Cylinder cyl;\n    cyl.radius = 1.3;\n    cyl.height = 2.15 + PRECISION;\n    cyl.center = vec3(0.0, -3, 0.0);\n    cyl.color = vec3(0.9, 1.0, 0.9);\n\n    Cube cube;\n    cube.size = 0.85;\n    cube.reflectN = GLASS_N;\n    cube.reflectR = GLASS_R;\n    cube.color = vec3(0.9, 0.7, 1.0);\n    // Figures setup ^==========================================================\n    \n    // Minecraft setup =========================================================\n    Cube mineSubscene;\n    mineSubscene.size = 0.7;\n    \n    Minecraft mine;\n    mine.subscene = mineSubscene;\n    mine.size = 15.0;\n    mine.maxHeight = 18.0;\n    // Minecraft setup ^========================================================\n    \n    \n    vec3 colorMult = vec3(1, 1, 1);\n    vec3 res = vec3(0.0);\n    \n    for (int i = 0; i < 10; i++) {\n        float t = INF;\n        int materialType = 0;\n        vec3 color = vec3(0);\n        vec3 normal = vec3(0);\n        float nNext = AIR_N;\n        \n        TraceLightResult tLight = traceLights(lights, orig, dir);\n        if (tLight.hit && tLight.dist < t) {\n            t = tLight.dist;\n            color = tLight.color;\n            normal = tLight.n;\n            materialType = EMISSION;\n        }\n        \n        TraceResult tCube = traceCube(cube, orig, dir);\n        if (tCube.hit && tCube.dist < t) {\n            t = tCube.dist;\n            normal = tCube.n;\n    \n            if (randVals.x < cube.reflectR) {\n                materialType = REFLECTION;\n            } else {\n                colorMult *= cube.color;\n                materialType = REFRACTION;\n                if (dot(dir, normal) > 0.0) {\n                    nNext = AIR_N;\n                } else {\n                    nNext = cube.reflectN;\n                }\n            }\n        }\n        \n        TraceResult tCyl = traceCylinder(cyl, orig, dir);\n        if (tCyl.hit && tCyl.dist < t) {\n            t = tCyl.dist;\n            normal = tCyl.n;\n            materialType = DIFFUSE;\n            color = cyl.color;\n        }\n        \n        TraceSubsceneResult tMine = traceMinecraftSubscene(mine, orig, dir);\n        if (tMine.hit && tMine.sumDist < t) {\n            t = tMine.sumDist;\n            materialType = DIFFUSE;\n            color = renderMinecraftSubscene(mine, tMine, orig, dir);\n            normal = tMine.subTrace.n;\n        }\n        \n        if (t != INF) {\n            vec3 gloalPos = orig + t * dir;\n            \n            if (materialType == DIFFUSE) {\n                res = calcLight(lights, gloalPos, color, normal) * colorMult;\n                break;\n            } else if (materialType == REFLECTION) {\n                dir = reflect(dir, normal);\n                orig = gloalPos + dir * PRECISION;\n            } else if (materialType == REFRACTION) {\n                RefractionResult ref = calcRefraction(dir, normal, nPrev, nNext);\n                dir = ref.newDir;\n                orig = gloalPos + dir * 2.0 * PRECISION;\n                \n                if (!ref.isReflection) {\n                    nPrev = nNext;\n                }\n            } else if (materialType == EMISSION) {\n                res = color * colorMult;\n                break;\n            }\n        } else {\n            res = texture(iChannel1, dir).rgb * colorMult;\n            break;\n        }\n    }\n    \n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0);\n    vec2 uv = getUV(fragCoord);\n\n    const int antiAliasing = 8;\n    vec2 uvs[antiAliasing];\n    uvs[0] = vec2(0.0, 0.0);\n    uvs[1] = vec2(1.0, 1.0);\n    uvs[2] = vec2(-1.0, -1.0);\n    uvs[3] = vec2(-1.0, 1.0);\n    uvs[4] = vec2(1.0, -1.0);\n    uvs[5] = vec2(0.0, -1.0);\n    uvs[6] = vec2(1.0, 0.0);\n    uvs[7] = vec2(-1.0, 0.0);\n    \n    for (int i = 0; i < antiAliasing; i++) {\n        vec2 uvh = uv + uvs[i] / iResolution.xy;\n        col += renderMainFrag(uvh, fragCoord);\n    }\n    col /= float(antiAliasing);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n// Main ^=======================================================================\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Magic Minecraft Cube\n// https://github.com/Zherdev/shadertoy-magic-cube/\n//\n// \"Buffer B\" module - used for result accumulation.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}