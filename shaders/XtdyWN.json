{
    "Shader": {
        "info": {
            "date": "1532690597",
            "description": "noit an original shader, see parent link.\nonly some slight improvements on the parent",
            "flags": 0,
            "hasliked": 0,
            "id": "XtdyWN",
            "likes": 2,
            "name": "giraffe hopping",
            "published": 3,
            "tags": [
                "giraffe"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "//sign 2d head giraffe hopping\n//https://www.shadertoy.com/view/MsSyRz\n\n\n//this shader did many things VERY inefficiently.\n//i was hoping for wisdom in this one,only to find obfuscation.\n//\n//as in ,not smart generalizations,and overly complicated/repetitive functions\n//  ,insufficient use of reflection and transflection.\n//it goes to show that it is not so much about efficiency,but about composition.\n\n#define PI 3.14159\n#define PI2 PI*2.0\n#define sm(a,b)smoothstep(a-10./iResolution.y,a,b)\n\n#define m2(a)mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//EvaluateCustomMove returns an angle over t,for an animation that is a bit like an egg-shaped f(x)\nfloat EvaluateCustomMove(float t,float a,float b){t=fract(t);t*=(t-1.);return mix(a,b,-4.*t);}\n//this animation makes for a nice relaxed-bounce-carricature.\n\nfloat PatternCircles(vec2 p,float m)\n{p.x-=m*.5*step(0.,sin(PI*p.y/m))\n;p=mod(p,m)-m*.5\n;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n\nfloat sRegion(vec2 p,vec2 d){return step(0.,dot(p,d));}\nfloat sSquare(vec2 p){p=abs(p);return step(-1.,-max(p.x,p.y));}\n\nfloat sCircle(vec2 p,float r){return sm(0.,r*r-(p.x*p.x+p.y*p.y));}//squared distance to ciecle.\nfloat sSemiCircle(vec2 p,float radius){return sm(0.,p.y)*sCircle(p,radius);}\n\nfloat fCapsule(vec2 p,float w){vec2 s=p;s.x/=w\n;return max(max(sCircle(p-vec2(-w,0.),1.)\n    ,sCircle(p-vec2(w,0.),1.))\n   ,sSquare(s));}//the inefficient way to make a capule,neglects mirror symmetry.\n\n//l-shaped body,is VERY inefficient/lazy composition of 2 rectangles,+1 circle,-1 circle.\nfloat fBody(vec2 p)\n{float f=max(sCircle(p,1.),sSquare(p*vec2(1.2,1)+vec2(1,0)))\n;f=max(f      ,sSquare(p*vec2(1.5,1)-vec2(.5,1.)))\n;return min(f,(1.-sCircle(p-vec2(-1.95,2.6),2.5)));}\n\n//lolypopp-shaped antenna;min(circle,rectangle);some user friendly UI\nfloat fLollipop(vec2 p,float w,float h,float r)//width,height,radius\n{vec2 s=p;s.y-=(1.+h)*r;return max(sCircle(p,r),sSquare(s/vec2(w,h)));}\n\n//floopy sinusoidial leg. its lazy ands cute,not a good gradient.\nfloat fLeg(vec2 p,float s,float t)//amp thickness\n{float f=p.y-s*sin(p.x);return(1.-sm(0.,p.x-PI))*sm(0.,p.x)*(1.-sm(t,f))*sm(-t,f);}//sm()is smoothstep(),scaled by resolution\n//a decapitated function,it uses a rotated leg for a tail:\n//float fTail(vec2 p,float a,float t,float l){return fLeg(p,a,t)*(1.-sm(0.,p.x-l));}//amp thickness limitx\n\nfloat fEye(vec2 p,float t,float l)//thickness,limitx\n{return sm(-l,p.x)*(1.-sm(l,p.x))*sm(-t,p.y-p.x*p.x)*(1.-sm(t,p.y-p.x*p.x));}//returns eyelid shape.\n\n\nvoid mainImage(out vec4 O,in vec2 fragCoord){float time=3.*iTime\n;vec4 backgroundCol=vec4(38,173,106,255)/255.\n;vec4 shadowCol =vec4(34,130,89,255)/255.\n;vec4 cskin  =vec4(255,207,64,255)/255.\n;vec4 cnose  =vec4(232,163,1,0)/255.\n;vec4 spotsCol  =vec4(208,124,74,1)/255.\n;vec4 blackCol  =vec4(0,0,0,1)\n;vec4 col=backgroundCol\n;\n;vec2 p=fragCoord.xy/iResolution.xy\n;p-=.5\n;p.x*=iResolution.x/iResolution.y\n;p.y-=-.3\n;p*=19.\n;p.x-=mod(time,22.*2.)-22.\n//Inspired by Javier Ag√ºera,iapafoto and FabriceNeyret2,\n;float k=1.5+3.5*(.5-.5*cos(time)) //neck length changes over time\n//;float k=1.\n;\n;float motherHeight=mix(k,6.-k,step(0.,p.x))\n;p.x=mix(p.x,mod(p.x,6.)-2.5,step(-6.,p.x)*(1.-step(6.,p.x)))\n;vec2 pbody=p\n;pbody.y+=EvaluateCustomMove(time,0.,-.4*PI)\n;float f=fBody(pbody)\n;O=mix(O,cskin,f)//body yellow\n;f*=PatternCircles(3.*pbody,3.)+PatternCircles(7.*(pbody+vec2(0.,.7)),7.)\n;f*=step(1.,pbody.y)\n;O=mix(O,spotsCol,f)//body dots\n;//order matters for above and below,because the below uses the \"f\" of the above.\n;vec2 psquare=(pbody-vec2(.74,7.-(5.-motherHeight)))/vec2(.25,motherHeight)\n;f=sSquare(psquare)\n;O=mix(O,cskin,f)//neck yellow\n;f*=PatternCircles(3.*pbody,3.)+PatternCircles(7.*(pbody+vec2(.0,.7)),7.)\n;f*=1.-step(11.,pbody.y)\n;O=mix(O,spotsCol,f)//neck dots\n;\n;float t=EvaluateCustomMove(time,.05*PI2,-.05*PI2)\n;vec2 phead=((p-vec2(2.75,12.4-1.85*(5.-motherHeight)))*m2(t)*1.3)+vec2(1,0)\n;O=mix(O,cskin,fCapsule(phead,1.))//head(without nose)\n;\n;mat2 m=m2(PI);//head rotation\n;t=PI+EvaluateCustomMove(time,-.2*PI,.1*PI)\n;vec2 pear=(pbody-vec2(.4,12.-1.85*(5.-motherHeight)))*m*2.-vec2(1,0);pear.x*=.8\n;O=mix(O,cskin,sSemiCircle(pear,1.))//ear\n;O=mix(O,cskin,fLollipop(3.4*(phead-vec2(-1.9,2.))*m,.25,2.5,1.))//2 antennas\n;O=mix(O,cskin,fLollipop(3.5*(phead-vec2(-1.1,2.4))*m,.25,2.5,1.))//this could be faster with the [transflect-ion] function\n;f=sCircle(3.5*phead-vec2(3.3,1.5),1.)+sCircle(3.5*phead-vec2(3.3,-1.5),1.)//2 circles,could be faster with a mirror.\n;O=mix(O,cnose,f)//2 nose holes\n;vec2 peye=3.*phead-vec2(-3.,.4);peye.x*=1.3;O=mix(O,blackCol,fEye(peye,.2,1.1))//closed eyelid\n;\n;//4 legs,fail to utilize modulo symmetry,even thoug hthere is no overlap over the whole animation.:\n;float amp=.5*sin(2.*PI*time)\n;float angle=EvaluateCustomMove(time,-PI*.5,-.6*PI*.5)\n;m=m2(angle);//leg rotation\n;O=mix(O,cskin,fLeg((pbody+vec2(-.3,.9))*m*1.7,amp,.12))\n;O=mix(O,cskin,fLeg((pbody+vec2( 1,.9))*m*1.7,amp,.12))\n;\n;amp=.8*(.5-.5*cos(2.*PI*time))\n;angle=EvaluateCustomMove(time,-PI*.5,-1.5*PI*.5)\n;m=m2(angle);//leg rotation\n;O=mix(O,cskin,fLeg((pbody+vec2(1.2,.9))*m*1.7,amp,.12))\n;O=mix(O,cskin,fLeg((pbody+vec2(0  ,.9))*m*1.7,amp,.12))\n;\n;vec2 ptail=pbody+vec2(1.6,-.05)\n;angle=PI+EvaluateCustomMove(time,-.8*PI*.5,.8*PI*.5)//tail is a small leg,rotated by 90deg.\n;ptail*=mat2(cos(angle),sin(angle),-sin(angle),cos(angle))\n;ptail*=3.\n;f=fLeg(ptail,.4*cos(2.*PI*time),.2)\n;O=mix(O,cskin,f);\n;\n;f=fCapsule(7.*p+vec2(3.,20.),EvaluateCustomMove(time,8.,15.))//capsule for shadows,gets clipped off poorly.\n;O=mix(O,shadowCol,f)\n\n//;float d=sSquare(p)//just testing if sSquare is really as slow as it is.\n//;p.x=fract(p.x);float d=step(1.,EvaluateCustomMove(p.x,p.y,p.x)-p.y)//visualizing an animation\n//;float d=PatternCircles(p,.0);//patterncircles makes 2 circles with b==0. other b is weird.\n//;O.xyz=vec3(d);\n;}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}