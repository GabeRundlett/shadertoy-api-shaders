{
    "Shader": {
        "info": {
            "date": "1665669247",
            "description": "WIP\nMultigrid solver of buoyant fluid with combustion ported from [url]https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html[/url].\nWell, it originally run in 512x512, so IÂ should do this in a cubemap (assuming half precision is ok).",
            "flags": 32,
            "hasliked": 0,
            "id": "css3RH",
            "likes": 4,
            "name": "Multigrid Fluid Dynamics: Fire0",
            "published": 3,
            "tags": [
                "fire",
                "port",
                "fluiddynamics",
                "pressure",
                "buoyancy",
                "multigrid"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "// porting https://www.cs.uaf.edu/2017/spring/cs482/example/03_31_fire_expanding.html\n// ( a more basic one here: https://www.shadertoy.com/view/mss3zn )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n // O = U.x < R.x/2. ? texelFetch( iChannel0, ivec2(U), 0 )\n //                  : texelFetch( iChannel1, ivec2(U), 0 ); \n                     \n    O = U.x < R.x/2. ? texture( iChannel0, (U-vec2(R.x/2.-R.y,0)/2.) /R.y , 0.)\n                     : texture( iChannel1, (U-vec2(3.*R.x/2.-R.y,0)/2.) /R.y , 0.);\n                     \n // O = texture( iChannel1, (U-vec2(R-R.y)/2.) /R.y , 0.);\n \n // O = O.aaaa;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// ported from https://www.cs.uaf.edu/2017/spring/cs482/example/03_24_multigrid_fluid.html\n\n/* This GLSL shader calculates the new wave texture. */\n\n// $$$ port of uniforms and varyings\n#define time         iTime                      // lib.time, seconds\n#define dt          (1./60.)                    // lib.dt timestep, seconds\n#define texcoords   (fragCoord/iResolution.xy)  // our texture coords, [0-1]\n#define texF         iChannel0                  // fluid source texture\n#define texR         iChannel1                  // reaction source texture\n#define texsize      iResolution.xy             // texcoord change per pixel\n#define del         (1./texsize)                // texcoord change per pixel\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   // $$$ replaces main(){\n\n// float tex_size=512.0; // pixels across\n// float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias); // reaction values\n   vec4 CF=texture(texF,P,bias);\n   \n   vec4 A=vec4(0.0); // acceleration\n   // A.y+=-0.05; // weak gravity\n\n// Multigrid pressure physics\n   float P2V=0.1; /* pressure-to-velocity */\n   float V2P=1.0; /* velocity-to-pressure */\n   vec4 L,R,T,B;\n   float divergence=0.0; // sum across levels\n   for (float lvl=9.0;lvl>=0.0;lvl-=1.0) {\n     float scale=pow(2.0,lvl);\n     vec2 dist=scale*del; // texture coordinate jump\n     float dx=0.2; // grid size, meters/pixel\n     float dy=0.2; // grid size, meters/pixel\n     L=texture(texF,P+vec2(-dist.x,0.0),lvl);\n     R=texture(texF,P+vec2(+dist.x,0.0),lvl);\n     T=texture(texF,P+vec2(0.0,+dist.y),lvl);\n     B=texture(texF,P+vec2(0.0,-dist.y),lvl);\n\n  // Compute divergence at this level\n     divergence+=((R.x - L.x)/dx + (T.y - B.y)/dy);\n\n  // pseudo pressure drives velocity\n  //   (from Navier Stokes equation)\n     A.x += -P2V*(R.a - L.a)/dx;\n     A.y += -P2V*(T.a - B.a)/dy;\n   }\n   divergence+=-10000.0*CR.a; // burning -> want divergence\n\n   // velocity convergence *is* pseudo pressure\n   CF.a = 0.5-V2P*divergence;\n\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n   \n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=5.0;\n   A+=blurFrac*(blur-CF);\n   \n   CF+=A*dt; // adjust velocities\n\n   if (P.y<0.001) { \n      CF.xy=vec2(0.5); // stationary bottom chunk\n   }\n\n   // hot gas -> accelerate Y upwards\n   CF.y+=0.3*CR.r*dt;\n\n   // limit velocities (for stability)\n   CF.xy=clamp(CF.xy,0.0,1.0); \n\n  fragColor = CF; // $$$ // return CF;\n  \n  if (iFrame==0)  // $$$ // Initialize fluid values\n      fragColor = vec4(0.5,0.5,0.0,1.0); \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ported from https://www.cs.uaf.edu/2017/spring/cs482/example/03_24_multigrid_fluid.html\n\n/* This GLSL shader calculates the new reaction texture.\n     red: temperature\n     green: propane\n     blue: air\n*/\n\n// $$$ port of uniforms and varyings\n#define time         iTime                      // lib.time, seconds\n#define dt          (1./60.)                    // lib.dt timestep, seconds\n#define texcoords   (fragCoord/iResolution.xy)  // our texture coords, [0-1]\n#define texF         iChannel0                  // fluid source texture\n#define texR         iChannel1                  // reaction source texture\n#define texsize      iResolution.xy             // texcoord change per pixel\n#define del         (1./texsize)                // texcoord change per pixel\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){   // $$$ replaces main(){\n\n //float tex_size=512.0; // pixels across\n //float del=1.0/tex_size; // texture coordinates per pixel\n   float bias=-1000.0; // mipmap bias (disable mipmaps)\n   \n   // P stores our texture coordinates\n   vec2 P=texcoords;\n   vec4 CR=texture(texR,P,bias);\n   vec4 CF=texture(texF,P,bias);\n\n   // Read neighbors\n   vec2 dist=del; // $$$ was float\n   float lvl=bias;\n   vec4 L=texture(texR,P+vec2(-dist.x,0.0),lvl);\n   vec4 R=texture(texR,P+vec2(+dist.x,0.0),lvl);\n   vec4 T=texture(texR,P+vec2(0.0,+dist.y),lvl);\n   vec4 B=texture(texR,P+vec2(0.0,-dist.y),lvl);\n\n   vec4 A=vec4(0.0);\n   // Advection physics via explicit dot(V,grad(V)):\n   vec2 V=CF.xy-vec2(0.5);\n   vec3 gradX=vec3(R-L);\n   vec3 gradY=vec3(T-B);\n   vec3 VgV=vec3(V.x*gradX+V.y*gradY);\n   A.xyz-=10.0*VgV;\n\n\n   // drop blue out (cooling)\n   // combustion rate needs three things: heat, fuel, oxygen\n   float burn=0.0;\n   if (CR.r>0.3 && CR.g>0.0 && CR.b>0.0) {\n     burn=10.0*CR.r*CR.g*CR.b;\n     CR.r+=10.0*burn;\n     CR.g-=burn;\n     CR.b-=burn;\n   }\n\n   CR.r-=0.5*CR.r*dt; // fast cooling\n\n   // Clamp values, to keep them from getting too big\n   CR=clamp(CR,0.0,1.0);\n\n   // Blur, to simulate viscosity:\n   vec4 blur=0.25*(L+R+T+B); /* neighborhood average */\n   float blurFrac=3.0;\n   A+=blurFrac*(blur-CR);\n\n   CR+=A*dt;\n\n   CR.a=burn;\n   \n   fragColor = CR; // $$$ // return CR;\n   \n   if (iFrame==0) { // $$$  // Initialize reaction values\n       vec2 sphere=vec2(0.5,0.2);   // Boundary condition sphere\n       float r=length(sphere-texcoords);\n       if (r<0.2) fragColor = vec4((texcoords.y>0.395)?1.0:0.0,1.0,0.0,0);\n       else fragColor = vec4(0.0,0.0,1.0,0.0);\n   }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// #define texture(ch,U,l) texelFetch(ch, ivec2((U)*iResolution.xy+1e-4)>>(l<=0.?0:int(l)) , l<=0. ? 0 : int(l) )\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}