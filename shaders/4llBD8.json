{
    "Shader": {
        "info": {
            "date": "1511771220",
            "description": "Please uncomment #define HIGH_QUALITY  in buf C for full experiance.\n\nPress 2-key to toggle manual/auto camera mode. Description for more info...\n\nManual camera allows you to use mouse to control the camera.\nThis also enables zoom with D and E keys.",
            "flags": 112,
            "hasliked": 0,
            "id": "4llBD8",
            "likes": 76,
            "name": "[Planet] Outer Space",
            "published": 3,
            "tags": [
                "3d",
                "noise",
                "reflection",
                "terrain",
                "raymarch",
                "fire",
                "texture",
                "shadow",
                "light",
                "space",
                "raytrace",
                "stars",
                "alien",
                "stone",
                "comet"
            ],
            "usePreview": 1,
            "username": "ingagard",
            "viewed": 6427
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////////////////\n// Copyright Â© 2017 Kim Berkeby (email: mr.kimb@hotmail.com)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n////////////////////////////////////////////////////////////////////////////////////////////\n/*\n\n Toggle effects by pressing folloving keys:\n ------------------------------------------\n 1-key  = Change color tint mode  \n\n 2-key  = Switch manual/auto camera mode         (default auto)\n\n ------------------  NOTICE    ------------------------------------\n Using manual camera allows you to use mouse to control the camera.\n This also allows you to use D and E keys to zoom (alternative F1 and F2 keys)\n -------------------------------------------\n\n 3-key  = Chromatic aberration  on/off           (default on)    \n 4-key  = God Rays  on/off                       (default on)\n 5-key  = Lens flare  on/off                     (default on)\n\n --------------------------------------------------------\n --------------------------------------------------------\n\n  TO INCREASE PERFORMANCE OR QUALITY:\n  --------------------------------\n  \n  Turn on/off one or several defines in Buf C:\n \n  #define CLOUDS\n  #define QUALITY_CLOUDS\n\n  #define SHADOWS\n  #define ROTATING_MOON\n  #define ROTATING_PLANET\n  #define SPACE_CLOUDS\n  #define HIGH_QUALITY_BELT\n\n  Enable for full experience (can crash some machines):\n \n\n  #define HIGH_QUALITY    <-----\n\n\n --------------------------------------------------------\n \n This shader was made by using distance functions found in HG_SDF:\n http://mercury.sexy\n \n Special thanks to Inigo Quilez for his great tutorials on:\n https://iquilezles.org/\n\n Music by chamberlain:\n https://soundcloud.com/chamberlainyeah/path-to-shangri-la-1\n\n Last but not least, thanks to all the nice people here at ShaderToy! :-D\n\n*/\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// POST EFFECTS BUFFER\n//////////////////////////////////////////////////////////////////////////////////////\n\n  #define FastNoise(posX) (  textureLod(iChannel1, (posX+0.5)/iResolution.xy, 0.0).r)\n  #define readAlpha(memPos) (  textureLod(iChannel2, memPos, 0.0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel0, memPos, 0).rgb)\n  #define PI acos(-1.)\n  #pragma optimize(off) \n\nmat3 cameraMatrix;\n\nvec3 sunPos=vec3(0.);\n\nfloat CalcSum(vec2 uvPos) \n{\n    vec4 col = textureLod(iChannel2, uvPos,0.);\n    float sum = (col.r+col.g+col.b)*0.333;\n    return mix(0.,sum,step(0.65,sum-col.a));\n}\n\n#define VOLUMESAMPLES 32\nfloat GetVolumetrics(vec2 pos, vec2 uv)\n{\n    float sum \t = 0.;\n    float weight = 1. / float(VOLUMESAMPLES);\n    vec2 dir = pos-uv;\n    \n    for(int i = 0; i < VOLUMESAMPLES; i++)\n    {\n        sum += CalcSum(uv)*(1.-(float(i)*weight));\n        uv += dir * .01;\n    }\n    \n    return sum * weight;\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec2 GetScreenPos(vec3 pos)\n{\n  return vec2(PI*dot( pos, cameraMatrix[0].xyz ), PI* dot( pos, cameraMatrix[1].xyz ));\n}\n\nvec3 CalculateSunFlare(vec3 rayDir, vec3 rayOrigin, vec2 screenSpace, float alpha, float enableFlare, vec2 uv)\n{\n\n  float visibility = pow(max(0., dot(sunPos, rayDir)), 5.0);  \n  if (visibility<=0.006) return vec3(0.);\n\n  vec2 sunScreenPos = GetScreenPos(sunPos);\n\n  vec2 uvT = screenSpace-sunScreenPos;  \n  vec2 offSetCol = (uvT.xy-1.)/iResolution.xy*14.5;  \n     \n  float sunIntensity = (1.0/(pow(length(uvT)*4.0+1.0, 1.30)))*visibility;\n\n  vec3 flareColor = vec3(0.);\n  vec2 offSet = uvT;\n  vec2 offSetStep=  0.4*sunScreenPos;\n  float size=.0, dist=0.;\n  \n  if(enableFlare>0.)\n  {\n  // check if center of sun is covered by any object. MATH IS OFF AT SCREEN CHECK POS! sunScreenPos/2.0 +0.5 IS NOT EXACTLY SUN MIDDLE!\n  // only draw if not covered by any object\n  if (readAlpha( sunScreenPos/2.0 +0.5)<0.50)\n  {\n    // create flare rings\n    for (float i =1.; i<8.; i++)\n    {\n      offSet += offSetStep;\n\n      size = 0.006+((1.-sin(i*0.54))*0.2);\n      dist = pow(length(sunScreenPos+offSetCol-offSet), 1.20);\n      flareColor.r += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))/(1.0-size);\n      dist = pow(length(sunScreenPos-offSet), 1.20);\n      flareColor.g += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))/(1.0-size);\n      dist = pow(length(sunScreenPos-offSetCol-offSet), 1.20);\n      flareColor.b += mix(0., sunIntensity*(18.*size), smoothstep(size, size-dist, dist))/(1.0-size);   \n    }\n\n  }\n      flareColor = mix(flareColor,flareColor*.1, max(0.,visibility));\n      flareColor += vec3(1.0, .7, .0)  * pow(visibility, 2.);\n}\n  flareColor*=mix(2., .2, smoothstep(0., 1., visibility)); \n    \n  // flare star shape\n  vec3 sunSpot = vec3(1.30, 1., .80)*sunIntensity*(sin(FastNoise((sunScreenPos.x+sunScreenPos.y)*2.3+atan(uvT.x, uvT.y)*15.)*5.0)*.12);\n  \n  // sun glow\n  sunSpot+=vec3(1.0, 0.9,0.8)*sunIntensity*2.5;\n    \n     float d = length(uvT*vec2(4.,.2))*50.;\n\tsunSpot += vec3(1.0, 0.776, 0.620)/pow(d,2.);\n\td = length(uvT*vec2(.2,4.))*50.;\n\tsunSpot += vec3(1.0, 0.776, 0.620)/pow(d,2.);\n \n  return flareColor+(sunSpot*(1.0-alpha));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  // read values from buffer\n  vec3 effects = readRGB(ivec2(120, 0));  \n  vec3 effects2 = readRGB(ivec2(122, 0)); \n\n  sunPos = readRGB(ivec2(50, 0));\n    \n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  cameraMatrix  = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = cameraMatrix * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec4 color = vec4(0.);\n\n  // chromatic aberration?\n  if (effects.z>0.)\n  {\n    vec2 offSet = (uv.xy*3.-1.)/iResolution.xy*1.5;\n    color.rgb = vec3(texture(iChannel2, uv + offSet).r, texture(iChannel2, uv).g, texture(iChannel2, uv - offSet).b);   \n  }\n  // no chromatic aberration \n  else\n  {\n      color.rgb = texture(iChannel2, uv).rgb;\n  }\n\n  color.a=textureLod(iChannel2, uv, 0.).a;\n\n  // add sun with lens flare effect\n  color.rgb += CalculateSunFlare(rayDir, rayOrigin, screenSpace, clamp(color.a, 0., 1.0),effects2.x,uv);\n\n    \n  // perform volumetric light ray pass if looking into the sun\n  if (effects2.y>0.)\n  { \n    vec2 sunScreenPos = GetScreenPos(sunPos);\n    float sunVisibility = max(0.,dot(sunPos, rayDir));\n         \n    if(length(sunScreenPos)<2.3)\n    {\n      color.rgb += mix(0.,GetVolumetrics(sunScreenPos/2.0 +0.5, uv),pow(sunVisibility,6.));\n    }\n  } \n    \n  // gamma correction and edge fade\n  fragColor =  vec4(pow(color.rgb, vec3(1.0/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.32 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 12659,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/chamberlainyeah/path-to-shangri-la-1"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// DATA BUFFER  -  CAMERA CONTROL AND KEYBOARD CHECKS\n//////////////////////////////////////////////////////////////////////////////////////\n\n  // #pragma optimize(off) \n  #define keyClick(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 0), 0).x > 0.)\n  #define keyPress(ascii)   ( texelFetch(iChannel0, ivec2(ascii, 1), 0).x > 0.)\n  #define read(memPos) (  texelFetch(iChannel2, memPos, 0).a)\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n\n  // D     ZOOM OUT\n  #define ZOOMOUT_KEY 68\n  // E     ZOOM IN\n  #define ZOOMIN_KEY 69\n  // F1     ZOOM OUT (alternative)\n  #define ZOOMOUT_KEY_ALT 112\n  // F2     ZOOM IN (alternative)\n  #define ZOOMIN_KEY_ALT 113\n\n  //#define MANUAL_CAMERA\n  #define ROTATING_SUN\n\n\n  #define pR(p, a) p*=r2(a)\n\nmat2 r2(float r) \n{\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nvoid ToggleEffects(inout vec4 fragColor, vec2 fragCoord)\n{\n  // read and save effect values from buffer  \n  vec3 effects =  mix(vec3(-1.0, -1.0, -1.0), readRGB(ivec2(120, 0)), step(1.0, float(iFrame)));\n  effects.x*=1.0+(-2.*float(keyPress(49))); //1-key  color tint mode\n  effects.y*=1.0+(-2.*float(keyPress(50))); //2-key  manual / auto camera mode\n  effects.z*=1.0+(-2.*float(keyPress(51))); //3-key  chromatic aberration\n\n  vec3 effects2 =  mix(vec3(1.0, 1.0, 1.0), readRGB(ivec2(122, 0)), step(1.0, float(iFrame)));\n  effects2.y*=1.0+(-2.*float(keyPress(52))); //4-key  god Rays\n  effects2.x*=1.0+(-2.*float(keyPress(53))); //5-key  lens flare\n\n  fragColor.rgb = mix(effects, fragColor.rgb, step(1., length(fragCoord.xy-vec2(120.0, 0.0))));  \n  fragColor.rgb = mix(effects2, fragColor.rgb, step(1., length(fragCoord.xy-vec2(122.0, 0.0))));\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{ \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  // load data  \n  vec3 sunPos = normalize( vec3(-.50, 0.13, .700));\n  vec3 camData = mix(vec3(0., 0., 230.), readRGB(ivec2(52, 0)), step(1.0, float(iFrame)));  \n  vec2 camRot = mix(vec2(3.73, 0.), readRGB(ivec2(57, 0)).xy, step(1.0, float(iFrame))); \n  vec3 oldOrigin = readRGB(ivec2(62, 0));\n\n  ToggleEffects(fragColor, fragCoord);\n\n  // adding a small amount of camRot.y just to check if the camera has been moved in ANY way when later doing AA pass\n  float camrot = 15.+(iTime*0.1);\n  vec3 rayOrigin = vec3(230.*cos(camrot), 10.-40.*sin(-camrot*4.)+(0.0001*camRot.y), 230.0*sin(-camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n\n  // manual camera mode?  2-key\n  if (readRGB(ivec2(120, 0)).y>0.)\n  {\n    if (iMouse.z>0.)\n    {\n      camRot.x=(mo.x*12.); \n      camRot.y=-64.+((mo.y)*128.);\n    }\n    camRot.y = clamp(camRot.y, -128., 128.);\n\n    camData.z-=0.3*float(keyClick(ZOOMIN_KEY) || keyClick(ZOOMIN_KEY_ALT));\n    camData.z+=0.3*float(keyClick(ZOOMOUT_KEY) || keyClick(ZOOMOUT_KEY_ALT));\n    camData.z=clamp(camData.z, 180., 320.);\n\n    rayOrigin = vec3(camData.z*cos(camRot.x), camRot.y, camData.z*sin(camRot.x) );\n  }\n\n  // rotate the sun\n  #ifdef ROTATING_SUN\n    pR(sunPos.xz, -iTime*0.2);\n  #endif\n\n  // save date    \n  fragColor.rgb = mix(sunPos, fragColor.rgb, step(1., length(fragCoord.xy-vec2(50.0, 0.0))));\n  fragColor.rgb = mix(camData, fragColor.rgb, step(1., length(fragCoord.xy-vec2(52.0, 0.0))));\n  fragColor.rgb = mix(rayOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(62.0, 0.0))));\n  fragColor.rgb = mix(oldOrigin, fragColor.rgb, step(1., length(fragCoord.xy-vec2(60.0, 0.0))));\n\n  fragColor.rgb = mix(vec3(camRot.xy, 0.), fragColor.rgb, step(1., length(fragCoord.xy-vec2(57.0, 0.0))));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// BACKGROUND BUFFER -   RENDERS SPACE\n//////////////////////////////////////////////////////////////////////////////////////\n\n  #define PI 3.14159265359\n  #define PI_TWO 6.28318530718\n  #define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  //#pragma optimize(off) \n\n\n  #define COMETS\n\n  vec2 PosToSphere(vec3 pos)\n{\n  float x = atan(pos.z, pos.x); \n  float y = acos(pos.y / length(pos)); \n  return vec2(2.*x / PI_TWO, 2.*y / PI);\n}\n\nfloat hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nvec3 sunPos=vec3(0.);\n\n// by IQ\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return -1.0+2.0*mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\n// by IQ\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\nvec4 SphereMap(sampler2D sam, in vec3 p)\n{\n  vec2 spherePos = PosToSphere(p);\n  return textureLod(sam, spherePos, 2.*log2(spherePos.y*2.));\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 BoxMap( sampler2D sam, in vec3 p, in vec3 n, in float k, in float LOD)\n{\n  vec3 m = pow( abs(n), vec3(k) );\n  vec4 x = textureLod( sam, p.yz, LOD);\n  vec4 y = textureLod( sam, p.zx, LOD);\n  vec4 z = textureLod( sam, p.xy, LOD);\n  return (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n#define pR(p, a) (p)*=r2(a)\n  mat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\n\nvec3 GetSpaceColor(vec3 rayDir)\n{ \n  vec3 stars = BoxMap(iChannel0, rayDir, rayDir, 0.5, 0.0).rgb;\n  vec3 stars2 = SphereMap(iChannel0, rayDir).rgb; \n\n  vec3 starPos = rayDir+vec3(iTime*0.0004, iTime*0.0005, iTime*0.0003);\n  float starsDetailS = pow(noise(starPos*450.), 1.);\n  float starsDetailM = pow(noise(starPos*150.), 2.);\n  float starsDetailL = pow(0.45+noise(starPos*52.), 3.);\n\n  vec3 starColor = vec3(1.0);\n\n  starColor.r += abs(starsDetailS-starsDetailM);\n  starColor.g += abs(starsDetailL-starsDetailM);\n  starColor.b += abs(starsDetailS-starsDetailL);\n\n  starColor=(starColor*0.5)+(starsDetailL*.5);\n\n  float sun = mix(0., pow( clamp( 0.5 + 0.5*dot(sunPos, rayDir), 0.0, 1.0 ), 2.0 ), smoothstep(.33, .0, rayDir.y));\n  float sun2 = clamp( 0.75 + 0.25*dot(sunPos, rayDir), 0.0, 1.0 );\n\n  vec3 col = mix(vec3(0, 0, 164)/255., vec3(0, 0, 150)/255., smoothstep(0.8, 0.00, rayDir.y)*sun2);\n  col = mix(col, vec3(100, 0, 169)/255., smoothstep(0.015, .0, rayDir.y)*sun2);\n  col = mix(col, vec3(160, 0, 136)/255., smoothstep(0.3, 1.0, sun));\n  col = mix(col, vec3(255, 0, 103)/255., smoothstep(0.6, 1.0, sun));\n\n  col=col*stars;\n  col = mix(col, vec3(starsDetailS*starColor), smoothstep(0.7, 1., starsDetailS));\n  col = mix(col, vec3(starsDetailM*starColor), smoothstep(0.7, 1., starsDetailM));\n\n  vec3 nebula = (vec3(stars.r, 0., 0.)*stars2.r);\n  nebula = mix(nebula, nebula*2., pow(stars2.r, 2.));\n  nebula = mix(nebula, vec3(1.), pow(stars2.r, 4.));        \n\n  vec3 offset = vec3(iTime, iTime*2., 0.)*0.01;\n  vec2 addStep = vec2(-0.04, -0.07)*0.05;\n  vec2 pp = PosToSphere(rayDir);\n\n  #ifdef COMETS\n    vec3 comet = textureLod(iChannel3, (pp)-offset.xy, 1.).rgb;\n\n  for ( int i=0; i<30*int(step(0.2, comet.r)); i++ )\n  {\n    col = mix(col, vec3(1.), step(0.4, pow(textureLod(iChannel3, (pp*2.)-offset.xy, 1.).r, 6.))/((float(i)+1.)));\n    offset.xy+=addStep;\n  }   \n  #endif\n\n    nebula = mix(nebula, nebula*vec3(1.2, 0.9, .50), max(0., readRGB(ivec2(120, 0)).x));\n\n  return col+nebula;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n  float alpha=0.;\n\n  sunPos =  readRGB(ivec2(50, 0));\n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;   \n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0. ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 color =  GetSpaceColor(rayDir)*1.5;\n\n  vec2 beltPos = rayDir.xz;\n  pR(beltPos, iTime*0.01);\n  vec3 noisePos = vec3(iTime*2., iTime*4., iTime*0.5)*0.2;\n  vec3 test= textureLod(iChannel0, beltPos*0.4, log2(beltPos.y*2.)).rgb*vec3(1.3, 0.74, 1.);\n  color.rgb = mix(color.rgb+test*vec3(1.2, 0.9, .50), color.rgb, smoothstep(0., 0.3, (0.5+(.285*fastFBM(noisePos+(rayDir*122.))))*distance(((rayDir.y)*3.1), 0.)));\n\n  fragColor = vec4(mix(color.rgb, color.rgb*vec3(1., 0.97, 0.40), max(0., readRGB(ivec2(120, 0)).x)), 0.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// PLANET BUFFER -   RENDERS PLANETS, RING AND SPACE-CLOUDS\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n  #define PI 3.14159265359\n  #define PI_TWO 6.28318530718\n  //#pragma optimize(off) \n\n  // Delete on or several of below defines to increase performance\n  #define CLOUDS\n  #define QUALITY_CLOUDS\n  #define SHADOWS\n  #define ROTATING_MOON\n  #define ROTATING_PLANET\n  #define SPACE_CLOUDS\n  #define HIGH_QUALITY_BELT\n\n  //enable for full experience (can crash some machines)\n  //#define HIGH_QUALITY\n\n\n  float hash(float h)\n{\n  return fract(sin(h) * 43758.5453123);\n} \n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  vec4 dist;\n  float depth;\n};\n\nvec3 sunPos=vec3(0.);\n\nvec2 PosToSphere(vec3 pos)\n{\n  float x = atan(pos.z, pos.x); \n  float y = acos(pos.y / length(pos)); \n  return vec2( x / (2.0 * PI), y / PI);\n}\n\n// by afl_ext (achlubek)\n//*****************************************************************\nfloat oct(vec3 p) {\n  return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0)));\n}\nfloat oct(vec2 p) {\n  return fract(4768.1232345456 * sin((p.x+p.y*43.0)));\n}\n\nfloat noise2D(vec2 x) {\n  vec2 p = floor(x);\n  vec2 fr = fract(x);\n  vec2 LB = p;\n  vec2 LT = p + vec2(0.0, 1.0);\n  vec2 RB = p + vec2(1.0, 0.0);\n  vec2 RT = p + vec2(1.0, 1.0);\n\n  float LBo = oct(LB);\n  float RBo = oct(RB);\n  float LTo = oct(LT);\n  float RTo = oct(RT);\n\n  float noise1d1 = mix(LBo, RBo, fr.x);\n  float noise1d2 = mix(LTo, RTo, fr.x);\n\n  float noise2d = mix(noise1d1, noise1d2, fr.y);\n\n  return -1.0+2.0*noise2d;\n}\n\nfloat noise(vec3 x) { \n  vec3 p = floor(x);\n  vec3 fr = fract(x);\n  vec3 LBZ = p + vec3(0.0, 0.0, 0.0);\n  vec3 LTZ = p + vec3(0.0, 1.0, 0.0);\n  vec3 RBZ = p + vec3(1.0, 0.0, 0.0);\n  vec3 RTZ = p + vec3(1.0, 1.0, 0.0);\n\n  vec3 LBF = p + vec3(0.0, 0.0, 1.0);\n  vec3 LTF = p + vec3(0.0, 1.0, 1.0);\n  vec3 RBF = p + vec3(1.0, 0.0, 1.0);\n  vec3 RTF = p + vec3(1.0, 1.0, 1.0);\n\n  float l0candidate1 = oct(LBZ);\n  float l0candidate2 = oct(RBZ);\n  float l0candidate3 = oct(LTZ);\n  float l0candidate4 = oct(RTZ);\n\n  float l0candidate5 = oct(LBF);\n  float l0candidate6 = oct(RBF);\n  float l0candidate7 = oct(LTF);\n  float l0candidate8 = oct(RTF);\n\n  float l1candidate1 = mix(l0candidate1, l0candidate2, fr[0]);\n  float l1candidate2 = mix(l0candidate3, l0candidate4, fr[0]);\n  float l1candidate3 = mix(l0candidate5, l0candidate6, fr[0]);\n  float l1candidate4 = mix(l0candidate7, l0candidate8, fr[0]);\n\n\n  float l2candidate1 = mix(l1candidate1, l1candidate2, fr[1]);\n  float l2candidate2 = mix(l1candidate3, l1candidate4, fr[1]);\n\n\n  float l3candidate1 = mix(l2candidate1, l2candidate2, fr[2]);\n\n  return -1.0+2.0*l3candidate1;\n} \n//*****************************************************************\n// by IQ\n//*****************************************************************\n\nfloat fastFBM(vec3 p)\n{\n  vec3 ip=floor(p);\n  p-=ip; \n  vec3 s=vec3(7, 157, 113);\n  vec4 h=vec4(0., s.yz, s.y+s.z)+dot(ip, s);\n  p=p*p*(3.-2.*p); \n  h=mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy=mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n//*****************************************************************\n\n\n#define pR(p, a) (p)*=r2(a)\n  mat2 r2(float r) {\n  float c=cos(r), s=sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop)\n{\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p+halfsize, size) - halfsize;\n  if (c > stop) { //yes, this might not be the best thing numerically.\n    p += size*(c - stop);\n    c = stop;\n  }\n  if (c <start) {\n    p += size*(c - start);\n    c = start;\n  }\n  return c;\n}\n\n\n\nvec4 TraceSpaceClouds( vec3 origin, vec3 direction, int steps)\n{\n  vec4 col = vec4(.7, 0.7, 1., 0.);\n\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos = vec3(0.);\n  vec3 texPos = vec3(0.);\n  float density=0.;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n\n    if (sdSphere(rayPos, 70.)<0.01) break;\n\n    vec3 texPos = (rayPos+vec3(iTime*27.3, iTime*2.3, -iTime*13.3));\n\n    density = pow(fastFBM(texPos*0.002), 4.);\n    density *= pow(fastFBM(texPos*0.007 ), 6.);\n    density *= pow(fastFBM(texPos*0.05), 1.);\n\n    if (density>0.0)\n    {        \n      col.a+=(1.-col.a)*density;\n    }\n\n    if (col.a>0.999) break;\n\n    t+=9.;\n  }\n  return col;\n}\n\n\n\nfloat MapRing(vec3 p, float inRadius, float outRadius, float height)\n{\n  pR(p.xy, 0.15);\n  return max(sdCappedCylinder(p, vec2(outRadius, height)), -sdCappedCylinder(p, vec2(inRadius, 15.)));\n}\n\nvec4 GetRingHitPos( vec3 origin, vec3 direction)\n{\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos = vec3(0.);\n  for ( int i=0; i<48+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapRing( rayPos, 110., 155., 5.);\n    precis =0.01*t;\n    if (dist<precis || t>500.)\n    {       \n      break;\n    }\n    t+=dist;\n  }\n\n  return vec4(rayPos, dist);\n}\n\nvec4 TraceRing( vec3 origin, vec3 direction, int steps, float scale, float densLimit, float rotSpeed, float inRad, float outRad)\n{\n  vec4 ringColor = vec4(0.12, 0.12, 0.17, 0.);\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0, density=0., densAdd=0., sunDensity=0.;\n  vec3 rayPos = vec3(0.);\n  vec3 texPos = vec3(0.);\n    float planetDist=10000.;\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    rayPos.y+=cos((rayPos.x+rayPos.z)*0.23)*.25;\n\n    dist = MapRing( rayPos, inRad, outRad, 3.4);\n    precis =0.001*t;\n    planetDist = sdSphere(rayPos, 70.);\n    dist = min(dist,planetDist);\n      \n    if (dist!=planetDist)\n    {\n\n    texPos = rayPos;\n    pR(texPos.xz, -iTime*rotSpeed);\n    density = pow((fastFBM(texPos*scale)), 8.);\n\n    if (dist<precis && density>densLimit)\n    {       \n      densAdd = 0.35;\n      sunDensity = pow(fastFBM((texPos+sunPos*.7)*scale), 8.); \n      ringColor.rgb += max(0., density-sunDensity)*(1.-ringColor.a)*densAdd*0.8;\n      ringColor.a+=(1.-ringColor.a)*densAdd*0.5;\n    }\n    }\n    if (ringColor.a>0.999) break;\n\n    t+=max(.04, dist);\n  }\n  return ringColor;\n}\n\n#define calcNormal( pos ) normalize( vec3(MapPlanet(pos+vec3(0.02, 0.0, 0.0).xyy).x - MapPlanet(pos-vec3(0.02, 0.0, 0.0).xyy).x, 0.5*2.0*0.02, MapPlanet(pos+vec3(0.02, 0.0, 0.0).yyx).x - MapPlanet(pos-vec3(0.02, 0.0, 0.0).yyx).x ) )\n  #define calcNormalRocks( pos ) normalize( vec3(MapRocks(pos+vec3(0.02, 0.0, 0.0).xyy) - MapRocks(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, MapRocks(pos+vec3(0.02, 0.0, 0.0).yyx) - MapRocks(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n  #define calcNormalGlobe( pos ) normalize( vec3(sdSphere(pos+vec3(0.02, 0.0, 0.0).xyy, 70.) - sdSphere(pos-vec3(0.02, 0.0, 0.0).xyy, 70.), 0.5*2.0*0.02, sdSphere(pos+vec3(0.02, 0.0, 0.0).yyx, 70.) - sdSphere(pos-vec3(0.02, 0.0, 0.0).yyx, 70.) ) )\n\n  RayHit GetDistancePlanet( vec3 origin, vec3 direction, int steps, float maxDist, inout vec3 hitPos)\n{\n  RayHit result;\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    hitPos = rayPos;\n    dist = min(dist, sdSphere(rayPos, 70.));\n    t += dist;\n  }\n\n  result.hit=(dist<1.);\n  result.depth = t; \n  result.dist.x = dist;  \n  result.hitPos = origin+((direction*t)); \n\n  return result;\n}\n\nfloat GetTerrainHeight( vec3 p)\n{   \n  p*=0.0032;\n\n  float terrainHeight =fastFBM(p)*14.; \n  p*=3.0;      \n  pR(p.xz, 3.14);\n  terrainHeight -= fastFBM(p)*10.2;\n  p*=3.0;      \n  pR(p.xz, 3.14);   \n  terrainHeight -= fastFBM(p)*5.2;\n  p*=3.0;      \n  pR(p.xz, 3.14);\n  return terrainHeight - (fastFBM(p)*1.5);\n}\n\nvoid GetPlanetRotation(inout vec3 p)\n{\n  #ifdef ROTATING_PLANET\n    pR(p.xz, (0.08*-iTime));\n  #endif\n}\nvoid GetMoonRotation(inout vec3 p)\n{\n  #ifdef ROTATING_MOON\n    pR(p.xz, 2.65-(0.005*-iTime)); \n  #else\n    pR(p.xz, 2.65);\n  #endif\n}\n\nvec3 GetMoonPosition(vec3 p)\n{\n  vec3 pos = vec3(-430., 180., -430);\n  GetMoonRotation(pos);\n  return pos;\n}\n\n\nvec4 MapPlanet(vec3 p)\n{\n  vec3 moonPos = p-GetMoonPosition(p);\n  vec2 mapPos = PosToSphere(moonPos);\n  float heightMap = -fastFBM((moonPos*0.5)*.4);\n  float moon = sdSphere(moonPos, 40.+heightMap);\n  GetPlanetRotation(p);  \n  mapPos = PosToSphere(p);\n  heightMap = ((GetTerrainHeight(8.*p)*0.35))*textureLod(iChannel3, 2.*mapPos, log2(mapPos.y*2.)).z*1.5;\n  return vec4(min(moon, sdSphere(p, 70.-min(2., (1.-heightMap)))), heightMap, moon, 0.);\n}\n\nRayHit TracePlanet( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  vec4 dist = vec4(1000000.);\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    dist = MapPlanet( rayPos);\n    precis =0.00001*t;\n\n    if (dist.x<precis || t>maxDist)\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;  \n      result.hitPos = origin+((direction*t));    \n      break;\n    }\n\n    t += dist.x*0.55;\n  }\n\n  return result;\n}\n\n\nvoid GetRockRotation(inout vec3 p)\n{\n  pR(p.xy, 0.15); \n  pR(p.xz, -iTime*0.052);\n}\n\nfloat MapRocks(vec3 p)\n{\n  GetRockRotation(p);\n  vec3 checkPos = p;\n  checkPos.xz = pModPolar(checkPos.xz, 230.0);\n  checkPos-=vec3(124, 0., 0.);\n  pModInterval1(checkPos.x, 6., 0., 4.);\n  return sdSphere(checkPos, pow(0.5+noise(p*0.44), 2.)*1.5);\n}\n\nRayHit TraceRocks( vec3 origin, vec3 direction, int steps, float maxDist)\n{\n  RayHit result;\n  float dist = 1000000.;\n  float precis = 0.0, t = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<steps+min(0, iFrame); i++ )\n  {\n    rayPos =origin+direction*t; \n    rayPos.y+=cos((rayPos.x+rayPos.z)*0.23)*.5;\n    dist = MapRocks( rayPos);\n    float planetDist = sdSphere(rayPos, 70.) ;\n    dist=min(dist, planetDist);\n\n    if (dist!=planetDist) \n    {\n      precis =0.001*t;\n\n      if (dist<precis || t>maxDist)\n      {             \n        result.hit=!(t>maxDist);\n        result.depth = t; \n        result.dist.x = dist;  \n        result.hitPos = origin+((direction*t));    \n        break;\n      }\n    }\n\n    t += dist*0.6;\n  }\n\n  return result;\n}\n\n\nfloat GetCloudDensitySimple(vec3 p)\n{\n      vec2 cloudPos = vec2(iTime*.036, 0.006*iTime);\n      vec2 cPos = PosToSphere(p);\n\n      vec3 clouds1 = textureLod(iChannel1, (cPos+cloudPos), 4.0*log2(cPos.y*2.)).rrr+0.25;\n      cPos = PosToSphere(p-vec3(10., 10, 10));\n      vec3 clouds2 = textureLod(iChannel1, (cPos+(0.55*cloudPos)), 4.0*log2(cPos.y*2.)).rgb;\n\n     return pow(clouds1.r*clouds2.g, 2.);\n}\n\n#define calcNormalClouds( pos ) normalize( vec3(GetCloudDensitySimple(pos+vec3(0.02, 0.0, 0.0).xyy) - GetCloudDensitySimple(pos-vec3(0.02, 0.0, 0.0).xyy), 0.5*2.0*0.02, GetCloudDensitySimple(pos+vec3(0.02, 0.0, 0.0).yyx) - GetCloudDensitySimple(pos-vec3(0.02, 0.0, 0.0).yyx) ) )\n \n\nvec4 TraceClouds( vec3 origin, vec3 direction, vec3 skyColor, int steps)\n{ \n  vec4 cloudCol=vec4(.52, 0.31, 0.31, 0.);\n  float density = 0.0, t = .0;\n  vec3 rayPos = vec3(0.);\n  float densAdd=0.;\n  float sunDensity=0.;\n\n  for ( int i=0; i<steps; i++ )\n  {\n    rayPos = origin+direction*t;\n    density = GetCloudDensitySimple(rayPos);          \n\n    if (density>0.001)\n    {    \n      densAdd = density*0.35;\n      sunDensity = GetCloudDensitySimple(rayPos+(sunPos*3.));          \n      cloudCol.rgb += max(0., density-sunDensity)*densAdd;\n      cloudCol.a+=(1.-cloudCol.a)*densAdd*0.4;\n    }\n    if (cloudCol.a > 0.99) break; \n\n    t+=.25;\n  }\n\n  cloudCol.a = clamp(cloudCol.a, 0., 1.);\n  return cloudCol;\n}\n\n\nmat3 setCamera(  vec3 ro, vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\nfloat SoftShadowRing( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h=0.;\n  vec3 rayPos = vec3(origin+direction*t);    \n\n    for ( int i=0; i<10+min(0, iFrame); i++ )\n    {\n      h = MapPlanet(rayPos).x;\n      res = min( res, 8.5*h/t );\n      t += clamp( h, 0.01, 100.1);\n      if ( h<0.005 ) break;\n      rayPos = vec3(origin+direction*t);\n    }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat SoftShadow( in vec3 origin, in vec3 direction )\n{\n  float res =1., t = 0.0, h=0.;\n  vec3 rayPos = vec3(origin+direction*t);    \n  #ifdef HIGH_QUALITY\n    for ( int i=0; i<30+min(0, iFrame); i++ )\n  {\n    h = MapPlanet(rayPos).x;\n    #ifdef HIGH_QUALITY_BELT\n    h = min(h, MapRocks(rayPos));\n    #endif\n      \n    res = min( res, 3.5*h/t );\n    t += clamp( h, 0.01, 250.1);\n    if ( h<0.005 ) break;\n    rayPos = vec3(origin+direction*t);\n  }\n  #else\n    for ( int i=0; i<10+min(0, iFrame); i++ )\n    {\n      h = MapPlanet(rayPos).x;\n      res = min( res, 8.5*h/t );\n      t += clamp( h, 0.01, 100.1);\n      if ( h<0.005 ) break;\n      rayPos = vec3(origin+direction*t);\n    }\n  #endif\n\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvec3 GetLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin, float illuminance)\n{                \n  vec3 reflectDir = reflect( rayDir, normal );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);\n\n  vec3 lightTot = vec3(0.0);\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float dif2 =max(0., dot( normal, normalize(vec3(1.5, 0., -3.5)) ));\n\n  float fre = clamp(1.0+dot(normal, rayDir), 0.0, 1.0);\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 2.0);\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n\n  float shadow=1.;\n  #ifdef SHADOWS\n    shadow = SoftShadow(shadowPos, sunPos);\n  dif*=shadow;\n  #endif\n\n    const vec3 sunColor = vec3(1.1, 1.1, 1.1); \n  lightTot += 2.*dif*sunColor;\n  lightTot +=0.5*dif2*vec3(.6, .35, 1.5);\n  lightTot += 1.0*amb*vec3(0.2, 0.25, 0.4);  \n  lightTot += 0.40*skylight*vec3(0.4, 0.6, 1.0);\n  lightTot += 2.*specLevel*vec3(1., 0.85, 0.75)*dif;  \n  fre = pow( 1.0-abs(dot(rayHit.normal, rayDir)), 3.0);\n  lightTot = mix( lightTot, lightTot*2.5, fre );\n\n  return clamp(lightTot, 0.1, 10.);\n}\n\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  sunPos =  readRGB(ivec2(50, 0));\n\n  // setup camera and ray direction\n  vec2 camRot = readRGB(ivec2(57, 0)).xy;\n  vec3 rayOrigin =readRGB(ivec2(62, 0));\n  mat3 ca = setCamera( rayOrigin, vec3(0., 0., 0.), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n\n  // create sky color fade\n  vec4 color = texture(iChannel0, uv);\n  color.a=0.;\n\n  vec3 hitPos = vec3(0.);\n  RayHit plametDistResult = GetDistancePlanet(rayOrigin, rayDir, 32, 400., hitPos);\n\n\n  RayHit marchResult = TracePlanet(rayOrigin, rayDir, 200, 1000.);\n\n  // is terrain hit?\n  if (marchResult.hit)\n  { \n\n    vec3 col= vec3(0.); \n\n    // moon hit\n    if (length(marchResult.dist.x-marchResult.dist.z)<0.05)\n    {\n      vec3 pp = marchResult.hitPos;\n      GetMoonRotation(pp);\n\n      vec2 texPos = PosToSphere(pp);\n      vec4 tex = textureLod(iChannel1, texPos*2., log2(texPos.y*2.));\n      col = tex.rgb;\n      marchResult.normal = calcNormal(marchResult.hitPos); \n      vec3 light = GetLight(1., marchResult.normal, marchResult, rayDir, rayOrigin, 0.0)*0.35;   \n      col = (col*light)+vec3(0.1, 0., 0.1);\n    }\n    // planet hit\n    else\n    {\n      vec3 pp = marchResult.hitPos;     \n      GetPlanetRotation(pp);\n\n      float specLevel = 1.;\n      if (marchResult.dist.y>-0.5) // land\n      {\n        vec2 texPos = PosToSphere(pp);\n        vec3 tex = textureLod(iChannel1, 2.*texPos, log2(texPos.y*2.)).rgb;\n\n        col = vec3(1., 0.32, 0.2)*tex;\n\n        col=mix(tex.rgb*vec3(0.9, 0.8, 0.76)*0.3, vec3(.29, 0.1, 0.1)*2.25*(0.6+(tex)), smoothstep(-0.83, -.10, marchResult.dist.y));\n        col=mix(col, vec3(.5, 0.3, 0.3), smoothstep(-.10, .39, marchResult.dist.y));\n        col*=0.5;\n        marchResult.normal = calcNormal(marchResult.hitPos);\n      } else   // liqid\n      {  \n        specLevel=4.;\n        col=mix(vec3(0.2, 0., 0.)*0.23, vec3(0.2, 0., 0.)*1.15, smoothstep(-1.615, .15, marchResult.dist.y));\n\n        marchResult.normal = calcNormalGlobe(marchResult.hitPos)+(0.2*fastFBM((pp*6.+vec3(iTime*0.4))));\n      } \n\n      vec3 light = GetLight(specLevel, marchResult.normal, marchResult, rayDir, rayOrigin, 0.0);   \n      col = col*light;   \n\n      float sunDot = dot( marchResult.normal, sunPos);\n\n      #ifdef CLOUDS\n      plametDistResult.normal = calcNormalGlobe(plametDistResult.hitPos);\n      float sunAmount = 0.15+(0.85*max(0., dot( plametDistResult.normal, sunPos )));\n\n      #ifdef QUALITY_CLOUDS\n        vec4 cloudColor=TraceClouds(rayOrigin+((rayDir*plametDistResult.depth)*0.97), rayDir, vec3(.3), 30);   \n      col.rgb = mix(col.rgb, col+(cloudColor.rgb*sunAmount)*0.5, smoothstep(0.24, 0.37, cloudColor.a*cloudColor.a));\n      #endif\n\n     float cloudDensity = GetCloudDensitySimple(plametDistResult.hitPos);\n     vec3 cloudNormal = calcNormalClouds(plametDistResult.hitPos);\n\n        float cDif = max(0.,dot(cloudNormal, sunPos));\n           col.rgb += mix(0., (0.2+cDif)*max(0., dot( plametDistResult.normal, sunPos )), smoothstep(0.15, 0.45, cloudDensity));   \n      #endif\n\n        // add atmosphere\n        float fre = 0.5+max(0., (0.5*(1.0+dot(marchResult.normal, rayDir))));\n      col= mix(col, vec3(.6, 0.7, .9)*2.5, pow(fre, 6.0)*max(0.62, sunDot));\n    }\n\n    color.rgb = col; \n    color.a+=1.;\n  } \n\n  if (!marchResult.hit || length(marchResult.dist.x-marchResult.dist.z)<0.05)\n  { \n    vec3 nPos = rayDir;\n\n    color.rgb = mix(vec3(.3, .4, .6), color.rgb, smoothstep(-6., 7., plametDistResult.dist.x));\n\n    color.rgb = mix(mix(color.rgb+vec3(2.), color.rgb, smoothstep(-0., 0.50, plametDistResult.dist.x)), color.rgb, step(1., plametDistResult.dist.x));\n\n    pR(nPos.xy, iTime*0.016);\n    pR(nPos.zx, iTime*0.01);\n    float atNoise = max(0., noise((nPos*13.)*1.75));\n\n    color.rgb = mix(color.rgb+vec3(.2, 0.45, .642), color.rgb, pow(smoothstep(-2., 20., plametDistResult.dist.x+(22.*atNoise)), .50));\n  }\n\n\n  vec3 background = color.rgb;\n\n  // get distance to ring bounding shape. Only draw content of ring if raytrace hit the ring. VEC4(hitpos.xyz,distance)\n  vec4 ringHitPos = GetRingHitPos(rayOrigin, rayDir);\n\n  float shadow =1.;\n\n  #ifdef SHADOWS\n    shadow = max(0.5, SoftShadowRing(ringHitPos.xyz, sunPos));\n  #endif\n\n    #ifdef HIGH_QUALITY_BELT\n    // trace rock belt\n    RayHit rockMarch = TraceRocks(rayOrigin, rayDir, 100, 500.);   \n\n  // is rock belt hit?\n  if (rockMarch.hit)\n  { \n    vec3 pp = rockMarch.hitPos;\n    GetRockRotation(pp);\n\n    vec3 rockCol= vec3(0.5)+(0.4*abs(noise(pp*3.))); \n    rockMarch.normal = calcNormalRocks(rockMarch.hitPos); \n    vec3 rockLight = GetLight(1., rockMarch.normal, rockMarch, rayDir, rayOrigin, 0.0)*0.4; \n    rockCol = rockCol*rockLight;\n    //rockCol = mix(rockCol,mix(rockCol,rockCol+background,0.35),smoothstep(100.,500.,rockMarch.depth));  \n    color.rgb = rockCol;\n  }\n  #endif \n\n    //vec3 origin, vec3 direction, int steps, float scale, float densLimit, float rotSpeed, float inRad, float outRad)\n\n    vec4 ringColor = TraceRing(rayOrigin, rayDir, 40, 1.1, .15, 0.04, 120., 150.);    \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );   \n\n  ringColor = TraceRing(rayOrigin, rayDir, 40, 1.65, 0.12, 0.06, 120., 150.);      \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );\n\n  ringColor = TraceRing(rayOrigin, rayDir, 30, 1., 0.12, 0.07, 120., 145.);      \n  color.rgb =mix( color.rgb, clamp(ringColor.rgb*shadow, 0., 0.8), ringColor.a );\n\n\n  #ifdef SPACE_CLOUDS\n  vec4 cColor = TraceSpaceClouds(rayOrigin, rayDir, 90);      \n  color.rgb =mix( color.rgb, cColor.rgb, cColor.a );  \n  #endif\n\n  fragColor = color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 45,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buf C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n// AA BUFFER -    REMOVES NOISE\n//////////////////////////////////////////////////////////////////////////////////////\n\n\n#define readRGB(memPos) (  texelFetch(iChannel2, memPos, 0).rgb)\n//#pragma optimize(off) \n\n#define PERFORM_AA_PASS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n  vec4 color = textureLod(iChannel0, uv,0.);\n\n    \n #ifdef PERFORM_AA_PASS\n    // Perform AA pass\n    if( iFrame>0) \n    {\n            // if the camera is kept steady, switch to fine AA pass.\n            if(length(readRGB(ivec2(62, 0))-readRGB(ivec2(60, 0)))>0.)           \n       {\n            // better for moving cameras\n            vec3 oldColor = textureLod(iChannel1, uv,1.0).rgb;\n            color.rgb = mix(color.rgb,oldColor,0.2);\n       }      \n            else\n            {\n                  // good for static camera\n             vec3 oldColor = texelFetch(iChannel1, ivec2(fragCoord-0.5), 0 ).rgb;\n            color.rgb = mix( oldColor, color.rgb, 0.5 );\n            }\n    }   \n  #endif\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buf D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}