{
    "Shader": {
        "info": {
            "date": "1567022144",
            "description": "Another experiment gone too far.",
            "flags": 0,
            "hasliked": 0,
            "id": "ttjSWy",
            "likes": 8,
            "name": "Kapla",
            "published": 3,
            "tags": [
                "basket"
            ],
            "usePreview": 0,
            "username": "leon",
            "viewed": 443
        },
        "renderpass": [
            {
                "code": "// Kapla\n// Leon Denise (ponk) 2019.08.28\n\n// Using code from\n// Inigo Quilez\n// Morgan McGuire\n// Xor\n\n// toolbox\nconst float PI = 3.1415;\n#define repeat(p,r) (mod(p,r)-r/2.)\nfloat random(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat smoothmin (float a, float b, float r) { float h = clamp(.5+.5*(b-a)/r, 0., 1.); return mix(b, a, h)-r*h*(1.-h); }\nfloat sdBox (vec3 p, vec3 b) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nvec3 look (vec3 eye, vec3 target, vec2 anchor, float fov) {\n    vec3 forward = normalize(target-eye);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(forward * fov + right * anchor.x + up * anchor.y);\n}\nvec3 triplanar(sampler2D tex, vec3 p, vec3 n) {\n    p.y *= .2;\n \treturn  (texture(tex,p.yx).rgb*n.z*n.z\n            +texture(tex,p.yz).rgb*n.x*n.x\n            +texture(tex,p.zx).rgb*n.y*n.y);\n}\n\nfloat geometry (vec3 pos, float time, inout vec3 ppos) {\n    float t = time * .5 + pos.x / 30.;\n    t = floor(t)+smoothstep(0.0,.9,pow(fract(t),2.));\n    \n    pos.x = repeat(pos.x+time, 5.);\n    pos.zy = abs(pos.zy)-3.;\n    \n    float scene = 1.;\n    float balance = 1.5;\n    float range = .8+.2*sin(time*.1);\n    float radius = .08+.02*sin(time*0.4);\n    float blend = .1;\n    \n    float a = 1.0;\n    const int count = 10;\n    for (int i = count; i > 0; --i) {\n        pos.x = abs(pos.x)-range*a;\n        pos.xy *= rot(cos(t)*balance/a+a*2.);\n        pos.zy *= rot(sin(t)*balance/a+a*2.);\n        float shape = sdBox(pos,vec3(radius*(3.+1.*sin(time*.2)),\n                                     radius*20.,\n                                     radius*.2)*a);\n        ppos = mix(pos, ppos, step(scene,shape));\n        scene = min(scene, shape);\n        a /= 1.05;\n    }\n    return scene;\n}\n\nvec3 getNormal (vec3 pos, float time) {\n \tvec2 e = vec2(.001,0);\n    vec3 p = vec3(0);\n \treturn normalize(vec3(geometry(pos,time,p)\n                          -vec3(geometry(pos-e.xyy,time,p),\n                                geometry(pos-e.yxy,time,p),\n                                geometry(pos-e.yyx,time,p))));\n}\n\nvec4 raymarch ( vec3 eye, vec3 ray, float time, inout vec3 ppos ) {\n    float dither = random(ray.xy+fract(iTime));\n    float total = 0.0;\n    const int count = 25;\n    for (int index = count; index > 0; --index) {\n        float dist = geometry(eye+ray*total,time,ppos);\n        dist *= 0.9+0.1*dither;\n        total += dist;\n        if (dist < 0.001 * total) {\n            return vec4(eye+ray*total, float(index)/float(count));\n        }\n    }\n    return vec4(eye+ray*total, 0.);\n}\n\nvec3 lighting (vec2 uv, vec3 ray, vec4 result, vec3 ppos) {\n    float shade = result.w;\n    vec3 pos = result.xyz;\n    vec3 normal = getNormal(pos, iTime);\n    vec3 colorLight = vec3(.9,.8,.7);\n    vec3 light = normalize(vec3(-1,-8,-1));\n    float diffuse = clamp(dot(normal, light),0.,1.);\n    float point = clamp(dot(normal, -ray),0.,1.);\n    vec3 map = triplanar(iChannel0, ppos*.5, normal).rgb;\n    vec3 color = map*shade;\n    float spec = smoothstep(0.4,.8,map.r);\n    color += diffuse*shade*map*spec;\n    color += pow(point,4.)*shade*colorLight*spec;\n    return color;\n}\n\nvec3 camera (vec3 eye) {\n    vec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    if (iMouse.z > 0.5) {\n        eye.yz *= rot(mouse.y*PI);\n        eye.xz *= rot(mouse.x*PI);\n    } else {\n        eye.yz *= rot(.1*PI);\n        eye.xz *= rot(.45*PI);\n    }\n    return eye;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 eye = camera(vec3(0,0,3));\n    vec3 ray = look(eye, vec3(0), uv, .8);\n    vec3 ppos = eye;\n    float dither = random(ray.xy+fract(iTime));\n    vec4 result = raymarch(eye, ray, iTime+dither/20.,ppos);\n    vec3 color = lighting(uv, ray, result, ppos);\n    \n    fragColor = vec4(color,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}