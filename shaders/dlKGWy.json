{
    "Shader": {
        "info": {
            "date": "1684608085",
            "description": "lampin in a lava land",
            "flags": 32,
            "hasliked": 0,
            "id": "dlKGWy",
            "likes": 5,
            "name": "bubblin",
            "published": 3,
            "tags": [
                "lavalamp",
                "simplex"
            ],
            "usePreview": 1,
            "username": "ufffd",
            "viewed": 193
        },
        "renderpass": [
            {
                "code": "// see breakdown animation here: https://www.shadertoy.com/view/DtK3Dc\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0,uv).rgb;\n    // Output to screen\n    col = pow(col, vec3(.7));\t// gamma correction (tweaked)\n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.141592653589793\n#define MAX_STEP 200\n#define MAX_DIST 10000.\n#define SURF_DIST 0.001\n#define JIGGLE .1\n\n#define DELTA\t\t\t\t0.00005\n#define RAY_COUNT\t\t\t4\n#define RAY_LENGTH_MAX\t\t40.0\n#define RAY_STEP_MAX\t\t60\n#define REFRACT_FACTOR\t\t.6\n#define REFRACT_INDEX\t\t1.15\n#define AMBIENT\t\t\t\t.95\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.7\n#define FADE_POWER\t\t\t1.\n#define FOG                 10.\n\n#define TT                  (iTime*0.4+3.)\n\n\n// simplex noise from https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// with wisdom from:\n// Nrx glass polyhedron - https://www.shadertoy.com/view/4slSzj\n// artofcode raymarch - https://www.shadertoy.com/view/WtGXDD\n// artofcode bending light - https://www.shadertoy.com/view/sllGDN\n\nfloat nsin(float a){return sin(a)*0.5+0.5;}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nbool nearly(in float a, in float b) {\n    return abs(a - b) < 0.001;\n}\n\nmat2 Rot(in float a) {\n    return mat2(cos(a),-sin(a),\n                sin(a),cos(a));\n}\n\nfloat columnDist( vec3 p, vec3 c, vec3 r ) { \n    p.xy *= Rot(r.x);\n    // p.yz *= Rot(r.y);\n    // p.zx *= Rot(r.z);\n    return length(p.xz-c.xy)-c.z; \n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nvec2 texNormalMap(in vec2 uv, in sampler2D tx, in vec2 txr)\n{\n    vec2 s = 1.0/txr.xy;\n    \n    float p = texture(tx, uv).x;\n    float h1 = texture(tx, uv + s * vec2(1,0)).x;\n    float v1 = texture(tx, uv + s * vec2(0,1)).x;\n       \n   \treturn (p - vec2(h1, v1));\n}\n\nfloat sphereDist(vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec2 map(vec3 p) {\n    float mater = -1.;\n    float d = 1000.;   \n    \n    // noise field\n    vec3 axis = vec3(0.,1.,0.);\n    vec3 nfp = p;\n    nfp.xy *= Rot(sin(TT+p.z));\n    float nf = simplex3d(nfp + vec3(0.,TT,0.));\n    nf += 0.6 - abs(nfp.y)*0.2;\n    \n    if (nf < 0.001) mater = 2.;\n    d = min(d, nf);\n    \n    return vec2(d, mater);\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 mapr = map(p);\n    vec2 e = vec2(.001, 0);\n    \n\tfloat d = mapr.x;\n    vec3 n = vec3(0.);\n    \n    int method = 1;\n    // method 1\n    if (method==1) { \n        n = d - vec3(\n            map(p-e.xyy).x,\n            map(p-e.yxy).x,\n            map(p-e.yyx).x);\n    }\n    // method 2\n    if (method==2) {\n        n = vec3(\n            map(p+e.xyy).x - map(p-e.xyy).x,\n            map(p+e.yxy).x - map(p-e.yxy).x,\n            map(p+e.yyx).x - map(p-e.yyx).x);\n    }\n    \n    return normalize(n);\n}\n\nvec3 getLightPos(in int i) {\n    if (i==1){\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n        return lightPos;\n    }\n}\n\nfloat getLight(vec3 p, vec3 n, in vec3 rd) {\n    vec3 lp = getLightPos(1);\n    vec3 l = normalize(lp-p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = map(p+n*SURF_DIST*2.).x;\n    if(d<length(lp-p)) dif *= .1;\n    \n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-l, n), -rd ), 0.), 50.);\n    \n    return dif + spec;\n}\n\nvec3 getCol(vec3 p, float mater, in vec3 rd, in vec3 norm) {\n    vec3 col = vec3(0.);\n    if (mater < 0.) {\n        return vec3(0.0);\n    } else if (mater < 0.5) {\n        col = norm;\n        col *= norm;\n    } else if (mater < 1.5) {\n        col = vec3(sin(norm.r*100.));\n        col *= norm;\n    } else if (mater < 2.5) {\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        vec3 text = texture(iChannel0, txuv).rrr;\n        col = mix(col,text*0.5,1.-col.r);\n        col *= length(p.xy/3.)-0.25;\n        col.r += sin(p.z+108.);\n        col.g += sin(p.z*1.01+112.);\n        col.b += sin(p.z*1.005+105.);\n        col *= sin(p.z*0.9)*0.5+0.5;\n        col /= 2.;\n    } else if (mater < 3.5) {\n        col = norm;\n        col = vec3(sin(norm.b*100.));\n    } else if (mater < 4.5) {\n        col = p * mat3(vec2(0.5), 0.1, vec2(0.2), 0.9, vec2(0.4), 1.);\n        // col = vec3(sin(norm.g*100.));\n    } else {\n        col = vec3(0.9,0.85,0.8) * 0.1;\n    }\n    return col;\n}\nvec3 k = vec3(0.);\n\nbool doesBounce(in float mater) {\n    if (mater > 1.5 && mater < 2.5) return true; // 2\n    if (mater > 4.5 && mater < 5.5) return true; // 5\n    return false;\n}\n\nvec3 materNorm(in float mater, in vec3 norm) {\n    vec3 mN;\n    if (mater > 1.5 && mater < 2.5) {\n        // todo - improve texturing https://www.youtube.com/watch?v=VaYyPTw0V84\n        vec2 txuv = norm.rg;\n        txuv.x += iTime * 0.02;\n        mN = texNormalMap(txuv, iChannel0, iChannelResolution[0].xy).xyx;\n    }\n    return mN;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    ro = vec3(0.); \n    // ro.xz *= Rot(iTime*0.3);\n    ro.z += TT;\n    ro -= JIGGLE*sin(vec3(iTime*1.,iTime*0.22,iTime*0.91));    \n    rd = normalize(vec3(uvc.x, uvc.y, .8));\n    // rd.xz *= Rot(iTime*0.3);\n    rd.yz *= Rot(sin(iTime)*0.05);\n    rd.xy *= Rot(sin(iTime*1.1)*0.05);\n    rd.zx *= Rot(sin(iTime*0.9)*0.05);\n    vec3 ord = rd;\n       \n    \n    float d = 0.;\n    bool hit = false;\n    bool hit_matte = false;\n    float glow = 0.;\n    float mater = -1.;\n\tvec2 delta = vec2 (DELTA, 0.0);\n    \n    float intensity = 0.;\n\n    // vec3 backColor = vec3(0.,0.01,0.02) * (1.-length(uv + vec2(0.,0.3)));\n    vec3 backColor = vec3(54./255., 57./255., 63./255.);\n    col = vec3(0.);\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n        d = 0.; // reset ray dist\n        float ds = 0.; // distance step\n        for(int i=0;i<MAX_STEP;i++){\n            p = ro + rd * d; // update current point\n            vec2 mapr = map(p);\n            ds = mapr.x; // map distance\n            ds *= distanceFactor; // flip sdf when inside\n            mater = mapr.y; // material index\n            ds *= 0.3;\n            d += max(ds, DELTA); // update march distance\n            if(ds<0.) { hit=true; break; } // check hit\n            if(d>MAX_DIST) break; // check limit\n            glow += 1./ds; // add glow\n        }\n        if (!hit) {col = backColor; break;}\n        vec3 norm = distanceFactor*getNorm(p);\n        // material color\n        col += getCol(p,mater,rd,norm) * AMBIENT;\n        // matte lighting\n        float light = getLight(p, norm, rd);\n        if (rayIndex==0) {\n            col += mix(vec3(light*light), vec3(0.), smoothstep(0.,0.5,ds)); // light outside\n            col = mix(col, backColor, smoothstep(0.,0.5,ds)); // background\n        }\n        // check for bounces\n        bool do_bounce = doesBounce(mater);\n        if (!do_bounce) {\n            // hit matte, done bouncing\n            break;\n        } else {\n            // col *= 0.1;\n            // apply normal to material 2 - note: make this a conditional if more reflective/refractive materials are added\n            norm += materNorm(mater, norm);\n            \n            vec3 reflection = reflect(rd, norm);            \n            // reflection light (i think it should be in getLight fxn so I can call it with multiple lights)\n            if (distanceFactor > 0.) { // only calculate light on outside\n                vec3 lp = getLightPos(1);\n                vec3 lightDirection = normalize(lp-p);\n                float reflectDiff = max (0.0, dot (norm, lightDirection));\n                float reflectSpec = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n                float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n\n                vec3 localColor = max(sin (k * k), 0.2);\n                localColor = (AMBIENT + reflectDiff) * localColor + reflectSpec;\n                localColor = mix(backColor, localColor, fade);\n\n                col = col * (1.0 - intensity) + localColor * intensity;\n                intensity *= REFRACT_FACTOR;\n            }\n\n            // Next ray...\n            ro = p;\n            vec3 refraction = refract(rd, norm, refractionRatio);\n            if (dot (refraction, refraction) < DELTA) { // reflect at grazing angles, idk how the dot math works here\n                // fragColor = vec4(1.,1.,0.,1.); return;\n                rd = reflection; // update ray dir to reflected angle\n                ro += rd * DELTA * 2.0; // step away from surface\n            } else {\n                rd = refraction; // update ray dir to refracted angle\n                ro += rd * DELTA * 2.0; // step away from surface - not needed?\n                refractionRatio = 1.0 / refractionRatio; // reverse refraction ratio \n                distanceFactor = -distanceFactor; // flip sdf sign while inside\n            }\n        }\n        \n        // todo: chromatic aberation, optical density, bevel, fresnel reflection\n        // https://www.youtube.com/watch?v=0RWaR7zApEo\n    }\n    \n    col *= 1.+smoothstep(0.3,1.,sin(TT*10.+p.z*2.));\n    \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}