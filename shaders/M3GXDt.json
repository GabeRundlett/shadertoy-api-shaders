{
    "Shader": {
        "info": {
            "date": "1720624273",
            "description": "I made this a year ago and just remembered it existed :)",
            "flags": 0,
            "hasliked": 0,
            "id": "M3GXDt",
            "likes": 37,
            "name": "Eyes of Zahard",
            "published": 3,
            "tags": [
                "eye"
            ],
            "usePreview": 1,
            "username": "SnoopethDuckDuck",
            "viewed": 268
        },
        "renderpass": [
            {
                "code": "#define sc 6.5\n#define R iResolution.xy\n#define pi 3.14159\n\n// from iq\nfloat arc(vec2 u, float a, float ap, float ra, float rb) {\n    u *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    vec2 dr = vec2(sin(ap), cos(ap));\n    u.x = abs(u.x);\n    return ((dr.y*u.x>dr.x*u.y) ? length(u-dr*ra) : \n                                  abs(length(u)-ra)) - rb;\n}\n\n// from iq\nfloat ves( in vec2 p, in vec2 a, in vec2 b, float w ) {\n    float r = 0.5*length(b-a);\n    float d = 0.5*(r*r-w*w)/w;\n    vec2 v = (b-a)/r;\n    vec2 c = (b+a)*0.5;\n    vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));\n    vec3 h = (r*q.x < d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n    return length(q-h.xy) - h.z;\n}\n\nvoid draw(inout vec3 o, vec2 u, float xscale, float ysep, float id) {  \n    vec2 O = vec2(2.*pi/xscale, ysep);\n    vec2 f = mod(u, O) - O / 2.; // Fract position\n    vec2 i = floor(u/O);         // Integer position\n    \n    // Base colors\n    vec3 lred0  = vec3(252,  20,  23) / 255.;\n    vec3 red0   = vec3(212,  14,  15) / 255.;\n    vec3 mred0  = .5*(lred0+red0);\n    vec3 dred0  = vec3(108,   6,   4) / 255.;\n    vec3 dred00 = vec3( 77,   4,   3) / 255.;\n    vec3 black0 = vec3(0);\n    vec3 white0 = vec3(255, 255, 255) / 255.;\n    vec3 pink0  = vec3(255, 145, 144) / 255.;\n\n    // Assign red to 3 eyes (left and right eyes blend at tips)\n    float mxcol = .85;\n    if      (id == 0. && i == vec2(-1))\n        mxcol *= smoothstep(-O.x/8., -O.x/2., f.x);\n    else if (id == 0. && i == vec2(0, -1))\n        mxcol *= smoothstep( O.x/8.,  O.x/2., f.x);\n    else if (id == 1. && i == vec2(-1))\n        mxcol = 0.;\n        \n    // Mix color to red\n    #define C(a) mix(a, .54*a.rrr, mxcol)\n    \n    // Mix colors for gradient\n    float mx = .4 * smoothstep(0., 1., .7 + f.y - f.x);\n    vec3 lred  = C(mix( lred0, pink0, mx)),\n         red   = C(mix(  red0, lred0, mx)),\n         mred  = C(mix( mred0,  red0, mx)),\n         dred  = C(mix( dred0, mred0, mx)),\n         dred1 = C(mix(dred00, dred0, mx)),\n         black = C(mix(black0, dred0, mx)),\n         white = C(white0),\n         pink  = C(mix( pink0, white0, mx));\n         \n    // Radius and (arc length?)\n    float r = .8;\n    float w = r/15.;\n    \n    // Slight distortion\n    f += .01 * (texture(iChannel0, .011 * f).r - .5);\n    \n    // Distances\n    float dsin1 = abs(abs(f.y) -  .5 - .5*cos(xscale*f.x)) - .06; \n    float dsin2 = abs(abs(f.y) - .39 - .5*cos(xscale*f.x)) - .05;\n    float dsin3 = abs(dsin1-.015) - w/2.;\n    float dsin4 =     abs(f.y) -  .5 - .5*cos(xscale*f.x); \n    float dsin5 =     abs(f.y) - .47 - .5*cos(xscale*f.x); \n    \n    float dc1 = length(f - vec2(-.95,   .4)) - 1.32;\n    float dc2 = length(f - vec2( -.8,   .4)) - .9;\n    float dc3 = length(f - vec2(   1, -.35)) - .9;\n    float dc4 = length(f - vec2( -.8,   .4)) - .6;\n    float dc5 = length(f - vec2( 1.1, -.45)) - .5;  \n    \n    float d1 = length(f);\n    float d2 = abs(d1-r);\n    float d3 = abs(d2-w+w/4.);\n\n    // Texture used for distortion (I think)\n    float tx = .8 + .2*texture(iChannel0,.008*u).r;\n    \n    // Angle used for arcs (I think)\n    float A = w/2.3 - w/2.*cos(atan(f.y, f.x) - .2);\n\n    // Draw stuff (I'm not commenting this!)\n    #define M o = mix(o, \n    #define E + (.05+.05*mxcol) * lred * cos(f.y-f.x)\n    #define ss(d) smoothstep(sc/R.y, -sc/R.y, d)\n    \n    M dred1 E, ss(ves(f, vec2(2,0),   vec2(-2,0),     .8)) );\n    M dred  E, ss(ves(f, vec2(1.5,0), vec2(-1.5, 0),  1.)) );\n    M red   E, ss(ves(f, vec2(1.2,0), vec2(-1.2, 0), .88)) );\n    \n    float W = r/8.*tx; \n    M lred  E, ss(arc(f, -.78 , .95, r-1.5*W, W))     );\n    W = w*tx; \n    M dred  E, ss(abs(r-w-W-d1) - W)                  );\n    M dred  E, ss(length(f+vec2(-.02,.055)) - r/3.-A) );\n    M red   E, ss(d1 - r/3.)                          );\n    M black E, ss(d3 - w/4.)                          );\n    M black E, ss(abs(r/3.+w/4. - d1) - w/4.)         );\n    \n    M lred  E, ss(arc(f, -.75,  1., r, w/2.))                 );\n    M lred  E, ss(arc(f,  1.9,  .4, r, w/2.))                 );\n    M lred  E, ss(arc(f,  2.6,  .1, r, w/2.))                 );\n    M pink  E, ss(arc(f, -.55,  .6, r+.2*w/2., w/2.-.2*w/2.)) );\n    M white E, ss(arc(f, -.45,  .3, r+.3*w/2., w/2.-.3*w/2.)) );   \n    M mred  E, ss(arc(f,  -.7,  pi, r/3.-A, A))               );  \n    M lred  E, ss(arc(f,  -.7, 1.2, r/3.-A, A))               );  \n    M pink  E, ss(arc(f, -.55,  .5, r/3.-.8*A, .8*A))         );  \n    M white E, ss(arc(f,  -.5, .25, r/3.-.5*A, .5*A))         ); \n    \n    M dred1, ss(dsin2)                         );\n    M black, ss(dsin3)                         );\n    M red,   ss(dsin1)                         );\n    M lred,  ss(dc1)   * ss(dsin1)             );\n    M lred,  ss(dsin1) * ss(dsin4)             );\n    M pink,  ss(dc2)   * ss(dsin4) * ss(dsin1) );\n    M pink,  ss(dc3)   * ss(dsin4) * ss(dsin1) );\n    M white, ss(dc4)   * ss(dsin5) * ss(dsin1) );\n    M white, ss(dc5)   * ss(dsin5) * ss(dsin1) );\n}\n\nvoid mainImage( out vec4 o, vec2 u )\n{      \n    float t = iTime;\n    float th = tanh(t);\n    \n    u = sc*(u-.5*R)/R.y;\n    u.y -= .75;\n    \n    // Barrel distortion\n    u /= 1.1 - .1* th - .0016*dot(u,u);\n    \n    // Distort u for shakiness \n    // --- \n    vec2 dir = .01 * vec2(cos(.4*t), sin(.4*t));\n    u += dir * texture(iChannel0, .2 * dir * u).r;\n    \n    u *= .995 + .01 * texture(iChannel0, .001 * u).r;    \n    \n    u += (1. - .9*tanh(.4*t))\n       * (1. - exp(-.025 * length(u + vec2(.2, .9)))) \n       * texture(iChannel0, .004 * u + t).g;\n    // ---  \n      \n    float xscale = 1.3; // Stretch x axis\n    float ysep = 2.175; // Offset sin-shapes vertically\n    \n    // Draw 2 layers\n    o = vec4(1);\n    draw(o.rgb, u-vec2(pi/xscale,1), xscale, ysep, 1.);\n    draw(o.rgb, u,                   xscale, ysep, 0.);\n    \n    // Vignette and darken\n    o *= th * smoothstep(1.45, .5, length(u) / sc);\n    o = pow(o, vec4(1.14));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}