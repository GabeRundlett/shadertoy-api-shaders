{
    "Shader": {
        "info": {
            "date": "1474632686",
            "description": "THIS IS MY FIRST ANIMATED SHADER!\nThis took me a0.9 hours to make the base,\na1. hours to figure out the animatic effect.\nso that makes it a1.9 hours to do this.\nUse the mouse to move scene.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtyGDD",
            "likes": 1,
            "name": "\"The Mountain\"",
            "published": 3,
            "tags": [
                "raytracing",
                "raymarching",
                "light",
                "sky",
                "shadows",
                "animated",
                "ground",
                "etc",
                "shaping",
                "realistic",
                "algebraic"
            ],
            "usePreview": 0,
            "username": "Imsure1200q_1UWE130",
            "viewed": 783
        },
        "renderpass": [
            {
                "code": "const float PI = asin(1.)*2.; //infinite PI\nfloat Hash( vec2 p )\n{\n\tfloat h = dot(p,vec2(127.1,311.7));\n\t\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\nfloat Hash( vec3 p )\n{\n    float h = dot(p,vec3(127.1,311.7,562.1));\n    return -1.0 + 2.0*fract(sin(h)*43578.5453123);\n}\nfloat MNoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( Hash( i + vec2(0.0,0.0) ), \n                     Hash( i + vec2(1.0,0.0) ), u.x),\n                mix( Hash( i + vec2(0.0,1.0) ), \n                     Hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nvec3 randNor(vec3 pos, vec3 w)\n{\n    vec3 nor = vec3(\n        (Hash(pos.xyy-w)+Hash(pos.xyy-w))*\n        (Hash(pos.yxy-w)+Hash(pos.yxy-w))*\n        (Hash(pos.yyx-w)+Hash(pos.yyx-w))\n        );\n    vec3 pay = normalize(nor);\n    return pay+texture(iChannel0, nor.xy).r;\n}\nfloat shape(float method, vec2 limit, float steps)\n{\n    float lx = clamp(steps, limit.x, limit.y);\n    float mt = method-lx;\n    for(float i = 0.; i < 1.9; i++)\n    {\n        mt += lx * length(limit);\n    }\n    return min(-distance(lx, mt), MNoise(limit));\n}\nfloat map(vec3 p)\n{\n    return length(shape(length(p),p.xy,length(p)-1.0))-1.5;\n}\n//not exactly normal xD :((((((((((((\n\nvec3 s(float q, float x, float k, vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 24; i++)\n    {\n        float h = sin(float(i)) * q;\n        x += h * 0.5;\n        vec3 p = ro+t*rd;\n        float d = map(p);\n        if(normalize(t)!=normalize(d)&&t<d)\n        t += d * 0.5 / 3.1;\n        else\n            t += d * 0.5;\n    }\n    return max(vec3(1.0/(1.0+t*t*0.1)),vec3(0.1));\n}\nmat2 rotF(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//Comment me in FB, Gmail, GOogle+, Or Twitter About\n//My performance k? Start.... NOW!\n{\n    float X = iMouse.x / iResolution.x;\n    float Y = iMouse.y / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.xz *= rotF(X-0.5);\n    rd.yz *= rotF(Y);\n    vec3 ro = vec3(0.0, -Y, -3.0);\n    float q = rd.y-uv.x*rd.z+100.0-length(rd+ro);\n    float x = atan(PI*9.);\n    float k = length(uv);\n    vec3 t = s(q, x, k, ro, rd);\n    vec3 suffer = randNor(rd, ro);\n    if(t.r > 0.29)\n\tfragColor = mix(vec4(t, 1.0), vec4(cos(uv.y)-0.4) + vec4(0.25, 0.6, 0.025, 1.0),\n                    length(uv));\n    else\n        fragColor = vec4(cos(uv.y)*2.)\n        + vec4(0.6,1.205,2.205, 1.0)+(MNoise(uv*rd.xy-1.2)-0.5);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}