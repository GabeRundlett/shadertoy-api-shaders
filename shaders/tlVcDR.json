{
    "Shader": {
        "info": {
            "date": "1622088088",
            "description": "Look around with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "tlVcDR",
            "likes": 12,
            "name": "Underwater (Pool)",
            "published": 3,
            "tags": [
                "voronoi",
                "refraction",
                "water",
                "caustic",
                "pool"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 271
        },
        "renderpass": [
            {
                "code": "struct Surface {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n    float dist;\n    bool iswater;\n};\n\nSurface opUnion(in Surface surf1, in Surface surf2) {\n    Surface surfUnion = surf1;\n    if (surf2.dist < surf1.dist) {\n        surfUnion = surf2;\n    }\n\n    return surfUnion;\n}\n\nSurface opInter(in Surface surf1, in Surface surf2) {\n    Surface surfInter = surf1;\n    if (surf2.dist > surf1.dist) {\n        surfInter = surf2;\n    }\n\n    return surfInter;\n}\n\nSurface opSub(in Surface surf1, in Surface surf2) {\n    return opInter(surf1, Surface(surf2.ambient, surf2.diffuse, surf2.specular, surf2.gloss, -surf2.dist, surf2.iswater));\n}\n\nmat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    float rndx = Hash11(p.x + 1000.0) * 2.0, rndy = Hash11(p.y + 1000.0) * 2.0;\n    return 0.5 + 0.5 * vec2(sin(p.x * rndx + p.y * rndy + iTime * rndx), cos(p.y * rndx - p.x * rndy + 2.0 * iTime * rndy * rndx));\n}\n\nfloat voronoi(in vec2 uv) {\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), 0.1);\n        }\n    }\n\n    return minDist;\n}\n\nfloat fakeCaustic(in vec2 uv) {\n    float color = voronoi(uv);\n    color *= color * color;\n    return color;\n}\n\nSurface mapScene(in vec3 p) {\n    p.z -= iTime;\n\n    Surface sphere = Surface(vec3(0.0), vec3(1.0, vec2(0.0)), vec3(1.0), 8.0, 1000000.0, false);\n\n    float waterDisp = fnoise(vec3(p.xz, 0.25 * iTime), 1.0, 3.0);\n    Surface water = Surface(vec3(0.0), vec3(0.0), vec3(1.0), 128.0, waterDisp - p.y, true);\n\n    vec3 groundCol = vec3(1.0);\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.x, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.z, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol += fakeCaustic(p.xz * 0.75);\n    Surface ground = Surface(groundCol, vec3(0.0), vec3(0.0), 0.0, p.y + 4.0, false);\n\n    return opUnion(sphere, opUnion(water, ground));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvec3 applyFog(in vec3 color, in float dist) {\n    return mix(color, vec3(0.25, 0.25, 1.0), 1.0 - exp(-dist * 0.15)) / max(1.0, 0.125 * dist);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    if (rd.y > 0.1) {\n        vec2 uv = ro.xz + (5.0 - ro.y) / rd.y * rd.xz;\n        float clouds = fnoise(vec3(uv, 0.0) + iTime, 0.3, 5.0);\n        return mix(vec3(0.5, 0.5, 1.0), vec3(1.0), clouds * clouds * 1.5);\n    }\n\n    return vec3(0.25, 0.25, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    mouse.y *= -1.0;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -2.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Mouse control\n    float cx = cos(mouse.y), sx = sin(mouse.y);\n    rd.yz *= mat2(cx, sx, -sx, cx);\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    bool hitSky = true, hitWater = false, missed = false;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t; p.z *= 1.0;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001 * (t * 5.0 + 1.0)) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            vec3 r = reflect(l, n);\n\n            if (!scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                float lambert = max(0.0, dot(n, l));\n                fragColor.rgb += scene.diffuse * lambert;\n                if (lambert > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(r, rd)), scene.gloss));\n                }\n\n                fragColor.rgb = applyFog(fragColor.rgb, t);\n\n                hitSky = false;\n                break;\n            }\n\n            if (scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                if (dot(-n, l) > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(-r, rd)), scene.gloss));\n                }\n\n                rd = refract(rd, n, 1.003 / 1.333);\n                hitWater = true;\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            fragColor.rgb = vec3(0.0);\n            missed = true;\n            break;\n        }\n\n        t += scene.dist;\n    }\n\n    if (hitSky && !missed) {\n        fragColor.rgb += getSky(ro, rd);\n        if (hitWater) {\n            fragColor.rgb = applyFog(fragColor.rgb, t);\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}