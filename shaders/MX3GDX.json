{
    "Shader": {
        "info": {
            "date": "1717342512",
            "description": "Voxel Grid visualization of 4D space. Each grid cell is a layer of the 4th dimension (w).",
            "flags": 0,
            "hasliked": 0,
            "id": "MX3GDX",
            "likes": 19,
            "name": "voxels 4D",
            "published": 3,
            "tags": [
                "voxels",
                "4d",
                "tesseract",
                "hypercube"
            ],
            "usePreview": 0,
            "username": "nimitz",
            "viewed": 280
        },
        "renderpass": [
            {
                "code": "//voxels 4D by nimitz 2024 (stormoid.xyz) (twitter: @stormoid)\n\n/*\n    The idea to \"understanding\" the visualization is to see this 4d grid space as a\n    set of 15 3D spaces stacked on top of each other. \n    \n    If a cell has voxels at the same 3d position as the previous/next grid cell\n    you are actually seeing a continuous line.\n    \n    Palette explained:\n        \"Object space\" palette, where:\n            -X is red   (magenta is X+Z)\n            -Y is green (yellow is Y+Z)\n            -Z is blue  (cyan is Y+Z)\n            -Overall Brightness is modulated by W\n    \n    \n    The 5-cell is probably the easiest to \"grok\" (shown as cell-first here)\n        -The first grid position has the first cell (of the 5-cell) showing as a tetrahedron.\n        -Each of the 4 vertices of the first cell are prolonged in 4d space to the single vertex at W+ (\"worldspace\").\n        -The other 4 cells are formed by the 4 triangles of that first cell extending to the W+ world vertex.\n        -The empty \"space\" in the second grid position between four edges is the 4d interior of the 5-cell\n            Allowing you to move in any of the 4 axis and still be withing the solid.\n        -The empty \"space\" in the second grid position between any 3 edges is a 3d cell boundary, moving\n            away on the normal of that 3d cell will bring you outside the 4d solid.\n            \n    \n    Map 2 is the edges of a Tesseract (4-cube)\n    \n    Map 3 is just a 4d axial \"cross\", but the rotation can make it tricky to visualize\n  \n*/\n\n\n//1 = 5-cell, 2= Tesseract, 3= 4d axial cross\n#define MAP 2\n#define NUM_LAYERS 20.\n\n#define time (iTime*.75)\n\n#define pi 3.14159265359\n#define tau 6.283185307\n\nmat2 rot2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat xcl = 0.;\nfloat ycl = 0.;\nfloat zcl = 0.;\nfloat wcl = 0.;\n\n\nvec2 uni( vec2 d1, vec2 d2 ){ return (d1.x<d2.x) ? d1 : d2; }\n\n#if MAP == 1\n////5-cell edges from knighty\nvec4 fold(in vec4 pos) \n{\n\tconst vec4 nc= 0.5*vec4(0,-1,1.73205,0.);\n    const vec4 nd = vec4(-0.5,-0.5,-0.288675,0.6455);\n    for(int i=0;i<2;i++)\n    {\n\t\tpos.xy=abs(pos.xy);\n\t\tfloat t=-2.*min(0.,dot(pos,nc));\n        pos+=t*nc;\n\t\tt=-2.*min(0.,dot(pos,nd));\n        pos+=t*nd;\n\t}\n\treturn pos;\n}\nfloat map4d(in vec4 p)\n{\n    p.w += 5.;\n    \n    p.yz *= rot2(.66);\n    //p.xy *= rot2(1.3);\n    \n    p.xz *= rot2(1.6 + time);\n    p.zw *= rot2(2.);\n\n    xcl = p.x, ycl = p.y, zcl = p.z, wcl = p.w;\n\n   \t//const vec4 pln = 0.866*vec4(0.6455,0.,0.,0.5);\n    const vec4 pln = 0.866*vec4(0.6455,0.,0.,0.5);\n    p = fold(p)-pln*15.;\n    float g = length(p.yzw)-1.3;\n    \n    \n    return g;\n}\n#elif MAP==2\n//Tesseract edges\nfloat map4d(vec4 p)\n{   \n    p.yw *= rot2(time*0.7);\n    p.zw *= rot2(time*0.64);\n    p.xw *= rot2(time*0.575);\n    \n    \n\t\n    float d = max(abs(p.x),max(abs(p.y),max(abs(p.z),abs(p.w))))-7.;\n\tconst float n = 4.5;\n\td = max(d, -(max(abs(p.x), abs(p.y))-n));\n\td = max(d, -(max(abs(p.x), abs(p.z))-n));\n\td = max(d, -(max(abs(p.z), abs(p.y))-n));\t\n\td = max(d, -(max(abs(p.z), abs(p.w))-n));\n\td = max(d, -(max(abs(p.x), abs(p.w))-n));\n\td = max(d, -(max(abs(p.y), abs(p.w))-n));\n    \n    xcl = p.x, ycl = p.y, zcl = p.z, wcl = p.w;\n\treturn d;\n}\n#else\n//4d Axial \"cross\"\nfloat map4d( vec4 p )\n{\n    float ft = fract(time/tau)*tau;\n    \n    \n    p.zw *= rot2(time*0.9);\n    p.xw *= rot2(time);\n    p.yw *= rot2(time);\n\t\t\n    float l = 10.;\n    float w = 1.15;\n\tfloat d1 = length(max(abs(p)-vec4(l, w, w, w ), 0.));\n    float d2 = length(max(abs(p)-vec4(w, l, w, w ), 0.));\n    float d3 = length(max(abs(p)-vec4(w, w, l, w ), 0.));\n    float d4 = length(max(abs(p)-vec4(w, w, w, l ), 0.));\n    \n    float d = min(d1, d2);\n    \n    xcl = p.x;\n    ycl = p.y;\n    zcl = p.z;\n    wcl = p.w;\n    \n    return d;\n}\n#endif\n\nvec4 lgt;\n\nvec4 largest(vec4 v)\n{\n    vec4 z = abs(v);\n    return step(max(max(max(z.x, z.y),z.z),z.w), z)*step(vec4(0),v);\n}\n\n//modified from iq's \"Hexagons - distance\" (https://www.shadertoy.com/view/Xd2GR3)\n//return values: x = trigger, y = voxel shading, z = distance to voxel edge, w = lighting\nvec4 voxelize( vec2 p, float bias3d, float bias4d ) \n{\n    xcl = 0.;\n    ycl = 0.;\n    zcl = 0.;\n    wcl = 0.;\n\t//displace based on layer\n\tp.x += 0.866025*bias3d;\n\tp.y += 0.5*bias3d;\n\t\n\t//setup coord system\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\tvec2 ip = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ip.x + ip.y, 3.);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tvec2 bz = 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy);\n\tfloat e = dot( ma, bz );\t\n\t\n\t//voxel shading\n\tfloat top = cb*ma.y+clamp((1.-(ca+ma.y)),0.,1.);\n\tfloat left = 0.5+step(ca,cb)*0.75;\n\t\n\tvec2 j = ip + ca - cb*ma;\n\tfloat sdf = map4d( vec4(j, bias3d, bias4d) );\n\t\n    float nl = max(dot(normalize(lgt),normalize(vec4(j,bias3d,bias4d))),0.);\n\treturn vec4( step(sdf,.0),left+top, e, nl*2. );\n}\n\nvec3 pal()\n{   \n    vec3 col = smoothstep(-17., 17., vec3(xcl * (wcl*0.5+0.5), ycl, zcl))*0.8;\n    col *= smoothstep(-12.,12.,wcl);\n    return pow(col,vec3(0.8));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    lgt =  vec4(5.,5.,5., 0.);\n    vec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    vec2 bp = p;\n    \n    p.x += 0.165;\n    p.y -= 0.16;\n    \n    vec2 ip = floor(p*3.);\n    //ip.x += 2.;\n    ip.y = -ip.y;;\n    float id = -5. + ip.x + ip.y*5.;\n    \n    p = fract(p*3.)/3.;\n    \n    \n\tp -= 0.165;\n    p *= 92.;\n\tvec3 col = vec3(0.);\n    \n    \n    for (float i=-NUM_LAYERS/2.;i<NUM_LAYERS/2.;i++) \n    {\n        vec4 rz = voxelize(p, i, id);\n        vec3 colx = pal()*rz.x*2.;\n        colx *= .4+rz.z*.9;\n        colx *= rz.y*.5;\n        colx *= rz.w*0.5+1.;\n        col = col*step(colx,vec3(0.)) + colx;\n    }\n    \n    col *= step(abs(bp.x)-.83, 0.);\n    \n\t\n\tfragColor = vec4( col*1.2, 1.0 );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}