{
    "Shader": {
        "info": {
            "date": "1700495393",
            "description": "-tmm changed flower coloring\nShader for testing random pattern distribution via hexagonal cells.\nIn a game scenario the patterns would be sampled from a texture atlas instead. (textures need to fit inside circle bounds to avoid cut off during rotation)",
            "flags": 0,
            "hasliked": 0,
            "id": "DtKcz3",
            "likes": 9,
            "name": "Hexagon dist w/detailed flowers",
            "published": 3,
            "tags": [
                "tiling",
                "hex"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "// Fork of \"Hexagon distribution\" by Hikagi. https://shadertoy.com/view/DlVcR3\n// 2023-11-20 15:49:31\n\nconst float PI = 3.14159265359;\n\n//Hash and Noise Functions\n\n\n\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n// https://www.shadertoy.com/view/4djSRW\n// Trying to find a Hash function that is the same on ALL systens\n// and doesn't rely on trigonometry functions that change accuracy \n// depending on GPU. \n// New one on the left, sine function on the right.\n// It appears to be the same speed, but I suppose that depends.\n\n// * Note. It still goes wrong eventually!\n// * Try full-screen paused to see details.\n\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n// customizable color from @WhiteTophat  in https://www.shadertoy.com/view/dlBczW\nvec4 lerp(vec4 a, vec4 b, float t) {\n    return (a * vec4(t)) + (b * vec4(1.0-t));\n}\nvec4 lerp(vec4 a, vec4 b, vec4 t) {\n    return (a * t) + (b * (vec4(1.0) * t));\n}\n\nvec4 hue2rgb(float hue) {\n    hue = fract(hue); //only use fractional part of hue, making it loop\n    float r = abs(hue * 6.0 - 3.0) - 1.0; //red\n    float g = 2.0 - abs(hue * 6.0 - 2.0); //green\n    float b = 2.0 - abs(hue * 6.0 - 4.0); //blue\n    vec4 rgb = vec4(r,g,b, 1.0); //combine components\n    rgb = clamp(rgb, 0.0, 1.0); //clamp between 0 and 1\n    return rgb;\n}\nvec4 hsv2rgb(vec3 hsv) {\n    vec4 rgb = hue2rgb(hsv.x); //apply hue\n    rgb = lerp(vec4(1.0), rgb, 1.0 - hsv.y); //apply saturation\n    rgb = rgb * hsv.z; //apply value\n    return rgb;\n}\n\n\nvec2 mouseUV;\nbool mouseDown;\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 hexCoord(vec2 uv) {       \n    vec2 sc = vec2(1, 1.7320508);\n    vec2 a = uv - round(uv / sc) * sc;\n    vec2 b = uv - (round((uv - vec2(0.5, 1.0)) / sc) + 0.5) * sc;\n    \n    vec2 offset = dot(a, a) < dot(b, b) ? a : b;    \n    vec2 center = uv - offset;\n\n    // Center coordinates\n    return vec4(offset * 2.0, center);\n}\n\nfloat flower(vec2 p) {\n    float angle = atan(p.y, p.x) / (PI * 2.0);\n    float a = abs(fract(angle * 5.0) - 0.5);\n    float b = 1.0 - length(p);   \n\n    return b * (a + 0.4);\n}\n\nvec4 flowerColor(vec2 p) {\n    float angle = atan(p.y, p.x) / (PI * 2.0);\n    float a = abs(fract(angle * 5.0) - 0.5);\n    float b = 1.0 - length(p);   \n\n    return hsv2rgb( vec3(hash12(p)*b * a, b * (a + 0.4),0.9) );\n}\n\nfloat leaf(vec2 p) {\n    float a = 1.0 - abs(p.y) * 1.5;\n    float b = 1.0 - length(p) * 2.0;\n    \n    return mix(a, b, 0.5);\n}\n\nvec2 rotate (vec2 p, float angle){\t\t\t\n\tfloat sinRot = sin(angle * 2.0 * PI);\n\tfloat cosRot = cos(angle * 2.0 * PI);\n\tmat2x2 rotMat = mat2x2(cosRot, -sinRot, sinRot, cosRot);\n\t\n\treturn p * rotMat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    mouseUV = iMouse.xy / iResolution.xy;\n    mouseDown = (iMouse.x!=0. && iMouse.z >= 0.);\n    vec3 mouseColor;\n    if(iMouse.xy==vec2(0.0)) {\n      mouseColor = vec3(1.0);//vec3(1.0, 0.75, 1.0);\n    } else {\n      mouseColor = hsv2rgb(vec3(mouseUV.x, mouseUV.y, 1.0)).rgb;\n    }\n    \n    vec2 uv = (fragCoord / iResolution.y) * 8.0;\n    uv.xy += iTime * 0.5;\n    \n    vec4 hex = hexCoord(uv.xy);\n\n    vec2 coord = hex.xy;    \n    float index = rand(hex.zw * 13.0);\n\n    // Primary and secondary rotation\n    float angleA = index * PI * 2.0;\n    float angleB = (iTime * 0.5 * index + index * 37.31) * 0.1 * PI * sign(index - 0.5);\n\n    vec2 dir = vec2(sin(angleA), cos(angleA));\n    \n    // Offset remap (determines scale)\n    float dist = fract(index * 3.33) * 0.4 + 0.25;\n\n    // Rotation Offset Scale\n    coord = rotate(coord, angleB);\n    coord = coord + dir * dist;\n    coord /= (1.0 - dist);\n\n    // Shape blending\n    float weight = floor(index + 0.75);\n\n    float shape = max(mix(mouseDown ? flowerColor(coord).r : flower(coord), leaf(coord), weight), 0.0);   \n    shape = floor(1.2 - shape);\n\n    vec3 flowerC = flowerColor(coord).rgb * mouseColor.rgb;\n    vec3 leafC = mix(vec3(0.75, 1.0, 0.25), vec3(0.25, 0.5, 0.5), index);\n\n    vec3 water = vec3(0.0, 0.3, 0.4);\n\n    vec3 color = mix(flowerC, leafC, weight);   \n    color = mix(color, water, shape);\n\n \n    \n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}