{
    "Shader": {
        "info": {
            "date": "1651902262",
            "description": "distance-dependant dolly zoom :  zoom changes during the ray-tracing (to enlarge background).\nMouse.y controls the effect.\nkey 1,2: force camera 1 or 2\n\nPress SPACE to stop the anti-banding treatment.",
            "flags": 16,
            "hasliked": 0,
            "id": "flSBzm",
            "likes": 8,
            "name": "inner dolly zoom / curve rays",
            "published": 3,
            "tags": [
                "raymarching",
                "camera",
                "interpolation",
                "spacefungus"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "// variant of https://shadertoy.com/view/wlBBWG\n\n#define rot(a)         mat2( cos( a + vec4(0,33,11,0)) )\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n        \n// Space fungus https://www.shadertoy.com/view/lsSBWh\n#define map(q) (                                                     \\\n    t = max( d = length(q) - 9.,                    /* Sphere */     \\\n             abs(a=cos(b=3.*dot(sin(q),p/p)))/9. ), /* EggCarton */  \\\n    t = max( t, 8.5-length(q) ),                    /* inner hole */ \\\n    q.xy = mod(q.xy,10.) -5., t = min(t, e = max( length(q)-1.,-d)), /* spheres grid */ \\\n    t )\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    \n    float a,b,d,e,l,i,  t = iTime,                    // materials id\n        _t, c = 1., s = .015,                         // color (pseudo-shading), delta per iteration\n          m = iMouse.z > 0. ?  iMouse.y/R.y : .5+.5*sin(iTime ) ; // inner dolly zoom control\n    vec3  D1 = normalize( vec3(U,-2.) ),              // ray direction 1\n          D2 = normalize( vec3(U,-15.) ),             // ray direction 2 (different zoom )\n          p = vec3(0,4,40.), p0, q,D;                 // ray origin, then current point on ray\n#define rot3(D)  D.yz *= rot(1.5); //D.xy*=rot(.1*t); // rotate camera\n    rot3(D1);\n    rot3(D2);                \n    rot3(p);\n    p0 = p;\n    if keyPress(49) D2=D1;                            // key \"1\": force camera 1\n    if keyPress(50) D1=D2;                            // key \"2\": force camera 2\n    for ( l = 0.; c > 0. && t > .01 ; c -= s )        // march scene\n        q = p, _t=t,\n        l += t = map(q),                              // distance to objects\n        i = mix(1.,40./l,m),                          // camera choice interpolation\n     // i = mix(1.,exp(-l/40.),m),                   \n        // l=40 → camera D1.  l=infinity → camera D2 if m=1 (fool effect).\n        i = smoothstep(0.,1.,.5+.5*i)*2.-1.,\n        D = mix(D2,D1,i),                             // camera changes with depth\n        p = p0+l*D;                                   // sphere-tracing step\n\n    if ( c > 0. && t>1e-5 && !keyPress(32) ) // --- anti-banding: see  https://www.shadertoy.com/view/wt2fzc\n        c += s * ( 1. - 2.3*t/.01 ),  // pseudo-shading: interpolate between iterations [why this ? + not perfect ]\n        t = min( _t/t*(_t-t), .01 ),  // Taylor series estimation of true distance [ min: because an artifact I don't understand. would be better without ]\n        q = p += t*D, t = map(q);     // go there and reeval, to correct hit point material \n    \n    O = vec4(c);                                      // --- coloring & shading\n    if (c > 0.) t==e \n                ? q = p+t*D+.01*vec3(1,-1,1), d = clamp((map(q)-0.)/.01,0.,1.),// pseudo-diffuse https://iquilezles.org/articles/derivative\n                  O = vec4(c*(.3+.7*d),0,0,0)         // spheres grid\n                :( O.r -= b/30., O.g -= a, O*=O ),    // space fungus\n                O.a = 1.;                             // hit -> opaque\n       else     O -= O;                               // background\n       \n    O = pow( O, vec4(1./2.2) );                       // to sRGB\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}