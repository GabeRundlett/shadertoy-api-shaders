{
    "Shader": {
        "info": {
            "date": "1703107818",
            "description": ";alkjdfal;dkjf",
            "flags": 0,
            "hasliked": 0,
            "id": "ddVBDh",
            "likes": 5,
            "name": "dead channel 2",
            "published": 3,
            "tags": [
                "fasldkfjalskdj"
            ],
            "usePreview": 0,
            "username": "lennyjpg",
            "viewed": 183
        },
        "renderpass": [
            {
                "code": "  #define hashi(x)   triple32(x) \n\n  #define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 uv = U/iResolution.xy;\n    vec2 uu = U;\n   float p = (uv.y-0.2)*0.9;\n//uv.y-=sin(uv.x*3.3)*0.3;\n       uu.x+=iTime*iResolution.y*0.02/p;\n       uu.x *= uu.y*0.00035;\n    uvec2 V = uvec2(uu);\n    float h = hash( V.x + hashi(V.y) ); \n    h = floor(h+0.7*uv.y*uv.y);    \n    O = vec4( h );\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}