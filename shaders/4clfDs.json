{
    "Shader": {
        "info": {
            "date": "1724505717",
            "description": "CC0: First attempt at 2D simplex truchet",
            "flags": 0,
            "hasliked": 0,
            "id": "4clfDs",
            "likes": 23,
            "name": "First attempt at 2D simplex truc",
            "published": 3,
            "tags": [
                "2d",
                "simplex",
                "truchet"
            ],
            "usePreview": 0,
            "username": "mrange",
            "viewed": 174
        },
        "renderpass": [
            {
                "code": "// CC0: First attempt at 2D simplex truchet\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: Unknown, author: Shane, found: https://www.shadertoy.com/view/WtfGDX\nvec2 simplexTile(inout vec2 pp) {\n  // Adopted from Shane's code (check it out, it's sweet).\n  \n  // Shane's code is always good but I think my adoption of it seems kind of off\n  // The problem is that I don't really understand how the tiling works.\n  // Seems this could be done better than what I got working here but when\n  // searching for a simplex tiling function I didn't find one\n  // So I tinkered with Shane's code until I got it to work\n  // but the rotation or how I computed the cell id seems off.\n  \n  const float \n      c0 = 1./(1.+sqrt(3.))\n    , c1 = 1./sqrt(3.)\n    , c2 = (3.-sqrt(3.))/6.\n    ;\n  const mat2 \n      r0 = ROT(PI/12.)\n    ;\n    \n  pp *= r0;\n  \n  vec2 s = floor(pp + (pp.x + pp.y)*c0); // Skew the current point.\n  \n  vec2 cp = pp - (s - (s.x + s.y)*c2); // Use it to attain the vector to the base vertex (from p).\n\n  float i = cp.x < cp.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\n  vec2 ioffs = vec2(1. - i, i);\n\n  // Vectors to the other two triangle vertices.\n  vec2 ip0 = vec2(0), ip1 = ioffs - c2, ip2 = vec2(c1); \n    \n    \n  // Centralize everything, so that vec2(0) is in the center of the triangle.\n  vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\n  //\n  // ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; \n  cp -= ctr;\n\n  pp = r0*cp;\n  pp *= 1.-i*2.;\n  \n  vec2 np = round(s)+vec2(0.5,0.)*i;\n  return 2.*(np);\n}\n\nfloat segmenty(vec2 p) {\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  return p.y > 0. ? d0 : d1;\n}\n\nvec3 truchetCell(vec2 p) {\n  vec2 p0 = p;\n  vec2 p1 = p;\n  vec2 p2 = p;\n  // Trial and error constants\n  p0.y -= 0.07;\n  p2.y -= 0.471404;\n  \n  float d0 = length(p0) -0.1;\n  d0 = abs(d0);\n  float d1 = segmenty(p1);\n  float d2 = length(p2) - 0.408;\n  \n  d2 = abs(d2);\n\n  return vec3(d0,d1,d2)-0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n\n  float aa = sqrt(2.)/RESOLUTION.y;\n\n  float cz = mix(0.5, 1.5, smoothstep(-sqrt(0.5), sqrt(0.5), sin(TAU*TIME/13.)));\n  vec2 cp = p;\n  cp += 10.*cz*sin((vec2(sqrt(0.5), 1.)*TAU*TIME+100.)/200.);\n  cp /=cz;\n  vec2 np = simplexTile(cp);\n  float h0 = hash(np+123.4);\n  float h1 = fract(8667.*h0);\n  cp *= ROT(floor(h0*3.)/3.*TAU);\n  float spx = sign(cp.x);\n  vec3 cs3 = truchetCell(cp);\n  vec3 cd3 = cs3*cz;\n  \n  if (spx*(-1.+2.*h1) > 0.) {\n    col = mix(col, vec3(tanh(0.2-60.*cs3.z)), smoothstep(aa, -aa, cd3.z));\n    col *= 1.-exp(-100.*max(cs3.x, 0.));\n    col = mix(col, vec3(tanh(0.2-60.*cs3.x)), smoothstep(aa, -aa, cd3.x));\n  } else {\n    col = mix(col, vec3(tanh(0.2-60.*cs3.x)), smoothstep(aa, -aa, cd3.x));\n    col *= 1.-exp(-100.*max(cs3.z, 0.));\n    col = mix(col, vec3(tanh(0.2-60.*cs3.z)), smoothstep(aa, -aa, cd3.z));\n  }\n  col *= 1.-exp(-100.*max(cs3.y, 0.));\n  col = mix(col, vec3(tanh(0.20-60.*cs3.y)), smoothstep(aa, -aa, cd3.y));\n\n  if (iMouse.z > 0.) {\n    col += h0*0.5;\n  }\n\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}