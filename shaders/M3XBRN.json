{
    "Shader": {
        "info": {
            "date": "1728083541",
            "description": "splatting some Gaussians",
            "flags": 0,
            "hasliked": 0,
            "id": "M3XBRN",
            "likes": 3,
            "name": "Splasterizer",
            "published": 3,
            "tags": [
                "gaussian",
                "splatting"
            ],
            "usePreview": 0,
            "username": "ShnitzelKiller",
            "viewed": 32
        },
        "renderpass": [
            {
                "code": "#define NUM_STEPS 150\n#define FDIST 0.5\n#define SPLAT_RADIUS 0.25\n#define FUZZINESS 0.01\n#define INV_VAR 40.\n#define TRANSMISSION_CUTOFF 0.02\n\n\nstruct Hit {\n    vec3 id;\n    float h;\n    vec3 col;\n};\n\nvec3 noise(in vec3 seed) {\n    return fract(mat3x3(10921., 9494., -1942., 921., 99644., 44477., 38108., 128949., -66005.) * sin(mat3x3(10921., 9494., -1942., 921., 99644., 44477., 38108., 128949., -66005.) * seed));\n}\n\nfloat shadeCell(in vec3 id, in vec3 rd, in vec3 ro, in vec3 viewDir) {\n    vec3 cell_center = id + 0.5;\n    \n    vec3 co = cell_center - ro;\n    // min distance between center and a point on the ray < const\n    // projected distance (screen space) between center and ray origin < const / r\n    \n    // if we want to project these to screen space accurately, we need to take directional derivatives of the view projection w.r.t. principle axes of the shape\n    //sort of like how we do anisotropic texture projection (view -> uv transform to get receptive shape in tex space), we are computing\n    // (3D -> view to get receptive shape in image space)\n\n    // problem: Spheres are isotropic, how do you interpret the transformed vectors as a new shape in 2D?\n    \n    \n    vec3 v = cross(co, rd);\n    float vv = dot(v, v);\n    //return smoothstep(vv, vv + FUZZINESS, 0.05)* step(0., dot(co, rd)); //works perfectly for rasterizing a sphere thanks to trigonometry\n    return exp(-vv * INV_VAR) * step(0., dot(co, rd));\n    \n    /*float t = dot(co, viewDir);\n    vec3 ray_proj = rd / dot(rd, viewDir);\n    vec3 co_proj = co / t;\n    \n    float thresh = SPLAT_RADIUS / t;\n    \n    float dist2d = length(ray_proj - co_proj);\n    return exp(-dist2d * dist2d * (t*t)*INV_VAR) * step(0., t);*/\n    //return smoothstep(dist2d, dist2d + FUZZINESS, thresh);\n}\n\n\n\nHit voxel_march(in vec3 o, in vec3 d, in vec3 viewDir) {\n    Hit h;\n    h.id = floor(o);\n  /*\n    o------o1,1\n    |   O  |\n    |      |\n    |      |\n    o------o1\n   */\n  \n  vec3 di = 1./d;\n  vec3 mm = vec3(0.);\n  float t = 0.0;\n  vec3 ds = sign(d);\n  vec3 dis = (h.id - o + 0.5 + 0.5 * ds) * di;\n    \n    float transmission = 1.0;\n    \n    // radiative transfer: dL/ds = -sigma * L(s)\n    // L(s) = L_0 * exp(-sigma * s)\n    \n  for (int i=0; i<NUM_STEPS; ++i) {\n      vec3 col = noise(h.id);\n      float opacity = shadeCell(h.id, d, o, viewDir);\n      h.col += col * opacity * transmission;\n      transmission *= (1.0-opacity);\n      if (transmission < TRANSMISSION_CUTOFF) break;\n    mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n    dis += mm * di*ds;\n    h.id += mm * ds;\n  }\n  \n  return h;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fac = 0.4;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 up = vec3(0., 0., 1.0);\n    vec3 viewDir = vec3(cos(iTime * fac), sin(iTime * fac), 0.);\n    vec3 u = normalize(cross(viewDir, up));\n    vec3 v = cross(viewDir, u);\n    \n    vec3 rd = normalize(viewDir * FDIST + (uv.x-0.5) * u + (uv.y-0.5) * (v * iResolution.y / iResolution.x));\n    vec3 eye = vec3(0., iTime, 5.*sin(iTime / 2.));\n    Hit hit = voxel_march(eye, rd, viewDir);\n    \n    // Output to screen\n    fragColor = vec4(pow(hit.col, vec3(1./1.22)), 1.);\n    // fragColor = vec4(sqrt(abs(hit.id) / 2.),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}