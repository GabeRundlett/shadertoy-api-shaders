{
    "Shader": {
        "info": {
            "date": "1624499475",
            "description": "Added reflections to the raytracer base. Removed fog because it was broken. Also added metals.",
            "flags": 0,
            "hasliked": 0,
            "id": "sl2GRc",
            "likes": 16,
            "name": "Raytracer - Reflections",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "bounce",
                "fresnel"
            ],
            "usePreview": 0,
            "username": "SpinningCube",
            "viewed": 537
        },
        "renderpass": [
            {
                "code": "// Filmic tonemapping curve by milesWaugh\n\nconst float epsilon = 0.001;\nconst float focalLength = 1.;\nconst float renderDist = 850.;\nconst float pi = 3.141592653589793;\nconst int bounces = 5;\n\nvec3 camera;\nfloat nearestDist;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfRoughness;\nint surfType; /* 0=dielectric 1=metallic */\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = 1.*vec3(.3, 0.4, 0.7);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nvec4 Sphere( vec3 rayOrigin, vec3 rayDir, vec3 pos, float radius ) {\n    vec3 offset = pos - rayOrigin;\n    float dot1 = dot(offset, rayDir);\n    float dot2 = dot(offset, offset);\n    if (dot1 < 0.) {\n        return vec4(-1., 0, 0, 0);\n    }\n    if (dot2 - dot1 * dot1 < radius * radius) {\n        float near = sqrt(radius * radius - (dot2 - (dot1 * dot1)));\n        return vec4(dot1 - near, (rayOrigin + (rayDir * (dot1 - near))) - pos);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvec4 Plane( vec3 rayOrigin, vec3 rayDir, vec3 normal, float dist ) {\n    float dot1 = dot(normal, rayDir);\n    float near = (dot(normal, rayOrigin) + dist)/dot1;\n    if (!(dot1 == 0.) && near < 0.)\n    {\n        return vec4(-near, normal);\n    }\n    return vec4(-1., 0, 0, 0);\n}\n\nvoid addIntersector( vec4 surface, vec3 col, float roughness, int type /* 0=dielectric, 1=metallic */) {\n    float dist = surface.x;\n    if ( dist < nearestDist && dist > 0. ) {\n        nearestDist = dist;\n        if (updateMat) {\n        \tsurfCol = col;\n            surfRoughness = roughness*roughness;\n            surfNormal = normalize(surface.yzw);\n            surfType = type;\n        }\n    }\n}\n\nfloat scene( vec3 rayOrigin, vec3 rayDir)\n{\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addIntersector( Sphere( rayOrigin, rayDir, vec3(0, 0, 18), 1.), vec3(0.4,.2, 0.01), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(3, 1, 22), 2.), vec3(0.05,0.1, 0.6), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-5, 5, 90), 6.), vec3(0.35,0.35, 1.), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 7, 100), 8.), vec3(.7,0.05, 0.05), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(15, 3, 80), 4.), vec3(.85,0.8, 0.05), .1, 1);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(-3, 3, 60), 4.), vec3(.02,0.3, 0.07), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(1, 1, 55), 2.), vec3(.7,0.7, 0.1), .1, 0);\n    addIntersector( Sphere( rayOrigin, rayDir, vec3(10, 2, 50), 3.), vec3(.03,0.05, 0.3), .1, 0);\n    addIntersector( Plane( rayOrigin, rayDir, vec3(0, 1, 0), 1.), vec3(0.1, 0.3, 0.1), .1, 0);\n    \n    return nearestDist;\n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    \n    nearestDist = renderDist;\n        \n    scene(start, rayDir);\n        \n    if ( nearestDist < renderDist ) {\n        return vec4(1., rayDir * nearestDist + start);\n    }\n    else {\n        return vec4(0., rayDir * nearestDist + start);\n    }\n}\n\nfloat GGX (float halfDot, float roughness) {\n    float r2 = roughness*roughness;\n    float a = halfDot * halfDot * (r2 - 1.) + 1.;\n    return r2 / (a * a);\n}\n\nvoid directionalLight(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * epsilon), lightDist, false).x == 0. ) {\n        float lambertian = dot(surfNormal, lightDir);\n        diffuse += max(intensity * lambertian, 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n        float halfDot = dot(surfNormal, halfway);\n    \tspecular += max(lambertian * intensity * GGX(halfDot, surfRoughness), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    directionalLight( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-10, 50, 20), 2.5, surfNormal);\n    //directionalLight( ray, rayDir, normalize(vec3(-2,2,-1)), surfNormal, 1., 0. );\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec3 filmic(vec3 color) {\n    //return color;\n    return 1. - (1./(5. * pow(color, vec3(2.)) + 1.));\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 rayOrigin, vec3 surfNormal, float f) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    /*\n    float fog = clamp(length(ray - rayOrigin)/(renderDist), 0., 1.);\n    fog = fog*fog*fog;\n    //fog = fog*fog;\n    fog = smoothstep(0., 1., fog);\n    */\n    \n    vec3 finalCol = vec3(0.);\n    \n    if (surfType == 0) {\n        finalCol = mix(surfCol * (diffuse + ambient), vec3(specular), f);\n    }\n    else if (surfType == 1) {\n        finalCol = mix(surfCol * specular, vec3(specular), f);\n    }\n    \n    finalCol = finalCol;\n    \n    return finalCol;\n}\n\nvec3 renderFromRay(vec3 rayDir, vec3 rayOrigin) {\n    vec3 contribution = vec3(1.0);\n    vec3 combinedCol;\n    float totalDepth = 0.;\n    float foga;\n    for (int i = 0; i < bounces; i++) {\n        vec4 rayData = shootRay( rayDir, rayOrigin, renderDist, true );\n\n        if (rayData.x == 1.) {\n            totalDepth += distance(rayData.yzw, rayOrigin);\n            float f = fresnel(1.5, surfRoughness, surfNormal, -rayDir);\n            combinedCol += contribution * lighting(rayData.yzw, rayDir, rayOrigin, surfNormal, f);\n            if (surfType == 0) {\n                contribution *= f;\n            }\n            else if (surfType == 1) {\n                contribution *= mix(surfCol, vec3(1.), vec3(f));\n            }\n            \n            rayDir = reflect(rayDir, surfNormal);\n            rayOrigin = rayData.yzw + epsilon * surfNormal;\n        }\n        else {\n            combinedCol += contribution * ambient;\n            break;\n        }\n    }\n    return combinedCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cosTime = cos(iTime/2.);\n    cosTime = 6.*-cosTime+6.;\n    camera = vec3(.5*cosTime, .6*cosTime+0.3, 5.*cosTime-5.);\n    //camera = vec3(0,0,0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec3 col = renderFromRay(rayDir, camera);\n    \n    // Output to screen, filmic tonemapping, and gamma correction.\n    fragColor = vec4(pow(filmic(col),vec3(1./2.2)),1.0);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}