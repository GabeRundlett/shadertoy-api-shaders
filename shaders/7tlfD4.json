{
    "Shader": {
        "info": {
            "date": "1656107428",
            "description": "Releasing it half-finished, feel free to hack on the two unused biomes!",
            "flags": 32,
            "hasliked": 0,
            "id": "7tlfD4",
            "likes": 1,
            "name": "Detailed 2d Terrain",
            "published": 3,
            "tags": [
                "2d",
                "terrain"
            ],
            "usePreview": 0,
            "username": "cra_manning_w",
            "viewed": 237
        },
        "renderpass": [
            {
                "code": "#define TEX_BUF_A iChannel1\n#define TEX_BUF_B iChannel2\n\n//TODO: Structs for each biome's pre-computed data that might be relevant around biome intersections.\n\n\nvec3 colorTerrain_Water(Camera cam, SunState sun,\n                        BufferA bufA, BufferB bufB,\n                        BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                        BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    return vec3(0.35, 0.55, 0.85);\n}\nvec3 colorTerrain_Plains(Camera cam, SunState sun,\n                         BufferA bufA, BufferB bufB,\n                         BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                         BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    vec3 plainsColor = mix(vec3(0.0, 0.3, 0.1),\n                           vec3(0.1, 0.97, 0.25),\n                           pow(cam.pixelWorld.y / bufA.terrHeight, 0.48));\n\n    //There may be some small caves coming from a nearby mountain biome.\n    float caveEdge = bufA.caveMask * (1.0 - BUF_PULL_MAXX(bufACloseNeighbors).caveMask);\n    vec3 caveColor = vec3(0.32, 0.19, 0.06),\n         caveBorderColor = vec3(0.5);\n    return mix(mix(plainsColor, caveColor, bufA.caveMask),\n               caveBorderColor,\n               caveEdge);\n}\n\nvec3 colorTerrain_Mountains(Camera cam, SunState sun,\n                            BufferA bufA, BufferB bufB,\n                            BufferA bufACloseNeighbors[4], BufferA bufAFarNeighbors[4],\n                            BufferB bufBCloseNeighbors[4], BufferB bufBFarNeighbors[4])\n{\n    vec2 pos = cam.pixelWorld;\n    \n    //Cave data:\n    float caveMask = bufA.caveMask,\n          caveEdgeMask = caveMask * (1.0 - BUF_PULL_MAXX(bufACloseNeighbors).caveMask);\n    //If on the floor of a cave, provide some noisy surface color.\n    float caveFloorMask = bufA.caveMask *\n                          SATURATE(\n                              //An adjacent empty space means this is definitely a floor pixel.\n                              (1.0 - BUF_PULL_MINY(bufACloseNeighbors).caveMask)\n                              //Empty space a bit further above has a weaker effect on the floor mask.\n                                + step(BUF_PULL_MINY(bufAFarNeighbors).caveMask,\n                                       hashT(pos * 2.234).a)\n                          ),\n          caveFloorNoise = mix(0.5, 1.0, hashT(pos.x * 1.2312).b) *\n                           octaveNoise(pos.x * 20.0, 2.22781, 3, 2.0),\n          caveFloorColorT = SHARPEN(SHARPEN(SHARPEN(0.1 + pos.y / bufA.terrHeight)));\n\n    //TODO: Raymarch to see if sunlight is visible from caves along the surface\n    //TODO: Remove 'iron ore' from Buffer B, add rock data to it, give rocks a better border\n                       \n    //Rocks:\n    float rockNoise = 1.0 - worley3(pos * 80.0,\n                                    mix(0.5, 0.0, pos.y / bufA.terrHeight),\n                                    1.2135);\n    rockNoise = pow(rockNoise * step(0.55, rockNoise), 0.75);\n    rockNoise *= 1.0 - step(0.75, worley1(pos * 20.0,\n                                          0.4,\n                                          1.61421));\n    float rockMask = step(0.5, rockNoise) *\n                     //Keep inside the mountain biome, but spread out in shallower ground.\n                     step(0.9 * (1.0 - pos.y), bufA.biome);\n    float rockValue = rockMask\n                        * SHARPEN(SHARPEN(SHARPEN(SHARPEN(pow(rockNoise, 1.5)))))\n                        * mix(0.625, 1.0, hashT(floor(pos * 500.0)).r),\n          rockBorderMask = border(rockNoise, 0.65, 0.55, 13.0);\n\n    //Check gold ore.\n    //TODO: Hiding this in a branch based on gold weight may speed things up, because most pixels have no gold.\n    float oreGoldNoise = bufferOreWeight(bufB.goldMask),\n          oreGoldMask = step(0.0001, bufB.goldMask),\n          oreGoldNeighborCount = bufferOreMask(bufBCloseNeighbors[0].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[1].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[2].goldMask) +\n                                 bufferOreMask(bufBCloseNeighbors[3].goldMask),\n          oreGoldBorder = oreGoldMask *\n                          pow(1.0 - (oreGoldNeighborCount / 4.0), 0.5);\n    //Interpret the gold noise value as a bumpmap,\n    //    and do pseudo-normal-mapping to make an interesting look.\n    #define GOLD_BUMP(pull_dir) (bufferOreMask(pull_dir(bufBCloseNeighbors).goldMask) *    \\\n                                 mix(0.5, 1.0, bufferOreWeight(pull_dir(bufBCloseNeighbors).goldMask)))\n    #define GOLD_LIGHTING_AMBIENT 0.475\n    vec2 normal = normalize(vec2(0.00001) +\n                            vec2(GOLD_BUMP(BUF_PULL_MINX) - GOLD_BUMP(BUF_PULL_MAXX),\n                                 GOLD_BUMP(BUF_PULL_MINY) - GOLD_BUMP(BUF_PULL_MAXY)));\n    float oreGoldBrightness = oreGoldMask *\n                              max(GOLD_LIGHTING_AMBIENT, dot(-normal, sun.dir)),\n          oreGoldSpecular = pow(oreGoldBrightness, 60.0);\n\n    //Compute the final color:\n    return mix(\n        mix(\n            mix(\n                mix(\n                    mix(\n                        //The mountain's base color:\n                        vec3(0.32, 0.19, 0.06),\n                        //Apply the gold ore:\n                        mix(\n                            oreGoldBrightness * sun.brightness *\n                              mix(mix(vec3(0.66, 0.62, 0.3),\n                                      vec3(0.86, 0.8, 0.35),\n                                      oreGoldNoise),\n                                  //Apply the gold ore's border:\n                                  vec3(1.0, 1.0, 0.3),\n                                  oreGoldBorder),\n                            //Apply specular color to the gold ore:\n                            sun.brightness,\n                            oreGoldSpecular\n                        ),\n                        oreGoldMask\n                    ),\n                    //Apply the rocks:\n                    mix(vec3(0.87, 0.82, 0.85),\n                        //Apply the rock border:\n                        vec3(0.55, 0.5, 0.6),\n                        rockBorderMask),\n                    rockValue\n                ),\n                //Apply the cave hole color:\n                vec3(0.032, 0.019, 0.006),\n                caveMask\n            ),\n            //Apply the cave border color:\n            pow(vec3(0.032, 0.019, 0.006), vec3(0.2)),\n            caveEdgeMask\n        ),\n        //Apply the floor color to cave floors:\n        mix(vec3(0.85, 0.35, 0.15),\n            vec3(0.3, 0.85, 0.45),\n            caveFloorColorT)\n          * caveFloorNoise,\n        caveFloorMask\n    );\n}\n\nvec3 colorTerrain(Camera cam, SunState sun, BufferA bufA)\n{\n    BufferB bufB = readBufferB(TEX_BUF_B, cam.screenUV);\n    \n    //Sample from neighbors to get more information.\n    vec2 closeRadius = vec2(1.0),\n         farRadius = vec2(2.0);\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, closeRadius, bufACloseNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, farRadius, bufAFarNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferB, TEX_BUF_B, cam.screenUV, closeRadius, bufBCloseNeighbors)\n    BUF_SAMPLE_AROUND_ME(BufferB, TEX_BUF_B, cam.screenUV, farRadius, bufBFarNeighbors)\n\n    //Use a branch to reduce the amount of coloring work per-pixel from 3 biomes to 2.\n    //The branch should be pretty coherent, because\n    //    biomes are large and don't change vertically.\n    #define COLORING_ARGS cam,sun,bufA,bufB,\\\n                          bufACloseNeighbors,bufAFarNeighbors,bufBCloseNeighbors,bufBFarNeighbors\n    if (bufA.biome < 0.5)\n        return mix(colorTerrain_Water(COLORING_ARGS),\n                   colorTerrain_Plains(COLORING_ARGS),\n                   SHARPEN(SHARPEN(smoothstep(0.0, 0.5, bufA.biome))));\n    else\n        return mix(colorTerrain_Plains(COLORING_ARGS),\n                   colorTerrain_Mountains(COLORING_ARGS),\n                   SHARPEN(SHARPEN(smoothstep(0.5, 1.0, bufA.biome))));\n}\n\n\nfloat raymarchedClouds(Camera cam, SunState sun, float time)\n{\n    float seed = 0.989;\n    float cloudStrength = 0.0;\n    //\"Raymarch\" through multiple parallax layers of clouds.\n    #define N_ITERATIONS 5\n    for (int i = 0; i < N_ITERATIONS; ++i)\n    {\n        float depthT = float(i) / float(N_ITERATIONS-1);\n        float iterSeed = seed + (10.0 * fract(100.0 * depthT));\n        \n        //Compute the world position of this layer of clouds under the pixel.\n        float cloudSpeed = 0.2 * mix(0.2, 0.01, depthT);\n        vec2 cloudPosParallax = vec2(\n            (iTime * cloudSpeed) + iterSeed,\n            0.0\n        );\n        float cloudScale = mix(1.0, 1.5, depthT);\n        #define CLOUD_NOISE_POS(scale) ((cam.pixelWorld * cloudScale * (scale)) + cloudPosParallax)\n        \n        float cloudMask = worley1(CLOUD_NOISE_POS(vec2(0.5, 2.0)),\n                                  iterSeed + 0.5721, 0.4);\n        cloudMask = 1.0 - cloudMask;\n        cloudMask *= pow(cam.pixelWorld.y, 1.21);\n        cloudMask = SHARPEN(SHARPEN(SHARPEN(cloudMask)));\n        cloudMask = pow(cloudMask, 0.65);\n        \n        float sunStrength = 1.0 - SATURATE(distance(cam.pixelWorld, sun.worldPos) - 0.04);\n        sunStrength = pow(sunStrength, 20.0);\n        \n        float cloudNoise = octaveWorley1Noise(CLOUD_NOISE_POS(2.0),\n                                              iterSeed + 8.3423,\n                                              4, 2.0,\n                                              1.0);\n        cloudNoise = pow(1.0 - cloudNoise, 0.9);\n        cloudNoise += sunStrength * pow(cloudNoise, 0.95);\n        cloudNoise = pow(SATURATE(cloudNoise), 0.75);\n        cloudNoise = SHARPEN(cloudNoise);\n        \n        float brightness = 1.5;\n        cloudStrength += cloudMask * cloudNoise * brightness;\n    }\n    \n    return SATURATE(cloudStrength / float(N_ITERATIONS));\n}\n//TODO: Try coarser clouds using a worley-esque approach.\n\nvec3 colorSky(Camera cam, SunState sun, BufferA bufA)\n{\n    //TODO: If near the terrain, output a \"shadow\" of it, based on sun direction.\n    \n    //Compute sun data.\n    float sunField = 1.0 - SATURATE(distance(cam.pixelWorld, sun.worldPos) - 0.04),\n          sunStrength = pow(sunField, 50.0);\n    \n    //Compute clouds.\n    float cloudStrength = raymarchedClouds(cam, sun, iTime);\n    //TODO: Color the clouds based on sun direction and distance\n    \n    return pow(\n        mix(\n            //Make the sky bluer near the zenith.\n            mix(vec3(0.5, 0.5, 1.0),\n                vec3(0.15, 0.15, 1.0),\n                cam.pixelWorld.y),\n            //Draw the sun:\n            vec3(1.0, 0.95, 0.45),\n            sunStrength    \n        ),\n        //Apply clouds:\n        vec3(1.0 - cloudStrength)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.0;\n       \n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    SunState sun = getSunData(cam, iTime);\n    \n    BufferA bufA = readBufferA(TEX_BUF_A, cam.screenUV);\n    \n    if (cam.pixelWorld.y > bufA.terrHeight)\n        fragColor.rgb = colorSky(cam, sun, bufA);\n    else\n        fragColor.rgb = colorTerrain(cam, sun, bufA);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "                            // Header: Enable access to inputs from Common tab\n                            // See https://www.shadertoy.com/view/ttf3R4\n                                #if __LINE__<17          // Must be on line 3!\n                                #define _ST_TAB_COMMON\n                                #endif\n                                #if __LINE__<25\n                                #define _ST_TAB_SOUND\n                                uniform vec3 iResolution; // Sound tab\n                                uniform float iTime;  // never defines these\n                                #endif\n                                #ifdef _ST_TAB_COMMON\n                                #undef _ST_TAB_SOUND\n                                uniform float iTimeDelta;\n                                uniform int iFrame;\n                                uniform float iChannelTime[4];\n                                uniform vec3 iChannelResolution[4];\n                                uniform vec4 iMouse;\n                                // iDate and iSampleRate: Alread have them.\n                                uniform sampler2D iChannel0;\n                                uniform sampler2D iChannel1; // Change type to\n                                uniform sampler2D iChannel2; // samplerCube\n                                uniform sampler2D iChannel3; // if Cube input\n                                #endif\n                            // End header\n//Above header indented to separate it from the rest of the code.\n      \n      \n#define PI 3.1415926535898\n#define PI2 (2.0 * PI)\n\n#define PHI 1.618033988\n\n#define COMMA , /* Helps for more complex macros */\n                      \n\n///////////////////////\n//    Randomness     //\n///////////////////////\n\n//The texture that's sampled for randomness.\n//Note that it's not normally available within the Common tab;\n//    there is some hacky code at the top of this file to support this.\n#define RNG_TEX iChannel0\n\n//Meant for hashing small values.\nvec4 hashT(vec2 t) { return textureLod(RNG_TEX, t * PI * 5.0, 0.0); }\nvec4 hashT(float t) { return hashT(vec2(t)); }\nvec4 hashT(vec3 t) { return hashT(t.xy + t.z); }\nvec4 hashT(vec4 t) { return hashT(t.xy + t.zw); }\n\n\n//////////////////////\n//    Utilities     //\n//////////////////////\n\n#define OSCILLATE(a, b, input) (mix(a, b, 0.5 + (0.5 * sin(PI2 * (input)))))\n\n#define INV_LERP(a, b, x) ((x-a) / (b-a))\n#define SATURATE(x) clamp(x, 0.0, 1.0)\n#define SHARPEN(t) smoothstep(0.0, 1.0, t)\n\n#define RAND_IN_ARRAY(array, t) array[int(mix(0.0, float(array.length()) - 0.00001, t))]\n\n//A higher-quality smoothstep(), with a zero second-derivative at the edges.\n#define SMOOTHERSTEP(t) clamp(t * t * t * (t * (t*6.0 - 15.0) + 10.0), \\\n                              0.0, 1.0)\n\n//Returns a value that increases towards 1 as it gets closer to some target.\nfloat border(float x, float target, float thickness, float dropoff)\n{\n    float dist = abs(x - target);\n    float closeness = 1.0 - min(1.0, dist / thickness);\n    return pow(closeness, dropoff);\n}\n\n//Distance-squared is faster to compute in 2D+, but not in 1D.\n//Some noise is defined with the help of macros to work with any dimensionality,\n//    and so is agnostic to the dimensionality.\nfloat efficientDist(float a, float b) { return abs(b - a); }\nfloat efficientDist(vec2 a, vec2 b) { vec2 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec3 a, vec3 b) { vec3 delta = b - a; return dot(delta, delta); }\nfloat efficientDist(vec4 a, vec4 b) { vec4 delta = b - a; return dot(delta, delta); }\nfloat realDist(float efficientDist, float posType) { return efficientDist; }\nfloat realDist(float efficientDist, vec2 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec3 posType) { return sqrt(efficientDist); }\nfloat realDist(float efficientDist, vec4 posType) { return sqrt(efficientDist); }\n\nfloat sumComponents(float f) { return f; }\nfloat sumComponents(vec2 v) { return v.x + v.y; }\nfloat sumComponents(vec3 v) { return v.x + v.y + v.z; }\nfloat sumComponents(vec4 v) { return v.x + v.y + v.z + v.w; }\n\n//Gets the angle of the given vector, in the range 0-1.\nfloat angleT(vec2 dir) { return 0.5 + (0.5 * atan(dir.y, dir.x)/PI); }\n\n//Given a uniformly-distributed value, and another target value,\n//    biases the uniform value towards the target.\n//The \"biasStrength\" should be between 0 and 1.\nfloat applyBias(float x, float target, float biasStrength)\n{\n    //Degenerative case if x=0.\n    if (x == 0.0)\n        return mix(x, target, biasStrength);\n    \n    //Get the \"scale\" of the target relative to x.\n    //Multiplying x by this number would give exactly the target.\n    float scale = target / x;\n    \n    //Weaken the \"scale\" by pushing it towards 1.0, then apply it to 'x'.\n    //Make sure to respect the sign, in case 'x' or 'target' is negative.\n    return x * sign(scale) * pow(abs(scale), biasStrength);\n}\n\n//Linearly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleLerp(float a, float b, float c, float t)\n{\n    vec3 lerpArgs = (t < 0.5) ?\n                        vec3(a, b, INV_LERP(0.0, 0.5, t)) :\n                        vec3(b, c, INV_LERP(0.5, 1.0, t));\n    return mix(lerpArgs.x, lerpArgs.y, lerpArgs.z);\n}\nvec3 tripleLerp(vec3 a, vec3 b, vec3 c, float t)\n{\n    bool isFirstHalf = (t < 0.5);\n    return isFirstHalf ?\n               mix(a, b, INV_LERP(0.0, 0.5, t)) :\n               mix(b, c, INV_LERP(0.5, 1.0, t));\n    \n}\n//Smoothly interpolates between a beginning, midpoint, and endpoint.\nfloat tripleSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(lerpArgs.z, lerpArgs.w, t));\n}\n//Interpolates between a beginning, midpoint, and endpoint, with aggressive smoothing.\nfloat tripleSmoothSmoothstep(float a, float b, float c, float t)\n{\n    vec4 lerpArgs = (t < 0.5) ?\n                        vec4(a, b, 0.0, 0.5) :\n                        vec4(b, c, 0.5, 1.0);\n    return mix(lerpArgs.x, lerpArgs.y, smoothstep(0.0, 1.0, smoothstep(lerpArgs.z, lerpArgs.w, t)));\n}\n\nfloat distToLine(vec2 lineP, vec2 lineDir, vec2 pos)\n{\n    //Reference: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n    \n    vec2 numerator2 = lineDir * (lineP - pos).yx;\n    return abs(numerator2.x - numerator2.y) / length(lineDir);\n}\n\n//RGB<=>HSV converter, from here: https://stackoverflow.com/a/17897228\nvec3 RGBtoHSV(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 HSVtoRGB(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n////////////////\n//   Ripple   //\n////////////////\n\n//An oscillating value, as a function of the angle around a circle.\nstruct Ripple\n{\n    float scale, speed;\n    int nSpikes;\n    bool canBeNegative;\n};\nfloat ripple(Ripple r, float angleT, float time)\n{\n    float inpt = (time * r.speed) +\n                  (angleT * float(r.nSpikes));\n    float minVal = (r.canBeNegative ? -r.scale : 0.0);\n    return OSCILLATE(minVal, r.scale, inpt);\n}\n\nvec2 rippleRange(Ripple r)\n{\n    return vec2(r.canBeNegative ? -r.scale : 0.0,\n                r.scale);\n}\n\n\n///////////////////////////////\n//    Value/Octave Noise     //\n///////////////////////////////\n\nfloat valueNoise(float x, float seed)\n{\n    float xMin = floor(x),\n          xMax = ceil(x);\n\n    float noiseMin = hashT(vec2(xMin, seed)).r,\n          noiseMax = hashT(vec2(xMax, seed)).r;\n\n    float t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    return mix(noiseMin, noiseMax, t);\n}\nfloat valueNoise(vec2 x, float seed)\n{\n    vec2 xMin = floor(x),\n         xMax = ceil(x);\n    vec4 xMinMax = vec4(xMin, xMax);\n\n    vec2 t = x - xMin;\n    //t = SMOOTHERSTEP(t); //Actually gives worse results due to\n                           //  the dumb simplicity of the underlying noise\n    \n    #define VALUE_NOISE_2D(pos) hashT(vec3(pos, seed)).r\n    return mix(mix(VALUE_NOISE_2D(xMinMax.xy),\n                   VALUE_NOISE_2D(xMinMax.zy),\n                   t.x),\n               mix(VALUE_NOISE_2D(xMinMax.xw),\n                   VALUE_NOISE_2D(xMinMax.zw),\n                   t.x),\n               t.y);\n}\n\n//Octave noise behaves the same regardless of dimension.\n#define IMPL_OCTAVE_NOISE(noiseFunc, noiseMidArg)                    \\\n    float sum = 0.0,                                                 \\\n          scale = 1.0,                                               \\\n          nextWeight = 1.0,                                          \\\n          totalWeight = 0.0;                                         \\\n    for (int i = 0; i < nOctaves; ++i)                               \\\n    {                                                                \\\n        sum += noiseFunc(x * scale, noiseMidArg seed + float(i)) * nextWeight;  \\\n        totalWeight += nextWeight;                                   \\\n                                                                     \\\n        nextWeight /= persistence;                                   \\\n        scale *= persistence;                                        \\\n    }                                                                \\\n                                                                     \\\n    return sum / totalWeight;\nfloat octaveNoise(float x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(valueNoise, ) }\nfloat octaveNoise(vec2 x, float seed, int nOctaves, float persistence) { IMPL_OCTAVE_NOISE(valueNoise, ) }\n\n\n/////////////////////////\n//    Worley Noise     //\n/////////////////////////\n\n//Helper function for worley noise that finds the point in a cell.\n//Outputs its position, and returns whether or not it really exists.\nbool getWorleyPoint(float cell, float chanceOfPoint, float seed, out float pos)\n{\n    vec2 rng = hashT(vec2(cell, seed)).xy;\n    \n    pos = cell + rng.x;\n    return (rng.y < chanceOfPoint);\n}\nbool getWorleyPoint(vec2 cell, float chanceOfPoint, float seed, out vec2 pos)\n{\n    vec3 rng = hashT(vec3(cell, seed)).xyz;\n    \n    pos = cell + rng.xy;\n    return (rng.z < chanceOfPoint);\n}\n\n//Generates worley-noise points that might influence the given position.\n//See the below functions for common use-cases.\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int outNPoints, out float outPoints[3]);\n//Implementation below:\n#define IMPL_WORLEY_START(T)                                    \\\n    T xCenter = floor(x),                                       \\\n      xMin = xCenter - 1.0,                                     \\\n      xMax = xCenter + 1.0;                                     \\\n    nPoints = 0;                                                \\\n    T nextPoint\n//end #define\n#define IMPL_WORLEY_POINT(cellPos)                                  \\\n    if (getWorleyPoint(cellPos, chanceOfPoint, seed, nextPoint))    \\\n        points[nPoints++] = nextPoint\n//end #define\nvoid worleyPoints(float x, float chanceOfPoint, float seed,\n                  out int nPoints, out float points[3])\n{\n    IMPL_WORLEY_START(float);\n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n}\nvoid worleyPoints(vec2 x, float chanceOfPoint, float seed,\n                  out int nPoints, out vec2 points[9])\n{\n    IMPL_WORLEY_START(vec2);\n    \n    IMPL_WORLEY_POINT(xMin);\n    IMPL_WORLEY_POINT(xCenter);\n    IMPL_WORLEY_POINT(xMax);\n    \n    IMPL_WORLEY_POINT(vec2(xMin.x, xCenter.y));\n    IMPL_WORLEY_POINT(vec2(xMin.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xCenter.x, xMax.y));\n    \n    IMPL_WORLEY_POINT(vec2(xMax.x, xMin.y));\n    IMPL_WORLEY_POINT(vec2(xMax.x, xCenter.y));\n}\n\n//Variant 1: straight-line distance, to the nearest point.\nfloat worley1(float x, float chanceOfPoint, float seed);\nfloat worley1(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY1(T, nMaxPoints)                                              \\\nfloat worley1(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /*Specify a hard-coded cap,  */            \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, efficientDist(points[i], x));                     \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                \\\n}\n//end #define\nIMPL_WORLEY1(float, 3)\nIMPL_WORLEY1(vec2,  9)\n\n//Variant 2: manhattan distance, to the nearest point.\nfloat worley2(float x, float chanceOfPoint, float seed);\nfloat worley2(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY2(T, nMaxPoints)                                              \\\nfloat worley2(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist = 9999999.9;                                                   \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        minDist = min(minDist, sumComponents(abs(points[i] - x)));               \\\n    }                                                                            \\\n    return min(realDist(minDist, points[0]), 1.0);                               \\\n}\n//end #define\nIMPL_WORLEY2(float, 3)\nIMPL_WORLEY2(vec2,  9)\n\n//Variant 3: straight-line distance, to the second- nearest point.\nfloat worley3(float x, float chanceOfPoint, float seed);\nfloat worley3(vec2 x, float chanceOfPoint, float seed);\n//Implementation below:\n#define IMPL_WORLEY3(T, nMaxPoints)                                              \\\nfloat worley3(T x, float chanceOfPoint, float seed) {                            \\\n    int nPoints;                                                                 \\\n    T points[nMaxPoints];                                                        \\\n    worleyPoints(x, chanceOfPoint, seed, nPoints, points);                       \\\n                                                                                 \\\n    if (nPoints < 1)                                                             \\\n        return 1.0; /* The nearest point is far away */                          \\\n                                                                                 \\\n    float minDist1 = 9999999.9,                                                  \\\n          minDist2 = 9999999.9;                                                  \\\n    for (int i = 0; i < min(nMaxPoints, nPoints); ++i) /* Specify a hard-coded cap,  */           \\\n    {                                                  /*   in case it helps with unrolling   */  \\\n        float newD = efficientDist(points[i], x);                                \\\n        if (newD < minDist1) {                                                   \\\n            minDist2 = minDist1; minDist1 = newD;                                \\\n        } else if (newD < minDist2) {                                            \\\n            minDist2 = newD;                                                     \\\n        }                                                                        \\\n    }                                                                            \\\n    return SATURATE(min(realDist(minDist2, points[0]) / 1.5, 1.0));                    \\\n}\n//end #define\nIMPL_WORLEY3(float, 3)\nIMPL_WORLEY3(vec2,  9)\n\n//TODO: More variants\n\n//Octave worley noise:\nfloat octaveWorley1Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley1, chanceOfCell COMMA); }\nfloat octaveWorley1Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley1, chanceOfCell COMMA); }\nfloat octaveWorley2Noise(float x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley2, chanceOfCell COMMA); }\nfloat octaveWorley2Noise(vec2 x, float seed, int nOctaves, float persistence, float chanceOfCell) { IMPL_OCTAVE_NOISE(worley2, chanceOfCell COMMA); }\n\n//TODO: Profile worley noise compared to a more hard-coded implementation.\n\n\n\n///////////////////\n//    Camera     //\n///////////////////\n\nstruct Camera\n{\n    vec2 pixelUV, pixelWorld;\n    vec2 screenUV; //Uncorrected for aspect ratio;\n                   //   use this to read from buffers\n    \n    vec2 horzUVRange, horzWorldRange;\n    \n    //Vertical UV and world space are identical, ranging from 0 to 1, for simplicity.\n};\n\nCamera getCamera(vec2 fragCoord, float time, vec2 mouseUV)\n{\n    vec2 uvScreen = fragCoord / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = vec2(uvScreen.x * aspect, uvScreen.y);\n    \n    vec3 worldHorzData  //Pos, Min, Max\n        = vec3(uv.x, 0.0, aspect);\n    float worldY = uv.y;\n               \n    //Find a good position for mountain-debugging.\n    worldHorzData -= 0.75;\n    \n    //Pan rightward.\n    //worldHorzData += time * 0.3;\n    \n    //Add mouse controls.\n    worldHorzData += mouseUV.x * 20.0;\n    \n    return Camera(uv, vec2(worldHorzData.x, worldY),\n                  uvScreen,\n                  vec2(0.0, aspect),\n                  vec2(worldHorzData.yz));\n}\n\n///////////////\n//    Sun    //\n///////////////\n\nstruct SunState\n{\n    vec2 dir;\n    vec3 brightness;\n    vec2 worldPos;\n};\n\nSunState getSunData(Camera cam, float time)\n{\n    vec2 dir = normalize(vec2(-1));\n    \n    //Use the sun's X direction to determine its horizontal position.\n    // -1 maps to the right edge of the screen; +1 maps to the left edge.\n    float horzRange = cam.horzWorldRange.y - cam.horzWorldRange.x;\n    vec2 worldPos = vec2(\n        mix((cam.horzWorldRange.x + cam.horzWorldRange.y) / 2.0,\n            cam.horzWorldRange.y,\n            -dir.x),\n        0.9\n    );\n                \n    return SunState(dir, vec3(1), worldPos);\n}\n\n\n/////////////////////////\n//    Data buffers     //\n/////////////////////////\n\n//Buffer A contains terrain data.\n//  Channel R: biome (0.0 is \"underwater\", 0.5 is \"plains\", 1.0 is \"mountains\")\n//  Channel G: terrain height (in UV space -- 0 to 1\n//  Channel B: mountain cave mask (1 means caves, 0 means solid rock)\n//  Channel A: [unused]\nstruct BufferA\n{\n    float biome, terrHeight, caveMask;\n};\n//Buffer B contains various biome-specific data.\n// Channel R: Gold ore (0.0 is \"none\", 0.1-1.0 is used to generate color)\n// Channel G: Iron ore (0.0 is \"none\", 0.1-1.0 is used to generate color)\n// Channel B: [unused]\n// Channel A: [unused]\nstruct BufferB\n{\n    //TODO: Remove the \"mask\" from the names\n    float goldMask, ironMask;\n};\n\n\n//---------------------------\n//Buffer-specific helpers:\n\n//From buffer value to real value:\nfloat bufferOreWeight(float oreValue) { return INV_LERP(0.1, 1.0, oreValue); }\n//From buffer value to 0-or-1 mask:\nfloat bufferOreMask(float oreValue) { return step(0.05, oreValue); }\n\n//From real masks to buffer value:\nfloat bufferOreValue(float binaryMask, float noiseMask) { return binaryMask * mix(0.1, 1.0, noiseMask); }\n\n//---------------------------\n\n//Packing helpers:\nvec4 packBuffer(BufferA buf)\n{\n    return vec4(buf.biome, buf.terrHeight, buf.caveMask, 1.0);\n}\nvec4 packBuffer(BufferB buf)\n{\n    return vec4(buf.goldMask, buf.ironMask, 0, 1);\n}\n\n//Unpacking helpers:\nvoid unpackBuffer(vec4 v, out BufferA buf)\n{\n    buf.biome = v.x;\n    buf.terrHeight = v.y;\n    buf.caveMask = v.z;\n}\nvoid unpackBuffer(vec4 v, out BufferB buf)\n{\n    buf.goldMask = v.x;\n    buf.ironMask = v.y;\n}\n//One-liner unpacking helpers:\nBufferA unpackBufferA(vec4 v) { BufferA b; unpackBuffer(v, b); return b; }\nBufferB unpackBufferB(vec4 v) { BufferB b; unpackBuffer(v, b); return b; }\n\n//Reading/unpacking helpers:\nvoid readBuffer(sampler2D tex, vec2 uv, out BufferA buf) { unpackBuffer(textureLod(tex, uv, 0.0), buf); }\nvoid readBuffer(sampler2D tex, vec2 uv, out BufferB buf) { unpackBuffer(textureLod(tex, uv, 0.0), buf); }\n//One-liner reading helpers:\nBufferA readBufferA(sampler2D tex, vec2 uv) { BufferA b; readBuffer(tex, uv, b); return b; }\nBufferB readBufferB(sampler2D tex, vec2 uv) { BufferB b; readBuffer(tex, uv, b); return b; }\n\n//Samples from four neighboring buffer values and stores the results.\n#define BUF_SAMPLE_AROUND_ME(BufType, bufTex, uv, radius, outName) \\\n    BufType outName[4]; { \\\n        vec3 texel = vec3(vec2(radius) / iResolution.xy, 0.0); \\\n        readBuffer(bufTex, uv - texel.xz, outName[0]); \\\n        readBuffer(bufTex, uv - texel.zy, outName[1]); \\\n        readBuffer(bufTex, uv + texel.xz, outName[2]); \\\n        readBuffer(bufTex, uv + texel.zy, outName[3]); \\\n    }\n#define BUF_PULL_MINX(outName) outName[0]\n#define BUF_PULL_MINY(outName) outName[1]\n#define BUF_PULL_MAXX(outName) outName[2]\n#define BUF_PULL_MAXY(outName) outName[3]",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "float getBiome(float x)\n{\n    //For testing, use something very simple.\n    //The real biome curve is further below.\n    float dumbBiome = OSCILLATE(0.0, 1.0, fract(x/4.0) + 0.25);\n    return tripleSmoothSmoothstep(0.0, 0.5, 1.0, dumbBiome);\n\n    float raw = OSCILLATE(0.15 + OSCILLATE(0.0, 0.2, x/21.0),\n                          0.5 + OSCILLATE(-0.275, 0.4, x/25.0),\n                          x/6.7);\n    return tripleSmoothSmoothstep(0.0, 0.5, 1.0, raw);\n}\n\nfloat getTerrHeight(float x, float biome)\n{\n    float mountains = mix(0.7, 1.0,\n                          octaveNoise(x*8.0, 2.234, 8, 1.8)\n                          * min(1.0, 1.6*worley1(x*2.0, 0.8, 4.31))),\n          plains = mix(0.4, 0.6, octaveNoise(x*2.0, 0.7834, 5, 2.0)),\n          water = mix(0.0, 0.2, octaveNoise(x*2.0, 1.56927, 3, 8.0));\n\n    return tripleLerp(water, plains, mountains, biome);\n}\n\nfloat getCaveMask(vec2 pos, float biome, float terrainHeight)\n{\n    //TODO: Get rid of the tiny floating chunks of rock inside caves\n\n    float domainWarp = octaveWorley1Noise(pos * vec2(45, 25),\n                                          5.234, 2, 2.0, 0.5);\n    \n    vec2 domainOffset = vec2(0, (domainWarp * 1.3 * domainWarp));\n    float rawValue = octaveWorley1Noise(pos*vec2(15, 15) + domainOffset,\n                                        2.543, 1,\n                                        2.0, 1.0);\n    return step(mix(0.25, 0.65, pos.y / terrainHeight),\n                rawValue * pow(biome, 1.5));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    \n    float biome = getBiome(cam.pixelWorld.x),\n          terrHeight = getTerrHeight(cam.pixelWorld.x, biome),\n          caveMask = getCaveMask(cam.pixelWorld, biome, terrHeight);\n          \n    fragColor = packBuffer(BufferA(biome, terrHeight, caveMask));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define TEX_BUF_A iChannel1\n\nfloat getGoldValue(vec2 pos, BufferA bufA,\n                  BufferA bufANeighbors[4])\n{\n    //Remove gold as the mountain biome drops off,\n    //    and as the elevation increases.\n    float maskExponent = (0.75 + (pos.y * 7.0)) / pow(bufA.biome, 2.5);\n    float mask1 = pow(octaveNoise(pos * 2.5, 0.0023453, 5, 3.0),\n                      maskExponent),\n          mask2 = pow(octaveNoise(pos * 2.5, 0.345, 2, 3.0),\n                      1.4);\n    #define ORE_GOLD_MASK1 0.35\n    #define ORE_GOLD_MASK2 0.45\n    float mask = step(ORE_GOLD_MASK1, mask1)\n                  * step(ORE_GOLD_MASK2, mask2);\n\n    //Remove gold that's too close to a cave surface.\n    mask *= 1.0 - step(0.01, bufA.caveMask\n                               + bufANeighbors[0].caveMask + bufANeighbors[1].caveMask\n                               + bufANeighbors[2].caveMask + bufANeighbors[3].caveMask);\n    \n    float border = min(mask,\n                       border(mask1,\n                              ORE_GOLD_MASK1, 1.0 - (ORE_GOLD_MASK1/2.0),\n                              65.0)\n                         + border(mask2,\n                                  ORE_GOLD_MASK2, 1.0 - (ORE_GOLD_MASK2/2.0),\n                                  55.0));\n\n    float oreNoise = SHARPEN(octaveNoise(pos * 80.0, 8.2523, 4, 2.0));\n    \n    return bufferOreValue(mask, oreNoise);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam = getCamera(fragCoord, iTime, iMouse.xy / iResolution.xy);\n    \n    vec3 texel = vec3(1.0 / iResolution.xy, 0);\n    BufferA bufA = readBufferA(TEX_BUF_A, cam.screenUV);\n    BUF_SAMPLE_AROUND_ME(BufferA, TEX_BUF_A, cam.screenUV, 3, bufANeighbors)\n    \n    float goldValue = getGoldValue(cam.pixelWorld, bufA, bufANeighbors);\n    fragColor = packBuffer(BufferB(goldValue, 0.0));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}