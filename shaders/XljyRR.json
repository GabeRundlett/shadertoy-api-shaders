{
    "Shader": {
        "info": {
            "date": "1507169521",
            "description": "A bigger comparison of various noise functions at top/left and two ways of doing approximate Gaussian blue noise at bottom/right. Notice how the noises based on the sin-function start showing more and more patterns after a while.",
            "flags": 0,
            "hasliked": 0,
            "id": "XljyRR",
            "likes": 22,
            "name": "Gaussian Blue Noise 2",
            "published": 3,
            "tags": [
                "noise",
                "blue",
                "gaussian",
                "dithering",
                "histogram",
                "triangular"
            ],
            "usePreview": 0,
            "username": "TimoKinnunen",
            "viewed": 1523
        },
        "renderpass": [
            {
                "code": "//\n// Gaussian Blue Noise 2\n// by Timo Kinnunen 2017\n//\n// Comparison between approximated Gaussian blue noise,\n// approximated Gaussian noise and triangular noise.\n//\n// The idea is to approximate a Gaussian distribution by\n// adding a bunch of uncorrelated random values together.\n// Given enough values the familiar bell shaped curve\n// should emerge, but we only add 4 to reduce the cost.\n//\n// To approximate blue noise, the resulting random values\n// are filtered. Using a 5x5 filter kernel causing\n// \"ringing\" would give a nice result, but we only\n// use a 3x1 kernel on the theory that on an LCD screen\n// vertical stripes are less apparent than\n//\n// __________ horizontal lines. ___________\n//\n// The end result is a self-contained noise function that\n// hopefully should optimize well.\n//\n\n//\n// Segments from top to bottom and left to right are:\n//\n// Triangular noise w/ a 2to2-hash\n// Triangular noise w/ 2x 2to1-hash\n// Triangular noise w/ a 2to1-hash, remapped\n// Exponential noise w/ a 2to1-hash, remapped from ^1 to ^8 (use mouse!)\n// Gaussian noise w/ 4x 2to1-hash, summed\n// Gaussian noise w/ 2x 2to1-hash, remapped\n// Gaussian blue noise w/ 3 taps of 2x 2to1-hash, remapped\n// Gaussian blue noise w/ 3 taps of a 2to4-hash, summed\n//\n\n//\n// Based on A faster triangle noise by TomF\n// @ https://www.shadertoy.com/view/4t2SDh\n//\n// Based on Triangular PDF Noise Dithering by andyborrell\n// @ https://www.shadertoy.com/view/Mllczf\n//\n\n// Modification of https://www.shadertoy.com/view/4ssXRX\n// Added a second way to do triangle noise without doing\n// a second random sample.\n\nconst int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\nfloat iiTime;\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(p.xyx * vec3(9.1031, 8.1030, 7.0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.x+p3.yz)*p3.zy);\n}\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\n\nfloat n2rand_faster( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\n    // Convert uniform distribution into triangle-shaped distribution.\n    float orig = nrnd0*2.0-1.0;\n    nrnd0 = orig*inversesqrt(abs(orig));\n    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!\n    nrnd0 = nrnd0-sign(orig)+0.5;\n    \n    // Result is range [-0.5,1.5] which is\n    // useful for actual dithering.\n    // convert to [0,1] for histogram.\n    return (nrnd0+0.5) * 0.5;\n}\nfloat n2rand_tri(vec2 n) {\n    n += 0.07* fract(iiTime);\n    return dot(hash22(n), vec2(1))*0.5;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\nfloat n4rand_inv( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    float nrnd4 = nrand( n + 0.19*t );\n\tfloat v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;\n    float v3 = 0.5 * remap( 0.5, 1.0, v1 );\n    return (nrnd4<0.5) ? v2 : v3;\n}\n\n//alternate Gaussian,\n//thanks to @self_shadow\nfloat n4rand_ss( vec2 n )\n{\n\tfloat nrnd0 = nrand( n + 0.07*fract( iiTime ) );\n\tfloat nrnd1 = nrand( n + 0.11*fract( iiTime + 0.573953 ) );\t\n\treturn 0.23*sqrt(-log(nrnd0+0.00001))*cos(2.0*3.141592*nrnd1)+0.5;\n}\n//Mouse Y give you a curve distribution of ^1 to ^8\n//thanks to Trisomie21\nfloat n4rand_cus( vec2 n )\n{\n\tfloat t = fract( iiTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\t\n\tfloat p = 1. / (1. + iMouse.y * 8. / iResolution.y);\n\tnrnd0 -= .5;\n\tnrnd0 *= 2.;\n\tif(nrnd0<0.)\n\t\tnrnd0 = pow(1.+nrnd0, p)*.5;\n\telse\n\t\tnrnd0 = 1.-pow(nrnd0, p)*.5;\n\treturn nrnd0; \n}\nfloat blugausnoise(vec2 c1) {\n    c1 += 0.07* fract(iiTime);\n    //vec2 c0 = vec2(c1.x- 1.,c1.y);\n    //vec2 c2 = vec2(c1.x+ 1.,c1.y);\n    vec3 cx = c1.x+ vec3(-1,0,1);\n    vec4 f0 = fract(vec4(cx* 9.1031,c1.y* 8.1030));\n    vec4 f1 = fract(vec4(cx* 7.0973,c1.y* 6.0970));\n\tvec4 t0 = vec4(f0.xw,f1.xw);//fract(c0.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t1 = vec4(f0.yw,f1.yw);//fract(c1.xyxy* vec4(.1031,.1030,.0973,.0970));\n\tvec4 t2 = vec4(f0.zw,f1.zw);//fract(c2.xyxy* vec4(.1031,.1030,.0973,.0970));\n    vec4 p0 = t0+ dot(t0,t0.wzxy+ 19.19);\n    vec4 p1 = t1+ dot(t1,t1.wzxy+ 19.19);\n    vec4 p2 = t2+ dot(t2,t2.wzxy+ 19.19);\n\tvec4 n0 = fract(p0.zywx* (p0.xxyz+ p0.yzzw));\n\tvec4 n1 = fract(p1.zywx* (p1.xxyz+ p1.yzzw));\n\tvec4 n2 = fract(p2.zywx* (p2.xxyz+ p2.yzzw));\n    return dot(0.5* n1- 0.125* (n0+ n2),vec4(1));\n}\nfloat blugausnoise2(vec2 c1) {\n    float nrand1 = n4rand_ss(c1);\n    float nrand0 = n4rand_ss(vec2(c1.x- 1.,c1.y));\n    float nrand2 = n4rand_ss(vec2(c1.x+ 1.,c1.y));\n    return 2.0* nrand1- 0.5* (nrand0+ nrand2);\n}\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n        if        ( iter < 2 ) { r = n2rand_tri   ((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t} else if ( iter < 3 ) { r = n2rand       ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 4 ) { r = n2rand_faster( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 5 ) { r = n4rand_cus   ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 6 ) { r = n4rand       ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 7 ) { r = n4rand_ss    ( vec2(uv.x,0.5) + seed );\n\t\t} else if ( iter < 8 ) { r = blugausnoise2((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t} else                 { r = blugausnoise ((vec2(uv.x,0.5) + seed)* iResolution.xy );\n\t\t}\n        bucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\nvec4 mainImageTop(vec2 fragCoord) {\n    iiTime = 0.0;\n    vec2 uv = fragCoord.xy/ iResolution.xy;\n    uv.y = fract(uv.y* 2.0)* 0.5;\n\n    const float bands = 4.;\n    const float den = 0.5/8.0;\n    float o = fract(uv.x+ iTime* 0.1);\n    if        (uv.y > 7.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand_tri   (fragCoord));  // Triangular PDF noise\n    } else if (uv.y > 6.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand       ( uv ));\n    } else if (uv.y > 5.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n2rand_faster( uv ));\n    } else if (uv.y > 4.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand_cus   ( uv ));\n    } else if (uv.y > 3.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand       ( uv ));\n    } else if (uv.y > 2.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* n4rand_ss    ( uv ));\n    } else if (uv.y > 1.0 * den) {o += (1.0/ bands)* (-1.0+ 2.0* blugausnoise2(fragCoord));  // Gaussian blue noise\n    } else                       {o += (1.0/ bands)* (-1.0+ 2.0* blugausnoise (fragCoord));  // Gaussian blue noise\n    }\n    o = floor(o* bands+ 0.5)/ bands; // Quantisation\n    \n    return vec4(o,o,o,1);\n}\nvec4 mainImageBottom(vec2 fragCoord) {\n    iiTime = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tconst float num = 8.0;\n\tfloat o = 0.0;\n\tif        ( uv.x < 1.0 / num ) { o += n2rand_tri   ( fragCoord );\n\t} else if ( uv.x < 2.0 / num ) { o += n2rand       ( uv );\n\t} else if ( uv.x < 3.0 / num ) { o += n2rand_faster( uv );\n\t} else if ( uv.x < 4.0 / num ) { o += n4rand_cus   ( uv );\n\t} else if ( uv.x < 5.0 / num ) { o += n4rand       ( uv );\n\t} else if ( uv.x < 6.0 / num ) { o += n4rand_ss    ( uv );\n\t} else if ( uv.x < 7.0 / num ) { o += blugausnoise2( fragCoord );\n\t} else                         { o += blugausnoise ( fragCoord );\n\t}\n    int idx = int(1.0+ uv.x* num);\n    vec2 uvrange = vec2( float(idx- 1)/ num, float(idx)/ num );\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(mod(uv.x- 0.5 / num,1.0 / num) - 0.5 / num) < 0.002 ) o = 0.0;\n\tif ( abs(mod(uv.y- 0.5 / 4.0,1.0 / 4.0) - 0.5 / 4.0) < 0.002 ) o = 0.0;\n\n\t\n\treturn vec4( vec3(o), 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = fragCoord.y* 2.0 < iResolution.y ? mainImageBottom(fragCoord) : mainImageTop(fragCoord);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}