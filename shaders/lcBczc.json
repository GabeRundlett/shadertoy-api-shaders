{
    "Shader": {
        "info": {
            "date": "1722707015",
            "description": "originals  https://glslsandbox.com/e#94325.0",
            "flags": 0,
            "hasliked": 0,
            "id": "lcBczc",
            "likes": 3,
            "name": "reflection  geometry",
            "published": 3,
            "tags": [
                "ray",
                "reflect"
            ],
            "usePreview": 1,
            "username": "nayk",
            "viewed": 73
        },
        "renderpass": [
            {
                "code": "\n\n#define time iTime\n#define resolution iResolution.xy\n#define TAU \t\t(8. * atan(1.))\n#define PHI \t\t((sqrt(5.)+1.)*.5)\n#define PHI2 \t\t(PHI*PHI)\n#define PHI3 \t\t(PHI*PHI*PHI)\n#define MAX_FLOAT \t(pow(2., 128.)-1.)\n\n\n#define ITERATIONS \t256.\n#define MIN_DISTANCE\t(.0002)\n#define MAX_LENGTH\t(40.)\n\n#define TARGET_RANGE\t4.\n#define FLIP_VIEW\t(mouse.y < .5 ? 1. : -1.)\n\n#define VIEW_ORBIT \t(normalize(vec3(sin((mouse.x-.75) * TAU), atan((mouse.y-.5) * TAU) - .95, -cos((mouse.x-.75)*TAU))) * -TARGET_RANGE) //orbit cam\n#define VIEW_X \t\t(normalize(vec3(1., .01,  0.)) * TARGET_RANGE)\n#define VIEW_Y \t\t(normalize(vec3(0., 1., -.01)) * TARGET_RANGE)\n#define VIEW_Z \t\t(normalize(vec3(.01, 0., -1.)) * TARGET_RANGE)\n\n#define VIEW_POSITION   (mouse.x < .22 ? (mouse.y < .6 ? (mouse.y < .3 ? VIEW_X : VIEW_Y) : VIEW_Z) : VIEW_ORBIT - vec3(0., -1.5, 0.))\n#define VIEW_TARGET \tvec3(0., .5, 0.)\n\n#define LIGHT_POSITION \tvec3(128., 128., -64.)\n\n\n#define LIGHT\n\t#define REFLECTION\t\t\n\t#define REFRACTION\n#define BRIGHTNESS\t1.\n#define GAMMA\t\t.6\n\n#define GLOBAL_TIME\t(.1*time)\n\n\n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tvec3 color;\n\tfloat length;\n\tfloat distance;\n\tfloat threshold;\n\tbool intersection;\n\tvec4 gradient;\n\tvec3 material;\n};\n\nvec3 g_normal\t\t\t= vec3(0., 0., 0.);\nvec3 g_color\t\t\t= vec3(0., 0., 0.);\nfloat g_iterations\t\t= 0.;\n\nmat2 rmat(float t);\nvec3 hsv(in float h, in float s, in float v);\nfloat squaresum(in vec3 v); \nfloat sum(in vec3 v);\nfloat max_component(vec3 v);\nfloat smoothmin(float a, float b, float x);\nfloat hash(float x);\nfloat logistic(float x, float y);\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r);\nfloat edge(vec3 p, vec3 a, vec3 b);\nfloat cube(vec3 p, vec3 s);\nfloat edge(vec3 p, vec3 a, vec3 b, float r);\nfloat icosahedron(vec3 p, float r);\nfloat dodecahedron(vec3 p, float r);\nfloat rhombictriacontahedron(vec3 p, float r);\nfloat rhombictriacontahedron_edges(vec3 p, float r);\nfloat trucatedicosahedron(vec3 p, float r);\n\nvec4 derivative(in vec3 position, in float range);\n\nvec3 project(vec3 v, vec3 origin);\nmat3 projection_matrix(in vec3 origin, in vec3 target);\n\nray emit(vec3 origin, vec3 direction, float distance_threshold);\nfloat fresnel(in float i, in float hdl);\nfloat geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl);\nfloat distribution(in float r, in float ndh);\nfloat exp2fog(float depth, float density);\nfloat shadow(vec3 origin, vec3 direction, float mint, float maxt, float k);\nfloat ambient_occlusion(vec3 position, vec3 normal, float delta, float t, float f);\nfloat subsurface_scattering(vec3 position, vec3 normal, vec3 direction, float delta, float t, float f);\nvec3 sphericalharmonic(vec3 normal);\nvec3 gamma_correction(vec3 color, float brightness, float gamma);\nray shade(inout ray r);\n\n\n#ifdef DEBUG\nfloat extract_bit(float n, float b);\t\t\nfloat sprite(float n, vec2 p);\t\t\t\nfloat digit(float n, vec2 p);\t\t\t\t\t\nfloat print(float n, vec2 position);\nvec4 fps_sync(vec2 memory_uv);\n#endif\n\n\nfloat map_polytope(in vec3 position)\n{\t\n\n\tg_iterations++;\n\t\n\tfloat r \t= 3.8;\n\tvec3 p  \t= position;\n\tvec3 q0 \t= -normalize(vec3(0., .5,.80901699437));\t\n\tvec3 q1 \t= vec3(.30901699437, .5,.80901699437);\t\n\t\n\tfloat rtc\t= rhombictriacontahedron(p,r);\n\tfloat ddc \t= dodecahedron(p, r);\n\tfloat tic \t= trucatedicosahedron(p.xyz, r);\n\tfloat ico \t= icosahedron(p, r);\n\tvec3 anim\t= vec3(0., abs(1.-sin(time*2.5))*.1, 0.);\n\tfloat sph \t= length(position-anim)-r/4.;\n\n\n\tfloat edg \t= rhombictriacontahedron_edges(p,r-sph)*sph;\n\tfloat range\t= 99999.;\n\trange\t\t= min(min(min(min(min(max(dodecahedron(p.zxy, r), -icosahedron(p.xyz, r)), max(-dodecahedron(p, r), icosahedron(p, r))+.5), range), range), sph), range);\n\trange \t\t= min(range, edg);\n\treturn range;\n}\n\n\nfloat map_base(in vec3 position)\n{\nposition.xz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime));\n\tif(position.y > -5.45)\n\t{\n\t\tvec2 p \t\t= fract(position.xz * .5 + .5);\n\t\tposition.y\t+= max(min(abs(p.x - .5), abs(p.y - .5)) * -.5, -.015);\n\t}\n\treturn min(cube(position + vec3(0., 5.5,0.), vec3(7.95, .125, 7.95)),cube(position + vec3(5., -6.5,-5.), vec3(.25, 12., .25)));\n}\n\n\nfloat map_distance(in vec3 position)\n{\t\n\tfloat base\t= map_base(position);\t\n\tfloat poly\t= map_polytope(position);\n\t\n\tfloat range\t= MAX_FLOAT;\n\trange\t\t= min(range, base);\t\n\trange\t\t= min(range, poly);\t\n\t\n\treturn range;\n}\n\n\t\n\t\t\t\nray map(inout ray r)\n{\n\tvec3 position   \t= r.position;\n    \n\tfloat base\t\t= map_base(position);\t\n\tfloat poly\t\t= map_polytope(position);\n\t\n\tfloat range\t\t= MAX_FLOAT;\n\trange\t\t\t= min(range, base);\t\n\trange\t\t\t= min(range, poly);\t\n\t\n\tif(base == range)\n\t{\n\t\tvec2 p \t\t= fract(position.xz * .25);\n\n\t\tr.color \t= p.x > .5 ^^ p.y > .5 ? vec3(1., 1., 1.) : vec3(0.125, 0.125, 0.125);\n\t\tr.color \t= position.y < -5.45 ? vec3(1., 1., 1.) : r.color;\n\t\tr.material\t= vec3(.8, .8, 0.);\n\t}\n\telse if(poly == range)\n\t{\n\t\tg_color \t= vec3(.8,.1,.05);\n\t\tvec3 p \t\t= r.position;\n\n\t\t\n\n\t\tr.color \t= vec3(.1, .5, .8);\n\t\t\n\t\tr.material \t= vec3(.3, .6, .8);\n\t}\n\t\n\tr.distance \t\t= range;\n\treturn r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect\t\t\t= resolution.xy/resolution.yy;\n\tvec2 uv \t\t\t= gl_FragCoord.xy/resolution.xy-0.5;\t\n\t\n    \n\t\n  \n\tvec2 panel\t\t\t= (1. + uv * vec2(4., 6.));\n\tvec2 axis_screen\t\t= (fract(uv*3.) - vec2(.4, .5)) * aspect;\n\tvec2 orbit_screen\t\t= (fract(uv) - vec2(.66, .66)) * aspect;\n\tvec2 mobile_screen\t\t= (uv - .5) * aspect;\n\tbool mobile_view\t\t= resolution.y > resolution.x;\t\n\tbool axis_view\t\t\t= panel.x < 2.;\n\t\n\tvec3 origin\t\t\t= vec3(0.,3.,10.);\n\torigin.xz*=mat2(cos(iTime), sin(iTime), -sin(iTime),cos(iTime));\n\tvec2 screen\t\t\t=  uv;\n\tvec3 target\t\t\t= VIEW_TARGET;\n\t\n\t\n\tfloat field_of_view\t\t= 0.5;\n\t\n\tvec3 w          \t\t= normalize(origin-target);\n\tvec3 u          \t\t= normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          \t\t= normalize(cross(u,w));\n\n\t\t\t\n\tvec3 direction \t\t\t= normalize(screen.x * u + screen.y * v + field_of_view * -w);\n    \n\tfloat distance_threshold\t= MIN_DISTANCE;\t\n\tray r \t\t\t\t= emit(origin, direction, distance_threshold);\n\t////\t\n\t\n\t\n\t////light\t\t\n\tvec4 color \t\t\t= vec4(0., 0., 0., 0.);\n\t#ifdef LIGHT\n\tif(r.intersection)\n\t{\t\t\t\t\n\t\tshade(r);\t\t\n\n\t\t#ifdef REFLECTION\n\t\tray reflection \t\t= emit(r.position + r.gradient.xyz * .05, reflect(r.direction, r.gradient.xyz), r.distance * 1.);\n\t\n\n\t\tif(reflection.intersection)\n\t\t{\t\t\t\t\n\t\t\tshade(reflection);\n\n\t\t\tfloat f \t= clamp(fresnel(reflection.material.y, dot(reflection.gradient.xyz, reflection.direction)), 0., 1.);\n\t\t\tr.color\t\t+= reflection.color * r.material.y - reflection.gradient.w * .001;\n\t\t}\n\t\t#endif\t\n\t\t\n\n\t\t#ifdef REFRACTION\n\t\tif(r.material.z != 0.)\n\t\t{\n\t\t\tray refraction\t\t= r;\t\n\t\t\trefraction.intersection\t= false;\n\t\t\trefraction.origin\t= r.position - r.gradient.xyz * MIN_DISTANCE * 8.;\n\t\t\trefraction.direction \t= refract(refraction.direction.xyz, -refraction.gradient.xyz, refraction.material.y);\t\t\n \t\t\trefraction \t\t= emit(refraction.origin, refraction.direction, MIN_DISTANCE);\n\t\t\t\n\t\t\tif(r.intersection)\n\t\t\t{\t\n\t\t\t\tray reflection \t\t= emit(refraction.position, reflect(-refraction.direction, -refraction.gradient.xyz), MIN_DISTANCE * 1.);\n\t\t\t\n\t\t\t\tif(reflection.intersection)\n\t\t\t\t{\t\t\t\t\n\t\t\t\t\tshade(reflection);\n\t\t\n\t\t\t\t\tfloat f \t= clamp(fresnel(reflection.material.y, dot(reflection.gradient.xyz, reflection.direction)), 0., 1.);\n\t\t\t\t\tr.color\t\t+= reflection.color * f / r.material.z + reflection.gradient.w * .5 ;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvec3 gradient \t\t= refraction.gradient.xyz;\n\t\t\t\trefraction.gradient.xyz\t= -refraction.direction;\n\t\t\t\trefraction.direction\t= -refraction.gradient.xyz;\n\t\t\t\tshade(refraction);\t\n\t\t\t\trefraction.direction\t= -refraction.gradient.xyz;\n\t\t\t\trefraction.gradient.xyz\t= gradient;\n\n\t\t\t\tr.color \t\t*= r.material.z;\n\t\t\t\tr.color\t\t\t+= clamp(refraction.color * r.material.z - exp2fog(.05, refraction.length), 0., 1.);\n\t\t\t\tr.color\t\t\t+= pow(clamp(dot(refraction.direction, r.direction),0., 1.), 1. + r.material.z);\n\t\t\t\trefraction.direction \t= refract(refraction.direction, refraction.gradient.xyz, refraction.material.y);\n\t\t\t\trefraction.origin \t= refraction.position + refraction.gradient.xyz * MIN_DISTANCE * 8.;\n\n\t\t\t\t\n\t\t\t\trefraction\t\t= emit(refraction.origin, -refraction.direction, MIN_DISTANCE);\n\t\t\t\tshade(refraction);\n\t\t\t\trefraction.color\t= clamp(refraction.color, 0., 1.);\n\t\t\t\tr.color\t\t\t+= refraction.color * r.material.z;\t\t\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t#endif\n\t\t\t\t\n\t\tcolor.xyz\t\t= r.color;\n\t}\n\telse\n\t{\n\t\tcolor.xyz\t\t*= 1.-logistic(ITERATIONS/g_iterations, .25);\n\t}\n\t#else\n\tcolor.xyz\t\t\t+= logistic(ITERATIONS/g_iterations, .2);\n\t#endif\n\tcolor.xyz\t\t\t= gamma_correction(color.xyz, BRIGHTNESS, GAMMA);\n\t////light\n\t\n\t\n\tfragColor.xyz\t\t= color.xyz;\n\n\t\n\t\n\t\n\n}//sphinx\n\n\n\nmat3 projection_matrix(in vec3 origin, in vec3 target) \n{\t\n\tvec3 w          \t= normalize(origin-target);\n\tvec3 u         \t\t= normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          \t= normalize(cross(u,w));\n\treturn mat3(u, v, w);\n}\n\n\nvec3 project(vec3 v, vec3 origin)\n{\n\tv \t+= origin;\n\tv.z \t= v.z + 1.;\n\tv.xy \t/= v.z;\n\treturn v;\n}\n\n\n\nray emit(vec3 origin, vec3 direction, float distance_threshold)\n{\n\tfloat min_distance\t\t= distance_threshold;\n\tfloat max_length\t\t= MAX_LENGTH;\n\t\n\tray r;\n\tr.direction     \t\t= direction;\n\tr.position\t\t\t= origin;\n\tr.origin\t\t\t= origin;\n\tr.color\t\t\t\t= vec3(0., 0., 0.);\n\tr.material\t\t\t= vec3(0., 0., 0.);\n\tr.threshold\t\t\t= distance_threshold >= 0. ? min_distance : -min_distance; \t\n\tr.distance\t\t\t= min_distance;\n\tr.length\t\t\t= 0.;\n\tr.intersection \t\t\t= false;\n\t\n\tr\t\t\t\t= map(r);\n\tconst float iterations\t\t= ITERATIONS/2.;\n\tfor(float i = 1.; i < iterations; i++)\n\t{\n\t\tif(abs(r.distance) > r.threshold * .00125 && r.length < max_length)\n\t\t{\n\t\t\tr.position \t\t= r.origin + r.direction * r.length;\t\n\t\t\t\n\t\t\tr\t\t\t= map(r);\t\n\t\t\t\n\t\t\tr.threshold\t\t*= 1.0085;\n\t\t\tr.length\t\t-= .00015 * cos(time) + .000125;\n\t\t\tr.length\t\t+= r.distance * .96;\t\t\n\t\t}\n\t}\n\t\n\tif(abs(r.distance) <= r.threshold)\n\t{\n\t\tr.intersection  \t= true;\n\t\tr.distance\t\t= r.threshold;\n\t\tr.gradient\t\t= derivative(r.position, r.threshold);\n\n\t\tr.length\t\t= length(r.origin-r.position);\n\t\tr.gradient.xyz\t\t= normalize(r.gradient.xyz);\n\n\t}\n\t\n\treturn r;\n}\n\n\nfloat squaresum(in vec3 v) \n{ \n\treturn dot(v,v); \n}\n\n\n\nfloat sum(in vec3 v) \n{ \n\treturn dot(v, vec3(1., 1., 1.)); \n}\n\n\nfloat smoothmin(float a, float b, float k)\n{\n//\tconst float k = 5.8;\n        return -log(exp(-k*a)+exp(-k*b))/k;\n}\n\n\nfloat logistic(float x, float y)\n{\t\n\treturn 1./(1. + pow(2.718281828, -y * (x - .5)));\n}\n\n\nfloat max_component(vec3 v)\n{\n\treturn max(max(v.x, v.y), v.z);\n}\n\n\nvec3 hsv(in float h, in float s, in float v)\n{\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat hash(in float x)\n{\n\tfloat k = x * 65537.618034;   \t\n\treturn fract(fract(k * x) * k);\n}\n\nmat2 rmat(float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat cube(vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n\treturn max(d.x,max(d.y,d.z) - min(length(d), 0.));\n}\n\n\n\nfloat segment(vec3 p, vec3 a, vec3 b, float r)\n{\n\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\n\treturn length(pa - ba * h)-r;\n}\n\n\t\nfloat edge(vec3 p, vec3 a, vec3 b, float r)\n{\n\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\n\treturn length(pa - ba * h)-r;\n}\n\nfloat icosahedron(vec3 p, float r)\n{\n\tvec4 q \t= (vec4(.30901699437, .5, .80901699437, 0.)); \t\n\tp \t= abs(p);\n\treturn max(max(max(dot(p,q.wxz), dot(p, q.yyy)),dot(p,q.zwx)),dot(p,q.xzw))-r;\n}\n\n\nfloat dodecahedron(vec3 p, float r)\n{\n\tvec3 q \t= normalize(vec3(0., .5,.80901699437));\t\n\tp \t= abs(p);\t\n\treturn max(max(dot(p, q.yxz), dot(p, q.zyx)),dot(p, q.xzy))-r;\n}\n\nfloat rhombictriacontahedron(vec3 p, float r)\n{\n\tvec3 q = vec3(.30901699437, .5,.80901699437);\t\n\tp = abs(p);\t\n\treturn  max(max(max(max(max(p.x, p.y), p.z), dot(p, q.zxy)), dot(p, q.xyz)), dot(p, q.yzx)) - r;\n}\n\n\nfloat trucatedicosahedron(vec3 p, float r)\n{\n\tvec4 q\t= vec4(.30901699437, .5,.80901699437, 0.);\t\n\t//p = abs(p);\n\tfloat d = 0.;\n\n\tp\t= abs(p);\n\td\t= max(max(max(max(max(p.x, p.y), p.z), dot(p, q.zxy)), dot(p, q.xyz)), dot(p, q.yzx));\t\n\td \t= max(max(max(dot(p, q.ywz), dot(p, q.zyw)),dot(p, q.wzy)), d - .125);\t\t\t\n\td\t-= r - .125;\n\treturn  d;\n}\n\n\nfloat rhombictriacontahedron_edges(vec3 p, float r)\n{\n\tvec4 v \t\t= vec4(pow(vec3(PHI), vec3(3., 2., 1.)), 0.) * r;\n\tvec3 o\t\t= vec3(0., 0., 0.);\n\t\n\tfloat e \t= 8192.;\n\tp \t\t= abs(p);\n\te\t\t= min(e, edge(p, o, v.yyy,0.)); //center\n\te \t\t= min(e, edge(p, o, v.xyw,0.)); //right\n\te \t\t= min(e, edge(p, o, v.xwz,0.)); //bottom right\n\te \t\t= min(e, edge(p, o, v.ywx,0.)); //bottom center\n\te \t\t= min(e, edge(p, o, v.wzx,0.)); //left\n\te \t\t= min(e, edge(p, o, v.wxy,0.)); //top left\n\te \t\t= min(e, edge(p, o, v.zxw,0.)); //top right\n\t\t\n\treturn e;\n}\n\n\nvec4 derivative(in vec3 position, in float epsilon)\n{\n\tvec2 offset \t= vec2(-epsilon, epsilon);\n\tvec4 simplex \t= vec4(0.);\n\tsimplex.x \t= map_distance(position + offset.xyy);\n\tsimplex.y \t= map_distance(position + offset.yyx);\n\tsimplex.z \t= map_distance(position + offset.yxy);\n\tsimplex.w \t= map_distance(position + offset.xxx);\n\tvec3 grad \t= offset.xyy * simplex.x + offset.yyx * simplex.y + offset.yxy * simplex.z + offset.xxx * simplex.w;\t\n\tg_normal\t= normalize(grad);\n\treturn vec4(grad, .2/epsilon*(dot(simplex, vec4(1.)) - 4. * map_distance(position)));\n}\n\n\n\nray shade(inout ray r)\n{\n\tvec3 surface_direction\t= normalize(r.gradient.xyz);\n\tvec3 light_position \t= LIGHT_POSITION;\n\tvec3 light_direction\t= normalize(light_position - r.position);\n   \n\tvec3 half_direction    \t= normalize(light_direction - r.direction); \n\t  \n\tfloat fog \t\t= exp2fog(MAX_LENGTH/(1.+abs(r.length)), .5);\n\tfloat shadows\t\t= shadow(r.position, light_direction, r.distance, 32., 16.);\n\tfloat occlusion\t\t= ambient_occlusion(r.position, surface_direction, .125, .05, .125);\n\t\n\tfloat ndl   \t\t= max(.01, dot(surface_direction, light_direction));\n\tfloat ndv   \t\t= dot(surface_direction, r.direction);\t\t\n\tfloat hdn   \t\t= dot(half_direction, surface_direction);\n\tfloat hdv   \t\t= dot(half_direction, r.direction);\n\tfloat hdl   \t\t= dot(half_direction, light_direction);\n\t\n\tfloat g     \t\t= geometry(r.material.x, ndl, ndv, hdn, hdv, hdl);\n\tfloat d     \t\t= distribution(r.material.x, hdn);\n\tfloat f     \t\t= fresnel(r.material.y, hdv);\n\t\n\tfloat brdf  \t\t= f*g*d/(4.*ndl*ndv);\n\tvec3 light_color\t= sphericalharmonic(surface_direction);\n\t\n\tr.color\t\t\t= r.color + light_color * brdf;\t\t\n\t\n\tr.color\t\t\t+= fog;\t\t\n\tr.color\t\t\t*= clamp(shadows * occlusion * ndl, 0.25, 1.);\t\t\n\n\tr.color\t\t\t*= fresnel(r.material.y, ndl-r.gradient.w);\n\treturn r;\n}\n\n\nfloat fresnel(in float i, in float hdv)\n{   \n    return i + (1.-i) * pow(1.-max(hdv, 0.), 5.);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl)\n{\n    //#define WALTER\n    #ifdef WALTER\n    float a         = 1./(i*tan(acos(max(ndv, 0.))));\n\tfloat a2        = a * a;\n    float ak        = a > 1.6 ? (3.535 * a + 2.181 * a2)/(1. + 2.276 * a + 2.577 * a2) : 1.;\n    return 1.-(step(0.0, hdl/ndl) * ak)*( step(0., hdv/ndv) * ak);\n    #endif\n    \n    #define COOKTORRENCE\n    #ifdef COOKTORRENCE\n\treturn min(min(2. * hdn * max(ndv, 0.) / hdv, 2. * hdn * max(ndl, 0.) / hdv), 1.);\n    #endif\n    \n    //#define SCHLICK \n    #ifdef SCHICK\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(2./pi);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n    #endif\n}\n\n\nfloat distribution(in float r, in float ndh)\n{  \n    #define BLINNPHONG\n    #ifdef BLINNPHONG\n\tfloat m     = 2./(r*r) - 2.;\n\treturn (m+2.) * pow(max(ndh, 0.0), m) / TAU;\n    #endif\n\n\t//#define BECKMAN\n    #ifdef BECKMAN\n    float r2    = r * r;\n\tfloat ndh2  = max(ndh, 0.0);\n\tndh2        = ndh2 * ndh2;\n\treturn exp((ndh2 - 1.0)/(r2*ndh2))/ (PI * r2 * ndh2 * ndh2);\n    #endif\n}\n\n\nfloat exp2fog(float depth, float density)\n{\n\tfloat f = pow(2.71828, depth * density);\n\treturn 1./(f * f);\n}\n\n\nfloat shadow(vec3 origin, vec3 direction, float mint, float maxt, float k) \n{\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = t;\n\tfor (int i = 0; i < 32; i++) \n\t{\n\t\tif (t < maxt)\n\t\t{\n\t\t\th \t\t= map_distance(origin + direction * t);\n\t\t\tsh \t\t= smoothmin(abs(k * h/t), sh, k);\n\t\t\tt \t\t+= min(h, maxt);\n\t\t}\n\t}\n\treturn clamp(sh, .0, 1.);\n}\n\n\nfloat ambient_occlusion(vec3 position, vec3 normal, float delta, float t, float f)\n{\t   \n\n\tfloat occlusion = 0.0;\n\tvec3 color \t= vec3(0., 0., 0.);\n\tfor (float i = 1.; i <= 9.; i++)\n\t{\n\t    occlusion\t  += t * (i * delta - map_distance(position + normal * delta * i));\n\t    t \t\t  *= f;\n\t}\n \t\n\tconst float k \t= 4.0;\n\treturn 1.0 - clamp(k * occlusion, 0., 1.);\n}\n\n\nvec3 sphericalharmonic(vec3 n)\n{     \n\tvec4 c[7];\n\tc[0] = vec4(0.0, 0.5, 0.0, 0.4);\n\tc[1] = vec4(0.0, 0.3, .05, .45);\n\tc[2] = vec4(0.0, 0.3, -.3, .85);\n\tc[3] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[4] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[5] = vec4(0.1, 0.1, 0.1, 0.0);\n\tc[6] = vec4(0.0, 0.0, 0.0, 0.0);  \n\t\n\tvec4 p = vec4(n, 1.);\n\n\tvec3 l1 = vec3(0.);\n\tl1.r = dot(c[0], p);\n\tl1.g = dot(c[1], p);\n\tl1.b = dot(c[2], p);\n\n\tvec4 m2 = p.xyzz * p.yzzx;\n\tvec3 l2 = vec3(0.);\n\tl2.r = dot(c[3], m2);\n\tl2.g = dot(c[4], m2);\n\tl2.b = dot(c[5], m2);\n\n\tfloat m3 = p.x*p.x - p.y*p.y;\n\tvec3 l3 = vec3(0.);\n\tl3 = c[6].xyz * m3;\n\n\tvec3 sh = vec3(l1 + l2 + l3);\n\n\treturn clamp(sh, 0., 1.);\n}\n\n\nvec3 gamma_correction(vec3 color, float brightness, float gamma)\n{\n\treturn pow(color * brightness, vec3(1., 1., 1.)/gamma);\n}\t\n\n\nfloat extract_bit(float n, float b)\n{\n\tn = floor(n);\n\tb = floor(b);\n\tb = floor(n/pow(2., b));\n\treturn float(mod(b, 2.) == 1.);\n}\n\t\n\t\t\t\t\t\nfloat sprite(float n, vec2 p)\n{\n\tp = floor(p);\n\tfloat bounds = float(all(bvec2(p.x < 3., p.y < 5.)) && all(bvec2(p.x >= 0., p.y >= 0.)));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\t\n\t\t\t\t\t\nfloat digit(float n, vec2 p)\n{\n\tif(n == 0.) { return sprite(31599., p); }\n\telse if(n == 1.) { return sprite( 9362., p); }\n\telse if(n == 2.) { return sprite(29671., p); }\n\telse if(n == 3.) { return sprite(29391., p); }\n\telse if(n == 4.) { return sprite(23497., p); }\n\telse if(n == 5.) { return sprite(31183., p); }\n\telse if(n == 6.) { return sprite(31215., p); }\n\telse if(n == 7.) { return sprite(29257., p); }\n\telse if(n == 8.) { return sprite(31727., p); }\n\telse if(n == 9.) { return sprite(31695., p); }\n\telse { return 0.0; }\n}\n\t\n\t\t\t\t\t\nfloat print(float n, vec2 position)\n{\t\n\tfloat offset\t= 4.;\n\tfloat result\t= 0.;\n\tposition.x \t-= log2(n)/log2(2.71828);\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\t\t\n\t\tif(n >= place || i == 0)\n\t\t{\n\t\t\tresult\t \t+= digit(floor(mod(floor(n/place)+.5, 10.)), position);\t\t\n\t\t\tposition.x\t+= 4.;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n\t}\n\treturn result;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}