{
    "Shader": {
        "info": {
            "date": "1674058801",
            "description": "sdf sketch for cartoon \"pop!\" shape.\n\nthis time, popping in high viscocity medium.\nand more modern cartoonish style.\nprev: [url]https://www.shadertoy.com/view/ctj3zK[/url]",
            "flags": 48,
            "hasliked": 0,
            "id": "dl2GWc",
            "likes": 25,
            "name": "BLF Pop! part II",
            "published": 3,
            "tags": [
                "cartoon",
                "comic",
                "pop",
                "maptoy"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 505
        },
        "renderpass": [
            {
                "code": "/*\n  SDF is in BufB.\n*/\n#define getBuf(coord)\ttexelFetch(iChannel0, ivec2(coord), 0)\nvec3 getAlbedo(vec2 coord) { return unpackU4(getBuf(coord).x).rgb; }\nfloat getDiffuse(vec2 coord) { return s2u(unpackS3(getBuf(coord).y).r); }\nfloat getDepth(vec2 coord) { return getBuf(coord).w; }\nvec3 getNormal(vec2 coord) { return normalize(unpackS3(getBuf(coord).z)); }\nvec2 clampCoord(vec2 coord) { return clamp(coord, vec2(0), iResolution.xy - .5); }\n\nfloat calcEdge(vec3 nlm1, vec3 nlm2) {\n\tvec2 difN = abs(nlm1.xy - nlm2.xy);\n\treturn smoothstep(1.5, 1., difN.x + difN.y);\n}\n\nfloat getOutline(vec2 coord) {\n    if(getDepth(coord)>.9)return .4;\n    \n\tconst vec3 offset = vec3(.5, -.5, 0)*2.;\n    #define NM(x)\tgetNormal(x)\n\tvec2 coords = coord;\n\tfloat edge = 1.;\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yx)), NM(clampCoord(coords + offset.xy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.xx)), NM(clampCoord(coords + offset.yy))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.yz)), NM(clampCoord(coords + offset.xz))));\n\tedge = min(edge, calcEdge(NM(clampCoord(coords + offset.zx)), NM(clampCoord(coords + offset.zy))));\n\treturn edge;\n}\n\n// ref: (in japanese)\n// https://imagingsolution.net/imaging/canny-edge-detector/\n// Detect edge.\nvec4 sobel(vec2 fragCoord, vec2 dir) {\n\tfloat np, zp, pp, nz, pz, nn, zn, pn, gx, gy;\n    np = getDiffuse(clampCoord(fragCoord + (vec2(-1, 1) + dir)));\n    zp = getDiffuse(clampCoord(fragCoord + (vec2(0, 1) + dir)));\n    pp = getDiffuse(clampCoord(fragCoord + (vec2(1) + dir)));\n    nz = getDiffuse(clampCoord(fragCoord + (vec2(-1, 0) + dir)));\n    pz = getDiffuse(clampCoord(fragCoord + (vec2(1, 0) + dir)));\n    nn = getDiffuse(clampCoord(fragCoord + (vec2(-1) + dir)));\n    zn = getDiffuse(clampCoord(fragCoord + (vec2(0, -1) + dir)));\n    pn = getDiffuse(clampCoord(fragCoord + (vec2(1, -1) + dir)));\n\n\t// https://www.shadertoy.com/view/Wds3Rl\n\tgx = np * -3. + nz * -10. + nn * -3. + pp * 3. + pz * 10. + pn * 3.;\n\tgy = np * -3. + zp * -10. + pp * -3. + nn * 3. + zn * 10. + pn * 3.;\n\n\tvec2 G = vec2(gx, gy);\n\treturn vec4(G, length(G), atan(G.y, G.x));\n}\n\nvec2 hysteresisThr(vec2 fragCoord, float mn, float mx) {\n\tvec4 edge = sobel(fragCoord, vec2(0));\n\tvec2 dir = vec2(cos(-edge.w), sin(-edge.w));\n\tvec4 edgep = sobel(fragCoord, dir),\n\t     edgen = sobel(fragCoord, -dir);\n\tif (edge.z < edgep.z || edge.z < edgen.z) edge.z = 0.;\n\treturn vec2((edge.z > mn) ? edge.z : 0., (edge.z > mx) ? edge.z : 0.);\n}\n\nfloat cannyEdge(vec2 fragCoord, float mn, float mx, bool isDiffuse) {\n\tvec2 np = hysteresisThr(fragCoord + vec2(-1, 1), mn, mx),\n\t     zp = hysteresisThr(fragCoord + vec2(0, 1), mn, mx),\n\t     pp = hysteresisThr(fragCoord + vec2(1), mn, mx),\n\t     nz = hysteresisThr(fragCoord + vec2(-1, 0), mn, mx),\n\t     zz = hysteresisThr(fragCoord + vec2(0), mn, mx),\n\t     pz = hysteresisThr(fragCoord + vec2(1, 0), mn, mx),\n\t     nn = hysteresisThr(fragCoord + vec2(-1), mn, mx),\n\t     zn = hysteresisThr(fragCoord + vec2(0, -1), mn, mx),\n\t     pn = hysteresisThr(fragCoord + vec2(1, -1), mn, mx);\n\treturn 1. - min(1., step(1e-3, zz.x * 8.) * smoothstep(0., .5, np.y + zp.y + pp.y + nz.y + pz.y + nn.y + zn.y + pn.y) * 8.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec3 albedo = getAlbedo(fragCoord);\n    vec3 col = vec3(.9608, .9216, .8431);\n\n\tcol *= min(getOutline(fragCoord), cannyEdge(fragCoord, 0., 3.5, true));    \n\tcol *= sms(.4, .401, gnoise(fragCoord * .18+floor(iTime)) + gnoise(fragCoord * .15) + .3);\n\tcol += 1. - sms(.8, .801, (1. - gnoise(fragCoord * .05+floor(iTime)) * gnoise(fragCoord * .1)) + .7);\n\tfragColor = vec4(pow3(col, .45), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n  Generals\n*/\n\n#define PI acos(-1.)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n#define sat(x) clamp(x,0.,1.)\n#define sms(min,max,x) smoothstep(min,max,x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x > 0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x),sign1f(v.y))\n#define linearstep(edge0,edge1,x) min(max((x-(edge0))/((edge1)-(edge0)),0.),1.)\n#define ZERO min(0,iFrame)\nvec3 pow3(vec3 v,float power){return pow(v,vec3(power));}\n\n// \"hash11()\"-\"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec3 hash33(vec3 p3) {\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yxz + 33.33);\n  return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st) {\n  st *= .75;\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 u = smoothstep(0., 1., f);\n\n  vec2 rnd_x0y0 = u2s(hash22(i + vec2(0, 0)));\n  vec2 rnd_x1y0 = u2s(hash22(i + vec2(1, 0)));\n  vec2 rnd_x0y1 = u2s(hash22(i + vec2(0, 1)));\n  vec2 rnd_x1y1 = u2s(hash22(i + vec2(1, 1)));\n\n  vec2 dir_x0y0 = st - (i + vec2(0, 0));\n  vec2 dir_x1y0 = st - (i + vec2(1, 0));\n  vec2 dir_x0y1 = st - (i + vec2(0, 1));\n  vec2 dir_x1y1 = st - (i + vec2(1, 1));\n\n  float dot_x0y0 = dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0 = dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1 = dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1 = dot(rnd_x1y1, dir_x1y1);\n\n  float res_x = mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y = mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y) * 2.);\n}\n\n// Data packer/unpacker\n// albedo,diffuse,specular,shadow,normal,and depth are rendered in raymarching pass,\n// and then,those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x) {\n\tx = round(clamp(x,-1., 1.) *.997 * 511.);\n\tuvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n\tuvec3 mag = uvec3(abs(x));\n\tuvec3 r = sig.xyz << 9 | mag.xyz;\n\treturn r.x << 22 | r.y << 12 | r.z << 2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x) {\n\tuvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n\tuvec3 sig = r >> 9;\n\tuvec3 mag = r & uvec3(0x1FF);\n\tvec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n\tvec3 fmag = vec3(mag) / 511.;\n\treturn fsig * fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x) {\n\tx = round(clamp(x, 0., 1.) * 255.);\n\tuvec4 r = uvec4(x);\n\treturn r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n\tvec4 v = vec4(r) / 255.0;\n\treturn v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n\nstruct RenderData {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n} renDat;\n\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n}ray;\n\nstruct Camera {\n  vec3 position;\n  vec3 direction;\n  vec3 target;\n  vec4 quaternion;\n  float fov;\n  float orthoDist;\n  float orthoScale;\n  vec3 up;\n};\n\nstruct Light {\n  vec3 direction;\n  vec3 color;\n  float intensity;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n\n#define MAT_VOID vec3(-1)\n\n// Raymarching setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define DIST_MIN .001\n#define DIST_MAX 20.\n#define STEP_MAX 100\n\n#define INIT_CAM_POS vec3(2,-.25,2)\n#define CAM_DIST 10.\n#define CAM_INIT_SCALE 1.35\n#define TURN_TABLE_SPEED .25\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec3 mouse=vec3(0);\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(2,0)\n#define C_MOUSE_VEC vec2(4,0)\n#define C_MOUSE_POS vec2(6,0)\n#define C_QUAD_VIEW vec2(8,0)\n#define C_TURN_TABLE vec2(10,0)\n#define C_CAM_SCALE vec2(12,0)\n#define C_TARGET_X vec2(14,0)\n#define C_TARGET_Y vec2(16,0)\n#define C_TARGET_Z vec2(18,0)\n#define C_DEBUG_ISO vec2(20,0)\n#define C_DEBUG_COST vec2(22,0)\n#define C_DEBUG_MATCAP vec2(24,0)\n#define C_DEBUG_NORMAL vec2(26,0)\n\nvec4 packRenderData(){\n  return vec4(packU4(vec4(renDat.albedo, renDat.shadow)), packS3((vec3(u2s(renDat.diffuse), renDat.specular, u2s(renDat.ao)))), packS3((renDat.normal)), renDat.depth);\n}\n\n#define render() \\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=ZERO; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=ZERO; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 target = vec3(fetch(C_TARGET_X).x,fetch(C_TARGET_Y).x,fetch(C_TARGET_Z).x);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    int num;\\\n    if(sign(iMouse.z)>.0)\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(target-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= (CAM_INIT_SCALE+fetch(C_CAM_SCALE).x)/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = target-pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nvec4 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    float t= march(ray.origin, ray.direction);\\\n    renDat.normal=vec3(0);\\\n    renDat.diffuse=1.;\\\n    renDat.albedo=vec3(.9);\\\n    renDat.depth=1.;\\\n    renDat.specular=0.;\\\n    renDat.shadow=1.;\\\n    renDat.ao=1.;\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(0,1,1);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        renDat.normal=n;\\\n        renDat.diffuse=dif;\\\n        renDat.albedo = vec3(1);\\\n        renDat.depth = 0.;\\\n    }\\\n    return packRenderData();\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    mouse = (vec3(iMouse.xy/iResolution.xy,.5)*2.)-1.;\\\n    fragColor = renderRect(fragCoord);\\\n}int dummy\\\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "/*\n  User Inputs\n\n  References:\n  \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n  \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n  \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n  \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n  Shows how to use the mouse input (only left button supported):\n       mouse.xy  = mouse position during last button down\n   abs(mouse.zw) = mouse position during last button click\n  sign(mouze.z)  = button is down\n  sign(mouze.w)  = button is clicked\n*/\n\nconst int K_PAD_0 = 96;\nconst int K_PAD_1 = 97;\nconst int K_PAD_2 = 98;\nconst int K_PAD_3 = 99;\nconst int K_PAD_4 = 100;\nconst int K_PAD_5 = 101;\nconst int K_PAD_6 = 102;\nconst int K_PAD_7 = 103;\nconst int K_PAD_8 = 104;\nconst int K_PAD_9 = 105;\n\nconst int K_NUM_0 = 48;\nconst int K_NUM_1 = 49;\nconst int K_NUM_2 = 50;\nconst int K_NUM_3 = 51;\nconst int K_NUM_4 = 52;\nconst int K_NUM_5 = 53;\nconst int K_NUM_6 = 54;\nconst int K_NUM_7 = 55;\nconst int K_NUM_8 = 56;\nconst int K_NUM_9 = 57;\n\nconst int K_W = 87;\nconst int K_A = 65;\nconst int K_S = 83;\nconst int K_D = 68;\nconst int K_E = 69;\nconst int K_Q = 81;\nconst int K_T = 84;\nconst int K_N = 78;\nconst int K_M = 77;\nconst int K_C = 67;\nconst int K_I = 73;\nconst int K_X = 88;\nconst int K_Y = 89;\nconst int K_Z = 90;\n\nconst int K_SHIFT = 16;\nconst int K_CTRL = 17;\nconst int K_ALT = 18;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 O, in vec2 C ){\n\n    if(iFrame < 2 ){O = vec4(0);return;}\n    \n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){O = (sign(iMouse.z)>.0) ? iMouse : last;return;}\n    \n    if(ID(C_CAMERA)){\n        O = last;\n        bool isFreeCamera = bool(last.y);\n        if((getKeypress(K_NUM_0)||getKeypress(K_PAD_0)) && sign(iMouse.z)<=.0)O = vec4(0, 0, 0, 0);\n        if(getState(K_NUM_1)||getState(K_PAD_1))O = vec4(1, true, 0, 0);\n        if(getState(K_NUM_3)||getState(K_PAD_3))O = vec4(3, true, 0, 0);\n        if(getState(K_NUM_7)||getState(K_PAD_7))O = vec4(7, true, 0, 0);\n        return;}\n    \n    if(ID(C_CAM_SCALE)){\n        if(getState(K_W))last-=.01;\n        if(getState(K_S))last+=.01;\n        O = last;\n        return;}\n    \n    if(ID(C_TARGET_X)){\n        if(getState(K_X) &&  getState(K_ALT))last+=.01;\n        if(getState(K_X) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n        \n    if(ID(C_TARGET_Y)){\n        if(getState(K_Y) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Y) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n            \n    if(ID(C_TARGET_Z)){\n        if(getState(K_Z) &&  getState(K_ALT))last+=.01;\n        if(getState(K_Z) && !getState(K_ALT))last-=.01;\n        O = last;\n        return;}\n    if(ID(C_QUAD_VIEW))   {O = vec4(getToggle(K_Q));return;}\n    if(ID(C_TURN_TABLE))  {O = vec4(getToggle(K_T));return;}\n    if(ID(C_DEBUG_ISO))   {O = vec4(getToggle(K_I));return;}\n    if(ID(C_DEBUG_COST))  {O = vec4(getToggle(K_C));return;}\n    if(ID(C_DEBUG_MATCAP)){O = vec4(getToggle(K_M));return;}\n    if(ID(C_DEBUG_NORMAL)){O = vec4(getToggle(K_N));return;}\n    \n    // blank pixel\n    O = vec4(0,0,1,1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "/*\n  Pop! SDF\n*/\n\nfloat fOpUnionSmooth(float a,float b,float r){\n\tfloat h=max(r-abs(a-b),0.)/r;\n    return min(a,b)-h*h*h*r*(1./6.);\n}\n\nfloat sdCapsule(vec3 p, float h, float r){\n  p.y-=clamp(p.y,-h*.5,h*.5);\n  return length(p)-r;\n}\n\n#define USE_DODECAHEDRON 0\n// precalculated vertices of dodecahedron\n// not so efficient than I had guessed.\n// http://japla.sakura.ne.jp/workshop/symposium/2009/nishikawa_dec2009_1.pdf\nconst vec3[20] VCOORD = vec3[](\n    vec3(1.7013,0,2.22703),\n    vec3(0.525731,1.61803,2.22703),\n    vec3(-1.37638,1,2.22703),\n    vec3(-1.37638,-1,2.22703),\n    vec3(0.525731,-1.61803,2.22703),\n    vec3(2.75276,0,0.525731),\n    vec3(0.850651,2.61803,0.525731),\n    vec3(-2.22703,1.61803,0.525731),\n    vec3(-2.22703,-1.61803,0.525731),\n    vec3(0.850651,-2.61803,0.525731),\n    vec3(2.22703,-1.61803,-0.525731),\n    vec3(2.22703,1.61803,-0.525731),\n    vec3(-0.850651,2.61803,-0.525731),\n    vec3(-2.75276,0,-0.525731),\n    vec3(-0.850651,-2.61803,-0.525731),\n    vec3(1.37638,-1,-2.22703),\n    vec3(1.37638,1,-2.22703),\n    vec3(-0.525731,1.61803,-2.22703),\n    vec3(-1.7013,0,-2.22703),\n    vec3(-0.525731,-1.61803,-2.22703)\n);\n\n// \"SphericalFibonacci\" by EvilRyu:\n// https://www.shadertoy.com/view/dsjXDm\nconst float gNum = 8.;\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n// unoptimized version\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j){\n    float phi = 2. * PI * j * (2. / (3. - sqrt(5.)));\n    float theta = acos(1. - 2. * j / gNum);\n    return vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n}\n\nfloat sabs(float x,float k) {\n\tfloat a = (.5/k)*x*x+k*.5;\n\tfloat b = abs(x);\n\treturn b<k ? a : b;\n}\n\nfloat map(vec3 p){\n    // pop on every half sec.\n    float T = floor(iTime*7.);\n    \n    // random center\n    p+=(hash33(vec3(T))-.5)*.5;\n    \n    // deform space a little bit\n    p.y+=sin(p.x*1.+T)*.125;\n    p.y+=cos(p.z*1.-T)*.125;\n    \n    // center sphere\n    float d = length(p)-.4;\n    \n    for(float i = float(ZERO); i < gNum; i++){\n    \n        /*\n          main-pop\n        */\n        \n        // create vertices on sphere\n        #if USE_DODECAHEDRON\n        vec3 sp = VCOORD[int(i*2.)]*.33;\n        #else\n        vec3 sp = sphericalFibonacci(i+1.);\n        #endif\n        \n        // randomize cells\n        vec3 r = hash33(sp+T+i);\n        \n        // create cells\n        const float MAX_RADIUS = .5;\n        float distFromCenter = .2 + r.x*.15 + r.y*.15;\n        float cellRadius = max(.15,MAX_RADIUS-distFromCenter); // get more spherical look than just random.\n        cellRadius+=.2*r.z; // and break it just a little.\n        d = fOpUnionSmooth(length(p-sp*distFromCenter)-cellRadius, d, .01+distFromCenter*.05);\n        \n        /*\n          pop-out parts\n        */\n        \n        float dd = 1e3;\n        \n        //distance from center\n        float popOffset = max(.1,(2.*r.x*r.x-1.));\n        \n        if(r.x*r.y*r.z>.05){\n            vec3 q = p-sp*.8;\n            \n            // fit vectors of sub-pop to main-pop.\n            float yz = atan(sp.z,sp.y);\n            vec3 sq = sp;\n            R(sq.yz, yz);\n            float xy = atan(sq.y,sq.x)+PI*.5;\n            R(q.yz, yz);\n            R(q.xy, xy);\n            \n            // pop-out\n            q.y+=popOffset;\n            \n            R(q.xz, q.y*4.);\n            \n            // sub-pop at the tip\n            for(float j = float(ZERO); j < gNum; j+=1.){\n            \n                #if USE_DODECAHEDRON\n                vec3 ssp = VCOORD[int(j*2.)]*.33;\n                #else\n                vec3 ssp = sphericalFibonacci(j+1.);\n                #endif\n                \n                vec3 rr = hash33(ssp.xyz+T+vec2(i,j).xyx);\n                \n                if(int(j)%3<1){\n                    // sub-pop\n                    vec3 subPopCenter = q+vec3(0,.5*r.x,0);\n                    subPopCenter.z*=1.25;\n                    R(subPopCenter.yz, yz);\n                    R(subPopCenter.xy, xy);\n                    float subPopRadius = .01+.05*rr.x;\n                    dd = fOpUnionSmooth(length(subPopCenter-ssp*.3*rr) - subPopRadius, dd, .02*rr.y+.05);\n                }\n                else{\n                    // tiny splashing\n                    dd = fOpUnionSmooth(length(q+vec3((rr.x-.5)*.15,.2+(rr.y-.5)*.4,(rr.z-.5)*.15))-rr.y*.015, dd,.05);\n                }\n            }\n            // cylinders between main-pop and sub-pop\n            q.y-=popOffset*.5;\n            q.x = sabs(q.x, .015);\n            q.x-=.025*r.z;\n            float suji = sdCapsule(q, .5+popOffset, .02-.01*popOffset);\n            suji+=(.5+.5*sin(atan(q.z,q.x)*1.))*.02;\n            \n            // combine cylinders with sub-pop\n            dd = fOpUnionSmooth(dd, suji, .2);\n            \n            // combine it with main-pop\n            d = fOpUnionSmooth(dd, d,.1+.3*popOffset);\n        }\n        else{\n            // additional cells for main-pop\n            d = fOpUnionSmooth(length(p-sp*(.6+.2*r.z))-r.y*.05, d,.05);\n        }\n        \n    }\n    return d;\n}\n\nrender();\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}