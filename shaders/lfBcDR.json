{
    "Shader": {
        "info": {
            "date": "1726464978",
            "description": "Controls: WASD/Arrows: walk, Space: jump, Shift: sprint. Some stuff inspired by my Complementary Shaders settings and Mathis' way of ripping textures. It was going OK until I tried to shoehorn transparency in there",
            "flags": 48,
            "hasliked": 0,
            "id": "lfBcDR",
            "likes": 38,
            "name": "Minecraft Raytraced",
            "published": 3,
            "tags": [
                "minecraft"
            ],
            "usePreview": 1,
            "username": "KylBlz",
            "viewed": 720
        },
        "renderpass": [
            {
                "code": "// Ripped textures - thanks Mathis - https://www.shadertoy.com/view/ctV3WG\n// GGX BRDF - thanks XT95 - https://www.shadertoy.com/view/Dtl3WS\n// Voxel raymarch - thanks fb39ca4 - https://www.shadertoy.com/view/4dX3zl\n// ACES fitted - thanks Paniq - https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst float exposure = 1.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 channel0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.rgb = linear_srgb(ACESFitted(\n        exposure * channel0.rgb / floor(channel0.a)\n    ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Keyboard controls\n\nconst vec2 KEY_W \t = vec2(87.5 / 256.0, 0.0),\n    \t   KEY_S \t = vec2(83.5 / 256.0, 0.0),\n    \t   KEY_A \t = vec2(65.5 / 256.0, 0.0),\n    \t   KEY_D \t = vec2(68.5 / 256.0, 0.0),\n\t\t   KEY_LEFT  = vec2(37.5 / 256.0, 0.0),\n\t\t   KEY_UP    = vec2(38.5 / 256.0, 0.0),\n\t\t   KEY_RIGHT = vec2(39.5 / 256.0, 0.0),\n\t\t   KEY_DOWN  = vec2(40.5 / 256.0, 0.0),\n    \t   KEY_SHIFT = vec2(16.0 / 256.0, 0.0),\n    \t   KEY_SPACE = vec2(32.0 / 256.0, 0.0);\n\nvec4 getAcceleration() {\n    return vec4(\n        texture(iChannel1, KEY_D).x     - texture(iChannel1, KEY_A).x     + texture(iChannel1, KEY_RIGHT).x - texture(iChannel1, KEY_LEFT).x,\n        texture(iChannel1, KEY_SPACE).x,\n        texture(iChannel1, KEY_W).x     - texture(iChannel1, KEY_S).x     + texture(iChannel1, KEY_UP).x    - texture(iChannel1, KEY_DOWN).x,\n        texture(iChannel1, KEY_SHIFT).x\n    );\n}\n\nbool sampleVoxels(in sampler2D terr, in vec3 pos, in vec3 vel, out vec3 normal) {\n    vec3 prevPos = floor(pos);\n    vec3 mapPos = floor(pos + vel);\n    normal = vec3(prevPos - mapPos);\n    return bool(getVoxel(terr, mapPos, true).x);\n}\n\nvoid checkXZ(in sampler2D terr, in vec3 pos, inout vec3 vel) {\n    vec3 normal;\n    vec3 v2 = vel + (0.0625 * sign(vel));\n    // try to move then check voxels\n    if (sampleVoxels(terr, pos - vec3(0.0, 0.0, 0.0), vec3(v2.x, 0.0, 0.0), normal))\n        vel -= normal * dot(vel, normal);\n    if (sampleVoxels(terr, pos - vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, v2.z), normal))\n        vel -= normal * dot(vel, normal);\n    // Steve's height is 1.62 meters\n    if (sampleVoxels(terr, pos - vec3(0.0, 1.62, 0.0), vec3(v2.x, 0.0, 0.0), normal))\n        vel -= normal * dot(vel, normal);\n    if (sampleVoxels(terr, pos - vec3(0.0, 1.62, 0.0), vec3(0.0, 0.0, v2.z), normal))\n        vel -= normal * dot(vel, normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    if (fragCoord.y > 1.)\n        return;\n    \n    int a = int(fragCoord.x);\n    vec4 value = texelFetch(iChannel0, ivec2(a, 0), 0);\n    \n    // set initial values\n    if (iFrame == 0) {\n        if (a == lst_pos) {\n            value = init_pos;\n        } else if (a == cur_pos) {\n            value = init_pos;\n        } else if (a == lst_rot) {\n            value = init_rot;\n        } else if (a == cur_rot) {\n            value = init_rot;\n        } else if (a == lst_mou) {\n            value = init_mou;\n        } else if (a == cur_mou) {\n            value = init_mou;\n        } else if (a == cur_vel) {\n            value = init_vel;\n        }\n        fragColor = vec4(value);\n        return;\n    }\n    \n    updateScene(iFrame);\n    \n    if (a == lst_pos) {\n        value = texelFetch(iChannel0, px_cur_pos, 0);\n    \n    } else if (a == cur_pos) {\n        vec3 vel = texelFetch(iChannel0, px_cur_vel, 0).xyz;\n        // try to move then check voxels\n        checkXZ(iChannel2, value.xyz, vel);\n        // check y here\n        vec3 normal = vec3(0.0);\n        if (sampleVoxels(iChannel2, value.xyz - vec3(0.0, 0.0, 0.0), vec3(0.0, vel.y, 0.0), normal))\n            vel -= normal * dot(vel, normal);\n        if (sampleVoxels(iChannel2, value.xyz - vec3(0.0, 1.62, 0.0), vec3(0.0, vel.y, 0.0), normal))\n            vel -= normal * dot(vel, normal);\n        value.xyz += vel;\n        \n    } else if (a == lst_rot) {\n        value = texelFetch(iChannel0, px_cur_rot, 0);\n    \n    } else if (a == cur_rot && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = texelFetch(iChannel0, px_cur_mou, 0);\n        value.y = mouse.z - mouse.x + rot.y;\n        value.x = clamp(mouse.w - mouse.y + rot.x, -ieps * HPI, ieps * HPI);\n        \n    } else if (a == lst_mou) {\n        value = texelFetch(iChannel0, px_cur_mou, 0);\n    \n    } else if (a == cur_mou && iMouse.z < 0.) {\n        value = texelFetch(iChannel0, px_cur_rot, 0);\n    \n    } else if (a == cur_vel) {\n        // user input\n        float grav = -iTimeDelta * 0.5;\n        vec4 acc = getAcceleration();\n        if (dot(acc.xz, acc.xz) > 0.0) {\n            float rot = texelFetch(iChannel0, px_cur_rot, 0).y;\n            acc.xz = rotate2d(acc.xz, rot);\n            acc.xz = normalize(acc.xz) * iTimeDelta;\n        }\n        acc.xyz *= (1.0 + acc.w * vec3(0.5, 0.4, 0.5));\n        // check for voxel near feet\n        vec3 normal = vec3(0.0);\n        vec3 pos = texelFetch(iChannel0, px_cur_pos, 0).xyz;\n        bool onGround = sampleVoxels(iChannel2, pos - vec3(0.0, 1.62, 0.0), value.xyz, normal);\n        onGround = onGround && (normal.y > 0.5);\n        // friction and gravity\n        if (onGround) {\n            value.y = grav;\n            grav = 0.0;\n            value.xz *= 0.75;\n            // jump\n            if (acc.y > 0.0) {\n                value.y = 0.0;\n                acc.y *= 8.5 / 60.0;\n            }\n        } else {\n            // air friction\n            value.xz *= 0.98;\n            acc.y = 0.0;\n            acc.xz *= 0.125;\n        }\n        // velocity collision detection\n        value.xyz += acc.xyz + vec3(0.0, grav, 0.0);\n        checkXZ(iChannel2, pos, value.xyz);\n        \n    }\n    \n    fragColor = vec4(value);\n    return;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define SHADOWS\n#define USE_DFD_SMOOTH\n#define USE_PSC\n\n// math constants\nconst highp float\n    SQRT2 = 1.4142136, SC45 = 0.7071068, D2R = 0.0174533,\n    eps = 0.001, ieps = 0.999, epsCol = 0.0039062,\n    QTRPI = 0.7853981, HPI = 1.5707963, PI = 3.1415926, TWOPI = 6.2831853,\n    iQTRPI = 1.2732396, iHPI = 0.6366197, iPI = 0.3183098, iTWOPI = 0.1591549;\n\nconst highp float PHI1 = 1.0 - 1.0 / float(1.61803398);\nconst highp vec2  PHI2 = 1.0 - 1.0 / vec2(1.32471795, 1.32471795*1.32471795);\nconst highp vec3  PHI3 = 1.0 - 1.0 / vec3(1.22074408, 1.22074408*1.22074408, 1.22074408*1.22074408*1.22074408);\n\n// camera properties\nconst float\tznear = 0.03125, zfar = 512.0, FOV = 80.0;\nconst int MAX_RAY_STEPS = 512;\nconst int MAX_REFLECTION_STEPS = 64;\nconst int MAX_SHADOW_STEPS = 32;\nconst int TEMPORALSMOOTHING = 4;\n\n// user controller variable\nconst int lst_pos = 0;\nconst int cur_pos = 1;\nconst int lst_rot = 2;\nconst int cur_rot = 3;\nconst int lst_mou = 4;\nconst int cur_mou = 5;\nconst int cur_vel = 6;\n\n\n// storage register/texel addresses\nconst ivec2 px_lst_pos = ivec2(lst_pos, 0);\nconst ivec2 px_cur_pos = ivec2(cur_pos, 0);\nconst ivec2 px_lst_rot = ivec2(lst_rot, 0);\nconst ivec2 px_cur_rot = ivec2(cur_rot, 0);\nconst ivec2 px_lst_mou = ivec2(lst_mou, 0);\nconst ivec2 px_cur_mou = ivec2(cur_mou, 0);\nconst ivec2 px_cur_vel = ivec2(cur_vel, 0);\n\n// initial values\nconst vec4 init_pos = vec4(251.5, 96.5, 130.5, 1.0);\nconst vec4 init_rot = vec4( 0.1,-QTRPI, 0.0, 1.0);\nconst vec4 init_mou = vec4( 0.0,   0.0, 0.0, 1.0);\nconst vec4 init_vel = vec4( 0.0,   0.0, 0.0, 1.0);\n\n// thanks iradicator\nfloat dfSmooth(in vec2 fc, in float v) { \n    vec2 q = vec2(uvec2(fc.xy) & uvec2(1));\n    q = q * 2.0 - 1.0;    \n    v -= 0.5 * dFdx(v) * q.x;\n    v -= 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\n// generate a z order curveor each pixel/frame\nint genSeed(in int f, in ivec2 c) {\n    return (c.x + c.y*2 + f) + (c.x*1155 ^ c.y*2244);\n}\n\n// r2 low discrepancy sequence\nfloat r21(in int v) {\n    return fract(PHI1 * float(v));\n}\nvec2 r22(in int v) {\n    return fract(PHI2 * float(v));\n}\nvec3 r23(in int v) {\n    return fract(PHI3 * float(v));\n}\n\nfloat noise(in vec2 l) {\n    vec2 i = floor(l);\n    vec2 f = fract(l);\n    vec2 m = f * f * (3.0 - 2.0 * f);\n    \n    int seed = 1;\n    float r00 = r21(genSeed(seed, ivec2(i)               ));\n    float r01 = r21(genSeed(seed, ivec2(i) + ivec2(0, 1) ));\n    float r10 = r21(genSeed(seed, ivec2(i) + ivec2(1, 0) ));\n    float r11 = r21(genSeed(seed, ivec2(i) + ivec2(1, 1) ));\n    \n    return mix(mix(r00, r10, f.x), mix(r01, r11, f.x), f.y) - 0.5;\n}\n\nfloat fbm(in vec2 l, const int oct) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    vec2 shift = vec2(100.0);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n\n    for (int i = 0; i < oct; ++i) {\n        value += amplitude * noise(l);\n        l = rot * l * 2.0 + shift;\n        amplitude *= 0.5;\n    }\n\n    return value;\n}\n\n// orthonormal basis assuming up is +y\nmat3 basisUp(in vec3 forward) {\n    vec3 down = vec3(0.0, -1.0, 0.0);\n    vec3 right = normalize(cross(forward, down));\n    return mat3(right, normalize(cross(forward, right)), forward);\n}\n\n// orthonormal basis at normal\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float s = (n.z >= 0.0)? 1.0: -1.0;\n    float a = 1.0 / (s + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1.0 - n.x*n.x*a*s, b*s, -n.x*s);\n    r = vec3(b, s - n.y*n.y*a, -n.y);\n}\n\nvec2 rotate2d(in vec2 v, in float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n// concentric mapping square [0,1] to circle [-1,1]\nvec2 concentric(in vec2 v) {\n    vec2 w = v * 2.0 - 1.0;\n    float thta, rad;\n    if (abs(w.x) > abs(w.y)) {\n        rad = w.x;\n        thta = QTRPI * (w.y/w.x);\n    } else {\n        rad = w.y;\n        thta = HPI - QTRPI * (w.x/w.y);\n    }\n    return rad * vec2(cos(thta), sin(thta));\n}\n\n// uniform sample cone\nvec3 uniformConeDir(vec3 lv, float lr, in vec2 rng) {\n    // cone section\n    float b = length(lv);\n    float sa = lr / sqrt(b*b - lr*lr);\n    vec3 u, r, nlv = normalize(lv);\n    basis(nlv, r, u);\n    return normalize(nlv + sa * (r * rng.x + u * rng.y));\n}\n\nmat4 psc_precomp(in vec3 l, in vec3 n, in vec4 s) {\n    mat4 ret = mat4(0.0);\n    \n    vec3 sl = s.xyz - l.xyz;\n    // +y is normal vec\n    float Y = dot(sl, n);\n    vec3 Ybasis = n;\n    // +x is plane tangent vec towards light\n    vec3 Xbasis = sl - Y * Ybasis;\n    float X = max(eps, sqrt(dot(Xbasis, Xbasis)));\n    Xbasis /= X;\n    // by definition Z is zero\n    vec3 Zbasis = cross(Xbasis, Ybasis);\n    // distance to light\n    float d = 1.0 / sqrt(X*X + Y*Y);\n    // light direction and size on unit circle\n    vec3 sln = sl * d;\n    float swn = s.w * d;\n    float pdf = PI * swn * swn;\n    // angle to light +/- half angle\n    float va = asin(clamp(swn, eps, ieps));\n    float vi = atan(Y / X);\n    // x range on unit disk\n    float x1 = cos(clamp(vi - va, eps, PI));\n    float x2 = cos(clamp(vi + va, eps, PI));\n    float xr = x1 - x2;\n    // one dimension simplifies away\n    vi = PI * 0.5;\n    // z range on unit disk\n    float y1 = cos(clamp(vi - va, eps, PI));\n    float y2 = cos(clamp(vi + va, eps, PI));\n    float yr = y1 - y2;\n\n    ret[0] = vec4(Xbasis, X);\n    ret[1] = vec4(Ybasis, Y);\n    ret[2] = vec4(Zbasis, pdf * (xr/yr));\n    ret[3] = vec4(xr, yr, x2, y2);\n    return ret;\n}\n\nvec4 psc(mat4 precomp, in vec2 rng) {\n    // disk in range [0, 1]\n    vec2 cw2 = rng * 0.5 + 0.5;\n    // in range [xz1 to xz2]\n    cw2 = cw2 * precomp[3].xy + precomp[3].zw;\n    // project up onto unit circle\n    vec3 pc3 = vec3(cw2.x, sqrt(max(eps, 1.0 - cw2.x*cw2.x - cw2.y*cw2.y)), cw2.y);\n    return vec4(\n        // back to world space using basis vecs\n        mat3(precomp) * pc3,\n        // pdf from earlier\n        precomp[2].w\n    );\n}\n\n// thanks XT95 https://www.shadertoy.com/view/Dtl3WS\nfloat F_Schlick(float f0, float f90, float theta) {\n    return f0 + (f90 - f0) * pow(1.0 - theta, 5.0);\n}\n\nfloat D_GTR(float roughness, float NoH, float k) {\n    float a2 = roughness*roughness;\n    return a2 / (PI * pow(NoH*NoH * (a2*a2 - 1.0) + 1.0, k));\n}\n\nfloat G_Smith(float NoV, float roughness2) {\n    float b = NoV*NoV;\n    float a = roughness2*roughness2;\n    return 2.0 * NoV / (NoV + sqrt(a+b - a*b));\n}\n\nfloat GeometryTerm(float NoL, float NoV, float roughness) {\n    float a2 = roughness*roughness;\n    float G1 = G_Smith(NoV, a2);\n    float G2 = G_Smith(NoL, a2);\n    return G1*G2;\n}\n\nfloat ggxDiffuse(float NoL, float NoV, float LoH, float roughness) {\n    float FD90 = 0.5 + 2.0 * roughness * LoH*LoH;\n    float a = F_Schlick(1.0, FD90, NoL);\n    float b = F_Schlick(1.0, FD90, NoV);\n    return a * b / PI;\n}\n\nfloat ggxSpecular(float roughness, float NoH, float NoV, float NoL) {\n    float alpha = roughness*roughness;\n    float D = D_GTR(alpha, NoH, 2.0);\n    float beta = 0.5 + roughness * 0.5;\n    float G = GeometryTerm(NoL, NoV, beta*beta);\n    return D * G / (4.0 * NoL * NoV);\n}\n\n// fast orthogonal matrix inverse\nmat4 orthoInverse(in mat4 m) {\n    mat3 r = transpose(mat3(m));\n    return mat4(\n        vec4(r[0], 0.0),\n        vec4(r[1], 0.0),\n        vec4(r[2], 0.0),\n        vec4(r * -m[3].xyz, 1.0)\n    );\n}\n\n// construct 4x4 view mat from camera origin, forward direction\nmat4 viewMat(in vec3 origin, in vec3 direction) {\n    mat3 bas = basisUp(direction);\n    return mat4(\n        vec4(bas[0], 0.0),\n        vec4(bas[1], 0.0),\n        vec4(bas[2], 0.0),\n        vec4(origin, 1.0)\n    );\n}\n\n// construct 4x4 projection mat using offaxis parameters, aspect ratio, global FOV\nmat4 projectionMat(in vec2 offaxis, in float aspect, in float fov) {\n    // proj parameters\n    float f = zfar;\n    float n = znear;\n    float fovrad = fov * D2R;\n    float r =  n * aspect * tan(0.5 * (fovrad - offaxis.x));\n    float l = -n * aspect * tan(0.5 * (fovrad + offaxis.x));\n    float t =  n          * tan(0.5 * (fovrad - offaxis.y));\n    float b = -n          * tan(0.5 * (fovrad + offaxis.y));\n    // construct proj mat\n    return mat4(\n        2.0*n/(r-l),         0.0, (r+l)/(r-l),           0.0,\n                0.0, 2.0*n/(t-b), (t+b)/(t-b),           0.0,\n                0.0,         0.0, (f+n)/(f-n), 2.0*f*n/(f-n),\n                0.0,         0.0,         1.0,           0.0\n    );\n}\n\n// project the pixel at ndc into a worldspace ray\nvoid getCameraRay(in mat4 view, in mat4 proj, in vec2 ndc, out vec3 ro, out vec3 rd) {\n    ro = view[3].xyz;\n    vec4 ndch = transpose(inverse(proj)) * vec4(ndc, 1.0, 1.0);\n    rd = normalize(mat3(view) * vec3(ndch.xy, 1.0));\n}\n\n// project a worldspace location hl into camera NDC using its view projection\nvec3 reprojCoordsNDC(in mat4 view, in mat4 proj, in vec3 hl) {\n    vec4 camspace = orthoInverse(view) * vec4(hl, 1.0);\n    vec4 ndch = camspace * proj;\n    return vec3(ndch.xy / ndch.w, length(camspace));\n}\n\n// 3D reproject given image, distance, pixel location (see reprojCoordsNDC)\nvec4 reprojectBuffer(in sampler2D iChannel, in ivec2 iChanRes, in float dist, in vec2 fc) {\n    ivec2 ifc = ivec2(fc);\n    // bound check\n    if (any( lessThan( ifc, ivec2(0) )) || any( greaterThan( ifc, iChanRes - 1)))\n        return vec4(0.0, 0.0, 0.0, dist);\n    // get the 4 neighboring pixel values\n    vec4 b   = texelFetch(iChannel, ifc,               0);\n    vec4 bx  = texelFetch(iChannel, ifc + ivec2(1, 0), 0);\n    vec4 by  = texelFetch(iChannel, ifc + ivec2(0, 1), 0);\n    vec4 bxy = texelFetch(iChannel, ifc + ivec2(1, 1), 0);\n    // depth match filter\n    float has   = float(abs(fract(b.a  ) - dist) * zfar < 1.4142 + dist * 5.0);\n    float hasx  = float(abs(fract(bx.a ) - dist) * zfar < 1.4142 + dist * 5.0);\n    float hasy  = float(abs(fract(by.a ) - dist) * zfar < 1.4142 + dist * 5.0);\n    float hasxy = float(abs(fract(bxy.a) - dist) * zfar < 1.4142 + dist * 5.0);\n    float ttl = has + hasx + hasy + hasxy;\n    if (ttl < 0.5)\n        return vec4(0.0, 0.0, 0.0, dist);\n    if (ttl > 3.5) {\n        // fancy bilinear interpolation\n        vec2 a = fc - floor(fc);\n        return max(vec4(eps), mix(mix(b, bx, a.x), mix(by, bxy, a.x), a.y));\n    }\n    // last resort interp\n    vec4 sum = b*has + bx*hasx + by*hasy + bxy*hasxy;\n    return max(vec4(eps), sum / max(1.0, ttl));\n}\n\n// Thanks Paniq\nvec3 linear_srgb(in vec3 x) {\n    return mix(1.055*pow(x, vec3(1./2.4)) - 0.055, 12.92*x, step(x, vec3(0.0031308)));\n}\n\nvec3 srgb_linear(in vec3 x) {\n    return mix(pow((x + 0.055)/1.055,vec3(2.4)), x / 12.92, step(x, vec3(0.04045)));\n}\n\n// Paniq's ACES fitted from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nvec3 ACESFitted(in vec3 color) {\n    // ODT_SAT => XYZ => D60_2_D65 => sRGB\n    color = color * mat3(\n        0.59719, 0.35458, 0.04823,\n        0.07600, 0.90834, 0.01566,\n        0.02840, 0.13383, 0.83777\n    );\n    // Apply RRT and ODT\n    vec3 a = color * (color + 0.0245786) - 0.000090537;\n    vec3 b = color * (0.983729 * color + 0.4329510) + 0.238081;\n    color = a / b;\n    // Back to color space\n    color = color * mat3(\n         1.60475, -0.53108, -0.07367,\n        -0.10208,  1.10813, -0.00605,\n        -0.00327, -0.07276,  1.07602\n    );\n    // Clamp to [0, 1]\n    return clamp(color, 0.0, 1.0);\n}\n\nvec2 sdMin(in vec2 a, in vec2 b) {\n    return (a.x < b.x)? a: b;\n}\n\nfloat sdSphere(vec3 p, float d) {\n    return length(p) - d;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// global sun light\nvec3 sunDir = normalize(vec3(-1.0, 0.0, 0.0));\nvec3 sunCol = vec3(11.0, 8.0, 6.0) * 0.25;\n\nconst float mat_air = 0.0;\nconst float mat_log = 1.0;\nconst float mat_leaves = 2.0;\nconst float mat_water = 3.0;\nconst float mat_grass = 4.0;\nconst float mat_sand = 5.0;\n\nvec3 skyCol(in vec3 rd, in float doSun, float time, in sampler2D iChannel) {\n    vec3 col1 = pow(vec3(1.83, 2.10, 2.45) * 0.41, vec3(4.4));\n    vec3 col2 = pow(vec3(1.28, 1.74, 2.50) * 0.41, vec3(4.4));\n    vec3 sun = smoothstep(0.999, 1.0, max(0.0, dot(rd, sunDir))) * sunCol * doSun;\n    // cloud layers as of 1.8\n    vec4 smp1 = texture(iChannel, rd.xz / (rd.y * 128.0) + vec2(0.5 + time * -0.0001, 0.5), 0.0);\n    col2 += step(fract(smp1.a + smp1.r * 0.03), 0.5) * rd.y * step(0.0, rd.y);\n    vec4 smp2 = texture(iChannel, rd.xz / (rd.y * 132.0) + vec2(0.5 + time * -0.0001, 0.5), 0.0);\n    col2 += step(fract(smp2.a + smp2.r * 0.03), 0.5) * rd.y * step(0.0, rd.y);\n    return sun + mix(col1, col2, sqrt(max(eps, rd.y)));\n}\n\nvoid updateScene(in int iFrame) {\n    // in Minecraft -Z is north, meaning that the sun should rise in +x and set in -x\n    sunDir.xy = rotate2d(sunDir.xy, float(iFrame + 5000) * -0.0001);\n}\n\nivec2 getVoxel(in sampler2D t, in vec3 c, in bool doWater) {\n    vec2 d = vec2(zfar, mat_air);\n    \n    // sample terrain properties\n    vec4 htps = texelFetch(t, ivec2(c.xz), 0);\n    float height = c.y - htps.x;\n    \n    // grass unless hot, then sand, if close to the water then beach\n    d = sdMin(d, vec2(height, (htps.y > 0.25)? mat_sand: (floor(c.y) < 64.0 + htps.y * 16.0)? mat_sand: mat_grass));\n    if (doWater)\n        d = sdMin(d, vec2( c.y - 63.01, mat_water));\n    \n    // tree rng every chunk\n    ivec2 cq = ivec2(c.xz * 0.125);\n    int treeSeed = genSeed(11, cq);\n    float rng = r21(treeSeed);\n    vec3 tbl = fract(c * 0.125) * 8.0 - 4.0;\n    vec4 tree_htps = texelFetch(t, cq * 8, 0);\n    float tree_height = c.y - tree_htps.x;\n    tbl.y = (tree_height + height) * 0.5;\n    \n    if (tree_height + 65.0 < c.y && rng > 1.25 + tree_htps.z) {\n    \n        // how lush are we talking\n        float lush = htps.z - htps.y;\n        float treeHeight = 1.0 + (rng * 2.0 + lush) * 3.0;\n        float treeWidth = 0.5 + treeHeight * 0.04;\n        // old growth?\n        float oldgrowth = step(0.75, treeWidth);\n        treeHeight += oldgrowth * 4.0;\n        \n        d = sdMin(d, vec2(sdSphere((tbl - vec3(0.0, treeHeight, 0.0)) * vec3(1.0, 2.0, 1.0), 3.5 + oldgrowth), mat_leaves));\n        d = sdMin(d, vec2(sdBox(tbl + 0.25, vec3(treeWidth, treeHeight, treeWidth)), mat_log));\n    }\n    return (d.x < 0.0)? ivec2(1, int(d.y)): ivec2(0, int(mat_air));\n}\n\n// thanks fb39ca4 https://www.shadertoy.com/view/4dX3zl\nvoid voxelRaymarch(in sampler2D terr, in vec3 rayPos, in vec3 rayDir, const bool doWater, const int MAX_STEPS, out float t, out float mat, out vec3 normal, out vec3 hitloc) {\n    vec3 mp = floor(rayPos);\n    vec3 rayStep = sign(rayDir);\n    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    vec3 sideDist = (rayStep * (mp - rayPos) + rayStep * 0.5 + 0.5) * deltaDist; \n    vec3 mask;\n    \n    mat = mat_air;\n    t = zfar;\n    normal = vec3(0.0);\n    hitloc = rayPos + rayDir * t;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        ivec2 vox = getVoxel(terr, mp, doWater);\n        if (vox.x == 1) {\n            // there's probably a better way\n            normal = mask * -rayStep;\n            t = dot(sideDist - deltaDist, mask);\n            hitloc = rayPos + rayDir * t;\n            mat = float(vox.y);\n            return;\n        }\n        // Thanks kzy for the suggestion!\n        mask = vec3(lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)));\n        // All components of mask are false except for the corresponding largest component of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n        sideDist += mask * deltaDist;\n        mp += mask * rayStep;\n    }\n}\n\nfloat getAO(in sampler2D terr, in vec3 hitPos, in vec3 normal) {\n    vec3 basis = 1.0 - abs(normal);\n    vec3 mapos = floor(hitPos - normal * 0.5) + 0.5;\n    vec3 diff = (hitPos - mapos) * basis;\n    vec3 absdiff = abs(diff);\n    // two potential closest walls\n    vec3 maxcomp = vec3(greaterThanEqual(absdiff.xyz, max(absdiff.yzx, absdiff.zxy)));\n    vec3 diff1stmax = diff * maxcomp;\n    vec3 diff2ndmax = diff * (1.0 - maxcomp);\n    // sample 3 voxels\n    vec3 nd1m = normalize(diff1stmax);\n    vec3 nd2m = normalize(diff2ndmax);\n    vec3 nd3m = nd1m + nd2m;\n    bool occupied0 = bool(getVoxel(terr, vec3( floor(mapos + normal + nd1m) ), false).x);\n    bool occupied1 = bool(getVoxel(terr, vec3( floor(mapos + normal + nd2m) ), false).x);\n    bool occupied2 = bool(getVoxel(terr, vec3( floor(mapos + normal + nd3m) ), false).x);\n    // distance functions of occupied voxels\n    diff1stmax = abs(diff1stmax);\n    diff2ndmax = abs(diff2ndmax);\n    float occlu0 = float(occupied0) * max(diff1stmax.x, max(diff1stmax.y, diff1stmax.z));\n    float occlu1 = float(occupied1) * max(diff2ndmax.x, max(diff2ndmax.y, diff2ndmax.z));\n    float occlu2 = float(occupied2 && !occupied0 && !occupied1) * (0.5 - distance(hitPos * basis, (mapos + nd3m * 0.5) * basis));\n    // occlude up to 3/4 hemisphere\n    return 1.0 - min(ieps, (occlu0 + occlu1 + occlu2));\n}\n\nfloat sampleLight(in sampler2D terr, in vec3 hitloc, in vec3 lv) {\n\n#ifdef SHADOWS\n    float t;\n    float mat;\n    vec3 normal, hitloc2;\n    voxelRaymarch(terr, hitloc, lv, false, MAX_SHADOW_STEPS, t, mat, normal, hitloc2);\n#else\n    float t = zfar;\n#endif\n    return t;\n}\n\nvec3 shade_ggx(in sampler2D terr, in vec2 fc, in vec3 diffCol, in vec3 specCol, in vec3 rayPos, in vec3 rayDir, in vec3 hitloc, in float t, in vec3 normal, in vec3 light, in vec3 litCol, in vec3 rflcol, in vec2 rng, in float rough) {\n    vec3 ll = hitloc + light * 128.0;\n    vec3 quant = (0.5 + floor(hitloc * 16.0)) * 0.0625;\n\n#ifdef USE_PSC\n    mat4 precomp = psc_precomp(quant, normal, vec4(ll, TWOPI));\n    vec4 pscsmp = psc(precomp, rng);\n    vec3 lv = pscsmp.xyz;\n#else\n    // really sampling a sphere inside the voxel\n    vec3 lv = ll - quant;\n    lv = uniformConeDir(lv, 0.125, rng);\n#endif\n\n    // sample light\n    float dnl = max(0.0, dot(normal, lv));\n    float dnv = max(0.0, dot(normal, -rayDir));\n    float smp = sampleLight(terr, quant, lv);\n    \n#ifdef USE_DFD_SMOOTH\n    bool shouldSmooth = dot(vec3(dfSmooth(fc, normal.x), dfSmooth(fc, normal.y), dfSmooth(fc, normal.z)), normal) > 0.99;\n#endif\n\n    // decide to shade\n    float diff = 0.0;\n    float spec = 0.0;\n    if (dnl > 0.0) {\n    \n        // light stuff\n        vec3 hv = normalize(lv - rayDir);\n        float dnh = dot(normal, hv);\n        float dlh = dot(lv, hv);\n        float hitlit = float(smp >= zfar);\n#ifdef USE_PSC\n        hitlit *= pscsmp.w * 127.0;\n#endif\n        // value sharing\n#ifdef USE_DFD_SMOOTH\n        if (shouldSmooth) {\n            hitlit = dfSmooth(fc, hitlit);\n        }\n#endif\n        // ggx\n        diff = ggxDiffuse(dnl, dnv, dlh, rough) * hitlit;\n        spec = ggxSpecular(rough, dnh, dnv, dnl) * hitlit;\n    }\n    \n    // base ambient\n    float amb = 0.2 * max(0.2, dot(normal, normalize(ll * vec3(0.5, 1.0, -0.5) - 10.0)));\n    // ambient occlusion per screen pixel\n    float ao = getAO(terr, hitloc, normal);\n    // reflection\n    float refl = F_Schlick(0.25, 1.0, dnv);\n\n#ifdef USE_DFD_SMOOTH\n    if (shouldSmooth) {\n        rflcol.r = dfSmooth(fc, rflcol.r);\n        rflcol.g = dfSmooth(fc, rflcol.g);\n        rflcol.b = dfSmooth(fc, rflcol.b);\n    }\n#endif\n    \n    // integrate, clamping spec is biased\n    vec3 color = (amb + diff) * diffCol;\n    color += min(vec3(1.0), spec * specCol);\n    color *= litCol * ao;\n    color += min(vec3(1.0), refl * rflcol * diffCol);\n    return max(vec3(eps), color);\n}\n\n// Textures, thanks Mathis https://www.shadertoy.com/view/ctV3WG\nconst lowp vec4 TexLog[256] = vec4[256](vec4(0.36,0.29,0.18,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.39,0.30,0.18,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.21,0.16,0.09,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.39,0.31,0.18,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.22,0.17,0.10,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.59,0.46,0.28,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.57,0.44,0.26,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.39,0.31,0.18,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.36,0.29,0.18,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.43,0.34,0.21,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.38,0.30,0.17,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.61,0.48,0.30,1.0),vec4(0.22,0.17,0.10,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.22,0.17,0.09,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.21,0.16,0.09,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.39,0.31,0.18,1.0),vec4(0.59,0.46,0.28,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.38,0.30,0.17,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.43,0.35,0.22,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.21,0.16,0.09,1.0),vec4(0.36,0.29,0.18,1.0),vec4(0.61,0.49,0.30,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.59,0.46,0.28,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.60,0.48,0.29,1.0),vec4(0.27,0.21,0.14,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.58,0.46,0.27,1.0),vec4(0.22,0.17,0.10,1.0),vec4(0.39,0.30,0.18,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.36,0.29,0.18,1.0),vec4(0.62,0.49,0.31,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.60,0.48,0.29,1.0),vec4(0.26,0.21,0.13,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.61,0.48,0.30,1.0),vec4(0.27,0.22,0.14,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.22,0.17,0.09,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.6,0.47,0.29,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.43,0.35,0.22,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.57,0.45,0.26,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.60,0.48,0.29,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.6,0.47,0.29,1.0),vec4(0.22,0.17,0.10,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.43,0.34,0.21,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.59,0.46,0.28,1.0),vec4(0.38,0.30,0.17,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.56,0.44,0.25,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.34,0.27,0.17,1.0),vec4(0.21,0.16,0.09,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.43,0.34,0.21,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.36,0.29,0.18,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.56,0.43,0.25,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.43,0.34,0.21,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.41,0.33,0.20,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.27,0.21,0.14,1.0),vec4(0.38,0.30,0.17,1.0),vec4(0.25,0.2,0.12,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.61,0.48,0.30,1.0),vec4(0.25,0.20,0.13,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.22,0.17,0.10,1.0),vec4(0.36,0.29,0.18,1.0),vec4(0.39,0.30,0.18,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.6,0.47,0.29,1.0),vec4(0.24,0.19,0.11,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.23,0.18,0.10,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.6,0.47,0.29,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.39,0.31,0.18,1.0),vec4(0.43,0.35,0.22,1.0),vec4(0.21,0.16,0.09,1.0),vec4(0.24,0.19,0.12,1.0),vec4(0.59,0.47,0.28,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.6,0.47,0.29,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.60,0.47,0.29,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.29,0.23,0.14,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.27,0.22,0.14,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.60,0.48,0.29,1.0),vec4(0.23,0.18,0.11,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.58,0.45,0.27,1.0),vec4(0.25,0.20,0.12,1.0),vec4(0.4,0.31,0.18,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.40,0.32,0.19,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.42,0.34,0.21,1.0),vec4(0.48,0.38,0.24,1.0),vec4(0.41,0.32,0.2,1.0),vec4(0.61,0.48,0.30,1.0));\nconst lowp vec4 TexLeaves[256] = vec4[256](vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.06,0.43,0.17,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.07,0.56,0.22,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.05,0.37,0.15,1.0),vec4(0.06,0.43,0.17,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.00,0.00,0.00,0.0),vec4(0.09,0.69,0.27,1.0),vec4(0.00,0.00,0.00,0.0),vec4(0.07,0.56,0.22,1.0));\nconst lowp vec4 TexSand[256] = vec4[256](vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.93,0.92,0.80,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.93,0.92,0.80,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.93,0.92,0.80,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.91,0.89,0.73,1.0),vec4(0.93,0.92,0.80,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.93,0.92,0.80,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.82,0.73,0.54,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.84,0.77,0.59,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0),vec4(0.89,0.86,0.69,1.0),vec4(0.85,0.81,0.64,1.0));\nconst lowp vec4 TexGrass[256] = vec4[256](vec4(0.32,0.48,0.27,1.0),vec4(0.27,0.41,0.24,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.26,0.40,0.23,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.27,0.41,0.24,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.30,0.45,0.26,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.30,0.45,0.26,1.0),vec4(0.33,0.51,0.29,1.0),vec4(0.24,0.37,0.21,1.0),vec4(0.30,0.45,0.26,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.26,0.40,0.23,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.27,0.41,0.24,1.0),vec4(0.33,0.51,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.24,0.37,0.21,1.0),vec4(0.33,0.51,0.29,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.27,0.42,0.24,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.26,0.40,0.23,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.26,0.40,0.23,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.33,0.51,0.29,1.0),vec4(0.25,0.38,0.22,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.27,0.41,0.24,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.32,0.48,0.27,1.0),vec4(0.30,0.45,0.26,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.32,0.49,0.28,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.22,0.34,0.19,1.0),vec4(0.28,0.43,0.24,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.42,0.42,0.42,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.27,0.41,0.24,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.24,0.36,0.21,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.26,0.40,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.42,0.42,0.42,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.53,0.53,0.53,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.53,0.53,0.53,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.42,0.42,0.42,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.45,0.35,0.27,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.73,0.52,0.36,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.53,0.53,0.53,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.59,0.42,0.29,1.0),vec4(0.47,0.33,0.23,1.0),vec4(0.35,0.24,0.16,1.0));\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Rendering\n\nvec3 biomeColor(in vec4 htps) {\n    // lush (sparse jungle)\n    vec3 lush = vec3(0.35, 0.79, 0.24);\n    // dry (savannah)\n    vec3 dry = vec3(0.75, 0.72, 0.33);\n    // cold (taiga)\n    vec3 cold = vec3(0.53, 0.72, 0.51);\n\n    return mix(cold, mix(dry, lush, clamp(htps.z, -0.25, 1.25)), clamp(htps.y, -0.25, 1.25));\n}\n\nfloat doSnow(in vec4 htps) {\n    // sprinkle in some snowy pixels in cold biomes\n    return clamp(1.0 - smoothstep(-0.8, -0.5, htps.y), 0.0, 1.0);\n}\n\nvoid textureMap(in float mat, in vec3 hitloc, in vec3 normal, out vec3 diffCol, out vec3 specCol, out float rough, out float alpha) {\n    \n    // mapping\n    mat3 rot = mat3(vec3(0.0), normal.xyz, vec3(0.0));\n    basis(rot[1], rot[0], rot[2]);\n    vec2 plnpos = fract(hitloc * rot).xz;\n    plnpos.y = (normal.z < 0.0)? plnpos.y: 1.0 - plnpos.y;\n    \n    // textures\n    ivec2 iUV = ivec2(plnpos * 16.0);\n    int Index = (iUV.x % 16) + (iUV.y * 16);\n    \n    if (mat == mat_sand) {\n        \n        diffCol = clamp(TexSand[Index].rgb - TexSand[0].rrr * 0.3, vec3(0.0), vec3(1.0));\n        specCol = diffCol * diffCol * 2.0;\n        rough = 1.0 - specCol.r * 0.25;\n        alpha = 1.0;\n        \n    } else if (mat == mat_grass) {\n        \n        // biome info\n        vec4 htps = texelFetch(iChannel2, ivec2(hitloc.xz), 0);\n        vec3 finalCol = biomeColor(htps);\n        \n        // do snow\n        float snowy = doSnow(htps);\n        float n = r21(genSeed(1, -iUV)) * 0.2 + 0.8;\n        finalCol = max(finalCol, step(n, snowy) * 1.414);\n        \n        if (normal.y > eps) {\n            // top of grass block\n            diffCol = clamp(finalCol * TexSand[Index].bbb - TexGrass[0].ggg * 0.2, vec3(0.0), vec3(1.0));\n            specCol = diffCol * diffCol;\n            rough = 1.0 - specCol.r * 0.25;\n            alpha = 1.0;\n       } else {\n            diffCol = clamp(TexGrass[Index].rgb - TexGrass[0].ggg * 0.1, vec3(0.0), vec3(1.0));\n            if (diffCol.g > diffCol.r) {\n                // grass pixel\n                diffCol = diffCol.ggg * (normalize(finalCol) * 1.414 + step(n, snowy));\n                specCol = diffCol * diffCol;\n                rough = 1.0 - diffCol.g * 0.5;\n                alpha = 1.0;\n            } else {\n                // dirt pixel\n                diffCol = mix(diffCol, diffCol * vec3(0.8, 0.9, 1.0), snowy);\n                specCol = diffCol * diffCol;\n                rough = 1.0 - diffCol.b * 0.75;\n                alpha = 1.0;\n            }\n        }\n        \n    } else if (mat == mat_log) {\n        \n        diffCol = clamp(TexLog[Index].rgb - TexLog[0].rrr * 0.1, vec3(0.0), vec3(1.0));\n        specCol = diffCol * diffCol;\n        rough = 1.0 - diffCol.r * 0.5;\n        alpha = 1.0;\n        \n    } else if (mat == mat_leaves) {\n        \n        // biome info\n        vec4 htps = texelFetch(iChannel2, ivec2(hitloc.xz), 0);\n        vec3 finalCol = biomeColor(htps);\n        \n        // sprinkle in some snowy pixels\n        float n = r21(genSeed(1, -iUV)) * 0.2 + 0.8;\n        float snowy = clamp(0.98 - smoothstep(-0.8, -0.6, htps.y - normal.y * 0.05), 0.0, 1.0);\n        \n        vec4 tex = TexLeaves[Index];\n        diffCol = clamp(tex.ggg * max(normalize(finalCol), step(n, snowy) * 1.5), vec3(0.0), vec3(1.0));\n        specCol = diffCol * diffCol * 2.0;\n        rough = 1.0 - diffCol.g * 0.25;\n        alpha = tex.a;\n        \n    } else if (mat == mat_water) {\n        \n        diffCol = pow(vec3(1.28, 1.74, 2.50) * 0.41, vec3(3.3));\n        specCol = vec3(1.0);\n        rough = eps;\n        alpha = 0.5;\n        \n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // random numbers\n    int seed = genSeed(iFrame, ivec2(fragCoord));\n    vec2 rng = concentric(r22(seed) * ieps);\n    \n    // get input, calc camera\n    vec4 curpos = texelFetch(iChannel0, px_cur_pos, 0);\n\tvec4 currot = texelFetch(iChannel0, px_cur_rot, 0);\n    vec3 camfwd = vec3(0.0, 0.0, 1.0);\n    camfwd.yz = rotate2d(camfwd.yz, currot.x);\n    camfwd.xz = rotate2d(camfwd.xz, currot.y);\n    // camera view proj matrices\n    mat4 view = viewMat(curpos.xyz, camfwd);\n    mat4 proj = projectionMat(vec2(0.0), iResolution.x / iResolution.y, FOV);\n    // get pixel ray to trace\n    vec2 uv = (fragCoord.xy + rng * 0.1) / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    vec3 ro, rd;\n    getCameraRay(view, proj, ndc, ro, rd);\n    \n    // main voxel ray march\n    float t;\n    float m;\n    vec3 normal, hitloc;\n    voxelRaymarch(iChannel2, ro, rd, true, MAX_RAY_STEPS, t, m, normal, hitloc);\n    \n    // get sky now, use for fog later\n    updateScene(iFrame);\n    vec3 sky = skyCol(rd, 0.5, iTime, iChannel2);\n    float nz = (t / float(MAX_RAY_STEPS)) * ieps;\n    \n    // main hit sky\n    if (t >= zfar) {\n        fragColor = vec4(sky, 1.0);\n        return;\n    }\n    \n    // main material properties\n    vec3 diffCol = vec3(0.0);\n    vec3 specCol = vec3(0.0);\n    float rough = 0.0;\n    float alpha = 0.0;\n    textureMap(m, hitloc, normal, diffCol, specCol, rough, alpha);\n\n    vec3 rd2 = vec3(0.0);\n    if (alpha < 1.0) {\n        // check fresnel for reflect or refract (glass, water)\n        float sch = F_Schlick(0.5, eps, dot(normal, -rd));\n        if (alpha * (rng.x * 0.5 + 0.5) < sch) {\n            if (m == mat_leaves)\n                hitloc += rd * ieps;\n            rd2 = rd;\n        } else {\n            rd2 = reflect(rd, normal);\n            rd2 = uniformConeDir(rd2, rough * sch, rng);\n        }\n    } else {\n        // reflection sharpness based on roughness and Schlick\n        float sch = F_Schlick(0.5, eps, dot(normal, -rd));\n        rd2 = reflect(rd, normal);\n        rd2 = uniformConeDir(rd2, rough * sch, rng);\n    }\n\n    // second ray march\n    float t2;\n    float m2;\n    vec3 normal2, hitloc2;\n    voxelRaymarch(iChannel2, hitloc + rd2 * eps, rd2, false, MAX_REFLECTION_STEPS, t2, m2, normal2, hitloc2);\n    \n    vec3 sky2 = skyCol(rd2, 0.25, iTime, iChannel2);\n    float nz2 = (t2 / float(MAX_RAY_STEPS)) * ieps;\n    \n    vec3 col2 = vec3(0.0);\n    // second ray hit sky?\n    if (t2 >= float(MAX_REFLECTION_STEPS)) {\n        \n        // clamp to black if not looking towards sky\n        col2 = sky * step(0.0, rd2.y);\n        \n    } else {\n        \n        // reflected material properties\n        vec3 diffCol2 = vec3(0.0);\n        vec3 specCol2 = vec3(0.0);\n        float rough2 = 0.0;\n        float alpha2 = 0.0;\n        textureMap(m2, hitloc2, normal2, diffCol2, specCol2, rough2, alpha2);\n        \n        // light power falls off deeper under water\n        if (hitloc2.y < 64.0) {\n            sunCol *= mix(pow(vec3(1.28, 1.74, 2.50) * 0.41, vec3(3.3)), vec3(0.0), clamp((64.0 - hitloc2.y) * 0.1, 0.0, 0.95));\n        }\n        \n        // shade reflections\n        col2 = shade_ggx(iChannel2, fragCoord, diffCol2, specCol2, hitloc, rd2, hitloc2 + normal2 * eps, t2, normal2, sunDir, sunCol, vec3(0.0), rng, rough2);\n        \n    }\n    \n    vec3 col = vec3(0.0);\n    // shade main ray\n    if (alpha < 1.0) {\n        col = col2;\n    } else {\n        col = shade_ggx(iChannel2, fragCoord, diffCol, specCol, ro, rd, hitloc + normal * eps, t, normal, sunDir, sunCol, col2, rng, rough);\n    }\n    \n    // distance fog\n    col = mix(sky, col, exp2(nz*nz*-TWOPI));\n    \n    // get last camera\n    vec4 lstpos = texelFetch(iChannel0, px_lst_pos, 0);\n\tvec4 lstrot = texelFetch(iChannel0, px_lst_rot, 0);\n    vec3 lstfwd = vec3(0.0, 0.0, 1.0);\n    lstfwd.yz = rotate2d(lstfwd.yz, lstrot.x);\n    lstfwd.xz = rotate2d(lstfwd.xz, lstrot.y);\n    // last view proj matrices\n    mat4 lastView = viewMat(lstpos.xyz, lstfwd);\n    mat4 lastProj = proj;\n    // last frame reprojection in NDC\n    vec3 lastNDC = reprojCoordsNDC(lastView, lastProj, hitloc);\n    vec2 lastPx = (lastNDC.xy * 0.5 + 0.5) * iChannelResolution[1].xy - 0.5;\n    vec4 lastFrame = reprojectBuffer(iChannel1, ivec2(iChannelResolution[1].xy), (lastNDC.z / zfar) * ieps, lastPx);\n    \n    // temporal smoothing\n    int lastFrameN = int(floor(lastFrame.a));\n    if (lastFrameN > TEMPORALSMOOTHING) {\n        float s = float(TEMPORALSMOOTHING) / float(lastFrameN);\n        lastFrame.a = float(TEMPORALSMOOTHING);\n        lastFrame.rgb *= s;\n    }\n    \n    // encode sample number in integer componenet and distance in fractional componenet of .a\n    fragColor = vec4(lastFrame.rgb + col, floor(lastFrame.a) + 1.0 + nz );\n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// World generation\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    float h = fbm(vec2( fragCoord   ) * 0.008, 6);\n    float t = fbm(vec2( fragCoord.yx) * 0.006, 3) * 2.0 - h;\n    float p = fbm(vec2(-fragCoord   ) * 0.006, 3) - 0.5 * h - 0.5 * abs(t - 0.5);\n    float s = fbm(vec2(-fragCoord.yx) * 0.008, 4);\n\n    // height, temperature, precipitation, strangeness\n    fragColor = vec4(h * 64.0 + 64.0, t, p, s);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}