{
    "Shader": {
        "info": {
            "date": "1491673759",
            "description": "clikc on screen to move a new point. put the mouse on the left, to hide the mouse point",
            "flags": 0,
            "hasliked": 0,
            "id": "MsjyWR",
            "likes": 24,
            "name": "Distance Field from Points Array",
            "published": 3,
            "tags": [
                "distance",
                "field",
                "array",
                "points"
            ],
            "usePreview": 0,
            "username": "aiekick",
            "viewed": 1570
        },
        "renderpass": [
            {
                "code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\n// this tech can be used to easily compute the df of a polygon mesh.\n// we just need to pass as a uniform the point list and lets the shader compute the df\n// the thick may be tuned to avoid the clamp of the df by the display color\n\n#define count 6\n#define thick 0.18\n#define zoom 1.5\n\nvec4 col;\n\n// compute the df from a points array\nfloat computeDf(in vec2 vUV, in vec2 vArr[count + 1], in int vCount, in float vDFThick)\n{\n\tfloat d = 1e3;\n\tfor (int i = 0; i < vCount;  i++)\n\t{\n        // p = current point\n        // lp = last point\n        vec2 p = vArr[i], lp = p, np = p;\n        \n        // circular\n\t\tif (i==0) lp = vArr[vCount-1]; else lp = vArr[i-1];\n\t\t\n        // 2d line df\n        vec2 a = vUV - lp;\n\t\tvec2 b = p - lp;\n\t\tfloat h = clamp(dot(a,b)/dot(b,b),0.,1.);\n\t\tfloat c = length(a-b*h) + vDFThick;\n\t\t\t\n       \t// df min\n\t\td = min(d, c);\n\n        // facultative : display the current point just for the demo\n\t\tcol += .0001/dot(vUV-p,vUV-p);\n\t}\n    \n    return d;\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tcol = vec4(0);\n    \n\tvec2 uv = (fragCoord.xy *2. - iResolution.xy)/iResolution.y*zoom;\n\t\n    // array of points\n\tvec2 arr[count + 1]; // count + 1 is for the adding of the mouse point if needed at line 67\n\t\n\tint n = count;\n\t    \n    // generate a basic polygon arrangement\n    float radius = .9;\n\tfor (int i = 0; i < n;  i++)\n\t{\n\t\tfloat a = float(i) / float (n) * 3.14159 * 2.;\n\t\tarr[i] = radius * vec2(cos(a), sin(a)); \n\t}\n    \n    // if mouse out of the dead zone, add point controled by user\n\tif (iMouse.x > 50.)\n\t{\n\t\tvec2 p = (iMouse.xy *2. - iResolution.xy)/iResolution.y*zoom;\n\t\tarr[n] = p;\n\t\tn ++;\n\t}\n\t\n    float d = computeDf(uv, arr, n, thick);\n    \n    // display the computed df\n    fragColor = col + d;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}