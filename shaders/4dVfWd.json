{
    "Shader": {
        "info": {
            "date": "1531086727",
            "description": "WIP\nstill in early stages of learning monte carlo path tracing.",
            "flags": 32,
            "hasliked": 0,
            "id": "4dVfWd",
            "likes": 12,
            "name": "2D MonteCarlo PathTrace",
            "published": 3,
            "tags": [
                "2d",
                "pathtrace",
                "montecarlo"
            ],
            "usePreview": 0,
            "username": "xdaimon",
            "viewed": 1207
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 oc, in vec2 fragCoord ) {\n    vec2 p = fragCoord / iResolution.xy;\n    oc = texture(iChannel0, p);\n    oc.rgb = pow(oc.rgb / oc.a, vec3(1./2.2));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Define here so I can copy from my desktop shader viewer easier\n#define iRes iResolution.xy\n#define iMouseLastDownPos iMouse.xy\n#define iMouseDown iMouse.z > 0.\n#define iB iChannel0",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//vim: set foldmethod=marker foldmarker={,}\n\n//#define REFLECTIVE\n#define NSAMPLES 3\n\nfloat sat(float x) {\n    return clamp(x, 0.,1.);\n}\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\nfloat hash11(float p) {\n    vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Returns a random number in the range [0,1]\nfloat my_seed = 1.; // set this in main()\nfloat get_rand() {\n    my_seed += .01;\n    return hash11(my_seed);\n}\n\nvec2 randDir(float range, float shift) {\n    float rand = get_rand();\n    return vec2(cos(rand*range + shift), sin(rand*range + shift));\n}\n\n#define DID_NOT_HIT 10.\n#define RO_ON_CIRCLE 0.\n\nfloat intersectCircle(vec2 ro, vec2 rd, vec2 so, float sr) {\n    vec2 oc = ro - so;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sr*sr;\n    if (c < 0.)\n        return RO_ON_CIRCLE;\n    float h = b*b - c;\n    if (h < 0.)\n        return DID_NOT_HIT;\n    h = sqrt(h);\n\n    float t0 = -b-h;\n    if (t0 > 0.) // do not intersect backward\n        return t0;\n    float t1 = -b+h;\n    if (t1 > 0.)\n        return t1;\n\n    return DID_NOT_HIT;\n}\n\n/*\nif o is in the box, then intersects the box\nif o is not in the box, then will give weird results\n*/\nfloat intersectBox(vec2 o, vec2 d, vec2 b) {\n    float t1 = (b.x-o.x)/d.x;\n    float t2 = (-b.x-o.x)/d.x;\n    float t3 = (b.y-o.y)/d.y;\n    float t4 = (-b.y-o.y)/d.y;\n    float t = 100000.;\n    if (t1 > 0. && t1 < t) t = t1;\n    if (t2 > 0. && t2 < t) t = t2;\n    if (t3 > 0. && t3 < t) t = t3;\n    if (t4 > 0. && t4 < t) t = t4;\n    return t;\n}\n\nfloat min3(float x, float y, float z) {\n    return min(x,min(y,z));\n}\n\nfloat min4(float x, float y, float z, float w) {\n    return min(min(x,y), min(z,w));\n}\n\n#define PI 3.1415926535897932384626\n\n/*\nvec2 V;\n#define neat_rot_macro(a) mat2( V= sin(vec2(PI*0.5, 0) + a), -V.y, V.x)\n*/\n\n// these are all global so they can easily be displayed for debugging (has been useful)\nvec3 acc_p1 = vec3(0);\nvec3 ind_p1 = vec3(0);\nvec3 dir_p1 = vec3(0);\nvec3 alb_p1 = vec3(0);\nvec3 inc_p1 = vec3(0);\n\nvec3 acc_p2 = vec3(0);\nvec3 ind_p2 = vec3(0);\nvec3 dir_p2 = vec3(0);\nvec3 alb_p2 = vec3(0);\nvec3 inc_p2 = vec3(0);\n\nvec3 acc_p3 = vec3(0);\nvec3 ind_p3 = vec3(0);\nvec3 dir_p3 = vec3(0);\nvec3 alb_p3 = vec3(0);\nvec3 inc_p3 = vec3(0);\n\nfloat lh;\nfloat sh1;\nfloat sh2;\nfloat sh3;\nfloat wh;\n\nbool is_p1_in_shadow;\nbool is_p2_in_shadow;\nbool is_p3_in_shadow;\nvec2 p_to_light;\nfloat nearest;\n\nvec2 ro_p1;\nvec2 rd_p1;\nvec2 n_p1;\n\nvec2 ro_p2;\nvec2 rd_p2;\nvec2 n_p2;\n\nvec2 ro_p3;\nvec2 rd_p3;\nvec2 n_p3;\n\nfloat aspect;\nvec2 uv;\nvec2 mouse;\nvec2 jitter;\n\nvec2 lo; // TODO make a torus shaped light\nfloat lr = .125;\nfloat li = 50.;\nfloat lheight = .333;\n\n// occluders\nvec2 so1 = vec2(0,.5);\nfloat sr1 = .3333;\nvec2 so2 = vec2(-.5);\nfloat sr2 = .3333;\nvec2 so3 = vec2(.5,-.5);\nfloat sr3 = .3333;\n\nvec2 wall_dim;\n\n// colors\nvec3 gc = vec3(.4);\nvec3 wc = vec3(.2);\nvec3 sc1 = vec3(0,.04,.46);\nvec3 sc2 = vec3(.46,0,.04);\nvec3 sc3 = vec3(.5/3.);\nvec3 lc = vec3(1);\n\n//void computeHitProperties(inout vec2 ro, inout vec2 rd, out vec2 n, out vec2 alb)\n//void shadowRay(vec2 ro, vec2\n\n// RAY 2\nvoid get_col_r2() {\n    // compute hit and surface properties at hit\n    sh1 = intersectCircle(ro_p2,rd_p2,so1,sr1);\n    sh2 = intersectCircle(ro_p2,rd_p2,so2,sr2);\n    sh3 = intersectCircle(ro_p2,rd_p2,so3,sr3);\n    wh = intersectBox(ro_p2,rd_p2,wall_dim);\n    nearest = min4(sh1, sh2, sh3, wh);\n    if (sh1 == nearest) {\n        ro_p3 = ro_p2 + rd_p2 * sh1;\n        n_p3 = normalize(ro_p3 - so1);\n        alb_p3 = sc1;\n        rd_p3 = randDir(PI, atan(n_p3.y, n_p3.x) - PI / 2.);\n    }\n    else if (sh2 == nearest) {\n        ro_p3 = ro_p2 + rd_p2 * sh1;\n        n_p3 = normalize(ro_p3 - so2);\n        alb_p3 = sc2;\n        rd_p3 = randDir(PI, atan(n_p3.y, n_p3.x) - PI / 2.);\n    }\n    else if (sh3 == nearest) {\n        ro_p3 = ro_p2 + rd_p2 * sh1;\n        n_p3 = normalize(ro_p3 - so3);\n        alb_p3 = sc3;\n        rd_p3 = randDir(PI, atan(n_p3.y, n_p3.x) - PI / 2.);\n    }\n    else if (wh == nearest) {\n        ro_p3 = ro_p2 + rd_p2 * wh;\n        if (abs(ro_p3.x) / aspect > abs(ro_p3.y)) {\n            n_p3 = vec2(-sign(ro_p3.x), 0.); // fails to compile w/ weird error if 0 instead of 0.\n            rd_p3 = randDir(PI, -n_p3.x * PI / 2.);\n        }\n        else {\n            n_p3 = vec2(0, -sign(ro_p3.y));\n            rd_p3 = randDir(PI * n_p3.y, 0.);\n        }\n        alb_p3 = wc;\n    }\n    #ifdef REFLECTIVE\n    rd_p3 = reflect(n_p3, rd_p2);\n    #endif\n    // push away from the surface a bit.\n    // add a bit of randomness to make sure there are no anomalies\n    ro_p3 = ro_p3 + .001 * (rd_p3 + jitter);\n\n    // no indirect light for last ray\n\n    // compute direct light\n    is_p3_in_shadow = true; // is light visible from p1\n    p_to_light = normalize(lo - ro_p3);\n    lh = intersectCircle(ro_p3,p_to_light,lo,lr);\n    sh1 = intersectCircle(ro_p3,p_to_light,so1,sr1);\n    sh2 = intersectCircle(ro_p3,p_to_light,so2,sr2);\n    sh3 = intersectCircle(ro_p3,p_to_light,so3,sr3);\n    wh = intersectBox(ro_p3,p_to_light,wall_dim);\n    nearest = min4(sh1, sh2, sh3, wh);\n    if (lh < nearest) {\n        is_p3_in_shadow = false;\n    }\n    if (!is_p3_in_shadow) {\n        //if (lh == RO_ON_CIRCLE)\n        //    lh = 0.;\n        lh = sqrt(lh*lh + lheight*lheight); // figure that light is above the ground\n        float falloff = sat(1. / (4. * PI * lh * lh));\n        // TODO scale accoring to size of light in hemisphere\n        dir_p3 = .5 * lc * li * falloff;\n    }\n\n    inc_p3 = ind_p3 * 2. * PI * max(0., dot(n_p3, rd_p3)) + dir_p3 / PI * max(0., dot(n_p3, p_to_light));\n    acc_p3 = alb_p3 * inc_p3;\n}\n\n// RAY 1\nvoid get_col_r1() { \n    // ray 1 is the first ray sent away from the uv coord\n\n    ind_p2 = vec3(0);\n    for (int i = 0; i < NSAMPLES; ++i) {\n        // compute hit and surface properties at hit\n        sh1 = intersectCircle(ro_p1,rd_p1,so1,sr1);\n        sh2 = intersectCircle(ro_p1,rd_p1,so2,sr2);\n        sh3 = intersectCircle(ro_p1,rd_p1,so3,sr3);\n        if (sh1 == RO_ON_CIRCLE) sh1 = DID_NOT_HIT; // prevent self intersections\n        if (sh2 == RO_ON_CIRCLE) sh2 = DID_NOT_HIT;\n        if (sh3 == RO_ON_CIRCLE) sh3 = DID_NOT_HIT;\n        wh = intersectBox(ro_p1,rd_p1,wall_dim);\n        nearest = min4(sh1, sh2, sh3, wh);\n        if (sh1 == nearest) {\n            ro_p2 = ro_p1 + rd_p1 * sh1;\n            n_p2 = normalize(ro_p2 - so1);\n            alb_p2 = sc1;\n            rd_p2 = randDir(PI, atan(n_p2.y, n_p2.x) - PI / 2.);\n        }\n        else if (sh2 == nearest) {\n            ro_p2 = ro_p1 + rd_p1 * sh2;\n            n_p2 = normalize(ro_p2 - so2);\n            alb_p2 = sc2;\n            rd_p2 = randDir(PI, atan(n_p2.y, n_p2.x) - PI / 2.);\n        }\n        else if (sh3 == nearest) {\n            ro_p2 = ro_p1 + rd_p1 * sh3;\n            n_p2 = normalize(ro_p2 - so3);\n            alb_p2 = sc3;\n            rd_p2 = randDir(PI, atan(n_p2.y, n_p2.x) - PI / 2.);\n        }\n        else if (wh == nearest) {\n            ro_p2 = ro_p1 + rd_p1 * wh;\n            if (abs(ro_p2.x) / aspect > abs(ro_p2.y)) {\n                n_p2 = vec2(-sign(ro_p2.x), 0.); // fails to compile w/ weird error if 0 instead of 0.\n                rd_p2 = randDir(PI, -n_p2.x * PI / 2.);\n            }\n            else {\n                n_p2 = vec2(0, -sign(ro_p2.y));\n                rd_p2 = randDir(PI * n_p2.y, 0.);\n            }\n            alb_p2 = wc;\n        }\n        #ifdef REFLECTIVE\n        rd_p2 = reflect(n_p2,rd_p1);\n        #endif\n        // push away from the surface a bit.\n        // add a bit of randomness to make sure there are no anomalies\n        ro_p2 = ro_p2 + .001 * (rd_p2 + jitter);\n\n        // compute indirect light\n        get_col_r2();\n        ind_p2 += acc_p3 * max(0., dot(n_p2, rd_p2));\n    }\n    ind_p2 /= float(NSAMPLES);\n\n    // compute direct light // TODO treats light as point light but should treat light as having size\n    is_p2_in_shadow = true; // is light visible from p1\n    p_to_light = normalize(lo - ro_p2);\n    lh = intersectCircle(ro_p2,p_to_light,lo,lr);\n    sh1 = intersectCircle(ro_p2,p_to_light,so1,sr1);\n    sh2 = intersectCircle(ro_p2,p_to_light,so2,sr2);\n    sh3 = intersectCircle(ro_p2,p_to_light,so3,sr3);\n    wh = intersectBox(ro_p2,p_to_light,wall_dim);\n    nearest = min4(sh1, sh2, sh3, wh);\n    if (lh < nearest) {\n        is_p2_in_shadow = false;\n    }\n    if (!is_p2_in_shadow) {\n        //if (lh == RO_ON_CIRCLE)\n        //    lh = 0.;\n        lh = sqrt(lh*lh + lheight*lheight); // figure that light is above the ground\n        float falloff = sat(1. / (4. * PI * lh * lh));\n        dir_p2 = .5 * lc * li * falloff;\n    }\n\n    inc_p2 = ind_p2 * 2. * PI + dir_p2 / PI * max(0., dot(n_p2, p_to_light));\n    acc_p2 = alb_p2 * inc_p2;\n}\n\n// RAY 0\nvec3 get_color(in vec2 fragP) {\n    // ray 0 is the first ray and is simply the uv coord\n\n    // this is the second ray which has it's tail (ro) at the uv coord (head of ro_p0, the first ray)\n    ro_p1 = uv + jitter;\n\n    ind_p1 = vec3(0);\n    for (int i = 0; i < NSAMPLES; ++i) {\n        // compute surface properties, how will this point reflect light? ray 1 cannot hit wall\n        if (distance(ro_p1, so1) <= sr1) { // hit occluder\n            n_p1 = normalize(ro_p1 - so1);\n            alb_p1 = sc1;\n            rd_p1 = randDir(PI, atan(n_p1.y, n_p1.x) - PI / 2.);\n        }\n        else if (distance(ro_p1, so2) <= sr2) { // hit occluder\n            n_p1 = normalize(ro_p1 - so2);\n            alb_p1 = sc2;\n            rd_p1 = randDir(PI, atan(n_p1.y, n_p1.x) - PI / 2.);\n        }\n        else if (distance(ro_p1, so3) <= sr3) { // hit occluder\n            n_p1 = normalize(ro_p1 - so3);\n            alb_p1 = sc3;\n            rd_p1 = randDir(PI, atan(n_p1.y, n_p1.x) - PI / 2.);\n        }\n        else { // hit floor, can only be intersected on ray 1\n            rd_p1 = randDir(2.*PI, 0.);\n            n_p1 = rd_p1;\n            alb_p1 = gc;\n        }\n        #ifdef REFLECTIVE\n        float range = .333;\n        rd_p1 = randDir(range * PI, -PI * range / 2. + atan(n_p1.y, n_p1.x));\n        #endif\n        \n        // compute indirect light (recurse)\n        get_col_r1();\n        ind_p1 += acc_p2 * max(0., dot(n_p1, rd_p1));\n    }\n    ind_p1 /= float(NSAMPLES);\n    \n    // compute direct light\n    is_p1_in_shadow = true; // is light visible from ro_p1\n    p_to_light = normalize(lo - ro_p1);\n    lh = intersectCircle(ro_p1,p_to_light,lo,lr);\n    sh1 = intersectCircle(ro_p1,p_to_light,so1,sr1);\n    sh2 = intersectCircle(ro_p1,p_to_light,so2,sr2);\n    sh3 = intersectCircle(ro_p1,p_to_light,so3,sr3);\n    if (sh1 == RO_ON_CIRCLE) sh1 = DID_NOT_HIT;\n    if (sh2 == RO_ON_CIRCLE) sh2 = DID_NOT_HIT;\n    if (sh3 == RO_ON_CIRCLE) sh3 = DID_NOT_HIT;\n    wh = intersectBox(ro_p1,p_to_light,wall_dim);\n    nearest = min4(sh1, sh2, sh3, wh);\n    if (lh < nearest) {\n        is_p1_in_shadow = false;\n    }\n    if (!is_p1_in_shadow) {\n        //if (lh == RO_ON_CIRCLE)\n        //    lh = 0.;\n        lh = sqrt(lh*lh + lheight*lheight); // figure that light is above the ground\n        float falloff = sat(1. / (4. * PI * lh * lh));\n        // TODO scale according to size of light in hemisphere\n        dir_p1 = .03 * lc * li * falloff;\n    }\n\n    inc_p1 = ind_p1 * 2. * PI + dir_p1 / PI * max(0., dot(n_p1, p_to_light));\n    acc_p1 += alb_p1 * inc_p1;\n\n    return acc_p1;\n\n    // DEBUGGING and just neat\n    //return acc_p2;\n    //return acc_p3;\n    //return ind_p1;\n    //return dir_p1;\n    //return vec3(dot(n_p1, rd_p1));\n    //return ind_p2 / PI;\n    //return dir_p2 / PI / 16.;\n    //return ind_p3; // zero\n    //return dir_p3 / PI / 16.;\n    //return alb_p1;\n    //return alb_p2;\n    //return alb_p3;\n    //return vec3(!is_p1_in_shadow);\n    //return vec3(!is_p2_in_shadow);\n    //return vec3(!is_p3_in_shadow);\n    //return vec3(ro_p1.x,0,ro_p1.y);\n    //return vec3(ro_p2.x,0,ro_p2.y);\n    //return vec3(ro_p3.x,0,ro_p3.y);\n    //return vec3(rd_p1.x,0,rd_p1.y);\n    //return vec3(rd_p2.x,0,rd_p2.y);\n    //return vec3(rd_p3.x,0,rd_p3.y);\n    //return vec3(n_p1.x,0,rd_p1.y);\n    //return vec3(n_p2.x,0,n_p2.y);\n    //return vec3(n_p3.x,0,n_p3.y);\n    //return vec3(p_to_light.x,0,p_to_light.y);\n    //return iRes.y*vec3(jitter.x,0,jitter.y);\n    //return 10.*vec3(randDir(2.*PI,0.), 0); // scene geometry shows through if this return is used (and if only 2 rays traced for some reason)\n}\n\nvoid mainImage(out vec4 C, in vec2 fragP) {\n    fragP /= iRes;\n    vec4 oc = texture(iB, fragP);\n\n    my_seed = hash12(fragP * (1.+mod(iTime,16.)));\n    aspect = iRes.x / iRes.y;\n\n    uv = fragP * 2. - 1.;\n    uv.x *= aspect;\n\n    mouse = iMouseLastDownPos / iRes * 2. - 1.;\n    mouse.x *= aspect;\n    if (mouse.x < -.999 && mouse.y < -.999)\n        mouse = vec2(0, .77);\n\n    // light\n    lo = mouse;\n    \n    wall_dim = vec2(aspect, 1.); // half width, half height\n    \n    jitter = randDir(2.*PI, 0.) / iRes.y;\n\n    vec3 col = get_color(fragP);\n\n    //if (iMouseDown || iFrame == 0) {\n    //    C.rgb = mix(oc.rgb, col / float(ITERS), vec3(.2));\n    //    C.a = 1.;\n    //}\n    //else {\n    //    C.rgb = mix(oc.rgb, col / float(ITERS), vec3(.2));\n    //    C.a = 1.;\n    //}\n \n    if (iMouseDown || iFrame == 0) {\n        oc = vec4(0);\n    }\n    C = oc + vec4(col, 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}