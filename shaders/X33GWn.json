{
    "Shader": {
        "info": {
            "date": "1716299302",
            "description": "Trying to make a ray-marching shader\nHas been using this as a guidance: https://michaelwalczyk.com/blog-ray-marching.html\nStill need to look a little more into it so I can understand it better",
            "flags": 0,
            "hasliked": 0,
            "id": "X33GWn",
            "likes": 0,
            "name": "Ray marching - nissen",
            "published": 3,
            "tags": [
                "ray",
                "marching"
            ],
            "usePreview": 0,
            "username": "MrNissenDK",
            "viewed": 93
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926535897932384626433\n\nconst float gamma = .8;\n\nconst float step_size = 0.1;\nconst float fov = 90.0;\n\nconst int NUMBER_OF_STEPS = 100;\nconst float MINIMUM_HIT_DISTANCE = 0.0001;\nconst float MAXIMUM_TRACE_DISTANCE = 10000.0;\n\nstruct object {\n    int type;\n    vec3 pos;\n    vec3 color;\n    float radius;\n};\n\nstruct hit {\n    vec3 color;\n    float dist;\n};\n\nobject newSphere(vec3 pos, float radius, vec3 color) {\n    object o;\n    o.type = 0;\n    o.pos = pos;\n    o.color = color;\n    o.radius = radius;\n    return o;\n}\n\nobject newWobble(vec3 pos, float radius, vec3 color) {\n    object o;\n    o.type = 2;\n    o.pos = pos;\n    o.color = color;\n    o.radius = radius;\n    return o;\n}\n\nobject newPlane(float pos, vec3 color) {\n    object o;\n    o.type = 1;\n    o.pos = vec3(0, pos, 0);\n    o.color = color;\n    return o;\n}\n\nfloat distanceFromSphere(in vec3 pos, in object obj) {\n    return length(pos - obj.pos) - obj.radius;\n}\n\nfloat distanceFromWobble(in vec3 pos, in object obj) {\n    float displacement = sin(5.0 * pos.x + iTime / 5.) * sin(5.0 * pos.y + iTime / 2.) * sin(5.0 * pos.z + iTime / 15.) * 0.25;\n    return distanceFromSphere(pos, obj) + displacement;\n}\n\n\nfloat distToPlane(in vec3 pos, in object obj) {\n    return abs(pos.y - obj.pos.y);\n}\n\nfloat getDist(vec3 pos, object o) {\n    if (o.type == 0) {\n        return distanceFromSphere(pos, o);\n    } else if (o.type == 1) {\n        return distToPlane(pos, o);\n    } else if (o.type == 2) {\n        return distanceFromWobble(pos, o);\n    }\n    return 1000000000.0;\n}\n\n#define Num_Of_Points 4\nvoid initializeObjects(out object objects[Num_Of_Points]) {\n    objects[0] = newSphere(vec3(0, 0, 0), 1.0, vec3(1, 0, 0));\n    objects[1] = newWobble(vec3(5, 0, -2), 1.0, vec3(abs(mod(iTime / 30., 2.) - 1.), abs(mod(iTime / 10., 2.) - 1.), abs(mod(iTime / 20., 2.) - 1.)));\n    objects[2] = newPlane(-3.0, vec3(0, 1, 0));\n    objects[3] = newPlane(3.0, vec3(0, 0, 1));\n}\n\nhit map(in vec3 pos) {\n    object objects[Num_Of_Points];\n    initializeObjects(objects);\n\n    object closestObject = objects[0];\n    float dist = getDist(pos, closestObject);\n\n    for (int i = 1; i < Num_Of_Points; i++) {\n        float cDist = getDist(pos, objects[i]);\n        if (cDist < dist) {\n            dist = cDist;\n            closestObject = objects[i];\n        }\n    }\n\n    hit h;\n    h.color = closestObject.color;\n    h.dist = dist;\n    return h;\n}\n\nvec3 calculateNormal(in vec3 p) {\n    const vec3 smallStep = vec3(0.001, 0.0, 0.0);\n\n    float gradientX = map(p + smallStep.xyy).dist - map(p - smallStep.xyy).dist;\n    float gradientY = map(p + smallStep.yxy).dist - map(p - smallStep.yxy).dist;\n    float gradientZ = map(p + smallStep.yyx).dist - map(p - smallStep.yyx).dist;\n\n    vec3 normal = vec3(gradientX, gradientY, gradientZ);\n\n    return normalize(normal);\n}\n\nmat3 rotationMatrix(vec3 rotation) {\n    float sinX = sin(rotation.x);\n    float cosX = cos(rotation.x);\n    float sinY = sin(rotation.y);\n    float cosY = cos(rotation.y);\n    float sinZ = sin(rotation.z);\n    float cosZ = cos(rotation.z);\n\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cosX, -sinX,\n        0.0, sinX, cosX\n    );\n\n    mat3 rotY = mat3(\n        cosY, 0.0, sinY,\n        0.0, 1.0, 0.0,\n        -sinY, 0.0, cosY\n    );\n\n    mat3 rotZ = mat3(\n        cosZ, -sinZ, 0.0,\n        sinZ, cosZ, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    return rotZ * rotY * rotX; // Combined rotation matrix\n}\n\nvec3 calculateRayDirection(vec2 uv, vec3 rotation) {\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 ndc = uv * 2.0 - 1.0;\n\n    float scale = tan(radians(fov) / 2.0);\n    float cameraX = ndc.x * aspectRatio * scale;\n    float cameraY = ndc.y * scale;\n    float cameraZ = -1.0;\n\n    vec3 rayDir = normalize(vec3(cameraX, cameraY, cameraZ));\n\n    // Apply rotation\n    mat3 rotMatrix = rotationMatrix(rotation);\n    rayDir = rotMatrix * rayDir;\n\n    return rayDir;\n}\n\n\nvec3 rayMarch(in vec3 ro, in vec3 rd) {\n    float totalDistanceTraveled = 0.0;\n    int i;\n    for (i = 0; i < NUMBER_OF_STEPS; ++i) {\n        vec3 currentPosition = ro + totalDistanceTraveled * rd;\n        hit closest = map(currentPosition);\n\n        if (closest.dist < MINIMUM_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 lightPosition = vec3(1, 0, 1.5);\n            vec3 directionToLight = normalize(lightPosition - currentPosition);\n\n            float diffuseIntensity = max(0.0, dot(normal, directionToLight));\n            return closest.color * diffuseIntensity;\n        }\n\n        if (totalDistanceTraveled > MAXIMUM_TRACE_DISTANCE) {\n            break;\n        }\n\n        totalDistanceTraveled += closest.dist;\n    }\n\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 camera = vec3(0, 0, 2);\n    vec2 mouseCorrection;\n    if (iMouse.z > .5) {\n        mouseCorrection = iMouse.yx / iResolution.yx - .5;\n    }\n    else {\n        mouseCorrection = vec2(0, sin(iTime / 5.) * .1);\n    }\n    vec3 rotation = vec3(mouseCorrection.xy * vec2(PI, PI * 2.), 0); // Scaled rotation\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 rayDirection = calculateRayDirection(uv, rotation);\n\n    vec3 col = rayMarch(camera, rayDirection);\n\n    fragColor = vec4(pow(col, vec3(1./gamma)), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}