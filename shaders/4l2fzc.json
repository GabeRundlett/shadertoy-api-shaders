{
    "Shader": {
        "info": {
            "date": "1619784043",
            "description": "Rotating cube engulfed in rain-like artefacts.",
            "flags": 0,
            "hasliked": 0,
            "id": "4l2fzc",
            "likes": 4,
            "name": "rainy ghost cube",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "nylki",
            "viewed": 312
        },
        "renderpass": [
            {
                "code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// uniform vec2 iResolution;\n// uniform vec2 u_mouse;\n// uniform float iGlobalTime;\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float S = 0.01;\n\n\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\n\nfloat sphere(vec3 p, float r) {\n return length(p) - r;\n}\n\n// New distance function for a cube\nfloat cube(vec3 p, float s /* half length of the faces */) {\n    vec3 q = abs(p) - vec3(s);\n    return min(max(q.x,max(q.y,q.z)),0.0) +\n         length(max(q,0.0));\n}\n\nfloat sdfGhost(float a, float b) {\n    return mod(iTime * b,a);\n}\n\n\nfloat distanceToNearestSurface(vec3 p) {\n    return sdfGhost(cube(vec3(1.0,0.0, 1.0) + p, 1.5), sphere(p,  1000.0));\n}\n\n\n// const delta vectors for normal calculation\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\n\nvec3 calcNormalForPoint(vec3 p, float dist) {\n // ... my own old attempt at the normal calc without\n // Create the three vectors pointing out\n // along each one of the axes by copying p each time first.\n vec3 A = p;\n vec3 B = p;\n vec3 C = p;\n\n A.x += S;\n B.y += S;\n C.z += S;\n\n // Get their distances to the surface\n float distA = distanceToNearestSurface(A) - dist;\n float distB = distanceToNearestSurface(B) - dist;\n float distC = distanceToNearestSurface(C) - dist;\n\n // And use the distances as value for each axe (X,Y,Z)\n vec3 normal = normalize(vec3(distA,distB,distC));\n return normal;\n\n}\n\nvec3 computeToon(vec3 color, float steps) {\n return ceil(color * steps) / steps;\n}\n\nvec3 computeLambert(vec3 p, vec3 n, float intensity) {\n    \n\tvec3 lightPos = vec3(100., 30., 50.);\n    // calc vector pointing from light to point\n    // and then take dot product of that\n    // vector and the surface normal\n    vec3 lightToPoint = normalize(lightPos-p);\n    return vec3( intensity * dot(lightToPoint, n));\n}\n\nvec3 intersectWithWorld(vec3 p, vec3 dir) {\n\tfloat dist = 0.0;\n    for(int i = 0; i < 20; i++) {\n    \tvec3 currentRayPos = p + dir*dist;\n    \tfloat nearest = distanceToNearestSurface(currentRayPos);\n        if (nearest < 0.01) {\n        \tvec3 normal = calcNormalForPoint(currentRayPos, nearest);\n            return computeLambert(currentRayPos, normal, 1.0);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(10.0*sin(iTime), 0.0, 10.0*cos(iTime));\n    vec3 camDir = vec3(-1.0*sin(iTime), 0.0, -1.0*cos(iTime));\n    vec3 camUp  = vec3(0.0, 1.0, 0.0);\n    \n    // tracing stuff\n    const float fovx = PI * fov / 360.0;\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n    float vlen = tan(fovy);\n    \n    \n    // Generate Ray for this fragment\n \n    // create camera UV (-1 to 1.0) from UV (0.0 to 1.0)\n    \n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    \n    // Get perpendicular vector from camUp and camDir\n    // which is the x axis of the camera basically\n\n    vec3 nright = normalize( cross(camUp, camDir) );\n    \n    // Calculate Pixel position in space to trace\n    vec3 pixel = camPos + camDir + nright*camUV.x*ulen + camUp*camUV.y*vlen;\n\t\n    // Calculate direction vector from camera to pixel\n    vec3 ray = normalize(pixel - camPos);\n\n\n    vec3 intersectionColor = intersectWithWorld(pixel, ray);\n    intersectionColor.r *= sin(iMouse.x/iResolution.x);\n    fragColor = vec4(intersectionColor , 1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}