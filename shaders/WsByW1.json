{
    "Shader": {
        "info": {
            "date": "1586531297",
            "description": "Sequel to [url]https://www.shadertoy.com/view/Wdjyzm[/url]\n\nMore colour, more triangles, see code for details. If the \"null rotations\" are distracting, type 'n'. If the colours are too garish, type 'a'.",
            "flags": 16,
            "hasliked": 0,
            "id": "WsByW1",
            "likes": 22,
            "name": "Poincar√© Disc Tilings II",
            "published": 3,
            "tags": [
                "disc",
                "poincare"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 676
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tiling the Poincare Disc II\n//\n// Construct P,Q,R hyperbolic triangle, centred at the origin, with\n// straight sides at angle PI/P at origin, and a circular side\n// making angles PI/Q and PI/R with the first two sides. Fold into\n// triangle by iterated reflection in its sides (so the triangle is a\n// fundamental region for the group of reflections).\n//\n// Lots of options:\n// 1,2,3: show different edge types\n// a: alternative palette\n// c: clip to unit disc\n// h: halfplane\n// i: colour by index\n// m: mouse isometry\n// n: null rotation\n// p: progressive folding\n// s: show sequence\n// t: show parity\n// z: exponential zoom out (halfplane only)\n//\n// This one does the folds in layers, so we can index and colour the\n// tiles according to what layer they are in.\n//\n// Any P,Q,R with 1/P + 1/Q + 1/R < 1 can be used, and Q and R may be\n// set to 0, which actually means \"infinity\", ie. a dihedral angle of\n// 0 (so the triangle points are ideal).\n//\n// This one really shows up any inaccuracy in the GPUs cos and sin,\n// so we use a table of cos(PI/n) for n = 0 up to 15. Note that the\n// table has cos(PI/0) = 1.0 as 0 really means \"infinity\" here.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 5, Q = 2, R = 4;\nint NSTEPS = 100; // Max number of folding steps\nint PSTEPS = 50; // Number of \"progressive\" steps\nint CYCLETIME = 2; // Time to show each triangle\nbool dotwotone = true;       // Show parity of fundamental regions\nbool doedge1 = true;         // Show x-axis edge\nbool doedge2 = true;         // Show y-axis edge\nbool doedge3 = true;         // Show circular edge\nbool donullrotation = false; // Do a \"null rotation\"\nbool domouse = true;         // Invert origin to mouse position\nbool dozoom = false;         // Zoom out, in halfplane mode only\nbool dohalfplane = false;    // Show the halfplane model, instead of the disc\nbool doprogressive = false;   // Progressively increase max number of folds\nbool doclip = true;         // Clip to unit disc\nbool dosequence = true;      // Show sequence of tilings\nbool doindexing = true;      // Use index for colour\nbool dopalette = false;      // Use alternative palette\n\nfloat PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\n// Maybe use relative error here?\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat dihedral(vec2 n, vec2 m) {\n  return -dot(n,m);\n}\n\n// The dihedral angle between a plane and a spherical face. If d is\n// the perpendicular distance to plane, and s the sphere radius, then\n// angle is acos(d/s)\nfloat dihedral(vec2 n, vec2 C, float s) {\n  return dot(C,n)/s;\n}\n\nfloat COS[] =\n  // Look who doesn't trust cos on the GPU: cos(PI/n) for n = 0..31\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat mycos(int p) {\n  // cos(PI/p)\n  if (p < COS.length()) return COS[p];\n  return cos(PI/float(p));\n}\n                        \nfloat mysin(int p) {\n  // sin(PI/p)\n  float t = mycos(p);\n  return sqrt(1.0-t*t);\n}\n\nvec2 A,B,C; // Fundamental mirrors, C is circle centre\nfloat S,S2; // Circle radius and squared radius\n// Constructing the fundamental region:\n//\n// A and B have dihedral p, then want a circle (C,s) such that:\n// dihedral(A,C,s) = r\n// dihedral(B,C,s) = q\n// (q and r this way round for aesthetic reasons).\n//\n// Since the triangle can be any size, we solve for s = 1 and then scale:\n// dot(C,A) = cos(r)\n// dot(C,B) = cos(q)\n// or, with matrices:\n// transpose(mat2(A,B))*C = vec2(cos(r),cos(q))\n//\n// How the final scaling works is left as an exercise for the reader.\n// We could optimize a little since m has a simple form, but it's neat\n// doing it like this and the compiler might well do the optimization\n// for us (fairly simple inlining and constant folding would do).\nvoid solve(int p, int q, int r) {\n  // Use the y-axis for the first side, for bilateral symmetry.\n  A = vec2(1,0);\n  B = vec2(-mycos(p),mysin(p));\n  mat2 m = inverse(mat2(A,B));\n  C = vec2(mycos(r),mycos(q))*m; // multiply by transpose\n  // and set the correct radius = 1.0\n  S2 = 1.0/(dot(C,C)-1.0);\n  S = sqrt(S2);\n  C *= S;\n  assert(eq(dihedral(A,B),mycos(p)));\n  assert(eq(dihedral(B,C,S),mycos(q)));\n  assert(eq(dihedral(A,C,S),mycos(r)));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 background = vec3(0.1);\n\nvec3 diagram(vec2 z, vec2 mouse) {\n  assert(P >= 2);\n  assert(Q == 0 || Q >= 2);\n  assert(R == 0 || R >= 2);\n  assert(Q == 0 || R == 0 || (Q*R + R*P + P*Q) < P*Q*R);\n  solve(P,Q,R);\n  if (dohalfplane) {\n    z.y += 1.0;\n    if (dozoom) z *= exp(iTime);\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n  }\n  // Map screen coordinate at mouse position to origin\n  // We do this by inverting in an imaginary circle centred\n  // at the mouse position to take the mouse to infinity,\n  // then invert in the imaginary unit circle to bring it\n  // back to the origin. Both circles are orthogonal to the\n  // (real) unit circle, and so are hyperbolic lines and\n  // the inversions are isometries.\n  if (domouse && mouse != vec2(0)) {\n    vec2 c = mouse;\n    z -= c;\n    z *= (dot(c,c)-1.0)/dot(z,z);\n    z += c;\n    z *= -1.0/dot(z,z);\n  }\n  if (donullrotation) {\n    // One ideal fixed point: do with reflection in x = 0 and an\n    // inversion in a circle going through (0,1).\n    float theta = PI*iTime/float(CYCLETIME);\n    if (theta != 0.0) {\n      z.x = -z.x;\n      float r = 1.0/tan(theta);\n      r = (r<0.0?-1.0:1.0)*max(1e-2,abs(r));\n      vec2 c = vec2(r,1);\n      z -= c;\n      z *= r*r/dot(z,z);\n      z += c;\n    }\n  }\n  if (dot(z,z) > 1.0) {\n    if (doclip) return background;\n    z /= dot(z,z); // Map exterior to interior if displaying.\n  }\n  int nsteps = NSTEPS, folds = 0, index = -1;\n  if (doprogressive) nsteps = 1+int(iTime)%PSTEPS;\n  for (index = 0; index < nsteps; index++) {\n    if (P == 2) {\n      // This optimization may not be worth it.\n      folds += int(z.x < 0.0) + int(z.y < 0.0);\n      z = abs(z);\n    } else {\n      // Enough folds to do the central region\n      for (int i = 0; i < (P+1)/2; i++) {\n        // A is (1,0) so maybe optimize this, or again, just let the\n        // compiler do it.\n        {\n          float t = dot(z,A);\n          if (t < 0.0) {\n            z -= 2.0*t*A;\n            folds++;\n          }\n        }\n        {\n          float t = dot(z,B);\n          if (t < 0.0) {\n            z -= 2.0*t*B;\n            folds++;\n          }\n        }\n      }\n    }\n    {\n      vec2 z1 = z-C;\n      float t = dot(z1,z1);\n      if (t >= S2) break;\n      z1 *= S2/t;\n      z = z1+C;\n      folds++;\n    }\n  }\n  if (index == nsteps) return background;\n  // We have now folded the original point z into the fundamental\n  // region, now draw whatever should be in there. Things get smaller\n  // as we move outwards in the disc, so need a scale factor.\n  float scalefactor = abs(1.0 - dot(z,z));\n  // Euclidean distances to edge of fundamental regions\n  float d1 = abs(dot(z,A));\n  float d2 = abs(dot(z,B));\n  float d3 = abs(length(z-C)-S);\n  // Desired widths, appropriately scaled.\n  float ewidth = 0.5*scalefactor*0.02;\n  float lwidth = 0.5*scalefactor*0.02;\n  vec3 col = vec3(0,1,1);\n  if (doindexing) {\n    if (dopalette) col = 0.5 + 0.5*cos(float(index)*PI/3.0 + vec3(2, 1, 0));\n    else col = hsv2rgb(vec3(float(index)/6.0,1,1));\n  }\n  // Haven't worked out how to do smooth colour transition yet.\n  // If nearest to edge 1 or 2, then same colour, else\n  // it's either colour index+1 or index-1 depending on what?\n  if (dotwotone && folds%2 != 0) col *= 0.5;\n  if (doedge1 || doedge2 || doedge3) {\n    // Draw the edges of the region, if desired.\n    float d = 1e8;\n    if (doedge1) d = min(d,d1);\n    if (doedge2) d = min(d,d2);\n    if (doedge3) d = min(d,d3);\n    col = mix(vec3(0),col,smoothstep(0.0,lwidth/*+fwidth(z.x)*/,d));\n  }\n  assert(!isnan(dot(col,col)));\n  return col;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_Z = 90;\n\nivec3 sequence[] =\n  ivec3[](ivec3(2,3,7),ivec3(3,2,7),ivec3(7,2,3),\n          ivec3(4,4,4),ivec3(3,2,0),ivec3(2,0,0));\n                          \nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  dotwotone = dotwotone != key(CHAR_T);\n  doedge1 = doedge1 != key(CHAR_0+1);\n  doedge2 = doedge2 != key(CHAR_0+2);\n  doedge3 = doedge3 != key(CHAR_0+3);\n  donullrotation = donullrotation != key(CHAR_N); \n  domouse = domouse != key(CHAR_M); \n  dozoom = dozoom != key(CHAR_Z); // halfplane only\n  dohalfplane = dohalfplane != key(CHAR_H);\n  doprogressive = doprogressive != key(CHAR_P);\n  doclip = doclip != key(CHAR_C);\n  dosequence = dosequence != key(CHAR_S);\n  doindexing = doindexing != key(CHAR_I);\n  dopalette = dopalette != key(CHAR_A);\n  \n  if (dosequence) {\n    int N = CYCLETIME;\n    if (doprogressive) N = PSTEPS;\n    int i = int(iTime/float(N))%sequence.length();\n    ivec3 pqr = sequence[i];\n    P = pqr.x; Q = pqr.y; R = pqr.z;\n  }\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  int AA = 2;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 p = vec2((2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y);\n      col += diagram(p,mouse);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}