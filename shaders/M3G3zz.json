{
    "Shader": {
        "info": {
            "date": "1717201018",
            "description": "Alternative 12-hour analog clock.\nWhen it's exactly N:00, both the hour and the minute hand point straight at N.\nWhen it's N:30, the hour hand is halfway from N to N+1, and the minute hand is exactly opposite the hour hand.\nUgly minute ticks, tho.",
            "flags": 0,
            "hasliked": 0,
            "id": "M3G3zz",
            "likes": 12,
            "name": "alternative clock hand scheme",
            "published": 3,
            "tags": [
                "clockhands"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 140
        },
        "renderpass": [
            {
                "code": "const bool BE_A_BORING_NORMAL_CLOCK = false;\n\nconst float gZoom       = 0.8;\n      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n      \n\nfloat getT() {\n\n    if (iMouse.z > 0.0) {\n        // Mouse drags around the hour hand\n        vec2 m = VIEWFROMSCREEN(iMouse.xy);\n        float theta = atan(m.x, m.y) / pi / 2.0;\n        return theta * 60.0 * 60.0 * 12.0;\n    }\n    \n    // actual time\n    return iDate.w;\n\n}\n\nfloat getHour() {\n    return mod(getT() / 60.0 / 60.0, 60.0);\n}\n\nfloat getMinute() {\n    return mod(getT() / 60.0, 60.0);\n}\n\nfloat getSecond() {\n    return mod(getT(), 60.0);\n}\n\nfloat sdHourHand(in vec2 p) {\n    float t     = getHour();\n    float theta = -pi * 2.0 * (t / 12.0 - 0.25);\n    float len   = 0.6;\n    \n    vec2  v     = vec2(cos(theta), sin(theta));\n    float d     = 1e9;\n    \n    d  = min(d, sdSegment(p, v * 0.0, v * len));\n    d -= length(p) / len * 0.05;\n    d -= 0.02;\n    d  = min(d, sdSegment(p, v * len, v * (len + .11)));\n    \n    return abs(d) - gLineWidth;\n}\n\nfloat sdMinuteHand(in vec2 p) {\n    float t      = getMinute();\n    float theta  = -pi * 2.0 * (t / 60.0 - 0.25);\n    \n    if (!BE_A_BORING_NORMAL_CLOCK) {\n          theta += -pi * 2.0 * (getHour() / 12.0);\n    }\n    \n    float len    = 0.82;\n    \n    float d      = 1e9;\n    vec2  v      = vec2(cos(theta), sin(theta));\n    \n    d  = min(d, sdSegment(p, v * 0.0, v * len));\n    d -= length(p) / len * 0.025;  \n    d -= 0.02;\n    d = min(d, sdSegment(p, v * len, v * (len + .09)));\n    \n    return abs(d) - gLineWidth;\n}\n\nfloat sdTicks(in vec2 p) {\n    vec2 q;\n    float d = 1e9;\n    \n    q = opRing(p, 1.0, 12.0).xy;\n    d = min(d, sdSegment(q, vY * 0.23, vY * 0.27) - gLineWidth * 2.0);\n    \n    float numMinuteTicks = BE_A_BORING_NORMAL_CLOCK ? 60.0 : 55.0;\n    q = opRing(p.yx, 1.0, numMinuteTicks).xy;\n    d = min(d, sdSegment(q, vY * 0.05, vY * 0.08) - gLineWidth * 0.5);\n    \n    return d;\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = VIEWFROMSCREEN_DIST(2.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n    \n    vec3 rgb = v1.xxx * 0.3;\n    \n    float d = 1e9;\n    d = min(d, sdHourHand(p)   - 0.0);\n    d = min(d, sdMinuteHand(p) - 0.0);\n    float hands = d;\n    d = min(d, abs(length(p)   - 1.0) - gLineWidth);\n    d = min(d, sdTicks(p));\n    \n    float c = smoothstep(gAAEps, -gAAEps, d);\n    \n\n    rgb = mix(rgb, vec3(0.2), smoothstep(gAAEps, 0.0, length(p) - 1.0));\n\n    rgb = mix(rgb, vec3(0.15), smoothstep(gLineWidth * 15.0, 0.0, hands));\n    \n    rgb = mix(rgb, vec3(1.0), c);\n    \n    RGBA.rgb  = rgb;\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec2  vX  = v01.yx;\nconst vec2  vY  = v01.xy;\nconst vec2  v0  = v01.xx;\nconst vec2  v1  = v01.yy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n//----------------------------------------------------------------\n// SDF Stuff\n\n// Orion Elenzil\n// From https://www.shadertoy.com/view/43l3zr\n//\n// repeats the origin 'reps' times\n// around a ring of radius 'rad'.\n//\n// reps must be a positive integer.\n//\n// returns:\n//   v.xy = new coordinates\n//   v.z  = cell index, [0, reps - 1].   \nvec3 opRing(in vec2 p, float rad, float reps) {\n    float scale = pi * 2.0 / reps;\n    float theta;\n    float cell;\n    float isEven;\n    \n    // theta in [-ùúã, ùúã]\n    theta  = atan(p.y, p.x);\n    \n    // scale theta to [-reps/2, reps/2]\n    theta /= scale;\n\n    // determine cell index\n    isEven = float((int(reps) + 1) % 2);\n    cell   = theta + (reps + isEven) / 2.0;\n    cell   = floor(mod(cell, reps));\n\n    // repeat space. theta in [-1/2, 1/2]\n    theta  = fract(theta + 0.5) - 0.5;\n    \n    // scale up again\n    theta *= scale;\n    \n    // polar to cartesian\n    p      = vec2(cos(theta), sin(theta)) * length(p);\n\n    // move the origin onto the ring\n    p.x   -= rad;\n\n    // align +x to be counter-clockwise along the ring.\n    // this might not be what you want,\n    // but it seems natural to me.\n    p      = vec2(p.y, -p.x);\n\n    return vec3(p, cell);\n}\n\n\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}