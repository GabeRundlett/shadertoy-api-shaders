{
    "Shader": {
        "info": {
            "date": "1586147673",
            "description": "Trying to figure out voxels",
            "flags": 0,
            "hasliked": 0,
            "id": "WdByRW",
            "likes": 6,
            "name": "Voxel Flower",
            "published": 3,
            "tags": [
                "raymarching",
                "flower",
                "voxel"
            ],
            "usePreview": 0,
            "username": "Roninkoi",
            "viewed": 472
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n#define MAXIT 180\n#define EPSILON 0.05\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n \nfloat bud(vec3 r, float a)\n{\n\tr.xz += cos((r.y + r.z) * 3.) * 0.2;\n\t\n\tr.y += sin(length(r.xzx) * 6.) * 0.2;\n\t\n    return length(r) - a + sin(length(r.xz) * 12.) * 0.4;\n}\n\nfloat stem(vec3 r, vec2 a)\n{\n\tr.xz += cos(r.y) * 0.15 + sin(r.y * 1.5) * 0.3;\n\tr.xz += cos(r.y * 0.25) * 1.;\n\t\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat leaf(vec3 r, vec3 a)\n{\n\tr.xz += sin(length(r.xz + 1.) * 1.5);\n\tr.y += (r.x + r.z) * 0.5;\n\tr.x *= 0.9;\n\t\n    vec3 p = abs(r) - a;\n\t\n    return length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nmat3 obj;\n \nvec2 map(vec3 r)\n{\n    float b = 0.05;\n    vec3 rr = vec3(0.);\n    rr.x = floor(r.x / b) * b;\n    rr.y = floor(r.y / b) * b;\n    rr.z = floor(r.z / b) * b;\n\t\n    vec3 rb1 = obj * rr;\n    \n    vec2 b1 = vec2(\n        bud(rotX(0.6) * rotZ(-0.1) * rb1, 2.),\n        (int(sin(rb1.xyz * 5.) * cos(rb1.yxz * 5.) * 2.) % 2)\n    );\n\tvec2 s1 = vec2(\n        stem(rb1 + vec3(0., 7., 1.), vec2(.3, 6.81)),\n        (int(sin(rb1.y * 3.1) * 2.) % 2) + 2\n    );\n\t\n\tvec2 l1 = vec2(\n        leaf(rb1 + vec3(1.5, 5., 2.2), vec3(1., 0.1, 1.0)),\n        (int(sin(rb1.x * rb1.z * 4.1) * 2.) % 2) + 4\n    );\n    \n    return minx2(l1, minx2(b1, s1));\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == 0.)\n        return normalize(vec3(1., 0., .0));\n   \n    if (o.y == 1.)\n        return normalize(vec3(1.1, 0., .6));\n    \n    if (o.y == 2.)\n        return (vec3(0.4, .5, 0.));\n    \n    if (o.y == 3.)\n        return normalize(vec3(.2, 1., 0.4));\n    \n    if (o.y == 4.)\n        return (vec3(0.8, .5, 0.));\n    \n    if (o.y == 5.)\n        return normalize(vec3(.5, .5, 0.));\n   \n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n    \n    obj = rotY(t);\n    obj *= mat3(2.);\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 0.5, -3.3);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = normalize(vec3(.8, 2., 0.7)) * (.7 + cos(length(uv.xy) * 1.5) * .6) * 0.8;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * d.x * 0.15;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.8)\n\t\tcol.rgb *= exp(-sqrt(sh) * 1.2);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}