{
    "Shader": {
        "info": {
            "date": "1590661432",
            "description": "Mandelbulb fractal.\nCan be rotated with the mouse.",
            "flags": 0,
            "hasliked": 0,
            "id": "WdSfDG",
            "likes": 2,
            "name": "Mandelbuld fractal",
            "published": 3,
            "tags": [
                "3d",
                "fractal",
                "mandelbulb",
                "raymarcing"
            ],
            "usePreview": 0,
            "username": "kotfind",
            "viewed": 437
        },
        "renderpass": [
            {
                "code": "#define u_resolution iResolution.xy\n#define u_mouse iMouse.xy\n#define u_time iTime\n\n#define inf 1000000.0\n#define M_PI 3.1415926\n\nfloat map(in vec3 p) {\n\tvec3 z = p;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n    float power = 8.0;\n\n\tfor(int i = 0; i < 8; ++i)\n    {\n\t\tr = length(z);\n\n\t\tif(r > 2.0)\n            continue;\n\n\t\ttheta = power * atan(z.y / z.x);\n        phi   = power * (asin(z.z / r) + u_time * 0.2);\n\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n\n\t\tz = r * vec3(cos(theta) * cos(phi),\n                     sin(theta) * cos(phi),\n                     sin(phi)) + p;\n\t}\n\n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat cast_ray(in vec3 ro, in vec3 rd) {\n    float t = 0.01;\n    for (int i = 0; i < 100; ++i) {\n        vec3 p = ro + t * rd;\n\n        float h = map(p);\n        if (h < 0.001) break;\n        if (t > 10.0) break;\n        t += h;\n    }\n    if (t > 10.0) t = inf;\n    return t;\n}\n\nvec3 calc_normal(in vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //                      map(p + e.yxy) - map(p - e.yxy),\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n    float d = map(p);\n    return normalize(vec3(map(p + e.xyy) - d,\n                          map(p + e.yxy) - d,\n                          map(p + e.yyx) - d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy - u_resolution.xy / 2.0) / min(u_resolution.x, u_resolution.y);\n\n    float r     = 3.0;\n    float theta = 2.0*M_PI * (u_mouse.x / u_resolution.x - 0.25);\n    float phi   = 1.0*M_PI * (u_mouse.y / u_resolution.y + 0.000001);\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro = ta + r * vec3(sin(phi) * cos(theta), cos(phi), sin(phi) * sin(theta));\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 rd = normalize(vec3(uv.x*uu + uv.y*vv + 1.0*ww));\n\n    vec3 col = vec3(0.);\n\n    float t = cast_ray(ro, rd);\n    if (t < inf) {\n        vec3 p = ro + t*rd;\n        vec3 norm = calc_normal(p);\n\n        vec3 c = vec3(1.0);\n\n        vec3  sun1_dir = normalize(vec3(1.0, 2.0, 3.0));\n        float sun1_dif = clamp(dot(norm, sun1_dir), 0.0, 1.0);\n        float sun1_sha = step(inf - 1.0, cast_ray(p, sun1_dir)) * (1.0 - 0.2) + 0.2;\n\n        vec3  sun2_dir = normalize(vec3(-1.0, -2.0, -3.0));\n        float sun2_dif = clamp(dot(norm, sun2_dir), 0.0, 1.0);\n        float sun2_sha = step(inf - 1.0, cast_ray(p, sun2_dir)) * (1.0 - 0.2) + 0.2;\n\n        col = c * clamp(0.6 * (sun1_sha * sun1_dif + sun2_sha * sun2_dif), 0.05, 0.90);\n    }\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}