{
    "Shader": {
        "info": {
            "date": "1425137876",
            "description": "Demonstrating the optical illusion captured by accident in that notorious photograph:\nhttp://www.bbc.co.uk/news/uk-scotland-highlands-islands-31656935\n(The lack of) context is everything.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltfGDj",
            "likes": 6,
            "name": "White Gold Blue Black",
            "published": 3,
            "tags": [
                "opticalillusion",
                "colourperception"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1820
        },
        "renderpass": [
            {
                "code": "// Hazel Quantock 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// Obviously in reality there's a lot of other effects at work,\n// but for this I've just used exposure and white balance.\n\n\nfloat DressDF( vec3 p )\n{\n    //return max( abs(p.y)-1.0, length(p.xz)-.5 ); // vaguely dress shaped\n    \n    return length( max(vec3(.0),abs(p)-vec3(0,.5,0)) )-.5 + sin(p.y*8.0)*.3/8.0 + sin(p.x*17.0+sin(p.y*8.0))*.2/17.0;\n}\n\n\nfloat RoomDF( vec3 p )\n{\n    p = abs(p-vec3(-1,1,-1)); // centre of the room\n    const vec3 dim = vec3(3,2.2,3);\n    \n    vec3 i = dim-p; // interior\n    vec3 o = -(i+.1); // exterior\n\n    // front windows\n    i.z += .2;\n\n    float f = max(max(o.x,o.y),o.z);\n    \n    f = max( f, min(min(i.x,i.y),i.z) );\n    \n    return f;\n}\n\nfloat ObjectsDF( vec3 p )\n{\n    return length( abs(p-vec3(0,-.5,.3))-vec3(1,0,0) )-.3;\n}\n\nfloat DF( vec3 p )\n{\n    return min( min( DressDF(p), RoomDF(p)), ObjectsDF(p) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 iHalfRes = iResolution.xy/2.0;\n\n//    float whiteBalance = mix( .30, .70, sin(iTime)*.5+.5 );\n//    float exposure = exp2( sin(iTime/3.0)*2.0 );\n    \n    vec2 div = vec2(iHalfRes.x*(1.0+.5*sin(iTime*.5)),.0);\n    if ( iMouse.z > .0 )\n        div = iMouse.xy-vec2(.0,iHalfRes.y);\n\n    float whiteBalance, exposure;\n    if ( fragCoord.x < div.x )\n    {\n        // settings for a blue dress:\n        whiteBalance = .2;\n        exposure = 3.0;\n    }\n    else\n    {\n        // settings for a white dress:\n        whiteBalance = .75;\n        exposure = .5;\n    }\n    \n    // make a shape to place the material on\n    // so we can test lighting, volumetric mapping, etc\n    vec3 ray = normalize(vec3(fragCoord.xy-iHalfRes,iHalfRes.y*3.0));\n    \n    vec2 r = vec2(0);\n    r = mix( vec2(-.1,1), vec2(.5,-.5), smoothstep( -.8, .8, sin( iTime / vec2(2.3,3.1) ) ) );\n    //if ( iMouse.z > .0 ) r += vec2(-2,3)*(iMouse.yx/iHalfRes.yx-1.0);\n    \n    vec2 c = cos(r);\n    vec2 s = sin(r);\n    \n    ray.yz = ray.yz*c.x + vec2(-1,1)*ray.zy*s.x;\n    ray.xz = ray.xz*c.y + vec2(1,-1)*ray.zx*s.y;\n\n    vec3 p = vec3(-c.x*s.y,s.x,-c.x*c.y)*4.0;\n    \n    float h;\n    for ( int i=0; i < 100; i++ )\n    {\n        h = DF(p);\n        p += ray*h;\n        if ( h < .0001 )\n            break;\n    }\n    \n    \n   \tvec3 col = 8.0*pow( texture( iChannel1, ray ).rgb, vec3(2.2) );\n\n    vec3 albedo = col;\n    if ( h < .1 )\n    {\n        if ( DressDF(p) < .01 )\n        {\n            // lilac and brown, similar to the actual colours in the dress *image*\n            albedo = mix( vec3(.2,.4,1), vec3(.07,.07,.03), step(fract(p.y*1.7),.3) );\n\n            // then compute what the albedo would have to be to look this way in the final image, given the current lighting/camera settings\n            albedo /= exposure;\n            albedo /= mix( vec3(2,1,0), vec3(0,1,2), whiteBalance-.05 );\n        }\n        else if ( ObjectsDF(p) < .01 )\n        {\n            vec3 blue = vec3(.2,.4,1)/(3.0*vec3(1.7,1,.3));\n            vec3 white = vec3(.2,.4,1)/(.5*vec3(.6,1,1.4));\n            albedo = (p.x > .0) ? blue : white;\n        }\n        else\n        {\n            if ( p.y <= -1.199 )\n            {\n                // floor\n            \talbedo = pow( texture( iChannel0, p.xz/2.0 ).rgb, vec3(2.2) );\n\t\t\t}\n            else\n            {\n                albedo = vec3(1.3,1,.8);\n            }\n        }\n        \n        vec2 d = vec2(-1,1)*.0001;\n        vec3 n = normalize(\tDF(p+d.xxx)*d.xxx +\n                           \tDF(p+d.xyy)*d.xyy +\n                           \tDF(p+d.yxy)*d.yxy +\n                           \tDF(p+d.yyx)*d.yyx );\n        \n        vec3 light = vec3(.3);\n        light += max(.0,dot(n,normalize(vec3(1,3,-1))))*1.0;\n        light += max(.0,dot(n,normalize(vec3(1,2,3))))*2.0;\n        \n        col = albedo*light;\n    }\n\n\n    // fade out the camera effects periodically\n    float fade = smoothstep( .7, .85, sin(iTime) );\n//    if ( iMouse.z > .0 ) fade = iMouse.y/iResolution.y;\n    \n    exposure = mix( exposure, 1.0, fade );\n    whiteBalance = mix( whiteBalance, .5, fade );\n    \n    \n    // colour correction, similar to a camera\n    // exposure\n    col *= exposure;\n    \n    // white balance\n    col *= mix( vec3(2,1,0), vec3(0,1,2), whiteBalance-.05 );\n    \n    /*if ( fragCoord.y < div.y )\n    {\n        // show actual colour\n        col = albedo;\n    }*/\n\n    fragColor = vec4( pow(col,vec3(1.0/2.2)), 1 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}