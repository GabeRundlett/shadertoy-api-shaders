{
    "Shader": {
        "info": {
            "date": "1495831831",
            "description": "mouse input!\n\nhttps://en.wikipedia.org/wiki/Glide_reflection\nThe darker half is the mirrored duplicate\nmirror() abs()es a reflection to render in a single pass\ntransflect() adds offset to the mirror image,like footprints\n\ncould use pMod() along the mirror",
            "flags": 0,
            "hasliked": 0,
            "id": "XsfBDH",
            "likes": 3,
            "name": "glide reflect transflect",
            "published": 3,
            "tags": [
                "reflection",
                "mirror",
                "tiling",
                "reflect",
                "euclidean",
                "tesselation",
                "wallpaper",
                "wallpapergroup",
                "pmodmirror",
                "transflect",
                "isometrie",
                "glide"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 668
        },
        "renderpass": [
            {
                "code": "//self: https://www.shadertoy.com/view/XsfBDH\n//dad : https://www.shadertoy.com/view/lsBcDt   (sloppy mirror tesselation)\n//mon : https://www.shadertoy.com/view/4dfBRn   (previous failed attempt)\n\n/*\nhttps://en.wikipedia.org/wiki/Glide_reflection\nThe darker (less green) half is the mirrored duplicate.\n\nmirror() abs()es a mirror imate to render in a single pass.\ntransflect() adds an offset to the mirror image, like 2 footprints\nThe mirror image is offset by [transflectOffset]\n\nI am pretty sure i made this uneccessesarrily complicated\njust by adding mouse input.\n\nthis could use pmod() or pmodmirror below.\n*/\n\n//mirror changes over time (moves or rotates or both)\n#define MirrorMove\n#define MirrorRotate\n//the mirror image is offset to the side like 2 footpriints (transflection==https://en.wikipedia.org/wiki/Glide_reflection)\n#define transflectOffset -1.5\n\n/*\n//pMod       repeats space, f(x)=x -> fract(x)       =   seesaw-wave\n//pModMirror repeats space, f(x)=x -> fract(x)*2.-1. = triangle-wave\n//pMod* functions inout-project p into a tile via fract(), with offset,\n//... and return a tileIDoffset that is \"floor()\", with offset\nfloat pMod(inout float p,float s){float c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nfloat pModMirror(inout float p,float s){float c=pMod(p,s);p*=mod(c,2.)*2.-1.;return c;}\nvec2 pMod(inout vec2 p,vec2 s){vec2 c=floor((p/s)+.5);p=(fract((p/s)+.5)-.5)*s;return c;}\nvec2 pModMirror(inout vec2 p,vec2 s){vec2 c=pMod(p,s);p*=mod(c,2.)*2.-1.;return c;}\n//http://mercury.sexy/hg_sdf/\n*/\n\n/*\n//possibly useful for an extension.\nfloat pModMirror1interval(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n    float start =-1.;\n    //above is pModMirror\n    //fused with\n    //below is pModInterval\n    float stop=0.;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c );\n\t\tc = stop;\n\t}if (c <start) {\n\t\tp += size*(c);\n\t\tc = start;\n\t}return c;}*/\n\n//return mirror duplicate of [m]mousePos and [u]FragmentPos on axis y=0;\nvoid mirror(inout vec2 u,inout vec2 m){m.y=abs(m.y);u.y=abs(u.y);}\n//mirror(), but the mirror immage is offset by [o]\nvoid transflect(inout vec2 u, inout vec2 m,float o){\n if(m.y<0.){u.x+=step(0.,u.y)*o;}//if (sign(u.y)>0.)u.x+=o;}\n else u.x+=step(u.y,0.)*o;//if (sign(u.y)<0.)u.x+=o;\n mirror(u,m);}\n\n//return distance to a, asymmetric glyph, to tell what symmetry transformatiosns are happening.\nfloat AsymmetricGlyph(vec2 p){p.y=-p.y;p+=.5;\n float a=min(length(p),length(p-.4)*.5);\n p.y+=.2;return max(a,-length(p)+.5);}//the claw! (i was in a hurry)\n\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n\n#define frame(u) (u-.5*iResolution.xy)/iResolution.y\nvoid mainImage(out vec4 O,in vec2 U){vec2 u=frame(U)*6.;\n vec2 m;\n if (iMouse.z<0.) m=-vec2(2,1);\n else m=frame(iMouse.xy)*6.;\n float time=iTime*.2;\n #ifdef MirrorMove\n  float t=sin(time)*2.;u.y+=t;m.y+=t;//move mirror over time.\n #endif\n #ifdef MirrorRotate\n  u.x-=.4;m.x-=.4;\n  mat2 a=r2(time*.61);m*=a;u*=a;//rotate mirror over time\n #endif\n bool isMitrrored=(sign(m.y)!=sign(u.y));//if(fragment is in mirror image)\n transflect(u,m,transflectOffset);\n float d=AsymmetricGlyph(m-u);\n //d=length(m-u);//simpler less symmetrical distance to mouse position.\n d=fract(d*3.1);//seesaw first derivative, contrast illusion.\n u=fract(u+.02);//shows that the whole domain is transflect-ed, and small offset shows the mirror\n if(isMitrrored)u*=.4;\n u.x*=.7;//less green = better dichromacy contrast.\n O=vec4(d,u,1.);} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}