{
    "Shader": {
        "info": {
            "date": "1520703888",
            "description": "Edit ROUGHNESS in code to adjust blurriness of the reflection.\nSee comment in code for camera controls.\nScatter reflection rays using micornormals distributed with a pow curve, using the distribution function from https://www.shadertoy.com/view/4sdcD8",
            "flags": 48,
            "hasliked": 0,
            "id": "Md3yWl",
            "likes": 42,
            "name": "Blurred Reflections",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "camera",
                "material"
            ],
            "usePreview": 0,
            "username": "TekF",
            "viewed": 1678
        },
        "renderpass": [
            {
                "code": "// Cylinder Ray Tracer - Plus motion blur & depth of field\n// by Hazel Quantock\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n/*\n\nCAMERA CONTROLS\n\nRotate: Mouse Drag\nMove: WASDRF or cursors\nAdjust Focus: Page Up, Page Down, Auto Focus: Home (toggle)\nAperture: []\nZoom: -+\nExposure: <>\n\n*/\n\n#define ROUGHNESS .05\n\n// comment this out to use a random sample pattern\n#define PATTERN_RAND 1\n\n#define NUM_SAMPLES 40\n\n// comment this out to remove some lens curving effects\n#define LENSFX 1\n\n\nvec3 SphereRand( vec2 rand )\n{\n    rand += .5;\n    // use interference of 2 very large numbers, calibrated (by hand) to cover\n    // lots of different directions very early on, and to fill in the gaps eventually\n    float sina = rand.x*2. - 1.;\n    float b = 6.283*rand.y;\n    float cosa = sqrt(1.-sina*sina);\n    return vec3(cosa*cos(b),sina,cosa*sin(b));\n}\n\nvec3 PowRand( vec2 rand, vec3 axis, float fpow )\n{\n    vec3 r = SphereRand(rand);\n    \n    // redistribute samples\n\n    float d = dot(r,axis);\n\n    // map sphere to cylinder\n    r -= d*axis;\n    r = normalize(r); // hahaha! I'd forgotten this, very clever\n\n    // project onto a spike\n    // h = pow(1.-radius,m)*2-1\n    // radius = 1.-pow(h*.5+.5,1/m)\n    // ^ WRONG! That's radius squared, otherwise POW=1 gives a spike\n    float h = d*.5+.5;\n    //        r *= sqrt(1.-pow(h,1./POW));\n    // ^ wrong again! Need to solve the integral with that sqrt in,\n    // and needed a factor of /radius for sample density\n    r *= sqrt( 1. - pow( h, 2./(fpow+1.) ) ); // YES!!!!\n\n    // and down onto the hemisphere\n    r += axis*sqrt(1.-dot(r,r));\n\n    return r;\n}\n\n\n\nvec3 ShadeRay( vec3 pos, vec3 ray, float time, vec4 rand )\n{\n    // animate moving objects\n    float r = -(time+sin(time))*10.;\n    float a = time/3.;\n    vec4 s0 = vec4(.1*cos(a),.1*sin(a)+.05,0,1), s1 = vec4(-.1*cos(a),-.1*sin(a)+.05,0,2);\n    s0.xz = s0.xz*cos(r)+sin(r)*vec2(1,-1)*s0.zx;\n    s1.xz = s1.xz*cos(r)+sin(r)*vec2(1,-1)*s1.zx;\n    //s0.w *= .5+.5*pow(1.-fract(time*2.),2.);\n    Scene[0] = s0;\n    Scene[1] = s1;\n    \n    vec3 normal = vec3(0);\n    int material = 0;\n    float t = Trace(normal,material,pos,ray);\n    \n    vec3 col = Sky(ray);\n    if ( length(normal) > 0. )\n    {\n        pos += ray*t;\n\n        Material mat = GetMaterial(pos,material);\n        \n        if ( material == 2 ) mat.roughness = ROUGHNESS;\n\n        float specPower = 1./(mat.roughness*mat.roughness);\n        float specStrength = (specPower+8.)/(4.*tau);\n        \n\n        // sample light\n        vec3 sun = normalize(vec3(-.5,2,3));\n        \n        // soften shadow by sampling radius around sun\n        vec3 areaLight = PowRand( rand.zx, -sun, 1. );\n        vec3 suntap = normalize( sun + areaLight*.03 );\n        \n        vec3 testn = vec3(0);\n        int ignore;\n        Trace(testn,ignore,pos,suntap);\n        \n        float ndotl = max(0.,dot(normal,sun));\n        float ndoth = max(0.,dot(normal,normalize(-ray+sun)));\n\n        vec3 ambientColour = vec3(.05,.065,.09);\n        vec3 lightColour = vec3(1,.95,.92);\n        vec3 light = ambientColour*(normal.y*.3+1.); // ambient\n        vec3 specular = vec3(0);\n        if ( length(testn) == 0. )\n        {\n        \tlight += ndotl * lightColour;\n\t        specular += lightColour*ndotl*pow(ndoth,specPower)*specStrength;\n        }\n\n        \n        // randomize reflection direction with Blinn-Phong probability distribution\n        vec3 microfacet = PowRand( rand.zy, normal, specPower );\n\n        // sample reflection\n        vec3 reflection = vec3(0);\n        \n        if ( dot(microfacet,ray) < 0. ) // cull microfacets pointing away from camera\n        {\n            vec3 refray = reflect(ray,microfacet);\n            vec3 refn = vec3(0);\n            int refmati = 0;\n            float reft = Trace(refn,refmati,pos,refray);\n\n            reflection = Sky(refray);\n            if ( length(refn) > 0. )\n            {\n                Material refmat = GetMaterial(pos+refray*reft,refmati);\n                reflection = refmat.albedo * (max(0.,dot(refn,sun)) * lightColour + ambientColour*(refn.y*.3+1.));\n            }\n        }\n        \n        reflection += specular;\n        \n        col = light*mat.albedo;\n\n        vec3 fresnel = mix( mat.specularColour, vec3(1), pow(1.-dot(-ray,normal),5.) );\n        \n        col = mix( col, reflection, fresnel );\n    }\n    \n    return col;\n}\n\n\nvec4 PatternRand( uint seed )\n{\n    return vec4(\n        float((seed*0x73494U)&0xfffffU)/float(0x100000),\n    \tfloat((seed*0xAF71FU)&0xfffffU)/float(0x100000),\n        float((seed*0x67a42U)&0xfffffU)/float(0x100000), // a bit stripey against x and z, but evens out over time\n        float((seed*0x95a8cU)&0xfffffU)/float(0x100000) // good vs x or y, not good against z\n        );\n}\n\n\nuvec4 Hash( uint seed ) \n{\n    // integer hash from Hugo Elias\n\tseed = (seed << 13U) ^ seed;\n    seed = seed * (seed * seed * 15731U + 789221U) + 1376312589U;\n    return seed * uvec4(seed,seed*16807U,seed*48271U,seed*31713U);\n}\n\n\nvec4 Rand( uint seed )\n{\n    vec4 pattern = PatternRand(seed);\n    vec4 random = vec4(Hash(seed)&0x7fffffffU)/float(0x7fffffffU);\n#if defined(PATTERN_RAND)\n    //return pattern;\n    // break up patterns in the bokeh by distorting the regular sample positions\n\treturn fract( pattern + random*sqrt(1./float(NUM_SAMPLES)) );\n    // OMG this fixes some really big artefacts that can occur when moire patterns phase!\n#else\n    return random;\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec4 parameters = GetParameters();\n    \n    uint n = uint(NUM_SAMPLES); // it actually runs fine with higher numbers, but I want to see the noise!\n    \n    uint pseed = (uint(iFrame)<<12U) + (uint(fragCoord.y)<<6U) + uint(fragCoord.x);\n    \n//    vec4 prand = Rand( pseed );\n//    float motionJitter = prand.y;\n\n    // pixel noise, but per-pixel samples and motion blur are still coherent\n//    pseed = uint(Rand(pseed).y*float(0x100000));\n    pseed = ((pseed*0xAF71FDU) + ((Hash(pseed).x&0x7ffU)/n))&0xffffffU;//((1U<<uint(exp2(ceil(log2(sqrt(float(n)))))))-1U));\n\n    if ( n < 20U ) pseed *= n; // gives a more stable result for high n, but ugly for low n\n    \n    for ( uint i=0U; i < n; i++ )\n    {\n        uint seed = pseed + i;\n\t    vec4 rand = Rand( seed );\n        \n        float f = rand.z;//(float(i)+motionJitter)/float(n);\n//rand.z is still interfering with the aperture => my non-phasing things are phasing!\n        \n        // with high time values and high number of samples precision can cause samples to coincide\n        // could improve this by frac'ing to period of any looped animations\n    \tfloat time = iTime+iTimeDelta*f;\n//time *= 20.; // lol!\n        \n/*        vec2 a = vec2(-sin(time*.0626)*.3+.08,time*6.283/60.-2.);\n        vec3 cam = 5.*vec3(sin(a.y)*cos(a.x),sin(a.x),cos(a.y)*cos(a.x));\n        vec3 target = vec3(-.5,.5,0);\n\n        vec3 camk = normalize(target-cam);\n        vec3 cami = normalize(cross(vec3(0,1,0),camk));\n        vec3 camj = cross(camk,cami);*/\n\t\tCamera cam = GetCamera();\n\n        rand -= .5;\n\n        vec3 ray = vec3( (fragCoord + rand.zw - iResolution.xy*.5)/iResolution.y, parameters.x );\n        \n        // offset source for focal blur\n        vec3 pos = vec3( rand.xy, 0 ); // rand is in the range -.5 to .5\n\n\t\t// hexagonal bokeh: chop corners off the square and move them to make hexagon\n        /* ____         ____         ____\n         |/\\  /\\|      |\\  /\\ |     /\\  /\\a \n         |__\\/__|      |_\\/__\\|    /b_\\/__\\  \n         |  /\\  |      | /\\  /|    \\a /\\  /  \n         |\\/__\\/|      |/__\\/ |     \\/__\\/b\n            (1)           (2)         (3)      */\n        pos.x += .25/1.5; // (1) -> (2)\n        if ( pos.x > .5-abs(pos.y)*2./3. )\n        {\n\t        // (3)\n            pos.x -= 1.;\n            pos.y = fract(pos.y)-.5;\n        }\n\n        // scale vertically to make a regular hexagon\n        pos.y *= sqrt(3.)/1.5;\n        \n        // rotate (pyth 9^2+40^2=41^2)\n        pos.xy = pos.xy*40./41. + pos.yx*vec2(9,-9)/41.;\n        \n#if defined (LENSFX)\n        // distort the bokeh a little near the screen edges\n        pos.xy -= 1.*(pos.xy-ray.xy)*dot(ray.xy,pos.xy); // AWESOME!\n\n        // and distort the lens a little\n        float distort = -.03;// -ve for barrel, +ve for pincushion distortion\n        ray.z *= 1.+distort*(dot(ray.xy,ray.xy)-.5);\n#endif\n        \n        pos *= parameters.z;\n        \n        ray /= ray.z;\n        \n        // start out of focus, to show off! :)\n//        float focus = mix( 2., length(target-cam.pos), .8*smoothstep(.5,1.,time) );\n        float focus = parameters.y;\n        ray.xy -= pos.xy/focus; // focus rays at correct distance\n        \n        \n        ray = normalize(ray);\n\n        ray = ray.x*cam.i + ray.y*cam.j + ray.z*cam.k;\n        pos = pos.x*cam.i + pos.y*cam.j + cam.pos;\n        \n        \n        fragColour.rgb += ShadeRay(\n            \t\t\t\tpos, ray,\n                            time\n                            //+ 8.*sin(time/4.)*fragCoord.x/iResolution.x\n                            //+ exp2(sin(time)*4.)*fragCoord.y/iResolution.y\n            \t\t\t\t, rand\n                            );\n    }\n    fragColour.rgb /= float(n);\n    \n    // vignetting\n#if defined (LENSFX)\n    {\n    \tvec3 ray = vec3( (fragCoord - iResolution.xy*.5)/iResolution.y, 50./36. );\n    \tfragColour.rgb *= 1.1*smoothstep(.6,1.,normalize(ray).z);\n\t}\n#endif\n    \n    fragColour.rgb *= parameters.w;\n\n    // soft clamp to white (oh this is so good)\n    const float whiteSoftness = 0.1;\n    float w2 = whiteSoftness*whiteSoftness;\n    fragColour.rgb += w2;\n    fragColour.rgb = (1.-fragColour.rgb)*.5;\n    fragColour.rgb = 1. - (sqrt(fragColour.rgb*fragColour.rgb+w2) + fragColour.rgb);\n    // might be nnice to do this in grey, so colours don't shift, but looks quite photographic like this\n    \n    //fragColour = vec4(pow(fragColour.rgb,vec3(1./2.2)),1.0); // approx sRGB\n    // sRGB\n\tfragColour = mix( 12.92 * fragColour,\n                     1.055 * pow(fragColour, vec4(1./2.4)) - 0.055,\n                     step(0.0031308,fragColour));\n\t// signature\n\t#define L(m,n,u,v,l,f) min(f,max(abs(dot(fragCoord-vec2(m,n),vec2(u,v)))-l,abs(dot(fragCoord-vec2(m,n),vec2(-v,u)))-1.))\n\tfloat sig=L(3,7,0,1,3.5,L(7,7,0,1,3.5,L(5,7,1,0,2.,L(14.5,5,.7071,-.7071,2.5,abs(length(fragCoord-vec2(12.7,7))-3.)-1.))));\n\tfragColour.rgb = clamp(fragColour.rgb,0.,1.)*sig/(.1+abs(sig));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float tau = 6.283185;\n\n// Scene\n\n// list of cylinders\n// Each cylinder is decribed by a pair of vec4's:\n// vec4( start position, radius ), vec4( end pos, material index )\nvec4 Scene[] = vec4[](\n    vec4(-.7071,-1.+.7071,0,.2), vec4(.7071,-1.+3.*.7071,0,2),\n    vec4(0,-1.3,0,10), vec4(0,-2,0,0),\n    vec4(0,-1,0,3.5), vec4(0,-2,0,1),\n    vec4(0,-1,3,.2), vec4(0,4,3,0),\n    vec4(2.12,-1,2.12,.2), vec4(2.12,4,2.12,0),\n    vec4(3,-1,0,.2), vec4(3,4,0,0),\n    vec4(2.12,-1,-2.12,.2), vec4(2.12,4,-2.12,0),\n    vec4(0,-1,-3,.2), vec4(0,4,-3,0),\n    vec4(-2.12,-1,-2.12,.2), vec4(-2.12,4,-2.12,0),\n    vec4(-3,-1,0,.2), vec4(-3,4,0,0),\n    vec4(-2.12,-1,2.12,.2), vec4(-2.12,4,2.12,0),\n    vec4(0,4,0,3.5), vec4(0,5,0,0)\n    \n    // tiny shapes for testing bokeh\n    /*,vec4(-1,0,-10,.05),vec4(-1,0,-10.01,0)\n    ,vec4(-1,0,-8,.05), vec4(-1,0,-8.01,0)\n    ,vec4(-1,0,-6,.05), vec4(-1,0,-6.01,0)\n    ,vec4(-1,0,-4,.05), vec4(-1,0,-4.01,0)\n    ,vec4(-1,0,-2,.05), vec4(-1,0,-2.01,0)*/\n    );\n\n\n// return a colour for a given direction\nvec3 Sky( vec3 ray )\n{\n//    return 5.*abs(sin(ray*50.))*step(2.5,abs(dot(sin(ray*80.+ray.yzx*80.),vec3(1))));//vec3(.01);\n\n    ray.y += .1;\n//    ray.y = max(0.,ray.y);\n    float d = .1;\n    ray.y = sqrt(ray.y*ray.y + d*d)-d;\n    return exp2(-ray.y/vec3(.1,.3,.6)); // blue\n//    return exp2(-ray.y/vec3(.18,.2,.28))*vec3(1,.95,.8); // overcast\n//    return exp2(-ray.y/vec3(.1,.2,.8))*vec3(1,.75,.5); // dusk\n//    return exp2(-ray.y/vec3(.03,.2,.9)); // tropical blue\n//    return exp2(-ray.y/vec3(.4,.06,.01)); // orange-red\n//    return exp2(-ray.y/vec3(.1,.2,.01)); // green\n}\n\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specularColour;\n    float roughness;\n};\n    \n\nMaterial GetMaterial( in vec3 pos, in int index )\n{\n    // base material parameters - can add some maths to modify this\n    const Material base[] = Material[](\n        Material(vec3(1),vec3(.004),.2), // white\n        Material(vec3(.05),vec3(.004),.05), // floor\n        Material(vec3(0,0,0),vec3(.8),.1) // disc (roughness gets overridden by ROUGHNESS)\n        );\n    \n    Material material = base[index];\n    \n    if ( index == 0 ) material.albedo *= smoothstep(.01,.02,abs(fract( pos+.001 )-.5));\n    \n    return material;\n}\n\n\n\n\n\n// Data-reading functions\n\nstruct Camera\n{\n    vec3 pos, i, j, k;\n};\n\nCamera GetCameraInternal( sampler2D dataTex )\n{\n    Camera cam;\n    cam.pos = texelFetch(dataTex,ivec2(0,0),0).xyz;\n    vec4 camrot = texelFetch(dataTex,ivec2(1,0),0);\n    \n    vec4 pitch = vec4(cos(camrot.x),sin(camrot.x)*vec2(1,-1),0);\n    vec4 yaw = vec4(cos(camrot.y),sin(camrot.y)*vec2(1,-1),1);\n    cam.i = vec3(yaw.x,0,yaw.z);\n    cam.j = pitch.yxy*yaw.ywx;\n    cam.k = pitch.xzx*yaw.ywx;\n    \n    return cam;\n}\n\n// x = zoom, y = focus, z = aperture, w = exposure\n// todo: white balance?\nvec4 GetParametersInternal( sampler2D dataTex )\n{\n    // all parameters want to be positive and exponential, so store their logs!\n    return exp2(texelFetch(dataTex,ivec2(2,0),0));\n}\n\n#define GetCamera() GetCameraInternal(iChannel0)\n#define GetParameters() GetParametersInternal(iChannel0)\n\n\n\n// Ray Tracing\n\n#define FLT_MAX 1e38\n\nfloat IntersectCylinder( out vec3 normal, vec4 a, vec4 b, vec3 pos, vec3 ray )\n{\n    vec3 m = (a.xyz+b.xyz)/2.;\n    \n    pos -= m; // centre all maths on the cylinder\n    \n    float radius = a.w;\n    vec3 n = (a.xyz-b.xyz)/2.;\n    float l = length(n);\n    n /= l;\n    \n    \n    // intersect infinite cylinder\n    // flatten everything along the axis\n    vec3 r = ray-dot(ray,n)*n;\n    vec3 p = pos-dot(pos,n)*n;\n    float rl = length(r);\n    r /= rl;;\n    float rdp = dot(r,p);\n    float pp = dot(p,p);\n    float q = pp - rdp*rdp;\n    if ( q >= radius*radius ) return FLT_MAX;\n    \n    float d = sqrt(radius*radius-q);\n    float front = (-rdp - d)/rl;\n    float back = (-rdp + d)/rl;\n    normal = normalize(p+front*r*rl);\n    \n    \n    // intersect facing plane\n    float rdn = dot(ray,n);\n    float pdn = dot(pos,n);\n    \n    if( rdn < 0. ) { n = -n; rdn = -rdn; pdn = -pdn; }\n    \n    float front2 = (-l-pdn)/rdn;\n    \n    if ( front2 > front )\n    {\n        front = front2;\n        normal = -n;\n    }\n\n    \n    // clip the back sides\n    if (\n        front > back || // clip to back of cylinder\n    \tpdn+rdn*front > l // clip to back plane\n        )\n        return FLT_MAX;\n    \n    return front;\n}\n\n\nfloat Trace( out vec3 normal, out int index, vec3 pos, vec3 ray )\n{\n    index = -1;\n    normal = vec3(0);\n    float t = FLT_MAX;\n    for ( int i=0; i < Scene.length(); i += 2 )\n    {\n        vec3 n;\n        float f = IntersectCylinder( n, Scene[i], Scene[i+1], pos, ray );\n        if ( f > 0. && f < t )\n        {\n            t = f;\n            normal = n;\n            index = int(Scene[i+1].w);\n            // todo: remember object index for material lookup\n        }\n    }\n    return t;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// Read Keyboard\nconst int // values from http://keycode.info/ - some might be browser/region dependent\nkReturn=13,kShift=16,kCtrl=17,kAlt=18,kSpace=32,kPgUp=33,kPgDn=34,kEnd=35,kHome=36,kLeft=37,kUp=38,kRight=39,kDown=40,kInsert=45,kDelete=46,\nk0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57,kPlusEq=61,kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,\nkL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90,kNum0=96,kNum1=97,kNum2=98,kNum3=99,kNum4=100,kNum5=101,\nkNum6=102,kNum7=103,kNum8=104,kNum9=105,kNumTimes=106,kNumPlus=107,kNumMinus=109,kNumPeriod=110,kNumDivide=111,kMinus=173,kSquareLeft=219,kSquareRight=221,\nkComma=188,kPeriod=190;\n#define Key(a) texelFetch(iChannel3,ivec2(a,0),0).x\n#define KeyToggle(a) texelFetch(iChannel3,ivec2(a,2),0).x\n\n\nbool reset = true; // first frame initialisation\n\n\nvec4 UpdatePosition()\n{\n    Camera cam = GetCamera();\n    \n    cam.pos += cam.i*1.*iTimeDelta*(Key(kD)-Key(kA)+Key(kRight)-Key(kLeft));\n    cam.pos += cam.j*1.*iTimeDelta*(Key(kR)-Key(kF));\n    cam.pos += cam.k*1.*iTimeDelta*(Key(kW)-Key(kS)+Key(kUp)-Key(kDown));\n    \n    return reset?vec4(-1.3,0,-4.,0):vec4( cam.pos, 0 );\n}\n\nvec4 UpdateRotation()\n{\n    vec4 camrot = texelFetch(iChannel0,ivec2(1,0),0);\n    \n    // mouse drag stuff always sucks... hmm...\n    // SHOULD be able to just measure difference between xy (current) and zw (last click), if x != 0.\n    if ( iMouse.z > 0. )\n    {\n        if ( camrot.z <= 0. ) camrot.zw = iMouse.zw;\n        \n        // drag in progress\n        // total drag distance is iMouse.xy-iMouse.zw - but we want realtime feedback so remember where we were last frame\n        vec2 delta = vec2(-1,1) * (iMouse.xy-camrot.zw)/iResolution.x;\n        camrot.zw = iMouse.xy;\n        camrot.xy += delta.yx;\n    }\n    else\n    {\n        camrot.zw = vec2(-1);\n    }\n    \n    return reset?vec4(0,.2,-1,-1):camrot;\n}\n\n\n\nvoid AutoFocus( inout float logDist )\n{\n    Camera cam = GetCamera();\n\n    // measure distance in front of camera\n    vec3 ignorev;\n    int ignorei;\n    float t = Trace( ignorev, ignorei, cam.pos, cam.k );\n    \n    t = clamp(t,0.,65536.);\n    \n    t = log2( t );\n    \n    // animate focus moving toward t\n    logDist += (t-logDist)*.04;\n}\n\n\nvec4 UpdateParameters()\n{\n    // x = zoom, y = focus, z = aperture, w = exposure\n    vec4 parameters = texelFetch(iChannel0,ivec2(2,0),0);//GetParameters();\n    \n    parameters.x += 1.*iTimeDelta*(Key(kNumPlus)-Key(kNumMinus) + Key(kPlusEq)-Key(kMinus));\n    parameters.y += 1.*iTimeDelta*(Key(kPgUp)-Key(kPgDn));\n    parameters.z += 1.*iTimeDelta*(Key(kSquareRight)-Key(kSquareLeft));\n    parameters.w += 1.*iTimeDelta*(Key(kPeriod)-Key(kComma));\n    \n    if ( KeyToggle(kHome) > 0. )\n    {\n        AutoFocus( parameters.y );\n    }\n    \n    return reset?log2(vec4(50./36.,4,.05,1.)):parameters;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    reset = (iFrame == 0);\n    \n    // read controls and update values\n    int pixel = int( fragCoord.x );\n    \n    fragColour = vec4(0);\n    if ( pixel == 0 ) fragColour = UpdatePosition();\n    if ( pixel == 1 ) fragColour = UpdateRotation();\n    if ( pixel == 2 ) fragColour = UpdateParameters();\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}