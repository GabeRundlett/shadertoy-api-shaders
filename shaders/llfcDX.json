{
    "Shader": {
        "info": {
            "date": "1506634077",
            "description": "Golan Levin's Polynomial Shaping Functions[0] ported to GLSL as an exercise from The Book of Shaders[1].  Comment out lines to visualize the functions.\n\n[0]: http://www.flong.com/texts/code/shapers_poly/\n[1]: https://thebookofshaders.com/05/",
            "flags": 0,
            "hasliked": 0,
            "id": "llfcDX",
            "likes": 1,
            "name": "Polynomial Shaping",
            "published": 3,
            "tags": [
                "gradient",
                "curve",
                "polynomial",
                "shaping"
            ],
            "usePreview": 0,
            "username": "lordbunson",
            "viewed": 891
        },
        "renderpass": [
            {
                "code": "const vec3 lineColor = vec3(0.0, 1.0, 0.0);\n\nfloat plotLine(vec2 uv, float y){\n    return smoothstep(y - 0.02, y, uv.y) -\n           smoothstep(y, y + 0.02, uv.y);\n}\n\n\n// Blinn-Wyvill Approximation to the Raised Inverted Cosine\nfloat cosineApprox(float x){\n    \n\tfloat x2 = x * x;\n    float x4 = x2 * x2;\n    float x6 = x4 * x4;\n    \n    float fa = 4.0 / 9.0;\n    float fb = 17.0 / 9.0;\n    float fc = 22.0 / 9.0;\n    \n    return fa * x6 - fb * x4 + fc * x2;\n}\n\n\n// Double-Cubic Seat\nfloat doubleCubicSeat(float x, float a, float b){\n\t   \n    float epsilon = 0.00001;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    float min_param_b = 0.0;\n    float max_param_b = 1.0;\n    \n    a = min(max_param_a, max(min_param_a, a));\n    b = min(max_param_b, max(min_param_b, b));\n    \n    float y = 0.0;\n    if(x <= a){\n    \ty = b - b * pow(1.0 - x / a, 3.0);   \n    } else {\n\t\ty = b + (1.0 - b) * pow((x - a) / (1.0 - a), 3.0);\n    }\n    \n    return y;\n}\n\n// Double-Cubic Seat with Linear Blend\nfloat doubleCubicSeatLinear(float x, float a, float b){\n    \n    float epsilon = 0.00001;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    float min_param_b = 0.0;\n    float max_param_b = 1.0;\n    \n    a = min(max_param_a, max(min_param_a, a));\n    b = min(max_param_b, max(min_param_b, b));\n    \n    b = 1.0 - b;\n    \n    float y = 0.0;\n    if(x <= a){\n    \ty = b * x + (1.0 - b) * a * (1.0 - pow(1.0 - x / a, 3.0 ));\n    } else {\n    \ty = b * x + (1.0 - b) * (a + (1.0 - a) * pow((x - a) / (1.0 - a), 3.0));\n    }\n    \n    return y;\n}\n\n// Symmetric Double-Polynomial Sigmoid\nfloat doublePolynomialSigmoid(float x, float a, float b, float n){\n\tfloat y = 0.0;\n    \n    if(int(n) % 2 == 0){ // even\n        \n        if (x <= 0.5){\n            y = pow(2.0 * x, n) / 2.0;\n        } else {\n            y = 1.0 - pow(2.0 * (x - 1.0), n) / 2.0;\n        }\n        \n    } else { //odd\n        \n        if(x <- 0.5){\n            y = pow(2.0 * x, n) / 2.0;\n        } else {\n            y = 1.0 + pow(2.0 * (x - 1.0), n) / 2.0;\n        }\n    }\n    \n    return y;\n}\n\n\n\n// Quadratic through a given point\nfloat quadraticPoint(float x, float a, float b){\n\n\tfloat epsilon = 0.00001;\n    float min_param_a = 0.0 + epsilon;\n    float max_param_a = 1.0 - epsilon;\n    float min_param_b = 0.0;\n    float max_param_b = 1.0;\n    \n    a = min(max_param_a, max(min_param_a, a));\n    b = min(max_param_b, max(min_param_b, b));\n    \n    float A = (1.0 - b) / (1.0 - a) - (b / a);\n    float B = (A * (a * a) - b) / a;\n    float y = A * (x * x) - B * (x);\n    y = min(1.0, max(0.0, y));\n    \n    return y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;  \n    \n    //float y = cosineApprox(uv.x);\n    \n    //float y = doubleCubicSeat(uv.x, 0.407, 0.720);\n    //float y = doubleCubicSeat(uv.x, 0.607, 0.247);\n    \n    float y = doubleCubicSeatLinear(uv.x, 0.640, 0.827);\n    //float y = doubleCubicSeatLinear(uv.x, 0.347, 0.887);\n    \n    //float y = doublePolynomialSigmoid(uv.x, 0.347, 0.887, 2.0);\n    \n    //float y = quadraticPoint(uv.x, 0.233, 0.340);\n    //float y = quadraticPoint(uv.x, 0.500, 0.307);\n    \n    vec3 gradient = vec3(y);\n    \n    float line = plotLine(uv, y);\n    \n    vec3 color = (1.0 - line) * gradient + line * lineColor;\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}