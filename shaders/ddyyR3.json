{
    "Shader": {
        "info": {
            "date": "1696387906",
            "description": "graphs stuff\nclick + drag to rotate",
            "flags": 48,
            "hasliked": 0,
            "id": "ddyyR3",
            "likes": 9,
            "name": "3d grapher",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "graph"
            ],
            "usePreview": 0,
            "username": "ArmandB",
            "viewed": 348
        },
        "renderpass": [
            {
                "code": "/*\nchange eq() to change what you're graphing\n*/\nfloat eq(vec3 p){\n    return sin(p.x*2.0) + sin(p.y*2.0) + sin(p.z*2.0);\n}\n\n//increasing helps with equations with tigher turns, but increases other artifacts\nfloat fidelity = 1.0;\n//increase for more accurate renders (but more lag)\nint maxsteps = 1024;\n\n//estimate of partial derivative\nvec3 partialEstimate(vec3 p){\n    vec2 e = vec2(0,0.001);\n    return vec3(\n        eq(p + e.yxx) - eq(p - e.yxx),\n        eq(p + e.xyx) - eq(p - e.xyx),\n        eq(p + e.xxy) - eq(p - e.xxy)\n    )/(e.y*2.0);\n}\n\n//estimates distance to implicit function\n//https://iquilezles.org/articles/distance/\nfloat distEstimate(vec3 p){\n    return abs(eq(p))/length(partialEstimate(p));\n}\n\n//returns distance to hit point\nfloat castRay(Ray ray){\n    //set march start to bounding box\n    float t;\n    float t2;\n    boxIntersection(ray, vec3(-1), vec3(1), t, t2);\n    if (t == 1e20) return 1e20; //ray does not intersect with bounding box\n    ray.origin += ray.direction*t;\n    \n    //raymarch\n    for (int i = 0; i < maxsteps; i++){\n        float d = distEstimate(ray.origin);\n        d = d/(d + fidelity); //removes some artifacts as d gets bigger\n        if (d <= 1e-4) return t;\n        if (t >= t2) return 1e20; //ray has exited bounding box\n        if (i == 255) return t; //removes edge artifacts\n        ray.origin += ray.direction*d;\n        t += d;\n    }\n    return 1e20;\n}\n\n//draws a 3d line to the screen\nvoid drawLine(inout vec4 col, vec3 a, vec3 b, vec3 lineCol, Camera cam){\n    mat3 inverseRot = inverse(cam.rotmat);\n    a *= inverseRot;\n    b *= inverseRot;\n    \n    vec2 ab = b.xy - a.xy;\n    float t = dot(cam.uv - a.xy, ab)/dot(ab, ab);\n    vec2 p2 = a.xy + clamp(t,0.0,1.0)*ab;\n    float d = distance(cam.uv,p2);\n    \n    //if (mix(a.z,b.z,t) > col.a){\n    col.rgb = mix(lineCol, col.rgb, smoothstep(0.0, 0.005, d));\n    //}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //cam setup\n    vec3 rotation = vec3(texelFetch(iChannel0, ivec2(1,0),0).yx*vec2(1,-1),0)*sensitivity;\n    Camera cam = createCamera(fragCoord, iResolution.xy, rotation, 5.0);\n    Ray ray = cam.ray;\n    \n    vec4 col = vec4(0);\n    float t = castRay(ray);\n    col.a = t;\n    if (t < 1e20){\n        vec3 point = ray.direction*t + ray.origin;\n        vec3 normal = normalize(partialEstimate(point));\n        normal = faceforward(normal,ray.direction,normal);\n        col.rgb = mix(hsvToRgb(vec3(0.5,1.0,0.2)), hsvToRgb(vec3(0.3,0.9,1.0)), smoothstep(0.0,1.0,normal.y*0.5 + 0.5));\n    } else {\n        col.rgb = vec3(1);\n    }\n    \n    //bounding box & axis lines\n    drawLine(col, vec3(2,2,2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(2,2,2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(2,2,2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,-2,2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,-2,-2), vec3(2,-2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(-2,-2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(-2,2,2), vec3(0.4), cam);\n    drawLine(col, vec3(-2,2,-2), vec3(2,2,-2), vec3(0.4), cam);\n    drawLine(col, vec3(2,0,0), vec3(-2,0,0), vec3(1,0,0), cam);\n    drawLine(col, vec3(0,2,0), vec3(0,-2,0), vec3(0,1,0), cam);\n    drawLine(col, vec3(0,0,2), vec3(0,0,-2), vec3(0,0,1), cam);\n\n    // gamma correction\n    fragColor = vec4(pow(col.rgb,vec3(1.0/2.2)),1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159265\n\nconst float sensitivity = 4.0;\nconst float moveSpeed = 0.1;\nconst float moveDamping = 0.7;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    Ray ray;\n    mat3 rotmat;\n    vec2 res;\n    vec2 uv;\n};\n\n//fakes x^n for various effects\nfloat fpow(float x, float k){\n    return x > k ? pow((x-k)/(1.0-k),2.0) : 0.0;\n}\n\nmat3 rotationMatrix(vec3 a){\n    //calculate consts\n    float cx = cos(a.x);\n    float sx = sin(a.x);\n    float cy = cos(a.y);\n    float sy = sin(a.y);\n    float cz = cos(a.z);\n    float sz = sin(a.z);\n    //return matrix\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n// https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size boxSize\nvoid boxIntersection( Ray ray, vec3 aaa, vec3 bbb, out float t0, out float t1){\n    vec3 boxSize = abs(bbb - aaa);\n    vec3 m = 1.0/ray.direction; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ray.origin;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 h1 = -n - k;\n    vec3 h2 = -n + k;\n    float tN = max(max( h1.x, h1.y ), h1.z);\n    float tF = min(min( h2.x, h2.y ), h2.z);\n    if (tN > tF) { // no intersection\n        t0 = 1e20;\n        t1 = 1e20;\n        return;\n    }\n    t0 = min(tN, tF);\n    t1 = max(tN, tF);\n    return;\n}\n\nvec3 hsvToRgb(vec3 hsv){ //hsv.x = hue, hsv.y = saturation, hsv.z = value\n    vec3 col = vec3(hsv.x, hsv.x + 2.0/3.0, hsv.x + 4.0/3.0); //inputs for r, g, and b\n    col = clamp(abs(mod(col*2.0, 2.0)-1.0)*3.0 - 1.0, 0.0, 1.0)*hsv.z*hsv.y + hsv.z - hsv.z*hsv.y; //hue function (graph it on desmos)\n    return col;\n}\n\n//returns a point rotated in 3d (radians)\nvec3 rotate3d(vec3 point, vec3 angle, vec3 origin){ \n    point -= origin; //subtract pivot\n    point *= rotationMatrix(angle); //rotate point\n    point += origin; //add pivot\n    return point;\n}\n\n//camera constructor\nCamera createCamera(vec2 fragCoord, vec2 resolution, vec3 camRot, float screensize){\n    vec3 uv = vec3((fragCoord - resolution*0.5)/resolution.y, 0)*screensize;\n    mat3 rotmat = rotationMatrix(camRot);\n    vec3 rd = vec3(0,0,1)*rotmat;\n    vec3 ro = uv*rotmat - rd*100.0;\n    return Camera(Ray(ro, -rd), rotmat, resolution, uv.xy);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int _w = 87;\nconst int _a = 65;\nconst int _s = 83;\nconst int _d = 68;\nconst int _space = 32;\nconst int _shift = 16;\nconst int _c = 67;\nconst int _v = 86;\n\nfloat keyPressed(int key){\n    return float(texelFetch(iChannel1, ivec2(key,0),0).x >= 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    //rotation\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy); //current mouse pos\n        \n        if (iFrame <= 1){\n            col = vec2(0.35,0.09).xyxy;\n        } else {\n            //if mouse button up\n            if (m.z < 0.0 && mp.z >= 0.0){\n                col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n            } else if (m.z >= 0.0){\n                col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n            } else {\n                col = texelFetch(iChannel0, ivec2(1,0), 0);\n            }\n        }\n        \n        if (col.y*sensitivity > PI/2.0){\n            col.y = PI/2.0/sensitivity;\n        }\n        if (col.y*sensitivity < -PI/2.0){\n            col.y = -PI/2.0/sensitivity;\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = vec4(iMouse.xy/iResolution.xy,iMouse.zw/iResolution.xy);\n    }\n    \n    //resolution\n    if (floor(fragCoord) == vec2(5,0)){\n        col.xy = iResolution.xy;\n    }\n    //light direction\n    if (floor(fragCoord) == vec2(6,0)){\n        float t = texelFetch(iChannel0,ivec2(6,0),0).w;\n        if (iFrame == 0){\n            t = 0.5;\n        }\n        col.xyz = vec3(sin(t*PI*2.0),cos(t*PI*2.0),0);\n        col.w = t + (keyPressed(_c) - keyPressed(_v))*0.01;\n    }\n    \n    fragColor = col;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}