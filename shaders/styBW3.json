{
    "Shader": {
        "info": {
            "date": "1665387327",
            "description": "Approximation of the surface's normal.\nSome experiences on fake 3D randering\n",
            "flags": 0,
            "hasliked": 0,
            "id": "styBW3",
            "likes": 3,
            "name": "Line 2d with lightning",
            "published": 3,
            "tags": [
                "2d",
                "projection",
                "lightning"
            ],
            "usePreview": 0,
            "username": "rubioh",
            "viewed": 241
        },
        "renderpass": [
            {
                "code": "float lines(in vec2 pos){\n    float scale = 16.;\n    pos *= scale;\n    float v = sin(pos.x);\n    return smoothstep(-2., 2., v/fwidth(v));\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n// Not real gradient just an approximation relativly ok when h is away from 0.\n// Anyway we could take any gradient since we are not dealing with a real predefine 3D structure\nvec3 calcNormal(vec2 uv, float angle) { \n float l = length(uv);\n uv = normalize(uv);\n float h = .5+abs(1.5*cos(iTime));\n float x = cos(l*16.-iTime)*uv.x;\n float y = cos(l*16.-iTime)*uv.y;\n float z = (.5+ .5*sin(l*16.-iTime))*h;\n return normalize(vec3(x, y, z));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    \n    float angle = .5+.5*sin(length(uv*16.)-iTime);\n    angle *= cos(iTime) ;\n    mat2 rot = rotate2d(angle);  \n    vec2 xy = uv;\n    uv = rot*uv;\n    \n    vec2 st = vec2(length(uv), atan(uv.x, uv.y));\n    \n    st.x *= smoothstep(.2, .21, length(uv));\n    st.y *= step(.02, length(uv));\n    float l = lines(st.yx);\n    // Time varying pixel color\n    vec3 col = vec3(l)+.2*vec3(1.-l);\n    \n    \n    float h = abs(angle);\n    vec3 p = vec3(uv.x, uv.y, h);\n    vec3 normal = calcNormal(xy, angle);\n    vec3 lightPosition = vec3(iMouse.x, iMouse.y, 1.);\n    vec3 lightDirection = normalize(lightPosition - p);\n    float dif = clamp(dot(lightDirection, normal), 0.2, 1.);\n    \n    col = col*dif;\n    \n    vec3 res = vec3(0.);\n    if (xy.x>0.){\n        res = col;\n    }\n    else{\n        res = normal.xyz;\n    }\n    \n    // Output to screen\n    fragColor = vec4(res, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}