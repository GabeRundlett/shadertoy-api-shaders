{
    "Shader": {
        "info": {
            "date": "1510397287",
            "description": "From top to bottom: \nnearest, linear, cubic-linear (i.e. 2 samples involved), cubic Catmull-Rom (i.e. 4 samples involved), Sinc.\nmouse x to explore.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ljyWc",
            "likes": 25,
            "name": "compared interpolation",
            "published": 3,
            "tags": [
                "spline",
                "sampling",
                "cubic",
                "interpolation",
                "catmullrom",
                "hermite",
                "sinc"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 1299
        },
        "renderpass": [
            {
                "code": "float CR(float v0, float v1, float v2, float v3, float t)           // Catmull-Rom\n{\n\tfloat A0 = mix( v0, v1, t+1.),\n\t      A1 = mix( v1, v2, t   ),\n\t      A2 = mix( v2, v3, t-1.),\n          B0 = mix( A0, A1, .5*t + .5),\n\t      B1 = mix( A1, A2, .5*t     );\n\treturn     mix( B0, B1, t   );\n}\n\n#define T(x)  texelFetch(iChannel0,ivec2((x+64)%64,0),0).r\n//#define T(x)  float( x == 6 )                                     // pulse, for test\n#define sinc(x) ( x==0. ? 1. : sin( 3.14*(x) ) / ( 3.14*(x) ) )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;   U /= R;\n    O-=O;\n    \n    U.x = 10.*(U.x+4.*iMouse.x/R.x); U.y*= 5.;\n    int i = int(U.x), j = int(U.y);\n    float x = fract(U.x), y = fract(U.y)*1.01, c;\n          \n    c =   j==4 ? T(int(U.x+.5))                                     // nearest\n        : j==3 ? mix(T(i),T(i+1),x)                                 // linear\n        : j==2 ? mix(T(i),T(i+1),smoothstep(0.,1.,x))               // cubic-linear\n        : j==1 ? CR( T(i-1), T(i), T(i+1), T(i+2), x ) : 0.;        // Catmull-Rom\n    if (j==0) for (int j = -3; j <= 3; j++) c += sinc(x-float(j)) * T(i+j); // Sinc\n        \n    O += sqrt(c);                                                   // gamma conversion\n    O += smoothstep(1.,0.,abs(c-y)/fwidth(c-y)) * vec4(1,-1,-1,0);  // curves\n    if (y>=1.) O += vec4(-1,1,-1,0);                                // horizontal lines\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}