{
    "Shader": {
        "info": {
            "date": "1582485268",
            "description": "My first raymarched scene",
            "flags": 0,
            "hasliked": 0,
            "id": "tlKXzm",
            "likes": 2,
            "name": "my first raymarched scene",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 371
        },
        "renderpass": [
            {
                "code": "struct Obj {\n\tint type;\n    float d;\n};\n\nstruct Ray {\n\tObj hitObj;\n    vec3 hitPos;\n    // travelled distance along the ray\n    float t;\n};\n    \nfloat sdSphere(vec3 p, float r) {\n\treturn length(p)-r;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y + 1.95;\n}\n\nObj SDF(vec3 pos) {\n\n    float d0 = sdPlane(pos);\n    float d1 = sdSphere(pos-vec3(1, .2, 1), 2.2);\n\n    Obj obj = Obj(1, d1);\n\n    if (d0 < d1) {\n      obj = Obj(0, d0);\n    }\n\n    return obj;\n  }\n\n// Raymarching loop\nRay castRay(vec3 rayOrigin, vec3 rayDir) {\n\n    float tmax = 180.0;\n    float t = 0.0;\n\n    Obj hitObj = Obj(-1, t);\n    vec3 hitPos = vec3(0);\n\n    for (int i = 0; i < 500; i++) {\n\n      vec3 p = rayOrigin + t*rayDir;\n      Obj res = SDF(p);\n\n      if (res.d < 0.01) {\n        hitObj = res;\n        hitPos = p;\n        break;\n      } else if (res.d > tmax) {\n        break;\n      }\n      t += res.d;\n    }\n\n\treturn Ray(hitObj, hitPos, t);\n}\n\nvec3 calcNormal(vec3 pos) {\n\n\t// Center sample\n    float c = SDF(pos).d;\n\n    // Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3(SDF(pos + eps_zero.xyy).d, SDF(pos + eps_zero.yxy).d,\n                          SDF(pos + eps_zero.yyx).d) - c);\n}\n\n// Calculates Lambertian reflection\nvec3 calculateLightning(vec3 pos, vec3 lightDir, vec3 surfaceColor) {\n\n\t// L is vector from surface point to light, N is surface normal. N and L must be normalized!\n    vec3 L = normalize(lightDir);\n\n    vec3 N = calcNormal(pos);\n\n    float NoL = max(dot(N, L), 0.0);\n    vec3 directional = vec3(1.80,1.27,0.99) * NoL;\n\n    vec3 diffuse = surfaceColor * directional;\n\n    return diffuse;\n}\n\n// Analytically box-filtered checkerboard by iq\nfloat checkersTextureGradBox(in vec2 p, in vec2 ddx, in vec2 ddy) {\n\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n\n    // xor pattern\n\treturn 0.5 - 0.5*i.x*i.y;\n}\n\nvec2 texCoords(in vec3 pos) {\n\n    const vec4 sc0 = vec4(1.0, 1.3, 1.0, 0.5);\n    vec3 q = normalize(pos - sc0.xyz);\n    vec2 matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n\n    return 12.0*matuv;\n}\n\nvec3 floorColor(in vec3 p) {\n   \n    float f = mod(floor(p.z / 3.0) + floor(p.x / 3.0), 2.0);\n    return f * vec3(.8)+0.03;\n}\n\nvec3 fog(vec3 color, float d, vec3 camDir, vec3 sunDir, float extintion, float inscattering) {\n\t\n    float sunAmount = max(dot(camDir, sunDir), 0.0);\n    vec3 fogColor = mix(vec3(0.001, 0.001, 0.001), vec3(0.6, 0.6, 0.6), pow(sunAmount, 8.0));\n    return (color * exp(-d * extintion)) + (fogColor * (1.0 - exp(-d * inscattering)));\n}\n\n// Value noise from the Art of Code\nfloat generateNoise(vec2 p) {\n\treturn fract(sin(p.x*100.+p.y*6574.)*5647. );\n}\n\nfloat smoothNoise(vec2 uv) {\n \n    vec2 lv = fract(uv*1.0);\n    vec2 id = floor(uv*1.0);\n\n    lv = lv*lv*(3.-2.*lv);\n\n    float bl = generateNoise(id);\n    float br = generateNoise(id + vec2(1,0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = generateNoise(id + vec2(0,1));\n    float tr = generateNoise(id + vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\n\nfloat turbulence(vec2 uv) {\n\n    float c = smoothNoise(uv*4.0);\n    c += smoothNoise(uv*8.0) * 0.5;\n    c += smoothNoise(uv*16.0) * 0.25;\n    c += smoothNoise(uv*32.0) * 0.125;\n    c += smoothNoise(uv*65.0) * 0.0625;\n\n    return c / 5.0;\n}\n\nvec3 render(in vec3 camPos, in vec3 rayDir, out bool rayHitObj, in vec2 uv, in mat3 camMat) {\n\n    vec3 col;\n\n    vec3 lightDir = vec3(0.8, 0.4, -0.5);\n    vec3 sunDir = camMat * lightDir;\n\t    \n    rayHitObj = false;\n \n    Ray ray = castRay(camPos, rayDir);\n \n    // no objects were hit by the ray -> skydome\n    if (ray.hitObj.type == -1) {\n\n        //Sun\n        vec3 sun1 = vec3(1, 0.0, 0.0);\n        vec3 sun2 = vec3(0.268, 0.243, 0.007);\n\n        float sun_weight = smoothstep(0.0, .9, sin(uv.y)*1.1);\n        vec3 sunCol = mix(sun1, sun2, sun_weight);\n\n        // the sun is rendered only if the light is coming from the visible sky\n        if (sunDir.z > 0.0) {\n\n          \tif ((uv.x - sunDir.x*2.2) * (uv.x - sunDir.x*2.2) +\n                (uv.y - sunDir.y+0.2) * (uv.y - sunDir.y+0.2) <= 0.1) {\n\n            \tsunCol *= turbulence(uv)*1.9;\n            \treturn sunCol;\n        \t}\n       \t}\n\n\t\tvec3 sky_col = vec3(rayDir.y*0.5+0.01);\n\t\tcol = vec3(rayDir.y*0.5+0.01);\n       \t// add clouds\n       \tcol *= turbulence(uv);\n       \treturn col;\n    }\n\n    // ray hit the floor plane\n    else if (ray.hitObj.type == 0) {\n    \tcol = floorColor(ray.hitPos);\n\n    \t//vec3 lightDir = vec3(0.8, 0.4, -.5);\n    \tcol = calculateLightning(ray.hitPos, lightDir, col)*0.3;\n\n    \t// Add shadows\n    \tfloat shadow = 0.0;\n    \tvec3 L = normalize(lightDir);\n    \tvec3 N = calcNormal(ray.hitPos);\n    \tvec3 shadowRayOrigin = ray.hitPos + N * 0.01;\n    \tvec3 shadowRayDir = L;\n\n    \tRay shadowRayIntersection = castRay(shadowRayOrigin, shadowRayDir);\n    \tif (shadowRayIntersection.hitObj.type == 1) {\n            col *= 0.01;\n        } else {\n        \n      \t// Add fog for floor attenuation\n      \tfloat fogExtintion = 0.035;\n     \tfloat fogInscattering = .1;\n        lightDir *= 0.8;\n      \tcol = fog(col, ray.t, rayDir, lightDir, fogExtintion, fogInscattering);\n        }\n    }\n\n    // sphere\n    else if (ray.hitObj.type == 1) {\n\n      vec2 uvw = texCoords(ray.hitPos) - uv;\n\n      vec2 ddx_uv = dFdx( uvw );\n      vec2 ddy_uv = dFdy( uvw );\n      col = vec3(checkersTextureGradBox(uvw, ddx_uv, ddy_uv));\n\n      // apply anti alias only to the sphere \n      rayHitObj = true;\n\n      // add lightning\n      vec3 surfaceCol = vec3(0.6, 0.0, 0.0);\n      vec3 lightDir = vec3(0.8, 0.4, -1.0);\n      col += calculateLightning(ray.hitPos, lightDir, surfaceCol);\n\n      // add small amount of light to the backside of the sphere\n      col += surfaceCol*0.4;\n    }\n\n     return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  \n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n    vec3 camPos = vec3(30.0*sin(iTime*0.5), 2.0, 30.0*cos(iTime*0.5));\n    vec3 camTar = vec3(-0.2, 2.0, -0.2);\n\n    mat3 camMat = lookAt(camPos, camTar, 0.0);\n\n    vec3 col = vec3(0.0);\n    \n    // MSAA anti aliasing\n    bool msaa = true;\n\n    bool rayHitObj = false;\n    if (msaa) {\n    \tconst float AA_size = 2.0;\n    \tfloat count = 0.0;\n      \tfor (float aaY = 0.0; aaY < AA_size; aaY++) {\n        \tfor (float aaX = 0.0; aaX < AA_size; aaX++) {\n\n\t\t\t\tvec2 offset = ((fragCoord.xy + vec2(aaX, aaY) / AA_size) - iResolution.xy*0.5)/iResolution.y;\n          \t\tvec3 rayDir = normalize(camMat * vec3(offset.xy, 2.0));\n\n          \t\tcol += render(camPos, rayDir, rayHitObj, offset, camMat);\n\n          \t\t\n          \t\tcount += 1.0;\n          \t\tif (!rayHitObj) {\n            \t\tbreak;\n          \t\t}\n        \t}\n      \t}\n      col /= count;\n   \n    } else {\n\t\tbool rayHitObj = false;\n    \tvec3 rayDir = normalize(camMat * vec3(uv.xy, 2.0));\n    \tcol = render(camPos, rayDir, rayHitObj, uv, camMat);\n    }\n    \n    // gamma\n\tcol = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}