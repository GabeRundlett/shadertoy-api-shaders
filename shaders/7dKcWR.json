{
    "Shader": {
        "info": {
            "date": "1654733020",
            "description": "Infinite shadow && SDF. Mask video",
            "flags": 64,
            "hasliked": 0,
            "id": "7dKcWR",
            "likes": 8,
            "name": "BritneyInFocus",
            "published": 3,
            "tags": [
                "2d",
                "video",
                "sdf",
                "transition",
                "repeat"
            ],
            "usePreview": 1,
            "username": "Sergeindamix",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "#define SHADOW_ANGLE -50.0\n#define SHADOW_COLOR vec3(1, 0, 0);\n#define LIGHT_DIR vec2(1, 1)\n#define LIGHT_INTENSITY 0.3\n\n#define EPS 0.01\n#define ITER 30\n\n#define T iTime\n#define S(a,b,t) smoothstep(a,b,t)\n#define pi 3.1415926535898\n\nvec2 rot(vec2 uv, float t) {\n    float c = cos(t), s = sin(t);\n    return mat2(c, -s, s, c) * uv;\n}\nvec3 RotateY(vec3 v, float degree)\n{\n    float rad = 0.0174532925*degree;\n    float cosY = cos(rad);\n    float sinY = sin(rad);\n    return vec3(cosY*v.x - sinY * v.z, v.y, sinY*v.x + cosY * v.z);\n}\n\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n// Copied from iq's article\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\nfloat radius =.5;\nfloat angle =.1;\nfloat width =.5;\nvec2 size = vec2(0.4,.24);\nvec2 start = vec2(0,0);\nvec2 end = vec2(1,0);\nfloat map(vec2 p) {\n    //p = rot(p, iTime);\n    p += vec2(sin(iTime), cos(iTime)*.5);\n    float a1 = 5., a2 = a1 + 5., a3 = a2 + 5., a4 = a3 + 5., a5 = a4 + 5., a6 = a5 + 5., a7 = a6 + 5., a8 = a7 + 5.;    \n    float gTime = mod(iTime,  a8 + 1.);//time after animations\n    \n    float Circ = sdCircle(p, 0.3);\n    float tria = triangleDist(p, radius);\n    float box = boxDist(p, size, radius-.45);\n    float star = sdStar5(p, 0.4, 0.5);\n    float scir = semiCircleDist(p, radius, angle, width);\n    float lin = lineDist(p, start, end, width-.45);\n        for (int i = 0; i < 4; i++)\n        {\n            vec3 p3;\n            p3=RotateY(p3, -22.5 * float(i)) + vec3(float(i)*sin(T)*.75, float(i)*cos(T)*.75, float(i)*pi);\n            float circAdd = sdCircle(p-p3.xy, 0.3);\n            float triaAdd = triangleDist(p-p3.xy, radius);\n            Circ = min(Circ, circAdd);\n            tria = min(tria, triaAdd);\n            float boxAdd = boxDist(p-p3.xy, size, radius-.45);\n            box = min(box, boxAdd);\n            float starAdd = sdStar5(p-p3.xy,0.4, 0.5);\n            star = min(star, starAdd);\n            float scirAdd = semiCircleDist(p-p3.xy, radius, angle, width);\n            scir = min(scir, scirAdd);\n            float linAdd = lineDist(p-p3.xy, start, end, width-.45);\n            lin = min(lin, linAdd);\n        }\n        \n    if (gTime < a1){\n        float t0 = gTime-2.;\n        \n\t\treturn Circ;//sdCircle(p, 0.3);\n    } else if (gTime < a2) {\n        float t0 = gTime-a1;\n        \n        return tria; \n    } else if (gTime < a3 ){\n     \tfloat t0 = gTime - a2;\n        \n        return box;\n    } else if (gTime < a4) { \n        float t0 = gTime-a3;\n        \n        return star;\n    } else if (gTime < a5) {\n    \n       return Circ;     \n    } else if (gTime < a5) {\n    \n       return tria;       \n    \n    } else if (gTime < a6) {\n    \n       return scir;       \n    } else if (gTime < a7){\n    \n       return box;\n    } else if  (gTime < a8) {\n    \n       return  lin;\n    }\n    \n    \n    \n}\n\nvec2 getNormal(vec2 p) {\n    vec2 d = vec2(1, 0) * EPS;\n    return normalize(vec2(\n        map(p + d.xy) - map(p - d.xy),\n        map(p + d.yx) - map(p - d.yx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y; // fix aspect ratio\n\n    vec3 col;\n    \n    // Draw BG\n    float a = floor((uv.x - uv.y * 0.5 - iTime * .08) * 8.) - iTime * 2.;\n    col = vec3(sin(a), sin(a + 2.), sin(a + 3.)) * 0.2 + 0.7;\n    \n    // Draw infinite shadow by raymarching\n    float angle = radians(SHADOW_ANGLE);\n    vec2 dir = -vec2(cos(angle), sin(angle));\n    float d;\n    float t = 0.;\n    vec2 p2;\n    \n    for (int i = 0; i < ITER; i++) {\n        p2 = p + dir * t;\n        d = map(p2);\n        if (d < EPS) {\n            vec2 n = getNormal(p2);\n            float shade = dot(n, normalize(LIGHT_DIR));\n            col = SHADOW_COLOR;\n            col *= 1. + shade * LIGHT_INTENSITY;\n        }\n        t += d;\n    }    \n\n    // Draw foreground\n    d = map(p);\n    float inside = step(d, EPS);\n    if (d < EPS) {\n        col = vec3(step(d, -EPS));\n        //uv = rot(uv, iTime);\n        \n            \n        uv/=vec2(.75);\n        uv+=vec2(.75);\n        uv += vec2(sin(iTime), cos(iTime));\n        col=min(col, texture(iChannel0,uv).rgb);\n    }    \n    //col*=rectangle(uv, vec2(0.5, 0.51));//\n    // vignette\n    col -= smoothstep(0.5, 3.0, length(p));\n    \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 29123,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/believer/test-2022-06-03-at-19h25m40s?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}