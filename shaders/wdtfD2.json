{
    "Shader": {
        "info": {
            "date": "1606080873",
            "description": "I've been playing a lot of the game Control recently and I love the blend of brutalist style and impossible structures.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdtfD2",
            "likes": 11,
            "name": "Control",
            "published": 3,
            "tags": [
                "3d",
                "tunnel",
                "control",
                "concrete"
            ],
            "usePreview": 0,
            "username": "liamegan",
            "viewed": 477
        },
        "renderpass": [
            {
                "code": "\n  // movement variables\n  vec3 movement = vec3(.0);\n  \n  const int maxIterations = 256;\n  const float stopThreshold = 0.005;\n  const float stepScale = .2;\n  const float eps = 0.002;\n  const vec3 clipColour = vec3(0.);\n  const vec3 fogColour = vec3(0.);\n  \n  const vec3 light1_position = vec3(0, 1., -1.);\n  const vec3 light1_colour = vec3(.8, .8, .85);\n  \n  struct Surface {\n    int object_id;\n    float distance;\n    vec3 position;\n    vec3 onsurface_position;\n    vec3 colour;\n    float steps;\n    float ambient;\n    float spec;\n  };\n  \n  // Distance function copyright Inigo Quilez\n  float opExtrusion( in vec3 p, in float primitive, in float h ) {\n      float d = primitive;\n      vec2 w = vec2( d, abs(p.z) - h );\n      return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n  }\n  float sdBox( in vec2 p, in vec2 b ) {\n      vec2 d = abs(p)-b;\n      return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n  }\n  \n  vec3 path(float z) {\n    // return vec3(0,0,0.);\n    return vec3(sin(z * .1) * 4., sin(z * .05) * 2., z);\n  }\n  \n  float getBlock(vec3 position, inout int object_id, inout vec3 p) {\n    // position.z = fract(position.z) - .5;\n    // object_id = int(id);\n    float id = float(object_id);\n    float r = sin(id * .3 + iTime) * .5;\n    r = sin(texture(iChannel0, vec2((id)/255.), -10.).x * 2. + iTime * .5 - id) * .25;\n    float rw = texture(iChannel0, vec2((id)/255.), -10.).x - .5;\n    // // position.xy += r;\n    float s = sin(r);\n    float c = cos(r);\n    position.xy *= mat2(c, -s, s, c);\n    \n    p = position;\n    \n    float box = sdBox(position.xy, vec2(1.5 + rw, 1.)) * -1.;\n    float world = opExtrusion(position, box, .45) - .005;\n    return world;\n  }\n  \n  float world(in vec3 position, inout int object_id, inout vec3 p) {\n    \n    position.xy -= path(position.z).xy;\n    \n    float id = floor(position.z);\n    position.z = fract(position.z) - .5;\n    \n    int oid1 = int(id);\n    vec3 p1;\n    float block1 = getBlock(position, oid1, p1);\n    int oid0 = int(id-1.);\n    vec3 p0;\n    float block0 = getBlock(position + vec3(0,0,1), oid0, p0);\n    int oid2 = int(id+1.);\n    vec3 p2;\n    float block2 = getBlock(position + vec3(0,0,-1), oid2, p2);\n    \n    object_id = oid1;\n    p = p1;\n    \n    if(block2 < block1) {\n      block1 = block2;\n      object_id = oid2;\n      p = p2;\n    }\n    \n    return block1;\n  }\n  float world(in vec3 position, inout int object_id) {\n    vec3 p;\n    return world(position, object_id, p);\n  }\n  float world(in vec3 position) {\n    int dummy = 0;\n    return world(position, dummy);\n  }\n  \n  Surface getSurface(int object_id, float rayDepth, vec3 sp, float steps, vec3 onsurface_pos) {\n    return Surface(\n      object_id, \n      rayDepth, \n      sp, \n      onsurface_pos,\n      vec3(1.), \n      steps,\n      .5, \n      1000.);\n  }\n  \n  // The raymarch loop\n  Surface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float sceneDist = 1e4;\n    float rayDepth = start;\n    int object_id = 0;\n    float steps = 0.;\n    vec3 p;\n    for(int i = 0; i < maxIterations; i++) {\n      sceneDist = world(ro + rd * rayDepth, object_id, p);\n      steps++;\n      \n      if(sceneDist < stopThreshold || rayDepth > end) {\n        break;\n      }\n      \n      rayDepth += sceneDist * stepScale;\n    }\n    \n    return getSurface(object_id, rayDepth, ro + rd * rayDepth, steps, p);\n  }\n  \n  // Calculated the normal of any given point in space. Intended to be cast from the point of a surface\n  vec3 calculate_normal(in vec3 position) {\n    vec3 grad = vec3(\n      world(vec3(position.x + eps, position.y, position.z)) - world(vec3(position.x - eps, position.y, position.z)),\n      world(vec3(position.x, position.y + eps, position.z)) - world(vec3(position.x, position.y - eps, position.z)),\n      world(vec3(position.x, position.y, position.z + eps)) - world(vec3(position.x, position.y, position.z - eps))\n    );\n    \n    return normalize(grad);\n  }\n  \n  vec3 lighting(Surface surface_object, vec3 cam) {\n    \n    // start with black\n    vec3 sceneColour = vec3(0);\n    \n    // Surface normal\n    vec3 normal = calculate_normal(surface_object.position);\n    normal += smoothstep(.02, 0., abs(sin(surface_object.onsurface_position.x * 4.))) * .5;\n    normal += smoothstep(.01, 0., abs(sin(surface_object.onsurface_position.y * 2.))) * .5;\n    \n    // Light position\n    vec3 lp = cam;\n    // Light direction\n    vec3 ld = lp - surface_object.position;\n    \n    // light attenuation\n    // For brightly lit scenes or global illumination (like sunlit), this can be limited to just normalizing the ld\n    float len = length( ld );\n    ld = normalize(ld);\n    float lightAtten = min( 1.0 / ( 0.15*len ), 1.0 );\n    lightAtten = 1.;\n    \n    // Scene values, mainly for fog\n    float sceneLength = length(cam - surface_object.position);\n    float sceneAttenuation = min( 1. / ( 0.015 * sceneLength * sceneLength ), 1. );\n    \n    // The surface's light reflection normal\n    vec3 reflection_normal = reflect(-ld, normal);\n    \n    // Ambient Occlusion\n    float ao = 1.;\n    \n    // Object surface properties\n    float diffuse = max(0., dot(normal, ld));\n    float specular = max(0., dot( reflection_normal, normalize(cam - surface_object.position) ));\n    \n    // Bringing all of the lighting components together\n    vec3 tp = surface_object.onsurface_position * 2.;\n    vec3 c = texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    tp = surface_object.onsurface_position;\n    c += texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    tp = surface_object.onsurface_position * .5;\n    c += texture(iChannel0, tp.xy + tp.zx, -10.).rrr + texture(iChannel0, tp.zy + tp.yx).rrr;\n    c *= .125;\n    c *=  vec3(1,.98,.90);\n    sceneColour += ( c * (diffuse + specular )) * light1_colour * lightAtten;\n    \n    // adding fog\n    sceneColour = mix( sceneColour, fogColour, 1. - sceneAttenuation );\n    \n    return sceneColour;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float t =iTime;\n    \n    // Camera and look-at\n    vec3 cam = path(t);\n    vec3 lookAt = path(t+3.);\n    \n    // Unit vectors\n    vec3 forward = normalize(lookAt - cam);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n    vec3 up = normalize(cross(forward, right));\n    \n    // FOV\n    float FOV = .9;\n    \n    // Ray origin and ray direction\n    vec3 ro = cam;\n    vec3 rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    \n    // Ray marching\n    const float clipNear = 0.;\n    const float clipFar = 32.;\n    Surface objectSurface = rayMarch(ro, rd, clipNear, clipFar);\n    if(objectSurface.distance > clipFar) {\n      fragColor = vec4(clipColour, 1.);\n      return;\n    }\n    \n    float ao = (objectSurface.steps*.0025);\n    ao *= ao*4.;\n    ao = clamp(1.-ao, 0., 1.);\n    vec3 sceneColour = lighting(objectSurface, cam) * ao;\n    // vec3 sceneColour = vec3(objectSurface.steps*.01);\n    \n    fragColor = vec4(sceneColour, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}