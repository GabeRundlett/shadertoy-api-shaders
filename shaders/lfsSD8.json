{
    "Shader": {
        "info": {
            "date": "1705232806",
            "description": "practice",
            "flags": 0,
            "hasliked": 0,
            "id": "lfsSD8",
            "likes": 12,
            "name": "Raymarching dango",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "nagi",
            "viewed": 278
        },
        "renderpass": [
            {
                "code": "precision highp float;\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform float time;\nuniform sampler2D backbuffer;\n\nfloat PI = acos(-1.);\n\nvec3 foldX(vec3 p) {\n    p.x = abs(p.x);\n    return p;\n}\n\nmat2 rotate(float a) {\n    float s = sin(a),c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat ball(vec3 p, float r){\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h){\n  float d1 = length(p.xy) - r;\n  float d2 = abs(p.z) - h;\n  \n  float d = max(d1, d2);\n  \n  return d;\n}\n\nfloat cube(vec3 p, vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q, 0.0);\n  return length(max(q-s, 0.0))-min(min(m.x, m.y), m.z);\n}\n\nfloat dist(vec3 p){\n  float scale = 1.6;\n  float s = 1.0;\n  float d = 999.0;\n  \n  for(int i=0;i<4;i++){\n    float tscale = 0.5;\n    p.yz *= rotate(iTime*tscale);\n    p.xy *= rotate(iTime*tscale/s);\n    \n    p = abs(p);\n    p -= 0.5/s;\n    \n    p *= scale;\n    s *= scale;\n    \n    float d1 = cylinder(p, 0.03, 1.0);\n    float d2 = cube(p, vec3(0.2));\n    float d3 = ball(vec3(p.x, p.y, p.z - 1.), 0.15);\n    float d5 = min(min(d1, d2), d3)/s;\n  \n    d = min(d, d5);\n \n  }\n  \n  return d;\n}\n\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    float eps = 0.0001;\n    vec2 h = vec2(eps,0);\n    return normalize( vec3(dist(p+h.xyy) - dist(p-h.xyy),\n                           dist(p+h.yxy) - dist(p-h.yxy),\n                           dist(p+h.yyx) - dist(p-h.yyx) ) );\n}\n\nvec3 lighting(vec3 light_color, vec3 lightpos, vec3 pos, vec3 normal, vec3 rd){\n  vec3 lightdir = normalize(lightpos - pos);\n  float lambrt = max(dot(normal, lightdir), 0.0);\n  vec3 half_vector = normalize(lightdir - rd);\n  float m = 200.;\n  float norm_factor   = ( m + 2. ) / ( 2.* PI );\n  vec3 light_specular = light_color * norm_factor * pow( max( 0., dot( normal, half_vector ) ), m );\n\n  return vec3(0.4,0.8,0.9)*lambrt*light_color + light_specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 r=iResolution.xy, p=(fragCoord.xy*2.-r)/min(r.x,r.y);\n  \n  vec3 tar = vec3(0.0, 0.0, 0.0);\n  float radius = 2.0;\n  float theta = iTime * 0.5;\n  \n  vec3 cpos = vec3(radius*cos(theta), 0.5, radius*sin(theta)); //camera pos\n  \n  vec3 cdir = normalize(tar - cpos); //camera dir\n  vec3 side = cross(cdir, vec3(0, 1, 0));\n  vec3 up = cross(side, cdir);\n  float fov = 1.5; // field of view\n  \n  vec3 screenpos = vec3(p, 4.0);\n  \n  vec3 rd = normalize(p.x*side + p.y*up + fov*cdir);\n  \n  float d = 0.0; //distance\n  float t = 0.0; //total distance\n  vec3 pos = cpos;\n  \n  for(int i=0;i<30;i++){\n    d = dist(pos);\n    t += d;\n    pos = cpos + rd*t;\n    if(d<0.0001 || t>10.0) break;\n  }\n  \n  vec3 col = vec3(0.0);\n  \n  vec3 normal = calcNormal(pos);\n  \n  vec3 light_color = vec3(0.5, 1.0, 0.6);\n  vec3 lightpos = vec3(1.0, 2.0, 0.0);\n  col = lighting(light_color, lightpos, pos, normal, rd);\n  \n  light_color = vec3(0.5, 0.5, 1.0);\n  lightpos = vec3(2.0, 1.0, 0.0);\n  col += lighting(light_color, lightpos, pos, normal, rd);\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.4));\n  \n  if(t>10.0) col = vec3(0.0);\n\n  fragColor = vec4(col, 1.0);\n  \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}