{
    "Shader": {
        "info": {
            "date": "1631492623",
            "description": "My first attempt to model a sea snail with a spiral. Should note that a nautilus is classified as a cephalopod so it's technically not a snail.\n\nThanks this visualizer for helping me debug the SDF: https://www.shadertoy.com/view/ssKGWR",
            "flags": 0,
            "hasliked": 0,
            "id": "sdVGWh",
            "likes": 59,
            "name": "Nautilus Shell",
            "published": 3,
            "tags": [
                "spiral",
                "logarithmic",
                "interior",
                "beach",
                "nautilus",
                "seashell",
                "conch"
            ],
            "usePreview": 0,
            "username": "harry7557558",
            "viewed": 865
        },
        "renderpass": [
            {
                "code": "// I have always been facinated with seashells.\n\n// Nautilus is probably the most mathematical one \n// to get my seashell shader journey started.\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\nvec2 cut;  // when modeling the nautilus, cut z<cut.x and z>cut.y to show its interior\n\n\n// calculate the signed distance and color of the nautilus shell\n// this function calculates color only when @req_color is true\nfloat mapShell(in vec3 p, out vec3 col, bool req_color) {\n    p -= vec3(0.7, 0, 0);\n\n    // r=exp(b*θ)\n    const float b = 0.17;\n\n    // Catesian to cylindrical\n    float r = length(p.xy);  // r\n    float a = mix(0.0, 0.45, smoothstep(0.0, 1.0, 0.5*(r-0.6)));  // rotate by this angle\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;  // rotation\n    float t = atan(p.y, p.x);  // θ\n\n    // shell opening, kill discontinuities of the spiral\n    float ro = exp(b*PI);  // center of the \"ring\"\n    float d = length(vec2(length(p.xz-vec2(-ro,0))-ro,p.y));  // distance to the \"ring\"\n    float u = t, dx = r-ro, dy = p.z;  // longitude and two numbers to determine latitude\n\n    // spiral\n    // r(n) = exp(b*(2.*PI*n+t)), (x-r)^2+y^2=r^2, solve for n\n    float n = (log((r*r+p.z*p.z)/(2.*r))/b-t)/(2.0*PI);  // decimal n\n    n = min(n, 0.0);  // clamp to opening\n    float n0 = floor(n), n1 = ceil(n);  // test two boundaries\n    float r0 = exp(b*(2.*PI*n0+t)), r1 = exp(b*(2.*PI*n1+t));  // two r\n    float d0 = abs(length(vec2(r-r0,p.z))-r0);  // distance to inner\n    float d1 = abs(length(vec2(r-r1,p.z))-r1);  // distance to outer\n    if (d0 < d) d = d0, u = 2.*PI*n0+t, dx = r-r0, dy = p.z;  // update distance\n    if (d1 < d) d = d1, u = 2.*PI*n1+t, dx = r-r1, dy = p.z;  // update distance\n\n    // septa/chambers\n    const float f = 2.4;  // \"frequency\" of chambers\n    float s0 = t + 2.0*PI*(n0+0.5);  // longitude parameter\n    float v = fract(n);  // 0-1, distance from inner circle\n    float s = f*s0 + 1.0*pow(0.25-(v-0.5)*(v-0.5), 0.5)+0.5*v;  // curve of septa\n    s += pow(min(1.0/(40.0*length(vec2(v-0.5,p.z))+1.0), 0.5), 2.0);  // hole on septa\n    float sf = fract(s);  // periodic\n    sf = s0>-1.8 ? abs(s+3.25) :  // outer-most septa, possibly cause discontinuities\n         min(sf, 1.0-sf);  // inner septa\n    float w = sf/f*exp(b*(s0+PI));  // adjust distance field\n    if (length(p*vec3(1,1,1.5))<3.0)  // prevent outer discontinuity\n        d = min(d, 0.5*w+0.012);  // union chambers\n\n    d += 0.00012*r*sin(200.*u);  // geometric texture\n    d = abs(d)-0.8*max(0.02*pow(r,0.4),0.02);  // thickness of shell\n    d = max(d, max(cut.x-p.z,p.z-cut.y));  // cut it open\n    if (!req_color) return d;  // distance calculation finished\n\n    // color\n    v = atan(dy, dx);  // latitude parameter\n    w = length(vec2(dx,dy)) / exp(b*u);  // section radius parameter\n    for (float i=0.;i<6.;i+=1.) {  // distort the parameters\n        float f = pow(2., i);\n        float du = 0.15/f*sin(f*u)*cos(f*v);\n        float dv = 0.15/f*cos(f*u)*sin(f*v);\n        u+=du, v+=dv;\n    }\n    float f1 = cos(50.*u);  // middle stripes\n    float f2 = cos(21.3*u)+0.1;  // side stripes\n    float tex = mix(f1, f2, 0.5-0.5*tanh(1.0-3.0*sin(v)*sin(v)))  // blend stripes\n         + 0.5-0.6*cos(v);  // fading at sides\n    tex += 0.5+0.5*tanh(4.0*(u-2.0));  // fading near opening\n    col = n==0.0 ? vec3(0.9,0.85,0.8) : vec3(0.95,0.85,0.7);  // base color, outer and inner\n    if (w>1.0 && w<1.1)  // on the surface of the shell\n        col = (u-0.3*cos(v)<-2.6 ? 1.0-0.6*min(exp(2.+0.5*u),1.0) : 1.0)  // black inside the opening\n            * mix(vec3(0.6,0.3,0.2), col, clamp(8.0*tex+0.5,0.,1.));  // apply stripes\n\n    return d;\n}\n\n// calculate the signed distance and color of the scene\nfloat map(in vec3 p, out vec3 col, bool req_color) {\n    vec3 shell_col;\n    float shell_d = mapShell(p.yzx, shell_col, req_color);  // call mapShell\n    float beach_d = p.z+1.5;  // beach surface: z=-1.5\n    beach_d += 0.001*sin(20.0*p.x)*sin(20.0*p.y) + 0.0005*(sin(51.0*p.x)+sin(50.0*p.y));  // deform the surface of the beach\n    vec3 beach_col = vec3(0.95,0.8,0.5);  // color of the beach\n    float d = min(shell_d, beach_d);  // final signed distance\n    if (d==shell_d) col = shell_col;  // closer to nautilus shell\n    else col = beach_col;  // closer to beach\n    return d;\n}\n\n// calculate signed distance only\nfloat mapDist(vec3 p) {\n    vec3 col;\n    return map(p, col, false);\n}\n\n// numerical gradient of the SDF\nvec3 mapGrad(vec3 p) {\n    const float e = 0.001;\n\tfloat a = mapDist(p+vec3(e,e,e));\n\tfloat b = mapDist(p+vec3(e,-e,-e));\n\tfloat c = mapDist(p+vec3(-e,e,-e));\n\tfloat d = mapDist(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n// \"standard\" raymarching\nbool raymarch(vec3 ro, vec3 rd, inout float t, float t1, float step_size, float eps) {\n    for (int i=int(ZERO); i<100; i++) {\n        float dt = step_size*mapDist(ro+rd*t);\n        t += dt;\n        if (abs(dt) < eps) break;\n        if (t > t1) return false;\n    }\n    return true;\n}\n\n// soft shadow - https://iquilezles.org/articles/rmshadows\nfloat calcShadow(vec3 ro, vec3 rd) {\n    float sh = 1.;\n    float t = 0.1;\n    for (int i = int(ZERO); i<20; i++){\n        float h = mapDist(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 4.0*h/t));\n        t += clamp(h, 0.1, 0.3);\n        if (h<0. || t>8.0) break; \n    }\n    return max(sh, 0.);\n}\n\n// AO - from Shane's https://www.shadertoy.com/view/wslcDS\nfloat calcAO(vec3 p, vec3 n){\n\tfloat sca = 1.5;\n    float occ = 0.;\n    for(float i=ZERO+1.; i<=5.; i+=1.){\n        float t = 0.07*i;\n        float d = mapDist(p+n*t);\n        occ += (t-d)*sca;\n        sca *= .5;\n    }\n    return 1.0 - clamp(occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set cut to view interior\n    float at = mod(iTime, 8.0);  // animation time\n    cut = vec2(-1.8, 1.8);  // show all\n    cut = mix(cut, vec2(-1.8, 0.0), clamp(at-1.0, 0., 1.));  // half\n    cut = mix(cut, vec2(-0.1, 0.1), clamp(at-3.0, 0., 1.));  // slice in the middle\n    cut = mix(cut, vec2(-1.0, -0.8), clamp(at-5.0, 0., 1.));  // slice at the side\n    cut = mix(cut, vec2(-1.8, 1.8), clamp(at-7.0, 0., 1.));  // show all\n\n    // set camera\n    float rx = iMouse.z!=0.0 ? 1.8*(iMouse.y/iResolution.y)-0.2 : 0.3;\n    float rz = iMouse.z!=0.0 ? -iMouse.x/iResolution.x*4.0*3.14 : -0.3;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  // far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  // left to right\n    vec3 v = cross(w,u);  // down to up\n\n    vec3 ro = 12.0*w;  // ray origin\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  // ray direction\n\n    // ray intersection\n    float t0 = 0.01;  // start at t=t0\n    float t1 = 3.0*length(ro);  // end distance\n    float t = t0;\n    if (!raymarch(ro, rd, t, t1, 0.8, 1e-3)) {  // raymarch\n        t = 100.;  // miss, set t to a large number so it fades\n    }\n    vec3 p = ro+rd*t;  // current position\n\n    const vec3 sundir = normalize(vec3(0.5, -0.5, 0.5));  // direction of the sun\n    vec3 n = normalize(mapGrad(p));  // get normal\n    vec3 col; map(p, col, true);  // get color\n    float shadow = calcShadow(p, sundir);  // soft shadow\n    float ao = calcAO(p, n);  // ao\n    vec3 sunlight = shadow * max(dot(n, sundir), 0.0) * vec3(0.9, 0.8, 0.6);  // sunlight, yellowish\n    vec3 skylight = ao * max(n.z, 0.0) * vec3(0.6, 0.7, 0.8);  // skylight, blueish\n    vec3 backlit = ao * (vec3(0.2)  // background lighting\n        + vec3(0.3)*max(-dot(n,sundir),0.0)  // opposite of sunlight\n        + vec3(0.4,0.3,0.2)*max(-n.z,0.0));  // opposite of skylight, warm\n    col *= sunlight + skylight + backlit;  // sum three lights\n    float fresnel = 0.2+1.4*pow(1.0+dot(rd,n),2.0);  // faked Fresnel reflectance\n    vec3 refl = 0.8*col+vec3(0.4,0.3,0.2)*pow(max(dot(rd-2.0*dot(rd,n)*n,sundir),0.0),100.);  // reflection, blend with col\n    if (!raymarch(p+0.2*reflect(rd, n), reflect(rd, n), t0, 8.0, 1.0, 0.02))  // not occluded\n        col = mix(col, refl, fresnel);  // add reflection\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.15*max(t-0.4*t1,0.)));  // sky/fog\n    col += 0.6*vec3(0.3,0.2,0.25) * max(dot(rd, sundir), 0.);  // sun haze\n    col = 0.9*pow(col, vec3(0.75));  // brightness/gamma\n    fragColor = vec4(vec3(col), 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}