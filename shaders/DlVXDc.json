{
    "Shader": {
        "info": {
            "date": "1686428017",
            "description": "An auto-VJ of a 2.5d-spaceship-cockpit flying through space, including gauges, sound textures, and bass reactive animations.\n\n - Use with music in iChannel0 -",
            "flags": 64,
            "hasliked": 0,
            "id": "DlVXDc",
            "likes": 11,
            "name": "Spaceship Console",
            "published": 3,
            "tags": [
                "music",
                "25d"
            ],
            "usePreview": 0,
            "username": "QuantumSuper",
            "viewed": 292
        },
        "renderpass": [
            {
                "code": "// Spaceship Console 0.6.230610 by QuantumSuper\n// auto-vj of a 2d spaceship ui flying through pseudo-3d space with gauges, fft textures, and bass reactive animations\n//\n// - use with music in iChannel0 -\n\n#define PI 3.14159265359 \n#define aTime 2.133333*iTime\n\nvec4 fft, ffts; //compressed frequency amplitudes\n\nvoid compressFft(){ //v1.2, compress sound in iChannel0 to simplified amplitude estimations by frequency-range\n    fft = vec4(0), ffts = vec4(0);\n\n\t// Sound (assume sound texture with 44.1kHz in 512 texels, cf. https://www.shadertoy.com/view/Xds3Rr)\n    for (int n=0;n<3;n++) fft.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //bass, 0-517Hz, reduced to 0-258Hz\n    for (int n=6;n<8;n++) ffts.x  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech I, 517-689Hz\n    for (int n=8;n<14;n+=2) ffts.y  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech II, 689-1206Hz\n    for (int n=14;n<24;n+=4) ffts.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //speech III, 1206-2067Hz\n    for (int n=24;n<95;n+=10) fft.z  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //presence, 2067-8183Hz, tenth sample\n    for (int n=95;n<512;n+=100) fft.w  += texelFetch( iChannel0, ivec2(n,0), 0 ).x; //brilliance, 8183-44100Hz, tenth2 sample\n    fft.y = dot(ffts.xyz,vec3(1)); //speech I-III, 517-2067Hz\n    ffts.w = dot(fft.xyzw,vec4(1)); //overall loudness\n    fft /= vec4(3,8,8,5); ffts /= vec4(2,3,3,23); //normalize\n\t\n\t//for (int n=0;n++<4;) fft[n] *= 1. + .3*pow(fft[n],5.); fft = clamp(fft,.0,1.); //limiter? workaround attempt for VirtualDJ\n}\n\nvec3 getCol(float id){ //color definitions, for triplets\n    vec3 setCol = vec3(0);\n    id = mod(id,15.);\n         if (id< 1.) setCol = vec3(244,  0,204); //vw2 pink\n    else if (id< 2.) setCol = vec3(  0,250,253); //vw2 light blue\n    else if (id< 3.) setCol = vec3( 30, 29,215); //vw2 blue\n    else if (id< 4.) setCol = vec3(252,157,  0); //miami orange\n    else if (id< 5.) setCol = vec3( 26,246,138); //miami green\n    else if (id< 6.) setCol = vec3(131, 58,187); //nordic violet\n    else if (id< 7.) setCol = vec3(231, 15, 20); //arena red\n    else if (id< 8.) setCol = vec3( 35, 87, 97); //arena dark blue\n    else if (id< 9.) setCol = vec3(103,211,225); //arena blue\n    else if (id<10.) setCol = vec3(241,204,  9); //bambus2 yellow\n    else if (id<11.) setCol = vec3( 22,242,124); //bambus2 green\n    else if (id<12.) setCol = vec3( 30,248,236); //magic turquoise\n    else if (id<13.) setCol = vec3( 28,142, 77); //matrix green\n    else if (id<14.) setCol = vec3( 66,120, 91); //matrix green 2\n    else if (id<15.) setCol = vec3(173,  0, 27); //matrix red\n    return setCol/256.;\n}\n\nfloat hash21(vec2 p){ //pseudorandom generator, cf. The Art of Code on youtu.be/rvDo9LvfoVE\n    p = fract(p*vec2(13.81, 741.76));\n    p += dot(p, p+42.23);\n    return fract(p.x*p.y);\n}\n\nfloat aaStep( float fun){return smoothstep( fwidth(fun), .0, fun);} //simple antialiasing\nfloat aaStep( float fun, float minWidth){return smoothstep( max(fwidth(fun),minWidth), .0, fun);} //overload to set minimum width\n\nmat2 rotM(float r){float c = cos(r), s = sin(r); return mat2(c,s,-s,c);} //2D rotation matrix\n\nfloat sdCircle( vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdBox( vec2 p, vec2 b){ //source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p) - b;\n    return length(max(d,.0)) + min(max(d.x,d.y),.0);\n}\n\nfloat sdSegment( vec2 p, vec2 a, vec2 b){//source: https://iquilezles.org/articles/distfunctions2d/\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h);\n}\n\nvec3 getStar(vec2 p, vec2 id){\n    id = vec2( hash21(id), hash21(id+id.yx));\n    p *= 1. + id.y*2.; //different sizes\n    p += id.y*vec2(sin(id.x*aTime/8.),sin(id.y*iTime*.1)); //different postions\n    return smoothstep( .85, 1., id.x) //brightness\n        * (.8 + .2 * vec3( sin(id*aTime/4.), sin(dot(id,vec2(.5))*iTime))) * vec3(1.5,1.,1.5) //color\n        * ((.5 + .5 * sin(2.*aTime*id.x+2.*PI*id.x) * sin(iTime)) //brightness varying over time\n        * aaStep(1. - dot( .1/(abs(p)+fwidth(p)+.12), vec2(1))) //\"lens flare\" shape\n        + smoothstep( .2, .8, .07/length(p))); //round core \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    // General initialization\n    compressFft(); //initializes fft, ffts\n    vec2 uv = (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y); //long edge -1 to 1, square aspect ratio\n    float rho = atan(-abs(uv.x),uv.y)/PI+1.; //polar angle flipped & mirrored\n    \n    \n    // Animation definitions\n    vec4 bang = vec4(0);\n    for (int n=0;n<4;n++)\n        bang[n] = smoothstep( .91, 1., texelFetch( iChannel0, ivec2(n,0), 0 ).x);\n    float colId = 3. * floor(mod(aTime/16.,5.)); //color set id\n    mat2 spaceRot = rotM(.2*sin(aTime/8.+fft.x)*sin(iTime*.1)); //\"outside\" space rotation\n \n \n    // Object definitions\n    float winDistort = length(uv*vec2(1.2,2.)-vec2(0,.2)); //morphing window shape\n    vec4 tmp = vec4( uv*winDistort, vec2(.7,.3)); //temporary \"throw-away\" variable\n    float window = sdBox( tmp.xy, tmp.zw)-.1; //window frame\n    float frame = sdBox( .6*tmp.xy, tmp.zw)-.1; //frame of window frame\n    float sideBox = sdBox( vec2(abs(tmp.x),tmp.y)+vec2(-1.4,1.), vec2(.5)); //bottom edges\n    tmp.x = uv.x;\n    float vent = sdBox( tmp.xy-vec2(-.5,.75), vec2(.15,.3)); //top left \"vent\" shape\n    float ventAmp = sdSegment( fract(tmp.xy*33.), vec2(0), vec2(0,1))-.3; //vertical line texture   \n    \n    tmp = vec4( uv*winDistort+vec2(0,.53), vec2(.8,.09));\n    float bBar = sdBox( tmp.xy, tmp.zw); //bottom \"screen\"\n    float bBarAmp = texelFetch( iChannel0, ivec2(1024.*abs(tmp.x/(2.*tmp.z)),0),0).x; // sound texture, full\n    tmp = vec4( uv*winDistort+vec2(1.05,.0), vec2(.2,.4));\n    float lBar = sdBox( tmp.xy, tmp.zw); //left \"screen\"\n    float lBarAmp = texelFetch( iChannel0, ivec2(24.+71.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, presence\n    tmp.x = uv.x*winDistort-1.05;\n    float rBar = sdBox( tmp.xy, tmp.zw); //right \"screen\"\n    float rBarAmp = texelFetch( iChannel0, ivec2(95.+417.*(tmp.y+tmp.w)/(2.*tmp.w),0),0).x; // sound texture, brilliance\n    \n    tmp = vec4( uv*spaceRot, .1/fft.y, 0.);\n    float reticle = sdCircle( uv, tmp.z); //reticle\n    float horBars = sdSegment( abs(tmp.xy), vec2(.1+tmp.z,.0), vec2(.4+tmp.z,.0)); //horizontal bars \n    float reticleAmp = (length(uv)<.1/fft.y+.1)? //inner/outer\n        texelFetch(iChannel0,ivec2(6.+17.*rho,0),0).x : //sound texture, speech\n        (tmp.x>.0)? //left/right\n            texelFetch(iChannel0,ivec2(94.-71.*(tmp.x-.1-tmp.z)/.3,0),0).x : //sound texture, -presence\n            texelFetch(iChannel0,ivec2(5.-5.*(-tmp.x-.1-tmp.z)/.3,0),0).x; //sound texture, -bass \n\n    vec4 cannonAngle = vec4(2.4,PI-2.4,2.5,PI-2.5); //orientation   \n    vec4 cannons = vec4(\n        sdBox( (uv+vec2(.8,.6))*rotM(cannonAngle.x)-vec2(0,.1*bang.x), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //left bottom cannon\n        sdBox( (uv+vec2(-.8,.6))*rotM(cannonAngle.y)+vec2(0,.1*bang.y), vec2(.1,.55)-.5*vec2(uv.y+.3,-.1)) - .02, //right bottom cannon\n        sdBox( (uv*3.+vec2(-2.,-1.5))*rotM(cannonAngle.z)+vec2(0,.2*bang.z), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05, //right top cannon\n        sdBox( (uv*3.+vec2(2.,-1.5))*rotM(cannonAngle.w)-vec2(0,.2*bang.w), vec2(.01,.8)+.8*vec2(uv.y-.25,.1)) - .05); //left top cannon\n\n    tmp = vec4( -.9, .39, .02, .0);\n    vec4 led = vec4( //dot lights\n        sdCircle( uv-tmp.xy-vec2(-.02,.0), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.07,.02), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.09,.08), tmp.z),\n        sdCircle( uv-tmp.xy-vec2(.0,.06), tmp.z));\n    \n    tmp = vec4( uv*rotM(2.9)+vec2(.8,.6), .005, -.02);\n    float strip1 = sdSegment( tmp.xy, vec2(.0), vec2(.5,.0)) - tmp.z; //strip light 1 carve-out\n    float strip2 = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4,tmp.w)) - tmp.z; //strip light 2 carve-out\n    float strip3 = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3,2.*tmp.w)) - tmp.z; //strip light 3 carve-out\n    float strip1fill = sdSegment( tmp.xy, vec2(.0), vec2(.5*ffts.x,.0)) - tmp.z; //strip light 1 fill, speech I\n    float strip2fill = sdSegment( tmp.xy, vec2(.0,tmp.w), vec2(.4*ffts.y,tmp.w)) - tmp.z; //strip light 2 fill, speech II \n    float strip3fill = sdSegment( tmp.xy, vec2(.0,2.*tmp.w), vec2(.3*ffts.z,2.*tmp.w)) - tmp.z; //strip light 3 fill, speech III\n    \n    \n    // Draw starfield\n    vec3 col = vec3(0); \n    vec2 myUv;\n    float aFrac;\n    for (float n=0.;n<4.;n++){\n        aFrac = fract(-aTime/32.+.25*n) - .03*fft.w*fft.w*fft.w;\n        myUv = 30. * (.3+aFrac) * uv * spaceRot;\n        col += getStar(fract(myUv)-.5, ceil(myUv)+sin(n)) \n            * smoothstep(1.,.33,aFrac) //fade in\n            * smoothstep(.0,.33,aFrac); //fade out (not very graceful)\n    }\n    \n    \n    // Draw screen overlay   \n    reticle = clamp( .005/abs(reticle), .0, 1.) + clamp( .005/abs(horBars), .0, 1.); //glow\n    reticle = reticle * mix( 1., smoothstep(.2,.8,reticleAmp), .75*smoothstep(.66,1.,reticle)); //mix with texture\n    col += mix(reticle,pow(reticle,20.),reticle) * getCol(colId+0.); //heighten contrast & color\n\n    col -= clamp(-1.,.0,texelFetch( iChannel0, ivec2(512.*2.*abs(fragCoord.x/iResolution.x-.5)*winDistort,0),0).x \n        - 1.5*abs(fragCoord.y/iResolution.y-.5)*winDistort) * (.8+.2*getCol(colId)); //sound texture \"shield\"\n     \n     \n    // Draw cannons \n    vec4 flashX = vec4(.4,-.4,-.51,.51); //x position\n    vec4 flashY = vec4(.21,.21,-.3,-.3); //y position\n    vec4 flashMorphX = vec4(1,1,4,4); //x stretch\n    vec4 flashMorphY = vec4(5,5,20,20); //y stretch\n    for (int n=0;n<4;n++) //draw \"nuzzle\" flash\n        col += .1 * (clamp( .1 / clamp( \n            length( (uv+vec2(flashX[n],flashY[n]))*rotM(cannonAngle[n])*vec2(flashMorphX[n],flashMorphY[n]) - sign(flashX[n])*vec2(0,.18*bang[n])) - .05\n            , .001, 1.) * pow(bang[n],9.), .08, 10.) - .08);    \n    for (int n=0;n<4;n++)\n        tmp[n] = aaStep(cannons[n]);\n    col *= 1. - dot(tmp,vec4(1)); //delete col at cannon positions\n    for (int n=0;n<4;n++)\n           col += tmp[n] * (.05-cannons[n]) * (.6+.4*getCol(colId)) * (.5+.5*bang[n]); //cannons\n\n\n    // Draw inside    \n    col *= aaStep(window); //delete\n    col += (1.-aaStep(window)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .1; //window frame\n    col -= (1.-aaStep(frame)) * (.8+.2*getCol(colId)) * (.3+.7*ffts.w) * .05; //frame of window frame\n\n    col *= 1. - aaStep(sideBox); //delete\n    col += aaStep(sideBox) * (.15+sideBox) * (.7+.3*getCol(colId)) * (.3+.7*ffts.w) * 1.5; //bottom side elements\n    \n    col *= 1. - aaStep(vent) * aaStep(ventAmp); //vent\n    \n    col *= 1.-(aaStep(bBar)+aaStep(lBar)+aaStep(rBar)); //delete\n    col += aaStep(bBar) * bBarAmp*bBarAmp*bBarAmp * getCol(colId+1.) //bottom \"screen\"\n        + aaStep(lBar) * lBarAmp*lBarAmp*lBarAmp*lBarAmp * getCol(colId) //left \"screen\"\n        + aaStep(rBar) * rBarAmp*rBarAmp * getCol(colId); //right \"screen\"        \n        \n    tmp = vec4(bBar,lBar,rBar,0);\n    for (int n=0;n<3;n++)\n        col *= 1. - aaStep(abs(tmp[n]),.01)  * .9; //\"screen\" frames   \n\n    col *= 1. - (aaStep(led.x)+aaStep(led.y)+aaStep(led.z)+aaStep(led.w)); //delete\n    for (int n=0;n<4;n++)\n        col += (aaStep(led[n]) + .001/length(led[n])) * (.2+.8*step(.6,fft[n])) * getCol(colId+float(n)); //round led lights\n    \n    col *= 1. - (aaStep(strip1) + aaStep(strip2) + aaStep(strip3)); //delete\n    col += aaStep(strip1fill) * getCol(colId+0.) * .7; //top right line 1\n    col += aaStep(strip2fill) * getCol(colId+1.) * .7; //top right line 2\n    col += aaStep(strip3fill) * getCol(colId+2.) * .7; //top right line 3\n \n    \n    // Finalizations\n    col -= length(uv) * .03; //vignette\n    col = pow(col, vec3(.4545)); //gamma correction\n \n    fragColor = vec4(col,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 33585,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/bop/imanu-noir-bop-remix"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}