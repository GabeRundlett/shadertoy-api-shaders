{
    "Shader": {
        "info": {
            "date": "1604955949",
            "description": "Raymarching based on iq template\nPlaying with folding space",
            "flags": 0,
            "hasliked": 0,
            "id": "wscBWH",
            "likes": 26,
            "name": "Melting fractal",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "makio135",
            "viewed": 776
        },
        "renderpass": [
            {
                "code": "//#define u_resolution iResolution\n//#define u_time iTime\n\n#define AA 1\n\n#define MIN_DIST 0.001\n#define MAX_DIST 50.\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if(k < 0.0) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 opSymXYZ(vec3 p) {\n    p = abs(p);\n    return p;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvoid mengerFold(inout vec3 z) {\n    float a = min(z.x - z.y, 0.0);\n    z.x -= a;\n    z.y += a;\n    a = min(z.x - z.z, 0.0);\n    z.x -= a;\n    z.z += a;\n    a = min(z.y - z.z, 0.0);\n    z.y -= a;\n    z.z += a;\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n    z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n\nfloat glow = 0.;\nvec2 sceneSDF(vec3 p) {\n    float t = iTime * .1;\n    t = easeInOutQuad(mod(t, 1.));\n    vec2 d = vec2(10e5, 0);\n\n    for(int i = 0; i < 5; i++) {\n        p = opSymXYZ(p);\n        mengerFold(p);\n        boxFold(p, vec3(.5));\n        p.x -= .2;\n        p *= rotate3D(t * TAU, vec3(1, 1, 0));\n        p *= .95;\n        p *= rotate3D(-t * TAU, vec3(0, 1, 1));\n\n        float dd = sdRoundCone(p, 1.6, .1, 1.6);\n        if(i == 3) glow += 0.006 / (0.01 + dd * dd * 5.) / (float(AA * AA) * 10.);\n    }\n    d = opUnion(d, vec2(sdBox(p, vec3(.8, .1, .1)), 2.));\n\n    return d;\n}\n\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n\n    #if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n    #endif\n\n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = sceneSDF(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n    // epsilon = a small number\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy).x + \n        e.yyx * sceneSDF(pos + e.yyx).x + \n        e.yxy * sceneSDF(pos + e.yxy).x + \n        e.xxx * sceneSDF(pos + e.xxx).x\n    );\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = sceneSDF(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor); // reflected ray\n\n    // material\n    vec3 col = vec3(202, 82, 68)/255.;\n\n    // lighting        \n    float occ = calcAO(pos, nor); // ambient occlusion\n    vec3 lig = normalize(vec3(-0.4, 0.7, -0.6)); // sunlight\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0); // ambient light\n    float dif = clamp(dot(nor, lig), 0.0, 1.0); // diffuse reflection from sunlight\n    // backlight\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y); // dome light\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0); // fresnel\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0); // specular reflection\n\n    dif *= softshadow(pos, lig, 0.02, 2.5);\n    dom *= softshadow(pos, ref, 0.02, 2.5);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 2.00 * spe * vec3(1.00, 0.90, 0.70) * dif;\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col = col * lin;\n\n    return col;\n}\n\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n    // cast ray to nearest object\n    vec2 res = castRay(ro, rd);\n    float distance = res.x; // distance\n    float materialID = res.y; // material ID\n\n    vec3 col = vec3(0.6 - length((gl_FragCoord.xy - iResolution.xy / 2.) / iResolution.x));;\n        if(materialID > 0.0) {\n            vec3 pos = ro + distance * rd;\n            col = computeColor(ro, rd, pos, distance, materialID);\n        }\n    return vec3(clamp(col, 0.0, 1.0));\n}\nvoid init() {}\n\nvec3 effect(vec3 c) {\n    c += glow * vec3(242, 223, 126)/255.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Ray Origin)\\t\n    vec3 ro = vec3(-5, 2.5, -6) * 2.2 * rotate3D(iTime * .05 * TAU, vec3(0, 1, 0));\n    vec3 ta = vec3(0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 color = vec3(0.0);\n\n    #if AA>1\n    for(int m = 0; m < AA; m++)\n        for(int n = 0; n < AA; n++) {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n            #else\n            vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n            #endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\\t\n            vec3 col = render(ro, rd);\n\n            color += col;\n            #if AA>1\n        }\n    color /= float(AA*AA);\n    #endif\n\n    color = effect(color);\n\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}