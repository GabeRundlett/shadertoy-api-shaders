{
    "Shader": {
        "info": {
            "date": "1508263083",
            "description": "truchet traveler in 4d, same as in 3d and in 2d.\n\n[url=https://www.shadertoy.com/view/XtlyDl]without travel[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "4tjyDz",
            "likes": 8,
            "name": "4d truchet traveler",
            "published": 3,
            "tags": [
                "truchet",
                "4d",
                "rollercoaster"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 790
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define dir3(num) vec4(equal(abs(dir),vec4(num)))\n#define ray_iters 200\n#define draw_dist 20.0\n\n#define pi acos(-1.0)\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(.1031, .1030, .0973, .1099)\n\nfloat box(vec4 p, float size) {\n    vec4 p2 = abs(p)-size;\n    return length(max(p2,0.0))+min(0.0,max(max(max(p2.x,p2.y),p2.z),p2.w));\n}\n\nfloat torus2(vec4 p, vec2 r) {//creates 8 toruses\n    return length(vec3(abs(length(p.xy)-r.x),abs(p.zw))-0.1)-r.y;\n}\n\n/*float map(vec4 p) {\n    vec4 p2 = mod(p,4.0)-2.0;\n    \n    //float transition = clamp(abs(mod(iTime*0.2,2.0)-1.0)*5.0-2.0,0.0,1.0);\n    //return min(box(p2,1.0-transition)-transition,length(abs(p2)-1.0)-0.5);\n    //return box(p2,1.0-transition)-transition;\n    return torus(p2,vec2(1.0,0.3));\n}*/\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat map(vec4 p) {\n    \n    //vec4 p2 = abs(mod(p,4.0)-2.0)-1.0;\n    //return box(p2,0.5);\n    vec4 p2 = mod(p,2.0)-1.0;\n    vec4 floorpos = floor(p*0.5);\n    \n    //the truchet flipping\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0;\n    //orientation.yz = vec2(1.0);\n    \n    //actually flipping the truchet\n    vec4 p3 = p2*orientation;\n    \n    //positions relative to truchet centers\n    mat4 truchet = mat4 (\n        vec4(p3.xy+vec2(-1,+1),p3.zw),// +x +y       fixed - +\n        vec4(p3.yz+vec2(-1,+1),p3.xw),//    +y +z    fixed - +\n        vec4(p3.zw+vec2(-1,+1),p3.xy),//       +z +w fixed - +\n        vec4(p3.xw+vec2(+1,-1),p3.yz) // +x       +w fixed + -\n    );\n    \n    //finding distances to the torises\n    vec4 lens = vec4(\n        torus2(truchet[0],vec2(1.0,0.05)),\n        torus2(truchet[1],vec2(1.0,0.05)),\n        torus2(truchet[2],vec2(1.0,0.05)),\n        torus2(truchet[3],vec2(1.0,0.05)));\n    \n    //creating mask for smallest distance,\n    //so in case i want to do some crazy moddeling i can do that without doing it for all the toruses(4x slower!)\n    vec4 mask = vec4(lessThanEqual(lens, min(min(lens.yzwx,lens.zwxy),lens.wxyz)));\n    float len = dot(lens,mask);\n    \n    return len;\n}\n\n//finding a normal, rough approxximation\nvec4 findnormal(vec4 p, float len) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-len,\n        map(p+eps.yxyy)-len,\n        map(p+eps.yyxy)-len,\n        map(p+eps.yyyx)-len));\n}\n\nvec4 shade(vec4 p, vec4 d, vec4 objnorm, float depth) {\n    vec4 sun = normalize(vec4(-1.0));\n    vec4 reflectnorm = reflect(d,objnorm);\n    vec4 color = objnorm*0.5+0.5;\n    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,sun)));\n    //fragColor /= depth*depth*0.01+1.0;\n    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*3.0/depth/depth);\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n\n    fragColor = vec4(0);\n    \n    vec4 floorpos = vec4(0,0,0,0);\n    vec4 pos = vec4(0,1,1,1);\n    vec4 dir = vec4(1,2,3,4);\n    int num = 0;\n    float time = iTime*0.2;\n    for (float i = 0.0; i <= floor(time); i++) {\n        \n        pos += dir*dir3(1);\n        \n    \tvec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n        //orientation.xyz = vec3(1.0);\n        \n        dir *= orientation;\n        \n        int num2 = (num-int(dot(dir,dir3(1)))+4)%4;\n        float back = dir[num2];\n        dir[num2] = dir[num];\n        dir[num] = -back;\n        num = num2;\n        \n        dir *= orientation;\n        \n        floorpos += dir*dir3(1);\n        pos += dir*dir3(1);\n    }\n\t\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0; //the truchet flipping\n    vec4 dir2 = dir;\n    \n    dir *= orientation;\n    \n    int num2 = (num-int(dot(dir,dir3(1)))+4)%4;\n    float back = dir[num2];\n    dir[num2] = dir[num];\n    dir[num] = -back;\n    num = num2;\n    \n    dir *= orientation;\n\t\n    //animation\n    pos += dir2*vec4(equal(abs(dir2),vec4(1.0)))*(sin(fract(time)*3.14*0.5));\n    pos += dir*dir3(1)*(1.0-cos(fract(time)*pi*0.5));\n    vec4 forward = dir2*cos(fract(time)*pi*0.5)+dir*sin(fract(time)*pi*0.5);\n    \n    /*\n    mat4 rotation = mat4(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0));\n    rotation[3] = forward;\n    rotation[2] = normalize(cross(forward,vec4(1)));\n    rotation[1] = cross(rotation[1],forward);\n    //rotation[0] = cross(rotation[2],rotation[1]);\n    */\n    \n    mat4 rotation = mat4(\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0),\n        vec4(0.0));\n    \n    vec2 t = vec2(cos(fract(time)*pi*0.5),sin(fract(time)*pi*0.5));\n\trotation[3] = normalize(dir2*vec4(equal(abs(dir2),vec4(4)))/4.0*t.x+dir*dir3(4)/4.0*t.y);\n    rotation[0] = normalize(dir2*vec4(equal(abs(dir2),vec4(3)))/3.0*t.x+dir*dir3(3)/3.0*t.y);\n    rotation[1] = normalize(dir2*vec4(equal(abs(dir2),vec4(2)))/2.0*t.x+dir*dir3(2)/2.0*t.y);\n    rotation[2] = normalize(dir2*vec4(equal(abs(dir2),vec4(1)))/1.0*t.x+dir*dir3(1)/1.0*t.y);\n    \n    float count = 0.0;\n    \n    vec4 pos4d = pos+rotation[3]*0.1+rotation[1]*0.3;\n    vec4 dir4d = normalize(vec4(uv,1,0.0));\n    dir4d = rotation*dir4d;\n    float dist = 0.0;\n    float len;\n    for (int i = 0; i < ray_iters; i++) {\n        len = map(pos4d);\n        if (len < 1.0/iResolution.y*dist||dist > draw_dist) {\n            break;\n\n        }\n        pos4d += dir4d*len;\n        dist += len;\n    }\n    if (dist < draw_dist)\n    {\n        count++;\n        /*\n        fragColor = (mod(pos4d,3.0)-1.5);\n        /*\n        vec4 sun = normalize(vec4(-1.0));\n        vec4 objnorm = findnormal(pos4d);\n        vec4 reflectnorm = reflect(dir4d,objnorm);\n        fragColor = objnorm*0.5+0.5;\n        fragColor = vec4(fragColor*max(0.6,dot(objnorm,sun)));\n        */\n        fragColor += shade(pos4d,dir4d, findnormal(pos4d,len), dist);\n    }\n    \n    fragColor = sqrt(fragColor);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}