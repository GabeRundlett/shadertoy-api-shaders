{
    "Shader": {
        "info": {
            "date": "1680128408",
            "description": "Simple rotating transparent textured cube projection without raymarching. Written with help of ChatGPT and GitHub Copilot. Light source is a point light and moves in a circle. Cube looks distorted sometimes, maybe a bug.",
            "flags": 0,
            "hasliked": 0,
            "id": "mddSzj",
            "likes": 2,
            "name": "Simple Cube Projection",
            "published": 3,
            "tags": [
                "cube",
                "projection"
            ],
            "usePreview": 1,
            "username": "emh",
            "viewed": 265
        },
        "renderpass": [
            {
                "code": "mat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 u = normalize(up);\n    vec3 s = normalize(cross(f, u));\n    u = cross(s, f);\n\n    mat4 result = mat4(1.0);\n    result[0][0] = s.x;\n    result[1][0] = s.y;\n    result[2][0] = s.z;\n    result[0][1] = u.x;\n    result[1][1] = u.y;\n    result[2][1] = u.z;\n    result[0][2] = -f.x;\n    result[1][2] = -f.y;\n    result[2][2] = -f.z;\n    result[3][0] = -dot(s, eye);\n    result[3][1] = -dot(u, eye);\n    result[3][2] = dot(f, eye);\n\n    return result;\n}\n\nmat4 perspective(float fov, float aspect, float near, float far) {\n    float tanHalfFov = tan(radians(fov) / 2.0);\n    mat4 result = mat4(0.0);\n    result[0][0] = 1.0 / (aspect * tanHalfFov);\n    result[1][1] = 1.0 / tanHalfFov;\n    result[2][2] = (far + near) / (near - far);\n    result[2][3] = -1.0;\n    result[3][2] = 2.0 * far * near / (near - far);\n    return result;\n}\n\n// Write the barycentric function\nvec3 barycentric(vec2 p, vec2 v0, vec2 v1, vec2 v2) {\n  vec2 e0 = v1 - v0;\n  vec2 e1 = v2 - v0;\n  vec2 e2 = p - v0;\n\n  float d00 = dot(e0, e0);\n  float d01 = dot(e0, e1);\n  float d11 = dot(e1, e1);\n  float d20 = dot(e2, e0);\n  float d21 = dot(e2, e1);\n\n  float denom = d00 * d11 - d01 * d01;\n  float v = (d11 * d20 - d01 * d21) / denom;\n  float w = (d00 * d21 - d01 * d20) / denom;\n  float u = 1.0 - v - w;\n\n  return vec3(u, v, w);\n}\n\n// Write the drawTriangle function\nvec4 drawTriangle(vec2 uv, vec3 v1, vec3 v2, vec3 v3, mat4 view, mat4 projection) {\n    vec3 normal = normalize(cross(v2 - v1, v3 - v1));\n    \n    vec4 screenPos1 = projection * view * vec4(v1, 1.0);\n    vec4 screenPos2 = projection * view * vec4(v2, 1.0);\n    vec4 screenPos3 = projection * view * vec4(v3, 1.0);\n    vec2 p1 = screenPos1.xy / screenPos1.w;\n    vec2 p2 = screenPos2.xy / screenPos2.w;\n    vec2 p3 = screenPos3.xy / screenPos3.w;\n    vec3 bary = barycentric(uv, p1, p2, p3);\n    if (bary.x < 0.0 || bary.y < 0.0 || bary.z < 0.0) {\n        return vec4(0.0);\n    }\n    if (bary.x > 1.0 || bary.y > 1.0 || bary.z > 1.0) {\n        return vec4(0.0);\n    }\n    // Use the barycentric coordinates to lookup texture coordinates\n    vec2 uv1 = vec2(0.0, 0.0);\n    vec2 uv2 = vec2(1.0, 0.0);\n    vec2 uv3 = vec2(0.0, 1.0);\n    vec2 uvCoord = bary.x * uv1 + bary.y * uv2 + bary.z * uv3;\n    // Use the texture coordinates to lookup the texture color\n    vec4 texColor = texture(iChannel0, uvCoord);\n    \n    // Set lightSource to rotate based on iTime\n    vec3 lightSource = vec3(sin(iTime), cos(iTime), 0.0);\n\n    // Calculate the current point on the triangle\n    vec3 point = bary.x * v1 + bary.y * v2 + bary.z * v3;\n\n    // Set lightDir to be the normalized vector from lightSource to the current point on the triangle\n    vec3 lightDir = normalize(lightSource - point);\n\n    float d = 0.5 * length(lightSource - point);\n\n    float diff = max(dot(normal, lightDir) / d, 0.0);\n    \n    // Return the texture color\n    return vec4(texColor.rgb * diff, 1.0);\n}\n\nmat4 rotationMatrix(float time) {\n  float angleX = time * 0.5;\n  float angleY = time * 0.8;\n  float angleZ = time * 1.2;\n\n  mat4 rotX = mat4(1.0, 0.0, 0.0, 0.0,\n                   0.0, cos(angleX), sin(angleX), 0.0,\n                   0.0, -sin(angleX), cos(angleX), 0.0,\n                   0.0, 0.0, 0.0, 1.0);\n\n  mat4 rotY = mat4(cos(angleY), 0.0, -sin(angleY), 0.0,\n                   0.0, 1.0, 0.0, 0.0,\n                   sin(angleY), 0.0, cos(angleY), 0.0,\n                   0.0, 0.0, 0.0, 1.0);\n\n  mat4 rotZ = mat4(cos(angleZ), sin(angleZ), 0.0, 0.0,\n                   -sin(angleZ), cos(angleZ), 0.0, 0.0,\n                   0.0, 0.0, 1.0, 0.0,\n                   0.0, 0.0, 0.0, 1.0);\n\n  return rotX * rotY * rotZ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 color = mix(vec3(1.0), vec3(0.3, 0.4, 0.5), uv.y + 0.5);\n    fragColor = vec4(color, 1.0);\n    fragColor = vec4(vec3(0.0), 1.0);\n\n    vec3 vertices[8] = vec3[8](\n        vec3(-0.5, -0.5, -0.5),\n        vec3(0.5, -0.5, -0.5),\n        vec3(0.5, 0.5, -0.5),\n        vec3(-0.5, 0.5, -0.5),\n        vec3(-0.5, -0.5, 0.5),\n        vec3(0.5, -0.5, 0.5),\n        vec3(0.5, 0.5, 0.5),\n        vec3(-0.5, 0.5, 0.5)\n    );\n\n    int indices[36] = int[36](\n        0, 1, 2, 0, 2, 3,\n        1, 5, 6, 1, 6, 2,\n        5, 4, 7, 5, 7, 6,\n        4, 0, 3, 4, 3, 7,\n        3, 2, 6, 3, 6, 7,\n        4, 5, 1, 4, 1, 0\n    );\n\n    vec3 eye = vec3(2.0, 2.0, 2.0);\n    vec3 direction = normalize(vec3(uv, -1.0) - eye);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 view = lookAt(eye, eye + direction, up);\n    mat4 projection = perspective(45.0, iResolution.x / iResolution.y, 0.1, 10.0);\n\n    vec3 position = vec3(1.0, 1.0, 0.5);\n    vec3 scale = vec3(1.0, 1.0, 1.0) * (sin(iTime) * 0.25 + 1.0);\n    // scale = vec4(1.0);\n\n    // Get a rotation matrix based on iTime\n    mat4 rotation = rotationMatrix(1.0 * iTime);\n    \n    for (int i = 0; i < 36; i += 3) {\n        vec3 v0 = position + scale * (rotation * (vec4(vertices[indices[i]], 1.0))).xyz;\n        vec3 v1 = position + scale * (rotation * (vec4(vertices[indices[i + 1]], 1.0))).xyz;\n        vec3 v2 = position + scale * (rotation * (vec4(vertices[indices[i + 2]], 1.0))).xyz;\n        vec3 bv0 = position - scale * (rotation * (vec4(vertices[indices[i]], 1.0))).xyz;\n        vec3 bv1 = position - scale * (rotation * (vec4(vertices[indices[i + 1]], 1.0))).xyz;\n        vec3 bv2 = position - scale * (rotation * (vec4(vertices[indices[i + 2]], 1.0))).xyz;\n        // Draw front face\n        fragColor += drawTriangle(uv, v0, v1, v2, view, projection);\n        // Draw back face? Seems to work... was just using my intuition.\n        fragColor += drawTriangle(uv, bv0, bv1, bv2, view, projection);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}