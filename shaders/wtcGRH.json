{
    "Shader": {
        "info": {
            "date": "1575639909",
            "description": "For once, backward evolution: from continuous spiral, now looking for the field on grid ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcGRH",
            "likes": 9,
            "name": "Moebius Spiral field",
            "published": 3,
            "tags": [
                "spiral",
                "mobius",
                "field",
                "complex",
                "screenspace"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "// Reusing bits of https://shadertoy.com/view/llsfRj\n// ( watch there and upstream for contiuous lines ).\n\n// --- direct transforms\nvec2 Mobius(vec2 p, vec2 z1, vec2 z2)\n{\n\tz1 = p - z1; p -= z2;\n\treturn mat2(z1, z1.y,-z1.x) * p / dot(p, p);\n}\n\nvec2 spiralZoom(vec2 p, vec2 offs, float n, float spiral, float zoom, vec2 phase)\n{\n\tp -= offs;\n\tfloat a = atan(p.y, p.x)/6.283  + iTime/32.,\n\t      d = length(p);\n\treturn mat2(n,1, spiral,-zoom) * vec2(a, log(d)) + phase;\n}\n\n// --- demo configuration \nvec2 Z1 = vec2(-.875, -.525),\n     Z2 = vec2( .375, -.125);\n\nvec2 MobiusSpiral(vec2 q)      // total direct transform\n{                              // ( for reverse, see https://shadertoy.com/view/llsfRj )\n    q = Mobius(q, Z1, Z2);\n    return spiralZoom(q, vec2(-.5), 5., 3.14159*.2, .5, vec2(-1, 1)*iTime*.25);\n}\n\n// #define hash(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nvoid mainImage(out vec4 O, vec2 u) // --- Draw Moebius Spiral field\n{\n#define scale (R.y/15.) // 30.                           // number of cells\n\tvec2 R = iResolution.xy,\n         U = (u -.5*R) / R.y,\n      // ofs = hash(floor(scale*U)),  // U -= ofs/scale; // jittering\n         V = MobiusSpiral(U);\n    O = .7+.3*vec4(.5+.5*sin(3.*6.28*V),0,1);        // display continuous field\n    U = 2.*fract(U*scale+.5)-1.; \n   \n #define f(v) fract(v+.5)-.5                         // suppress the wrapping glitch\n    mat2 M = inverse( mat2(f(dFdx(V)),f(dFdy(V))) ); // measure compression, for LOD\n    M /= length(vec4(M));   // / max(360.,R.y);      // normalize\n  //float v = 2.*length(U*M) - .5;                   // draw ellipse\n    float v = abs(dot(U,M[1]));                      // draw main direction\n    v = smoothstep(2.*scale/R.y, 0., v);\n    O *= vec4( pow(v, 1./2.2 ) );                    // to sRGB\n} ",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}