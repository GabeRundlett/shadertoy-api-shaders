{
    "Shader": {
        "info": {
            "date": "1608927462",
            "description": "A ring twister was suggested as the next project after I made the classic twister effect. So here it is. :-) \n\nOther shaders I used to study how the effect works:\nhttps://www.shadertoy.com/view/Xt23z3\nhttps://www.shadertoy.com/view/lsX3WM",
            "flags": 0,
            "hasliked": 0,
            "id": "3dyBDy",
            "likes": 8,
            "name": "ring twister",
            "published": 3,
            "tags": [
                "2d",
                "oldschool",
                "ring",
                "twister",
                "polar"
            ],
            "usePreview": 0,
            "username": "maksy",
            "viewed": 534
        },
        "renderpass": [
            {
                "code": "const float IN_RADIUS = 0.3;\nconst float OUT_RADIUS = 0.85;\nconst float PI = 3.14159;\n\nvec3 borderColor(float x0, float x1, vec2 uv, \n                 float leftVisible, float rightVisible) {\n\n    vec3 edgeCol = vec3(0.05);\n    vec3 white = vec3(1.);\n    float thick = 0.03;\n   \t\n    // the exterior side of the left border\n\tfloat outside = (step(uv.x, x0-thick) + step(x0, uv.x));\n    vec3 borderCol = mix(white, edgeCol, smoothstep(x0, x0-thick, uv.x)) \n    \t* (1. - outside) * leftVisible;\n        \n    // the interior side of the left border\n    outside = (step(uv.x, x0) + step(x0+thick, uv.x));\n    borderCol += mix(edgeCol, white, smoothstep(x0+thick, x0, uv.x)) \n    \t* (1. - outside)* leftVisible;      \n    \n    // the exterior side of the right border\n    outside = (step(uv.x, x1) + step(x1+thick, uv.x));        \n    borderCol += mix(white, edgeCol, smoothstep(x1, x1+thick, uv.x))\n        * (1.- outside) * rightVisible ;\n    \n    // the interior side of the right border\n    outside = (step(uv.x, x1-thick) + step(x1, uv.x));            \n    borderCol += mix(edgeCol, white, smoothstep(x1-thick, x1, uv.x))\n    \t* (1.- outside) * rightVisible;\n    \n    return borderCol;\n}\n\nvec3 getBorderColor(float x0, float x1, vec2 uv,\n              vec3 fragColor) {\n        \n    vec3 rightCol = vec3(0.);\n    vec3 leftCol = vec3(0.);\n        \n    leftCol = borderColor(x0, x1, uv, 1., 0.);       \n    rightCol = borderColor(x0, x1, uv, 0., 1.);\n   \n    if (leftCol != vec3(0.))\n        return leftCol;\n    else if (rightCol != vec3(0.))\n   \t\treturn rightCol;                 \n   \n    return fragColor;   \n}\n\nvec3 getColor(float x0, float x1, vec2 uv, vec3 color) {\n   \n   // First u becomes [0,1] then the range [0.0, 0.5] will be \n   // transformed into [0.0, 1.0] and ]0.5, 1.0] into ]1.0, 0.0].\n   float u = (uv.x - x0)/(x1 - x0);\n              \n   // u <= 0.5\n   float ud = (u/0.5) * (1.0 - step(0.5, u));\n   // u > 0.5\n   ud += (1. - (u/0.5-1.)) * (1.0 - step(u, 0.5));\n           \n   // Remove aliasing by making the shading points near x0 and x1 darker.\n   vec3 col = mix(vec3(0.0), color, smoothstep(.0, .6, ud)); \n            \n   // Add lightning by making darker the shading points that are \n   // about to be covered and going \"behind\" another face. This also\n   // removes aliasing since if x1-x0 is small the borders cover the \n   // darker sides and transition to interior area becomes very sharp. \n   float w = (x1 - x0);            \n   col *= w / .55;\n   return col;            \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    uv *= 2.7;\n    \n    // Polar coordinates\n    vec2 uvr = vec2(length(uv), atan(uv.y, uv.x) + PI);\n    uvr.x -= OUT_RADIUS;\n       \n    vec3 col = mix(vec3(0.01), vec3(0.05), smoothstep(2.2, .1, abs(uv.x)));    \n    \n    vec3 colors[4];\n    colors[0] = vec3(0.9, 0.0, 0.0);\n    colors[1] = vec3(0.0, 0.9, 0.0);\n    colors[2] = vec3(0.0, 0.2, 1.0);\n    colors[3] = vec3(1.0, 0.42, 0.0);\n        \n    float angle = uvr.y + 1.5*iTime + .5*sin(uvr.y) * 1.5*sin(iTime) * PI;\n    \n    // Add faces\n    for(int i = 0; i < 4;i++)\n    {\n        float x0 = IN_RADIUS * sin(angle + 0.5 * float(i) * PI);       \n        float x1 = IN_RADIUS * sin(angle + 0.5 * float(i+1) * PI);\n\n        if (uvr.x >= x0 && uvr.x <= x1) {\n            col = getColor(x0, x1, uvr, colors[i]);            \n       }\n    }\n\n    // Add borders.\n    float x0 = IN_RADIUS * sin(angle + 0.0);       \n    float x1 = IN_RADIUS * sin(angle + 0.5*PI);\n    float x2 = IN_RADIUS * sin(angle + 1.0*PI);       \n    float x3 = IN_RADIUS * sin(angle + 1.5*PI);    \n\t\n    if (x0 < x1) {\n        col = getBorderColor(x0, x1, uvr, col);      \n    }    \n    \n\tif (x1 < x2) {\n    \tcol = getBorderColor(x1, x2, uvr, col);\n    }\n   \n   \tif (x2 < x3) {\n    \tcol = getBorderColor(x2, x3, uvr, col);\n    }\n    \n    if (x3 < x0) {\n    \tcol = getBorderColor(x0, x3, uvr, col);\n    \tif (x2 < x3) {\n            col = getBorderColor(x3, x0, uvr, col);    \t\n    \t}\n    }\n    \n    col = pow(col,vec3(.454545));\n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}