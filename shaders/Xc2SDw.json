{
    "Shader": {
        "info": {
            "date": "1706466871",
            "description": "golden ratio conjugate spiral   multiplied by   1.0 - golden ration conjugate spiral",
            "flags": 32,
            "hasliked": 0,
            "id": "Xc2SDw",
            "likes": 11,
            "name": "golden spiral multiply",
            "published": 3,
            "tags": [
                "tunnel",
                "spiral"
            ],
            "usePreview": 0,
            "username": "GoldenRatioScience",
            "viewed": 257
        },
        "renderpass": [
            {
                "code": "// [ golden spiral multiply ]\n// [ shader by goldenratioscience is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International ]\n//\n//\n// ---------------------------------------------------------------------------------------------------------\n//\n\n// ------ from 16807 - https://www.shadertoy.com/view/3dl3DN\nconst float SPEED_OF_LIGHT = 299792458.; // METER / SECOND\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23; // * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8; // * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34; //* JOULE * SECOND;\n\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_black_body_fraction_below_wavelength(float wavelength, float temperature){ \n\n\tconst float h = PLANCK_CONSTANT;\n\tconst float k = BOLTZMANN_CONSTANT;\n\tconst float c = SPEED_OF_LIGHT;\n\n\tfloat L = wavelength;\n\tfloat T = temperature;\n\n\tfloat C2 = h*c/k;\n\tfloat z = C2 / (L*T);\n\t\n\treturn 15.*(z*z*z + 3.*z*z + 6.*z + 6.) * exp(-z)/(pi*pi*pi*pi);\n}\nfloat solve_black_body_fraction_between_wavelengths(float lo, float hi, float temperature){\n\treturn \tsolve_black_body_fraction_below_wavelength(hi, temperature) - \n\t\t\tsolve_black_body_fraction_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_black_body_emissive_flux(float temperature){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec4 weights = vec4(1.0f, 2.0f, 3.0f, 4.0f) * 0.25f;\n    \n    vec2 uv = (fragCoord.xy)/iResolution.xy;\n\n    vec4 samp = textureLod(iChannel0, uv, 0.0f).rgba;\n    \n    vec3 color = vec3(0.0f);\n    \n    for (int i = 0; i < 4; ++i) {\n        float T = samp[i]*1370.+273.15; // from freezing to the melting point of steel\n        float I = get_black_body_emissive_flux(T); // WATT/(METER*METER)\n\n        color.rgb += I * vec3( solve_black_body_fraction_between_wavelengths(600e-9, 700e-9, T),\n                               solve_black_body_fraction_between_wavelengths(500e-9, 600e-9, T), \n                               solve_black_body_fraction_between_wavelengths(400e-9, 500e-9, T) ) \n                               + mix(0.0f, \n                                     samp[i], weights[i]) * 0.0333333f;\n    \n    }\n\n    color.rgb = 1.0f - exp2(-color.rgb);\n\n    fragColor = vec4(vec3(pow(color.rgb, vec3(1.0f/2.2f))), 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define phi 1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243\n#define iphi 0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243\n#define pi 3.14159265359\n#define pi2 (2.0*pi)\n#define eps 0.00001f\n#define luma vec3(0.2126f, 0.7152f, 0.0722f)\n#define bn_scalar (17.0f/255.0f)\n\nconst vec4 feedback_scalar = vec4(0.9f, 0.6f, 0.3f, 0.15f);",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// [ golden spiral multiply ]\n// [ shader by goldenratioscience is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International ]\n//\n//\n// ---------------------------------------------------------------------------------------------------------\n//\n\n#define rot(x) mat2(cos(x), sin(x), -sin(x), cos(x))\n\nfloat spiral(in vec3 uv, in float i, in float t, in float angle, in vec3 spiral_desc) {  \n\n    uv.xy *= rot(t*i*angle*pi2);\n    uv.xyz += spiral_desc * sin(i*angle*pi*uv.xyz);\n\n\tfloat d = length(uv.xyz * uv.z*0.5f)*iphi;\n    float it = uv.z * 1.0f/(1.0f + d*d);\n    return smoothstep(phi, -phi*phi, abs(d-it*it)/fwidth(d) - iphi);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 spiral_desc = vec3(iResolution.x/iResolution.y,1.0f,phi);\n    \n    float t = (iTime + 1.0f);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float color = 0.0f;\n\t\n    vec2 iphis = vec2(iphi, 1.0f - iphi);\n    \n    for(float i=.003; i<1.0; i+=.003) {   \n        float z = fract(i-.1*iphi*t);\n\n        float a = spiral(vec3(uv,z), i, t, iphis.x, spiral_desc);\n        float b = spiral(vec3(uv,z), i, t, iphis.y, spiral_desc);\n        \n        color += a*b * ((phi)/(1.0f + z*z));\n\n        iphis.xy = iphis.yx;\n    }\n\n    vec4 last = textureLod(iChannel0, fragCoord.xy/iResolution.xy, phi).rgba * 0.925f;\n    last.w = last.z;\n    last.z = last.y;\n    last.y = last.x;\n    \n    color += last.y * feedback_scalar.y;\n    color += last.z * feedback_scalar.z;\n    color += last.w * feedback_scalar.w;\n    \n    fragColor = clamp(vec4(color, last.yzw), 0.0f, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}