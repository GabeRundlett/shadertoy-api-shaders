{
    "Shader": {
        "info": {
            "date": "1554045012",
            "description": "It is a video of the original game.\nhttps://youtu.be/LXDT7b0sqIs?t=583",
            "flags": 0,
            "hasliked": 0,
            "id": "WdjSWm",
            "likes": 52,
            "name": "The cake is a lie.",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "portal",
                "cake"
            ],
            "usePreview": 1,
            "username": "kaneta",
            "viewed": 1551
        },
        "renderpass": [
            {
                "code": "#define MAT_SPONGE 0.0\n#define MAT_CREAM 1.0\n#define MAT_BALL 2.0\n#define MAT_CANDLE 3.0\n#define MAT_DISH 4.0\n#define MAT_FRAME 5.0\n#define MAT_OUTSIDE 6.0\n#define MAT_INSIDE 7.0\n#define MAT_HEART 8.0\n#define MAT_SHELF 9.0\n#define MAT_FLOOR 10.0\n#define MAT_CORE 11.0\n\nvec3 RayOrigin, Target, Coord, CoreCoord;\nvec4 CoreID;\nfloat CameraLight, CubeLight;\nfloat Black;\n\nconst float pi = acos(-1.);\nconst float pi2 = pi * 2.0;\n\n// Grab from https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(.1031,.11369,.13787)\n//#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec2 hash12(float n) { return vec2(fract(sin(n) * vec2(12345.6, 78901.2))); }\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\n// ========= Noise ===========\nfloat value_noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(hash21(ip),hash21(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash21(ip+vec2(0.0,1.0)),hash21(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res * 2.0 - 1.0;\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat noise(vec3 p) {\n    return simplex_noise(p);\n}\n\nfloat noise_sum(vec3 p)\n{\n    float f = 0.0;\n    p = p * 4.0;\n    f += 1.0000 * noise(p); p = 2.0 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat fbm(vec2 uv)\n{\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*value_noise( uv ); uv = m*uv;\n\tf += 0.2500*value_noise( uv ); uv = m*uv;\n\tf += 0.1250*value_noise( uv ); uv = m*uv;\n    return f;\n}\n\nfloat height(vec3 p)\n{\n    float base = noise(p * 10.5) * 0.25 + 0.5;\n    return base * 0.03;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n///////////////////// Distance Functions /////////////////////\n// Rotate fold technique\n// https://gam0022.net/blog/2017/03/02/raymarching-fold/\nvec2 pMod(in vec2 p, in float s) {\n    float a = pi / s - atan(p.x, p.y);\n    float n = pi2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\nfloat opRep( in float p, in float c )\n{\n    return mod(p,c)-0.5*c;\n}\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p,c)-0.5*c;\n}\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat sdPlane(vec3 p)\n{\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCream(vec3 p, float phiScale, float radiusOffset, float thickness)\n{\n    p.zx = vec2(atan(p.x, p.z) / pi * phiScale, length(p.zx));\n    p.x -= radiusOffset;\n\n    vec2 theta = vec2(1.6, 0.) + p.z * pi * 4.;\n    float k1 = length(p.yx + sin(theta) * 2.) - thickness;\n    float k2 = length(p.yx + sin(theta + pi) * 2.) - thickness;\n\n    return smin(k1, k2, 2.5);\n}\n\nfloat sdDish(vec3 p)\n{\n    vec2 q = vec2(atan(p.z, p.x), length(p.xz));\n    float d = q.y - 1.2 - sin(q.x * 16.0) * 0.02;\n    vec2 w = vec2( d, abs(p.y) - 0.03);\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat sdChamferedCube1( vec3 p, vec3 size, float corner)\n{\n    vec3 s = max(size - corner, 0.0);\n    p = p - clamp( p, -s, s );\n    p = abs(p);\n    return (p.x+p.y+p.z-corner)*0.57735027;\n}\n\nfloat sdChamferedCube2( vec3 p, vec3 size, float corner)\n{\n    vec3 s = max(size - corner, 0.0);\n    p = p - clamp( p, -s, s );\n    p = abs(p);\n    return max((p.z+p.y-corner) * 0.7071067, p.x);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdFrame(vec3 p)\n{\n    vec3 q = p;\n    p *= 6.0; // normalize frame size\n    p=abs(p) - 4.0;\n    float d = sdChamferedCube1(p, vec3(2.0), 0.5);\n    \n\tif (p.x>p.y) {p.xy = p.yx;}\n\tif (p.x>p.z) {p.xz = p.zx;}\n    p.x += 3.5;\n    p.zy -= 0.7;\n    d = min(d, sdChamferedCube2(p, vec3(1.0, 1.0, 1.0), 0.2));\n    \n    p = q;\n    p = abs(p);\n\tif (p.x<p.y) {p.xy = p.yx;}\n\tif (p.x<p.z) {p.xz = p.zx;}\n    p.x -= 2.79;\n    return max(-sdSphere(p, 2.0), d/6.0);\n}\n\nfloat sdHeartCylinder(vec3 p)\n{\n    p = abs(p);\n\tif (p.y<p.x) {p.xy = p.yx;}\n\tif (p.y<p.z) {p.yz = p.zy;}\n    float c = sdRoundedCylinder( p, 0.2, 0.02, 0.95 );\n    return c;\n}\n\nfloat sdHeart(vec2 p)\n{\n    p.y = -0.1 - p.y*1.2 + abs(p.x)*(1.0-abs(p.x));\n    return length(p) - 0.5;\n}\n\nfloat sdCross(vec3 p)\n{\n    p.xy = abs(p.xy);\n    p.xy *= rot(-1.0);\n    return sdRoundedCylinder(p, 0.02, 0.02, 1.8027);\n}\n\nvec2 sdDesk(vec3 p)\n{\n    vec3 q = p;\n    q.xz = abs(q.xz) - vec2(0.8, 0.6);\n    float legs = sdBox(q, vec3(0.03, 0.5, 0.03));\n    p.y -= 0.5;\n    float top = sdBox(p, vec3(1.1, 0.03, 0.8));\n    float d = min(legs, top);\n    return vec2(d, MAT_OUTSIDE);\n}\n\nvec2 sdStage(vec3 p)\n{\n    vec2 flor = vec2(-abs(p.y - 4.5) + 5.5, MAT_FLOOR);\n    vec2 d = flor;\n    vec3 q = p;\n    q.y -= 9.0;\n    q.xz = opRep(q.xz, vec2(8.0));\n    q = abs(q) - vec3(0.4, 1.0, 0.25);\n    vec2 beams = vec2((min(max(q.x, q.y), max(q.z, q.y + 0.4))), MAT_OUTSIDE);\n    d = opU(d, beams);\n\n    p.xz = pMod(p.xz, 8.0);\n    p.xz = opRep(p.xz, vec2(24.0, 12.0));\n    q = abs(p) - vec3(0.7);\n    vec2 pillars = vec2(max(q.x, q.z), MAT_OUTSIDE);\n    d = opU(d, pillars);\n    return d;\n}\n\nvec2 sdShelf(vec3 p, vec2 size)\n{\n    float width = 1.5;\n    \n    /// Core\n    vec3 q = p;\n    q.x += 1.6;\n    q.y -= 0.295;\n    float id1 = (floor(q.x / 3.2));\n    float id3 = (floor(q.y));\n    q.xy = opRep(q.xy, vec2(3.2, 1.0));\n    q.x += 0.5;\n    float id2 = (floor(q.x/(3.2*0.3333)));\n    q.x = opRep(q.x, 3.2*0.3333);\n    float core;\n    float rnd = hash31(vec3(id1, id2, id3) + CoreID.w + 1.0) * 0.5 + 0.5;\n    if (rnd <= 0.5 || (id1 == 0.0 && id2 == 0.0 && id3 == 0.0)) {\n    \tcore = 99999.9;\n    } else {\n        CoreID.xyz = vec3(id1, id2, id3);\n        vec3 h = hash33(CoreID.xyz + CoreID.w);\n        q.xz += h.xz * 0.05;\n        h *= pi2;\n        q.xz *= rot(h.x);\n        q.xy *= rot(h.y);\n        q.yz *= rot(h.z);\n        core = sdSphere(q, 0.4);\n        CoreCoord = q;\n    }\n    \n    /// Shelf\n    p.x += size.x * 1.6;\n    vec3 o = p;\n    p.y += 0.2;\n    p.xy = opRep(p.xy, vec2(3.2, 1.0));\n    \n    q = p;\n    q.xz = abs(q.xz) - vec2(width, 1.0);\n    \n    float legs = sdBox(q, vec3(0.05, 1.0, 0.05));\n    float flor = sdBox(p, vec3(width, 0.05, 1.0)) * 0.6;\n    \n    float d = min(legs, flor);\n    \n    p = o;\n    p.y += 0.7;\n    p.z += 1.0;\n    p.xy = opRep(p.xy, vec2(3.2, 2.0));\n    float cros = sdCross(p);\n    d = max(o.y - size.y + 1.0, d);\n    cros = max(o.y - size.y + 1.7, cros);\n    d = min(d, cros);\n    //core = max(abs(o.y - 0.8) - size.y + 1.6, core);\n    core = max(o.y - size.y + 0.8, core);\n    core = max(-o.y - 0.8, core);\n    vec2 ret = opU(vec2(d, MAT_SHELF), vec2(core, MAT_CORE));\n    ret.x = max(o.x - size.x * 3.0 - size.x * 0.2, ret.x);\n    ret.x = max(-o.x, ret.x);\n\n    return ret;\n}\n\nvec2 sdCake(vec3 p)\n{\n    float ss = sdSphere(p, 2.0);\n    if (ss > 1.0) {\n    \treturn vec2(ss, 0.0);\n    }\n    p.y += 0.15;\n    vec3 q = p;\n    q.y = abs(p.y) - 0.2;\n    vec2 sponge = vec2(sdRoundedCylinder(q, 0.5, 0.2, 0.15), MAT_SPONGE);\n    \n    q = p;\n    q.xz = pMod(q.xz, 8.0);\n    q.yz -= vec2(0.58, 0.6);\n    vec3 s = vec3(50.0, 75.0, 50.0);\n    vec2 cream = vec2(sdCream(q * s, 1., 3.0, 2.5) / s.y * 0.75, MAT_CREAM);\n    q.y -= 0.06;\n    vec2 redBall = vec2(sdSphere(q, 0.08), MAT_BALL);\n    \n    q = p;\n    q.y -= 0.8;\n    vec2 candle = vec2(sdCappedCylinder(q, vec2(0.03, 0.4)), MAT_CANDLE);\n    \n    q.y += 1.25;\n    vec2 dish = vec2(sdDish(q), MAT_DISH);\n    \n    vec2 d = opU(sponge, cream);\n    d = opU(redBall, d);\n    d = opU(candle, d);\n    d = opU(dish, d);\n    \n    return d;\n}\n\nvec2 sdInsideBox(vec3 p)\n{\n    vec2 b1 = vec2(sdBox(p, vec3(0.9)), MAT_INSIDE);\n    p = abs(p) - 0.47;\n    vec2 b2 = vec2(sdBox(p, vec3(.45)), MAT_OUTSIDE);\n    return opU(b1, b2);\n}\n\nvec2 sdCube(vec3 p)\n{\n    float ss = sdSphere(p, 2.0);\n    if (ss > 1.0) {\n    \treturn vec2(ss, 0.0);\n    }\n    vec3 q = p;\n\tvec2 f = vec2(sdFrame(p), MAT_FRAME);\n    vec2 b = sdInsideBox(p);\n    vec2 c = vec2(sdHeartCylinder(p), MAT_HEART);\n    vec2 d = opU(f, b);\n    d = opU(d, c);\n    \n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 pp = sdStage(p);\n    vec3 cubePos = p * 2.0;\n    cubePos -=  vec3(-4.5, -0.5, -13.0) * 2.0;\n    cubePos.xz *= rot(1.);\n    \n    vec3 cakePos = p * 2.0;\n    cakePos -=  vec3(0.0, 0.07, -8.0) * 2.0;\n    \n    vec2 d = opU(sdCube(cubePos), sdCake(cakePos)) * vec2(0.5, 1.0);\n    \n    Coord = cubePos;\n    \n    vec3 deskPos = p - vec3(0.0, -0.8, -8.0);\n    deskPos.xz *= rot(0.25);\n    \n    vec2 desk = sdDesk(deskPos);\n    d = opU(d, desk);\n    d = opU(d, pp);\n    \n    vec3 q = p;\n    p.xz = pMod(p.xz, 8.0);\n    q = p;\n    CoreID.w = abs(floor(p.z / 6.0));\n    p.z = opRep(p.z, 6.0);\n    \n    vec2 size = floor(hash12(CoreID.w) * vec2(3.0, 5.0)) + vec2(5.0, 3.0);\n\tif (abs(CoreID.w) == 2.0) {\n    \tsize = vec2(3.0, 3.0);\n    }\n    p.z *= -1.0;\n    vec2 shelf = sdShelf(p, size);\n    shelf.x = max(-q.z + 12.0, shelf.x) * 0.7;\n    d = opU(d, shelf);\n    return d;\n}\n\nfloat shadow(in vec3 p, in vec3 l, float ma)\n{\n    float t = 0.03;\n    float t_max = ma;\n    \n    float res = 1.0;\n    for (int i = 0; i < 48; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.001)\n        {\n            return 0.0;\n        }\n        t += d*1.0;\n        res = min(res, 20.0 * d / t);\n    }\n    \n    return res;\n}\n\nvec3 normal( vec3 pos, float eps, vec4 h )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*(map( pos + e.xyy ).x + h.x) +\n\t\t\t\t\t  e.yyx*(map( pos + e.yyx ).x + h.y) +\n\t\t\t\t\t  e.yxy*(map( pos + e.yxy ).x + h.z) +\n\t\t\t\t\t  e.xxx*(map( pos + e.xxx ).x + h.w) );\n}\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (pi * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - min(1.0, cosTheta), 5.0);\n}\n\nvec3 PBR(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n\tvec3 diffuseBRDF = kd * albedo / pi;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL;\n}\n\nvec3 pointLight(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n    vec3 lightVector = L - pos;\n    float lightDistance = length(lightVector);\n    vec3 lightDir = lightVector / lightDistance;\n    \n    float shadow = shadow(pos, lightDir, lightDistance);\n    return PBR(pos, albedo, metalness, roughness, N, V, lightDir, Lradiance) * shadow / (lightDistance * lightDistance);\n}\n    \nvec3 ambient(vec3 n, vec3 albedo)\n{\n    return albedo * clamp(0.5+0.5*n.y,0.0,1.0) * 0.02;\n}\n\nfloat linerFog(float x, float ma, float len)\n{\n  return pow(min(max(x - ma, 0.0) / len, 1.0), 1.7);\n}\n\n// Thanks \"Candlestick\" by P_Malin\n// https://www.shadertoy.com/view/Xss3DH\nvec3 GetFlameWander()\n{\n    vec3 vFlameWander = vec3(0.0, 0.0, 0.0);\n\n\tvFlameWander.x = sin(iTime * 20.0);\n\tvFlameWander.z = sin(iTime * 10.0) * 2.0;\n\n    return vFlameWander;\t\n}\n\nvec3 vFlameColour1 = vec3(1.0, 0.5, 0.1);\nvec3 vFlameColour2 = vec3(1.0, 0.05, 0.01);\n\nvec3 GetFlameIntensity( const in vec3 vOrigin, const in vec3 vDir, const in float fDistance )\n{\n\tvec3 vFlamePos = vec3(0.0, 0.65, -8.0);\n\tvec3 vToFlame = vFlamePos - vOrigin;\n\t\n\tfloat fClosestDot = dot(vDir, vToFlame);\n\tfClosestDot = clamp(fClosestDot, 0.0, fDistance);\n\t\n\tvec3 vClosestPos = vOrigin + vDir * fClosestDot;\n\tvec3 vClosestToFlame = vClosestPos - vFlamePos;\n\t\n\tvClosestToFlame.xz *= (vClosestToFlame.y + 1.0) * 1.5;\n\tvClosestToFlame.y *= 0.5;\n\tvClosestToFlame *= 40.0;\n\n\tfloat fSwayAmount = (1.0 + vClosestToFlame.y ) * 0.05;\n\tvClosestToFlame += GetFlameWander() * fSwayAmount;\n\t\n\tfloat fClosestDist = length(vClosestToFlame);\n\t\t\n\tfloat fBrightness = smoothstep(1.0, 0.5, fClosestDist) * 2.0;\n\t\t\t\n\tfloat fHeightFade = (vClosestToFlame.y * 0.5 + 0.5);\n\tfBrightness *= clamp(dot(vClosestToFlame.xz, vClosestToFlame.xz) + fHeightFade, 0.0, 1.0);\n\n\treturn mix(vFlameColour1 * 32.0, vFlameColour2, 1.0 - fBrightness) * fBrightness;\n}\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    RayOrigin.z = opRep(RayOrigin.z, 120.0);\n    vec3 col = vec3(0.0);\n    vec3 sky = vec3(0.1, 0.3, 0.5) * 1.5;\n\n    float roughness = 0.0, metalness = 0.0;\n    vec3 albedo = vec3(0.0), n = vec3(0.0), emissive = vec3(0.0);\n    CubeLight = 4.0;\n    vec4 h = vec4(0.0);\n    \n    if (mat.y == MAT_SPONGE) {\n    \tvec3 q = p * 3.5;\n    \tvec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n        h = vec4(height(q + e.xyy), height(q + e.yyx), height(q + e.yxy), height(q + e.xxx));\n        albedo = vec3(0.12, 0.04, 0.04) * 0.5;\n        roughness = 0.5;\n\t} else if (mat.y == MAT_CREAM) {\n        albedo = vec3(0.5);\n        roughness = 0.4;\n    } else if (mat.y == MAT_BALL) {\n        albedo = vec3(0.2, 0.0, 0.0);\n        roughness = 0.2;\n    } else if (mat.y == MAT_CANDLE) {\n\t\talbedo = vec3(0.8);\n        roughness = 0.2;\n        emissive = vec3(1.0, 0.5, 0.01) * smoothstep(0.35,  0.65, p.y) * 2.0;\n    } else if (mat.y == MAT_DISH) {\n\t\talbedo = vec3(0.3, 0.1, 0.01);\n        roughness = 0.2;\n    } else if (mat.y == MAT_FRAME) {\n    \talbedo = vec3(0.8);\n        roughness = 0.2;\n        CubeLight = 1.0;\n    } else if (mat.y == MAT_OUTSIDE) {\n    \talbedo = vec3(0.3);\n        roughness = 0.3;\n        CubeLight = 1.0;\n    } else if (mat.y == MAT_INSIDE) {\n    \talbedo = vec3(1.0, 0.2, 0.5);\n        emissive = vec3(1.0, 0.2, 0.5) * 10.0 * (sin(iTime) * 0.5 + 0.5);\n        roughness = 0.2;\n    } else if (mat.y == MAT_HEART) {\n        vec3 q = Coord * 2.0;\n        float heart = min(sdHeart(q.xy), min(sdHeart(q.zx), sdHeart(q.yz))) * 0.5;\n        heart = smoothstep(0.0, 0.01, heart);\n    \talbedo = mix(vec3(0.5, 0.1, 0.2), vec3(0.8), heart);\n        emissive = mix(vec3(0.5, 0.1, 0.2) * 5.0, vec3(0.0), heart) * (sin(iTime) * 0.5 + 0.5);\n        roughness = mix(0.6, 0.2, heart);\n        CubeLight = 0.3;\n    } else if (mat.y == MAT_SHELF) {\n        float a = smoothstep(0.7, 0.9, noise(p * 3.0) * 0.5 + 0.5);\n    \talbedo = mix(vec3(0.5), vec3(0.5, 0.2, 0.05), a);\n        roughness = mix(0.6, 0.9, a);\n        metalness = 1.0;\n    } else if (mat.y == MAT_FLOOR) {\n    \tfloat checker = mod(floor(p.x) + floor(p.z), 2.0);\n        float c = mix(0.2, 0.3, checker);\n        float dirty = smoothstep(0.5, 1.0, noise_sum(p * 0.25) * 0.5 + 0.5);\n        float wet = smoothstep(0.2, 1.0, noise_sum(p *0.1) * 0.5 + 0.5);\n        c = mix(c, 0.6, dirty);\n        c = mix(c, c * 0.2, wet);\n        albedo = vec3(c);\n        \n    \tvec3 q = p * 1.0;\n    \tvec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n        h = vec4(noise_sum(q + e.xyy), noise_sum(q + e.yyx), noise_sum(q + e.yxy), noise_sum(q + e.xxx)) * 0.01;\n        roughness = mix(0.5, 0.8, checker);\n        roughness = mix(roughness, 0.6, dirty);\n        roughness = mix(roughness, 0.2, wet);\n    } else if (mat.y == MAT_CORE) {\n        albedo = vec3(1.0);\n        \n        float len = length(CoreCoord.xy);\n        float corePattern = mix(0.4, 1.0, smoothstep(0.2, 0.21, len));\n        corePattern = mix(0.4, corePattern, smoothstep(0.01, 0.02, abs(CoreCoord.y)));\n        corePattern = mix(1.0, corePattern, smoothstep(0.17, 0.175, len));\n        corePattern = mix(0.4, corePattern, smoothstep(0.11, 0.12, len));\n\n        roughness = mix(0.2, 0.5, corePattern);\n        albedo = vec3(corePattern);\n        \n        float hash = hash31(CoreID.xyz + CoreID.w);\n        float wave = max(0.0, sin(iTime * 0.3 + hash * pi2));\n        emissive += mix(vec3(1.0, 0.01, 0.01) * 3.0, vec3(0.0), smoothstep(0.0, 0.22, len)) * wave;\n        emissive += mix(vec3(1.0, 0.5, 0.1) * 40.0, vec3(0.0), smoothstep(0.0, 0.15, len)) * wave;\n    }\n    n = normal(p, 0.001, h);\n    vec3 l1 = vec3(0.0, 1.0, -8.0) + vec3(fbm(vec2(0.0, iTime)), fbm(vec2(iTime, 0.0)), fbm(vec2(iTime))) * 0.1;\n    vec3 l2 = vec3(sin(iTime * 1.0)*5., 1.0, cos(iTime * 1.0)*5.) + vec3(0.0, 0.0, -8.0);\n\n    col = pointLight(p, albedo, metalness, roughness, n, -ray, l1, vec3(1.0, 0.5, 0.1) * 20.0 * mix(0.8, 1.0, sin(iTime * 20.0) * 0.5 + 0.5));\n    col += pointLight(p, albedo, metalness, roughness, n, -ray, RayOrigin + vec3(0.0, -0.05, 0.0), vec3(0.5) * CameraLight);\n    col += pointLight(p, albedo, metalness, roughness, n, -ray, vec3(-4.1, -0.5, -12.35), vec3(0.5, 0.1, 0.2) * CubeLight * (sin(iTime) * 0.5 + 0.5));\n    col += ambient(n, albedo);\n    col += emissive;\n\n    float fo = linerFog(depth, 9.0, 50.0);\n    vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n    col = mix( col, sky, fo ) + GetFlameIntensity(RayOrigin, ray, depth);\n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    for (int i = 0; i < 150; i++) {\n        pos = p + ray * t;\n        pos.z = opRep(pos.z, 120.0);\n        mat = map(pos);\n        if (mat.x < 0.00001 || t > 50.0) {\n        \tbreak;\n        }\n        t += mat.x;\n    }\n    return materialize(pos, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat exponentialOut(float t) {\n\treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvoid cameraPath()\n{\n    float t = mod(iTime, 51.0);\n    vec3 origin = vec3(0.0, 0.0, -60.0);\n    vec3 cube = origin + vec3(-4.5, -0.5, -13.0);\n    vec3 cake = origin + vec3(0.0, 0.07, -8.0);\n    CameraLight = 0.0;\n    Black = 1.0;\n    if (t < 10.0) {\n    \t// far camera\n    \tRayOrigin =  vec3(sin(-t * 0.1) * 24.0, 6.0, cos(-t * 0.1) * 24.0) + vec3(0.0, 0.0, -60.0);\n    \tTarget = vec3(-0.0, 1.0, -68.0);\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 16.0) {\n    \t// core camera\n    \tt -= 10.0;\n    \tRayOrigin =  vec3(-t, 1.0, 0.0) + vec3(0.0, 0.0, -72.0);\n    \tTarget = RayOrigin + vec3(1.0, 0.0, -1.0);\n        Black = sm(0.0, 6.0, t, 1.0);\n    } else if(t < 26.0) {\n    \t// companion cube camera\n        t -= 16.0;\n    \tRayOrigin = cube + vec3(-t * 0.5 + 3.0, 1.0, 3.0);\n    \tTarget = cube;\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 36.0) {\n    \t// cake camera\n        t -= 26.0;\n    \tfloat dist = t * 0.2 + 0.5;\n    \tRayOrigin = cake + vec3(sin(t*0.2) * dist, 1.0 - t * 0.05, cos(t*0.2) * dist);\n    \tTarget = cake + vec3(0.0, 0.4 - t * 0.03, 0.0);\n    \tCameraLight = 3.0;\n        Black = sm(0.0, 10.0, t, 1.0);\n    } else if(t < 51.0) {\n    \t// the cake is a lie\n    \tt -= 36.0;\n        RayOrigin = mix(vec3(0.0, 1.0, 52.0), vec3(0.0, 1.0, -62.0), exponentialOut(min(1.0, t*0.06)));\n        RayOrigin.y = mix(1.0, 1.3, quadraticInOut(clamp((t-4.0)*0.2, 0.0, 1.0)));\n    \tTarget = vec3(-0.0, 1.0, -68.0);\n    \tCameraLight = 30.0;\n        Black = sm(0.0, 15.0, t, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    cameraPath();\n\n    mat3 c = camera(RayOrigin, Target, 0.0);\n    vec3 ray = c * normalize(vec3(p, 3.0));\n    vec3 col = trace(RayOrigin, ray);\n    \n    col = reinhard(col, 1.0, 5.0);\n    col = pow(col, vec3(1.0/2.2));\n\n    p = fragCoord.xy / iResolution.xy;\n    p *=  1.0 - p.yx;\n    float vig = p.x*p.y * 200.0;\n    vig = pow(vig, 0.1);\n    \n    fragColor = vec4(col * vig * Black,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}