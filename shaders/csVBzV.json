{
    "Shader": {
        "info": {
            "date": "1698413538",
            "description": "more tricks",
            "flags": 0,
            "hasliked": 0,
            "id": "csVBzV",
            "likes": 3,
            "name": "spqr transparency",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 162
        },
        "renderpass": [
            {
                "code": "\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat hash11(float t) {\n  return fract( sin(t * 7361.994) * 4518.442);\n}\n\n\n\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat closestWall(vec3 p) {\n    vec3 d = min(fract(p), 1.0 - fract(p));\n    return min(min(d.x, d.y), d.z);\n}\n\nfloat box (vec3 p, vec3 s) {\n    vec3 ap = abs(p) - s;\n    return length(max(vec3(0.),ap)) + min( 0., max(ap.x,max(ap.y,ap.z)));\n\n\n}\n\n\nfloat tick(float t) {\n\n    float n = floor(t);\n    float r = fract(t);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    r = smoothstep(0.,1.,r);\n    \n    return n + r;\n}\nfloat field (vec3 p, float scale) {\n\n\n   float tt = tick(iTime*.67);\n   scale *= .25;\n   p *= scale;\n   vec3 id = floor(p)-.5; \n   p = fract(p) -.5;\n   \n   float f1 = hash31(id);\n \n\n   float ball = box(p, pow(f1,sin(tt*1.617)*.5+.5) * vec3(.49));\n   // important detail\n   float bound = closestWall(p+.5);\n   \n   return min(bound + .1, ball)/scale;\n}\n\nfloat map (vec3 p){\n    p.xz *= rot(iTime*.1);\n \n    float thing = box(p, vec3(3));\n\n   // geo\n   \n    for (float i = 0.; i < 5.; i++) {\n       thing = max(thing, -field(p,pow(2.,i)));\n    }\n\n    return thing;\n}\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.001,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  // nav\n  \n  vec3 s = vec3 (0,0,-4);\n  s *= (sin(iTime*.3)*.5+.5)+.2;\n  vec3 t = vec3(0);\n  \n \n  \n  float tt = iTime * .3;\n  s.xz *= rot(tt*.4);\n  s.xy *= rot(tt*.5);\n  s.zy *= rot(tt*.7);\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=-normalize(cross(cz,cx));\n  \n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz);\n  \n\n  \n  vec3 col = vec3(0);\n  \n  vec3 p = s;\n  \n  float dd = 0.;\n  \n  float side=sign(map(p));\n  int hit = 0;\n  for(int i = 0; i < 1000; i++) {\n  \n      float d=map(p)*side;\n      \n      if(d<0.01) {\n          hit++;\n          vec3 n = norm(p)*side;\n          vec3 l = normalize(vec3(-1));\n          \n      \n          vec3 h = normalize(l-r);\n          \n          float diff = max(0., dot(n,l));\n          float spec =( 0.4 + pow(max(0., dot(n,h)),100.));\n          \n          vec3 remaining = vec3(1) - col;\n          col += remaining  *  spec * .2 * (dd/10.);\n              \n          side = -side;\n          \n          d = .1;\n          if (hit >10) { break;}\n          \n      }\n      if ( dd > 10.) {\n          break;\n      }\n       \n      dd += d;\n      p+=r*d;\n  }\n  \n\n  \n  fragColor = vec4(col, 1);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}