{
    "Shader": {
        "info": {
            "date": "1509642437",
            "description": "medusa with continuous texture.\nyou can download the geometry of this shape at my site  [url]https://shaderoo.org[/url].\nits very similar to shadertoy but has some extra features. i'd be happy if someone is keen to post a shader there :-)\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ltBcDw",
            "likes": 38,
            "name": "medusas hairdo with uv",
            "published": 3,
            "tags": [
                "uv",
                "snake",
                "truchet",
                "medusa"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 1372
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// meduas's hairdo with uv coords\n\n// you can look at (and download) a geometry version of this at my new site \n\n// https://shaderoo.org\n\n// its very simmilar to shadertoy but with some extra features (and others missing)\n// i'd be very happy if some of you check it out or tell me what you think of it\n// or even post a shader there... :-)\n// shaderoo is rather young...\n// ...and most likely still stumbling and not walking straight ;-)...\n// ...so it might have some issues here and there...\n// ...hopefully its ready for the outside world\n\n//uncomment this if you want a snake-skin surfce\n#define SNAKE_SKIN\n//uncomment this for only uv-coords\n//#define UV_ONLY\n    \n// golden ratio - used for icosahedron\n#define G (.5+sqrt(5./4.))\n#define PI 3.141592653\n#define PI2 6.28318531\n\n#define XCHGV3(a,b) { vec3 d=a; a=b; b=d; }\n\nvoid sortXYZ(inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    #define W(p) (p.x+p.y*.01+p.z*.0001)\n    if(W(p3)>W(p2)) XCHGV3(p3,p2);\n    if(W(p2)>W(p1)) XCHGV3(p2,p1);\n    if(W(p3)>W(p2)) XCHGV3(p3,p2);\n    if(W(p2)>W(p1)) XCHGV3(p2,p1);\n}\n\n// get closest icosahedron triangle\nvoid getIcosaTriOld(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    float dot1 = -1000.0;\n    float dot2 = -1000.0;\n    float dot3 = -1000.0;\n    for(int s1=0;s1<2;s1++)\n    {\n    \tfor(int s2=0;s2<2;s2++)\n        {\n    \t\tfor(int perm=0;perm<3;perm++)\n            {\n                vec3 p0 = normalize(vec3(G,1,0))*vec3(s1*2-1,s2*2-1,0);\n                if     (perm>1) p0 = p0.yzx;\n                else if(perm>0) p0 = p0.zxy;\n                float dot0 = dot(pos,p0);\n                if(dot0>dot1){\n                    dot3=dot2; p3=p2;\n                    dot2=dot1; p2=p1; \n                    dot1=dot0; p1=p0;\n                }\n                else if(dot0>dot2){\n                    dot3=dot2; p3=p2;\n                    dot2=dot0; p2=p0; \n                }\n                else if(dot0>dot3){\n                    dot3=dot0; p3=p0;\n                }\n            }\n        }\n    }\n}\n\nvoid getIcosaTri(vec3 pos, out vec3 p1, out vec3 p2, out vec3 p3)\n{\n    mat2 rot=mat2(0.809016994374947, 0.587785252292473, -0.587785252292473, 0.809016994374947);\n    \n    float ph = atan(pos.y,pos.x);  ph=(ph<0.)?PI2+ph:ph;\n    \n    float dang=PI2/5.;\n    float seg=ph/dang;\n    float fseg=floor(seg);\n    \n    // 3 topmost points of segment + lower point of seg (p4t)\n    vec3 p1t=vec3(0,0,1.);\n    vec3 p2t=vec3(cos(fseg*dang-vec2(0,PI2/4.))*.894427190999916,.447213595499958);\n    vec3 p4t=vec3(rot*p2t.xy,-p2t.z);\n    vec3 p3t=vec3(rot*p4t.xy, p2t.z);\n\n    if (dot(pos,cross(p2t,p4t))<0. || dot(pos,cross(p4t,p3t))<0.) {\n        // xchg p2 and p3 (because bottom is mirrored in z)\n        p1t=vec3(0,0,-1.);\n        p3t=vec3((seg-fseg<.5)?p2t.xy*rot:rot*p2t.xy,-p2t.z);\n        p4t=vec3(rot*p3t.xy,-p3t.z);\n        p2t=vec3(rot*p4t.xy, p3t.z);\n    }\n\n    // mix top or below\n    bool top=(dot(pos,cross(p2t,p3t))>0.);\n    p1=top?p1t:p4t; \n    p2=top?p2t:p3t; \n    p3=top?p3t:p2t;\n}\n\n\n// check if pos hits triangle\nbool thruTriangle(vec3 pos, vec3 v1, vec3 v2, vec3 v3)\n{\n    vec3 n = cross(v2-v1,v3-v1);\n    // calc where pos hits triangle plane\n    pos = pos*dot(v1,n)/dot(pos,n);\n    v1-=pos; v2-=pos; v3-=pos;\n \tvec3 c1=cross(v1,v2);\n    vec3 c2=cross(v2,v3);\n    vec3 c3=cross(v3,v1);\n    // check if the cross products of all the pos-edge-vectors show into the same direction\n    return dot(c1,c2)>0. && dot(c2,c3)>0. && dot(c3,c1)>0. ;\n}\n\n// subdivide 1 triangle into 4 triangles and give back closest triangle\nvoid getTriSubDivOld(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    vec3 p4 = normalize(p1+p2);\n    vec3 p5 = normalize(p2+p3);\n    vec3 p6 = normalize(p3+p1);\n\n    if     (thruTriangle(pos,p1,p4,p6)) { p1=p1; p2=p4; p3=p6; }\n    else if(thruTriangle(pos,p6,p5,p3)) { p1=p6; p2=p5; p3=p3; }\n    else if(thruTriangle(pos,p6,p4,p5)) { p1=p6; p2=p4; p3=p5; }\n    else if(thruTriangle(pos,p4,p2,p5)) { p1=p4; p2=p2; p3=p5; }\n}\n\nvoid getTriSubDiv(vec3 pos, inout vec3 p1, inout vec3 p2, inout vec3 p3)\n{\n    mat3 m = mat3((p2-p1)*.5,(p3-p1)*.5,p1);\n    vec3 q = inverse(m)*pos;\n    q/=q.z;\n    vec3 qf=floor(q);\n    float f=step(1.,q.x-qf.x+q.y-qf.y);\n    p1 = m*vec3( qf.xy+f,            1 );\n    p2 = m*vec3( qf.xy+vec2(1.-f,f), 1 );\n    p3 = m*vec3( qf.xy+vec2(f,1.-f), 1 );\n    p1=normalize(p1);\n    p2=normalize(p2);\n    p3=normalize(p3);\n}\n\nfloat tri01(float x)\n{\n    return abs(fract(x)-.5)*2.;\n}\n\n\n// get some 3d rand values by multiplying 2d rand in xy, yz, zx plane\nvec4 getRand(vec3 pos)\n{\n    vec4 r = vec4(1.0);\n    r*=textureLod(iChannel0,pos.xy,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.xz,0.)*2.-1.;\n    r*=textureLod(iChannel0,pos.zy,0.)*2.-1.;\n    return r;\n}\n\n// distancefield of torus around arbitrary axis z\n// similar to https://iquilezles.org/articles/distfunctions\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z)\n{\n    float pz = dot(pos,normalize(z));\n    return length(vec2(length(pos-z*pz)-r1,pz))-r2;\n}\n\nfloat distTorus(vec3 pos, float r1, float r2, vec3 z, out float ang)\n{\n    float pz = dot(pos,normalize(z));\n    vec2 r = vec2(length(pos-z*pz)-r1,pz);\n    ang = atan(r.y,r.x);\n    return length(r)-r2;\n}\n\nvec4 getRand01Sph(vec3 pos)\n{\n    vec2 res = iChannelResolution[0].xy;\n    vec2 texc=((pos.xy*223.+pos.z)*res+.5)/res;\n    return textureLod(iChannel0,texc,0.);\n}\n\nfloat distSphere(vec3 pos, float r)\n{\n\treturn length(pos)-r;\n}\n\nfloat calcAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1,v2)/length(v1)/length(v2));\n}\n\n#define mixSq(a,b,f) mix(a,b,.5-cos(f*PI)*.5)\n\n// distance to 2 torus segments in a triangle\n// each torus segment spans from the middle of one side to the middle of another side\nfloat distTruchet(vec3 pos, vec3 p1, vec3 p2, vec3 p3, float dz, out vec2 uv)\n{\n    float d = 10000.0;\n    float rnd =getRand01Sph(p1+p2+p3).x;\n    float rnd2=getRand01Sph(p1+p2+p3).y;\n    // random rotation of torus-start-edges\n    /*if      (rnd>.75) { vec3 d=p1; p1=p2; p2=d; }\n    else if (rnd>.50) { vec3 d=p1; p1=p3; p3=d; }\n    else if (rnd>.25) { vec3 d=p2; p2=p3; p3=d; }*/\n\n    if(dot(cross(p2-p1,p3-p1),p1)>0.) { vec3 dummy=p2; p2=p3; p3=dummy; }\n    \n    vec3 p4 = p1*(1.-dz);\n    vec3 p5 = p2*(1.-dz);\n    vec3 p6 = p3*(1.-dz);\n    \n    float r,r1,r2,fact,ang,fullAng;\n    vec3 n = normalize(cross(p2-p1,p3-p1));\n    // point to normal distance on triangle\n    vec3 pos2 = pos-dot(pos-p1,n)*n;\n    \n    // torus segments:\n    // actually i have to fade from one torus into another\n    // because not all triangles are equilateral\n    float angRad=0., factTan=0.;\n    vec3 v1,v2,v3,v4,v5,v6;\n    for(int i=0; i<3 ;i++)\n    {\n        if(i==0) { v1=p1; v2=p2; v3=p3; v4=p4; v5=p5; v6=p6; }\n        if(i==1) { v1=p2; v2=p3; v3=p1; v4=p5; v5=p6; v6=p4; }\n        if(i==2) { v1=p3; v2=p1; v3=p2; v4=p6; v5=p4; v6=p5; }\n        float rndv1=getRand01Sph(v1).x;\n        float rndv2=getRand01Sph(v2).x;\n        float rndv3=getRand01Sph(v3).x;\n        \n        // v1 is always the center axis of the torus\n        // some circles randomly cw/ccw\n        if(rndv1>0.5)\n        {\n            vec3 dummy;\n            dummy=v2; v2=v3; v3=dummy;\n            dummy=v5; v5=v6; v6=dummy;\n        }\n\n        // logic xor ^^ wont work on all platforms so using (integer sum)&1\n        // start of arc\n        float up1=mod(float(1\n         + ((rndv1>0.5)?1:0)  // put cw up and ccw down\n         + ((rndv1>0.5 && rndv3>0.5 && rndv1>rndv3)?1:0) // from cw take the one down that has the smaller randvalue in its center (unique)\n         + ((rndv1<0.5 && rndv2<0.5 && rndv1>rndv2)?1:0) // from ccw take the one up that has the smaller randvalue in its center (unique)\n         + ((rndv1<0.5 && rndv2>0.5)?1:0)                // xchg the ones who meet from different rot dirs (one cw other ccw)\n         + ((rndv1>0.5 && rndv3<0.5)?1:0)                // xchg the ones who meet from different rot dirs (one cw other ccw)\n         ),2.);\n        \n        // end of arc\n        float up2=mod(float(1\n         + ((rndv1>0.5)?1:0)  // put cw up and ccw down\n         + ((rndv1>0.5 && rndv2>0.5 && rndv1>rndv2)?1:0) // from cw take the one down that has the smaller randvalue in its center (unique)\n         + ((rndv1<0.5 && rndv3<0.5 && rndv1>rndv3)?1:0) // from ccw take the one up that has the smaller randvalue in its center (unique)\n         ),2.);\n        \n        \n        vec3 n = normalize(cross(v2-v1,v3-v1));\n        vec3 pos2 = pos-dot(pos-v1,n)*n;\n    \tang = calcAngle(cross(pos,v1),cross(v2,v1));\n    \tfullAng = calcAngle(cross(v3,v1),cross(v2,v1));\n    \tfact = ang/fullAng;\n        float factUD = mix(up1,up2,fact);\n        /*if(rnd2>.25) {\n            if(i==0) factUD=1.;\n            if(i==1) factUD=0.;\n        }*/\n    \tr1 = .5*mix(length(v2-v1),length(v5-v4),up1);\n    \tr2 = .5*mix(length(v3-v1),length(v6-v4),up2);\n    \tvec3 posS=mix(.5*(v2+v1),.5*(v5+v4),up1);\n    \tvec3 posE=mix(.5*(v3+v1),.5*(v6+v4),up2);\n    \tvec3 posSPrj=dot(posS,normalize(v1))*normalize(v1);\n    \tvec3 posEPrj=dot(posE,normalize(v1))*normalize(v1);\n        /*if(rndv1>0.5)\n        {\n            vec3 dummy;\n            dummy=posS;    posS=posE;       posE=dummy;\n            dummy=posSPrj; posSPrj=posEPrj; posEPrj=dummy;\n        }*/\n    \t//r1 = length(posS-posSPrj);\n    \t//r2 = length(posE-posEPrj);\n    \tr=mix(r1,r2,fact);\n    \t//r=r1;\n        float ang2;\n        float dold=d;\n\t\t//d=min(d,distTorus(pos-mixSq(v1,v4,factUD)*sqrt(1.-r*r),r,.11*r,v1,ang2));\n\t\t// the factor factUD/3.2 is kind of phenomenological (tuned it by hand -\n\t\t// ...didnt quite find the time to make a theoretical aproach)\n\t\td=min(d,distTorus((pos-mixSq(v1,v4,factUD)*sqrt(1.-r*r))*(1.-dz*factUD/3.2),r,.11*r,v1,ang2));\n\t\t//d=min(d,distTorus(pos-mixSq(posSPrj,posEPrj,fact),r1,.11*r1,v1,ang2));\n\t\tif(rndv1>0.) ang2=2.*PI-ang2;\n\t\t// rotate radial angle to point outwards (radial to the whole structure) so that uv's match between segments\n\t\t// ...again the angle (=58.) was determined by hand - a theoretical approach would be nice, \n\t\t// because this way it only works only for the icosahedron, not for higher subdivisions\n\t\tang2=mod(ang2+58.*PI/180.+10.*PI,2.*PI);\n\t\t// we mirror the radial uv (might be a bit more complicated to get a full circle uv here)\n\t\tif(ang2>PI) ang2=2.*PI-ang2;\n\t\tangRad =(d!=dold)?ang2:angRad;\n\t\tfactTan=(d!=dold)?fact:factTan;\n        //d-=(tri01(ang*50.*.25)+tri01(ang2*12.*.25))*.004*r;\n    }\n    uv=vec2(factTan,fract(angRad/PI));\n    // snake skin pattern\n    #ifdef SNAKE_SKIN\n    #ifndef UV_ONLY\n    d-=(abs(sin((factTan*20.+.3*20.*iTime)*2.*PI)+cos(angRad*12.)))*.0015*r;\n    #endif\n    #endif\n    return d;\n}\n\n// final distance funtion\nvec4 distUV(vec3 pos)\n{\n    //pos+=.00015*getRand(pos*1.3).xyz*4.;\n    //pos+=.00006*getRand(pos*3.).xyz*4.;\n    //pos+=.00040*getRand(pos*.5).xyz*4.;\n    vec3 p1,p2,p3;\n    float d = 10000.;\n    \n    // sphere in the middle\n\t//d=min(d,distSphere(pos,.79));\n    \n    // start with an icosahedron subdivided once\n    getIcosaTri(pos, p1, p2, p3);\n    //getTriSubDiv(pos, p1, p2, p3);\n    // always sort by X, then Y, then Z - to get a unique order of the edges\n    sortXYZ(p1,p2,p3);\n    vec2 uv;\n    d=min(d,distTruchet(pos, p1,p2,p3,.2,uv));\n    \n    return vec4(d,uv,0);\n}\n\nfloat dist(vec3 pos)\n{\n    return distUV(pos).x;\n}\n\n\nvec3 getGrad(vec3 pos, float eps)\n{\n    vec2 d=vec2(eps,0);\n    float d0=dist(pos);\n    return vec3(dist(pos+d.xyy)-d0,\n                dist(pos+d.yxy)-d0,\n                dist(pos+d.yyx)-d0)/eps;\n                \n}\n\n// march it...\nvec4 march(inout vec3 pos, vec3 dir, out vec2 uv)\n{\n    // cull the sphere\n    if(length(pos-dir*dot(dir,pos))>1.07) \n    \treturn vec4(0,0,0,1);\n    \n    float eps=0.001;\n    float bg=1.0;\n    for(int cnt=0;cnt<52;cnt++)\n    {\n        float d = dist(pos);\n        pos+=d*dir*.8;\n        if(d<eps) { bg=0.0; break; }\n    }\n    vec3 n = normalize(getGrad(pos,.001));\n    uv=distUV(pos).yz;\n    return vec4(n,bg); // .w=1 => background\n}\n\nmat3 rotX(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(1,0,0, 0,c,s, 0,-s,c);\n}\n\nmat3 rotZ(float ang)\n{\n    float c=cos(ang), s=sin(ang);\n    return mat3(c,s,0, -s,c,0, 0,0,1);\n}\n\nfloat saw(float x) { float s=step(.5,fract(x*.5)); return fract(x)*s+s; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen coord -1..1\n    vec2 sc = (fragCoord.xy/iResolution.xy)*2.-1.;\n    // viewer position\n    vec3 pos = vec3(0,-3.5,0);\n    // pixel view direction\n    vec3 dir = normalize(2.*normalize(-pos)+vec3(sc.x,0,sc.y*iResolution.y/iResolution.x));\n    // rotate view around x,z\n    float phi = iMouse.x/iResolution.x*7.;\n    float th  = iMouse.y/iResolution.y*7.;\n    if (iMouse.x==0.) { phi=iTime*.5*.5; th=.27*.5*iTime*.5; }\n    mat3 rx = rotX(th);\n    mat3 rz = rotZ(phi);\n    pos = rz*(rx*pos);\n    dir = rz*(rx*dir);\n    \n    // march it...\n    vec2 uv;\n   \tvec4 n=march(pos,dir,uv);\n    float bg=n.w;\n        \n    // calc some ambient occlusion\n    float ao=1.;\n    #if 0\n    // calc simple ao by stepping along radius\n    ao*=dist(pos*1.02)/.02;\n    ao*=dist(pos*1.05)/.05;\n    ao*=dist(pos*1.1)/.1;\n    #else\n    // calc ao by stepping along normal\n    ao*=dist(pos+n.xyz*.02)/.02;\n    ao*=dist(pos+n.xyz*.05)/.05;\n    ao*=dist(pos+n.xyz*.10)/.10;\n    #endif\n    // adjust contrast of ao\n    ao=pow(ao,.4);\n    \n    // reflection dir\n    vec3 R = pos-2.0*dot(pos,n.xyz)*n.xyz;\n    R = -((R*rz)*rx).yzx;\n    \n    vec3 c = vec3(.1);\n    float pat=.5+1.2*sin((uv.x+iTime*.3)*2.*PI*3.);\n    pat+=.4*cos((uv.y)*2.*PI);\n    pat=smoothstep(.0,1.,pat);\n    #ifndef SHADEROO\n    vec2 tRes = iChannelResolution[3].xy;\n    #else\n    vec2 tRes = vec2(textureSize(iChannel3,0));\n    #endif\n    //float texPat=texture(iChannel3,fract(uv.xy+vec2(iTime*.3,0))*vec2(64,14)/tRes.xy).x;\n    //texPat=(texPat-.3);\n    //texPat=exp(-texPat*texPat*40.);\n    //pat=pat+2.*(.5-pat)*texPat;\n    //pat=mix(pat,pat+2.*(.5-pat)*texPat,clamp(.5-cos(.2*iTime),0.,1.));\n    \n    c=mix(vec3(0,0,.4),vec3(1,1,0),clamp(pat,0.,1.));\n    // simply add some parts of the normal to the color\n    // gives impression of 3 lights from different dir with different color temperature\n    c *= clamp(dot(n.xyz,normalize(-dir)+vec3(0)),0.,1.)*.5+.3 + n.xyz*.1;\n    //  reflection of cubemap\n    float fres=clamp(dot(n.xyz,normalize(R)),0.,1.);\n    fres=1.-fres;\n    fres*=fres*fres*fres;\n    #ifndef SHADEROO\n    c += fres*texture(iChannel2,R).xyz*.5;\n    #else\n    c += fres*mix(vec3(0),vec3(1),max(normalize(R).y,0.))*.5;\n    #endif\n    \n    \n    // add some depth darkening\n\tc*=clamp(-dot(dir,pos)*.1+.9, .2, 1.);\n    \n    // apply ambient occalusion\n    c*=ao;\n    \n    // apply background (medusa poison green)\n    float aspect=iResolution.y/iResolution.x;\n    phi=atan(sc.y*aspect,sc.x);\n    float r = length(vec2(sc.y*aspect,sc.x));\n    \n    vec2 tc=fragCoord/iResolution.xy*vec2(1,5)+vec2(iTime*.3,0);\n    tc.x=mod(tc.x,2.);\n    float bgPat=clamp((sin((phi+.5*r-.2*iTime)*17.+.7*sin(14.*log(r)-3.*iTime))+.5)*r,0.,1.);\n\n    if(bg>=.5) c=clamp((.3+r),0.,1.)*mix(vec3(0,0,.3),vec3(.7,.7,0),bgPat);\n    //if(bg>=.5) c=vec3(1,.7,0.);\n\n    #ifdef UV_ONLY\n    c.xy=uv.xy;\n    #endif\n\n    // vignetting\n    float vign = (1.-.5*dot(sc.xy,sc.xy));\n    \n\tfragColor = vec4(c*1.5*vign,1);\n    //fragColor = texture(iChannel3,fragCoord/iResolution.xy);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}