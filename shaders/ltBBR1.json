{
    "Shader": {
        "info": {
            "date": "1514543505",
            "description": "My First Scene",
            "flags": 0,
            "hasliked": 0,
            "id": "ltBBR1",
            "likes": 0,
            "name": "My First Scene",
            "published": 3,
            "tags": [
                "scene"
            ],
            "usePreview": 0,
            "username": "lzjseed",
            "viewed": 512
        },
        "renderpass": [
            {
                "code": "#define RAYMARCH_STEP_NUM 64\n\nfloat hash( vec2 p ) \n{\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) \n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nvec2 opU2(vec2 d1,vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(p.xz * m,p.y);\n}\n\nmat3 fromEuler(vec3 ang) \n{\n    vec2 a1 = vec2(sin(ang.z),cos(ang.z));\n    vec2 a2 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a3 = vec2(sin(ang.y),cos(ang.y));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return m;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) -s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p,float fh)\n{\n    float d = p.y - fh;\n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    float t = iTime;\n    vec3 v0 = vec3(0,2,0);\n    vec3  g = vec3(0,-0.98,0);\n    vec3  s = v0 * t + 0.5 * g * t * t;\n    float a = t;\n\n    if(t > 2.0 * length(v0) / length(g))\n    {\n        s = vec3(0,0,0);\n        a = max(1.0 - 0.5*t,0.0);\n    }\n\n    vec2 r1 = vec2(sdSphere(p + vec3( 0.0,-0.25, 0.0), 0.25),1);\n    vec2 r4 = vec2(sdBox( (p + vec3( 0.2,-0.25, -2.0) * fromEuler(vec3(0,0.5,0))), vec3( 0.2,0.2, 0.2)),2.0);\n    vec2 r5 = vec2(sdTorus((p + vec3( 0.2,-0.4, -2.0) + s)*fromEuler(vec3(0,0,a)), vec2( 0.2,0.1)),0.0);\n\n    r1 = opU2(r1,r5);\n\n    vec2 r2 = vec2(sdBox(p + vec3( -1.0,-0.2,-0.5), vec3( 0.2,0.2, 0.2)),3);\n    vec2 r3 = vec2(sdBox(p + vec3( 0,-0.5,0), vec3( 3.0,0, 3.0)),4);\n\n    return opU2(opU2(r1,r2),r3);\n}\n\n\nvec2 map_alpha(vec3 p)\n{\n    vec2 r1 = vec2(sdSphere(p + vec3( -0.4,-0.05, -1.8), 0.35),10);\n\n    return r1;\n}\n\nmat3 setCamera(vec3 ro,vec3 ta)\n{\n    vec3 rz = normalize(ta - ro);\n    vec3 p = vec3(0.0, 1.0, 0.0);\n    vec3 rx = normalize(cross(rz,p));\n    vec3 ry = normalize(cross(rz,rx));\n\n    return mat3(-rx,ry,rz);\n}\n\nvec2 raymarching(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    float m = -1.0;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = 0.0005*t;\n        vec2 res = map( ro + rd*t );\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    return vec2(t,m);\n}\n\nvec2 raymarching_alpha(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float t = tmin;\n    float m = -1.0;\n\n    for( int i = 0; i < RAYMARCH_STEP_NUM; i++ )\n    {\n        float precis = 0.0005*t;\n        vec2 res = map_alpha( ro + rd*t );\n        if( res.x < precis || t > tmax ) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m = -1.0;\n\n    return vec2(t,m);\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n                      e.yyx*map( pos + e.yyx ).x + \n                      e.yxy*map( pos + e.yxy ).x + \n                      e.xxx*map( pos + e.xxx ).x );\n    /*\n    vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n    */\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat softshadow_alpha( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map_alpha( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    vec2 target = raymarching(ro,rd);\n    float t = target.x;\n    float m = target.y;\n\n    vec2 target2 = raymarching_alpha(ro,rd);\n    float t2 = target2.x;\n    float m2 = target2.y;\n\n    vec4 baseColor2 = vec4(1,1,1,0);\n    if(t2 <= 20.0 && m2 > -1.0 && t2 < t)\n    {\n        if(m2 == 10.0)\n            baseColor2 = vec4(1,0,0,0.75);\n\n        vec3 p = ro + rd * t2;\n        vec3 nor = calcNormal(p);\n\n        vec3 diffColor = vec3(1,1,1);\n        vec3 specColor = vec3(1,1,1);\n\n        vec3 ref = reflect( rd, nor );\n\n        vec3 lig = normalize(vec3(mo.x,-0.5,mo.y));\n\n        float diff = baseColor2.a;//max(0,dot(lig,nor));\n        diff *= min(softshadow_alpha(p, lig, 0.02, 2.5) + 0.5,1.0);\n        //diff *= softshadow(p, lig, 0.02, 2.5);\n        baseColor2.rgb = baseColor2.rgb * diffColor * diff;\n    }\n\n    if(t <= 20.0 && m > -1.0)\n    {\n        vec3 baseColor = vec3(1,1,1);\n\n        if(m == 0.0)\n            baseColor = vec3(1,0,0);\n        if(m == 1.0)\n            baseColor = vec3(1,1,0);\n        if(m == 2.0)\n            baseColor = vec3(1,0,1);\n        if(m == 3.0)\n            baseColor = vec3(0,1,0);\n        if(m == 4.0)    \n            baseColor = vec3(0,0,1);\n\n        vec3 p = ro + rd * t;\n        vec3 nor = calcNormal(p);\n\n        vec3 diffColor = vec3(1,1,1);\n        vec3 specColor = vec3(1,1,1);\n\n        vec3 ref = reflect( rd, nor );\n\n        vec3 lig = normalize(vec3(mo.x,-0.5,mo.y));\n\n        float diff = max(0.0,dot(lig,nor));\n        float spec = pow(clamp(dot(ref,lig),0.0,1.0),16.0);\n\n        diff *= min(softshadow_alpha(p, lig, 0.02, 2.5) + 0.2,1.0);\n        diff *= softshadow(p, lig, 0.02, 2.5);\n\n        vec3 color = baseColor * diffColor * diff + spec * specColor;\n\n        color = mix(color,baseColor2.rgb,baseColor2.a);\n\n        return color;\n    }\n    \n    return mix(vec3(1,1,1),baseColor2.rgb,baseColor2.a);\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;    \n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    mo = mo * 2.0 - 1.0;\n\n    //mo.x = iGlobalTime;\n\n    // camera\n    float w = 0.8;\n    float cameraLen = 1.0;\n    //vec3 ro = vec3(0,0,0);\n    //vec3 ta = vec3(0.0,0.0,1.0);\n\n    //vec3 ro = vec3( cameraLen * sin(mo.x * w), mo.y , 4 + cameraLen * cos(mo.x * w));\n    vec3 ro = vec3( 0, 0 , 4 );\n    \n    vec3 ta = vec3( 0, 0, 0 );\n\n    mat3 ca = setCamera(ro,ta);\n    //mat3 ca = setCamera(vec3(1,0,0),vec3(0,0,0));\n\n    // ray direction\n    vec3 rd = (ca*normalize( vec3(p.xy,2.0) ));\n\n    // rendering\n\n    vec3 col = render( ro, rd );   \n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}