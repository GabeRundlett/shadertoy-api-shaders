{
    "Shader": {
        "info": {
            "date": "1617557705",
            "description": "no label since it was implemented as an svg image",
            "flags": 32,
            "hasliked": 0,
            "id": "sdjGzR",
            "likes": 35,
            "name": "Nutrition Facts",
            "published": 3,
            "tags": [
                "liquid",
                "soda"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 1296
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfragColor /= fragColor.w; //\"film grain\"\n\tfragColor *= 1.0 - dot(uv,uv)*0.5; //vingetting lol\n\tfragColor = smoothstep(0.09,0.99,sqrt(fragColor))+.02; //colour grading\n\tfragColor += hash(uv.x,uv.y)*.015;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//label\n//from https://www.shadertoy.com/view/4sKyRK\nfloat distanceToBottleCurve(vec2 point) {\n    return point.y-0.1*sin(point.x*2.5 + 0.6) + 0.05*sin(5.0*point.x) + 0.04*sin(7.5*point.x);\n}\nbool texturee(vec2 uv) {\n    float ang = atan(uv.y, uv.x);\n    float len = floor(length(uv)*10.0);\n    bool val = len == 2. || len == 6. || len == 9.;\n    if (len == 3. || len == 4. || len == 5. || len == 8. || len == 10.) {\n        val = distanceToBottleCurve(vec2(ang+len,0.0))*7.99 > cos(len*7.99);\n    }\n    return val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.xy;\n\n    //I would make a better revision logo but I am too tired :(\n    fragColor = vec4(232./255., 40./255., 40./255.,1);\n    float rad1 = abs(floor(atan(uv.x,uv.y)/2.)*.04);\n    if (texturee(uv*3.5)) {\n        fragColor = vec4(1);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b) - h*h*h*k/6.;\n}\n\nfloat ss(vec2 p) {\n  return sqrt(length(p*p));\n}\n\nfloat ss(vec3 p) {\n  return sqrt(length(p*p));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return length(p-mix(a,b,clamp(k,0.,1.)));\n}\n\nvec2 kink(vec2 p, vec2 c, float k) {\n    p -= c;\n    float ang = atan(p.x, p.y);\n    float len = length(p);\n    ang -= ang/sqrt(1.+ang*ang)*(1.-k);\n    return vec2(sin(ang),cos(ang))*len + c;\n}\n\nfloat cn(vec2 p) {\n  return ss(max(p,0.)) + min(0.,max(p.x,p.y));\n}\n\n//welcome to the 4 dimensional corner function how may I take your order?\nfloat cn(vec4 p) {\n    return length(max(p,0.))+min(0.,max(max(p.x,p.y),max(p.z,p.w)));\n}\n\nfloat cylinder(vec3 p, vec2 d) {\n  return cn(vec2(length(p.xy), abs(p.z)) - d);\n}\n\nfloat chamfer(vec2 p, float st, float r, float f) {\n  return smin(-cn(-p), dot(p,normalize(vec2(st,1)))-r, r*f);\n}\n\nfloat cantab(vec3 p){\n    vec2 off=vec2(0,cos(p.r)/4.);\n    p=erot(p,vec3(1,0,0),-.1)-vec3(0,0,.4);\n    if(abs(p.r)<3.4&&p.g<0.&&p.g>-7.)p.b+=smoothstep(0.,5.,p.g+7.)*.5;\n    float connector=cn(vec2(p.b+.1+.2,cn(abs(p.rg-vec2(0,-6))-vec2(3,4)+.2+2.)-2.))-.2;\n    float tabprofile=linedist(p.rg+off,vec2(0,4.25),vec2(0,-4.25))-6.55;\n    float tab=cn(vec2(tabprofile,abs(p.b)))-.5;\n    float indent=-chamfer(vec2(tabprofile+4.,.5-p.b),.6,1.5,.5);\n    float bridge=cn(vec2(p.b+.1+.8,linedist(p.rg,vec2(-10.,2.),vec2(10.,2.))-.05))-.8;\n    indent=smin(min(bridge,connector),indent,1.3);\n    return-smin(-indent,-tab,.5);\n}\n\nfloat stex(vec3 p) {\n\treturn sin(dot(sin(p*32.),vec3(2,9,1)))*cos(dot(cos(p*43.),vec3(6,1,5)))+sin(dot(sin(p*52.),vec3(2,3,9)))*cos(dot(cos(p*73.),vec3(9,1,2)));\n}\n\nvec3 gcancoords;\nfloat thecan(vec3 p){\n    gcancoords = p;\n    if (length(p)> 1.1) return length(p)-1.; //proxy\n    p.z += stex(p*vec3(6,.2,.1))*.0001*smoothstep(.78,.8,p.z);\n    p*=80.;\n    \n    float outer1=cylinder(p,vec2(24.345,58.925))-2.;\n    float outer2=cylinder(p-vec3(0,0,3.105),vec2(23.2,64.83))-2.;\n    float rim=cylinder(p-vec3(0,0,69.63),vec2(23.88,-.75))-2.;\n    float subinner=cylinder(p-vec3(0,0,69.63),vec2(22.25,3.))-2.;\n    float addinner=cylinder(p-vec3(0,0,64.63),vec2(20.56,.5))-2.;\n    float knob=cylinder(p-vec3(0,0,67.23),vec2(1.65,.55))-.25;\n    vec3 p2=vec3(sqrt(p.r*p.r+4.),p.gb);\n    // float bumps=length(p2-vec3(4.,10.,66.13))-1.1;\n    float hole=cn(vec2(-smin(-length(p.rg-vec2(0,-9))+8.,-length(p.rg-vec2(0,-15))+11.5,3.),-p.z));\n    p2.g+=20.5;\n    p2.gr=kink(p2.gr,vec2(10,0),.1);\n    float ridge=length(vec2(p.b-66.73,linedist(p2.rg,vec2(2,-2),vec2(12,14))))-.5;\n    float fuckery=ss(p-vec3(5,-6.5,66.73))-2.;\n    float inside=cylinder(p-vec3(0,0,14.63),vec2(20.56,52.));\n    // float tab=10000.;\n    // p-=vec3(5,-4.,66.23);\n    // p=erot(p,normalize(vec3(1.5,-.5,.4)),-1.);\n    // p+=vec3(5.,-4.5,66.73);\n    float main=chamfer(vec2(outer1,outer2),.4,1.4,.9);\n    main=smin(-smin(-min(main,rim),subinner,1.),addinner,2.);\n    main=-smin(hole,-min(main,knob),.5);\n    main=-smin(-smin(main,ridge,1.),fuckery,3.);\n    main=max(main,-inside);\n    \n    if(p.b>60.)\n    \tmain=min(main,cantab(erot(gcancoords*80.,vec3(0,0,1),.2)-vec3(0.,5.5,68.13)));\n    return main/80.;\n}\n\nfloat gated_sphere(vec3 p, float scale, bool gate) {\n    if (!gate) {\n        p = abs(p);\n        if(p.x < p.y) p.xy = p.yx;\n        if(p.y < p.z) p.yz = p.zy;\n        if(p.x < p.y) p.xy = p.yx;\n        p.x -= scale;\n    }\n    return length(p)-scale/4.;\n}\n\nfloat hash(float a, float b) {\n\tint x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n\tint y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n\treturn float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\n//help... me... the SDF functions... are taking over... AAUAHGGUGHG\nfloat bubbleify(vec3 p, float sdf) {\n    float bubbles = 1e9;\n    float scale = .06;\n    for (int i = 0; i < 3; i++) { //loops in an sdf function.. please forgive me!!!\n        p = erot(p, normalize(vec3(i,2,4)), .7)+.2;\n        scale *= .8;\n\n        //ripe for minify\n        vec3 id = round(p/scale)*scale;\n        //not using hash here bc it's too different on other platforms\n        bool gated = stex(id) > .65;\n        float holes = gated_sphere(p-id, scale, gated);\n        bubbles = min(bubbles, holes);\n        \n    }\n    \n    return max(smin(-bubbles, -sdf-.002, .005), sdf);\n}\n\nfloat fractal(vec2 p, float k) {\n    vec2 cut = normalize(vec2(k,1.));\n    float scale = 1.;\n    for (int i = 0; i < 4; i++) {\n        p.x = sqrt(p.x*p.x+.05)-sqrt(.05);\n        p.y = sqrt(p.y*p.y+.05)-sqrt(.05);\n        p.x -= 1.;\n        p += smin(0.,-dot(p,cut),.5)*2.*cut;\n        p *= 2.;\n        scale *= 2.;\n    }\n    return linedist(p,vec2(1,0), vec2(-2,0))/scale;   \n}\n\nfloat splat;\nfloat scene(vec3 p) {\n    float can = 10000.;\n    if (p.y < 0.) can = thecan(erot(p-vec3(-0.2,-1.90,-1.25), vec3(0.49, 0.34, 0.8), 1.79));\n\n    p.x += cos(p.z*4.)/25.*cos(p.y*5.);\n    //p.y += 1.;\n    float fr1 = fractal(p.yz, 1.8);\n    vec3 p2 = erot(p,normalize(vec3(1)),.4);\n    float fr2 = fractal(p2.yz, 2.4);\n    //this is like, a 4 dimensional.. intersection(?) of two versions of a KIFS fractal\n    splat = cn(vec4(fr1-.045, fr2-.045, abs(p.x), p2.x)/sqrt(2.))-.008+ cos(fr1*100.)*.001+ cos(fr2*200.)*.001;\n    if (splat < 0.) splat = bubbleify(p, splat);\n    //return can;\n    //return splat;\n    return min(splat, can);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.0001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 pixel_color( vec2 uv, float hs )\n{\n    vec3 cam = normalize(vec3(1.9,uv));\n    vec3 init = vec3(-4,-.6,-.6);\n    \n    float zrot = 4.;\n    // float yrot = .0;\n    cam = erot(cam, vec3(1,0,0), -.6);\n    //cam = erot(cam, vec3(0,1,0), yrot);\n    //init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool bounce = false;\n    float k = 1.;\n    float cola = 0.;\n    bool recalcK = false;\n    bool escape = false;\n    bool label = false;\n    vec3 cancoords;\n    vec3 n;\n    for (int i = 0; i < 150; i++) {\n        float dist = scene(p);\n        if (recalcK) { k = dist < 0. ? -1. : 1.; recalcK = false; }\n        p += cam*dist*k;\n        if (dist < 0.) cola += abs(dist);\n        if (dist*dist < 1e-9) {\n            cancoords = gcancoords; //this is a nightmare of my own creation\n            bool iscola = dist == splat;\n            if (iscola) escape=true;\n            hs = hash(hs, 9.3);\n            n = norm(p)*k;\n            float fres = abs(dot(n,cam))*.98;\n            if (hs*.5+.5 > fres || !iscola) {\n                cam = reflect(cam,n);\n                if (length(cam)==0.)cam=n;\n                if (!iscola) {\n                    if (abs(cancoords.z) < .72 && length(cancoords.xy) > .31) {\n                        label = true;\n                    }\n                }\n                cam = normalize(cam);\n                bounce = true;\n                // p += n*.0005;\n            } else {\n                cam = refract(cam,n, k < 0. ? 1.33 : 1./1.33);\n            }\n            p += n*.0005*sign(dot(cam,n));\n            recalcK = true;\n            //break;\n        }\n        if (length(p-init) > 10.) { escape=true; break; }\n    }\n    \n    \n    float fact = length(sin(cam*3.9)*.5+.5);\n    vec3 environ = vec3(smoothstep(1.,2.5,fact)+smoothstep(1.45,1.6,fact)*8.) + fact/8.;\n    //environ = 1.;\n    //environ += cola*1000.;\n    environ *= mix(vec3(1), vec3(1.,0.5,0.4), smoothstep(0.,.4,cola+.1));\n    vec3 col = (bounce&&escape) ? environ : vec3(0.0);\n    col += cola*vec3(1.,0.5,0.4)*2.;\n    if (label) {\n        //diffuse material takes too long to converge, so it's time 2 cheat :3\n        vec2 texcoords = vec2(atan(cancoords.y,cancoords.x)/3.1415-.15, cancoords.z*.7+.5);\n        float diff = length(sin(n*3.)*.5+.5)/sqrt(3.);\n        vec4 tone = pow(length(texcoords-vec2(.5, .65)) < .25 ? vec4(1) : vec4(232./255., 40./255., 40./255.,1),vec4(2.));\n        tone = texture(iChannel1, texcoords);\n        col += diff*tone.xyz*.8;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n\tfloat sd = float(iFrame);\n\tsd = hash(sd, 2.6);\n\tvec2 h2 = tan(vec2(hash(sd, 6.7), hash(sd, 3.6)));\n\tvec2 uv2 = uv + h2/iResolution.y;\n\tfragColor += vec4(pixel_color(uv2, sd), 1);\n\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}