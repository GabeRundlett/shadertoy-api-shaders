{
    "Shader": {
        "info": {
            "date": "1560002081",
            "description": "Entry for the June 2019 ShaderToy compo from Graphics Programming Discord. ",
            "flags": 0,
            "hasliked": 0,
            "id": "Wt2GRG",
            "likes": 17,
            "name": "Cubic Dance",
            "published": 3,
            "tags": [
                "cubes",
                "repetition",
                "rainbow"
            ],
            "usePreview": 0,
            "username": "MadEqua",
            "viewed": 2335
        },
        "renderpass": [
            {
                "code": "#define PRIMARY_STEPS 32\n#define SECONDARY_STEPS 16\n\n#define RM_EPSILON 0.01\n#define BIAS_EPSILON 0.02\n\n#define MAX_DIST 30.\n\n#define REFLECTIONS 1\n#define SHADOWS 1\n\nstruct Light {\n    vec3 dir;\n    vec3 diffColor;\n    vec3 specColor;\n};\n\nstruct ScenePoint {\n    vec3 p;\n    vec3 color; //Color of material\n    float d; //Distance to closest object\n    float t; //Distance on ray that generated this point\n};\n\nLight lights[4];\n\nfloat rand(float v) {\n    return fract(sin(v) * 5454.7367);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 4451.5453);\n}\n\nvec3 cam2world(vec3 v, vec3 pos, vec3 lookAt) {\n    vec3 z = normalize(lookAt - pos);\n    vec3 y = vec3(0., 1., 0.);\n    vec3 x = normalize(cross(z, y));\n    y = normalize(cross(x, z));\n    return normalize(mat3(x, y, z) * v);\n}\n\nvec2 repeat(inout vec2 p, vec2 size) {\n\tvec2 h = size * .5;\n\tvec2 cell = floor((p + h) / size);\n\tp = mod(p + h, size) - h;\n\treturn cell;\n}\n\nfloat roundBox(vec3 p, vec3 c, vec3 b, float r) {\n    vec3 d = abs(p - c) - b;\n    return length(max(d, 0.)) - r + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nfloat stoppingCurve(float t, float stopFactor) {\n  return mix(rand(floor(t)), rand(floor(t) + 1.), pow(smoothstep(0., 1., fract(t)), stopFactor));\n}\n\nScenePoint scene(vec3 p, int neighboursToCheck) {\n    ScenePoint result;\n\n    float dist = MAX_DIST;\n    vec2 cellId;\n    vec3 repP;\n\n    for(int x = -neighboursToCheck; x <= neighboursToCheck; ++x) {\n        for(int y = -neighboursToCheck; y <= neighboursToCheck; ++y) {\n            vec3 currentRepP = p;\n            vec2 currentCellId = repeat(currentRepP.xy, vec2(1.));\n\n            vec2 offset = vec2(float(x), float(y));\n            currentCellId += offset;\n\n            currentRepP.xy -= offset; // * cellSize = 1.0\n\n            float timeOffset1 = mod(currentCellId.x * currentCellId.y, 2.0);\n            float timeOffset2 = mod(currentCellId.x + currentCellId.y, 2.0);\n            float timeOffset3 = mod(currentCellId.x, 2.0);\n            float timeOffset4 = mod(currentCellId.y, 2.0);\n            float timeOffsetFinal = mix(mix(timeOffset1, timeOffset2, sin(iTime * .4 + 56.2) * .5 + .5),\n                                        mix(timeOffset3, timeOffset4, sin(iTime * .5 + 12.5) * .5 + .5),\n                                        sin(iTime * .6 + 23.4) * .5 + .5);\n\n            currentRepP.z += stoppingCurve(1.7 * iTime + timeOffsetFinal, 5.) * 2.5;\n\n            const float minSize = .31;\n            const float maxSize = .43;\n            float sizeAnim = stoppingCurve(0.9 * iTime + timeOffsetFinal, 5.) * (maxSize - minSize) + minSize;\n            float currentCubeDist = roundBox(currentRepP, vec3(0.), vec3(sizeAnim), .07);\n            if(currentCubeDist < dist) {\n                dist = currentCubeDist;\n                cellId = currentCellId;\n                repP = currentRepP;\n            }\n        }\n    }\n\n    float wallX = (-cellId.x + 6.) / 13.;\n    float cubeDiagonal = (repP.x + .5) * (repP.y + .5);\n\n    vec3 cubeBaseHsv = vec3(wallX, 1., 1.);\n    cubeBaseHsv.r += .1 * rand(cellId.y);\n\n    vec3 cubeColor1 = hsv2rgb(cubeBaseHsv);\n    vec3 cubeColor2 = hsv2rgb(vec3(cubeBaseHsv.r + .2 * rand(cellId.x), cubeBaseHsv.g, cubeBaseHsv.b));\n\n    result.color = mix(cubeColor1, cubeColor2, cubeDiagonal);\n    result.d = dist;\n    return result;\n}\n\nbool rm(vec3 ro, vec3 rd, out ScenePoint sp, int steps, int neighboursToCheck) {\n    float t = 0.;\n    vec3 p;\n\n    for(int i = 0; i < steps && t < MAX_DIST; ++i) {\n        p = ro + rd * t;\n        sp = scene(p, neighboursToCheck);\n        if(sp.d < RM_EPSILON) {\n            sp.p = p;\n            sp.t = t;\n            return true;\n        }\n        t += sp.d;\n    }\n    return false;\n}\n\nvec3 normal(ScenePoint sp) {\n    vec2 e = vec2(RM_EPSILON, 0.);\n    float x = scene(sp.p - e.xyy, 1).d;\n    float y = scene(sp.p - e.yxy, 1).d;\n    float z = scene(sp.p - e.yyx, 1).d;\n    return normalize(vec3(sp.d) - vec3(x, y, z));\n}\n\nfloat cheapAo(vec3 p, vec3 n, float dist) {\n    float d = scene(p + n * dist, 1).d / dist;\n    return clamp(d, 0., 1.);\n}\n\n/*float ao(vec3 p, vec3 n, float strength) {\n    const int AO_SAMPLES = 2;\n    float k = 1.;\n    float d = 0.;\n    float occ = 0.;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        d = scene(p + .1 * k * n, 0).d;\n        occ += 1. / pow(2., k) * (k * .1 - d);\n        k += 1.;\n    }\n    return 1. - clamp(strength * occ, 0., 1.);\n}*/\n\nvec3 lighting(vec3 cameraPos, vec3 normal, ScenePoint sp) {\n    vec3 albedo = sp.color;\n    vec3 specular = vec3(1.);\n    float shininess = 100.;\n\n    vec3 V = normalize(cameraPos - sp.p);\n\n    vec3 sum = vec3(0.);\n    for(int i = 0; i < 4; ++i) {\n        vec3 L = -lights[i].dir;\n        vec3 H = normalize(V + L);\n\n        float difFactor = max(0., dot(L, normal));\n        float specFactor = pow(max(0., dot(H, normal)), shininess);\n        sum += lights[i].diffColor * albedo * difFactor +\n               lights[i].specColor * specular * specFactor;\n    }\n    return sum;\n}\n\nvec3 shadeAndReflection(vec3 cameraPos, vec3 rd, ScenePoint sp) {\n    vec3 result;\n\n    vec3 normal = normal(sp);\n    vec3 light = lighting(cameraPos, normal, sp);\n    float ao = cheapAo(sp.p, normal, .15);\n\n    bool hit;\n    result = light * ao;\n    \n#if REFLECTIONS\n    ScenePoint reflectionSp;\n    vec3 reflected = reflect(rd, normal);\n    hit = rm(sp.p + reflected * BIAS_EPSILON, reflected, reflectionSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result = mix(light, lighting(cameraPos, reflected, reflectionSp), .5) * ao;\n    }\n#endif\n    \n#if SHADOWS\n    ScenePoint shadowSp;\n    hit = rm(sp.p + normal * BIAS_EPSILON, -lights[0].dir, shadowSp, SECONDARY_STEPS, 1);\n    if(hit) {\n        result *= vec3(.2);\n    }\n#endif\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lights[0].dir = normalize(vec3(0., -.3, -1.));\n    lights[0].diffColor = vec3(1.);\n    lights[0].specColor = vec3(1.);\n\n    lights[1].dir = normalize(vec3(1., 0., 0.));\n    lights[1].diffColor = vec3(.3);\n    lights[1].specColor = vec3(.05);\n\n    lights[2].dir = normalize(vec3(0., 1., 0.));\n    lights[2].diffColor = vec3(.3);\n    lights[2].specColor = vec3(.05);\n\n    lights[3].dir = normalize(vec3(-1., 0., 0.));\n    lights[3].diffColor = vec3(.3);\n    lights[3].specColor = vec3(.05);\n\n    vec2 uv = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n    float curve = stoppingCurve(iTime * .5 + 12., 5.);\n    float curve2 = stoppingCurve(iTime * .8 + 195., 50.);\n\n    vec3 cameraPos = vec3(6. * (curve - .5) + iTime, 1.9 * (curve2 + .5), 10.);\n    vec3 lookAt = vec3(iTime, 0., 0.);\n    vec3 rd = cam2world(vec3(uv, 1.), cameraPos, lookAt); \n\n    ScenePoint sp;\n    vec3 col = vec3(.05);\n\n    bool hit = rm(cameraPos, rd, sp, PRIMARY_STEPS, 1);\n    if(hit) {\n        col = shadeAndReflection(cameraPos, rd, sp);\n    }\n\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}