{
    "Shader": {
        "info": {
            "date": "1589583153",
            "description": "Almost playable Chaturanga. See code for rules.",
            "flags": 48,
            "hasliked": 0,
            "id": "wsBfzW",
            "likes": 20,
            "name": "Chaturanga",
            "published": 3,
            "tags": [
                "game"
            ],
            "usePreview": 1,
            "username": "eiffie",
            "viewed": 518
        },
        "renderpass": [
            {
                "code": "//Almost Playable Chaturanga - by eiffie (because you almost want to play Chaturanga don't you)\n//Chaturanga is chess before there was chess. I'm not sure of all the rules but following wikipedia...\n//ROOKS, KNIGHTS and KINGS move as in chess\n//PAWNS move one forward or diagonally forward to capture\n//QUEENS just move 1 diagonally (they should probably also move as rooks)\n//BISHOPS jump 2 diagonally or orthogonally or move 1 diagonally or 1 forward.\n\n//This is more of an experiment than an actual game. The end game is non-existent.. literally.\n\n#define PAWN 1.\n#define ROOK 4.\n#define KNIGHT 3.\n#define BISHOP 5.\n#define QUEEN 2.\n#define KING 15.\n#define get(v) texture(iChannel0,(v+vec2(.5))/iResolution.xy)\n#define STATEVEC vec2(iResolution.x-1.,iResolution.y-1.)\n\nvec4 B[4],sel;//packed board, cell selection\nvoid loadBoard(){//load board into memory\n  for(int i=0;i<4;i++)B[i]=get(vec2(i,0));\n}\nvec4 gB(float i){return i<1.?B[0]:i<2.?B[1]:i<3.?B[2]:B[3];}//hacks for const array index\nfloat gC(float i,vec4 b){return i<1.?b.x:i<2.?b.y:i<3.?b.z:b.w;}\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\nfloat getB(vec2 v){//unpack 6 bits per cell,4 cells per float, 16 cells per pixel\n  v=floor(v);\n  vec2 av=abs(v-vec2(3.5));//if(max(av.x,av.y)>4.)return -32.;\n  float cell=v.y*8.+v.x;\n  vec4 b=gB(cell/16.);\n  float c=gC(mod(cell/4.,4.),b);\n  return gb(c,mod(cell,4.)*6.,6.)-16.;\n}\nfloat pc2tp(float b){//piece#(1-16) to score/type (scores must be unique per type)\n  b=abs(b);\n  if(b<1.)return 0.;\n  else if(b<9.)return PAWN;\n  else if(b<11.)return ROOK;\n  else if(b<13.)return KNIGHT;\n  else if(b<15.)return BISHOP;\n  else if(b<16.)return QUEEN;\n  return KING;\n}\nvec3 mcol=vec3(0.0); \nfloat DE(vec3 p0){ \n  vec3 p=vec3(fract(p0.x)-0.5,p0.y,fract(p0.z)-0.5); \n  float mx=0.65-max(abs(p.x),abs(p.z)); \n  if(max(abs(p0.x),abs(p0.z))>4.)return mx; \n  float ts=getB(p0.xz+4.),tp=pc2tp(ts);\n  if(tp==0.)return mx;//don't step too far into the next square \n  float f0=0.46,f1=2.7,f2=0.0,f3=0.25,f4=0.66,f5=-1.,f6=2.;//base config \n  float da=1.0,ds=1.0;//bits to add and subtract to the dif type pieces \n  if(tp!=QUEEN && tp<BISHOP){p.y+=0.15;f6*=1.5;} \n  p*=f6;\n  float r=length(p.xz); \n  if(p.y>0.8){f5=1.;f0=0.;//swap base for head config \n    if(tp==PAWN || tp==BISHOP){//pawns and bishop \n      f1=3.3;f2=1.1;f3=(tp<4.?.3:.22);f4=1.57; \n      if(tp==PAWN)da=length(p-vec3(0.,1.56,0.))-0.08;//pawn \n      else ds=max(-p.y+1.0,abs(p.z-p.y*0.5+.5)-0.05); \n    }else if(tp==ROOK){//rook \n      f1=2.6;f2=8.;f3=.5;f4=1.3; \n      ds=max(-p.y+1.,min(r-.37,min(abs(p.x),abs(p.z))-0.09)); \n    }else if(tp==QUEEN || tp==KING){//queen and king \n      f1=3.3;f2=0.81;f3=.28;f4=1.3; \n      if(tp==QUEEN){//queen \n        da=length(vec3(abs(p.x)-.19,p.y-1.33,abs(p.z)-.19))-0.1; \n      }else{ \n        da=max(p.y-1.75,min(r-0.02,max(abs(p.x)-.2,length(p.yz-vec2(1.59,0.))-0.02))); \n      } \n    }else{//knight \n      f1=2.,f2=3.4,f3=.31,f4=1.5; \n      float az=abs(p.z)-(p.y-1.)*0.18; \n      da=max(az-.16-p.x*.25,max(abs(p.x+.2-az*.17)-.34,abs(p.y-p.x*.16-1.19-az*.24)-.29-p.x*.16*2.)); \n      ds=min(length(p.xy-vec2(-.53,1.09)),length(p.xy-vec2(0.,1.3)))-.07; \n    } \n  }  \n  float d=r-f0+sin(p.y*f1+f2)*f3; \n  d=max(d,p.y*f5-f4); \n  da=min(da,length(max(vec2(r-0.28,abs(p.y-0.8)),0.))-0.05); \n  d=max(min(d,da),-ds); \n  if(mcol.x>0.)mcol+=ts<0.?vec3(0.4,0.45,0.5):vec3(1.); \n  return min(0.8*d/f6,mx); \n} \nvec3 normal(vec3 p, float d){vec2 e=vec2(d,0.);\n  return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n} \nfloat spow(float a,float p){return sign(a)*pow(abs(a),p);} \nvec4 sky(vec3 ro, vec3 rd, vec3 L){ \n  vec3 bgr=vec3(0.2,0.35,0.25); \n  if(rd.y>0.){ \n    return vec4(bgr,100.0); \n  }else{ \n    float t=(-0.33-ro.y)/rd.y; \n    vec2 v=(ro.xz+rd.xz*t);//a silly way to make antialiased checks  \n    if(abs(v.x)>4. || abs(v.y)>4.)return vec4(bgr,t); \n    vec3 glow=vec3(0.);vec2 fv=floor(v+vec2(4.)); \n    if(fv.x==sel.x && fv.y==sel.y)glow=vec3(0.6,0.6,0.0); \n    if(fv.x==sel.z && fv.y==sel.w)glow=vec3(0.0,0.75,0.2); \n    v=abs(fract(vec2(v.x-v.y,v.x+v.y)*0.5)-0.5);//turn 45 deg, fract, re-center \n    v=vec2(v.x-v.y,v.x+v.y);//turn again and multiply x*y \n    float d=spow(v.x*v.y,sqrt(t)*0.03);///(1.0+t*t*0.008); \n    return vec4(glow+vec3(clamp(d,0.,1.)),t); \n  } \n} \nfloat rnd; \nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*42317.7654321);} \nfloat DES(vec3 p){return min(DE(p),p.y+0.33);} \nfloat ShadAO(in vec3 ro, in vec3 rd){  \n float t=0.01*rnd,s=1.0,d,mn=0.01; \n for(int i=0;i<12;i++){ \n  d=max(DES(ro+rd*t),mn); \n  s=min(s,d/t+t*0.5); \n  t+=d; \n } \n return s; \n} \nvec3 scene(vec3 ro, vec3 rd){ \n  vec3 L=normalize(vec3(0.4,0.25,0.5)); \n  vec4 col=vec4(0.,0.,0.,1.);float px=1.0/iResolution.x; \n  float d,t=length(ro)-6.0; \n  ro+=t*rd;t=DE(ro)*rnd; \n  vec4 bcol=sky(ro,rd,L); \n  for(int i=0;i<99;i++){ \n    t+=d=DE(ro+rd*t); \n    if(t>bcol.w || d<px*t)break; \n  } \n  bool bHit=d<px*t?true:false; \n  if(bHit || rd.y<0.){\n    vec3 so,N,scol; \n    if(bHit){ \n      mcol=vec3(0.001); \n      so=ro+rd*t; \n      N=normal(so,px*t);if(N!=N)N=-rd; \n      scol=mcol/6.; \n    }else{ \n      t=bcol.w; \n      so=ro+rd*t;so.y+=0.01; \n      N=vec3(0.,1.,0.); \n      scol=bcol.xyz; \n    } \n    float dif=0.5+0.5*dot(N,L); \n    float spec=pow(max(dot(reflect(rd,N),L),0.),12.0); \n    float shad=ShadAO(so,L); \n    col=vec4((scol*dif+vec3(0.5,0.4,.2)*spec)*shad,0.); \n  } \n  col.xyz+=bcol.xyz*col.w; \n  return col.xyz; \n} \nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=(U.xy-0.5*iResolution.xy)/iResolution.x; \n  randomize(U);\n  vec4 st=get(STATEVEC);\n  loadBoard();\n  float viewAng0=gb(st.y,0.,4.)*0.0625*6.283,viewAng1=0.1+gb(st.y,4.,4.)*0.0625;\n  vec3 rd=normalize(vec3(uv,3.));\n  vec3 ro=vec3(sin(viewAng0)*cos(viewAng1),sin(viewAng1),cos(viewAng0)*cos(viewAng1))*33.;\n  vec3 fw=normalize(vec3(0.,-0.5,0.)-ro),rt=normalize(cross(fw,vec3(0.0,1.0,0.0))),up=cross(rt,fw);\n  sel=vec4(gb(st.w,0.,4.),gb(st.w,4.,4.),gb(st.w,8.,4.),gb(st.w,12.,4.));\n  O=vec4(scene(ro,mat3(rt,up,fw)*rd),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//comment this for a 3 move look ahead (which seems one less buggy)\n#define FOURMOVES\n\n//The idea was to flatten a min-max search tree by assigning each pixel a series of moves to attempt.\n//That idea went south pretty fast but I was able to cram a 4 move look ahead in one frame.\n//Thats 146410000 moves analyzed in 83187.5 pixels!\n//What follows is a bunch of hideous 24 bit, bit manipulation of vec4 structures. \n//... like freezing your GPU and using it as a hammer. Enjoy!  \n#define KEY_RIGHT 37.\n#define KEY_UP 38.\n#define KEY_LEFT 39.\n#define KEY_DOWN 40.\n#define PAWN 1.\n#define ROOK 4.\n#define KNIGHT 3.\n#define BISHOP 5.\n#define QUEEN 2.\n#define KING 15.\n#define ILLEGAL -32.\n#define MOVES 110.\n#define wid 8.\n#define zero 0.\n#define one 1.\n#define two 2.\n#define get(v) texture(iChannel0,(v+vec2(.5))/iResolution.xy)\n#define same(x,y) all(equal(x,y))\n#define STATEVEC vec2(iResolution.x-one,iResolution.y-one)\n#define ENDFRAME 9.\n#define ssgn(x) ((x)-.1>0.?1.:(x)+.1<0.?-1.:0.)\n#define FL(x) floor((x)+.5)\n#define VEC2ID(U) (U.y*iResolution.x+U.x-7.)*16.\n#define NOSEL 2056.\n//packed board, pieces and moves\nvec4 B[4],P[3],M[14];\nvoid Init(){\n  B[0]=vec4(274759,1589376,3199887,2134667);B[1]=vec4(4260880,4260880,4260880,4260880);\n  B[2]=vec4(4260880,4260880,4260880,4260880);B[3]=vec4(5321873,6387093,8247001,6932384);\n  P[0]=vec4(328452,67074,983047,789774);P[1]=vec4(592395,3145736,3355185,3552564);\n  P[2]=vec4(4143159,3817017,3947325,0);//B=pc6,  P=x3,y3,dead2,  M=pc4,dx4,dy4\n  M[0]=vec4(5309728,5379376,5444881,5317922);M[1]=vec4(5387570,5453075,5326116,5395764); \n  M[2]=vec4(5461269,5334310,5403958,5469463);M[3]=vec4(2589288,2720392,2851496,2982600);\n  M[4]=vec4(7505448,9603112,11700776,13798440);M[5]=vec4(2593385,2724489,2855593,2986697);\n  M[6]=vec4(7509545,9607209,11704873,13802537);M[7]=vec4(3449914,237898,1089562,4301578);\n  M[8]=vec4(3454011,241995,1093659,4305675);M[9]=vec4(3392812,1163580,4375324,2409548);\n  M[10]=vec4(180300,2146316,5428236,1299261);M[11]=vec4(3264797,4510765,315981,53293);\n  M[12]=vec4(4248077,1303358,3268894,3404591);M[13]=vec4(1307199,1175855,3273247,2228768);\n}\nbool Key(in float key){return (texture(iChannel1,vec2((key+0.5)/256.0, 0.25)).x>0.0);}\nvoid loadBoard(){for(int i=0;i<4;i++)B[i]=get(vec2(i,0));}//load to edit\nvoid loadPieces(){for(int i=0;i<3;i++)P[i]=get(vec2(i+4,0));}\nvec4 gB(float i){return i<1.?B[0]:i<2.?B[1]:i<3.?B[2]:B[3];}//hacks for const array index\nvec4 gP(float i){return i<1.?P[0]:i<2.?P[1]:P[2];}\nfloat gC(float i,vec4 b){return i<1.?b.x:i<2.?b.y:i<3.?b.z:b.w;}//get channel\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(two,start)),pow(two,bits));}//get bits\n#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(two,s)\n//set the bits of a vec4 field (xyzw), should be sb(B[m][n].. but for loop \"constants\" don't work on fields\nvoid sVb(inout vec4 b, float field, float start, float bits, float value){//yuk\n  if(field<1.)sb(b.x,start,bits,value); //i love a good hack, this isn't one of them\n  else if(field<2.)sb(b.y,start,bits,value);\n  else if(field<3.)sb(b.z,start,bits,value);\n  else sb(b.w,start,bits,value);\n}\nfloat pc2s(float b){//piece#(1-16) to score/type (scores must be unique as they are reused as type)\n  float ab=abs(b),s=16.;\n  if(ab<9.)s=PAWN;\n  else if(ab<11.)s=ROOK;\n  else if(ab<13.)s=KNIGHT;\n  else if(ab<15.)s=BISHOP;\n  else if(ab<16.)s=QUEEN;\n  return s*sign(b);\n}\nfloat getB(vec2 v){//unpack 6 bits per cell, 4 cells per float, 16 cells per pixel\n  v=FL(v);\n  vec2 av=abs(v-vec2(3.5));if(max(av.x,av.y)>4.)return ILLEGAL;\n  float cell=v.y*8.+v.x;\n  vec4 b=gB(cell/16.);\n  float c=gC(mod(cell/4.,4.),b);\n  return gb(c,mod(cell,4.)*6.,6.)-16.;\n}\nvoid putB(float pc, vec2 v){//repackage yikes! webgl didn't expect this\n  pc=floor(pc+16.5);v=FL(v);\n  vec2 av=abs(v-vec2(3.5));if(max(av.x,av.y)>4.)return;// ILLEGAL\n  float cell=v.y*8.+v.x;\n  int i=int(cell/16.);\n  float c=mod(cell/4.,4.),start=mod(cell,4.)*6.;\n  //sb(B[i][int(c)],start,6.,pc);//when var index is allowed (outside webgl) this should work but doesn't!\n  for(int n=0;n<4;n++)if(n==i){  //the field index requires a TRUE constant (not even a for loop works)\n    sVb(B[n],c,start,6.,pc);return; //when passing inout\n  }\n}\nvec2 getP(float pc){//get a piece's position, unpack 3 bits x, 3 y and 2 status (dead)\n  pc=floor(pc+16.5);\n  vec4 b=gP(pc/12.);\n  float c=gC(mod(pc/3.,4.),b);\n  float start=mod(pc,3.)*8.;\n  float dead=gb(c,start+6.,1.);\n  if(dead>0.)return vec2(-2);\n  return vec2(gb(c,start,3.),gb(c,start+3.,3.));\n}\nvoid putP(float pc, vec2 p){//update a piece\n  pc=floor(pc+16.5);p=FL(p);//from -16,16 to 0,32\n  float f=p.x<0.?64.:p.x+8.*p.y;//value to store\n  int i=int(pc/12.);\n  float start=mod(pc,3.)*8.,c=mod(pc/3.,4.);\n  for(int n=0;n<3;n++)if(n==i){sVb(P[n],c,start,7.,f);return;}\n}\nvoid putBP(float pc, vec2 v){putB(pc,v);putP(pc,v);}//why not do both\nvec3 getM(float id){id=floor(id);//unpack move, 4 bits piece #, 4 delta x, 4 delta y\n  int i=int(id/8.);float j=mod(id/2.,4.),start=mod(id,2.)*12.;//vec4,chan,startbit\n  for(int n=0;n<14;n++)if(n==i){\n    float c=gC(j,M[n]);\n    return vec3(gb(c,start,4.)+1.,gb(c,start+4.,4.)-2.,gb(c,start+8.,4.)-2.);\n  }\n  return vec3(ILLEGAL);\n}\nfloat getS(float id){//unpack a 6 bit score, each pixel holds 16 scores for series of moves\n  float pid=floor(id/16.)+7.;\n  vec4 b=get(vec2(mod(pid,iResolution.x),floor(pid/iResolution.x)));//pixel\n  float c=gC(mod(id/4.,4.),b);//channel\n  return gb(c,mod(id,4.)*6.,6.)-32.;//bits\n}\nvec4 bestLvlScore(float p, vec2 U, float lvl){//the minmax part\n  float bs=ILLEGAL*-p,bid=0.;//player -1 wants high score\n  for(float i=0.;i<MOVES;i+=one){\n    float s;\n    if(lvl==two)s=getS(U.x*MOVES+(U.y-1.)*(MOVES*MOVES)+i);\n    else{\n      vec2 v=vec2(i,U.y);if(lvl==0.)v=vec2(0.,i+1.);\n      s=get(v).x;\n    }\n    if(abs(s)>31.)continue;//illegal move\n    float rs=sin(iTime+i)+s;\n    if((p>0. && rs<bs) || (p<0. && rs>bs)){bs=s;bid=i;}\n  }\n  return vec4(bs,bid,0,0);\n}\n\nfloat legalS(float t, float p, vec2 p1, vec2 p2){//is the move legal and was a piece captured?\n  if(p2.x<zero||p2.x>=wid||p2.y<zero||p2.y>wid)return ILLEGAL;//off board\n  if(same(p1,p2))return ILLEGAL;\n  float cap=getB(p2);\n  if(cap!=zero){//not empty \n    if(sign(cap)==p)return ILLEGAL;//landed on own piece  \n  }//cap=abs(cap);\n  if(t!=PAWN && t!=ROOK)return cap;//these cannot be blocked and have no special rules\n  if(t==PAWN){//pawn needs special checks for diag capture\n    vec2 a=abs(p2-p1);\n    if((a.x==one && cap==zero) || (a.x==zero && cap!=zero))return ILLEGAL;//only captures diag \n    else return cap;\n  }\n  vec2 d=vec2(ssgn(p2.x-p1.x),ssgn(p2.y-p1.y)),w=p1+d;\n  for(int i=0;i<8;i++){//that leaves the rook that can be blocked (this works for chess bishops/queens as well)\n    if(same(w,p2))break;//not blocked\n    if(getB(w)!=zero)return ILLEGAL;//blocked\n    w+=d;\n  }\n  return cap;\n}\nfloat legalC(float t, float p, vec2 p1, vec2 p2){//check the human more carefully\n  float cap=legalS(t,p,p1,p2);\n  if(cap==ILLEGAL) return cap;//this covers offboard, cap own piece, blocked\n  vec2 a=abs(p2-p1);\n  float dy=p2.y-p1.y,mna=min(a.x,a.y),mxa=max(a.x,a.y);\n  if(t==PAWN){if(dy!=-p || a.x>1.)return ILLEGAL;}//capture handled in legalS\n  else if(t==ROOK){if(mna>0.)return ILLEGAL;}\n  else if(t==KNIGHT){if(mxa!=2. || mna != 1.)return ILLEGAL;}\n  else if(t==BISHOP){if(mxa>2. || (a.x==1. && a.y==0.) || (a.x==0. && dy==p) || (mna>0. && a.x!=a.y))return ILLEGAL;}\n  else if(t==QUEEN){if(mna==0. || mxa>1.)return ILLEGAL;}\n  else if(mxa>1.)return ILLEGAL;//king\n  return cap;\n}\nvec3 getLvlMove(float id, int lvl){return getM(mod(lvl==2?id:lvl==1?id/MOVES:id/(MOVES*MOVES),MOVES));}\nvec2 deltaMove(float p, vec2 p1, vec2 m){//the moves store a delta but some are absolute\n  if(m.y==3.)m.y=-p;//move player's forward \n  else if(m.y>=4.)m.y=m.y-4.-p1.y; //rook slides are absolute \n  if(m.x>=4.)m.x=m.x-4.-p1.x;\n  return p1+m;\n}\nfloat doMove(float p, float id, int lvl){//the id determines a series of moves, do 1\n  float score=0.;\n  vec3 m=getLvlMove(id,lvl);//get the move for this level from the id (coord)\n  if(m.x==ILLEGAL)return ILLEGAL;//not used\n  m.x*=p;\n  vec2 p1=getP(m.x);//get the position of the piece\n  if(p1.x<0.)return ILLEGAL;//end of branch, piece is captured\n  vec2 p2=deltaMove(p,p1,m.yz);\n  float cap=legalS(abs(pc2s(m.x)),p,p1,p2);\n  if(cap==ILLEGAL)return ILLEGAL;//end of branch, bad move\n  if(cap!=0.){\n    score=pc2s(cap);\n    putP(cap,vec2(-2));//wipe piece off board\n  }\n  putB(0.,p1);putB(m.x,p2);putP(m.x,p2);//remove from old position and set at new\n  return score;\n}\nvec4 doMoves(float player, vec2 U){//p=player -1,1, each pixel holds 16 scores (do a bunch)\n  vec4 sc=vec4(0);\n  float id=VEC2ID(U);\n  if(id>MOVES*MOVES*MOVES)return sc;//returns 16 illegal scores -32\n  for(float i=0.;i<16.;i+=one){//the pixel is filled with 16 scores\n    loadBoard();loadPieces();//reset the board and pieces\n    float p=player,score=0.;\n    for(int lvl=0;lvl<3;lvl++){//do a series of moves flipping players and keeping score\n      float s=doMove(p,id+i,lvl);\n      if(s==ILLEGAL){score=ILLEGAL;break;}else {\n        score+=s;\n        if(abs(s)==KING)break;//should have better end game now\n      }\n      p=-p;\n    }\n    //find worst (min) of next moves for 4th level (play as human)\n#ifdef FOURMOVES\n    if(abs(score)<KING){//we never made it 4 moves if score==illegal or king taken\n      float ws=-ILLEGAL;vec2 p1,p2;\n      for(float id=zero;id<MOVES;id+=one){\n        vec3 m=getM(id);\n        p1=getP(m.x);//player 1 hardcoded\n        if(p1.x>=zero){//piece is on board\n          p2=deltaMove(1.,p1,m.yz);//player 1 hardcoded\n          float cap=legalS(abs(pc2s(m.x)),1.,p1,p2);//cap will be negative\n          if(cap!=ILLEGAL && cap!=zero){cap=pc2s(cap);if(cap<ws)ws=cap;}\n        }\n      }\n      if(abs(ws)<31.)score+=ws;\n    }\n#endif\n    sVb(sc,i/4.,mod(i,4.)*6.,6.,score+32.);\n  }\n  return sc;\n}\nvec2 getMouseCell(float y){//find clicked on square  \n  float viewAng0=gb(y,0.,4.)*0.0625*6.283,viewAng1=0.1+gb(y,4.,4.)*0.0625;\n  vec2 uv=(iMouse.xy-0.5*iResolution.xy)/iResolution.x; \n  vec3 rd=normalize(vec3(uv,3.));\n  vec3 ro=vec3(sin(viewAng0)*cos(viewAng1),sin(viewAng1),cos(viewAng0)*cos(viewAng1))*33.;\n  vec3 fw=normalize(vec3(0.,-0.5,0.)-ro),rt=normalize(cross(fw,vec3(0.0,1.0,0.0))),up=cross(rt,fw);\n  rd=mat3(rt,up,fw)*rd;\n  float t=(-0.33-ro.y)/rd.y;\n  vec2 v=(ro.xz+rd.xz*t);  \n  if(max(abs(v.x),abs(v.y))>4.)return vec2(8.); \n  return floor(v+vec2(4.));\n}\nvoid mainImage(out vec4 O, vec2 U){\n  U=floor(U);Init();\n  O=get(U);//maintain pixels by default\n  if(same(U,STATEVEC)){//state vector rez.x,viewangles,frame,selections\n    if(O.x!=iResolution.x){O.x=iResolution.x;O.y=128.;O.z=zero;O.w=NOSEL;}\n    else{//game state loop\n      if(O.z==zero || O.z==two){//check for user's selected cells\n        if(iMouse.z>0.){//wait for mouse down\n          vec2 v=getMouseCell(O.y);\n          if(O.z==zero)O.w=NOSEL;//clear selection\n          else {//validate move\n            loadBoard();\n            vec2 p1=vec2(gb(O.w,0.,4.),gb(O.w,4.,4.));\n            float pc=getB(p1);if(pc<=0.){O.z=zero;O.w=NOSEL;return;}//clicked empty or black piece\n            float cap=legalC(abs(pc2s(pc)),1.,p1,v);\n            if(cap==ILLEGAL){O.z=zero;O.w=NOSEL;return;}\n          }\n          sb(O.w,O.z*4.,8.,v.x+v.y*16.);\n          if(v.x<8.)O.z+=one;\n        }else if(Key(KEY_DOWN))sb(O.y,4.,4.,clamp(gb(O.y,4.,4.)-one,0.,15.));\n        else if(Key(KEY_UP))sb(O.y,4.,4.,clamp(gb(O.y,4.,4.)+one,0.,15.));\n        else if(Key(KEY_LEFT))sb(O.y,0.,4.,mod(gb(O.y,0.,4.)-one,16.));//touchy :)\n        else if(Key(KEY_RIGHT))sb(O.y,0.,4.,mod(gb(O.y,0.,4.)+one,16.));\n      }else if(O.z==one || O.z==3.){//wait for mouse up\n        if(iMouse.z<=0.)O.z+=one;\n      }else if(O.z<ENDFRAME)O.z+=one;\n      else {//loop back to zero\n        O.z=zero;\n        vec3 m=getM(get(vec2(0,1)).y);loadPieces();\n        vec2 p1=getP(-m.x),p2=deltaMove(-1.,p1,m.yz);//player -1 hardcoded\n        O.w=p1.x+p1.y*16.+p2.x*256.+p2.y*4096.;//show to/from\n      }\n    }\n    return;//done with state\n  }\n  vec4 st=get(STATEVEC);\n  if(U.y==zero && U.x<7.){//board and pieces\n    if(iFrame==0){if(U.x<4.)O=gB(U.x);else O=gP(U.x-4.);}//save setup board and pieces\n    else if(st.z==4. || st.z==ENDFRAME){\n      loadBoard();loadPieces();//load the board and pieces to edit them\n      if(st.z<ENDFRAME){//the users move is packed in st.w\n        vec2 p1=vec2(gb(st.w,0.,4.),gb(st.w,4.,4.)),p2=vec2(gb(st.w,8.,4.),gb(st.w,12.,4.));\n        float pc=getB(p1),cap=getB(p2);\n        if(cap<0.)putP(cap,vec2(-2));//wipe piece from board\n        putB(0.,p1);putB(pc,p2);putP(pc,p2);\n      }else{//the best silicon move is in vec2(0,1).y\n        vec2 id=get(vec2(0,1)).xy;\n        float s=doMove(-1.,id.y,2);//do move #id 0-110\n        //if(s==ILLEGAL){}//debug\n      }\n      if(U.x<4.)O=gB(U.x);else O=gP(U.x-4.);//save board and pieces\n    }\n    return;//done with board and pieces\n  }else if(U.y*iResolution.x+U.x-7.>7.*MOVES*MOVES)return;//not used\n  if(st.z<5. || st.z>=ENDFRAME)return;//nothing to do\n  else if(st.z==5.)O=doMoves(-1.,U);//score the moves\n  else if(U.y>=1. && U.y<MOVES+one && U.x<MOVES){//best score box\n    float lvl=8.-st.z;//2,1,0\n    if(lvl<two && U.x>0.5)return;//just a column of pixels left\n    if(lvl<one && U.y>1.5)return;//just 1 pixel left to do the work\n    O=bestLvlScore(lvl==one?1.:-1.,U,lvl);//find best moves in 110x110 grid, row then column\n  }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}