{
    "Shader": {
        "info": {
            "date": "1489006673",
            "description": "A try with  reflection, transparency and  glow",
            "flags": 0,
            "hasliked": 0,
            "id": "MdlyR2",
            "likes": 22,
            "name": "Trip in Tron 2",
            "published": 3,
            "tags": [
                "raytracing",
                "transparent",
                "glow",
                "reflect"
            ],
            "usePreview": 0,
            "username": "ocb",
            "viewed": 2401
        },
        "renderpass": [
            {
                "code": "// Author: ocb\n// Title: Trip in Tron 2\n// testing reflection, transparency and glow\n\n\n#define PI 3.141592653589793\n\n\n// Global\n// object def\n// sphere A and B\nvec3 sphAO;\nfloat sphAR;\nvec3 sphBO;\nfloat sphBR;\nfloat ground;\n\n\nfloat random (in vec2 _st) { \t\t\t\t\t\t\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123+iTime*.1);\n}\n\nvec2 truchetPattern(in vec2 st, in float index){\n    \n    if (index > 0.75) {\n        st = vec2(1.) - st;\n    } else if (index > 0.5) {\n        st = vec2(1.0-st.x,st.y);\n    } else if (index > 0.25) {\n        st = 1.0-vec2(1.0-st.x,st.y);\n    }\n    return st;\n}\n\nbool groundImpact(inout vec3 pos,in float gndSurface, in vec3 N_ray, out vec3 N_normGnd){\n    bool impact = false;\n    \n    float t = ((gndSurface-pos.y)/N_ray.y);\n    if (t > 0.){\n        impact = true;\n\t\tpos = pos + t*N_ray;\n        N_normGnd = vec3(0., 1., 0.);\n    }\n    return impact;\n}\n\n\nfloat sphereImpact(inout vec3 pos, in vec3 sphO, in float sphR, in vec3 ray, out vec3 normSph){\n    \n    float t_dmin = 0.;\n    float taux = 0.;\n    vec3 delta = pos - sphO;\n\n    // Sphere interception\n    // pre-calculation\n    float b = dot(delta, ray);\n    float d = b*b - (dot(delta,delta) - sphR*sphR);\n    if (d >= 0.){\n        float Vd = sqrt(d);\n        float t = min( -b + Vd, -b - Vd ) ;\n        if (t > 0.){\n            t_dmin =  - b;\n    \t\tvec3 pos_dmin = pos + ray*t_dmin;\n   \t\t\ttaux = min(1./( (length(pos_dmin - sphO)/sphR) +.8)-0.8, 1.) + .5*pow(length(pos_dmin - sphO)/sphR,4.);\n            pos = pos + ray*t;\n            normSph = normalize(pos - sphO);\n        }\n    }\n    return taux;\t// return color index for the glow (center and surface)\n}\n\nvec3 groundColor(in vec3 pos){\n    vec3 col= vec3(0.);\n    \n    \tvec2 ipos = floor(vec2(pos.x,pos.z)*.1);  // integer\n    \tvec2 fpos = fract(vec2(pos.x,pos.z)*.1);  // fraction\n\t\tvec2 tile = truchetPattern(fpos, random( ipos ));\t\t// generate Maze\n        vec2 tileXL = truchetPattern(fract(vec2(pos.x,pos.z)*.1), random( floor(vec2(pos.x,pos.z)*.1) ));\t\t// used for impact effect\n        \n        // Maze\n    \tcol.b += .4*(smoothstep(tile.x-0.05,tile.x,tile.y)-smoothstep(tile.x,tile.x+0.05,tile.y));\n        col.b += .5*(1.-smoothstep(.0,.1,length(tile-fract(iTime*.4))));\t// Head on top of Truchet pattern\n    \t\n        col.rb += .5*(1.-smoothstep(0.,5.*sphAR,length(pos.xz-sphAO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere A\n        col.gb += .5*(1.-smoothstep(0.,5.*sphBR,length(pos.xz-sphBO.xz)))*(smoothstep(tile.x-0.05,tile.x,tile.y)-\n              \t\t   smoothstep(tile.x,tile.x+0.05,tile.y));\t\t// grid lag below sphere B\n     \t\n        \n        col += (1.-smoothstep(0.,.02,abs(pos.x)));\t\t\t\t// thin white line (main line)\n        col.rgb += .3*max(0.,1.-atan(abs(pos.x))*2./PI-.1);\t\t// White line glow\n        col.r += (1.-smoothstep(0.,.02,abs(pos.z)));\t\t\t    // thin red line (crossing signal)\n        \n        col.r += max(0.,(1.-smoothstep(0., .6, fract(iTime*.1+pos.x*0.00025)))*((1.-smoothstep(0.,.02,abs(pos.z))) + max(0.,1.-atan(abs(pos.z))*2./PI-.1)));\t//crossing pulse\n        col.b += max(0.,(1.-smoothstep(0., .4, fract(iTime*3.+pos.z*0.01)))*((1.-smoothstep(0.,.02,abs(pos.x))) + max(0.,1.-atan(abs(pos.x))*2./PI-.1)));\t//rapid pulse\n                \n       col.r += 1.*min(.9, smoothstep(0.,1.,(1.-fract(iTime*.1))\n                *( smoothstep(tile.x-0.05,tile.x,tile.y) - smoothstep(tile.x,tile.x+0.05,tile.y)+1.*(1.-smoothstep(.0,.1,length(tileXL-fract(iTime*2.)))) )\n                *(1.-smoothstep(0.,300000.*fract(iTime*.1), pos.x*pos.x+ pos.z*pos.z))*smoothstep(0.,100000.*(fract(iTime*.1)), pos.x*pos.x+ pos.z*pos.z)  ));  //impact\n                                                                      \n       col *= min(.8,10./length(.01*pos))+.2; \t// distance fog\n\n    return col;\n}\n\nvec3 skyColor(in vec3 ray){\n    vec3 col = vec3(0.);\n    col += vec3( max((ray.x+1.)/2.*(-4.*ray.y+1.)/2.,0.),.1*(1.-ray.y),.2*(1.-ray.y) );\n    return col;\n}\n\n\nint ojectReflect(inout vec3 pos, inout vec3 N_ray, inout vec3 color){\n    vec3 posA = pos, posB= pos, N_normPosA = vec3(0.), N_normPosB = vec3(0.);\n    float tauxA, tauxB;\n    bool A_ok = false;\n    bool B_ok = false;\n    \n    tauxA = 1.3*sphereImpact(posA, sphAO, sphAR, N_ray,N_normPosA);\n    tauxB = 1.3*sphereImpact(posB, sphBO, sphBR, N_ray,N_normPosB);\n    \n    A_ok = bool (tauxA);\n    B_ok = bool (tauxB);\n    \n    if (A_ok) {\n        if (B_ok){\n            if (length(posA-pos) < length(posB-pos)){\t\t// A and B are one behind the other\n                \t\t\t\t\t\t\t\t\t\t\t// at the end, both color are mixed\n                color += vec3(0.,tauxB,tauxB);\t\t\t\t// but first, we must get the reflection on the sphere behind.\n                vec3 Sray = reflect(N_ray,N_normPosB);\t\t\t\t\t\t// recursivity would be good\n                if (groundImpact(posB, ground, Sray, N_normPosB) ){\t\t\t// but not allowed by my shader\n       \t\t\t\tcolor += groundColor(posB);\t\t\t\t\t\t\t\t// so here we get the ground or sky reflexion\n    \t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// on the sphere behind\n    \t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t// color is added at the sphere basic color tauxB\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(tauxA,0.,tauxA),color,.7);\t\t// finally A and B are mixed\n        \t\tpos = posA;\t\t\t\t\t\t\t\t\t\t// and pos and ray of the front sphere is returned.\n        \t\tN_ray = reflect(N_ray,N_normPosA);\n    \t\t}\n    \t\telse{\n                color += vec3(tauxA,.0,tauxA);\n                vec3 Sray = reflect(N_ray,N_normPosA);\n                if (groundImpact(posA, ground, Sray, N_normPosA) ){\n       \t\t\t\tcolor += groundColor(posA);\n    \t\t\t}\n    \t\t\telse {\t\t// ray goes to the sky\n        \t\tcolor += skyColor(Sray);\n   \t\t\t\t}\n                color = mix(vec3(0.,tauxB,tauxB),color,.7);\n        \t\tpos = posB;\n        \t\tN_ray = reflect(N_ray,N_normPosB);   \n            }\n        }\n        else{\n            color.rb += tauxA;\n        \tpos = posA;\n        \tN_ray = reflect(N_ray,N_normPosA);   \n        }\n    }\n    else if (B_ok){\n        color.gb += tauxB;\n        pos = posB;\n        N_ray = reflect(N_ray,N_normPosB);\n    }\n    \n    return int(A_ok)+int(B_ok);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n    \n    // init global object\n    sphAO = vec3(40.*sin(iTime*.4),15.,60.*cos(iTime*.3));\n\tsphAR = 5.;\n\tsphBO = vec3(80.*sin(iTime*.4),16.,40.*cos(iTime*.3));\n\tsphBR = 6.;\n    ground = 0.;\n    \n    // camera def\n    float focal = 1.;\n    float \trau = 15.*(sin(iTime/11.)+1.)+3.*sphAR,\n    \t\talpha = -iTime/5.,\n    \t\ttheta = (sin(iTime/7.)/2.+.5)*(PI/2.-1.2)-.1;\t//rau, alpha, theta camera position   \n\t\n    vec3 camTarget = (sin(iTime*.2)+1.)*.5*sphAO + (sin(iTime*.2+PI)+1.)*.5*sphBO;  //target going from sphA to sphB\n    \n    vec3 screenPos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n    \n    vec3 ww = normalize( camTarget - screenPos );\n    vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n\n    vec3 N_normPos = vec3(0.);\n    vec3 pos = screenPos;\n\n    vec3 color = vec3(.0);\n    \n    // get color on transparency path\n    // no object hit, only ground or sky\n    vec3 transPos = pos;    \n    vec3 transColor = vec3(0.);\n    if (groundImpact(transPos, ground, N_ray, N_normPos)){\n        transColor = groundColor(transPos);\n    }\n    else {transColor = skyColor(N_ray);}\n    //-------------------------------\n    \n    // calculate reflection\n    if (ojectReflect(pos, N_ray, color)>0){\t\t// first step ray\n        ojectReflect(pos, N_ray, color);\t\t// if sphere hit, second step ray\n    }\n    //-------------------------------\n    \n    // mix reflection and transparency\n    color = mix(color, transColor, .5);\n    \n    // otherwise no object impacted\n    if (groundImpact(pos, ground, N_ray, N_normPos) ){\n       color += groundColor(pos);\n    }\n    else {\t\t// ray goes to the sky\n        color += skyColor(N_ray);\n    }\n    \n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}