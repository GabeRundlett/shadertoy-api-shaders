{
    "Shader": {
        "info": {
            "date": "1661838205",
            "description": "This animation was invented by Robert Fathauer, responding to the #SwirledSeries a few years ago. AFAICT it never made it into a shadertoy, so I think it's fair to recreate it here.\n\nhttps://twitter.com/RobFathauerArt/status/1329125556252594178",
            "flags": 0,
            "hasliked": 0,
            "id": "ftVyWw",
            "likes": 11,
            "name": "Fathauer Hinged Squares (225 ch)",
            "published": 3,
            "tags": [
                "checkerboard",
                "golf",
                "reproduction",
                "swirled"
            ],
            "usePreview": 0,
            "username": "fenix",
            "viewed": 267
        },
        "renderpass": [
            {
                "code": "// ---------------------------------------------------------------------------------------\n// Created by fenix in 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Part of my Hinged Squares series:\n\n// Fathauer Hinged Squares    https://www.shadertoy.com/view/ftVyWw\n// Kaplan Hinged Squares      https://www.shadertoy.com/view/NtGcDm\n// Kaplan 5-Color Squares     https://www.shadertoy.com/view/slGyzy\n\n// This is the first, simplest of the hinged squares. I was reading about the Swirled Series\n// (https://isohedral.ca/swirled-series-the-result) and came across this entry that I really\n// liked (https://twitter.com/RobFathauerArt/status/1329125556252594178). I couldn't find\n// a shadertoy implementation so hopefully he doesn't mind if I put one here.\n\n// I feel like this is reasonably competantly golfed, but I'm sure others on this site will\n// put me to shame.\n\n// From coyote: 225 chars (-7)\n//*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    float a = iTime,\n          c = abs(sin(a + a))*.08 + .2;\n    \n    O = .5\n       + min(0.\n            ,max(u= abs((mod(u= mod((u - (O.xy=.5*iResolution.xy)) / O.y\n                            ,c+c)-c\n                        ,c)-.5*c) * mat2(cos(a*(c= sign(u.x*u.y))\n                                         - vec4(0,11,33,0))))\n                ,u.y).x - .1) *.5*c * O.yyyy;\n}\n/**/\n\n// From Xor: 232 chars (-75)\n/*\nvoid mainImage( out vec4 O, vec2 u)\n{\n    float a = iTime,\n          c = abs(sin(a + a))*.08 + .2,\n          s;\n\n    u = mod((u - (O.xy=.5*iResolution.xy)) / O.y / c, 2.);\n    \n    s = sign(--u * u.y).x;\n    u = abs(mat2(cos(a*s + vec4(0,11,33,0))) * (fract(u)-.5));\n    \n    O = .5 + .5 * s * O.yyyy * min(0., max(u.x, u.y) * c - .1);\n}\n/**/\n\n// Original golfed version: 307 chars\n/*\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy;\n    float a = iTime,\n          c = abs(sin(a + a)) / 25. + .1,\n          s;\n\n    O = vec4(.5);\n    u = mod(.5 * (2. * u/R.y - vec2(R.x/R.y, 1.)) / c, 2.);\n    \n    s = sign((u.x - 1.) * (u.y - 1.));\n    a *= s;\n    u = fract(u);\n    u = abs(mat2(cos(a), sin(a), -sin(a), cos(a)) * ((u + u) * c - c)) - .1;\n    \n    O += s * R.y * O * min(0., length(max(u, 0.)) + min(max(u.x, u.y), 0.));\n}\n/**/\n\n// Completely pre-golfed version, 741 chars\n/*\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nmat2 rotAng(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0 * fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y, 1.0);\n    \n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    \n    float inv = 1.0;\n    float a = iTime;\n    vec2 center = abs(vec2(sin(a + a))) / 23.0 + 0.1;\n\n    if (p.x < 0.0)\n    {\n        p.x = -p.x;\n        inv = -inv;\n    }\n    if (p.y < 0.0)\n    {\n        p.y = -p.y;\n        inv = -inv;\n    }\n    \n    p = mod(p, 4.0 * center);\n    if (p.x > 2.0 * center.x)\n    {\n        p.x -= 2.0 * center.x;\n        inv = -inv;\n        a = -a;\n    }\n    if (p.y > 2.0 * center.x)\n    {\n        p.y -= 2.0 * center.x;\n        inv = -inv;\n        a = -a;\n    }\n    \n    fragColor.xyz += vec3(0.5)*inv * smoothstep(-0.001, 0.001, -sdBox(rotAng(-a) * (p - center), vec2(0.1)));\n}\n/**/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}