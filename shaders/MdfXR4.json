{
    "Shader": {
        "info": {
            "date": "1400905375",
            "description": "These are hydrogen atom atomic orbitals at different energy levels. They are visualized with a rotating cross-section, and of course, they move to the music. Because what would atoms be if they didn't move to music?",
            "flags": 0,
            "hasliked": 0,
            "id": "MdfXR4",
            "likes": 12,
            "name": "orbitals",
            "published": 3,
            "tags": [
                "orbitals"
            ],
            "usePreview": 0,
            "username": "otaviogood",
            "viewed": 1147
        },
        "renderpass": [
            {
                "code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n-Otavio Good\n\nThere is a bug with higher energy levels. Some day maybe I'll figure out the problem.\n\n*/\n#define MANUAL_CAMERA 0\n#define MOVE_TO_MUSIC 1\n#define MAX_ENERGY_PLUS_ONE 4.0\n\n// broken\n#define TRACED_SKY_SHADOWS 0\n\nfloat PI=3.14159265;\nvec3 sunColOrig = vec3(255.0, 208.0, 100.0)*0.5 / 255.0;\nvec3 environmentSphereColor = vec3(0.3001, 0.501, 0.901)*0.5;\nvec3 environmentGroundColor = vec3(0.4001, 0.25, 0.1)*0.3;\n\nfloat marchingMultiplier = 1.0;\nfloat shadow;\nfloat localTime;\nvec3 sunCol;\n\nvec3 freq;\n\nfloat distFromSphere;\nvec3 normal;\n\nfloat material;\n\nvec3 saturate(vec3 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nvec2 saturate(vec2 a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\nfloat saturate(float a)\n{\n\treturn clamp(a, 0.0, 1.0);\n}\n\nfloat SmoothMix(float a, float b, float x)\n{\n\tfloat t = x*x*(3.0 - 2.0*x);\n\treturn mix(a, b, t);\n}\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n\t//else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n\t//else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\t//if (RIGHT_HANDED_COORD)\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\n// k should be negative. -4.0 works nicely.\nfloat smin(float a, float b, float k)\n{\n\t// I'm guessing that base 2 operations are the fastest.\n\treturn log2(exp2(k*a)+exp2(k*b))/k;\n}\n\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 tex = texture(iChannel1, rayDir).xyz;\n\treturn(tex*tex);\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = max(0.0, 0.01 / sunIntensity - 0.025);\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tvec3 ground = mix(environmentGroundColor, environmentSphereColor,\n\t\t\t\t\t  pow(localRay.y, 0.35)*sign(localRay.y) * 0.5 + 0.5);\n\treturn ground + sunCol * sunIntensity;\n}\n\n// http://www.chemistry.mcmaster.ca/esam/Chapter_3/section_2.html\nfloat a0 = 0.05291772;  // Bohr radius (in nanometers maybe?)\nfloat E = 2.71828;\n\nfloat GeneralizedLaguerre(float n, float a, float x)\n{\n\t// http://en.wikipedia.org/wiki/Laguerre_polynomials;\n\t//if (n == 0.0) return 1.0;\n\tif (n == 1.0) return (-x + a + 1.0);\n\telse if (n == 2.0) return ((x*x)/2.0) - (a+2.0)*x + (((a+2.0)*(a+1.0))/2.0);\n\telse if (n == 3.0) return (-(x*x*x)/6.0)\n\t\t+ (((a+3.0)*(x*x))/2.0)\n\t\t- (((a+2.0)*(a+3.0)*x)/2.0)\n\t\t+ (((a+1.0)*(a+2.0)*(a+3.0))/6.0);\n\telse if (n == 4.0)\t// Not sure this n == 4 case is the right math\n\t\treturn (x*x*x*x/24.0)\n\t\t- (a+4.0)*x*x*x/2.0\n\t\t+ (a+4.0)*(a+3.0)*x*x/2.0\n\t\t- (a+4.0)*(a+3.0)*(a+2.0)*x/2.0\n\t\t+ (a+4.0)*(a+3.0)*(a+2.0)*(a+1.0)/24.0;\n\treturn 1.0;\n}\n\nfloat factorial(float a)\n{\n\tif (a <= 1.0) return 1.0;\n\telse if (a == 2.0) return 2.0;\n\telse if (a == 3.0) return 6.0;\n\telse if (a == 4.0) return 24.0;\n\telse if (a == 5.0) return 120.0;\n\telse if (a == 6.0) return 720.0;\n\telse if (a == 7.0) return 5040.0;\n\telse if (a == 8.0) return 40320.0;\n\telse if (a == 9.0) return 362880.0;\n\telse if (a == 10.0) return 3628800.0;\n\telse if (a == 11.0) return 39916800.0;\n\telse if (a == 12.0) return 479001600.0;\n\treturn 1.0;\n}\n\nfloat CalcR(float n, float l, float m, float r) {\n    float Z = 1.0;  // index into periodic table (number of protons)\n\tfloat sub1 = pow((2.0 * Z) / (n * a0), 3.0);\n\tfloat sub2 = factorial(n - l - 1.0) / (2.0 * n * factorial(n + l));\n\tfloat part1 = sqrt(sub1 * sub2);\n\t// e ^ (-r/2*a0)\n\tfloat part2 = pow(E, (-Z * r) / (n * a0));\n\t// 1\n\tfloat part3 = pow((2.0 * Z * r) / (n * a0), l);\n\t// laguerre = -r/a0 + 2   -------- \n\tfloat part4 = GeneralizedLaguerre(n - l - 1.0, 2.0 * l + 1.0, (2.0 * Z * r) / (n * a0));\n\treturn part1 * part2 * part3 * part4;\n //   }\n}\n\nfloat SphericalHarmonicXYZ(float l, float m, vec3 pos)\n{\n\tfloat x = pos.x;\n\tfloat y = pos.y;\n\tfloat z = pos.z;\n\t// http://en.wikipedia.org/wiki/Table_of_spherical_harmonics#Real_spherical_harmonics\n/*\tif (l == 0.0)\n\t{\n\t\treturn 0.28209479;\n\t} else*/ if (l == 1.0)\n\t{\n\t\tfloat posm1 = pos.y;\n\t\tif (m == 0.0) posm1 = pos.z;\n\t\telse if (m == 1.0) posm1 = pos.x;\n\t\tfloat r = length(pos);\n\t\treturn 0.488602511 * (posm1 / r);\n\t} else if (l == 2.0)\n\t{\n\t\tfloat r = length(pos);\n\t\tfloat r2 = r * r;\n\t\tif (m == -2.0)\n\t\t\treturn 1.09254889 * ((pos.x * pos.y) / r2);\n\t\telse if (m == -1.0)\n\t\t\treturn 1.09254889 * ((pos.y * pos.z) / r2);\n\t\telse if (m == 1.0)\n\t\t\treturn 1.09254889 * ((pos.z * pos.x) / r2);\n\t\telse if (m == 0.0)\n\t\t\treturn 0.31539156 * (-(pos.x * pos.x)-(pos.y * pos.y) + 2.0 * pos.z * pos.z) / r2;\n\t\telse if (m == 2.0)\n\t\t\treturn 0.54627444 * ((pos.x * pos.x) - (pos.y * pos.y)) / r2;\n\t}\n\telse if (l == 3.0)\n\t{\n\t\tfloat r = length(pos);\n\t\tfloat r3 = r * r * r;\n\t\t// Math.sqrt(35/(2*Math.PI))/4\n\t\tif (m == -3.0)\n\t\t\treturn 0.59004358 * (3.0 * x * x - y * y) * y / r3;\n\t\t// Math.sqrt(105/(Math.PI))/2\n\t\telse if (m == -2.0)\n\t\t\treturn 2.89061144 * (x * y * z) / r3;\n\t\t// Math.sqrt(21/(2*Math.PI))/4\n\t\telse if (m == -1.0)\n\t\t\treturn 0.45704579 * y * (4.0 * z * z - x * x - y * y) / r3;\n\t\t// Math.sqrt(7/(Math.PI))/4\n\t\telse if (m == 0.0)\n\t\t\treturn 0.37317633 * z * (2.0 * z * z - 3.0 * x * x - 3.0 * y * y) / r3;\n\t\t// Math.sqrt(21/(2*Math.PI))/4\n\t\telse if (m == 1.0)\n\t\t\treturn 0.45704579 * x * (4.0 * z * z - x * x - y * y) / r3;\n\t\t// Math.sqrt(105/(Math.PI))/4\n\t\telse if (m == 2.0)\n\t\t\treturn 1.44530572 * (x * x - y * y) * z / r3;\n\t\t// Math.sqrt(35/(2*Math.PI))/4\n\t\telse if (m == 3.0)\n\t\t\treturn 0.59004358 * (x * x - 3.0 * y * y) * x / r3;\n\t}\n\t// l = 0 is a constant.\n\treturn 0.28209479;\n}\n\nfloat matMin(float a, float b, float matNum)\n{\n\tif (a < b)\n\t{\n\t\t//material = 0.0;\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\tmaterial = matNum;\n\t\treturn b;\n\t}\n}\n\nfloat DistanceToObject2(vec3 p)\n{\n\t//float f = length(p) - 1.75;\n\t//f += sin((p.x+iTime)*4.0)*0.05+0.05;\n\t//f += cos((p.y+iTime)*8.0)*0.05+0.05;\n\n\tfloat f = length(p);\n\tfloat currentL = 2.0;\n\tfloat currentM = mod(floor(localTime), 5.0)-2.0;\n\tfloat currentMB = mod(floor(localTime+1.0), 5.0)-2.0;\n\tfloat alpha = fract(localTime);\n\tfloat shA = (SphericalHarmonicXYZ(currentL, currentM, p));\n\tfloat shB = (SphericalHarmonicXYZ(currentL, currentMB, p));\n\tfloat sh = SmoothMix(shA, shB, alpha);\n\tif (sh < 0.0) material = 1.0;\n\telse material = 0.0;\n\tf = f - abs(sh);\n\n\treturn f;\n}\n\nfloat DistanceToObject(vec3 p)\n{\n\t//vec3 pOrigOrig = p;\n\t//float boxDist = -dBox(pOrigOrig, vec3(1.0,1.0,1.0)*5.0);\n\t//if (boxDist > 0.01) return boxDist;\n\n\tp += vec3(6.0, 3.0, 1.0);\n\tvec3 pOrig = p;\n\tvec3 c = vec3(2.0, 2.0, 2.0)*1.0;\n\tp = mod(p,c)-0.5*c;\n\t//float f = length(p) - 1.75;\n\t//f += sin((p.x+iTime)*4.0)*0.05+0.05;\n\t//f += cos((p.y+iTime)*8.0)*0.05+0.05;\n\n\tfloat f = length(p);\n\t//marchingMultiplier = clamp(0.2, 1.0, f*0.4);\n\tvec3 temp = floor(pOrig/c);\n\tfloat miss = 3.0;\n\t// table of valid numbers here: http://en.wikipedia.org/wiki/Atomic_orbital\n\tif (temp.x >= MAX_ENERGY_PLUS_ONE) return miss;\n\tif (temp.x < 1.0) return miss;//1.0\n\tif (temp.y < 0.0) return miss;\n\tif (temp.y >= temp.x) return miss;\n\tif (temp.z < -temp.y) return miss;\n\tif (temp.z >= temp.y+1.0) return miss;\n\tfloat currentN = temp.x;//floor(pOrig*c).x;\n\tfloat currentL = temp.y;//0.0;//mod(floor(localTime*0.25), 4.0);\n\tfloat currentM = temp.z;// mod(floor(localTime), 5.0)-2.0;\n\t//float currentMB = mod(floor(localTime+1.0), 5.0)-2.0;\n\tfloat alpha = fract(localTime);\n\n\tfloat shA = (SphericalHarmonicXYZ(currentL, currentM, p));\n\tfloat coolR = CalcR(currentN, currentL, currentM, length(p));\n\tfloat waveFunc = (shA * coolR);\n\tshA = waveFunc;\n\n/*\tfloat shB = (SphericalHarmonicXYZ(currentL, currentMB, p));\n\tcoolR = CalcR(currentN, currentL, currentMB, length(p));\n\twaveFunc = (shB * coolR);\n\tshB = waveFunc;\n*/\n\tfloat sh = shA;// SmoothMix(shA, shB, alpha);\n\n\tif (sh < 0.0) material = 1.0;\n\telse material = 0.0;\n\tf = f - abs(sh);\n\t// do the cross-section slice\n\tf = max(f, p.y*sin(localTime)+p.z*cos(localTime));\n\t// move to the music\n#if MOVE_TO_MUSIC\n\tf += sin((p.x+localTime)*8.0)*0.2*saturate(freq.x-0.5);\n\tfloat hf = sin((p.y+localTime)*32.0)*0.15*saturate(freq.y-0.3);\n\tf -= hf;\n#endif\n\n\treturn f;\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up brick texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel0, pos.yz);\n\tvec4 texY = texture(iChannel0, pos.xz);\n\tvec4 texZ = texture(iChannel0, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\n// ----------------------------------------------------------------------------\n// ----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tlocalTime = iTime;\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;// - 0.5;\n\n\tfreq.x = texture(iChannel3, vec2(0.0, 0.0)).x;\n\tfreq.y = texture(iChannel3, vec2(0.1, 0.0)).x;\n\tfreq.z = texture(iChannel3, vec2(0.3, 0.0)).x;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n#if MANUAL_CAMERA\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\tvec3 camPos=vec3(1.0, 1.0, 1.0)*3.99;\n\n\tfloat mx=iMouse.x/iResolution.x*PI*2.0;// + iTime * 0.2;\n\tfloat my=-iMouse.y/iResolution.y*10.0;// + sin(iTime * 0.3)*0.2+0.2;//*PI/2.01;\n\tcamPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*camPos; \t// prp\n#else\n\tfloat camSpeed = 0.25;\n\tvec3 camLookat=vec3(0,0.0,0);\t// vrp\n\tvec3 camPos=vec3(0.0, 0.0, 0.0);\n\tfloat camRad = 3.25;\n\tcamPos = vec3(sin(localTime*camSpeed)*camRad, 0.0, cos(localTime*camSpeed)*camRad);\n\n#endif\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\tvec3 sunDir = normalize(vec3(-0.95, -3.0, -0.95));\n\tsunCol = sunColOrig;\n\n\t// ------------------------------ Ray march -----------------------------------\n\tfloat dist = 0.02;\n\tfloat t = 0.1;\n\tfloat maxDepth = 16.0;\n\tvec3 pos = vec3(0,0,0);\n\tvec3 lastPos = vec3(1000000.0, 0.0, 0.0);\n\t// ray marching time\n\tfloat marchCount = 0.0;\n\tfor (int i = 0; i < 200; i++)\n\t{\n\t\tif ((t > maxDepth) || (abs(dist) < 0.001))\n\t\t{\n\t\t\tbreak;\t// break doesn't work on some machines\n\t\t\tcontinue;\t// so do a continue for those\n\t\t}\n\t\tpos = camPos + relVec * t;\n\t\tdist = DistanceToObject(pos);\n\t\tt += dist * 0.2;//marchingMultiplier;//*0.2;\t// because deformations mess up distance function.\n\t\tmarchCount += 1.0;\n\t}\n\tfloat finalMaterial = material;\n\tmarchingMultiplier = 1.0;\n\n\t// ----------------------------------------------------------------------------\n\n\n\tvec3 finalColor = GetSunColorReflection(relVec, -sunDir);// + vec3(0.1, 0.1, 0.1);\n\n\t// calculate normal from distance field\n\tvec3 smallVec = vec3(0.005, 0, 0);\n\tvec3 dx = pos - smallVec.xyy;\n\tvec3 dy = pos - smallVec.yxy;\n\tvec3 dz = pos - smallVec.yyx;\n\tvec3 normal = vec3(dist - DistanceToObject(dx),\n\t\t\t\t\t   dist - DistanceToObject(dy),\n\t\t\t\t\t   dist - DistanceToObject(dz));\n\tnormal = normalize(normal);\n\n\t// -------------------------- Shadow trace --------------------------\n\tshadow = 1000000.0;\n\t//for (int i = 1; i < 8; i++)\n\t//{\n\t//\tvec3 midPos = mix(pos, oculus, float(i) / 64.0);\n\t//\tfloat shadow0 = max(0.0, DistanceToObject(midPos));\n\t//\tshadow = min(shadow, shadow0);\n\t//}\n/*\tfloat dist2 = 0.02;\n\tfloat t2 = 0.1;\n\tfloat maxDepth2 = 40.0;\n\tvec3 pos2 = vec3(0,0,0);\n\t// ray marching time\n\tfloat mCount = 0.0;\n\tfor (int i = 0; i < 32; i++)\n\t{\n\t\tif ((t2 > maxDepth2) || (abs(dist2) < 0.001)) continue;\t// break DOESN'T WORK!!! ARRRGGG!\n\t\tpos2 = (pos + normal*0.02) + normalize(oculus - pos) * t2;\n\t\tdist2 = DistanceToObject(pos2);\n\t\tt2 += dist2 * marchingMultplier;\t// because deformations mess up distance function.\n\t\tmCount++;\n\t}\n\tif (dist2 < 0.01) shadow = 0.0;*/\n\tshadow = saturate(shadow * 300.9);\n\n//\tfloat shadow0 = max(0.0, DistanceToObject(mix(oculus, pos, 0.333)));\n//\tfloat shadow1 = max(0.0, DistanceToObject(mix(oculus, pos, 0.666)));\n//\tshadow0 = min(shadow0, shadow1);\n\t// ----------------------------------------------------------------------------\n\n\t// calculate ambient occlusion with 3 extra distance field queries\n\tfloat ambient = DistanceToObject(pos + normal * 0.5);\n\tambient += DistanceToObject(pos + normal * 0.25);\n\tambient += DistanceToObject(pos + normal * 0.125);\n\tambient = max(0.1, ambient);\t// tone down ambient with a pow and min clamp it.\n\tambient = saturate(ambient);\n\n\tvec3 tempPos = pos;\n\t// look up brick texture, blended across xyz axis based on normal.\n\tvec3 tex = tex3d(tempPos, normal).xxx;\n\ttex = tex * tex;\t// gamma correct\n\n\t// materials\n\tvec3 ref = reflect(relVec, normal);\n\n\t//tex.xyz = vec3(1.0,1.0,1.0)*0.8;\n\tif (finalMaterial == 1.0)\n\t{\n\t\ttex.xyz *= vec3(1.0, 0.175, 0.175)*1.0;\n\t}\n\telse\n\t{\n\t\ttex.xyz *= vec3(0.5, 1.0, 0.5)*1.0;\n\t}\n\ttex.xyz *= 1.6;\t// texture seems a bit dark, maybe not normalized\n\t//tex.xyz = vec3(1.0,1.0,1.0);\n\n\t// if ray marching found an intersection, then calculate lighting and stuff\n\tif (t <= maxDepth)\n\t{\n\t\tvec3 lightDir = sunDir;\n\t\tfloat lenLightDir = length(lightDir);\n\t\tfloat skyMult = max(0.0, -lightDir.y) * max(0.0, dot(-lightDir, normal));\n\t\tskyMult *= 0.55 / (lenLightDir*lenLightDir);\n\t\t//vec3 envLight = environmentSphereColor;// * skyMult;// + environmentGroundColor * (normal.y * 0.5 + 0.5);\n\t\tvec3 envLight = mix(environmentGroundColor, environmentSphereColor, (normal.y * 0.5 + 0.5));\n\t\tenvLight *= shadow;// * skyMult;\n\t\t//envLight += environmentSphereColor * 0.045;\t// ambient is lame, but better than black.\n\t\t//vec3 domeLight = vec3(1.0, 0.1, 0.5) * (normal.y * 0.5 + 0.5) * min(ambient, shadow) * 0.15;\n\n\t\tvec3 sunDirect = max(0.0, dot(-sunDir, normal)) * sunCol * 3.0;\n\t\tvec3 sunIndirect;// = 0.25*pow(saturate((3.5-distance(flatPos, flatOculus))), 2.0) * sunCol * 0.31;\n\t\tfinalColor = (envLight) * tex.xyz;\n\t\tfinalColor *= vec3(1.0,1.0,1.0) * ambient;\n\t\tfinalColor += (sunDirect) * tex.xyz;// * ambient;\n\t\tvec3 texBack = texture(iChannel1, ref).xyz;\n\t\tvec3 texDark = pow(texBack, vec3(1.0,1.0,1.0)*50.0).zzz;\t// fake hdr texture\n\t\ttexBack += texDark*0.5;\n\t\tfloat nooks = pow(saturate(tex.x + 0.85), 4.0);\n\t\ttexBack *= nooks;\n\t\tfinalColor = mix(finalColor, texBack*texBack*texBack*ambient * 0.995, 0.3);\n\t\t//finalColor += texBack*texBack*texBack*ambient * 0.5;\n\t\tfinalColor = mix(finalColor, vec3(0.015,0.015,0.015), pow(saturate(distance(pos, camPos)*0.075), 0.7) );\n\t\t//finalColor = vec3(1.0,1.0,1.0)*pow(tex.x + 0.85, 14.0);\n\t}\n\t//finalColor += vec3(0.9,0.3,1.0)* marchCount/256.0;\n\t//fragColor = vec4(clamp(finalColor, 0.0, 1.0),1.0);\n\tfragColor = vec4(sqrt(clamp(finalColor*1.0, 0.0, 1.0)),1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "music",
                        "id": 35,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}