{
    "Shader": {
        "info": {
            "date": "1592609657",
            "description": "coded in 1 hour 30 minutes for the Nova 2020 shader freestyle. the sacrificial altar sure looks like a birthday cake!",
            "flags": 0,
            "hasliked": 0,
            "id": "wlXczf",
            "likes": 34,
            "name": "Lord Oculon's Birthday",
            "published": 3,
            "tags": [
                "eyes",
                "eye",
                "livecode",
                "shaderfreestyle"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 772
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nconst float bpm = 168.;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec3 arot(vec3 p, vec3 a, vec3 b) {\n    vec3 ax = normalize(cross(a,b));\n    float ro = acos(dot(a,b));\n    return erot(p,ax,ro);\n}\n\nvec3 urot(vec3 p, vec3 a, vec3 b, vec3 u) {\n    float ang = atan(dot(u,cross(a,b)), dot(a,b));\n    p = erot(p, u, ang);\n    a = erot(a, u, ang);\n    return arot(p,a,b);\n}\n\nvec3 face(vec3 p) {\n    vec3 ap = abs(p); vec4 k = vec4(sign(p),0);\n    if (ap.x >= max(ap.y,ap.z)) return k.xww;\n    if (ap.y >= max(ap.x,ap.z)) return k.wyw;\n    if (ap.z >= max(ap.y,ap.x)) return k.wwz;\n}\n\nvec3 edge(vec3 p) {\n    vec3 mask = vec3(1)-abs(face(p));\n    vec3 v = sign(p);\n    vec3 a = v*mask.zxy;\n    vec3 b = v*mask.yzx;\n    return distance(p,a)<distance(p,b)?a:b;\n}\n\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a),y=FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nfloat box(vec2 p, vec2 d) {\n    vec2 q = abs(p)-d;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat pentagram(vec2 p) {\n    float dist = 10000.;\n    for (int i = 0; i < 5; i ++ ){\n        float ang = float(i)*3.14/5.*2.;\n        float ang2 = float(i+2)*3.14/5.*2.;\n        vec2 a = vec2(sin(ang), cos(ang));\n        vec2 b = vec2(sin(ang2), cos(ang2));\n        dist = min(linedist(p,a,b),dist);\n    }\n    return dist;\n}\n\nvec3 lpos;\nvec3 id;\nfloat pedistal;\nfloat l1;\nfloat dbg;\nfloat torch;\nfloat scene(vec3 p) {\n    vec3 op = p;\n    \n    vec2 pc = vec2(length(p.xy),p.z);\n    pedistal = box(pc+vec2(0.,3.8), vec2(2.,0.1));\n    float ang = atan(p.x,p.y);\n    pedistal += smoothstep(-.2,.2,sin(ang*100.))*.02;\n    pedistal = min(pedistal, box(pc+vec2(0.,3.8), vec2(1.9,0.15)));\n    float ang2 = round(ang*4.)/4.;\n    vec2 clos = vec2(sin(ang2),cos(ang2))*1.7;\n    \n    float ang3 = round(ang*2.)/2.;\n    vec2 clos2 = vec2(sin(ang3),cos(ang3))*2.;\n    \n    pc = vec2(length(p.xy-clos),p.z);\n    vec2 pc2 = vec2(length(p.xy-clos2),p.z);\n    dbg = sin(min(pentagram(p.xy),pc.x)*100.);\n    pedistal = min(pedistal, box(pc+vec2(0.,4.), vec2(.01,0.8)))-0.03;\n    pedistal = min(pedistal, box(pc2+vec2(0.,6.5), vec2(.1,2.8)));\n    torch = box(pc+vec2(0.,3.2), vec2(.05,0.05));\n    pedistal = min(torch, pedistal);\n    \n    \n    vec3 beyp = vec3(7,0,0);\n    id = floor(p)+.5;\n    vec3 m = sign(mod(id,2.)-1.);\n    if (m.x*m.y*m.z < 0.) id += face(p-id);\n    float sd = hash(hash(id.x,id.z),id.y);\n    if (length(id) < 6. || sd < -0.5 || distance(id,beyp) < 3.7) {\n        id += edge(p-id);\n    }\n    p -= id;\n    float balls = max(5.-length(op),length(p)-.7);\n    l1 = distance(op,lpos) - .3;\n    if (distance(op,beyp) < 3.1) {\n        id = beyp;\n    }\n    balls = min(distance(op,beyp) - 3.,balls);\n    return min(pedistal, min(l1, balls));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float bpmt = iTime/60.*bpm;\n    float t = mix(pow(sin(fract(bpmt)*3.14/2.),50.) + floor(bpmt), bpmt, 0.8);\n    lpos = vec3(sin(t),cos(t),sin(t/3.))*4.;\n    vec3 cam = normalize(vec3(.8 + sin(t*3.14)*.2,uv));\n    vec3 init = vec3(-3.5+cos(t*3.14/2.),0,0) + cam*.1;\n    \n    cam = erot(cam, vec3(0,1,0), sin(t/2.-.5)*.5);\n    init = erot(init, vec3(0,1,0), sin(t/2.)*.5);\n    cam = erot(cam, vec3(0,0,1), cos(t/5.-.5)*.5);\n    init = erot(init, vec3(0,0,1), cos(t/5.)*.5);\n    cam = erot(cam, vec3(1,0,0), (asin(sin(t/2.))*-1.)*.2);\n    init.z -= 2.; \n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glo = 0.;\n    float glo2 = 0.;\n    for (int i = 0; i < 100 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        glo += 100./(1.+l1*2000.)*dist;\n        glo2 += 200./(1.+torch*5000.)*dist;\n    }\n    float dbgg = dbg;\n    bool tc = torch == dist;\n    bool pd = dist == pedistal;\n    vec3 lid = id;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    \n    vec3 lookat = normalize(init-lid);\n    vec3 lookat2 = normalize(lpos-lid);\n    lookat = normalize(mix(lookat,lookat2,smoothstep(8.,5.,distance(lid,lpos))));\n\n    vec3 eycrd = urot(n, lookat, vec3(1,0,0), vec3(0,0,1));\n    float ey = eycrd.x;\n    float garble = atan(eycrd.y,eycrd.z) + dot(sin(eycrd.yz*11.),sin(eycrd.yz*25.))*.05;\n    garble = (sin(garble*50.)+sin(garble*131.))*.2+.9;\n    \n    vec3 ldir = normalize(lpos-p);\n    float ao = smoothstep(12.,6.,length(p));\n    float nd = dot(ldir,n)*.5+.5;\n    float rd = max(0.,dot(ldir,n));\n    float fres = 1.-abs(dot(cam,n))*.98;\n    vec3 ecol = vec3(0.3,0.4,0.7);\n    float sd1 = hash(hash(lid.x,lid.y),lid.z);\n    float sd2 = hash(sd1,sd1);\n    ecol = erot(ecol, vec3(0,1,0), sd2);\n    ecol = erot(ecol, vec3(1,0,0), sd1*.4)*garble;\n    float atten = 3./pow(distance(p,lpos),1.4) + .4/pow(length(vec2(length(p.xy)-1.8, p.z+3.2)), 1.2);\n    \n    vec3 dcol = mix(vec3(.9),ecol, smoothstep(.8,.9,ey));\n    dcol = mix(dcol,vec3(0), smoothstep(.95,.98,ey));\n    \n    if (pd) dcol = vec3(0.5,0.4,0.3)*(dbgg*.25+.75);\n    vec3 col = (dcol*nd + pow(smoothstep(.7,1.,rd),100.)*fres*1.2)*ao*atten;\n    if (distance(lpos,p) < .4) {\n        col = vec3(0.2,0.5,0.9);\n    }\n    if (tc) col = vec3(0.8,0.5,0.2);\n    fragColor.xyz = (hit ? col : vec3(.1))+glo*glo + glo*vec3(0.2,0.5,0.9) +glo2*glo2 + glo2*vec3(0.8,0.5,0.2);\n    fragColor = smoothstep(vec4(0.1),vec4(1.02),sqrt(fragColor));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}