{
    "Shader": {
        "info": {
            "date": "1635002927",
            "description": "For SDF Sculptors!\nI've noticed the curvature is useful as a visual debug with complex SDF modelling.\nI've mostly just copied and pasted Evan's postprocess code.\n\"Screen Space Curvature Shader\" by Evan Wallace:\nhttp://madebyevan.com/shaders/curvature/",
            "flags": 0,
            "hasliked": 0,
            "id": "fsGXzc",
            "likes": 50,
            "name": "Curvature shader",
            "published": 3,
            "tags": [
                "modeling",
                "debug",
                "curvature",
                "sculpting"
            ],
            "usePreview": 0,
            "username": "iY0Yi",
            "viewed": 1927
        },
        "renderpass": [
            {
                "code": "// \"Screen Space Curvature Shader\" by Evan Wallace:\n// http://madebyevan.com/shaders/curvature/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Change shading type\n#define CURVATURE 0\n#define METAL 0\n#define RED_WAX 1\n\n\n// Shoe Model from my shader.\n// \"A man from 'A LOST MEMORY'\" by iYOYi:\n// https://www.shadertoy.com/view/Ws3yW4\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define PI 3.14159265\n#define TAU (2.0*PI)\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define MIN_DIST 0.001\n#define MAX_DIST 30.0\n#define ITERATION 100\n\n#define SHOW_ANIM 0\nvec3 ro = vec3(0), rd = vec3(0);\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n    R(p.xz, r.y);\n    R(p.yx, r.z);\n    R(p.zy, r.x);\n    return p;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 n, int rep){\n    float sum = 0.0;\n    float amp= 1.0;\n    for (int i = 0; i <rep; i++){\n        sum += noise(n) * amp;\n        n += n*4.0;\n        amp *= 0.25;\n    }\n    return sum;\n}\n\n// SDF functions by iq and HG_SDF\n// https://iquilezles.org/articles/distfunctions\n// https://mercury.sexy/hg_sdf/\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat vmax(vec3 v){\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) {\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedTorus(vec3 p, vec2 r, float per) {\n    p.x = abs(p.x);\n    vec2 sc = vec2(sin(per),cos(per));\n    float k = (sc.y*p.x>sc.x*p.z) ? dot(p.xz,sc) : length(p.xz);\n    return sqrt( dot(p,p) + r.x*r.x - 2.0*r.x*k ) - r.y;\n}\n\nfloat sdBox(vec3 p,vec3 b) {\n    vec3 d=abs(p)-b;\n    return length(max(d,vec3(0)))+vmax(min(d,vec3(0.0)));\n}\n\nfloat fOpUnion(in float a,in float b) {\n    return a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b) {\n    return a.x<b.x?a:b;\n}\n\nfloat fOpUnionSmooth(float a,float b,float r) {\n    vec2 u = max(vec2(r - a,r - b), vec2(0));\n    return max(r, min (a, b)) - length(u);\n}\n\nfloat fOpSubstraction(in float a,in float b) {\n    return max(-a, b);\n}\n\nfloat fOpSubstractionSmooth( float a,float b,float r) {\n    vec2 u = max(vec2(r + b,r + -a), vec2(0));\n    return min(-r, max (b, -a)) + length(u);\n}\n\nvoid pElongate(inout float p, in float h ) {\n    p = p-clamp(p,-h,h);\n}\n\nfloat sdFoot(vec3 p) {\n\tfloat d = MAX_DIST;\n\tfloat bsd = length(p), bsr=0.2500;\n\tif (bsd > 2.*bsr) return bsd-bsr;\n    \n\tvec3 cpFoot = p;\n\t{\n\t\tvec3 q = cpFoot;\n#if SHOW_ANIM\n        float patapata = -q.z*(sin(iTime*5.)*.5+.05)+cos(iTime*5.)*.5;\n#else\n        float patapata = -.3;\n#endif\n        q.yz*=mat2(cos(-q.z*1.25+patapata+vec4(0,11,33,0)));\n        cpFoot=q;\n\t}\n\tvec3 cpFoot_Main = cpFoot;\n\tcpFoot_Main.xyz += vec3(0.0000, 0.0000, 0.1273);\n\tpElongate(cpFoot_Main.y, 0.0125);\n\t{\n\t\tvec3 q=cpFoot_Main;\n        vec3 pq=q;pq.yz *= mat2(cos(.6 + vec4(0, 11, 33, 0)));\n        float ycl = smoothstep(.002,.2,q.y);\n        float zcl = 1.-smoothstep(-.2,.5,q.z);\n        float zcl2 = smoothstep(-.2,.0,q.z);\n        q.z+=fbm(vec2(pq.x*20.5,pq.y*80.), 1)*.075*ycl*zcl*zcl2;\n        cpFoot_Main=q;\n\t}\n\n    // Shoe\n    float d1,d2;\n\td1 = sdEllipsoid(rot(cpFoot_Main+vec3(-0.0005, 0.0274, 0.1042), vec3(0.0818, -0.6861, 0.0566)), vec3(0.1102, 0.1233, 0.1214));\n\td1 = fOpUnionSmooth(sdEllipsoid(rot(cpFoot_Main+vec3(0.0028, -0.0093, -0.1258), vec3(-0.0291, -0.2744, -0.0364)), vec3(0.0870, 0.2295, 0.0880)), d1, 0.1438);\n\td1 = fOpSubstractionSmooth(sdBox(cpFoot+vec3(0.0000, -0.194, 0.0019), vec3(0.1676, 0.0551, 0.1171)), d1, 0.0100);\n    d1 = fOpSubstractionSmooth(dot(cpFoot_Main, vec3(0,1,0)) - .001, d1, 0.0080);\n\td1 = fOpSubstraction(sdBox(rot(cpFoot+vec3(0.0000, 0.0171, 0.1521), vec3(-1.4413, 0.0000, 0.0000)), vec3(0.1676, 0.0912, 0.0116)), d1);\n\td1 = fOpUnionSmooth(sdCappedTorus(cpFoot+vec3(0.0028, -0.1578, 0.0014), vec2(0.0519, 0.0264), 3.1413), d1, 0.0100);\n\t\n\t// Shoe lace\n\td2 = sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0579, 0.1827), vec3(1.5708, 0.0000, 0.0000)), vec2(0.0636, 0.0064), 0.6283);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2401, -0.3407, 0.2843)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7335, 0.4446, -0.0513)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.1001, 0.0608), vec3(2.2463, 0.3180, -0.2669)), vec2(0.0636, 0.0064), 0.6283), d2);\n\td2 = fOpUnion(sdCappedTorus(rot(cpFoot+vec3(0.0000, -0.0639, 0.1321), vec3(1.7334, -0.4468, 0.0515)), vec2(0.0636, 0.0064), 0.6283), d2);\n\t\n\treturn min(d1,d2);\n}\n\nfloat sdScene(vec3 p) {\n    return sdFoot(p);\n}\n\nfloat intersect() {\n    float d = MIN_DIST;\n\n    for (int i = 0; i < ITERATION; i++) {\n        vec3 p = ro + d * rd;\n        float res = sdScene(p);\n        res*=.5;\n        if (abs(res) < MIN_DIST)break;\n        d += res;\n        if (d >= MAX_DIST) return MAX_DIST;\n    }\n    if(d>MAX_DIST) return MAX_DIST;\n    return d;\n}\n\n// from iq's shader\nvec3 normal(vec3 p) {\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ ) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\n// Camera localized normal\nvec3 campos, camup;\nvec3 localNormal(vec3 p) {\n    vec3 n = normal(p), ln;\n    vec3 side = cross(campos, camup);\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -rd));\n}\n\n// \"camera\": create camera vectors.\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 10.;\n    const vec3 forcus = vec3(0,.08,-.137);\n    const float fov = .015;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,0);\n    pos.xz = vec2(sin(iTime*.6),cos(iTime*.6))*cL;\n    if(iMouse.z>.5)\n        pos = vec3(sin(iMouse.x/iResolution.x*TAU),sin(iMouse.y/iResolution.y*TAU),cos(iMouse.x/iResolution.x*TAU))*cL;\n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\tcampos = cw, camup = cv;\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv*2.-1.);\n    uv.x *= iResolution.x / iResolution.y;\n\n    camera(uv);\n    float hit = intersect();\n    vec3 p = ro + hit * rd;\n\n    vec3 n = localNormal(p);\n    float depth = distance(ro, p)/MAX_DIST;\n    \n    // I've mostly just copied and pasted Evan's code.\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\t// Compute curvature\n\tvec3 dx = dFdx(n);\n\tvec3 dy = dFdy(n);\n\tvec3 xneg = n - dx;\n\tvec3 xpos = n + dx;\n\tvec3 yneg = n - dy;\n\tvec3 ypos = n + dy;\n\tfloat curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 2.0 / (depth*5.);\n\n\t// Compute surface properties\n    #if CURVATURE\n        vec3 light = vec3(0.0);\n        vec3 ambient = vec3(curvature + 0.5);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        float shininess = 0.0;\n    #elif METAL\n        float corrosion = clamp(-curvature * 3.0, 0.0, 1.0);\n        float shine = clamp(curvature * 5.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.15, 0.1, 0.1)*.5;\n        vec3 diffuse = mix(mix(vec3(0.3, 0.25, 0.2), vec3(0.45, 0.5, 0.5), corrosion),\n        vec3(0.5, 0.4, 0.3), shine) - ambient;\n        vec3 specular = mix(vec3(0.0), vec3(1.0) - ambient - diffuse, shine);\n        float shininess = 128.0;\n    #elif RED_WAX\n        float dirt = clamp(0.25 - curvature * 4.0, 0.0, 1.0);\n        vec3 light = normalize(vec3(0.0, 1.0, 10.0));\n        vec3 ambient = vec3(0.05, 0.015, 0.0);\n        vec3 diffuse = mix(vec3(0.4, 0.15, 0.1), vec3(0.4, 0.3, 0.3), dirt) - ambient;\n        vec3 specular = mix(vec3(0.15) - ambient, vec3(0.0), dirt);\n        float shininess = 32.0;\n    #endif\n    \n    // Compute final color\n    float cosAngle = dot(n, light);\n    fragColor.rgb = ambient +\n    diffuse * max(0.0, cosAngle) +\n    specular * pow(max(0.0, cosAngle), shininess);\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    \n    fragColor.rgb = pow(fragColor.rgb*1.5, vec3(.9));\n    if(depth>.9) fragColor.rgb = vec3(.125);\n\tfragColor.a = 1.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}