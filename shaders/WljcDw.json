{
    "Shader": {
        "info": {
            "date": "1594544092",
            "description": "Interactively explore Mandelbrot and Julia sets (computed with emulated double precision) - see source for usage",
            "flags": 32,
            "hasliked": 0,
            "id": "WljcDw",
            "likes": 14,
            "name": "Mandelbrot and Julia Explorer",
            "published": 3,
            "tags": [
                "fractal",
                "interactive",
                "precision",
                "ui",
                "double"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "// \"Mandelbrot and Julia Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Interactively explore Mandelbrot and Julia sets (computed with emulated double precision)\n \n See \"Mandelbrot Trillion-Fold Zoom\" and \"Julia Set Trillion-Fold Zoom\" for background.\n \n Usage -\n \n Buttons: cyan - color mode; green/red - select Mandelbrot or Julia modes ; blue - reset.\n Rings: green - shift display midpoint; red (only in Julia mode) - vary Julia parameters.\n Slider: vary zoom level.\n \n When switching to Julia mode the parameters are set to the current Mandelbrot midpoint\n (starting in the black is not a good idea).\n Reduced iteration count at low zoom (too much black causes slowdown).\n Reset sets parameters to their original values.\n Best color mode depends on scene parameters.\n Prior to mouse click the shader automatically cycles through all modes at low zoom levels.\n Scale factor is shown (log).\n*/\n\n#define AA   0  // set = 1 for antialiasing (recommended, slower)\n\n#define DP_VERS  1   // set in both shaders (= 0 for single precision)\n\n#if DP_VERS\nvec2 DvAdd (vec2 va, vec2 vb);\nvec2 DvSub (vec2 va, vec2 vb);\nvec2 DvMul (vec2 va, vec2 vb);\nvec2 DvFromF (float a);\nvoid DvInit ();\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\n\nvec2 wgVal[3];\nvec2 xMidv, yMidv, xJulv, yJulv;\nfloat nFrameF, scale, colTyp;\nint nFrame;\nbool isJulia;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  float ns, itLim, xyLim, w;\n  bool smoothCut;\n#if DP_VERS\n  vec2 x, y, xx, yy, cx, cy;\n#else\n  float x, y, xx, yy, cx, cy;\n#endif\n  if (isJulia) {   // = 1for linux\n#if DP_VERS\n    x = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n    y = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n    cx = xJulv;\n    cy = yJulv;\n#else\n    x = uv.x * scale + xMidv.x;\n    y = uv.y * scale + yMidv.x;\n    cx = xJulv.x;\n    cy = yJulv.x;\n#endif\n  } else {\n#if DP_VERS\n    x = DvFromF (0.);\n    y = DvFromF (0.);\n    cx = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n    cy = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n#else\n    x = 0.;\n    y = 0.;\n    cx = uv.x * scale + xMidv.x;\n    cy = uv.y * scale + yMidv.x;\n#endif\n  }\n#if DP_VERS\n  const float nsMax = 8192.;\n  w = (cx.x + 0.25) * (cx.x + 0.25) + cy.x * cy.x;\n#else\n  const float nsMax = 1024.;\n  w = (cx + 0.25) * (cx + 0.25) + cy * cy;\n#endif\n  ns = 0.;\n  col = vec3 (0.2);\n  if (w > 0.25) {\n    smoothCut = true;\n    if (scale <= 1./128.) itLim = isJulia ? 0.5 * nsMax : nsMax;\n    else itLim = isJulia ? 512. : 256.;\n    xyLim = smoothCut ? 256. * 256. : 4.;\n    for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n      ++ ns;\n#if DP_VERS\n      xx = DvMul (x, x);\n      yy = DvMul (y, y);\n      y = DvMul (x, y);\n      y = DvAdd (DvAdd (y, y), cy);\n      x = DvAdd (DvSub (xx, yy), cx);\n      if (DvAdd (xx, yy).x > xyLim || ns == itLim) break;\n#else\n      xx = x * x;\n      yy = y * y;\n      y = 2. * x * y + cy;\n      x = xx - yy + cx;\n      if (xx + yy > xyLim || ns == itLim) break;\n#endif\n    }\n    if (ns < itLim) {\n      if (smoothCut) {\n#if DP_VERS\n        ns -= log2 (log2 (DvAdd (xx, yy).x)) - 4.;\n#else\n        ns -= log2 (log2 (xx + yy)) - 4.;\n#endif\n      }\n      if      (colTyp == 0.) col = HsvToRgb (vec3 (mod (sqrt (ns) / 8., 1.), 1., 1.));\n      else if (colTyp == 1.) col = HsvToRgb (vec3 (mod (ns / 512., 1.), 1., 1.));\n      else if (colTyp == 2.) col = 0.55 + 0.45 * cos (3. + vec3 (0., 0.5, 1.) + 0.5 * sqrt (ns));\n      else if (colTyp == 3.) col = HsvToRgb (vec3 (mod (0.5 * log2 (ns) +\n         mod (0.001 * nFrameF, 1.), 1.), 1., 1.));\n      else if (colTyp == 4.) col = mix (vec3 (1.), vec3 (0.2), floor (mod (ns, 2.)));\n      else if (colTyp == 5.) col = mix (vec3 (1.), vec3 (0.2), floor (mod (4. * log2 (ns), 2.)));\n    }\n  }\n  return col;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 wgBx[6];\n  vec3 cc, c;\n  vec2 ut;\n  float asp, s;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.39, 0.15, 0.135, 0.);\n  wgBx[1] = vec4 (-0.39, 0.15, 0.135, 0.);\n  wgBx[2] = vec4 (0.39, -0.22, 0.03, 0.15);\n  wgBx[3] = vec4 (0.39, 0.4, 0.025, 0.025);\n  wgBx[4] = vec4 (-0.39, 0.4, 0.025, 0.025);\n  wgBx[5] = vec4 (-0.39, -0.4, 0.025, 0.025);\n  cc = vec3 (1., 0., 0.);\n  for (int k = 0; k <= 1; k ++) {\n    if (k == 0 || k == 1 && isJulia) {\n      ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n      s = (length (ut) - wgBx[k].z) * canvas.y;\n      if (s < 0.) {\n        c = (k == 0) ? cc.yxy : cc;\n        col = (s > -2. || min (abs (ut.x), abs (ut.y)) * canvas.y < 1.) ? c :\n           mix (vec3 (1.), c, 0.3);\n        col = mix (c.grb, col, smoothstep (1.5, 2.5, abs (length (ut - wgVal[k]) - 0.015) *\n           canvas.y));\n      }\n    }\n  }\n  for (int k = 2; k <= 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n    s = max (abs (ut.x)- wgBx[k].z, abs (ut.y) - wgBx[k].w) * canvas.y;\n    if (s < 0.) {\n      col = (s > -2. || abs (ut.y) * canvas.y < 1.) ? cc.yxy : mix (vec3 (1.), cc.yxy, 0.3);\n      col = mix (cc, col, smoothstep (1.5, 2., abs (length (ut - wgVal[k]) - 0.015) * canvas.y));\n    }\n  }\n  for (int k = 3; k <= 5; k ++) { \n    ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n    s = max (abs (ut.x) - wgBx[k].z, abs (ut.y) - wgBx[k].w) * canvas.y;\n    if (s < 0.) {\n      c = (k == 4) ? (isJulia ? cc : cc.yxy) : ((k == 3) ? cc.yxx : cc.yyx);\n      col = (s > -2.) ? c : mix (vec3 (1.), c, 0.3);\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat;\n  vec3 col;\n  vec2 canvas, uv;\n  float asp, sr;\n  bool mouseDn;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  nFrameF = float (nFrame);\n  stDat = Loadv4 (0);\n  mPtr.z = stDat.z;\n  stDat = Loadv4 (1);\n  wgVal[0] = stDat.xy;\n  wgVal[2] = stDat.zw;\n  stDat = Loadv4 (2);\n  xMidv = stDat.xy;\n  yMidv = stDat.zw;\n  mouseDn = (mPtr.z > 0.);\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (3);\n  scale = stDat.x;\n  colTyp = stDat.z;\n  stDat = Loadv4 (4);\n  wgVal[1] = stDat.xy;\n  isJulia = (stDat.z > 0.);\n  stDat = Loadv4 (5);\n  xJulv = stDat.xy;\n  yJulv = stDat.zw;\n#if DP_VERS\n  DvInit ();\n#endif\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene ( uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi));\n    }\n  } else col = vec3 (0.82);\n  col = ShowWg (uv, canvas, col);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.41 * asp, -0.47),\n      vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  if (mouseDn) {\n    uv = abs (uv) * canvas.y;\n    if (max (max (uv.x, uv.y) - 15., min (uv.x, uv.y) - 2.) < 0.) col = 1. - col;\n  }\n  fragColor = vec4 (col, 1.);\n}\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1   // set = 0 if GLSL compiler conforms (else get sp results), or for linux\n#define LESS_BAD_FP 0   // optional = 1 for linux: linux/nvidia(binary) and linux/intel(mesa)\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)  // must be 1\n\n#if ! BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return a + b;\n}\n\nfloat FFSub (float a, float b)\n{\n  return a - b;\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvoid DvInit ()\n{\n#if REAL_BAD_FP \n  nFrameF1 = nFrameF + 1.;\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n}\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if ! BAD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = - FFSub (FFSub2 (ma, va.x), ma);\n  sb1 = - FFSub (FFSub2 (mb, vb.x), mb);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Mandelbrot and Julia Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define DP_VERS  1   // set in both shaders\n\n#if DP_VERS\nvec2 DvAdd (vec2 va, vec2 vb);\nvec2 DvFromF (float a);\nvoid DvInit ();\n#endif\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat nFrameF;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, wgBx[6];\n  vec2 iFrag, canvas, wgVal[3], ut, xMidv, yMidv, xJulv, yJulv,\n     xMidvMS, yMidvMS, xMidvJS, yMidvJS, xJulvS, yJulvS;\n  float tCur, asp, scale, sclLim, sclFac, colTyp, autoMd;\n  int pxId, nFrame;\n  bool isJulia;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = iTime;\n  nFrame = iFrame;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 6) discard;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n  wgBx[0] = vec4 (0.39, 0.15, 0.135, 0.);\n  wgBx[1] = vec4 (-0.39, 0.15, 0.135, 0.);\n  wgBx[2] = vec4 (0.39, -0.22, 0.03, 0.15);\n  wgBx[3] = vec4 (0.39, 0.4, 0.025, 0.025);\n  wgBx[4] = vec4 (-0.39, 0.4, 0.025, 0.025);\n  wgBx[5] = vec4 (-0.39, -0.4, 0.025, 0.025);\n  xMidvMS = vec2 (-1.2499080e+07 / (4096. * 4096.), 6.4092e-09);\n  yMidvMS = vec2 (2.2692490e+06 / (4096. * 4096.),  4.4428e-08);\n  xMidvJS = vec2 (-3.0709070e+06 / (4096. * 4096.), 4.0579e-08);\n  yMidvJS = vec2 (6.7450760e+06 / (4096. * 4096.),  4.2139e-08);\n  xJulvS = vec2 (2.7101420e+06 / (4096. * 4096.), 2.2352e-08);\n  yJulvS = vec2 (9.9288270e+06 / (4096. * 4096.), 2.4958e-08);\n  if (nFrame <= 5) {\n    mPtrP = mPtr;\n    autoMd = 1.;\n    wgVal[0] = vec2 (0.);\n    wgVal[2] = vec2 (0.);\n    xMidv = xMidvMS;\n    yMidv = yMidvMS;\n    scale = 2.;\n    sclFac = 1.;\n    colTyp = 0.;\n    wgVal[1] = vec2 (0.);\n    isJulia = false;\n    xJulv = xJulvS;\n    yJulv = yJulvS;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    autoMd = stDat.w;\n    stDat = Loadv4 (1);\n    wgVal[0] = stDat.xy;\n    wgVal[2] = stDat.zw;\n    stDat = Loadv4 (2);\n    xMidv = stDat.xy;\n    yMidv = stDat.zw;\n    stDat = Loadv4 (3);\n    scale = stDat.x;\n    sclFac = stDat.y;\n    colTyp = stDat.z;\n    stDat = Loadv4 (4);\n    wgVal[1] = stDat.xy;\n    isJulia = (stDat.z > 0.);\n    stDat = Loadv4 (5);\n    xJulv = stDat.xy;\n    yJulv = stDat.zw;\n  }\n#if DP_VERS\n  DvInit ();\n#endif\n  if (mPtr.z > 0.) {\n    if (autoMd > 0.) {\n      autoMd = 0.;\n      xMidv = xMidvMS;\n      yMidv = yMidvMS;\n      isJulia = false;\n      colTyp = 0.;\n      scale = 2.;\n    }\n  }\n  if (autoMd > 0.) {\n    isJulia = (floor (2. * mod (0.1 * tCur, 2.) - 1.) > 0.);\n    if (isJulia) {\n      xMidv = xMidvJS;\n      yMidv = yMidvJS;\n    } else {\n      xMidv = xMidvMS;\n      yMidv = yMidvMS;\n    }\n    colTyp = floor (6. * mod (0.1 * tCur, 1.));\n    scale = 2. * pow (0.25, 4. * mod (0.1 * tCur, 1.));\n  }\n  if (mPtr.z > 0.) {\n    ut = (mPtr.xy - wgBx[0].xy) * vec2 (asp, 1.);\n    wgVal[0] = (length (ut) < wgBx[0].z && length (ut) > 0.) ? ut : vec2 (0.);\n    if (isJulia) {\n      ut = (mPtr.xy - wgBx[1].xy) * vec2 (asp, 1.);\n      wgVal[1] = (length (ut) < wgBx[1].z && length (ut) > 0.) ? ut : vec2 (0.);\n    }\n    ut = (mPtr.xy - wgBx[2].xy) * vec2 (asp, 1.);\n    wgVal[2] = (abs (ut.x) < wgBx[2].z && abs (ut.y) < wgBx[2].w && abs (ut.y) > 0.) ?\n       vec2 (0., ut.y) : vec2 (0.);\n    ut = (mPtr.xy - wgBx[3].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[3].z, abs (ut.y) - wgBx[3].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        if (++ colTyp > 5.) colTyp = 0.;\n      }\n    }\n    ut = (mPtr.xy - wgBx[4].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[4].z, abs (ut.y) - wgBx[4].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        isJulia = ! isJulia;\n        if (isJulia) {\n          if (xMidv.x != 0. && yMidv.x != 0.) {\n            xJulv = xMidv;\n            yJulv = yMidv;\n          } else {\n            xJulv = xJulvS;\n            yJulv = yJulvS;\n          }\n          xMidv = vec2 (-0.05, 0.);\n          yMidv = vec2 (0.);\n        } else {\n          xMidv = vec2 (-0.75, 0.);\n          yMidv = vec2 (0.);\n        }\n        scale = 2.;\n        sclFac = 1.;\n      }\n    }\n    ut = (mPtr.xy - wgBx[5].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[5].z, abs (ut.y) - wgBx[5].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        if (isJulia) {\n          xMidv = xMidvJS;\n          yMidv = yMidvJS;\n          xJulv = xJulvS;\n          yJulv = yJulvS;\n        } else {\n          xMidv = xMidvMS;\n          yMidv = yMidvMS;\n        }\n        scale = 2.;\n        sclFac = 1.;\n      }\n    }\n  } else {\n    wgVal[0] = vec2 (0.);\n    wgVal[1] = vec2 (0.);\n    wgVal[2] = vec2 (0.);\n  }\n  if (nFrame > 5) {\n    sclFac = 1. - (1./64.) * clamp (wgVal[2].y / wgBx[2].z, -1., 1.);\n    scale *= sclFac;\n#if DP_VERS\n    sclLim = isJulia ? 1e-11 : 1e-12;\n#else\n    sclLim = 1e-5;\n#endif\n    scale = clamp (scale, 2. * sclLim, 2.);\n#if DP_VERS\n    xMidv = DvAdd (xMidv, DvFromF ((1./8.) * scale * wgVal[0].x));\n    yMidv = DvAdd (yMidv, DvFromF ((1./8.) * scale * wgVal[0].y));\n#else\n    xMidv.x += (1./8.) * scale * wgVal[0].x;\n    yMidv.x += (1./8.) * scale * wgVal[0].y;\n#endif\n    if (isJulia) {\n#if DP_VERS\n      xJulv = DvAdd (xJulv, DvFromF ((1./1024.) * scale * wgVal[1].x));\n      yJulv = DvAdd (yJulv, DvFromF ((1./1024.) * scale * wgVal[1].y));\n#else\n      xJulv.x += (1./1024.) * scale * wgVal[1].x;\n      yJulv.x += (1./1024.) * scale * wgVal[1].y;\n#endif\n    }\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, autoMd);\n  else if (pxId == 1) stDat = vec4 (wgVal[0], wgVal[2]);\n  else if (pxId == 2) stDat = vec4 (xMidv, yMidv);\n  else if (pxId == 3) stDat = vec4 (scale, sclFac, colTyp, 0.);\n  else if (pxId == 4) stDat = vec4 (wgVal[1], (isJulia ? 1. : 0.), 0.);\n  else if (pxId == 5) stDat = vec4 (xJulv, yJulv);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1\n#define LESS_BAD_FP 0\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)\n\n#if ! BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return a + b;\n}\n\nfloat FFSub (float a, float b)\n{\n  return a - b;\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvoid DvInit ()\n{\n#if REAL_BAD_FP \n  nFrameF1 = nFrameF + 1.;\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n}\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}