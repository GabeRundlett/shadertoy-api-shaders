{
    "Shader": {
        "info": {
            "date": "1465315384",
            "description": "Use the mouse to rotate\n\nI will try to improve the performance later...",
            "flags": 0,
            "hasliked": 0,
            "id": "MdKSWm",
            "likes": 22,
            "name": "Post-mortem Death Star",
            "published": 3,
            "tags": [
                "raymarching",
                "starwars",
                "deathstar"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 1380
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define SPHERES 6\n#define REFLECTIONS 0\n\n#define saturate(x) clamp(x, 0., 1.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nfloat hash(vec3 uv) {\n  float f = fract(cos(sin(dot(uv ,vec3(.009123898,.00231233, .00532234))) * 480.512353) * 11111.5452313);\n    return f;\n}\n\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 8; ++i) {\n        f += noise((uv + 10.) * vec3(r, r, r)) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// distance function\nfloat map(vec3 p) {\n    float sphere = length(p) - 1.;\n    float f = fbm(p * vec3(1,3,3));\n    sphere = max(f - p.x / 3.  - .6, sphere);\n    sphere = max(-length(p - vec3(1.)) + .85, sphere);\n    sphere = max(sphere, -abs(p.y) + .01);\n    sphere = min(sphere, -length(p) + 5.);\n    return sphere;\n}\n\n// raymarching function\nfloat trace(vec3 o, vec3 r, int steps) {\n    float t = 0.;\n    for (int i = 0; i < 100; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < .0001 || t > 10. || i > steps) break;\n    }\n    return t;\n}\n\n\nvec3 tex(vec2 uv) {\n    vec3 c = vec3(0);\n    if (abs(abs(uv.y - .5) - .22) > .2 || fract(uv.y * 10.) < .1) {\n        c = vec3(.25);\n    } else {\n        float l = floor(uv.y * 10.);\n        c = vec3(\n            smoothstep(.6, .7, noise(vec3(uv.x * 300.,1, l))) / 8. + .125\n        );\n    }\n    return c;\n}\n\n// apply texture ( fbm + stripes )\nvec3 texSphere(vec3 p) {\n    float l = length(p);\n    float ratio = smoothstep(.99, 1.01, l);\n    p = normalize(p);\n    vec2 uv = vec2(.5 + atan(p.z, p.x) / PI / 2., .5 - asin(p.y) / PI);\n    vec3 c = mix(vec3(fbm(p * 20.) / 10. + .125), tex(uv), ratio);\n    return c * (.5 + smoothstep(0., .002, abs(l - .89)) / 4. + smoothstep(0., .005, abs(l - .99)) / 4.);\n}\n\n// rendering function: o - ray origin, r - ray vector, dist - distance traveled, steps - raymarching iterations\nvec3 render(inout vec3 o, inout vec3 r, inout float dist, in int steps) {\n    \n    // march to first object\n    float f = trace(o, r, steps);\n    \n    // get intersection point\n    vec3 p = o + f * r;\n    \n    // get normal vector\n    vec2 eps = vec2(0, .0001);\n    vec3 normal = normalize(vec3(\n    \tmap(p + eps.yxx) - map(p - eps.yxx),\n    \tmap(p + eps.xyx) - map(p - eps.xyx),\n    \tmap(p + eps.xxy) - map(p - eps.xxy)\n\t));\n    \n    // light source\n    vec3 ls = vec3(0, 0, 2);\n    ls.xz *= rot(iTime * .1);\n    ls.xy *= rot(.3);\n    vec3 light = normalize(ls);\n    \n    // reflection point\n    vec3 ref = reflect(r,normal);\n    \n    vec3 color = vec3(0);\n    \n    if (length(p) < 2.) {\n        // add ambient light (hue from angle)\n        color += saturate(texSphere(p) * dot(p,p));\n\n        // calculate shadow\n        float s = trace(p + light * .01, light, steps);\n\n        if (s > 1.) {\n\t\n            // add diffuse light\n            color += vec3(dot(normal, light)) * .5;\n\n            // add specular light\n            //color += saturate(vec3(pow(saturate(dot(light, ref)), 8.)) / 2.);\n            \n        }\n    } else {\n        vec3 np = p;\n        np.xz *= rot(-iTime* .1);\n        np.xy *= rot(-.3);\n        color = smoothstep(.9, 1., vec3(noise(np * 10.)));\n        color += vec3(pow(saturate(dot(normal, -light)), 100.));\n    }\n        \n    // new origin becomes the point hit\n    o = p;\n    \n    // new ray vector becomes the reflection vector\n    r = normalize(ref);\n    \n    // go a bit further on the ray, so we don't hit the same surface\n    o += r * .1;\n    \n    // add marched distance to distance traveled\n    f = max(0., f);\n    dist += f;\n    \n    // return divided by the fog\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // transform viewport coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray from screen coordinates\n    vec3 r = normalize(vec3(uv, 3.));\n    \n    // eye for origin\n    vec3 o = vec3(0, 0, -4);\n    \n    // transform mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n\n    mouse *= PI * 2.;\n    \n    // rotate camera around the center\n    float a = (iMouse.z > 0.) ? -mouse.y : .3;\n    o.yz *= rot(a);\n    r.yz *= rot(a);\n    a = (iMouse.z > 0.) ? -mouse.x : 3.2;// + iTime * .5;\n    o.xz *= rot(a);\n    r.xz *= rot(a);\n    \n    float f = 0.;\n    int steps = 100;\n    \n    // render scene\n    vec3 c = render(o, r, f, steps);\n    \n    // render reflections\n    for (int i = 0; i < REFLECTIONS; ++i) {\n        steps /= 2;\n    \tc += c * render(o, r, f, steps);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}