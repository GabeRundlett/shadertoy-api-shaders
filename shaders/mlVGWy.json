{
    "Shader": {
        "info": {
            "date": "1684608523",
            "description": "Balls rolling on a hexagonal grid of variable-height spherocylinders  (mouse in upper-right to reset balls)",
            "flags": 32,
            "hasliked": 0,
            "id": "mlVGWy",
            "likes": 23,
            "name": "Grid-Surfing Balls",
            "published": 3,
            "tags": [
                "wave",
                "dynamics",
                "physics",
                "surface"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 300
        },
        "renderpass": [
            {
                "code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  In addition to collisions with each other and the surface, balls experience\n  gravity and a weak force pulling them towards the grid midpoint.\n  (Based on mix of \"Hexagonally Discretized Waves\", \"Rolling Stones\", etc)\n\n  (No.92 in \"Physical Dynamics\" series - listed at end)\n\nNotes:\n\n   The simulation is tuned for the approx range 50-100 fps; too\n   slow and it won't look good.\n\n   Collisions are highly inelastic, otherwise you see bouncing balls\n   instead of surfing and rolling.\n\n   Two different 'clocks' are required to ensure both numerical stability\n   of the ball dynamics (based on frame counter) as well as decent wave\n   motion visuals independent of GPU speed (wall clock).\n\n   Wave speed can be changed via the parameter 'wtFac' in all Buffers.\n\n   Effective ball speed can be reduced via the timestep parameter 'dt'\n   in all Buffers or by removing Buffers (C/B), and increased by adding\n   an identical Buffer D as in previous shaders of this kind.\n\n   Other parameters are from earlier shaders and should be ok.\n*/\n\n#define AA       0  // (= 0/1) optional antialiasing\n#define SHADOWS  0  // (= 0/1) optional shadows\n\n#define VAR_ZERO min (nFrame, 0)\n\nmat3 QtToRMat (vec4 q);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv2 (vec2 p);\nfloat Minv3 (vec3 p);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\n\nvec3 qHit, vnBall, ltDir;\nvec2 cId, cMid;\nfloat dstFar, tCur, hgSize, wavHt, whFac, wtFac;\nint nFrame, idObj, idBall, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat ObjDf (vec3 p)\n{\n  float h, sy;\n  sy = 5.;\n  h = p.y - wavHt + sy;\n  return min (length (vec3 (p.xz - cMid, sign (h) * max (abs (h) - sy, 0.))) -\n     (hgSize * 0.5 * sqrt3 - 0.005), p.y + 2. * sy);\n}\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid SetConf ()\n{\n  cMid = HexToPix (cId * hgSize);\n  wavHt = WaveHt (cMid);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM;\n  float dHit, d, s, eps;\n  bool cNu;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.001;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  dHit = 0.;\n  cId = PixToHex (ro.xz / hgSize);\n  pM = HexToPix (cId);\n  cNu = true;\n  for (int j = VAR_ZERO; j < 400; j ++) {\n    if (j == 0 || cNu) {\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n      SetConf ();\n      cNu = false;\n    }\n    d = ObjDf (ro + dHit * rd);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      cId = PixToHex ((ro.xz + dHit * rd.xz) / hgSize);\n      pM += sqrt3 * edN[(s == hv.x) ? 0 : ((s == hv.y) ? 1 : 2)];\n      cNu = true;\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BallHit (vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnBall = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh (vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    u = ro - p.xyz;\n    rad = 0.5 * p.w;\n    b = dot (rd, u);\n    w = b * b - dot (u, u) + rad * rad;\n    if (w > 0.) {\n      d = - b - sqrt (w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return 0.5 + 0.5 * smoothstep (0., rng, dMin);\n}\n\nfloat BallChqr (int idBall, vec3 vnBall)\n{\n  vec3 u;\n  u = vnBall * QtToRMat (Loadv4 (4 * idBall + 2 + 2));\n  return 0.7 + 0.3 * step (0., sign (u.y) * sign (u.z) * atan (u.x, u.y));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstBall, h, sh;\n  dstObj = ObjRay (ro, rd);\n  dstBall = BallHit (ro, rd);\n  bgCol = vec3 (0.4, 0.4, 0.5);\n  col = bgCol;\n  sh = 1.;\n  if (min (dstBall, dstObj) < dstFar) {\n    if (dstObj < dstBall) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      col4 = vec4 (HsvToRgb (vec3 (0.05 + 0.9 * fract (ro.y / (2.6 * whFac)), 0.4, 1.)), 0.);\n#if SHADOWS\n      sh = BallHitSh (ro + 0.01 * vn, ltDir, 5.);\n#endif\n    } else {\n      ro += dstBall * rd;\n      vn = vnBall;\n      col4 = vec4 (vec3 (1., 0.3, 0.1) * BallChqr (idBall, vnBall), 0.2);\n    }\n    col = col4.rgb * (0.2 + 0.2 * max (dot (vn, ltDir * vec3 (-1., 1., -1.)), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (reflect (ltDir, vn), rd), 0.), 32.);\n    col = mix (col, bgCol, smoothstep (0.8, 1., min (dstObj, dstBall) / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, asp, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (0);\n  nBall = int (stDat.x);\n  whFac = stDat.y;\n  wtFac = stDat.z;\n  hgSize = stDat.w;\n  stDat = Loadv4 (1);\n  mPtr.xyz = stDat.xyz;\n  az = 0.;\n  el = -0.18 * pi;\n  if (mPtr.z > 0. && Minv2 (mPtr.xy + 0.05 * vec2 (1. / asp, 1.) - 0.5) < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.4 * pi, -0.13 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vec3 (0., 40., -50.);\n  zmFac = 2.6;\n  dstFar = 200.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (mPtr.z > 0. && Minv2 (uv - vec2 (asp, 1.)) > -0.1) col = mix (col, vec3 (1.), 0.4);\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1.,\n     0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\n/*\n  \"Physical Dynamics\" series (chronological order)\n                                           |\n   \"Molecular Dynamics\"          (4dG3RW)  |  \"Ball Cluster\"                (3sfGD8)\n   \"Granular Vibration\"          (Mdy3RW)  |  \"Molecular Diffusion\"         (3d23z3)\n   \"Puck Dynamics\"               (MsV3zW)  |  \"Freezing and Melting\"        (3dj3Wy)\n   \"Colliding Balls\"             (XsGGRm)  |  \"Maze Ball Solved\"            (tdfXRM)\n   \"Pseudo Billiards\"            (4sy3Rm)  |  \"Particle Scattering\"         (wsjSW1)\n   \"Pseudo Billiards 2\"          (ldy3zm)  |  \"Mondrian in Motion\"          (WdBXDG)\n   \"Balls and Springs\"           (MsV3zw)  |  \"Molecular Waltz\"             (Wt2GWG)\n   \"Reflecting Balls\"            (Xsy3WR)  |  \"Toroidal Mondrian\"           (3lSGWd)\n   \"Flashing Balls\"              (ldVGDR)  |  \"Polymer Chains 2\"            (wlsSWl)\n   \"Quasi Billiards\"             (MsGGD1)  |  \"Colliding Blocks 2\"          (3tSXWz)\n   \"Trapped Balls\"               (4dV3RG)  |  \"Leaping Snakes\"              (ttjXW1)\n   \"Herding Balls\"               (4dKGRt)  |  \"Leaping Snakes 2\"            (3lBXWV)\n   \"Ball Run\"                    (XsyGWG)  |  \"Dice Leaping\"                (3st3WS)\n   \"Stone Spiral\"                (XsyGDc)  |  \"Racetrack\"                   (tscSDn)\n   \"Falling Towers\"              (lsG3W3)  |  \"Leaping Glowsticks\"          (tttGR4)\n   \"Destruction\"                 (XsKGWc)  |  \"Knot Dynamics\"               (ttKXzc)\n   \"Leaping Balls\"               (MdKGWc)  |  \"Bouncing Rings 2\"            (3dScWc)\n   \"Leaping Balls Return\"        (4sG3Wt)  |  \"Floppy Clock With Dice\"      (3sXBDr)\n   \"Stairway from Heaven\"        (4sG3Dt)  |  \"Channeling Marbles\"          (wtfcRr)\n   \"Colliding Blocks\"            (lsG3Wd)  |  \"Truchet Balls\"               (tlXBW4)\n   \"Jumping Cubes\"               (4s3Xzn)  |  \"Marble Paths\"                (wddyDn)\n   \"Faberge Balls\"               (MsdXWn)  |  \"Balls in Spinning Drum\"      (tdcyWs)\n   \"Free the Balls\"              (lttGRn)  |  \"Magic Ball Sorter\"           (tsGyDy)\n   \"Balls and Springs 2\"         (XlGXzz)  |  \"Balls In Motion\"             (WdGBRG)\n   \"Floppy Sheet\"                (MlVSz1)  |  \"Wobbly Blob 2\"               (tsGfzV)\n   \"Stonewashed Flag\"            (MlyXzD)  |  \"Quick Slime 3D\"              (3syBRd)\n   \"More Balls\"                  (MsfyRn)  |  \"Multi-Slime\"                 (wsKBDd)\n   \"Rolling Stones\"              (MdsfD7)  |  \"Soup Can Dynamics\"           (3tKyRt)\n   \"Chocolate Dominoes\"          (ldBfz1)  |  \"Stairway to Hell\"            (sdl3WS)\n   \"Quick Slime\"                 (llsyDn)  |  \"Flagtime\"                    (NsfSR8)\n   \"Ben-Hur Balls\"               (XtfBWf)  |  \"Union Jack Flag\"             (NsXXRN)\n   \"Boxing Day\"                  (ltSfzz)  |  \"Antarctic Flag\"              (sdlSRl)\n   \"Snake Run\"                   (ltjfR1)  |  \"Polymers In Spinning Drum\"   (NsBXDD)\n   \"Refracted Colliding Balls\"   (lljBDR)  |  \"Channeling Slime\"            (NdSSR3)\n   \"Dancing Dumbbells\"           (lstyWr)  |  \"Green Mercury\"               (7tfGDn)\n   \"Polymer Chains\"              (4dcBRs)  |  \"Bouncing Sticks\"             (stsGRj)\n   \"Desert Dumbbells\"            (lsdfD2)  |  \"Dominoes Toppling\"           (stX3DS)\n   \"Reflecting Ben-Hur Balls\"    (MsVfRW)  |  \"Domino Towers\"               (7lXGWf)\n   \"Maze Ball\"                   (ldyBDm)  |  \"Block Impact\"                (7lB3zz)\n   \"Bouncing Rings\"              (MdVBD3)  |  \"Flag From Down Under\"        (NtfXDM)\n   \"Bouncing Chain\"              (XdKBDt)  |  \"Maze Ball Solved 2\"          (ftSXDV)\n   \"Floppy Cylinder\"             (4ltyz4)  |  \"Dynamic 3D Mondrian\"         (7sG3zD)\n   \"Surface Skimmer\"             (XtcBzN)  |  \"Balls Falling\"               (NsKGR3)\n   \"Tempus Fugit\"                (Ml3fW2)  |  \"Rock the Balls\"              (7ltXWX)\n   \"Quasi Billiards 2\"           (4ldBWl)  |  \"Union Jack Flag 2\"           (Nl3BDr)\n   \"Jamming Polymers\"            (XtGfz3)  |\n*/\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Grid-Surfing Balls\" by dr2 - 2023\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec4 QtMul (vec4 q1, vec4 q2);\nmat3 QtToRMat (vec4 q);\nvec4 RMatToQt (mat3 m);\nvec4 EulToQt (vec3 e);\nmat3 LpStepMat (vec3 a);\nfloat Maxv2 (vec2 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashff (float p);\nvec2 Noisev2v4 (vec4 p);\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat tCur, fOvlap, fricN, fricSW, fricT, hgSize, whFac, wtFac;\nint nFrame, nBall;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\nfloat WaveHt (vec2 p)\n{\n  vec4 t4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.01 * p;\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = wtFac * tCur * vec2 (1., -1.);\n  h = 0.;\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    t4 = wFreq * (q.xyxy + tw.xxyy);\n    t4 = abs (sin (t4 + 2. * Noisev2v4 (t4).xxyy - 1.));\n    t4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (t4.xz * t4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    q *= mat2 (1.6, -1.2, 1.2, 1.6);\n    wFreq *= 2.;\n    wAmp *= 0.25;\n  }\n  return whFac * h;\n}\n\nvoid CollFc (float rSep, float szAv, vec3 dr, vec3 dv, vec3 dw, inout vec3 am, inout vec3 wam)\n{\n  float fc, drv, ft;\n  fc = fOvlap * (szAv / rSep - 1.);\n  drv = dot (dr, dv) / (rSep * rSep);\n  fc = max (fc - fricN * drv, 0.);\n  am += fc * dr;\n  dv -= drv * dr + cross (dw, dr);\n  ft = min (fricT, fricSW * abs (fc) * rSep / max (0.001, length (dv)));\n  am -= ft * dv;\n  wam += (ft / rSep) * cross (dr, dv);\n}\n\nvoid Step (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec4 p;\n  vec3 rmN, vmN, wmN, dr, am, wam, e;\n  vec2 cId, cMid, ee[7];\n  float fDamp, fCent, grav, rSep, szN, szAv, ms, dt;\n  fOvlap = 1000.;\n  fricN = 50.;\n  fricSW = 2.;\n  fricT = 0.5;\n  fDamp = 0.1;\n  fCent = 0.006;\n  grav = 5.;\n  p = Loadv4 (4 * mId + 2);\n  rm = p.xyz;\n  sz = p.w;\n  vm = Loadv4 (4 * mId + 1 + 2).xyz;\n  qm = Loadv4 (4 * mId + 2 + 2);\n  wm = Loadv4 (4 * mId + 3 + 2).xyz;\n  //return;\n  ms = sz * sz * sz;\n  am = vec3 (0.);\n  wam = vec3 (0.);\n  for (int n = VAR_ZERO; n < nBall; n ++) {\n    p = Loadv4 (4 * n + 2);\n    rmN = p.xyz;\n    szN = p.w;\n    dr = rm - rmN;\n    rSep = length (dr);\n    szAv = 0.5 * (sz + szN);\n    if (n != mId && rSep < szAv) {\n      vmN = Loadv4 (4 * n + 1 + 2).xyz;\n      wmN = Loadv4 (4 * n + 3 + 2).xyz;\n      CollFc (rSep, szAv, dr, vm - vmN, (sz * wm + szN * wmN) / (sz + szN), am, wam);\n    }\n  }\n  cId = PixToHex (rm.xz / hgSize);\n  e = vec3 (1., 0., -1.);\n  ee[0] = e.yy;\n  ee[1] = e.yx;\n  ee[2] = e.yz;\n  ee[3] = e.xy;\n  ee[4] = e.zy;\n  ee[5] = e.xz;\n  ee[6] = e.zx;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    rmN.xz = HexToPix ((cId + ee[k]) * hgSize);\n    rmN.y = WaveHt (rmN.xz);\n    dr = rm - rmN;\n    dr.y = max (dr.y, 0.);\n    rSep = length (dr);\n    szAv = 0.5 * (sz + 1.);\n    if (rSep < szAv) CollFc (rSep, szAv, dr, vm, wm, am, wam);\n  }\n  rSep = length (rm.xz);\n  if (rSep > 0.) am.xz -= fCent * rm.xz / rSep;\n  am.xz -= fDamp * vm.xz;\n  am.y -= grav * ms;\n  dt = 0.01;\n  vm += dt * am / ms;\n  rm += dt * vm;\n  wm += dt * wam / (0.1 * ms * sz);\n  qm = normalize (QtMul (RMatToQt (LpStepMat (0.5 * dt * wm)), qm));\n}\n\nvoid Init (int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm, out float sz)\n{\n  vec3 e;\n  float mIdf, ne;\n  mIdf = float (mId);\n  ne = sqrt (float (nBall));\n  rm.xz = 2. * (vec2 (mod (mIdf, ne), floor (mIdf / ne)) - 0.5 * ne);\n  rm.y = 2.6 * whFac + 1.;\n  vm = 2. * (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)) - 0.5);\n  e = normalize (vec3 (Hashff (mIdf), Hashff (mIdf + 0.3), Hashff (mIdf + 0.6)));\n  qm = EulToQt (e);\n  wm = vec3 (0.);\n  sz = 1.;\n}\n\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 canvas, iFrag;\n  float sz, nStep, asp;\n  int mId, pxId, kp;\n  bool doInit;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  nBall = 144;\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 2) discard;\n  doInit = (nFrame <= 2);\n  if (doInit) {\n    whFac = 10.;\n    wtFac = 0.07;\n    hgSize = 1./sqrt3;\n    nStep = 0.;\n  } else {\n    stDat = Loadv4 (0);\n    whFac = stDat.y;\n    wtFac = stDat.z;\n    hgSize = stDat.w;\n    nStep = stDat.x;\n    stDat = Loadv4 (1);\n    nStep = stDat.w;\n    ++ nStep;\n  }\n  if (mPtr.z > 0. && Maxv2 (mPtr.xy + 0.03 * vec2 (1. / asp, 1.)) > 0.5 && nStep > 100.)\n     doInit = true;\n  if (doInit) nStep = 0.;\n  mId = (pxId >= 2 && pxId < 4 * nBall + 2) ? (pxId - 2) / 4 : -1;\n  if (mId >= 0) {\n    if (doInit) Init (mId, rm, vm, qm, wm, sz);\n    else Step (mId, rm, vm, qm, wm, sz);\n    kp = pxId - 2 - 4 * mId;\n    if      (kp == 0) stDat = vec4 (rm, sz);\n    else if (kp == 1) stDat = vec4 (vm, 0.);\n    else if (kp == 2) stDat = qm;\n    else if (kp == 3) stDat = vec4 (wm, 0.);\n  } else {\n    if      (pxId == 0) stDat = vec4 (float (nBall), whFac, wtFac, hgSize);\n    else if (pxId == 1) stDat = vec4 (mPtr.xyz, nStep);\n  }\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\nvec4 QtMul (vec4 q1, vec4 q2)\n{\n  vec2 e = vec2 (1., -1.);\n  return vec4 (dot (e.xyxx * q1.wzyx, q2), dot (e.xxyx * q1.zwxy, q2),\n     dot (e.yxxx * q1.yxwz, q2), dot (e.yyyx * q1.xyzw, q2));\n}\n\nmat3 QtToRMat (vec4 q)\n{\n  mat3 m;\n  vec3 a1, a2;\n  a1 = q.yzx * q.zxy;\n  a2 = q.w * q.xyz;\n  a1 += a2;\n  a2 = a1 - 2. * a2;\n  m[1][2] = a1.x;  m[2][1] = a2.x;\n  m[2][0] = a1.y;  m[0][2] = a2.y;\n  m[0][1] = a1.z;  m[1][0] = a2.z;\n  q.xyz = q.xyz * q.xyz + q.w * q.w - 0.5;\n  m[0][0] = q.x;  m[1][1] = q.y;  m[2][2] = q.z;\n  return 2. * m;\n}\n\nvec4 RMatToQt (mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = 0.5 * sqrt (max (1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs (q.w) > tol) q.xyz =\n     vec3 (m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt (max (0.5 * (1. + m[0][0]), 0.));\n    if (abs (q.x) > tol) q.yz = vec2 (m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt (max (0.5 * (1. + m[1][1]), 0.));\n      if (abs (q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize (q);\n}\n\nvec4 EulToQt (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nmat3 LpStepMat (vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = 0.25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;\n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2;\n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), 1.5 * h.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}