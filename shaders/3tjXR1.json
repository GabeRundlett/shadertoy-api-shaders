{
    "Shader": {
        "info": {
            "date": "1565140254",
            "description": "Rough take on Tool's Fear Inoculum album art. Video: https://youtu.be/Gf2H5PZoPeA",
            "flags": 0,
            "hasliked": 0,
            "id": "3tjXR1",
            "likes": 3,
            "name": "Tool - Fear Inoculum",
            "published": 3,
            "tags": [
                "tool",
                "fearinoculum",
                "fearinoculum"
            ],
            "usePreview": 0,
            "username": "dc",
            "viewed": 570
        },
        "renderpass": [
            {
                "code": "// Author: Dillon Cower (dcower@)\n// License: Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n#define HIGH_QUALITY 0\n#define DO_THE_ANGLE 0\n\n#define LOOP 0\n\n// inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n#define ZERO (min(iFrame,0))\n\n#if HIGH_QUALITY\n#define AA 4\n#define STEPS 500\n#define STEP_SIZE 0.05\n#define D_MIN 0.01\n#define D_MAX 300.0\n#define LIGHT_D_MIN 0.025\n#define LIGHT_D_MAX 10.0\n#define LIGHT_STEPS 200\n#define LIGHT_STEP_SIZE 0.2\n#else\n#define AA 2\n#define STEPS 500\n#define STEP_SIZE 0.05\n#define D_MIN 0.01\n#define D_MAX 100.0\n#define LIGHT_D_MIN 0.025\n#define LIGHT_D_MAX 10.0\n#define LIGHT_STEPS 200\n#define LIGHT_STEP_SIZE 0.2\n#endif\n\nfloat get_start_fade() {\n    return min(1.0, iTime / 10.0);\n}\n\n\nfloat mypow(float x, float y) {\n    return sign(x) * pow(abs(x), y);\n}\n\n\nvec3 mypow(vec3 x, vec3 y) {\n    return sign(x) * pow(abs(x), y);\n}\n\n\nfloat Rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat ValueNoise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 s = smoothstep(0.0, 1.0, f);\n    float nx0 = mix(Rand(i + vec2(0.0, 0.0)), Rand(i + vec2(1.0, 0.0)), s.x);\n    float nx1 = mix(Rand(i + vec2(0.0, 1.0)), Rand(i + vec2(1.0, 1.0)), s.x);\n    return mix(nx0, nx1, s.y);\n}\n\n/*float random_flicker(float time) {\n    return clamp(round(Rand(vec2(round(time * 20.0) / 20.0)) + 1.2), 0.0, 1.0);\n}*/\n\nfloat random_flicker(float time) { return 1.0; }\n\n// by iq:\nfloat noise( const in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy) + f.xy;\n    return textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).x;\n}\n\n/*float noise( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}*/\n\nfloat iqhash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// Was getting radial artifacts with commented out noise above...\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( iqhash(n+0.0  ), iqhash(n+1.0  ),f.x),\n                   mix( iqhash(n+57.0 ), iqhash(n+58.0 ),f.x),f.y),\n               mix(mix( iqhash(n+113.0), iqhash(n+114.0),f.x),\n                   mix( iqhash(n+170.0), iqhash(n+171.0),f.x),f.y),f.z);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a,float b,float k){ return -smin(-a,-b,k);}\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\n\nfloat hash( vec2 p ) {\n    float h = dot(p,vec2(127.1,311.7));\n    return fract(sin(h)*43758.5453123);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nconst float blood_pumping_scale = 11.0;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n\n// from mskr@\nfloat sabs(float d, float eps) {\n    float abs = abs(d);\n    if(d > -eps && d < eps) return mix(abs, eps, (eps - abs) / eps / 2.);\n    return abs;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nconst float MATERIAL_FLAME = 1.0;\n\n\n/*float flame(in vec3 p) {\n    float d = 1e10;\n    \n    for (int i = 0; i < 10; i++) {\n        vec3 offset = vec3(\n            ValueNoise(vec2(float(i) * 300.0)),\n            ValueNoise(vec2(float(i) * 500.0)),\n            ValueNoise(vec2(float(i) * 200.0))\n        );\n        float time_offset = ValueNoise(vec2(float(i) * 1100.0));\n        float lifetime = 1.0 + abs(2.0 * ValueNoise(vec2(float(i) * 1300.0)));\n        vec3 sphere_p = p + offset * 3.0;\n        float life = (1.0 - mod(iTime + time_offset, lifetime) / lifetime);\n        sphere_p.y -= (1.0 - life) * 9.0;\n        float radius = 8.0 * abs(ValueNoise(vec2(float(i) * 700.0))) * life;\n    \td = smin(d, sdSphere(sphere_p, radius), 3.0);\n    }\n    return d;\n}*/\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nvec2 opRevolution(in vec3 p, float o)\n{\n    return vec2(length(p.xz) - o, p.y);\n}\n\n\nfloat mymod(float x, float y) {\n    return x - y * trunc(x/y);\n}\nvec2 mymod(vec2 x, float y) {\n    return x - y * trunc(x/y);\n}\nvec3 mymod(vec3 x, float y) {\n    return x - y * trunc(x/y);\n}\n\n#define PI 3.14159265359\n\n#define saturate(x) clamp(x, 0., 1.)\n\n\nvec3 sphIntersect3(in vec2 screen_p, in vec3 p)\n{\n    // infinite zoom\n    /*p.z = p.z - mymod(iTime, 5.7) * 5.0;\n    p.y = p.y - mymod(iTime, 5.7) * 0.54;\n    p.x = p.x + mymod(iTime, 5.7) * 0.045;*/\n    \n   // p.z -= 20.0;\n    //p.y -= 3.0;\n\n    vec3 real_original_p = p;\n\n    p.y *= 2.7;\n\n    p = rotX(1.9) * p;\n\n    p.y += -10.0;\n    \n    vec3 original_p = p;\n    // d, material id\n    vec3 res = vec3(1e10, 0.0, 0.0);\n    float d = 1e10;\n    vec3 q;\n    \n    float sphere_radius = 0.7;\n\n    p.xyz += vec3(-7.0, 0.0, 5.0 - 5.0);\n    \n    //p.xy *= 0.7;\n\n    //p += 20.0;\n    //p.y -= mod(iTime * 0.25, 1.0);\n    //p.y -= mod(iTime * 0.25, 1.0);\n\n    //p.xz += iTime;\n    //p *= 4.0;\n    \n    //p.xz -= 5.0;\n    //p.y = abs(p.y);\n    \n\n    //float rot_amount = mypow(clamp(original_p.y * 0.1, -2.0, 2.0), 1.0)+ 0.0 * iTime * 0.5;\n    float rot_amount = mypow(original_p.y * 0.25,  1.0) + 1.78 / 2.0;\n    \n    //rot_amount = mod(rot_amount, PI / 1.0);\n    //p = rotY(-1.0) * p;\n#if LOOP\n\trot_amount += iTime / 8.0 * PI;\n#else\n\trot_amount += iTime * 0.1;\n#endif\n    p = rotY(rot_amount) * p;\n    \n    //p = rot(sin(iTime * 0.1) * original_p.y * 0.25) * p;\n    \n    //p = rotY(iTime) * p;\n    \n    //p.y *= 0.05 * length(p.xz);\n    \n    // make less stretched.\n    p.xyz *= vec3(2.0, 4.0, 2.0);\n    \n    //p.xyz *= 2.0 + sin(rot_amount);\n    \n    //p.y *= mymod(original_p.y * 0.25 + 1.78 / 2.0, PI) * 0.2;\n    //p.y *= 1.0;\n    //p.z *= 0.1;\n\n\n    \n    //p.xz -= 5.0;\n    //p *= 1.0 / 4.0;\n    //p.y *= 0.5;\n\n\n    vec3 pre_mod_p = p;\n    \n    //p.y = -p.y;\n    \n    \n    // vertical cylinder of eyes\n    float dist_to_cylinder = length((original_p - vec3(0.0, 0.0, 0.0)).xz);\n    float dist_to_center = length((original_p + vec3(-7.0, 0.0, 5.0)).xz);\n    //float dist_to_center = 6.0;\n    if (dist_to_cylinder < 35.0 + 0.5 * abs(-original_p.y) && dist_to_center >= 0.0) {\n    //if (length(p) < 100.0 && length(p.xyz) > 5.0 && p.z > 0.0) {\n        p.x = mod(p.x, sphere_radius * 2.0);\n        p.x -= sphere_radius;\n\n        p.y = mod(p.y, sphere_radius * 2.0);\n\n        p.y -= sphere_radius;\n        \n        //p.z /= 1.0 + (p.y + sphere_radius) * 4.0;\n        \n        p.x = pow(abs(p.x), 0.8);\n        p.y = pow(abs(p.y), 0.9);\n        \n        p.z *= 1.5;\n\n        \n        \n        /*if (dist_to_cylinder < 7.0) {\n          p.z = mod(p.y, sphere_radius * 2.0);\n          p.z -= sphere_radius;\n        }*/\n        \n\t    d = sdSphere(p, sphere_radius);\n    } else {\n        d = dist_to_cylinder;\n    }\n        \n\n    //    vec4 vals = iMouse / vec4(iResolution.x, iResolution.y, iResolution.x, iResolution.y);\n    //       vec3 lp = (vals.xyz - 0.5) * 100.0;\n    //d = min(d, sdSphere(real_original_p - lp, 1.0));\n    \n    //if (length(p.z) < 20.0) {\n    //    p.z = mod(p.z, sphere_radius * 2.0);\n    //    p.z -= sphere_radius;\n    //}\n    \n    //p.z = clamp(p.z, -20.0, 20.0);\n    /*if (length(p) < 5.0) {\n        p.z = mod(p.z, sphere_radius * 2.0);\n        p.z -= sphere_radius;\n    }*/\n\n\n    //p.xz *= rot(original_p.y*PI/5.);\n    //p.xz *= rot(iTime/2.);\n    \n    \n    \n\n        \n    //d = max(d, helix_d);\n    \n    \n    //p.y = mod(p.y, 9.0);\n    \n    //p.x = mod(p.x, 2.0);\n    //p.x += 1.0;\n    \n   // if (length(polar_p.x) < 3.0) {\n    //}\n    \n\n\n    \n    //p.x -= 2.0;\n\n    \n    //p = polarToCart(polar_p);\n\n\n    // Flame:\n    //d = opSubtraction(eye_d, flame(p, 3.0));\n    \n    \n    \n    if (d < res.x) {\n\t\tres = vec3(d, MATERIAL_FLAME, 0.0);\n    }\n    \n    return res;\n}\n\nfloat sphIntersect(in vec2 screen_p, in vec3 p)\n{\n    return sphIntersect3(screen_p, p).x;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat noise_texture(vec3 p) {\n    float val = 0.0;\n    //p *= 0.5;\n    //p += 33.0;\n    \n    //p += vec3(pow(1.0 - get_start_fade(), 0.5) * 4.0, pow(1.0 - get_start_fade(), 0.5) * 3.0, pow(1.0 - get_start_fade(), 0.5) * 7.0);\n    float s = sign(p.x);\n    /*if (p.x < 10.0 && p.x >= 0.0) {\n        s = pow(p.x * 0.1, 2.0) * 10.0;\n    } else if (p.x > -10.0 && p.x <= 0.0) {\n        s = pow(p.x * 0.1, 2.0) * 10.0;\n    }*/\n\n    p += vec3(s * (1.0 - pow(get_start_fade(), 0.7)) * 20.0, 0.0, 0.0);\n\t//p += 0.2 * vec3(get_heartbeat(iTime) * 1.0 * sin(iTime * 0.3), get_heartbeat(iTime) * 1.0 * cos(iTime * 0.7), get_heartbeat(iTime) * 1.0 * sin(iTime * 0.2));\n\n\t//p += vec3(sin(iTime * blood_pumping_scale) * 0.05, 0.0, 0.0);\n    \n#if HIGH_QUALITY\n    const float divisor = 1.25 + 0.5;\n    val += texture(iChannel0,\n                   vec2(p.x + p.z + 5.0, p.x + p.y + p.z - 6.0)).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 11.0, p.x + p.y + p.z - 39.0) / 2.0).r * 0.25;\n#else\n    const float divisor = 1.25;\n#endif\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + p.y * 3.0 + 33.0, p.x + p.y + p.z - 3.0) / 4.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.y + 13.0, p.y + p.z - 9.0) / 8.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 119.0, p.y + p.z + 133.0) / 16.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z + 70.0, p.y + p.z + 130.0) / 32.0).r * 0.25;\n    val += texture(iChannel1,\n                   vec2(p.x + p.z, p.y + p.z) / 64.0).r * 0.25;\n    \n    val *= (1.0 / divisor);\n        \n    //val += texture(iChannel0,\n    //               vec2(p.x / 1241.0 + p.y / 1233.0 + p.z / 1111.0,\n    //                    p.x / 1111.0 + p.y / 1111.0 + p.z / 333.0) * 20.0).r;\n    /*val += texture(iChannel0,\n                   vec2(1.0 / p.x / 124.0 + p.y / 123.0 + 1.0 / p.z / 111.0,\n                        p.x / 111.0 + 1.0 / p.y / 111.0 + 1.0 / p.z / 33.0) * 5.0).r;*/\n    return val;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define doublepow(x, p) (1.0 - pow(1.0 - pow(x, p), p))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float initial_fade = 10.0;\n    \n    //vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    //float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\tfloat debug_val4 = iMouse.w / 281.0;\n    \n    vec4 vals = vec4(147.0, 120.0, 0.0, 190.0) / vec4(500.0, 281.0, 1.0, 281.0);\n    vals = iMouse / vec4(iResolution.x, iResolution.y, iResolution.x, iResolution.y);\n\n    vec3 total_color = vec3(0.0);\n\n    for (int chrom = 0; chrom < 3; chrom++) {\n    for( int aa_x = ZERO; aa_x < AA; aa_x++ )\n    for( int aa_y = ZERO; aa_y < AA; aa_y++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(aa_x),float(aa_y)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n   /* vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.5 + 3.0 * q ;\n    p.x *= iResolution.x/iResolution.y;\n*/\n        // time coordinate (motion blurred, shutter=0.5)\n        //float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        //float time = iTime - 0.5*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    \n#if DO_THE_ANGLE\n    // TODO(dcower): This is broken.\n    vec3 ro = normalize(vec3(30.0, 0.0, 40.0)) * 35.0;\n    vec3 ta = vec3( 3.0, 1.0 + 0.13*cos(0.3*0.0), 0.0 );\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy, 3.0));\n    //m = vec2(0.05, 0.0);\n#else\n    //vec2 camera_m = vec2(m.x, 1.0-vals.y);\n    //camera_m = mix(vec2(0.5), camera_m, 0.5);\n    //float fov_change = camera_m.y;\n\n    //fov_change = 0.95;\n    //fov_change = vals.w;\n\n    //float an =  3.1415/2.0 + 3.1415 * (0.0 * camera_m.x + 0.5);\n    //float cr = 0.15*sin(0.2*0.0);\n    // z rotation\n    float cr = 0.18;\n    //vec3 poser = vec3(0.0, 0.0, -2.0 + -18.0 + 17.0 * (fov_change - 0.5));\n    //vec3 ro = vec3(0.0, 0.0, iTime * 0.5);\n    vec3 ro = vec3(0.0, 0.0, 0.0) ;//+ (vals.xyz - 0.5) * 10.0;\n\n    //vec3 ro = (poser + 7.4) * vec3(sin(an),0.0,cos(an)) * 4.0;\n    ro.y += 0.0;\n    //vec3 ta = vec3( 0.0, 2.0 + 0.13*cos(0.3*0.0), 0.0 );\n    //vec3 ta = vec3( sin(iTime), cos(iTime), 0.0) * 10.0;\n    //vec3 ta = vec3( sin(iTime), cos(iTime), 0.0) * 10.0;\n    vec4 good_vals = vec4(32.0, 50.0, 67.0, 0.0) / vec4(640.0, 360.0, 640.0, 360.0);\n        \n\tvec3 ta = vec3(good_vals.x * 20.0, good_vals.y * 20.0, -5.0);\n    mat3 ca = setCamera( ro, ta, cr );\n    // z parameter controls fov\n    //vec3 rd = ca * normalize( vec3(p.xy,4.5 - 4.0 * (fov_change - 0.5)));\n    vec3 rd = ca * normalize( vec3(p.xy, good_vals.z * 10.0));\n    //vec3 rd = normalize( vec3(p,-2.0) );\n#endif\n   \n    float tmin = 1e10;\n    float t = 0.0;\n    float fog_amount = 0.0;\n    float dmin = 1e10;\n\n    // crappy chrom abber\n#if LOOP\n    float chrom_time = 0.0;\n#else\n    float chrom_time = iTime;\n#endif\n\n    ro +=  0.5 * vec3(0.05 * sin(chrom_time * 0.13 + float(1+chrom) * 2.3),\n               0.05 * sin(chrom_time * 0.17 + float(1+chrom) * 314.2),\n               0.05 * sin(chrom_time * 0.15 + float(1+chrom) * 4.1));\n    rd = mypow(rd, 1.0 + vec3(0.02 * sin(chrom_time * 0.2 + float(1+chrom) * 2.0)));\n    \n    // lil squish.\n    rd = mypow(rd, vec3(1.0 + 0.2 * sin(chrom_time * 0.23)));\n        \n    for (int i = 0; i < STEPS; i++) {\n        vec3 pos = ro + t*rd;\n        float d = sphIntersect(p, pos);\n        /*float screen_x = 2.0*(q.x - 0.5);\n        #if HIGH_QUALITY\n        float step_size = STEP_SIZE; \n        #else\n        float step_size = abs(screen_x) < 0.25 ? STEP_SIZE * 3.5 : STEP_SIZE * (3.0 * abs(screen_x)); \n        #endif*/\n        const float step_size = STEP_SIZE;\n        //float step_size = STEP_SIZE; \n        \n        // skip rendering stuff too close to screen.\n        /*if (length(pos - ro) < 1.0) {\n            d = step_size;\n        }*/\n        \n        t += d * step_size;\n        dmin = min(d, dmin);\n        \n\n        \n        if (d < D_MIN || d > D_MAX) break;\n    }\n    \n    if (t < tmin) {\n        tmin = t;\n    }\n    \n    //float d = sphIntersect(ro + tmin*rd);\n    \n    vec3 pos = ro + tmin*rd;\n    \n    //vec3 bg_color = vec3(0.05);\n    vec3 bg_color = vec3(0.0);\n    \n    vec3 col = bg_color;\n\n    if( dmin <= D_MIN)\n    {\n        //vec3 diffuse_color = vec3(0.9, 0.12, 0.12);\n        //vec3 diffuse_color = vec3(0.9, 0.15, 0.15);\n        \n        vec3 d3 = sphIntersect3(p, pos);\n        float material = d3.y;\n        \n        const float del = 0.001;\n        vec3 nor = vec3(\n            (sphIntersect(p, ro + tmin * rd + vec3(del, 0.0, 0.0)) - sphIntersect(p, ro + tmin * rd - vec3(del, 0.0, 0.0))),\n            (sphIntersect(p, ro + tmin * rd + vec3(0.0, del, 0.0)) - sphIntersect(p, ro + tmin * rd - vec3(0.0, del, 0.0))),\n            (sphIntersect(p, ro + tmin * rd + vec3(0.0, 0.0, del)) - sphIntersect(p, ro + tmin * rd - vec3(0.0, 0.0, del))));\n\n        nor = normalize(nor);\n\n        if (material == MATERIAL_FLAME) {\n            col = vec3(0.0);\n            for (int i = 0; i < 2; i++ ) {\n                vec3 lp;\n\t\t\t\tfloat diffuse_intensity = 0.0;\n                float specular_intensity = 0.5;\n                float specular_exp = 128.0;\n                vec3 spec_color = vec3(0.7, 0.7, 1.0);\n                float radius = 300.0;\n                float ambient = 0.0;\n                float falloff = 2.1;\n                if (i == 0) {\n                \tlp = (vals.xyz - 0.5) * 100.0;\n                \t//lp = (vec3(420.0, 193.0, 290.0) / vec3(640.0, 360.0, 640.0) - 0.5) * 100.0;\n\t\t\t\t\tlp = (vec3(420.0, 185.0, 240.0) / vec3(640.0, 360.0, 640.0) - 0.5) * 100.0;\n\n                    diffuse_intensity = 1.1;\n                float specular_exp = 128.0;\n                float specular_intensity = 0.5;\nambient = 0.2;\n                    //falloff = 0.1;\n                    //radius = 2000.0;\n\n                    spec_color = vec3(0.7, 0.8, 1.0);\n\n                } else if (i == 1) {\n                \t//lp = (vals.xyz - 0.5) * 100.0;\n                \tlp = (vec3(57.0, 360.0, 196.0) / vec3(640.0, 360.0, 640.0) - 0.5) * 10000.0;\n\n                    diffuse_intensity = 0.5;\n                    specular_intensity = 1.3;\n                    specular_exp = 256.0;\n                    radius = 0.0;\n                    spec_color = vec3(0.7, 0.8, 1.0);\n                } else if (i == 3) {\n                \tlp = (vals.xyz - 0.5) * 200.0;\n                \t//lp = (vec3(57.0, 360.0, 196.0) / vec3(640.0, 360.0, 640.0) - 0.5) * 10000.0;\n\n                    diffuse_intensity = 0.0;\n                    specular_intensity = 1.3;\n                    specular_exp = 512.0;\n                    radius = 0.0;\n                    spec_color = vec3(0.7, 0.8, 1.0);\n                }\n                \n                vec3 color = vec3(111.0, 136.0, 173.0) / 255.0;\n                //normalize(pos - vec3(-7.0, 0.0, 5.0 - 5.0))\n                //if (acos(dot(nor, rd)) >= PI * 0.7) {\n                //if (dot(nor, -rd) <= 0.5) {\n                \n                vec3 eye_move = vec3(0.0);\n                \n#if LOOP\n                // hyuck hyuck hyuck\n                float eye_time = mod(iTime  + 0.2, 8.0);\n#else\n                float eye_time = iTime + 0.2;\n#endif\n                \n                float eye_move_scale = 0.5;\n                eye_move = vec3(\n                    mypow(sin(eye_time * 0.7 * eye_move_scale) * cos(eye_time * 3.2* eye_move_scale), 13.0),\n                mypow(sin(eye_time * 0.3* eye_move_scale) * cos(eye_time * 1.2* eye_move_scale), 13.0),\n                mypow(sin(eye_time * 0.5* eye_move_scale) * cos(eye_time * 2.2* eye_move_scale), 13.0));\n                \n                eye_move = normalize(eye_move) * sin(eye_time * 0.6 * eye_move_scale);\n                \n                eye_move = rotY(eye_time * 0.3) * eye_move;\n                \n                vec3 ld = normalize(vec3(0.0, 1.0, 0.3));\n                vec3 ld_before_move = ld;\n                \n                ld += eye_move * 0.4;\n                ld = normalize(ld);\n\n                float dilate = 0.005 * mypow(sin(eye_time * 0.56 * 0.3) * cos(eye_time * 1.2), 9.0);\n                //ld = normalize(ld + vec3(0.0, sin(iTime), cos(iTime)));\n                //ld = normalize(pos - vec3(vals.xyz - 0.5) * 100.0);\n\n                vec3 to_light = normalize(lp - pos);\n                \n                float eye_ring = abs(dot(nor, ld));\n                if (eye_ring >= 0.978) {\n                    if (eye_ring >= (0.992 - dilate)) {\n                      color *= vec3(0.5);\n                        \n                      // sheen:\n                \n                      //vec3 h = normalize(-rd + normalize(2.0 * (vals.xyz - 0.5)));\n                      //h = ld_before_move;\n                      vec3 h = normalize(-rd * 0.1 + ld_before_move + 2.0 * (vals.xyz - 0.5));\n                      float specular_amount = pow(abs(dot(h, nor)), 3000.0);\n                      \n                      // ensure the top eyes get some sheen too ...\n                      //h = normalize(-rd + 2.0 * (vals.xyz - 0.5));\n                      //specular_amount = max(specular_amount, pow(abs(dot(h, nor)), 1024.0));\n                      color *= 1.0 + 7.0 * specular_amount;\n                    } else {\n                      float extra_ring = pow((eye_ring - 0.978) / ((0.992 - dilate) - 0.978), 3.0);\n                   \t  //extra_ring = 0.0;\n                        color *= vec3(1.6 + 0.3 * extra_ring);\n                    }\n\n\n                    //color = vec3(1.0, 0.0, 0.0);\n                }\n                \n                float light_amount = pow(saturate(dot(to_light, nor)), 1.0);\n\n                 light_amount *= min(1.3, radius / pow(length(lp - pos), falloff));\n\t\t\t\tlight_amount = max(light_amount, ambient);\n                col += diffuse_intensity * color * (light_amount);\n\n                //float specular_amount = dot(rd, to_light);\n\n                \n                vec3 h = normalize(-rd + to_light);\n                float specular_amount = pow(clamp(dot(h, nor), 0.0, 1.0), specular_exp);\n                col += spec_color * specular_intensity * specular_amount;\n            }\n            \n        }\n    }\n                \n    // chrom abber\n        if (chrom == 0) {\n    total_color += col * vec3(1.0, 0.0, 0.0);\n        }\n        else if (chrom == 1) {\n    total_color += col  * vec3(0.0, 1.0, 0.0);\n        }\n        else if (chrom == 2) {\n    total_color += col  * vec3(0.0, 0.0, 1.0);\n        }\n    // Close the AA for loops above. Only inner uses brace.\n    }\n     \n        \n    }\n    total_color /= float(AA*AA);\n\n    //total_color /= float(AA);\n    \n    total_color = pow(total_color * 1.7, vec3(1.5));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    total_color *= saturate(pow(1.9 - length(p), 1.5));\n    total_color *= vec3(1.0, 0.85, 0.85);\n    //col += 16.0/255.0;\n    fragColor = vec4(total_color, 1.0 );\n\n    //fragColor = vec4( col, 1.0 ) * pow(get_start_fade(), 0.25);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}