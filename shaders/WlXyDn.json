{
    "Shader": {
        "info": {
            "date": "1591760204",
            "description": "A simple model",
            "flags": 0,
            "hasliked": 0,
            "id": "WlXyDn",
            "likes": 2,
            "name": "Baymax_v1",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "CS_climber",
            "viewed": 255
        },
        "renderpass": [
            {
                "code": "//计算机图形学大作业\nconst int Max_Steps=300;\nconst float Max_Distance=300.0;\nconst float Threshold=0.001;\nconst float EPSILON=0.001;\n\n//Part1  基于符号距离函数构造场景\n//基本操作\nfloat Intersect(float A,float B){return max(A,B);}\nfloat Union(float A,float B){return min(A,B);}\nfloat Diffence(float A,float B){return max(A,-B);}\nfloat dot2( in vec3 v ){ return dot(v,v);}\n//地面SDF\nfloat Set_Ground(vec3 p){\n    return p.y;\n}\n//金子塔SDF\nfloat Set_Pyramid(vec3 p,float h) {\n  float m2 = h*h + 0.25; \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n  float s = max(-q.x,0.0);\n  float t = clamp((q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0);   \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t); \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n//球形SDF\nfloat Set_Sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//梨形SDF\nfloat Set_RoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n//环形SDF\nfloat Set_CappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n//环形SDF\nfloat Set_Ellipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n//胶囊形SDF\nfloat Set_Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n//整个场景SDF\nvec2 Senery(vec3 p){\n    //a. 地面\n    float conponent[10],part[4];\n    part[0]=Set_Ground(p);\n    \n    //b. 模型主体\n    //构建身体\n    vec3 a=vec3(0.0,0.76,0);\n    vec3 b=vec3(0.0,0.0,0);\n    conponent[0]=Set_RoundCone( p-vec3(0,0.4,0),  a,  b, 0.35, 0.75);\n    //构建手臂\n    vec2 sc=vec2(1,2);\n    conponent[1]=Set_CappedTorus(p-vec3(0,0.2,0), vec2(0.866025,-0.50), 1.0, 0.2);\n    //构建头部\n    vec3 r=vec3(0.4,0.3,0.3);\n    conponent[2]=Set_Ellipsoid(p-vec3(0,1.5,0), r );\n    //构建腿部\n    vec3 c=vec3(-0.25,0.1,1);\n    vec3 d=vec3(-0.3,0.1,0);\n    conponent[3]=Set_RoundCone( p,  c,  d, 0.15, 0.41);\n    vec3 e=vec3(0.25,0.1,1);\n    vec3 f=vec3(0.3,0.1,0);\n    conponent[4]=Set_RoundCone( p,  e,  f, 0.15, 0.41);\n    part[1]=1e7;\n    for(int i=0;i<5;i++){\n        part[1]=Union(part[1],conponent[i]); \n    }\n    \n    //c. 模型细节\n    //构建眼睛\n    conponent[5]=Set_Sphere(p-vec3(0.15,1.55,0.25),0.059);\n    conponent[6]=Set_Sphere(p-vec3(-0.15,1.55,0.25),0.059);\n    conponent[7]=Set_Capsule(p, vec3(0.15,1.55,0.28),vec3(-0.15,1.55,0.28),0.019);\n    part[2]=1e7;\n    for(int i=5;i<8;i++){\n        part[2]=Union(part[2],conponent[i]); \n    }\n                           \n    //d. 组合场景中的各个部分\n    float m,min_dis=100000000.0;\n    for(int i=0;i<3;i++){\n        if(min_dis>part[i]){\n            min_dis=part[i];\n            m=float(i);\n        }\n    }\n    return vec2(min_dis,m);\n}\n\n//Part2  Ray_marching算法\n//光线以当前位置到最近的点距离作为步长前进，当超过设定迭代次数和阈值时返回结果\nvec2 Ray_marching(vec3 start,vec3 dir){\n    float l=0.0,m=0.0;\n    for(int i=0;i<Max_Steps;i++){\n        vec2 new_pos=Senery(start+l*dir);\n        //超出边界返回全零\n        if(l>Max_Distance||abs(new_pos.x)<Threshold)break;\n        l+=new_pos.x;\n        m=new_pos.y;\n    }\n    if(l>Max_Distance)m=-1.0;\n    return vec2(l,m);\n}\n//Part3 光照\nvec3 Get_Normal(vec3 p) {\n    return normalize(vec3(//中间差分求梯度\n        Senery(vec3(p.x + EPSILON, p.y, p.z)).x - Senery(vec3(p.x - EPSILON, p.y, p.z)).x,\n        Senery(vec3(p.x, p.y + EPSILON, p.z)).x - Senery(vec3(p.x, p.y - EPSILON, p.z)).x,\n        Senery(vec3(p.x, p.y, p.z  + EPSILON)).x - Senery(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\nfloat soft_shadow(vec3 start,vec3 dir){\n    float l=0.0,ans=1.0;\n    for(int i=0;i<Max_Steps;i++){\n        float new_pos=Senery(start+l*dir).x;\n        ans=min(ans,new_pos/(l*0.05));\n        if(l>6.0)break;\n        l+=clamp(new_pos, 0.005, 0.50);\n    }\n    return ans;\n}\nvec3 Phong_shader(vec3 p, vec3 eye,vec3 kd) {\n    //设置参数\n    vec3 light_pos = vec3(-30, 30, 40);\n    vec3 light_intensity = vec3(1.5, 1.5, 1.5);\n    vec3 amb_light_intensity=vec3(0.4, 0.4, 0.4);\n\n    vec3 ka = vec3(0.005, 0.005, 0.005);\n    vec3 ks = vec3(1.0, 1.0, 1.0);\n    float alpha = 6.0;\n    \n    //测试阴影\n    //将当前点沿着法向移动一点，从该点向光源光线步计算阴影系数\n    vec3 n =  Get_Normal(p);\n    float s=soft_shadow(p,normalize(light_pos -p));\n    kd*=s;\n    \n    //计算向量\n    vec3 l = normalize(light_pos  - p);\n    vec3 v = normalize(eye - p);\n    vec3 r = normalize(reflect(-l, n));\n    //计算phong模型三类光\n    vec3 color=ka*amb_light_intensity;\n    float l_n = dot(l, n);\n    float r_v = dot(r, v);\n    if (l_n< 0.0) {//照不到\n        return vec3(0.0, 0.0, 0.0);\n    }else if (r_v < 0.0) {\n        color+=light_intensity*kd*l_n;\n    }\n    else{\n        color+=light_intensity*(kd * l_n+ ks * pow(r_v, alpha));\n    }\n    return color;\n}\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\n    vec3 x = texture( sa, p.yz ).xyz;\n    vec3 y = texture( sa, p.zx ).xyz;\n    vec3 z = texture( sa, p.xy ).xyz;\n    return x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n//mainImage函数\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    \n    //cast_ray;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n    if( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n    float ctime = iTime;\n    float an = sin(5.3+0.05*ctime) - 6.2831*(m.x-0.5);\n    vec3 ro = vec3(5.0*sin(an),5.0,5.0*cos(an));\n    vec3 ta = vec3(1.0,1.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n    vec2 dist = Ray_marching(ro,rd);\n    vec3 n = Get_Normal(dist.x*rd+ro);\n    if (dist.y==-1.0) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }else if (dist.y==1.0) {\n       vec3 kd = vec3(1.0,0.98431,0.9411);\n       vec3 temp=Phong_shader(dist.x*rd+ro, ro,kd);\n       fragColor = vec4(temp, 0.5);\n       return;\n    }else if(dist.y==0.0){\n        vec3 kd=0.7*pow( texturize( iChannel1, 0.45*(dist.x*rd+ro), n ).xyz, vec3(2.0) );\n        vec3 temp2=Phong_shader(dist.x*rd+ro,ro,kd) ;\n        fragColor = vec4(temp2, 1.0);\n        return;\n    }  \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}