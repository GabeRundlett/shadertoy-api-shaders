{
    "Shader": {
        "info": {
            "date": "1679310006",
            "description": "Read top of Image tab",
            "flags": 48,
            "hasliked": 0,
            "id": "md3XRr",
            "likes": 16,
            "name": "Touchscreen Keyboard",
            "published": 3,
            "tags": [
                "keyboard",
                "touchscreen"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 485
        },
        "renderpass": [
            {
                "code": "// Scuffed use of keyboard texture as a touchscreen. Imagine your keyboard\n// was a touch screen, and then try zooming in with two fingers by pressing\n// on a key and then sliding to the next one and so on, effectively using\n// the keyboard as a low resolution touchscreen. The four rows of the\n// keyboard are supported: number row (as well as ` - = delete keys), all\n// the letter keys and [ ] \\ tab left-shift ; ' , . / return keys. The\n// keyboard keys' physical locations were mapped based on the keyboard of a\n// 14\" MacBook Pro. Its a bit buggy, I can't really be bothered fixing it,\n// it was more just a proof of concept :D\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 o = texelFetch(iChannel1, ivec2(4, 0), 0).xy;\n    vec2 i = texelFetch(iChannel1, ivec2(5, 0), 0).xy;\n    vec2 p = texelFetch(iChannel1, ivec2(6, 0), 0).xy;\n    vec2 q = texelFetch(iChannel1, ivec2(7, 0), 0).xy;\n    \n    \n    vec2 c = transform(fragCoord, o, i, vec2(0.0), vec2(1.0, 0.0));\n    \n    if (clamp(c, vec2(0.0), iResolution.xy) != c) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = texture(iChannel0, c / iResolution.xy);\n    }\n    \n    if (p != INVALID && q != INVALID) {\n        if (distance(fragCoord, p) < 10.0) {\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n\n        if (distance(fragCoord, q) < 10.0) {\n            fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2 INVALID = vec2(-1, -1);\nconst vec2[] KEY_LOCATIONS = vec2[](\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(1915, 482),\n\tvec2(127, 340),\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(1888, 208),\n\tINVALID,\n\tINVALID,\n\tvec2(189, 76),\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(1474, 482),\n\tvec2(230, 482),\n\tvec2(367, 482),\n\tvec2(505, 482),\n\tvec2(647, 482),\n\tvec2(785, 482),\n\tvec2(917, 482),\n\tvec2(1055, 482),\n\tvec2(1192, 482),\n\tvec2(1340, 482),\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(334, 208),\n\tvec2(952, 76),\n\tvec2(675, 76),\n\tvec2(605, 208),\n\tvec2(578, 340),\n\tvec2(750, 208),\n\tvec2(888, 208),\n\tvec2(1029, 208),\n\tvec2(1265, 340),\n\tvec2(1160, 208),\n\tvec2(1301, 208),\n\tvec2(1437, 208),\n\tvec2(1231, 76),\n\tvec2(1088, 76),\n\tvec2(1405, 340),\n\tvec2(1543, 340),\n\tvec2(294, 340),\n\tvec2(720, 340),\n\tvec2(470, 208),\n\tvec2(855, 340),\n\tvec2(1131, 340),\n\tvec2(822, 76),\n\tvec2(437, 340),\n\tvec2(542, 76),\n\tvec2(986, 340),\n\tvec2(401, 76),\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(1576, 208),\n\tvec2(1753, 482),\n\tvec2(1366, 76),\n\tvec2(1612, 482),\n\tvec2(1509, 76),\n\tvec2(1648, 76),\n\tvec2(89, 482),\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tINVALID,\n\tvec2(1684, 340),\n\tvec2(1956, 340),\n\tvec2(1814, 340),\n\tvec2(1721, 208)\n);\nconst int NUM_LOCATIONS = 223;\nconst vec2 LOCATION_RESOLUTION = vec2(2039, 548);\n\nvec2 cmul(vec2 x, vec2 y) {\n    return vec2(x.x * y.x - x.y * y.y, x.x * y.y + x.y * y.x);\n}\n\nvec2 cdiv(vec2 x, vec2 y) {\n    return cmul(x, vec2(y.x, -y.y)) / dot(y, y);\n}\n\nvec2 transform(vec2 z, vec2 p, vec2 q, vec2 P, vec2 Q) {\n    return cdiv(cmul(z - p, Q - P), q - p) + P;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    int idx = int(floor(fragCoord.x) + floor(fragCoord.y) * iResolution.x);\n    \n    if (idx >= 8) {\n        return;\n    }\n    \n    vec2 o = texelFetch(iChannel1, ivec2(0, 0), 0).xy;\n    vec2 i = texelFetch(iChannel1, ivec2(1, 0), 0).xy;\n    vec2 p = texelFetch(iChannel1, ivec2(2, 0), 0).xy;\n    vec2 q = texelFetch(iChannel1, ivec2(3, 0), 0).xy;\n    vec2 ol = texelFetch(iChannel1, ivec2(4, 0), 0).xy;\n    vec2 il = texelFetch(iChannel1, ivec2(5, 0), 0).xy;\n    vec2 pl = texelFetch(iChannel1, ivec2(6, 0), 0).xy;\n    vec2 ql = texelFetch(iChannel1, ivec2(7, 0), 0).xy;\n    \n    \n    vec2 O, I, Ol, Il, P = INVALID, Q = INVALID, Pl, Ql;\n    \n    float bestPDist = 1e10;\n    float bestQDist = 1e10;\n    \n    for (int i = 0; i < NUM_LOCATIONS; i++) {\n        if (KEY_LOCATIONS[i] == INVALID || texelFetch(iChannel0, ivec2(i, 0), 0).r != 1.0) {\n            continue;\n        }\n        \n        vec2 keyLocation = KEY_LOCATIONS[i] / LOCATION_RESOLUTION.x * iResolution.x + vec2(0.0, iResolution.y * 0.25);\n        \n        if (p == INVALID || q == INVALID) {\n            if (P == INVALID) {\n                P = keyLocation;\n                pl = P;\n            } else {\n                Q = keyLocation;\n                ql = Q;\n                break;\n            }\n        }\n        \n        float pDist = distance(p, keyLocation);\n        float qDist = distance(q, keyLocation);\n        \n        bool setP = false;\n        bool setQ = false;\n        \n        if (pDist < bestPDist) {\n            if (qDist < bestQDist) {\n                if (pDist < qDist) {\n                    setP = true;\n                } else {\n                    setQ = true;\n                }\n            } else {\n                setP = true;\n            }\n        } else if (qDist < bestQDist) {\n            setQ = true;\n        }\n        \n        if (setP) {\n            if (P != INVALID && distance(q, P) < bestQDist) {\n                bestQDist = distance(q, P);\n                Q = P;\n            }\n            \n            bestPDist = pDist;\n            P = keyLocation;\n        } else if (setQ) {\n            if (Q != INVALID && distance(p, Q) < bestPDist) {\n                bestPDist = distance(p, Q);\n                P = Q;\n            }\n            \n            bestQDist = qDist;\n            Q = keyLocation;\n        }\n    }\n    \n    if (p != INVALID && q != INVALID) {\n        if ((P == INVALID) != (Q == INVALID)) {\n            if (P == INVALID) {\n                P = p;\n            } else {\n                Q = q;\n            }\n        }\n    }\n    \n    if (P == Q) {\n        P = INVALID;\n        Q = INVALID; \n    }\n    \n    if (p != INVALID && q != INVALID && P != INVALID && Q != INVALID) {\n        O = transform(o, p, q, P, Q);\n        I = transform(i, p, q, P, Q);\n    } else {\n        O = o;\n        I = i;\n    }\n    \n    if (P == INVALID || Q == INVALID) {\n        P = INVALID;\n        Q = INVALID;\n    }\n    \n    if (iFrame == 0) {\n        O = vec2(0.0);\n        I = vec2(1.0, 0.0);\n        P = INVALID;\n        Q = INVALID;\n        Ol = vec2(0.0);\n        Il = vec2(1.0);\n        Pl = INVALID;\n        Ql = INVALID;\n    }\n    \n    Ol = mix(ol, O, min(1.0, 10.0 * iTimeDelta));\n    Il = mix(il, I, min(1.0, 10.0 * iTimeDelta));\n    Pl = mix(pl, P, min(1.0, 10.0 * iTimeDelta));\n    Ql = mix(ql, Q, min(1.0, 10.0 * iTimeDelta));\n    \n    if (P == INVALID || Q == INVALID) {\n        Pl = Ql = INVALID;\n    }\n    \n    \n    switch (idx) {\n        case 0: fragColor.xy = O; return;\n        case 1: fragColor.xy = I; return;\n        case 2: fragColor.xy = P; return;\n        case 3: fragColor.xy = Q; return;\n        case 4: fragColor.xy = Ol; return;\n        case 5: fragColor.xy = Il; return;\n        case 6: fragColor.xy = Pl; return;\n        case 7: fragColor.xy = Ql; return;\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}