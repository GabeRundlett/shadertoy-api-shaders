{
    "Shader": {
        "info": {
            "date": "1650418376",
            "description": "noise box",
            "flags": 0,
            "hasliked": 0,
            "id": "Nt2cDd",
            "likes": 2,
            "name": "noise box",
            "published": 3,
            "tags": [
                "2d",
                "noise",
                "box",
                "noisebox"
            ],
            "usePreview": 0,
            "username": "jorge2017a2",
            "viewed": 200
        },
        "renderpass": [
            {
                "code": "//por jorge2017a2\n//19-abril-2020\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n// http://patriciogonzalezvivo.com\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n    \nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigBordeCol(vec3 pColObj, vec3 colOut, float distObj , vec3 colBorde )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,colBorde ,S2(abs( distObj)-0.01,0.0));\n  return colOut;\n}\n\nvec3 HacerVariosCuadros(vec2 uv, int xmax, int ymax, vec3 colOut)\n{  vec2 res=vec2(9999.9,-1.0); \n   vec2 pos;\n   \n   for(int j=0;j<ymax;j++)\n   for(int i=0;i<xmax;i++) \n   {\n        pos=vec2(0.0+float(i)*2.0,float(j)*2.0);\n        float d1= sdBox(uv-pos, vec2(1.0,1.0));   \n         res=opU2(res, vec2(d1,i+1+j));\n   }\n   vec3 colI= getColor(int( res.y));\n   vec3 col= DrawFigBorde(colI, colOut,res.x );\n   return col;\n}\n\nvec3 HacerVariosCuadrosv0(vec2 uv, int xmax, int ymax, vec3 colOut)\n{  float res=9999.9; \n   vec2 pos;\n   \n   for(int i=0;i<xmax;i++) \n   {    pos=vec2(0.0+float(i)*2.0,0.0);\n        float d1= sdBox(uv-pos, vec2(1.0,1.0));   \n        res=unionSDF(res, d1);\n   }\n   vec3 col= DrawFigBorde(vec3(0.0), colOut,res );\n   return col;\n}\n\nvec3 HacerCuadro(vec2 uv, vec2 pos, vec3 colOut)\n{   float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(vec3(0.5), colOut,d1 );\n    return col;\n}\n\nvec3 HacerCuadroCol(vec2 uv, vec2 pos, vec3 colIn,  vec3 colOut)\n{   float d1= sdBox(uv-pos, vec2(1.0,1.0));\n    vec3 col= DrawFigBorde(colIn, colOut,d1 );\n    return col;\n}\n\n\nvec3 HacerCuadroRnd(vec2 uv,vec3 colOut)\n{   vec2 pos;\n    uv=floor(uv/2.0+vec2(iTime));\n    float pnx= noise(uv+iTime)*5.0;\n    float pny= noise(uv+iTime)*4.0;\n    uv=vec2(floor(pnx), (pny));\n    vec3 col= HacerCuadro(uv,vec2(0.0),colOut);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(1.5,0.05);\n    float esc=10.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(0.8);\n    uv0.x+=10.0;\n    uv0.y+=2.0;\n    col=HacerCuadroCol(uv0, vec2(0.0,2.0),vec3(0.2), col);\n    col=HacerCuadroCol(uv0, vec2(2.0,2.0),vec3(0.3),col);\n    col=HacerCuadroCol(uv0, vec2(4.0,2.0),vec3(0.4),col);\n    col=HacerCuadroCol(uv0, vec2(6.0,2.0),vec3(0.5),col);\n    col=HacerCuadroCol(uv0, vec2(8.0,2.0),vec3(0.6),col);\n    \n    col= HacerVariosCuadros(uv-vec2(-10.0,2.0), 5, 4, col);\n    col= HacerCuadroRnd(uv,col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}