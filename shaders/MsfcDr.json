{
    "Shader": {
        "info": {
            "date": "1487683940",
            "description": "messing around with sdfs and lattices",
            "flags": 0,
            "hasliked": 0,
            "id": "MsfcDr",
            "likes": 0,
            "name": "Melty SDF Torus Lattice",
            "published": 3,
            "tags": [
                "sdf",
                "columns",
                "lattice",
                "camfer",
                "cabbibo"
            ],
            "usePreview": 0,
            "username": "bio998",
            "viewed": 619
        },
        "renderpass": [
            {
                "code": "// If you came here to learn, I just began this so!  Check out the Cabbibo SDF tutorial:\n// Well really it is Cabbibo's shader tutorial available at\n// https://www.shadertoy.com/view/Xl2XWt\n\n// Also using some of the following library\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n\n//Also using code from for the torus sdf\n// https://iquilezles.org/articles/distfunctions\n\n\n\n// This calculation basically gets a way for us to \n// transform the rays coming out of our eyes and going through the window.\n// If it doesn't make sense, thats ok. It doesn't make sense to me either :)\n// Whats important to remember is that this basically gives us a way to position\n// our window. We could you it to make the window look north, south, east, west, up, down\n// or ANYWHERE in between!\nmat3 calculateEyeRayTransformationMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n\n//this is from\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n//Union function from the SDF library\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  //vec2 q = vec2(length(p.xz)-t.x,p.y);\n  //return length(q)-t.y;\n    \n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\nvec2 sdfTorus( vec3 currentRayPosition){\n    \n      currentRayPosition.x -= iTime * 0.3;\n      currentRayPosition.z += iTime * 0.3;\n      currentRayPosition.z -= iTime * 0.5;\n\n\n  currentRayPosition.z -= 0.3;\n      currentRayPosition.y -= 0.5;\n\n    \n    pMod1(currentRayPosition.x,1.);\n    pMod1(currentRayPosition.y,1.);\n    pMod1(currentRayPosition.z,1.);\n\n    \n    vec2 torusRadii = vec2(0.4,0.03);\n    float torusID = 4.;\n    \n    vec2 torus = vec2( sdTorus(currentRayPosition,torusRadii), torusID);\n    return torus;\n    \n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 sdfRoundBox( vec3 currentRayPosition ){\n    \n  currentRayPosition.x -= sin(iTime) * 0.3;\n  currentRayPosition.z -= iTime * 0.3;\n  currentRayPosition.z -= iTime * 0.5;\n\n\n  currentRayPosition.z -= 0.3;\n  currentRayPosition.y -= 0.3;\n\n  \n\n    \n  pMod1(currentRayPosition.x,1.);\n  pMod1(currentRayPosition.y,0.6);\n  pMod1(currentRayPosition.z,1.);\n    \n    \n  \n    \n  float xpos = 0.3 * sin(iTime);\n  \n  // First we define our box position\n  //vec3 boxPosition = vec3( -.8 , -.4 , 0.2 );\n  vec3 boxPosition = vec3( xpos , 0.0 , 0.0 );\n    \n  // than we define our box dimensions using x , y and z\n  vec3 boxSize = vec3( .08 );\n    \n  // Here we get the 'adjusted ray position' which is just\n  // writing the point of the ray as if the origin of the \n  // space was where the box was positioned, instead of\n  // at 0,0,0 . AKA the difference between the vectors in\n  // vector format.\n  vec3 adjustedRayPosition = currentRayPosition - boxPosition;\n    \n  // finally we get the distance to the box surface.\n  // I don't get this part very much, but I bet Inigo does!\n  // Thanks for making code for us IQ !\n  vec3 distanceVec = abs( adjustedRayPosition ) - boxSize;\n  float maxDistance = max( distanceVec.x , max( distanceVec.y , distanceVec.z ) ); \n  //float distanceToBoxSurface = min( maxDistance , 0.0 ) + length( max( distanceVec , 0.0 ) );\n  \n  vec3 zero = vec3(0.2);\n  float distanceToBoxSurface = udRoundBox(adjustedRayPosition, boxSize, 0.05);\n  \n  // Finally we build the full box information, by giving it an ID\n  float boxID = 3.;\n    \t\n  // And there we have it! A fully described box!\n  vec2 box = vec2( distanceToBoxSurface,  boxID );\n    \n  return box;\n    \n}\n\nfloat smin( float a, float b)\n{\n   // float k = 0.77521;\n        \n    float k = 0.2521;\n\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat opBlend( float d1, float d2)\n{\n    //float d1 = primitiveA(p);\n    //float d2 = primitiveB(p);\n    return smin( d1, d2 );\n}\n\n// 'TAG : WHICH AM I CLOSER TO?'\n// This function takes in two things\n// and says which is closer by using the \n// distance to each thing, comparing them\n// and returning the one that is closer!\nvec2 whichThingAmICloserTo( vec2 thing1 , vec2 thing2 ){\n \n   vec2 closestThing;\n    \n   // Check out the balloon function\n   // and remember how the x of the returned\n   // information is the distance, and the y \n   // is the id of the thing!\n   if( thing1.x <= thing2.x ){\n       \n   \t   closestThing = thing1;\n       \n   }else if( thing2.x < thing1.x ){\n       \n       closestThing = thing2;\n       \n   }\n \n   return closestThing;\n    \n}\n\n    \n\n// Takes in the position of the ray, and feeds back\n// 2 values of how close it is to things in the world\n// what thing it is closest two in the world.\n\nvec2 mapTheWorld( vec3 currentRayPosition ){\n\n\n  vec2 result;\n    \n  vec2 torus = sdfTorus( currentRayPosition );\n  vec2 box     = sdfRoundBox( currentRayPosition );\n        \n  result = whichThingAmICloserTo( torus , box );\n  //result.x = opBlend( torus.x, box.x);\n    \n  float chamferRadius = 0.15;\n  float numberOfColumns = 3.;\n  float colUnion =  fOpUnionColumns(torus.x, box.x, chamferRadius, numberOfColumns);\n  result.x = colUnion;\n    \n  return result;\n\n\n}\n\n\n\n//---------------------------------------------------\n// SECTION 'C' : NAVIGATING THE WORLD\n//---------------------------------------------------\n\n// We want to know when the closeness to things in the world is\n// 0.0 , but if we wanted to get exactly to 0 it would take us\n// alot of time to be that precise. Here we define the laziness\n// our navigation function. try chaning the value to see what it does!\n// if you are getting too low of framerates, this value will help alot,\n// but can also make your scene look very different\n// from how it should\nconst float HOW_CLOSE_IS_CLOSE_ENOUGH = 0.005;\n\n// This is basically how big our scene is. each ray will be shot forward\n// until it reaches this distance. the smaller it is, the quicker the \n// ray will reach the edge, which should help speed up this function\nconst float FURTHEST_OUR_RAY_CAN_REACH = 30.;\n\n// This is how may steps our ray can take. Hopefully for this\n// simple of a world, it will very quickly get to the 'close enough' value\n// and stop the iteration, but for more complex scenes, this value\n// will dramatically change not only how good the scene looks\n// but how fast teh scene can render. \n\n// remember that for each pixel we are displaying, the 'mapTheWorld' function\n// could be called this many times! Thats ALOT of calculations!!!\n//const int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 800;\nconst int HOW_MANY_STEPS_CAN_OUR_RAY_TAKE = 21;\n\n\n\n\nvec2 checkRayHit( in vec3 eyePosition , in vec3 rayDirection ){\n\n  //First we set some default values\n \n  \n  // our distance to surface will get overwritten every step,\n  // so all that is important is that it is greater than our\n  // 'how close is close enough' value\n  float distanceToSurface \t\t\t= HOW_CLOSE_IS_CLOSE_ENOUGH * 2.;\n    \n  // The total distance traveled by the ray obviously should start at 0\n  float totalDistanceTraveledByRay \t= 0.;\n    \n  // if we hit something, this value will be overwritten by the\n  // totalDistance traveled, and if we don't hit something it will\n  // be overwritten by the furthest our ray can reach,\n  // so it can be whatever!\n  float finalDistanceTraveledByRay \t= -1.;\n    \n  // if our id is less that 0. , it means we haven't hit anything\n  // so lets start by saying we haven't hit anything!\n  float finalID = -1.;\n\n    \n    \n  //here is the loop where the magic happens\n  for( int i = 0; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE; i++ ){\n      \n    // First off, stop the iteration, if we are close enough to the surface!\n    if( distanceToSurface < HOW_CLOSE_IS_CLOSE_ENOUGH ) break;\n      \n    // Second off, stop the iteration, if we have reached the end of our scene! \n    if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ) break;\n    \n    // To check how close we are to things in the world,\n    // we need to get a position in the scene. to do this, \n    // we start at the rays origin, AKA the eye\n    // and move along the ray direction, the amount we have already traveled.\n    vec3 currentPositionOfRay = eyePosition + rayDirection * totalDistanceTraveledByRay;\n    \n    // Distance to and ID of things in the world\n    //--------------------------------------------------------------\n\t// SECTION 'D' : MAPPING THE WORLD , AKA 'SDFS ARE AWESOME!!!!'\n\t//--------------------------------------------------------------\n    vec2 distanceAndIDOfThingsInTheWorld = mapTheWorld( currentPositionOfRay );\n      \n      \n \t// we get out the results from our mapping of the world\n    // I am reassigning them for clarity\n    float distanceToThingsInTheWorld = distanceAndIDOfThingsInTheWorld.x;\n    float idOfClosestThingInTheWorld = distanceAndIDOfThingsInTheWorld.y;\n     \n    // We save out the distance to the surface, so that\n    // next iteration we can check to see if we are close enough \n    // to stop all this silly iteration\n    distanceToSurface           = distanceToThingsInTheWorld;\n      \n    // We are also finalID to the current closest id,\n    // because if we hit something, we will have the proper\n    // id, and we can skip reassigning it later!\n    finalID = idOfClosestThingInTheWorld;  \n     \n    // ATTENTION: THIS THING IS AWESOME!\n   \t// This last little calculation is probably the coolest hack\n    // of this entire tutorial. If we wanted too, we could basically \n    // step through the field at a constant amount, and at every step\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // say 'am i there yet', than move forward a little bit, and\n    // that would take FOREVER, and get really annoying.\n      \n    // Instead what we say is 'How far until we are there?'\n    // and move forward by that amount. This means that if\n    // we are really far away from everything, we can make large\n    // movements towards the surface, and if we are closer\n    // we can make more precise movements. making our marching functino\n    // faster, and ideally more precise!!\n      \n    // WOW!\n      \n    totalDistanceTraveledByRay += distanceToThingsInTheWorld;\n      \n\n  }\n\n  // if we hit something set the finalDirastnce traveled by\n  // ray to that distance!\n  if( totalDistanceTraveledByRay < FURTHEST_OUR_RAY_CAN_REACH ){\n  \tfinalDistanceTraveledByRay = totalDistanceTraveledByRay;\n  }\n    \n    \n  // If the total distance traveled by the ray is further than\n  // the ray can reach, that means that we've hit the edge of the scene\n  // Set the final distance to be the edge of the scene\n  // and the id to -1 to make sure we know we haven't hit anything\n  if( totalDistanceTraveledByRay > FURTHEST_OUR_RAY_CAN_REACH ){ \n  \tfinalDistanceTraveledByRay = FURTHEST_OUR_RAY_CAN_REACH;\n    finalID = -1.;\n  }\n\n  return vec2( finalDistanceTraveledByRay , finalID ); \n\n}\n\n\n\n\n\n\n\n//--------------------------------------------------------------\n// SECTION 'E' : COLORING THE WORLD\n//--------------------------------------------------------------\n\n\n\n// Here we are calcuting the normal of the surface\n// Although it looks like alot of code, it actually\n// is just trying to do something very simple, which\n// is to figure out in what direction the SDF is increasing.\n// What is amazing, is that this value is the same thing \n// as telling you what direction the surface faces, AKA the\n// normal of the surface. \nvec3 getNormalOfSurface( in vec3 positionOfHit ){\n    \n\tvec3 tinyChangeX = vec3( 0.001, 0.0, 0.0 );\n    vec3 tinyChangeY = vec3( 0.0 , 0.001 , 0.0 );\n    vec3 tinyChangeZ = vec3( 0.0 , 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = mapTheWorld( positionOfHit + tinyChangeX ).x; \n    float downTinyChangeInX = mapTheWorld( positionOfHit - tinyChangeX ).x; \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = mapTheWorld( positionOfHit + tinyChangeY ).x; \n    float downTinyChangeInY = mapTheWorld( positionOfHit - tinyChangeY ).x; \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n    float upTinyChangeInZ   = mapTheWorld( positionOfHit + tinyChangeZ ).x; \n    float downTinyChangeInZ = mapTheWorld( positionOfHit - tinyChangeZ ).x; \n    \n    float tinyChangeInZ = upTinyChangeInZ - downTinyChangeInZ;\n    \n    \n\tvec3 normal = vec3(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY,\n        \t\t\ttinyChangeInZ\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n\n\n\n\n// doing our background color is easy enough,\n// just make it pure black. like my soul.\nvec3 doBackgroundColor(){\n\treturn vec3( 0.1,0.2,0.2 );\n}\n\n\n\n\nvec3 doBalloonColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.8 , 0.8 , 0.8 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\n\nvec3 doCurveBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 balloonColor = vec3( 0.9 , 0.9 , 0.9 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = balloonColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n}\n\nvec3 doTorusColor(vec3 positionOfHit, vec3 normalOfSurface){\n    \n    vec3 sunPosition = vec3( 4. , 1. , 3. );\n    \n    // the direction of the light goes from the sun\n    // to the position of the hit\n    vec3 lightDirection = sunPosition - positionOfHit;\n   \t\n    \n    // Here we are 'normalizing' the light direction\n   \t// because we don't care how long it is, we\n    // only care what direction it is!\n    lightDirection = normalize( lightDirection );\n    \n    \n    // getting the value of how much the surface\n    // faces the light direction\n    float faceValue = dot( lightDirection , normalOfSurface );\n\t\n    // if the face value is negative, just make it 0.\n    // so it doesn't give back negative light values\n    // cuz that doesn't really make sense...\n    faceValue = max( 0. , faceValue );\n    \n    vec3 torusColor = vec3( 1. , .4 , 0.3 );\n    \n   \t// our final color is the balloon color multiplied\n    // by how much the surface faces the light\n    vec3 color = torusColor * faceValue;\n    \n    // add in a bit of ambient color\n    // just so we don't get any pure black\n    color += vec3( .1 , .14, .1 );\n    \n    \n\treturn color;\n    \n}\n\n\n\n// Here we are using the normal of the surface,\n// and mapping it to color, to show you just how cool\n// normals can be!\nvec3 doBoxColor(vec3 positionOfHit , vec3 normalOfSurface ){\n    \n    vec3 color = vec3( normalOfSurface.x , normalOfSurface.y , normalOfSurface.z );\n    \n    //could also just write color = normalOfSurce\n    //but trying to be explicit.\n    \n\treturn color;\n}\n\n\n\n\n// This is where we decide\n// what color the world will be!\n// and what marvelous colors it will be!\nvec3 colorTheWorld( vec2 rayHitInfo , vec3 eyePosition , vec3 rayDirection ){\n   \n  // remember for color\n  // x = red , y = green , z = blue\n  vec3 color;\n    \n  // THE LIL RAY WENT ALL THE WAY\n  // TO THE EDGE OF THE WORLD, \n  // AND DIDN'T HIT ANYTHING\n  if( rayHitInfo.y < 0.0 ){\n      \n  \tcolor = doBackgroundColor();  \n     \n      \n  // THE LIL RAY HIT SOMETHING!!!!\n  }else{\n      \n      // If we hit something, \n      // we also know how far the ray has to travel to hit it\n      // and because we know the direction of the ray, we can\n      // get the exact position of where we hit the surface\n      // by following the ray from the eye, along its direction\n      // for the however far it had to travel to hit something\n      vec3 positionOfHit = eyePosition + rayHitInfo.x * rayDirection;\n      \n      // We can then use this information to tell what direction\n      // the surface faces in\n      vec3 normalOfSurface = getNormalOfSurface( positionOfHit );\n      \n      \n      // 1.0 is the Balloon ID\n      if( rayHitInfo.y == 1.0 ){\n          \n  \t\tcolor = doBalloonColor( positionOfHit , normalOfSurface ); \n       \n          \n      // 2.0 is the Box ID\n      }else if( rayHitInfo.y == 2.0 ){\n          \n      \tcolor = doBoxColor( positionOfHit , normalOfSurface );   \n          \n      }else if( rayHitInfo.y == 3.0 ){\n          \n      \tcolor = doCurveBoxColor( positionOfHit , normalOfSurface );   \n          \n      }else if( rayHitInfo.y == 4.0 ){\n          \n      \tcolor = doTorusColor( positionOfHit , normalOfSurface );   \n          \n      }\n \n  \n  }\n    \n    \n    return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //---------------------------------------------------\n    // SECTION 'A' : ONE PROGRAM FOR EVERY PIXEL!\n    //---------------------------------------------------\n    \n    // Here we are getting our 'Position' of each pixel\n    // This section is important, because if we didn't\n    // divied by the resolution, our values would be masssive\n    // as fragCoord returns the value of how many pixels over we \n    // are. which is alot :)\n\tvec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n     \n    // thats a super long name, so maybe we will \n    // keep on using uv, but im explicitly defining it\n    // so you can see exactly what those two letters mean\n    vec2 xyPositionOfPixelInWindow = p;\n    \n    \n    \n    //---------------------------------------------------\n    // SECTION 'B' : BUILDING THE WINDOW\n    //---------------------------------------------------\n    \n    // We use the eye position to tell use where the viewer is\n    vec3 eyePosition = vec3( 0., 0., 2.);\n    \n    // This is the point the view is looking at. \n    // The window will be placed between the eye, and the \n    // position the eye is looking at!\n    vec3 pointWeAreLookingAt = vec3( 0. , 0. , 0. );\n  \n\t// This is where the magic of actual mathematics\n    // gives a way to actually place the window.\n    // the 0. at the end there gives the 'roll' of the transformation\n    // AKA we would be standing so up is up, but up could be changing \n    // like if we were one of those creepy dolls whos rotate their head\n    // all the way around along the z axis\n    mat3 eyeTransformationMatrix = calculateEyeRayTransformationMatrix( eyePosition , pointWeAreLookingAt , 0. ); \n   \n    \n    // Here we get the actual ray that goes out of the eye\n    // and through the individual pixel! This basically the only thing\n    // that is different between the pixels, but is also the bread and butter\n    // of ray tracing. It should be since it has the word 'ray' in its variable name...\n    // the 2. at the end is the 'lens length' . I don't know how to best\n    // describe this, but once the full scene is built, tryin playing with it\n    // to understand inherently how it works\n    vec3 rayComingOutOfEyeDirection = normalize( eyeTransformationMatrix * vec3( p.xy , 2. ) ); \n\n    \n    \n    //---------------------------------------------------\n\t// SECTION 'C' : NAVIGATING THE WORLD\n\t//---------------------------------------------------\n    vec2 rayHitInfo = checkRayHit( eyePosition , rayComingOutOfEyeDirection );\n    \n    \n    //--------------------------------------------------------------\n\t// SECTION 'E' : COLORING THE WORLD\n\t//--------------------------------------------------------------\n\tvec3 color = colorTheWorld( rayHitInfo , eyePosition , rayComingOutOfEyeDirection );\n    \n   \n   \t//--------------------------------------------------------------\n    // SECTION 'F' : Wrapping up\n    //--------------------------------------------------------------\n\tfragColor = vec4(color,1.0);\n    \n    \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW!\n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    // WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! WOW! \n    \n    \n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}