{
    "Shader": {
        "info": {
            "date": "1539229741",
            "description": "cosine set deformation between square and hex lattice, with works surprisingly well\ni was searching this shader of mine, and could not find it, i thought i uploaded or labeled it well,neither was ture so far. i might just have forgotten to ever submit it.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ttfDr",
            "likes": 9,
            "name": "parquetDeform hex in disguise",
            "published": 3,
            "tags": [
                "deformation",
                "hex",
                "lattice",
                "disguise",
                "parquet"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 657
        },
        "renderpass": [
            {
                "code": "\nfloat TAU=6.28318530718;\nfloat L=10.0;\n\n\nfloat miv(vec2 a){return min(a.x,a.y);}\n#define u2(a)((a)*2.-1.)\n////ss2t(a)changes a seesaw waves output(range [0..1])to a triangle wave.\n#define ss2t(a)a=abs(u2(a))\n\n\n\n\n//;return vec4(length(p-m));//to make a mouse work within a lattice as frame,you mzst delay this till the end.\n//meaning,you do it on a differential(between p and m)of all transforms.\n//;if(length(p)<.03)return vec4(0,0,0,1);return vec4(1);}\n\nvec2 hash(vec2 p,float z\n){vec3 p3=vec3(p,z+10.0*floor(iTime/40.0))\n ;p3=fract(p3*.1031)\n ;p3+=dot(p3,p3.yzx+19.19)\n ;float t=TAU*fract((p3.x+p3.y)*p3.z)\n ;return vec2(cos(t),sin(t));}\n//F andd G are known as \"skew constants\",scale a skew matrix to translate between orthogonal(square)and BarycentricRombus(tri/hex)\nfloat F=0.36602540378;//sqrt(3.)*.5-.5\nfloat G=0.21132486540;//(sqrt(3.)*.5-.5)/sqrt(3.)-.5-(.5/sqrt(3.))\n//https://www.shadertoy.com/view/Xs2fRd\nvec2 skew(vec2 p){float f=(p.x+p.y)*F;return p+vec2(f,f);}\nvec2 unskew(vec2 q){float g=(q.x+q.y)*G;return q-vec2(g,g);}\nvec4 sSkew(float t,vec2 p,vec2 m//time,fragmentPosition,MousePosition\n){ ;p*=4.;m*=4.//zoom\n ;t/=5.//;t=.5//debug overwrite\n ;t+=1.61*sin(p.x/iResolution.x)-cos(p.y/iResolution.y)//optional,transition between square and hex,over p.x,over time.\n//;t=fract(t);t=ss2t(t)//seesaw shape is less confusing than cosine shape:\n//;t=cos(t*5.)*.5+.5;//cosine shape instead of the asbovem,strangely causes brick pattern.\n ;t=cos(t)*.5+.5;//cosine shape instead of the asbovem,strangely causes brick pattern.less steep\n//;t=(p.x+iResolution.x)/iResolution.x/2.//debug overwrite t=0 makes a square patern,t=1 makes a hex pattern,\n ;p/=100.;m/=100.//treat this like a rotation matrix\n ;p=t*skew(p)+(1.-t)*p;m=t*skew(m)+(1.-t)*m//,except that its a skew matrix that lerps over T from L2 to L3\n ;vec2 q=vec2(0),n=vec2(0);//used only within the loop\n ;float r=999990.;//remember longest distance\n ;for(float i=-1.;i<2.;i++\n){for(float j=-1.;j<2.;j++){//i tried a voronoi,but mostly failed?\n  ;q=fract(p)-vec2(i,j)//fract,with voronoi L2 3x3-offsets \n   ;n=fract(m)\n   ;q=t*unskew(q)+(1.-t)*q;n=t*unskew(n)+(1.-t)*n\n   ;r=min(length(q-n),r)\n ;}};return vec4(r);}\n\n//skewed and then unskewed noise for a 2-simplex lattice.(equilateral triangles)is simplicial 2d noise\n//,but not necessarily what we mean by \"simplex noise\"\n//,because you could still do fbm with this and turn it into simplicial-value-noise.\n//actual simplex,nouse is smarter simoplicial-complex folding than this.this is the least common of value and gradient noise!\nfloat noise(vec2 p,float r2,float z,vec2 q){vec2 h=hash(q,z),d=unskew(q)-p;z=d.x*d.x+d.y*d.y\n ;return pow(max(0.,r2-z),4.)*dot(d,h);}\nfloat noise(vec2 p,float r2,float z \n){vec2 q=skew(p),r=fract(q);q=floor(q);return \n  noise(p,r2,z,q)\n+noise(p,r2,z,q+1.)\n+noise(p,r2,z,q+mix(vec2(0,1),vec2(1,0),vec2(step(r.y,r.x))));}\nfloat noise(vec2 p,float r2){float k=0.,o=1.;for(float z=.0;z<L;++z){k+=noise(p/o,r2,z)*o;o*=2.;}return k;}\nvec4 sNoise(float T,vec2 p\n){T=(T-10.)/2.\n ;float N=floor(T),pT=T/10.,k=0.,o=1.\n ;p/=pow(2.,6.64385618977*(1.-pT))\n ;T-=floor(T)\n ;for(float z=0.;z<N;++z){k+=noise(p/o,.5,z)*o;o*=2.;}\n ;float m=T\n ;if(N<1.)m=1.\n ;k+=m*noise(p/o,0.5,N)*o\n ;k=.5+pow(2.,(1.-pT)*8.96578428466)*0.1*k\n ;return vec4(k,k,k,1.);}\n\nvec4 sLatice(float T,vec2 p){T=(T-5.)/5.\n ;return vec4(vec3(.5+50.*pow(100000.,1.-sqrt(T))*noise(p/100.,.5*T,0.)),1);}\n\n\n\nvec4 sIsoWorld(float T,vec2 p){\n ;T=min(1.,(T-30.)/3.)\n ;float k=noise(p,.5)\n ;k=max(0.,min(1.,.5+.1*k))\n ;vec4 r;\n ;if(k<.5)r=vec4(0.,k,.7+.6*k,1.)\n ;else if(k<.55)r=vec4(1.,4.*(k-.5)+.8,.6,1.)//ocean?\n ;else if(k<.8)r=vec4(0,.5*k+.5,0,0)//sand?\n ;else if(k<.85)r=vec4(0,-9.*k+8.,0,1.)//dtrrs(bright green)?\n ;else r=vec4(0,(1.-k)*.3+.4,0,1)//grass(dark green)?\n ;return(1.-T)*vec4(k,k,k,1.)+T*r;}\n\nvoid mainImage(out vec4 o,vec2 p\n){p=p-.5*iResolution.xy\n ;vec2 m=iMouse.xy-.5*iResolution.xy;\n ;float T=iTime;\n//;T=mod(T,40.)\n ;o=vec4(.5,.5,.5,1.)\n//;if(T<5.)\n ;o=sSkew(T,p,m)\n//;else if(T<10.)o=sLatice(T,p-m)\n//;else if(T<30.)o=sNoise(T,p-m)\n//;else    o=sIsoWorld(T,p-m)\n ;}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}