{
    "Shader": {
        "info": {
            "date": "1600723467",
            "description": "info in shader",
            "flags": 0,
            "hasliked": 0,
            "id": "3s3cWn",
            "likes": 3,
            "name": "Delta Poetry",
            "published": 3,
            "tags": [
                "raymarch",
                "triangle",
                "reflections",
                "delta"
            ],
            "usePreview": 0,
            "username": "BradyInstead",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////\n//\t\t\tDELTA POETRY\t\t\t//\n//////////////////////////////////////\n\n//\tDelta = Change\n\n//\tThanks to iq for the raymarching inspiration\n//\tThanks to Connor Bell for the AA technique\n\n\n//////////////////////////////////////\n//\t\t\tVARIABLES\t\t\t\t//\n//////////////////////////////////////\n\n#define AA 2\n\n#define MAX_MARCH 12.\n#define MAX_MARCH_REFLECT 5.\n\n#define REFLECT_POWER 1.5\n#define NUM_REFLECTIONS 2\n\n\n//////////////////////////////////////\n//\t\t\t\tCODE\t\t\t\t//\n//////////////////////////////////////\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nvec2 delta(vec3 p)\n{   \n    //float sphere = length(p) - .5;\n    float tri = sdTriPrism(p, vec2(1., .1));\n    float stri = sdTriPrism(p, vec2(.4, .1));\n    tri = opSmoothSubtraction(stri, tri, .5);\n    \n    return vec2(tri, 1.);\n}\n  \nvec2 plane( vec3 p)\n{\n\treturn vec2(abs(p.y), 2.);\n}\n\nvec2 model(vec3 p)\n{   \n    vec2 sp = delta(p + vec3(0., -.2 + sin(iTime*3.)*.1, 0.));\n    vec2 pl = plane(p + vec3(0, .5, 0.));\n    \n    vec2 mod = vec2(0.);\n    if(sp.x < pl.x)\n        mod = sp;\n    else\n    \tmod = pl;\n    \n    return mod;\n    //return sp;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float maxdist, float modifier)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist).x*modifier;\n        dist += m;\n        \n        if(m < .01) return dist;\n        else if(dist > maxdist) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz).x - model(pos + eps.yzz).x,\n        model(pos + eps.zxz).x - model(pos + eps.zyz).x,\n        model(pos + eps.zzx).x - model(pos + eps.zzy).x));\n}\n\n\nvec3 background()\n{\n    return vec3(0.);\n}\n\nvec3 getColor(vec3 pos)\n{\n    float m = model(pos).y;\n    vec3 color = vec3(0.);\n    \n    if(m == 1.) // delta\n        return vec3(1., .65, 0.2);\n    if(m == 2.)\n        return vec3(1., 1., 1.);\n    \n    return background();\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 lp = vec3(2., 2., 2.);\n    vec3 ld = normalize((lp-pos)*rd);\n    \n    float dif = max(dot(nor,ld),.45);\n    vec3 lin = vec3(dif);\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    \n    col = pow(col, vec3(1.8));\n    \n    col *= getColor(pos);\n    \n    return col;\n}\n\nvec3 reflection(vec3 pos, vec3 rd, vec3 nor, float dist)\n{\n    if(dist < -.1) return background();\n    \n    vec3 rrd = reflect(rd, nor);\n    vec3 rro = pos + rrd*.02;\n    \n    vec3 col = vec3(0.);\n    vec3 fade = vec3(1.);\n    \n    for(int i = 0; i < NUM_REFLECTIONS; i++)\n    {\n    \tfloat rdist = raymarch(rro, rrd, MAX_MARCH_REFLECT, 1.);\n    \n    \tvec3 rpos = rro + rrd*rdist;\n    \tvec3 rnor = normal(rpos);\n    \n    \tfade -= pow(1. - rdist/MAX_MARCH_REFLECT, .5) *.4; //* vec3(.5, .9, .1);\n        \n        rrd = reflect(rrd, rnor);\n    \trro = rpos + rrd*.02;\n        \n        col += shade(rpos, rnor, rrd, rdist) * fade;\n    }\n    \n    return col;\n}\n\nvec3 render(vec2 p)\n{   \n    vec3 ro = vec3(4. * cos(iTime*.5), 1., 4. * sin(iTime*.5)); \n    vec3 ta = vec3(0.0, .25, 0.0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.5));\n    \n    float dist = raymarch(ro, rd, MAX_MARCH, 1.);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    vec3 ref = reflection(pos, rd, nor, dist);\n    \n    col += ref*REFLECT_POWER;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 color = vec3(0.);\n    for (int j = 0; j < AA; j++) {\n        for (int k = 0; k < AA; k++)\n        {\n            vec2 o = vec2(float(j), float(k)) / float(AA);\n            vec2 uv = (p + o / iResolution.xy);\n            color += render(uv);\n        }\n    }\n\n    color /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}