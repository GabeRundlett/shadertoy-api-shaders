{
    "Shader": {
        "info": {
            "date": "1566771681",
            "description": "Based on https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html \nand Kalil set: https://www.shadertoy.com/view/XlfGRj",
            "flags": 0,
            "hasliked": 0,
            "id": "ttBSRt",
            "likes": 7,
            "name": "Planet_00",
            "published": 3,
            "tags": [
                "kaliset",
                "scattering",
                "hdr",
                "atmosphere"
            ],
            "usePreview": 1,
            "username": "VB",
            "viewed": 1300
        },
        "renderpass": [
            {
                "code": "const float PI = 3.1415926535f;\n\n// ------ EARTH\nconst float EARTH_R = 1.0f;\nconst float ATM_R = EARTH_R * 1.0157f; // Karman line: 1.57% of Earth's radius\nconst float H0 = (ATM_R - EARTH_R) * 0.25f;\nconst float SCATTERING = 2.f;\nconst float SUN_INTENSITY = 100.0f;\nconst float EARTH_AMBIENT = 0.01f;\nconst vec3 EARTH_COLOR = 0.04f * vec3(0.2f, 0.9f, 0.2f);\nconst float N_STEPS_1 = 32.f;\nconst float N_STEPS_2 = 8.f;\nconst vec3 Kr = vec3(0.18f, 0.49f, 0.66f); // http://codeflow.org/entries/2011/apr/13/advanced-webgl-part-2-sky-rendering/\n\n// ------ SUN\nvec3 sunDir()\n{\n\treturn normalize(vec3(0.f, 1.f, 6.f));\n}\n\n// ------ CAMERA\nconst float FOCAL = 2.0;\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n// theta [0, pi]\n// phi [0, 2pi]\nvec3 sph(float theta, float phi, float r)\n{\n    return r * vec3(\n        sin(phi)*cos(theta),\n        cos(phi),\n        sin(phi)*sin(theta)  \n    );\n}\n\nvoid getRay(in vec2 fragCoord, out vec3 ro, out vec3 rd, out float fade)\n{\n    // misc\n    float r = EARTH_R;\n    vec3 top = vec3(0, r * 1.0001f, 0);\n\n    // time / segment\n    const float SEGMENT_DURATION = 5.5;\n    float t = iTime;\n    float segment = trunc(t / SEGMENT_DURATION);\n    float segT = mod(t, SEGMENT_DURATION) / SEGMENT_DURATION;\n    \n    // fade\n    float fadePercent = 0.12;\n    fade = smoothstep(0.0, fadePercent, segT) * (1.0 - smoothstep(1.0 - fadePercent, 1.0, segT));\n    if (t/SEGMENT_DURATION<0.5)\n        fade = 1.0;\n    \n    //     \n    float s = (segment+10.0)/202.0;\n    float rand1 = clamp(texture(iChannel0, vec2(s, s)).x, 0.0, 1.0);\n    float rand2 = clamp(texture(iChannel0, vec2(s, rand1)).x, 0.0, 1.0);\n    float rand3 = clamp(texture(iChannel0, vec2(rand1+s, rand2)).x, 0.0, 1.0);\n    \n    // source\n    float thetaCoef = rand1;\n    float thetaSign = sign(rand2-0.5);\n    float theta = -PI*0.5 + thetaSign * mix(0.4, 1.1, thetaCoef);\n    float phi = PI*0.5 + PI*0.27 * mix(-1.0, 1.0, rand3); \n    \n    float maxH = mix(r*6.0, r*3.0, thetaCoef); \n    float h = mix(r*1.1, maxH, rand2);\n    \n    vec3 start = vec3(theta, phi, h);    \n    \n    vec3 end = start;\n    end.x += thetaSign * PI * 0.35 / (1.0+thetaCoef);\n    \n    float maxZChange = r*2.5;\n    float minZ = r * 1.0001f;\n    float tgtZ = max(start.z * 0.3, minZ);\n    float change = min(start.z - tgtZ, maxZChange);\n    end.z = start.z - change;\n    \n    vec3 cur = mix(start, end, segT);       \n    ro = sph(cur.x, cur.y, cur.z);\n    \n    // target\n    vec3 dirTop = normalize(top - ro);\n    vec3 dirSun = sunDir();\n    float coef = length(ro - top) / r;\n    vec3 dir = mix(dirSun, dirTop, 0.4);\n    vec3 tgt = ro + dir * r;\n    \n    // final ray\n    mat3 cam = setCamera(ro, tgt, 0.0);    \n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    rd = cam * normalize(vec3(p.xy, FOCAL));        \n}\n\n// --- KALI SET\nconst int KALI_N_ITERATIONS = 20;\nconst int KALI_N_LAYERS = 6;\n\nconst float KALI_C = 0.53;\nconst float KALI_EVOLVE_SPEED = 0.004;\nconst float KALI_POW = 11.0;\nconst float KALI_LUM = 28.0;\n\nconst vec3 KALI_ORIGIN = vec3(1.578, 9.3, 3.8);\nconst vec3 KALI_COLOR_TONE = vec3(1.8, 1.4, 0.9);\n\nvec3 kali(vec3 o, vec3 d)\n{\n\tfloat avg = 0.0; \n \tvec3 p = o + d + KALI_EVOLVE_SPEED * (iTime);\n\tvec3 p0 = p;\n\tfloat l0 = length(p);\n\tfor (int k = 0; k < KALI_N_LAYERS; k++)\n\t{\n\t\tp = p0 + float(k) * d;\n\t\tfor (int i = 0; i < KALI_N_ITERATIONS; i++)\n\t\t{\n\t\t\tp = abs(p) / dot(p,p) - KALI_C;\n\t\t\tfloat l1 = length(p);\n\t\t\tavg += abs(l1-l0);\n\t\t\tl0 = l1;\n\t\t}\n\t}\n\tfloat v = avg * (1.0 / float(KALI_N_LAYERS * KALI_N_ITERATIONS));    \n    v = smoothstep(0.0, 2.0, v);\n    \n    vec3 hdr = vec3(v);    \n    hdr = pow(hdr, vec3(KALI_POW) * KALI_COLOR_TONE);    \n    return hdr * KALI_LUM;\n}\n\n// ------ SDF TOOLS\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nvec4 intersectSphere_raymarch(vec3 o, vec3 l, float r)\n{\n\tint max_steps = 200;\n\tfloat max_delta = r * 1e3f;\n\tfloat min_delta = r / 1e5f;\n\tfloat end_delta = r / 1e4f;\n\n\tvec4 NO_HIT = vec4(0.0f, 0.0f, 0.0f, -1.0f);\n\tvec3 rd = l;\n\tvec3 p = o;\n\n\tint i;\n\tfor (i = 0; i < max_steps; i++)\n\t{\n\t\tfloat d = sdSphere(p, r);\n\t\tif (d > max_delta)\n\t\t\treturn NO_HIT;\n\t\tif (d < end_delta)\n\t\t\tbreak;\n\t\tp += rd * max(d, min_delta);\n\t}\n\n\tif (i == max_steps)\n\t\treturn NO_HIT;\n\telse\n\t\treturn vec4(p, 1.0f);\n}\n\n// ------ SPHERE RAY INTERSECTION(S)\n// intersection with a sphere centered at zero\n// o: ray origin\n// l: ray direction, must be normalized\n// r: sphere radius\n// result.x : 1st intersection distance\n// result.y : 2nd intersection distance\n// result.z : nb intersections\nvec3 intersectSphere(vec3 o, vec3 l, float r)\n{\n\tvec3 res = vec3(0.0f);\n\tfloat l_dot_o = dot(l, o);\n\tfloat lo = length(o);\n\tfloat n = l_dot_o*l_dot_o - lo*lo + r*r;\n\n\t// 2 potential intersections\n\tif (n > 0.0f)\n\t{\n\t\tfloat sqn = sqrt(n);\n\t\tvec2 v = vec2(-l_dot_o + sqn, -l_dot_o - sqn); // v.x >= v.y, because sqrt(n) >= 0\n\n\t\tif (v.x >= 0.0)\n\t\t{\n\t\t\tif (v.y >= 0.0)\n\t\t\t{\n\t\t\t\tres.z = 2.0f;\n\t\t\t\tres.x = v.y;\n\t\t\t\tres.y = v.x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres.z = 1.0f;\n\t\t\t\tres.x = v.x;\n\t\t\t}\n\t\t}\n\t}\n\t// 1 intersection, this means the ray grazes the sphere shell we consider we missed the in this case\n\t//else if (n == 0.0f)\n\t//{\n\t//\tres.z = 1.0f;\n\t//\tres.x = -l_dot_o;\n\t//}\n\treturn res;\n}\n\n// ------ ATMOSPHERE PATH\n// finds the two intersection points between ray and earth / atmosphere shells\nint getAtmPath(vec3 a, vec3 b, out vec3 oA, out vec3 oB, float rAtmo, float rPlanet)\n{\n\tvec3 v = b - a;\n\tfloat l = length(v);\n\tvec3 rd = normalize(v);\n\tvec3 itAtm = intersectSphere(a, rd, rAtmo);\n\tvec3 itEarth = intersectSphere(a, rd, rPlanet);\n\n\t// inside atmosphere\n\tif (length(a) <= ATM_R)\n\t{\n\t\toA = a;\n\t\toB = b;\n\t\tif ((itEarth.z > 0.0) && (itEarth.x <= l))\n\t\t\toB = a + rd * itEarth.x;\n\t\telse if ((itAtm.z > 0.0) && (itAtm.x <= l))\n\t\t\toB = a + rd * itAtm.x;\n\t}\n\t// outside atmosphere\n\telse\n\t{\n\t\tif (itAtm.z <= 0.0)\n\t\t\treturn 0;\n\t\toA = a + rd * itAtm.x;\n\t\toB = b;\n\t\tif (itEarth.z > 0.0 && itEarth.x <= l)\n\t\t\toB = a + rd * itEarth.x;\n\t\telse if ((itAtm.z > 0.0) && (itAtm.x <= l))\n\t\t\toB = a + rd * itAtm.y;\n\t}\n\treturn 1;\n}\n\n// ------ PHASE FUNCTION\nfloat phaseFunction(float cos_theta, float g)\n{\n\tfloat a = (3.0f * (1.0f - g*g)) / (2.0f * (2.0f + g*g));\n\tfloat b = (1.0f + cos_theta*cos_theta) / pow(1.0f + g*g - 2.0f * g * cos_theta, 3.0f / 2.0f);\n\treturn a * b;\n}\n\n// ------ OPTICAL DEPTH (light scattered along AB)\nfloat exp_h_h0(vec3 p)\n{\n\tfloat h = length(p) - EARTH_R;\n//\tASSERT(h >= -0.001f);\n\tfloat res = exp(-h / H0);\n\treturn res;\n}\n\nfloat opticalDepth(vec3 pA, vec3 pB)\n{\n\t// integrate optical depth between a & b, using trapezoidal method\n\tfloat nSteps = N_STEPS_2;\n\tfloat res = 0.0f;\n\tvec3 dV = (pB - pA) / nSteps;\n\tfloat dL = length(dV);\n\tfor (float i = 1.0f; i <= nSteps; i++)\n\t{\n\t\tvec3 p1 = pA + dV * (i - 1.0f);\n\t\tvec3 p2 = pA + dV * (i);\n\t\tres += dL * 0.5f * (exp_h_h0(p1) + exp_h_h0(p2));\n\t}\n\treturn res;\n}\n\n// ------ ATMOSPHERE\n\nvec3 outScattering(vec3 pA, vec3 pB, vec3 LColor, vec3 absorption)\n{\n\t// light scattered away along AB\n\treturn (4.0f * PI) * SCATTERING * absorption * opticalDepth(pA, pB);\n}\n\nvec3 inScatteringInner(vec3 p, vec3 sd, vec3 LColor, vec3 absorption, vec3 ro)\n{\n\tvec3 n = normalize(p);\n\n\t// no scattering when in shadow\n\tfloat dotnsd = dot(n, sd);\n\tif (dotnsd < 0.f)\n\t\treturn vec3(0.0);\n\n\t// move the start point a bit inside the atmosphere\n\t// this is to avoid points on atm. boundary for which getAB may return 0\n\tvec3 pStart;\n\tpStart = p - n * 0.0000001f;\n\n\t// ---- p to cam\n\tvec3 cpA, cpB;\n\tint nIt2 = getAtmPath(pStart, ro, cpA, cpB, ATM_R, EARTH_R);\n\tvec3 osCam = vec3(0.0);\n\tif (nIt2 > 0)\n\t\tosCam = outScattering(cpA, cpB, LColor, absorption);\n\n\t// ---- p to sun\n\tvec3 spA, spB;\n\tint nIt = getAtmPath(pStart, pStart + sd * EARTH_R * 1e2f, spA, spB, ATM_R, EARTH_R);\n\tvec3 osSun = vec3(0.0);\n\tif (nIt > 0)\n\t\tosSun = outScattering(spA, spB, LColor, absorption);\n\n\treturn vec3(exp_h_h0(pStart)) *exp(-osSun - osCam);\n}\n\nvec3 inScattering(vec3 ro, vec3 pA, vec3 pB, vec3 LColor, vec3 absorption, float g)\n{\n\tvec3 sd = sunDir();\n\n\t// phase function\n\tvec3 toCam = normalize(pA - pB);\n\tfloat cos_theta = dot(sd, toCam);\n\tfloat phase = phaseFunction(cos_theta, g);\n\n\t// integrate in-scattering between pA and pB\n\tfloat nSteps = N_STEPS_1;\n\tvec3 dV = (pB - pA) / nSteps;\n\tfloat dL = length(dV);\n\tvec3 res = vec3(0.0);\n\tvec3 v1 = inScatteringInner(pA, sd, LColor, absorption, ro);\n\tfor (float i = 1.0; i <= nSteps; i++)\n\t{\n\t\tvec3 v2 = inScatteringInner(pA + dV * i, sd, LColor, absorption, ro);\n\t\tres += dL * 0.5f * (v1 + v2);\n\t\tv1 = v2;\n\t}\n\n\t// final formula\n\treturn SUN_INTENSITY * LColor * phase * absorption * res;\n}\n\nvec4 earthRay(vec3 ro, vec3 rd)\n{\n\tvec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);\n\tif (res.w <= 0.0)\n\t\treturn vec4(0.0);\n\n\t// diffuse\n\tvec3 p = vec3(res.x, res.y, res.z);\n\tvec3 n = normalize(p);\n\tfloat diff = SUN_INTENSITY * max(dot(n, sunDir()), 0.0f);\n\n\t// gi\n\tfloat amb = SUN_INTENSITY * EARTH_AMBIENT;\n\n\treturn vec4(EARTH_COLOR * (diff + amb), 1.0);\n}\n\nvec4 atmRay(vec3 ro, vec3 rd)\n{\n\tvec3 atmCol = vec3(0.f);\n\n\t// optional fake sun using phase\n\tvec4 res = intersectSphere_raymarch(ro, rd, EARTH_R);\n\tif (res.w <= 0.0f)\n\t{\n\t\tvec3 toCam = -rd; // normalize(pA - pB);\n\t\tfloat cos_theta = dot(sunDir(), toCam);\n\t\tfloat phase = phaseFunction(cos_theta, -0.99f);\n\t\tatmCol += vec3(1.5, 1.3, 0.9) * vec3(0.01f) * phase;\n\t}\n\n\t//\n\tvec3 pA, pB;\n\tint foundPath = getAtmPath(ro, ro + rd * EARTH_R * 1e2f, pA, pB, ATM_R, EARTH_R);\n\tif (foundPath == 0)\n\t\treturn vec4(atmCol, 0.0);\n\n\t//\n\tvec3 SUN_COLOR = vec3(1.0);\n\n\t// rayleigh\n\tvec3 rayleigh = inScattering(ro, pA, pB, SUN_COLOR, Kr, 0.0f);\n\tatmCol += rayleigh;\n\n\t//\n\treturn vec4(atmCol, 1.0);\n}\n\n// ------ POST PROCESSING\nconst float EXPOSURE = 0.95f;\nconst vec3 CONTRAST = vec3(2.1);\n\nvec3 postProcess(vec3 hdr)\n{\n    vec3 ldr = hdr * EXPOSURE;\n    ldr = ldr / (vec3(1.0) + ldr);\n\tvec3 gamma = pow(ldr, CONTRAST / vec3(2.2));\n    return gamma;\n}\n\n// --- MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get ray\n    float fade;\n\tvec3 ro,rd;\n    getRay(fragCoord, ro, rd, fade);\n        \n    // earth + atmosphere rays\n\tvec4 earth = earthRay(ro, rd);\n\tvec4 atm = atmRay(ro, rd);\n\n   \t// compute kali\n\tvec3 kaliC = vec3(0);\n    \n    if (earth.w < 0.01) \n        kaliC = kali(KALI_ORIGIN, rd);\n\n    vec3 hdr = mix(kaliC.rgb, earth.rgb, earth.w) + atm.rgb;\n    \n    //\n\tfragColor.rgb = fade * postProcess(hdr);\n}\n\n/*\nvec4 kali(vec2 p)\n{\n    vec4 kali = texture(iChannel0, p);\n    kali = pow(kali, vec4(2.2)) * 32.0;\n    return vec4(kali.rgb * 1.1, 1.0);\n}\n\nvoid mainImage(OUT(vec4, fragColor), IN(vec2, fragCoord)) \n{\n    // get ray\n\tvec3 ro, rd;\n\tgetRay(vec2(fragCoord.x, fragCoord.y), ro, rd);\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    \n    // earth + atmosphere rays\n\tvec4 earth = earthRay(ro, rd);\n\tvec4 atm = atmRay(ro, rd);\n\n    float atmIntensity = 0.0;\n        \n    // combine with starfield\n \tvec3 c = earth.rgb + atm.rgb;\n    if (earth.w < 0.001)\n    {\n        atmIntensity = (atm.r + atm.g + atm.b) / 3.0;\n        float m = smoothstep(0.5, 0.6, atmIntensity);        \n       \tc += kali(p).rgb * vec3(1.0-m);\n    }\n\n  \tc += kali(p).rgb;\n\n\tc *= EXPOSURE;\n\tc = c / (vec3(1.0f) + c);\n\n\tc = pow(c, vec3(CONTRAST / 2.2f));\n\n   // c = vec3(atmIntensity);\n    \n\tfragColor = vec4(c, 1.f);\n}\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}