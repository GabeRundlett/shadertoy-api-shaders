{
    "Shader": {
        "info": {
            "date": "1578702042",
            "description": "Rotating/translating 4D grid with motion blur and analytical fog.",
            "flags": 32,
            "hasliked": 0,
            "id": "wtVGDR",
            "likes": 90,
            "name": "4D Sun",
            "published": 3,
            "tags": [
                "3d",
                "raymarch",
                "sun",
                "space",
                "4d"
            ],
            "usePreview": 0,
            "username": "Klems",
            "viewed": 6245
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\n#define SAMPLES 5\n#define BLOOM_RADIUS 30.0\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 bloom = vec3(0);\n    float totfac = 0.0;\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    float offset = rnd.x*2.0*PI;\n    \n    // bloom\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float theta = 2.0*PI*PHI*float(i) + offset;\n        float radius = sqrt(float(i)) / sqrt(float(SAMPLES));\n        radius *= BLOOM_RADIUS;\n        vec2 offset = vec2(cos(theta), sin(theta))*radius;\n        vec2 delta = vec2( 1.0+exp(-abs(offset.y)*0.1) , 0.5);\n        offset *= delta;\n        vec4 here = textureGrad(iChannel0,(fragCoord+offset)/iResolution.xy, \n                                vec2(0.001, 0)*BLOOM_RADIUS, vec2(0, 0.001)*BLOOM_RADIUS);\n        float fact = smoothstep(BLOOM_RADIUS, 0.0, radius);\n        bloom += here.rgb*0.05*fact;\n        totfac += fact;\n    }\n    \n    bloom /= totfac;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = uv*2.0-1.0;\n    mo *= 0.01;\n    fragColor.r = textureLod(iChannel0, uv-mo*0.1, 0.0).r;\n    fragColor.g = textureLod(iChannel0, uv-mo*0.6, 0.0).g;\n    fragColor.b = textureLod(iChannel0, uv-mo*1.0, 0.0).b;\n    \n    fragColor.rgb += bloom*bloom*100.0;\n    vec2 vi = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb *= (1.0-sqrt(dot(vi,vi)*0.45));\n    fragColor.rgb = ACESFitted(fragColor.rgb);\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    fragColor.rgb += (rnd-0.5)*0.1;\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.5*vec4(0,1,3,0)))\n\n#define SAMPLES 4\n\nconst float motionBlurAmount = 5.0;\nconst float nearZ = 2.0;\n\n//#define warm\n//#define complex\n\n#ifdef warm\nconst vec3 sunCol = vec3(0.9, 0.55, 0.1)*9.0;\nconst vec3 subCol = vec3(0.5, 0.8, 0.9)*0.5;\nconst float sunRadius = 2.0;\nconst float sunExponent = -40.0;\nconst float timeScale = 3.0;\n#else\nconst vec3 sunCol = vec3(0.6, 0.2, 0.85)*9.0;\nconst vec3 subCol = vec3(0.5, 0.8, 0.9)*0.5;\nconst float sunRadius = 1.5;\nconst float sunExponent = -30.0;\nconst float timeScale = 2.0;\n#endif\n\nfloat time;\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash( in vec3 center ) {\n    return center + (hash33(center)-0.5) * 0.5;\n}\n\nfloat B2( vec2 _P ) {\n    return mod( 2.0*_P.y + _P.x + 1.0, 4.0 );\n}\n\nfloat B8( vec2 _P ) {\n    vec2\tP1 = mod( _P, 2.0 );\t\t\t\t\t// (P >> 0) & 1\n    vec2\tP2 = floor( 0.5 * mod( _P, 4.0 ) );\t\t// (P >> 1) & 1\n    vec2\tP4 = floor( 0.25 * mod( _P, 8.0 ) );\t// (P >> 2) & 1\n    return 4.0*(4.0*B2(P1) + B2(P2)) + B2(P4);\n}\n\nvec3 voronoi( in vec3 uv, in vec3 no, inout float rough ) {\n    \n    vec3 center = floor(uv) + 0.5;\n    vec3 bestCenterOffset = vec3(0);\n    float bestDist = 9e9;\n    vec3 bestCenterOffset2 = vec3(0);\n    float bestDist2 = 9e9;\n    \n    for (float x = -0.5 ; x < 1.0 ; x+=1.0)\n    for (float y = -0.5 ; y < 1.0 ; y+=1.0)\n    for (float z = -0.5 ; z < 1.0 ; z+=1.0) {\n\t\tvec3 offset = vec3(x, y, z);\n        vec3 newCenter = center + offset;\n        vec3 newCenterOffset = hash(newCenter);\n        vec3 temp = newCenterOffset - uv;\n        float distSq = dot(temp, temp);\n        if (distSq < bestDist) {\n    \t\tbestCenterOffset2 = bestCenterOffset;\n    \t\tbestDist2 = bestDist;\n            bestCenterOffset = newCenterOffset;\n            bestDist = distSq;\n        } else if (distSq < bestDist2) {\n            bestCenterOffset2 = newCenterOffset;\n            bestDist2 = distSq;\n        }\n    }\n    \n    vec3 n1 = normalize(no + hash33(bestCenterOffset)-0.5);\n    vec3 n2 = normalize(no + hash33(bestCenterOffset2)-0.5);\n    float d = (sqrt(bestDist)-sqrt(bestDist2));\n    float aad = 0.02;\n    return mix(n1, n2, smoothstep(-aad, +aad, d*2.0));\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat cross4D(vec4 p) {\n    float aa = length(p.xy)-0.1;\n    float bb = length(p.zw)-0.02;\n    float cc = length(p.yw)-0.03;\n    float de = smin(smin(aa, bb, 0.1), cc, 0.1)-0.03;\n    return de;\n}\n\nfloat de4d(vec4 p) {\n    p.zw *= rot(time*0.148);\n    p.xz *= rot(time*0.241);\n    p.wy *= rot(time*0.187);\n    p.x += time*3.687;\n   \tp.y -= time*0.37454;\n    vec4 inG = (fract(p) - 0.5);\n    return cross4D(inG);\n}\n\nfloat de(vec3 p) {\n    #ifdef complex\n    float d = dot(p, p);\n    d = de4d(vec4(p/d, d))*d;\n    #else\n    vec4 pp = vec4(p, length(p));\n    float d = dot(pp, pp);\n    d = de4d(pp/d)*d;\n    #endif\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 e = vec3(0.0, 0.001, 0.0);\n\treturn normalize(vec3(\n\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\tde(p+e.xxy)-de(p-e.xxy)));\t\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 computeLighting(in vec3 normal, in vec3 viewDir,\n                     in vec3 albedo, in float metallic, in float roughness,\n                     in vec3 lightDir, in vec3 radiance) {\n    vec3 result = vec3(0);\n    vec3 halfwayDir = normalize(viewDir + lightDir);\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n    float NDF = DistributionGGX(normal, halfwayDir, roughness);\n    float G = GeometrySmith(normal, viewDir, lightDir, roughness);\n    vec3 F = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), F0);\n    vec3 kS = F;\n    vec3 kD = 1.0 - kS;\n    kD *= 1.0 - metallic;\n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0);\n    vec3 specular = numerator / max(denominator, 0.001);\n    float NdotL = max(dot(normal, lightDir), 0.0);\n    result += (kD * albedo / PI + specular) * radiance * NdotL;\n    return result;\n}\n\n// fake subsurface scattering\nvec3 computeSSS(in vec3 normal, in vec3 viewDir, \n                in vec3 albedo, in float trans, in float index,\n                in vec3 lightDir, in vec3 radiance) {\n    float add = 1.0 - index;\n    add *= add;\n    add *= add;\n    add *= add;\n    add *= add;\n    float fr = dot(viewDir, normal)*0.5+0.5;\n    float lu = dot(viewDir, lightDir)*-0.5+0.5;\n    add *= fr*fr;\n    add *= lu;\n    return radiance*add*1.0*trans*albedo;\n}\n\n// approximation of the error function\nfloat erf( in float x ) {\n    //return tanh(1.202760580 * x);\n\tfloat sign_x = sign(x);\n\tfloat t = 1.0/(1.0 + 0.47047*abs(x));\n\tfloat result = 1.0 - t*(0.3480242 + t*(-0.0958798 + t*0.7478556))*exp(-(x*x));\n\treturn result * sign_x;\n}\n\nfloat getIntegral(vec3 start, vec3 dir, float dist) {\n    const float a = sunExponent;\n\tconst float b = sunRadius;\n    float k = start.x;\n    float l = dir.x;\n    float m = start.y;\n    float n = dir.y;\n    float o = start.z;\n    float p = dir.z;\n    float res = sqrt(PI);\n    res *= exp(b+a*(+k*k*(n*n+p*p)\n                    -m*m*(-1.0+n*n)\n                    -o*o*(-1.0+p*p)\n                    -2.0*k*l*o*p\n                    -2.0*m*n*(k*l+o*p) ));\n    res *= - erf(sqrt(-a)*dot(start, dir)) + erf(sqrt(-a)*(dot(start, dir)+dist));\n    res /= 2.0 * sqrt(-a);\n    res *= 500.0;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 acc = vec3(0);\n    \n    for (int i = min(0, iFrame) ; i < SAMPLES ; i++) {\n    \t\n        float bay = B8(floor(fragCoord))/64.0;\n        \n        #if SAMPLES > 1\n        vec3 rnd = hash33(vec3(fragCoord, iFrame*SAMPLES+i));\n        bay = rnd.z;\n        #endif\n        \n        time = (iTime + (1.0/120.0)*bay*motionBlurAmount)*timeScale;\n\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\t\t#if SAMPLES > 1\n        uv += (rnd.xy-0.5) / iResolution.y;\n        #endif\n        \n        vec3 from = vec3(0, 0, -1.4);\n        vec3 dir = normalize(vec3(uv*0.5, 1.0));\n        \n        mat2 rotxz = rot(time*0.3);\n\t\tmat2 rotxy = rot(sin(time*0.1));\n        if (iMouse.z > 0.5) {\n            vec2 delt = iMouse.xy-iMouse.zw;\n            rotxz *= rot(-delt.x*0.01);\n            rotxy *= rot(delt.y*0.01);\n        }\n        \n        from.zy *= rotxy;\n        from.xz *= rotxz;\n        dir.zy  *= rotxy;\n        dir.xz  *= rotxz;\n\n        float totdist = 0.0;\n        totdist += (0.1+pow(bay, 0.2)*0.4)*nearZ;\n        totdist += de(from+dir*totdist)*bay;\n\n        float ao = 0.0;\n        for (int steps = min(0, iFrame) ; steps < 150 ; steps++) {\n            vec3 p = from + totdist * dir;\n            float dist = de(p);\n            totdist += dist*(0.65+bay*0.1);\n            if (dist < 0.0001 || length(p) > 1.4) {\n                ao = float(steps)/149.0;\n                break;\n            }\n        }\n\n        vec3 result = vec3(0);\n        vec3 p = from + totdist * dir;\n\n        if (length(p) < 1.4) {\n\n            vec3 n = -getNormal(p);\n\n            vec3 sunDir = normalize(p);\n            const vec3 subDir = normalize(vec3(2, -7, 3));\n\n            float rough = 0.0;\n            vec3 vor = voronoi(p*600.0, n, rough);\n            n = normalize(n+vor*0.5);\n\n            vec4 albedo = vec4(0.98, 0.8, 0.5, 0.4);\n\n            result += computeLighting(n, dir, albedo.rgb, 0.9, albedo.a, sunDir, sunCol);\n            result += computeLighting(n, dir, albedo.rgb, 0.9, albedo.a, subDir, subCol);\n            result += computeSSS(n, dir, albedo.rgb, albedo.a, ao, sunDir, sunCol);\n            result += computeSSS(n, dir, albedo.rgb, albedo.a, ao, subDir, subCol);\n\n        } else {\n\n            // background\n            float rough = 0.0;\n            vec3 vor = voronoi(dir*800.0, vec3(0), rough);\n            result = vec3(pow(abs(vor.x), 500.0))*3.0;\n\n        }\n\n        fragColor.rgb = result;\n        float sun = getIntegral(from, dir, totdist);\n        fragColor.rgb += sun*0.005*sunCol;\n        \n        acc += fragColor.rgb;\n        \n    }\n    \n    acc /= float(SAMPLES);\n    fragColor.rgb = clamp(acc, vec3(0), vec3(10));\n    \n\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}