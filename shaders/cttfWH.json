{
    "Shader": {
        "info": {
            "date": "1701186972",
            "description": "All credit to @sylvain69780  - I just added candy cane wrap, colored lights and some faux foil effect-tmm\nIt's Christmas time for Math's lovers !\n[url=https://www.shadertoy.com/view/stB3WK]SDF for Archimedean Spiral[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "cttfWH",
            "likes": 11,
            "name": "RE-Decorated Christmas Spiral",
            "published": 3,
            "tags": [
                "christmas",
                "spiral",
                "archimed"
            ],
            "usePreview": 0,
            "username": "timmaffett",
            "viewed": 253
        },
        "renderpass": [
            {
                "code": "// Fork of \"Decorated Christmas Spiral\" by sylvain69780. https://shadertoy.com/view/3dVfDc\n// 2023-11-28 15:55:53\n\n/*\n    Decorated Christmas Spiral\n    --------------------------\n\n    Happy Christmas to you all the great Shadertoy community !\n    \n    It seems that the archimedian spiral can be used as a distance field with coordinates\n    a quite neat way to create a repetition domain where you can put blinking balls and ribbons.\n\n    Spirals are commonly use in art, and we may find this figure frequently in the nature.\n    Of course there is several kinds of spirals. For example, the Logarithmic Spiral that IQ  \n    used in his awesome Snail shader and the ones built using arc of circles (multiple center spirals).\n    \n    Related references:    \n\n    Nyarchimedes Spiral - kibble\n    https://www.shadertoy.com/view/lsS3WV\n    \n    Quick Lighting Tech - blackle \n    https://www.shadertoy.com/view/ttGfz1\n    \n    soft shadows in raymarched SDFs - IQ\n    https://iquilezles.org/articles/rmshadows\n    \n    outdoors lighting- IQ\n    https://iquilezles.org/articles/outdoorslighting\n    \n    Cubic Truchet Pattern - Shane\n    https://www.shadertoy.com/view/4lfcRl\n    \n*/\n\n#define COLOR_RANGE 360.\n\n// SNOW background from @g1mishr's \"Snow Simple \" https://www.shadertoy.com/view/DlGczD\n#define TILES 10.0\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\n\nvec4 snowBackground( vec2 fragCoord )\n{\n    vec4 fragColor = vec4(0.0);\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    uv.y -= 0.3;\n    \n    //uv.x -= 0.6;\n\n    \n    vec3 col = mix(vec3(0.0, 0.45, 0.85), vec3(1), -0.3-uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //if(curid.y > 10.0)\n    {\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n    \n    fragColor = smoothstep(0.0, 3.0, iTime)*fragColor;\n    }\n    return fragColor;\n}\n\n// END Snow Simple https://www.shadertoy.com/view/DlGczD\n\n\n\n// remember our ball color for later glowing\nvec3 ballColor = vec3(1.0);\n\n\n// #define AA\n\n#define MAX_STEPS 256\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define TAU 6.283185\n\n#define S smoothstep\n#define T (iTime)\n#define PI 3.14159265\n\n\nvec3 hsb2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return (c.z * mix( vec3(1.0), rgb, c.y));\n}\n\n\n\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdVerticalCapsule( vec3 p, float r, float h )\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat braids(vec3 p,float l,out float id) {\n    p.yz*=rot(p.x*3.14159*.5);\n    p.yz = abs(p.yz)-0.25; // 4 for the price of one\n    p.yz = (p.yz + vec2(p.z, -p.y))*sqrt(0.5); // Shortcut for 45-degrees rotation https://www.shadertoy.com/view/WsGyWR\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    p.yz = abs(p.yz)-0.05;\n    p.yz*=rot(p.x*3.14159*4.0);\n    p.yz = abs(p.yz)-0.02;\n    float d = sdVerticalCapsule(p,0.02,l);\n    return(d);\n}\n\nfloat carvings(vec3 p,float l, out float id) {\n    p.x-=.03;\n    float n = round(l);\n    id = clamp(round(p.x*2.0),1.0,n*2.0-1.0);\n    p.x-=id*.5;\n    p.zy*=rot(id*3.1415*.25); \n    return min(sdHexagram(p.xy,0.045),(sdBox(abs(p.xz)-0.033,vec2(0.022)+.006)));\n}\n\nfloat balls(vec3 p,float l, out float id) {\n    float rank = round(p.x);\n    p.yz*=rot((rank+0.25)*3.14159*.5);\n    p.x -= clamp(rank,0.0,l);\n    vec2 sector=step(0.0,p.yz);\n    id = sector.x + 2.0 * sector.y; \n    float r = .05*(1.0+id*.2);\n    p.yz = abs(p.yz);\n    p.yz -= vec2(.25,.25);\n    id += 4.0*rank;\n    return length(p)-r;\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat decoratedStick(vec3 p,out float m,out float glowDist) {\n    float l = 40.0;   // lenght of the stick\n    float d = 1e10; // distance\n    // materials : 1.0=spiral 2.x=tubes 3.x=stars and squares 4.0=inside spiral 5.0 Balls\n    m = 1.0;    // materials\n    glowDist = 1e10;\n    float core = length(vec3(p.x-clamp(p.x,0.0,l),p.y,p.z));\n    float outer = core-.25;\n    float inner = core-.22;\n    // Stars and Littles windows carvings, change sign to have holes or bumps\n    float id;\n    float carvings = -carvings(p,l,id);\n    d = smax(outer,carvings,.025);\n    if ( inner    < d ) { d = inner    ; m = 4.0+id/1024.0 ; }\n    // Braids \n    float braids = braids(p,l,id);\n    if ( braids < d ) { d=braids ; m= 2.0 + id/1024.0 ; }; // packing the ID in the material\n    // Balls :-)\n    float balls = balls(p,l,id);\n    if ( balls < d ) {\n        d=balls ;\n        m= 5.0 + id/1024.0 ;\n        ballColor = hsb2rgb(vec3(fract(m)*COLOR_RANGE,1.,0.3));\n    }; // packing the ID in the material\n    \n    \n    // Some blinking\n    float blink=1.0-cos(5.0*id+2.0*T);\n    glowDist = balls+blink*.1; \n    return d; \n}\n\n// approximated !\nfloat arclength(float turn) {\n\tfloat d = turn * turn;\n\treturn d * PI;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// arc length of archimedes spiral\nfloat spiralLength(float b, float a) {\n  // https://en.wikipedia.org/wiki/Archimedean_spiral\n  return 0.5*b*(a*sqrt(1.0+a*a)+log(a+sqrt(1.0+a*a)));\n}\n\n// SDF for Archimedean Spiral\n// https://www.shadertoy.com/view/stB3WK\nfloat spiralUV2(vec2 p,float b, float a1r,float a2r, float strip, out vec2 uv) {\n    float atn = atan(p.y, p.x)/TAU; // sector from -.5 to .5\n    float a1n = a1r/TAU, a2n = a2r/TAU; // predivide allows to use fract for modulo TAU computations\n    float w = b*TAU;\n    float r = length(p)/w;\n\tfloat grad = r - atn; // radial distance gradien used for domain repetition using \"round\"\n    float d = 1e9;\n    if (a2n-a1n >= fract(atn-a1n)) // opened sector case test\n    {\n        uv.y = w*(grad-round(clamp(r,a1n+.5,a2n-.5)-atn));\n        d=abs(uv.y)-.5*strip;\n    }\n    // inner end\n    vec2 q = p*rot(a1r);\n    q.x -= a1n*w;\n    q.x -= clamp(q.x,-strip*.5,strip*.5);\n    float db = length(q);\n    // outer end\n    q = p*rot(a2r);\n    q.x -= a2n*w;\n    q.x -= clamp(q.x,-strip*.5,strip*.5);\n    db = min(db,length(q));\n    // interior / exterieur distance to ends\n    d = d > 0.0 ? min(d,db) : max(d,-db);        \n    // UV calculations\n    float turn = round(grad); \n    float an = TAU*(turn + atn); \n    uv.x = spiralLength(b,an)-spiralLength(b,a1r);\n\treturn d;\n}\n\nfloat GetDist(vec3 p,out float objID, out float glowDist, out float dC ) {\n    p.xz *= rot(T*.1);\n    p.xy *= rot(-sin(T*.1)*.5);\n    glowDist = 1e10;\n    objID = 1.0;\n    float tmin = 0.0, tmax = 2.0;\n    vec2 uv;\n    float d = 1e10;\n    dC = abs(p.y)-0.5;\n    if ( dC < SURF_DIST ) {\n        float dSpiral = spiralUV2(p.xz,1.0/TAU,(tmin+1.0)*TAU,(tmax+2.0)*TAU,1.0,uv);\n        dC = abs(dSpiral);\n        if ( dSpiral < SURF_DIST-.02 ) {\n            vec3 q = vec3(uv.x, p.y, uv.y ); // spiral UV space\n            d = decoratedStick(q-vec3(.5,0.,0.),objID,glowDist);\n        } \n    }\n    return d;\n}\n\nfloat GetDist(vec3 p,out float glowDist,out float dC) {\n    float objID;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetDist(vec3 p) {\n    float glowDist,objID,dC;\n    return GetDist(p,objID,glowDist,dC);\n}\n\nfloat GetMat(vec3 p) {\n    float glowDist,objID,dC;\n    float d = GetDist(p,objID,glowDist,dC);\n    return objID;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd,out float glowCumul) {\n\tfloat dO=0.0;  \n    float dS;\n    float dC; // distance to cell boundaries\n    float glowDist;\n    glowCumul=0.0;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p,glowDist,dC);\n        dO += min(dS*.9,dC+0.05); \n        float at = 1.0 / (1. + pow(glowDist*20.,3.0) );\n        glowCumul+=at;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col = vec3(0);    \n    vec3 tcol = vec3(0);\n    vec3 target = vec3(0,-0.7,0);\n    vec3 ro = vec3(0, 0.7, 3.3);\n    vec2 m = iMouse.xy / iResolution.xy-.5;\n    float time=mod(T+10.0,20.0);\n    float atime=1.0;\n    if ( iMouse.x > 0.0 ) {\n        target = vec3(0,-0.8,0.0);\n        ro = vec3(0, 0.5, 2.0)*2.4;\n        ro.yz *= rot(m.y*3.14*.5);\n        ro.xz *= rot(-m.x*6.2831*2.0);\n    } else  \n        ro.y+=S(0.0,10.0,time)-S(10.0,20.0,time);\n     \n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++)\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    \n    vec3 rd = GetRayDir(uv, ro, target, 1.);\n\n    vec3 bgcol = vec3(0.10,0.28,0.10)*(1.-abs(rd.y)); // fast gradient - \"the sky will be blue\" - https://youtu.be/Cfe5UQ-1L9Q?t=2795\n    // default ball color, changed if there is a colored ball\n    ballColor = vec3(0.1,0.1,0.01); //vec3(1.);//\n    //SNOW//\n    vec3 snowBgcol = snowBackground( fragCoord ).rgb;\n    \n    float glowCumul;\n    float d = RayMarch(ro, rd,glowCumul);\n    if(d<MAX_DIST) {\n    \tvec3 pos = ro + rd * d;\n        float m = GetMat(pos);\n    \tvec3 nor = GetNormal(pos);\n        vec3 ref = reflect(rd, nor); \n        vec3 c=vec3(0);\n        float ks = 1.0; \n        float occ = calcOcclusion( pos, nor );\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = calcSoftshadow( pos+0.01*nor, sun_lig, 0.01, 0.25 );\n        float sun_spe = ks*pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\t\tvec3 lin = vec3(0.0);\n        // materials  \n        if ( m >=5.0 ) {            // Balls\n            float ballID = fract(m)*1024.0;\n            //ORIGc = fract(ballID*.5) > 0.0 ? vec3(1.0,0.1,0.01) : vec3(0.6,0.6,0.2)*.5;\n            \n            c = hsb2rgb(vec3(fract(m)*COLOR_RANGE,0.9,0.6));\n            \n            \n            float directionality=0.75;\n            float sharpness=0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            float blink=1.0+cos(5.0*ballID+2.0*T);\n            lin = vec3(blink)*3.3;\n            \n            c = spec * c;  \n        } else if ( m >=4.0 ) {     // bright inside spiral\n            float starID=fract(m)*1024.0;\n            float blink=1.0+cos(5.0*starID+3.15*T);\n            //COLOR// c = vec3(0.7,0.7,0.1)*.3;\n            \n            c = hsb2rgb(vec3(fract(m)*COLOR_RANGE,0.8,0.4));\n           \n            \n            lin = vec3(blink)*3.0;\n            float directionality=0.75;\n            float sharpness=0.3; //ORIG// 0.5;\n            float spec = length(sin(ref * 3.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            c = spec * c;  \n        } else if ( m >=3.0 ) {    \n            // Material Not used  c = vec3(0.3,0.1,0.01);\n        } else if ( m >=2.0 ) {     // tubes \n            float ropeID=fract(m)*1024.0;\n            \n            c = vec3(1.0);\n            \n            //ORIG//c = ropeID>2.0 ? c*vec3(0.5,0.5,0.01)*.25 : c*vec3(0.01,0.6,0.01)*.1;\n            \n            //candy cane\n            c = ropeID>2.0 ? c*vec3(0.9,0.01,0.01)*.25 : c*vec3(1.0,1.0,1.0)*.2;\n\n            \n            \n        } else if ( m >=1.0 ) {     \n            // spiral core\n            // https://www.shadertoy.com/view/tlscDB\n            //ORIG\n            c = vec3(0.28,0.2,0.02);\n            //blue//c = vec3(0.02,0.02,0.28);\n            \n            float directionality=0.75;\n            float sharpness=0.7;\n            float spec = length(sin(ref * 4.) * directionality + (1. - directionality)) / sqrt(3.);\n            spec = spec + pow(spec, 10. * sharpness);\n            \n            // give some'foil' reflection quality to core\n//#define NO_GLOW_ON_FOIL\n#ifdef NO_GLOW_ON_FOIL\n            c = hsb2rgb(vec3(spec*PI,0.8,0.9)) * c;  // glow does not effect foil\n#else       \n            c = ((hsb2rgb(vec3(spec*PI,0.8,0.9)) * c) + (hsb2rgb(vec3(glowCumul*spec*PI,0.8,0.9)) * c));\n#endif\n            c =  spec * c * (.3+.7*sun_sha);  \n        }\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha*.5;\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ*2.0;\n        lin += bou_dif*vec3(0.40,1.00,0.40)*occ*2.0;\n\t\tcol = c*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        // fog\n        float fog=S(12.0,5.0,d);\n        col = mix(bgcol, col, fog);\n        \n    } else {\n        col = snowBgcol;\n    }\n    col += ballColor*(glowCumul*0.75);\n    //ORIG yellow glow// col += vec3(0.1,0.1,0.01)*glowCumul;\n    col = sqrt(col);\t// gamma correction    \n    tcol+=col;\n#ifdef AA\n\t\t}\n\ttcol /= 4.;\n#endif\n    \n    fragColor = vec4(tcol,1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}