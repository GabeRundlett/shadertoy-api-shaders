{
    "Shader": {
        "info": {
            "date": "1467646343",
            "description": "Crunching!\n\nShare and enjoy!\n\nReference: https://www.shadertoy.com/view/MdKXD3",
            "flags": 0,
            "hasliked": 0,
            "id": "Xlc3zn",
            "likes": 7,
            "name": "[SH16A] P_Malin",
            "published": 3,
            "tags": [
                "challenge",
                "codesize",
                "sh16a"
            ],
            "usePreview": 0,
            "username": "P_Malin",
            "viewed": 1166
        },
        "renderpass": [
            {
                "code": "// [SH16A] P_Malin\n\n// Changes:\n\n// Remove variable 'a' for albedo color and overwrite 'Y' -> 598\n// Revert c.xwx because Fabrice told me off -> 600\n// Unroll macro to single loop (like all the cool kids are doing) credit to knarkowicz -> 597\n// Ok, now we all have the same shader.\n\n// Older Changes:\n\n// Apply Kabuto's comment (initialize Y vector using c.xwx) -> 602\n// From coyote / fb39ca4  Use fract for color / size calculation -> 605\n// Apply coyote's comment - Changed + (++n.y * a ) *   to + a * ++n.y * -> 606\n// Remove -- / ceil change -> 608\n// From coyote - change smoothstep distance to length(o - sign( t - t*Y ) )) -> 608\n// Remove float variables, use -- instead of -1. on result of mod, this also does -- on a so we can use ceil for color -> 609\n// Steal fb39ca4's awesome trick using sign to clamp range of AO -> 610\n// Scale Y by 2 -> 618\n// Revert (**) -> 618\n// (**) Remove n, assign Y in paren -> 614\n// apply fb39ca4, coyote's comment - replaced (a + a * n.y) with  + a * ++n.y -> 616\n\n// in order to add V(2,0,0) to sphere color, use +Y+Y and swizzle .rgb to .grb (needed to reinstate n variable) -> 617\n\n// Older Changes:\n\n// Changed shadow condition from >= to <  -> 618\n// Removed variable s -> 619\n// Idea from fb39ca4 - limit smoothstep by clamping sphere position -> 621\n// Use r instead of 0. in ground plane albedo color calculations -> 629\n// Move .y out of calculation for r -> 631\n// Revert (*), normalize Y in assignment -> 633\n// Applied coyote's comment - Select normal in albedo floor / sphere test -> 635 chars\n// Applied fb39ca4. coyote's comment - checkerboard calc c = mod( o, Z ) - 1; c.x * c.z > 0. ? .. : -> 639 \n// Applied coyote's comment - Remove ) from start of macro and = from end or space becomes delimiter -> 640\n// Remove variable p (use n in trace instead of p, overwrite up vector Y with normal) -> 642\n// (*) Encode .2 in Y axis (we always normalize), need to change ambient sky and sphere col calculation -> 644\n\n// Older Changes:\n\n// Apply iq comment ( \"add  c.xyz =\" to end of C macro and remove from call location, rename use of d.x, d.z to c.x, c.z ) -> 645\n// Apply iq / Coyote commnet ( add \") ) ;\" to beginning of C macro and removed from call location ) -> 647\n// Add more precision to ray origin -> 649\n// Steal Stubbe's great idea and negate ray direction saving lots of '-' -> 648\n    \n// Older Changes:\n\n// Apply iq's commnet ( only output xyz ) -> 650\n// Changed order of ? : to allow r < o.y instead of o.y <= r -> 651\n// Applied FabriceNeyret's comment ( Remove {} from for loop, and use ',' ) -> 653\n// (No change) Shadertoy character counting updated -> 655\n// Wait, what I declared a float variable I didnt use! -> 653\n// Renamed variables (LESS SHOUTY)\n\n// Older Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n\n\n#define V vec3\n#define N normalize\n\nvoid mainImage( out vec4 c, vec2 x )\n{    \n\tV \tY = V(0,1,0), // Constant Up\n        n = Y,\n    \td = iResolution,        \n\t    // o = Ray Origin\n        o = V( .851, 2, -2.87677 ),  //o = V( cos(5.), 1, sin(5.) )*3.-Y,\n        t = N( Y *.2 + o ),\n        v = N( cross( t, Y ) );\n    \n    // d = Ray Direction, store for later in v for view direction\n   \td = v = N( mat3( v, cross( t, v ), t ) * V( x - d.xy / 2., d.y ) );\n    \n    for (int i = 0; i < 128; i++) \n        // Sphere centre\n        t = clamp( ceil( o - .5 ), -2., 2. ), \n        // Sphere Size\n        t.y = .4 - fract( c.a = t.x * 2.5 + t.z * .5 ) * .3,\n        o -= \n            i == 63 \n                ?   d = mod( o, 2. ) -1.,\n        \t\t\t// surface albedo\n                    Y = .01 < o.y\n                        ? \tn = N(o - t), \n        \t\t\t\t\tY + Y + V( 3, -8, 6 ) * floor( c.a + 6. ) / 50.\n                        : \tV( d.x * d.z > .0 ? .8 : texture( iChannel0, .1 * o.xz ).x )\n                            * smoothstep( 0., .5, length( o - sign( t - t*Y ) ) ),\n                    // d = light dir\n                    d = N( V( 6, -7, 5 )),\n                    // step ray by .01\n                    d * .01\n                : d * min( o, length( o - t ) - t ).y;         \n    \n    c.yxz = sqrt(\n        // Shadow and N dot L term\n        V( o.y > 1. ) * dot( n, -d ) *\n             \t( \n        \t\t\t// directional\n                    Y * V(.51,.6,.33) \n                    // specular\n                  \t+ pow( max( 0., dot( reflect( v, n ), d ) ), 16. ) \n                ) \n        // Ambient / sky\n        + Y * ++n.y * V( 7, 5, 10 ) / 80. );          \n}\n\n\n\n/*\n// Changes:\n\n// Apply Kabuto's comment (initialize Y vector using c.xwx) -> 602\n// From coyote / fb39ca4  Use fract for color / size calculation -> 605\n// Apply coyote's comment - Changed + (++n.y * a ) *   to + a * ++n.y * -> 606\n// Remove -- / ceil change -> 608\n// Change smoothstep distance to length(o - sign( t - t*Y ) )) -> 608\n// Remove float variables, use -- instead of -1. on result of mod, this also does -- on a so we can use ceil for color -> 609\n// Steal fb39ca4's awesome trick using sign to clamp range of AO -> 610\n// Scale Y by 2 -> 618\n// Revert (**) -> 618\n// (**) Remove n, assign Y in paren -> 614\n// apply fb39ca4, coyote's comment - replaced (a + a * n.y) with  + a * ++n.y -> 616\n\n// in order to add V(2,0,0) to sphere color, use +Y+Y and swizzle .rgb to .grb (needed to reinstate n variable) -> 617\n\n// Older Changes:\n\n// Changed shadow condition from >= to <  -> 618\n// Removed variable s -> 619\n// Idea from fb39ca4 - limit smoothstep by clamping sphere position -> 621\n// Use r instead of 0. in ground plane albedo color calculations -> 629\n// Move .y out of calculation for r -> 631\n// Revert (*), normalize Y in assignment -> 633\n// Applied coyote's comment - Select normal in albedo floor / sphere test -> 635 chars\n// Applied fb39ca4. coyote's comment - checkerboard calc c = mod( o, Z ) - 1; c.x * c.z > 0. ? .. : -> 639 \n// Applied coyote's comment - Remove ) from start of macro and = from end or space becomes delimiter -> 640\n// Remove variable p (use n in trace instead of p, overwrite up vector Y with normal) -> 642\n// (*) Encode .2 in Y axis (we always normalize), need to change ambient sky and sphere col calculation -> 644\n\n// Older Changes:\n\n// Apply iq comment ( \"add  c.xyz =\" to end of C macro and remove from call location, rename use of d.x, d.z to c.x, c.z ) -> 645\n// Apply iq / Coyote commnet ( add \") ) ;\" to beginning of C macro and removed from call location ) -> 647\n// Add more precision to ray origin -> 649\n// Steal Stubbe's great idea and negate ray direction saving lots of '-' -> 648\n    \n// Older Changes:\n\n// Apply iq's commnet ( only output xyz ) -> 650\n// Changed order of ? : to allow r < o.y instead of o.y <= r -> 651\n// Applied FabriceNeyret's comment ( Remove {} from for loop, and use ',' ) -> 653\n// (No change) Shadertoy character counting updated -> 655\n// Wait, what I declared a float variable I didnt use! -> 653\n// Renamed variables (LESS SHOUTY)\n\n// Older Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n\n#define V vec3\n#define N normalize\n\n// C() (C)ast ray, \n// global inputs o = ray (O)rigin, d = Ray (D)ir\n// outputs o = Intersection, s = offset to sphere, q = sphere index, \n#define C  ); for( int i=0; i < 64; i++) t = clamp( ceil( o - .5 ), -2., 2. ), t.y = .4 - fract( c.a = t.x * 2.5 + t.z * .5 ) * .3, o -= d * min( o, length( o - t ) - t ).y; c.yxz\n\nvoid mainImage( out vec4 c, vec2 x )\n{    \n\tV \tv,\n        Y = c.xwx, // Constant Up\n        n=Y,\n    \td = iResolution,\n\t    // o = Ray Origin\n        o = V( .851, 2, -2.87677 ),  //o = V( cos(5.), 1, sin(5.) )*3.-Y,\n        t = N( Y *.2 + o ),\n        a = N( cross( t, Y ) );\n    \n    // d = Ray Direction, store for later in v for view direction\n    d = v = N( mat3( a, cross( t, a ), t ) * V( x - d.xy / 2., d.y ) // );\n    \n    C = mod( o, 2. ) -1.;\n\n    // surface (a)lbedo\n\ta = .01 < o.y\n        ? n = N(o - t), Y + Y + V( 3, -8, 6 ) * floor( c.a + 6. ) / 50.\n        : V( c.y * c.z > .0 ? .8 : texture( iChannel0, .1 * o.xz ).x )\n    \t\t\t* smoothstep( 0., .5, length( o - sign( t - t*Y ) ) );        \n\n\t// d = light dir\n    // step ray by .01\n    o -= .01 * (d = N( V( 6, -7, 5 )) // );\n          \n    // Cast Ray\n    C = sqrt( \n        // Shadow and N dot L term\n        V( o.y > 1. ) * dot( n, -d ) *\n             \t( \n        \t\t\t// directional\n                    a * V(.51,.6,.33) \n                    // specular\n                  \t+ pow( max( 0., dot( reflect( v, n ), d ) ), 16. ) \n                ) \n        // Ambient / sky\n        + a * ++n.y * V( 7, 5, 10 ) / 80. );          \n}\n*/\n\n////////////////////////////////////////////\n\n/*\n// Changes:\n\n// Removed variable s -> 619\n// Idea from fb39ca4 - limit smoothstep by clamping sphere position -> 621\n// Use r instead of 0. in ground plane albedo color calculations -> 629\n// Move .y out of calculation for r -> 631\n// Revert (*), normalize Y in assignment -> 633\n// Applied coyote's comment - Select normal in albedo floor / sphere test -> 635 chars\n// Applied fb39ca4. coyote's comment - checkerboard calc c = mod( o, Z ) - 1; c.x * c.z > 0. ? .. : -> 639 \n// Applied coyote's comment - Remove ) from start of macro and = from end or space becomes delimiter -> 640\n// Remove variable p (use n in trace instead of p, overwrite up vector Y with normal) -> 642\n// (*) Encode .2 in Y axis (we always normalize), need to change ambient sky and sphere col calculation -> 644\n\n// Older Changes:\n\n// Apply iq comment ( \"add  c.xyz =\" to end of C macro and remove from call location, rename use of d.x, d.z to c.x, c.z ) -> 645\n// Apply iq / Coyote commnet ( add \") ) ;\" to beginning of C macro and removed from call location ) -> 647\n// Add more precision to ray origin -> 649\n// Steal Stubbe's great idea and negate ray direction saving lots of '-' -> 648\n    \n// Older Changes:\n\n// Apply iq's commnet ( only output xyz ) -> 650\n// Changed order of ? : to allow r < o.y instead of o.y <= r -> 651\n// Applied FabriceNeyret's comment ( Remove {} from for loop, and use ',' ) -> 653\n// (No change) Shadertoy character counting updated -> 655\n// Wait, what I declared a float variable I didnt use! -> 653\n// Renamed variables (LESS SHOUTY)\n\n// Older Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n\n#define V vec3\n#define N normalize\n\n// C() (C)ast ray, \n// global inputs o = ray (O)rigin, d = Ray (D)ir\n// outputs o = Intersection, s = offset to sphere, q = sphere index, \n#define C  ); r =.01; for( int i=0; i < 64; i++) o -= d * r, t = clamp( ceil( o - .5 ), -Z, Z ), t.y = .4 - mod( q = t.x * 5. + t.z, Z ) * .15, r = min( o, length( o - t ) - t ).y; c.xyz\n\nvoid mainImage( out vec4 c, vec2 x )\n{\n\tfloat q, r, \n    \tZ = 2.; // constant 2.\n    \n\tV \tv,\n        Y = V( 0, 1, 0 ), // Constant Up\n    \td = iResolution,\n        o = V( .851, 2, -2.87677 ),\n        //o = V( .851, 2, -2.8768 ),\t\t\n        //o = V( cos(5.), 1, sin(5.) )*3.-Y,\n        t = N( Y *.2 + o ), // we could * o by 5 here instead of scale Y by .2\n        a = N( cross( t, Y ) );\n    \n    // o = Ray Origin\n    // d = Ray Direction, store for later in v for view direction\n    d = v = N( mat3( a, cross( t, a ), t ) * V( x - d.xy / Z, d.y ) // ); is in C macro\n    \n    // Cast Ray\n    C \n                                               \n\t// c.xyz\t\tis in C macro\n\n    = mod( o, Z ) - 1.;\n\n    // surface (a)lbedo\n\ta = r < o.y\n        ? Y = N(o - t), V( -8, 3, 6 ) * floor( q / Z + 6. ) / 50. + V(Z,0,0)\n        : V( c.x * c.z > r ? .8 : texture( iChannel0, .1 * o.xz ).x )\n    \t\t\t* smoothstep( r, .5, length( (o - clamp( t, -1., 1. )).xz ) );        \n\n\t// d = light dir\n    d = N( V( 6, -7, 5 ) // ); is in C macro\n    \n          \n    // Cast Ray\n    C\n             \n\t// c.xyz\t\tis in C macro        \n    = sqrt( \n        // Ambient / sky\n        (a + a * Y.y) * V( 5, 7, 10 ) / 80.  \n        // Shadow and N dot L term\n        - V( o.y <= r ) * dot( Y, d ) *\n             \t( \n        \t\t\t// directional\n                    a * V(.6,.51,.33) \n                    // specular\n                  \t+ pow( max( 0., dot( reflect( v, Y ), d ) ), 16. ) \n                ) \n             );\n}\n\n*/\n          \n////////////////////////////////////////////\n\n/*\n// Changes:\n\n// Apply iq comment ( \"add  c.xyz =\" to end of C macro and remove from call location, rename use of d.x, d.z to c.x, c.z ) -> 645\n// Apply iq / Coyote commnet ( add \") ) ;\" to beginning of C macro and removed from call location ) -> 647\n// Add more precision to ray origin -> 649\n// Steal Stubbe's great idea and negate ray direction saving lots of '-' -> 648\n    \n// Older Changes:\n\n// Apply iq's commnet ( only output xyz ) -> 650\n// Changed order of ? : to allow r < o.y instead of o.y <= r -> 651\n// Applied FabriceNeyret's comment ( Remove {} from for loop, and use ',' ) -> 653\n// (No change) Shadertoy character counting updated -> 655\n// Wait, what I declared a float variable I didnt use! -> 653\n// Renamed variables (LESS SHOUTY)\n\n// Older Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define N normalize\n\n// C() (C)ast ray, \n// global inputs o = ray (O)rigin, d = Ray (D)ir\n// outputs o = Intersection, s = offset to sphere, q = sphere index, \n#define C  ) ); r =.01; for( int i=0; i < 64; i++) o -= d * r, p = clamp( ceil( o - .5 ), -Z, Z ), p.y = .4 - mod( q = p.x * 5. + p.z, Z ) * .15, r = min( o.y, length( s = o - p ) - p.y ); c.xyz = \n\nvoid mainImage( out vec4 c, vec2 x )\n{\n\tfloat q, r, \n    \tZ = 2.; // constant 2.\n    \n\tV \tp, v, n,\n        Y = V( 0, 1, 0 ), // Constant Up\n    \td = iResolution,\n        o = V( .851, 2, -2.87677 ),\n        //o = V( .851, 2, -2.8768 ),\t\t\n        //o = V( cos(5.), 1, sin(5.) )*3.-Y,\n        s = N( Y * .2 + o ),\n        a = N( cross( s, Y ) );\n    \n    // o = Ray Origin\n    // d = Ray Direction, store for later in v for view direction\n    d = v = N( mat3( a, cross( s, a ), s ) * V( x - d.xy / Z, d.y // ) ); is in C macro\n    \n    // Cast Ray\n    C \n                                               \n\t// c.xyz =\t\tis in C macro\n\n    mod( o, Z );\n    n = o * o;    \n    // surface (a)lbedo\n\ta = r < o.y\n        ? V( -8, 3, 6 ) * floor( q / Z + 6. ) / 50. + Y.yxx * Z\n        : V( c.x > 1. ^^ c.z < 1. ? .8 : texture( iChannel0, .1 * o.xz ).x )\n    \t\t\t* smoothstep( 0., .5, max( n.x, n.z ) < 2.25 ? length( s.xz ) : Z );         \n\n    n = r < o.y ? N( s ) : Y; // n = surface normal\n\n\t// d = light dir\n    d = N( V( 6, -7, 5  // ) ); is in C macro\n    \n    \n          \n    // Cast Ray\n    C\n             \n\t// c.xyz =\t\tis in C macro        \n    sqrt( \n        // Ambient / sky\n        a * ( Y + n ).y * V( 5, 7, 10 ) / 80.  \n        // Shadow and N dot L term\n        - V( o.y <= r ) * dot( n, d ) *\n             \t( \n        \t\t\t// directional\n                    a * V(.6,.51,.33) \n                    // specular\n                  \t+ pow( max( 0., dot( reflect( v, n ), d ) ), 16. ) \n                ) \n             );\n}\n*/\n\n////////////////////////////////////////////\n\n/*\n// Changes:\n\n// Apply iq's commnet ( only output xyz ) -> 650\n// Changed order of ? : to allow r < o.y instead of o.y <= r -> 651\n// Applied FabriceNeyret's comment ( Remove {} from for loop, and use ',' ) -> 653\n// (No change) Shadertoy character counting updated -> 655\n// Wait, what I declared a float variable I didnt use! -> 653\n// Renamed variables (LESS SHOUTY)\n\n// Older Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define N normalize\n\n// C() (C)ast ray, \n// global inputs o = ray (O)rigin, d = Ray (D)ir\n// outputs o = Intersection, s = offset to sphere, q = sphere index, \n#define C r =.01; for( int i=0; i < 64; i++) o += d * r, p = clamp( ceil( o - .5 ), -Z, Z ), p.y = .4 - mod( q = p.x * 5. + p.z, Z ) * .15, r = min( o.y, length( s = o - p ) - p.y );\n\nvoid mainImage( out vec4 c, vec2 x )\n{\n\tfloat q, r, \n    \tZ = 2.; // constant 2.\n    \n\tV \tp, v, n,\n        Y = V( 0, 1, 0 ), // Constant Up\n    \td = iResolution,\n        o = V( .851, 2, -2.8768 ),\t\t\n        //o = V( cos(5.), 1, sin(5.) )*3.-Y,\n        s = -N( Y * .2 + o ),\n        a = N( cross( s, Y ) );\n    \n    // o = Ray Origin\n    // d = Ray Direction, store for later in v for view direction\n    d = v = N( mat3( a, cross( a, s ), s ) * V( x - d.xy / Z, d.y ) );\n    \n    // Cast Ray\n    C \n\n    d = mod( o, Z );\n    n = o * o;    \n    // surface (a)lbedo\n\ta = r < o.y\n        ? V( -8, 3, 6 ) * floor( q / Z + 6. ) / 50. + Y.yxx * Z\n        : V( d.x > 1. ^^ d.z < 1. ? .8 : texture( iChannel0, .1 * o.xz ).x )\n    \t\t\t* smoothstep( 0., .5, max( n.x, n.z ) < 2.25 ? length( s.xz ) : Z );         \n\n    n = r < o.y ? N( s ) : Y; // n = surface normal\n\n    d = N( V( -6, 7, -5 ) ); // d = light dir\n    \n    // Cast Ray\n    C \n        \n    c.xyz = sqrt( \n        // Ambient / sky\n        a * ( Y + n ).y * V( 5, 7, 10 ) / 80.  \n        // Shadow and N dot L term\n        + V( o.y <= r ) * dot( n, d ) *\n             \t( \n        \t\t\t// directional\n                    a * V(.6,.51,.33) \n                    // specular\n                  \t+ pow( max( 0., dot( reflect( v, n ), d ) ), 16. ) \n                ) \n             );\n}\n\n*/\n\n////////////////////////////////////////////\n\n\n\n/*\n\n// Changes:\n\n// Constant for ray origin -> 655\n// Change hit sphere / floor test to (O.y <= r) -> 663\n// Init N inline -> 665\n\n// Older Changes:\n\n// Remove material index -> 667\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define Z normalize\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// outputs M = (M)aterial, N = (N)ormal - actually unnormalized offset to closest sphere, O = Intersection, S = (S)phere pos\n\n#define C r =.01; for(int i=0;i<64;i++) { O += D * r; P = clamp( ceil( O - .5 ), -z, z ); P.y = .4 - mod( f = P.x * 5. + P.z, z ) * .15; r = min(O.y,length( s=O-P ) - P.y); }\n\nvoid mainImage( out vec4 o, vec2 x )\n{\n\tfloat l, f, r, \n    \tz = 2.; // constant 2.\n    \n\tV P, D, v,\n        Y = V( 0, 1, 0 ),\n    \tN = iResolution,\n        O = V( .851, 2, -2.8768 ),\t\t\t// O = Ray Origin\n        //O = V( cos(5.), 1, sin(5.) )*3.-Y,  // O = Ray Origin\n\n        s = -Z( Y * .2 + O ),\n        c = Z( cross( s, Y ) );\n    \n    // D = Ray Direction\n    D = v = Z( mat3( c, cross(c,s), s ) * V( x-N.xy/z, N.y ) );\n    \n    // Cast Ray\n    C \n\n    D = mod(O,z);\n    N = O*O;\n\tc = O.y <= r\n        ? V( D.x > 1. ^^ D.z < 1.? .8 : texture( iChannel0, .1*O.xz).x )\n    \t\t\t* smoothstep( 0., .5, max(N.x, N.z) < 2.25 ? length(s.xz) : z )\n        : V( -8, 3, 6) * floor(f/z+6.) / 50. + Y.yxx * z;\n\n    D = Z( V(-6, 7, -5) ); // D = light dir\n\n    N = O.y<=r ? Y : Z(s); // t = hit normal\n    \n    // Cast Ray\n    C \n        \n    o = sqrt( \n        // Ambient / sky\n        c * (Y + N).y*V(5,7,10)/80.  \n        // Shadow and N dot L term\n        + V(O.y<=r) * dot( N, D ) *\n             \t( \n        \t\t\t// diffuse\n                    c * V(.6,.51,.33) \n                    // specular\n                  \t+ pow(max(0., dot( reflect( v, N ), D ) ),16.) \n                ) \n             ).xyzz;\n}\n\n*/\n\n////////////////////////////////////////////\n\n\n/*\n\n// Changes:\n\n// Remove material index -> 669\n// Don't actually store ground material -> 673\n// Store sphere offset  & defer calculation of normal -> 675\n// Ray offset at start of loop reducing shadow offset setup (idea from Stubbe ) -> 679\n// Albedo color * 2 reduces constant size and scale on texture intensity. -> 682\n// Rearrange lighting to apply albedo twice and lambert inline (inspired by Stubbe, but was already considering) -> 686\n// Move global parameters to be function local as C is now a macro (also inspired by Stubbe :/) -> 691\n// Drop another use of step for ? : -> 693\n// Blatently steal Stubbe's use of macro instead of function > 697\n\n// Older Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define Z normalize\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// outputs M = (M)aterial, N = (N)ormal - actually unnormalized offset to closest sphere, O = Intersection, S = (S)phere pos\n\n#define C r =.01; for( int i=0; i<66; i++ ) { O += D * r;S = clamp( ceil( O - .5 ), -z, z ); S.y = .4 - mod( f = S.x * 5. + S.z, z ) * .15; N=O-S; r = min(O.y,length( N ) - S.y); }\n\nvoid mainImage( out vec4 o, vec2 p )\n{\n\tV Y = V(0,1,0),\n      //O = V( .850987, 2, -2.87677 ),         \n      O = V( cos(5.), 1, sin(5.) )*3.-Y, \n      S = -Z(Y*.2+O),\n      c = Z( cross(S,Y) ),\n      N, D, d,\n      t = iResolution;\n\n\tfloat l, f, r, z=2.;\n    \n    // ray direction\n    // S = W Axis, c = U axis\n    D = d = Z( mat3( c, cross(c,S), S ) * V (p-t.xy/z , t.y ) );\n    \n    C\n    \n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = mod(O,z);\n    t = O*O;    \n\tc = O.y < .01\n        ? V( D.x > 1. ^^ D.z < 1.? .8 : texture( iChannel0, .1*O.xz).x )\n    \t\t\t* smoothstep( 0., .5, max(t.x, t.z) < 2.25 ? length(N.xz) : z )\n        : V( -8, 3, 6) * (floor(f/z)+6.) / 50. + Y.yxx * z;\n\n    // C() param - D is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    t = O.y<.01 ? Y : Z(N); // t =hit normal\n    \n    C\n        \n    o = sqrt( c * (Y + t).y*V(5,7,10)/80.\n             + V(O.y<=r) * dot( t, D ) *\n             \t( c * V(.6,.51,.33)\n                  + pow(max(0., dot( reflect( d, t), D ) ),16.)\n                ) \n             ).xyzz;\n}\n\n\n////////////////////////////////////////////\n\n\n/*\n\n// Changes:\n\n// Blatently steal Stubbe's use of O*O instead of abs() -> 702\n// Applying aiekick's commment ( move .xz swizzle outside paren ) -> 704\n// Applying iq's comment (Replace constant 2. with global float z - including * .5 -> / z) -> 705\n\n// Older Changes:\n\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define Z normalize\n\nV O, N, D, S, d, c,\n    t = iResolution,     \n    Y = V(0,1,0);\n\nfloat M, l, r, f, z=2.;\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// outputs M = (M)aterial, N = (N)ormal, O = Intersection, S = (S)phere pos\nvoid C()\n{\n    for( int i=0; i<66; i++ )\n    {\n        // map\n\n        // S = sphere origin\n        S = clamp( ceil( O - .5 ), -z, z );\n        // init to O.y for floor plane distance\n        r = O.y;\n        S.y = .4 - mod( f = S.x * 5. + S.z, z ) * .15;\n\n        l = length( O - S ) - S.y; // sphere Y pos is radius\n        \n        // Plane material and normal\n        M = -l; // hack - any negative value will do\n        N = Y; \n        \n        // Union\n        if ( l < r ) M = floor(f/z+6.), r = l, N = Z(O - S);\n                \n        // advance ray\n        O += D * r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\t// camera\t\n\tO = V( cos(5.), 1, sin(5.) )*3.-Y;\n\t\n    // ray direction\n    // S = W Axis, c = U axis    \n    D = d = Z( mat3( c = Z( cross(S = -Z(Y*.2+O),Y) ), cross(c,S), S ) * V (f-t.xy/z , t.y ) );\n    \n    C();\n    \n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = mod(O,z);\n    t = O*O;    \n\tc = M < 0.\n        ? V( D.x > 1. ^^ D.z < 1.? .4 : texture( iChannel0, .1*O.xz).x / z )\n    \t\t\t* smoothstep( 0., .5, length((O-S).xz) + step(2.25,max(t.x, t.z)) )\n        : V( -8, 3, 6) * .01 * M + Y.yxx;\n\n    // C() param - D is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    // C() param - O start pos for shadow trace\n    O += D * .01;\n    \n    t=N; // t = backup of hit normal\n    \n    C();\n    // O is now shadow hit position\n    // N is hit shadow normal\n    // M is hit shadow material\n\n    // M is shadow hit material\n    l = M < 0. ? dot( t, D ) : 0.;    \n    c *= l*V(1.2,1.02,.66) + (Y + t).y*V(5,7,10)/40.;\n\n    o = sqrt(c.xyzz + pow(max(0., dot( reflect( d, t), D ) ),16.)*l);\n}\n\n*/\n\n\n\n////////////////////////////////////////////\n\n\n/*\n\n// Changes:\n// Remove diffuse max() (I steals it from Reinder Bwahaha!!) -> 711\n// Applying Reinder's comment ( initialize c inline ) -> 719\n// Applying GregRostami's comment ( initialize t=iResolution ) -> 721\n// Applying FabriceNeyret2's comment (Treat grid as monochrome with vec3 cast avoid texture.xxx) -> 723\n// Test M against 0. instead of -1. -> 727\n// Applying FabriceNeyret2's comment ( change * step(M,-1) to ? : ) -> 728\n// Applying FabriceNeyret2's comment (identity in calculation of D) -> 731\n// Assign f inside mod() -> 734\n// Ray direction setup from Reinder's comment -> 736\n\n\n\n// Older Changes:\n// Changed floor -> ceil -> 749\n// Made r, f floats global -> 750\n// Removed *2 in projection code -> 752\n// Changed smoothstep hackery to fix iOS version\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n\n#define V vec3\n\n// normali(Z)e\n#define Z normalize\n\nV O, N, D, S, d, c,\n    t = iResolution,     \n    Y = V(0,1,0);\n\nfloat M, l, r, f;\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// outputs M = (M)aterial, N = (N)ormal, O = Intersection, S = (S)phere pos\nvoid C()\n{\n    for( int i=0; i<66; i++ )\n    {\n        // map\n\n        // S = sphere origin\n        S = clamp( ceil( O - .5 ), -V( 2 ), V( 2 ) );\n        // init to O.y for floor plane distance\n        r = O.y;\n        S.y = .4 - mod( f = S.x * 5. + S.z, 2. ) * .15;\n\n        l = length( O - S ) - S.y; // sphere Y pos is radius\n        \n        // Plane material and normal\n        M = -l; // hack - any negative value will do\n        N = Y; \n        \n        // Union\n        if ( l < r ) M = floor(f/2.+6.), r = l, N = Z(O - S);\n                \n        // advance ray\n        O += D * r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\t// camera\t\n\tO = V( cos(5.), 1, sin(5.) )*3.-Y;\n\t\n    // ray direction\n    // S = W Axis, c = U axis    \n    D = d = mat3( c = Z( cross(S = -Z(Y*.2+O),Y) ), cross(c,S), S ) * Z( V (f-t.xy/2. , t.y ) );\n    \n    C();\n    \n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = mod(O,2.);\n    t = abs(O);    \n\tc = M < 0.\n        ? V( D.x > 1. ^^ D.z < 1.? .4 : texture( iChannel0, .1*O.xz).x * .5 )\n    \t\t\t* smoothstep( 0., .5, length(O.xz-S.xz) + step(1.5,max(t.x, t.z)) )\n        : V( -8, 3, 6) * .01 * M + Y.yxx;\n\n    // C() param - D is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    // C() param - O start pos for shadow trace\n    O += D * .01;\n    \n    t=N; // t = backup of hit normal\n    \n    C();\n    // O is now shadow hit position\n    // N is hit shadow normal\n    // M is hit shadow material\n\n    // M is shadow hit material, M will be diffuse after this line\n    //M = M < 0. ? max(0., dot( t, D ) ) : 0.;    \n    M = M < 0. ? dot( t, D ) : 0.;    \n    c *= M*V(1.2,1.02,.66) + (Y + t).y*V(5,7,10)/40.;\n\n    o = sqrt(c.xyzz + pow(max(0., dot( reflect( d, t), D ) ),16.)*M);\n}\n\n*/\n\n\n////////////////////////////////////////////\n\n/*\n// Changes:\n// Applying Reinder's comment ( removing #define float, #define max(dot( ) -> 757\n// Applying Reinder's comment ( inline initialization of S ) -> 755\n// Changed smoothstep hackery to fix iOS version\n// Removed *2 in projection code -> 752\n// Made r, f floats global -> 750\n// Changed floor -> ceil -> 749\n\n#define V vec3\n\n// normali(Z)e\n#define Z normalize\n\nV O, N, D, S, d, t,     \n    Y = V(0,1,0);\n\nfloat M, l, r, f;\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// sets M = (M)aterial, N = (N)ormal, O = Intersection, S = (S)phere pos\nvoid C()\n{\n    for( int i=0; i<64; i++ )\n    {\n        // map\n\n        // S = sphere origin\n        S = clamp( ceil( O - .5 ), -V( 2 ), V( 2 ) );\n        // init to O.y for floor plane distance\n        r = O.y;\n        f = S.x * 5. + S.z;\n        S.y = .4 - mod( f, 2. ) * .15;\n\n        l = length( O - S ) - S.y; // sphere Y pos is radius\n        \n        // Plane material and normal\n        M = -l; // hack - any negative value will do\n        N = Y; \n        \n        // Union\n        if ( l < r ) M = floor(f/2.+6.), r = l, N = Z(O - S);\n                \n        // advance ray\n        O += D * r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\t// camera\t\n\tO = V( cos(5.), 1, sin(5.) )*3.-Y;\n\t\n    // ray direction\n    V c = Z( cross(S = -Z(Y*.2+O),Y) ); // S = W Axis, c = U axis\n    \n    t = iResolution;\n    f = f/t.xy-.5;\n    D = d = mat3( c, cross(c,S), S ) * Z( V(f.x* t.x/t.y, f.y ,1) );\n    \n    C();\n    \n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = mod(O,2.);\n    t = abs(O);    \n\tc = M < 0.\n        ? (\n            D.x > 1. ^^ D.z < 1.\n        \t\t? V( .4 ) \n        \t\t: texture( iChannel0, .1*O.xz).xxx * .5)\n    \t\t\t\t* smoothstep( 0., .5, length(O.xz-S.xz) + step(1.5,max(t.x, t.z)) )\n        : V( -8, 3, 6) * .01 * M + Y.yxx;\n\n    // C() param - D is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    // C() param - O start pos for shadow trace\n    O += D * .01;\n    \n    t=N; // t = backup of hit normal\n    \n    C();\n    // O is now shadow hit position\n    // N is hit shadow normal\n    // M is hit shadow material\n\n    // M is shadow hit material, M will be diffuse after this line\n    M = max(0., dot( t, D ) * step( M, -1. ) );    \n    c *= M*V(1.2,1.02,.66) + (Y + t).y*V(5,7,10)/40.;\n\n    o = sqrt(c.xyzz + pow(max(0., dot( reflect( d, t), D ) ),16.)*M);\n}\n*/\n\n\n/////////////////////////////////////////////\n\n/*\n// [SH16A] P_Malin\n// Original - 768 Chars\n\n#define V vec3\n#define F float\n#define Z normalize\n#define P max(0., dot\n\nV O,N,D,S,d,t,Y=V(0,1,0);\nF M;\n\nvoid C() {\n    for(int i=0;i<64;i++) {\n        S=clamp(floor(O+.5),-V(2),V(2));\n        F r=O.y,f=S.x*5.+S.z;\n        S.y=.4-mod(f,2.)*.15;\n        F l=length(O-S)-S.y;\n        M=-l;N=Y; \n        if(l<r)M=floor(f/2.+6.),r=l,N=Z(O-S);                \n        O+=D*r;\n    }\n}\n\nvoid mainImage(out vec4 o,vec2 f) {\n\tO=V(cos(5.),1,sin(5.))*3.-Y;\t\n\tS=-Z(Y*.2+O);\t\n    V c=Z(cross(S,Y));    \n    t=iResolution;\n    f=2.*f/t.xy-1.;    \n\tD=d=mat3(c,cross(c,S),S)*Z(V(f.x* t.x/t.y,f.y,2));    \n    C();\n    D=mod(O,2.);t=abs(O);    \n\tc=M<0.?(D.x>1.^^D.z<1.?V(.4):texture(iChannel0,.1*O.xz).xxx*.5)*smoothstep(0.,.5*step(max(t.x,t.z),1.5),length(O.xz-S.xz)):V(-8,3,6)*.01*M+Y.yxx;\n    D=Z(V(-6,7,-5) );\n    O +=D*.01;\n    t=N;\n    C();\n    M=P(t,D)*step(M,-1.));    \n    c*=M*V(1.2,1.02,.66)+(Y+t).y*V(5,7,10)/40.;\n    o=sqrt(c.xyzz+pow(P(reflect(d,t),D)),16.)*M);\n}\n\n*/\n          \n/*\n\n// 768\n\n\n#define V vec3\n#define F float\n\n// normali(Z)e\n#define Z normalize\n\n// dot (P)roduct\n#define P max(0., dot\n\nV O, N, D, S, \n  d, t, \n    \n    Y = V(0,1,0);\n\nF M;\n\n// C() (C)ast ray, \n// global inputs O = ray (O)rigin, D = Ray (D)ir\n// sets M = (M)aterial, N = (N)ormal, O = Intersection, S = (S)phere pos\nvoid C()\n{\n    for( int i=0; i<64; i++ )\n    {\n        // map\n\n        // S = sphere origin\n        S = clamp( floor( O + .5 ), -V( 2 ), V( 2 ) );\n        // init to O.y for floor plane distance\n        F r = O.y, f = S.x * 5. + S.z;\n        S.y = .4 - mod( f, 2. ) * .15;\n\n        F l = length( O - S ) - S.y; // sphere Y pos is radius\n        \n        // Plane material and normal\n        M = -l; // hack - any negative value will do\n        N = Y; \n        \n        // Union\n        if ( l < r ) M = floor(f/2.+6.), r = l, N = Z(O - S);\n                \n        // advance ray\n        O += D * r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\t// camera\t\n\tO = V( cos(5.), 1, sin(5.) )*3.-Y;\n\t\n\t// camera-to-world transformation\n\tS = -Z(Y*.2+O);\n\t\n    V c = Z( cross(S,Y) ); // c = U axis\n    \n    // ray direction\n    t = iResolution;\n    f = 2.*f/t.xy-1.;    \n\tD = d = mat3( c, cross(c,S), S ) * Z( V(f.x* t.x/t.y, f.y ,2) );\n    \n    C();\n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = mod(O,2.);\n    t = abs(O);    \n\tc = M < 0.       \n        ? (\n            D.x > 1. ^^ D.z < 1.\n        \t\t? V( .4 ) \n        \t\t: texture( iChannel0, .1*O.xz).xxx * .5)\n    \t\t\t\t* smoothstep( 0., .5 * step(max(t.x, t.z), 1.5), length(O.xz-S.xz) \n          )        \n        : V( -8, 3, 6) * .01 * M + Y.yxx;\n\n\n    // C() param - D is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    // C() param - O start pos for shadow trace\n    O += D * .01;\n    \n    t=N; // t = backup of hit normal\n    \n    C();\n    // O is now shadow hit position\n    // N is hit shadow normal\n    // M is hit shadow material\n\n    // M is shadow hit material, M will be diffuse after this line\n    M = P( t, D ) * step( M, -1. ) );    \n    c *= M*V(1.2,1.02,.66) + (Y + t).y*V(5,7,10)/40.;\n\n    o = sqrt(c.xyzz + pow(P( reflect( d, t), D ) ),16.)*M);\n}\n\n*/\n          \n/*\n\n\n// 781\n\n\n#define V vec3\n#define F float\n\n// normali(Z)e\n#define Z normalize\n\n// dot (P)roduct\n#define P max(0., dot\n\nV O, N, D, \n  c, d, t, w, Y = V(0,1,0);\n\nF M;\n\n// C() cast ray, \n// global inputs O = ray origin, D = Ray dir\n// sets M = Material, N = Normal, O = Intersection\nvoid C()\n{\n    for( int i=0; i<64; i++ )\n    {\n        // map\n\n        // W = sphere origin\n        w = clamp( floor( O + .5 ), V( -2 ), V( 2 ) );\n        // O.y for plane\n        F r = O.y, f = w.z + w.x * 5. + 12.;\n        w.y = .4 - mod( f, 2. ) * .15;\n\n        F l = length( O - w ) - w.y;\n        \n        // Plane material and normal\n        M = -1.;\n        N = Y; \n        \n        // Union\n        if ( l < r ) M = floor(f/2.), r = l, N = Z(O - w);\n                \n        // advance ray\n        O += D * r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\t// camera\t\n\tO = V( 3.*cos(5.), 2, 3.*sin(5.) );\n\t\n\t// camera-to-world transformation\n\tw = -Z(Y*.2+O);\n\tc = Z( cross(w,Y) ); // c = U axis\n    //c = Z(V(-w.z,0,w.x));\n    \n    // ray direction\n    t = iResolution;\n    f = 2.*f/t.xy-1.;    \n\tD = d = mat3( c, cross(c,w), w ) * Z( V(f.x* t.x/t.y, f.y ,2) );\n    \n    C();\n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    // D, t = temp\n    D = fract(O * .5);\n    t = abs(O);    \n\tc = M < 0.       \n        ? (\n            D.x > .5 ^^ D.z < .5\n        \t\t? V( .4 ) \n        \t\t: texture( iChannel0, .1*O.xz).xxx * .5)\n    \t\t\t\t* smoothstep( 0., .5 * step(max(t.x, t.z), 1.5), length(fract(O.xz+.5)-.5) \n          )        \n        : V( -8, 3, 6) * .01 * M + Y.yxx;\n\n\n    // C() para D : is now light dir\n    D = Z( V(-6, 7, -5) );\n\n    // C() param O : move start pos for shadow\n    O += D * .01;\n    \n    t=N; // t = stored normal\n    \n    C();\n    // O is now shadow hit position\n    // N is hit shadow normal\n    // M is hit shadow material\n\n    // M is shadow hit material, M will be diffuse after this line\n    M = P( t, D ) * step( M, -1. ) );    \n    c *= M*V(1.2,1.02,.66) + (Y + t).y*V(5,7,10)/40.;\n\n    o = sqrt(c.xyzz + pow(P( reflect( d, t ), D ) ),16.)*M);\n}\n\n*/\n          \n/* \n\n// 871\n\n\n#define V vec3\n#define F float\n\n// normali(Z)e\n#define Z normalize\n\n// dot (P)roduct\n#define P max( 0., dot(\n\nV O, c, N, n, D, d, t,\n        cw, \n        cu, \n        cv;\n        \n\nF M;\n\n// C cast ray, \n// global inputs O = ray origin, D = Ray dir\n// sets M = Material, N = Normal, O = Intersection\nvoid C()\n{\n    // m = material, r = map result (dist), f = temp float for sphere pos\n    for( int i=0; i<64; i++ )\n    {\n        // map\n        \n        // plane material & normal \n        M = -1.;\n        N = V( 0.,1.,0. ); \n\n        // sphere\n        V s = clamp( floor( O + .5 ), V( -2. ), V( 2. ) );\n        // O.y for plane\n        F r = O.y, f = s.z + s.x * 5. + 12.;\n        s.y = .4 - mod( f, 2. ) * .15;\n\n        F l = length( O - s ) - s.y;\n\n        // Union\n        if ( l < r ) M = floor(f/2.), r = l, N = Z(O - s);\n                \n        // advance ray\n        O += D*r;\n    }\n}\n\nvoid mainImage( out vec4 o, vec2 f )\n{\n\n    \n    // Todo : Camera setup can be much smaller!\n    \n    t = iResolution;\n    V p = 2.*f.xyy/t-1.;\n\n\t// camera\t\n\tO = V( 3.*cos(5.), 2., 3.*sin(5.) );\n\t\n\t// camera-to-world transformation\n\tcw = Z(V( 0., -.2, 0. )-O);\n\tcu = Z( cross(cw,V(0., 1.,0.)) );\n\tcv = Z( cross(cu,cw) );\n    mat3 ca = mat3( cu, cv, cw );\n    \n    // ray direction\n\tD = d = ca * Z( V(p.x* t.x/t.y, p.y ,2.) );\n    \n    C();\n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n    \n    // plane cols, sphere cols, plane AO\n    D = fract(O * .5);\n    t = abs(O);    \n\tc = M < 0.        \n        ? (\n            D.x > .5 ^^ D.z < .5\n        \t\t? V( .4 ) \n        \t\t: texture( iChannel0, .1*O.xz + vec2(37.,17.)/256.).yyy * .5)\n    \t\t\t\t* smoothstep( 0., .5 * step(max( t.x, t.z), 1.5), length(mod(O.xz+.5,1.)-.5) \n          )        \n        : V( 1. + M * -.08, M * .03, M * .06) ;\n\n\n    // D is now light dir\n    D = Z( V(-.6, .7, -.5) );\n\n    // move start pos for shadow\n    O += D * .01;\n    \n    n=N; // store normal\n    C();\n    // O is now hit position\n    // N is hit normal\n    // M is hit material\n\n    // M is shadow hit material, M will be diffuse after this line\n    M = P n, D ) * step( M, -1. ) );    \n    c *= M*V(1.2,1.02,.66) + (1. + n.y)*V(.5,.7,1.)/4.;\n\n    o = sqrt(c.xyzz + pow(P reflect( d, n ), D ) ),16.)*M);\n}\n\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}