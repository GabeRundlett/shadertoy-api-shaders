{
    "Shader": {
        "info": {
            "date": "1600208750",
            "description": "Best viewed in fullscreen. Pixel art is all original and not based on an existing game, but built roughly within Turbografx-16 / PC Engine graphics limitations.",
            "flags": 32,
            "hasliked": 0,
            "id": "MdyyWt",
            "likes": 49,
            "name": "1990-esque",
            "published": 3,
            "tags": [
                "retro",
                "crt",
                "sprites",
                "pixelart",
                "television",
                "videogames"
            ],
            "usePreview": 0,
            "username": "ChrisK",
            "viewed": 2144
        },
        "renderpass": [
            {
                "code": "// My latest attempt at a retro CRT simulation.\n\n// J. Kyle Pittman wrote a very good blog post a few years ago which provided a lot of\n// information on the CRT simulation techniques that he uses in Super Win The Game:\n// www.gamasutra.com/blogs/KylePittman/20150420/241442/CRT_Simulation_in_Super_Win_the_Game.php\n// My effects here aren't quite the same as those he descibes in the article (my simulation\n// is simpler in many ways and I'm simulating a higher-quality TV), but I definitely used\n// that as an inspirational starting point. Incidentally, Super Win The Game is pretty\n// underrated IMO and you should play it.\n\n\n#define gaussian(a,b)\texp2((a)*(a)*-(b))\n\n\nvec2 curveScreen( vec2 uv ) {\n    float r = PI*0.5/SCREEN_CURVE_RADIUS;\n    float d = 1.0-cos(uv.x*r)*cos(uv.y*r);\t\t//distance to screen\n    float s = cos(r);\t\t\t\t\t\t\t//scale factor to re-fit window\n    return uv / (1.0-d) * s;\n}\n\n\nfloat discardCorners( vec2 pos ) {\n    pos = abs(pos);\n    pos.x = pos.x*1.333-0.333;\t\t\t\t\t\t\t\t\t\t\t// 4:3 aspect ratio correction\n    if( min(pos.x, pos.y) < 1.0-SCREEN_CORNER_RADIUS ) return 1.0;\t\t// not near corner -- break early\n    float d = distance( pos, vec2(1.0-SCREEN_CORNER_RADIUS) );\n    return float( d<SCREEN_CORNER_RADIUS );\n}\n\n\nvec3 getSample( vec2 pos, vec2 off ) {\n\t//get nearest emulated sample\n\tpos = floor(pos*IRES) + vec2(0.5) + off;\n\tvec3 col = vec3(0.0);\n\tif ( pos.x>=0.0 && pos.x<=IRES.x && pos.y>=0.0 && pos.y<=IRES.y ) {\n        #ifdef NTSC_ARTIFACTS\n        col = texelFetch( iChannel0, ivec2(pos), 0).rgb;\n        #else\n        col = texelFetch( iChannel2, ivec2(pos), 0).rgb;\n        #endif\n        col = pow( ( (col + 0.055) / 1.055), vec3(2.4) );\t\t// SRGB => linear\n\t}\n\treturn col;\n}\n\n\nvec3 getScanline( vec2 pos, float off ) {\n\t// 3-tap gaussian filter to get colour at arbitrary point along scanline\n    float d = 0.5-fract(pos.x*IRES.x);\n\tvec3 ca = getSample( pos, vec2(-1.0, off ) );\n\tvec3 cb = getSample( pos, vec2( 0.0, off ) );\n\tvec3 cc = getSample( pos, vec2( 1.0, off ) );\n\tfloat wa = gaussian( d-1.0, PIXEL_SHARPNESS );\n\tfloat wb = gaussian( d,     PIXEL_SHARPNESS );\n\tfloat wc = gaussian( d+1.0, PIXEL_SHARPNESS );\n\treturn ( ca*wa + cb*wb + cc*wc ) / ( wa+wb+wc);\n}\n\n\nvec3 getScreenColour( vec2 pos ) {\n\t//Get influence of 3 nearest scanlines\n    float d = 0.5-fract(pos.y*IRES.y);\n\tvec3 ca = getScanline( pos,-1.0 ) * gaussian( d-1.0, LINE_SHARPNESS );\n\tvec3 cb = getScanline( pos, 0.0 ) * gaussian( d,     LINE_SHARPNESS );\n\tvec3 cc = getScanline( pos, 1.0 ) * gaussian( d+1.0, LINE_SHARPNESS );\n    return ca + cb + cc;\n}\n\n\nvec3 ACESFilm( vec3 x ) {\n    return clamp((x*(2.51*x + 0.03)) / (x*(2.43*x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord / iResolution.xy;\n   \tpos = pos*2.0 - 1.0;\n    pos.x *= iResolution.x/iResolution.y*0.75;\t\t\t\t\t\t// 4:3 aspect\n    \n    #ifdef SCREEN_SHAPE\n    pos = curveScreen(pos);\t\t\t\t\t\t\t\t\t\t\t// curve screen\n    #endif\n    \n    vec3 col = vec3(0.0);\n    \n    if(max( abs(pos.x), abs(pos.y) )<1.0) {\t\t\t\t\t\t\t// skip everything if we're beyond the screen edge\n    \t\n        col = vec3(1.0);\n        \n        #ifdef SCREEN_SHAPE\n        col *= discardCorners(pos);\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n        col *= 1.0 - sqrt(length(pos)*0.25);\t\t\t\t\t\t// vignette\n        #endif\n        \n        pos = pos*0.5 + 0.5;\n\n        #ifdef SCANLINES\n\t\tcol *= getScreenColour( pos );\n        #else\n        col *= getSample( pos, vec2(0.0) );\n        #endif\n        \n        #ifdef SHADOW_MASK\n        #ifdef CURVE_MASK_TO_SCREEN\n        col *= texelFetch( iChannel1, ivec2(pos*iResolution.xy), 0).rgb;\t// curve mask with screen\n        #else\n    \tcol *= texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\t\t\t\t// draw mask flat (moire fix)\n        #endif\n        #endif\n        \n        #ifdef LIGHT_EFFECTS\n\t\tcol *= BRIGHTNESS;\n    \tcol = ACESFilm(col);\n        #endif\n    \n    \tcol = pow( col, vec3(1.0/2.4) ) * 1.055 - 0.055;\t\t\t// linear => SRGB\n        \n    \t//col = texelFetch( iChannel1, ivec2(fragCoord), 0).rgb;\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// I'm approximating TurboGrafx-16 specifications, because I have nostalgia\n// for that particular console and the restrictions are fun to work with.\n// here's a simplified list of the restrictions:\n\n// variable resolution, but 256 x 239 is most common\n// 9-bit colour\n// 16 colours per palette (15 + transparent for sprite palettes)\n// can use up to 16 sprite palettes and 16 tile palettes simultaneously\n// background tiles are 8x8\n// one background layer (parallax is only possible with linescrolling and sprite tricks)\n// sprites are 16×16, 16×32, 16×64, 32×16, 32×32, or 32×64\n// up to 64 simultaneous sprites on screen or 256 sprite pixels on one scanline\n// ...and a few other things that don't really figure into this particular image\n\n// I'm not exactly pushing these restrictions to the limit here, but I think this feels\n// pretty representative of the graphics found in many of the games on the console\n\n\n// palette colours in 0-7 range; final colour is divided by 7 for 9-bit RGB\nvec3 palette_t[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 7),\t// 1  - white\n                              vec3(6, 7, 2),\t// 2  - yellow\n                              vec3(5, 3, 1),\t// 3  - orange\n                              vec3(4, 1, 1),\t// 4  - red\n                              vec3(2, 0, 2),\t// 5  - dark purple (same as 0)\n                              vec3(0, 0, 2),\t// 6  - dark blue\n                              vec3(0, 1, 2),\t// 7  - grey-blue\n                              vec3(1, 3, 4),\t// 8  - medium cyan\n                              vec3(0, 2, 1),\t// 9  - green\n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\nvec3 palette_p[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 5),\t// 1  - white eyes\n                              vec3(6, 5, 3),\t// 2  - light shirt\n                              vec3(2, 2, 1),\t// 3  - pants\n                              vec3(5, 3, 2),\t// 4  - skintone\n                              vec3(4, 0, 1),\t// 5  - red\n                              vec3(2, 0, 0),\t// 6  - dark red\n                              vec3(1, 0, 0),\t// 7  - deep red (outline)\n                              vec3(0, 0, 0),\t// 8  - \n                              vec3(0, 0, 0),\t// 9  - \n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\nvec3 palette_u[16] = vec3[16](vec3(-1),\t\t\t// 0  - transparent\n                              vec3(7, 7, 7),\t// 1  - white\n                              vec3(4, 5, 6),\t// 2  - pale blue\n                              vec3(5, 1, 1),\t// 3  - red\n                              vec3(3, 0, 0),\t// 4  - dark red\n                              vec3(0, 0, 0),\t// 5  - black\n                              vec3(0, 0, 0),\t// 6  - \n                              vec3(0, 0, 0),\t// 7  - \n                              vec3(0, 0, 0),\t// 8  - \n                              vec3(0, 0, 0),\t// 9  - \n                              vec3(0, 0, 0),\t// 10 -\n                              vec3(0, 0, 0),\t// 11 - \n                              vec3(0, 0, 0),\t// 12 - \n                              vec3(0, 0, 0),\t// 13 - \n                              vec3(0, 0, 0),\t// 14 - \n                              vec3(0, 0, 0) );\t// 15 - \n\n\nconst int map[1024] = int[1024](\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,25, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0,25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23,24, 0,\n    0, 0,23,24,23,24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,23,24,22, 0, 0,23,24,23,17,17,24,\n   24,23,17,17,17,17,24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,22,23,17,17,17,24,23,17,17,17,17,17,17,\n   17,17,17,17,17,17,17,24,22,23,24,22, 0, 0, 0, 0, 0, 0,23,17,17,17,17,17,17,17,17,17,17,17,17,17,\n   17,17,17,17,18,19,21,20,17,17,17,17,24, 0, 0, 0, 0,23,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n   17,17,18,19,16,16,16,16,21,20,17,17,17,24,23,24,23,17,17,17,17,17,17,17,17,17,18,19,21,20,17,17,\n   18,19,16,16,16,16,16,16,16,16,21,20,17,17,17,17,18,19,21,20,17,17,17,17,18,19,16,16,16,16,21,20,\n   29,28,16,16,16,16,16,16,16,16,16,16,21,20,18,19,16,16,16,16,21,20,18,19,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,29,28,16,16,16,16,26,27,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,26,27,16,16,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n   16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n   14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,14,15,\n   12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,12,13,\n   \t4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,\n    2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n    8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9,\n    6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 7,\n    4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5, 4, 5,\n    2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n   10, 1, 1, 1, 1, 1, 1, 1,10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,10, 1, 1, 1, 1, 1,\n    1,11, 1, 1, 1, 1, 1, 1, 1,11, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,11, 1, 1, 1, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t// off bottom of screen\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\n\nconst int atlas[256] = int[256](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\t\t// 0 - clear sky\n    0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444, 0x44444444,\t\t// 1 - dirt\n\n    0x99797797, 0x99777797, 0x99799799, 0x79797797, 0x79697677, 0x66667676, 0x67674667, 0x74744774,\t\t// 2 - grass bottom 1\n    0x99799997, 0x99797997, 0x79797997, 0x67796796, 0x67997776, 0x66676777, 0x67767447, 0x74474444,\t\t// 3 - grass bottom 2\n    0x99999999, 0x99999999, 0x79999999, 0x99999999, 0x99999799, 0x99997999, 0x99999999, 0x99997999,\t\t// 4 - grass mid 1\n    0x99999999, 0x99999999, 0x99999999, 0x99999999, 0x79999999, 0x99999999, 0x99999999, 0x99799999,\t\t// 5 - grass mid 2\n    0x33333333, 0x33333333, 0x33333333, 0x33393339, 0x33399399, 0x93999999, 0x99999999, 0x99999999,\t\t// 6 - low dirt path 1\n    0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x39339399, 0x99999399, 0x99999999, 0x99999999,\t\t// 7 - low dirt path 2\n    \n\t0x44447444, 0x34444344, 0x33433343, 0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333,\t\t// 8 - high dirt path 1\n    0x94474474, 0x44433434, 0x34333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333, 0x33333333,\t\t// 9 - high dirt path 2\n    0x44444444, 0x44444444, 0x44444444, 0x44433344, 0x44333344, 0x44333644, 0x44666644, 0x44466444,\t\t//10 - rock in dirt 1\n    0x44444444, 0x44444444, 0x44433444, 0x44433444, 0x44466444, 0x43444444, 0x46444444, 0x44444444,\t\t//11 - rock in dirt 2\n    0x77777777, 0x77777777, 0x77777777, 0x79779779, 0x99979979, 0x99979999, 0x99999999, 0x99999999,\t\t//12 - grass fade 1\n    0x77777777, 0x77777777, 0x77777777, 0x77797777, 0x97997797, 0x99999799, 0x99999999, 0x99999999,\t\t//13 - grass fade 2\n    0x66666666, 0x66666666, 0x66666666, 0x76676676, 0x77776777, 0x77777777, 0x77777777, 0x77777777,\t\t//14 - grass fade 3\n    0x66666666, 0x66666666, 0x66666666, 0x76676676, 0x76777677, 0x77777777, 0x77777777, 0x77777777,\t\t//15 - grass fade 4\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//16 - mountainside\n\t0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888,\t\t//17 - cloud\n    0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888866, 0x88886666, 0x88666666,\t\t//18 - mountain left  ( / ) slope 1\n    0x88888888, 0x88888866, 0x88886666, 0x88666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//19 - mountain left  ( / ) slope 2\n    0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x88888888, 0x66888888, 0x66668888, 0x66666688,\t\t//20 - mountain right ( \\ ) slope 1\n\t0x88888888, 0x66888888, 0x66668888, 0x66666688, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//21 - mountain right ( \\ ) slope 2\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x08222280, 0x82888828, 0x28888882, 0x88888888,\t\t//22 - small cloud bump\n    0x00000822, 0x00082222, 0x00822888, 0x00288888, 0x08888888, 0x02888888, 0x88888888, 0x88888888,\t\t//23 - left side cloud bump\n    0x22800000, 0x22228000, 0x88822800, 0x88888200, 0x88888880, 0x88888820, 0x88888888, 0x88888888,\t\t//24 - right side cloud bump\n\t0x00000000, 0x00002000, 0x00022000, 0x02222220, 0x00322200, 0x00222300, 0x02203200, 0x00000000,\t\t//25 - star\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x66666688, 0x66668866, 0x66866666, 0x86666666,\t\t//26 - mountain left  ( / ) overlap slope 1\n    0x66688888, 0x66888866, 0x68886666, 0x88666666, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//27 - mountain left  ( / ) overlap slope 2\n    0x66666666, 0x66666666, 0x66666666, 0x66666666, 0x88666666, 0x66886666, 0x66666866, 0x66666668,\t\t//28 - mountain right ( \\ ) overlap slope 1\n    0x88888666, 0x66888866, 0x66668886, 0x66666688, 0x66666666, 0x66666666, 0x66666666, 0x66666666,\t\t//29 - mountain right ( \\ ) overlap slope 2\n    \n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\n\nconst int spr_heart[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00021100, 0x00112000,\n\t0x00223310, 0x01332200,\n    0x00131131, 0x13133100,\n    0x00131233, 0x32333100,\n    0x00133333, 0x33344100,\n    \n    0x00224333, 0x34444200,\n    0x00014444, 0x44441000,\n    0x00001444, 0x44410000,\n    0x00000144, 0x44100000,\n\t0x00000014, 0x41000000,\n    0x00000001, 0x10000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000);\n\nconst int spr_heart_empty[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00022200, 0x00222000,\n\t0x00255520, 0x02555200,\n    0x00255552, 0x25555200,\n    0x00255555, 0x55555200,\n    0x00255555, 0x55555200,\n    \n    0x00255555, 0x55555200,\n    0x00025555, 0x55552000,\n    0x00002555, 0x55520000,\n    0x00000255, 0x55200000,\n\t0x00000025, 0x52000000,\n    0x00000002, 0x20000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000);\n\nconst int spr_player_shadow[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    \n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00000000, 0x00000000,\n    0x00066666, 0x66666000,\n    0x66666666, 0x66666666,\n    0x66666666, 0x66666666,\n    0x00066666, 0x66666000);\n\nconst int spr_score[64] = int[64](\n    0x01111000, 0x01111000, 0x11111100, 0x01111000,\n    0x11551100, 0x11551100, 0x11555550, 0x11551100,\n    0x05501150, 0x05501150, 0x11111000, 0x11511150,\n    0x00111550, 0x00111550, 0x05551100, 0x11111150,\n\t0x02255500, 0x00052200, 0x00002250, 0x22252250,\n    0x22550000, 0x22002250, 0x22002250, 0x22552250,\n    0x22222200, 0x02222550, 0x02222550, 0x02222550,\n    0x05555550, 0x00555500, 0x00555500, 0x00555500, \n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_moon[128] = int[128](\n    0x00000000, 0x00032222, 0x22223000, 0x00000000,\n    0x00000000, 0x02222222, 0x22222230, 0x00000000,\n    0x00000000, 0x83322222, 0x22222222, 0x30000000,\n    0x00000000, 0x08803222, 0x22222222, 0x23000000,\n    0x00000000, 0x00880322, 0x22322222, 0x22300000,\n    0x00000000, 0x00088032, 0x22222222, 0x22200000,\n    0x00000000, 0x00008003, 0x22222222, 0x22220000,\n    0x00000000, 0x00000800, 0x22222222, 0x22223000,\n    \n    0x00000000, 0x00000800, 0x32222222, 0x22222000,\n    0x00000000, 0x00000000, 0x02300022, 0x22222300,\n    0x00000000, 0x00000000, 0x32031302, 0x22222300,\n    0x00000000, 0x00000030, 0x23211130, 0x22222200,\n    0x00000000, 0x00000002, 0x22111110, 0x22222200,\n    0x00000000, 0x00000322, 0x22130030, 0x22222200,\n    0x00000000, 0x08222222, 0x23101000, 0x22222200,\n    0x00000000, 0x08032222, 0x23300003, 0x22222200,\n    \n    0x00000000, 0x08003222, 0x22230032, 0x22222200,\n    0x08200000, 0x08000322, 0x22222222, 0x22322200,\n    0x08220000, 0x08000032, 0x22222222, 0x22222200,\n    0x08322000, 0x00800003, 0x22222222, 0x33222300,\n    0x08322200, 0x08322222, 0x22232222, 0x33222000,\n    0x08022222, 0x20032222, 0x22222222, 0x22222000,\n    0x08032222, 0x22203222, 0x22222222, 0x22223000,\n    0x08002222, 0x22220322, 0x33222222, 0x22220000,\n    \n    0x00803223, 0x22222233, 0x03222222, 0x22200000,\n    0x00800222, 0x22222222, 0x22222222, 0x22000000,\n    0x00080022, 0x22222222, 0x22222222, 0x20000000,\n    0x00080002, 0x22222222, 0x22222223, 0x00000000,\n    0x00008000, 0x32222222, 0x22222200, 0x00000000,\n    0x00000800, 0x03322222, 0x22233000, 0x00000000,\n    0x00000008, 0x00003333, 0x30000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_moon_blink[128] = int[128](\n    0x00000000, 0x00032222, 0x22223000, 0x00000000,\n    0x00000000, 0x02222222, 0x22222230, 0x00000000,\n    0x00000000, 0x83322222, 0x22222222, 0x30000000,\n    0x00000000, 0x08803222, 0x22222222, 0x23000000,\n    0x00000000, 0x00880322, 0x22322222, 0x22300000,\n    0x00000000, 0x00088032, 0x22222222, 0x22200000,\n    0x00000000, 0x00008003, 0x22222222, 0x22220000,\n    0x00000000, 0x00000800, 0x22222222, 0x22223000,\n    \n    0x00000000, 0x00000800, 0x32222222, 0x22222000,\n    0x00000000, 0x00000000, 0x02222322, 0x22222300,\n    0x00000000, 0x00000000, 0x32222332, 0x22222300,\n    0x00000000, 0x00000030, 0x22222233, 0x22222200,\n    0x00000000, 0x00000002, 0x22322222, 0x22222200,\n    0x00000000, 0x00000322, 0x23322222, 0x22222200,\n    0x00000000, 0x08222222, 0x20322230, 0x22222200,\n    0x00000000, 0x08032222, 0x23300003, 0x22222200,\n    \n    0x00000000, 0x08003222, 0x22230032, 0x22222200,\n    0x08200000, 0x08000322, 0x22222222, 0x22322200,\n    0x08220000, 0x08000032, 0x22222222, 0x22222200,\n    0x08322000, 0x00800003, 0x22222222, 0x33222300,\n    0x08322200, 0x08322222, 0x22232222, 0x33222000,\n    0x08022222, 0x20032222, 0x22222222, 0x22222000,\n    0x08032222, 0x22203222, 0x22222222, 0x22223000,\n    0x08002222, 0x22220322, 0x33222222, 0x22220000,\n    \n    0x00803223, 0x22222233, 0x03222222, 0x22200000,\n    0x00800222, 0x22222222, 0x22222222, 0x22000000,\n    0x00080022, 0x22222222, 0x22222222, 0x20000000,\n    0x00080002, 0x22222222, 0x22222223, 0x00000000,\n    0x00008000, 0x32222222, 0x22222200, 0x00000000,\n    0x00000800, 0x03322222, 0x22233000, 0x00000000,\n    0x00000008, 0x00003333, 0x30000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_player_run_a[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00767777, 0x77770000,\n    0x00000000, 0x00000000, 0x07666666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666666, 0x66666700,\n    0x00000000, 0x00000000, 0x07666566, 0x66666700,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000777, 0x77666666, 0x66647000,\n    \n    0x00000000, 0x00007222, 0x27766666, 0x44447000,\n    0x00000000, 0x00072222, 0x22276466, 0x44447000,\n    0x00000000, 0x00722222, 0x22226465, 0x44177000,\n    0x00000000, 0x07722222, 0x22222444, 0x41174700,\n    0x00000000, 0x07444277, 0x22222244, 0x44174700,\n    0x00000000, 0x07444565, 0x52222244, 0x44447000,\n    0x00000000, 0x00745765, 0x52222264, 0x44470000,\n    0x00000000, 0x00077652, 0x22222226, 0x77700000,\n    \n    0x00000000, 0x00076636, 0x22222227, 0x25770000,\n    0x00000000, 0x00766333, 0x66222227, 0x22247000,\n    0x00000000, 0x07366333, 0x33662272, 0x22247000,\n    0x00000007, 0x73336633, 0x33336672, 0x22270000,\n    0x00000773, 0x33336663, 0x33333377, 0x77700000,\n    0x00007733, 0x33333667, 0x33333337, 0x00000000,\n    0x00076733, 0x33333677, 0x73333333, 0x70000000,\n    0x00076773, 0x33677700, 0x07633333, 0x37777000,\n    \n    0x00076677, 0x77700000, 0x00776333, 0x33767000,\n    0x00076700, 0x00000000, 0x00007733, 0x37670000,\n    0x00077000, 0x00000000, 0x00000077, 0x76700000,\n    0x00000000, 0x00000000, 0x00000007, 0x67000000,\n    0x00000000, 0x00000000, 0x00000000, 0x70000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_player_run_b[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00007000, 0x00000000,\n    0x00000000, 0x00000000, 0x00676777, 0x77770000,\n    0x00000000, 0x00000000, 0x07766666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666566, 0x66666700,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000000, 0x07666666, 0x66646700,\n    \n    0x00000000, 0x00000000, 0x07666666, 0x65447000,\n    0x00000000, 0x00000000, 0x07666666, 0x44447000,\n    0x00000000, 0x00000000, 0x07766466, 0x44177000,\n    0x00000000, 0x00000000, 0x07777465, 0x41177000,\n    0x00000000, 0x00000000, 0x72222444, 0x44174700,\n    0x00000000, 0x00000007, 0x22222244, 0x44444700,\n    0x00000000, 0x00000072, 0x22222244, 0x45447000,\n    0x00000000, 0x00000722, 0x22626224, 0x44470000,\n    \n    0x00000000, 0x00000722, 0x22662222, 0x77700000,\n    0x00000000, 0x00000722, 0x22272222, 0x70000000,\n    0x00000000, 0x00000772, 0x22277227, 0x70000000,\n    0x00000000, 0x00000767, 0x22447274, 0x70000000,\n    0x00000000, 0x00007666, 0x74447674, 0x70000000,\n    0x00000000, 0x00007366, 0x67776670, 0x00000000,\n    0x00000000, 0x00073333, 0x66663370, 0x00000000,\n    0x00000000, 0x00073333, 0x37333370, 0x00000000,\n    \n    0x00000000, 0x00733333, 0x76333370, 0x00000000,\n    0x00000000, 0x00733336, 0x67333700, 0x00000000,\n    0x00000000, 0x07333337, 0x67633700, 0x00000000,\n    0x00000000, 0x07733367, 0x76777000, 0x00000000,\n    0x00000000, 0x07673370, 0x07677000, 0x00000000,\n    0x00000000, 0x00767700, 0x00767000, 0x00000000,\n    0x00000000, 0x00076670, 0x00077000, 0x00000000,\n    0x00000000, 0x00007770, 0x00000000, 0x00000000);\n\nconst int spr_player_run_c[128] = int[128](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00007000, 0x00000000,\n    0x00000000, 0x00000000, 0x07676777, 0x77770000,\n    0x00000000, 0x00000000, 0x00766666, 0x66667000,\n    0x00000000, 0x00000000, 0x07666655, 0x66666700,\n    0x00000000, 0x00000000, 0x07666666, 0x66676700,\n    0x00000000, 0x00000000, 0x07666666, 0x65447700,\n    0x00000000, 0x00000777, 0x77766766, 0x54447000,\n    \n    0x00000000, 0x00007222, 0x27777466, 0x44177000,\n    0x00000000, 0x00072222, 0x22277456, 0x41177000,\n    0x00000000, 0x00722222, 0x22227444, 0x44177000,\n    0x00000000, 0x00722225, 0x22222644, 0x44444700,\n    0x00000000, 0x00722272, 0x22222244, 0x45444700,\n    0x00000000, 0x00744722, 0x22222224, 0x44447000,\n    0x00000000, 0x00077222, 0x25222225, 0x44470000,\n    0x00000000, 0x00007222, 0x25222222, 0x67770000,\n    \n    0x00000000, 0x00073622, 0x25522222, 0x22447000,\n    0x00000000, 0x00733366, 0x25652222, 0x22247000,\n    0x00000000, 0x07333333, 0x66667522, 0x22270000,\n    0x00000007, 0x73333333, 0x36667777, 0x77700000,\n    0x00000773, 0x33333333, 0x67777770, 0x00000000,\n    0x00007733, 0x33333367, 0x77776337, 0x00000000,\n    0x00076733, 0x33336670, 0x77773333, 0x70000000,\n    0x00076673, 0x36677700, 0x00773333, 0x37777000,\n    \n    0x00076677, 0x77700000, 0x00076333, 0x37677000,\n    0x00076700, 0x00000000, 0x00007733, 0x76770000,\n    0x00077000, 0x00000000, 0x00000077, 0x67700000,\n    0x00000000, 0x00000000, 0x00000007, 0x77000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00000000);\n\nconst int spr_bush_small[32] = int[32](\n    0x00000000, 0x00000000,\n    0x00000990, 0x99000000,\n    0x00099999, 0x99900000,\n    0x00999999, 0x99999000,\n    0x00999999, 0x99999000,\n    0x09999999, 0x99999900,\n    0x09999979, 0x77797900,\n    0x99999997, 0x77779000,\n    \n    0x09999777, 0x74697990,\n    0x99997746, 0x66779999,\n    0x77977774, 0x46999990,\n    0x79999996, 0x47999997,\n    0x99999997, 0x67799977,\n    0x99799999, 0x77777770,\n    0x77999999, 0x94746600,\n    0x07797999, 0x94466960);\n\nconst int spr_bush_large[256] = int[256](\n    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000000, 0x00999990, 0x00000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00000009, 0x99999999, 0x90000000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x00090999, 0x99999999, 0x99900000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000000, 0x09999999, 0x99999999, 0x99900000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000009, 0x99999999, 0x99999999, 0x99990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000009, 0x99999999, 0x99999999, 0x99990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999999, 0x97900000, 0x00000000, 0x00000000, 0x00000000,\n    \n    0x00000000, 0x00000999, 0x99999999, 0x99999999, 0x97990000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000999, 0x99999999, 0x99999977, 0x79977000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999997, 0x97777000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00000099, 0x99999999, 0x99999999, 0x99770000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00009999, 0x99799999, 0x99979999, 0x99999000, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00009999, 0x97779999, 0x77799999, 0x99999990, 0x00000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00999997, 0x77799999, 0x77999999, 0x99799999, 0x97000000, 0x00000000, 0x00000000,\n    0x00000000, 0x00799999, 0x77797999, 0x99999999, 0x99977999, 0x99000000, 0x00000000, 0x00000000,\n    \n    0x00000000, 0x99999977, 0x74779999, 0x99999999, 0x79979999, 0x99900000, 0x00000000, 0x00000000,\n    0x00000000, 0x79779976, 0x66799799, 0x99999999, 0x97797979, 0x97790000, 0x00000000, 0x00000000,\n    0x00000000, 0x07779776, 0x67677999, 0x99979977, 0x99797799, 0x99970000, 0x00000000, 0x00000000,\n    0x00000000, 0x07797797, 0x67697999, 0x99777767, 0x77779777, 0x99999900, 0x00000000, 0x00000000,\n    0x00000000, 0x00979967, 0x66699979, 0x99777646, 0x76977799, 0x99997700, 0x00000000, 0x00000000,\n    0x00000099, 0x99997677, 0x76679977, 0x66766466, 0x77669999, 0x99999990, 0x00000000, 0x00000000,\n    0x00009977, 0x99999776, 0x66677797, 0x77677669, 0x67799999, 0x99999990, 0x00000000, 0x00000000,\n    0x00077999, 0x99999964, 0x66467999, 0x76646666, 0x76999999, 0x99979979, 0x00000000, 0x00000000,\n    \n    0x00999799, 0x99999796, 0x66476766, 0x67646674, 0x79999999, 0x99997799, 0x00000000, 0x00000000,\n    0x09799999, 0x99977976, 0x66666777, 0x66646446, 0x99999999, 0x99999797, 0x00000000, 0x00000000,\n    0x09999799, 0x79997799, 0x97666666, 0x66744467, 0x79999999, 0x99979779, 0x00000000, 0x00000000,\n    0x79999777, 0x97779999, 0x99996666, 0x66444749, 0x99999999, 0x79977977, 0x00000000, 0x00000000,\n    0x99999979, 0x77769999, 0x99776674, 0x77447669, 0x77999999, 0x97777777, 0x00000000, 0x00000000,\n    0x77999997, 0x77699999, 0x99979664, 0x44479967, 0x97797999, 0x99779776, 0x00000000, 0x00000000,\n    0x77799779, 0x79999999, 0x77997766, 0x44499997, 0x79977997, 0x99799779, 0x00000000, 0x00000000,\n    0x97779999, 0x79779799, 0x99977769, 0x64779997, 0x77799797, 0x79979799, 0x00000000, 0x00000000);\n\n\nfloat lineScroll (float y) {\n    float s = 0.0;\n    if (y>8.0*8.0) s = 10.0;\n    if (y>8.0*20.0) s = 40.0;\n    if (y>8.0*21.0) s = 60.0;\n\treturn floor(s*iTime);\n}\n\n\nvec3 drawTiles( vec2 p ) {\n\t// get coords for 8x8 tile\n    p.x = mod( p.x + lineScroll(p.y), IRES.x );\n    ivec2 i = ivec2( floor(p/8.0) );\n    vec2 t = fract(p/8.0)*8.0;\n    int ti = map[ i.x + 32*i.y ]*8 + int(t.y);\n    int pi = ( atlas[ ti ] >> (int(8.0-t.x)*4) ) & 0xF;\t\t//palette index of pixel in atlas\n    return palette_t[pi];\n}\n\n\nvoid drawSprite_16x16( inout vec3 col, int spr[32], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<16 && i.y>=0 && i.y<16 ) {\n        int pi = spr[ i.x/8 + i.y*2 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_32x16( inout vec3 col, int spr[64], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<16 ) {\n        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_32x32( inout vec3 col, int spr[128], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<32 && i.y>=0 && i.y<32 ) {\n        int pi = spr[ i.x/8 + i.y*4 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid drawSprite_64x32( inout vec3 col, int spr[256], vec3 pal[16], vec2 p, vec2 s ) {\n    ivec2 i = ivec2( floor(p-s) );\n    if( i.x>=0 && i.x<64 && i.y>=0 && i.y<32 ) {\n        int pi = spr[ i.x/8 + i.y*8 ] >> ((7-i.x)*4) & 0xF;\n        if (pal[pi].r>-0.5) col = pal[pi];\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy;\n    uv.y = IRES.y-uv.y;\n    \n    vec3 col = vec3(2, 0, 2);\n    //if( mod(fragCoord.x,16.0)<1.0 ) col.r = 7.0;\n    //if( mod(fragCoord.y,16.0)<1.0 ) col.g = 7.0;\n    \n    vec3 bg = drawTiles(uv);\n    if (bg.r>-0.5) col = bg;\n    \n    // UI\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(16,8)\t );\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(32,8)\t );\n    drawSprite_16x16( col, spr_heart,\t\tpalette_u, uv, vec2(48,8)\t );\n    drawSprite_32x16( col, spr_score,\t\tpalette_u, uv, vec2(200,220) );\n    \n    // BUSHES\n    drawSprite_64x32( col, spr_bush_large,  palette_t, uv, vec2( mod( -lineScroll(200.0)+96.0 , IRES.x*2.0)-64.0, 144.0) );\n    drawSprite_16x16( col, spr_bush_small,  palette_t, uv, vec2( mod( -lineScroll(200.0)+32.0 , IRES.x*2.0)-64.0, 160.0) );\n    drawSprite_16x16( col, spr_bush_small,  palette_t, uv, vec2( mod( -lineScroll(200.0)+320.0, IRES.x*2.0)-64.0, 160.0) );\n    \n    // MOON\n    vec2 moonpos = vec2(110,16);\n    if ( mod(iTime,5.0)>4.8 )\t\t\tdrawSprite_32x32( col, spr_moon_blink, palette_t, uv, moonpos );\n    else\t\t\t\t\t\t\t\tdrawSprite_32x32( col, spr_moon,\t   palette_t, uv, moonpos );\n    \n    // PLAYER\n    vec2 pp = vec2(110, 168);\n    drawSprite_16x16( col, spr_player_shadow, palette_p, uv, pp+vec2(8,18) );\n    float rc = fract(iTime*1.0);\n    if (rc<0.25)\t\t\t\t\t\tdrawSprite_32x32( col, spr_player_run_a, palette_p, uv, pp );\n    else if (rc>=0.5 && rc<0.75)\t\tdrawSprite_32x32( col, spr_player_run_c, palette_p, uv, pp );\n    else\t\t\t\t\t\t\t\tdrawSprite_32x32( col, spr_player_run_b, palette_p, uv, pp );\n    \n    col = clamp( col/7.0, 0.0, 1.0 );\t\t\t// convert to 9-bit RGB\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define NTSC_ARTIFACTS\n#define SCANLINES\n#define SHADOW_MASK\n#define SCREEN_SHAPE\n#define LIGHT_EFFECTS\n\n//#define CURVE_MASK_TO_SCREEN\n#define SCREEN_CURVE_RADIUS\t\t5.0\n#define SCREEN_CORNER_RADIUS\t0.1\n#define BRIGHTNESS      \t\t2.5\n#define PIXEL_SHARPNESS   \t\t3.0\n#define LINE_SHARPNESS\t\t\t6.0\n#define MASK_STRENGTH\t\t\t0.35\n#define MASK_SCALE\t\t\t\t600.0\n\n\n\n\n\n\n#define IRES\t\tvec2( 256, 239 )\n\n\nconst float PI = 3.14159265;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// NTSC composite sampling artifacts, as usually seen on consoles such as the NES or TG-16\n// Explanation: http://wiki.nesdev.com/w/index.php/NTSC_video\n\n\nconst mat3 rgbtoyiq = mat3(0.299, 0.587, 0.114, 0.596, -0.275, -0.321, 0.212, -0.528, 0.311);\nconst mat3 yiqtorgb = mat3(1.0, 0.946882, 0.623557, 1.0, -0.274788, -0.635691, 1.0, -1.108545, 1.709007);\n\n\nvec3 YIQfromsample( vec3 rgb, float phase ) {\n  vec3 yiq = rgb * rgbtoyiq;\n  float p = phase / 6.0 * PI;\n  float sig = yiq.x + yiq.y*cos(p) + yiq.z*sin(p);\n  return sig * vec3( 1.0, cos(p), sin(p) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  ivec2 l = ivec2(fragCoord)-ivec2(1,0);\n  ivec2 m = ivec2(fragCoord);\n  ivec2 r = ivec2(fragCoord)+ivec2(1,0);\n    \n  l.x = max(l.x, 0);\n  r.x = min(r.x, int(IRES.x));\n    \n  vec3 lp = texelFetch( iChannel0, l, 0).rgb;\n  vec3 mp = texelFetch( iChannel0, m, 0).rgb;\n  vec3 rp = texelFetch( iChannel0, r, 0).rgb;\n\n  float phase = fragCoord.x*8.0 + fragCoord.y*4.0 + round(iTime*60.0)*4.0;\n  const float samples = 12.0;                   // number of signal samples (4 per subcarrier wavelength)\n  const float pwidth = 8.0;                     // width of the current pixel's signal, in samples\n  float overflow = (samples-pwidth)*0.5;\n\n  vec3 yiq = vec3(0.0);\n  for ( float f=0.0; f<samples; f++ ) {\n    vec3 s = f<overflow ? lp : ( f<samples-overflow ? mp : rp );    // get sample\n    yiq += YIQfromsample( s, phase-overflow+f );                    // add sample to buffer\n  }\n  yiq /= samples;\n  yiq.yz *= 2.0;\n  \n  vec3 rgb = yiq * yiqtorgb;\n  \n  // Here is where I had considered blending in a bit of the previous frame due to CRT phosphor afterglow\n  // but after some research it seems as though the effects visible on a healthy television of the\n  // early 90s should probably be pretty much negligible at 60fps (I have no reference unit on hand\n  // to compare against).\n    \n  // Pages 597 and 598 of the Phosphor Handbook, Second Edition (1999) imply that the time should be\n  // no more than 2ms for a phosphor to fall to 10% of its emissive output. Maybe 1 or 2% percent could\n  // still be present when the next frame happens, but it doesn't really seem worth simulating to me.\n    \n  // For way more information on this subject than you could ever possibly need:\n  // http://research.mrl.ucsb.edu/~ngeorge/downloads/Phosphor%20books/Phosphor%20Handbook.pdf\n  \n  //rgb += texelFetch( iChannel1, ivec2(fragCoord), 0).rgb * vec3(0.1);\n    \n  rgb = clamp(rgb, 0.0, 1.0);\n  fragColor = vec4( rgb, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// generate shadow mask based on pattern and dot pitch\n// please excuse the mess\n\n// common tv size in the early 90s was ~27\"\n// common dot pitch on tvs of the time is ~.5 mm (computer monitors were closer to .25 mm)\n\n\nvec3 TriadMask( vec2 pos ) {\n\tvec3 col = vec3(0.0);\n    float h = sqrt(3.0)/2.0;\n    pos.x = mod(pos.x, 3.0);\n    pos.y = mod(pos.y, h*2.0);\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(0.0,0.0)   ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(1.0,0.0)   ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(2.0,0.0)   ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(3.0,0.0)   ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(-0.5,h)    ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(0.5,h)     ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(1.5,h)     ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(2.5,h)     ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(3.5,h)     ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(0.0,h*2.0) ), 0.0 );\n    col += vec3(0,1,0) * max( 1.0-distance(pos, vec2(1.0,h*2.0) ), 0.0 );\n    col += vec3(0,0,1) * max( 1.0-distance(pos, vec2(2.0,h*2.0) ), 0.0 );\n    col += vec3(1,0,0) * max( 1.0-distance(pos, vec2(3.0,h*2.0) ), 0.0 );\n    col - min(col, 1.0);\n    col = smoothstep(0.4, 0.65, col);\n    return col;\n}\n\n\nvec3 SlotMask( vec2 pos ) {\n\tvec3 col = vec3(0.0);\n    col += vec3(1,0,0) * max( (1.0 - distance(mod(pos.x,3.0),0.5) ), 0.0 );\n    col += vec3(0,1,0) * max( (1.0 - distance(mod(pos.x,3.0),1.5) ), 0.0 );\n    col += vec3(0,0,1) * max( (1.0 - distance(mod(pos.x,3.0),2.5) ), 0.0 );\n\tcol += vec3(1,0,0) * max( (1.0 - distance(mod(pos.x,3.0),3.5) ), 0.0 );\n    float b = pos.y;\n    b += (fract(pos.x/6.0) > 0.5) ? 1.5 : 0.0;\n    b = mod(b,3.0);\n    col -= (b<0.35) ? 1.0 : 0.0;\n    col = smoothstep(0.6, 0.7, col);\n    return col;\n}\n\n\nvec3 TriadMask_PixelPerfect( vec2 pos ) {\n    float f = fract( pos.x/6.0 + floor(pos.y/2.0)/2.0);\n    vec3 col = (f<=0.333) ? vec3(1,0,0) : ( (f<0.667) ? vec3(0,1,0) : vec3(0,0,1) ); \n    return col;\n}\n\n\nvec3 SlotMask_PixelPerfect( vec2 pos ) {\n    pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    float glow = 0.5;\n    float f = mod(pos.x,3.0);\n    vec3 col = vec3( (f<=1.0), (f>1.0&&f<=2.0), (f>2.0) );\n    col += vec3( (f<1.5 || f>=2.5), (f>0.5 && f<=2.5), (f>1.5 || f<=0.5) ) * glow;\n    col *= ( mod(pos.y+(fract(pos.x/6.0)>0.5?1.5:0.0),3.0)<1.0 ) ? glow : 1.0;\n    col /= 1.0+glow;\n    return col;\n}\n\n\nvec3 ApertureGrille_PixelPerfect( vec2 pos ) {\n    pos /= 1.0 + floor( iResolution.y / 1440.0 );\n    float f = fract(pos.x/3.0);\n    vec3 col = vec3( (f<=0.333), (f>0.333&&f<0.667), (f>=0.667) );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = fragCoord/iResolution.x * MASK_SCALE;\n    \n    //vec3 col = TriadMask( pos );\n    //vec3 col = SlotMask( pos );\n    //vec3 col = TriadMask_PixelPerfect( fragCoord );\n    vec3 col = SlotMask_PixelPerfect( fragCoord );\n    //vec3 col = ApertureGrille_PixelPerfect( fragCoord );\n    \n    col = mix( vec3(1.0-MASK_STRENGTH), vec3(1.0+MASK_STRENGTH), col);\n    \n    //if (fract(fragCoord.x/200.0)<0.02) col = vec3(10.0);\n    //if (fract(fragCoord.y/200.0)<0.02) col = vec3(10.0);\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}