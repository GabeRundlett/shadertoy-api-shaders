{
    "Shader": {
        "info": {
            "date": "1694425199",
            "description": "Wrapping of a tiling texture around a sohere with minimal distortions, using mulitple methods. \nUsing a performance test designed to tank your FPS to see which operation is faster.",
            "flags": 0,
            "hasliked": 0,
            "id": "mdSfRw",
            "likes": 2,
            "name": "PerfTest Cubemapping",
            "published": 3,
            "tags": [
                "test",
                "cubemap",
                "performance",
                "speed"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 203
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2023 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis performance test aims to compare cubemapping implementations.\n\nThe test works by measuring frames per second (FPS) on Shadertoy. To \nensure valid results, we repeat the test function with varying values, \naccumulating their results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS are below your monitors refreshrate \n    (probably somewhere around 60-144 fps)\n- Modify TEST value to switch between test cases\n- The highest FPS indicates the fastest implementation\n- Congratulate yourself for doing SCIENCE\n\nWhile it's possible to improve Mips using derivatives, I have not \nimplemented this optimization in these versions, cubemapping inherently \nfaces challenges with mapping on at least six edges. Therefore, I have \nnot implemented Mip optimization for these implementations.\n*/\n\n// Number of repeats of the test, 4000 should be enough for RTX3080\n#define REPEAT 1\n\n// switch between the test cases\n// 0 = Cubemap using if ~ 81 fps\n// 1 = Folded Cubemap using if ~ 44 fps\n// 2 = Cubemap using a Mask ~ 61 fps\n// 3 = Cubemap using a Mask v2 ~ 62 fps\n// 4 = folded Cubemap using a Mask  ~ 37 fps\n#define TEST 1\n\n// smallest float to avoid float errors\n#define TINY (1.0 / float(0xffffffffU))\n\n// Default Cubemap using if from IG https://www.shadertoy.com/view/ltl3D8\nvec2 CubemapIf(vec3 uvw) {\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? uvw.xyz: \n             (n.y>n.z) ?            uvw.yzx:\n                                    uvw.zxy;\n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using if, that is folded so all but 6 edges align\nvec2 CubemapFoldedIf(vec3 uvw) {\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? vec3(uvw.x, uvw.y, sUVW.x * uvw.z): \n             (n.y>n.z) ?            vec3(uvw.y, -uvw.x, sUVW.y * uvw.z):\n                                    vec3(uvw.z, sUVW.z * uvw.x, uvw.y);\n                                    \n    // edge distance\n    //float eDist = clamp(-(n.z - max(n.x, n.y)), 0., 1.) + \n    //              clamp(n.z - max(n.x, uvw.y), 0., 1.);\n                  \n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using if, that is folded so all but 6 edges align\nvec2 CubemapMostlyFoldedIf(vec3 uvw) {\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // intersect cube\n    vec3 n = abs(uvw);\n    vec3 v = (n.x>n.y && n.x>n.z) ? vec3(uvw.x, uvw.y, sUVW.x * uvw.z): \n             (n.y>n.z) ?            vec3(uvw.y, -uvw.x, sUVW.y * uvw.z):\n                                    vec3(uvw.z, uvw.x, uvw.y);\n                                    \n    // edge distance\n    //float eDist = clamp(-(n.z - max(n.x, n.y)), 0., 1.) + \n    //              clamp(n.z - max(n.x, uvw.y), 0., 1.);\n                  \n    // project into face\n    vec2 uv = v.yz/v.x;\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If\nvec2 CubemapMask(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(aUVW.x - max(aUVW.y, aUVW.z),\n                     aUVW.y - max(aUVW.x, aUVW.z),\n                     aUVW.z - max(aUVW.x, aUVW.y));\n    mask = clamp(mask, 0., 1.);\n    //float eDist = max(mask.x, max(mask.y, mask.z)); // edge distance\n    vec3 bitMask = step(TINY,mask);\n\n    // project into face without if\n    vec2 uv = vec2((uvw.yz * bitMask.x)/uvw.x + \n                   (uvw.zx * bitMask.y)/uvw.y + \n                   (uvw.xy * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If\nvec2 CubemapMaskv2(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(max(aUVW.y, aUVW.z),\n                     max(aUVW.x, aUVW.z),\n                     max(aUVW.x, aUVW.y));\n    //float eDist = max(mask.x, max(mask.y, mask.z)); // edge distance\n    vec3 bitMask = step(mask,aUVW);\n\n    // project into face without if\n    vec2 uv = vec2((uvw.yz * bitMask.x)/uvw.x + \n                   (uvw.zx * bitMask.y)/uvw.y + \n                   (uvw.xy * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\n// Cubemap using masks instead of If, that is folded so all but 6 edges align\nvec2 CubemapFoldedMask(vec3 uvw) {\n    // Cube Masks\n    vec3 aUVW = abs(uvw);\n    vec3 mask = vec3(aUVW.x - max(aUVW.y, aUVW.z),\n                     aUVW.y - max(aUVW.x, aUVW.z),\n                     aUVW.z - max(aUVW.x, aUVW.y));\n    \n    // edge distance\n    //float eDist = clamp(-mask.z, 0., 1.) + \n    //              clamp(aUVW.z - max(aUVW.x, uvw.y), 0., 1.);\n                  \n    mask = clamp(mask, 0., 1.);\n    vec3 bitMask = step(TINY,mask);\n\n    // bitmask for flipping some sides\n    vec3 sUVW = sign(uvw);\n\n    // project into face without if\n    vec2 uv = vec2((vec2(uvw.y, sUVW * uvw.z) * bitMask.x)/uvw.x + \n                   (vec2(-uvw.x, sUVW.y * uvw.z) * bitMask.y)/uvw.y + \n                   (vec2(sUVW.z * uvw.x, uvw.y) * bitMask.z)/uvw.z);\n    \n    // Cass Everitt's piecewise quadratic warp \n    // https://github.com/casseveritt/projection/blob/master/envmap.h (Ctrl+F pinch)\n    vec2 distort = (1.45109572583 - 0.451095725826*abs(uv));\n    uv *= distort;\n    \n    // rescale to 0-1 range\n    return 0.5+0.5*uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 dir = sphereNormals(uv);\n\n    // if you get around 144 fps use a higher repeat value\n    vec2 test;\n    for(int i=0; i<REPEAT; i++) {\n        vec3 aDIR = dir + (float(i)/float(REPEAT)); // permutation each iteration\n    \n        // use which ever you wish to test\n        #if TEST == 0\n            test += CubemapIf(aDIR);\n        #elif TEST == 1\n            test += CubemapFoldedIf(aDIR);\n        #elif TEST == 2\n            test += CubemapMask(aDIR);\n        #elif TEST == 3\n            test += CubemapMaskv2(aDIR);\n        #else\n            test += CubemapFoldedMask(aDIR);\n        #endif   \n    }\n    \n    vec4 col = texture(iChannel0, test);\n\n    // Output to screen\n    fragColor = vec4(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.1415926536\n\n// sphere normals form morgan3d https://www.shadertoy.com/view/4dsGD2\nvec3 sphereNormals(vec2 uv) \n{\n    float theta = (1.0 - uv.y) * PI;\n\tfloat phi   = uv.x * PI * 2.0;\n    \n    float sinTheta = sin(theta);    \n    \n    // Equation from http://graphicscodex.com  [sphry]\n\tvec3 dir = vec3(sinTheta * sin(phi),\n                    cos(theta), \n                    sinTheta * cos(phi));\n    return dir;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}