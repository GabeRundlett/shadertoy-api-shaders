{
    "Shader": {
        "info": {
            "date": "1417191486",
            "description": "Working with a ray-based kaleidoscope.",
            "flags": 0,
            "hasliked": 0,
            "id": "4dBSDt",
            "likes": 1,
            "name": "SuperKaleider",
            "published": 3,
            "tags": [
                "kaleidoscope"
            ],
            "usePreview": 0,
            "username": "eoghan_rehab",
            "viewed": 461
        },
        "renderpass": [
            {
                "code": "// With thanks, adapted from https://www.shadertoy.com/view/XslGz7\n\nstruct Ray {\n\tvec2 point;\n\tvec2 direction;\n};\n\n//#define debug\n\n#ifdef debug\n    #define debugCircleSize 0.005\n    #define debugLineWidth 0.001\n    #define debugLineLength 0.15\n#endif\n\n#define imagePosWander 0.01\n#define imageRotWander 0.01\n#define imageScaleWander 0.001\n\n#define globalPosWander 0.1\n#define globalRotWander 0.1\n#define globalScaleWander 0.01\n    \n#define patternShapeWander 0.003\n//#define patternDepthWander 0.015\n//#define patternBranchWander 0.015\n    \n#define initRay initCenterRay\n#define nextRay nextRecursiveRay\n#define map mapKaleidoscope\n\n#define pi 3.14159265\n#define tau 6.28318531\n\nconst int maxDepth = 15;\nconst int maxBranches = 6;\nconst float orbit = 0.05;\nconst float refraction = 0.0;\n\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n),\n        f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    \n\treturn mix(mix(rand(b), rand(b+d.yx), f.x), mix(rand(b+d.xy), rand(b+d.yy), f.x), f.y);\n}\n\nvec2 noise2(vec2 n) {\n\treturn vec2(noise(vec2(n.x+0.2, n.y-0.6)), noise(vec2(n.y+3.0, n.x-4.0)));\n}\n\nfloat length2(vec2 v) {\n    return dot(v, v);\n}\n\nfloat distance2(vec2 a, vec2 b) {\n    return length2(a-b);\n}\n\nvec2 perp(vec2 v) {\n    return vec2(v.y, -v.x);\n}\n\nmat2 vecRotation(vec2 vec) {\n    if(length2(vec) != 1.0) {\n        vec = normalize(vec);\n    }\n    \n    return mat2(vec.x, -vec.y,\n               vec.y, vec.x);\n}\n\nmat2 angleRotation(float angle) {\n    float c = cos(angle),\n        s = sin(angle);\n    \n    return mat2(c, -s,\n               s, c);\n}\n\n\n// Ray init styles.\n\nRay initCenterRay(vec2 pos, vec2 vec) {\n    return Ray(pos, normalize(vec-pos));\n}\n\nRay initCenterPerpRay(vec2 pos, vec2 vec) {\n    return Ray(pos, perp(normalize(vec-pos)));\n}\n\nRay initOffsetRay(vec2 pos, vec2 vec) {\n    return Ray(vec, normalize(vec-pos));\n}\n\nRay initOffsetPerpRay(vec2 pos, vec2 vec) {\n    return Ray(vec, perp(normalize(vec-pos)));\n}\n\nRay initOrbitRay(vec2 pos, vec2 vec) {\n    vec2 toVec = vec-pos,\n        vecOrbit = normalize(toVec)*orbit,\n        //orbitOffset = ((length2(vecOrbit) > length2(toVec))? vecOrbit : toVec);\n        orbitOffset = mix(vecOrbit, toVec, step(length2(vecOrbit), length2(toVec)));\n    \n    return Ray(pos+orbitOffset, normalize(vec));\n}\n\nRay initOrbitPerpRay(vec2 pos, vec2 vec) {\n    vec2 toVec = vec-pos,\n        vecOrbit = normalize(toVec)*orbit,\n        //orbitOffset = ((length2(vecOrbit) > length2(toVec))? vecOrbit : toVec);\n        orbitOffset = mix(vecOrbit, toVec, step(length2(vecOrbit), length2(toVec)));\n    \n    return Ray(pos+orbitOffset, normalize(perp(vec)));\n}\n\n\n// Ray iteration styles.\n\n// Travel along the ray and rotate by the same direction.\nRay nextConstantRay(Ray ray, float size, mat2 rotation, float i) {\n    return Ray(ray.point+(ray.direction*size),\n               normalize(rotation*ray.direction));\n}\n\nRay nextConstantPerpRay(Ray ray, float size, mat2 rotation, float i) {\n    return Ray(ray.point+perp(ray.direction*size),\n               normalize(rotation*ray.direction));\n}\n\nRay nextRecursiveRay(Ray ray, float size, mat2 rotation, float i) {\n    size = pow(size, i);\n    \n    return Ray(ray.point+(ray.direction*size),\n               normalize(ray.direction*rotation));\n}\n\n\n// Map position through pattern ray.\n\nvec2 mapKaleidoscope(vec2 pos, Ray ray) {                \n    vec2 fromRay = pos-ray.point;\n\n    float offset = dot(fromRay, ray.direction);\n\n    if(offset < 0.0) {\n        pos -= 2.0*offset*ray.direction;\n    }\n    \n    return pos;\n}\n\nvec2 mapRefract(vec2 pos, Ray ray) {                \n    vec2 fromRay = pos-ray.point;\n\n    float offset = dot(fromRay, ray.direction);\n\n    if(offset < 0.0) {\n        pos -= refract(fromRay, ray.direction, refraction);\n    }\n    \n    return pos;\n}\n\nvec2 mapMulti(vec2 pos, Ray ray) {                \n    vec2 fromRay = pos-ray.point;\n\n    float offset = dot(fromRay, ray.direction);\n\n    if(offset < 0.0) {\n        pos += refract(fromRay, ray.direction, refraction)-2.0*offset*ray.direction;\n    }\n\n    return pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Prefixing screen units with `s`.\n\tvec2 sCenter = iResolution.xy*0.5,\n        sCenterMouse = iMouse.xy-sCenter;\n    \n    float sSize = min(iResolution.x, iResolution.y),\n        sInvSize = 1.0/sSize;\n    \n    // Normalised units.\n    vec2 pos = fragCoord.xy*sInvSize,\n        center = sCenter*sInvSize;\n    \n    #ifdef globalPosWander\n\t    pos += noise2(vec2(iTime*globalPosWander));\n    #endif\n    #ifdef globalRotWander\n\t    pos *= vecRotation(normalize(noise2(vec2(iTime*globalRotWander))-vec2(0.5)));\n    #endif\n    #ifdef globalScaleWander\n\t    pos *= length2(noise2(vec2(iTime*globalScaleWander)));\n    #endif\n    \n    #ifdef debug\n        if(abs(distance(pos, center)-orbit) < debugLineWidth) {\n            fragColor.rgb = vec3(0, 0, 1);\n            return;\n        }\n        if(distance(pos, center) < debugCircleSize) {\n            fragColor.rgb = vec3(0, 0, 1);\n            return;\n        }\n    #endif\n    \n    #ifdef patternShapeWander\n    \tvec2 mouseVec = noise2(vec2(iTime*patternShapeWander));\n    #else\n\t    vec2 mouseVec = iMouse.xy*sInvSize;\n    #endif\n    \n    vec2 centerMouse = mouseVec-center;\n    float mouseDist = length(centerMouse),\n        stepSize = max(mouseDist-orbit, 0.0);\n\n    #ifdef patternDepthWander\n    \tint depth = int(min(length2(noise2(vec2(iTime*patternDepthWander))), 1.0)*float(maxDepth));\n    #else\n        // Bail out according to the distance from the center to the edge.\n        // (`mouseDist/{half normalised size} == mouseDist/0.5 == mouseDist*2.0`)\n        //int depth = int(min((mouseDist*2.0)-orbit/4.0, 1.0)*float(maxDepth));\n        int depth = maxDepth;\n    #endif\n\n    #ifdef patternBranchWander\n    \tint branches = int(min(length2(noise2(vec2(iTime*patternBranchWander))), 1.0)*float(maxBranches));\n    #else\n        int branches = maxBranches;\n    #endif\n    \n    // Loop the initial rays for the number of initial branches.\n    // Offset the starting angle/position by 360/numBranches.\n    Ray ray = initRay(center, mouseVec);\n    mat2 depthRotation = vecRotation(ray.direction),\n        branchRotation = angleRotation(tau/float(branches));\n\n    // This should be breadth-first (branches loop inside depth loop), but it doesn't look\n    // right for some reason.\n    /*for(int d = 0; d < maxDepth; ++d) {\n        if(d >= depth) {\n            break;\n        }*/\n    for(int b = 0; b < maxBranches; ++b) {\n        if(b >= branches) {\n            break;\n        }\n        else {\n            Ray iterRay = Ray(ray.point, ray.direction);\n\n            /*for(int b = 0; b < maxBranches; ++b) {\n                if(b >= branches) {\n                    break;\n                }*/\n            for(int d = 0; d < maxDepth; ++d) {\n                if(d >= depth) {\n                    break;\n                }\n                else {\n                    pos = map(pos, iterRay);\n\n                    #ifdef debug\n                        vec2 fromRay = pos-iterRay.point;\n\n                        float offset = dot(fromRay, iterRay.direction),\n                            dist = length(fromRay);\n\n                        if(dist <= debugLineLength &&\n                           offset > 0.0 &&\n                           abs(dot(fromRay, perp(iterRay.direction)))*length(iterRay.direction) < debugLineWidth) {\n                            fragColor.rgb = vec3(1, 0, 0);\n                            return;\n                        }\n                        else if(abs(offset) < debugLineWidth) {\n                            fragColor.rgb = vec3(1, 1, 1);\n                            return;\n                        }\n                    #endif\n\n\t\t            //iterRay = initRay(iterRay.point, iterRay.direction*branchRotation);\n\t\t            iterRay = nextRay(iterRay, stepSize, depthRotation, float(d));\n                }\n            }\n\n            //ray = nextRay(ray, stepSize, depthRotation, float(d));\n            ray = initRay(ray.point, ray.direction*branchRotation);\n        }\n    }\n\t\n    vec2 uv = vec2(pos.x, -pos.y);\n    \n    #ifdef imagePosWander\n\t    uv += noise2(vec2(iTime*imagePosWander));\n    #endif\n    #ifdef imageRotWander\n\t    uv *= vecRotation(normalize(noise2(vec2(iTime*imageRotWander))-vec2(0.5)));\n    #endif\n    #ifdef imageScaleWander\n\t    uv *= length2(noise2(vec2(iTime*imageScaleWander)));\n    #endif\n    \n\tfragColor.rgb = texture(iChannel0, uv).xyz;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}