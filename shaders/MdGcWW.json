{
    "Shader": {
        "info": {
            "date": "1521987631",
            "description": "simple procedural model of Eiffel tower (see blueprints below).\nI let the 3D version as an exercice :-D\n\nEach line should be a framework, as in [url]https://www.shadertoy.com/view/MdK3Rm[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "MdGcWW",
            "likes": 22,
            "name": "Eiffel tower",
            "published": 3,
            "tags": [
                "2d",
                "framework",
                "short",
                "victorian",
                "structure"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "// ref: https://upload.wikimedia.org/wikipedia/commons/7/79/Eiffel_Tower_plans_07.jpg\n\n#define S(v) smoothstep(1.,0.,abs(v)/e) // antialiased curve/line\n\n// --- a piece of nx*ny units of framework of type i, \n//     placed at dx0,dy0 and scaled/deformed with dx1,s0,s1,sy\nfloat strip(vec2 U, float dx0,float s0, float dx1,float s1, float y0, float sy, float nx, float ny, int i){\n    float y = (U.y-y0)/sy, v,\n          x = U.x / mix(s0,s1,y) - mix(dx0,dx1,y),// scaling/offset/shear/disto\n          e = min(fwidth(y*ny),fwidth(x*nx));     // pixel size (for AA)\n       // e = max(ny/sy,nx/s1)/iResolution.y;\n    if (y < -e/ny || y > 1.+e/ny || x < -e/nx || x > 1.+e/nx) return 0.;\n    x = fract(x*nx);                   // one module\n    y = fract(y*ny);\n    v = S(x)+S(x-1.)+S(x+y-1.)+S(x-y); // vertical sides + simple X\n    if (i>0) v += S(y)+S(y-1.);        // horizontal separators\n    if (i>1) v += S(x-.5);             // vertical mid-separator\n    if (i>2) v += S(y-.5);             // horizontal mid-separator\n    return v;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n         U = abs(U-.2-vec2(.5*R.x,0))/R.y;\n    float e = 1./R.y; \n    O -= O;\n    O += S(U.x)*step(.96,U.y);                           // antenna\n    O += S(length(U-vec2(0,.96))-1./70.);                // head\n             //   dx0 s0  dx1 s1    y0  s    nx ny type\n    O += strip(U, .0,.015,.0,.015, .93,.03,  3.,6.,0);   // jaw\n    O += strip(U, .0,.02, .0,.03,  .90,.03,  2.,3.,1);   // deck 3\n    O += strip(U, .0,.03, .0,.02,  .60,.30,  1.,11.,1);  // neck 2\n    O += strip(U, .5,.04, .0,.03,  .40,.20,  1.,6.,1);   // neck 1\n    O += strip(U, .0,.07, .0,.06,  .37,.03,  3.,2.,2);   // deck 2\n    O += strip(U, 1.,.07, .5,.04,  .20,.20,  1.,5.,2);   // legs 2\n    O += strip(U, .0,.163, .0,.14, .158,.042,5.,2.,2);   // deck 1\n    O += strip(U, 2.6,.07, 1.,.07, .00,.20,  1.,4.,3);   // legs 1\n    O += S(length(U)-1./6.3);                            // arch\n    O = 1.-O;\n                 \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}