{
    "Shader": {
        "info": {
            "date": "1540392098",
            "description": "drag points to see what they do.\nklick to add points. \ndrag to red square to erase point\nmore points == different demo\n\na lot of parametric patterns need more than a vec4 of iMouse or some hash/noise",
            "flags": 32,
            "hasliked": 0,
            "id": "Xt3BzX",
            "likes": 16,
            "name": "UI parametrics spartial diegetic",
            "published": 3,
            "tags": [
                "mouse",
                "bezier",
                "template",
                "drop",
                "ui",
                "quadratic",
                "drag",
                "parabola",
                "canvas",
                "util",
                "widget",
                "reusable",
                "parabolic",
                "spartial",
                "diegetic"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1019
        },
        "renderpass": [
            {
                "code": "//self   : https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\n//parent0: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\n//parent1: https://www.shadertoy.com/view/4dtSRn (multiple dots)\n//parent2: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\n//reusable drag and drop framework. \n//  * Drag objects around by clicking on them.\n//  * Add new objects by clicking in space.\n//  * Delete objects by dragging them to the red square.\n\n\nfloat mi(float a,float b){return min(a,b);}\n\nvoid drawDragDots(inout vec4 s,vec2 U,inout vec2 e\n){for(float i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;float f=length(U-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(f,e.y)),mi(f,e.y))\n ;}}\n\nvec4 dotColor(vec4 s,float r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))\n ;return vec4(.5,.5,1,1);}\n\nvec4 MainEntry(vec2 U){\n ;vec4 c=vec4(0)\n ;vec4 s=bufDrag(statePos)\n ;float r=0.,d=UiDotRadius+UiDotBorder \n ;vec2 e=vec2(r,d)\n ;drawDragDots(s,U,e)  \n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(U, deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n\nvoid mainImage(out vec4 o, in vec2 u\n){o=vec4(0)\n ;vec4 a=MainEntry(u)\n ;vec4 b=texture(iChannel1,u/1./iResolution.xy, -100.0 )\n ;//a=sat(a) \n ;//b=sat(b) \n ;o=pdOver(o,MainEntry(u))//ui dots\n     \n ;o=pdOver(o,texture(iChannel3,u/1./iResolution.xy, -100.0 ))\n ;//o=sat(o*.2)\n ;//o=pdOver(o,texture(iChannel1,u/1./iResolution.xy, -100.0 ))//buffB has a background of patterns\n ;//o=pdOver(o,vec4(1))\n ;//o=p\n ;}\n\n\n\n/*\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bézier-curves\nis tricky but usseful\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//reusable drag&drop\n//ichan0 is self\n\n// scale inout to storate data by iResolution.xy\n\n//parent     : https://www.shadertoy.com/view/4dtSRn\n//Inspired by: https://www.shadertoy.com/view/MdKGRw\n//reusable drag and drop framework; by mhnewman\n//- Drag objects around by clicking on them.\n//- Add new objects by clicking in space.\n//- Delete objects by dragging them to the red square.\n\n//this is usually split in 2 FBOs.\n//THIS shader just buffers sets of a list of dots, with a screnspace mouseclick UI\n//any other shader can read these dot-coordinates, commonly to define kinematic spline(s).\n// buffOfDot(float(floor(x))) function returns parameters of dot[x]\n//- but THIS shader should not contain buffOfDot() \n//- , butinstead most likely just the [ImageTab] for a screenspace UI\n//and maybe later some diegetic UI like in a FlöightSim, [BattleTech], [DeathSpace] or [Astroneer] \n\n\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n//alias for an initial state:\n#define addInit(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nvoid  KlickLoop(inout vec4 state,vec4 o,vec4 m\n){float r=clickPointRadius+1.\n ;for(float i=0.;i<maxCount;++i\n ){float f=i\n  ;if(f>=state.y)break\n  ;vec4 center=texture(ChannelDragDrop ,vec2(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(vec2(2.*statePos,state.y),state.yy+vec2(0,1),step(state.y,statePos));}\n\nvoid branchi(inout vec4 fragColor, vec2 p,float statePos,vec4 state,vec2 U\n){if(p.x==statePos)fragColor=vec4(2.*statePos,state.y-1.,iMouse.z,1)\n ;else if(p.x<state.x)fragColor=texture(ChannelDragDrop, U/iResolution.xy)\n ;else fragColor=texture(ChannelDragDrop,(U+vec2(1,0))/iResolution.xy)\n ;}\n\nvoid mainImage(out vec4 fragColor,in vec2 U\n){vec2 p=U-.5\n ;if(p.y>0.||p.x>offsetPos){fragColor=vec4(0);return;}\n ;if (iFrame==0\n ){float count=0.//init\n  ;addInit(.2*iResolution.x,.2*iResolution.y)//3 dots exist from frame0:\n  ;addInit(.2*iResolution.x,.8*iResolution.y)\n  ;addInit(.8*iResolution.x,.8*iResolution.y)\n  ;addInit(.5*iResolution.x,.7*iResolution.y)\n  ;addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(p.x==statePos)fragColor=vec4(2.*statePos,count,0.,0.);return;}\n ;vec4 state=texture(ChannelDragDrop,vec2(.5+statePos,.5)/iResolution.xy)\n ;vec4 o=texture(ChannelDragDrop,vec2(.5+offsetPos,.5)/iResolution.xy)\n ;     if(max(state.z,-iMouse.z)<0.)KlickLoop(state,o,iMouse)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect)\n ){branchi(fragColor,p,statePos,state,U);return\n ;}if(p.x==statePos)fragColor=vec4(state.xy,iMouse.z,state.w)\n ;else if(p.x==offsetPos)fragColor=o\n ;else if(p.x==state.x&&iMouse.z>0.)fragColor=iMouse+o\n ;else fragColor=texture(ChannelDragDrop,U/iResolution.xy)\n ;}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define ChannelDragDrop iChannel0\n#define bufDrag(x) texture(ChannelDragDrop,(vec2(x, 0.)+.5)/iResolution.xy)\n\n\nconst float maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst float UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst float statePos = maxCount;\nconst float offsetPos = maxCount + 1.;\nconst vec4 deleteRect=vec4(0.,0.,40.,40.);\n\nfloat mi(vec4 a){return min(min(a.x,a.y),min(a.z,a.w));}\n//original was halfOpen ]interval], while this is [closed]\nbool inRect(vec2 pos, vec4 rect\n){rect.xyzw-=pos.xyxy\n ;return min(rect.z-rect.x,rect.y-rect.w)<mi(rect) ;}\n\nvoid rToD(float d,inout float r,inout vec4 state,inout float f,inout vec4 o,vec4 center,vec4 m\n){if(d<r\n ){r=d\n  ;state.x=f\n  ;o=center-m;}}\n\n//#define viewZoom(t,r) (hl2(r)/floor(mix(1.,hl2(r)*.1,u5(-cos(t)))))\n//viewZoom() returns a float; is defined in a local channel context, to quickly modify its scaling\n//divide by/aa for hairline drawing and sharp smoothstep()\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n#define dd(a) dot(a,a)\n#define vec1 float\n#define norma normalize\n\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau pi*2.\n//float tau=6.2831853071795864769252867665590057683943387987502116419;//trig definition can be better for smarter compilers.\n#define eul 2.7182818284590452353602874713526624977572470936999595749\n//eul=exp(1.)???\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n\n\n//\"goldenRatio\"=phi+1=Phi :where: 1/phi=phi-1&&1/Phi=Phi-1\n//https://en.wikipedia.org/wiki/Golden_ratio\n#define phi (sqrt(5.)*.5-.5)\n//goldenRatio is great fun with fract(),good for hashes.\n#define Phi (sqrt(5.)*.5+.5)\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u2(a)((a)*2.-1.)\n#define u5(a)((a)*.5+.5)\n#define cosu5(a) u5(cos(a))\n\nvec1 suv(vec4 a){return dot(vec4(1),a);}vec1 suv(vec3 a){return dot(vec3(1),a);}vec1 suv(vec2 a){return a.x+a.y;}//sum of vector\n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\n\n#define segment2(a,c) dd((a-(c*sat((dot(a,c)/dd(c))))))\n//sqared orthogonal projection ,segment()subroutine ,is squared distance\n#define segments(a,b,c) (segment2((a-b),(c-b)))\n//offset segment2(a,c) by -b\n#define segment(a,b,c) sqrt(segments(a,b,c))\n//pointAdistance to (diagonal) lineSegment from B to C\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbowt(float a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(vec3(1.),sat(a(-c.x)),c.y);}\nvec3 angleToColor(vec3 c){ToRgb(rainbow)//cos-mix\n//vec3 hsv2rgb(vec3 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nvec3 hsv2rgb(const vec3 c){return c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y);}\nvec3 rgb2hsv(vec3 a){vec4 K=vec4(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;vec4 P=mix(vec4(a.bg,K.wz),vec4(a.gb,K.xy),step(a.b,a.g));vec4 Q=mix(vec4(P.xyw,a.r),vec4(a.r,P.yzx),step(P.x,a.r))\n ;float D=Q.x-min(Q.w,Q.y),E=1e-10;return vec3(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//v41 ut(v41 a,vec1 b){return mu(a,(1.-b));}\nvec3 ut(vec3 a,vec1 b){return a*(1.-b);}//v31 ut(v31 a,vec1 b){return mu(a,(1.-b));}\nvec2 ut(vec2 a,vec1 b){return a*(1.-b);}//v21 ut(v21 a,vec1 b){return mu(a,(1.-b));}\nvec1 ut(vec1 a,vec1 b){return a*(1.-b);}//v11 ut(v11 a,vec1 b){return mu(a,(1.-b));}//#define ut(a,b) (a*(1.-b))\n#define Over 0.\n#define Atop 1.\n#define Out 2.\n#define Xor 3.\n#define In 4.\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\nvec4 pdIn(vec4 a,vec4 b){return a*b.w;}//pdIn() is just multiplication,note swapped AB case here",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\nfloat viewZoom(vec1 t,vec2 u,vec3 r,vec4 m){return 1.;}\n\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n#define vec1 float\n#define dd(a) dot(a,a)\n//#define sat(a) clamp(a,0.,1.)\n\nfloat add(vec2 a){return a.x+a.y;}\n\nbool rea(float s,float b,float e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n//get 2/3 roots,Cardano: http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),vec2(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((vec2(1,-1)*sqrt(d)-q)*.5) )\nvec2 solveCubic2b(vec1 a,vec1 b,vec1 c//https://www.shadertoy.com/view/XtdyDn\n){vec2 p=vec2(b-a*a/3.,a)\n ;vec1 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(vec2(a),b,c)//both return values are identical\n ;float v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return vec2(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nvec2 solveCubic2b(vec3 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nvec2 dQBezierSub(inout vec2 u,inout vec2 a,inout vec2 b,vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+vec2(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(vec3(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b))\n ;}\n\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(vec2 a,vec2 b,vec2 c){return length(normalize(a-b)-normalize(a-c))<.001;}\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nfloat BezierQuadParabola(vec2 u,vec2 a,vec2 b,vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nfloat BezierQuad(vec2 u, vec2 a, vec2 b, vec2 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nfloat BezierQuadGeneral(vec2 u, vec2 a, vec2 b, vec2 c,vec2 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a) )\n\nvec1 ss(vec1 a,float b){return smoothstep(b,-b,a);}\nvec2 ss(vec2 a,float b){return smoothstep(b,-b,a);}\nvec3 ss(vec3 a,float b){return smoothstep(b,-b,a);}\nvec4 ss(vec4 a,float b){return smoothstep(b,-b,a);}\n\n#define viewzoom 2.\n//#define Aa min(iResolution.x,iResolution.y)\n\nvec2 sort(vec2 a){return vec2(min(a.x,a.y),max(a.x,a.y));}\n\nvec4 demoBezierQuad(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;if(m.z<=0.)m.xy=vec2(cos(t),sin(t*1.61))\n ;vec4 o=vec4(0,0,0,1)\n ;vec2 p0=vec2(-cos(t*.5),sin(t*0.9))*.4\n ,p1=vec2(-cos(t*2.3),sin(t*1.1))\n ,p2=vec2(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y\n \n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*2.//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*2.//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*2.\n ;}\n  \n //if (4 points exist) 4th points .y overwrites m.y\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;vec2 p3=fra(t,bufDrag(3.).xy,r,m)*2.\n  ;m.x=mix(.5,1.,p3.y*.5+.5)     \n  ;c.w=segment(u,p3,mix(p0,p2,p3.y*.5+.5))//c.w for a yellow line for an  associative connection\n ;} \n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){vec2 p4=fra(t,bufDrag(4.).xy,r,m)*2.;m.y=mix(.5,1.,p4.y*.5+.5)\n  ;c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y*.5+.5)))//c.w for a yellow line for an  associative connection\n ;}\n  \n ;c.x=segment(u,p0,p1)\n ;c.x=min(c.x,segment(u,p1,p2))\n ;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs\n     \n ;c.y=BezierQuadParabola(u,p0,p1,p2)           //green shows parabola\n ;m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n     \n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=20./Aa(t,u,r,m) //line thickness\n ;c.x -= 2./Aa(t,u,r,m) \n ;c.wy-= 4./Aa(t,u,r,m)\n ;c.xyzw=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c.xy+=c.w*.2//.w folds to a dimmed yellow\n ;o.xyz+=c.xyz\n     \n ;return o;}\n\n//project point [a] onto line trough vecN(0) and vecN([b])\nvec2 project(vec2 a,vec2 b){return b*dot(a,b)/dd(b);}\nvec2 projectS(vec2 a,vec2 b){return b*sat(dot(a,b)/dd(b));}\n//vec3 project(vec3 a,vec3 b){return a*dot(a,b)/dd(b);}\n//vec4 project(vec4 a,vec4 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//vec2 dLine(vec2 a,vec2 b){return a*dot(a,b)/dd(b);}\n\nvec4 demoProject(float t,vec2 u,vec3 r,vec4 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;vec4 c=vec4(1)\n ;vec2 l0=vec2(-.4)\n ;vec2 l1=vec2( .7)\n ;vec2 p0=vec2(.5,-.5)\n ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y\n \n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;}\n ;//l0=vec2(0)\n ;float d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;vec2 p10=projectS(p0-l0,l1-l0)+l0//projected point on line\n ;c.x=length(u-p10)//red projected point\n ;vec2 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d     \n ;c.z-=.1  \n ;c.x-=.05\n ;c.x=min(c.x,segment(u,p0,p10))-.01\n ;c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;return c\n ;}\n\n\n#define tiny .00001\n\nvec2 gLLxX(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nvec2 gLLxX0(vec2 A,vec2 B,vec2 C,vec2 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){vec2 b=B-A,d=D-C,c=C-A\n ;float dotperp=b.x*d.y-b.y*d.x\n ;//if (dotperp==0.)return A\n ;//dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;float t=(c.x*d.y-c.y*d.x)/dotperp\n ;return vec2(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(vec2 rs,vec2 r2,vec2 ls,vec2 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;vec2 ll=le-ls\n ;float c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nvec2 InterWall(vec2 rs,vec2 r2,vec2 ls,vec2 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;vec2 j=(ls+le)*.5//midpoint\n ;vec2 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nvec4 demoLineIntersection(float t,vec2 u,vec3 r,vec4 m\n){vec4 c=vec4(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;vec2 l0=vec2(-.4)\n ;vec2 l1=vec2( .7)\n ;vec2 r0=vec2(.5,-.5)\n ;vec2 r1=vec2(.5,-.1)\n ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c.w=abs(c.w-.1)-.03\n ;c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c.xy+=c.w*.2//fold w as yellow\n ;return c\n ;}\n\n//return p1 of quadratic bezier, when given start, end and arclength\nvec2 knee(vec2 p0,vec2 p2,float L//https://www.shadertoy.com/view/4ltyWr\n){vec2 l = p2-p0\n ;float h = sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)\n ;return (p0+p2)/2.+sqrt(max(0.,L*L-dot(l,l)))/2. *sign(L)*normalize( vec2(-l.y,l.x) )     \n    ;}\n\nvec4 demoIkBezier(float t,vec2 u,vec3 r,vec4 m//define bezier by start,eng,Arclength\n){vec4 c=vec4(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;vec2 p0=vec2(-.4)\n ;vec2 l0=vec2( .7)\n ;vec2 l1=vec2(.5,-.5)\n ;//vec2 r1=vec2(.5,-.1)\n ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;float d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;vec2 p11=knee(l0,l1,d)//red dot is knee \n ;vec2 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c.xy+=c.w*.2//fold w as yellow\n ;return c\n ;}\n\n\nvoid mainImage(out vec4 o, vec2 u\n){//o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;float pointCount=texture(ChannelDragDrop,(vec2(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=demoBezierQuad   (iTime,u,iResolution,iMouse)\n ;else if(pointCount< 9.)o=demoProject      (iTime,u,iResolution,iMouse) \n ;else                   o=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;o=sat(o)\n ;}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n/**/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//this buffer was just a rainbow-backdrop to gix alpha compositing of [imageTab]\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\nfloat viewZoom(vec1 t,vec2 u,vec3 r,vec4 m){return 1.;}\n/*\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac vec2 h){h=fract(h)\n#define gthv greaterThan(h,vec2\n#define floatbool2);return float(b.x==b.y);}\nfloat checkerBool(hfrac;return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nfloat checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n\n/*\n*/\n       \n/*\n\nvec4 mainEntry(vec1 t,vec2 u,vec3 r,vec4 m\n){\n ;u   =fra(t,u   ,r,m)\n ;m.xy=fra(t,m.xy,r,m)\n ;m.zw=fra(t,m.zw,r,m)\n ;vec4 c=vec4(0)\n ;float p=0.\n ;p=sat(checkerBoolT(u*4.*viewZoom(t,u,r,m)))\n ;//p=p*.5+.25\n ;//c=vec4(rainbowt(u.x),1.)\n ;c=vec4(p)\n ;c=sat(c)\n ;return c\n ;}\n                   \nvoid mainImage(out vec4 o,vec2 u\n){\n ;o=mainEntry(iTime,u,iResolution,iMouse)\n ;//o=vec4(1)\n;}\n                   \n                   /**/\n\n\n\n\n//https://www.shadertoy.com/view/ltj3Wc\n//brush stroke experiments\n\n// todo: implement sweep amt\nvec2 mouse;\n\nconst float pi2 = pi*2.;\n\n// from \"Magic Fractal\" by dgreensp , usefull for fungus/splatters, best multiplied with a metaball.\n// https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p\n){const int MAGIC_BOX_ITERS = 13\n ;const float MAGIC_BOX_MAGIC = 0.55\n ; // The fractal lives in a 1x1x1 box with mirrors on all sides.\n ;// Take p anywhere in space and calculate the corresponding position\n ;// inside the box, 0<(x,y,z)<1\n ;p = 1.0 - abs(1.0 - mod(p, 2.0))\n ;float lastLength = length(p)\n ;float tot = 0.0\n ;// This is the fractal.  More iterations gives a more detailed\n ;// fractal at the expense of more computation.\n ;for (int i=0; i < MAGIC_BOX_ITERS; i++\n ){// The number subtracted here is a \"magic\" paremeter that\n  ;// produces rather different fractals for different values.\n  ;p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC\n  ;float newLength = length(p)\n  ;tot += abs(newLength-lastLength)\n  ;lastLength = newLength\n ;}\n ;return tot;}\n\n//random 3x3 unitary matrix, used to avoid artifacts from slicing the\n//volume along the same axes as the fractal's bounding box.\nfloat magicBox(vec2 u\n){const mat3 M = mat3(.28862355854826727,.6997227302779844 , .6535170557707412\n                    , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                    ,-.9548821651308448 ,.26025457467376617, .14306504491456504)\n ;return magicBox(.0*M*vec3(u,.0));}\n\n\n\n\nmat2 rot2D(float r){float c = cos(r), s = sin(r);return mat2(c, s, -s, c);}\n\n\n\n\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand(float n){return fract(cos(n*89.42)*343.42);}\n\nfloat dtoa(float d,float amount){return sat(1./(clamp(d,1./amount,1.)*amount));}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br//rounded rectangle\n){vec2 d = max(tl-uv, uv-br)\n ;return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));}\n\n// 0-1 1-0\nfloat smoothstep4(float e1, float e2, float e3, float e4, float val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n// hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nvec2 hash(vec2 p \n){p=vec2(dot(p,vec2(127.1,311.7))\n        ,dot(p,vec2(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}\n// returns -.5 to 1.5. i think.\nfloat noise(in vec2 p\n){const float K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const float K2 = 0.211324865 // (3-sqrt(3))/6;\n ;vec2 i = floor( p + (p.x+p.y)*K1)\n ;vec2 a = p - i + (i.x+i.y)*K2\n ;vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0) //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n ;vec2 b = a - o + K2\n ;vec2 c = a - 1.0 + 2.0*K2\n ;vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, vec3(70.0));}\nfloat noise01(vec2 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\n// debug function to convert distance to color, revealing sign.\nvec3 dtocolor(vec3 inpColor, float dist\n){vec3 ret\n ;if(dist>0.)ret=mix(vec3(0, 0,.5),vec3(.5,.5,1),sin(dist*pi *100.))// red = negative / inside geometry.\n ;else       ret=mix(vec3(1,.5,.5),vec3(.5, 0,0),sin(dist*pi *100.))// blue = positive, of of geometry.\n ;ret = mix(ret,vec3(0),clamp(abs(dist),0.,1.))// falloff\n ;return ret;}\n\nfloat smoothf(float x){return x*x*x*(x*(x*6. - 15.) + 10.);}\n\n////////////////////////////////////////////////////////////////\n// APP CODE ...................\n\n// this function will produce a line with brush strokes. the inputs are such\n// that you can apply it to pretty much any line; the geometry is separated from this function.\nvec3 colorBrushStroke(vec2 uvLine, vec2 uvPaper, vec2 lineSize, float sdGeometry, vec3 inpColor, vec4 brushColor\n){float posInLineY=(uvLine.y/lineSize.y)// position along the line. in the line is 0-1.\n ;if(iMouse.z>0.\n ){\n//    return mix(inpColor, vec3(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.y), dtoa(sdGeometry, 1000.));// reveal Y\n//    return mix(inpColor, dtocolor(inpColor, posInLineY), dtoa(sdGeometry, 1000.));// reveal pos in line.\n//    return mix(inpColor, dtocolor(inpColor, uvLine.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n  ;if(posInLineY>0.   // warp position-in-line, to control the curve of the brush falloff.\n  ){float mouseX = iMouse.x == 0. ? 0.2 : (iMouse.x / iResolution.x)\n   ;posInLineY = pow(posInLineY, (pow(mouseX,2.) * 15.) + 1.5)\n  ;}\n  // brush stroke fibers effect.\n ;float strokeBoundary=dtoa(sdGeometry, 300.)// keep stroke texture inside geometry.\n ;float strokeTexture=0.\n +noise01(uvLine*vec2(min(iResolution.y,iResolution.x)*.2, 1.))//tiny\n +noise01(uvLine*vec2(79,1))//fine\n +noise01(uvLine*vec2(14,1))//coarse\n ;strokeTexture*=strokeBoundary/3.\n ;strokeTexture=max(.08,strokeTexture)//null-evasion\n ;//fade along y\n ;float strokeAlpha = pow(strokeTexture, max(0.,posInLineY)+.09)// add allows bleeding\n ;const float strokeAlphaBoost=1.09\n ;if(posInLineY>0.)strokeAlpha = strokeAlphaBoost * max(0., strokeAlpha - pow(posInLineY,0.5))// fade out the end\n ;else strokeAlpha*=strokeAlphaBoost\n ;strokeAlpha = smoothf(strokeAlpha)\n ;float paperBleedAmt =60.+(rand(uvPaper.y)*30.) + (rand(uvPaper.x) * 30.)\n ;//paperBleedAmt = 500.// disable paper bleed    \n ;strokeAlpha+=.4*smoothstep(17.,18.5,magicBox(vec3(uvPaper,uvLine.x)))\n ;float alpha=strokeAlpha * brushColor.a*dtoa(sdGeometry, paperBleedAmt)\n ;alpha=sat(alpha)\n ;return mix(inpColor, brushColor.rgb, alpha);}\n\nvec3 colorBrushStrokeLine(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 p1_, vec2 p2_, float lineWidth\n){float lineAngle = pi-atan(p1_.x - p2_.x, p1_.y - p2_.y)//axis-align\n ;mat2 rotMat = rot2D(lineAngle)\n ;float lineLength = distance(p2_, p1_)    // make an axis-aligned line from this line.\n ;vec2 tl = (p1_ * rotMat)// top left\n ;vec2 br = tl + vec2(0,lineLength)// bottom right\n ;vec2 uvLine = uv * rotMat\n ;uvLine.x+=(noise01(uvLine*1.)-.5)*.02\n ;uvLine.x+=cos(uvLine.y*3.)*.009// smooth lp wave\n ;uvLine.x+=(noise01(uvLine*5.)-.5)*.005;// a sort of random waviness like individual strands are moving around\n ;uvLine.x+=(noise01(uvLine*min(iResolution.y,iResolution.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;float d = sdAxisAlignedRect(uvLine, tl, br)-lineWidth/2.\n ;uvLine=tl-uvLine\n ;vec2 lineSize = vec2(lineWidth, lineLength)\n ;vec3 ret = colorBrushStroke(vec2(uvLine.x, -uvLine.y), uv, lineSize,d, inpColor, brushColor)\n ;return ret;}\n\n// returns: xy=uvLine, z = radius\nvec3 humanizeBrushStrokeDonut(vec2 uvLine, float radius_, bool clockwise, float lineLength\n){vec2 humanizedUVLine = uvLine\n ;float twistAmt=.24//offset circle along its path for a twisting effect.\n ;float linePosY = humanizedUVLine.y / lineLength// 0 to 1 scale\n ;humanizedUVLine.x += linePosY * twistAmt\n ;float humanizedRadius = radius_ // perturb radius / x\n ;float res = min(iResolution.y,iResolution.x)\n ;humanizedRadius += (noise01(uvLine * 1.)-0.5) * 0.04\n ;humanizedRadius += sin(uvLine.y * 3.) * 0.019// smooth lp wave\n ;humanizedUVLine.x += sin(uvLine.x * 30.) * 0.02// more messin\n ;humanizedUVLine.x += (noise01(uvLine * 5.)-0.5) * 0.005// a sort of random waviness like individual strands are moving around\n ;//humanizedUVLine.x += (noise01(uvLine * res * 0.18)-0.5) * 0.0035;// HP random noise makes it look less scientific\n ; return vec3(humanizedUVLine, humanizedRadius);}\n\n// there's something about calling an Enso a \"donut\" that makes me giggle.\n// TODO: sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. 1=whole circle. 0=just a point.\nvec3 colorBrushStrokeDonut(vec2 uv, vec3 inpColor, vec4 brushColor, vec2 o, float radius_, float angleStart, float sweepAmt, float lineWidth\n){vec2 uvLine = uv - o\n ;float angle = atan(uvLine.x, uvLine.y) + pi// 0-2pi\n ;angle = mod(angle-angleStart+pi, pi2)\n ;float lineLength = radius_ * pi2// this is calculated before any humanizing/perturbance. so it's possible that it's slightly inaccurate, but in ways that will never matter\n ;uvLine = vec2(radius_-length(uvLine),angle / pi2 * lineLength)\n ;float lineWidth1 = lineWidth * mix(1., .9, smoothstep(0.,lineLength,uvLine.y))//narrower end\n ;vec3 hu = humanizeBrushStrokeDonut(uvLine, radius_, false, lineLength)\n ;vec2 humanizedUVLine = hu.xy\n ;float humanizedRadius = hu.z\n ;float d = max(-length(uv-o)+humanizedRadius,length(uv-o)-humanizedRadius)\n ;d-=lineWidth1*.5// round off things just like in the line routine.\n ;vec3 ret=colorBrushStroke(humanizedUVLine, uv, vec2(lineWidth1, lineLength), d, inpColor, brushColor)\n ;vec3 ret2 = vec3(1)//same,but for line start. distance field is just a single point\n ;if(angle > pi\n ){uvLine.y -= lineLength\n  ;hu = humanizeBrushStrokeDonut(uvLine, radius_, false, lineLength)\n  ;humanizedUVLine = hu.xy\n  ;humanizedRadius = hu.z\n  ;vec2 strokeStartPos = o + vec2(sin(angleStart), cos(angleStart)) * humanizedRadius\n  ;d=length(uv-strokeStartPos)\n  -lineWidth*.5*1.// round off things just like in the line routine.\n  ;ret2= colorBrushStroke(humanizedUVLine,uv,vec2(lineWidth,lineLength),d,inpColor,brushColor)\n ;}return min(ret,ret2);}\n\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize\n){vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y)/iResolution.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;float aspect = iResolution.x / iResolution.y\n ;ret.x *= aspect// orig aspect ratio\n ;float newWidth = newSize.x * aspect\n ;return ret + vec2(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\n\n\nvec4 mainEntry(vec2 u\n){\n ;//return vec4(.01*magicBox(vec3(u/iResolution.xy,iMouse.x)))//debug\n ;vec2 uvSignature=(u / iResolution.y * 2.0) - 1.\n ;mouse = getuv_centerX(iMouse.xy, vec2(-1,-1), vec2(2,2))// (iMouse.xy / iResolution.y * 2.0) - 1.;\n ;vec2 uv = getuv_centerX(u, vec2(-1,-1), vec2(2,2))// 0-1 centered\n ;vec3 col = vec3(1.,1.,0.875)// bg\n ;float dist\n ;// geometry on display...\n ;float yo = sin(-uv.x*pi*0.5)*0.2\n ;col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),.9),// red line\n                           vec2(-1.4, -.4+yo),\n                           vec2(2.6, -.4+yo), 0.3)\n ;col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.4),// red line\n                           vec2(1.3, 0.+yo),\n                           vec2(-2.9, 0.+yo), 0.03)\n ;col = colorBrushStrokeLine(uv, col, vec4(vec3(.8,.1,0),0.52),// red line\n                           vec2(1.3, .3+yo + (cos(uv.x * 12.) * 0.025)),\n                           vec2(-2.9, .3+yo), 0.1)\n ;col = colorBrushStrokeDonut(uv*vec2(1,1), col, vec4(0,0,0,.9)\n                            ,vec2(0,0),// origin\n                                .6,// radius\n                                .2,// angle of brush start\n                                .5,// sweep amt 0-1\n                                .3)// width\n ;// paint blotches\n ;float blotchAmt = smoothstep(20.,50.,magicBox((uv+12.)*2.))// smoothstep(40.,40.5, magicBox((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;col *= 1.-blotchAmt\n ;// signature/stamp\n ;dist = sdAxisAlignedRect(uvSignature, vec2(-0.68), vec2(-0.55))\n ;float amt = 90. + (rand(uvSignature.y) * 100.) + (rand(uvSignature.x / 4.) * 90.)\n ;float vary = sin(uvSignature.x*uvSignature.y*50.)*0.0047\n ;dist = max(-(dist-0.028+vary), dist-0.019-vary)// round edges, and hollow it out\n ;col=mix(col, vec3(.8,.1,.0),dtoa(dist,amt   )*.3)\n ;col=mix(col, vec3(.8,.1,.0),dtoa(dist,amt*4.)*.9)\n ;col.rgb+=(rand(uv)-.5)*.08// grain\n ;col.rgb=sat(col.rgb)//clamp\n ;vec2 uvScreen=(u /iResolution.xy * 2.)-1.\n ;//col*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return vec4(col,1);}\n\nvoid mainImage( out vec4 o, in vec2 u ){o=mainEntry(u);}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}