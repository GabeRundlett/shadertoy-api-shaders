{
    "Shader": {
        "info": {
            "date": "1533932738",
            "description": "Controls:\nR - Use Reduced Resolution Rendering (a little faster)\nSpace - flymode.\nWhen in flymode:\nWASD - move\nmouse - rotate\nshift - move faster \nF - toggle look at camera\nG - toggle head turning\n",
            "flags": 112,
            "hasliked": 0,
            "id": "4lcyD8",
            "likes": 68,
            "name": "[SH18] Visage",
            "published": 3,
            "tags": [
                "eye",
                "face",
                "skin",
                "human"
            ],
            "usePreview": 1,
            "username": "P_Malin",
            "viewed": 4961
        },
        "renderpass": [
            {
                "code": "//    ___ _____ _    _ __  ___ ___  __      ___                      \n//   |  _/ ____| |  | /_ |/ _ \\_  | \\ \\    / (_)                     \n//   | || (___ | |__| || | (_) || |  \\ \\  / / _ ___  __ _  __ _  ___ \n//   | | \\___ \\|  __  || |> _ < | |   \\ \\/ / | / __|/ _` |/ _` |/ _ \\\n//   | | ____) | |  | || | (_) || |    \\  /  | \\__ \\ (_| | (_| |  __/\n//   | ||_____/|_|  |_||_|\\___/_| |     \\/   |_|___/\\__,_|\\__, |\\___|\n//   |___|                    |___|                        __/ |     \n//                                                        |___/                                                                                                          \n// https://www.shadertoy.com/view/4lcyD8\n// [SH18] Visage - by @P_Malin\n\n// Entry for the 2018 Shadertoy Competition \n// https://www.shadertoy.com/events/competition2018\n// Theme \"Human\"\n\n// Video Here: https://youtu.be/tuKlyJv2JEI\n\n// Most of the interesting bits like scene rendering and materials are in Buffer A.\n\n// Audio: https://soundcloud.com/silas-neptune/aqualight\n// ASCII Comments: http://patorjk.com/software/taag/#p=display&h=2&c=c%2B%2B&f=Big&t=My%20Comment\n\n// Controls:\n// R - Use Reduced Resolution Rendering (a little faster)\n// Space - flymode.\n// When in flymode:\n// WASD - move\n// mouse - rotate\n// shift - move faster \n// F - toggle look at camera\n// G - toggle head turning\n\n//    _____                               _____                                _ _   _             \n//   |_   _|                             / ____|                              (_) | (_)            \n//     | |  _ __ ___   __ _  __ _  ___  | |     ___  _ __ ___  _ __   ___  ___ _| |_ _  ___  _ __  \n//     | | | '_ ` _ \\ / _` |/ _` |/ _ \\ | |    / _ \\| '_ ` _ \\| '_ \\ / _ \\/ __| | __| |/ _ \\| '_ \\ \n//    _| |_| | | | | | (_| | (_| |  __/ | |___| (_) | | | | | | |_) | (_) \\__ \\ | |_| | (_) | | | |\n//   |_____|_| |_| |_|\\__,_|\\__, |\\___|  \\_____\\___/|_| |_| |_| .__/ \\___/|___/_|\\__|_|\\___/|_| |_|\n//                           __/ |                            | |                                  \n//                          |___/                             |_|                                  \n\n\n#define iChannelSceneImage \tiChannel0\n#define iChannelBloom \t\tiChannel1\n\n#define SHOW_CAMERA_COORDS 0\n\n\n///////////////////////////////////////////////\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\n\nvec3 ApplyGrain( vec2 vUV, vec3 col, float amount )\n{\n    float h = hash13( vec3(vUV, iTime) );\n    \n    col *= (h * 2.0 - 1.0) * amount + (1.0f -amount);\n    \n    return col;\n}\n\n\nfloat GetVignetting( const in vec2 vUV, float fScale, float fPower, float fStrength )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0) * fScale;\n\t\n\tfloat fDist = max( 0.0, 1.0 - length( vOffset ) );\n    \n\tfloat fShade = 1.0 - pow( fDist, fPower );\n    \n    fShade = 1.0 - fShade * fStrength;\n\n\treturn fShade;\n}\n\nvec3 ColorGrade( vec3 vColor )\n{\n    vec3 vHue = vec3(1.0, .7, .2);\n    \n    vec3 vGamma = 1.0 + vHue * 0.6;\n    vec3 vGain = vec3(.9) + vHue * vHue * 8.0;\n    \n    vColor *= 1.5;\n    \n    float fMaxLum = 100.0;\n    vColor /= fMaxLum;\n    vColor = pow( vColor, vGamma );\n    vColor *= vGain;\n    vColor *= fMaxLum;  \n    return vColor;\n}\n\nvec4 SampleBloom( vec2 vUV )\n{\n    vec2 vBloomSize = iResolution.xy / 4.0;//min( vec2(320.0, 240.0), iResolution.xy );\n    \n    vec2 vBloomCoord = vUV * vBloomSize;\n    vBloomCoord.y += 1.0; // bottom row of bloom is used for data\n    \n\tvec4 vBloomSample = textureLod( iChannelBloom, vBloomCoord / iResolution.xy, 0.0 ).rgba;\n    \n    return vBloomSample;\n}\n\nvec3 SampleImage( vec2 vUV, int image )\n{\n    if ( image >= 0 )\n    {\n        vUV.x *= 0.5;\n    }\n    \n    if (image > 0 )\n    {\n        vUV.x += 0.5;\n    }\n    \n\tvec4 vImageSample = textureLod( iChannelSceneImage, vUV, 0.0 ).rgba;\n\n    vec4 vBloomSample = SampleBloom( vUV );    \n    const float fBloomAmount = 0.1;  \n    return mix( vImageSample.rgb, vBloomSample.rgb, fBloomAmount );    \n    \n    //return vImageSample.rgb;\n}\n\nvec2 DistortUV( vec2 vUV, float f )\n{\n    vUV -= 0.5;\n\n    float fScale = 0.0075;\n    \n    float r1 = 1. + f * fScale;\n    \n    vec3 v = vec3(vUV, sqrt( r1 * r1 - dot(vUV, vUV) ) );\n    \n    v = normalize(v);\n    vUV = v.xy;\n    \n    \n    vUV += 0.5;\n    \n    return vUV;\n}\n\nvec3 SampleImage2( vec2 vUV, vec2 vScreen, int image )\n{\n    //return SampleImage( vUV, image );\n    \n    vec3 a = SampleImage( DistortUV( vUV, 1.0 ), image );\n    vec3 b = SampleImage( DistortUV( vUV, 0.0 ), image );\n    vec3 c = SampleImage( DistortUV( vUV, -1.0 ), image );\n    \n    vec3 vResult = vec3(0);\n    \n    vec3 wa = vec3(1., .5, .1);\n    vec3 wb = vec3(.5, 1., .5);\n    vec3 wc = vec3(.1, .5, 1.);\n    \n    vResult += a * wa;\n    vResult += b * wb;\n    vResult += c * wc;\n    \n    vResult /= wa + wb + wc;\n    \n    return vResult;\n}\n\n\nvoid Process( out vec4 fragColor, vec2 vUV, vec2 vScreen, int image )\n{\n    vec3 vResult = SampleImage2( vUV, vScreen, image );\n    \n    //vResult = texelFetch( iChannel0, ivec2( fragCoord.xy ), 0 ).rgb;\n    \n    float fShade = GetVignetting( vUV, 0.8, 1.0, 1.0 );\n    \n    vResult *= fShade;\n    \n\tvResult = ApplyGrain( vUV, vResult, 0.15 );      \n    \n    vec3 vFlare = vec3(0.0)\n        + SampleBloom((vScreen)).rgb * 0.1\n        + SampleBloom((vScreen - 0.5)*-0.5 + 0.5).rgb * 0.005\n        + SampleBloom((vScreen - 0.5)*-.9 + 0.5).rgb * 0.0025\n        + SampleBloom((vScreen - 0.5)*0.2 + 0.5).rgb * 0.00125\n        ;\n    \n    float flareTex = texture(iChannel2, vUV ).r;\n    flareTex = (flareTex * flareTex * 0.75 + 0.25) * 1.5;\n    //flareTex = 1.0;\n    vResult += vFlare * flareTex;\n    \n    vResult = vResult;\n    \n    //if ( vUV.x > sin(iTime)*0.5+0.5 )\n    {\n    \tvResult = ColorGrade( vResult );\n    }\n    \n    // fade in\n    vResult = vResult * min( 1.0, iTime / 10.0 );\n    \n    vResult = Tonemap( vResult );\n    fragColor.rgb = vResult;\n    fragColor.a = 1.0;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    \n    Process( fragColor, vUV, vUV, -1 );   \n        \n#if SHOW_CAMERA_COORDS  \n    CameraState cam;\n    \n    Cam_LoadState( cam, iChannel1, ivec2(0,0) );\n    \n    vec2 vFontUV = vUV * 32.0 * vec2(2.0, 1.0);\n    vFontUV -= vec2( 0.0, 1.5 * 3.0 );\n    if ( PrintValue( vFontUV, cam.vPos.x, 4.0, 4.0 ) > 0.0 )fragColor = vec4(1);vFontUV += vec2(0.0, 1.5);\n    if ( PrintValue( vFontUV, cam.vPos.y, 4.0, 4.0 ) > 0.0 )fragColor = vec4(1);vFontUV += vec2(0.0, 1.5);\n    if ( PrintValue( vFontUV, cam.vPos.z, 4.0, 4.0 ) > 0.0 )fragColor = vec4(1);vFontUV += vec2(0.0, 1.5);\n#endif     \n    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 15747,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/silas-neptune/aqualight"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//     _____                           _____                   _             \n//    / ____|                         |  __ \\                 | |            \n//   | (___    ___  ___  _ __    ___  | |__) | ___  _ __    __| |  ___  _ __ \n//    \\___ \\  / __|/ _ \\| '_ \\  / _ \\ |  _  / / _ \\| '_ \\  / _` | / _ \\| '__|\n//    ____) || (__|  __/| | | ||  __/ | | \\ \\|  __/| | | || (_| ||  __/| |   \n//   |_____/  \\___|\\___||_| |_| \\___| |_|  \\_\\\\___||_| |_| \\__,_| \\___||_|   \n//                                                                           \n//                                                                           \n\n#define RAYMARCH_ITER 48\n#define RAY_BOUNCES 2\n#define SHADOW_STEPS 28\n\n#define SCENE_SKIN 1\n#define SCENE_EYES 1\n#define SCENE_NOSE 1\n#define SCENE_HAIR 1\n#define SCENE_EARS 1\n#define SCENE_MOUTH 1\n\n#define MODEL_TOGGLES 0\n// Z,X,C - toggle model parts\n\n#define iChannelState\t\t\tiChannel0\n#define iChannelKeyboard \t\tiChannel3\n\n//    ____                      \n//   / ___|  ___ ___ _ __   ___ \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\\n//    ___) | (_|  __/ | | |  __/\n//   |____/ \\___\\___|_| |_|\\___|\n//                              \n\nstruct SceneResult\n{\n\tfloat fDist;\n\tint iObjectId;\n    vec3 vUVW;\n};\n    \n\nSceneResult Scene_GetDistance( vec3 vPos );\n\n    \nSceneResult Scene_Union( SceneResult a, SceneResult b )\n{\n    if ( b.fDist < a.fDist )\n    {\n        return b;\n    }\n    return a;\n}\n\n    \nSceneResult Scene_Subtract( SceneResult a, SceneResult b )\n{\n    if ( a.fDist < -b.fDist )\n    {\n        b.fDist = -b.fDist;\n        return b;\n    }\n    \n    return a;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat e = max(0.0, k - abs(a - b));\n\treturn min(a, b) - e*e * 0.25 / k;\n}\n\nSceneResult Scene_SmoothSubtract( SceneResult a, SceneResult b, float k )\n{    \n    float fA = a.fDist;\n    float fB = -b.fDist;        \n    \n    float fC = -smin( -fA, -fB, k );\n    \n    a.fDist = fC;\n    b.fDist = fC;\n    \n    if ( fA < (fB + k) )\n    {        \n        return b;\n    }\n    \n    return a;\n}\n\nSceneResult Scene_GetDistance( vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.0001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( e.yxx * fDelta + vPos ).fDist * e.yxx + \n        Scene_GetDistance( e.xxy * fDelta + vPos ).fDist * e.xxy + \n        Scene_GetDistance( e.xyx * fDelta + vPos ).fDist * e.xyx + \n        Scene_GetDistance( e.yyy * fDelta + vPos ).fDist * e.yyy;\n    \n    return normalize( vNormal );\n}    \n    \nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float minDist, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.iObjectId = -1;\n    \n\tfloat t = minDist;\n    \n\tfor(int i=0; i<RAYMARCH_ITER; i++)\n\t{\t\t\n        float epsilon = 0.0001 * t;\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\n        if ( abs(result.fDist) < epsilon )\n\t\t{\n\t\t\tbreak;\n\t\t}\n                        \n        if ( t > maxDist )\n        {\n            result.iObjectId = -1;\n\t        t = maxDist;\n            break;\n        }       \n        \n        if ( result.fDist > 1.0 )\n        {\n            result.iObjectId = -1;            \n        }    \n        \n        t += result.fDist; \n\t}\n    \n    result.fDist = max( t, minDist );\n\n\n    return result;\n}    \n\nfloat Scene_TraceShadow( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fMinDist, const in float fLightDist )\n{\n    // Soft Shadow Variation\n    // https://www.shadertoy.com/view/lsKcDD    \n    // based on Sebastian Aaltonen's soft shadow improvement\n    \n\tfloat res = 1.0;\n    float t = fMinDist;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = Scene_GetDistance( vRayOrigin + vRayDir*t ).fDist;\n\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>fLightDist ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );    \n}\n\nfloat Scene_GetAmbientOcclusion( const in vec3 vPos, const in vec3 vDir )\n{\n    float fOcclusion = 0.0;\n    float fScale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float fOffsetDist = 0.001 + 0.1*float(i)/4.0;\n        vec3 vAOPos = vDir * fOffsetDist + vPos;\n        float fDist = Scene_GetDistance( vAOPos ).fDist;\n        fOcclusion += (fOffsetDist - fDist) * fScale;\n        fScale *= 0.46;\n    }\n    \n    return clamp( 1.0 - 30.0*fOcclusion, 0.0, 1.0 );\n}\n\n\n//    _     _       _     _   _             \n//   | |   (_) __ _| |__ | |_(_)_ __   __ _ \n//   | |   | |/ _` | '_ \\| __| | '_ \\ / _` |\n//   | |___| | (_| | | | | |_| | | | | (_| |\n//   |_____|_|\\__, |_| |_|\\__|_|_| |_|\\__, |\n//            |___/                   |___/ \n//                                          \n\n#define ENABLE_EMISSIVE 0\n\nstruct SurfaceInfo\n{\n    vec3 vPos;\n    vec3 vNormal;\n    vec3 vDiffNormal;    \n    vec3 vSpecNormal;    \n    vec3 vAlbedo;\n    vec3 vR0;\n    float fGloss;\n    float fSkin;\n#if ENABLE_EMISSIVE    \n    vec3 vEmissive;\n#endif    \n};\n    \nSurfaceInfo Scene_GetSurfaceInfo( vec3 vRayOrigin, vec3 vRayDir, SceneResult traceResult );\n\nstruct SurfaceLighting\n{\n    vec3 vDiffuse;\n    vec3 vSpecular;\n};\n    \nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vRayDir, in SurfaceInfo surfaceInfo );\n\nfloat Light_GIV( float dotNV, float k)\n{\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nfloat AlphaSqrFromGloss( const in float gloss )\n{\n\tfloat MAX_SPEC = 10.0;\n\treturn 2.0f  / ( 2.0f + exp2( gloss * MAX_SPEC) );\n}\n\nvoid Light_Add(inout SurfaceLighting lighting, SurfaceInfo surface, vec3 vViewDir, vec3 vLightDir, vec3 vLightColour, float fShadow)\n{\n\tfloat fDiffNDotL = clamp(dot(vLightDir, surface.vDiffNormal), 0.0, 1.0);\n\tfloat fSpecNDotL = clamp(dot(vLightDir, surface.vSpecNormal), 0.0, 1.0);\n\t\n    if ( surface.fSkin > 0.0 )\n    {    \n        float fSSFactor = fDiffNDotL * fShadow;\n        fSSFactor = pow ( fSSFactor, 0.3 );\n    \tvLightColour *= mix( vec3(1,0,0), vec3(1.0), fSSFactor );\n    }\n        \n\tlighting.vDiffuse += vLightColour * fDiffNDotL * fShadow;\n    \n\tvec3 vH = normalize( -vViewDir + vLightDir );\n\tfloat fNdotV = clamp(dot(-vViewDir, surface.vSpecNormal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surface.vSpecNormal, vH), 0.0, 1.0);\n    \n\t// D\n\n\tfloat alphaSqr = AlphaSqrFromGloss( surface.fGloss );\n    float alpha = sqrt( alphaSqr );\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (PI * denom * denom);\n\n\tfloat k = alpha / 2.0;\n\tfloat vis = Light_GIV(fSpecNDotL, k) * Light_GIV(fNdotV, k);\n\n\tfloat fSpecularIntensity = d * vis * fSpecNDotL;    \n\tlighting.vSpecular += vLightColour * fSpecularIntensity * fShadow;    \n}\n\nvoid Light_AddPoint(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightPos, const vec3 vLightColour)\n{    \n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.001, length(vToLight) );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fAttenuation, fShadowFactor);\n}\n\nfloat Light_SpotFactor( vec3 vLightDir, vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle )   \n{\n    float fSpotDot = dot( vLightDir, -vSpotDir );\n    \n    float fTheta = acos(fSpotDot);\n\n    float fAngularAttenuation = clamp( (fTheta - fSpotOuterAngle) / (fSpotInnerAngle - fSpotOuterAngle), 0.0, 1.0 );\n    \n    float fShapeT = fTheta / fSpotOuterAngle;\n    fShapeT = fShapeT * fShapeT * fShapeT;\n    float fShape = (sin( (1.0 - fShapeT) * 10.0));\n    fShape = fShape * fShape * (fShapeT) + (1.0 - fShapeT);\n    \n    //return fShape;\n    return fAngularAttenuation * fShape;\n}\n    \n\nvoid Light_AddSpot( inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const vec3 vLightPos, const vec3 vSpotDir, float fSpotInnerAngle, float fSpotOuterAngle, vec3 vLightColour )\n{\n    vec3 vPos = surface.vPos;\n\tvec3 vToLight = vLightPos - vPos;\t\n    \n\tvec3 vLightDir = normalize(vToLight);\n\tfloat fDistance2 = dot(vToLight, vToLight);\n\tfloat fAttenuation = 100.0 / (fDistance2);\n\t\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.1, length(vToLight) );\n    \n    fShadowFactor *= Light_SpotFactor( vLightDir, vSpotDir, fSpotInnerAngle, fSpotOuterAngle );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fAttenuation, fShadowFactor);    \n}\n\nvoid Light_AddDirectional(inout SurfaceLighting lighting, SurfaceInfo surface, const in vec3 vViewDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\t\n\tfloat fAttenuation = 1.0;\n\tfloat fShadowFactor = Scene_TraceShadow( surface.vPos, vLightDir, 0.005, 10.0 );\n\t\n\tLight_Add( lighting, surface, vViewDir, vLightDir, vLightColour * fAttenuation, fShadowFactor);\n}\n\nvec3 Light_GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss )\n{\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvoid Env_AddPointLightFlare(inout vec3 vEmissiveGlow, const in vec3 vRayOrigin, const in vec3 vRayDir, const in float fIntersectDistance, const in vec3 vLightPos, const in vec3 vLightColour)\n{\n    vec3 vToLight = vLightPos - vRayOrigin;\n    float fPointDot = dot(vToLight, vRayDir);\n    fPointDot = clamp(fPointDot, 0.0, fIntersectDistance);\n\n    vec3 vClosestPoint = vRayOrigin + vRayDir * fPointDot;\n    float fDist = length(vClosestPoint - vLightPos);\n\tvEmissiveGlow += sqrt(vLightColour * 0.05 / (fDist * fDist));\n}\n\nvoid Env_AddDirectionalLightFlareToFog(inout vec3 vFogColour, const in vec3 vRayDir, const in vec3 vLightDir, const in vec3 vLightColour)\n{\n\tfloat fDirDot = clamp(dot(vLightDir, vRayDir) * 0.5 + 0.5, 0.0, 1.0);\n\tfloat kSpreadPower = 2.0;\n\tvFogColour += vLightColour * pow(fDirDot, kSpreadPower) * 0.25;\n}\n\n//    ____                _           _             \n//   |  _ \\ ___ _ __   __| | ___ _ __(_)_ __   __ _ \n//   | |_) / _ \\ '_ \\ / _` |/ _ \\ '__| | '_ \\ / _` |\n//   |  _ <  __/ | | | (_| |  __/ |  | | | | | (_| |\n//   |_| \\_\\___|_| |_|\\__,_|\\___|_|  |_|_| |_|\\__, |\n//                                            |___/ \n//                                                  \n\nvec3 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, float fRaySpread );\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist );\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist);\n\n\nvec4 Render_GetColorAndDepth( vec3 vRayOrigin, vec3 vRayDir )\n{\n    float fRaySpread = 1.0;\n    \n\tvec3 vResultColor = vec3(0,0,0);\n    float fResultDepth = 0.0;\n    \n    \n\tSceneResult firstTraceResult;\n    \n    float fStartDist = 0.0f;\n    float fMaxDist = 10.0f;\n    \n    vec3 vRemaining = vec3(1.0);\n    \n\tfor( int iPassIndex=0; iPassIndex < RAY_BOUNCES; iPassIndex++ )\n    {\n    \tSceneResult traceResult = Scene_Trace( vRayOrigin, vRayDir, fStartDist, fMaxDist );\n\n        if ( iPassIndex == 0 )\n        {\n            firstTraceResult = traceResult;\n        }\n        \n        vec3 vColor = vec3(0);\n        vec3 vReflectAmount = vec3(0);\n        \n\t\tif( traceResult.iObjectId < 0 )\n\t\t{\n            vColor = Env_GetSkyColor( vRayOrigin, vRayDir, fRaySpread * traceResult.fDist );\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n        }\n        else\n        {\n            \n            SurfaceInfo surfaceInfo = Scene_GetSurfaceInfo( vRayOrigin, vRayDir, traceResult );\n            SurfaceLighting surfaceLighting = Scene_GetSurfaceLighting( vRayDir, surfaceInfo );\n                \n            // calculate reflectance (Fresnel)\n\t\t\tvReflectAmount = Light_GetFresnel( -vRayDir, surfaceInfo.vSpecNormal, surfaceInfo.vR0, surfaceInfo.fGloss );\n\n            vec3 vTransmitted = surfaceInfo.vAlbedo * surfaceLighting.vDiffuse;\n#if ENABLE_EMISSIVE            \n\t\t\tvTransmitted += surfaceInfo.vEmissive;\n#endif    \n\t\t\tvColor = vTransmitted * (vec3(1.0) - vReflectAmount); \n            fRaySpread *= surfaceInfo.fGloss;\n            \n            vec3 vReflectRayOrigin = surfaceInfo.vPos;\n            vec3 vReflectRayDir = normalize( reflect( vRayDir, surfaceInfo.vSpecNormal ) );\n            fStartDist = 0.001 / max(0.0000001,abs(dot( vReflectRayDir, surfaceInfo.vNormal ))); \n\n            vColor += surfaceLighting.vSpecular * vReflectAmount;            \n\n\t\t\tvColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n\t\t\tvColor = FX_Apply( vColor, vRayOrigin, vRayDir, traceResult.fDist );\n            \n            vRayOrigin = vReflectRayOrigin;\n            vRayDir = vReflectRayDir;\n        }\n        \n        vResultColor += vColor * vRemaining;\n        vRemaining *= vReflectAmount;        \n    }\n\n    {\n        vec3 vColor = Env_GetSkyColor( vRayOrigin, vRayDir, fRaySpread );\n        vColor = Env_ApplyAtmosphere( vColor, vRayOrigin, vRayDir, 1000.0 );\n        vResultColor += vColor * vRemaining;\n    }\n    \n    return vec4( vResultColor, EncodeDepthAndObject( firstTraceResult.fDist, firstTraceResult.iObjectId ) );\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n//    ____                        ____                      _       _   _             \n//   / ___|  ___ ___ _ __   ___  |  _ \\  ___  ___  ___ _ __(_)_ __ | |_(_) ___  _ __  \n//   \\___ \\ / __/ _ \\ '_ \\ / _ \\ | | | |/ _ \\/ __|/ __| '__| | '_ \\| __| |/ _ \\| '_ \\ \n//    ___) | (_|  __/ | | |  __/ | |_| |  __/\\__ \\ (__| |  | | |_) | |_| | (_) | | | |\n//   |____/ \\___\\___|_| |_|\\___| |____/ \\___||___/\\___|_|  |_| .__/ \\__|_|\\___/|_| |_|\n//                                                           |_|                      \n//\n\n// Materials\n\nconst int \n    MAT_DEFAULT = 0,\n\tMAT_CHROME = 1,\n    MAT_EYEBALL_L = 2,\n    MAT_EYEBALL_R = 3,\n    MAT_SKIN = 4,\n    MAT_HAIR = 5;\n\n\nstruct SceneState\n{\n    mat3 mHeadRot;\n    vec3 vNeckOffset;\n    \n    vec3 lEyePos;\n    vec3 lEyeDir;\n    \n    vec3 rEyePos;\n    vec3 rEyeDir;\n};\n\nSceneState g_sceneState;\n\nvec3 InvTransformHeadPos( vec3 vPos )\n{\n    return  g_sceneState.mHeadRot * (vPos + g_sceneState.vNeckOffset) - g_sceneState.vNeckOffset;\n}\n\nvec3 InvTransformHeadDir( vec3 vPos )\n{\n    return g_sceneState.mHeadRot * vPos;\n}\n\nvec3 TransformHeadPos( vec3 vPos )\n{\n    return (vPos + g_sceneState.vNeckOffset) * g_sceneState.mHeadRot - g_sceneState.vNeckOffset;\n}\n\n\nvoid ClampEyeDir( inout vec3 vDir, float fSide )\n{\n    vDir.z = max( 0.01, vDir.z );\n    vDir /= vDir.z;\n    \n    vDir.x = clamp( vDir.x * fSide, -0.4, 0.6) * fSide;\n    vDir.y = clamp( vDir.y, -0.3, 0.3);\n    \n    vDir = normalize( vDir );\n}\n\nvoid InitSceneState( AnimState animState, vec3 vCamPos )\n{   \n    vec3 vEyeTarget = animState.vEyeTarget;\n    \n    g_sceneState.mHeadRot = MatFromAngles( animState.vHeadAngles );    \n    \n    g_sceneState.vNeckOffset = vec3( 0.0, 1.0, 1.2 );\n    \n    float ipd = 0.3f;\n    g_sceneState.lEyePos = TransformHeadPos( vec3( ipd, 0.0f, 0.0f ) );\n    g_sceneState.rEyePos = TransformHeadPos( vec3( -ipd, 0.0f, 0.0f ) );\n    \n    g_sceneState.lEyeDir = vEyeTarget - g_sceneState.lEyePos;\n    g_sceneState.rEyeDir = vEyeTarget - g_sceneState.rEyePos;\n    \n    ClampEyeDir( g_sceneState.lEyeDir, 1.0 );\n    ClampEyeDir( g_sceneState.rEyeDir, -1.0 );\n}\n\n// https://iquilezles.org/articles/distfunctions   \nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p/r ) - 1.) * min(min(r.x,r.y),r.z);\n}\n\n\n    \nconst float fEyeRadius = 0.25f * 0.5f;\nconst float fCorneaShift = 0.4 * fEyeRadius;\nconst float fCorneaSphereRadius = 0.66 * fEyeRadius;\n\nfloat SdEllipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\n\nSceneResult Scene_GetDistance( vec3 vPos )\n{\n    SceneResult result;\n    \n    result.fDist = 1000.0;\n    result.vUVW = vPos;\n    result.iObjectId = MAT_DEFAULT;\n    \n    vec3 vHeadDomain = vPos;\n    \n    //vHeadDomain *= headRot;        \n    \n#if SCENE_EYES\n    SceneResult resultEye;\n    \n    vec3 vEyePos;\n    vec3 vEyeDir;\n    \n    vec3 vEyeMid = (g_sceneState.lEyePos + g_sceneState.rEyePos) * 0.5;\n    vec3 vEyeOffset = vEyeMid - vPos;\n    vec3 vEyeDiff = g_sceneState.lEyePos - g_sceneState.rEyePos;\n    \n    float fEyeDir = 1.0;\n    \n    if( dot( vEyeDiff, vEyeOffset) < 0.0 )\n    {\n        vEyePos = g_sceneState.lEyePos;\n        vEyeDir = g_sceneState.lEyeDir;\n\t    resultEye.iObjectId = MAT_EYEBALL_L;\n        fEyeDir = 1.0;\n    }\n\telse\n    {\n        vEyePos = g_sceneState.rEyePos;\n        vEyeDir = g_sceneState.rEyeDir;        \n\t    resultEye.iObjectId = MAT_EYEBALL_R;\n        fEyeDir = -1.0;\n    }\n    \n    float fEyeCullDist = length( vPos - vEyePos ) - 0.23;\n    \n    bool testEyes = ( fEyeCullDist < 0.0 );        \n    \n    vec3 vEyeDomain;\n    float fEyeDist;\n    \n    if ( testEyes )\n    {\n\t    vEyeDomain = InvTransformHeadDir( vPos - vEyePos );\n    \n        float d1 = length( vEyeDomain ) - fEyeRadius;\n        float d2 = length( vEyeDomain - vEyeDir * fCorneaShift ) - fCorneaSphereRadius;\n\n         fEyeDist = smin( d1, d2, 0.003);\n\n        resultEye.fDist = fEyeDist;\n        resultEye.vUVW = vEyeDomain;\n\n#if MODEL_TOGGLES    \n        if( !Key_IsToggled( iChannelKeyboard, KEY_X ) )\n#endif            \n        {\n            result = Scene_Union(result, resultEye);\n        }\n    }\n#endif    \n    \n#if SCENE_SKIN    \n    \n    SceneResult resultSkin;\n    \n    vec3 vFaceDomainPos = InvTransformHeadPos( vHeadDomain );\n\n    \n#if 1\n    //float fSmile = sin( iTime ) * 0.5 + 0.5;\n    float fSmile = 1.0;\n    \n    float fSmileRad = 0.26;\n    float fSmileSide = 1.0;\n    vec3 vSmileDomain = vFaceDomainPos;\n    if ( vSmileDomain.x < 0.0 )\n    {\n        vSmileDomain.x = -vSmileDomain.x;\n        fSmileSide = -1.0;\n    }\n    float fSmileDist = (fSmileRad - length( vSmileDomain - vec3(0.25, -0.48, 0.1) ));\n\n    {\n        SceneResult resultTemp;\n        resultTemp.fDist = -fSmileDist;\n        resultTemp.iObjectId = MAT_DEFAULT;\n        resultTemp.vUVW = vPos;\n        //result = Scene_Union(result, resultTemp);  \n    }     \n    \n    vec3 vSmileDir = vec3( fSmileSide * -1.0, -0.6, 0.3 );\n    \n    fSmileDist = max( 0.0, fSmileDist / fSmileRad );\n    vFaceDomainPos += fSmileDist * fSmileDist * 0.1 * fSmile * vSmileDir;\n#endif     \n          \n    \n    vec3 vFaceDomain = vFaceDomainPos;\n    vFaceDomain.x = abs( vFaceDomain.x );\n    vHeadDomain.x = abs( vHeadDomain.x );\n    \n    float fForeheadDist = SdEllipsoid( vFaceDomain - vec3(0.0, 0.24, -0.56 ) * 1.2, vec3(0.6f, 0.75f, 0.75f) * 1.2 );\n    float fBrowDist = SdEllipsoid( vFaceDomain - vec3(0.3, 0.0, -0.2 ) * 1.2, vec3( 0.2f, 0.4f, 0.3f) * 1.2 );\n    float fSkullBackDist = SdEllipsoid( vFaceDomain - vec3(0.0, 0.25, -0.75 ) * 1.2, vec3(0.65f, 0.75f, 0.8f) * 1.2 );\n    float fSkullBaseDist = SdEllipsoid( vFaceDomain - vec3(0.02, -0.2, -0.9 ) * 1.2, vec3(0.425f, 0.8f, 0.5f) * 1.2 );\n    float fMouthExtrudeDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.475, -0.1 ) * 1.2, vec3(0.2f, 0.2f, 0.3f) * 1.2 );\n    \n    float fFaceDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.3, -0.4 ) * 1.2, vec3(0.46f, 0.6f, 0.6f) * 1.2 );\n    float fCheekDist = SdEllipsoid( vFaceDomain - vec3(0.25, -0.2, -0.2 ) * 1.2, vec3( 0.2f, 0.4f, 0.3f) * 1.2 );\n    float fChinDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.65, -0.1 ) * 1.2, vec3(0.28f, 0.25f, 0.25f) * 1.2 );\n\n    float fNeckDist = SdEllipsoid( vHeadDomain - vec3(0.0, -1.3, -0.95 ) * 1.2, vec3(0.4f, 0.7f, 0.4f) * 1.2 );\n    float fNeckDist2 = SdEllipsoid( vHeadDomain - vec3(0.0, -0.85, -0.725 ) * 1.2, vec3(0.325f, 0.5f, 0.33f) * 1.2 );\n\n    float fShoulderDist = SdEllipsoid( vHeadDomain - vec3(0.25, -1.45, -1.0 ) * 1.2, vec3(0.7f, 0.25f, 0.45f) * 1.2 );\n    \n    fNeckDist = smin( fNeckDist, fNeckDist2, 0.1 ); \n\n\tfFaceDist = smin( fFaceDist, fChinDist, 0.1 ); \n\tfFaceDist = smin( fFaceDist, fCheekDist, 0.1 ); \n    fFaceDist = smin( fFaceDist, fMouthExtrudeDist, 0.1 ); \n\t    \n    fForeheadDist = smin( fForeheadDist, fBrowDist, 0.1 ); \n\n    float fSkullDist = smin( fSkullBackDist, fSkullBaseDist, 0.1 ); \n    fSkullDist = smin( fSkullDist, fForeheadDist, 0.1 ); \n    \n    float fHeadDist = smin( fFaceDist, fSkullDist, 0.1 );\n    \n\n    fHeadDist = smin( fHeadDist, fNeckDist, 0.1 );\n\n\tfHeadDist = smin( fHeadDist, fShoulderDist, 0.1 );\n \n    \n    float fSkinDist = fHeadDist;\n    \n    float ws = sin( fMouthExtrudeDist * 15.0) * 0.5 + 0.5;\n    fSkinDist += ws * ws * 0.01 / (1.0 + fMouthExtrudeDist * 8.0);\n    \n\n#if MODEL_TOGGLES    \n    if( Key_IsToggled( iChannelKeyboard, KEY_Z ) )\n    {\n        fSkinDist = 1000.0;\n    }    \n#endif        \n    \n    float fEyeRecessDist = SdEllipsoid( vFaceDomain - vec3(0.5, -0.075, 0.43 ), vec3(0.5, 0.25, 0.35) );    \n    float fEyeRecessDist2 = SdEllipsoid( vFaceDomain - vec3(0.4, -0.1, 0.12 ), vec3(0.2, 0.1, 0.05) );    \n    fEyeRecessDist = smin( fEyeRecessDist, fEyeRecessDist2, 0.08 );    \n\tfSkinDist = -smin( -fSkinDist, fEyeRecessDist, 0.08 );    \n\n    resultSkin.vUVW.z = 0.0f;      \n    \n#if SCENE_NOSE    \n#if MODEL_TOGGLES    \n    if( !Key_IsToggled( iChannelKeyboard, KEY_C ) )\n#endif        \n    {    \n        float fNoseDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.25, 0.15 ) * 1.2, vec3(0.06, 0.15, 0.1) * 1.2 );\n        float fNoseBridgeDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.15, 0.05 ) * 1.2, vec3(0.06, 0.18, 0.1) * 1.2 );\n        float fNoseTipDist = SdEllipsoid( vFaceDomain - vec3(0.0, -0.3, 0.25 ) * 1.2, vec3(0.05, 0.05, 0.06) * 1.2 );\n        float fNoseBulgeDist = SdEllipsoid( vFaceDomain - vec3(0.06, -0.31, 0.225 ) * 1.2, vec3(0.04, 0.04, 0.05) * 1.2 );\n        float fNostrilDist = SdEllipsoid( vFaceDomain - vec3(0.04, -0.35, 0.26 ) * 1.2, vec3(0.02, 0.03, 0.015) * 1.2 );\n        fNoseDist = smin( fNoseDist, fNoseBridgeDist, 0.1);\n        fNoseDist = smin( fNoseDist, fNoseTipDist, 0.1);\n        fNoseDist = smin( fNoseDist, fNoseBulgeDist, 0.03);\n        fNoseDist = -smin( -fNoseDist, fNostrilDist, 0.015);\n\n        fSkinDist = smin( fSkinDist, fNoseDist, 0.05);\n    }\n#endif    \n         \n    vec3 vMouthDomain = vFaceDomain - vec3(0, -0.6, 0);    \n    float fFreq = 1.0 + abs(vMouthDomain.y) * 13.0;\n    float px = clamp( vFaceDomain.x * 6.0 * fFreq, 0.0, 1.0 );\n    px = pow( px, 0.8);\n    float pd = (-cos(px * PI * 2.0 ) * 0.5 + 0.5);\n    float fPhiltrumDist = ( pd * pd) * 0.005;\n        \n    fPhiltrumDist *= smoothstep( 0.2, 0.0f, abs( vMouthDomain.y ) );\n        \n    \n#if SCENE_MOUTH\n    float fMouthCullDist = length( vMouthDomain - vec3(0,0,-0.1) ) - 0.38;\n    {\n        SceneResult resultTemp;\n        resultTemp.fDist = fMouthCullDist;\n        resultTemp.iObjectId = MAT_DEFAULT;\n        resultTemp.vUVW = vPos;\n        //result = Scene_Union(result, resultTemp);  \n    }    \n    \n    if ( fMouthCullDist < 0.0 )    \n    {\n        float fMouthWidth = 0.2;\n\n        float fMouthSX = vMouthDomain.x / fMouthWidth;\n        //float fMouthX = fMouthSX * 0.5 + 0.5;\n\n        float fMouthTop = 0.0f;\n        float fMouthBot = 0.0f;\n        float fLipWidthTop = 0.05;\n        float fLipWidthBot = 0.04;\n\n        float fMouthEdgeDist = abs(vMouthDomain.x) - fMouthWidth;\n        \n        float fCornerFade = smoothstep(1.0, 0.2, abs(fMouthSX) );\n        fLipWidthTop *= fCornerFade;\n        fLipWidthBot *= fCornerFade;\n        \n\n        float fMouthDistTop = (vMouthDomain.y - fMouthTop);\n        float fMouthDistBot = -(vMouthDomain.y - fMouthBot);\n\n        float fMouthDist = 0.0;\n        float fLipWidth = 0.0;\n        \n        if ( fMouthDistTop > fMouthDistBot )\n        {\n            fMouthDist = fMouthDistTop;\n            fLipWidth = fLipWidthTop;\n        }\n        else\n        {\n            fMouthDist = fMouthDistBot;\n            fLipWidth = fLipWidthBot;\n            fPhiltrumDist *= 0.3;\n        }\n        \n        if ( fLipWidthTop > 0.0 )\n        fSkinDist = -smin( -fSkinDist, fMouthDist, fLipWidth );\n        \n        float fMouthT = max( fMouthDistTop / fLipWidthTop, fMouthDistBot / fLipWidthBot ) - 0.3;\n        fPhiltrumDist *= smoothstep( 0.2, 0.9, fMouthT );\n        \n        fMouthT = clamp( fMouthT, 0.0, 1.0 );\n        \n        fMouthT = 1.0 - fMouthT * fMouthT;\n        resultSkin.vUVW.z = fMouthT;\n    }\n\t\n    fSkinDist -= fPhiltrumDist;\n#endif    \n\n\n\n    resultSkin.vUVW.xy = vFaceDomainPos.xy;\n\n    \n#if SCENE_EARS\n    vec3 vEarDomain = vFaceDomain;\n    vEarDomain -= vec3( 0.62, -0.15, -0.7 );\n\n    float fEarCullDist = length( vEarDomain - vec3(0,0,-0.1) ) - 0.4;\n    {\n        SceneResult resultTemp;\n        resultTemp.fDist = fEarCullDist;\n        resultTemp.iObjectId = MAT_DEFAULT;\n        resultTemp.vUVW = vPos;\n        //result = Scene_Union(result, resultTemp);  \n    }\n    \n    if ( fEarCullDist < 0.0 )\n    {   \n        vEarDomain.z *= 1.5; // z scale\n        vEarDomain.x += vEarDomain.z*.45; // slope / stick out back\n        vEarDomain.z += smoothstep(-.2, 0., vEarDomain.y)*.1; // ear shape\n        vEarDomain.x += smoothstep(-.1, .4, vEarDomain.y) * -0.2; // stick out top\n        float fLobe = smoothstep(-.05, -.4, vEarDomain.y);\n        vEarDomain.x += fLobe * -0.04; // stick out lobe\n        vEarDomain.y += fLobe * 0.03; // pull down lobe\n        vEarDomain.z *= 1.0 + fLobe * 0.2;\n        float ear = sdCylinder(vEarDomain.yxz+vec3(0,.05,0), vec2(.2, .05));\n\n        vec2 vSwirlDomain = vEarDomain.zy - vec2( 0.04, -0.05 );\n\n        float sl = length( vSwirlDomain );\n        float sa = atan( vSwirlDomain.x, vSwirlDomain.y );\n        float sf = sin( sl * 30.0 );\n        ear -= sf * sf * 0.01;\n\n        ear = smin(ear, sdTorus(vEarDomain.yxz, vec2(.2, .03)), .005);\n\n        ear = min(ear, length(vEarDomain-vec3(0.0,-0.05,.1)) - 0.05 ); // bump\n\n        resultSkin.vUVW.z = max( resultSkin.vUVW.z, (0.6 - 0.2 * sf) / (1.0 +  ear * 30.0) );\n        \n        fSkinDist = smin(fSkinDist, ear * 0.85, .03);\n\n        fSkinDist = -smin(-fSkinDist, length(vEarDomain - vec3(-0.03, -0.05, 0.05)) - 0.01, .06); // hole\n\n    }    \n#endif\n\n    \n#if SCENE_EYES    \n    float fEyeX, fEyeLidSubtractTop, fEyeLidSubtractBot;\n    if ( testEyes )\n    {\n        float fEyelidThickness = 0.0;// 0.0125f;\n\n        float fEyelidDist = fEyeDist - fEyelidThickness;\n\n        fEyeX = ( fEyeDir * -vEyeDomain.x / fEyeRadius) * 0.5 + 0.5; \n\n        float fEyelidShape = sin( fEyeX * PI ) * 0.5 + 0.5;\n        float fTopMag = clamp( vEyeDir.y + 0.25, 0.1, 0.45 );\n        float fTopAng = -fEyelidShape * fTopMag;\n\n        float fBotMag = clamp( -vEyeDir.y + 0.25, 0.1, 0.4 );\n        float fBotAng = fEyelidShape * fEyelidShape * fBotMag;\n\n        float fBlink = clamp( 1.0 - mod( iTime, 5.0 ) * 10.0, 0.0, 1.0 );\n        \n        //fBlink = sin( iTime * 2.0 ) * 0.5 + 0.5;\n        \n        fBotAng = fBotAng * (1.0 - fBlink * 0.5); // bottom closes slightly\n        fTopAng = mix( fTopAng, fBotAng, fBlink ); // Top blends to meet bottom\n\n        float es = sin( -0.05 * fEyeDir );\n        float ec = cos( -0.05 * fEyeDir );\n\n        vec3 vEyeLidDirTop = normalize( vec3(es, cos(fTopAng), ec * sin(fTopAng)) );\n        fEyeLidSubtractTop = dot( vEyeLidDirTop, (vEyeDomain) );\n\n        float fEyelashCurlDist = clamp(fEyelidDist - 0.02, 0.0, 0.03);\n        fEyeLidSubtractTop -= fEyelashCurlDist * fEyelashCurlDist * 20.0 * (1.0 - fEyeX); // eyelash curl\n\n        vec3 vEyeLidDirBot = normalize( vec3(es, cos(fBotAng), ec * sin(fBotAng)) );\n        fEyeLidSubtractBot = -dot( vEyeLidDirBot, (vEyeDomain) );\n\n        float fEyeLidSubtract = -smin( -fEyeLidSubtractBot, -fEyeLidSubtractTop, 0.02 );\n\n        // Set eyelid inner color\n        float fEyeLidBlend =-fEyelidDist - fEyeLidSubtract;\n        fEyeLidBlend += 0.005;\n        if ( fEyeLidBlend > 0.0f )\n        {\n            fEyeLidBlend *= 150.0;\n\n            resultSkin.vUVW.z = max( resultSkin.vUVW.z, clamp( fEyeLidBlend, 0.0f, 1.0f ) );\n        }\n\n        //fEyeLidSubtract += -fEyeDist * fEyeDist * 0.1;\n\n    #if 1\n        float bmb = fBotMag * (1.0 - fBlink);\n        float wdb = fEyeLidSubtractBot / (1.0 - bmb * 0.5);\n        float wsb = sin( wdb * wdb * 1000.0 );\n        fEyelidDist -= wsb * wsb * 0.005 * clamp(fEyeLidSubtractBot * 10.0, 0.0, 0.1) * (bmb * 0.8 + 0.2);\n\n        float bmt = fTopMag * (1.0 - fBlink);\n        float wdt = fEyeLidSubtractTop / (1.0 - bmt * 1.5);\n        float wst = sin( 2.0 + wdt * wdt * 1000.0 );\n        fEyelidDist -= wst * wst * 0.02 * clamp( fEyeLidSubtractTop * 20.0, 0.0, 0.1) * (bmt * 0.8 + 0.2);\n\n    #endif    \n\n        fEyelidDist = -smin( -fEyelidDist, fEyeLidSubtract, 0.005 );\n\n        fSkinDist = smin( fSkinDist, fEyelidDist , 0.02 );        \n        //fSkinDist = min( fSkinDist, fEyelidDist );        \n    }\n#endif    \n  \n    \n        \n    float fBlush = clamp( 1.0 - fCheekDist * 10.0, 0.0, 1.0 );\n    resultSkin.vUVW.z = max( resultSkin.vUVW.z, 0.3 * fBlush );\n    \n#endif    \n\n    \n#if SCENE_HAIR    \n    SceneResult resultHair;\n\t    \n    float fHairDistA = SdEllipsoid( vFaceDomain - vec3(0.0, 0.53, -0.68 ) * 1.2, vec3(0.65f, 0.52f, 0.8f) * 1.2 );\n    float fHairDistB = SdEllipsoid( vFaceDomain - vec3(0.1, 0.2, -0.75 ) * 1.2, vec3(0.63f, 0.5f, 0.7f) * 1.2 );\n    float fHairDistC = SdEllipsoid( vFaceDomain - vec3(0.1, -0.15, -0.73 ) * 1.2, vec3(0.435f, 0.5f, 0.8f) * 1.2 );\n    float fHairDistD = SdEllipsoid( vFaceDomain - vec3(0.52, -0.0, -0.47 ) * 1.2, vec3(0.1f, 0.23f, 0.13f) );\n    \n    float fHairDist = fHairDistA;\n\tfHairDist = smin( fHairDist, fHairDistB, 0.2 );\n    fHairDist = smin( fHairDist, fHairDistC, 0.2 );\n\n    if ( fHairDist > -0.1 )\n    {\n\t    fHairDist = min( fHairDist, length( vFaceDomain - vec3(0.0, 0.3, -1.9 ) ) - 0.4 );\n        float fHairSub = SdEllipsoid( vFaceDomain - vec3(0.1, -0.2, -0.62 ) * 1.2, vec3(1.1f, 0.45f, 0.33f) );\n\n        fHairSub = min( fHairSub, length( vFaceDomain - vec3(0,-0.2,0.5) ) - 0.5 );\n        fHairSub = min( fHairSub, length( vFaceDomain - vec3(0.4,0.4,0.1) ) - 0.2 );\n\n        fHairDist = -smin( -fHairDist, fHairSub, 0.1 );\n    }\n    \n    float fBlush2 = clamp( (0.1 - fHairDist) * 5.0, 0.0, 1.0 );\n    resultSkin.vUVW.z = max( resultSkin.vUVW.z, fBlush2 * 0.3 );\n    \n    \n\tresultHair.iObjectId = MAT_HAIR;\n    resultHair.vUVW = vPos;\n    \n    if ( fHairDist < 0.05 )\n    {\n        vec3 vHairOrigin = vFaceDomain;\n        vHairOrigin.y += 0.1;\n        vHairOrigin.y += vHairOrigin.z * 0.25;\n        \n        float hb = atan( vHairOrigin.z, vHairOrigin.y );\n        float ha = atan( vHairOrigin.x, vHairOrigin.y );\n        \n        if ( (fHairDistD - 0.05) < fHairDist )\n        {\n            float b = -0.2 - vFaceDomain.y;\n            hb = vFaceDomain.y * 0.5;\n            ha = vFaceDomain.z + b * b * 2.0;\n        }\n            \n\t    fHairDist = smin( fHairDist, fHairDistD, 0.1 );\n            \n        \n\t    fHairDist += textureLod( iChannel2, vec2( ha * 2.5, hb * 0.001 ), 0.0 ).r * 0.06;\n        \n        resultHair.vUVW.x = ha;        \n        resultHair.vUVW.y = hb;\n    }\n    resultHair.fDist = fHairDist;\n    \n\n    result = Scene_Union(result, resultHair);\n#endif    \n    \n#if (SCENE_EYES && SCENE_SKIN)\n    if ( testEyes )\n    {    \n        float fTopEyelashOffset = -0.005;\n        float fBotEyelashOffset = -0.01;\n\n        float fTopEyelashThickness = 0.001;\n        float fTopEyelashLength = 0.04 * (1.0 - abs( fEyeX - 0.3 ) );\n\n        float fBotEyelashThickness = 0.001;\n        float fBotEyelashLength = 0.005;\n\n        float fTopEyelashDist = fEyeLidSubtractTop;\n        fTopEyelashDist = abs( fTopEyelashDist + fTopEyelashOffset) - fTopEyelashThickness;\n        fTopEyelashDist = max( fTopEyelashDist, fEyeDist - fTopEyelashLength );\n\n\n        float fBotEyelashDist = fEyeLidSubtractBot;\n        fBotEyelashDist = abs( fBotEyelashDist + fBotEyelashOffset) - fBotEyelashThickness;\n        fBotEyelashDist = max( fBotEyelashDist, fEyeDist - fBotEyelashLength );\n\n        float fEyelashDist = min( fTopEyelashDist, fBotEyelashDist );        \n\n        //float f2 = sin( vPos.x * 1000.0 + sin( vPos.x * 123.0) );\n        //float f2 = \n        //fEyelashDist += (f2 * 0.5 + 0.5) * 0.01;\n        //if ( textureLod( iChannel2, vec2(vPos.x * 5.0, 0.5), 0.0 ).r > 0.5 )\n        {\n            vec2 vLashPos = vPos.xz - vEyePos.xz;\n            vLashPos.y += 0.01;\n\n            float ang = vLashPos.x / vLashPos.y;\n\n            if ( fEyelashDist < 0.01 )\n            {\n                fEyelashDist += textureLod( iChannel2, vec2(ang, 0.5), 0.0 ).r * 0.002;\n            }\n        }\n\n\n        fSkinDist = smin( fSkinDist, fEyelashDist + 0.001, 0.005 );\n\n        SceneResult resultLash;\n        resultLash.fDist = fEyelashDist;\n        resultLash.iObjectId = MAT_HAIR;\n        resultLash.vUVW = vEyeDomain;\n        result = Scene_Union(result, resultLash);\n    }\n#endif    \n \n    //result.fDist = mix( result.fDist, length(vPos) - 0.5, sin(iTime) * 0.5 + 0.5);\n    \n    //result.iObjectId = MAT_CHROME;\n    //result.iObjectId = MAT_DEFAULT;\n    \n    //result.fDist *= 0.9;\n\n    /*\n    SceneResult resultSphere;\n    resultSphere.fDist = SdEllipsoid( vPos + g_sceneState.vNeckOffset, vec3(1.02, 0.03, 0.015) * 1.2 );\n    //length( vPos - vec3(-1.0, 0.0, 1.0) ) - 0.25;\n    resultSphere.iObjectId = MAT_CHROME;\n    resultSphere.vUVW = vPos;\n\tresult = Scene_Union(result, resultSphere);\n    */\n                \n    resultSkin.fDist = fSkinDist;\n\tresultSkin.iObjectId = MAT_SKIN;\n    result = Scene_Union(result, resultSkin);    \n    \n    \n    /*SceneResult resultTeeth;\n    vec3 vToothDomain = vFaceDomain - vec3(0, -0.6, -0.03);\n    resultTeeth.fDist = length( vToothDomain ) - 0.25;\n    resultTeeth.fDist = -min( -resultTeeth.fDist, abs(vToothDomain.y) - 0.05 );\n    resultTeeth.iObjectId = MAT_DEFAULT;\n    resultTeeth.vUVW = vFaceDomain;\n    result = Scene_Union(result, resultTeeth);    */\n    \n    \n    /*if ( fEyeLidBlend < 0.0f && fEyeLidBlend > -0.005f )\n    {\n\t\tresultSkin.iObjectId = MAT_HAIR;\n    } */\n\t\n    //result.iObjectId = MAT_CHROME;\n        \n    \n    return result;\n}\n\nSurfaceInfo Scene_GetSurfaceInfo( vec3 vRayOrigin, vec3 vRayDir, SceneResult traceResult )\n{\n    SurfaceInfo surfaceInfo;\n    \n    surfaceInfo.vPos = vRayOrigin + vRayDir * (traceResult.fDist);\n    \n    surfaceInfo.vNormal = Scene_GetNormal( surfaceInfo.vPos ); \n    surfaceInfo.vDiffNormal = surfaceInfo.vNormal;\n    surfaceInfo.vSpecNormal = surfaceInfo.vNormal;\n    surfaceInfo.vAlbedo = vec3(1.0);\n    surfaceInfo.vR0 = vec3( 0.02 );\n    surfaceInfo.fGloss = 1.0;\n#if ENABLE_EMISSIVE            \n    surfaceInfo.vEmissive = vec3( 0.0 );\n#endif    \n    surfaceInfo.fSkin = 0.0f;\n    \n    switch ( traceResult.iObjectId )\n    {\n    //case MAT_CHROME:\n        //surfaceInfo.vR0 = vec3(1.0);\n\t\t//break;\n        \n    case MAT_SKIN:\n        float z = clamp( abs(traceResult.vUVW.z), 0.0, 1.0 );\n        // Skin tone to red\n        surfaceInfo.vAlbedo = mix( vec3(0.76f, 0.58f, 0.50f), vec3(0.76f, 0.46f,0.45f) * 0.75, z );\n        surfaceInfo.vAlbedo = surfaceInfo.vAlbedo * surfaceInfo.vAlbedo;\n        // Red areas more smooth\n        surfaceInfo.fGloss = 0.4 + sqrt( z ) * 0.2;\n        \n        surfaceInfo.fSkin = 1.0f;\n        surfaceInfo.vR0 = vec3( 0.015f );\n        \n        // add low frequency noise to red - gives the impression of blue structures under skin\n        vec4 vLowNoiseSample = textureLod( iChannel2, traceResult.vUVW.xy * 0.05, 0.0);\n        float blueness = vLowNoiseSample.r;\n        surfaceInfo.vAlbedo.r += blueness * 0.1;\n                \n        // noise pattern\n        vec4 vNoiseSample = textureLod( iChannel2, traceResult.vUVW.xy * 1.0, 0.0);\n        float t = vNoiseSample.x;\n        float skinNoise =  t * t * 0.15 * ( 1.0 - z * 0.9);\n        surfaceInfo.vAlbedo *= 1.0 - skinNoise;\n        \n        vec4 vHighNoiseSample = textureLod( iChannel2, traceResult.vUVW.xy * 8.0, 0.0);\n    \n        \n        \n        // freckles\n        float t2 = vNoiseSample.y * vNoiseSample.y;\n        t2 = max (0.0, 1.0 - t2 * 50.0 );\n        //t2 = t2 * t2;\n        //t2 = max(0.0, (t2 - 0.75) / (1.0 - 0.75));\n        t2 *= ( 1.0 - z * 0.9) * 0.25;\n        surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vec3(0.1, 0.02, 0.0), t2 );\n\n        \n        //surfaceInfo.vAlbedo *= 0.3; // skin tone\n        \n        // Eyebrows\n        if ( traceResult.vUVW.y > 0.09 && traceResult.vUVW.y < 0.22 && abs(traceResult.vUVW.x) > 0.1 )\n        {\n            float fEyebrowDist = 100.0;\n            vec2 vEyebrowPos = vec2(0.0, 0.06);\n            vec2 vEyebrowDomain = traceResult.vUVW.xy;\n            vEyebrowDomain.x = abs( vEyebrowDomain.x );\n            vEyebrowDomain -= vEyebrowPos;\n                    \n            float fEyebrowBottom = vEyebrowDomain.y - sin( vEyebrowDomain.x * 6.2 - 0.5 ) * 0.1 * 1.2;\n            float fEyebrowTop = vEyebrowDomain.y - sin( vEyebrowDomain.x * 7.0 - 0.5 ) * 0.1 - 0.03;\n            \n            float fEyebrowShape = min( fEyebrowBottom, -fEyebrowTop );\n\n            fEyebrowShape = smin( fEyebrowShape, vEyebrowDomain.x - 0.15, 0.05 );\n            fEyebrowShape = smin( fEyebrowShape, 0.48 - vEyebrowDomain.x - vEyebrowDomain.y * 0.25, 0.02 );\n\n            fEyebrowDist = -fEyebrowShape;    \n            \n            \n            float fBlendBase = clamp( 1.0 - fEyebrowDist * 50.0, 0.0, 1.0 );\n            \n            float fTexture = textureLod( iChannel2, vec2( fEyebrowBottom * 2.5 + vEyebrowDomain.x * -0.4, vEyebrowDomain.x * 0.225 ), 0.0 ).r;\n            float fBlend = max( 0.0, fBlendBase - fTexture * 0.5 );\n            surfaceInfo.fSkin *= 1.0 - fBlend;\n\n            fBlend *= 0.8;\n            \n            surfaceInfo.vAlbedo = mix ( surfaceInfo.vAlbedo, vec3(0), fBlend );\n        }\n\t\n        // hacky skin bump map (applied to specular normal only)\n        surfaceInfo.fGloss *= surfaceInfo.fSkin;\n        surfaceInfo.vSpecNormal += ((vHighNoiseSample.xyz * 1.5 + vNoiseSample.yzw * 0.5) - 1.0) * 0.3 * surfaceInfo.fSkin;\n\n        break;        \n        \n    case MAT_EYEBALL_L:\n    case MAT_EYEBALL_R:\n        {\n            vec3 vEyeDir;\n            vec3 vEyePos;\n            if ( traceResult.iObjectId == MAT_EYEBALL_L )\n            {\n                vEyePos = g_sceneState.lEyePos;\n                vEyeDir = g_sceneState.lEyeDir;\n            }\n            else\n            {\n                vEyePos = g_sceneState.rEyePos;\n                vEyeDir = g_sceneState.rEyeDir;\n            }\n            \n            vec3 vSide = normalize( cross( vec3(0,1,0), vEyeDir ) );\n            vec3 vUp = normalize( cross( vEyeDir, vSide ) );\n            \n            vec3 vEyeOffset = surfaceInfo.vPos - vEyePos;\n\n            vec2 vUV;\n            vUV.x = dot( vEyeOffset, vSide );\n            vUV.y = dot( vEyeOffset, vUp );\n\n            \n            const float fCorneaStartZ = 0.84f * fEyeRadius;\n            const float fIrisSize = 0.48f * fEyeRadius;\n            //const float fPupilFraction = 0.4f;\n            float fPupilFraction = 0.4f + sin(iTime * 0.4) * 0.1f;                \n\n            float zOffset = dot(vEyeOffset, vEyeDir);\n            \n            float thickness = zOffset - fCorneaStartZ;\n            if ( thickness > 0.0f )\n            {\n                float refractiveIndex = 1.0 / 1.3f;\n                vec3 vRefracted = refract(vRayDir, surfaceInfo.vSpecNormal, refractiveIndex);\n\n                float refractedZ = dot( vRefracted, vEyeDir );\n                \n                float opticalDepth = thickness / refractedZ;\n\n                vec3 vUVOffset = vec3(vRefracted * opticalDepth);\n                vUV.x -= dot( vUVOffset, vSide );\n                vUV.y -= dot( vUVOffset, vUp );\n            }\n\n            vec2 vIrisUV = vUV / fIrisSize;\n\n            float irisR = length( vIrisUV );\n            float irisT = atan( vUV.x, vUV.y ) / TAU;\n\n            float R = irisR * fIrisSize;\n\n            float fBloodShot = textureLod( iChannel2, vec2( irisR, irisT ) * vec2(0.02, 0.4) + 0.3, 0.0).r;\n\n            float fBloodShotFade = 1.0 - dot( vEyeDir, surfaceInfo.vNormal);\n            fBloodShot *= fBloodShotFade + 0.4;\n\n            fBloodShot = fBloodShot * fBloodShot * fBloodShot;\n                        \n            surfaceInfo.vAlbedo = mix( vec3(1.0, 0.8, 0.8), vec3(0.5f, 0.2f, 0.2f), fBloodShot );                \n\n            if ( zOffset > 0.0 )\n            {\n                // Darken around iris\n                float fIrisOuterBlend = clamp( -(irisR - 1.15) * 5.0, 0.0, 1.0f );                                                           \n                surfaceInfo.vAlbedo *= mix( 1.0, 0.2, fIrisOuterBlend);\n\n\n                float fIrisBlend = clamp( -(irisR - 1.0) * 10.0, 0.0, 1.0f );\n\n                if ( fIrisBlend > 0.0 )\n                {\n                    float fMiscNoise = textureLod( iChannel2, vUV * 0.25 + 0.1, 0.0).r;\n\n                    vec3 vIrisColor =  mix( vec3(0.2, .3, 0.8) * 0.3, vec3(0.8, 0.5, 0.2) * 0.2, fMiscNoise );\n\n                    float scaledIrisR = irisR - fPupilFraction;\n                    \n                    float fIrisNoise = textureLod( iChannel2, vec2( scaledIrisR, irisT ) * vec2(0.03, 0.8), 0.0).r;\n\n                    fIrisNoise = pow( fIrisNoise, 1.5);\n\n\n                    vec3 vIrisAlbedo = vIrisColor * (fIrisNoise + 0.8);\n                    vIrisAlbedo = min( vIrisAlbedo, vec3(1.0) );\n\n                    surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vIrisAlbedo, fIrisBlend );\n\n\n                    vec3 vNormal2 = vEyeDir;\n                    vNormal2 -= vSide * vIrisUV.x * 0.75;\n                    vNormal2 -= vUp * vIrisUV.y * 0.75;\n                    surfaceInfo.vDiffNormal = mix( surfaceInfo.vDiffNormal, vNormal2, fIrisBlend );\n\n\n                    //surfaceInfo.vAlbedo = vec3(1);\n                    float fIrisBump = textureLod( iChannel2, vec2( scaledIrisR, irisT - 0.001 ) * vec2(0.03, 0.8), 0.0).r;                   \n                    fIrisBump = fIrisNoise - fIrisBump;\n                    surfaceInfo.vDiffNormal.x += cos( irisT * TAU ) * fIrisBump;\n                    surfaceInfo.vDiffNormal.y += sin( irisT * TAU ) * fIrisBump;\n\n                }\n\n                //surfaceInfo.vSpecNormal += (textureLod( iChannel2, vec2( irisR, irisT ) * vec2(0.1,1), 0.0).xyz * 2.0 - 1.0) * 0.01 * (1.0f - fIrisBlend);\n\n\n\n                float fPupilBlend = clamp( -(irisR-fPupilFraction) * 10.0, 0.0, 1.0f );\n                {\n                    surfaceInfo.vAlbedo = mix( surfaceInfo.vAlbedo, vec3(0, 0, 0), fPupilBlend);\n\n                    vec3 vPerpDir = -normalize( vec3( vIrisUV, 0.0 ) );\n                    surfaceInfo.vDiffNormal = mix( surfaceInfo.vDiffNormal, vPerpDir, fPupilBlend );\n                }\n            }\n        }\n        break;\n\n\tcase MAT_HAIR:\n        surfaceInfo.fGloss = 0.6f;\n        \n        vec4 vHairSample = textureLod( iChannel2, vec2(traceResult.vUVW.xy) * vec2(10.0, 0.1), 0.0);\n        surfaceInfo.vAlbedo = vHairSample.rrr;\n        \n        vec3 vHairCol = vec3(1.0, 0.4, 0.1) * 0.4;\n        //surfaceInfo.vAlbedo = vec3(0.5);\n        surfaceInfo.vAlbedo *= vHairCol;\n        surfaceInfo.vR0 = vHairCol * vHairSample.g * 0.1 + 0.005;\n        //surfaceInfo.vSpecNormal = normalize( cross( surfaceInfo.vSpecNormal, vec3(0,1,0) ) );\n        \n\t\tbreak;\n    }\n    \n\tsurfaceInfo.vDiffNormal = normalize( surfaceInfo.vDiffNormal );\n    surfaceInfo.vSpecNormal = normalize( surfaceInfo.vSpecNormal );\n    \n    \n    return surfaceInfo;\n}\n\n// Scene Lighting\n\nvec3 g_vSunDir = normalize(vec3(0.3, 0.4, 0.5));\nvec3 g_vSunColor = vec3(1, 0.95, 0.8) * 5.0;\nvec3 g_vAmbientColor = vec3(1.0, 1.2, 1.5)* 1.0 * vec3(0.5, 1.0, 0.5);\n\nSurfaceLighting Scene_GetSurfaceLighting( const in vec3 vViewDir, in SurfaceInfo surfaceInfo )\n{\n    SurfaceLighting surfaceLighting;\n    \n    surfaceLighting.vDiffuse = vec3(0.0);\n    surfaceLighting.vSpecular = vec3(0.0);    \n    \n    Light_AddDirectional( surfaceLighting, surfaceInfo, vViewDir, g_vSunDir, g_vSunColor );\n    \n    vec3 vLightPos = vec3(-2.0, 0.4, 2.0);\n    vec3 vLightCol = vec3(0.1);\n    \n    //Light_AddSpot( surfaceLighting, surfaceInfo, vViewDir, vSpotPos, vSpotDir, radians(10.0), radians(60.0), vLightCol * 0.02 );\n    Light_AddPoint( surfaceLighting, surfaceInfo, vViewDir, vLightPos, vLightCol );\n    \n    float fAO = Scene_GetAmbientOcclusion( surfaceInfo.vPos, surfaceInfo.vDiffNormal );\n    // AO\n    surfaceLighting.vDiffuse += fAO * (surfaceInfo.vDiffNormal.y * 0.5 + 0.5) * g_vAmbientColor;\n    \n    return surfaceLighting;\n}\n\n// Environment\n\nvec3 Env_GetSkyColor( vec3 vViewPos, vec3 vViewDir, float fRaySpread )\n{\n\tvec3 vResult = vec3( 0.0, 0.0, 0.0 );\n   \n#if 1\n    float fFactor = 1.0f - fRaySpread * fRaySpread;\n    vec3 vEnvMap = textureLod( iChannel1, vViewDir.zyx, 8.0 * fFactor ).rgb;\n    //vEnvMap = vEnvMap * vEnvMap;\n    //float kEnvmapExposure = 0.999;\n    //vResult.rgb = -log2(1.0 - vEnvMap * kEnvmapExposure);\n    vResult.rgb = vEnvMap;\n#endif\n    \n    // Sun\n    //float NdotV = dot( g_vSunDir, vViewDir );\n    //vResult.rgb += smoothstep( cos(radians(.7)), cos(radians(.5)), NdotV ) * g_vSunColor * 5000.0;\n\n    return vResult * 3.5;\n}\n\nfloat Env_GetFogFactor(const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{    \n\tfloat kFogDensity = 0.1;\n\treturn exp(fDist * -kFogDensity);\t\n}\n\nvec3 Env_GetFogColor(const in vec3 vDir)\n{    \n\treturn vec3(0.5, 0.45, 0.4) * 2.0;\t\t\n}\n\nvec3 Env_ApplyAtmosphere( const in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist )\n{\n    return vColor;\n    \n    //vec3 vResult = vColor;        \n\t//float fFogFactor = Env_GetFogFactor( vRayOrigin, vRayDir, fDist );\n\t//vec3 vFogColor = Env_GetFogColor( vRayDir );\t\n    //vResult = mix( vFogColor, vResult, fFogFactor );\n    //return vResult;\t    \n}\n\n\nvec3 FX_Apply( in vec3 vColor, const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float fDist)\n{    \n    return vColor;\n}\n\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    if ( iFrame == 0 )\n    {\n        vFragColor = vec4(0);\n        return;\n    }\n    \n    vec2 vReducedResolution = texelFetch( iChannelState, ADDR_RESOLUTION, 0).xy;\n    vec2 vUV = vFragCoord.xy / vReducedResolution.xy;\n        \n    CameraState cam;\n\tCam_LoadState( cam, iChannelState, ivec2(0,0) );\n    \n\n    AnimState animState;\n    AnimState_LoadState( animState, iChannelState, ADDR_ANIMSTATE );    \n    \n    // Trace Scene\n    float fAspectRatio = iResolution.x / iResolution.y;            \n    \n    vec3 vRayOrigin, vRayDir;\n    vec2 vJitterUV = vUV + cam.vJitter / vReducedResolution.xy;\n    Cam_GetCameraRay( vJitterUV, fAspectRatio, cam, vRayOrigin, vRayDir );\n \n    InitSceneState( animState, cam.vPos );\n    \n    if ( cam.fPlaneInFocus < 0.0 )\n    {\n        vec3 vForwards = normalize(cam.vTarget - cam.vPos);\n        SceneResult focusTrace = Scene_Trace( cam.vPos, vForwards, 0.0, 100.0 );\n        cam.fPlaneInFocus = focusTrace.fDist;     \n    }\n    \n    float fHitDist = 0.0f;\n    vFragColor = Render_GetColorAndDepth( vRayOrigin, vRayDir );    \n    \n\tCam_StoreState( ivec2(0), cam, vFragColor, ivec2(vFragCoord.xy) );        \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 41,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a//media/previz/cubemap00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//     _____                                              _____            _       \n//    / ____|                                            / ____|          | |      \n//   | |      ___   _ __ ___   _ __ ___    ___   _ __   | |      ___    __| |  ___ \n//   | |     / _ \\ | '_ ` _ \\ | '_ ` _ \\  / _ \\ | '_ \\  | |     / _ \\  / _` | / _ \\\n//   | |____| (_) || | | | | || | | | | || (_) || | | | | |____| (_) || (_| ||  __/\n//    \\_____|\\___/ |_| |_| |_||_| |_| |_| \\___/ |_| |_|  \\_____|\\___/  \\__,_| \\___|\n//                                                                                 \n//                                                                                 \n\n\n\n//    __  __ _            _    _ _   _ _ \n//   |  \\/  (_)          | |  | | | (_) |\n//   | \\  / |_ ___  ___  | |  | | |_ _| |\n//   | |\\/| | / __|/ __| | |  | | __| | |\n//   | |  | | \\__ \\ (__  | |__| | |_| | |\n//   |_|  |_|_|___/\\___|  \\____/ \\__|_|_|\n//                                       \n//                                       \n\n\n#define PI\t3.141592654\n#define TAU 6.283185308\n\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n//  _   _           _       _____                 _   _                 \n// | | | | __ _ ___| |__   |  ___|   _ _ __   ___| |_(_) ___  _ __  ___ \n// | |_| |/ _` / __| '_ \\  | |_ | | | | '_ \\ / __| __| |/ _ \\| '_ \\/ __|\n// |  _  | (_| \\__ \\ | | | |  _|| |_| | | | | (__| |_| | (_) | | | \\__ \\\n// |_| |_|\\__,_|___/_| |_| |_|   \\__,_|_| |_|\\___|\\__|_|\\___/|_| |_|___/\n//                                                                      \n\n// From: Hash without Sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n//#define HASHSCALE1 .1031\n//#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec3(443.897, 441.423, 437.195, 444.129)\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n//  ____        _          ____  _                             \n// |  _ \\  __ _| |_ __ _  / ___|| |_ ___  _ __ __ _  __ _  ___ \n// | | | |/ _` | __/ _` | \\___ \\| __/ _ \\| '__/ _` |/ _` |/ _ \\\n// | |_| | (_| | || (_| |  ___) | || (_) | | | (_| | (_| |  __/\n// |____/ \\__,_|\\__\\__,_| |____/ \\__\\___/|_|  \\__,_|\\__, |\\___|\n//                                                  |___/      \n//\n\nvec4 LoadVec4( sampler2D sampler, in ivec2 vAddr )\n{\n    return texelFetch( sampler, vAddr, 0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in ivec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( ivec2 p, ivec2 c ) { return all( equal( p, c ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n//\n//  ____       _        _   _             \n// |  _ \\ ___ | |_ __ _| |_(_) ___  _ __  \n// | |_) / _ \\| __/ _` | __| |/ _ \\| '_ \\ \n// |  _ < (_) | || (_| | |_| | (_) | | | |\n// |_| \\_\\___/ \\__\\__,_|\\__|_|\\___/|_| |_|\n//                                        \n//\n\nvec3 RotateX( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( vPos.x, c * vPos.y + s * vPos.z, -s * vPos.y + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateY( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.z, vPos.y, -s * vPos.x + c * vPos.z);\n    \n    return vResult;\n}\n\nvec3 RotateZ( const in vec3 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n    \n    vec3 vResult = vec3( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y, vPos.z);\n    \n    return vResult;\n}\n\n\nmat3 MatFromAngles( vec3 vAngles )\n{\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    return m;\n}\n\n\n//   ___              _                  _             \n//  / _ \\ _   _  __ _| |_ ___ _ __ _ __ (_) ___  _ __  \n// | | | | | | |/ _` | __/ _ \\ '__| '_ \\| |/ _ \\| '_ \\ \n// | |_| | |_| | (_| | ||  __/ |  | | | | | (_) | | | |\n//  \\__\\_\\\\__,_|\\__,_|\\__\\___|_|  |_| |_|_|\\___/|_| |_|\n//                                                     \n//\n\nvec4 QuatMul(const in vec4 lhs, const in vec4 rhs) \n{\n      return vec4( lhs.y*rhs.z - lhs.z*rhs.y + lhs.x*rhs.w + lhs.w*rhs.x,\n                   lhs.z*rhs.x - lhs.x*rhs.z + lhs.y*rhs.w + lhs.w*rhs.y,\n                   lhs.x*rhs.y - lhs.y*rhs.x + lhs.z*rhs.w + lhs.w*rhs.z,\n                   lhs.w*rhs.w - lhs.x*rhs.x - lhs.y*rhs.y - lhs.z*rhs.z);\n}\n\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n\treturn vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nmat3 QuatToMat3( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n\treturn v + q.w * t + cross(q.xyz, t);\n}\n\n//\n//  _  __          _                         _ \n// | |/ /___ _   _| |__   ___   __ _ _ __ __| |\n// | ' // _ \\ | | | '_ \\ / _ \\ / _` | '__/ _` |\n// | . \\  __/ |_| | |_) | (_) | (_| | | | (_| |\n// |_|\\_\\___|\\__, |_.__/ \\___/ \\__,_|_|  \\__,_|\n//           |___/                             \n//\n\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\nconst int KEY_1 = \t49;\nconst int KEY_2 = \t50;\nconst int KEY_3 = \t51;\nconst int KEY_ENTER = 13;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_TAB\t= 9;\n\nbool Key_IsPressed( sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 0), 0 ).x > 0.0;    \n}\n\nbool Key_IsToggled(sampler2D samp, int key)\n{\n    return texelFetch( samp, ivec2(key, 2), 0 ).x > 0.0;    \n}\n\n\n//\n//   ____                               \n//  / ___|__ _ _ __ ___   ___ _ __ __ _ \n// | |   / _` | '_ ` _ \\ / _ \\ '__/ _` |\n// | |__| (_| | | | | | |  __/ | | (_| |\n//  \\____\\__,_|_| |_| |_|\\___|_|  \\__,_|\n//                                      \n\n\nstruct CameraState\n{\n    vec3 vPos;\n    vec3 vTarget;\n    vec3 vUp;\n    float fFov;\n    vec2 vJitter;\n    float fPlaneInFocus;\n};\n    \nvoid Cam_LoadState( out CameraState cam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    cam.vPos = vPos.xyz;\n    vec4 targetFov = LoadVec4( sampler, addr + ivec2(1,0) );\n    cam.vTarget = targetFov.xyz;\n    cam.fFov = targetFov.w;\n    vec4 vUp = LoadVec4( sampler, addr + ivec2(2,0) );\n    cam.vUp = vUp.xyz;\n    \n    vec4 jitterDof = LoadVec4( sampler, addr + ivec2(3,0) );\n    cam.vJitter = jitterDof.xy;\n    cam.fPlaneInFocus = jitterDof.z;\n}\n\nvoid Cam_StoreState( ivec2 addr, const in CameraState cam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( cam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( cam.vTarget, cam.fFov ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(2,0), vec4( cam.vUp, 0 ), fragColor, fragCoord );    \n    StoreVec4( addr + ivec2(3,0), vec4( cam.vJitter, cam.fPlaneInFocus, 0 ), fragColor, fragCoord );    \n}\n\nmat3 Cam_GetWorldToCameraRotMatrix( const CameraState cameraState )\n{\n    vec3 vForward = normalize( cameraState.vTarget - cameraState.vPos );\n\tvec3 vRight = normalize( cross( cameraState.vUp, vForward) );\n\tvec3 vUp = normalize( cross(vForward, vRight) );\n    \n    return mat3( vRight, vUp, vForward );\n}\n\nvec2 Cam_GetViewCoordFromUV( vec2 vUV, float fAspectRatio )\n{\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= fAspectRatio;\n\n\treturn vWindow;\t\n}\n\nvoid Cam_GetCameraRay( const vec2 vUV, const float fAspectRatio, const CameraState cam, out vec3 vRayOrigin, out vec3 vRayDir )\n{\n    vec2 vView = Cam_GetViewCoordFromUV( vUV, fAspectRatio );\n    vRayOrigin = cam.vPos;\n    float fPerspDist = 1.0 / tan( radians( cam.fFov ) );\n    vRayDir = normalize( Cam_GetWorldToCameraRotMatrix( cam ) * vec3( vView, fPerspDist ) );\n}\n\n// fAspectRatio = iResolution.x / iResolution.y;\nvec2 Cam_GetUVFromWindowCoord( const in vec2 vWindow, float fAspectRatio )\n{\n    vec2 vScaledWindow = vWindow;\n    vScaledWindow.x /= fAspectRatio;\n\n    return (vScaledWindow * 0.5 + 0.5);\n}\n\nvec2 Cam_WorldToWindowCoord(const in vec3 vWorldPos, const in CameraState cameraState )\n{\n    vec3 vOffset = vWorldPos - cameraState.vPos;\n    vec3 vCameraLocal;\n\n    vCameraLocal = vOffset * Cam_GetWorldToCameraRotMatrix( cameraState );\n\t\n    vec2 vWindowPos = vCameraLocal.xy / (vCameraLocal.z * tan( radians( cameraState.fFov ) ));\n    \n    return vWindowPos;\n}\n\nfloat EncodeDepthAndObject( float depth, int objectId )\n{\n    //depth = max( 0.0, depth );\n    //objectId = max( 0, objectId + 1 );\n    //return exp2(-depth) + float(objectId);\n    return depth;\n}\n\nfloat DecodeDepthAndObjectId( float value, out int objectId )\n{\n    objectId = 0;\n    return max(0.0, value);\n    //objectId = int( floor( value ) ) - 1; \n    //return abs( -log2(fract(value)) );\n}\n\n\n//     _____                                      _                 _   _             \n//    / ____|                         /\\         (_)               | | (_)            \n//   | (___   ___ ___ _ __   ___     /  \\   _ __  _ _ __ ___   __ _| |_ _  ___  _ __  \n//    \\___ \\ / __/ _ \\ '_ \\ / _ \\   / /\\ \\ | '_ \\| | '_ ` _ \\ / _` | __| |/ _ \\| '_ \\ \n//    ____) | (_|  __/ | | |  __/  / ____ \\| | | | | | | | | | (_| | |_| | (_) | | | |\n//   |_____/ \\___\\___|_| |_|\\___| /_/    \\_\\_| |_|_|_| |_| |_|\\__,_|\\__|_|\\___/|_| |_|\n//                                                                                    \n//                                                                                    \n\nstruct AnimState\n{\n    vec3 vEyeTarget;\n    vec3 vHeadAngles;\n};\n    \n    \nvoid AnimState_LoadState( out AnimState animState, sampler2D sampler, ivec2 addr )\n{\n    vec4 vData0 = LoadVec4( sampler, addr + ivec2(0,0) );\n    animState.vEyeTarget = vData0.xyz;\n    vec4 vData1 = LoadVec4( sampler, addr + ivec2(1,0) );\n    animState.vHeadAngles = vData1.xyz;\n}\n    \n   \nvoid AnimState_StoreState( ivec2 addr, const in AnimState animState, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( animState.vEyeTarget, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( animState.vHeadAngles, 0 ), fragColor, fragCoord );\n}\n\n#define ADDR_RESOLUTION ivec2(12,0)\n#define ADDR_ANIMSTATE ivec2(13,0)\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//    _______                                   _                        _____              \n//   |__   __|                                 | |     /\\        /\\     |  __ \\             \n//      | | ___ _ __ ___  _ __   ___  _ __ __ _| |    /  \\      /  \\    | |__) |_ _ ___ ___ \n//      | |/ _ \\ '_ ` _ \\| '_ \\ / _ \\| '__/ _` | |   / /\\ \\    / /\\ \\   |  ___/ _` / __/ __|\n//      | |  __/ | | | | | |_) | (_) | | | (_| | |  / ____ \\  / ____ \\  | |  | (_| \\__ \\__ \\\n//      |_|\\___|_| |_| |_| .__/ \\___/|_|  \\__,_|_| /_/    \\_\\/_/    \\_\\ |_|   \\__,_|___/___/\n//                       | |                                                                \n//                       |_|                                                                \n\n\n#define ENABLE_TAA\n\n///////////////////////////////\n\n\n#define iChannelState\tiChannel2\n#define iChannelCurr \tiChannel0\n#define iChannelHistory iChannel1\n\nvec3 Tonemap( vec3 x )\n{\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nvec3 TAA_ColorSpace( vec3 color )\n{\n    return Tonemap(color);\n}\n\nfloat minComponent( vec3 a )\n{\n    return min(a.x, min(a.y, a.z) );\n}\n\n// Adapted from https://github.com/gokselgoktas/temporal-anti-aliasing/blob/master/Assets/Resources/Shaders/TemporalAntiAliasing.cginc\n// which is adapted from https://github.com/playdeadgames/temporal\n// Optimization by Stubbesaurus and epsilon adjustment to avoid division by zero\nvec3 clipToAABB(vec3 color, vec3 minimum, vec3 maximum) {\n    // note: only clips towards aabb center (but fast!)\n    vec3 center  = 0.5 * (maximum + minimum);\n    vec3 extents = 0.5 * (maximum - minimum);\n\n    // This is actually `distance`, however the keyword is reserved\n    vec3 offset = color - center;\n\n    vec3 ts = abs(extents / (offset + 0.0001));\n    float t = clamp(minComponent(ts), 0.0, 1.0);\n    return center + offset * t;\n}\n\nvoid mainImage( out vec4 vFragColor, in vec2 vFragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannelCurr, ivec2(0) );\n    \n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannelHistory, ivec2(0,0) );\n\n    vec2 vReducedResolution = LoadVec4( iChannelState, ADDR_RESOLUTION ).xy;\n    \t    \n    vec2 vUV = vFragCoord.xy / iResolution.xy;\n\tivec2 vCurrXY = ivec2(floor(vFragCoord.xy));\n    \n    vec2 vfReducedXY = vFragCoord.xy * vReducedResolution / iResolution.xy;\n\tivec2 vReducedXY = ivec2(floor(vfReducedXY));\n    //vfReducedXY -= 0.5;\n\n        \n \t//vec2 vUnJitterUV = vUV - camCurr.vJitter / iResolution.xy;    \n    \n    //vFragColor = textureLod(iChannelCurr, vUnJitterUV, 0.0);\n    //vFragColor = texelFetch( iChannelCurr, vReducedXY, 0);\n    vFragColor = textureLod( iChannelCurr, vfReducedXY / iResolution.xy, 0.0);\n    \n    float fAspectRatio = iResolution.x / iResolution.y;\n    \n    \n#ifdef ENABLE_TAA\n    vec3 vRayOrigin, vRayDir;\n    Cam_GetCameraRay( vUV, fAspectRatio, camCurr, vRayOrigin, vRayDir );    \n    float fDepth;\n    int iObjectId;\n    //vec4 vCurrTexel = texelFetch( iChannelCurr, vReducedXY, 0);\n    vec4 vCurrTexel = texture( iChannelCurr, vfReducedXY / iResolution.xy, 0.0);\n    fDepth = DecodeDepthAndObjectId( vCurrTexel.w, iObjectId );\n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n    \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), fAspectRatio );\n        \n    if ( all( greaterThanEqual( vPrevUV, vec2(0) )) && all( lessThan( vPrevUV, vec2(1) )) )\n\t{\n        vec3 vMin = vec3( 10000);\n        vec3 vMax = vec3(-10000);\n        \n        int iNeighborhoodSize = 1;\n        for ( int iy=-iNeighborhoodSize; iy<=iNeighborhoodSize; iy++)\n        {\n            for ( int ix=-iNeighborhoodSize; ix<=iNeighborhoodSize; ix++)\n            {\n                ivec2 iOffset = ivec2(ix, iy);\n\t\t        vec3 vTest = texelFetch( iChannelCurr, vReducedXY + iOffset, 0 ).rgb;\n                                \n                vMin = min( vMin, vTest );\n                vMax = max( vMax, vTest );\n            }\n        }\n        \n        float epsilon = 0.0;\n        vMin -= epsilon;\n        vMax += epsilon;\n        \n        float fBlend = 0.0f;\n        \n        vec4 vHistory = textureLod( iChannelHistory, vPrevUV, 0.0 );\n        vHistory.rgb = clipToAABB( vHistory.rgb, vMin, vMax );\n\n        fBlend = 0.95;\n        \n        //fBlend = 0.0;\n        \n        vFragColor.rgb = mix( vFragColor.rgb, vHistory.rgb, fBlend);\n    }  \n    else\n    {\n        //vFragColor.gb *= 0.0;\n    }\n\n#endif\n    \n    vFragColor.rgb = max( vec3(0), vFragColor.rgb ); // clear NaNs\n    \n    vFragColor.rgb += (hash13( vec3( vFragCoord, iTime ) ) * 2.0 - 1.0) * 0.03;\n    \n\tCam_StoreState( ivec2(0), camCurr, vFragColor, ivec2(vFragCoord.xy) );    \n\tCam_StoreState( ivec2(4,0), camPrev, vFragColor, ivec2(vFragCoord.xy) );    \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//    _____          _   ________   __  _____              \n//   |  __ \\        | | |  ____\\ \\ / / |  __ \\             \n//   | |__) |__  ___| |_| |__   \\ V /  | |__) |_ _ ___ ___ \n//   |  ___/ _ \\/ __| __|  __|   > <   |  ___/ _` / __/ __|\n//   | |  | (_) \\__ \\ |_| |     / . \\  | |  | (_| \\__ \\__ \\\n//   |_|   \\___/|___/\\__|_|    /_/ \\_\\ |_|   \\__,_|___/___/\n//                                                         \n//                                                         \n// Motion blur, Depth of Field\n\n\n#define ENABLE_DOF\n#define ENABLE_MOTION_BLUR\n\n///////////////////////////////\n\n\n\nfloat GetCoC( float fDistance, float fPlaneInFocus )\n{\n#ifdef ENABLE_DOF    \n\t// http://http.developer.nvidia.com/GPUGems/gpugems_ch23.html\n\n    float fAperture = min(1.0, fPlaneInFocus * fPlaneInFocus * 0.5);\n    float fFocalLength = 0.05;\n    \n\treturn abs(fAperture * (fFocalLength * (fDistance - fPlaneInFocus)) /\n          (fDistance * (fPlaneInFocus - fFocalLength)));  \n#else\n    return 0.0f;\n#endif    \n}\n\n// Depth of field pass\n\n#define BLUR_TAPS 32\nfloat fGolden = 3.141592 * (3.0 - sqrt(5.0));\n\n#define MOD2 vec2(4.438975,3.972973)\n\nfloat Hash( float p ) \n{\n    // https://www.shadertoy.com/view/4djSRW - Dave Hoskins\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CameraState camCurr;\n\tCam_LoadState( camCurr, iChannel0, ivec2(0) );\n\n    CameraState camPrev;\n\tCam_LoadState( camPrev, iChannel0, ivec2(4,0) );\n    \n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n \t//vUV -= camCurr.vJitter / iResolution.xy;    // TAA has removed jitter\n\n    vec4 vSample = texelFetch( iChannel0, ivec2(fragCoord.xy), 0 ).rgba;\n    \n    int iObjectId;\n    float fDepth = DecodeDepthAndObjectId( vSample.w, iObjectId );\n    \n    vec3 vRayOrigin, vRayDir;\n\n    float fAspectRatio = iResolution.x / iResolution.y;\n    \n    Cam_GetCameraRay( vUV, fAspectRatio, camCurr, vRayOrigin, vRayDir );    \n    vec3 vWorldPos = vRayOrigin + vRayDir * fDepth;\n        \n    vec2 vPrevUV = Cam_GetUVFromWindowCoord( Cam_WorldToWindowCoord(vWorldPos, camPrev), fAspectRatio );// - camPrev.vJitter / iResolution.xy;\n        \n\tvec3 vResult = vec3(0.0);\n    \n    float fTot = 0.0;\n    \n    float fPlaneInFocus = camCurr.fPlaneInFocus;\n        \n\tfloat fCoC = GetCoC( fDepth, camCurr.fPlaneInFocus );\n        \n    float r = 1.0;\n    vec2 vangle = vec2(0.0,fCoC); // Start angle\n    \n    float fWeight = max( 0.001, fCoC );    \n    vResult.rgb = vSample.rgb * fWeight;\n    fTot += fWeight;\n    \n#if defined(ENABLE_DOF) || defined(ENABLE_MOTION_BLUR)    \n    float fMotionBlurTaps = float(BLUR_TAPS);\n    \n    float fShutterAngle = 0.5;\n    \n    float f = 0.0;\n    float fIndex = 0.0;\n    for(int i=1; i<BLUR_TAPS; i++)\n    {\n        float fRandomT = Hash( iTime + fIndex + vUV.x + vUV.y * 12.345);\n        float fOrderedT = fIndex / fMotionBlurTaps;\n        \n        float fDofT = fOrderedT;\n        float fMotionT = fRandomT;\n        \n        vec2 vTapUV = vUV;\n        #ifdef ENABLE_MOTION_BLUR\n        vTapUV = mix( vTapUV, vPrevUV, (fMotionT - 0.5) * fShutterAngle );\n        #endif\n                \n        // http://blog.marmakoide.org/?p=1\n        \n        float fTheta = fDofT * fGolden * fMotionBlurTaps;\n        float fRadius = fCoC * sqrt( fDofT * fMotionBlurTaps ) / sqrt( fMotionBlurTaps );        \n        \n        vTapUV += vec2( sin(fTheta), cos(fTheta) ) * fRadius;\n        \n        vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n\t    //vec4 vTapTexel = texelFetch( iChannel0, ivec2(vTapUV.xy * iResolution.xy), 0 ).rgba;\n        \n        int iTapObjectId;\n        float fTapDepth = DecodeDepthAndObjectId( vTapSample.w, iTapObjectId );\n        \n        if ( fTapDepth > 0.0 )\n        {            \n  \t\t  \tfloat fCurrCoC = GetCoC( fTapDepth, fPlaneInFocus );\n            \n            float fCurrWeight = max( 0.001, fCurrCoC );\n            \n    \t\tvResult += vTapSample.rgb * fCurrWeight;\n        \tfTot += fCurrWeight;\n        }\n        f += 1.0;\n        fIndex += 1.0;\n    }\n#endif    \n    vResult /= fTot;\n    \n\tfragColor = vec4(vResult, 1.0);        \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n//    _____             _    ______ __   __  ____   _                                      _____  _          _        \n//   |  __ \\           | |  |  ____|\\ \\ / / |  _ \\ | |                            ___     / ____|| |        | |       \n//   | |__) |___   ___ | |_ | |__    \\ V /  | |_) || |  ___    ___   _ __ ___    ( _ )   | (___  | |_  __ _ | |_  ___ \n//   |  ___// _ \\ / __|| __||  __|    > <   |  _ < | | / _ \\  / _ \\ | '_ ` _ \\   / _ \\/\\  \\___ \\ | __|/ _` || __|/ _ \\\n//   | |   | (_) |\\__ \\| |_ | |      / . \\  | |_) || || (_) || (_) || | | | | | | (_>  <  ____) || |_| (_| || |_|  __/\n//   |_|    \\___/ |___/ \\__||_|     /_/ \\_\\ |____/ |_| \\___/  \\___/ |_| |_| |_|  \\___/\\/ |_____/  \\__|\\__,_| \\__|\\___|\n//                                                                                                                    \n//                                                                                                                    \n                                                             \n\n#define ENABLE_TAA_JITTER\n\n#define FLY_CAM_INVERT_Y 1\n\n#define iChannelState\t\t\tiChannel1\n#define iChannelKeyboard \t\tiChannel3\n\n\n//    _____ _          ____                \n//   |  ___| |_   _   / ___|__ _ _ __ ___  \n//   | |_  | | | | | | |   / _` | '_ ` _ \\ \n//   |  _| | | |_| | | |__| (_| | | | | | |\n//   |_|   |_|\\__, |  \\____\\__,_|_| |_| |_|\n//            |___/                        \n//\n\nstruct FlyCamState\n{\n    vec3 vPos;\n    vec3 vAngles;\n    vec4 vPrevMouse;\n};\n\nvoid FlyCam_LoadState( out FlyCamState flyCam, sampler2D sampler, ivec2 addr )\n{\n    vec4 vPos = LoadVec4( sampler, addr + ivec2(0,0) );\n    flyCam.vPos = vPos.xyz;\n    vec4 vAngles = LoadVec4( sampler, addr + ivec2(1,0) );\n    flyCam.vAngles = vAngles.xyz;\n    vec4 vPrevMouse = LoadVec4( sampler, addr + ivec2(2,0) );    \n    flyCam.vPrevMouse = vPrevMouse;\n}\n\nvoid FlyCam_StoreState( ivec2 addr, const in FlyCamState flyCam, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    StoreVec4( addr + ivec2(0,0), vec4( flyCam.vPos, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(1,0), vec4( flyCam.vAngles, 0 ), fragColor, fragCoord );\n    StoreVec4( addr + ivec2(2,0), vec4( iMouse ), fragColor, fragCoord );\n}\n\nvoid FlyCam_GetAxes( FlyCamState flyCam, out vec3 vRight, out vec3 vUp, out vec3 vForwards )\n{\n    vec3 vAngles = flyCam.vAngles;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0, cos(vAngles.x), sin(vAngles.x), \n                     0.0, -sin(vAngles.x), cos(vAngles.x));\n    \n    mat3 rotY = mat3(cos(vAngles.y), 0.0, -sin(vAngles.y), \n                     0.0, 1.0, 0.0, \n                     sin(vAngles.y), 0.0, cos(vAngles.y));    \n\n    mat3 rotZ = mat3(cos(vAngles.z), sin(vAngles.z), 0.0,\n                     -sin(vAngles.z), cos(vAngles.z), 0.0,\n                     0.0, 0.0, 1.0 );\n    \n    \n    mat3 m = rotY * rotX * rotZ;\n    \n    vRight = m[0];\n    vUp = m[1];\n    vForwards = m[2];\n}\n\nvoid FlyCam_Init( inout FlyCamState flyCam, vec3 vStartPos, vec3 vStartAngles )\n{\n    if ( iFrame == 0 )\n    {\n        flyCam.vPos = vStartPos;\n        flyCam.vAngles = vStartAngles;\n        flyCam.vPrevMouse = iMouse;    \n    }\n}\n\nvoid FlyCam_Update( inout FlyCamState flyCam )\n{    \n    //float fMoveSpeed = 0.01;\n    float fMoveSpeed = iTimeDelta * 0.5;\n    float fRotateSpeed = 3.0;\n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_SHIFT ) )\n    {\n        fMoveSpeed *= 4.0;\n    }\n          \n    vec3 vMove = vec3(0.0);\n        \n    if ( Key_IsPressed( iChannelKeyboard, KEY_W ) )\n    {\n        vMove.z += fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_S ) )\n    {\n        vMove.z -= fMoveSpeed;\n    }\n\n    if ( Key_IsPressed( iChannelKeyboard, KEY_A ) )\n    {\n        vMove.x -= fMoveSpeed;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_D ) )\n    {\n        vMove.x += fMoveSpeed;\n    }\n    \n    vec3 vForwards, vRight, vUp;\n    FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n        \n    flyCam.vPos += vRight * vMove.x + vForwards * vMove.z;\n    \n    vec3 vRotate = vec3(0);\n    \n    bool bMouseDown = iMouse.z > 0.0;\n    bool bMouseWasDown = flyCam.vPrevMouse.z > 0.0;\n    \n    if ( bMouseDown && bMouseWasDown )\n    {\n    \tvRotate.yx += ((iMouse.xy - flyCam.vPrevMouse.xy) / iResolution.xy) * fRotateSpeed;\n    }\n    \n#if FLY_CAM_INVERT_Y    \n    vRotate.x *= -1.0;\n#endif    \n    \n    if ( Key_IsPressed( iChannelKeyboard, KEY_E ) )\n    {\n        vRotate.z -= fRotateSpeed * 0.01;\n    }\n    if ( Key_IsPressed( iChannelKeyboard, KEY_Q ) )\n    {\n        vRotate.z += fRotateSpeed * 0.01;\n    }\n        \n\tflyCam.vAngles += vRotate;\n    \n    flyCam.vAngles.x = clamp( flyCam.vAngles.x, -PI * .5, PI * .5 );\n}\n\n\n\n///////////////////////////////////////////////\n\nvec3 GetBloom( vec2 vBloomSize, vec2 vBloomCoord, vec2 vUV )\n{\n    vec3 vResult = vec3(0);\n    \n    #define KERNEL_SIZE 8\n    #define BLOOM_STRENGTH 16.0\n    #define KERNEL_SIZE_F float(KERNEL_SIZE)     \n    \n    float fTot = 0.0;\n    \n    {\n        float fY = -KERNEL_SIZE_F;\n        for( int y=-KERNEL_SIZE; y<=KERNEL_SIZE; y++ )\n        {\n            float fX = -KERNEL_SIZE_F;\n            for( int x=-KERNEL_SIZE; x<=KERNEL_SIZE; x++ )\n            {            \n\n                vec2 vOffset = vec2( fX, fY );\n                vec2 vTapUV =  (vBloomCoord.xy + vOffset + 0.5) / vBloomSize;\n\n                vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n                if( vTapUV.y < 1.0 / iResolution.y )\n                {\n                   vTapSample = vec4(0.0);\n                }\n\n                vec2 vDelta = vOffset / KERNEL_SIZE_F;\n\n                float f = dot( vDelta, vDelta );\n                float fWeight = exp2( -f * BLOOM_STRENGTH );\n                vResult += vTapSample.xyz * fWeight;\n                fTot += fWeight;\n\n                fX += 1.0;\n            }\n\n            fY += 1.0;\n        }\n    }\n\n    #define HORIZONTAL_BLUR_SIZE 128\n    #define HORIZONTAL_BLOOM_STRENGTH 128.0\n    \n    \n    {\n        float fY = 0.0;\n        float fX = -float(HORIZONTAL_BLUR_SIZE);\n        for( int x=-HORIZONTAL_BLUR_SIZE; x<=HORIZONTAL_BLUR_SIZE; x++ )\n        {            \n\n            vec2 vOffset = vec2( fX, fY );\n            vec2 vTapUV =  (vBloomCoord.xy + vOffset + 0.5) / vBloomSize;\n\n            vec4 vTapSample = textureLod( iChannel0, vTapUV, 0.0 ).rgba;\n            if( vTapUV.y < 1.0 / iResolution.y )\n            {\n                vTapSample = vec4(0.0);\n            }\n\n            vec2 vDelta = vOffset / float(HORIZONTAL_BLUR_SIZE);\n\n            float f = dot( vDelta, vDelta );\n            float fWeight = exp2( -f * HORIZONTAL_BLOOM_STRENGTH );\n            vResult += vTapSample.xyz * fWeight;\n            fTot += fWeight;\n\n            fX += 1.0;\n        }\n    }\n    \n    \n    vResult /= fTot; \n \n    return vResult;\n}\n\n    \nstruct StageState\n{\n    int stageId;\n    float fSceneTime;\n    float fBegin;\n    float fTime;\n    float fLength;\n    float fFraction;\n};\n  \n\n\nconst vec3 vCamEyeStart = vec3(-0.28, 0.0116, 0.15);\nconst vec3 vCamEyePanOut = vec3(-0.3, 0.0116, 0.4);\nconst vec3 vCamEyePanSide = vec3(-0.55, 0.004, 0.25);\nconst vec3 vCamLeftSidePosA = vec3(-0.84, -0.2, 0.9885);    \nconst vec3 vCamFrontPosA = vec3(0.3538, -0.0675, 1.5351);\nconst vec3 vCamAbove = vec3(-1.04, 1.22, 1.74);\nconst vec3 vCamNose = vec3(0.2971, -0.4393, 0.8276);\n\t\n\nconst vec3 vTargetEyeStart = vec3(-0.28, 0.0116, 0.14);\nconst vec3 vTargetEye = vec3(-0.3, 0.0116, 0.14);\nconst vec3 vTargetEyeSide = vec3(-0.3, -0.01, 0.05);\nconst vec3 vTargetLeftSidePosA = vec3(-0.02727, -0.1839, -0.2 );\nconst vec3 vTargetFrontPosA = vec3(-0.02727, -0.1839, -0.2 );\nconst vec3 vTargetNose = vec3( 0.0717, -0.3134, 0.2846 );\n\nconst vec3 vFocusEye = vec3(-0.28, 0.0116, 0.12);\nconst vec3 vFocusLeftSidePosA = vec3(0.3201, 0.0095, 0.1174 );\nconst vec3 vFocusFrontPosA = vec3(0.0901, -0.1431, 0.1837 );\nconst vec3 vFocusNose = vec3( 0.0717, -0.3134, 0.2846 );\n\nconst int\n    LOOK_MODE_FORWARDS = 0,\n    LOOK_MODE_CAM = 1,\n    LOOK_MODE_RANDOM = 2;\n\nconst int\n    HEAD_MODE_FORWARDS = 0,\n    HEAD_MODE_TRACK = 1;\n\nstruct ShotState\n{\n    vec3 vCam;\n    vec3 vTarget;\n    vec3 vFocus;\n    int lookMode;\n    int headMode;\n    float fov;\n};\n\nconst ShotState shotStateZoomInOnEye = ShotState\n(\n    vCamEyeStart, \t\t// vec3 vCamStart;\n    vTargetEyeStart, \t\t// vec3 vTargetStart;\n    vFocusEye, \n    LOOK_MODE_FORWARDS, // int lookModeStart;\n    HEAD_MODE_FORWARDS, // int headModeStart;\n    15.0\n);    \n\n    \nconst ShotState shotStateEyePanOut = ShotState\n(\n    vCamEyePanOut, \t\t// vec3 vCamStart;\n    vTargetEye, \t\t// vec3 vTargetStart;\n    vFocusEye, \n    LOOK_MODE_FORWARDS, // int lookModeStart;\n    HEAD_MODE_FORWARDS, // int headModeStart;\n    15.0\n); \n\n    \nconst ShotState shotStateEyeLookAround = ShotState\n(\n    vCamEyePanOut, \t\t// vec3 vCamStart;\n    vTargetEye, \t\t// vec3 vTargetStart;\n    vFocusEye, \n    LOOK_MODE_RANDOM, \t// int lookModeStart;\n    HEAD_MODE_FORWARDS, // int headModeStart;\n    15.0\n);\n\nconst ShotState shotStateSidePosRandom = ShotState\n(\n    vCamEyePanSide, \t// vec3 vCamStart;\n    vTargetEyeSide, \t// vec3 vTargetStart;    \n    vFocusEye,     \n    LOOK_MODE_RANDOM, \t// int lookModeStart;    \n    HEAD_MODE_FORWARDS, // int headModeStart;    \n    15.0\n);\n\nconst ShotState shotStateSidePosEyeLookAtCam = ShotState\n(\n    vCamLeftSidePosA,\n    vTargetLeftSidePosA,    \n    vFocusLeftSidePosA,\n    LOOK_MODE_CAM,    \n    HEAD_MODE_FORWARDS,\n    15.0\n);\n\nconst ShotState shotStateSidePosHeadTurn = ShotState\n(\n    vCamLeftSidePosA,\n    vTargetLeftSidePosA, \n    vFocusLeftSidePosA,\n    LOOK_MODE_CAM,    \n    HEAD_MODE_TRACK,\n    15.0\n);\n\nconst ShotState shotStateFrontPosLookAtCam = ShotState\n(\n    vCamFrontPosA,\n    vTargetFrontPosA,\n    vFocusFrontPosA,\n    LOOK_MODE_CAM, \n    HEAD_MODE_TRACK,\n    15.0\n);\n\n\nconst ShotState shotStateFrontPosLookRandom = ShotState\n(\n    vCamFrontPosA,\n    vTargetFrontPosA, \n    vFocusFrontPosA,\n    LOOK_MODE_RANDOM,    \n    HEAD_MODE_TRACK,\n    15.0\n);\n\n\nconst ShotState shotStateAboveRandom = ShotState\n(\n    vCamAbove,\n    vTargetFrontPosA,    \n    vFocusFrontPosA,\n    LOOK_MODE_RANDOM,    \n    HEAD_MODE_TRACK,\n    15.0\n);\n\nconst ShotState shotStateAboveCam = ShotState\n(\n    vCamAbove,\n    vTargetFrontPosA,\n    vFocusFrontPosA,\n    LOOK_MODE_CAM,    \n    HEAD_MODE_TRACK,\n    15.0\n);\n\nconst ShotState shotStateNose = ShotState\n(\n    vCamNose,\n    vTargetNose, \n    vFocusNose,\n    LOOK_MODE_CAM,    \n    HEAD_MODE_TRACK,\n    15.0\n);\n\nvec3 GetRandomLookDir( float fSceneTime )\n{\n    return vec3( sin(fSceneTime) * 1.0, -0.1 + sin(fSceneTime * 0.456) * 0.5, 2.0);\n}\n\nvec3 GetRandomLookDirDarting( float fSceneTime )\n{\n    float fT = fSceneTime * 0.5;\n    \n    float fTimeA = floor( fT );\n    float fTimeB = fTimeA + 1.0;\n    \n    float fTimeFrac = fract( fT );\n    \n    vec3 vDirA = GetRandomLookDir( fTimeA );\n    vec3 vDirB = GetRandomLookDir( fTimeB );\n    \n    float t = smoothstep( 0.8, 1.0, fTimeFrac );\n    \n    return mix(vDirA, vDirB, t);\n}\n\n\nvec3 GetAnimTarget( int lookMode, float fSceneTime, vec3 vCamPos )\n{\n    vec3 vTarget;\n    switch( lookMode )\n    {\n        default:\n        case LOOK_MODE_FORWARDS:\n        \tvTarget = vec3( 0.0, 0.0, 2.0);        \t\n        break;\n        \n        case LOOK_MODE_CAM:\n        \tvTarget = vCamPos;\n        break;\n        \n        case LOOK_MODE_RANDOM:\n        \tvTarget = GetRandomLookDirDarting( fSceneTime );\n        break;\n    }\n    \n    return vTarget;\n}\n\nvec3 GetAnimHeadAngles( int headMode, AnimState animState )\n{\n    vec3 vHeadAngles = vec3(0);\n    \n    switch( headMode )\n    {\n        default:\n        case HEAD_MODE_FORWARDS:\n        break;\n        \n        case HEAD_MODE_TRACK:\n\t\t\tvHeadAngles = vec3( animState.vEyeTarget.y * 0.075, -animState.vEyeTarget.x * 0.05, -animState.vEyeTarget.x * 0.05 * 0.1 );\n        break;\n    }\n    \n    return vHeadAngles;\n}\n\nvoid GenericShot( StageState stageState, inout CameraState cam, inout AnimState animState, ShotState start, ShotState end )\n{\n    float t = smoothstep( 0.0, 1.0, stageState.fFraction );\n\n    cam.vPos = mix( start.vCam, end.vCam, t );    \n    cam.vTarget = mix( start.vTarget, end.vTarget, t );   \n        \n    vec3 vLookStart = GetAnimTarget( start.lookMode, stageState.fSceneTime, cam.vPos );\n    vec3 vLookEnd = GetAnimTarget( end.lookMode, stageState.fSceneTime, cam.vPos );\n    \n    animState.vEyeTarget = mix(vLookStart, vLookEnd, t);\n    \n    vec3 vHeadAnglesStart = GetAnimHeadAngles( start.headMode, animState );\n    vec3 vHeadAnglesEnd = GetAnimHeadAngles( end.headMode, animState );\n            \n    animState.vHeadAngles = mix( vHeadAnglesStart, vHeadAnglesEnd, t );\n        \n    vec3 vFocus = mix( start.vFocus, end.vFocus, t );\n    vec3 vToFocus = cam.vPos - vFocus;\n    vec3 vCamDir = normalize( cam.vTarget - cam.vPos );\n    cam.fPlaneInFocus = dot(vCamDir, vToFocus);\n}\n\nvoid SceneAnimation( float fTime, inout CameraState cam, inout AnimState animState )\n{\n    const int \n        STAGE_BEGIN = 0,\n        STAGE_B = 1,\n        STAGE_C = 2,\n        STAGE_D = 3,\n        STAGE_E = 4,\n        STAGE_F = 5,\n        STAGE_G = 6,\n        STAGE_H = 7,\n        STAGE_I = 8,\n        STAGE_J = 9,\n        STAGE_K = 10,\n        STAGE_L = 11,\n        STAGE_M = 12,\n        STAGE_BLEND_FINAL = 98,\n        STAGE_END = 99;\n\n    struct AnimStage\n    {\n        int stageId;\n        float fLength;\n    };\n\n    AnimStage g_animStages[] = AnimStage[]\n    (\n        AnimStage( STAGE_BEGIN, 13.0 ),\n        AnimStage( STAGE_B, 8.0 ),\n        AnimStage( STAGE_C, 10.0 ),\n        AnimStage( STAGE_D, 10.0 ),\n        AnimStage( STAGE_E, 3.0 ),\n        AnimStage( STAGE_F, 5.0 ),\n        AnimStage( STAGE_G, 10.0 ),\n        AnimStage( STAGE_H, 2.0 ),\n        AnimStage( STAGE_I, 2.0 ),\n        AnimStage( STAGE_J, 10.0 ),\n        AnimStage( STAGE_K, 10.0 ),\n        AnimStage( STAGE_L, 5.0 ),\n        AnimStage( STAGE_M, 5.0 ),\n        AnimStage( STAGE_BLEND_FINAL, 5.0 ),\n        \n\n        AnimStage( STAGE_END, 100.0 )\n    );\n    \n    StageState stageState;\n    stageState.fSceneTime = fTime;\n    stageState.stageId = STAGE_END;\n    stageState.fBegin = 0.0f;\n    stageState.fTime = 0.0f;\n    stageState.fLength = 1.0f;\n    stageState.fFraction = 0.0f;\n\n    float fStageBegin = 0.0f;\n    \n    for ( int stageIndex = 0; stageIndex < g_animStages.length(); stageIndex++ )\n    {\n        AnimStage stage = g_animStages[stageIndex];\n        float fStageTime = fTime - fStageBegin;\n        \n        if ( fStageTime >= 0.0 && fStageTime < stage.fLength )\n        {\n            stageState.stageId = stage.stageId;\n            stageState.fBegin = fStageBegin;\n            stageState.fTime = fStageTime;\n            stageState.fLength = stage.fLength;\n            stageState.fFraction = stageState.fTime / stage.fLength;\n            break;\n        }\n        \n        fStageBegin += stage.fLength;\n    }\n    \n       \n    ShotState shotOrbit;\n    \n    float d = 1.0 + (cos( fTime * 0.1323 ) * 0.5 + 0.5) * 1.5;\n    float xr = sin( fTime * 0.1345 ) * PI * 0.3;\n    float yr = cos( fTime * 0.08913 ) * PI * 0.1;\n    shotOrbit.vTarget = vec3(0,-0.2,-0.6);\n\tshotOrbit.vCam = shotOrbit.vCam + vec3(sin(xr) * cos( yr ), sin(yr), cos(xr) * cos( yr ))  * d;    \n    shotOrbit.vFocus = shotOrbit.vTarget;\n    shotOrbit.lookMode = LOOK_MODE_CAM;\n\tshotOrbit.headMode = HEAD_MODE_FORWARDS;\n\tfloat l = length( shotOrbit.vCam - shotOrbit.vTarget);\n    shotOrbit.fov = 15.0 / ( 1.0 + l * 0.1 );\n\n    switch( stageState.stageId )\n    {\n        case STAGE_BEGIN:\n        \tGenericShot( stageState, cam, animState, shotStateZoomInOnEye, shotStateEyePanOut );\n        break;\n        \n        case STAGE_B:\n        \tGenericShot( stageState, cam, animState, shotStateEyePanOut, shotStateEyeLookAround );\n        break;\n        \n        case STAGE_C:        \n        \tGenericShot( stageState, cam, animState, shotStateEyeLookAround, shotStateSidePosRandom );\n        break;\n        \n        case STAGE_D:    \n        \tGenericShot( stageState, cam, animState, shotStateSidePosRandom, shotStateSidePosEyeLookAtCam );\n        break;\n\n        case STAGE_E:        \n        \tGenericShot( stageState, cam, animState, shotStateSidePosEyeLookAtCam, shotStateSidePosHeadTurn );\n        break;\n        \n        case STAGE_F:        \n        \tGenericShot( stageState, cam, animState, shotStateSidePosHeadTurn, shotStateFrontPosLookAtCam );\n        break;\n        \n        case STAGE_G:        \n        \tGenericShot( stageState, cam, animState, shotStateFrontPosLookAtCam, shotStateFrontPosLookRandom );\n        break;\n        \n        case STAGE_H:                \n        \tGenericShot( stageState, cam, animState, shotStateAboveRandom, shotStateAboveCam );\n        break;\n        \n        case STAGE_I:                \n        \tGenericShot( stageState, cam, animState, shotStateAboveCam, shotStateAboveCam );\n        break;        \n\n        case STAGE_J:                \n        \tGenericShot( stageState, cam, animState, shotStateAboveCam, shotStateFrontPosLookAtCam );\n        break;        \n\n        case STAGE_K:                \n        \tGenericShot( stageState, cam, animState, shotStateFrontPosLookAtCam, shotStateFrontPosLookRandom );\n        break;        \n\n        case STAGE_L:                \n        \tGenericShot( stageState, cam, animState, shotStateFrontPosLookRandom, shotStateNose );\n        break;        \n\n        case STAGE_M:                \n        \tGenericShot( stageState, cam, animState, shotStateNose, shotStateNose );\n        break;   \n        \n        case STAGE_BLEND_FINAL:\n        \tGenericShot( stageState, cam, animState, shotStateNose, shotOrbit );\n            cam.fPlaneInFocus = -1.0;\n        break;\n\n        case STAGE_END:\n        {            \n        \tGenericShot( stageState, cam, animState, shotOrbit, shotOrbit );\n            cam.fPlaneInFocus = -1.0;\n            \n            float fEyeTime = fTime;\n            float fEyeModeTime = fTime / 10.0;\n            int fEyeModeNow = int( floor( fEyeModeTime ) );\n            int fEyeModeNext = fEyeModeNow + 1;\n            \n            int lookModeCurr = ((fEyeModeNow % 2) == 0) ? LOOK_MODE_CAM : LOOK_MODE_RANDOM;\n            int lookModeNext = ((fEyeModeNext % 2) == 0) ? LOOK_MODE_CAM : LOOK_MODE_RANDOM;\n            \n            vec3 vTargetCurr = GetAnimTarget( lookModeCurr, fTime, cam.vPos );\n            vec3 vTargetNext = GetAnimTarget( lookModeNext, fTime, cam.vPos );\n            \n            float t = clamp( mod( fEyeModeTime, 10.0), 0.0, 1.0 );\n\t\t\tanimState.vEyeTarget = mix(vTargetCurr, vTargetNext, t);\n\t\t\tanimState.vHeadAngles =  GetAnimHeadAngles( HEAD_MODE_FORWARDS, animState );\n        }\n        break;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 gBloomSize = min( vec2(320.0, 240.0), iResolution.xy );\n    vec2 vBloomSize = iResolution.xy / 4.0;//min( vec2(320.0, 240.0), iResolution.xy );\n    \n    vec2 vBloomCoord = fragCoord.xy;\n    vBloomCoord.y -= 1.0;\n    \n\tvec2 vUV = vBloomCoord.xy / vBloomSize;\n    \n    if ( vUV.x > 1.0 || vUV.y > 1.0 ) \n    {\n        discard;\n        return;\n    }\n\n    // output linear color\n    //fragColor = texture( iChannel0, vUV );\n    //return;\n   \n\n\tvec3 vResult = vec3(0.0);\n    \n    vResult = GetBloom( vBloomSize, vBloomCoord, vUV );\n    \n    \n    vec4 vPrevSample = texelFetch( iChannel1, ivec2(fragCoord), 0 ).rgba;\n    vResult = max( vResult, vPrevSample.xyz * vec3(0.5, 0.6, 0.7) );\n\n/*\n    ivec2 iFragCoord = ivec2( fragCoord.xy );\n    if( iFragCoord.y == 0 )\n    {\n     \tvResult = vec3(1000.0); \n    }\n*/\n    fragColor = vec4(vResult, 1.0);\n    \n    // State Update...\n    \n\n    float fReduction = 1.0;\n    if ( Key_IsToggled( iChannelKeyboard, KEY_R ) )\n    {\n        //fReduction = clamp( 30.0 * iTimeDelta - 0.5, 1.0, 4.0 );\n    \tfReduction = 4.0f;\n    }\n    vec2 vReducedResolution = iResolution.xy / fReduction;    \n\n    ivec2 iAddr = ivec2(fragCoord.xy);\n    \n    if ( iAddr.y != 0 ) return;\n    \n    // Setup Cam\n    CameraState cam;\n    AnimState animState;\n    \n    // Set defaults\n    cam.vPos = vec3(0,0.1,3.0);\n    cam.vTarget = vec3(0,-0.25, 0);\n    cam.vUp = vec3(0,1,0);\n    cam.fFov = 15.0;\n    cam.fPlaneInFocus = length(cam.vTarget - cam.vPos);\n    cam.vJitter = vec2(0.0);        \n    \n\tanimState.vEyeTarget = cam.vPos;\n    animState.vHeadAngles = vec3(0);\n\n        \n    SceneAnimation( iTime, cam, animState );\n    \n    \n    // Update FlyCam\n    FlyCamState flyCam;\n    FlyCam_LoadState( flyCam, iChannelState, ivec2(8,0) );\n    \n\tFlyCam_Init( flyCam, vec3(-0.1, 0.2, 3.5), vec3(.1, PI, 0) );\n    \n    if ( Key_IsToggled( iChannelKeyboard, KEY_SPACE ) )\n    {\n\t\tFlyCam_Update( flyCam );\n        \n        vec3 vForwards, vRight, vUp;\n        FlyCam_GetAxes( flyCam, vRight, vUp, vForwards );\n\n        cam.vPos = flyCam.vPos;\n        cam.vTarget = flyCam.vPos + vForwards;\n        cam.vUp = vUp;\n        cam.fPlaneInFocus = length(flyCam.vPos);        \n        \n        vec3 vEyeTarget = cam.vPos;\n        if ( Key_IsToggled( iChannelKeyboard, KEY_F ) )\n        {\n            vEyeTarget = GetRandomLookDirDarting( iTime );\n        }       \n\n        animState.vEyeTarget = vEyeTarget;\n\n        float xr = vEyeTarget.y * 0.075;\n        float yr = -vEyeTarget.x * 0.05;\n\n        if ( Key_IsToggled( iChannelKeyboard, KEY_G ) )\n        {\n            xr = 0.0;\n            yr = 0.0;\n        }\n\n        animState.vHeadAngles = vec3( xr, yr, yr * 0.1 );\n        \n        cam.fPlaneInFocus = -1.0; // auto focus\n    }    \n    else\n    {\n\t\tflyCam.vPos = cam.vPos;\n    }\n    \n#ifdef ENABLE_TAA_JITTER\n    cam.vJitter = hash21( fract( iTime ) ) - 0.5f;\n#endif    \n\n\tCam_StoreState( ivec2(0), cam, fragColor, iAddr );    \n\t//Cam_StoreState( ivec2(4,0), camPrev, fragColor, iAddr );    \n    FlyCam_StoreState( ivec2(8,0), flyCam, fragColor, iAddr );\n    \n    StoreVec4( ADDR_RESOLUTION, vec4( vReducedResolution,0,0 ), fragColor, iAddr );\n    \n    AnimState_StoreState( ADDR_ANIMSTATE, animState, fragColor, iAddr );       \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//    _    _ _____  _____     _____      _                                \n//   | |  | |  __ \\|  __ \\   / ____|    | |                               \n//   | |__| | |  | | |__) | | |    _   _| |__   ___ _ __ ___   __ _ _ __  \n//   |  __  | |  | |  _  /  | |   | | | | '_ \\ / _ \\ '_ ` _ \\ / _` | '_ \\ \n//   | |  | | |__| | | \\ \\  | |___| |_| | |_) |  __/ | | | | | (_| | |_) |\n//   |_|  |_|_____/|_|  \\_\\  \\_____\\__,_|_.__/ \\___|_| |_| |_|\\__,_| .__/ \n//                                                                 | |    \n//                                                                 |_|    \n\n// Convert a shadertoy LDR cubemap to HDR\n// This at least gives us linear HDR filtering and mipmaps\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    if ( iFrame > 120 )\n        discard;\n    fragColor = textureLod( iChannel0, rayDir, 0.0 );\n    fragColor = fragColor * fragColor;\n    float kEnvmapExposure = 0.999;\n    fragColor = -log2(1.0 - fragColor * kEnvmapExposure);    \n    return;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Cube A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 41
                    }
                ],
                "type": "cubemap"
            }
        ],
        "ver": "0.1"
    }
}