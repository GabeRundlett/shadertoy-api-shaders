{
    "Shader": {
        "info": {
            "date": "1478714236",
            "description": "\"pseudo\" buggy steelball physics.\nCollision calculation needs some more work :)\nHeavily relying on: https://www.shadertoy.com/view/XdtSWn\nmusic: https://soundcloud.com/virgill/virgill-just-chip-it",
            "flags": 96,
            "hasliked": 0,
            "id": "lt3Xz7",
            "likes": 19,
            "name": "Steelball physics",
            "published": 3,
            "tags": [
                "balls",
                "spheretracing",
                "physics"
            ],
            "usePreview": 0,
            "username": "Virgill",
            "viewed": 1528
        },
        "renderpass": [
            {
                "code": "// 3d ball physics\n// heavyly relying on this shader by hubbe:\n// https://www.shadertoy.com/view/XdtSWn\n\n// music: https://soundcloud.com/virgill/virgill-just-chip-it\n\n\n\n\n\n\nconst float GA =2.39; \n\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec3 dof(sampler2D tex,vec2 uv,float rad)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.002*iResolution.y/iResolution.x,.002),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<80;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\n// awesome bokeh dof by Dave Hoskins\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float zed)\n{\n\tvec3 acc = vec3(0.0), div = acc;\n    vec2 pixel = vec2(.002 *iResolution.y /iResolution.x, .002);\n    float r = 1.0;\n    vec2 vangle = vec2(0.0,radius); \n    for (int j = 0; j < 80; j++)\n    {  \n        r += 1. / r;\n\t    vangle *= rot;\n        vec4 col = texture(tex, uv + pixel * (r-1.) * vangle);\n        float dim = smoothstep(150.0, -10., zed-col.w);\n\t\tvec3 bokeh = (pow(col.xyz, vec3(9.0)) * 20.+.5) * dim;\n\t\tacc += col.xyz * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n\tfragColor=vec4(Bokeh(iChannel0,uv,texture(iChannel0,uv).w,1.),1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "musicstream",
                        "id": 12137,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/virgill-just-chip-it"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// 3d ball physics\n// heavyly relying on this shader by hubbe:\n// https://www.shadertoy.com/view/XdtSWn\n\n#define maxballs 20\n#define radius 0.253\n\n\n\n// Return a \"random\" number.\nfloat rand(vec2 co)\n{\n    float a = 12.9898;\n    float b = 78.233;\n    float c = 43758.5453;\n    float dt= dot(co.xy ,vec2(a,b));\n    float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;   \n    vec3 pos = vec3(0);\n    vec3 spd = vec3(0);\n  \n    if ((fract(iTime/4.57))<=0.01)\n    {\n        pos.x= 4.*rand(-uv+iTime)-1.5;\n    \tpos.y= 1.*rand( uv+iTime)-2.5;\n        pos.z= 2.*rand(-uv.yx+iTime)-1.; \n        spd.x=.09*rand( uv+iTime);\n        spd.y=.09*rand(-uv+iTime);\n        spd.z=.09*rand( uv.yx+iTime);\n    }    \n    \n    else \n    {\n        \n    \tpos = texture(iChannel0, vec2(float(uv.x),0.)).xyz; // get position\n\t\tspd = texture(iChannel0, vec2(float(uv.x),1.)).xyz; // get speed     \n        \n//\t\tcalculate touching balls :-)        \n    \tfor (int i = 0; i<maxballs;i++)\n    \t{\n    \t\tvec3 posother = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,0.)).xyz;\n            vec3 spdother = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,1.)).xyz;\n            if(pos==posother) continue;\n        \tfloat dista = length(posother - pos);\n        \tif (dista < radius * 2.0) \n        \t{\n            pos= pos + (posother-pos) * radius * 2.001 / dista;  \n            spd-=0.2*spdother;\n            }\n        }\n\n    pos.xyz -= spd.xyz;\n    spd.xyz *= 0.99;\n    spd.y -= 0.001;\n\n    // If we reach the bottom, invert the speed in the y direction.\n    if (pos.y >= 0.7) { spd.y = abs(spd.y * .7); }\n\n    // If we reach left/right wall, invert the speed in the x direction.         \n    if (pos.x >= 1.5) { spd.x = abs(spd.x * .7); }  \n    if (pos.x <= -1.5) { spd.x = -abs(spd.x * .7); }  \n        \n    // If we reach the bottom, invert the speed in the z direction.\n    if (pos.z >= 3.) { spd.z = abs(spd.z * .7); }\n    if (pos.z <= -2.) { spd.z = -abs(spd.z * .7); }\n\n       \n    }\n\n    if (fragCoord.y == 0.5) fragColor = vec4(pos,1.); // write position\n    else fragColor = vec4(spd,1.);  // write speed\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// 3d ball physics\n// heavyly relying on this shader by hubbe:\n// https://www.shadertoy.com/view/XdtSWn\n\n#define maxballs 20\n#define radius 0.25\n\n\n\n\n// \tpolyomial smooth min (IQ)\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// \texponential smooth min (IQ)\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// \tsphere\nfloat sphere(vec3 p, vec3 position)\n{\t\n\treturn length(p+position)-radius;\n}\n\nfloat map(vec3 p)\n{\t\n\tfloat f=1.0;\n    for (int i=0; i<maxballs; i++)\n    {\n        vec3 pos = texture(iChannel0, vec2((float(i)+0.5)/iResolution.x,0.)).xyz;\n    \tf = min (f,sphere(p,pos));\n    }\n    \n    f= min(f,p.y+0.9); //plane\nreturn f;\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.1;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.01;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<50;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n//\tsoftshadow (IQ)\nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    vec2 uv=fragCoord.xy/iResolution.xy; \n    vec2 p=uv*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n\t\n//  camera\n    vec3 org = vec3(sin(iTime*0.2),1.+sin(iTime),-3.); \n\tvec3 cw=normalize(vec3(0.,.25,0.)-org);\n    vec3 cu=normalize(cross(cw,vec3(0.,1.,0.)));\n\tvec3 dir=normalize(p.x*cu+ p.y*(cross(cu,cw))+2.5*cw);    \n\n// \tstandard sphere tracing:\n    vec3 color = vec3(0.);\n\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n \n// \tlighting:\n    vec3 lig=normalize(vec3(0.9*abs(cos(iTime*0.3)),1.*abs(sin(iTime*0.1)),0.9*-abs(sin(iTime))));\n\tlig = normalize (vec3(-0.5,1.,-0.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    vec3 pos2,nor2 =  vec3(0.);\n   \tif(t<6.0)\n    {\n    \tcolor = vec3(max(dot(lig,nor),0.0)  +1.* pow(max(dot(reflect(dir,nor),lig),0.),16.));\n     \n    \n// \treflections:\n\tvec3 org2 = pos-dir/t;\n\tvec3 dir2 = reflect(dir,nor);\n    float t2 = castRayx(org2, dir2);\n\tpos2 = org2 + dir2*t2;\n    nor2 = calcNormal(pos2);\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n\tfloat spec2 = pow(clamp(dot(reflect(dir2, nor2), lig), 0.0, 1.0), 16.0);\n\tcolor+= .9*vec3(dif2+spec2);\n        \n// \tshadow \n    color *=0.2+clamp(softshadow(pos,lig),0.,1.);      \n\t\n\t}\n\ncolor*=depth*depth+texture(iChannel1, vec2(0.1*nor.xy)).xyz;;\n\nfragColor = clamp(vec4(vec3(color),4.*(0.8-depth)),0.,1.);\n    \n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}