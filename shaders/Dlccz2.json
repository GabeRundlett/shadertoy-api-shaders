{
    "Shader": {
        "info": {
            "date": "1699399449",
            "description": "a",
            "flags": 0,
            "hasliked": 0,
            "id": "Dlccz2",
            "likes": 2,
            "name": "spqr planetary survey: ganymede",
            "published": 3,
            "tags": [
                "a"
            ],
            "usePreview": 0,
            "username": "spqr",
            "viewed": 180
        },
        "renderpass": [
            {
                "code": "// ANY and ALL adulation belongs to IQ, and his new sphere noise.\n// read about it here: https://iquilezles.org/articles/fbmsdf\n// see it in action in his shadertoy here: https://www.shadertoy.com/view/3dGSWR\n\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash31(float p) {\n\tvec3 p2 = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p2 += dot(p2.zxy, p2.xyz + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.x * 93.8365));\n}\n\nvec3 spline(vec3 a, vec3 b, vec3 c, vec3 d, float p)\n{\n    // CatmullRoms are cardinals with a tension of 0.5\n\tvec3 P = -a + (3. * (b - c)) + d;\n    vec3 Q = (2. * a) - (5. * b) + (4. * c) - d;\n    vec3 R = c - a;\n    vec3 S = 2. * b;\n\n\tfloat p2 = p * p;\n    float p3 = p * p2;\n\n    return .5 * ((P * p3) + (Q * p2) + (R * p) + S);\n}\n\nvec3 getPos ( float t) {\n\n  float n  = floor(t);\n  \n  \n\n\n float u = 1.;\n  \n  vec3 s = spline(\n      hash31(n)    * u,\n      hash31(n+1.) * u,\n      hash31(n+2.) * u,\n      hash31(n+3.) * u,\n      fract(t)\n   );\n \n  return vec3(s.x, s.y, s.z);\n}\n\nfloat rnd ( float t ) {\n  return fract( sin(t * 1841.63623 + 2714.23423));\n\n}\nvec2 unit ( float t ) {\n  float a =  fract( sin(t * 1841.63623 + 2714.23423))* 324.114;\n  float x = cos(a);\n  float y = sin(a);\n  return vec2(x,y);\n\n}\nfloat box (vec3 p, vec3 s) {\n  p = abs(p) -s ;\n  return max(p.x,max(p.y,p.z));\n}\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\nfloat repeat(float p, float s) {\n  return (fract(p/s-0.5)-0.5)*s;\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n} \nfloat sph(vec3 p, float r){\n  return length(p) - r;\n}\nfloat sph( vec3 i, vec3 f, vec3 c )\n{\n    // random radius at grid vertex i+c (please replace this hash by\n    // something better if you plan to use this for a real application)\n    vec3  p = 17.0*fract( (i+c)*0.3183099+vec3(0.11,0.17,0.13) );\n    float w = fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n    float r = 0.7*w*w;\n    // distance to sphere at grid vertex i+c\n    return length(f-c) - r; \n}\n\n// NuSan's improvement\nfloat sdBase(in vec3 p) {\nreturn length(fract(p)-0.5)-(0.3+dot(sin(p*vec3(2.21,1.13,1.7)),vec3(.2)));\n}\n/*\nfloat sdBase( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    return min(min(min(sph(i,f,vec3(0,0,0)),\n                       sph(i,f,vec3(0,0,1))),\n                   min(sph(i,f,vec3(0,1,0)),\n                       sph(i,f,vec3(0,1,1)))),\n               min(min(sph(i,f,vec3(1,0,0)),\n                       sph(i,f,vec3(1,0,1))),\n                   min(sph(i,f,vec3(1,1,0)),\n                       sph(i,f,vec3(1,1,1)))));\n}\n*/\nfloat tick( float t ) {\n  float i = floor(t);\n  float r = fract(t);\n  \n  for ( int n = 0; n < 4; n++) {\n    r = smoothstep(0.,1.,r);\n  }\n  return i + r;\n}\nvec2 sdFbm( in vec3 p, in float th, in float d )\n{\n    // rotation and 2x scale matrix\n    const mat3 m = mat3( 0.00,  1.60,  1.20,\n                        -1.60,  0.72, -0.96,\n                        -1.20, -0.96,  1.28 );\n    vec3  q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        if( d>s*0.866 ) break; // early exit\n        if( s<th ) break;      // lod\n        \n        float n = s*sdBase(q);\n        float porous = mix(0.02,0.2,sin(iTime/10.)*.5+0.5);  // default 0.1;\n        float y = 0.3;//(sin(iTime/24.) * 0.5 + 0.5) * .3 + .1;\n        n = smax(n,d-porous*s,y*s); // default 0.3\n        d = smin(n,d      ,y*s);    // default 0.3\n        q = m*q;\n        s = 0.415*s;\n     \n        t += d; \n        q.z += -4.33*t*s; // deform things a bit\n    }\n    return vec2( d, t );\n}    \n\n\n\n\nfloat fbm( in vec2 p )\n{\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=0; i<11; i++ )\n    {\n        float n = texture(iChannel1,p).x;\n        f += s*n;\n        p *= 2.01*mat2(4.0,-3.0,3.0,4.0)/5.0;\n        s *= 0.55;\n    }\n    return f;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//=========================================\n\nconst float precis = 0.0005;  // default 0.0005\n\nfloat cyl(vec2 p, float r) {\n  return length(p) - r;\n}\n\n\nvec2 off ( vec3 p) {\n  return vec2(sin(p.x/3.0), cos(p.y/4.1));\n}\nfloat layer (vec3 p, float r ) {\n  return length(p) -r ;\n}\nvec3 ro;\nvec3 ta;\nvec2 map( in vec3 p, in float dis )\n{\n    \n   \n    float spot = sph(p - ro   - vec3(0,0,2), .01); \n    \n    p.y *= .5; // default 1.0\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    d = p.y;\n    // terrain\n    vec2 dt = sdFbm( p, dis*precis, d );\n    //vec2 et = sdFbm( p, dis*precis, -d );\n   \n    //float hole = box(p - ro, vec3(1.));\n    //dt.x = max(dt.x, -hole);\n    dt.x = min(dt.x, spot);\n    return dt;\n    //return max(dt,-et);\n}\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t;\n    return normalize( e.xyy*map( pos + e.xyy, t ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t ).x );\n}\n\n\n\nmat2 rot ( float a ) {\n  float ca = cos(a);\n  float sa = sin(a);\n  return mat2(ca, sa, -sa, ca);\n}\nvec3 jump( float t ) {\n  float sc = 4.;\n  float y = sin(iTime);\n  vec2 a = unit(floor(t)) *sc *y;;\n  vec2 b = unit(floor(t)+1.)*sc*y;\n  \n  float height = 5.6 + sin(iTime);\n  return ( mix( vec3(a.x, height,a.y), vec3(b.x,height,b.y), fract(t)));  \n\n}\n\nvec2 offset (float t ) {\n  \n  t /= 1.;\n  float a = cos(t) + cos(t*2.1)/2.3 + cos(t*4.2)/ 4.1;\n  float b = cos(t*1.1) + cos(t*1.9)/1.7 + cos(t*4.)/ 3.6;\n \n  \n \n  return vec2(a,b)/10.;\n\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist,1.).x*3.0,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n \n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n\n       \n    float time = iTime * 1.3;\n\n\t// scene setup\n  \n    float cr, fl, fad;\n    \n  \n  \n    // navigation\n  \n    float n = time;   \n\n    vec3 fwd = vec3(0,0,1.) * iTime;\n    float ix = n * .37;\n \n    vec3 ro = getPos(ix)*4. + fwd;\n    vec3 ta = getPos(ix - 8.3141)*4. + fwd;\n    ro.y *= .5;\n    ta.y *= .1;\n    \n    ro.y += .3;\n    ta.y += .2;\n\n/* \n    vec3 pole = vec3( cos(tt), 0., sin(-tt) )* 1.2;   \n    ro = vec3(offset(n), tt);\n    ta = vec3(offset(n+1.), tt +2.*sin(iTime/4.1));\n    ro.y +=.5;\n    ro += pole;\n    ta += pole;\n*/    \n    \n   \n    \n\n    \n    // camera matrix\t\n    mat3 ca = setCamera( ro, ta, cr );\n    \n    vec3 rd = ca * normalize( vec3(p.xy,2.0));\n    \n   \n\n\n  \n\n    // raymarch\n    float t = 0.;\n    vec2 h = vec2(0.0,0.0);\n    bool hit = false;\n    vec3 pos;\n    float dd;\n    float i;\n\tfor( i=0.; i<300.; i++ )\n\t{\n        pos = ro + t*rd;\n        float flip = sign(map(pos,t).x);\n\t\th = map( pos, t )*flip;\n        if( abs(h.x)<.0001) {//(precis*t)) {\n          \n          hit = true;\n          break;\n        }\n       if (t>300.0 ) {\n          break;\n       }\n\t   t += h.x   * 1.; // overstepping\n       dd += t;\n\t}\n   \n\t\n   \n    vec3 nor = calcNormal( pos, t );\n    vec3 light = normalize(vec3(1,0,3));\n    light.xz *= rot(iTime*.31);\n    \n    float shade = dot(nor,light) + .45; \n    float ao = pow(1. - i/300.,8.);\n    \n    float spec= pow(max(dot(reflect(light,nor),-rd),.0), 17.);\n    //float sss = getsss(ro,rd,1.2);\n    vec3 col = vec3(1.,.5,.3);\n    col *= pow(shade,1.2);\n    col *= pow(ao,1.2) ;\n    //col += spec  ;\n    //col *= sss * 20.;\n    \n    float spot = length(pos - ((ro + vec3(0.,0.,2.))  ));\n    \n    \n    col += .001/pow(spot,10.) * vec3(.6,.5,1);\n   \n  \n    \n    if (! hit) {\n      col = vec3(.9,.2,.1) * rd.y/.4; \n    }\n    \n    // fog\n    col = mix(col, vec3(.3), i/2000.);\n  \n  \n   \n    col = pow(col,vec3(.35));\n    \n  \n    fragColor = vec4( col, 1.0 );\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}