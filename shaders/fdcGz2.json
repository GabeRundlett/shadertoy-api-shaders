{
    "Shader": {
        "info": {
            "date": "1630722847",
            "description": "sdfg",
            "flags": 32,
            "hasliked": 0,
            "id": "fdcGz2",
            "likes": 5,
            "name": "Simple little pt",
            "published": 3,
            "tags": [
                "srst"
            ],
            "usePreview": 0,
            "username": "MinimilisticBits",
            "viewed": 332
        },
        "renderpass": [
            {
                "code": "//NOT MY CODE//////////////////////\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.,1.);\n}\n\nvec3 tonemap_uchimura2(vec3 v)\n{\n    const float P = 1.0;  // max display brightness\n    const float a = 1.9;  // contrast\n    const float m = 0.1; // linear section start\n    const float l = 0.0;  // linear section length\n    const float c = 1.33; // black\n    const float b = 0.0;  // pedestal\n\n    float l0 = ((P - m) * l) / a;\n    float L0 = m - m / a;\n    float L1 = m + (1.0 - m) / a;\n    float S0 = m + l0;\n    float S1 = m + a * l0;\n    float C2 = (a * P) / (P - S1);\n    float CP = -C2 / P;\n\n    vec3 w0 = 1.0 - smoothstep(0.0, m, v);\n    vec3 w2 = step(m + l0, v);\n    vec3 w1 = 1.0 - w0 - w2;\n\n    vec3 T = m * pow(v / m, vec3(c)) + vec3(b);\n    vec3 S = P - (P - S1) * exp(CP * (v - S0));\n    vec3 L = m + a * (v - vec3(m));\n\n    return T * w0 + L * w1 + S * w2;\n}\n//////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n      float colw = texture(iChannel0, uv).w;\n\n   vec3 col = texture(iChannel0, uv).xyz/(colw+1.);\n   // d.yz = rot(d.yz, mouse.y*90.);\n  //  d.xy = rot(d.xy, -mouse.x*90.);\n    \n    // Time varying pixel color\n    \n    col = vec3(1.)-exp(-1.0*col);\n    //NOT MY CODE//////////////////\n    vec3 a = vec3(0.3,0.7,0.7)-0.4;\n    col = mix(col, smoothstep(0.,1.,col),a);\n    //////////////////////////////\n    // Output to screen\n    vec3 aa = vec3(1.0,1.1,1.7);\n    col = sqrt(col/aa);\n    col = (1.0/((1.0)+exp(-(10.)*(col-0.5))));\n    col = ACESFilm(col);\n    col = pow(col, vec3(1./2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n//NOT MY CODE///////////////\nuint wang_hash(inout uint seed)\n{\n//dunno, not mine\n//bit operations that give you a number between 0 and the maximum uint size which is\n//4294967296, dividing by the maximum gives you a number between 0 and 1\n\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat rndf(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\n\n///////////////////////////\n\nvec2 rot(vec2 a, float t){\n    float l = length(a);\n    a/=l;\n    float ang = (a.y < 0.)?2.*3.14159-acos(a.x):acos(a.x);\n    ang += t*3.14159/180.;\n    return vec2(cos(ang), sin(ang))*l;\n}\n\n\nfloat l = 0.;\nvec3 c = vec3(0.7);\n\n\nfloat box(vec3 p, vec3 s){\nvec3 a = abs(p)-s;\nreturn max(a.x,max(a.y,a.z));\n}\nfloat escape = 0.;\nfloat fractal(vec3 p0){\n//p0 = mod(p0, 2.)-1.;\n    vec4 p = vec4(p0, 1.);\n    escape = 0.;\n                                p.xyz=abs(p.xyz);\n                                uint seed = uint(p.x+p.y+p.z);\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z > p.y)p.zy = p.yz;\n        if(p.y > p.x)p.yx = p.xy;\n    for(int i = 0; i < 12; i++){\n        if(p.x < p.z)p.xz = p.zx;\n        if(p.z < p.y)p.zy = p.yz;\n        if(p.y < p.x)p.yx = p.xy;\n        \n        p.xyz = abs(p.xyz);\n\n        p*=((1.4+rndf(seed)*0.1)/clamp(dot(p.xyz,p.xyz),0.5,1.));\n        p.xyz-=vec3(0.2+rndf(seed)*0.2,0.6-rndf(seed)*0.3,2.3);\n        p*=1.2-rndf(seed)*0.4;\n\n        escape += exp(-0.2*dot(p.xyz,p.xyz));\n        //vec3 norm = normalize(p.xyz);\n        //float theta = acos(norm.z/length(norm.xyz));\n        //float phi = atan(norm.y/norm.x);\n        //escape = min(max(theta,phi),escape);\n    }\n    float m = 1.5;\n    p.xyz-=clamp(p.xyz,-m,m);\nreturn length(p.xyz)/p.w;\n}\n\n\n\n\n\nvec3 pal(float t, vec3 p){\nreturn 0.5 + 0.5*cos(2.*3.14159*t*0.9 + p);\n}\n\nfloat dis(vec3 p){\n    l = 0.;\n    c = vec3(.7);\n    float a = length(vec3(0.,7.,0.)-p)-1.3;\n    a = fractal((vec3(0.,0.,-0.0)-p)/6.)*6.;\n    float b = box(vec3(0.,4., -7.)-p, vec3(10.,10.,0.3));\n    float b2 = box(vec3(0.,4., 4.)-p, vec3(10.,10.,0.3));\n    float b3 = box(vec3(7.,4., 0.)-p, vec3(0.4,10.,10.3));\n    float b4 = box(vec3(-7.,4., 0.)-p, vec3(0.4,10.,10.3));\n    float b5 = box(vec3(-0.,14., 0.)-p, vec3(10.4,0.5,10.3));\n    float lig = box(vec3(0.,4., 2.3)-p, vec3(4.,4.,.004));\n\n    float fin = min(min(min(min(a,b),b2),min(b3,min(b4,b5))),lig);\n    fin = min(a,lig);\n    if(fin == a){\n        c = pal(escape, vec3(0.9,0.6,0.2));\n    }\n    if(fin == b){\n        c = vec3(0.5,0.5,0.8);\n    }\n    if(fin == b3){\n        c = vec3(0.2,0.9,0.2);\n    }\n    if(fin == b4){\n        c = vec3(0.8,0.2,0.2);\n    }\n    if(fin == lig){\n        l = 0.;\n       // c = vec3(0.8,0.2,0.2);\n    }\n    \n    \n    return fin;\n}\n\nvec3 beckmann_s(vec3 n, inout uint r, float a){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\n//float theta = sqrt(atan((-a*a*log(1.-r2))));\nfloat theta = acos(sqrt(1./(1.0-a*a*log(1.0-r2))));\nfloat x = cos(phi)*sin(theta);\nfloat y = sin(phi)*sin(theta);\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nbool trace(inout vec3 p, vec3 d, inout uint r){\n\n    for(int i = 0; i < 80; i++){\n        float dist = dis(p);\n        if(dist < 0.01)return true;\n        if(rndf(r) < 0.04){\n        d = beckmann_s(d, r, 0.04);\n        }\n        p+=d*dist;\n    }\n\n    return false;\n}\n\n\nvec3 norm(vec3 p){\n    return normalize(\n        vec3(\n            dis(vec3(p.x+0.03,p.yz))-dis(vec3(p.x-0.03,p.yz)),\n            dis(vec3(p.x,p.y+0.03,p.z))-dis(vec3(p.x,p.y-0.03, p.z)),\n            dis(vec3(p.x,p.y, p.z+0.03))-dis(vec3(p.x,p.y,p.z-0.03))\n        )\n    );\n}\n\n\nvec3 angledircos(vec3 n, inout uint r){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\nfloat theta = acos(sqrt(r2));\n\nfloat x = cos(phi)*sin(theta);\nfloat y = sin(phi)*sin(theta);\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nfloat beckmann_d(float cost, float rough){\nfloat aa = rough*rough;\nfloat a = exp(-((tan(cost)*tan(cost))/aa));\nfloat b = 3.14159*aa*pow(cos(cost), 4.);\nreturn a/b;\n}\nfloat beckmann_pdf(float cost, float rough){\nfloat aa = rough*rough;\nfloat a = exp(-((tan(cost)*tan(cost))/aa));\nfloat b = 3.14159*aa*pow(cos(cost), 3.);\nreturn a/b;\n}\n\n\n\n\nvec3 sun_cap(vec3 n, inout uint r, in float theta){\nfloat r1 = rndf(r);\nfloat r2 = rndf(r);\nfloat phi = 2.*3.14159*r1;\n//float theta = sqrt(atan((-a*a*log(1.-r2))));\nfloat x = cos(phi)*sqrt(1.-cos(theta)*cos(theta));\nfloat y = sin(phi)*sqrt(1.-cos(theta)*cos(theta));\nfloat z = cos(theta);\n\n\nvec3 N = n;\nvec3 W = (abs(n.x) < 0.99)?vec3(1.,0.,0.):vec3(0.,1.,0.);\nvec3 T = normalize(cross(N,W));\nvec3 B = normalize(cross(N,T));\n\nreturn normalize(T*x + B*y + N*z);\n\n}\n\nfloat lum(vec3 c){\nreturn 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}\n\nfloat powerh(float pdf1, float pdf2){\nreturn pdf1*pdf1/(pdf1*pdf1 + pdf2*pdf2);\n}\n\nfloat G(vec3 n, vec3 h, vec3 v, vec3 l){\nfloat a = (2.*max(dot(n,h),0.01)*max(dot(n,v),0.01))/max(dot(v,h),0.01);\nfloat b = (2.*max(dot(n,h),0.01)*max(dot(n,l),0.01))/max(dot(v,h),0.01);\nreturn min(1., min(a,b));\n}\n\nvec3 F(vec3 f0, float cost){\nreturn f0 + (1.0-f0)*pow(1.0-cost,5.);\n}\nvec3 light = normalize(vec3(0., 2., 1.5));\n\nvec3 render(vec3 p, vec3 d, inout uint r, vec2 fragCoord){\n    vec3 col = vec3(0.);\n    vec3 cc = vec3(0.);\n    float lig = 0.;\n    vec3 tt = vec3(1.);\n    vec3 cam = p;\n    const int bounces = 8;\n    for(int i = 0; i < bounces; i++){\n        if(trace(p,d,r)){\n            cc = c;\n            lig = l;\n            vec3 wi = d;\n            vec3 n = norm(p);\n            p+=n*0.04;\n            bool nee = (int(fragCoord.x)/64 % 2 == 0);\n            //nee = true;\n            \n            float theta = 0.1;\n            //vec3 sun_cap(vec3 n, inout uint r, in float theta){\n            light = sun_cap(light, r, theta);\n            if(lig > 0.01 && nee){\n                col+=tt*lig;\n                break;\n            }\n                float num = 0.1;\n                float rough = 0.01;\n            float prob = rndf(r);\n                        d = angledircos(n,r);\n                        \n            if(prob > num)\n            {\n                   d = beckmann_s(reflect(wi,n), r, rough);\n            }\n   // float lig = box(vec3(0.,7., 2.3)-p, vec3(2.,2.,.04));\n            vec3 lpos = vec3(0.,4., 2.3); \n            vec2 offset = vec2(rndf(r), rndf(r))*8.0-4.0;\n            lpos.xy += offset;\n            vec3 ldir = lpos - p;\n            float dist2 = dot(ldir,ldir);\n            ldir = normalize(light);\n            vec3 brdf = cc/3.14159;\n            vec3 brdf2 = cc/3.14159;\n\n            float pdf = max(dot(d, n),0.01)/3.14159;\n            float pdf2 = max(dot(d, n),0.01)/3.14159;\n\n//float beckmann_d(float cost, float rough){\n\n            if(prob > num){\n                                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                //d = beckmann_s(reflect(wi,n), r, rough);\n//                float G(vec3 n, vec3 h, vec3 v, vec3 l){\n\n                                \n                vec3 h = normalize(d + -wi);\n                float D = beckmann_d(acos(max(dot(reflect(wi, n), d),0.01)), rough);\n                float Gg = G(n, h, -wi, d);\n                vec3 Ff = F(cc, max(dot(h, d),0.01));\n                vec3 specular = (D*Gg*Ff)/max(4.*max(dot(-wi, n),0.)*max(dot(d,n),0.),0.01);\n                pdf = beckmann_pdf(acos(max(dot(reflect(wi, n), d),0.01)), rough);\n                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                brdf = specular;\n               // brdf = max(brdf, 0.0);\n                \n                vec3 h2 = normalize(ldir + -wi);\n                float D2 = beckmann_d(acos(max(dot(reflect(wi, n), ldir),0.01)), rough);\n                float Gg2 = G(n, h2, -wi, ldir);\n                vec3 Ff2 = F(cc, max(dot(ldir, h),0.01));\n                vec3 specular2 = (D2*Gg2*Ff2)/max(4.*max(dot(-wi, n),0.)*max(dot(ldir,n),0.),0.05);\n                pdf2 = beckmann_pdf(acos(max(dot(reflect(wi, n), ldir),0.0)), rough);\n                //vec3 beckmann_s(vec3 n, inout uint r, float a){\n                brdf2 = specular2;\n               // brdf2 = max(brdf, 0.0);\n            }\n            pdf = max(pdf, 0.01);\n            pdf2 = max(pdf2,0.01);\n            \n            float pdf3 = 2.*3.14159*(1.0-cos(theta));\n\n            \n            vec3 holdp = p;\n            if(!trace(holdp,ldir,r)){\n               col += vec3(10.)*brdf2*tt*powerh(pdf3, pdf)*max(dot(ldir, n),0.01)/pdf3;\n            }\n            \n            holdp = p;\n            if(!trace(holdp,d,r) && acos(max(dot(light, d),0.)) < theta){\n                    col += vec3(10.)*tt*brdf*powerh(pdf, pdf3)*max(dot(d, n),0.01)/pdf;\n                    break;\n            }\n            \n            /*\n            \n            if(!nee){\n                if(lig > 0.01 && i == 0){\n                    col+=lig*tt;\n                    break;\n                }else if(lig > 0.01){\n                    break;\n                }\n                float area = 8.*8.;\n                vec3 nlight = vec3(0., 0., -1.);\n                if(p.z > lpos.z){\n                    nlight = vec3(0.,0.,1.);\n                }\n                vec3 holdp = p;\n                if(trace(holdp,ldir)){\n                    cc = c;\n                    lig = l;\n                    if(lig > 0.01 && dot(ldir, n) > 0. && dot(-ldir, nlight)>0.01){\n                    vec3 lss = vec3(1.,0.,0.);\n                        float pdf3 = dist2/(max(dot(-ldir, nlight),0.01)*area);\n                        pdf3 = max(pdf3, 0.01);\n                        if(prob > num){\n                            pdf3 = pdf2;\n                        }\n                        col += lig*brdf2*tt*powerh(pdf3, pdf)*max(dot(ldir, n),0.01)/pdf3;\n                    }\n                }\n                \n                holdp = p;\n                if(trace(holdp,d) && dot(d, n) > 0. && dot(-d, nlight)>0.01){\n                    if(l > 0.01){\n                        dist2 = dot(holdp-p, holdp-p);\n                        float pdf3 = dist2/(max(dot(-d, nlight),0.01)*area);\n                        col += l*tt*brdf*powerh(pdf, pdf3)*max(dot(d, n),0.01)/pdf;\n                        break;\n                    }\n                }\n            }\n            */\n            if(i > 3){\n                float ma = lum(tt);\n                if(rndf(r)>ma)break;\n                tt/=ma;\n            }\n             \n            tt*=brdf*max(dot(d,n),0.01)/pdf;\n            \n            if(i == 0){\n                vec3 dd = p - cam;\n                dd /= 5.0;\n                float accum;\n                for(int i = 0; i < 5; i++){\n                    cam += dd*rndf(r);\n                    vec3 mm = cam;\n                    if(!trace(mm, light,r)){\n                        accum += 1.;\n                    }\n                }\n                accum/=5.;\n                col += vec3(0.9,0.6,0.2)*accum*0.1;\n            }\n            \n        }else{\n         if(i == 0){\n                vec3 dd = p - cam;\n                float l = clamp(length(dd),0.,20.);\n                dd = normalize(dd)*l;\n                dd /= 5.0;\n                float accum;\n                for(int i = 0; i < 5; i++){\n                    cam += dd*rndf(r);\n                    vec3 mm = cam;\n                    if(!trace(mm, light,r)){\n                        accum += 1.;\n                    }\n                }\n                accum/=5.;\n                col += vec3(0.9,0.6,0.2)*accum*0.1;\n            }\n            col += tt*texture(iChannel0, d.xzy).xyz;\n            break;\n        }\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //not my code///////////////////////////////////\n      uint r = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //////////////////////////////////////////////\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 offset = vec2(rndf(r), rndf(r))*2.0-1.0;\n   // offset *= 1.0/iResolution.xy;\n    vec2 fC = fragCoord.xy + offset;\n    vec2 uv = fC/iResolution.xy;\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= 1.3;\n    uv.y /= 1.3;\n   vec2 rdiff = iResolution.xy / float(tiles);\n    int tim = (iFrame/int(samples))%(tiles*tiles);\n    int x = tim%tiles;\n    int y = tim/tiles;\n    if(fragCoord.x > (rdiff.x*float(x+1)) || fragCoord.x < rdiff.x*float(x))discard;\n    if(fragCoord.y > (rdiff.y*float(y+1)) || fragCoord.y < rdiff.y*float(y))discard;\nfloat jk = float(iFrame%int(samples));\n    vec3 p = vec3(0.,-6.,1.);\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    vec3 d = normalize(vec3(uv.x, 1., uv.y));\n    d.yz = rot(d.yz,30.);\n    d.xy = rot(d.xy, 0.);\n    \n    // Time varying pixel color\n    vec3 col = render(p,d,r,fragCoord);\n    \n    col = clamp(col,0.,1.);\n        //col = tonemap_uchimura2(col);\n        col = pow(col, vec3(1.4))*1.8;\n        col = pow(col, vec3(1./2.2));\n    if(jk != 0.){\n        col += texture(iChannel1, fragCoord.xy/iResolution.xy).xyz;\n    }\n    // Output to screen\n    fragColor = vec4(col,jk);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "int tiles = 2;\nfloat samples = 50.;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}