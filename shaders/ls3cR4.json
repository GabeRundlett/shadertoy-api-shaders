{
    "Shader": {
        "info": {
            "date": "1518025798",
            "description": "Flow by stream function (no fluid solver here). Cf [url]https://hal.inria.fr/inria-00345903/[/url]\n\nMouse displaces borders and rocks, \nclick + up/down key tunes flow around rock (i.e. set stream value boundary condition - cf color).\n + left/right: radius",
            "flags": 48,
            "hasliked": 0,
            "id": "ls3cR4",
            "likes": 43,
            "name": "sculpt flow by stream function",
            "published": 3,
            "tags": [
                "fluid",
                "flow",
                "advection",
                "vortex",
                "river",
                "interpolation",
                "stream",
                "vorticity",
                "streamfunction"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 2650
        },
        "renderpass": [
            {
                "code": "// based on https://shadertoy.com/view/ldtSzn\n// See \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n\t     U = ( u+u - R ) / R.y;\n    \n    vec4 T = velocity(U, iChannel0);          \n    vec2 V = T.xy; float w = T.z, W=T.w;       // velocity field, stream, in rock\n    \n    // --- display\n#if 1                                          // --- display advected texture\n\n    O = texelFetch(iChannel1,ivec2(u),0);\n    if ( W >= 0.) O = clamp(O.b,0.,1.) * vec4(1.-W,W,0,0); // in rocks: display stream cond\n    if (iMouse.z > 0.) O.r += sin(100.*w);     // click: draw iso-streams\n        \n#else                                          // --- display velocity & stream\n   \tO = vec4(0,50.*length(V),sin(100.*w),0);   // draw |V| and iso-streams\n\n    // draw line\n#   define L(a,b) O+= 1e-3/length( clamp( dot(U-(a),v=b-(a))/dot(v,v), 0.,1.) *v - U+a ) // segments\n\n    vec2 p = floor(U*30.+.5)/30., v;           // draw velocity vectors\n    L ( p-V*2., p+V*2.);                               // L(vec2(.5,.5),p);\n\n    if ( W >= 0.) O = W + vec4(.2,0,0,0);      // in rocks: display stream cond\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// === create and edit river bed\n\n#define keyClick(ascii)  texelFetch(iChannel3,ivec2(ascii,0),0).x\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    \n    if (iFrame==0) {            // --- init: create river bed\n        if (U.y>1.) return;\n        \n       float dl = rnd(U.x), dr = rnd(U.x+.1);\n        O.xy = vec2(R.x/R.y*cos(U.x),sin(U.x)); // xy: pos  z: radius   w: streak\n         switch( int(U.x)%3 ) {                       \n            case 0: O.xy *= 1.+.3*dl; O.z = .3+.2*dr;   O.w = 1.; break; // outer\n            case 1: O.xy *=    .3*dl; O.z = .1+.1*dr;   O.w = 0.; break; // inner\n            case 2: O.xy *= .4+.3*dl; O.z = .02+.08*dr; O.w = .1+.8*dl; break; // islands\n        }\n        return;\n    }\n    \n    O = texelFetch(iChannel0,ivec2(U),0);\n    \n    if ( U-.5 == vec2(0,1) )    // --- mouse management\n        if (iMouse.z>0.) {      // mouse clicked\n            if (O.w<0.) {       // no edited object registered yet\n                float l,m=1e9; int _i=-1; \n                vec2 P, M = ( 2.*iMouse.xy - R ) / R.y;\n                for (int i=0; i<N; i++) { // search for closest object\n                    vec4 T = texelFetch(iChannel0,ivec2(i,0),0);\n                    l = length(M-T.xy);\n                    if (l<m) m = l, _i = i, P = T.xy;\n                }\n                O.w = float(_i); O.xy = P; // Buff(0,1) = edited rock + init pos\n            }\n        }\n    else \n        O.w = -1.;              // forget rock id\n    \n    if (iMouse.z>0. && U.y==.5) {\n        vec4 T = texelFetch(iChannel0,ivec2(0,1),0);    // cur edit data\n        if (U.x-.5==T.w) {      // --- manage clicked rock\n            O.xy = T.xy + (iMouse.xy-abs(iMouse.zw))*2./R.y; // move rock\n                                                        // edit streak value\n            O.w += .01* ( keyClick(38)-keyClick(40) );  // key up/down\n            O.z *= 1.+.02* ( keyClick(39)-keyClick(37) ); // key left/right\n            O.w = clamp(O.w,0.,1.);\n        }\n    }\n    \n#if 0\n    if (iMouse.xy==vec2(0) && U.y==.5 && rnd(iTime)>.9 ) // demo mode\n        O.xy += 3.*(2.*rnd(U.x+iTime+vec2(0,.5))-1.)/300.;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// === texture advection with the flow\n\nvoid mainImage( out vec4 O, vec2 u )\n{   vec2 R = iResolution.xy,\n\t     U = ( u+u - R ) / R.y;\n    \n    vec2 V = velocity(U, iChannel0).xy * R.y/1e2;             // velocity field  \n  //if (V!=V) return;                                         // in rock\n                        // try u/256. fullscreen\n    vec4 T = texture(iChannel2,u/R.y+ rnd(iTime+vec2(1,0)) ); // random texture\n \n    O =   texture(iChannel1,(u + V*R.y/60.) / R )             // advect\n        + max(.3,3.-iTime) * step(.9,T.x)*sign(T.y-.5) * vec4(.1,.5,1,0); // add new marks\n    O = clamp(O,-1.,2.);\n // O = clamp(O, 0.,1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define N 70                                   // number of rocks (including river bed)\n\n#define rnd(x) fract( sin( (x) * 1298.98 ) * 43758.5453)\n\n// === computation of velocity field. \n// See \"Scalable Real-Time Animation of Rivers\" https://hal.inria.fr/inria-00345903/\n\n#define r0 1.5 // influence distance   for efficiency, as small as it keep covering influencials river sides \n#define c0 1.5 // boundary condition   < 1: slip condition   > 1 : no-slip condition\n    \nfloat f(float d) {                             // interpolation function\n    float t = 1. - d/r0;\n    return t < 0. ? 0. :pow(d,-c0) * (6.*t*t-15.*t+10.)*t*t*t;\n}\n\nvec4 velocity(vec2 U, sampler2D ch)   // returns V, stream value, rock stream cond\n{\n    // interpolate stream function : add(distance to border, stream at border)\n#define add(d,phi)  w = f(d),  wf += w*phi,  wT += w;\n\n    float wf=0., wT=0., w, W=-1.; \n    \n    // river bed and obstacle geometry, + flux (diff of stream between river sides)\n    for (int i=0; i<N; i++) {\n        vec4 T = texelFetch(ch, ivec2(i,0), 0);\n        add( length(U-T.xy) - T.z, T.w );      // add obstacle i in stream\n        if (w!=w) W = T.w;                     // NaN: in rock. \n    }\n\n    w = wf / wT;                               // stream field\n    if (w!=w) w = W;                           // in rock\n    return vec4(-dFdy(w), dFdx(w), w, W );     // xy = velocity field\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}