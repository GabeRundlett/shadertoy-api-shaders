{
    "Shader": {
        "info": {
            "date": "1469514079",
            "description": "There is something under the surface\nJust testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\nImplemented by chronos in www.shadertoy.com/view/4lj3zK",
            "flags": 64,
            "hasliked": 0,
            "id": "Xtc3DM",
            "likes": 41,
            "name": "Under the surface",
            "published": 3,
            "tags": [
                "spheretracing",
                "relaxed",
                "enhanced",
                "64klang"
            ],
            "usePreview": 0,
            "username": "Virgill",
            "viewed": 1438
        },
        "renderpass": [
            {
                "code": "//**************************************************************************************************\n// ThereÂ´s something under the surface\n// Just testing enhanced sphere tracing: lgdv.cs.fau.de/get/2234\n// Implemented by chronos in www.shadertoy.com/view/4lj3zK\n\n// Soundtrack \"System malfunction\" done with 64klang\n\n//**************************************************************************************************\n\nfloat sminPoly( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\nvec2 ku=vec2(0.);\n\nfloat sdPlane(vec3 p) \n{\nreturn p.y+(0.002*sin(p.x*110.))+(0.002*sin(p.z*112.))-0.3-0.1*sin(2.*iTime+2.*p.z);\n}\n\nfloat fField2(vec3 p) \n{\n\tvec2 q = pModGrid2(p.xz,vec2(0.8));\n\tpR(p.xz,iTime*0.11);\n\tvec2 q2 = pModGrid2(p.xz,vec2(0.7));\n\tpR(p.xy,iTime*0.134);\n\tfloat box = fBox(p-vec3(0),vec3(0.6))-0.08;\n\tku=q; return box;\n}\n\nfloat map(vec3 p)\n{\n    return sminPoly(fField2(p),sdPlane(p),-0.01);\n}\n\nfloat shadowsoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 28; ++i )\n    {\n        float h = map( ro + rd * t );\n        if ( h < 0.001 ) return 0.0;\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\nfloat castRay(in vec3 ray_origin, in vec3 ray_direction, in bool inside) {\n    float relaxation = 1.5;// range [1.0, 2.0]\n    float distance_min =  0.1;\n    float distance_max = 12.0;\n    float precis   = 0.0005;\n    float distance = distance_min;\n    float previous_radius = 0.0;\n    float stepLength = 0.0;\n    float function_sign = 1.0;\n    if(map(ray_origin) < 0.0) function_sign = -1.0;\n    \n\tfor(int i = 0; i < 60; i++ ) {\n        float result; \n        if (inside==false) result = map(ray_origin + ray_direction * distance);\n        else result = -map(ray_origin + ray_direction * distance);\n        float signed_radius = function_sign * result;\n        float radius = abs(signed_radius);\n        \n        bool sorFail = relaxation > 1.0 && (radius + previous_radius) < stepLength;\n        if(sorFail) {\n        \tstepLength -= relaxation * stepLength; // revert last step\n            relaxation = 1.0;\n        } else {\n        \tstepLength = signed_radius * relaxation;   \n        }\n        previous_radius = radius;\n        if(!sorFail && radius < precis || distance > distance_max ) break;\n        distance += stepLength;\n    }\n    return  distance;\n\n}\n\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv,p;\n\tuv.xy = gl_FragCoord.xy /iResolution.xy; p = uv * 2.0 - 1.0;\n   \n//  cam    \n\tp.x *= iResolution.x /iResolution.y;\n\tfloat theta = sin(iTime*0.1) * 6.28;\n    float x = 3.0 * cos(theta); \n    float z = 3.0 * sin(theta); \n\tvec3 ro = vec3(x*2.2, 5.0+2.*sin((iTime+37.)*0.15), z*1.4);\t\t\n\n\tvec3 cw = normalize(vec3(0., 0.25, 0.) - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 7.5 * cw);\n\n// \trender:\n    vec3 col= vec3(0.0);\n    float t = castRay(ro,rd,false);\n\tvec3 pos = ro + rd *t;\n\tvec3 nor = calcNormal(pos);\n\tvec3 ligvec = vec3(-0.5, 0.5, 0.5);\n\tvec3 lig = normalize(ligvec);\t\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tcol = vec3(0.2*dif+1.*spec);\n    \n    float sh = shadowsoft(pos,lig,0.01,0.2,1.2); \n    col *= clamp(sh, 0.0, 1.0);\n\n\n//  refraction\n\tvec3 rd2 = refract(rd,nor,0.77);  \n    float t2 = castRay(pos,rd2,true);\n\tvec3 pos2 = pos + rd2* t2;\n    vec3 nor2 = calcNormal(pos2);\n\tfloat dif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n    col.r += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\n\trd2 = refract(rd,nor,0.83);\n    t2 = castRay(pos,rd2,true);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n    col.b += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\n\trd2 = refract(rd,nor,0.8);\n    t2 = castRay(pos,rd2,true);\n\tpos2 = pos + rd2* t2;\n    nor2 = calcNormal(pos2);\n\tdif2 = clamp(dot(lig, nor2), 0.0, 1.0);\n    float spec2 = pow(clamp(dot(reflect(rd2, nor2), lig), 0.0, 1.0), 16.0);\n    col.g += (1.0-t2*0.25)+(1.0-t*0.15)*dif2;\n    col +=0.3*spec2;\n    col *= clamp(sh, 0.8, 1.0);\n\n\tvec3 ro3 = pos2+rd; \n\tvec3 rd3 = rd2+0.05;\n    float t3 = castRay(ro3,rd3,false);\n\tvec3 pos3 = ro3 + rd3* t3;\n    vec3 nor3 = calcNormal(pos3);\n\tfloat dif3 = clamp(dot(lig, -nor3), 0.0, 1.0);\n    col-= 0.2*(1.-dif3);\n    col += 0.1*texture(iChannel0, vec2(0., 0.)).xyz;\n    col = mix(col, vec3(0.4,0.5,0.5), ku.y*0.2*t2);\n    fragColor = vec4(col, 1.0);\n\n}\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 4379,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/virgill/system-malfunction"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}