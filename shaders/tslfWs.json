{
    "Shader": {
        "info": {
            "date": "1589320602",
            "description": "Looping sequence of moves on a 2x2 Rubik's cube, with some follow through animation and sound. I've jumbled the parts so it looks a little more interesting.\n\nUncomment '#define AA' if it's running slow",
            "flags": 8,
            "hasliked": 0,
            "id": "tslfWs",
            "likes": 139,
            "name": "Rubik's Ball",
            "published": 3,
            "tags": [
                "sound",
                "animation",
                "momentum",
                "rubiks"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 7691
        },
        "renderpass": [
            {
                "code": "\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n\n//========================================================\n// Utils\n//========================================================\n\n// HG_SDF\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// Easings\n\nfloat range(float vmin, float vmax, float value) {\n  return clamp((value - vmin) / (vmax - vmin), 0., 1.);\n}\n\nfloat almostIdentity(float x) {\n    return x*x*(2.0-x);\n}\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n// rotate on axis, blackle\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//========================================================\n// Animation\n//========================================================\n\n// see common tab for a list of moves (rotations)\n\nbool lightingPass;\nfloat time;\n\nvoid applyMomentum(inout vec4 q, float time, int i, vec4 move) {\n\n    float turns = move.w;\n    vec3 axis = move.xyz;\n\n    float duration = abs(turns);\n    float rotation = PI / 2. * turns * .75;\n\n    float start = float(i + 1);\n    float t = time * MOVE_COUNT;\n    float ramp = range(start, start + duration, t);\n    float angle = circularOut(ramp) * rotation;\n    vec4 q2 = rotate_angle_axis(angle, axis);\n    q = qmul(q, q2);\n}\n\nvoid applyMove(inout vec3 p, int i, vec4 move) {\n\n    float turns = move.w;\n    vec3 axis = move.xyz;\n\n    float rotation = PI / 2. * turns;\n\n    float start = float(i);\n    float t = time * MOVE_COUNT;\n    float ramp = range(start, start + 1., t);\n    ramp = pow(almostIdentity(ramp), 2.5);\n    float angle = ramp * rotation;\n    \n    bool animSide = vmax(p * -axis) > 0.;\n    if (animSide) {\n    \tangle = 0.;\n    }    \n\n    p = erot(p, axis, angle);\n}\n\nvec4 momentum(float time) {\n    vec4 q = QUATERNION_IDENTITY;    \n    applyMomentum(q, time, 5, moves[5]);\n    applyMomentum(q, time, 4, moves[4]);\n    applyMomentum(q, time, 3, moves[3]);\n    applyMomentum(q, time, 2, moves[2]);\n    applyMomentum(q, time, 1, moves[1]);\n    applyMomentum(q, time, 0, moves[0]);\n    return q;\n}\n\nvec4 momentumLoop(float time) {\n    vec4 q;\n    \n    // end state\n    q = momentum(3.);\n    q = q_conj(q);\n    q = q_slerp(QUATERNION_IDENTITY, q, time);\n    \n    // next loop\n    q = qmul(momentum(time + 1.), q);\n   \n\t// current loop\n\tq = qmul(momentum(time), q);\n    \n    return q;\n}\n\n\n//========================================================\n// Modelling\n//========================================================\n\nvec4 mapBox(vec3 p) {\n\n    // shuffle blocks\n    pR(p.xy, step(0., -p.z) * PI / -2.);\n    pR(p.xz, step(0., p.y) * PI);\n\tpR(p.yz, step(0., -p.x) * PI * 1.5);\n    \n    // face colors\n    vec3 face = step(vec3(vmax(abs(p))), abs(p)) * sign(p);\n    float faceIndex = max(vmax(face * vec3(0,1,2)), vmax(face * -vec3(3,4,5)));\n    vec3 col = spectrum(faceIndex / 6. + .1 + .5);\n    \n    // offset sphere shell\n    float thick = .033;\n    float d = length(p + vec3(.1,.02,.05)) - .4;\n    d = max(d, -d - thick);\n    \n    // grooves\n    vec3 ap = abs(p);\n    float l = sqrt(sqrt(1.) / 3.);\n    vec3 plane = cross(abs(face), normalize(vec3(1)));\n    float groove = max(-dot(ap.yzx, plane), dot(ap.zxy, plane));\n    d = smax(d, -abs(groove), .01);\n    \n    float gap = .005;\n    \n    // block edge\n    float r = .05;\n    float cut = -fBox(abs(p) - (1. + r + gap), vec3(1.)) + r;\n    d = smax(d, -cut, thick / 2.);\n\n    // adjacent block edge bounding\n    float opp = vmin(abs(p)) + gap;\n    opp = max(opp, length(p) - 1.);\n    if (opp < d) {\n        return vec4(opp, vec3(-1));\n    }\n\n    return vec4(d, col * .4);\n}\n\nvec4 map(vec3 p) {\n\n    if (iMouse.x > 0.) {\n    \tpR(p.yz, ((iMouse.y / -iResolution.y) * 2. + 1.) * 2.);\n    \tpR(p.xz, ((iMouse.x / -iResolution.x) * 2. + 1.) * 4.);\n    }\n\n    //p.z *= -1.;\n    pR(p.xz, time * PI * 2.);\n    //pR(p.yz, time * PI * -2.);\n    //pR(p.xy, PI);\n    \n    vec4 q = momentumLoop(time);\n    p = rotate_vector(p, q);\n\n    applyMove(p, 5, moves[5]);\n    applyMove(p, 4, moves[4]);\n    applyMove(p, 3, moves[3]);\n    applyMove(p, 2, moves[2]);\n    applyMove(p, 1, moves[1]);\n    applyMove(p, 0, moves[0]);\n       \n    return mapBox(p);\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.001;\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\n\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\n    // iq optimisation, stop looking for occluders when we\n    // exit the bounding sphere for the model\n    vec2 bound = iSphere(ro, rd, .55);\n    tmax = min(tmax, bound.y);\n    \n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<100; i++ )\n    {\n        vec4 hit = map( ro + rd*t );\n        float h = hit.x;\n        if (hit.y > 0.) { // don't create shadows from bounding objects\n            res = min( res, 10.0*h/t );\n        }\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 render(vec2 p) {\n    \n    vec3 col = vec3(.02,.01,.025);\n    \n    // raymarch\n\n    vec3 camPos = vec3(0,0,2.);\n    mat3 camMat = calcLookAtMatrix( camPos, vec3(0,0,-1), 0.);\n    vec3 rd = normalize( camMat * vec3(p.xy, 2.8) );\n    vec3 pos = camPos;\n    \n    vec2 bound = iSphere(pos, rd, .55);\n    if (bound.x < 0.) {\n    \treturn col;\n    }\n\n    lightingPass = false;\n    float rayLength = bound.x;\n    float dist = 0.;\n    bool background = true;\n    vec4 res;\n\n    for (int i = 0; i < 200; i++) {\n        rayLength += dist;\n        pos = camPos + rd * rayLength;\n        res = map(pos);\n        dist = res.x;\n\n        if (abs(dist) < .001) {\n            background = false;\n            break;\n        }\n\n        if (rayLength > bound.y) {\n            break;\n        }\n    }\n\n    // shading\n    // https://www.shadertoy.com/view/Xds3zN\n    \n    lightingPass = true;\n    \n    if ( ! background) {\n        \n        col = res.yzw;\n        vec3 nor = calcNormal(pos);        \n        vec3 lig = normalize(vec3(-.33,.3,.25));\n        vec3 lba = normalize( vec3(.5, -1., -.5) );\n        vec3 hal = normalize( lig - rd );\n        float amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, lba ), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n        // iq optimisation, skip shadows when we're facing away\n        // from the light\n\t\tif( dif > .001) dif *= softshadow( pos, lig, 0.001, .9 );\n        \n        float occ = 1.;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n            dif *\n            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 1.55*bac*vec3(0.25,0.25,0.25)*occ*vec3(2,0,1);\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\n        col = col*lin;\n\t\tcol += 5.00*spe*vec3(1.10,0.90,0.70);\n    }\n\n    return col;\n}\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float mTime = (iTime + TIME_OFFSET) / LOOP_DURATION;\n    \n    //mTime = .38;\n    time = mTime;    \n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\t\t\n        time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4(col, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n#define LOOP_DURATION 5.\n#define MOVE_COUNT 6.\n#define TIME_OFFSET .3\n\n// axisX, axisY, axisZ, turns \nvec4 moves[6] = vec4[6](\n    vec4(1,0,0, 2.),\n    vec4(0,1,0, -1.),\n    vec4(0,-1,0, -3.),\n    vec4(0,0,-1, 2.),\n    vec4(0,-1,0, -1.),\n    vec4(0,1,0, -3.)\n);\n\n\n// Quaternions\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\n\n#define QUATERNION_IDENTITY vec4(0, 0, 0, 1)\n\n#define PI 3.1415926\n\n// Quaternion multiplication\n// http://mathworld.wolfram.com/Quaternion.html\nvec4 qmul(vec4 q1, vec4 q2) {\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\n// Vector rotation with a quaternion\n// http://mathworld.wolfram.com/Quaternion.html\nvec3 rotate_vector(vec3 v, vec4 r) {\n\tvec4 r_c = r * vec4(-1, -1, -1, 1);\n\treturn qmul(r, qmul(vec4(v, 0), r_c)).xyz;\n}\n\n// A given angle of rotation about a given axis\nvec4 rotate_angle_axis(float angle, vec3 axis) {\n\tfloat sn = sin(angle * 0.5);\n\tfloat cs = cos(angle * 0.5);\n\treturn vec4(axis * sn, cs);\n}\n\nvec4 q_conj(vec4 q) {\n\treturn vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 q_slerp(vec4 a, vec4 b, float t) {\n    // if either input is zero, return the other.\n    if (length(a) == 0.0) {\n        if (length(b) == 0.0) {\n            return QUATERNION_IDENTITY;\n        }\n        return b;\n    } else if (length(b) == 0.0) {\n        return a;\n    }\n\n    float cosHalfAngle = a.w * b.w + dot(a.xyz, b.xyz);\n\n    if (cosHalfAngle >= 1.0 || cosHalfAngle <= -1.0) {\n        return a;\n    } else if (cosHalfAngle < 0.0) {\n        b.xyz = -b.xyz;\n        b.w = -b.w;\n        cosHalfAngle = -cosHalfAngle;\n    }\n\n    float blendA;\n    float blendB;\n    if (cosHalfAngle < 0.99) {\n        // do proper slerp for big angles\n        float halfAngle = acos(cosHalfAngle);\n        float sinHalfAngle = sin(halfAngle);\n        float oneOverSinHalfAngle = 1.0 / sinHalfAngle;\n        blendA = sin(halfAngle * (1.0 - t)) * oneOverSinHalfAngle;\n        blendB = sin(halfAngle * t) * oneOverSinHalfAngle;\n    } else {\n        // do lerp if angle is really small.\n        blendA = 1.0 - t;\n        blendB = t;\n    }\n\n    vec4 result = vec4(blendA * a.xyz + blendB * b.xyz, blendA * a.w + blendB * b.w);\n    if (length(result) > 0.0) {\n        return normalize(result);\n    }\n    return QUATERNION_IDENTITY;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nvec2 rand(vec2 n) {\n    return fract(sin(n) * 43758.5453123) * 2. - 1.;\n}\n\nvec2 srand(vec2 n, float hard) {\n\tvec2 nf = floor(n);\n    vec2 nc = ceil(n);\n    return mix(rand(nf), rand(nc), smoothstep(.5 * hard, 1. - .5 * hard, fract(n)));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    time += TIME_OFFSET;\n    // shift time to stop clipping at start of move\n    float index = floor((time + .05) / LOOP_DURATION * MOVE_COUNT);\n    float moveIndex = mod(index - 1., MOVE_COUNT);\n    float turns = abs(moves[int(moveIndex)].w);\n    float volume = pow(turns / 3., 1.5);\n    \n    float t = mod(time, LOOP_DURATION);\n    t = mod(t, LOOP_DURATION / MOVE_COUNT);\n    vec2 s = srand(vec2(t * 2.5, t * 2. + .02) * 1000., .0) * exp(-100. * t);\n    s += sin(vec2(t * 5000.) / mix(1.1, 1., rand(vec2(index+.2)).x) / (1. + t * .5)) * exp(-30. * t) * .1;\n\n    return s * volume;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}