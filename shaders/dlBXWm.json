{
    "Shader": {
        "info": {
            "date": "1676444076",
            "description": "I set out to try subsurface scattering and a gyroid and ended up here. You know how it is.\nRaymarched except the plane.",
            "flags": 32,
            "hasliked": 0,
            "id": "dlBXWm",
            "likes": 15,
            "name": "deconstructed telescope",
            "published": 3,
            "tags": [
                "lens",
                "optics",
                "telescope",
                "lenses"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "const uint mtl_0       =  0u;\nconst uint mtl_clear1  =  1u;\nconst uint mtl_clear2  =  2u;\nconst uint mtl_pink    =  3u;\nconst uint mtl_chrome  =  4u;\nconst uint mtl_floor   =  5u;\nconst uint mtl_grey    =  6u;\nconst uint mtl_mtl     =  7u;\nconst uint mtl_black   =  8u;\nconst uint mtl_white1  =  9u;\nconst uint mtl_count   = 10u;\n\nconst mtl_t materials[mtl_count] = mtl_t[](\n    mtl_t(1.0        , 1.0 , v1),                   // sky\n    mtl_t(1.2        , 0.98, v1),                   // clear1\n    mtl_t(ior_aerogel, 0.94, v1),                   // clear2\n    mtl_t(1.2        , 0.0 , vec3(0.0, 0.8, 1.0)),  // pink\n    mtl_t(1e2        , 0.0 , v1),                   // chrome\n    mtl_t(1.0        , 0.0 , v1),                   // floor\n    mtl_t(1.0        , 0.4 , v1 * 0.4),             // grey\n    mtl_t(3.0        , 0.0 , vec3(0.5, 0.1, 0.1)),  // mtl\n    mtl_t(1.0        , 0.0 , v0),                   // black\n    mtl_t(1.0        , 0.0 , v1 * 0.8)              // white1\n);\n\nconst float cPixelize           =   1.0;\n\nconst float cMinRayAmt          =   1.0 / 256.0;\nconst uint  cMaxRays            =  22u;\nconst float cSurfEps            =   0.005;\nconst float cSelfSoftShadowDist =   0.5;\n\nconst int   cMaxMarchSteps      = 100;\nconst float cWSEps              =   0.002;\n      float gUnderStepFactor    =   1.0;\n\n\n#define Q_TYPE        ray_t\n#define Q_MAX_ENTRIES 6u\nQ_IMPLEMENTATION\n\n\nvec2 viewportFromScreen(in vec2 p) {\n    return (p * 2.0 - RES) / MINRES;\n}\n\nfloat gT           = 1e9;\nfloat gSmoothEps   = 1e9;\nvec3  gSunDir      = 1e9 * v1;\nvec3  gRGB         = 1e9 * (vX + vZ);\nfloat gSceneParam1 = 1e9;\n\nvec3  gBigLensDsc;\nvec3  gSmlLensDsc;\nfloat gBigLensFcl;\nfloat gSmlLensFcl;\nfloat gHeight;\nfloat gBigLensX;\nfloat gSmlLensX;\nmat2  gBigMatRot;\nmat2  gSmlMatRot;\n\nconst uint gLensMtl = mtl_clear1;\n\nfloat unitBounce(in float t) {\n    t = fract(t) * 2.0 - 1.0;\n    t *= t;\n    return 1.0 - t;\n}\n\nvoid setupScene() {\n    float sunT = gT * 0.1 + 3.3;\n    gSunDir = normalize(vec3(6.0 + cos(sunT), sin(sunT) * 2.0 + 2.5, 1.0));\n    \n    // lengths in cm\n    const float bigLensRad  =  6.0;\n    const float smlLensRad  =  1.0;\n    gBigLensFcl = 20.0;\n    gSmlLensFcl =  4.0;\n    \n    float ior = materials[gLensMtl].ior;\n    gBigLensDsc.xy = radiusAndOffsetForLens(gBigLensFcl, ior, bigLensRad);\n    gSmlLensDsc.xy = radiusAndOffsetForLens(gSmlLensFcl, ior, smlLensRad);\n    gBigLensDsc.z  = bigLensRad * 0.9;\n    gSmlLensDsc.z  = smlLensRad * 0.9;\n    \n    gBigLensX      = -gBigLensFcl / 2.0 + (gSceneParam1 * 2.0 - 1.0) * 6.0;\n    gSmlLensX      =  gBigLensFcl / 2.0 * 1.5;\n    \n    gBigMatRot = matRot2(pi * smoothstep(0.9, 1.0, fract(gT * 0.2       )));\n    gSmlMatRot = matRot2(pi * smoothstep(0.9, 1.0, fract(gT * 0.2 + 0.03)));\n    \n    gHeight = bigLensRad * 1.1;\n}\n\nmapSample_t map(in vec3 p) {\n    \n    MST ret = MST(1e9, mtl_0);\n\n    vec3 pa = p;\n    pa.y -= gHeight;\n    pa.x -= gBigLensX;\n    vec3 pc = pa;\n    pa.xz *= gBigMatRot;\n    opUnion(ret, MST(sdLensCc(pa, gBigLensDsc), mtl_clear1));\n    pc.x += gBigLensX - gSmlLensX;\n    pc.xz *= gSmlMatRot;\n    opUnion(ret, MST(sdLensCc(pc, gSmlLensDsc), mtl_clear1));\n    \n    vec3 pb = p;\n    pb.xy += vec2(90.0, -gHeight);\n    float cylHeight = gHeight * 0.6;\n    opUnion(ret, MST(sdCappedCylinderX((pb + vX * 10.0 + vY * (gHeight - cylHeight)).yxz, cylHeight, 2.0) - 0.1, mtl_white1));\n    pb.xy *= matRot2(gT * 0.76);\n    pb.xz *= matRot2(gT * 0.67);\n    opUnion(ret, MST(sdBoxFrame(pb, vec3(1.0), 0.1) - 0.08, mtl_clear2));\n\n//  opUnion(ret, MST(sdBoxFrame(p - vY * 1.1, vec3(1.0), 0.1) - 0.08, mtl_pink));\n\n    return ret;\n}\n\n// https://iquilezles.org/articles/normalsSDF\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\nvec3 mapNormal(vec3 p){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*cWSEps).dist;\n    }\n    return normalize(n);\n}\n\n\nvoid rayVsScene(in ray_t r, inout hit_t h) {\n    // tack on a plane via analytic intersection.\n    rayVsPlane (r, vY, 0.0, mtl_floor, h);\n\n    float t = 0.0;\n    \n    for (int n = 0; n < cMaxMarchSteps && t < 1e3; ++n) {\n        vec3 p = r.ro + r.rd * t;\n        mapSample_t ms = map(p);\n        if (ms.dist * r.side < cWSEps) {\n            h.hit      = true;\n            h.t        = t;\n            h.pnt      = p;\n            h.nrm      = mapNormal(p);\n            h.mtl      = ms.mtl;\n            h.miss     = 0.0;\n            return;\n        }\n        else {\n            if (t > cSelfSoftShadowDist && ms.dist < h.miss) {\n                h.miss  = ms.dist;\n                h.missT = t;\n            }\n        }\n\n        t += r.side * ms.dist * gUnderStepFactor;\n    }\n}\n\n\n//------------------------------------------------------------------\n\nvec3 toneSky(in ray_t r) {\n    vec3 rgb = simple_sky(r.ro, r.rd, gSunDir);\n    float theta = atan(r.rd.z, r.rd.x);\n    float q = 2.0 - smoothstep(1.0, 0.98, cos((theta + pi/2.0) * 50.0));\n    rgb *= q;\n    return rgb;\n}\n\nvec3 toneFloor(in vec2 p) {\n    return texture(iChannel0, fract(p * 0.03)).rgb;\n}\n\nvec3 tone(in ray_t r, in hit_t h) {\n    switch (h.mtl) {\n        case mtl_0:\n            return toneSky(r);\n        case mtl_floor:\n            return toneFloor(h.pnt.xz);\n        default:\n            return materials[h.mtl].color;\n    }\n}\n\n//------------------------------------------------------------------\n\nuint gRayCount;\nvoid runRays() {\n\n    // accumulates in gRGB.\n    \n    gRayCount = 0u;\n    \n    while (!QIsEmpty()) {\n        gRayCount += 1u;\n        ray_t r = QDequeue();\n\n        hit_t h = newHit();\n        h.mtl = mtl_0;\n        rayVsScene(r, h);\n        \n        if (!h.hit) {\n            // no hit\n            gRGB += r.amt * tone(r, h);\n        }\n        else {\n            // a hit!\n            // \"nrm\" here is the hit-facing normal,\n            // while h.nrm is the \"outward\" facing normal.\n            \n            mtl_t m = materials[h.mtl];\n            \n            vec3  nrm     = h.nrm * r.side;\n            float R0      = schlickR0(m.ior, ior_air);\n            float reflAmt = schlick  (R0, dot(r.rd, -nrm));            \n            float trnsAmt = m.diffVsTrns * (1.0 - reflAmt);\n            float diffAmt = (1.0 - m.diffVsTrns) * (1.0 - reflAmt);\n                        \n            reflAmt *= r.amt;\n            trnsAmt *= r.amt;\n            diffAmt *= r.amt;\n\n            if (diffAmt > cMinRayAmt) {\n                // diffuse lighting at surfaces.\n                // cast a ray for shadows.\n                ray_t shdRay;\n                shdRay.ro         = h.pnt + h.nrm * cSurfEps;\n                shdRay.rd         = gSunDir;\n                shdRay.amt        = diffAmt;\n                shdRay.side       = 1.0;\n                hit_t shdHit      = newHit();\n                \n                float sunDot      = max(0.0, dot(gSunDir, h.nrm));\n                \n                rayVsScene(shdRay, shdHit);\n                float lit = 1.0 - float(shdHit.hit);\n                float blur = shdHit.missT * 0.03;\n                lit *= smoothstep(0.0, blur, shdHit.miss);\n                                \n                vec3 diff = lit * diffAmt * sunDot * tone(r, h);\n                                \n                gRGB += diff;\n            }\n\n            // moving on to transmission and then reflection.\n            \n            if (QSpaceLeft() < 2u) {\n                continue;\n            }\n            \n            if (gRayCount >= cMaxRays) {\n                continue;\n            }\n            \n            if (trnsAmt > cMinRayAmt) {\n                float eta = ior_air / m.ior;\n                if (r.side < 0.0) {\n                    eta = 1.0 / eta;\n                }\n                vec3 trnRayDir = refract(r.rd, nrm, eta);\n                if (dot(trnRayDir, trnRayDir) < 0.001) {\n                    // total internal reflection.\n                    // this is theoretically impossible for a ray that entered a sphere,\n                    // but keeping it in here anyhow for more exotic scenarios.\n                    reflAmt += trnsAmt;\n                }\n                else {\n                    ray_t trnRay;\n                    trnRay.ro   = h.pnt - nrm * cSurfEps;\n                    trnRay.rd   = trnRayDir;\n                    trnRay.side = -r.side;\n                    trnRay.amt  = trnsAmt;\n                    \n                    QEnqueue(trnRay);\n                }\n            }\n\n            if (reflAmt > cMinRayAmt) {\n                ray_t rflRay;\n                rflRay.ro   = h.pnt + nrm * cSurfEps;\n                rflRay.rd   = reflect(r.rd, nrm);\n                rflRay.side = r.side;\n                rflRay.amt  = reflAmt;\n\n                QEnqueue(rflRay);\n            }\n        }\n    }\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime * 0.2;\n    gSmoothEps = 4.0 / MINRES;\n    \n    // pixelate\n    vec2 XY2 = XY - (fract(XY / cPixelize ) - 0.5) * cPixelize;\n    \n    vec2 xy = viewportFromScreen(XY2);\n    \n    vec4 inp = texelFetch(iChannel1, ivec2(0), 0);\n    vec2 m  = viewportFromScreen(inp.xy);\n    if (length(inp.xy) < 50.0) {\n        const vec2 start = vec2(0.7, -0.7);\n        m = mix(start, v0.xy, smoothstep(2.0, 9.0, iTime));\n    }\n    gSceneParam1 = inp.z / iResolution.y;\n\n    setupScene();\n                \n    // setup camera\n    float theta     = sign(m.x) * pow(abs(m.x), 2.0) * -pi / 3.0;\n    vec3  lookTo    = vY * gHeight;\n    vec3  lookFrom  = vec3(cos(theta), gHeight - 15.0 * sign(m.y) * pow(abs(m.y), 2.5), sin(theta));\n    lookFrom.xz  *= gSmlLensX * 1.2 + abs(theta * 15.0);\n    lookTo.x += abs(theta * 2.0);\n    //lookFrom = vec3(gBigLensFcl * 0.5 + gSmlLensFcl * 2.0, gHeight, 0.0);\n    // don't let camera go below the floor\n    lookFrom.y = max(0.1, lookFrom.y);\n    \n    // configure our initial ray for this pixel\n    ray_t r0;\n    r0.ro   = lookFrom;\n    r0.rd   = matLookTo(lookFrom, lookTo) * normalize(vec3(xy, -3.0));\n    r0.amt  = 1.0;\n    r0.side = 1.0;\n    QEnqueue(r0);\n    \n    gRGB = v0;\n    runRays();\n    \n    gRGB = pow(gRGB, vec3(1.0/2.2));\n       \n    // uncomment to view relative # of rays per pixel\n    // gRGB = v1 * float(gRayCount) / float(cMaxRays);\n    \n    RGBA = vec4(gRGB, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n#define ZERO   (0)\n\nconst float pi = 3.14159265359;\nconst vec3  v1 = vec3(1.0);\nconst vec3  v0 = vec3(0.0);\nconst vec3  vX = vec3(1.0, 0.0, 0.0);\nconst vec3  vY = vec3(0.0, 1.0, 0.0);\nconst vec3  vZ = vec3(0.0, 0.0, 1.0);\n\n//--------------------------------------------------------------------------------\n\nstruct ray_t {\n    vec3  ro;\n    vec3  rd;\n    float amt;   // [0, 1] amount of light left in the ray\n    float side;  // -1 = inside, 1 = outside.\n};\n\nstruct hit_t {\n    bool  hit;\n    float t;\n    vec3  pnt;\n    vec3  nrm;\n    uint  mtl;\n    float miss;  // smallest distance to a shadowing point.\n    float missT; // distance to miss.\n};\n\nstruct mapSample_t {\n    float dist;\n    uint mtl;\n};\n#define MST mapSample_t\n\nstruct mtl_t {\n    float ior;\n    float diffVsTrns;\n    vec3  color;\n};\n\nhit_t newHit() {\n    hit_t ret;\n    ret.hit      = false;\n    ret.t        = 1e9;\n    ret.miss     = 1e9;\n    ret.missT    = 1e9;\n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n\nconst float ior_air     =  1.0003;\nconst float ior_aerogel =  1.03;\nconst float ior_ice     =  1.309;\nconst float ior_water   =  1.333;\nconst float ior_quartz  =  1.46;\nconst float ior_diamond =  2.42;\nconst float ior_shiny1  =  4.0;    // ad hoc\nconst float ior_mrr     =  1e2;    // ad hoc\n\n\n//--------------------------------------------------------------------------------\n\n// fifo queue.\n// This is a basic ringbuffer.\n// NO ERROR CHECKING\n//\n// usage:\n// #define Q_TYPE and Q_MAX_ENTRIES,\n// then put Q_IMPLEMENTATION.\n// (Q_MAX_ENTRIES is a uint)\n//\n// for example:\n// #define Q_TYPE        ray_t\n// #define Q_MAX_ENTRIES 16u\n// Q_IMPLEMENTATION\n//\n// orion elenzil 2022.\n#define Q_IMPLEMENTATION                           \\\nconst uint gQCapacity = Q_MAX_ENTRIES;             \\\nconst uint gQNumSlots = gQCapacity + 1u;           \\\nQ_TYPE gQ[gQNumSlots];                             \\\nuint gQHead = 0u;                                  \\\nuint gQTail = 0u;                                  \\\n                                                   \\\nuint QCount() {                                    \\\n    if (gQHead >= gQTail) {                        \\\n        return gQHead - gQTail;                    \\\n    }                                              \\\n    else {                                         \\\n        return gQNumSlots - (gQTail - gQHead);     \\\n    }                                              \\\n}                                                  \\\n                                                   \\\nuint QSpaceLeft() {                                \\\n    return gQCapacity - QCount();                  \\\n}                                                  \\\n                                                   \\\nbool QIsFull() {                                   \\\n    return QSpaceLeft() == 0u;                     \\\n}                                                  \\\n                                                   \\\nbool QIsEmpty() {                                  \\\n    return QCount() == 0u;                         \\\n}                                                  \\\n                                                   \\\nuint _QEnqueueIndex() {                            \\\n    gQHead = (gQHead + 1u) % gQNumSlots;           \\\n    return gQHead;                                 \\\n}                                                  \\\n                                                   \\\nuint _QDequeueIndex() {                            \\\n    gQTail = (gQTail + 1u) % gQNumSlots;           \\\n    return gQTail;                                 \\\n}                                                  \\\n                                                   \\\nvoid QEnqueue(Q_TYPE item) {                       \\\n    gQ[_QEnqueueIndex()] = item;                   \\\n}                                                  \\\n                                                   \\\nQ_TYPE QDequeue() {                                \\\n    return gQ[_QDequeueIndex()];                   \\\n}\n////////////////////////////////////////////////////\n\n\n//--------------------------------------------------------------------------------\n\n// assumes 'up' is world Y.\nmat3 matLookTo(in vec3 lookFrom, in vec3 lookTo) {\n    vec3 fw = -normalize(lookTo - lookFrom);\n    vec3 rt =  normalize(cross(fw, vY));\n    vec3 up =  cross(rt, fw);\n    \n    return mat3(rt, up, fw);\n}\n\nmat2 matRot2(in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, s, -s, c);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvoid rayVsPlane(in ray_t ray, in vec3 n, in float d, uint mtl, inout hit_t hit) {\n    float t = -(dot(ray.ro, n) + d) / (dot(ray.rd, n));\n    if (t > 0.0 && t < hit.t) {\n        hit.hit = true;\n        hit.t   = t;\n        hit.mtl = mtl;\n        hit.pnt = ray.ro + hit.t * ray.rd;\n        hit.nrm = n;\n    }\n}\n\n//--------------------------------------------------------------------------------\n\n// https://en.wikipedia.org/wiki/Schlick%27s_approximation\nfloat schlickR0(in float n1, in float n2) {\n    // same if n1 and n2 are swapped.\n    float q  = (n1 - n2) / (n1 + n2);\n    float q2 = q * q;\n    return q2;\n}\n\nfloat schlick(in float R0, in float cosTheta) {\n    float q  = 1.0 - cosTheta;\n    float q5 = q * q * q * q * q;\n    return R0 + ((1.0 - R0) * q5);\n}\n\n\n//--------------------------------------------------------------------------------\n\n// how far to offset each of two spheres of radius sphRad\n// to obtain a lens of radius lensRad\nfloat offsetToMakeLens(float sphRad, float lensRad) {\n    return sqrt(max(0.0, (sphRad * sphRad) - (lensRad * lensRad)));\n}\n\n// lensmaker's equation\nfloat radiusForFocalLength(float focalLength, float ior) {\n    return (ior - 1.0) * 2.0 * focalLength;\n}\n\nvec2 radiusAndOffsetForLens(float focalLength, float ior, float lensRad) {\n    vec2 ret;\n    \n    ret.x = radiusForFocalLength(focalLength, ior);\n    ret.y = offsetToMakeLens(ret.x, lensRad);\n    \n    return ret;\n}\n\n\n//--------------------------------------------------------------------------------\n// @Gijs\n// https://www.shadertoy.com/view/7dSSzy Basic : Less Simple Atmosphere\n\nvec3  SUN_COLOR = vec3(1.0,1.0,1.0);\nvec3  SKY_SCATTERING = vec3(0.1, 0.3, 0.7);\n// vec3  SUN_VECTOR;\nfloat SUN_ANGULAR_DIAMETER = 0.08;\nfloat CAMERA_HEIGHT = -0.3;\n\n\n// Consider an atmosphere of constant density & isotropic scattering \n// Occupying, in the y axis, from -infty to 0\n// This shaders ``solves'' that atmosphere analytically.\n\nfloat atmosphereDepth(vec3 pos, vec3 dir)\n{\n    return max(pos.y, 0.1)/ max(dir.y, 0.0);\n}\n\nvec3 transmittance(float l)\n{\n    return exp(-l * SKY_SCATTERING);\n}\n\nvec3 simple_sun(in vec3 dir, in vec3 lightDir)\n{\n    //sometimes |dot(dir, SUN_VECTOR)| > 1 by a very small amount, this breaks acos\n    float a = acos(clamp(dot(dir, lightDir),-1.0,1.0));\n    float t = 0.005;\n    float e = smoothstep(SUN_ANGULAR_DIAMETER*0.5 + t, SUN_ANGULAR_DIAMETER*0.5, a);\n    return SUN_COLOR * e;\n}\n\nvec3 simple_sky(in vec3 p, in vec3 d, in vec3 lightDir)\n{\n    p.y *= -1.0;\n    p.y = max(0.1, p.y);\n    float l = atmosphereDepth(p, d);\n    vec3 sun = simple_sun(d, lightDir) * transmittance(l);\n    float f = 1.0 - d.y / lightDir.y;\n    float l2 = atmosphereDepth(p, lightDir);\n    vec3 sk = simple_sun(lightDir, lightDir) * transmittance(l2) / f * (1.0 - transmittance(f*l));\n    return clamp(sun + sk, 0.0, 1.0);\n}\n\n///////////////////////////////////////////////////////\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCyl(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame(in vec3 p, in vec3 b, in float e ) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinderX( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// return a symmetric bi-concave lens shape given:\n// desc.x = sphere radius\n// desc.y = lens radius\n// desc.z = chamfer radius\nfloat sdLensCc(in vec3 p, vec3 desc) {\n\n    p.x = abs(p.x) + desc.y;\n    \n    float dCyl = length(p.yz) - desc.z;\n    \n    float d = length(p) - desc.x;\n    \n    d = max(d, dCyl);\n    \n    return d;\n}\n\nvoid opUnion(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist < cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opMinus(inout mapSample_t cur, mapSample_t new) {\n    if (-new.dist > cur.dist) {\n        cur.dist = -new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opInter(inout mapSample_t cur, mapSample_t new) {\n    if (new.dist > cur.dist) {\n        cur.dist = new.dist;\n        cur.mtl  = new.mtl;\n    }\n}\n\nvoid opUnion(inout float cur, float new) {\n    cur = min(cur, new);\n}\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// mouse state\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (iFrame < 2) {\n        RGBA = vec4(0.0, 0.0, iResolution.y / 2.0, 0.0);\n        return;\n    }\n    \n    if (IJ == ivec2(0)) {\n        RGBA = texelFetch(iChannel0, IJ, 0);\n        if (iMouse.x > iResolution.x - 100.0) {\n            RGBA.z = iMouse.y;\n        }\n        else {\n            RGBA.xy = iMouse.xy;\n        }\n    }\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}