{
    "Shader": {
        "info": {
            "date": "1581436123",
            "description": "billy gibbons' whiskey runner - car physics simulation (needs a while to compile on windows)\nsteering: WASD, or cirsor keys\nzoom: +/- keys",
            "flags": 48,
            "hasliked": 0,
            "id": "3ttXzj",
            "likes": 52,
            "name": "whiskey runner",
            "published": 3,
            "tags": [
                "simulation",
                "physics",
                "car",
                "zztop"
            ],
            "usePreview": 1,
            "username": "flockaroo",
            "viewed": 1542
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop whiskey runner\n\n//#define RENDERED_REFECTIONS\n#define SHADOW\n#define SCRATCHES\n#define RENDER_GLASS\n//#define RENDER_BBOX\n#define Res  (iResolution.xy)\n\n#define RandTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n#ifndef PhysTex\n#define PhysTex iChannel1\n#endif\n#ifndef RandTex\n#define RandTex iChannel0\n#endif\n\n\nvec4 myRandInterpol(vec2 uv)\n{\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv-1./512.);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    //f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\n//#define RND_SC (256./64.)\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=\n     .8*myRandInterpol(p.xy*.00006*RND_SC)\n    +.4*myRandInterpol(p.xy*.00012*RND_SC)\n    //+.1*textureLod(iChannel0,p.xy*.12*RND_SC,0.)\n    ;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    vec2 fp=fract(p.xy*.5)-.5;\n    //return .2*exp(-fp.x*fp.x/.1/.1)+.2*exp(-fp.y*fp.y/.1/.1);\n    return rTerr.x*min(pp*pp,40.)+.1*textureLod(RandTex,p.xy*.012*.5*RND_SC,0.).x;\n}\n\nvec3 terrNormal(vec3 pos)\n{\n    //float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(1,0,0))-hTerr(pos-vec3(1,0,0)),\n    \t\t\t  hTerr(pos+vec3(0,1,0))-hTerr(pos-vec3(0,1,0)))*.5;\n    return normalize(vec3(-dh,1));\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,0)*.5,1.); WheelOffsFL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,0)*.5,1.); WheelOffsFR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,0)*.5,1.); WheelOffsRL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,0)*.5,1.); WheelOffsRR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n}\n\n\n#define BG 0.\n#define CARBODY 1.\n#define GUMMI 2.\n#define RIM 3.\n#define FLOOR 4.\n#define CHROME 5.\n#define INTERIOR 6.\n#define GLASS 7.\n#define CHASSIS 8.\n#define DBG_GREEN 9.\n#define DBG_RED 10.\n\n//#define SET_PREV_MAT(x) mat=(abs(d-d_mat)>.0001)?(x):mat; d_mat=d;\n//#define SET_PREV_MAT(x) mat=mix(mat,x,step(.0001,abs(d-d_mat))); d_mat=d;\n//#define SET_PREV_MAT(x) mat+=step(.0001,abs(d-d_mat))*(-mat+x); d_mat=d;\n#define SET_PREV_MAT(x) if(abs(d-d_mat)>.0001) mat=(x); d_mat=d;\n\nstruct Material{\n    vec3 col;\n    float refl;\n    float scratchy;\n    vec2  scratchScale;\n};\n\n//#define MAT_CARBODY    Material(vec3(.8, .05, .1),    -1.,   0.6, vec2(1,.01))\n#define MAT_BG         Material(vec3(-1,-1,-1),       -1.,   0.0, vec2(1,.01))\n#define MAT_CARBODY    Material(vec3(.5),    1.,   1., vec2(1,.03))\n#define MAT_GUMMI      Material(vec3(.15,.15,.15),    -0.35, 1.0, vec2(1,.1)*.3)\n#define MAT_RIM        Material(vec3(.3),          -1.,   0.6, vec2(1,.01))\n#define MAT_FLOOR      Material(vec3(.36,.35,.34)*1.2,            -0.2, 0.0, vec2(1,.01))\n#define MAT_CHROME     Material(vec3(.8),              1.,   0.1, vec2(1,.1))\n#define MAT_INTERIOR   Material(vec3(.9,.7,.5)*.3,    -0.0,  0.0, vec2(1,.01))\n#define MAT_GLASS      Material(vec3(1),              -1.,   0.6, vec2(1,.01))\n#define MAT_CHASSIS    Material(vec3(.45),              1.,  1.0, vec2(1,.01)*.5)\n#define MAT_DBG_GREEN  Material(vec3(0,1,0), -1.,  0.0, vec2(1,.01))\n#define MAT_DBG_RED    Material(vec3(1,0,0), -1.,  0.0, vec2(1,.01))\n\n#define USE_MTL_ARRAY \n#ifdef USE_MTL_ARRAY\nconst Material mat[11] = Material[] (\nMAT_BG        ,\nMAT_CARBODY   ,\nMAT_GUMMI     ,\nMAT_RIM       ,\nMAT_FLOOR     ,\nMAT_CHROME    ,\nMAT_INTERIOR  ,\nMAT_GLASS     ,\nMAT_CHASSIS   ,\nMAT_DBG_GREEN ,\nMAT_DBG_RED\n);\nMaterial getMaterial(float mtl) { return mat[int(mtl)]; }\n#else\nMaterial getMaterial(float mtl)\n{\n    if(mtl==BG)           return MAT_BG        ;\n    if(mtl==CARBODY)      return MAT_CARBODY   ;\n    if(mtl==GUMMI)        return MAT_GUMMI     ;\n    if(mtl==RIM)          return MAT_RIM       ;\n    if(mtl==FLOOR)        return MAT_FLOOR     ;\n    if(mtl==CHROME)       return MAT_CHROME    ;\n    if(mtl==INTERIOR)     return MAT_INTERIOR  ;\n    if(mtl==GLASS)        return MAT_GLASS     ;\n    if(mtl==CHASSIS)      return MAT_CHASSIS   ;\n    if(mtl==DBG_GREEN)    return MAT_DBG_GREEN ;\n    if(mtl==DBG_RED)      return MAT_DBG_RED   ;\n}\n#endif\n\n#define DESERT FLOOR\n#define TIRE GUMMI\n#define GRILL CHROME\n\nbool enable_glass=true;\n\n#ifndef RandTex \n#define RandTex iChannel1\n#endif\n\nvec4 rand3d(vec3 uv)\n{\n    float pz=uv.z*256.;\n    float z=floor(pz);\n    vec2 uv1=uv.xy+z*vec2(17,31)/256.;\n    vec2 uv2=uv1+vec2(17,31)/256.;\n    return mix(textureLod(RandTex,uv1,0.),textureLod(RandTex,uv2,0.),pz-z);\n}\n\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n    vec3 sun = normalize(getLightDir());\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col,1);\n}\n\n\nfloat distTire(vec3 p, float r)\n{\n    p=abs(p);\n    float d=1000.;\n    d=min(d,length(p)-r);\n    float ang = atan(p.z,p.y);\n    float l=length(p.zy);\n    p.x+=cos(ang*100.)*.005*smoothstep(.87*r,1.*r,l);\n    d=max(d,distTorus(p.yzx+vec3(0,0,.03),r*.78,r*.28));\n    d=max(d,-l+r*.61);\n    float dx=.04;\n    float xfr=mod(p.x,dx);\n    float x=p.x-xfr+dx*.5;\n    d=max(d,-distTorus(p.yzx-vec3(0,0,x),sqrt(r*r-x*x),.01));\n    return d;\n}\n\n\nfloat distRim(vec3 p, float r)\n{\n    r*=.6;\n    vec3 p0=p;\n    p.x=abs(p.x);\n    //p.yz=(p.y>p.z)?p.zy:p.yz; // only first 1/8 segment\n    p=p.zxy;\n    float d=1000.;\n    d=min(d,sdRoundedCylinder(p,r,.01,.6*r));\n    p-=vec3(0,.6*r,0);\n    d=-smin(-d,sdRoundedCylinder(p,.97*r,.01,.6*r),.015);\n    d=-smin(-d,sdRoundedCylinder(p,.89*r,.01,.8*r),.015);\n    float d_i=sdRoundedCylinder(p,.77*r,.01,1.9*r);\n    d=-smin(-d,d_i,.015);\n    \n    float d2=length(p0-vec3(-r*.6,0,0))-r*1.05;\n    d2=max(d2,d_i);\n    d2=-smin(-d2,sdRoundedCylinder(p,.4*r,.01,.8*r),.1);\n    d2=abs(d2)-.005;\n    d2=max(d2,-p0.x);\n\n    float mang,ang;\n    float ang0 = atan(p.z,p.x);\n    float dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n\n    d2=-smin(-d2,(length(p.xz-.95*r*cos(ang-vec2(0,1.57)))-.25*r),.01);\n    d=min(d,d2);\n    dang=PI2/5.;\n    mang=mod(ang0,dang);\n    ang=ang0-mang+dang*.5;\n    d=min(d,max(abs(p.y+.6*r)-.22*r,(length(p.xz-.3*r*cos(ang-vec2(0,1.57)))-.05*r)));\n    d=min(d,sdRoundedCylinder(p-vec3(0,-.23,0),.1*r,.01,.25));\n    float l=length(p0.zx);\n    d=min(d,sdRoundedCylinder(p0.zxy-vec3(0,-.06,0),.7*r,.02,.05-.015*fermi((length(p.xz)-.6*r)/.003)));\n    return d;\n}\n\nconst vec3 bbpos=vec3(0,-.06,.07);\nconst vec3 bbsize=vec3(ALLW*1.12,3.63,1.5);\nconst vec3 bbpos1=vec3(0,.04,-.231);\nconst vec3 bbsize1=vec3(ALLW*1.08,3.68,1.23);\nconst vec3 bbpos2=vec3(0,.23,.33);\nconst vec3 bbsize2=vec3(ALLW*.83,1.25,.7);\n\nfloat rille2(float d, float w)\n{ \n    return w*exp2(-d*d*2./w/w);\n}\nfloat rille(float d, float w)\n{\n    ///// gauss\n    //return w*exp2(-d*d*2./w/w);\n    ///// exp\n    return w*exp2(-abs(d)*1.44/w);\n    ///// linear\n    //return max(abs(d)-w,0.);\n}\n\n#ifdef USE_SIMDATA\n#define SteerAng (texelFetch(iChannel1,ivec2(4,0),0).x)\n#define WheelRot (texelFetch(iChannel1,ivec2(5,0),0))\n#define CamDistFact (texelFetch(iChannel1,ivec2(4,0),0).y)\n#else\nuniform float SteerAng;\nconst vec4 WheelRot=vec4(0);\n#define CamDistFact 1.0\n#endif\n\n#define PF WheelPosFL\n#define PR WheelPosRL\n\n\nvec2 distCar(vec3 p)\n{\n    //p.xy*=-1.;\n    vec3 p0rot=p;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),-.023));\n    float d=1000., d_mat=1001., mat=-1.;\n    SET_PREV_MAT(BG);\n    p*=2.;\n    if(p.x<0.) p.x=-p.x;\n    vec3 p0=p+vec3(0,0,.13);\n//#define SIMPLE_CAR\n#ifndef SIMPLE_CAR\n    //d=min(d,length(p)-.5);\n    p=p0+vec3(0,.1,0);\n    float drumpf=sdRoundBox( p, vec3(RUMPFW+p.y*.15-p.y*p.y*.04+p.z*p.y*.03, \n                                 3.2-p.z*.3+p.z*p.z*.1 - step(0.,-p.y)*p.x*.3-step(0.,p.y)*.4*p.z, \n                                 .8+p.y*.02-p.x*p.x*.05*(1.+.01*(p.y*p.y*p.y*p.y))),\n                             max(p.y*.04,mix(.25+p.y*.05,.07,-p.z*1.5+.5)))*.7;\n    p=p0-vec3(0,.5,.7);\n    float dcabin = sdRoundBox( p, vec3(RUMPFW*1.04+p.y*.07-p.y*p.y*.08+p.z*.0, \n                                       1.2-p.z*(.7-.4*step(0.,p.y)),\n                                       .7+p.y*.07-p.x*p.x*.05-p.y*p.y*.05),\n                               .33+.15*p.y )*.7;\n    d=min(d,dcabin);\n    // rear front screen\n    p=p0-vec3(0,.4,.88+.10-.06*p.x*p.x);\n    //float dfrontscr=sdRoundBox( p, vec3(RUMPFW*.4-step(0.,p.y)*.2,2.,.1-step(0.,p.y)*.03)*2., .1 )*.7;\n    // only 2d needed - not sure if rect is faster - maybe some compilers can optimize something out...\n    float sy=step(0.,p.y);\n    float dfrontscr=sdRoundRect( p.xz-vec2(0,-.12+sy*.1), vec2(RUMPFW*.4-sy*.2,.12-step(0.,p.y)*.07)*2., .14-sy*.04 )*.7;\n    dfrontscr=max(dfrontscr,-(drumpf-.07));\n    d=-smin(-d,dfrontscr,.03);\n    //d+=rille(dfrontscr-.03,.007);\n    // side screens\n    p=p0-vec3(0,.23,.91);\n    vec3 sidebox=vec3(2.,.35-(p.z+.3)*(.1+step(0.,p.z+.3)*.1),.065+p.y*.023-.05*p.y*p.y*step(0.,p.z))*2.;\n    //float dsidescr=sdRoundBox( p-vec3(0,.1*p.z,.015*p.y), sidebox, .13+.04*p.y )*.7;\n#if 1\n    float dsidescr=sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y), sidebox.yz, .1+.07*p.y )*.7;\n    //p.z+=.25;\n    //float ddoor   =sdRoundBox( p-vec3(0,.1*p.z,.015*p.y)+vec3(0,0,.59), sidebox+vec3(0,0,.59), .13+.04*p.y )*.7;\n    float ddoor   =sdRoundRect( p.yz-vec2(.1*p.z,.015*p.y)+vec2(0,.79), sidebox.yz+vec2(0,.79), .08+.07*p.y )*.7;\n#else\n    // not sure if even making 2 rects at once is really faster...\n    vec2 dssdoor=sdRoundRect2( (p.yz-vec2(.1*p.z,.015*p.y)).xyxy+vec4(0,0,0,.59), sidebox.yzyz+vec4(0,0,0,.59), vec2(.13+.04*p.y) )*.7;\n    float dsidescr=dssdoor.x;\n    float ddoor=dssdoor.y;\n#endif\n    ddoor-=.07;\n    //p=p0-vec3(0,-2.05,.77)*1.;\n    //p=transformVecByQuat(p-vec3(0,p.x*.25,0),axAng2Quat(vec3(1,0,0),.28));\n    //float dhood   =sdRoundBox( p,vec3(ALLW,.9,1.),.18)*.7;\n    //float dhood   =sdRoundRect( p.yz,vec2(.9,2.),.18)*.7;\n    float dhood1 =  dot(p0-vec3(0,-3.22,0),vec3(.28,-1,.28));\n    float dhood2 =  -dot(p0-vec3(0,-1.35,0),vec3(.28,-1,.28));\n    float dhood=max(dhood1,dhood2);\n    d=-smin(-d,dsidescr,.05);\n    //d=-smin(-d,abs(dsidescr-.03),.02);\n    d-=clamp((abs(dsidescr-.03)-.016)*.2,-0.02,0.);\n    p=p0;\n    p-=vec3(0,0,-.77);\n    float dz1=.5*(cos(p.x*4./ALLW)-1.)*(cos(p.y*1.5-2.-step(2.86,-p.y)*.8*(p.y+2.86)*(p.y+2.86))*.4+.4)*step(.766,-p.y);\n    float dz2=.5*(cos(p.x*3.3/ALLW)-1.)*clamp((cos(p.y*.6-1.5)*2.5-2.)*1.7,0.,1.);\n    p.z+=dz1+dz2;\n    p-=vec3(0,-.07,0);\n    //float dfender = sdHalfRoundBox( p, vec3(ALLW+p.y*.05,\n    //                            3.5-.12*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16),\n    //                            .16 )*.7;\n    \n    #if 1\n    float dfender = sdRoundBox( p-vec3(0,0,-.3), vec3(ALLW+p.y*.05,\n                                3.5-.1*cos(p.x*p.x*3.3/ALLW*(.85+.15*step(0.,-p.y)))*(.3+.7*step(0.,-p.y)),.16+.3),\n                                .16 )*.7;\n    float ss=1.-smoothstep(-3.,-1.8,p.y);\n    float fz0=p.z-dz1*(exp2(-ss*7.));\n    dfender=min(dfender,(sqrt(dfender*dfender+fz0*fz0)-.01)*.7);\n    dfender=max(dfender,-(fz0)*.7);\n    //d=min(d,dfender);\n    #endif\n    \n    SET_PREV_MAT(CARBODY);\n    //drumpf-=clamp(abs(dhood)-.005,-0.02,0.);\n    \n    //drumpf = max(drumpf,-sdBox(pi+vec3(0,.12,0),vec3(2.,.05,.1))/1.4);\n\n    //drumpf=max(drumpf,-sdRoundedCylinder((p0-PR).zxy,.8,.05,.5));\n    float dfloorline=p0.z+0.7-.5*(.5-.5*cos((p0.y*1.-p0.y*p0.y*.1)*step(0.,-p0.y)));\n    ddoor=-smin(-ddoor,dfloorline-.06,clamp(.15-.1*p0.y,0.01,.3));\n    dhood=-smin(-dhood,dfloorline-.08,clamp(.25+.05*p0.y,0.01,.3));\n    drumpf-=max(-dfloorline*.5-1.3*dfloorline*dfloorline,0.)*5.*clamp(((-p0.y-1.8)-.9*(-p0.y-1.8)*(-p0.y-1.8))*abs(-p0.y-1.8),0.,11.);\n    //drumpf-=rille2(dfender,.02);\n\n    drumpf+=rille(dhood,.005);\n\n    dfloorline=smin(length((p0-PR-vec3(0,0,.15)).zy)-.75,dfloorline,.4);\n    //drumpf-=.5*rille2(length((p0-PR-vec3(0,0,.15)).zy)-.75,.03);\n    drumpf-=.5*rille2(dfloorline,.03)*smoothstep(-.05,.05,p0.y+3.1);\n    \n    //side stripe\n    p=p0+vec3(0,.1,0);\n    drumpf-=.6*rille2(p.z-.4+.03*p.y-.1*p.x,.02)*(1.-smoothstep(2.4,2.6,abs(p0.y+.3)));\n\n    //drumpf+=min(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2+.02*smoothstep(2.8,2.9,-p.y),0.)/1.5; \n    //float dBigZ=length(vec2(bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.2,drumpf))-.01;\n    float dBigZ=bigZ((p.yz-vec2(.7,0))*vec2(-1.5,2.3)*1.3)*.085*(1.-smoothstep(2.55,2.6,abs(p0.y+.35)))+abs(drumpf);\n    //drumpf+=dBigZ;\n    \n    // side lamelles\n    vec3 pi = p0+vec3(0,-drumpf*2.-p0.z*.3,0)-vec3(0,-1.78,.3);\n    drumpf = max(drumpf,-sdBox(pi-vec3(0,clamp(floor(pi.y/.12+.5)*.12,-1.08,0.34),0),vec3(2.,.047,.11))/1.4);\n    \n    drumpf+=rille(sdRoundRect(p0.yz-vec2(-2.05+(p0.z-.3)*.3,.3),vec2(.8,.15),.03),.005);\n    \n    drumpf=min(drumpf,dBigZ);\n    \n    //*clamp((abs(p.z-.55)-.02)*.5,-0.02,0.);\n    d=smin(d,drumpf,.03);\n    //d=-smin(-d,abs(ddoor),.01);\n    //d-=clamp(abs(ddoor)-.005,-0.02,0.);\n    d+=rille(ddoor,.005);\n    //d=min(d,dfender+.01-.03*smoothstep(-1.45,-1.4,-p0.y)*smoothstep(-.95,-.9,p0.y));\n    //SET_PREV_MAT(TIRE);\n    \n    float z=p.z+.2;\n    float dgrillhole=sdRoundBox( p-vec3(0,-3.,-.02), vec3(.18*.9*RUMPFW-step(0.,-z)*z*z*.58*RUMPFW,.5,.33)*2., .1 );\n    d=-smin(-d,dgrillhole,.04);\n    float f=smoothstep(-3.,0.,p.y);\n    //float d2 = -smin(-d,-dgrillhole+.15,.04)\n    d=-smin(-d,-dgrillhole+.1+f*10.,.04);\n    float newmtl=(dhood1<0.)?CARBODY:GRILL;\n    SET_PREV_MAT(newmtl);\n    //SET_PREV_MAT(TIRE);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.01,dcabin+.01))-.015);\n    SET_PREV_MAT(GUMMI);\n    d=min(d,step(0.,p.y)+length(vec2(dfrontscr-.02,dcabin+.01))-.02);\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3( 0, -3.26+.3*p.z+.35*p.x-.1*p.z*p.z, 0);\n    p.x=mod(p.x+.005,.025)-.0125;\n    d=min(d,max(dgrillhole,(length(p.xy)-.007)*.8));\n    SET_PREV_MAT(GRILL);\n\n    p=p0-vec3(0,.7,.87-.2);\n    d=max(d,-dcabin-.06);\n    SET_PREV_MAT(INTERIOR);\n    \n#ifdef RENDER_GLASS\n    // window glass\n    //if(enable_glass)\n    {\n        d=min(d,dcabin+.035+(enable_glass?0.:1000.));\n        SET_PREV_MAT(GLASS);\n    }\n#endif\n\n#else // SIMPLE_CAR\n    d=min(d,sdBox(p,vec3(2,5,1.)*.5));\n    SET_PREV_MAT(GRILL);\n#endif // SIMPLE_CAR\n\n    p0-=vec3(0,0,.13);\n    \n    vec3 pf=p0-PF;\n    vec3 pr=p0-PR;\n    \n    // check tire only once\n    //bool rear = (dot(pr,pr)<dot(pf,pf));\n    float rear = step(0.,p0rot.y);\n    float left = step(0.,p0rot.x);\n    float leftSgn=sign(p0rot.x);\n    p=mix(pf,pr,rear); float siz=mix(WheelRadiusF,WheelRadiusR,rear);\n    \n    float axOffs=0.;\n    vec4 axQuat=vec4(0,0,0,1);\n#ifdef USE_SIMDATA\n    vec3 wo=vec3(mix(WheelDistF,WheelDistR,rear)*.5,0,0);\n    // wheel offsets\n    vec4 qf=axAng2Quat(vec3(0,1,0),(WheelOffsFL-WheelOffsFR)/WheelDistF*leftSgn);\n    vec4 qr=axAng2Quat(vec3(0,1,0),(WheelOffsRL-WheelOffsRR)/WheelDistR*leftSgn);\n    axQuat=mix(qf,qr,rear);\n    p=transformVecByQuat(p+wo*2.,axQuat)-wo*2.;\n    axOffs=mix(WheelOffsFR+WheelOffsFL,WheelOffsRR+WheelOffsRL,rear)*.5;\n    p.z-=axOffs;\n#endif\n\n#if 1\n    {\n    // steering rotation of front wheels\n    vec4 q=axAng2Quat(vec3(0,0,1),leftSgn*(1.-.1*leftSgn*sign(SteerAng))*SteerAng*(1.-rear));\n#if 0\n    p+=vec3(.07,0,0);\n    p = (p + 2.0 * cross( q.xyz, cross( q.xyz, p ) + q.w*p ));\n    p-=vec3(.07,0,0);\n#else\n    // the above is exactly this below... why is this not working... bug in nvidia pipeline?! or am i missing sth here??\n    p=transformVecByQuat(p+vec3(.16,0,0),q)-vec3(.16,0,0);\n#endif\n    }\n#endif\n\n#ifdef USE_SIMDATA\n    // wheel rotations\n    float rot=WheelRot.x;\n    p=transformVecByQuat(p,axAng2Quat(vec3(1,0,0),rot));\n#endif\n\n    d=min(d, distTire(p,siz));\n    SET_PREV_MAT(TIRE);\n    d=min(d, distRim(p,siz));\n    SET_PREV_MAT(RIM);\n    \n    p=p0;\n    float xx=p.x*p.x;\n    //p=pf+vec3(ALLW*.38,0,+.1-xx*.03-step(ALLW*.6,p.x)*(p.x-ALLW*.6)*.3)*2.;\n    //d=min(d,max(length(p.yz)-.05,p.x-ALLW*.7));\n    p=p0-PF*vec3(0,1,1);\n    // Frame\n    d=min(d,sdRoundBox(p-vec3(.55+p.y*.1,0,.15)+vec3(0,0,1)*(p.y+.3)*(p.y+.3)*sign(-p.y)*.38, vec3(.06-p.y*p.y*.05,.7,.08-p.y*p.y*.05), .015 ));\n    p=transformVecByQuat(p,axQuat);\n    // Blattfeder (leaf spring)\n    d=min(d,sdRoundBox(p+vec3(0,0,1)*p.x*p.x*.18*(1.-axOffs/.1), vec3(.8,.05,floor((.05-p.x*p.x*.035)/.008)*.008), .005 ));\n    p.z-=axOffs;\n    p.z+=.25*cos(p0.x*.8)-.15*fermi((p0.x-PF.x+.3)/.02);\n    d=min(d,sdRoundBox(p, vec3(1.15,.02+.02*fermi((abs(p.z)-.03)/.002),.065-p.x*p.x*.015), .005 ));\n    d=min(d,sdRoundedCylinder(p.xzy-vec3(+.9,0,0),.035,.005,.11));\n    d=min(d,sdRoundedCylinder(p.xzy-vec3(+1.15,0,0),.035,.005,.11));\n    d=max(d,-sdRoundedCylinder(p-vec3(floor(min(p.x,.8)/.1+.5)*.1,0,0),.03,.005,.11));\n    //d=min(d,dDirLine(pf,vec3(-.4,-.1,-.1),vec3(-1,0,1.5),.5)-.04);\n    //d=min(d,dDirLine(pf,vec3(-.42,.1,-.2),vec3(.05,1,-0.02),1.5)-.005+p0.y*.025);\n    d=min(d,sdLine(p0-vec3(0,PF.yz),transformVecByQuat(vec3(-.42+PF.x,.1,-.2),inverseQuat(axQuat))+vec3(0,0,axOffs),\n                      vec3(-.22+PF.x,2.,-.25)\n                  )-.02+p0.y*.015);\n    \n    SET_PREV_MAT(CHASSIS);\n    \n    #if 0\n    p=p0-vec3(.37,-1.57,0.1)*2.;\n    float d1=1000.;\n    d1=min(d1, length(p)-.11*2.1);\n    d1=-smin(-d1, (length(p+vec3(0,.35,0))-.17*2.1),.02);\n    d=min(d,d1);\n    SET_PREV_MAT(HEADLIGHTS);\n    #endif\n    \n    #ifdef RENDER_BBOX\n    //if(enable_glass)\n    {\n        p=p0;\n        //d=min(d,abs(sdRoundBox( p0rot-bbpos, bbsize*.5, .0)));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos1, bbsize1*.5, .0))+(enable_glass?0.:1000.));\n        d=min(d,abs(sdRoundBox( p0rot-bbpos2, bbsize2*.5, .0))+(enable_glass?0.:1000.));\n        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,-.06,-.11), vec3(ALLW*1.1,3.63,1.13)*.5, .0)));\n        //d=min(d,abs(sdRoundBox( p0rot-vec3(0,.33,.47), vec3(ALLW*.8,1.25,.7)*.5, .0)));\n        SET_PREV_MAT(GLASS);\n    }\n    #endif\n    \n    return vec2(d*.5,mat);\n}\n\nbool enable_car=true;\n\nfloat lorentz(float x) { return 1./(1.+x*x); }\n\nvec2 distM(vec3 p)\n{\n    float d=1000., mat=-1., d_mat=d;\n    \n    if(enable_car)\n    {\n        vec2 dm=distCar(carTrafo(p));\n        d=dm.x; mat=dm.y; d_mat=d;\n    }\n    \n    vec4 r=texture(iChannel0,p.xy*1.5*RND_SC,0.)-.5;\n    vec4 r2=texture(iChannel0,(p.xy*.005*RND_SC),-.5)-.5;\n    vec4 r3=texture(iChannel0,(p.xy*.015*RND_SC),-.0)-.5;\n    vec4 r4=texture(iChannel0,(p.xy*.03*RND_SC),-.0)-.5;\n    vec4 r5=texture(iChannel0,(p.xy*.06*RND_SC),-.0)-.5;\n    float rm=r3.y*1.+r4.y*.5+r5.y*.25;\n    float rm2=r3.z*.7+r4.z*.5;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n\n    d=min(d,p.z\n    +.66\n    -hTerr(p)\n    -.02-min(-abs(rm)*.06,.04-exp(-abs(rm/(r2.x+.15)*.25)*3.)*.07)-r.x*.0035\n    );\n    SET_PREV_MAT(FLOOR);\n    \n    //#define DEBUG\n    #ifdef DEBUG\n    vec3 accFrontAxe = texelFetch(PhysTex,ivec2(7,0),0).xyz;\n    vec3 accRearAxe  = texelFetch(PhysTex,ivec2(8,0),0).xyz;\n    d=min(d,sdLine(p,carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.),carTrafoInv((WheelPosFL+WheelPosFR)*.3,1.)+accFrontAxe)-.1);\n    d=min(d,sdLine(p,carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.),carTrafoInv((WheelPosRL+WheelPosRR)*.4,1.)+accRearAxe)-.1);\n    SET_PREV_MAT(DBG_GREEN);\n    #endif\n    \n    return vec2(d,mat);\n}\n\nfloat dist(vec3 p) { return distM(p).x; }\n\nvec3 getGradOld(vec3 p,float delta)\n{\n    float v=dist(p);\n    vec2 d=vec2(delta,0); return vec3( dist(p+d.xyy)-v,\n                                       dist(p+d.yxy)-v,\n                                       dist(p+d.yyx)-v )/delta;\n}\n\n/// my own version of a looped getGrad()\nvec3 getGrad(vec3 p,float delta)\n{\n    vec4 d=vec4(0,0,0,1); \n    vec3 s=vec3(0);\n    // use a loop here keep compiler from inlining this in win (thanks iq for the hint!)\n    for(int i=min(0,iFrame);i<4;i++)\n    {\n      \ts+=(d.xyz-d.w)*dist(p+d.xyz*delta);\n        d=d.wxyz;\n    }\n    return s/delta;\n}\n\nfloat march(inout vec3 p, vec3 dir)\n{\n    //if(!intersectBox(p-bbpos,dir,bbsize)) { enable_car=false; }\n    vec3 pc=carTrafo(p);\n    vec3 pdir=carTrafo(dir,0.);\n    //enable_car=true;\n    if(!(intersectBox(pc-bbpos1,pdir,bbsize1)||intersectBox(pc-bbpos2,pdir,bbsize2))) { enable_car=false; }\n    vec3 p0=p;\n    float eps=.001;\n    float dmin=1000.;\n    bool findmin=false;\n    float d=dist(p);\n    vec3 pmin=p;\n    for(int i=0;i<150;i++)\n    {\n        float dp=d;\n        d=dist(p);\n        p+=dir*d*.8;\n#ifdef SHADOW\n        if (d<dp) findmin=true;\n        if (findmin && d<dmin) { dmin=d; pmin=p; }\n#endif\n        if (d<eps) return 0.;\n        if (d>300.) break;\n    }\n    return clamp(dmin/length(pmin-p0)/.05,0.,1.);\n}\n\nfloat wstep(float w, float thr, float x)\n{\n    return smoothstep(thr-w*.5,thr+w*.5,x);\n}\n\nfloat getAO(vec3 pos, vec3 n)\n{    \n    float ao=1.;\n    float sc=.025;\n    float amb=.3;\n    // use loop here to keep compiler from inlining this in win (thanks iq for the hint!)\n    for( int i=min(iFrame,0); i<5; i++ )\n    {\n    \tao*=mix(dist(pos+n*sc)/sc*1.4,1.,amb);\n    \tao=clamp(ao,0.,1.);\n        sc*=2.;\n        amb=min(amb+.1,.5);\n    }\n    return ao;\n   \t/*\n    ao*=dist(pos+n*.02)/.02*1.4*.7+.3;\n   \tao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.05)/.05*1.4*.6+.4;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.1)/.1*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.2)/.2*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);\n    ao*=dist(pos+n*.4)/.4*1.4*.5+.5;\n    ao=clamp(ao,0.,1.);*/\n}\n\nvec3 lighting(vec3 pos, vec3 dir, vec3 pos0, float reflections, inout float outfres, inout float outao)\n{\n    vec3 pc=carTrafo(pos);\n    vec3 glasspos=vec3(1000.);\n    vec3 glassn=vec3(0.);\n    float mat=distM(pos).y;\n    if(mat==GLASS)\n    {\n        glasspos=pos;\n        glassn=normalize(getGrad(pos,.001));\n        enable_glass=false;\n        march(pos,dir);\n    }\n    mat=distM(pos).y;\n    \n    vec3 light=getLightDir();\n    float sh=1.;\n#ifdef SHADOW\n    vec3 posS=pos+.017*light;\n    enable_car=true;\n    sh=march(posS,light);\n#endif\n    enable_car=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    if(mat==BG) n=vec3(0,0,1);\n\n    float ao=1.;\n    ao=getAO(pos,n);\n    ao=sqrt(ao);\n    ao=ao*.7+.3;\n\n    //vec3 light = normalize(vec3(-.5,.5,2));\n    float diff=clamp(dot(n,light),0.,1.);\n\n    diff=min(diff,sh);\n    \n    // no ao in lighted areas\n    ao=mix(ao,1.,diff);\n    ao=clamp(ao,0.,1.);\n    //return vec3((diff*.6+.4)*(ao));\n    \n\n    Material mtrl=getMaterial(mat);\n\n    // evironmental reflection\n    n=normalize(n);\n    if(mat==CARBODY) // brushed metal surface\n    {\n        vec4 r1=rand3d(pc*.1);\n        vec4 r2=rand3d(pc*.05);\n        // scramble normals randomly\n        n+=clamp((r1.xyz-.5)*5.,0.,1.)*.015 + clamp((r2.xyz-.5)*5.,0.,1.)*.015;\n        // darken randomly\n        n*=clamp(r1.w*3.-1.,0.,1.)*.05 + clamp(r2.w*3.-1.,0.,1.)*.07 + .88;\n    }\n    vec3 R=reflect(dir,n);\n    vec3 refl=myenv(pos,R.xyz,1.).xyz;\n    //refl=refl*1.2+.3;\n    float fres=abs(dot(R,n));\n    fres=1.-fres;\n    fres*=fres*fres;\n    fres=fres*.9+.1;\n    float fres0=fres;\n    #ifdef SCRATCHES\n    vec3 n0=n;\n    int numscr=7;\n    float dang=1.57*2./float(numscr);\n    float ang=.5;\n    refl*=1.;\n    vec3 drefl=vec3(0);\n    float sum=0.;\n    vec3 pi=pc;\n    vec3 heading=vec3(0,0,1);\n    vec3 tan1=vec3(1,0,0);\n    vec3 tan2=vec3(0,1,0);\n    // ...trying to implement some micro scratches\n    for(int i=0;i<numscr*3;i++)\n    {\n        n=n0;\n        vec2 cs=cos(ang+vec2(0,-1.57));\n        mat2 m=mat2(cs,cs.yx*vec2(-1,1));\n        //dFdx()\n        vec2 dn2d=(texture(iChannel0,(m*pi.xy)*vec2(6.,.1)*mtrl.scratchScale+vec2(0,.5/256.)).x-.5)*mtrl.scratchScale;\n        dn2d=pow(abs(dn2d),vec2(.7))*sign(dn2d);\n        dn2d=dn2d*m;\n        //dn2d=dn2d.yx*vec2(1,-1);\n        n+=abs(dot(n0,heading))*carTrafoInv(dn2d.x*tan1+dn2d.y*tan2,0.);\n        n=normalize(n);\n        R=reflect(dir,n);\n        float fres=abs(dot(R,n));\n        fres=1.-fres;\n        fres*=fres*fres;\n        fres=fres*.4+.6;\n        float fact=(abs(dot(n0,-dir))*.8+.2)*fres;\n        //fact=.2;\n        drefl+=fact*myenv(pos,R.xyz,1.).xyz;\n        sum+=fact;\n        ang+=dang;\n        pi=pi.zxy;\n        heading=heading.yzx;\n        tan1=tan1.yzx;\n        tan2=tan2.yzx;\n    }\n    drefl/=float(numscr);\n    refl=mix(refl,drefl,mtrl.scratchy);\n    #endif\n    \n    #ifdef RENDER_GLASS\n    vec3 Rg=reflect(dir,glassn);\n    vec3 glassrefl=myenv(pos,Rg.xyz,1.).xyz;\n    //glassrefl=glassrefl*1.2+.3;\n    float glassfres=abs(dot(Rg,glassn));\n    glassfres=1.-glassfres;\n    glassfres*=glassfres*glassfres;\n    glassfres=glassfres*.85+.15;\n    if(glassn==vec3(0)) glassfres=0.;\n    #endif\n\n    vec3 rcol=vec3(1);\n    fres=(mtrl.refl<0.)?fres*-mtrl.refl:mtrl.refl;\n    rcol=(mtrl.refl<0.)?vec3(1):mtrl.col;\n    vec3 col=mtrl.col;\n    if(mat==FLOOR) {\n        col+=(texture(iChannel0,pos.xy*2.,-1.2).x-.5)*.3;\n        //col*=.9+.2*texture(iChannel2,pos.xy*.2).xyz;\n        #ifdef WET_ASPHALT\n        col*=.35+.65*step(-.66,pos.z);\n        fres=fres0*mix(-mtrl.refl,1.,(1.-smoothstep(-.661,-.659,pos.z))*exp(-length(pos.xy)/50.));\n        #endif\n    }\n\n    float zr=length(pos-pos0)/300.;\n    //diff=sqrt(diff);\n\n    outfres=fres;\n    if(glassfres!=0.) outfres=glassfres;\n    fres*=reflections;\n    glassfres*=reflections;\n\n    outao=ao;\n    \n\tvec3 bg=myenv(pos0,dir,1.).xyz;\n\t// diff, ao, refl\n\tvec3 finalcol = mix(col,rcol*refl,fres)*mix(vec3(1.2,1.4,1.5)*.5,vec3(1.,1,.9),diff)*ao*1.3;\n\t//finalcol=col;\n\t// fog\n\t//finalcol = mix(finalcol,bg,1.-exp(-zr));\n\tfinalcol = mix(finalcol,bg,1.-clamp(exp(-zr+.1),0.,1.));\n\t#ifdef RENDER_GLASS\n\tfinalcol=mix(finalcol,glassrefl,glassfres);\n\t#endif\n\treturn finalcol;\n}\n\n#ifdef CAM_ANIM\nvec4 camAnim[8] = vec4[] (\n    vec4( 1.5, -2.75,-0.25 ,1.), vec4(0,1.,.1, 0.),\n    vec4(-1.5, -2.75,-0.25 ,1.), vec4(.5,1.,.1, 0.),\n    //vec4(-2., -1.5,-0.25 ,1.), vec4(1.,0.,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.),\n    vec4(-2., 3.,-0.35 ,1.), vec4(.5,-1,.1, 0.)\n    );\n    \nvec3 getCamAnimPos(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].xyz,camAnim[i_c*2].xyz,fact);\n}\n\nvec3 getCamAnimDir(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2+1].xyz,camAnim[i_c*2+1].xyz,fact);\n}\n\nfloat getCamAnimBr(float t)\n{\n    t*=.1;\n    int i_f=int(t); float fact=fract(t); int i_c=i_f+1;\n    i_c=min(3,i_c);\n    i_f=min(3,i_f);\n    return mix(camAnim[i_f*2].w,camAnim[i_c*2].w,fact);\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 sc=(fragCoord-Res*.5)/Res.x;\n    \n    float zoom=1.;\n    #ifdef SHADEROO\n    zoom=exp(-iMouseData.z/5000.);\n    #endif\n    zoom*=CamDistFact;\n\n    vec3 CarPos = carTrafoInv(vec3(0),1.);\n    vec3 pos=vec3(0,0,4.5)*zoom;\n    vec3 dir=normalize(vec3(sc,-.8));\n    \n    calcWheelOffsets(-.2,.2);\n    \n    vec4 q=vec4(0,0,0,1);\n    float th=-(iMouse.y-Res.y*.5)/Res.y*6.;\n    float ph=-(iMouse.x-Res.x*.5)/Res.x*10.;\n    if(iMouse.x<1.) { th=1.45; ph=-iTime*.25; }\n    th=clamp(th,-1.65,1.65);\n    q=multQuat(q,axAng2Quat(vec3(0,0,1),ph));\n    q=multQuat(q,axAng2Quat(vec3(1,0,0),th));\n    pos=transformVecByQuat(pos,q)-vec3(0,0,.2);\n    dir=transformVecByQuat(dir,q);\n    pos=camTrafoInv(pos,1.);\n    // make sure cam is always above ground\n    pos.z=max(hTerr(pos)-.6,pos.z);\n    dir=camTrafoInv(dir,0.);\n\n    #ifdef CAM_ANIM\n    if(iMouse.x<1.)\n    {\n        pos=getCamAnimPos(iTime);\n        dir=normalize(getCamAnimDir(iTime));\n        vec3 right=normalize(cross(dir,vec3(0,0,1)));\n        vec3 up=cross(right,dir);\n        dir=normalize(dir+right*sc.x+up*sc.y);\n    }\n    #endif\n\n    vec3 pos0=pos;\n    float m=march(pos,dir);\n    \n    float refl=1.;\n    #ifdef RENDERED_REFECTIONS\n    refl=0.;\n    #endif\n    float fres=0., ao=0.;\n    fragColor.xyz=lighting(pos,dir,pos0,refl,fres,ao);\n    #ifdef RENDERED_REFECTIONS\n    enable_glass=true;\n    vec3 n=getGrad(pos,.001);\n    if (length(n)<.001) n=vec3(0,0,1);\n    n=normalize(n);\n    dir=reflect(dir,n);\n    pos+=dir*.003;\n    float mat=distM(pos).y;\n    march(pos,dir);\n    float dummyfres,dummyao;\n    vec3 lcol=lighting(pos,dir,pos0,1.,dummyfres,dummyao);\n    fragColor.xyz=mix(fragColor.xyz,lcol,(m!=0.)?0.:fres);\n    #endif\n    \n    #ifdef CAM_ANIM\n    fragColor*=1.-exp(-getCamAnimBr(iTime)*getCamAnimBr(iTime)/.01);\n    #endif\n\n\tfragColor.w=1.;\n}\n\n#if 0\nvoid mainImageXX( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    float snum=4.;\n    for(int i=0;i<max(int(snum),1);i++)\n    {\n        enable_glass=true;\n        vec4 col=vec4(0);\n        vec2 r = (texelFetch(iChannel0,ivec2(mod(fragCoord+vec2(i*5+iFrame*13,0)+.1,256.0))&255,0).xy-.5)*1.;\n        //vec2 r = getRand(i+int(fragCoord.x+fragCoord.y*iResolution.x)).xy-.5;\n        mainImageS(col,fragCoord+r*((snum>0.)?1.:0.3));\n        fragColor+=col;\n        vec4 r2=texture(iChannel0,fragCoord/Res0*.707+iTime*4.5+float(i)*.1)-.5;\n        fragColor+=.05*r2;\n    }\n    fragColor/=floor(max(snum,1.));\n}\n#endif\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// zztop whiskey runner\n\n// helper functions\n\n//#define COARSE_TERRAIN\n\n#define USE_SIMDATA\n\n#define PI2 6.283185\n\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n\nvec3 getLightDir() { return normalize(1.*vec3(cos(1.+/*iTime+*/vec2(0,1.6)),.81)); }\n\nvec2 scuv(vec2 uv) {\n    float zoom=1.;\n    return (uv-.5)*1.2*zoom+.5; \n}\n\nvec2 uvSmooth(vec2 uv,vec2 res)\n{\n    // no interpolation\n    //return uv;\n    // sinus interpolation\n    return uv+1.*sin(uv*res*PI2)/(res*PI2);\n    // iq's polynomial interpolation\n    vec2 f = fract(uv*res);\n    return (uv*res+.5-f+3.*f*f-2.0*f*f*f)/res;\n}\n\nvec4 inverseQuat(vec4 q)\n{\n    //return vec4(-q.xyz,q.w)/length(q);\n    // if already normalized this is enough\n    return vec4(-q.xyz,q.w);\n}\n\nvec4 multQuat(vec4 a, vec4 b)\n{\n    return vec4(cross(a.xyz,b.xyz) + a.xyz*b.w + b.xyz*a.w, a.w*b.w - dot(a.xyz,b.xyz));\n}\n\nvec3 transformVecByQuat( vec3 v, vec4 q )\n{\n    return (v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w*v ));\n}\n\nvec4 angVec2Quat(vec3 ang)\n{\n    float lang=length(ang);\n    return vec4(ang/lang,1) * sin(vec2(lang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\nvec4 axAng2Quat(vec3 ax, float ang)\n{\n    return vec4(normalize(ax),1)*sin(vec2(ang*.5)+vec2(0,PI2*.25)).xxxy;\n}\n\n// iq's sdf primitives\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundRect( vec2 p, vec2 b, float r )\n{\n  vec2 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;\n}\n\nvec2 sdRoundRect2( vec4 p, vec4 b, vec2 r )\n{\n  vec4 q = abs(p) - (b-r.xxyy);\n  vec4 qp=max(q,0.0);\n  return sqrt(qp.xz*qp.xz+qp.yw*qp.yw) + min(max(q.xz,q.yw),vec2(0)) - r;\n}\n\nfloat sdHalfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return max((length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r),-p.z);\n}\n\nfloat sdRoundedCylinder( vec3 p, float R, float r, float h )\n{\n  vec2 d = vec2( length(p.xz)-R, abs(p.y) - h*.5 );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n}\n\n// iq's capsule\nfloat sdLine( vec3 p, vec3 a, vec3 b)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat distTorus(vec3 p, float R, float r)\n{\n    return length(p-vec3(normalize(p.xy),0)*R)-r;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\n// iq's exponantial smooth-min func\nfloat smin( float a, float b, float k )\n{\n    k=3./k;\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n\n// iq's polynomial smooth-min func\nfloat smin_( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n#if 0\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    //vec3 n=cross(cross(dir,p),dir);\n    //return length(p-dot(p,n)*n/dot(n,n))<size.y;\n\n    //return true;\n    \n    size*=.5;\n    float tmin, tmax, tymin, tymax, tzmin, tzmax; \n    \n    vec3 s=sign(dir);\n    vec3 invdir=1./dir;\n\n    tmin  = (-size.x*s.x - p.x) * invdir.x; \n    tmax  = ( size.x*s.x - p.x) * invdir.x; \n    tymin = (-size.y*s.y - p.y) * invdir.y; \n    tymax = ( size.y*s.y - p.y) * invdir.y; \n \n    if ((tmin > tymax) || (tymin > tmax)) return false; \n    if (tymin > tmin) tmin = tymin; \n    if (tymax < tmax) tmax = tymax; \n \n    tzmin = (-size.z*s.z - p.z) * invdir.z; \n    tzmax = ( size.z*s.z - p.z) * invdir.z; \n \n    if ((tmin > tzmax) || (tzmin > tmax)) return false; \n    if (tzmin > tmin) tmin = tzmin; \n    if (tzmax < tmax) tmax = tzmax; \n \n    return true; \n}\n#endif\nbool intersectBox(vec3 p, vec3 dir, vec3 size)\n{\n    size*=.5*sign(dir);\n\n    vec3 vmin = (-size-p)/dir;\n    vec3 vmax = ( size-p)/dir;\n    \n    float tmin=vmin.x, tmax=vmax.x;\n    \n    if ((tmin > vmax.y) || (vmin.y > tmax)) return false; \n    tmin=max(tmin,vmin.y);\n    tmax=min(tmax,vmax.y);\n \n    if ((tmin > vmax.z) || (vmin.z > tmax)) return false; \n    tmin=max(tmin,vmin.z);\n    tmax=min(tmax,vmax.z);\n \n    return true; \n}\n\nvec2 ROT(float ang, vec2 v) \n{ \n    vec2 cs=sin(vec2(1.6,0)+ang); \n    return mat2(cs,cs.yx*vec2(-1,1))*v;\n}\n\nfloat bigZ(vec2 p)\n{\n    vec2 p0=p;\n    \n    p=ROT(-.05,p);\n    \n    p+=vec2(0,.7);\n    //float falloff=exp(-dot(p,p));\n    float falloff=1./(1.+dot(p,p)*2.);\n    p=ROT(-PI2*.2*falloff*p.y,p-vec2(0,.7));   // locally rotate around x by 180 degrees\n\n    p.x+=.7*p.y;\n    \n    //p.x-=p.y;\n    p=-sign(p.y+p.x)*p;\n    \n    float d=abs(max(-p.y-.5,p.x));\n    d-=.04+.1/(1.+dot(p0,p0)*3.)+.03*min(p0.x,0.);\n    return d;\n}\n\nfloat fermi(float x)\n{\n    return 1./(1.+exp(-x));\n}\n\nfloat zmask(vec2 p)\n{\n    float skew=1.;\n    p.x += skew*p.y;\n    return step(p.y,step(-.35,p.x)-.5+.1)\n          -step(p.y,step( .35,p.x)-.5-.1);\n}\n\n\n#define RUMPFW 1.3\n#define ALLW (RUMPFW*1.3)\n\n#define WheelDistF (ALLW*.78)\n#define WheelDistR (ALLW*.96)\n#define WheelPosFR (vec3(-WheelDistF*.5,-1.43,-.33)*2.)\n#define WheelPosRL (vec3( WheelDistR*.5, 1.23,-.35)*2.)\n#define WheelPosFL (vec3( WheelDistF*.5,-1.43,-.33)*2.)\n#define WheelPosRR (vec3(-WheelDistR*.5, 1.23,-.35)*2.)\n\nvec4 wheelOffs=vec4(0);\n#define WheelOffsRL wheelOffs.x\n#define WheelOffsRR wheelOffs.y\n#define WheelOffsFL wheelOffs.z\n#define WheelOffsFR wheelOffs.w\n\n#define WheelRadiusF .62\n#define WheelRadiusR .7\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "// created by florian berger (flockaroo) - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// some minimal driving sim (not much physics involved here, just simple driving/steering)\n\n#define RandTex iChannel2\n#define PhysTex iChannel0\n\n#ifdef SHADEROO\n#include Include_A.glsl\n#endif\n\n#ifndef PhysTex\n#define PhysTex iChannel1\n#endif\n#ifndef RandTex\n#define RandTex iChannel0\n#endif\n\nvec4 myRandInterpol(vec2 uv)\n{\n    #ifdef COARSE_TERRAIN\n    return textureLod(RandTex,uv,0.);\n    #endif\n    uv=fract(uv-1./512.);\n    ivec2 c0 = ivec2(fract(uv        )*256.);\n    ivec2 c1 = ivec2(fract(uv+1./256.)*256.);\n    vec2  f = fract(uv*256.);\n    vec4 c00=texelFetch(RandTex,ivec2(c0.x,c0.y),0);\n    vec4 c10=texelFetch(RandTex,ivec2(c1.x,c0.y),0);\n    vec4 c01=texelFetch(RandTex,ivec2(c0.x,c1.y),0);\n    vec4 c11=texelFetch(RandTex,ivec2(c1.x,c1.y),0);\n    f=mix(f,.5-.5*cos(f*PI2*.5),.5);\n    //f=.5-.5*cos(f*PI2*.5);\n    return mix(mix(c00,c10,f.x),mix(c01,c11,f.x),f.y);\n}\n\n//#define RND_SC (256./64.)\n#define RND_SC 1.\nfloat hTerr(vec3 p)\n{\n    vec4 rTerr=\n     .8*myRandInterpol(p.xy*.00006*RND_SC)\n    +.4*myRandInterpol(p.xy*.00012*RND_SC)\n    //+.1*textureLod(iChannel0,p.xy*.12*RND_SC,0.)\n    ;\n    float pp=dot(p.xy,p.xy)/(200.*200.);\n    vec2 fp=fract(p.xy*.5)-.5;\n    //return .2*exp(-fp.x*fp.x/.1/.1)+.2*exp(-fp.y*fp.y/.1/.1);\n    return rTerr.x*min(pp*pp,40.)+.1*textureLod(RandTex,p.xy*.012*.5*RND_SC,0.).x;\n}\n\nvec3 terrNormal(vec3 pos)\n{\n    //float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(1,0,0))-hTerr(pos-vec3(1,0,0)),\n    \t\t\t  hTerr(pos+vec3(0,1,0))-hTerr(pos-vec3(0,1,0)))*.5;\n    return normalize(vec3(-dh,1));\n}\n\nvec4 getTiltQuat(vec3 pos)\n{\n    float h0 =hTerr(pos);\n    vec2  dh=vec2(hTerr(pos+vec3(2,0,0))-h0,\n    \t\t\t  hTerr(pos+vec3(0,2,0))-h0)*.5;\n    \n    //return axAng2Quat(normalize(vec3(dh.y,-dh.x,0)),atan(length(dh)));\n    // same as above axAng2Quat(...) - but less angle back/forth conversions\n    float ch = sqrt(.5+.5/sqrt(1.+dot(dh,dh)));      // cos(ang/2)\n    return vec4(vec3(dh.y,-dh.x,0)*(ch-.5/ch),ch);  // (ch-.5/ch) == sin(ang/2)/tan(ang);\n}\n\n\n// transform to car coords\nvec3 carTrafo(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    ///offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p-translate*pos,inverseQuat(q));\n#else\n    return p;\n#endif\n}\n\nvec3 carTrafo(vec3 p)\n{\n    return carTrafo(p,1.0);\n}\n\n// transform to world coords\nvec3 carTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(3,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvec3 camTrafoInv(vec3 p, float translate)\n{\n#ifdef USE_SIMDATA\n    vec4 q=texelFetch(PhysTex,ivec2(6,0),0);\n    vec3 pos=texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    //offs.z=-hTerr(-offs);\n    //q=multQuat(getTiltQuat(-offs),q);\n    return transformVecByQuat(p,q)+pos*translate;\n#else\n    return p;\n#endif\n}\n\nvoid calcWheelOffsets(float clmin, float clmax)\n{\n    vec3 wp;\n    wp=carTrafoInv(WheelPosFL*vec3(1,1,0)*.5,1.); WheelOffsFL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosFR*vec3(1,1,0)*.5,1.); WheelOffsFR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRL*vec3(1,1,0)*.5,1.); WheelOffsRL = clamp(hTerr(wp)-wp.z,clmin,clmax);\n    wp=carTrafoInv(WheelPosRR*vec3(1,1,0)*.5,1.); WheelOffsRR = clamp(hTerr(wp)-wp.z,clmin,clmax);\n}\n\n\n#define keyTex iChannel1\n#define KEY_I (texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_A (texture(keyTex,vec2((65.5+ 0.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_W (texture(keyTex,vec2((65.5+22.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_R (texture(keyTex,vec2((65.5+17.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_S (texture(keyTex,vec2((65.5+18.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_D (texture(keyTex,vec2((65.5+ 3.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_F (texture(keyTex,vec2((65.5+ 5.)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_PLUS  (texture(keyTex,vec2((187.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_MINUS (texture(keyTex,vec2((189.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_LEFT  (texture(keyTex,vec2(( 37.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_RIGHT (texture(keyTex,vec2(( 39.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_DOWN  (texture(keyTex,vec2(( 40.5)/256.0,(0.5+0.0)/3.0)).x)\n#define KEY_UP    (texture(keyTex,vec2(( 38.5)/256.0,(0.5+0.0)/3.0)).x)\n\n#define CalcTorque(a,r) cross((r),transformVecByQuat((a),iquat)*Mass)/I\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    #ifdef ZZT_AS_TEX\n    vec2 uv = fragCoord.xy / Res0;\n    fragColor = zztop((uv*2.-.75)*11.,-1.);\n    #endif\n\n    vec3  pos      = texelFetch(PhysTex,ivec2(0,0),0).xyz;\n    vec3  vel      = texelFetch(PhysTex,ivec2(1,0),0).xyz;\n    vec3  omega    = texelFetch(PhysTex,ivec2(2,0),0).xyz;\n    vec4  quat     = texelFetch(PhysTex,ivec2(3,0),0);\n    float SteerAng = texelFetch(PhysTex,ivec2(4,0),0).x;\n    float camDist  = texelFetch(PhysTex,ivec2(4,0),0).y;\n    vec4  wheelRot = texelFetch(PhysTex,ivec2(5,0),0);\n    vec4  camQuat  = texelFetch(PhysTex,ivec2(6,0),0);\n    vec4  iquat = inverseQuat(quat);\n    \n    calcWheelOffsets(-1.2,1.2);\n    \n    float dt=min(iTimeDelta,.03);\n    \n    float axDist=3.5;\n    vec3 rearAxPos = vec3(0,1.7,0);\n    \n    //quat=vec4(0,0,0,1);\n    vec3 bx=transformVecByQuat(vec3(1,0,0),quat);\n    vec3 by=transformVecByQuat(vec3(0,1,0),quat);\n    vec3 bz=transformVecByQuat(vec3(0,0,1),quat);\n    \n    vec3 acc=vec3(0);\n    vec3 alpha=vec3(0);\n    \n    float Mass=1000.;\n    vec3 S=vec3(2.,3.2,1.5);\n    vec3 I=vec3(S.y*S.y+S.z*S.z, S.z*S.z+S.x*S.x, S.x*S.x+S.y*S.y)*Mass/12.;\n    float mu = .7;\n    #define GRAVITY 9.81\n    acc+=GRAVITY*vec3(0,0,-1);\n    float SpringOmega=10.;\n    float SpringGamma=20.;\n    \n    vec3 n=terrNormal(pos);\n    \n    float grip=step(pos.z,hTerr(pos)+.1);\n    \n    // FIXME: just one central springforce for now\n    float dTerr=(pos.z-hTerr(pos))*n.z;\n    acc += grip*(0.*GRAVITY+SpringOmega*SpringOmega*(.1-dTerr))*n;\n        \n    // FIXME: just angular spring for now... (use wheel forces instead)\n    alpha -= 150.*grip*cross(transformVecByQuat(n,iquat)*Mass,normalize(vec3(0,.0,1)))/I;\n\n    vec3 dacc=vec3(0);\n    vec3 dalpha=vec3(0);\n    \n    dacc-=30.*grip*(max(KEY_W,KEY_UP)-max(KEY_S,KEY_DOWN))*by;\n    acc+=dacc;\n    \n    // FIXME: get rid of tweak-constant 0.15\n    alpha-=.2*grip*cross(transformVecByQuat(dacc,iquat)*Mass,.5*(WheelPosRL+WheelPosRR))/I;\n        \n    SteerAng*=.91;\n    SteerAng-=(max(KEY_A,KEY_LEFT)-max(KEY_D,KEY_RIGHT))*.05;\n    camDist*=(1.-.02*KEY_PLUS);\n    camDist*=(1.+.02*KEY_MINUS);\n    \n    //quat=multQuat(quat,axAng2Quat(vec3(0,0,1),+.001*SteerAng*dot(vel,by)));\n    \n    vec3 accFrontAxe;\n    vec3 accRearAxe;\n    \n    // friction on front/back tire (one virtual middle tire)\n    for(int i=0;i<2;i++)\n    {\n        vec3 fricDir=vec3(cos(SteerAng),-sin(SteerAng),0);\n        vec3 fricPos=.5*(WheelPosFL+WheelPosFR);\n        if (i==1)\n        {\n            fricDir=vec3(1,0,0);\n            fricPos=.5*(WheelPosRL+WheelPosRR);\n        }\n        // FIXME: this should be +omega ?!\n        vec3 dv = cross(omega,fricPos) + transformVecByQuat(vel,iquat); // speed of wheelpos (by car rotation) + car speed\n        dv = clamp(dot(dv,fricDir)*1.,-4.,4.)*fricDir;  // just component normal to wheel\n        dacc   = -transformVecByQuat(dv,quat)*mu*GRAVITY*grip*.5;\n        dalpha = CalcTorque(dacc,fricPos);\n        if(i==0) accFrontAxe=dacc;\n        if(i==1) accRearAxe=dacc;\n        acc+=dacc;\n        alpha+=dalpha;\n    }\n    \n    camQuat=normalize(mix(quat,camQuat,.95));\n\n    if(pos.z<hTerr(pos)) vel-=dot(vel,n)*n*.5;\n    //pos.z=.5+hTerr(pos);\n    //quat=multQuat(getTiltQuat(pos),quat);\n    acc-=.03*vel*length(vel);\n\n    vel+=acc*dt*.5;\n    pos+=vel*dt;\n    vel+=acc*dt*.5;\n#if 1\n    omega+=alpha*dt*.5;\n    //if (length(omega)>.1) omega=normalize(omega)*.1;\n    if (length(omega)>.001)\n        quat=multQuat(quat,angVec2Quat(omega*dt));\n    omega+=alpha*dt*.5;\n#endif\n    \n    //if(pos.z<hTerr(pos)) \n    vec3 omegaN=dot(omega,n)*n;\n    omega=(omega-omegaN)*mix(.98,.85,grip)+omegaN;\n    omega*=.99;\n    //vel*=.99;\n    if(length(vel)>.001) vel-=normalize(vel)*.005;\n    //if(length(vel)<.1) vel=vec3(0);\n    //if(length(omega)<.01) omega=vec3(0);\n    \n    float wheelRadius=(WheelRadiusF+WheelRadiusR)*.5*.5;\n    wheelRot-=-dot(vel,by)*dt/wheelRadius;\n    \n    if(iFrame==0)\n    {\n        pos=vec3(0,0,0.);\n        pos.z=hTerr(pos)+1.;\n        vel=vec3(0,0,0);\n        quat=normalize(vec4(0.03,0.02,0,1));\n        camQuat=quat;\n        omega=vec3(0);\n        SteerAng=0.;\n        wheelRot=vec4(0);\n        camDist=1.;\n    }\n    \n    if (ivec2(fragCoord)==ivec2(0,0)) fragColor = vec4(pos,1.0);\n    if (ivec2(fragCoord)==ivec2(1,0)) fragColor = vec4(vel,1.0);\n    if (ivec2(fragCoord)==ivec2(2,0)) fragColor = vec4(omega,1.0);\n    if (ivec2(fragCoord)==ivec2(3,0)) fragColor = vec4(quat);\n    if (ivec2(fragCoord)==ivec2(4,0)) fragColor = vec4(SteerAng,camDist,0,1);\n    if (ivec2(fragCoord)==ivec2(5,0)) fragColor = vec4(wheelRot);\n    if (ivec2(fragCoord)==ivec2(6,0)) fragColor = vec4(camQuat);\n    if (ivec2(fragCoord)==ivec2(7,0)) fragColor = vec4(accFrontAxe,0);\n    if (ivec2(fragCoord)==ivec2(8,0)) fragColor = vec4(accRearAxe,0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}