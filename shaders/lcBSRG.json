{
    "Shader": {
        "info": {
            "date": "1706777339",
            "description": "This shader generates a noise pattern that tiles seamlessly not only to its opposite side, but also to its rotated sides. \nFor an immersive experience listen to Dead Or Alive - You Spin Me Round. ",
            "flags": 0,
            "hasliked": 0,
            "id": "lcBSRG",
            "likes": 8,
            "name": "Cardinal Tiling Voronoi Noise",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "tiling",
                "rotation",
                "octaves",
                "cardinal"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 291
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis shader is a vanilla Voronoi noise with a spin. I was curious to see how \nthe noise would appear if it not only tiled to its opposite side, but also \nto its rotated sides. I call this Cardinal Tiling and it should work on any \nprocedural noise. This type of tiling could be used to create seamless noise \non a cube-sphere mapping or a 1-sample random tiling.\n\nI suspect this tiling approach isn't novel and likely exists under a specific \nterm I'm unaware of. If you recognize it or have suggestions to reduce its \nrepetitiveness, particularly the dual repeating edges, I'd appreciate your \ninsights.\n\nThe shader has mouse controls and constants to experiment with. Mouse.x\ncontrols the rotation and mouse.y controls the zoom.\n\nFor an immersive experience, listen to Dead Or Alive - You Spin Me Round: \nwww.youtube.com/watch?v=PGNiXGX2nLU\n*/\n\n// Size of the noise cells, value range is 1 to infinity\n#define GRIDSIZE 7.\n\n// Number of noise layers, value range is 1 to infinity\n#define OCTAVES 5\n\n// Scaling of successive octaves, value range is 1 to infinity\n#define LACUNARITY 2.\n\n// Amplitude reduction of each successive octave, value range is 0 to 1\n#define PERSISTENCE 0.5\n\n// Switch the tiling. For tiling the GRIDSIZE also needs to be an integer\n// 0 = No tiling\n// 1 = Default tiling\n// 2 = Cardinal tiling\n#define TILING 2\n\n// Add lines for the grid outlines\n#define SHOWGRID\n\n// Constants\n#define INV_SQRT_TWO 1./sqrt(2.)\n#define TWO_PI 6.28318530718\n\n// Function to generate Voronoi noise\nfloat voronoi(vec2 position, uint gridSize, uvec2 seed) {\n\n    #if TILING >= 1\n        // Modulo operation may have floating point errors with negative values,\n        // which can break tiling. This fix should be sufficient, hopefully ...\n        position = abs(position + 421.);\n    #endif\n\n    // Scale the position by the grid size\n    position *= float(gridSize);\n    \n    // Calculate the cell coordinates and fractional part\n    vec2 cellCoords = floor(position); // Integer coordinates\n    vec2 fractionalCoords = position - cellCoords; // Fractional coordinates\n    \n    // Initialize the minimum distance to a large value\n    float minSquaredDistance = 8.0;\n    \n    // Loop over the 3x3 grid of cells around the current cell\n    for (int offsetX = -1; offsetX <= 1; offsetX++) {\n        for (int offsetY = -1; offsetY <= 1; offsetY++) {\n            // Calculate the offset vector\n            vec2 offset = vec2(offsetX, offsetY);          \n            \n            // Current cell coordinates\n            vec2 cell = cellCoords + offset;\n\n            #if TILING >= 1\n                // This makes the noise repeat between positions 0 and 1\n                cell = mod(cell, float(gridSize));\n            #endif\n\n            #if TILING == 2\n                // Calculate the centered coordinates\n                vec2 centeredCoords = (cell - float(gridSize) * 0.5 + 0.5) * 2.; \n\n                // Mirror the coordinates along the xy and diagonal axes\n                vec2 mirroredCoords = abs(centeredCoords);\n                mirroredCoords = mirroredCoords.x > mirroredCoords.y ? \n                                    mirroredCoords.xy : mirroredCoords.yx;\n\n                // Use the mirrored UVs on the outer cells touching the edges\n                bool isOnOutline = mirroredCoords.x > float(gridSize) - 1.5;\n                cell = isOnOutline ? mirroredCoords : cell;\n\n                // Generate a random offset for the current cell\n                vec2 randomOffset = hash22(cell + vec2(seed));\n\n                // Rotate the offset because their coordinates were rotated\n                randomOffset -= 0.5; // Center the offset\n                if (isOnOutline && \n                    centeredCoords.x >= centeredCoords.y && \n                    -centeredCoords.x < centeredCoords.y - 0.5) {\n                    \n                    // If on the left side\n                    randomOffset = -randomOffset;\n\n                } else if (isOnOutline && centeredCoords.x > centeredCoords.y) {\n                    // If on the bottom side\n                    randomOffset = vec2(-randomOffset.y, randomOffset.x);\n\n                } else if (isOnOutline && -centeredCoords.x <= centeredCoords.y) {\n                    // If on the top side\n                    randomOffset = vec2(randomOffset.y, -randomOffset.x);\n                }                \n                randomOffset += 0.5; // Move the offset back to the range 0-1\n\n            #else    \n                // Generate a random offset for the current cell\n                vec2 randomOffset = hash22(cell + vec2(seed));\n            #endif\n            \n            // Calculate the squared distance to the point in the neighboring cell\n            vec2 diff = fractionalCoords - offset - randomOffset;\n            float squaredDistance = dot(diff, diff);\n            \n            // Update the minimum squared distance\n            minSquaredDistance = min(minSquaredDistance, squaredDistance);\n        }\n    }\n    \n    // Take the square root of the minimum squared distance before returning    \n    return sqrt(minSquaredDistance); \n    // * INV_SQRT_TWO; should be normalized to 0-1 range but ugly and too dark\n}\n\n// Function to generate Voronoi noise with octaves\nfloat voronoi(vec2 position, float gridSize, \n                int octaves, float lacunarity, float persistence) {\n    \n    // Initialize the constants    \n    // For amplitude math, see: https://www.desmos.com/calculator/xgqeepapwn\n    float amplitude = 1.0;\n    float amplitudeSum = 0.0;\n    float result = 0.0;\n    uvec2 seed = uvec2(421); // Can be any positive integer\n    \n    // For each octave\n    for(int i = 0; i < octaves; ++i) {\n        // Sample noise and apply amplitude\n        result += voronoi(position, uint(gridSize), seed) * amplitude;\n        \n        // Add up amplitude to normalize the result later\n        amplitudeSum += amplitude;\n        \n        // Increase frequency for the next octave\n        gridSize *= lacunarity;\n        \n        // Decrease amplitude for the next octave\n        amplitude *= persistence;\n        \n        // Change seed/offset noise so it is unique for the next octave\n        seed += uvec2(gridSize);\n    }\n    \n    // Normalize the result to the 0-1 range\n    result /= amplitudeSum;\n\n    return result;\n}\n\n// Main function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    \n    // Initialize variables for angle and zoom\n    float angle;\n    float zoom;\n\n    // If the mouse was not clicked, animate\n    if (iMouse.x > 0.0) {\n        // Scale mouse coordinates to the 0-1 range of the screen\n        vec2 mouse = iMouse.xy / iResolution.xy;\n    \n        // Mouse controls zoom with steps\n        float zoomSteps = 10.0;\n        zoom = mix(4.0, 1.1, pow(floor(mouse.y * zoomSteps) / zoomSteps, 0.5));\n    \n        // Mouse controls rotation direction        \n        angle = mouse.x * 1.5;\n        \n    } else {\n        // Set static zoom\n        zoom = 1.5;\n    \n        // Time controls rotation direction \n        angle = iTime * 0.05;\n    } \n    \n    // Make the rotation plateau at 0, 90, 180, 270 degree angles\n    angle = (floor(angle * 4.0) + smoothstep(0.25, 1.0, fract(angle * 4.0))) * 0.25;\n    \n    // Convert angle to radians\n    angle *= TWO_PI;\n    \n    // Calculate direction clockwise\n    vec2 direction = vec2(sin(angle), cos(angle));\n    \n    // Offset coordinates\n    vec2 offset = vec2(0.0, -0.5);\n    \n    // Square UVs with (0,0) in the center\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y + offset; \n    \n    // Apply zoom on coordinates center\n    uv = (uv - offset) * zoom + offset;\n    \n    // Calculate anti-aliasing effect\n    vec2 uvFwidth = fwidth(uv);\n    float aa = max(uvFwidth.x, uvFwidth.y);\n    \n    // Create diamond tiling\n    vec2 uvDia = rotateUV(uv - 0.5, vec2(1.0)); // Rotate 45 degrees\n    uvDia = fract(uvDia * 0.5) - 0.5;     \n    uvDia = rotateUV(uvDia, vec2(-1.0, 1.0)) + 0.5; // Rotate -45 degrees\n    vec2 idDia = uv - uvDia; // Cell IDs\n    \n    // Rotate UVs around the 0.5 coordinate\n    vec2 center = vec2(0.5);\n    vec2 uvRot = rotateUV(uvDia - center, direction.xy) + center;     \n\n    // Create mask to make the outside of 0-1 UVs black\n    vec2 maskRot = step(abs(uvRot - 0.5), vec2(0.5));\n    float chessRot = min(maskRot.x, maskRot.y);\n\n    // Alternate between the two uv sets tilings\n    vec2 detailUV = chessRot > 0.5 ? uvRot + idDia : uv; \n    \n    // Sample the noise\n    float noise = voronoi(detailUV, GRIDSIZE, OCTAVES, LACUNARITY, PERSISTENCE);\n    \n    #if OCTAVES != 1\n        // Artistic increase of the gamma, so the noise is not so dark\n        noise = clamp(noise * 1.25, 0., 1.);\n    #endif\n    \n    // Apply pretty colormap because grayscale is boring\n    vec3 color = viridis(noise);  \n    \n    // Turn black background invisible at cardinal angles\n    if (abs(fract(angle / TWO_PI * 4.0) - 0.5) < 0.499) {\n        // Create smooth anti-aliasing stripes\n        vec2 stripe = smoothstep(0.25 + aa, 0.25 - aa, abs(fract(uv * 0.5 - 0.25) - 0.5)) * 2. - 1.;\n\n        // Create chess mask with alternating tiles\n        float chess = stripe.x * stripe.y;\n\n        // Add black background for out of bounds sections\n        color *= max(chess, chessRot);\n    }\n    \n    #ifdef SHOWGRID\n        // Add lines on the edges of the grid\n        float thickness = 0.003;\n        vec2 outline = smoothstep(.5 + thickness + aa, 0.5 - thickness - aa, abs(uvRot - 0.5));\n        color *= abs(min(outline.x, outline.y) - 0.5) * 2.;\n    #endif\n    \n    // Set the fragment color\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// GENERIC FUNCTIONS ___________________________________________________________\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}