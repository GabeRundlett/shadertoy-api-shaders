{
    "Shader": {
        "info": {
            "date": "1579611982",
            "description": "I just heard that you can make contour lines simply by feeding it to any periodic function.\nAlso, I was curious how it looks if we rotate gradient used for noise interpolation.",
            "flags": 0,
            "hasliked": 0,
            "id": "wlG3Rd",
            "likes": 8,
            "name": "2D noise contour",
            "published": 3,
            "tags": [
                "2d",
                "noise"
            ],
            "usePreview": 0,
            "username": "hiogawa",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "float M_PI = 3.1415;\n\nfloat SCALE = 3.0;\nfloat NUM_OCTAVES = 2.0;\nfloat SCALE_TIME = 0.1;\n\nfloat SCALE_CONTOUR = 32.0;\nvec2 CLIP_RANGE = vec2(0.8, 1.0);\nvec3 COLOR1 = vec3(1.0, 0.0, 1.0);\nvec3 COLOR2 = vec3(0.0, 1.0, 1.0);\n\n// R -> [0, 1)\nfloat hash11(float t) {\n  return fract(sin(t * 56789.0) * 56789.0);\n}\n\n// R^2 -> [0, 1)\nfloat hash21(vec2 uv) {\n  return hash11(hash11(uv[0]) + 2.0 * hash11(uv[1]));\n}\n\nvec2 hashGradient2(vec2 uv) {\n  float t = hash21(uv);\n  return vec2(cos(2.0 * M_PI * t), sin(2.0 * M_PI * t));\n}\n\nfloat mix2(float f00, float f10, float f01, float f11, vec2 uv) {\n  return mix(mix(f00, f10, uv[0]), mix(f01, f11, uv[0]), uv[1]);\n}\n\nvec2 rotate2(vec2 uv, float r) {\n  mat2 R = mat2(\n    cos(r), sin(r),\n   -sin(r), cos(r)\n  );\n  return R * uv;\n}\n\n// R^2 -> [0, 1)\n// support additional argument to rotate gradient\nfloat gradientNoise(vec2 uv, float r) {\n  vec2 uvi = floor(uv);\n  vec2 uvf = uv - uvi;\n  vec2 g00 = rotate2(hashGradient2(uvi + vec2(0.0, 0.0)), r);\n  vec2 g10 = rotate2(hashGradient2(uvi + vec2(1.0, 0.0)), r);\n  vec2 g01 = rotate2(hashGradient2(uvi + vec2(0.0, 1.0)), r);\n  vec2 g11 = rotate2(hashGradient2(uvi + vec2(1.0, 1.0)), r);\n  float f00 = dot(g00, uvf - vec2(0.0, 0.0));\n  float f10 = dot(g10, uvf - vec2(1.0, 0.0));\n  float f01 = dot(g01, uvf - vec2(0.0, 1.0));\n  float f11 = dot(g11, uvf - vec2(1.0, 1.0));\n  float t = mix2(f00, f10, f01, f11, smoothstep(vec2(0.0), vec2(1.0), uvf));\n\n  // Normalize via upper/lower bound = +- 1 / sqrt(2) ~ 0.7\n  return (t / 0.7 + 1.0) * 0.5;\n}\n\nfloat noise(vec2 uv, float r) {\n  float result = 0.0;\n  for (float i = 0.0; i < NUM_OCTAVES; i++) {\n    float p = pow(2.0, i);\n    result += (gradientNoise(uv * p, r) / p);\n  }\n  result /= (pow(2.0, NUM_OCTAVES) - 1.0) / (pow(2.0, NUM_OCTAVES - 1.0));\n  return result;\n}\n\nfloat wave(float t) {\n  return 0.5 * (1.0 - cos(SCALE_CONTOUR * M_PI * t));\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord) {\n  vec2 uv =  SCALE * frag_coord / iResolution.y;\n\n  float noise_fac = noise(uv, SCALE_TIME * 2.0 * M_PI * iTime);\n  float contour_fac = wave(noise_fac);\n  float clip = smoothstep(CLIP_RANGE[0], CLIP_RANGE[1], contour_fac);\n  vec3 color = mix(COLOR1, COLOR2, noise_fac);\n\n  frag_color = vec4(color * clip, 1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}