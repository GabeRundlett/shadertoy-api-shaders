{
    "Shader": {
        "info": {
            "date": "1616853873",
            "description": "Made for the willstall challenge - 1 shader a week keeps the depression meek\n\nThis started out as a fork of https://www.shadertoy.com/view/WstGDs, my froge shader\nThen I started messing around with perlin noise from https://www.shadertoy.com/view/tdtGR8",
            "flags": 0,
            "hasliked": 0,
            "id": "fs23Rz",
            "likes": 7,
            "name": "Among the dunes",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "loading",
                "dunes",
                "willstall"
            ],
            "usePreview": 0,
            "username": "clepirelli",
            "viewed": 427
        },
        "renderpass": [
            {
                "code": "const int aa = 2;\nconst float maxDist = 100.0;\nconst vec3 lightDirection = normalize(vec3(.5,.5, .2));\nconst vec3 blobOffset = vec3(.0, .0, -.4);\n\nfloat getHeightMapValue(vec2 point)\n{\n    point*=.04;\n    vec2 st = (point+141.15) * .8;\n    \n    st.x -= iTime*.2;\n    point.y += iTime*.24;\n    \n    float perlin1 = getPerlin(point);\n    float perlin2 = getPerlin(st);\n    return mix(perlin1, perlin2, .5)*20.0;\n}\n\nfloat mapSpheres(vec3 point)\n{\n    sphere s1 = sphere(blobOffset + vec3(.0, .1, .0), .07);\n    sphere s2 = sphere(blobOffset + vec3(cos(iTime)*.1, sin(iTime)*.1, .1), .1);\n    sphere s3 = sphere(blobOffset + vec3(.1,.1, .1), .05);\n    float d = smin(sphDist(point, s1), sphDist(point,s2), .2);\n    d = smin(d, sphDist(point, s3), .15);\n   \n    return d;\n}\n\nsdfRet map(vec3 point)\n{\n    float d1 = mapSpheres(point);\n    \n    //heightmapped plane\n    float d2 = point.y+1.2 + getHeightMapValue(point.xz);\n    \n    if(d1 < d2)\n    {\n        return sdfRet(d1,.0);\n    } else \n    {\n        return sdfRet(d2, 1.0);\n    }\n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*CLOSE_ENOUGH).sdf + \n                      k.yyx*map( p + k.yyx*CLOSE_ENOUGH).sdf + \n                      k.yxy*map( p + k.yxy*CLOSE_ENOUGH).sdf + \n                      k.xxx*map( p + k.xxx*CLOSE_ENOUGH).sdf );\n}\n\nvec3 lighting(vec3 point)\n{\n\tdirLight sun = dirLight(lightDirection, 1.0, vec3(1.0,.9,.8),.02);\n    \n    vec3 normal = calcNormal(point);\n    \n    return diffuse(normal,sun);\n}\n\nvec3 goochShading(vec3 point, vec3 viewDirection)\n{\n    const vec3 surface = vec3(1.0, 1.0, 1.0);\n    const vec3 warm = vec3(1.0, .1, .0) + .25 *surface;\n    const vec3 cold = vec3(.0, .1, .55) + .25*surface;\n    const vec3 highlight = vec3(1.0);\n    \n    vec3 normal = calcNormal(point);\n    const vec3 upDirection = vec3(.0, -1.0, .0);\n    \n    float lambert = dot(normal, upDirection);\n    float t = (lambert+1.0) * .5;\n    vec3 r = 2.0*lambert*normal - upDirection;\n    float s = max(min(100.0*dot(r, viewDirection)-97.0, .0), 1.0);\n    \n    return mix(highlight, mix(warm, cold, t), s);\n}\n\nray getCurrentRay(vec2 uv)\n{\n    //camera calculations\n    vec3 target = vec3(.0);\n    vec3 rayOrigin = target + vec3(.0,.2,1.5);\n    vec3 front = normalize(target-rayOrigin);\n    vec3 right = normalize(cross(front, vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, front));\n    vec3 rayDir = normalize(uv.x*right+uv.y*up+1.0*front);\n    \t\n    return ray(rayOrigin, rayDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 total = vec3(.0);\n    //MSAA\n    for(int i = 0; i <aa;i++)\n    for(int j = 0; j <aa;j++)\n    {\n    \t//offset the uv for MSAA\n    \tvec2 uv = (fragCoord+vec2(float(i),float(j))/float(aa)-.5)/iResolution.xy - vec2(.5);\n    \tuv.x *= iResolution.x/iResolution.y;\n    \t\n    \tray currentRay = getCurrentRay(uv);\n    \t\n        //sky color\n    \tvec3 col = vec3(.2,.4,.9)-vec3(.4,.4,.9)*currentRay.direction.y;\n    \t\n        //raymarching\n    \tfloat dist = .0;\n    \tfor(int i = 0; i < 200; i++)\n    \t{\n            //point at which we'll sample distances\n    \t\tvec3 rayPoint = currentRay.origin + currentRay.direction *dist;\n    \t    \n            //sampling of distances\n            sdfRet ret = map(rayPoint);\n            \n            //smaller than our epsilon : hit!\n    \t    if(ret.sdf < CLOSE_ENOUGH)\n    \t    {\n                if(ret.id > .5) col = lighting(rayPoint)*vec3(.9568,0.8862,0.776); \n                else col = goochShading(rayPoint, currentRay.direction);\n    \t        \n                col += fog(dist);\n    \t        break;\n    \t    }\n    \t    if(dist > maxDist) break;\n    \t    dist += ret.sdf;\n    \t}\n     \n    \ttotal += col;\n    }\n    total /= float(aa*aa);\n    \n    // Output to screen\n    fragColor = vec4(pow(total,vec3(1./2.2)),1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define CLOSE_ENOUGH .01\n\n// ----structs----\n\nstruct sdfRet\n{\n\tfloat sdf;\n    float id;\n};\n    \nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n  \nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct dirLight\n{\n\tvec3 direction;\n    float intensity;\n    vec3 color;\n    float ambient;\n};\n\n\n// ----distance functions----\n\n//all from iq : https://iquilezles.org/articles/distfunctions\n\nfloat sphDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n// ----lighting----\n\nvec3 fog(float dist)\n{\n    return vec3(.05) * min(exp(dist*.3-20.0), 1.0);\n}\n\nvec3 diffuse(vec3 normal, dirLight l)\n{\n\treturn max(dot(normal, l.direction)*l.intensity, l.ambient)*l.color;\n}\n\n// ----noise----\n\nvec2 pseudorandPos(vec2 randseed)\n{\n    return abs(cos(fract(randseed * dot(sin(randseed * 242.589), vec2(42.4391588, 3.91711988))) * 294419.4857));\n}\n\nvec2 getGradient(vec2 coord)\n{\n\treturn 2. * normalize(pseudorandPos(floor(coord))) - 1.0;\n}\n\n//from : https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds%20/perlin-noise-part-2?url=procedural-generation-virtual-worlds%20/perlin-noise-part-2\nfloat smoothFloat(float t)\n{\n\treturn t * t * (3. - 2. * t);\n}\n\n//from : https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds%20/perlin-noise-part-2?url=procedural-generation-virtual-worlds%20/perlin-noise-part-2\nfloat getPerlin(vec2 coord)\n{\n\tint xi0 = int(floor(coord.x)); \n \tint yi0 = int(floor(coord.y)); \n \tint xi1 = xi0 + 1; \n \tint yi1 = yi0 + 1;\n \tfloat tx = coord.x - floor(coord.x); \n \tfloat ty = coord.y - floor(coord.y); \t\n \tfloat u = smoothFloat(tx);\n \tfloat v = smoothFloat(ty);\n \t// gradients at the corner of the cell\n \tvec2 c00 = getGradient(vec2(xi0, yi0));\n \tvec2 c10 = getGradient(vec2(xi1, yi0)); \n \tvec2 c01 = getGradient(vec2(xi0, yi1)); \n \tvec2 c11 = getGradient(vec2(xi1, yi1));\n \t// generate vectors going from the grid points to p\n \tfloat x0 = tx, x1 = tx - 1.;\n \tfloat y0 = ty, y1 = ty - 1.;\n \tvec2 p00 = vec2(x0, y0); \n \tvec2 p10 = vec2(x1, y0); \n \tvec2 p01 = vec2(x0, y1); \n \tvec2 p11 = vec2(x1, y1);\t\n \t// linear interpolation\n \tfloat a = mix(dot(c00, p00), dot(c10, p10), u); \n \tfloat b = mix(dot(c01, p01), dot(c11, p11), u);\n \treturn abs(mix(a, b, v)); // g \n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}