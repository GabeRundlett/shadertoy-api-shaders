{
    "Shader": {
        "info": {
            "date": "1685207799",
            "description": "The simplest 2D pixel traversal algorithm - advancing to the next pixel is just two float additions (and a floor() to get the integer coordinate).",
            "flags": 0,
            "hasliked": 0,
            "id": "dltXzM",
            "likes": 18,
            "name": "Simplest 2D Pixel Traversal",
            "published": 3,
            "tags": [
                "voxel"
            ],
            "usePreview": 0,
            "username": "fad",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "// The simplest 2D pixel traversal algorithm - advancing to the next\n// pixel is just two float additions (and a floor() to get the integer\n// coordinate). I accidentally discovered this method while trying to\n// come up with an algorithm for voxel traversal that only used integer\n// arithmetic. The one caveat is that when the ray passes exactly\n// through the corner of a pixel, it ends up double counting a pixel,\n// consequently not being watertight (uncomment lines 67/68 to see an\n// example). This could be fixed with some extra manual checks but at\n// that point it might just be more worth it to use the regular voxel\n// traversal algorithm.\n\n// It works by finding an alternative parameterization of the input ray,\n// R(T) = O + D * T, that for successive integer values of T returns\n// points in order of the pixels pierced by the original ray. Such a\n// parameterization unfortunately does not exist in 3D.\n\n#define RES_Y 9.0\nvec2 _p;\nvec2 _g;\nfloat _s;\nbool _b = false;\nfloat _c = 0.0;\n\nvoid visitPixel(vec2 p) {\n    _b = _b || p == _p;\n}\n\nvoid plotCircle(vec2 p) {\n    _c += max(RES_Y / _s * 0.01 - distance(p / _s, _g), 0.0);\n    _c = min(_c, 1.0);\n}\n\nvoid traverse(vec2 o, vec2 d, float tMax) {\n    vec2 s = 1.0 - 2.0 * step(d, vec2(0.0)); o *= s; d *= s;\n    // N is the number of pixels to visit, it's\n    // 1 + manhattan distance between floor(r(0)) and floor(r(tMax))\n    int N = int(dot(abs(floor(o + d * tMax) - floor(o)), vec2(1.0))) + 1;\n    vec2 O = s * (o * d.yx + d * (floor(o) + 1.0 - fract(o.yx))) / (d.x + d.y);\n    vec2 D = s * d / (d.x + d.y);\n    // R(T) = O + D * T\n    vec2 P = O;\n    \n    for (int n = 0; n < N; ++n) {\n        visitPixel(floor(P));\n        plotCircle(P);\n        P += D;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    float s = RES_Y / iResolution.y; _s = s;\n    _p = floor(fragCoord * s);\n    _g = fragCoord;\n    vec2 o, d;\n    \n    if (iMouse.z > 0.0) {    \n        o = abs(iMouse.zw) * s;\n        d = iMouse.xy * s - o;\n    } else {\n        vec2 p1 = iResolution.xy * s * (vec2(cos(iTime * 1.3), sin(iTime * 1.2)) * 0.4 + 0.5);\n        vec2 p2 = iResolution.xy * s * (vec2(sin(iTime * 1.3), cos(iTime * 0.6)) * 0.4 + 0.5);\n        o = p1;\n        d = p2 - p1;\n    }\n    \n    // Uncomment to see corner intersection issue\n    // o = vec2(0.0);\n    // d = 4.0 * vec2(3.0, 2.0);\n    \n    traverse(o, d, 1.0);\n    \n    if ((int(_p.x) + int(_p.y)) % 2 == 0) {\n        fragColor.rgb = vec3(0.918,0.894,0.843);\n    } else {\n        fragColor.rgb = vec3(0.9647, 0.949, 0.906);\n    }\n    \n    if (_b) {\n        fragColor.rgb *= vec3(0.471, 0.549, 0.471);\n    }\n    \n    vec2 pa = fragCoord - o / s;\n    d /= s;\n\tfloat h = clamp(dot(pa, d) / dot(d, d), 0.0, 1.0);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0, 0.0, 0.0), clamp(1.5 - length(pa - h * d), 0.0, 1.0));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.745,0.937,0.792), _c);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}