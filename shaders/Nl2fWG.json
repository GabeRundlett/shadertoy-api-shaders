{
    "Shader": {
        "info": {
            "date": "1652702639",
            "description": "2-dimensional sine-Gordon equation. Click to excite a wave.\nChange the K parameter to increase/decrease non-linearity.\nLook at the excite function in Buffer A for more detail. We have moving breathers that seems capable of colliding and turning directions",
            "flags": 32,
            "hasliked": 0,
            "id": "Nl2fWG",
            "likes": 5,
            "name": "Sine-Gordon equation",
            "published": 3,
            "tags": [
                "pde",
                "soliton"
            ],
            "usePreview": 0,
            "username": "TreborHuang",
            "viewed": 229
        },
        "renderpass": [
            {
                "code": "#define hue(v) ( .6 + .6 * cos( (v) + vec4(0,-2.*Pi/3.,2.*Pi/3.,0) ) )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float strength = get(fragCoord).x;\n    float it = sin(strength * ANGLE)*1.3;\n    // the field strength is already an angle (radians)\n    it = sign(it) * pow(abs(it), 1.6);  // Reverse(!) gamma-correct\n    fragColor = vec4(it, (cos((strength*ANGLE)-Pi)-0.8)/.3, -it, 1.0);\n    // A tint of green to show that it went round the phase circle.\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nfloat laplace(vec2 pos) {\n    return(WRAP(get(pos + vec2(1,0)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(1,0)).x - get(pos).x) / dx) / dx\n         \n         +(WRAP(get(pos + vec2(0,1)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(0,1)).x - get(pos).x) / dx) / dx;\n}\n\nfloat excite(float dist, float x){\n    return sin(2.6*x*sin(iTime*.3)+2.) *   // This factor seems to create a pair of moving solitons?\n        3.2 * (1. - exp(-1./pow(dist+0.00001,2.))) * exp(-.1*pow(dist, 2.)) / ANGLE;\n        // Of course everything is approximate.\n}\n\n// Calculates the position.\n// x - records the corrent position.\n// y - records last position.\n// z - records last acceleration.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xy = get(fragCoord).xx;\n    fragColor.z = laplace(fragCoord) + sin(fragColor.x * ANGLE) * K;  // Acceleration\n    \n    fragColor.x += (getv(fragCoord) + fragColor.z * .5 * dt) * dt;\n    \n    if(iMouse.z > 0.) {\n        // mouse\n        fragColor.xy += excite(length(iMouse.zw - fragCoord) * dx,\n            ((iMouse.z-fragCoord.x)* sin(iTime)\n            +(iMouse.w-fragCoord.y)* cos(iTime))* dx);\n    }\n    if(iFrame < 2) {\n        // initial position\n        fragColor = vec3(\n            .3 * exp(- pow(length(2. * fragCoord - iResolution.xy),2.) / iResolution.x * .2) * sin(fragCoord.x * .09 + fragCoord.y * 0.03),\n            0.,\n            1.\n        ).xxyz;\n    }\n    fragColor *= smooth;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define dx 0.1\n#define dt 0.03\n\n#define Pi 3.141592653589793\n\n#define get(p) texture(iChannel0, vec2(p)/iResolution.xy)\n#define getv(p) texture(iChannel1, vec2(p)/iResolution.xy).x\n\n#define smooth 0.99999\n#define K -3.\n\n#define ANGLE (2.*Pi)\n\n#define WRAP(t) (t)\n// Todo..\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\nfloat laplace(vec2 pos) {\n    return(WRAP(get(pos + vec2(1,0)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(1,0)).x - get(pos).x) / dx) / dx\n         \n         +(WRAP(get(pos + vec2(0,1)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(0,1)).x - get(pos).x) / dx) / dx;\n}\n\n\n// Calculates the velocity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pos = get(fragCoord);\n    fragColor.x = getv(fragCoord) + (pos.z +\n        laplace(fragCoord) + sin(pos.x * ANGLE) * K) * .5 * dt;\n    fragColor.x = clamp(fragColor.x, -3., 3.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}