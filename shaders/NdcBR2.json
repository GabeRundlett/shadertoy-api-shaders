{
    "Shader": {
        "info": {
            "date": "1656758667",
            "description": "License CC0: Abstract dragon scales\nContinued tinkering with the \"bubblesort\"\nI suppose next step is to compute the normal of the scales \nand apply some nice metallic lighting to make it look like \n\"real\" dragon scales\n",
            "flags": 0,
            "hasliked": 0,
            "id": "NdcBR2",
            "likes": 24,
            "name": "Abstract dragon scales",
            "published": 3,
            "tags": [
                "2d",
                "bubblesort"
            ],
            "usePreview": 1,
            "username": "mrange",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "// License CC0: Abstract dragon scales\n// Continued tinkering with the \"bubblesort\"\n// I suppose next step is to compute the normal of the scales \n// and apply some nice metallic lighting to make it look like \n// \"real\" dragon scales\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nvec2 mod2_1(inout vec2 p) {\n  p += 0.5;\n  vec2 n = floor(p);\n  p = fract(p)-0.5;\n  return n;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  // Based on: https://en.wikipedia.org/wiki/Alpha_compositing\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                            length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nfloat cellhf(vec2 n) {\n  float h = texture(iChannel0, 0.005*n+0.5).x;\n  h = sqrt(abs(h));\n  return h;\n}\n\nfloat celldf(vec2 p, vec2 n) {\n  float hh = cellhf(n);\n  vec2 hxx = vec2(cellhf(n-vec2(1.0, 0.0))-hh, cellhf(n-vec2(0.0, 1.0))-hh);\n  float hl = length(hxx);\n  hxx /= hl;\n  vec2 hyy = vec2(hxx.y, -hxx.x);\n  const float off = 0.25;\n  if (hl > 1E-6) p *= mat2(hxx, hyy);\n  float r = (sqrt(0.5)+off);\n  float d = egg(p.yx, r*0.9, 0.25*r);\n  return d;\n}\n\nvec3 effect(vec2 p) {\n  const float sz = 0.25;\n  const float amp = 10.0;\n  const float th = -TAU*sz*20.0;\n  p += amp*cos(vec2(1.0, sqrt(0.5))*TAU*(TIME)/(amp*30.0));\n  vec2 op = p;\n  p /= sz;  \n  float aa = 2.0/(sz*RESOLUTION.y);\n  vec2 n = mod2_1(p);\n\n  const int c = 1;\n  const int l = (2*c+1)*(2*c+1);\n  vec2 results[l];\n  int j = 0;\n  for (int x = -c; x <= c; ++x) {\n    for (int y = -c; y <= c; ++y) {\n      vec2 off = vec2(float(x), float(y));\n      vec2 pp = p - off;\n      vec2 nn = n + off;\n      \n      float d = celldf(pp, nn);\n      float h = cellhf(nn);\n      \n      results[j] = vec2(d, h);\n      ++j;\n    }\n  }\n\n  // Bubblesort in 2022?\n  for (int o = 1; o < l; ++o) {\n    vec2 r = results[o];\n    for (int i = o; i > 0; --i) {\n      vec2 l = results[i-1];\n      if (l.y > r.y) {\n        results[i - 1] = r;\n        results[i] = l;\n      } else {\n        r = l;\n      }\n    }\n  }\n\n  vec3 col = vec3(0.0);\n  for (int i = 0; i < l; ++i) {\n    vec2 r = results[i];\n    float d = r.x;\n    float h = r.y;\n    vec4 bcol0 = vec4(hsv2rgb(vec3(fract(0.05*length(op)), mix(0.125, 1.0, h), mix(0.25, 1.0, h))), 1.0);\n    vec4 bcol1 = vec4(vec3(bcol0*bcol0*0.25), 0.5);\n    vec4 bcol = mix(bcol0, bcol1, smoothstep(-th*aa, th*aa, sin(th*d)));\n    float t = smoothstep(aa, -aa, d);\n    vec4 ccol = bcol;\n    ccol.w *= t;\n    col *= mix(1.0, 0.25, exp(-10.0*max(d, 0.0)));\n    col = alphaBlend(col, ccol);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n    \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}