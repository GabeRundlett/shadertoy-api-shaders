{
    "Shader": {
        "info": {
            "date": "1608312251",
            "description": "Volumetric Mandelbulb with Color. Looks so poggers!",
            "flags": 32,
            "hasliked": 0,
            "id": "3l3yzr",
            "likes": 3,
            "name": "Colored Volumetric Mandelbulb",
            "published": 3,
            "tags": [
                "raymarch",
                "volumetric",
                "nebula"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// Common is for Settings and Global Functions\n// Buffer A is for Rendering\n// Buffer B is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\n// Zi7ar21's Colored Volumetric Mandelbulb --- December 18th, 2020\n// Updated December 28th, 2020 13:00 Mountain Time\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I kindly ask you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/3l3yzr\n// Fork of \"Spooky Nebula\" by Zi7ar21. https://www.shadertoy.com/view/tsVcDt\n// October 30th, 2020\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// LoicVDB's Improvements\n// Fork of \"cscsdc\" by loicvdb. https://shadertoy.com/view/wlSfRt --- August 8th, 2020\n// Fork of \"dsdfqdf\" by loicvdb. https://www.shadertoy.com/view/tdGyRm --- October 11th, 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Rendering\n\n// Oof ugly mess below watch out lol\n\n// ##### Fractal #####\nfloat mandelbulb(vec3 pos, int iter) {\n\tfloat Power = float(2.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iter; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, Power-1.0)*Power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Fractal Density\nint randexpiter(float iter){\n    return int(round((rand()*iter)+iter));\n}\n\nvec3 mandelbulbvolume(vec3 raypos){\n    vec3 dist = vec3(mandelbulb(raypos, randexpiter(16.0)), mandelbulb(raypos, randexpiter(8.0)), mandelbulb(raypos, randexpiter(4.0)));\n    vec3 density = -clamp(pow(dist, vec3(0.25)), 0.0, 0.1)+0.1;\n    return density;\n}\n\n// ##### RAYMARCHING #####\nvec3 directLight(vec3 raypos){\n    vec3 LightColor = vec3(16.0);\n    vec3 LightDirection = normalize(vec3(1.0));\n    float distorigin = 0.0;\n    vec3 density = vec3(0.0);\n    vec3 raydirmod = LightDirection*STEP_SIZE*rand();\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos+raydirmod;\n        density = vec3(mandelbulbvolume(raypos)*DENSITY);\n        vec3 absorbance = exp(-density);\n        attenuation *= absorbance;\n    }\n    return LightColor*attenuation;\n}\n\n// Compute/March the Ray\nvec3 raymarch(vec3 camerapos, vec3 raydir, vec2 coord){\n    float distorigin = 0.0;\n    //vec3 densityadd = vec3(0.0);\n    //vec3 density = vec3(0.0);\n    vec3 raypos = camerapos;\n    vec3 raydirmod = (raydir*rand())*STEP_SIZE;\n    vec3 outCol = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    for(int i=0; i<MAX_MARCHES; i++){\n        raypos = raypos + raydirmod;\n        // LoicVDB: don't use this, the density doesn't accumulate, its\n        // only purpose is to compute absorbance and transmittance\n        //densityadd = vec3(fractal(raypos)*DENSITY);\n        //density = vec3(density+densityadd);\n\n        // LoicVDB: just use this for density instead:\n        vec3 density = vec3(mandelbulbvolume(raypos)*DENSITY);\n        vec3 absorbance = exp(-density*STEP_SIZE);\n        vec3 transmittance = 1.0-absorbance;\n        vec3 directlighting = attenuation*transmittance;\n        if((density.r+density.g+density.b) > 0.0){\n            directlighting = directlighting*directLight(raypos);\n        }\n        outCol += directlighting;\n        attenuation *= absorbance;\n        distorigin = raypos.z-camerapos.z;\n        if(distorigin>MAX_DISTANCE) break;\n    }\n    return outCol;\n}\n\n// ##### RENDERING #####\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Start RNG\n    INIT_RNG;\n    // Camera Orientation\n    vec3 camerapos = vec3(2.0, -2.0, 2.0);\n    #ifdef ROTATION_MATRIX\n\t    // Dumb rotation matrix hecking Michael made me make\n\t    float xrot = atan(sqrt(2.0));\n\t    float yrot = pi;\n\t    float zrot = -pi/4.0;\n\t    // Camera Orientation (Cursed)\n        mat3 dir;\n\t    dir[0] = vec3(cos(yrot)*cos(zrot),-cos(yrot)*sin(zrot),sin(yrot));\n\t    dir[1] = vec3(cos(xrot)*sin(zrot)+sin(xrot)*sin(yrot)*cos(zrot),cos(xrot)*cos(zrot)-sin(xrot)*sin(yrot)*sin(zrot),-sin(xrot)*cos(yrot));\n\t    dir[2] = vec3(sin(xrot)*sin(zrot)-cos(xrot)*sin(yrot)*cos(zrot),sin(xrot)*cos(zrot)+cos(xrot)*sin(yrot)*sin(zrot),cos(xrot)*cos(yrot));\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 xdir = vec3(1.0,0.0,0.0);\n        vec3 ydir = vec3(0.0,1.0,0.0);\n        vec3 zdir = vec3(0.0,0.0,1.0);\n    #endif\n    // LoicVDB: I store the number of samples in the alpha channel\n    // LoicVDB: take the previous color and sample count (black and 0 if on first frame)\n    vec4 oldFragColor = vec4(0.0);\n    if(iFrame != 0) oldFragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // LoicVDB:I put it in the fragColor var because I want to keep it even if it's not in a tile\n    fragColor = oldFragColor;\n\n    // LoicVDB's Hyper Epic Tiles Function\n    int index = int(fragCoord.x/iResolution.x*float(TILES))\n              + int(fragCoord.y/iResolution.y*float(TILES))*TILES;\n    if(iFrame-(TILES*TILES*(iFrame/(TILES*TILES))) != index) return;\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    vec2 uvd = fragCoord/iResolution.xy;\n    #ifdef ROTATION_MATRIX\n    \tvec3 raydir = normalize(FOV*(uv.x*dir[0]+uv.y*dir[1])+dir[2]);\n    #endif\n    #ifndef ROTATION_MATRIX\n        vec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n    #endif\n    vec3 raymarched = raymarch(camerapos, raydir, vec2(fragCoord));\n\n    // Output\n    fragColor += vec4(raymarched, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Exporting a 32-Bit Float OpenEXR using the Button on the Bottom of the Editor\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // LoicVDB: take the color from the A buffer\n    vec4 texel = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // LoicVDB: divide it by the sample count (the alpha channel)\n    vec3 color = (texel.a == 0. ? vec3(0.) : texel.rgb / texel.a);\n    \n    // Output to screen\n    fragColor = vec4(pow(color, vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// ^^^ Switch Between Common, Buffer A, and Buffer B ^^^\n// This is for Settings and Global Functions\n\n// ##### COMMON VALUES #####\n\n// Change these Parameters to Your Liking!\n// Maximum Number of Marches,\n// You want it to limit the raymarcher before the max distance parameter or it will look bad.\n#define MAX_MARCHES 64\n\n// Redundant for this idk if the max marches are large and you see ugly stuff then increase this\n#define MAX_DISTANCE 8.0\n\n// Size of Steps, smaller means more sampling over depth but also means more computation.\n// Increase max marches if the scene goes invisible.\n#define STEP_SIZE 0.125\n\n// Camera's FOV\n#define FOV 1.0\n\n// Uncomment to enable rotation matrix for rotating camera, currently too slow\n#define ROTATION_MATRIX\n\n// Density of the volume. Changes how much light it scatters.\n#define DENSITY 4.0\n\n// Bailout, a larger value makes rendering slower but more accurate. A value more than 4 is\n// sometimes helpful, but not always.\n#define Bailout 4.0\n\n// Tiles, more means easier on the Hardware\n#define TILES 4 // Set to 1 if you have a computer that can handle it so it will render faster\n// So kindly made by LoicVDB uwu\n\n// Yummy, Pi! 32-Bit Floating Point Precision limits us to 3.14159265, but hey one day Shadertoy\n// may support double precision so why not throw in 3589793.\n#define pi 3.141592653589793\n\n// High-Quality Noise https://www.shadertoy.com/view/tdGfWc\n#define INIT_RNG ns = uint(iFrame*24676) + uint(fragCoord.x*5557.0) + uint(fragCoord.y*8482.0);\nuint ns;\nvoid RNGupdate(){\n    // Integer hash copied from Hugo Elias\n\tns = (ns<<13U)^ns;\n    ns = ns*(ns*ns*15731U+789221U)+1376312589U;\n}\nfloat rand(){\n    RNGupdate();\n    return float((ns*ns)&uvec2(0x7fffffffU))/float(0x7fffffff);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}