{
    "Shader": {
        "info": {
            "date": "1670985802",
            "description": "test for VR",
            "flags": 1,
            "hasliked": 0,
            "id": "ddSXD3",
            "likes": 4,
            "name": "2022_1214_VR_oilPainting_Tours",
            "published": 3,
            "tags": [
                "phong",
                "vr",
                "oilpainting"
            ],
            "usePreview": 0,
            "username": "yunChenLee_329",
            "viewed": 289
        },
        "renderpass": [
            {
                "code": "// Author: RJean Lee\n// fork from:CMH\n// Title: Basic Raymarching_2(normal, camera) \n// Reference: 20220414_glsl Breathing Circle_v5A(BRDF).qtz\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//uniform vec2 u_resolution;\n//uniform vec2 u_mouse;\n//uniform float u_time;\n\n\n//=== distance functions ===\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n\n// math\nmat3 fromEuler(vec3 ang) {\n    vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    vec3 m0 = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n    vec3 m1 = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n    vec3 m2 = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n    return mat3(m0, m1, m2);\n}\n\n\n\n\n\n\nfloat map(in vec3 p)\n{\n//return sdSphere(p+vec3(0.,0.,0.0), 0.5);\n//return sdTorus(p+vec3(0.,0.,0.0),vec2(0.4,0.2));\n//return sdBox(p+vec3(0.0,0.0,0.0), vec3(0.4, 0.4, 0.4));\nmat3 rot=fromEuler(vec3(0.0,0.0,iTime*0.2));\nvec3 p1=(p+vec3( 0.0, -0.0, 1.2))*rot;\nvec3 p2=(p+vec3( 1.2, -0.0, 0.0))*rot;\nvec3 p3=(p+vec3(-1.2, -0.0, 0.0))*rot;\nvec3 p4=(p+vec3( 0.0, -0.0,-1.2))*rot;\nvec3 p5=(p+vec3( 0.0, -1.2, 0.0))*rot;\n\nvec2 op = vec2(0.4,0.2);\nreturn min(min(min(min(sdTorus(p1,op),sdTorus(p2,op)),sdTorus(p3,op)),sdTorus(p4,op)),sdTorus(p5,op));\n}\n\n//=== gradient functions ===\nvec3 gradient( in vec3 p ) //尚未normalize\n{\n\tconst float d = 0.001;\n\tvec3 grad = vec3(map(p+vec3(d,0,0))-map(p-vec3(d,0,0)),\n                     map(p+vec3(0,d,0))-map(p-vec3(0,d,0)),\n                     map(p+vec3(0,0,d))-map(p-vec3(0,0,d)));\n\treturn grad;\n}\n\n\n// === raytrace functions===\nfloat trace(vec3 o, vec3 r, out vec3 p)\n{\nfloat d=0.0, t=0.0;\nfor (int i=0; i<32; ++i)\n{\n\tp= o+r*t;\n\td=map(p);\n\tif(d<0.0) break;\n\tt += d*0.5; //影響輪廓精準程度\n\t}\nreturn t;\n}\n\n//=== camera functions ===\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n//noise \n// 2D Random\n// float random (in vec2 st) {\n//     return fract(sin(dot(st.xy,\n//                          vec2(12.9898,78.233)))\n//                  * 43758.5453123);\n// }\n\n// // 2D Noise based on Morgan McGuire @morgan3d\n// // https://www.shadertoy.com/view/4dS3Wd\n// float noise (in vec2 st) {\n//     vec2 i = floor(st);\n//     vec2 f = fract(st);\n\n//     // Four corners in 2D of a tile\n//     float a = random(i);\n//     float b = random(i + vec2(1.0, 0.0));\n//     float c = random(i + vec2(0.0, 1.0));\n//     float d = random(i + vec2(1.0, 1.0));\n\n//     // Smooth Interpolation\n\n//     // Cubic Hermine Curve.  Same as SmoothStep()\n//     vec2 u = f*f*(3.0-2.0*f);\n//     // u = smoothstep(0.,1.,f);\n\n//     // Mix 4 coorners percentages\n//     return mix(a, b, u.x) +\n//             (c - a)* u.y * (1.0 - u.x) +\n//             (d - b) * u.x * u.y;\n// }\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\n\nvec4 render(vec3 RayOri,vec3 RayDir){\n    vec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\t\n\n    float Ka=1.0;   // Ambient reflection coefficient\n    float Kd=1.0;   // Diffuse reflection coefficient\n    float Ks=1.0;   // Specular reflection coefficient\n    float shininessVal=80.0; // Shininess\n    // Material color\n    vec3 ambientColor = vec3(0.15,0.1,0.05);\n    vec3 diffuseColor = vec3(0.8,0.25,0.0);\n    vec3 specularColor = vec3(1.0,1.0,1.0);\n   \tvec3 backgroundClr = vec3(0.0,0.25,0.7); \n\tvec3 lightPos = vec3(1.0,1.0,1.0); // Light position\n    \n    // \n    vec3 N = n+vec3(fbm(n.yz*40.0),fbm(n.xz*20.0),fbm(n.xy*20.0))*0.1;\n    vec3 L = normalize(lightPos-p);\n    //\n    float lambertain = max(dot(N,L),0.0);\n    float specular = 0.0;\n    if(lambertain > 0.0){\n        vec3 R = reflect(-L,N);\n        vec3 V = normalize(-p);\n        float specAngle = max(dot(R,V),0.0);\n        specular = pow(specAngle,shininessVal);\n    }\n    \n    vec3 result = vec3(Ka*ambientColor+Kd*lambertain*diffuseColor+Ks*specular*specularColor);\n\n    if(t<3.5) result = result; else result = backgroundClr;\n    return vec4(result,t);\n}\n\n// ================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x*= iResolution.x/iResolution.y;\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    //uv = uv+vec2(fbm(uv*40.0),fbm(uv*20.0))*0.1;\n\n// camera option1  (模型應在原點，適用於物件)\n\tvec3 CameraRot=vec3(0.0, -mouse.y*1.6, -mouse.x*6.28);\n\tvec3 ro= vec3(0.0, 0.0, 0.0);\n\tvec3 ta =vec3(0.0, 0.0, -1.0)*fromEuler(CameraRot);\n\tmat3 ca = setCamera( ro, ta, 0.0 );\n\tvec3 RayDir = ca*normalize(vec3(uv, 1.5));\n\tvec3 RayOri = ro;\n\n\n// camera option2 (攝影機在原點，適用於場景)\n/*\t\n\tvec3 CameraRot=vec3(0.0, -iMouse.y, -iMouse.x);\n\tvec3 RayOri= vec3(0.0, 0.0, 0.0);\t//CameraPos;\n\tvec3 RayDir = normalize(vec3(uv, -1.))*fromEuler(CameraRot);\n*/\n\t/*\n\tvec3 p,n;\n\tfloat t = trace(RayOri, RayDir, p);\n\tn=normalize(gradient(p));\n\t\t\n\n    float Ka=1.0;   // Ambient reflection coefficient\n    float Kd=1.0;   // Diffuse reflection coefficient\n    float Ks=1.0;   // Specular reflection coefficient\n    float shininessVal=80.0; // Shininess\n    // Material color\n    vec3 ambientColor = vec3(0.15,0.1,0.05);\n    vec3 diffuseColor = vec3(0.8,0.25,0.0);\n    vec3 specularColor = vec3(1.0,1.0,1.0);\n   \tvec3 backgroundClr = vec3(0.0,0.25,0.7); \n\tvec3 lightPos = vec3(1.0,1.0,1.0); // Light position\n    \n    // \n    vec3 N = n;\n    vec3 L = normalize(lightPos-p);\n    //\n    float lambertain = max(dot(N,L),0.0);\n    float specular = 0.0;\n    if(lambertain > 0.0){\n        vec3 R = reflect(-L,N);\n        vec3 V = normalize(-p);\n        float specAngle = max(dot(R,V),0.0);\n        specular = pow(specAngle,shininessVal);\n    }\n    \n    vec3 result = vec3(Ka*ambientColor+Kd*lambertain*diffuseColor+Ks*specular*specularColor);\n\n\n*/\n    vec4 result = render(RayOri, RayDir);\n    \n    float t = result.a;\n    //gl_FragColor = vec4(vec3(result),1.0);    \n    //if(t<3.5) fragColor = vec4(vec3(result),1.0); ///else fragColor = vec4(backgroundClr,1.0);\n\n    fragColor = vec4(vec3(result),1.0);\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n \n    vec4 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n    fragColor = vec4( col.xyz, 1.0 );}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}