{
    "Shader": {
        "info": {
            "date": "1555353968",
            "description": "Basic practice of putting a random idea to screen.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdSXzt",
            "likes": 12,
            "name": "Beam bending",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "phong",
                "sdf",
                "shadows",
                "spheretracing",
                "reflections",
                "blinn"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 631
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Beam bending - Just shader-writing practice of a random idea.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nmat2 r2d (float deg) {\n\tfloat rad = radians (deg);\n\tfloat c = cos (rad);\n\tfloat s = sin (rad);\n\treturn mat2 (c,s,-s,c);\n}\n\nfloat texNoise (vec2 p) {\n\treturn texture (iChannel0, p).r;\n}\n\nfloat smin (float d1, float d2, float k) {\n\tfloat h = clamp (.5 + .5*(d2 - d1)/k, .0, 1.);\n\treturn mix (d2, d1, h) - h*k*(1. - h);\n}\n\nfloat map (vec3 p, inout int id, inout vec3 pout) {\n\tfloat size = 3.;\n\tfloat offset = cos (.2*iTime);\n\tfloat offset2 = cos (iTime);\n\tfloat ground = p.y + size + offset2 + .75*texNoise (offset+.05*p.xz+.1*iTime);\n\tground = min (ground, -p.y + size + offset2 + .75*texNoise (offset-.1*iTime+.075*p.xz + 1.));\n\tfloat wall = p.z + 3.*size;\n\twall = min (wall, -p.z + 3.*size);\n\twall = min (wall, p.x + 2.*size);\n\twall = min (wall, -p.x + 2.*size);\n\tvec3 pbar = p;\n\tpbar.xz *= r2d (25.*cos (pbar.y + sin(3.*iTime)));\n\tpbar.xy *= r2d (9.*cos (pbar.y + sin(4.*iTime)));\n\tpbar.yz *= r2d (9.*sin (pbar.y + sin(2.*iTime)));\n\n\tpbar.x += .2*cos (pbar.y + 2.*iTime);\n\tpbar.z += -(.3*(cos(2.*iTime)))*sin (2.*pbar.y + 2.*iTime);\n\tfloat thickness = .5-.2*offset2*cos (2.*pbar.y+3.*iTime);\n\tvec3 s = vec3 (thickness, 3.5, thickness);\n\tfloat bar = length (max (vec3 (.0), abs (pbar) - s)) - .1;\n\tfloat d = min (wall, smin (ground, bar, 1.5));\n\tid = 1;\n    pout = pbar;\n\tif (d == wall) {id = 2; pout = p;}\n    return d;\n}\n\nfloat march (vec3 ro, vec3 rd, inout int id, inout vec3 pout)\n{\n\tfloat t = .0;\n\tfloat d = .0;\n\tfor (int i = 0; i< 64; ++i) {\n\t\tvec3 p = ro+d*rd;\n\t\tt = map (p, id, pout);\n\t\tif (abs (t) < .000000001*(1. + .125*t)) break;\n\t\td += t*.5;\n\t}\n\treturn d;\n}\n\nvec3 norm (vec3 p){\n\tint foo;\n\tvec3 bar;\n\tfloat d = map (p, foo, bar);\n\tvec2 e = vec2 (.01, .0);\n\treturn normalize (vec3 (map (p+e.xyy, foo, bar),\n                            map (p+e.yxy, foo, bar),\n                            map (p+e.yyx, foo, bar))-d);\n}\n\nfloat sha (vec3 p, vec3 lp, vec3 n, vec3 ldir) {\n\tfloat d2l = distance (lp, p);\n\tint foo;\n\tvec3 bar;\n\tfloat d2w = march (p+.01*n, ldir, foo, bar);\n\treturn d2l < d2w ? 1. : .1;\n}\n\nvec3 shade (vec3 ro, vec3 rd, float d, vec3 n, vec3 lp, vec3 lc, float li, int id, vec3 pout) {\n    vec3 p = ro + d*rd;\n\tfloat ld = distance (p, lp); \n\tvec3 ldir = normalize (lp - p);\n\tfloat att = 12. / (ld*ld);\n\tvec3 mat = vec3 (1., .0, .0);\n\tif (id == 1) mat = vec3 (.0);\n\tif (id == 2) mat = mix (vec3 (.0), vec3 (1.), smoothstep (.0, .5, sin (3.*p.y+5.*iTime)));\n\tfloat s = sha (p, lp, n, ldir);\n\tfloat diff = max (.0, dot (n, ldir));\n\tvec3 h = normalize (-rd + ldir);\n\tfloat shiny = 40.;\n\tfloat sp = pow (max (.0, dot (n, h)), shiny);\n\tvec3 am = vec3 (.05);\n\treturn att*s*(am + diff*lc*li*mat + sp*vec3 (1.));\n}\n\nvec3 cam (vec2 uv, vec3 ro, vec3 aim, float z) {\n\tvec3 f = normalize (aim - ro);\n\tvec3 wu = vec3 (.0, 1., .0);\n\tvec3 r = normalize (cross (wu, f));\n\tvec3 u = normalize (cross (f, r));\n\tvec3 c = ro + f*z;\n\treturn normalize(c + r*uv.x + u*uv.y - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvRaw = fragCoord/iResolution.xy;\n\tvec2 uv = uvRaw*2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv *= 1. + .25*length (uv);\n\n\tfloat dist = 3.;\n\tvec3 ro = vec3 (dist*cos (iTime), .0, dist*sin(iTime));\n\tvec3 rd = cam (uv, ro, vec3 (.0), 1.25);\n\tint id = 0;\n\tvec3 pout = vec3 (.0);\n\tfloat d = march (ro, rd, id, pout);\n\tvec3 p = ro + d*rd;\n\tvec3 n = norm (p);\n\tvec3 c = shade (ro, rd, d, n, vec3 (.0, .0, 2.), vec3 (.9, .85, .3), 2.,id, pout);\n\tc += shade (ro, rd, d, n, vec3 (2., 2., -2.), vec3 (.5, .5, .9), 2.,id, pout);\n\n\tif (id == 1) {\n\t\tro = p + .01*n;\n\t\trd = normalize (reflect (rd, n));\n\t\td = march (ro, rd, id, pout);\n\t\tp = ro + d*rd;\n\t\tn = norm(p);\n\t\tvec3 rc = shade (ro, rd, d, n, vec3 (.0, .0, 2.), vec3 (.9, .85, .3), 2.,id, pout);\n\t\trc += shade (ro, rd, d, n, vec3 (2., 2., -2.), vec3 (.3, .3, .9), 2.,id, pout);\n\t\tc += .3*rc;\n\t}\n\tc=c/(1.25+c*.5);\n\tc*=1.-.65*length(uvRaw*2.-1.);\n\tc*=mix(1.,.75,cos(500.*uvRaw.y));\n\tc=pow(c,vec3(1./2.2));\n\n    fragColor = vec4(c,1.);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}