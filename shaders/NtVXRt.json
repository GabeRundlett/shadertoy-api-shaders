{
    "Shader": {
        "info": {
            "date": "1641223860",
            "description": "hi",
            "flags": 0,
            "hasliked": 0,
            "id": "NtVXRt",
            "likes": 0,
            "name": "Imaginative Concentration",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "Cleric",
            "viewed": 238
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define JERK_INTERVAL 0.3\n#define JERK_SPEED .25\n#define SPIRAL_TRANS_BEGIN 5.0\n#define SPIRAL_TRANS_END (SPIRAL_TRANS_BEGIN + 10.0)\n#define SPIRAL_CENTER (SPIRAL_TRANS_END + 5.0)\n#define UNVEIL_START (SPIRAL_CENTER - 5.0)\n#define UNVEIL_END (UNVEIL_START + 15.0)\n#define FRACT_TUNE_START (UNVEIL_END - 5.)\n#define FRACT_TUNE_END (UNVEIL_END + 10.)\n#define TOTAL_T (FRACT_TUNE_END + 15.0)\n\n\nfloat nextFloat(inout int seed) {\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    seed ^= seed << 13;\n    seed ^= seed >> 17;\n    seed ^= seed << 5;\n    return -1. + 2.*abs(fract(float(seed) / 3141.592653)); // float -1 .. 1\n}\n\nmat2 rotate2D(float rad) {\n    float cs = cos(rad);\n    float sn = sin(rad);\n    return mat2(cs, sn, -sn, cs);\n}\n\nvec2 mandelpent_iter(vec2 z, vec2 c, float t) {\n    #define RAYS 5.0\n    #define ANG (360.0*PI/180.0/RAYS)\n    #define HALF_ANG (ANG/2.0)\n    #define R .51\n    #define D .76\n    \n    float scale = 1.82;// + 12.5*smoothstep(FRACT_TUNE_END, FRACT_TUNE_START, t);\n    \n    float rad = -t/4.0;//radians(15.0);\n    \n    // general rotation\n    mat2 M = rotate2D(rad);\n    z = M*z;\n\n    \n\n    float ang = atan(z.y, z.x);\n    float p = floor(mod((ang - PI/2.0 + HALF_ANG)/ANG, RAYS));\n    float rot = -ANG*p;\n\n\n\n    float d = D + .1*sin(3.0*t);\n    float radius = R*smoothstep(FRACT_TUNE_END-2.0, FRACT_TUNE_END, t) + .1*sin(t);\n    scale = scale + .1*sin(3.0*t);//*.2*sin(ang);\n    M = rotate2D(rot);\n    z = M*z;\n    if (z.y > d)\n        z.y = d - (z.y - d);\n    M[0][1] = -M[0][1]; // transpose matrix (reverse rotation)\n    M[1][0] = -M[1][0];\n    z = M*z;\n\n    float rr = dot(z,z);\n    float m = scale;\n    if (rr < radius*radius) {\n        m = scale/(radius*radius);\n    }\n    else if (rr < 1.0) {\n        m = scale/rr;\n    }\n    return z*m + c;\n}\n\nvec2 ifsgeneric_iter(vec2 z, vec2 c_, float t) {\n    #define VERT 2\n    float d = 1e10;\n    vec2 np;\n    for (int i = 0; i < VERT; i++) {\n        float deg = float(i)*360.0/float(VERT)/180.0*PI;\n        vec2 p = vec2(cos(deg+t), sin(deg+t));\n        float td = dot(z-p, z-p);\n        if (td < d) {\n            np = p;\n            d = td;\n        }\n    }\n\n    z = np + (z - np)*2.;\n    float rad = t;\n    mat2 M = rotate2D(rad);\n    z = M*z;\n    return z;\n}\n\nvec3 mandelpent(vec2 c, float t) {\n    #define ITER 15\n    \n    vec2 z = c;\n    int n;\n    \n    for(int i = 0; i <= ITER; i++) {\n        n = i;\n        z = mix(ifsgeneric_iter(z, c, t), mandelpent_iter(z, c, t),\n            //iMouse.x/iResolution.x\n            smoothstep(FRACT_TUNE_START, FRACT_TUNE_END, t)\n            );\n        float mz = dot(z,z);\n        if (mz > 124.0)\n            break;\n    }\n    float comp = float(n)/float(ITER);\n    return vec3(1.,.9 - comp*.5,.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, TOTAL_T);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    \n    \n    \n    \n    \n    \n    float step = floor(t/JERK_INTERVAL);\n    int randSeed = int(step)*12345678;\n    \n    \n    vec2 curr_xy = vec2(nextFloat(randSeed), nextFloat(randSeed));\n    randSeed = (int(step) + 1)*12345678;\n    vec2 next_xy = vec2(nextFloat(randSeed), nextFloat(randSeed));\n    \n    float next_trans = step*JERK_INTERVAL + JERK_INTERVAL;\n    float trans_weight = smoothstep(next_trans-JERK_SPEED, next_trans, t);\n    vec2 blob_xy = mix(curr_xy, next_xy, trans_weight);\n    \n    \n    vec2 spiral_xy = vec2(cos(t*2.*PI), sin(t*2.*PI));\n    spiral_xy *= 1. - smoothstep(SPIRAL_TRANS_BEGIN, SPIRAL_CENTER, t);\n    \n    float spiral_weight = smoothstep(SPIRAL_TRANS_BEGIN, SPIRAL_TRANS_END, t);\n    \n    blob_xy = mix(blob_xy, spiral_xy, spiral_weight);\n    blob_xy *= .5;\n    \n    \n    \n    \n    \n    float ang = atan(uv.x, uv.y);\n    float r = length(uv);\n    float veil_mask = (.5 + cos(\n        .5*PI*t\n        + 12.*ang\n        )/2.0)\n        * (.5 + cos(\n        -2.*PI*t\n        + 12.*ang\n        - r*50.\n        )/2.);\n        \n    vec2 blob_xy_0 = uv - blob_xy;\n    float thought_mask = 1. - smoothstep(UNVEIL_START, UNVEIL_END, t)*.96;\n    vec3 fract_color = mandelpent(uv, t);\n\n    veil_mask = mix(.5+veil_mask/5., 1., smoothstep(FRACT_TUNE_START, FRACT_TUNE_END, t));\n    veil_mask *= clamp(1.0 - length(blob_xy_0)*15.*thought_mask, 0., 1.);\n    \n    fragColor = vec4(fract_color*veil_mask, 1.0);\n    \n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}