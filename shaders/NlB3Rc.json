{
    "Shader": {
        "info": {
            "date": "1624534211",
            "description": "A faceted 2D twisted torus rendered in a cheap pseudo sketch style.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlB3Rc",
            "likes": 52,
            "name": "Faceted Torus Rendering",
            "published": 3,
            "tags": [
                "2d",
                "torus",
                "sketch",
                "draw",
                "isometric",
                "polar",
                "quad"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 981
        },
        "renderpass": [
            {
                "code": "/*\n\n    Faceted Torus Rendering\n    -----------------------\n    \n    There are countless hand drawn geometric images online, and a lot of \n    tutorials showing people how to draw them. Most involve multiple \n    simplistic repetitive steps and measurements, which make their \n    construction well suited to a computer.\n    \n    The downside is that computers do such a good job that the results tend \n    to look too flawless, which means some of the artistry gets lost in \n    translation. Ironically, we then have to complicate things to put the \n    flaws back in. In this case, I've done that via a basic post-processing\n    algorithm. It works, but there are better ones out there. Flockaroo has \n    some great examples of various rendering styles for anyone interested.\n    \n    This particular geometric rendering is a faceted twisted torus and is \n    simple to produce. In fact, anyone with basic geometric knowledge can do \n    it easily: Start off with an n-gon (the default is an octagon), then \n    render some radial quad strips for each side using basic vector addition \n    and trigonometry. How one goes about it is up to the individidual, but \n    you can check to see how I've done it below.\n    \n    Obviously, this is a 2D rendering of a 3D object, but it's possible to\n    render a 3D version in the same style, which I plan to put together in \n    due course. I'll leave the short version to the code golfers. :)\n    \n \n \n    \n    Other 2D polygon-based sketch examples:\n    \n    \n    // Very watchable, and with virtually no code. \n    Cube Circle Sketch - Shane\n    https://www.shadertoy.com/view/3dtBWX\n    \n\n*/\n\n// Background: Plain: 0, Sunset: 1, Light blue: 2.\n#define BACKGROUND 0\n\n// Sketch only.\n//#define SKETCH\n\n// Offset scribbled edges.\n//#define OFFSET_EDGES\n\n// Vertices.\n//#define VERTICES\n\n// Face center marking.\n//#define FACE_CENTER\n\n// Light panels... Yeah, it's a bit much, but I had to try. :)\n//#define PANELS\n\n// Rotate the torus about the XY plane.\n//#define ROTATE\n\n// N-gon degree. The default is octagonal, but numbers 4 to about 16\n// work well enough.\n#define N 8\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    float gSc = 1.;// + sin(iTime/3.)*.25;\n    \n    // Smoothing factor.\n    float sf = gSc/iRes;\n    \n    // Scaling, translation, etc.\n    vec2 p = uv*gSc; \n    \n    // Coordinate perturbation. There's small rigid one to enhance the hand-drawn look, and\n    // a larger animated one to wave the paper around a bit.\n    vec2 offs = vec2(fbm(p*16.), fbm(p*16. + .35));\n    vec2 offs2 = vec2(fbm(p*1. + iTime/4.), fbm(p*1. + .5 + iTime/4.));\n    const float oFct = .007;\n    const float oFct2 = .04;\n    p -= (offs - .5)*oFct;\n    p -= (offs2 - .5)*oFct2;\n    \n    \n    \n    // Set the background to something neutral.\n    float lgt = dot(rot2(-3.14159/6.)*uv, vec2(.5)) + .5;\n    #if BACKGROUND == 0\n    vec3 col = mix(vec3(.6, .55, .45), vec3(.9, .85, .8), lgt);\n    #elif BACKGROUND == 1\n    vec3 col = mix(vec3(.7, .2, .3), vec3(1, .7, .3), lgt);\n    col = mix(col, col.yzx, .15);\n    #else\n    vec3 col = vec3(.65, .85, 1)*mix(.8, 1.2, lgt);\n    #endif\n\n    \n    // Edge width. \n    const float ew = .00165;  \n   \n    // N-Gon degree.\n    const float fN = float(N);\n   \n    // Center to vertex vector.\n    vec2 vi = vec2(-.15, 0); \n    \n    // Quad side length vector, used to construct the faces.\n    vec2 sL = vec2(0, abs(vi.x*sin(6.2831/fN/2.)*2.));\n    \n     \n    // Whole object, hit polygon and line distance fields.\n    float obj = 1e5, polyMin = 1e5, line = 1e5;\n    \n    // Offset edges.\n    float edge = 1e5;\n    \n    // The object vertices.\n    #ifdef ROTATE\n    vec2 q = rot2(iTime/8.)*p;\n    #else\n    vec2 q = p;\n    #endif\n    \n    // Hit quad vertices.\n    vec2[4] pV;\n    // Hit quad ID.\n    vec2 id;\n    \n    \n    // Quad circular strip for this edge.\n    for(int i = min(0, iFrame); i<N; i++){\n\n        // First quad for this particular edge.\n        vec2[4] vR;\n        \n        vR[0] = rot2(-6.2831/fN*float(i) + 3.14159/fN)*vi; \n        vR[1] = vR[0]+ rot2(3.14159/fN)*sL;\n        vR[2] = vR[1] + sL; \n        vR[3] = vR[0] + sL;\n            \n        // Edging out quad by quad in a circular fashion.\n        for(int j = 0; j<N - 1; j++){\n        \n            // Quad value.\n            float qud = quad(q, vR);\n            \n            // The combined quads, or the whole object.\n            obj = min(obj, qud);\n            if(qud<polyMin){\n            \n               // Update the minimum quad distance.\n               polyMin = qud;\n               \n               // Quad ID.\n               id = vec2(i, j);\n               \n               // Hit vertices.\n               pV = vR;\n              \n            }\n        \n           \n            // Drawing the helper grid lines.\n            //if(j%2==0) line = min(line, abs(length(q) - length(vR[2])));\n            vec2  nrm = normalize(vR[2] - vR[3]);\n            if(j%2==0) line = min(line, sdLine(q, vR[2] - nrm, vR[3] + nrm));\n            //nrm = normalize(vR[0] - vR[1]);\n            //if(j%4==2) line = min(line, sdLine(q, vR[0] - nrm, vR[1] + nrm)); \n            \n            // Offset edges, if chosen.\n            #ifdef OFFSET_EDGES\n            // Offset polygon edges.\n            for(int l = 0; l<3; l++){\n                for(int k = 0; k<4; k++){\n                    float a = 1./float(l + 1);\n                    vec2 pk = pV[k];\n                    vec2 pk1 = pV[(k + 1)%4];\n                    \n                    vec2 offs1 = (vec2(hash21(pk + .45*a), hash21(pk + .73*a)) - .5);\n                    vec2 offs2 = (vec2(hash21(pk1 + .29*a), hash21(pk1 + .87*a)) - .5);\n                    vec2 pA = pk - offs1*.0125;\n                    vec2 pB = pk1 - offs2*.0125;\n                    vec2 nm = normalize(pB - pA);\n                    edge = min(edge, sdLine(q, pA - nm*.01, pB + nm*.01));\n\n                }\n            }\n            #endif\n            \n            // Produce the vertices for the next quad in the strip. As you can see, \n            // each quad starts with the last vertices from the prevous quad, and the \n            // new end vertices are created by adding a rotated side edge. \n            vR[0] = vR[3];\n            vR[1] = vR[2];\n            vR[2] = vR[1] + rot2(-3.14159/fN*float(j+1))*sL;\n            vR[3] = vR[0] + rot2(-3.14159/fN*float(j+1))*sL;            \n           \n        }\n \n        // Rotate the side length vector to the right position for the next inner vertex.\n        sL = rot2(-6.283/fN)*sL; \n       \n        // Fake break to counter unrolling and slow compile times.\n        if(length(sL)>1e5) break;\n        \n    }\n    \n    \n    \n    \n    // Coloring and shading, based on polygon ID (side band number, or position within the band).\n    //float hlfN = float((N - 1)/2);\n    //float fi = float(N/2) + 1. - id.x;\n    //float sh = mod(fi, float(N/2))/float(hlfN)*.5 + .5;\n    \n    float rt = 0.;\n    #ifdef ROTATE\n    rt = iTime/8.;\n    #endif\n    float sh = sin((float(N) - id.x)*6.2831/fN*1.3 - rt)*.25 + .75;\n    sh *= id.y/(fN - 2.)*.5 + .5;\n \n    // Polygon color.\n    vec3 polyCol = (.55 + .45*cos(-6.2831*sh/3.5 + vec3(0, 1, 2) + 2.2))*1.5;//vec3(sh, sh*sh, sh*sh*sh)*1.5;\n    //vec3 polyCol = col*vec3(sh*.9 + .1)*1.35;\n    //polyCol = mix(polyCol.zyx, polyCol.yxz, .85);\n    polyCol = mix(polyCol, polyCol.yzx, .05);\n    //polyCol = mix(polyCol.yxz, polyCol.zyx, .95);\n    \n    \n    /*\n    // Holes.\n    polyMin = abs(polyMin + ew*6.) - ew*6.;\n    polyMin = abs(polyMin + ew*6.) - ew*6.;\n    obj = max(obj, polyMin);\n    */\n    \n   \n    // Object drop shadow and outside edges.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*24.*iRes/450., obj))*.35);\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, obj - ew*3.))*.85);\n     \n    \n  \n\n    #ifdef OFFSET_EDGES\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin)));\n    #else\n    col = mix(col, polyCol/3., (1. - smoothstep(0., sf, polyMin)));\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin + ew*2.)));\n    /*\n    // More decorated faces... I wasn't feeling it. :)\n    col = mix(col, polyCol/8., (1. - smoothstep(0., sf, polyMin)));\n    col = mix(col, mix(min(polyCol*2., 1.5), vec3(1), .35), (1. - smoothstep(0., sf, polyMin + ew*3.)));\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, polyMin + ew*6.)));\n    col = mix(col, polyCol, (1. - smoothstep(0., sf, polyMin + ew*8.)));\n    */\n    #endif\n    \n    #ifdef PANELS\n    // Lit face windows.\n    col = mix(col, polyCol*2., (1. - smoothstep(0., sf*12., polyMin + ew*28.)));\n    col = mix(col, polyCol/2., (1. - smoothstep(0., sf, abs(polyMin + ew*12.) - ew)));\n    col = mix(col, polyCol/2., (1. - smoothstep(0., sf, abs(polyMin + ew*22.) - ew)));\n    #endif\n    \n    /*\n    // Triangulate. Interesting, but a bit of depth is lost somehow.\n    float line2 = 1e5;\n    if(length(pV[0] - pV[2])<length(pV[1] - pV[3])) line2 = min(line2, sdLine(q, pV[0], pV[2]));\n    else line2 = min(line2, sdLine(q, pV[1], pV[3]));\n    line2 -= ew*.67;\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, line2)));\n    */\n    \n    #ifdef VERTICES\n    // Render vertex points.\n    float vert = min(length(q - pV[0]), length(q - pV[1]));\n    vert = min(vert, min(length(q - pV[2]), length(q - pV[3])));\n    vert -= ew*5.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n    col = mix(col, polyCol.xzy*.7, (1. - smoothstep(0., sf*2., vert + ew*4.)));\n    #endif\n\n    \n    #ifdef FACE_CENTER\n    // Face center points.\n    vec2 cntr = (pV[0] + pV[1] + pV[2] + pV[3])/4.;\n    float cVert = length(q - cntr) - ew*4.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cVert)));\n    col = mix(col, polyCol.xzy*.7, (1. - smoothstep(0., sf*2., cVert + ew*3.)));\n    #endif\n    \n    #ifndef ROTATE\n    #ifndef SKETCH\n    // Fake construction lines when the object isn't rotating.\n    line -= ew;\n    line = max(line, obj - .4);\n    float alpha = mix(.15, .15, 1. - smoothstep(0., sf*2., obj));\n    col = mix(col, polyCol/32., (1. - smoothstep(0., sf, line))*alpha);\n    #endif\n    #endif\n    \n    #ifdef OFFSET_EDGES\n    col = mix(col, polyCol/3., 1. - smoothstep(0., sf, edge - ew/3.));\n    #endif\n    \n    // Just a cheap way to seperate the foreground object coordinates from\n    // those in the background.\n    p = mix(p, q, 1. - smoothstep(0., sf*2., obj));\n     \n     \n    // Subtle pencil overlay... It's cheap and definitely not production worthy,\n    // but it works well enough for the purpose of the example. The idea is based\n    // off of one of Flockaroo's examples.\n    vec2 qq = p*8.;//*gSc;\n    //vec2 qq = p*8.;\n    #ifdef SKETCH\n    int drkLns = 1;\n    #else\n    int drkLns = 0;\n    #endif\n    vec3 colP = pencil(col, qq*iRes/450., drkLns);\n    #ifdef SKETCH\n    // Just the pencil sketch. The last factor ranges from zero to one and \n    // determines the sketchiness of the rendering... Pun intended. :D\n    col = colP;\n    //col = mix(dot(col, vec3(.299, .587, .114))*vec3(1), colP, .6);\n    #else\n    col = mix(col, 1. - exp(-(col*2.)*(colP + .15)), .85); \n    #endif\n    //col = mix(col, colP, .85);\n    //col = mix(min(col, colP), max(col, colP), .35); \n   \n \n\n    // Cheap paper grain... Also barely worth the effort. :)\n    vec2 pp = p;//floor(q*1024.);\n    vec3 rn3 = vec3(hash21(pp), hash21(pp + 2.37), hash21(pp + 4.83));\n    vec3 pg = .9 + (rn3.xyz*.35 + rn3.xxx*.65)*.2;\n    col *= min(pg, 1.); \n \n\n\n\n    // Rough gamma correction and output to screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// UTILITY FUNCTIONS -- These are just worker functions. All the logic is contained\n// within the \"Image\" tab.\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n    return fract(sin(mod(dot(p, vec2(27.619, 57.583)), 6.2831589))*43758.5453); \n}\n\n\n// IQ's line distace formula. \nfloat sdLine(in vec2 p, in vec2 a, in vec2 b){\n\n\tp -= a, b -= a;\n\treturn length(p - b*clamp(dot(p, b)/dot(b, b), 0., 1.));\n}\n\n// Entirely based on IQ's signed distance to a 2D triangle. I've expanded it \n// to work with convex quads and generalized it a bit, but I doubt it would \n// translate to speed. It would be easy to generalize to convex polyons though.\nfloat quad(in vec2 p, in vec2[4] v){\n\n    // Lines between successive vertex points.\n    vec2[4] e = vec2[4](v[1] - v[0], v[2] - v[1], v[3] - v[2], v[0] - v[3]);\n    \n    // Winding related sign.\n    float s = sign(e[0].x*e[3].y - e[0].y*e[3].x);\n    \n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<4; i++){\n        \n        // Minimum point to line calculations.\n        vec2 vi = p - v[i];\n        vec2 qi = vi - e[i]*clamp(dot(vi, e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(qi, qi), s*(vi.x*e[i].y - vi.y*e[i].x)));\n    }\n\n    // Quad distance.\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n\n// Compact, self-contained version of IQ's 2D value noise function.\nfloat n2D(vec2 p){\n   \n    // Setup.\n    // Any random integers will work, but this particular\n    // combination works well.\n    const vec2 s = vec2(1, 113);\n    // Unique cell ID and local coordinates.\n    vec2 ip = floor(p); p -= ip;\n    // Vertex IDs.\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n   \n    // Smoothing.\n    p *= p*(3. - 2.*p);\n    //p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother.\n   \n    // Random values for the square vertices.\n    h = fract(sin(mod(h, 6.2831589))*43758.5453);\n   \n    // Interpolation.\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x); // Output: Range: [0, 1].\n}\n\n// FBM -- 4 accumulated noise layers of modulated amplitudes and frequencies.\nfloat fbm(vec2 p){ return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\n\nvec3 pencil(vec3 col, vec2 p, int drkLns){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix similar, but rotated, layers on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    const vec2 sc = vec2(1, 12);\n    q += (vec2(n2D(q*4.), n2D(q*4. + 7.3)) - .5)*.03;\n    q *= rot2(-3.14159/4.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Repeat the process with a few extra rotated layers.\n    q *= rot2(3.14159/3.); q += 1.5;\n    float ns2 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(-3.14159/5.2); q += 3.;\n    float ns3 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    q *= rot2(3.14159/3.7); q += 6.;\n    float ns4 = (n2D(q*sc)*.66 + n2D(q*2.*sc)*.34);\n    //\n    // Compare it to the underlying grey scale value.\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    const float contrast = 1.;\n    if(drkLns==0){\n        // Same, but with contrast.\n        ns = (.5 + (gr - (max(max(ns, ns2), max(ns3, ns4))))*contrast); \n    }\n    else {\n        // Different contrast.\n        ns = smoothstep(0., 1., .5 + (gr - max(max(ns, ns2), max(ns3, ns4)))); \n    }\n    // \n    // Return the pencil sketch value.\n    return vec3(clamp(ns, 0., 1.));\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}