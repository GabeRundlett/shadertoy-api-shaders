{
    "Shader": {
        "info": {
            "date": "1447338826",
            "description": "Test for shorter starfield. This one is based on texture advection + quadtree + procedural stars (indeed, it is an infinite zoom. or perspective, depending on lines #10-11).\nI'm sure it's possible to do nicer + shorter ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "ltBXDd",
            "likes": 55,
            "name": "star field 4 (433 chars)",
            "published": 3,
            "tags": [
                "texture",
                "advection",
                "starfield",
                "short"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 5596
        },
        "renderpass": [
            {
                "code": "// Test for shorter starfield. \n// see also https://www.shadertoy.com/results?query=starfield&sort=newest\n// This one is based on texture advection, quadtree and procedural stars.\n\nfloat D=8., Z=3.;               // D: duration of advection layers, Z: zoom factor\n\n#define R(U,d) fract( 1e4* sin( U*mat2(1234,-53,457,-17)+d ) )\n\nfloat M(vec2 U, float t) {           // --- texture layer\n// vec2 iU = ceil(U/=exp2(t-8.)),              // quadtree cell Id - infinite zoom\n   vec2 iU = ceil(U/=exp2(t-8.)*D/(3.+t)),     // quadtree cell Id - with perspective\n          P = .2+.6*R(iU,0.);                  // 1 star position per cell\n    float r = 9.* R(iU,1.).x;                  // radius + proba of star ( = P(r<1) )\n\treturn r > 1. ? 1. :   length( P - fract(U) ) * 8./(1.+5.*r) ;\n}\n\nvoid mainImage( out vec4 o,  vec2 U )\n{\n    o -= o;\n    U = U / iResolution.y - .5;\n\n    // --- prepare the timings and weightings of the 3  texture layers\n\n    vec3 P = vec3(-1,0,1)/3., T,\n         t = fract( iTime/D + P +.5 )-.5,  // layer time\n         w = .5+.5*cos(6.28*t);                  // layer weight\n    t = t*D+Z;  \n    \n    // --- prepare the 3 texture layers\n\n    T.x = M(U,t.x),  T.y = M(-U,t.y),  T.z = M(U.yx,t.z); // avoid using same U for all layers\n    //T = sin(100.*U.x/exp2(t3))+sin(100.*U.y/exp2(t3));  // try this for obvious pattern\n    T = .03/(T*T);\n\n    // --- texture advection: cyclical weighted  sum\n\n    o += dot(w,T);\n    // o.rgb = w*T;             // try this alternative to see the 3 layers of texture advection\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}