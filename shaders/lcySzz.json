{
    "Shader": {
        "info": {
            "date": "1714704529",
            "description": "Just a night to unwind and code some pretty shader. ",
            "flags": 32,
            "hasliked": 0,
            "id": "lcySzz",
            "likes": 23,
            "name": "Metal Hexagon Truchet",
            "published": 3,
            "tags": [
                "raymarching",
                "hexagon",
                "truchet"
            ],
            "usePreview": 1,
            "username": "byt3_m3chanic",
            "viewed": 225
        },
        "renderpass": [
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Metal Hexagon Truchet\n    05/02/24 | @byt3_m3chanic\n\n    Average Hexagon Truchet shader with some reflections. Most of this is what I picked\n    up from @Shane and his help on my early shaders. \n\n    @Shane\n    https://www.shadertoy.com/view/4td3zj\n    https://www.shadertoy.com/view/llSyDh\n    \n    opEx / torus and hue palette picked up from @iq\n    https://iquilezles.org/articles/\n    \n*/\n\n#define R iResolution\n#define BUFFER iChannel0\n\nfloat offset[3] = float[]( 0.001, 2.25, 4.25 );\nfloat weight[3] = float[]( 0.2, 0.35, 0.075 );\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n\tvec2 uv = F.xy/R.xy;\n\n    vec3 original = texture(iChannel0, uv).rgb;\n    vec3 blur = texture(BUFFER, uv).rgb * weight[0];\n    \n    for (int i=1; i<3; i++) {\n      blur += texture(BUFFER, uv + vec2(offset[i])/R.xy, .01).rgb * weight[i];\n      blur += texture(BUFFER, uv - vec2(offset[i])/R.xy, .01).rgb * weight[i];\n    }\n\n    float clipMask = length(abs(uv.y)-.5);\n    vec3 C = mix(blur,original,smoothstep(.7,.895,1.-clipMask));\n\n    O = vec4(C,1.);\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Metal Hexagon Truchet\n    05/02/24 | @byt3_m3chanic\n\n    Average Hexagon Truchet shader with some reflections. Most of this is what I picked\n    up from @Shane and his help on my early shaders. \n\n    @Shane\n    https://www.shadertoy.com/view/4td3zj\n    https://www.shadertoy.com/view/llSyDh\n    \n    opEx / torus and hue palette picked up from @iq\n    https://iquilezles.org/articles/\n    \n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.141592653\n#define PI2 6.283185307\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 30.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n\n//@iq opEx & torus\nfloat opEx(in float d, in float pz, in float h){\n    vec2 w = vec2( d, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// globals\nvec4 hextiles,htile;\nvec3 hit,hp;\nfloat tRnd;\nmat2 r60;\n\nconst float scale =  .35;\nconst vec2 s = vec2(sqrt(3.), 1.);\n\nvec2 map(vec3 pos) {\n    vec2 res = vec2(1e5,0);\n\n    pos.x += T*.4;\n    \n    float py = pos.y*scale;\n\tvec2 p = pos.xz*scale;\n    \n    //@Shane Hexagon Tiling \n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h4 = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    h4 = dot(h4.xy, h4.xy)<dot(h4.zw, h4.zw) ? vec4(h4.xy, hC.xy) : vec4(h4.zw, hC.zw + .5);\n    p = h4.xy; vec2 id = h4.zw;\n    hextiles = h4;\n    \n    float rnd = hash21(id.xy);\n    \n    tRnd=rnd;\n        \n    if(rnd>.5) p *= r60;\n    \n    vec2 ts = vec2(.2891,.065+.045*sin(pos.x*.4+T) );\n\t\n    vec2 p0 = p - vec2(-0.288683602, .5);\n    vec2 p1 = p - vec2( 0.577350266, .0);\n    vec2 p2 = p - vec2(-0.288683602,-.5);\n\n    float t1 = torus(vec3(p0.x, py, p0.y), ts); \n          t1 = min(torus(vec3(p1.x, py, p1.y), ts),t1); \n          t1 = min(torus(vec3(p2.x, py, p2.y), ts),t1); \n\n    if(t1<res.x) {\n        res = vec2(t1,1.); \n        hit=pos;\n    }\n    \n    //@Shane Hexagon\n    const vec3 k = vec3(-.8660254, .5, .57735);\n    p = abs(p); \n    p -= 2.*min(dot(k.xy, p), 0.)*k.xy;\n    float r = .34;\n    float h2 = length(p - vec2(clamp(p.x, -k.z*r, k.z*r), r))*sign(p.y - r) - .15;\n    \n    h2 = opEx(abs(abs(h2)-.05)-.0125, (pos.y+.25), .185);\n    if(h2<res.x) {\n        res = vec2(h2,3.); \n        hit=pos;\n    }\n    \n    float f = pos.y+1.;\n    if(f<res.x) {\n        res=vec2(f,2);\n        hit=pos;\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\n// Tri-Planar blending function Ryan Geiss\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n//@iq palettes\nvec3 hue(float t){ \n    return .45+.4*cos( PI2*(50.+t)*vec3(.95,.97,.88)*vec3(0.949,0.518,0.110) ); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<128;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.35: ray.x;\n        m  = ray.y;\n    } \n    \n    hp = hit;\n    htile = hextiles;\n\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,8,0);\n        vec3 l = normalize(lpos-p);\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        vec3 h = vec3(.05);\n\n        if(m==1.) {\n            float tx = tex3D(iChannel1,hp*1.5,n).g;\n            float px = fwidth(hp.x);\n            \n            vec2 uv = htile.xy;\n            float dir = tRnd <.5 ? 1. : -1.;\n            if(tRnd>.5) uv *= r60; \n      \n            vec3 d3, a3;\n            vec2 p0 = uv - vec2(-0.288683602, .5);\n            vec2 p1 = uv - vec2( 0.577350266, .0);\n            vec2 p2 = uv - vec2(-0.288683602,-.5);\n     \n            d3 = vec3(length(p0), length(p1), length(p2));\n            d3 = abs(d3 - 1.732/6.) - .125;\n\n            a3.x = atan(p0.x, p0.y);\n            a3.y = atan(p1.x, p1.y);\n            a3.z = atan(p2.x, p2.y);\n\n            vec2 da = d3.x<d3.y && d3.x<d3.z? vec2(d3.x, a3.x) : d3.y<d3.z? vec2(d3.y, a3.y) : vec2(d3.z, a3.z);\n            float a = abs(fract(da.y/PI2*6.+(T*.1)*dir) - .5)*2. - .5;\n \n            h = mix(vec3(.35), hue(hp.x*.025)*tx, 1.-smoothstep(px,-px, a)); \n            h = mix(h, hue((100.-hp.x)*.025)*tx,  smoothstep(px,-px, abs(a)-.1)); \n            ref = h;\n        }\n        \n        if(m==2.) {\n            float tx = tex3D(iChannel1,hp*1.5,n).g;\n            h = hue(hp.x*.025)*tx;\n            ref = vec3(clamp(.2-tx,.15,1.));\n        }\n         \n        if(m==3.) {\n            h = vec3(.3);\n            ref = h;\n        }\n         \n        float shdw = 1.;\n        for( float t=.05; t < 12.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 32.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>12. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        C = h*diff+min(spec,shdw);\n        C = mix(FC.rgb,C,  exp(-.00005*d*d*d));\n    \n        ro = p+n*1e-3;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    r60 = rot(1.0471975512);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    \n    const float zoom = 5.;\n    vec3 ro = vec3(uv*zoom,-(zoom+1.));\n    vec3 rd = vec3(0,0,1.);\n\n    float x = M.xy == vec2(0) || M.z <0. ? 0. : -(M.y/R.y * .2 - .10) * PI;\n    float y = M.xy == vec2(0) || M.z <0. ? 0. : -(M.x/R.x * .5 - .25) * PI;\n    \n    mat2 rx = rot(-.73+x), ry = rot(.68+y);\n    ro.yz *= rx,ro.xz *= ry;\n    rd.yz *= rx,rd.xz *= ry;\n\n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d, a;\n    float numBounces = 3.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d = 0.;\n        vec3 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass * fil;\n        fil *= ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(FC.rgb,C,  exp(-.0005*a*a*a));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}