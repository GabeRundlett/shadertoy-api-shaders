{
    "Shader": {
        "info": {
            "date": "1634944770",
            "description": "Refraction Crystals [015] Just playing with some simple fold/mirror formulas / SDF intersections",
            "flags": 0,
            "hasliked": 0,
            "id": "ftB3DG",
            "likes": 34,
            "name": "Refraction Crystals [015]",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "refraction",
                "crystal"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 653
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Refraction Crystals [015]\n    10/22/21 @byt3_m3chanic\n    \n    Just playing with some simple fold/mirror formulas / SDF intersection\n    to make some pretty fractal crystal like things.\n\n*/\n\n#define R \t\t    iResolution\n#define T \t\t    iTime\n#define M \t\t    iMouse\n\n#define PI          3.14159265358\n#define PI2         6.28318530718\n\n#define MAX_DIST    100.\n\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*4123.2323); }\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), .0, 1.); }\nfloat eoc(float t) { return (t = t - 1.) * t * t + 1.; }\n\n//@iq sdf's\nfloat box(vec3 p, vec3 b, float r) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.0)-r;\n}\nfloat octa( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*.5773;\n}\n\n// fold formulas\nvoid bet(inout vec4 p, float s, float f, float m) {\n\tp.xy = abs(p.xy + f) - abs(p.xy - f) - p.xy;\n\tfloat rr = dot(p.xyz, p.xyz);\n\tif (rr < m) {\n\t\tif(m==0.) m=1e-5;\n\t\tp /= m;\n\t}else{\n\t\tif (rr<1.)p /= rr;\n\t}\n\tp *= s;\n}\n\nvoid tet(inout vec4 p, float k1, float k2, float k3, float k4) {\n\tp = abs(p);\n\tfloat k = (k1 - .5)*2.;\n\tp.xyz /= vec3(k2, k3, k4);\n\n\tif (p.x < p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x > p.y) p.xy = p.yx; p.x = -p.x;\n\tif (p.x < p.z) p.xz = p.zx; p.x = -p.x;\n\tif (p.x > p.z) p.xz = p.zx; p.x = -p.x;\n\n\tp.xyz = p.xyz*k1 - k + 1.;\n\tp.xyz *= vec3(k2, k3, k4);\n\tp.w *= abs(k);\n}\n\nvec2 sdform(in vec3 pos, float hs) {\n    vec4 P = vec4(pos.xzy, 1.);\n    float orbits = .0;\n    for(int i = 0; i < 3; i++) {\n        orbits = max(length(P.xz)*.075,orbits);\n        bet(P, 4.25-hs, 3.-hs, .55);\n        \n        if(hs>.5) {\n            tet(P, 1.5+hs, 1.5, 1.5, 1.5);\n        }else{\n            tet(P, 1.5-hs, 1.+hs, 1.5, 1.5);\n        }\n    }\n  \n    float ln = .9*(abs(P.z)-15.)/P.w;\n    \n    return vec2(ln,orbits);\n}\n\nmat2 rx,ry,turn;\nfloat time,ga1,ga2,ga3,ga4,tmod;\n    \nconst float s = 13.;\nconst float hf= s/2.;\n\nvec2 map (in vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n    \n    vec3 dp = p;\n    \n    p.y+= .2;\n    p.z+= M.z>0.?.75:1.75;\n   \n    // movin domain 1 rep but using px to move the ID's\n    // as if the domain is continious helps make the refraction\n    // stay pretty as things get messy with larger time variables \n    // used for distance\n    float px = p.x-(ga2*s);\n    p.x-=ga1*s;\n    float id = floor((px+hf)/s);\n\n    p.x=mod(p.x+hf,s)-hf;\n    p.yz*=rx;\n    p.xz*=ry;\n\n    float hs = hash21(vec2(id,1.));\n    vec2 f = sdform(p,hs);\n    float c = octa(p,3.);\n    \n    f.x= hs>.85?max(f.x,c):max(-f.x,c);\n    if(f.x<res.x) {\n        res = f;\n    }\n\n    float d = box(dp,vec3(9),.00);\n    d=max(d,-box(dp,vec3(5.5,4.,5.5),.001));\n    d=max(d,-box(dp,vec3(9.5,3.,4.5),.25));\n    d=max(d,-box(dp,vec3(4.5,3.,9.5),.25));\n    if(d<res.x) {\n        res = vec2(d,14.);\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 clr = .5 + .4 *sin(m + vec3(2.5,1.5,.5));\n    vec3 h = mix(vec3(0),clr,.45);\n    if(m==14.) h=vec3(.416,.420,.506)*clamp((p.y*.1+.5),0.,1.);\n    return h*diff;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    time = T;\n    float timer = T*.08;\n    \n    tmod = mod(time, 10.);\n    float t1 = lsp(0., 5., tmod);\n    ga1 = eoc(fract(t1));\n    ga1 = ga1*ga1*ga1;\n    ga2 = (t1)+floor(time*.1);\n\n    vec3 C=vec3(.0);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,4.),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? 0. :  (M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 2. - 1.) * PI;\n    //float dt = length(uv-vec2(x,y));\n    rx = rot(x+.28),ry = rot(timer+y);\n\n    vec3  p = ro + rd * .1;\n    float atten = .95,k = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    // lower for slow machines (128)\n    for(int i=0;i<172;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float d = ray.x*.95;\n        float m = ray.y;\n\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==4.)break;\n\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            if(m==14.) {\n                atten *=.4;\n                rd=reflect(-rd,n);\n                p+=n*.02;\n            }else{\n                atten *= .75;\n                rd=refract(rd,n,.9);\n            }\n        }  \n        if(distance(p,rd)>18.) { break; }\n    }\n    // Output to screen\n    O = vec4(sqrt(smoothstep(0.,1.,C)),1.);\n}\n\n//end",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}