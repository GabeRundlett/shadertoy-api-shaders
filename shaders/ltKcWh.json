{
    "Shader": {
        "info": {
            "date": "1536079948",
            "description": "Slightly more accurate. Thickness of film varies through cube. Did not account for interference from the reflection due to the 2 light sources, and function still not dependent on reflected ray.",
            "flags": 0,
            "hasliked": 0,
            "id": "ltKcWh",
            "likes": 15,
            "name": "More Accurate Iridescence",
            "published": 3,
            "tags": [
                "raytracing",
                "cube",
                "iridescence"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 1916
        },
        "renderpass": [
            {
                "code": "///////////////////////////////Iridescence/////////////////////////////////\n// based on the picture in                                               //\n// http://home.hiroshima-u.ac.jp/kin/publications/TVC01/examples.pdf     //\n// Copied from paniq: https://www.shadertoy.com/view/Ms33zj              //\n///////////////////////////////////////////////////////////////////////////\nvec2 mp;\n\n// ratio: 1/3 = neon, 1/4 = refracted, 1/5+ = approximate white\nvec3 physhue2rgb(float hue, float ratio) {\n    return smoothstep(\n        vec3(0.0),vec3(1.0),\n        abs(mod(hue + vec3(0.0,1.0,2.0)*ratio,1.0)*2.0-1.0));\n}\n        \nvec3 iridescence (float angle, float thickness) {\n    // typically the dot product of normal with eye ray\n    float NxV = cos(angle);\n    \n    // energy of spectral colors\n    float lum = 0.05064;\n    // basic energy of light\n    float luma = 0.01070;\n    // tint of the final color\n    //vec3 tint = vec3(0.7333,0.89804,0.94902);\n    vec3 tint = vec3(0.49639,0.78252,0.88723);\n    // interference rate at minimum angle\n    float interf0 = 2.4;\n    // phase shift rate at minimum angle\n    float phase0 = 1.0 / 2.8;\n    // interference rate at maximum angle\n    float interf1 = interf0 * 4.0 / 3.0;\n    // phase shift rate at maximum angle\n    float phase1 = phase0;\n    // fresnel (most likely completely wrong)\n    float f = (1.0 - NxV) * (1.0 - NxV);\n    float interf = mix(interf0, interf1, f);\n    float phase = mix(phase0, phase1, f);\n    float dp = (NxV - 1.0) * 0.5;\n    \n    // film hue\n    vec3 hue = \n    \t\t// fade in higher frequency at the right end\n        \tmix(\n                physhue2rgb(thickness * interf0 + dp, thickness * phase0),\n    \t\t\tphyshue2rgb(thickness * interf1 + 0.1 + dp, thickness * phase1),\n                f);\n    \n    vec3 film = hue * lum + vec3(0.49639,0.78252,0.88723) * luma;\n    \n    \n    return vec3((film * 3.0 + pow(f,12.0))) * tint;\n}\n\nvec3 srgb2lin(vec3 color) {\n    return color * (color * (\n        color * 0.305306011 + 0.682171111) + 0.012522878);\n}\n\nvec3 lin2srgb(vec3 color) {\n    vec3 S1 = sqrt(color);\n    vec3 S2 = sqrt(S1);\n    vec3 S3 = sqrt(S2);\n    return 0.585122381 * S1 + 0.783140355 * S2 - 0.368262736 * S3;\n}\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////Iridescence end///////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n//Smooth min from iq: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n//Distance function\nfloat SDMere(vec3 pos, vec3 p, float r, float t){\n    return\n    smin(\n    smin(\n    length(max(abs(p-pos)-r,0.0)),\n    distance(p,pos+.35*vec3(sin(2.5*t+.2),sin(5.*t),cos(3.*t)))-.1*r,\n    20.),\n    distance(p,pos+.35*vec3(cos(5.*t+.7),cos(2.*t),sin(3.5*t)))-.1*r,\n    20.)\n    ;\n}\n\nfloat SDscene(vec3 p, float t){\n\tfloat d = SDMere(vec3(0,0,0),p,.2,t);\n\treturn d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),t)-SDscene(vec3(p.x-ep,p.y,p.z),t),\n    SDscene(vec3(p.x,p.y+ep,p.z),t)-SDscene(vec3(p.x,p.y-ep,p.z),t),\n    SDscene(vec3(p.x,p.y,p.z+ep),t)-SDscene(vec3(p.x,p.y,p.z-ep),t)\n    ));\n}\n\n//phong shading\nvec3 phong(vec3 p, float t){\n    \n    //Lights:\n    //Lights position\n    vec3 L1 = 3.*vec3(sin(2.5*t),cos(t),sin(t));\n    float dt = t+2.;\n    vec3 L2 = 3.*vec3(sin(2.5*dt),cos(dt),sin(dt));\n    //Lights intensity\n    vec3 i1s = vec3(1.);\n    vec3 i1d = vec3(1.);\n    vec3 ia = .4*vec3(1.);\n    \n    //Material:\n    //Spectral lighting\n    vec3 Tks = vec3(.7);\n    //Diffuse lighting\n    vec3 Tkd = .5*vec3(.9);\n    vec3 Tka = 3.*vec3(.45);\n    float alp = 100.;\n    \n    vec3 L1v = normalize(L1-p);\n    vec3 L2v = normalize(L2-p);\n    vec3 N = SDn(p, t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 R2 = normalize(reflect(L2v,N));\n    vec3 J,Q,Ir;\n    float temp = dot(L1v,N);\n    float stemp = dot(R1,L1v);\n    if(temp>0.){J = Tkd*i1d*temp;}\n    if(stemp>0.){Q = Tks*i1d*pow(stemp,alp);}\n    float temp2 = dot(L2v,N);\n    float stemp2 = dot(R2,L2v);\n    if(temp2>0.){J += Tkd*i1d*temp2;}\n    if(stemp2>0.){Q += Tks*i1d*pow(stemp2,alp);}\n    \n    //Iridescence:\n    //Thickness of film (thickness = k*500nm)\n    float k = (p.x+p.y+p.z+.6)/2.;\n    Ir=lin2srgb(iridescence(asin(temp),k));\n    Ir+=lin2srgb(iridescence(asin(temp2),k));\n    vec3 ir = Tka*ia*(1.*Ir) + .1;\n    \n    vec3 I = ir + J + Q;\n    return I;\n}\n\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, float t){\n    float dist=0., d;\n    int max=200;\n    float ep = 0.0001;\n    for (int i=0; i<max; i++){\n    d = SDscene(ro + dist*rd, t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvoid mainImage(out vec4 C, in vec2 S ) {\n    \n    //Shader setup\n    vec2 R = iResolution.xy;\n    vec2 uv = (S / R-.5)*.75;\n    uv.y *= R.y/R.x;\n    vec2 T = iMouse.xy/R*5.;\n    float t = .2*iTime - 20.;\n\t\n    //Camera setup\n  \tfloat zoom = 5.;\n  \tvec3 ro = 2.*vec3(sin(T.x+t*.2)*cos(T.y+t*.3),sin(T.x+t*.2)*sin(T.y+t*.3),cos(T.x+t*.2));\n  \tvec3 lookat = vec3(0,0,0);\n  \tvec3 fw = normalize(lookat - ro);\n  \tvec3 r = normalize(cross(vec3(0,1.,0), fw));\n  \tvec3 up = normalize(cross(fw,r));\n  \tvec3 scrC = ro + (zoom)*fw + up*0.;\n  \tvec3 scrP = scrC + 4.*(uv.x*r + uv.y*up);\n  \tvec3 rd = normalize(scrP - ro);\n  \tvec4 Color;\n  \tfloat d = depth(ro,rd,t);\n  \tif (d<end){\n  \t\tvec3 p = d*rd + ro;\n  \t\tColor = vec4(phong(p,t),1.);\n  \t}\n  \telse{Color = 2.*vec4(.9,.8,.8,1.);}\n\n  \t//vigillant\n  \tColor *= sqrt(.65-1.*length(uv));\n  \t\n    C = Color;\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}