{
    "Shader": {
        "info": {
            "date": "1717996084",
            "description": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php",
            "flags": 0,
            "hasliked": 0,
            "id": "4XyGR3",
            "likes": 0,
            "name": "moving in fractal world",
            "published": 3,
            "tags": [
                "fractal",
                "cinshader"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 124
        },
        "renderpass": [
            {
                "code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\nfloat PI = acos(-1.);\n\nvec2 pmod(vec2 p,float n){\n  float np = 2.*PI/n;\n  float r = atan(p.x,p.y)-0.5*np;\n  r = mod(r,np)-0.5*np;\n  return length(p.xy)*vec2(cos(r),sin(r));\n}\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\nvec4 tetcol(vec3 p,vec3 offset,float scale,vec3 col){\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i<20;i++){\n        if(z.x+z.y<0.0)z.xy = -z.yx,col.z+=1.;\n        if(z.x+z.z<0.0)z.xz = -z.zx,col.y+=1.;\n        if(z.z+z.y<0.0)z.zy = -z.yz,col.x+=1.;       \n        z *= scale;\n        z.xyz += offset*(1.0-scale);\n    }\n    return vec4(col,(cube(z.xyz,vec3(1.5)))/z.w);\n}\n\nfloat bpm = 120.;\nvec4 dist(vec3 p,float t){\n    p.xy *= rot(PI);\n    p.xz = pmod(p.xz,24.);\n    p.x -= 5.1;\n \n    p.yz *= rot(iTime*0.5);\n\n    float s =1.;\n    p.z = abs(p.z)-3.;\n    p = abs(p)-s*8.;\n    p = abs(p)-s*4.;\n    p = abs(p)-s*2.;\n    p = abs(p)-s*1.;\n\n    vec4 sd = tetcol(p,vec3(1),1.8,vec3(0.));\n    float d= sd.w;\n    vec3 col = 1.-0.1*sd.xyz-0.3;\n    col *= exp(-2.5*d)*2.;\n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n \n   \n    float rsa =0.1+mod(iTime*0.0005,32.);\n    float rkt = iTime*5.+0.5*PI+1.05;\n    vec3 of = vec3(0,0,0);\n    vec3 ro = of+vec3(rsa*cos(rkt),-1.2,rsa*sin(rkt));\n    \n    vec3 ta = of+vec3(1.+cos(iTime),-1.3,1.+sin(iTime));\n      ro.yx *= rot(iTime*0.5);\n         ro.zx *= rot(iTime*0.5);\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+0.4*cdir);\n  \n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    float ep = 0.0001;\n    for(int i = 0;i<66;i++){\n        vec4 rsd = dist(ro+rd*t,t);\n        d = rsd.w;\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n\n    vec3 col = vec3(0.04*ac);\n \n    if(col.r<0.1&&(col.b<0.1&&col.g<0.1)) col =vec3(0.);\n\tfragColor = vec4(col, 1.0 );\n\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}