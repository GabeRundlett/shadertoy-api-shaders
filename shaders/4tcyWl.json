{
    "Shader": {
        "info": {
            "date": "1534518070",
            "description": "Second version. Phong shading is now done incorrectly intentionally because it looks nicer",
            "flags": 0,
            "hasliked": 0,
            "id": "4tcyWl",
            "likes": 2,
            "name": "Shiny Boi but shinier",
            "published": 3,
            "tags": [
                "phong",
                "inaccurate"
            ],
            "usePreview": 0,
            "username": "JuliaPoo",
            "viewed": 538
        },
        "renderpass": [
            {
                "code": "//sphere signed\nfloat SDsphere(vec3 pos, vec3 p, float r){\n    return distance(pos,p) - r;\n}\n\n//Mere signed\nfloat SDMere(vec3 pos, vec3 p, float r, vec2 T, float t){\n\treturn distance(pos,p) - r + 0.01*sin(t+(T.x*.5+T.y*.3)*.01)*(sin(100.*p.x +2.*t)+cos(70.*p.y+t)+sin(90.*p.z+t));\n}\n\n\nfloat SDscene(vec3 p, vec2 T, float t){\n    float d = SDMere(vec3(0,0,0),p,.2,T,t);\n    //d = min(d,SDsphere(L1,p,.1));\n    return d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, vec2 T, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),T,t)-SDscene(vec3(p.x-ep,p.y,p.z),T,t),\n    SDscene(vec3(p.x,p.y+ep,p.z),T,t)-SDscene(vec3(p.x,p.y-ep,p.z),T,t),\n    SDscene(vec3(p.x,p.y,p.z+ep),T,t)-SDscene(vec3(p.x,p.y,p.z-ep),T,t)\n    ));\n}\n\n//lights\nvec3 i1s = vec3(1.);\nvec3 i1d = vec3(1.);\n\n//ambient lighting\nvec3 ia = .6*vec3(1.);\n\n//test material\nvec3 Tks = vec3(.5);\nvec3 Tkd = .5*vec3(.5);\nvec3 Tka = 2.*vec3(.5);\nfloat alp = 900.;\n\n//phong shading\nvec3 phong(vec3 p, vec3 L1, vec2 T, float t){\n    vec3 L1v = normalize(L1-p);\n    vec3 N = SDn(p,T,t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 J,Q;\n    float temp = dot(L1v,N);\n    float temp2 = dot(R1,L1v);\n    J = Tkd*i1d*temp;\n    Q = Tks*i1d*pow(abs(dot(R1,L1v)),alp);\n    vec3 I = Tka*ia + J + Q;\n    return I;\n}\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, vec2 T, float t){\n    float dist=0., d;\n    int max=1000;\n    float ep = 0.001;\n    for (int i=0; i<max; i++){\n        d = SDscene(ro + dist*rd, T,t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvec2 T = vec2(12.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    T = 25.*(iMouse.xy)/iResolution.xy;\n    float t = .5*iTime;\n\n\n    //lights (t dependent position) \n\tvec3 L1 = vec3(3.*sin(2.5*t),3.*cos(t),3.*sin(t));\n\n    //initialise screen\n    vec2 uv = (fragCoord/iResolution.xy-.5)*.6 + (T-12.5)*0.002;\n    uv.x *= iResolution.x/iResolution.y;\n   \t\n    //Camera setup\n    float zoom = 0.3;\n    float k = .2;\n    vec3 ro = .35*vec3(cos(k*T.x)*sin(k*T.y),sin(k*T.x)*sin(k*T.y),cos(k*T.y));\n    vec3 lookat = vec3(0,0,0);\n    vec3 fw = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0,1.,0), fw));\n    vec3 up = normalize(cross(fw,r));\n    vec3 scrC = ro + zoom*fw;\n    vec3 scrP = scrC + uv.x*r + uv.y*up;\n    vec3 rd = scrP - ro;\n    vec4 Color;\n    float d = depth(ro,rd,T,t);\n    if (d<end){\n    \tvec3 p = d*rd + ro;\n    \tColor = vec4((5.*vec3(-p.z,p.y,-p.x)+1.*vec3(1.5,1,1.5))*phong(p,L1,T,t),1.);\n    }\n    else{Color = 2.*vec4(.9,.8,.8,1.);}\n\n    //vigillant\n    Color *= sqrt(.65-0.7*length(uv));\n    fragColor = Color;\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}