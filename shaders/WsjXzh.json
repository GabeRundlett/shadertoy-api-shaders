{
    "Shader": {
        "info": {
            "date": "1553017285",
            "description": "experiments with hashed location coloring",
            "flags": 32,
            "hasliked": 0,
            "id": "WsjXzh",
            "likes": 3,
            "name": "colorful apartments",
            "published": 3,
            "tags": [
                "raymarch",
                "hashing"
            ],
            "usePreview": 0,
            "username": "benhardy",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "// This buffer does some bokeh based on the alpha channel of buffer A which is the distance of the surface from the pixel.\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage9( out vec4 fragColor, in vec2 fragCoord ) {\n    \n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tfragColor=vec4( texture(iChannel0, uv).xyz,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 base = vec3(0.);\n    \n    // Gaussian blur by mrharicot https://www.shadertoy.com/view/XdfGDH\n    \n    //declare stuff\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\tfloat depth = texture(iChannel0, uv).a;\n    \n    //create the 1-D kernel\n    float sigma = mix(0.05, 4., max(0., -1. + depth*depth*0.1));\n    float Z = .0;\n    for (int j = 0; j <= kSize; ++j)\n    {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n    {\n        Z += kernel[j];\n    }\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            base += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n        }\n    }\n   \tvec4 b = vec4(base/(Z*Z), 1.0);\n\n    fragColor = b;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define MAX_FLOAT   3.402823466e+38\n#define MIN_FLOAT   1.175494351e-38\n#define MAX_DOUBLE  1.7976931348623158e+308\n#define MIN_DOUBLE  2.2250738585072014e-308\n\n#define PI          3.141592653589793\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER       1000000.0\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\n/**\n * centred modulo\n */\nfloat cmod(float x, float r) {\n    return mod(x + 0.5 *r, r) - 0.5 *r;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n/**\n * Ray marching parameters for this scene\n */\n#define MAX_STEPS  10000\n#define MAX_DIST   200.0\n#define EPSILON    0.001\n#define STEP_RATIO 0.3\n\n/**\n * object ids\n */\n#define ID_FLOOR 1\n#define ID_THING 2\n#define ID_FRONTS 3\n#define ID_BALLS  4\n#define ID_INNARDS 5\n\n#define COS_30    0.8660254037844387\n#define HEX_EVEN  1.7320508075688772\n\n// dimensions in metres\n#define UNIT_HEIGHT   4.000\n#define UNIT_WIDTH    6.000\n#define UNIT_LENGTH  12.000\n#define WALL_THICK    0.600\n#define FLOOR_THICK   0.600\n#define RAIL_HEIGHT   0.900\n#define BALL_RADIUS   3.000\n\n#define FLOORS        4.000\n\n#define BALL_SPEED    5.000\n\nvec3 box_exterior = vec3( UNIT_WIDTH, UNIT_HEIGHT, UNIT_LENGTH) * 0.5;\nvec3 walling_diff = vec3(WALL_THICK, FLOOR_THICK, -WALL_THICK) * 0.5;\n\nfloat box(vec3 where, vec3 size, float r) {\n    vec3 rel = abs(where) - size;\n    vec3 pos = max(rel,0.0);\n  \treturn length(pos) -r +min(0.0, max(rel.x, max(rel.y, rel.z)));   \n}\nfloat box_2d(vec2 where, vec2 size, float r) {\n    vec2 rel = abs(where) - size;\n    vec2 pos = max(rel,0.0);\n  \treturn length(pos) -r +min(0.0, max(rel.x, rel.y));   \n}\nfloat facing_cutout(vec3 where) {\n    float outside = box_2d(where.xy, box_exterior.xy - 0.65, 0.5);\n    float inside = box_2d(where.xy, box_exterior.xy - 0.7, 0.2);\n    float frame = max(outside, -inside);\n    float cutter = abs(where.z) -0.1;\n    float curve = 0.10;\n    vec2 offset = vec2(cutter, frame);\n    vec2 join = max(offset, 0.0);\n    float edging = length(join) - curve;\n    return edging;\n}\n    \nfloat distance_to_thingy(vec3 where) {\n    vec3 orig_where = where;\n\n    where.y = cmod(where.y, UNIT_HEIGHT);\n    where.x = cmod(where.x, UNIT_WIDTH);\n    float exter = box(where, box_exterior, 0.0);\n    float inter = box(where, box_exterior - walling_diff, 0.0);\n    \n    float boxes = max(exter, -inter);\n\tfloat cap = orig_where.y - UNIT_HEIGHT * (FLOORS + 0.5);\n    \n    return max(boxes, cap);\n    // rail\n    where.y += (-FLOOR_THICK + UNIT_HEIGHT) * 0.5 - RAIL_HEIGHT;\n    \n    float rail = length((where * vec3(1, 5, 1)).yz) - 0.05;\n    return min(rail* 0.2, boxes);\n}\n        \nfloat distance_to_fronts(vec3 where) {\n    vec3 orig_where = where;\n\n    where.y = cmod(where.y, UNIT_HEIGHT);\n    where.x = cmod(where.x, UNIT_WIDTH);\n    where.z = where.z + UNIT_LENGTH * 0.5;\n\n\tfloat cap = orig_where.y - UNIT_HEIGHT * (FLOORS + 0.5);\n    float boxes = facing_cutout(where);\n    return max(boxes, cap);\n}\n\nvec3 move_ball(vec3 where) {\n    where.y -= UNIT_HEIGHT *(FLOORS + 0.5) + BALL_RADIUS;\n    where.x = cmod(where.x - BALL_SPEED * iTime * BALL_RADIUS, 2.0 *PI);\n    where.z -= UNIT_WIDTH * 0.5;\n    \n    float angle = mod(iTime * BALL_SPEED, 2.0 * PI);\n    float cos_ang = cos(angle);\n    float sin_ang = sin(angle);\n    return vec3(\n        cos_ang * where.x - sin_ang * where.y,\n    \tsin_ang * where.x + cos_ang * where.y,\n    \twhere.z\n    ); \n}\nfloat distance_to_balls(vec3 where) {\n    vec3 where_rot = move_ball(where);\n    float ball = length(where_rot) - BALL_RADIUS;\n\twhere_rot.y = abs(where_rot.y);\n    float cut = where_rot.y - 0.15;\n    return max(ball, -cut);\n}\n\nfloat distance_to_innards(vec3 where) {\n    where = move_ball(where);\n    return length(where) - (BALL_RADIUS - 0.01);\n}\n       \n\n/**\n * find the closest object in the scene and return its distance and id\n */\nvec2 measure(vec3 where) {\n    vec2 closest = vec2(100000.0, 0.0);\n\n    float dist_floor = where.y;\n    if (dist_floor <= closest.x) {\n        closest = vec2(dist_floor, ID_FLOOR);\n    }\n    //where.xz = vec2(max(where.x,where.z), min(where.x,where.z));\n    float dist_thingy = distance_to_thingy(where);\n    if (dist_thingy <= closest.x) {\n        closest = vec2(dist_thingy, ID_THING);\n    }    \n    float dist_fronts = distance_to_fronts(where);\n    if (dist_fronts <= closest.x) {\n        closest = vec2(dist_fronts, ID_FRONTS);\n    }\n    float dist_balls = distance_to_balls(where);\n    if (dist_balls <= closest.x) {\n        closest = vec2(dist_balls, ID_BALLS);\n    }\n    float dist_innards = distance_to_innards(where);\n    if (dist_innards <= closest.x) {\n        closest = vec2(dist_innards, ID_INNARDS);\n    }    return closest;\n}\n\n/**\n * Figure out coloring for where we hit\n */\nconst vec4 floor_color = vec4(0.08,0.08,0.02,0.5);\nconst vec4 thing_color = vec4(0.4,0.4,0.35,0.5);\nconst vec4 fronts_color = vec4(0.9, 0.1, 0.1, 0.5);\nconst vec4 balls_color = vec4(0.2, 0.2, 0.22, 0.5);\nconst vec4 innards_color =  vec4(1.0, 1.0, 0.0, 0.9);\nconst vec4 sky = vec4(0,0,0.4,1.0);\n\nvec4 paint(vec2 hit, vec3 where) {\n\n    int who = int(hit.y);\n    float ambient = 0.0;\n    if (who == ID_FLOOR) {\n        return floor_color;\n    }\n    if (who == ID_THING) {\n        return thing_color;\n    }\n    if (who == ID_BALLS) {\n        return balls_color;\n    }\n    if (who == ID_INNARDS) {\n        return innards_color;\n    }\n    if (who == ID_FRONTS) {\n        int x = int(1000.5 + where.x / UNIT_WIDTH);\n        int y = int(1000.5 + where.y / UNIT_HEIGHT);\n        int col = (x * 1174 + y * 2887);\n        int red =   (col >> 4) & 0x01;\n        int green = (col >> 2) & 0x03; \n        int blue =  (col     ) & 0x03;\n        return vec4(\n            0.25 * float(red),\n            0.25 * float(green),\n            0.25 * float(blue),\n            0.0\n        );\n    }\n    return sky;\n}\n\n// end of model stuff\n\nvec3 calc_surface_normal(vec3 hit);\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(\n        sin(iTime*0.31) * 40.0 - 10.0,\n        sin(iTime*0.22) * 10.0 + 40.0,\n        cos(iTime*0.13) * 2.0 - 25.0\n    );\n    vec3 look_at = vec3(\n        sin(iTime*0.37) * 0.0 +  1.0,\n        sin(iTime*0.28) * 0.0 + 20.0,\n        cos(iTime*0.19) * 0.0 +  0.0\n    );\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    for(int steps = 0; steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        fragColor = sky;\n        return;\n    }\n\tvec3 hit = where;\n    vec4 the_paint = paint(current, where);\n    vec3 to_light = normalize(vec3(-5,15,-10));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = total_dist / MAX_DIST;\n    float ambient = the_paint.w;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = (1.0-light_fade) *(the_paint.xyz * lighting)\n        + fog_color * (light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring,total_dist/40.0);\n}\n\n#define NORMAL_DELTA 0.001\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}