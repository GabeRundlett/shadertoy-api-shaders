{
    "Shader": {
        "info": {
            "date": "1727243572",
            "description": "i refactored jiang's loopless fractal https://www.shadertoy.com/view/MXSyzz\nfor some reason this algorithm only maps the uv correctly on degree = 2.0 ? or is it also wrong just very slightly?",
            "flags": 0,
            "hasliked": 0,
            "id": "M3jcD1",
            "likes": 16,
            "name": "infinite zoom logexp",
            "published": 3,
            "tags": [
                "zoom",
                "exp",
                "infinite",
                "log"
            ],
            "usePreview": 0,
            "username": "shadertoyjiang",
            "viewed": 100
        },
        "renderpass": [
            {
                "code": "// 0 3d mandel\n// 1 red disk\n// 2 green disk\n// 3 blue disk\n// 4 2d mandel\n#define pictureINDEX 4\n\n\n\nfloat b,f,g,h,t,d = 1e-3;\nfloat m(vec3 z)\n{\n        f=2.;\n        for(int i=0; i<8 && (h=length(z))<4.; i++)\n                g = pow(h, 8.),\n                f = f*g/h*8.+2.,\n                z = vec3(cos(b=8. *acos(z.z/h))*cos(8.*atan(z.y, z.x)+vec2(0,11)), sin(b))*g,\n                z.x += .9;\n        return log(h)*h/f;\n}\n\nvec4 drawMDL(vec2 u)\n{\n        vec3 e,o,\n             r = vec3(1, u+u-1.);\n        e.y = d;\n        for(o.x = -1.5; d >= e.y && t < 3.;)t += d = m( o += r*d );\n        vec4 c= vec4( 2e3 * dot(vec3(m(o+e.yxx), m(o+e), m(o+e.xxy))-d, o)  );\n        return clamp(c,0.,1.);\n}\n\n\n#if pictureINDEX==0\nvec2 fragmentUV(vec2 p , float zoom, float scroll)\n{\n        // 增长指数\n        float degree = 3.3;  \n        \n        // 常数空间中的平移\n        p -= scroll;\n        \n        // 在常规空间的缩放\n        //p /= zoom;\n        \n        // 在指数空间的缩放\n        // 使用 fract() 是因为当 zoom = 0 时，为原图像。 \n        // 当它慢慢变到 1 时，它的大小为原来的 degree 倍。此时它与原图完全重合（虽然放大了）。\n        // 所以只需要要不断重复 0到1 之间的 zoom 就会有连续不断的错觉。\n        //p /= pow(degree, zoom);\n        p /= pow(degree, fract(zoom));\n\n        //\n        p.x = abs(p.x);\n        \n        // 在对数空间划分空间，分割线是(leftDividingLine 和 leftDividingLine)对应(index 和 index + 1.)\n        float index = floor(  log(p.x)/log(degree) );        \n        \n        // 第一次归一化\n        float leftDividingLine = 1.;  // <==>leftDividingLine = floor(  log(p.x)/log(degree) ) / zoom2\n        float rightDividingLine = degree;\n        float zoom2 = pow(degree, index);\n        p /= zoom2;\n        // 此时，左边界是 1., 右边界是 degree\n        \n        float zoom3 = degree - 1.;\n        // 设置 x 方向的原点在 1. 的位置， 此时左边界是 0, 右边界是 degree - 1.\n        p.x -= 1.;\n        // 等比例归一化\n        p /= zoom3;\n        // 设置 y 方向的原点， 这里暂时假设是乱凑的 (zoom + scroll * index)\n        p.y -= zoom + scroll;\n        // 划分 y 方向空间\n        p.y = fract(p.y);\n        return p;        \n}\n\n\nvoid mainImage( out vec4 color, in vec2 cdnt )\n{\n        vec2 uv = (cdnt * 2. - iResolution.xy) / iResolution.y;\n        vec2 f = fragmentUV(uv, iTime, cos(iTime));\n        // 现在 f 的坐标范围都是 0 到 1\n        // 画圆\n        //if( length(f-.5)<.5) color = vec4(1,0,0,1);\n        //else                 color = vec4(0);\n        color = drawMDL(f);\n}\n\n#elif pictureINDEX ==1\n\nvec4 drawManyCircles(vec2 p , float zoom, float scroll)\n{\n        float degree = 1.6;\n        p -= scroll;\n        // 在常规空间的缩放\n        //p /= zoom;\n        // 在指数空间的缩放\n        // 使用 fract() 是因为当 zoom = 0 时，为原图像。 \n        // 当它慢慢变到 1 时，它的大小为原来的 degree 倍。此时它与原图完全重合（虽然放大了）。\n        // 所以只需要要不断重复 0到1 之间的 zoom 就会有连续不断的错觉。\n        ////// p /= pow(degree, zoom);\n        // fract() 在防止大数的同时，图案连续（不是尺寸一样）\n        p /= pow(degree, fract(zoom));  \n        p.x = abs(p.x);\n        float index, leftDividingLine,rightDividingLine;\n        \n        // 在对数空间划分空间，分割线是(leftDividingLine 和 leftDividingLine)对应(index 和 index + 1.)\n        index = floor(  log(p.x)/log(degree) );\n        leftDividingLine = pow(degree, index);\n        rightDividingLine = leftDividingLine * degree ; // == pow(degree, index+1.);\n        \n        //\n        float diameter = (rightDividingLine - leftDividingLine);\n        float radius = diameter / 2.;\n        vec2 cent;\n        cent.x = (leftDividingLine + rightDividingLine) / 2.;\n        cent.y = round(p.y / diameter) * diameter;\n        \n        //\n        float dzoom = length(p - cent) - radius;\n        vec4 clr=vec4(1);\n        if(dzoom<0.)clr=vec4(1,0,0,1);\n        return clr;\n        //return dzoom * zoom;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 cdnt )\n{\n        vec2 uv = (cdnt * 2. - iResolution.xy) / iResolution.y;\n        color = drawManyCircles(uv, iTime, cos(iTime));\n}\n\n#elif pictureINDEX==2\n\nvec4 drawManyCircles(vec2 p , float zoom, float scroll)\n{\n        float degree = 1.7;\n        \n        // 平移与缩放，在不同的空间都可以\n        p -= scroll;        \n        //p /= zoom;        \n        //p /= pow(degree, zoom);        \n        p /= pow(degree, fract(zoom));\n        p.x = abs(p.x);\n        \n        float index, leftDividingLine,rightDividingLine;\n        // 分割\n        index = floor(  log(p.x)/log(degree) );        \n        \n        // 以分割点为基准归一化\n        float zoom2 = pow(degree, index);\n        leftDividingLine = 1.;  // <==>leftDividingLine = leftDividingLine / zoom2\n        rightDividingLine = degree;\n        p /= zoom2;\n        \n        // 求中心\n        float diameter = rightDividingLine - leftDividingLine;// <==>(rightDividingLine - leftDividingLine);\n        float radius = diameter / 2.;\n        vec2 cent;\n        cent.x = (leftDividingLine + rightDividingLine) / 2.;\n        cent.y = round(p.y / diameter) * diameter;\n        \n        // 画圆\n        float dzoom = length(p - cent) - radius;\n        //return dzoom * zoom * zoom2;\n        vec4 clr=vec4(.5);\n        if(dzoom<0.)clr=vec4(0,1,0,1);\n        return clr;\n        \n}\n\nvoid mainImage( out vec4 color, in vec2 cdnt )\n{\n        vec2 uv = (cdnt * 2. - iResolution.xy) / iResolution.y;\n        color = drawManyCircles(uv, iTime, cos(iTime));\n}\n\n#elif pictureINDEX==3\n\nvec4 drawManyCircles(vec2 p , float zoom, float scroll)\n{\n        float degree = 2.3;\n        p -= scroll;\n        // 在常规空间的缩放\n        //p /= zoom;\n        // 在指数空间的缩放\n        //p /= pow(degree, zoom);\n        p /= pow(degree, fract(zoom));\n        p.x = abs(p.x);\n        float index, leftDividingLine,rightDividingLine;\n        // 分割\n        index = floor(  log(p.x)/log(degree) );        \n        // 第一次归一化：以 index 对应的真实 x 值为基准\n        float zoom2 = pow(degree, index);\n        leftDividingLine = 1.;     // 归一化后的左边界位置\n        leftDividingLine = degree; // 归一化后的右边界位置\n        p /= zoom2;\n        \n        // 处理一下，使左边界为 0 右边界为 1\n        float zoom3 = degree-1.;\n        p.x -= 1.;\n        p /= zoom3;\n        \n        vec2 cent;\n        cent.x = .5;\n        // y 方向分割\n        cent.y = round(p.y);\n        \n        float dzoom = length(p - cent) - .5;\n        vec4 clr=vec4(1);\n        if(dzoom<0.)clr=vec4(0,0,1,1);\n        return clr;        \n        //return dzoom * zoom * zoom2 * zoom3;\n}\n\nvoid mainImage( out vec4 color, in vec2 cdnt )\n{\n        vec2 uv = (cdnt * 2. - iResolution.xy) / iResolution.y;\n        color = drawManyCircles(uv, iTime, cos(iTime));\n}\n\n#elif pictureINDEX == 4\nvec4 drawM2(vec2 u){\n        vec4 z=vec4(0),w;\n        u.x +=.25;\n        u = (u-.5)*.7+.5;\n        for(int i;i++<24;z=z.x*z+z.y*vec4(-z.y,z)-3.*(u.xyyy-.5))w=abs(z);\n        w=clamp(w,0.,1.);\n        return w;\n}\n\nvec4 fragmentUV(vec2 p , float zoom, float scroll)\n{\n        float degree = 1.8;  \n        p -= scroll;\n        p /= 1.2+sin(zoom);        \n        p /= pow(degree, fract(zoom*1.5));\n        float n=sign(p.x);\n        p.x = abs(p.x);\n        float index = floor(  log(p.x)/log(degree) );        \n        float leftDividingLine = 1.;   \n        float rightDividingLine = degree;\n        p /= pow(degree, index);\n        p.x -= 1.;\n        p /= ( degree - 1.);       \n               \n        p.y -= zoom + scroll;\n        \n        int j=int(floor(p.y));\n        p.y = fract(p.y);\n        vec4 c;\n        if((int(index*0.)+j)%8==0){\n              c = drawMDL(p);\n              \n        }else{\n              n=-n,\n              c = drawM2(p);\n        }\n        c = .5+n*(c-.5);\n        return c;\n}\n\n\nvoid mainImage( out vec4 color, in vec2 cdnt )\n{\n        vec2 uv = (cdnt * 2. - iResolution.xy) / iResolution.y;\n        color = fragmentUV(uv, iTime, cos(iTime));\n}\n\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}