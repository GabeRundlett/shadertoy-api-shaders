{
    "Shader": {
        "info": {
            "date": "1630728701",
            "description": "Some experimenting based the bigwings refraction tutorial",
            "flags": 0,
            "hasliked": 0,
            "id": "7dcGWX",
            "likes": 41,
            "name": "DNA Glass Refraction 03-sep-2021",
            "published": 3,
            "tags": [
                "refraction",
                "glass",
                "refract",
                "dna",
                "bigwings"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 4713
        },
        "renderpass": [
            {
                "code": "\n#define eps 0.001\n#define S smoothstep\n#define T iTime\n#define TX texture\n#define C clamp\n\n#define MAX_STEPS 100\n#define MAX_DIST 145.\n#define pi 3.14159265\n#define air 1.\n#define glass 1.45\n#define zoom 1.\n\n#define AA 1\n\n//for AA set AA_ON to 1 and then set aa to more than 1\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n    }   \nfloat sdBox(vec3 p, vec3 d){\n    p = abs(p)-d;\n    return length(max(p,0.)) + \n    min(max(p.x,max(p.y,p.z)), 0.);\n    \n}\nfloat bar(vec3 p, float r, float le){\n     return max(length(p.yz) - r, abs(p.x)-le);\n     \n}\nfloat gem(vec3 p){\n\n    float c = cos(pi/5.), s = sqrt(0.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    float d = p.z-1.;\n    return d;   \n}\n\nfloat dna(vec3 p){\np.z += iTime*8.;\n    float ySpacing = 2.4;\n    float xSpacing = 4.;\n    float xySpacing = 40.;\n    vec3 oldP = p;\n    \n    p.xz = mod(p.xz, xySpacing) -xySpacing/2.;\n    p.xz *= rot(floor(oldP.y/ySpacing)/4.);\n    \n    p.xz *= rot(iTime*.1);\n    p.y = mod(p.y, ySpacing)-1.2;\n    \n    \n    \n    float bar = bar(p, 0.5, xSpacing);\n    p.x = abs(p.x)-xSpacing;\n    float gems = gem(p);\n    \n    float dna = min(bar, gems);\n    \n    return dna;\n}\nfloat map(vec3 p){\n    float dna = dna(p);\n    vec3 gems_offset = vec3(12.+sin(iTime/4.),\n                            5.+sin(iTime/6.+9.),\n                            16.+sin(iTime/3.+34.)\n                            );\n                            \n    vec3 gems_mod = vec3(50.,77.,38.);    \n    float more_gems = gem((mod(p + gems_offset, \n                          gems_mod) - gems_mod/2.))/4.;\n                                            \n    float scene = min(more_gems, dna);\n    \n    more_gems = gem(mod((p + gems_offset+vec3(2.))/8., \n                          gems_mod) - gems_mod/2.);\n   \n    //scene = min(scene, more_gems);\n    return scene;\n}\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t, d= 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        d = abs(map(ro + rd*t));\n        if(d < 0.001 || t > MAX_DIST) break;\n        t += d*0.85;\n    }\n    \n    return t;\n}\nvec3 normal(vec3 p){\n    \n    float d = map(p);\n    vec2 e = vec2(eps,0.);\n    \n    vec3 n = d - vec3(\n            map(p-e.xyy),\n            map(p-e.yxy),\n            map(p-e.yyx));\n            \n    return normalize(n);\n}\nvec3 camRay(vec2 uv, vec3 o, vec3 target, float zm){\n    \n    vec3 fwd = normalize(target - o);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(uu, fwd));\n    //order matters\n    vec3 up = cross(fwd,right);\n    vec3 rd = right*uv.x + up*uv.y + fwd*zm;\n    return normalize(rd);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0., 1., -1.);\n    ro.yz *= rot(-m.y*pi+1.);\n    ro.xz *= rot(-m.x*pi*2.);\n    \n    vec3 rd = camRay(uv, ro, vec3(0., 1.,0.), zoom);\n    vec3 col = TX(iChannel0, rd).rgb;\n    col += hexTexture(uv+vec2(iTime/50.,0.), TX(iChannel1, vec2(3.)).rgb, col, vec2(1.))*0.13;\n   //ro.z +=iTime*8.;\n    float aa_step = 1./float(AA);\n    \n    for(float i = 0.; i < 1.; i += aa_step){\n    for(float j = 0.; j < 1.; j += aa_step){\n    \n    #if AA > 1\n    vec2 o = vec2(float(i),float(j));\n    uv = ((fragCoord+o)-iResolution.xy/2.)/iResolution.y;\n    //uv = ((fragCoord+o)-iResolution.xy*0.5)/iResolution.y;\n    #endif\n    //rd = camRay(uv+vec2(i,j)*2./iResolution.xy, ro, vec3(0., 1.,0.), zoom);\n    rd = camRay(uv, ro, vec3(0., 1.,0.), zoom);\n    float t = trace(ro, rd);\n    \n    \n    // Time varying pixel color\n    \n    \n    vec3 tex;\n    if(t < MAX_DIST){\n        \n        //tpnre\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p);\n        vec3 rIn = refract(rd,n,1./glass);\n        vec3 enter = p - n*0.01;\n        \n        vec3 obligatory_reflection = reflect(rd, n);\n        vec3 obligatory_outside = TX(iChannel0, obligatory_reflection).rgb;\n        \n        //tpnre\n        t = trace(enter, rIn);\n        p = enter + rIn*t;\n        vec3 nExit = -normal(p);\n        \n        \n        vec3 rOut = refract(rIn, nExit, glass - 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.r = TX(iChannel0,rOut).r;\n        \n        rOut = refract(rIn, nExit, glass);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.g = TX(iChannel0,rOut).g;\n        \n        rOut = refract(rIn, nExit, glass + 0.01);\n        if(dot(rOut,rOut) == 0.) rOut = reflect(rIn,nExit);\n        tex.b = TX(iChannel0,rOut).b;\n        \n        //vec3 exit = p + rOut*t;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        //col = n*0.5+0.5;\n        \n        col += mix(tex, obligatory_outside, fresnel);\n\n    }\n    \n    //end of aa\n    }}\n    #if AA > 1\n    col/=float(AA*AA);\n    #endif\n    col = pow(col, vec3(.545));\t\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//from david hoskins hash without sine\n// 3 in 1 out\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvec3 hexTexture(vec2 uv, vec3 color, vec3 tex, vec2 firstXY)\n{\n\tvec2 u = 6.*uv;;\n    vec2 s = vec2(1.,1.732);\n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB*1000.;\n    float id = rnd(idSeed+firstXY.x*firstXY.y/800.);\n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float radius = pow(id*0.2,4.);\n    float f = smoothstep(radius + 0., radius + 0.05, 1.0-q);\n    //+firstXY.y/16.\n    vec3 col = mix(tex,color-fract(8.*id)*0.5,f*step(0.2,id));\n    return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}