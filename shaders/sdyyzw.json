{
    "Shader": {
        "info": {
            "date": "1654675302",
            "description": "Fake lighting for some cheese;",
            "flags": 32,
            "hasliked": 0,
            "id": "sdyyzw",
            "likes": 23,
            "name": "Cheddar",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 1,
            "username": "El_Sargo",
            "viewed": 441
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    float totalFrames = col.w;\n    col *= smoothstep(.85,0.3,length(uv-0.5));\n\n         col = pow(col/totalFrames, vec4(.9, 1., .95, 1.));\n         col *= 0.93;\n    fragColor = sqrt(col);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float Earth = 63.71;\nconst float AtRad = 64.01;\nconst float directScatterCoef = .001;\nconst float inDirectScatterCoef = .3;\nconst float sunCoef = .1;\nconst vec3 rgbScatter = vec3(1,2,4);\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec3 getSky(vec3 rd, vec3 sun){\n//Distances, proportaional to the real world\n    const vec3 pos = vec3(0.,Earth,0.);\n    float atDist = sphIntersect(pos, rd, vec3(0), AtRad).y;\n    float snDist = sphIntersect(pos, sun,vec3(0), AtRad).y-1.1;\n    \n    float rds = dot(sun, rd);\n\n    vec3 light = vec3(smoothstep(0.995, .996, rds))*2.;\n         light += (1.-exp(-rgbScatter*atDist*inDirectScatterCoef*(atDist*5.*.5+.5)));\n         light *= exp(-rgbScatter*(atDist*directScatterCoef+snDist*sunCoef));\n         \n     return pow(light, vec3(2.));\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdTri( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "const int raymarchsteps = 150;\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\nfloat sdHoles(vec3 p){\n    const float c = .17;\n    p += vec3(.4163,1.62,1.46);\n    p = mod(p+c, 2.*c)-c;\n    return sdSphere(p,.14);\n}\nfloat sdCheeze(vec3 p, out float h){\n    p.z = -p.z;\n    p -= vec3(-0.4,-0.65,0.);\n    p.xz *= rot(0.65);\n    float base;\n    {\n        float d = sdTri(p.xz, vec2(.5, 1.3));\n        vec2 w = vec2( d, abs(p.y) - .35 );\n        base =  min(max(w.x,w.y),0.0) + length(max(w,0.0))-0.02;\n    }\n    h = sdHoles(p);\n    float d = ssub(h, base,0.02);\n    return d;\n}\n\nfloat sdOlive(vec3 p){\n    p -= vec3(.4,-0.82,0.);\n    p.x = abs(p.x)-0.12;\n    float l = length(p.xy);\n    return sdEllipse(vec2(l,p.z), vec2(.13,0.2));\n}\n\nfloat map(vec3 p){\n    float _;\n    float d = sdCheeze(p,_);\n    d = smin(d, p.y+1.,0.02);\n    d = min(d,sdOlive(p));\n    return d;\n}\n\nfloat intersection(vec3 ro, vec3 rd){\n    float T=0.;\n    for(int i=0;i<raymarchsteps;i++){\n        float d = map(ro+rd*T);\n        T += d;\n        if (abs(d) < 0.001*T  || T > 20.){\n            break;\n        }\n    }\n    return T;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p , in float T){\n    float h = 0.01*T;\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h);\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=0; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 triTex(vec3 p, vec3 nor, sampler2D tex){\n    vec3 x = texture(tex, p.yz).xyz;\n    vec3 y = texture(tex, p.xz).xyz;\n    vec3 z = texture(tex, p.xy).xyz;\n\n    return x*nor.x + y*nor.y + z*nor.z;\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float T = intersection(ro, rd);\n    vec3 p = ro+rd*T;\n    float dist = map(p);\n    float holes;\n    vec3 col = vec3(0.);\n    float chez = sdCheeze(p, holes);\n    float olive = sdOlive(p);\n    vec3 sun = normalize(vec3(5,5.,-1.4));\n    vec3 scl = vec3(0.925,0.906,0.792);\n    vec3 ccl = vec3(0.949,0.831,0.251);\n    vec3 gcl = vec3(0.867,0.851,0.851);\n    vec3 ocl = vec3(0.463,0.867,0.192);\n    bool isCheeze = chez < p.y+1.005;\n    float fisCheeze = float (isCheeze);\n    vec3 bcl = isCheeze ? ccl : gcl;\n    bool isOlive = false;\n    if (olive < chez && p.y > -.9){\n        bcl = ocl;\n        isOlive = true;\n    }\n    if (dist < 1.2){\n    \n        vec3 nor = calcNormal(p, T);\n        float occ = calcAO(p, nor);\n        float sha = softshadow(p, sun, 0.1, 5., 10.);\n        float nds = sqrt(max(0., dot(nor, sun)));\n        vec3 hvc = normalize(sun - rd);\n        vec3 ref = reflect(rd, nor);\n        float frez = .5+.5*dot(rd, ref);\n        float inchez = clamp(1.-15.*chez, 0., 1.);\n        \n        vec3 tex = triTex(p, nor, iChannel1);\n        \n        bcl += isCheeze ? tex*0.3 : tex*-0.1;\n        col += 6.*bcl*scl*nds*sha*scl;\n        col += 2.*max(0.00001, pow(dot(nor, hvc),3.))*sha;\n        col += 3.*max(0.5,dot(nor, -sun))*gcl*bcl*scl*occ;\n        col += 3.*clamp(getSky(ref,sun),0.,1.)*occ*0.75*(.5+.5*dot(nor,vec3(0,1,0)))*frez;\n        col += frez*( !isOlive ? vec3(0.902,0.176,0.176): vec3(0.000,0.000,0.000) )*sha*3.;\n        col += 3.5*vec3(0.878,0.278,0.024)*(max(0.5,1.-20.*holes))*inchez;\n        col += scl*ocl*smoothstep(.5, 0., olive);\n    } else {\n        col = getSky(rd, sun)*5.;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 prev = texture(iChannel0, uv);\n    float frame = float(iFrame);\n    float dx = mod(frame, 3.)/3.-0.25;\n    float dy = mod(frame, 9.)/9.-0.25;\n    vec2 off = vec2(dx,dy)/iResolution.xy;\n    vec2 nuv = (uv-0.5+off)*vec2(1.,iResolution.y/iResolution.x);\n    \n    vec3 ro = vec3(0., 0.5, 1.75);\n    vec3 rd = normalize(vec3(nuv, -0.9));\n         rd.yz *= rot(-0.45);\n    vec3 col = render(ro, rd);\n    \n    col /= 8.;\n    col = smoothstep(0., 1., col);\n    fragColor = prev+vec4(col, 1.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}