{
    "Shader": {
        "info": {
            "date": "1598614168",
            "description": "So yeah... I made a shader on new year's eve 2020 and I think it deserved a small revision.",
            "flags": 0,
            "hasliked": 0,
            "id": "3l2Bzw",
            "likes": 19,
            "name": "2020 - ðŸ¤® Revision",
            "published": 3,
            "tags": [
                "fire",
                "corona",
                "hell",
                "2020"
            ],
            "usePreview": 0,
            "username": "PixelPhil",
            "viewed": 604
        },
        "renderpass": [
            {
                "code": "//\n// 2020 - ðŸ¤® Revision; by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// Note: This shader is a fairly standard 2D composition with two layers. The digits\n// are produced with bespoke signed distance functions (the fact that 2020 has only two diferent\n// digits made the process easier).\n//\n\n\n#define S(a,b,c) smoothstep(a,b,c)\n\n// outputs a colored shape with a black border from distance field (RGBA premultiplied)\nvec4 border(vec3 color, float dist)\n{\n    vec4 res;\n    \n    float aa = 30. / iResolution.x;\n    \n    res.a = S(0.25 + aa, 0.25, dist); \n    res.rgb = color *  S(0.2, 0.2 - aa, dist); \n    \n    return res;\n}\n\n// Blend a premultiplied rbga color onto rgb\nvec3 premulBlend(vec4 src, vec3 dst)\n{\n    return dst * (1.0 - src.a) + src.rgb;\n}\n\n// Blend a premultiplied rbga color onto rgba (accurate alpha handling)\nvec4 premulBlend(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = dst.rgb * (1.0 - src.a) + src.rgb;\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a); \n    \n    return res;\n}\n\n\n// Distance field to the digit 0\nfloat zeroDst(vec2 uv)\n{\n    float dist;\n    \n    uv.y -= 0.5;\n    \n    if (uv.y > 0.0) // upper part\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    else if (uv.y > -1.1) // middle part\n    {\n        dist = abs(uv.x);\n    }\n    else  // lower part\n    {\n        uv.y += 1.1;\n        uv.y = pow(-uv.y, 1.8);\n    \tdist = length(uv);\n    }\n    \n    return (abs(dist - 0.725) - 0.275);\n}\n\n// a box distance function\nfloat box(vec2 p, vec2 b )\n{\n\tvec2 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n// Distance field to the digit 2\nfloat twoDst(vec2 uv)\n{\n    uv.y -= 0.5;\n    \n    float topBar = box((uv + vec2(0.725, 0.0)) * vec2(1.0, 1.4), vec2(0.275, 0.0));\n    \n    if (uv.y > 0.0) // Top 'curve'\n    {\n        uv.y = pow(uv.y, 1.8);\n    \tfloat dist = length(uv);\n        return max(-topBar, (abs(dist - 0.725) - 0.275));\n    }\n    else\n    {\n        float bottomBar = box((uv + vec2(0.0, 1.83)) * vec2(1.0, 1.4), vec2(0.95, 0.299));\n        \n        float two = min(topBar, bottomBar);\n        \n        if (uv.y > -1.8)\n        {    \n            float curve = (cos(uv.y * 2.0) - 1.0) * 0.7;\n            float x = 0.0 + uv.x - curve;\n            float mid = abs(uv.y + 0.4) * 0.7;\n            float x2 = 0.0 + uv.x - curve - mid * mid * 0.15 + 0.01;\n         \n            two = min(two, max(-x + 0.45, x2 -1.0));\n        }\n    \treturn two;\n    }\n\n}\n\n\n// Coordinate transform from global uv space to charcter space with poition and rotation\nvec2 letterUVs(vec2 uv, vec2 pos, float angle)\n{\n    float c = sin(angle);\n    float s = cos(angle);\n    float sc = 1.35;\n    uv -= pos;\n    return uv.x * vec2(s * sc, c) + uv.y * vec2(-c * sc, s);\n}\n\n\n// Borrowed from BigWIngs (random 1 -> 4)\nvec4 N14(float t) {\n\treturn fract(sin(t*vec4(123., 104., 145., 24.))*vec4(657., 345., 879., 154.));\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat embersSpot(vec2 uv, vec2 id, float decimation)\n{\n    float accum = 0.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            vec2 cellUV = uv - offset + rnd.yz * 1.0;\n\n            float dst = length(cellUV);\n\n            //float radSeed = sin(iTime * 0.02 + rnd.x * 40.0);\n            //float rad =  (abs(radSeed) - decimation) / (1.0 - decimation);\n            \n      \t\tfloat rad = rnd.y * 0.5;\n\n            float intensity = S(rad, rad - 0.8, dst);\n            \n            accum += intensity;\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat emberLayer(vec2 uv, float decimation)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    float intensity = embersSpot(cellUV, id, decimation);\n    \n    return intensity;\n}\n\n\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// https://iquilezles.org/articles/voronoise\nfloat VoroNoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = hash3( p + g )*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\n\n// Computes the fire background\nvec3 fire(vec2 uv)\n{\n    uv.x += sin(uv.y * 0.3 + iTime * 0.5)  + sin(uv.y * 0.8 + iTime * 1.23) * 0.25 - uv.y * 0.5;\n    \n    //accumulates several layers of bokeh\n    float fire = VoroNoise(uv * vec2(1.0, 0.3) - vec2(0.0, iTime), 0.0, 1.0) * 0.8;// * 0.2;\n    fire += VoroNoise(uv  * vec2(2.3, 1.68) - vec2(0.0, iTime * 3.0), 0.0, 1.0) * 0.5;\n    fire += VoroNoise(uv * vec2(4.3, 3.3) - vec2(0.0, iTime * 6.0), 0.0, 1.0) * 0.1;\n \n    \n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 1.6 - vec2(0.0, iTime) , 1.0) * 0.5;\n    fire -= emberLayer(uv * vec2(1.0, 0.7) * 3.3 - vec2(0.0, iTime) , 1.0) * 0.25;\n    \n    //return vec3(fire);\n    \n    vec3 col = mix(vec3(2.0, 0.90, 0.55),  vec3(0.1, 0.0, 0.0), min(1.0, uv.y * 0.3 + fire));\n    \n    \n    return col;\n}\n\n\n\nfloat shadowsIntensity = 0.74;\nfloat shadowRadius = 1.1;\n\n\n\nvec3 reflection(vec3 normal, vec2 uv)\n{\n    uv.x = -uv.x;\n    uv += normal.xz * 3.0;\n    return fire(uv);\n}\n\n\nfloat flatPart = -0.06;\nfloat bevel = 0.065;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\n\n// Character two with outline and shadow (premultiplied RGBA)\nvec4 twoCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = twoDst(uv);\n    float dstR = smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, twoDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, bevel);\n    vec3 n = normalize(vec3(dstR - clampedDst, 0.01, dstU - clampedDst));\n    \n    //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    col += reflection(n, uvIn) * 0.8;\n    \n    vec4 res = border(col, dst);\n    \n   \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, twoDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\n\n\n// Character zero with outline and shadow (premultiplied RGBA)\nvec4 zeroCol(vec2 uvIn, vec3 col, vec2 pos, float angle)\n{\n    //uv = letterUVs(uv, pos, angle);\n    \n    \n    vec2 uv = letterUVs(uvIn, pos, angle);\n    \n    float dst = zeroDst(uv);\n    float dstR = smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.05, 0.0), pos, angle)), bevel);\n    float dstU =  smax(flatPart, zeroDst(letterUVs(uvIn + vec2(0.0, 0.05), pos, angle)), bevel);\n    \n    float clampedDst = smax(flatPart, dst, 0.01);\n    vec3 n = normalize(vec3(dstR - clampedDst, bevel, dstU - clampedDst));\n    \n   \n        //col = n * 0.5 + vec3(0.5); \n    col *= 0.4;\n    \n    if (dst < 0.21)\n    {   \n   \t col += reflection(n, uvIn) * 0.8;\n    }\n    \n    vec4 res = border(col, zeroDst(uv));\n    \n    \n    uv.y += 0.14;\n    res.a = min(res.a +  S(shadowRadius, -1.0, zeroDst(uv)) * shadowsIntensity, 1.0);\n    \n    return res;\n}\n\n\nvec3 red = vec3(0.9, 0.01, 0.16);\nvec3 yellow = vec3(0.96, 0.70, 0.19); // 248, 181, 51\nvec3 green = vec3(0.00, 0.63, 0.34);  //1, 162, 88\nvec3 blue = vec3(0.01, 0.57, 0.76);   //5, 142, 197\n\n// 2020 with colors and shadows (premultiplied rgba)\nvec4 yearCol(vec2 uv)\n{\n    float angle = sin(iTime) * 0.3;\n    \n    vec4 date = twoCol(uv, green, vec2(-2.5, 0.0), angle);\n    date = premulBlend(zeroCol(uv, green, vec2(-0.8, 0.0), angle), date);\n    date = premulBlend(twoCol(uv, green, vec2(0.8, 0.0), angle), date);\n    date = premulBlend(zeroCol(uv, green, vec2(2.5, 0.0), angle), date);\n    \n    return  date;\n}\n\n\n\nfloat corona(vec2 uv, float blur)\n{\n      \n    float angle = atan(-uv.x, -uv.y) / 6.2831 + 0.5;\n    \n    float copies = 9.0;\n    //float step = (1.0 / copies);\n    float quarter = floor(angle * copies + 0.5);\n    \n    float rot = -quarter * 6.2831 / copies;\n    \n    float s = sin(rot);\n    float c = cos(rot);\n    \n    uv *= mat2(c, s, -s, c);\n    \n    float dst = length(uv) - 0.4;\n    \n    \n    float dst2 = length((uv - vec2(0.0, 0.63)) * vec2(1.0, 1.2)) - 0.13;\n    \n    if (uv.y < 0.63)\n    {\n        dst = min(dst, abs(uv.x) - 0.06);// + 0.1, 0.1);\n    }\n    \n    dst = smin(dst, dst2, 0.1);\n    \n    return S(-0.01 - blur, 0.01 + blur , dst);\n}\n\n\n// Compute a randomized Bokeh spot inside a grid cell\nfloat coronaSpot(vec2 uv, vec2 id)\n{\n    float accum = 1.0;\n    \n    for (float x = -1.0; x <= 1.0; x += 1.0)\n    {\n        for (float y = -1.0; y <= 1.0; y += 1.0)\n        {\n            vec2 offset = vec2(x, y);\n            vec2 cellId = id + offset;\n            vec4 rnd = N14(mod(cellId.x, 300.0) * 25.3 + mod(cellId.y, 300.0) * 6.67);\n    \n            float t = iTime;\n            \n            vec2 cellUV = uv - offset + rnd.yz * 1.0 + vec2(sin(t * (rnd.x + 0.3)), cos(t * (rnd.z + 0.2))) * 0.2;\n\n            \n            float rot = rnd.y * rnd.x * 456.0 + iTime * (0.3 * (rnd.y - 0.5)) ;\n            float c = cos(rot);\n            float s = sin(rot);\n            cellUV *= mat2(c,s,-s,c);\n\n            float dst = rnd.y;\n            \n            float intensity = corona(cellUV * (1.5 + dst), dst * 0.2);\n            \n            accum *= mix(intensity, 1.0, dst);\n        }\n    }\n    \n    return accum;\n}\n\n// Computes a random layer of embers spots\nfloat coronaLayer(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 cellUV = (uv - id) - vec2(0.5, 0.5) ;\n\n    return coronaSpot(cellUV, id);\n}\n\n\n\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    uv *= 3.0;\n    \n    vec4 dateCol =  yearCol(uv); // 2020\n    \n    vec3 bg = fire(uv);\n    \n    \n    float corona = coronaLayer(uv * 1.1);\n    \n    \n    bg.rgb += mix(0.0,  corona, S(-2.0, 7.0, uv.y)) * 0.8;\n \n    \n    //add a bit of light\n    dateCol.rgb -= uv.y * 0.15 * dateCol.a;\n    bg.rgb -= uv.y * 0.03;\n    \n    // blend 2020 and BG\n    vec3 col = premulBlend(dateCol, bg);\n    \n    // Gamma correction to make the image warmer\n    float gamma = 0.8;\n    col.rgb = pow(col.rgb, vec3(gamma));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}