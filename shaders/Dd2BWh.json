{
    "Shader": {
        "info": {
            "date": "1689665815",
            "description": "RayMarchingShader",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd2BWh",
            "likes": 1,
            "name": "RayMarching4489",
            "published": 3,
            "tags": [
                "3d",
                "raymarching"
            ],
            "usePreview": 0,
            "username": "shaderNoob4489",
            "viewed": 75
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 50\n#define MAX_DIST 50.\n#define MAX_SHADOW_DIST 30.\n#define SURF_DIST .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a; \n    vec3 ap = p - a; \n    float t = dot(ap, ab) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + t * ab;\n\n    return length(c - p) - r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b - a; \n    vec3 ap = p - a; \n    float t = dot(ap, ab) / dot(ab, ab);\n    vec3 c = a + t * ab;\n\n    float x = length(p - c) - r;\n    float y = (abs(t - .5) - .5) * length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    return e + i;\n}\n\nfloat sdTours(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    float e = length(max(d, 0.));\n    float i = min(max(max(d.x, d.y), d.z), 0.);\n    return e + i;\n}\n\nfloat GetDist(vec3 p)\n{\n    vec4 sphere = vec4(0, 1, 6, 1);\n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = p.y;\n    float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), .2);\n    float td = sdTours(p - vec3(0, .5, 6), vec2(1.5, .3));\n    float bd = sdBox(p - vec3(-3, .75, 6), vec3(.75));\n    float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(2, .3, 5), .3);\n    float d = min(planeDist, cd);\n    d = min(td, d);\n    d = min(bd, d);\n    d = min(cyld, d);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO * rd;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dO < SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    //vec3 normal = d - vec3\n    //(\n    //    GetDist(p - e.xyy),\n    //    GetDist(p - e.yxy),\n    //    GetDist(p - e.yyx)\n    //);\n    vec3 normal = vec3\n    (\n        GetDist(p + e.xyy),\n        GetDist(p + e.yxy),\n        GetDist(p + e.yyx)\n    );\n    return normalize(normal);\n}\n\nfloat shadow(vec3 p, vec3 lightDir, float ldis)\n{\n    float shadow = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float d = GetDist(p + t * lightDir);\n        t += d;\n        if (t > MAX_SHADOW_DIST) break;\n        if (d < SURF_DIST) return 0.;\n        shadow = min(2. * d / t, shadow);\n    }\n    return shadow;\n}\n\nfloat ao(vec3 p, vec3 n)\n{\n    float a = 0.;\n    float e = .1;\n    int ignored;\n    float weight = .5;\n    \n    for (int i = 1; i <= 5; i++)\n    {\n        float d = e * float(i);\n        a += weight * (1.0 - (d - GetDist(p + n * d)));\n        weight *= .5;\n    }\n    \n    return a;\n}\n\nvec3 GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 0);\n    lightPos += vec3(5. * cos(iTime) * .5, 0, 5. * sin(iTime) * .5);\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = GetNormal(p);\n    float dif = clamp(dot(lightDir, normal), 0., 1.);\n    float ldis = length(lightPos - p);\n    dif *= shadow(p + normal * SURF_DIST * 2., lightDir, ldis);\n    \n    vec3 ambient = ao(p, normal) * vec3(.2);\n    return vec3(dif) + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 2, 0); \n    vec3 rd = normalize(vec3(uv.x, uv.y - .2, 1));\n    \n    vec3 p = ro + rd * RayMarch(ro, rd);\n    col = GetLight(p);\n    //col = GetNormal(p);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}