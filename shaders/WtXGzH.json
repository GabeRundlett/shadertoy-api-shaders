{
    "Shader": {
        "info": {
            "date": "1555593893",
            "description": "Did a small experiment with raytracing. Got a blackhole working. If anyone has a more accurate solution of how to simulate orbits, please comment",
            "flags": 0,
            "hasliked": 0,
            "id": "WtXGzH",
            "likes": 17,
            "name": "Raytraced Blackhole",
            "published": 3,
            "tags": [
                "raytracing",
                "ray",
                "blackhole",
                "hole",
                "gravity",
                "black",
                "lensing",
                "gravitational",
                "robobo1221"
            ],
            "usePreview": 0,
            "username": "robobo1221",
            "viewed": 1488
        },
        "renderpass": [
            {
                "code": "const int steps = 80;\nconst float rSteps = 1.0 / float(steps);\n\nconst float G = 6.67408e-11;\nconst float speedOfLight = 1.079e12;\nconst float mass = 1.0e9;\n\nvec3 circlePos = vec3(0.0, 0.0, 2.0);\n\nfloat distFieldBlackHole(vec3 position){\n\tfloat dist = length(position - circlePos);\n    \n    return dist;\n}\n\nfloat calcGravity(const float mass, const float r){\n\treturn G * (mass / (r * r));\n}\n\nfloat calculateSchwarzchildradius(const float mass){\n\treturn 2.0 * G * mass;\n}\n\nvec4 raytraceBlackHole(inout vec3 worldVector){\n    vec3 position = worldVector;\n    \n    bool hit = true;\n    \n    float schwarzchildradius = calculateSchwarzchildradius(mass);\n    \n    float d = 0.0;\n    \n    for (int i = 0; i < steps; ++i){\n\t\tfloat m = distFieldBlackHole(position);\n        d += m;\n        \n        vec3 gravitationalDirection = normalize(position - circlePos);\n        float gravity = calcGravity(mass, m);\n        worldVector -= gravitationalDirection * gravity;\n        worldVector = normalize(worldVector);\n        \n        if (m < schwarzchildradius) hit = false;\n        if (d > 1e16) break;\n        \n        position += worldVector * (m - (schwarzchildradius * 0.999999));\n    }\n    \n    return vec4(position, float(hit));\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float xx = axis.x * axis.x;\n    float yy = axis.y * axis.y;\n    float zz = axis.z * axis.z;\n    \n    float xy = axis.x * axis.y;\n    float xz = axis.x * axis.z;\n    float zy = axis.z * axis.y;\n    \n    return mat3(oc * xx + c, oc * xy - axis.z * s, oc * xz + axis.y * s,\n                oc * xy + axis.z * s, oc * yy + c, oc * zy - axis.x * s, \n                oc * xz - axis.y * s, oc * zy + axis.x * s, oc * zz + c);\n}\n\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    color = pow(color, vec3(1.0 / 2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 wcoord = (uv * 2.0 - 1.0) * vec2(1.0, iResolution.y / iResolution.x);\n    vec3 wvec = normalize(vec3(wcoord, 1.0));\n   \n    vec4 raymarched = raytraceBlackHole(wvec);\n    vec3 worldVecTraced = normalize(raymarched.rgb);\n    worldVecTraced = rotationMatrix(vec3(0.0, 1.0, 0.0), iTime * 0.5) * worldVecTraced;\n\tworldVecTraced = normalize(worldVecTraced);\n    \n    vec3 color = vec3(0.0);\n         color = texture(iChannel0, worldVecTraced).rgb * raymarched.a;\n    \n         color /= 1.0 - color * 0.999999;\n         color = pow(color, vec3(2.2));\n         color = ACESFitted(color);\n         \n\n    fragColor = vec4(color,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}