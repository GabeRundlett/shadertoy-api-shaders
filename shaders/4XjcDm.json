{
    "Shader": {
        "info": {
            "date": "1727333118",
            "description": "Brushstrokes experiment.",
            "flags": 32,
            "hasliked": 0,
            "id": "4XjcDm",
            "likes": 3,
            "name": "Drawing Thing 2",
            "published": 3,
            "tags": [
                "painting",
                "drawing",
                "graphics",
                "turtle"
            ],
            "usePreview": 0,
            "username": "rafaelbeckel",
            "viewed": 52
        },
        "renderpass": [
            {
                "code": "const uint Airbrush = 0x00000001u;\nconst uint Roundbrush = 0x00000002u;\nconst uint TexturedBrush = 0x00000003u;\n\n// Define the Stroke struct with Bezier curve support and texture information\nstruct Stroke {\n    vec2 p0, p1, p2, p3; // Cubic Bezier control points\n    vec4 startColor;\n    vec4 endColor;\n    float startTime;\n    float endTime;\n    float startBrushSize;\n    float endBrushSize;\n    uint brushType;\n    vec2 textureScale;\n    vec2 textureOffset;\n};\n\n// Initialize the strokes array\n#define NUM_STROKES 6\nStroke strokes[NUM_STROKES];\n\nvoid initStrokes() {\n    // Background (textured)\n    strokes[0] = Stroke(\n        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0, 1.0),\n        vec4(1.0, 1.0, 1.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0),\n        0.0, 1.0,\n        1.0, 1.0,\n        TexturedBrush,\n        vec2(1.0, 1.0), vec2(0.0, 0.0)\n    );\n\n    // Left eye\n    strokes[1] = Stroke(\n        vec2(-0.3, 0.1), vec2(-0.2, 0.2), vec2(-0.1, 0.2), vec2(-0.05, 0.1),\n        vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0),\n        1.0, 2.0,\n        0.01, 0.03,\n        Roundbrush,\n        vec2(1.0), vec2(0.0)\n    );\n    \n    // Right eye\n    strokes[2] = Stroke(\n        vec2(0.3, 0.1), vec2(0.2, 0.2), vec2(0.1, 0.2), vec2(0.05, 0.1),\n        vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 1.0),\n        2.0, 3.0,\n        0.01, 0.03,\n        Roundbrush,\n        vec2(1.0), vec2(0.0)\n    );\n    \n    // Smile\n    strokes[3] = Stroke(\n        vec2(-0.3, -0.1), vec2(-0.1, -0.3), vec2(0.1, -0.3), vec2(0.3, -0.1),\n        vec4(0.8, 0.2, 0.2, 1.0), vec4(0.8, 0.2, 0.2, 1.0),\n        3.0, 4.0,\n        0.03, 0.03,\n        Roundbrush,\n        vec2(1.0), vec2(0.0)\n    );\n    \n    // Left blush\n    strokes[4] = Stroke(\n        vec2(-0.4, -0.1), vec2(-0.4, -0.1), vec2(-0.4, -0.1), vec2(-0.4, -0.1),\n        vec4(1.0, 0.2, 0.3, 0.0), vec4(1.0, 0.2, 0.3, 0.5),\n        4.0, 5.0,\n        0.05, 0.15,\n        Airbrush,\n        vec2(1.0), vec2(0.0)\n    );\n    \n    // Right blush\n    strokes[5] = Stroke(\n        vec2(0.4, -0.1), vec2(0.4, -0.1), vec2(0.4, -0.1), vec2(0.4, -0.1),\n        vec4(1.0, 0.2, 0.3, 0.0), vec4(1.0, 0.2, 0.3, 0.5),\n        5.0, 6.0,\n        0.05, 0.15,\n        Airbrush,\n        vec2(1.0), vec2(0.0)\n    );\n}\n\nvec2 bezierPoint(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float mt3 = mt2 * mt;\n    return p0 * mt3 + p1 * 3.0 * mt2 * t + p2 * 3.0 * mt * t2 + p3 * t3;\n}\n\nvec2 bezierDerivative(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t2 = t * t;\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    return 3.0 * (\n        (p1 - p0) * mt2 +\n        (p2 - p1) * 2.0 * mt * t +\n        (p3 - p2) * t2\n    );\n}\n\nfloat distanceToBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec2 point, float maxT, out float closestT) {\n    float minDist = 1e10;\n    closestT = 0.0;\n    \n    for (int i = 0; i <= 10; i++) {\n        float t = min(float(i) / 10.0, maxT);\n        vec2 pos = bezierPoint(p0, p1, p2, p3, t);\n        float dist = length(point - pos);\n        if (dist < minDist) {\n            minDist = dist;\n            closestT = t;\n        }\n    }\n    \n    // Refine the closest point\n    for (int i = 0; i < 5; i++) {\n        float dt = 0.1 / pow(2.0, float(i));\n        float t0 = max(closestT - dt, 0.0);\n        float t1 = min(closestT + dt, maxT);\n        \n        vec2 pos0 = bezierPoint(p0, p1, p2, p3, t0);\n        vec2 pos1 = bezierPoint(p0, p1, p2, p3, t1);\n        \n        float dist0 = length(point - pos0);\n        float dist1 = length(point - pos1);\n        \n        if (dist0 < dist1) {\n            closestT = t0;\n            minDist = dist0;\n        } else {\n            closestT = t1;\n            minDist = dist1;\n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    fragColor = vec4(0.95, 0.90, 0.85, 1.0); // light peach background\n\n    // Initialize strokes\n    initStrokes();\n\n    // Draw the strokes\n    for (int i = 0; i < NUM_STROKES; i++) {\n        Stroke stroke = strokes[i];\n        \n        if (iTime < stroke.startTime) continue;\n\n        float progress = min((iTime - stroke.startTime) / (stroke.endTime - stroke.startTime), 1.0);\n        vec4 color = mix(stroke.startColor, stroke.endColor, progress);\n\n        float intensity = 0.0;\n\n        if (stroke.brushType == TexturedBrush) {\n            vec2 textureUV = (uv + 0.5) * stroke.textureScale + stroke.textureOffset;\n            vec4 texColor = texture(iChannel0, textureUV);\n            intensity = texColor.r * progress;\n        } else if (stroke.brushType == Airbrush) {\n            float dist = length(uv - stroke.p0);\n            float brushSize = mix(stroke.startBrushSize, stroke.endBrushSize, progress);\n            intensity = smoothstep(brushSize, 0.0, dist) * color.a;\n            if (iTime > stroke.endTime) {\n                color = stroke.endColor;\n            }\n        } else if (stroke.brushType == Roundbrush) {\n            float closestT;\n            float dist = distanceToBezier(stroke.p0, stroke.p1, stroke.p2, stroke.p3, uv, progress, closestT);\n            float brushSize = mix(stroke.startBrushSize, stroke.endBrushSize, closestT);\n            intensity = smoothstep(brushSize, brushSize * 0.9, dist) * color.a;\n        }\n\n        vec4 strokeColor = vec4(color.rgb * intensity, intensity);\n\n        fragColor = mix(fragColor, strokeColor, intensity);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Simple noise function\nfloat noise(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Create some noise\n    float n = noise(uv * 10.0);\n    \n    // Add some larger scale variation\n    n += 0.5 * noise(uv * 5.0);\n    n += 0.25 * noise(uv * 2.5);\n    \n    n /= 1.75; // Normalize\n    \n    // Output to screen\n    fragColor = vec4(vec3(n), 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}