{
    "Shader": {
        "info": {
            "date": "1640488296",
            "description": "debuging, playing around. reduced complexity, - 2x vec4 and one dot operation, lerp between gain values.",
            "flags": 8,
            "hasliked": 0,
            "id": "7tySWR",
            "likes": 21,
            "name": "testing fdn stuff pi.II",
            "published": 3,
            "tags": [
                "sound",
                "reverberation",
                "fnd"
            ],
            "usePreview": 0,
            "username": "nabr",
            "viewed": 530
        },
        "renderpass": [
            {
                "code": "\nvoid print(inout vec4 O, in vec2 uv )\n{\n    //O -= O;\n    \n    vec2 U;\n    uv /= R.y;\n     \n    uv -= vec2(1.2,-.2);\n    U = ( uv - vec2(.0,.5) ) * 16.;\n    vec2 gV = getVal(0., 0., T);\n    \n    float ratio = float( gcd( int( gV.x ) , int( gV.y ) ));\n     \n    low C(22)C(1)C(12)caps C(-15)C(-6)spc spc // val1\n    O += pFloat(U, gV.x);\n    U = ( uv - vec2(.0,0.45) ) * 16.;\n    low C(22)C(1)C(12)caps C(-14)C(-6)spc spc  // val2\n    O += pFloat(U,gV.y);\n    U = ( uv - vec2(.05,0.40) ) * 24.;  // ratio\n    low C(18)C(1)C(20) C(9) C(15) \n    caps C(-6) spc spc\n    \n    O += pInt(U, (gV.x/ratio));\n    spc spc U.y+=.8;\n    O += pInt(U, 100.*floor(gV.y/ratio));\n    \n    U = ( uv - vec2(.05,0.30) ) * 24.;  // decay\n    low C(4)C(5)C(3) C(1) C(25) caps C(-6) spc spc\n    O += pFloat(U,decay);\n    O += draw_char(iChannel3).xxxx;\n \n}\n\n// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.)))\n\n// -------- texture\nfloat f(vec2 U)\n{\n    float O = 0.;\n     vec2 u=U;\n     u = vec2(.5, -1.5)+u*12.;\n     for(int i = 0; i < 7; ++i){\n     O += char(u,int[](83, 111, 117, 110, 100, 105, 110)[i]).x; //*max(0., 1.-T*.2);\n     u.x -= 1.5;\n     u*= mat2(0.6,-.8,.8, .6);\n     }\n     return O;\n}\nfloat tex(in vec2 p)\n{\n    float m = .5;\n    const vec2 e = vec2(.001, 0);\n    vec3 sn = normalize(vec3(f(p + e) - f(p - e), f(p + e.yx) - f(p - e.yx), -.2));\n    return clamp(max(0., dot(normalize(vec3(2.*p, m)), -sn)), .0, 1.);\n}\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    \n    vec2 cU = ((U - .5 * R) / R.y);\n    if(abs(cU.x-.54)<.3333&&abs(cU.y-.25)<.2){\n    vec2 M = vec2(.25, .5) * iTime ; //+ (6. * atan(iMouse.xy / R));\n    #define R3d(_a)(mat3(1,0,0,0,cos(_a.y),-sin(_a.y),0,sin(_a.y),cos(_a.y))*mat3(cos(_a.x),0,sin(_a.x),0,1,0,-sin(_a.x),0,cos(_a.x)))\n    vec3 o = R3d(M) * vec3(0, 0, float( (mod(T, 20.)> 16.)?-1.5:4.));\n    vec3 d = R3d(M) * vec3(cU+vec2(-.54, -.25), 2.2);\n    // -------- box\n    // https://iquilezles.org/articles/boxfunctions\n    vec3 no = o * 1. / d;\n    vec3 k = .25 * abs(1. / d);\n    vec3 pin = (-k) - no, pot = k - no;\n    float tN = max(pin.x, max(pin.y, pin.z));\n    float tF = min(pot.x, min(pot.y, pot.z));\n    if (tN < tF){\n        vec3 pos = (o + tF * d);\n        vec3 n = sign(d) * step(pot, pot.zxy) * step(pot, pot.yzx);\n        float tx = abs(n.x * tex(pos.zy) + n.y * tex(pos.zx) + n.z * tex(pos.xy));\n        // -------- shade box\n        O.xyz = sin(1.7 + tx * vec3(4.5, 6, 6.75)) * 0.45 + 0.5;\n        }\n    }\n    else{\n    //------- dancing beams of light\n    O.xyz=vec3(1e-6);\n    cU+=vec2(0.34, 0.19);\n    if(abs(cU.x)<.55&&abs(cU.y)<.3)\n    {\n    vec2 vr = v2rnd(T*6.);\n    vr = clamp(vr, -vec2(.5, .25), vec2(.5, .25));\n    float asp = 1.7/max(R.x, R.y),\n    cx = asp/length((cU.x+vr.x)),\n    cy = asp/length((cU.y+vr.y));\n    O.xyz = .051 * vec3(cU, sin(iTime)*.5+.5) \n    +vec3(mix(cy, cx, sin(2.*T)*.5+.5)-.074)\n    +.001*float(int(U.x+floor(U.y) * 21.999)& 13);\n    }\n    print(O, U);\n    }\n     \n     O = pow(O, vec4(.454545));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define R iResolution.xy\n#define T iTime\n\nfloat rndp(in uint sd,in uint mv){return float((1315313u%(sd+1u))%mv);}\n\nvec2 v2rnd(in float t)\n{\n    float x=rndp(uint(t),27U),y=rndp(uint(t),31U);\n    return vec2(sin(x),cos(y));\n}\n\n\n// DEKAY OK\nconst float decay = 1.2;\nvec2 getVal(in float x, in float y, in float t)\n{\n     float valchange = + 71.991; //new random sequence\n     t = (t * (1./8.)) + valchange;\n     float xx = v2rnd(.5*t).x;\n     float yy = v2rnd(1.+t).y;\n     return abs( 12.566370 * vec2(xx, yy));\n}\n\n// https://github.com/riccardoscalco/glsl-gcd/blob/master/index.glsl\nint gcd(int u, int v) {\n\tu = abs(u);\n\tv = abs(v);\n\t// While loop is not always allowed, use a for loop.\n\tfor (int i = 0; i < 10; ++i) \n    {\n\t\tif (v == 0) break;\n\t\tu = (u% v);\n\t\tif (u == 0) break;\n\t\tv = (v% u);\n\t}\n\treturn u + v;\n}\n\n// --- chars https://www.shadertoy.com/view/llySRh by FabriceNeyret2\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n  if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n //   if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char(sampler2D iCnl) {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5):textureGrad(iCnl, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );}\n// --- display int4\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 2.;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define Fs (1./iSampleRate)\n#define _f(x)  fract(x)\n\nfloat synth(in float rt, in float t, int ch) \n{\n  float f = 0., ft = mod(6. * t, 1.);\n  vec4 p = vec4(0);\n  if (ch == 0)\n    p = vec4(2880, 1440, 1182, 1804);\n  else if (ch == 1) {\n    p = vec4(1440., 720., 591, 902.);\n    if(mod(rt, 10.) > 8.) \n    p =vec4(1440., 1890, 603, 2685);\n  }\n\n  f = sin(1.570796 * p[int(6. * t) % 4] * rt) * min(1., 3. * ft) * max(0., 1. - ft);\n  f *= cos(_f(.1 * t) + 10. * exp(-.205 * pow(1. - ft, 10.)));\n  f = sin(2. * f / (1.24 - cos(f))) / (1.6643 + sin(13. * f));\n\n  return f * clamp((1. - sqrt(ft)) * 4. * ft, -1., 1.);\n}\n\nvoid bfdn(inout vec4 s, const in mat4 M, in uint i) \n{\n    s += //(s[0] * M[i][0] + s[1] * M[i][1] + s[2] * M[i][2] + s[3] * M[i][3]); \n         (s[0] * M[0][i] + s[1] * M[i][i] + s[2] * M[i][i] + s[3] * M[i][i]);\n}\n\n\nvec2 mainSound( in int samp,float time)\n{\n   // hard coded decay value in common tab\n   float mTime = float(samp)/iSampleRate;\n   vec2 gV = getVal(0., 0., mTime); // gain coefficient\n   \n   //\n   float ehd[6]=float[](.184089,.118295,.074423,.046412,.029080,.018004);//late dalaylines\n   vec4 dt = vec4(577, 601, 641, 661);//primes\n   \n   vec2 r = vec2(1e-6);\n   float fehd =0.;\n   float y = 0., y1 = 0., y2 = 0., y3=0., y4 = 0.;\n   float mt = float(samp)/iSampleRate;\n   float dlt = mt;\n   \n   //phaser\n   float vt = mt;\n   vec4 ehp = 1e-6 * vec4(17. * cos(vt), -15. * sin(vt), 12. * sin(vt),11. * cos(vt));\n   float rtxz =(mt+(ehp.x+ehp.z)), rtyw =(mt+(ehp.y+ehp.w));\n   \n   const uint sz=12u;\n   for(uint j = 0u; j < 2u; j++)\n     for(uint i = 0u; i < sz; ++i){\n\n\n//#define _DBG\n#ifdef _DBG\n   \n    const vec4 A = vec4(0, -1, 1, 0);\n    dt += vec4(\n    dt[(i + 0u)%4u],\n    dt[(i + 1u)%4u],\n    dt[(i + 2u)%4u],\n    dt[(i + 3u)%4u]);\n    \n    fehd = smoothstep(-gV.x, gV.y, (dot(A, dt) * .0001)  +  ehd[ i % 6u]) ;\n    float decayfehd = fehd; //mod(fehd, 1./4.) ;\n    dlt += fehd +  ehd[ i % 6u];\n    //mt += ehd[ i % 6u];\n\n#else\n\n     const mat4 A=mat4(0,-1.,1.,0,1.,0,0,1.,1.,0,0,-1.,0,-1.,-1.,0)*(1./sqrt(2.));\n     bfdn(dt, A, (i + 0u) % 4u );\n     bfdn(dt, A, (i + 1u) % 4u );\n     bfdn(dt, A, (i + 2u) % 4u );\n     bfdn(dt, A, (i + 3u) % 4u );\n     fehd = smoothstep(-gV.x, gV.y, (((dt.x + dt.y + dt.z + dt.w)) * .0001)+  ehd[ i % 6u] ) ;\n     float decayfehd = mod(fehd, 1./4.); //fehd;\n     dlt += fehd +  ehd[ i % 6u];\n     \n#endif\n        //-------- output\n        {\n            y1 =.4*synth(rtxz,time,0);\n            y2 =.4*synth(rtyw,time,0);\n            y3 =   synth(mt, dlt,0)*exp(-decay*decayfehd);\n            y4 =   synth(mt, dlt,0)*exp(-decay*decayfehd);\n        \n            if(time>9.5){\n            y1 +=.4*synth(.5*rtxz, time, 1 );\n            y2 +=.4*synth(.5*rtxz, time ,1);\n            y3 +=   synth(.5*mt, dlt, 1) * exp(-2.*decay*decayfehd);\n            y4 +=   synth(.5*mt, dlt, 1) * exp(-2.*decay*decayfehd);\n            }\n        }\n        \n        //multi channel split\n        float v[sz];//unroll for some mobile  \n        //float v[12] =float[](y2,y3,y3,y2,y2,y3,y3,y2,y4,y1,y1,y4);\n        v[0]=y2;v[1]=y3;v[2]=y3;v[3]=y2;v[4]=y2;v[5]=y3;v[6]=y3;v[7]=y2;v[8]=y4;v[9]=y1;v[10]=y1;v[11]=y4;\n        (i% 2u==0u)?(r.x += v[i % uint(sz)]): (r.y += v[i % uint(sz)]);\n\n    }\n\nreturn r /= float(8.) ;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}