{
    "Shader": {
        "info": {
            "date": "1574201263",
            "description": "This is my \"first released demo\". It's more like a training session for me.\nIt's not the first time I draw with math, and it's also not the first time I draw with math in 3D space. But it's the first time I can actually show the result around.",
            "flags": 32,
            "hasliked": 0,
            "id": "WdyXWD",
            "likes": 2,
            "name": "rendering training project",
            "published": 3,
            "tags": [
                "demo",
                "tracing",
                "scroller"
            ],
            "usePreview": 0,
            "username": "sirjofri",
            "viewed": 308
        },
        "renderpass": [
            {
                "code": "/*\n\nFINAL IMAGE COMPOSITE\n\nLet's composite the rendering and add some text and effects.\n\nThe text is a large step here...\n\nEverything else is ... no magic.\n\n*/\n\nvec3 campos;\n\n/* Text count (10 chars/row)\n----------\ngreetings \nto masterq\n32 and jul\niettesierr\na\n*/\n\n/* length of the string */\n#define LEN 44.\n\n/* let's define some chars */\n#define SP 2*16+0\n#define N0 3*16+0\n#define N1 3*16+1\n#define N2 3*16+2\n#define N3 3*16+3\n#define N4 3*16+4\n#define N5 3*16+5\n#define N6 3*16+6\n#define N7 3*16+7\n#define N8 3*16+8\n#define N9 3*16+9\n#define A 4*16+1\n#define B 4*16+2\n#define C 4*16+3\n#define D 4*16+4\n#define E 4*16+5\n#define F 4*16+6\n#define G 4*16+7\n#define H 4*16+8\n#define I 4*16+9\n#define J 4*16+10\n#define K 4*16+11\n#define L 4*16+12\n#define M 4*16+13\n#define N 4*16+14\n#define O 4*16+15\n#define P 5*16+0\n#define Q 5*16+1\n#define R 5*16+2\n#define S 5*16+3\n#define T 5*16+4\n#define U 5*16+5\n#define V 5*16+6\n#define W 5*16+7\n#define X 5*16+8\n#define Y 5*16+9\n#define Z 5*16+10\n\n/* and the message */\nint[] message = int[] (\n /*  0,  1,  2,  3,  4,  5,  6,  7,  8,  9 */\n     G,  R,  E,  E,  T,  I,  N,  G,  S, SP,\n     T,  O, SP,  J,  U,  L,  I,  E,  T,  T,\n     E,  S,  I,  E,  R,  R,  A, SP,  A,  N,\n     D, SP,  M,  A,  S,  T,  E,  R,  Q, N3,\n    N2, SP, SP, SP\n);\n\n/* get char from UV x position */\nint getChar(vec2 uv)\n{\n    int field = int(floor(uv.x));\n    int char = message[field];\n    return char;\n}\n\n/* get SDF data from font */\nfloat getTextSDF(vec2 uv)\n{\n    int char = getChar(uv);\n    vec2 myUV = uv/16.+fract(vec2(char-int(floor(uv.x)),15-char/16)/16.);\n    return textureGrad(iChannel1, myUV, dFdx(uv/16.), dFdy(uv/16.)).w;\n}\n\n/* get text mask from SDF data */\nvec4 getText(vec2 uv)\n{\n    uv += vec2(campos.x/10., sin(iTime)*0.01-0.01+cos(uv.x*40.)*0.01);\n    uv = vec2(mod(uv.x, 1.), uv.y);\n    uv = vec2(uv.x, clamp(uv.y, 0., 0.02));\n    float tex = getTextSDF(uv*LEN);\n    float tmask = smoothstep(0.51, 0.52, tex); // alpha mask\n    float tinner = smoothstep(0.50, 0.51, tex); // inner text body mask for outline\n    \n    vec3 textcolor = (0.7+vec3(\n        (sin(uv.x*500.)+1.)/8.,\n        (cos(uv.x*600.+sin(uv.y*300.))+1.)/7.,\n        (cos(uv.y*200.+sin(uv.x)*500.)+1.)/6.\n    )) * (1.-tinner); // times outline mask\n    return vec4(textcolor, 1.-tmask);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    campos = getCampos(iTime); // get camera position\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 tcolor = texture(iChannel0, uv); // 3d rendering\n    \n    vec2 textuv = fragCoord/iResolution.x;\n    vec4 text = getText(textuv/10.);\n\n    float dist = smoothstep(0., 100., tcolor.a); // fake mist from distance\n    vec3 col = mix(tcolor.rgb + dist, text.rgb, text.a); // composite output\n    float vignette = smoothstep(0.12 , .2, 0.15 + uv.x*(1.-uv.x) * uv.y*(1.-uv.y));\n\n    fragColor = vec4(col*vignette, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n3D RENDERING\n\nThis buffer renders the virtual 3d scene. It's just a simple ground plane with\nsome distortion. It also uses some simple (not normal aligned) parallaxish effect.\n\nThe buffer contains color information in RGB and the scene depth in A.\n\n*/\n\nvec3 campos;\nvec3 camdir;\n\n#define PARALLAX -0.07\n#define TERRAINHEIGHT 0.6\n\n/* return the ground color at the given world position */\nvec3 groundColor(vec3 worldpos)\n{\n    vec3 wp = worldpos + texture(iChannel0, worldpos.xy).r*PARALLAX;\n    float dist = distance(campos, wp);\n    float pebbles = texture(iChannel0, wp.xy).r;\n    vec3 tex = mix(vec3(0., .1, .01), vec3(.6, .3, 0.), pebbles);\n    vec3 o = mix(tex, vec3(0.), clamp(0., 1., dist*0.025));\n    return o;\n}\n\n/* trace the actual ray. */\nvec4 linetrace(vec2 uv)\n{\n    vec3 raydir = normalize(camdir + vec3(uv.x-.5, 0., uv.y-.5)/1.);\n    float m = -campos.z/raydir.z;\n    vec3 zero = campos + m*raydir;\n    \n    float n = m + sin(zero.x*2. + sin(zero.y*.5)*2.)*TERRAINHEIGHT;\n    vec3 intersection = campos + n*raydir;\n    float dist = distance(campos, intersection);\n    \n    return vec4(groundColor(intersection), dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get camera position and direction from buffer B\n    campos = getCampos(iTime);\n    camdir = getCamdir(iTime);\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = linetrace(uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec3 getCampos(float iTime)\n{\n    return vec3(iTime*0.3, 0., 3.+sin(iTime));\n}\n\nvec3 getCamdir(float iTime)\n{\n    return normalize(vec3(sin(iTime)*.5, 1.+sin(iTime)+1., -1.));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}