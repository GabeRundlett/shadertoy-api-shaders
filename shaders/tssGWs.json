{
    "Shader": {
        "info": {
            "date": "1547856186",
            "description": "simulates 5 bounces of rays starting as horizontal beam and reflecting on a sphere and top+bottom mirrors.\nSphere = Mouse or auto.\n\nProblem: sphere moving while rays propagates is an issue :-/\nSolved there: [url]https://www.shadertoy.com/view/3sSGRz[/url]",
            "flags": 32,
            "hasliked": 0,
            "id": "tssGWs",
            "likes": 7,
            "name": "bouncing rays",
            "published": 3,
            "tags": [
                "rays",
                "geometry",
                "optics"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 544
        },
        "renderpass": [
            {
                "code": "// or cf variant solving inconsistency issue as sphere moves: https://www.shadertoy.com/view/3sSGRz\n\n\n#define S(d,r) smoothstep( r/R.y, 0., d)   // antialiased draw. r >= 1.5\n\n// --- line segment with disc ends: seamless distance to segment //  https://www.shadertoy.com/view/4dcfW8\nfloat line(vec2 p, vec2 a, vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n  //return length(p - b * h);                         // dist to segment\n    p -= b*h; return dot(p,p);                        // square dist\n}\n\n// --- draw pathes -----------------------------------------------------\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R.y;\n    \n    float t, d = 1e5, l, y;\n    for( float n=0.; n<R.y/K; n++) {                  // follow path n\n        vec2 P = T(vec2(0,n)).xy, _P;                 // path start point\n        for( float i=1.; i<6.; i++) {                 // follow bounces\n            l = line( U, _P = P, P = T(vec2(i,n)).xy );\n            if (l < d) d = l, y = n;\n       }   }\n    O =   S( sqrt(d), 1.5)\n        * ( .6 + .6 * cos( 6.3*(y*K/R.y)  + vec4(0,23,21,0)  ) ); // hue:  https://www.shadertoy.com/view/ll2cDc\n    \n    O += S( abs(length(Pdisk-U)-.2), 1.5 );           // trace disk\n // O = sqrt(O); // to sRGB\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// bufA: path( bounce x, Id y) = ( Pos, Dir )\n\n#define Inf 1e3\n#define Eps 1e-2\n\n// --- ray-sphere intersec: || (P + l*D) - C ||² = r²  ->  2-polynomial\nfloat sphere(vec2 P, vec2 D, vec2 C, float r) {\n   vec2 d = P-C;\n    float b = dot(d,D), c = dot(d,d) - r*r, k = b*b-c, l;\n    if (k>0.) {\n        l = -b +sign(b)*sqrt(k) - Eps;\n        if (l>0.) return l;             // hit distance. Eps should rather be here\n    }\n    return Inf;                         // no hit\n}\n// normal at hit point P\n#define sphereN(P,C) normalize(P-(C))\n\n// --- ray-bottom intersec:  P + l*D = (x,0)   ->  l\nfloat bottom(vec2 P, vec2 D) {\n    if (D.y != 0.) {\n        float l = -P.y/D.y - Eps; \n        if (l > 0.) return l;           // hit distance. Eps should rather be here\n    }\n    return Inf;                         // no hit\n}\n// normal at hit point P\n#define bottomN(P) vec2(0,1)\n\n// --- ray-top intersec:  P + l*D = (x,1)   ->  l\nfloat top(vec2 P, vec2 D) {\n    if (D.y != 0.) {\n        float l = (1.-P.y)/D.y - Eps; \n        if (l > 0.) return l;           // hit distance. Eps should rather be here\n    }\n    return Inf;                         // no hit\n}\n// normal at hit point P\n#define topN(P) vec2(0,-1)\n\n// --- trace rays( x = bounceID, y = pathID ) ------------------------\nvoid mainImage( out vec4 O, vec2 U )\n{\n    float t, y;\n    vec2  R = iResolution.xy,\n          X = vec2(1,0), P,D,N,\n          C = Pdisk;                           // moving sphere ( C, r )\n             \n    y = K*U.y/R.y; if ( y > 1.) return;        // R.y/K rays \n    \n    if (U.x < 1.) { O = vec4( 0, .3+.4*y, X ); return; } // init ray\n    \n    O = T(U-X);                                // ray(y) = ( P= pos, D= dir )\n    P = O.xy, D = O.zw;                        //     x = xth bounce\n\n    float ls = sphere(P,D, C,.2),              // dist to intersections\n          lb = bottom(P,D),\n          lt = top(P,D),\n           l = min(ls,min(lb,lt));             // hit = closest\n    \n    if (l<Inf) {\n        O.xy = P += l*D;                       // hit point\n        N =   l==ls ? sphereN(P,C)             // normal at hit\n            : l==lb ? bottomN(P)\n            :         topN(P);\n        O.zw = reflect(D, N);                  // new ray dir\n    }\n    else O.xy += l*D;                          // go straight\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define K 4.         // trace R.y/K rays\n\n#define T(U)   texelFetch( iChannel0, ivec2(U), 0 )\n\n#define Pdisk  ( t=iTime*.5 , iMouse.z>0. ? iMouse.xy/R.y : .5 + .3* vec2(.6*cos(t)-.3*sin(3.1*t),sin(1.31*t)-.4*cos(3.7*t)) )",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}