{
    "Shader": {
        "info": {
            "date": "1712713103",
            "description": "Relatively basic satisfying animation thingy. Somewhat based on https://tenor.com/view/slicing-satisfying-relax-animation-oddly-satisfying-gif-16548765 but not that much. Pretty happy with how it turned out :D",
            "flags": 0,
            "hasliked": 0,
            "id": "lft3Ws",
            "likes": 2,
            "name": "Satisfying Rolling Balls",
            "published": 3,
            "tags": [
                "raymarching",
                "softshadows",
                "ao",
                "satisfying"
            ],
            "usePreview": 0,
            "username": "Oman395",
            "viewed": 115
        },
        "renderpass": [
            {
                "code": "const vec3 CAM = vec3(0, 3, -2.5);\nconst float PI = 3.14159265;\nconst float FOCUS = 3.5;\n\nconst vec3 FLOOR_COLOR = vec3(255, 209, 220) / 255.0;\nconst vec3 SPINNER_COLOR = vec3(183, 255, 250) / 255.0;\n\nconst vec3 BALL_COLORS[] = vec3[](\n    vec3(237, 135, 150) / 255.0,\n    vec3(238, 153, 160) / 255.0,\n    vec3(245, 169, 127) / 255.0,\n    vec3(238, 212, 159) / 255.0,\n    vec3(166, 218, 149) / 255.0,\n    vec3(139, 213, 202) / 255.0,\n    vec3(145, 215, 227) / 255.0,\n    vec3(138, 173, 244) / 255.0\n);\n\nconst vec3 BALL_BASE_COLOR = vec3(36, 39, 58) / 255.0;\n\n// https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// This isn't ideal but it works will enough and frankly I CBA adding a mat2 system-- besides, I think this might be faster.\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTime, vec2 iMouse) {\n    return rotate(CAM, vec2(-iTime * (PI / 16.0), 0));\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return vec2(- iTime * (PI / 16.0),PI / 3.5);\n}\n\n\n// Most ray marching code \"borrowed\" from https://www.shadertoy.com/view/Xds3zN, \n// https://iquilezles.org/articles/distfunctions/, and\n// https://iquilezles.org/articles/rmshadows/\n// Inigo Quilez is the absolute most based person in existence tbh\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/sdfxor/\nfloat opXor( float a, float b ) {\n    return max( min(a,b), -max(a,b) );\n}\n\n// https://iquilezles.org/articles/smin/\n// sigmoid\nfloat smin( float a, float b, float k ) {\n    k *= log(2.0);\n    float x = b-a;\n    return a + x/(1.0-exp2(x/k));\n}\n\n// 4 grooves, equal angles apart. We only need 4 because they cover both sides.\nfloat sdGrooves(vec3 p, float theta) {\n    float d = sdCylinder(p.yxz, vec2(0.15, 1000.0));\n    \n    for(float theta = PI / 4.0; theta < PI; theta += PI / 4.0) {\n        d = smin(d, sdCylinder(rotate(p, vec2(theta, 0)).yxz, vec2(0.15, 1000.0)), 0.01);\n    }\n    \n    return d;\n}\n\n// x is distance, y is current facing angle (used for rendering the spinning effect)\nvec2 sdBall(vec3 p, float pos, float startAngle) {\n    // Logic for negatives allows for easier empty start\n    if(pos > 0.0) pos = mod(pos, 12.0);\n    // Basically, we're just rotating where the ball should be\n    // It starts by just travelling along the x axis,\n    vec3 currentPos = vec3(4.0 - pos, 0, 0);\n    // Then rotates to fit its start axis,\n    currentPos = rotate(currentPos, vec2(startAngle, 0));\n    float angle = startAngle;\n    if(pos >= 3.0 && pos <= 5.0) {\n        // If it should be rotating with the center spinner, it does so,\n        currentPos = rotate(currentPos, vec2(-pos * PI / 4.0 + 3.0 * PI / 4.0, 0));\n        angle += -pos * PI / 4.0 + 3.0 * PI / 4.0;\n    } else if(pos >= 5.0) {\n        // Otherwise it will just rotate to its end axis.\n        currentPos = rotate(currentPos, vec2(-PI / 2.0, 0));\n        angle -= PI / 2.0;\n    }\n    \n    return vec2(\n        sdSphere(p - currentPos, 0.15),\n        angle\n    );\n}\n\n// x is distance, y is angle, and z is the index of the closest sphere (for coloring)\nvec3 sdBalls(vec3 p, float time) {\n    // 8 balls, each offset to fit all 8 directions. We need to add the index to the time so that they are staggered.\n    vec2 dData = sdBall(p, time, 0.0);\n    int nearest = 0;\n    int i = 1;\n    for(float theta = PI / 4.0; theta < 2.0 * PI; theta += PI / 4.0, i++) {\n        vec2 nd = sdBall(p, time + float(i), theta);\n        if(nd.x < dData.x) {\n            dData = nd;\n            nearest = i;\n        }\n    }\n\n    return vec3(dData, nearest);\n}\n\nvec3 map(vec3 p) {\n    // Offset with a constant negative so that we don't start with balls in the center\n    // sdBall only runs the modulus when the time value is greater than 0, so this works\n    float time = iTime - 7.0;\n\n    // Start with a base plane\n    float d = sdPlane(p, vec3(0,1,0), 0.0);\n    // Subtract a cylinder, smoothly so that we get nice curves, as well as making the resulting values closer to a true SDF\n    // see https://iquilezles.org/articles/interiordistance/ to learn more, it's not exactly the same but it's the same problem\n    d = -smin(sdCylinder(p - vec3(0,-0.2,0), vec2(1.02, 0.2)),-d, 0.05);\n    // Subtract our groves, again with a bit of smoothing for the reasons discussed above\n    d = -smin(sdGrooves(p, 0.0),-d, 0.01);\n    int inter = 1;\n    float angle = 0.0;\n    // Next, we need to render the center cylinder\n    // We start with a nice simple cylinder, subtracting a small value to round it (expanding it in all axis by 0.04)\n    float dCenterCylinder = sdCylinder(p - vec3(0, -0.2, 0), vec2(0.98, 0.28)) - 0.02;\n    // We can then subtract (smoothly, of course) a cylinder from it. Note the speed and offset of the rotation; this is set\n    // to precisely align with the balls.\n    dCenterCylinder = -smin(sdCylinder(rotate(p, vec2(time * PI / 4.0  - 3.0 * PI / 4.0, 0)).yxz, vec2(0.15, 1000.0)), -dCenterCylinder, 0.01);\n    \n    if(dCenterCylinder < d) {\n        d = dCenterCylinder;\n        inter = 0;\n    }\n    \n    vec3 dBalls = sdBalls(p, time);\n    if(dBalls.x < d) {\n        d = dBalls.x;\n        angle = dBalls.y;\n        // The index value given needs to be offset by 2 in order to be used for coloring\n        inter = 2 + int(dBalls.z);\n    }\n\n    return vec3(d, angle, inter);\n}\n\nvec3 march( in vec3 ro, in vec3 rd, float mint, float maxt) {\n    float t = mint;\n    // We need to store some data about the most recent hit, so we can do coloring and such\n    int mostRecent = -1;\n    float angle = 0.0;\n    // Skip down to the lowest possible y\n    t += (0.15 - ro.y) / rd.y;\n    // 64 chosen for decent enough results compared to performance\n    for(int i=0; i<64 && t<maxt; i++) {\n        vec3 ma = map(ro + t*rd);\n        float h = ma.x;\n        mostRecent = int(ma.z);\n        angle = ma.y;\n        t += h;\n        if(t>maxt ) {\n            // If we don't hit anything, we don't care about the nearest data\n            // It should be noted that this is impossible in the current scene, but I left it in because I know there's a 99% chance\n            // I'll forget to add it back in if it's ever possible\n            return vec3(\n                t,\n                -1,\n                -1\n            );\n        }\n        if(h < mint) break;\n    }\n    return vec3(\n        t,\n        mostRecent,\n        angle\n    );\n}\n\n\n// Lighting stuff\n// https://iquilezles.org/articles/rmshadows/\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ) {\n    float res = 1.0;\n    float t = mint;\n    int mostRecent = -1;\n    // 32 also chosen for good performance/quality, specifically in this scene.\n    for(int i=0; i<32 && t<maxt; i++) {\n        float h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        // The extra condition allows us to break out early if we're above the maximum possible height of the scene\n        if( res<-1.0 || t>maxt || (ro.y + t * rd.y > 0.3 && rd.y > 0.0)) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// Based on code found on a discord server lmfao\nfloat ao(vec3 ro, vec3 norm, float stepSize, int stepCount) {\n\tfloat res = 0.0;\n\tvec3 rp;\n\t// TBH I like vaguely understand how this works but not enough to explain it\n\tfor(int i = 1; i< stepCount; i++) {\n\t\trp = ro + stepSize * float(i) * norm;\n\t\tres += (1.0/pow(2.0,float(i)))*(stepSize*float(i)-(map(rp).x));\n\t}\n\tif(res >= 0.0) {\n\t\treturn 1.0 - clamp(1.0 - stepSize / res, 0.0, 1.0);\n\t}\n    else return 1.0;\n}\n\n// Tetrahedron normals from https://iquilezles.org/articles/normalsSDF/\nvec3 normal( in vec3 p ) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nfloat mapT(vec3 p) {\n    return texture(iChannel0, p.xz ).r - p.y;\n}\n\nvec3 normalTex( in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*mapT( p + k.xyy*h ) + \n                      k.yyx*mapT( p + k.yyx*h ) + \n                      k.yxy*mapT( p + k.yxy*h ) + \n                      k.xxx*mapT( p + k.xxx*h ) );\n}\n\n// https://github.com/glslify/glsl-specular-beckmann/blob/master/distribution.glsl\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\n// https://github.com/glslify/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float x = 2.0 * NdotH / VdotH;\n  float G = min(1.0, min(x * VdotN, x * LdotN));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\n// https://github.com/glslify/glsl-specular-ward\nfloat wardSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  vec3 fiberParallel,\n  vec3 fiberPerpendicular,\n  float shinyParallel,\n  float shinyPerpendicular) {\n\n  float NdotL = dot(surfaceNormal, lightDirection);\n  float NdotR = dot(surfaceNormal, viewDirection);\n\n  if(NdotL < 0.0 || NdotR < 0.0) {\n    return 0.0;\n  }\n\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  float NdotH = dot(surfaceNormal, H);\n  float XdotH = dot(fiberParallel, H);\n  float YdotH = dot(fiberPerpendicular, H);\n\n  float coeff = sqrt(NdotL/NdotR) / (4.0 * PI * shinyParallel * shinyPerpendicular); \n  float theta = (pow(XdotH/shinyParallel, 2.0) + pow(YdotH/shinyPerpendicular, 2.0)) / (1.0 + NdotH);\n\n  return coeff * exp(-2.0 * theta);\n}\n\n// https://github.com/glslify/glsl-diffuse-oren-nayar/blob/master/index.glsl\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nvec3 calculateIncomingLight(vec3 pos, vec3 rayDir, vec3 impactPos, vec3 impactNormal, vec3 lightPos, vec3 color, vec3 specularColor, float roughness, float diffuse, float lightEnergy) {\n    vec3 impactToLight = normalize(lightPos - impactPos);\n    vec3 incomingLight = color * orenNayarDiffuse(impactToLight, normalize(pos - impactPos), impactNormal, roughness, diffuse); // kd\n    incomingLight += specularColor * cookTorranceSpecular(impactToLight, normalize(pos - impactPos), impactNormal, roughness, 0.5); // ks\n    incomingLight /= pow(distance(impactPos, lightPos) / 5.0, 2.0); // Inverse square law, 5.0 scaling factor is what I found to look nice\n    incomingLight *= lightEnergy;\n    incomingLight *= softShadow(impactPos, impactToLight, 0.1, distance(impactPos, lightPos), 0.5);\n\n    incomingLight += 0.6 * color * (0.75 + 0.25 * pow(ao(impactPos, impactNormal, 0.05, 6), 0.5)); // ka, 0.25 intensity of AO I found to look nice\n    \n    return incomingLight;\n}\n\nvoid calculateBallMaterial(vec3 impactNormal, vec3 impactData, out vec3 color, out vec3 specularColor, out float roughness, out float diffuse) {\n    float angle = iTime * PI;\n    \n    vec3 nTest = rotate(impactNormal, vec2(-impactData.z - PI / 2.0, 0));\n    nTest = rotate(nTest, vec2(0, angle));\n    bool face;\n    // We want every other ball to be a fancy baseball kinda thing. \"face\" is whether or not we're on the shiny side.\n    // I found x^2+z<0.5 to give a nice result for the baseball style stuff, but there's probably better ways available.\n    if((int(impactData.y) - 2) % 2 == 0) face = nTest.x * nTest.x + nTest.z < 0.5;\n    else face = dot(nTest, vec3(0,0,1)) < 0.0;\n    if(face) {\n        color = BALL_COLORS[(int(impactData.y) - 2) % 8];\n        roughness = 0.2;\n        diffuse = 0.5;\n        specularColor = color * 0.5;\n    } else {\n        color = BALL_BASE_COLOR;\n        roughness = 1.0;\n        diffuse = 1.0;\n        specularColor = vec3(0);\n    }\n}\n\nvec3 calculateIncomingLightWithObjects(vec3 pos, vec3 rayDir, vec3 impactPos, vec3 impactNormal, vec3 lightPos, float lightEnergy, vec3 impactData) {\n    vec3 color;\n    float roughness, diffuseAlbedo;\n    vec3 specular;\n    if(impactData.y == 0.0) {\n        color = SPINNER_COLOR;\n        roughness = 0.02;\n        diffuseAlbedo = 1.0;\n        specular = vec3(1);\n    } else if(impactData.y == 1.0) {\n        color = FLOOR_COLOR;\n        roughness = 1.0;\n        diffuseAlbedo = 1.0;\n        specular = vec3(0);\n        if(impactPos.y >= -0.01) {\n            vec3 nt = normalTex(impactPos);\n            vec3 axis = normalize(cross(nt, vec3(0,1,0)));\n            if(axis.x >= 0.0 || axis.x <= 0.0) {\n                mat4 rotateToNormal = rotationMatrix(axis, 0.1 * acos(dot(vec3(0,1,0),nt)));\n                impactNormal = (vec4(impactNormal, 0) * rotateToNormal).xyz;\n            }\n        }\n    } else {\n        calculateBallMaterial(impactNormal, impactData, color, specular, roughness, diffuseAlbedo);\n    }\n    return calculateIncomingLight(pos, rayDir, impactPos, impactNormal, lightPos, color, specular, roughness, diffuseAlbedo, lightEnergy);\n}\n\n// https://github.com/dmnsgn/glsl-tone-map/blob/main/aces.glsl\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 getLight(vec3 pos, vec3 rayDir) {\n    vec3 light = vec3(1, 1, 0);\n    vec3 impactData = march(pos, rayDir, 0.001, 100.0);\n    float energy = 0.3;\n    vec3 impactPos = pos + rayDir * impactData.x;\n    vec3 impactNormal = normal(impactPos);\n    vec3 incomingLight = vec3(1);\n    if(impactData.y >= 0.0) incomingLight = calculateIncomingLightWithObjects(pos, rayDir, impactPos, impactNormal, light, energy, impactData);\n    return aces(incomingLight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    vec3 light = getLight(pos, rayDir);\n    fragColor = vec4(light, 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}