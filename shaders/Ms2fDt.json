{
    "Shader": {
        "info": {
            "date": "1502900533",
            "description": "Attempting to implement clouds as described in \"Real-Time Cloud Rendering\"  paper by Mark Harris and Anselmo Lastra, 2001. I may or may have not implemented it correctly.... though clouds look plausible imho.  It is also rather slow.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ms2fDt",
            "likes": 6,
            "name": "AlexM Cloud Test 1",
            "published": 3,
            "tags": [
                "clouds"
            ],
            "usePreview": 0,
            "username": "AlexM",
            "viewed": 906
        },
        "renderpass": [
            {
                "code": "// Attempting to implement clouds as described in \"Real-Time Cloud Rendering\" \n// paper by Mark Harris and Anselmo Lastra, 2001.\n// I may or may have not implemented it correctly.... though clouds plausible imho. \n// It is also rather slow - probably scaling noise in a bad way or something. \n\n#define PI 3.141592653589793 \n\nconst float MAXT = 150.0f;\nconst float FOGHEIGHT = 0.40; // background fog height. \nconst float FOGFADEHEIGHT = 0.60; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.839, 1, 0.980);\nconst float FOGDENSITY = 0.009; \nconst float FOGPOWER = 3.0;\n\nconst vec3  SUNDIRECTION = normalize(vec3(-1.0, -0.6, -0.9)); //direction of the sunlight\nconst vec3  SUNCOLOR =vec3(0.885, 0.980, 0.980); // sun color? \nconst vec3  SKYCOLOR = vec3(0.513, 0.882, 0.945);\n\n// colors for scene objects...\nconst vec3 TILE1_COLOR  = vec3(0.6);\nconst vec3 TILE2_COLOR  = vec3(0.8);\n\nconst vec3 CLOUD_ALBEDO = vec3(1.0);\nconst float CLOUDTRACE_NUMSTEPS = 20.0; // number of cloud samples. \nconst float CLOUDTRACE_STEPSIZE = 0.1;  // spacing of cloud samples.\n\n\nstruct TraceResult {\n    bool  hit;\n    float rayt;\n    float materialID;\n};\n\n// transformation funcs\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nmat3 rotateZ(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3(a, -b, 0.0, b, a, 0.0, 0.0, 0.0, 1.0);\n}\n\n// NOISE FUNCTIONS\nfloat random(in vec3 st) { \n    return fract(sin(dot(st,vec3(12.9898,78.233,19.124)))*43758.5453);\n}\n\nfloat noise(in vec3 st) {\n    vec3 i = floor(st);\n    vec3 x = fract(st);\n    vec3 u = x*x*(3.0-2.0*x);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n    float fa = mix(a, b, u.x);\n    float fb = mix(c, d, u.x);\n    float fc = mix(e, f, u.x);\n    float fd = mix(g, h, u.x);\n    float fe = mix(fa, fb, u.y);\n    float ff = mix(fc, fd, u.y);\n    float fg = mix(fe, ff, u.z);\n    return clamp(2.0*fg-1.0, -1.0, 1.0);\n}\n\nfloat fbm(vec3 p, int oct) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.5;\n\n    for (int i = 0; i < oct; i++) {\n        value += amplitude * noise(p*frequency);\n        p *= 2.;\n        amplitude *= 0.45;\n        frequency *= 1.2;\n    }\n    return value;\n}\n\n// Some primitives and CSG ops.\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,vec3(0.0)));\n}\nfloat sdPlane(vec3 p, vec4 n) { return dot(p, n.xyz) - n.w; }\nfloat opAdd(float d1, float d2) { return min(d1, d2); }\nfloat opSubtract( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat clouds(vec3 p) {\n    float f;\n    f = (sdBox(p, vec3(9000.0, 1.35, 9000.0)));\n    f -= noise(p * 0.4)*0.5+0.5;\n    f = opSubtract(noise((p+vec3(iTime*0.8, 0.0, 0.0))*0.12+iTime*0.02)*0.8, f);\n    f -= fbm(p*0.7+iTime*0.1, 2) *0.15;\n    return f;\n}\n\nfloat map(vec3 p, out float mattype) {\n    mattype = 1.0;\n    float cl = clouds(p);\n    float pl = sdPlane(p, vec4(0.0, 1.0, 0.0, -20.0));\n    float f = opAdd(cl,pl);\n    if (f == pl) mattype = 2.0;\n    return f;\n}\n\nfloat map(vec3 p) { float unused; return map(p, unused); }\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    TraceResult traceResult = TraceResult(false, 0.0, 0.0);\n    float t = 0.02;\n    float tmax = MAXT; \n    float mattype;\n\n    for (; t < MAXT; ) {\n        vec3 rp = ro + rd * t;\n        float tr = map(rp, mattype);\n        if (tr<0.0001) {\n            traceResult = TraceResult(true, t, mattype);\n            break;\n        }\n        t += tr;\n    }\n    traceResult.rayt = t;\n    return traceResult;\n}\n\n//@ro - cloud starting position.\n//@rd - view direction\n//@ld - light direction \nvec3 traceCloud(vec3 ro, vec3 rd, vec3 ld) {\n    float a = 1.118;  // transparency constant - each particle in the cloud will have this transparency.\n    float b = 0.056;  // distance field- dependent transparency.\n    float c = 0.896;  // air transparency;\n\n    vec3 albedo = CLOUD_ALBEDO; \n    // phase functions for forward scattering and eye scattering, respectively\n    float ph1 = 3.0/4.0*(cos(PI)*cos(PI)+1.0);\n    float ph2 = 3.0/4.0*(1.0+dot(ld,rd)*dot(ld,rd));\n\n\n    vec3 Ik = SUNCOLOR; \n    vec3 Ek = vec3(0.0); // eye scattering, initially no light is scattered...\n\n\n    const float numsteps = CLOUDTRACE_NUMSTEPS;\n    const float stepsize = CLOUDTRACE_STEPSIZE;\n\n    for (float i = stepsize; i <= stepsize*numsteps; i+=stepsize) {\n        // forward scattering\n        vec3 rp = ro+(i-stepsize)*ld;\n        float m = clouds(rp);\n        float transparency = (m<0.1) ? 1.0/(a+abs(m)*b) : c;\n        vec3 gk = albedo*transparency*Ik*ph1/(4.0*PI);\n        Ik = gk+Ik*transparency;\n\n        // compute eye scattering \n        rp = ro+stepsize*ld; \n        m = clouds(rp);\n        transparency = (m<0.01) ? 1.0/(a+abs(m)*b) : c;\n        vec3 sk = albedo*transparency*Ik*ph2/(4.0*PI);\n        Ek = sk+transparency*Ek;\n    }\n\n    // not sure if averaging is correct...! \n    return clamp((Ik+Ek)*0.5, 0.0, 1.0); \n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 eps = vec2(0.001,0.0);\n    float x = map(p+eps.xyy)-map(p-eps.xyy);\n    float y = map(p+eps.yxy)-map(p-eps.yxy);\n    float z = map(p+eps.yyx)-map(p-eps.yyx);\n    return normalize(vec3(x,y,z));\n}\n\n// softshadow function by iq. \nfloat traceShadow(vec3 ro, vec3 rd) {\n    float numsteps = 30.0;\n    float stepsize = 1.6;\n    float res = 1.0;\n    const float k = 200.0;\n\n    for (float i = 0.0; i < numsteps *stepsize; i+=stepsize) {\n        float d = map(ro+i*rd);\n        if (d < 0.001) { return 0.0; }\n        res = min( res, k*d/i );\n    }\n    return res;\n}\n\nfloat phongDiffuseFactor(vec3 l, vec3 n) {\n    return max(0.0, dot(l,n));\n}\n\nfloat phongSpecularFactor(vec3 l, vec3 n, vec3 v, float k) {\n    vec3 r = normalize(reflect(l, n));\n    return pow(max(0.0, dot(r, v)), k);\n}\n\nfloat fog(float dist, float d, float p) {\n    return  1.0 - 1.0/exp(pow(dist*d, p));\n}\n\nvec3 sky(vec3 ro, vec3 rd) {\n    vec3 color = SKYCOLOR; \n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0), pow(d, 150.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n\n    vec3 ro = vec3(iMouse.x*0.05, -18.0+iMouse.y*0.075, 0.0);\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd=rotateX(0.1)*rd;\n    rd=rotateY(-0.7)*rd;\n    rd = normalize(rd);\n    \n    vec3 color = sky(ro, rd);\n\n    TraceResult traceResult = trace(ro, rd);\n    if (traceResult.hit) {\n        vec3 rp = ro+traceResult.rayt*rd;\n        vec3 n = calcNormal(rp);\n\n        if (traceResult.materialID == 1.0) {\n            // get to cloud's start tracing position.\n            vec3 crp = rp + (-SUNDIRECTION)*CLOUDTRACE_NUMSTEPS*CLOUDTRACE_STEPSIZE*1.001;\n            color = 0.1+traceCloud(crp, rd, SUNDIRECTION);\n        }\n\n        if (traceResult.materialID == 2.0) {\n            vec3 tiles = (sin(rp.z) + sin(rp.x) <= 0.0) ? TILE1_COLOR : TILE2_COLOR;\n            vec3 sp = rp + 0.1*n;\n            float ph = phongDiffuseFactor(-SUNDIRECTION, n) \n                     + phongSpecularFactor(-SUNDIRECTION, n, rd, 10.0);\n            color = 0.5*SUNCOLOR + ph * traceShadow(sp, -SUNDIRECTION);\n            color = tiles * color;\n        }\n\n        float fg = fog(traceResult.rayt, FOGDENSITY, FOGPOWER);\n        vec3 fc = FOGCOLOR;\n        color = mix(color, fc, fg);\n    }\n\n    color = clamp(color, 0.0, 1.0);\n    fragColor = vec4(color, 1.0); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}