{
    "Shader": {
        "info": {
            "date": "1455884435",
            "description": "audio chill tracer, with SoundCloud. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4dK3Rt",
            "likes": 1,
            "name": "Audio Chill Tracer",
            "published": 3,
            "tags": [
                "blueeyeworld"
            ],
            "usePreview": 0,
            "username": "blueeyeworld",
            "viewed": 817
        },
        "renderpass": [
            {
                "code": "#define SPHERE_COUNT 128\n\n//Created by Nicky van de Groep\n//www.nickyvandegroep.com\n\n\nvec4 Light      = vec4(10.0,5.0, 0.0, 0.5);\nvec4 LightColor = vec4(1.0,1.0, 1.0, 1.0);\n\n\nvec3 CamPos, CamDirection;\n\nstruct Camera\n{\n \tvec3 pos;\n    float left;\n    float right;\n    float top;\n    float down;\n    float near;\n    float far;\n};\n    \nCamera camera = Camera(vec3(0.0,0.0,-8.0), -1.6, 1.6, 1.0, -1.0, 1.0, 1.0);\n    \nmat4 Identity()\n{\n     return mat4(\n        vec4( 1.0, 0.0, 0.0, 0.0),\n        vec4( 0.0, 1.0, 0.0, 0.0),\n        vec4( 0.0, 0.0, 1.0, 0.0),\n        vec4( 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 SetPosition(mat4 mat, vec3 pos)\n{\n    mat[3][0] = pos.x;\n    mat[3][1] = pos.y;\n    mat[3][2] = pos.z;\n    return mat;\n}\n\nmat4 rotationZYX(vec3 radiansXYZ )\n{\n    float sX, cX, sY, cY, sZ, cZ, tmp0, tmp1;\n    sX = sin( radiansXYZ[0]);\n    cX = cos( radiansXYZ[0]);\n    sY = sin( radiansXYZ[1]);\n    cY = cos( radiansXYZ[1]);\n    sZ = sin( radiansXYZ[2]);\n    cZ = cos( radiansXYZ[2]);\n    tmp0 = ( cZ * sY );\n    tmp1 = ( sZ * sY );\n    return mat4(\n        vec4( ( cZ * cY ), ( sZ * cY ), -sY, 0.0 ),\n        vec4( ( ( tmp0 * sX ) - ( sZ * cX ) ), ( ( tmp1 * sX ) + ( cZ * cX ) ), ( cY * sX ), 0.0 ),\n        vec4( ( ( tmp0 * cX ) + ( sZ * sX ) ), ( ( tmp1 * cX ) - ( cZ * sX ) ), ( cY * cX ), 0.0 ),\n        vec4(0.0, 0.0, 0.0,1.0)\n    );\n}\n\n\nfloat IntersectSphere(vec3 start, vec3 dir, vec4 sphere, out vec3 pos, out vec3 normal, out float t)\n{\n    vec3 rc = start-sphere.xyz;\n    float c = dot(rc, rc) - (sphere.w*sphere.w);\n    float b = dot(dir, rc);\n    float d = b*b - c;\n\tt = -b - sqrt(abs(d));\n    \n\tfloat st = step(0.0, min(t,d));\n    \n    pos = start + dir * t;\n    normal = pos - sphere.xyz;\n    normal = normalize(normal);\n    return mix(-1.0, t, st);\n}\n\nvec4 TraceScene(vec3 direction)\n{  \n    vec3  outpos;\n    vec3  outnormal;\n    float mint = 1000.0;\n    float k = (1.0 / float(SPHERE_COUNT));\n    \n    float halfcount = float(SPHERE_COUNT) * 0.5;\n    \n    vec4 high  = texture(iChannel0, vec2(0.7, 0.0));\n    vec4 bass1 = texture(iChannel0, vec2(0.1, 0.0));\n    \n    // camera.pos.z;\n    float t;\n    \n    vec3 FinalNormal;\n    vec3 FinalPosition;\n    vec3 FinalColor;\n    \n     mat4 mat = Identity();\n     mat *= rotationZYX(vec3(0.0,-iChannelTime[0] * 0.1, 0.0));\n     vec4 newlightpos = mat * vec4(Light.xyz ,1.0);\n      Light.xyz = newlightpos.xyz;\n    \n    \n    float res = IntersectSphere(camera.pos, direction, Light, outpos, outnormal, t);\n    if(res >= 0.0)\n    {\n        if(t < mint)\n        {\n            mint = t;\n           \tFinalNormal   = -outnormal;\n            FinalPosition = outpos;\n            FinalColor    = (LightColor * 2.0 * dot(vec3(0.0, 0.0, -1.0), outnormal)).xyz;\n        }\n    }\n    \n    for(int i = 0; i < SPHERE_COUNT; i++)\n    {\n        vec4 sound = texture(iChannel0, vec2(float(i) * k, 0.0));\n        \n        float x = -5.0 + (float(i) * k) * 10.0;\n        float y =  -4.0 + sound.x * 8.0;\n        \n        mat4 mat = Identity();\n        mat *= rotationZYX(vec3(iChannelTime[0] * 0.3, iChannelTime[0] * 0.1, 0.0));\n        vec4 newpos = mat * vec4(x, y, 0.0 ,1.0);\n        \n        if(dot(direction, normalize(camera.pos - newpos.xyz)) > -0.99){ continue; }\n        \n        float res = IntersectSphere(camera.pos, direction, vec4(newpos.xyz , 0.1 + bass1.x * 0.2), outpos, outnormal, t);\n    \tif(res >= 0.0)\n    \t{  \n           if(t < mint)\n           {\n               mint = t;\n           \t   FinalNormal   = outnormal;\n               FinalPosition = outpos;\n               FinalColor    = vec3(sound.x * direction.x * 2.0, sound.x * direction.y * 2.0, sound.z * direction.z) * 2.0; \n           }\n    \t}\n    }\n    \n    \n   \t\n    if(mint < 1000.0)\n    {\n         return vec4(FinalColor * LightColor.xyz * clamp( dot(Light.xyz - FinalPosition, FinalNormal), 0.1, 1.0) , 1.0);\n    }\n    \n    \n    \n   \t//float res = IntersectSphere(camera.pos, direction, Sphere1, outpos, outnormal);\n    //if(res >= 0.0)\n    //{\n    //   //return vec4(1.0, 1.0, 1.0, 1.0);\n    //    \n    //    return vec4(vec3(1.0, 1.0, 1.0) *dot(vec3(0.1, 0.0, -0.9), outnormal) , 1.0);\n    //}\n    return vec4(0.1,0.1,0.1,1.0);\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float x = fragCoord.x;\n    float y = fragCoord.y;\n    float width  = iResolution.x;\n    float height = iResolution.y;\n    \n    \n     vec3 pixelPos = vec3(((camera.right - camera.left) * (x + 0.5)) / width + camera.left,\n\t\t\t\t\t\t((camera.top - camera.down) * (y + 0.5)) / height + camera.down,\n\t\t\t\t\t\tcamera.pos.z + camera.near);\n    \n    \n    vec3 direction = pixelPos - camera.pos;\n\tdirection = normalize(direction);\n\n    \n    \n    vec4 Color = TraceScene(direction);\n    \n    fragColor = Color; //texture(iChannel0, vec2(uv.x)) * vec4(uv,0.5+0.5*sin(iTime), 1.0 );\n    \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 34,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}