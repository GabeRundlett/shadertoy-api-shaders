{
    "Shader": {
        "info": {
            "date": "1583273324",
            "description": "A simple water ripple effect.",
            "flags": 32,
            "hasliked": 0,
            "id": "WlVSz3",
            "likes": 18,
            "name": "Raindrops on a puddle",
            "published": 3,
            "tags": [
                "interactive",
                "water",
                "ripple"
            ],
            "usePreview": 1,
            "username": "4rknova",
            "viewed": 1397
        },
        "renderpass": [
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPSILON\t\t\t\t.25\n#define PI\t\t\t\t\t3.14159265359\n#define RADIAN\t\t\t\t180.0 / PI\n#define SIZE                (42.)\n#define RMARCH_MAX_STEPS \t25\n\nfloat des_sphere(vec3 p, float r) { return length(p) - r; }\nfloat deu_box\t(vec3 p, vec3  b) { return length(max(abs(p)-b,0.0)); }\nvec3  translate (vec3 v, vec3  t) { return v - t; }\n\nconst float cCamera_fov = 60.0;\n\nstruct Camera\t{ vec3 p, t, u; };\nstruct Ray\t\t{ vec3 o, d; };\n\t\nvoid generate_ray(vec2 uv, Camera c, out Ray r)\n{\n\tr.o = c.p;\n\tr.d = normalize(vec3(uv.x, uv.y, 1.0 / tan(cCamera_fov * 0.5 * RADIAN)));\n\t\n\tvec3 cd = c.t - c.p;\n\n\tvec3 rx,ry,rz;\n\trz = normalize(cd);\n\trx = normalize(cross(rz, c.u));\n\try = normalize(cross(rx, rz));\n\t\n\tmat3 tmat = mat3(rx.x, rx.y, rx.z,\n\t\t\t  \t\t ry.x, ry.y, ry.z,\n\t\t\t\t\t rz.x, rz.y, rz.z);\n\n\t\n\tr.d = normalize(tmat * r.d);\n}\n\nfloat scene_distance(vec3 p)\n{\n    vec2 uv = 0.5*(p.xz/SIZE+1.);\n\tvec3 res = texture(iChannel0, uv).xyz;\n    float d = dot(res, vec3(0,1,0));\n\treturn deu_box(p + vec3(0,d,0), vec3(SIZE,5,SIZE));\n}\n\nvec3 scene_normal(vec3 pos, float d)\n{\n    vec3 n;\n\t\n\t// Gradient via Forward differencing\n    n.x = scene_distance(vec3(pos.x + EPSILON, pos.y, pos.z));\n    n.y = scene_distance(vec3(pos.x, pos.y + EPSILON, pos.z));\n    n.z = scene_distance(vec3(pos.x, pos.y, pos.z + EPSILON));\n\t\n    return normalize(n - d);\n}\n\nvec3 scene_shade(vec3 v, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.5, 0.7, 0.9);\n    \n    vec3 d = texture(iChannel1, reflect(v, n)).xyz;\n    col *= vec3(d);\n    \n    return col;\n}\n\nbool rmarch(Ray r, out vec3 p, out vec3 n, out int iter)\n{\n\tp = r.o;\n\tvec3 pos = p;\n\tfloat d = 1.;\n\n\tfor (int i = 0; i < RMARCH_MAX_STEPS; i++) {\n\t\titer = i;\n\n\t\td = scene_distance(pos);\n\n\t\tif (d < EPSILON) {\n\t\t\tp = pos;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tpos += d * r.d;\n\t}\n\t\n\tn = scene_normal(p, d);\t\n\treturn d < EPSILON;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 nv = (fragCoord.xy / iResolution.xy);\t\n    \n    \n    vec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n        * vec2(iResolution.x / iResolution.y, 1);\t\n\n    Camera c;\n    c.p = vec3(20, 18, 14);\n    c.t = vec3(-6, -4, 10);\n    c.u = vec3(0, 1, 0); \n   \n\n    Ray r;\n    generate_ray(uv, c, r);\n\n    vec3 col = texture(iChannel1, normalize(r.d)).xyz;    \n    \n    vec3 sp, sn;\n    int iter = RMARCH_MAX_STEPS;\t\n    bool res = rmarch(r, sp, sn, iter);\n\n\n    if (res) {\n        col = scene_shade(r.d, sp, sn);    \n    }\n\n \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// by Nikos Papadopoulos, 4rknova / 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define STRENGTH     (3.50)\n#define MODIFIER     (0.99)\n#define STEP         (2.50)\n\n#define S(e) (texture(iChannel0, p+e).x) // Sample\n\nvec3 getPos()\n{\n  \tfloat t = iTime*4.0;\n    vec2  s = fract(floor(t)*vec2(0.456665,0.708618))*iResolution.xy;\n    return vec3(s, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.;\n    vec2  p = gl_FragCoord.xy / iResolution.xy;\n    vec4  c = texture(iChannel0, p);\n   \tvec3  e = vec3(vec2(STEP)/iResolution.xy,0.);\n   \tfloat s0 = c.y, s1 = S(-e.zy)\n        , s2 = S(-e.xz)\n        , s3 = S(e.xz)\n        , s4 = S(e.zy);\n\n   \tvec3 pos = getPos();\n \tif (pos.z > 0.5) d = STRENGTH * smoothstep(3.,0.5,length(pos.xy - gl_FragCoord.xy));\n\n   \t// Calculate new state\n   \td += -(s0 - .5) * 2. + (s1 + s2 + s3 + s4 - 2.);\n   \td *= MODIFIER;\n    d *= smoothstep(0.,1.,float(iFrame >= 60)); // Clean buffer at startup\n    d = d * 0.5 + 0.5;\n \tfragColor = vec4(d, c.x, 0, 0); // Save current and previous state    \n}\n   ",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}