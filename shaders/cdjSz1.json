{
    "Shader": {
        "info": {
            "date": "1669913382",
            "description": "Bird flying over Voronoi-based rural landscape",
            "flags": 0,
            "hasliked": 0,
            "id": "cdjSz1",
            "likes": 47,
            "name": "Voronoi Farms",
            "published": 3,
            "tags": [
                "voronoi",
                "landscape",
                "field",
                "bird",
                "flight"
            ],
            "usePreview": 1,
            "username": "dr2",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "// \"Voronoi Farms\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n/*\n  Note how the patterns and buildings are aligned relative to\n  the ground slope; mousing may be needed fo find bird.\n\n  No. 52 in \"Voronoi\" series - listed at end\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct VVec {\n  vec2 d;\n  float r;\n};\nVVec vVec[7];\n\nmat3 flyerMat;\nvec4 vVal;\nvec3 flyerPos, sunDir, qHit, trkAx, trkFx, trkAy, trkFy;\nvec2 gVec[7], hVec[7], ipp, csCen;\nfloat tCur, dstFar, gScale, szFacFl, fGrnd, wngAng, bkAng;\nint idObj;\nconst int nwSeg = 5;\nconst int idGrnd = 1, idWall = 2, idHut = 3, idTree = 4, idLeaf = 5, idBdy = 6, idTail = 7, \n   idEye = 8, idBk = 9, idWing = 10, idWTip = idWing + nwSeg - 1;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{  // (from \"Painted Bird\")\n  vec3 q;\n  float wSeg, wChord, wSpar, fTap, bkLen, dMin, d, a, wr, wf, ws, ww;\n  wSeg = 0.15;\n  wChord = 0.3;\n  wSpar = 0.02;\n  fTap = 8.;\n  bkLen = 0.2;\n  dMin = dstFar / szFacFl;\n  p = flyerMat * (p - flyerPos) / szFacFl;\n  q = p;\n  q.z -= 0.5;\n  q.x = abs (q.x) - 0.1;\n  a = wngAng;\n  wf = 1.;\n  ws = 0.02 * wChord;\n  for (int k = 0; k < nwSeg; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSeg;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSeg));\n    ww = ws - 0.01 * (q.z / wChord) * (q.z / wChord);\n    q.z += 0.4 * wr * wChord;\n    if (k < nwSeg - 1) {\n      d = length (max (abs (vec3 (q.xz, q.y - 0.5 * ww).xzy) - vec3 (wSeg, ww, wr * wChord),\n         0.)) - wr * wSpar;\n      q.x -= wSeg;\n      DMINQ (idWing + k);\n    } else {\n      q.x += wSeg;\n      d = max (length (abs (max (vec2 (length (q.xz) - wr * wChord,\n         abs (q.y - 0.5 * ww) - ww), 0.))) - wr * wSpar, - q.x);\n      DMINQ (idWTip);\n    }\n    q.z -= 0.4 * wr * wChord;\n    a *= 1.03;\n    wf *= (1. - 1. / fTap);\n    ws *= 0.8 * (1. - 1. / fTap);\n  }\n  q = p;\n  wr = q.z - 0.5;\n  if (wr > 0.) {\n    wr = 0.17 - 0.44 * wr * wr;\n  } else {\n    wr = clamp (0.667 * wr, -1., 1.);\n    wr *= wr;\n    wr = 0.17 - wr * (0.34 - 0.18 * wr); \n  }\n  d = PrCapsDf (q, wr, 1.);\n  DMINQ (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (q.z + 1.) * (q.z + 1.);\n  q -= vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCapsDf (q, 0.009, 0.2);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.07, 0.05, 0.9);\n  d = PrSphDf (q, 0.04);\n  DMINQ (idEye);\n  q = p;\n  q -= vec3 (0., -0.015, 1.15);\n  q.yz = Rot2D (vec2 (abs (q.y), q.z + 0.8 * bkLen), bkAng);\n  q.z -= 0.8 * bkLen;\n  wr = clamp (0.4 - 0.3 * q.z / bkLen, 0., 1.);\n  d = max (abs (length (max (abs (q) - vec3 (0., 0.25 * wr * bkLen, bkLen), 0.)) -\n     0.25 * wr * bkLen) - 0.002, - q.y);\n  DMINQ (idBk);\n  return 0.8 * szFacFl * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec3 col, c1, c2, c3;\n  float a, r, s, t, sx, spec;\n  spec = 0.2;\n  c1 = vec3 (0.9, 0.8, 0.8);\n  c2 = vec3 (0.3, 0.3, 0.8);\n  c3 = vec3 (0.1, 0.3, 0.1);\n  if (idObj == idEye) {\n    col = vec3 (0., 0., 1.);\n    spec = -1.;\n  } else if (idObj == idBdy || idObj == idTail) {\n    a = atan (abs (qHit.x), qHit.y) / pi;\n    col = mix (c3, mix (c1, c2, smoothstep (0.5, 0.7, a)), smoothstep (0.1, 0.3, a));\n    if (idObj == idBdy && qHit.z > 0. && length (max (abs (vec2 (qHit.x, qHit.y + 0.017)) -\n       vec2 (0., 0.035), 0.)) < 0.025) col = vec3 (1., 0.7, 0.2);\n  } else if (idObj == idBk) {\n    col = vec3 (0.9, 0.4, 0.1);\n  } else if (idObj >= idWing && idObj <= idWTip) {\n    col = (qHit.y > -0.006) ? c3 : c2;\n    t = 0.3 * float (idObj - idWing);\n    sx = 6.66 * qHit.x - 0.52;\n    if (idObj < idWTip || idObj == idWTip && qHit.x < 0.075) col = mix (col, c1, smoothstep (0.,\n       0.01, qHit.z - 0.54 * (abs (cos (pi * sx)) - 0.5) * (1. - 0.4 * t)));\n    r = (length (qHit.xz) - 0.165);\n    a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n    t = 0.11 * (qHit.x + t) - 0.29;\n    s = (idObj < idWTip) ? step (0., qHit.z + t) * (1. - smoothstep (0.1, 0.2, fract (8. * sx))) :\n       step (0.021, r) * smoothstep (0.8, 0.9, fract (64. * a));\n    col *= 1. - 0.2 * s;\n    s = (idObj == idWTip) ? smoothstep (0., 0.005, r) * (1. - smoothstep (0.3, 0.4, fract (32. * a))) :\n       (1. - smoothstep (0.01, 0.016, qHit.z - t)) * smoothstep (0.6, 0.7, fract (4. * sx));\n    col = mix (col, c1, s);\n  }\n  return vec4 (col, spec);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvoid SetVorp (vec2 ip)\n{\n  vec2 u;\n  ipp = ip;\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    vVec[k].d = hVec[k] + 0.5 * (0.4 + 0.6 * u.x) * sin (2. * pi * (u.y - 0.5) +\n       vec2 (0.5 * pi, 0.));\n    vVec[k].r = Hashfv2 (u);\n  }\n}\n\nvec4 HexVor (vec2 fp)\n{\n  vec4 sd;\n  vec2 d, dm;\n  float r;\n  sd = vec4 (4.);\n  dm = vec2 (4.);\n  for (int k = VAR_ZERO; k < 7; k ++) {\n    d = vVec[k].d - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      dm = d;\n      r = vVec[k].r;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, dm, r);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float f, a, aSum;\n  p *= 0.01;\n  f = 0.;\n  a = 1.;\n  aSum = 0.;\n  for (int j = 0; j < 3; j ++) {\n    f += a * Noisefv2 (p);\n    aSum += a;\n    a *= 0.4;\n    p *= 2.5;\n  }\n  return 40. * f / aSum;\n}\n\nfloat VObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 u, pCen, pp, ip;\n  float dMin, d, db, h;\n  dMin = dstFar;\n  pp = p.xz / gScale;\n  ip = PixToHex (pp);\n  if (ipp != ip) SetVorp (ip);\n  vVal = HexVor (pp - HexToPix (ip));\n  pCen = (pp + vVal.yz) * gScale;\n  h = GrndHt (pCen);\n  u = vec2 (GrndHt (pCen + vec2 (0., 0.1)), GrndHt (pCen + vec2 (0.1, 0.))) - h;\n  csCen = sin (atan (u.y, u.x) + vec2 (0.5 * pi, 0.));\n  q = p;\n  q.y -= GrndHt (p.xz);\n  d = q.y;\n  DMIN (idGrnd);\n  d = length (max (abs (vec2 (abs (vVal.x - 0.1), abs (q.y - 0.15))) -\n     vec2 (0., 0.15), 0.)) - 0.03;\n  DMIN (idWall);\n  q = p;\n  q -= vec3 (pCen, h).xzy;\n  q.xz = Rot2Cs (q.xz, csCen);\n  d = max (PrRoundBox2Df (q.xz, vec2 (0.4, 0.2), 0.05), dot (vec2 (q.y, - abs (q.z)),\n     sin (-0.25 * pi + vec2 (0.5 * pi, 0.))) - 0.5);\n  DMINQ (idHut);\n  q.xz -= vec2 (sign (vVal.w - 0.5), 0.7);\n  d = max (length (q.xz) - 0.07, q.y - 1.);\n  DMINQ (idTree);\n  d = PrConCapsDf ((q - vec3 (0., 1., 0.)).xzy, sin (0.08 * pi + vec2 (0.5 * pi, 0.)), 0.17, 0.3);\n  DMINQ (idLeaf);\n  return 0.8 * dMin;\n}\n\nfloat VObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    d = VObjDf (p);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 VObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = VObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat VObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = VObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.01 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y + 0.1 * tCur) - 0.1) * rd.y, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, qHitT;\n  vec2 vf, u;\n  float dstObj, dstObjF, sh, f, nDotL;\n  int idObjT;\n  wngAng = -0.03 * pi * (1. + 2. * cos (pi * tCur));\n  bkAng = 0.02 * pi * (1. + sin (3. * pi * tCur));\n  HexVorInit ();\n  ipp = vec2 (-999.);\n  vf = vec2 (0.);\n  dstObjF = ObjRay (ro, rd);\n  idObjT = idObj;\n  qHitT = qHit;\n  dstObj = VObjRay (ro, rd);\n  sh = 1.;\n  if (dstObj < min (dstObjF, dstFar)) {\n    ro += dstObj * rd;\n    vn = VObjNf (ro);\n    f = smoothstep (0.2, 0.4, dstObj / dstFar);\n    if (idObj == idWall) {\n      col4 = vec4 (0.7, 0.7, 0.75, 0.) * mix (0.85 + 0.15 * smoothstep (0.4, 0.5,\n         Noisefv3 (16. * vec3 (1., 1., 2.) * ro.xzy)), 0.9, f);\n      vf = vec2 (16., 8.);\n    } else if (idObj == idGrnd) {\n      if (vVal.x < 0.1) {\n        col4 = vec4 (1., 1., 0.5, 0.) * mix (0.7 + 0.3 * Fbm2 (32. * ro.xz), 0.75, f);\n        vf = vec2 (32., 1.);\n      } else {\n        u = Rot2Cs (vVal.yz * gScale, csCen);\n        if (min (PrRoundBox2Df (u, vec2 (0.4, 0.2) - 0.02, 0.02),\n           length (u + vec2 (sign (vVal.w - 0.5), 0.7))) < 0.12) {\n          col4 = vec4 (0.7, 0.7, 0.6, 0.) * (0.5 + 0.5 * Fbm2 (128. * ro.xz));\n          vf = vec2 (32., 1.);\n        } else {\n          col4 = vec4 (HsvToRgb (vec3 (0.15 + 0.25 * vVal.w, 0.9, 1.)), 0.);\n          col4 *= mix (0.85 + 0.15 * sin (fGrnd * dot (ro.zx, csCen)), 0.92,\n             max (f, 1. - smoothstep (0.2, 0.3, - dot (rd, vn))));\n          vf = vec2 (8., 2.);\n        }\n      }\n    } else if (idObj == idHut) {\n      col4 = vec4 (HsvToRgb (vec3 (mod (0.9 + 0.25 * vVal.w, 1.), 0.8, 1.)), 0.1);\n      if (vn.y < 0.01) col4 = mix (vec4 (0.8, 0.7, 0., -1.), col4, smoothstep (0., 0.01,\n         PrRoundBox2Df (vec2 (((abs (qHit.x) < 2. * abs (qHit.z)) ? abs (qHit.x) - 0.18 : qHit.z),\n         qHit.y - 0.25), vec2 (0.1, 0.07), 0.01)));\n      else col4.rgb = mix (col4.rgb, vec3 (1.), 0.5);\n      vf = vec2 (32., 0.1);\n    } else if (idObj == idTree) {\n      col4 = vec4 (0.6, 0.2, 0., 0.);\n      vf = vec2 (32., 0.5);\n    } else if (idObj == idLeaf) {\n      col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.15 * (1. - vVal.w), 1., 0.8)), 0.);\n      vf = vec2 (16., 4.);\n    }\n    sh = VObjSShadow (ro + 0.01 * vn, sunDir);\n    sh = min (sh, 0.6 + 0.4 * smoothstep (0., 0.2, Fbm2 (0.04 * ro.xz - 0.05 * tCur) - 0.4));\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y * (1. - f));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else if (dstObjF < dstFar) {\n    dstObj = dstObjF;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n    idObj = idObjT;\n    qHit = qHitT;\n    col4 = ObjCol ();\n    sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n  } else col = SkyCol (rd);\n  if (dstObj < dstFar) {\n    if (col4.a >= 0.) col = col4.rgb * (0.3 + 0.7 * sh * nDotL) +\n       col4.a * step (0.95, sh) * sh * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    else col = col4.rgb * (0.2 + 0.8 * max (- dot (rd, vn), 0.));\n    col = mix (col, SkyCol (rd), smoothstep (0.8, 1., dstObj / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), abs (dot (trkAy, sin (trkFy * t))), t);\n}\n\nvec3 TrackDir (float t)\n{\n  return vec3 (dot (trkFx * trkAx, cos (trkFx * t)), dot (trkFy * trkAy, cos (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (dot (trkFx * trkFx * trkAx, - sin (trkFx * t)), 0., 0.);\n}\n\nvoid FlyerPM (float t, float vu, out vec3 flPos, out mat3 flMat)\n{\n  vec3 vel, va, ori, ca, sa;\n  float el, az, rl;\n  flPos = TrackPath (t);\n  vel = TrackDir (t);\n  el = (vu != 0.) ? 0. : -0.2 * sign (vu);\n  el -= ((vu == 0.) ? 1. : 0.3) * asin (vel.y / length (vel));\n  az = atan (vel.z, vel.x) - 0.5 * pi;\n  va = cross (TrackAcc (t), vel) / length (vel);\n  rl = ((vu == 0.) ? 10. : 3.) * length (va) * sign (va.y);\n  if (vu < 0.) {\n    el *= -1.;\n    rl *= -1.;\n    az += pi;\n  }\n  ori = vec3 (el, az, rl);\n  ca = cos (ori);\n  sa = sin (ori);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\n#define N_WIN  2\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat, vuOrMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, vd;\n  vec2 canvas, uv, uvv, mMid[N_WIN], ut[N_WIN], mSize, msw;\n  float az, el, asp, zmFac, vel, sr, dir;\n  int vuId, regId;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 600.);// + 1.1 * floor (dateCur.w / 3600.);\n  asp = canvas.x / canvas.y;\n  mSize = (1./4.5) * vec2 (asp, 1.);\n  mMid[0] = (1. - mSize.y) * vec2 (- asp, -1.);\n  mMid[1] = (1. - mSize.y) * vec2 (asp, -1.);\n  for (int k = 0; k < N_WIN; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1;\n  if (mPtr.z > 0.) {\n    regId = 0;\n    for (int k = 0; k < N_WIN; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = k + 1;\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == 0) msw = mPtr.xy;\n  }\n  vuId = 0;\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = k + 1;\n      break;\n    }\n  }\n  fGrnd = (vuId == 0) ? 32. : 12.;\n  if (regId > 0 && (vuId == 0 || vuId == regId)) vuId = regId - vuId;\n  szFacFl = 0.3;\n  gScale = 4.;\n  trkAx = 8. * vec3 (1.9, 2.9, 4.3);\n  trkFx = 0.15 * vec3 (0.23, 0.17, 0.13);\n  trkAy = 0.2 * vec3 (1.7, 3.7, 0.);\n  trkFy = 0.1 * vec3 (0.21, 0.15, 0.);\n  vel = 1.5;\n  FlyerPM (vel * tCur, 0., flyerPos, flyerMat);\n  flyerPos.y += 10. + GrndHt (flyerPos.xz);\n  dir = (vuId == 0) ? 1. : -1.;\n  FlyerPM (vel * tCur - 2. * dir, dir, ro, vuOrMat);\n  ro.y += 10. + GrndHt (ro.xz);\n  if (vuId != 2) {\n    az = 0.;\n    el = -0.1 * pi;\n    if (mPtr.z > 0. && vuId == regId) {\n      az += 2. * pi * msw.x;\n      el += 0.5 * pi * msw.y;\n    }\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n    zmFac = 3.;\n  } else {\n    vd = flyerPos - ro;\n    az = 0.5 * pi + atan (- vd.z, vd.x);\n    el = asin (vd.y / length (vd));\n    zmFac = 4.;\n    if (mPtr.z > 0. && vuId == regId) {\n      az += 0.2 * pi * msw.x;\n      el += 0.2 * pi * msw.y;\n    }\n  }\n  vuMat = StdVuMat (el, az);\n  sunDir = normalize (vec3 (0., 2., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.3 * pi * sin (2. * pi * 0.01 * tCur));\n  if (dir < 0.) sunDir.xz *= -1.;\n  dstFar = 40. * gScale;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) *\n       pi)) / zmFac;\n    rd = normalize (vec3 (2. * tan (0.5 * atan (uvv.x / asp)) * asp, uvv.y, 1.));\n    rd = vuMat * rd;\n    if (vuId != 2) rd = rd * vuOrMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < N_WIN; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 3.) col = vec3 (0.8, 0.3, 0.3);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrConCapsDf (vec3 p, vec2 cs, float r, float h)\n{\n  float d;\n  d = max (dot (vec2 (length (p.xy) - r, p.z), cs), abs (p.z) - h);\n  h /= cs.x * cs.x;\n  r /= cs.x;\n  d = min (d, min (length (vec3 (p.xy, p.z + r * cs.y - h)) - r + h * cs.y,\n     length (vec3 (p.xy, p.z + r * cs.y + h)) - r - h * cs.y));\n  return d;\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. -\n     3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n \"Voronoi\" series:\n   \"Rainbow Cavern\"                  (XsfBWM)\n   \"Honeycomb Voronoi\"               (XsXfDX)\n   \"Desert Town\"                     (XslBDl)\n   \"Smoothed Honeycomb Voronoi\"      (4dsBWl)\n   \"Smoothed Voronoi Landscape\"      (lsffWs)\n   \"Smoothed Voronoi Tunnel\"         (4slfWl)\n   \"Island Flight\"                   (XdBBRR)\n   \"Voronoi Rocks\"                   (ldSBzz)\n   \"Voronoi Towers\"                  (XdBBRh)\n   \"Chocolate Dominoes\"              (ldBfz1)\n   \"Voronoi of the Week\"             (lsjBz1)\n   \"Arctic Patrol\"                   (lsBfzy)\n   \"Twisted Time\"                    (XlsyWH)\n   \"White Folly\"                     (ll2cDG)\n   \"White Folly 2\"                   (ltXfzr)\n   \"Lightweight Lighthouse\"          (XtfBz4)\n   \"Magic Tree 2\"                    (MllBzH)\n   \"Succulent Forest\"                (MlsBzN)\n   \"Voronoi Vegetation\"              (XtlfRM)\n   \"Backlit Lighthouse\"              (4lfBWB)\n   \"Lighthouse with Ship\"            (MtSBR1)\n   \"Into the Woods\"                  (Mddczn)\n   \"Rock Garden\"                     (XdccWn)\n   \"One-Pass Voronoi\"                (Xsyczh)\n   \"Book of the Woods\"               (XsVyRw)\n   \"Metallic Polyhedron\"             (lsGcWm)\n   \"Scrolling Texture Heightmap\"     (MdGBWz)\n   \"River Flight 2\"                  (4l3cz8)\n   \"Penguins Can't Fly\"              (ltVyzh)\n   \"One-Pass Voronoi with Spirals\"   (tsfXDl)\n   \"Voronoi Comparison\"              (WsSXzz)\n   \"Varying Mesh\"                    (tlfXWH)\n   \"Riding the Textured Tunnel\"      (WdVXzD)\n   \"Dynamic Space Rocks\"             (WsGSzt)\n   \"Planet Reboot\"                   (wldGD8)\n   \"Caged Kryptonite\"                (3ltSDn)\n   \"Cave Dolphins\"                   (wdSyRD)\n   \"Big Momavirus\"                   (Wd2yzm)\n   \"Channeling Marbles\"              (wtfcRr)\n   \"Gliders Over Voropolis\"          (WdKcz1)\n   \"Balls In Motion\"                 (WdGBRG)\n   \"Wobbly Blob 2\"                   (tsGfzV)\n   \"Floppy Column\"                   (wtccR4)\n   \"Soup Can Dynamics\"               (3tKyRt)\n   \"Dolphin Orb\"                     (sdBXRD)\n   \"Channeling Slime\"                (NdSSR3)\n   \"Flaming Asteroids\"               (NtSGzt)\n   \"Mesh Dome\"                       (ssKXRt)\n   \"Melange\"                         (slKXD3)\n   \"Voronoi Farms\"                   (cdjSz1)\n*/\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}