{
    "Shader": {
        "info": {
            "date": "1706216426",
            "description": "one of my friends was making a 3d version of the powder toy. they needed an algorithm for traversing an octree, so i coded this for them",
            "flags": 0,
            "hasliked": 0,
            "id": "lf2XWR",
            "likes": 1,
            "name": "octree DDA",
            "published": 3,
            "tags": [
                "dda",
                "octree"
            ],
            "usePreview": 0,
            "username": "unnick",
            "viewed": 101
        },
        "renderpass": [
            {
                "code": "bool signBit(float x) { return (floatBitsToInt(x) & 0x80000000) != 0; }\nbvec3 signBit(vec3 v) { return bvec3(signBit(v.x), signBit(v.y), signBit(v.z)); }\nfloat min3(vec3 v) { return min(min(v.x,v.y),v.z); }\nfloat max3(vec3 v) { return max(max(v.x,v.y),v.z); }\n\nconst int numLevels = 8;\n\n// not necessary, this is just for synthesizing an octree inside shadertoy\nbool circle(ivec3 pos, int level, vec3 center, float radius) {\n    pos = (pos*2 + 1) << level;\n    vec3 p = vec3(pos) / float(2<<numLevels);\n    float size = float(1 << level) / float(2<<numLevels);\n    return length(max(abs(p - center) - size, 0.)) < radius;\n}\n\n// roughly the equivalent of texelFetch\nbool mip(ivec3 pos, int level) {\n    if (level >= numLevels) return true;\n    return circle(pos, level, vec3(.2,.2,.6), .2) || circle(pos, level, vec3(.8,.8,.6), .2);\n}\n\nbvec3 bmix(bvec3 a, bvec3 b, bvec3 s) {\n    return bvec3(\n        s.x ? b.x : a.x,\n        s.y ? b.y : a.y,\n        s.z ? b.z : a.z\n    );\n}\n\n// result.xyz = block pos\n// result.w = normal (-x -y -z +x +y +z = 0 1 2 3 4 5)\nivec4 raytrace(vec3 pos, vec3 dir, out int steps) {\n    vec3 idir = 1./dir;\n    bvec3 sgn = signBit(dir);\n    ivec3 stp = 1-ivec3(sgn)*2;\n    int level = numLevels-1;\n    ivec3 bnd = ivec3(pos)>>level;\n    int previdx = 0;\n    for (int iter = 0; iter < 1000; iter++, steps = iter) {\n        // check if we got out of bounds\n        if (any(bmix(\n            greaterThanEqual(bnd, ivec3((1<<numLevels) >> level)),\n            lessThan(bnd, ivec3(0)<<level),\n            sgn\n        ))) return ivec4(-1);\n        // go down a level\n        if (mip(bnd, level)) {\n            vec3 dists = (vec3((bnd+ivec3((sgn))) << level) - pos) * idir;\n            level--;\n            float dist = max(dists[previdx], 0.);\n            if (level == 0) return ivec4(bnd, previdx + int(sgn[previdx])*3);\n            bnd = clamp(ivec3(pos + dir * dist) >> level, bnd<<1, (bnd<<1)+1);\n            continue;\n        }\n        // go up a level\n        if (!mip(bnd >> 1, level + 1)) {\n            level++;\n            bnd >>= 1;\n            //continue;\n        }\n        vec3 dists = (vec3((bnd+ivec3(not(sgn))) << level) - pos) * idir;\n        float md = min3(dists);\n        int idx = dists.x == md ? 0 : dists.y == md ? 1 : 2;\n        bnd[idx] += stp[idx];\n        previdx = idx;\n    }\n    return ivec4(-1);\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - iResolution.xy) / iResolution.y;\n    int steps = 0;\n    ivec4 res = raytrace(vec3(.5,.5,.0)*float(1<<numLevels), vec3(pos, 1), steps);\n    \n    // display number of steps\n    col = vec4(steps)/64.;\n    \n    if (pos.x > 0.) {\n        // display normals\n        col = vec4(0);\n        if(res.w != -1) col[res.w % 3] = 1.;\n    }\n    \n    // display block positions\n    //col = vec4(0);\n    //if(res.w != -1) col = fract(vec4(res.xyz, 0) / 8.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}