{
    "Shader": {
        "info": {
            "date": "1532330228",
            "description": "hum...It's just a RoBot want to find his Wood Heart.:)\nAlso it's a tutorial about how to use customize ETC2 to decode a (ACES Film)LUT with higher PSNR.\nNote: Suggest use a better color(>70% SRGB) display. :)",
            "flags": 96,
            "hasliked": 0,
            "id": "4ldcz7",
            "likes": 34,
            "name": "[SH18]Wood Heart [HD]",
            "published": 3,
            "tags": [
                "heart",
                "wood",
                "mis",
                "film",
                "pt",
                "lut",
                "human",
                "etc2",
                "sh18",
                "slog"
            ],
            "usePreview": 0,
            "username": "834144373",
            "viewed": 1880
        },
        "renderpass": [
            {
                "code": "/*\n\tWood Heart by 834144373\n\tCreated Date: 2018.7.23\n\tLicense: CC3.0 BY-NC-SA\n\t\n\thum...it seems that the number 834... not friendly to read,\n\t\tor you can call me TNWX or 恬纳微晰,my really name is 祝元洪(YuanHong Zhu)\n\nNote : Hum...If necessity,I will be add the descript about the shaders.\n\t\nMain About:\n\tCustomize ACES Film LUT:\n\tFilm LUT is used to post-processing,and it origin 32x32x32 Lut downscale into 16x16x16 by feature extract.\n\tyou can easy find this LUT data on : http://opencolorio.org/\n\tbut it re-product by Gimp.\n\t\n\tCustomize Sony Logarithmic Color:  \n\tthis formula on : http://www.theodoropoulos.info/attachments/076_on%20S-Log.pdf\n\there I used modulated parameter to approximate the standard higher range Log color.\n\n\tCustomize ETC2:\n\tyep at before I used the BC7 to decode texture with higher PSNR,but it's so heavy,\n\tso focus on Planar and ETC1 mode and deal with special situation color.\n\thttps://en.wikipedia.org/wiki/Ericsson_Texture_Compression#ETC2_and_EAC\n\thttp://www.graphicshardware.org/previous/www_2007/presentations/strom-etc2-gh07.pdf\n\n\tMultiple Importance Sample:\n\thttps://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n\t\n\t\n\tOrenNayar reflect Model:\n\thttps://en.wikipedia.org/wiki/Oren%E2%80%93Nayar_reflectance_model\n\tand reference Blender Cycle render manual\n\tat https://docs.blender.org/manual/en/dev/render/cycles/nodes/types/shaders/diffuse.html\n\t\n\t\nBufferA: Film LUT and ETC2 decoder.\n\nBufferB: Importance Multiple Sample.\n\nStory: It's a wood \n*/\n\n#define R iResolution.xy\n\n/*\n    http://www.theodoropoulos.info/attachments/076_on%20S-Log.pdf\n    y = (0.432699 * Log10(t + 0.037584) + 0.616596) + 0.03 \n*/\nvec3 log10(vec3 value){\n\treturn log2(value)/3.3219280949;//log2(10.);\n}\nvec3 S_LOG(vec3 rgb) {\n    return (0.432699 * log10(rgb + 0.037584) + 0.616596) + 0.03;\n}\nconst mat3 S_Gamut = mat3(\n    1.306240, -0.233075, -0.073165,\n   -0.126851,  1.178376, -0.051526,\n    0.000120, -0.085649,  1.085529\n);\n\n#define _LUT_Size 16.\n#define _LUT_2D_Size vec2(_LUT_Size*_LUT_Size,_LUT_Size)\nvec3 ColorGradeLUT3D_TriLinear(sampler2D _texLUT,vec3 color) {\n    vec3 coord = color*vec3(1.,1., _LUT_Size - 1.);\n    coord.x = fract(coord.x) / _LUT_Size;\n    float deltal = fract(coord.z);\n    coord.x += floor(coord.z) / _LUT_Size;\n    vec3 frontCol = texture(_texLUT, coord.xy*_LUT_2D_Size/R).rgb;\n    coord.x += 1. / _LUT_Size;\n    vec3 backCol = texture(_texLUT, coord.xy*_LUT_2D_Size/R).rgb;\n    return mix(frontCol,backCol,deltal);\n}\n\nvoid mainImage( out vec4 C, in vec2 U){\n\tvec2 uv = U/R;\n    ivec2 iUV = ivec2(U - 0.5);\n    \n    vec2 mousePos = iMouse.xy / R;\n    C = texture(iChannel1,uv);\n\n    C.rgb = Linear2sRGB(C.rgb*2.2);\n    if(uv.x<mousePos.x || true){\n    \tC = pow(C,vec4(1.561));\n    \tC.rgb = S_LOG(C.rgb);\n    \tC.rgb = ColorGradeLUT3D_TriLinear(iChannel0,C.rgb);\n    }\n    C.rgb *= 1.-smoothstep(0.56,1.,length(uv-0.5));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "musicstream",
                        "id": 15320,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/florianburcomposer/2-hours-emotional-fantasy-piano-epic-music"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//----------------------------------------------\nhighp ivec2 SV_DispatchThreadID = ivec2(0,0);\nhighp int Double_pixelID = 0;\nhighp vec4 col = vec4(0.,0.,0.,0.);\nint i = 0;\n//pass !\nvoid A(const uvec4 data){\n    if(Double_pixelID == i++){\n        if((SV_DispatchThreadID.x & 0x1) == 0){\n        \tcol.xy = unpackUnorm2x16(data.s);\n    \t\tcol.zw = unpackUnorm2x16(data.t);\n        }\n        else{\n        \tcol.xy = unpackUnorm2x16(data.p);\n    \t\tcol.zw = unpackUnorm2x16(data.q);\n        }\n    }\n}\nvec4 StoreData( in vec2 U ){\n    SV_DispatchThreadID = ivec2(floor(U-0.5));\n    if(SV_DispatchThreadID.x >= 64 || SV_DispatchThreadID.y >= 4)\n    \treturn vec4(1./3.);\n    //1个像素存一个数据块\n    //16 x 32, 16为其中2个像素存2个块数据\n    //像素ID编号\n    Double_pixelID = (SV_DispatchThreadID.x>>1) + (SV_DispatchThreadID.y<<5); \n\tA(uvec4(0xA058884u,0xC261100Au,0x2B058A86u,0xC1E20000u));\n\tA(uvec4(0x520480B0u,0xC00300u,0x5604804Cu,0xA00500u));\n\tA(uvec4(0xA058A84u,0x262100Au,0xAE058A86u,0xC1E20000u));\n\tA(uvec4(0x530480B0u,0xC00300u,0x5604804Cu,0xA00500u));\n\tA(uvec4(0xA058A84u,0x342100Au,0xAE058A86u,0xC2E20800u));\n\tA(uvec4(0x530480B0u,0xE00300u,0x5604804Cu,0xA00500u));\n\tA(uvec4(0x8A058A84u,0x442180Au,0x2E068A86u,0xC4C21000u));\n\tA(uvec4(0xD30480B0u,0xE00300u,0x5704804Eu,0xC00500u));\n\tA(uvec4(0x8A058A84u,0x4542200Au,0x2E068A86u,0x6C32000u));\n\tA(uvec4(0xD60680B0u,0x4E00B00u,0x5705804Eu,0xC00D00u));\n\tA(uvec4(0xA078A84u,0x8902380Au,0xAF078886u,0xAC34000u));\n\tA(uvec4(0xD60780B2u,0xA003400u,0x5A078050u,0x9E03D00u));\n\tA(uvec4(0x8A0C8882u,0x8E025808u,0xB20D8886u,0xD0C26800u));\n\tA(uvec4(0xD70E80B2u,0x11006400u,0x5A0E8050u,0x11E06D00u));\n\tA(uvec4(0x8B0E8682u,0x13037802u,0x32148086u,0x95E19800u));\n\tA(uvec4(0x571580B4u,0x18209400u,0x5A158050u,0x18E09D00u));\n\tA(uvec4(0xE158086u,0x9702A000u,0x33F2808Au,0x9B00C100u));\n\tA(uvec4(0xDAF380B6u,0x1E20C400u,0x5A1C8052u,0x1E00CE00u));\n\tA(uvec4(0x8FF28088u,0xDC20C000u,0x331C808Cu,0x5F00E900u));\n\tA(uvec4(0x5AFA80B6u,0x2340EC00u,0xDBFA8052u,0x2400F600u));\n\tA(uvec4(0x931C808Au,0x5F40D800u,0x36FA808Eu,0x63200101u));\n\tA(uvec4(0x5B0481B8u,0x28400C01u,0xDE048154u,0x29201E01u));\n\tA(uvec4(0x93F9808Cu,0x6240F000u,0xB7FB8090u,0xA6202101u));\n\tA(uvec4(0xDB0581BAu,0x2C602C01u,0xDE068156u,0x2D203601u));\n\tA(uvec4(0xEFB8086u,0xA4000801u,0xBE04818Cu,0xE8E04001u));\n\tA(uvec4(0xDF0781BCu,0x6F604C01u,0xE20C8158u,0x30405601u));\n\tA(uvec4(0x6058180u,0x67012801u,0x4AB0025u,0x86800F07u));\n\tA(uvec4(0x660E8142u,0x71A17401u,0x67EB815Eu,0x33817E01u));\n\tA(uvec4(0x3990200u,0x44CC5744u,0x4B0D8188u,0xAE448001u));\n\tA(uvec4(0x6B148146u,0x34C59401u,0x6E158164u,0xF6C49E01u));\n\tA(uvec4(0x82079B80u,0xAB075825u,0x4F0EA588u,0xB049982Du));\n\tA(uvec4(0xEF15A54Au,0x370BAD17u,0xF2F29968u,0x38EAB629u));\n\tA(uvec4(0xB058A84u,0x80070814u,0x3F048E8Au,0x6B0120u));\n\tA(uvec4(0x66049040u,0x808F0504u,0x6704805Eu,0x40900706u));\n\tA(uvec4(0x8B058C84u,0xC0070816u,0xBF04908Au,0x406B0120u));\n\tA(uvec4(0x66049040u,0xC08F0504u,0x6704805Eu,0x80900708u));\n\tA(uvec4(0xA068C82u,0x81016u,0xC2049088u,0xC04B0122u));\n\tA(uvec4(0x66049040u,0x40900504u,0x6704805Eu,0x910708u));\n\tA(uvec4(0x87068E82u,0x82082018u,0xC3059288u,0x402C0924u));\n\tA(uvec4(0x67049240u,0xB10506u,0x6704805Eu,0x80B1070Au));\n\tA(uvec4(0x6079082u,0x4809381Au,0xC60C9486u,0x45CD2026u));\n\tA(uvec4(0xEA059442u,0x1B20506u,0xEA048260u,0x40B20F0Eu));\n\tA(uvec4(0x830C9280u,0xD0A581Cu,0x470E9684u,0xE8E5828u));\n\tA(uvec4(0x6A0E9642u,0xCAB24D08u,0xEA0D8460u,0x46B35F10u));\n\tA(uvec4(0x82EB9480u,0x140B801Eu,0xCA149884u,0x164F902Au));\n\tA(uvec4(0x6B159842u,0xD6B38D08u,0x6B158662u,0x15B49F14u));\n\tA(uvec4(0x2F29680u,0xDB0BB020u,0xCBF39A84u,0xDD0FC82Eu));\n\tA(uvec4(0xEB1C9A44u,0xDFB4CD0Au,0xEB1C8662u,0xDFB4D716u));\n\tA(uvec4(0x821C9880u,0x600CE022u,0x4EFA9C84u,0xA410002Fu));\n\tA(uvec4(0x6E049B44u,0xA895050Du,0x6E048964u,0xA7B50F19u));\n\tA(uvec4(0x83FA9A80u,0xE60C0025u,0xCE049F84u,0x2A113031u));\n\tA(uvec4(0xEE069B46u,0x2F96350Du,0x6E078964u,0x2FB63F19u));\n\tA(uvec4(0x83049B80u,0x6A0D2027u,0xCF069F84u,0xAE115831u));\n\tA(uvec4(0x6F0D9D46u,0x74965D0Du,0xEE0D8B64u,0xB4B66F1Bu));\n\tA(uvec4(0x83059F80u,0xAC0D3829u,0x4F0CA384u,0xF1117835u));\n\tA(uvec4(0x6FEB9F48u,0xB8967D11u,0xEFEB8D66u,0xF9B6871Du));\n\tA(uvec4(0x207A580u,0x2E0E4831u,0x4F0DAB80u,0x7312883Du));\n\tA(uvec4(0xF214AB48u,0xFA96951Du,0x72159B68u,0xFBB6A72Du));\n\tA(uvec4(0x820CB380u,0xAF0E6041u,0xD20EBD80u,0xF412A053u));\n\tA(uvec4(0x76F2434Cu,0x3C77B53Bu,0xF6F2BB6Cu,0x3DB7BF49u));\n\tA(uvec4(0x820DBF80u,0x300F7051u,0xD2EB4D80u,0x7513B865u));\n\tA(uvec4(0x77F3594Eu,0xFC77C555u,0x771C536Eu,0xFEB7CF61u));\n\tA(uvec4(0x20E4980u,0xB00F8059u,0xD2145780u,0xF613C073u));\n\tA(uvec4(0x7A1C6750u,0x3D78D565u,0x7AF96570u,0x7FB8DF73u));\n\tA(uvec4(0x2044080u,0xE0058u,0x5704588Eu,0x530188u));\n\tA(uvec4(0x7F047E56u,0x5A068Au,0x7F04887Du,0x40FB0790u));\n\tA(uvec4(0x2044280u,0x400E0058u,0x5B045A88u,0x40F3008Au));\n\tA(uvec4(0x7F048057u,0x405A068Au,0x7F048A7Du,0x80FB0792u));\n\tA(uvec4(0x2044480u,0x800E005Au,0x5E045C86u,0x8093008Cu));\n\tA(uvec4(0x7F048257u,0xC03A068Eu,0x7F048C7Du,0xFC0794u));\n\tA(uvec4(0x2044880u,0xF005Eu,0x5E046084u,0x540092u));\n\tA(uvec4(0x7F048657u,0x803B0692u,0x7F04907Du,0x80FC0798u));\n\tA(uvec4(0x820C4E80u,0xC70F2864u,0x5E066680u,0x2150098u));\n\tA(uvec4(0x7F048C57u,0x803C0698u,0x7F04967Du,0x80FD079Eu));\n\tA(uvec4(0x820E5480u,0x4F10706Cu,0xDBEB6E80u,0xCE1540A0u));\n\tA(uvec4(0x7F079459u,0x841D1EA0u,0x7F069E7Du,0x83FE27A6u));\n\tA(uvec4(0x2F25A80u,0x5711A872u,0x56F37480u,0xD716A8A6u));\n\tA(uvec4(0xFFF29C57u,0x54FE95A6u,0xFF15A47Du,0x92FFA7ACu));\n\tA(uvec4(0x2F96080u,0x5E12E078u,0xD2FA7A80u,0xE017F8ACu));\n\tA(uvec4(0x7FFBA255u,0x20DFEDACu,0x7FFBAA7Du,0xDFFFF7B2u));\n\tA(uvec4(0x2046580u,0x2413187Du,0x28999B05u,0xC9C3131Fu));\n\tA(uvec4(0x7F07A755u,0xE9BF35B1u,0x7F07AF7Du,0xE9FF3FB5u));\n\tA(uvec4(0x82066980u,0xA9134081u,0xC70C8381u,0xED1870B7u));\n\tA(uvec4(0x7FEBAB55u,0xF09F75B3u,0x7FEBB37Bu,0xF0FF77B9u));\n\tA(uvec4(0x820C6B80u,0xED136883u,0x43EB8581u,0x711998B9u));\n\tA(uvec4(0xFF15AD53u,0xF69FA5B5u,0x7FF2B57Bu,0xF7FFA7BBu));\n\tA(uvec4(0x20E6D80u,0x2F147885u,0xC3148781u,0xB419B8BBu));\n\tA(uvec4(0xFFF3AF53u,0xFA7FCDB9u,0x25EECEFFu,0x11115755u));\n\tA(uvec4(0x2EB7180u,0x71148887u,0xC3158B81u,0xB619D0BDu));\n\tA(uvec4(0xFF1CB353u,0xFC7FDDBBu,0x25EFCEFFu,0x11015555u));\n\tA(uvec4(0x82EB7580u,0x7214988Fu,0x43F29181u,0xB719D8C3u));\n\tA(uvec4(0xFFF9B953u,0xFE7FEDC3u,0x1FFCEFFu,0xB1BB5515u));\n\tA(uvec4(0x2147B80u,0xB3149893u,0xC3F29781u,0xB719E0C9u));\n\tA(uvec4(0x7FFABF53u,0xFE7FF5C9u,0x7FFB477Bu,0xFFDFF7CDu));\n\tA(uvec4(0x2147D80u,0xB314A097u,0x43F39B81u,0xF819E8CBu));\n\tA(uvec4(0xFFFA4355u,0xFE7FFDCDu,0x3F8D3F8u,0xB9AB1511u));\n\tA(uvec4(0x3046880u,0x800F0084u,0x5F048E93u,0xB401C0u));\n\tA(uvec4(0xCCCFu,0xE3C00F03u,0x7F044E7Fu,0xC0FB07D2u));\n\tA(uvec4(0x2046A80u,0xC00F0086u,0x6304908Du,0x403401C2u));\n\tA(uvec4(0xCCCFu,0xE3E00F01u,0x7F04507Fu,0xFC07D4u));\n\tA(uvec4(0x2046E80u,0x40100088u,0x66049287u,0xC0D400C6u));\n\tA(uvec4(0x7F044661u,0xC03A06D8u,0x7F04547Fu,0x80FC07D8u));\n\tA(uvec4(0x82047280u,0x411008Cu,0x63049683u,0xC19500CCu));\n\tA(uvec4(0x7F044C61u,0xC01B06DCu,0x7F045A7Fu,0x80FD07DCu));\n\tA(uvec4(0x20D7680u,0x15123892u,0xE2059C81u,0xD21600D2u));\n\tA(uvec4(0x7F04525Fu,0xC4FC05E4u,0x7F04607Fu,0x83FE07E4u));\n\tA(uvec4(0x2147C80u,0xDA128898u,0xDE14A481u,0x9E1748DAu));\n\tA(uvec4(0xFF05585Fu,0x98DD0DEAu,0x7F05667Fu,0x16FF1FEAu));\n\tA(uvec4(0x21C8481u,0xA013C8A0u,0xD31CAA81u,0x2318C8E2u));\n\tA(uvec4(0xFFF3605Du,0x24DEADF0u,0xFFF26C7Fu,0xE3FFB7F0u));\n\tA(uvec4(0x82FB8A81u,0x261400A7u,0xCB04B181u,0xE91810E7u));\n\tA(uvec4(0xFF04675Bu,0xABBE05F7u,0xFF04737Fu,0xEBFF0FF7u));\n\tA(uvec4(0x2068F81u,0xAB1438ADu,0x24AACD05u,0x1F73F0Fu));\n\tA(uvec4(0x7F0D6B59u,0x319F55FBu,0x7F0D797Fu,0xF1FF57FBu));\n\tA(uvec4(0x820C9381u,0xEE1460B1u,0x4BCCD05u,0x83F71F0Fu));\n\tA(uvec4(0xFF147157u,0x769F8DFFu,0xFF147D7Fu,0xF7FF97FDu));\n\tA(uvec4(0x820E9781u,0x311580B3u,0x4CDCE04u,0xC3EF170Fu));\n\tA(uvec4(0x7FF37357u,0x7A7FBDFFu,0xFFF37D7Fu,0xFBFFBFFFu));\n\tA(uvec4(0x82EB9781u,0x321598B5u,0x4DECE04u,0xC3EF1F0Fu));\n\tA(uvec4(0x7FF97555u,0x7C7FDDFFu,0xFFF97F7Fu,0xFDFFDFFFu));\n\tA(uvec4(0x82149981u,0x7415A0B7u,0x4DECE04u,0xC1EF070Fu));\n\tA(uvec4(0x7FFA7755u,0xBE7FF5FFu,0xFFFA7F7Fu,0xFFFFF7FFu));\n\tA(uvec4(0x2159B81u,0xB415A8B9u,0x10DECE04u,0xE100070Fu));\n\tA(uvec4(0xFFFA7755u,0x7E7FFDFFu,0xFFFB7F7Fu,0xFFFFFFFFu));\n\tA(uvec4(0x82159D81u,0xF515B0B9u,0x10EECE04u,0xC100070Fu));\n\tA(uvec4(0x7FFB7755u,0xBE5FFDFFu,0xFFFB7F7Fu,0xFFDFFFFFu));\n\tA(uvec4(0x82159F81u,0x3516B0BBu,0x4EECE04u,0xE1FF030Fu));\n\tA(uvec4(0xFFFB7955u,0xBF7FFDFFu,0xFFFB7F7Du,0xFFDFFFFFu));\t\n    return col;\n}\n//-----------------------------------------------\nstruct BlockData{\n\tuint block_part_1;//低位 (LSB)\n    uint block_part_2;//高位 (MSB)\n};\nBlockData blockdata;\nuint[8] bitstring;\nconst int[8] etc2_distance_table = int[](3, 6, 11, 16, 23, 32, 41, 64 );\nconst int[] complement3bitshifted_table = int[](0, 8, 16, 24, -32, -24, -16, -8);\nconst ivec4[8] modifier_table = ivec4[](\n\t  ivec4( 2, 8, -2, -8 ),\n\t  ivec4( 5, 17, -5, -17 ),\n      ivec4( 9, 29, -9, -29 ),\n      ivec4( 13, 42, -13, -42 ),\n      ivec4( 18, 60, -18, -60 ),\n      ivec4( 24, 80, -24, -80 ),\n      ivec4( 33, 106, -33, -106 ),\n      ivec4( 47, 183, -47, -183 )\n);\n\nivec3 ETC2_Planar_mode(int x,int y,int id){\n\t// Each color O, H and V is in 6-7-6 format.\n    int RO = int((bitstring[0] & 0x7Eu) >> 1);\n    int GO = int(((bitstring[0] & 0x1u) << 6) | ((bitstring[1] & 0x7Eu) >> 1));\n    int BO = int(((bitstring[1] & 0x1u) << 5) | (bitstring[2] & 0x18u) | ((bitstring[2] & 0x03u) << 1) | ((bitstring[3] & 0x80u) >> 7));\n    int RH = int(((bitstring[3] & 0x7Cu) >> 1) | (bitstring[3] & 0x1u));\n    int GH = int((bitstring[4] & 0xFEu) >> 1);\n    int BH = int(((bitstring[4] & 0x1u) << 5) | ((bitstring[5] & 0xF8u) >> 3));\n    int RV = int(((bitstring[5] & 0x7u) << 3) | ((bitstring[6] & 0xE0u) >> 5));\n    int GV = int(((bitstring[6] & 0x1Fu) << 2) | ((bitstring[7] & 0xC0u) >> 6));\n    int BV = int(bitstring[7] & 0x3Fu);\n    RO = (RO << 2) | ((RO & 0x30) >> 4);    // Replicate bits.\n    GO = (GO << 1) | ((GO & 0x40) >> 6);\n    BO = (BO << 2) | ((BO & 0x30) >> 4);\n    RH = (RH << 2) | ((RH & 0x30) >> 4);\n    GH = (GH << 1) | ((GH & 0x40) >> 6);\n    BH = (BH << 2) | ((BH & 0x30) >> 4);\n    RV = (RV << 2) | ((RV & 0x30) >> 4);\n    GV = (GV << 1) | ((GV & 0x40) >> 6);\n    BV = (BV << 2) | ((BV & 0x30) >> 4);\n    ivec3 col = ivec3(\n        (x * (RH - RO) + y * (RV - RO) + 4 * RO + 2),\n        (x * (GH - GO) + y * (GV - GO) + 4 * GO + 2),\n        (x * (BH - BO) + y * (BV - BO) + 4 * BO + 2)\n    ) >>2;\n    return col;\n}\nivec3 ETC1_Decode_mode(int x,int y,int id){\n    int differential_mode = int(bitstring[3] & 2u);\n    int flipbit = int(bitstring[3] & 1u);\n    \n    ivec3 base_color_subblock1_RGB = ivec3(0);\n    ivec3 base_color_subblock2_RGB = ivec3(0);\n\n    if (differential_mode > 0){\n        base_color_subblock1_RGB = ivec3(bitstring[0],bitstring[1],bitstring[2]) & 0xF8;\n\t\tbase_color_subblock2_RGB = base_color_subblock1_RGB;\n        base_color_subblock2_RGB += ivec3(\n            complement3bitshifted_table[bitstring[0]],\n        \tcomplement3bitshifted_table[bitstring[1]],\n        \tcomplement3bitshifted_table[bitstring[2]]\n        ) & 7;\n\n        base_color_subblock1_RGB |= (base_color_subblock1_RGB & 224)>>5;\n        base_color_subblock2_RGB |= (base_color_subblock2_RGB & 224)>>5;\n    }\n    else{\n        base_color_subblock1_RGB = ivec3(bitstring[0],bitstring[1],bitstring[2]);\n        base_color_subblock2_RGB = base_color_subblock1_RGB;\n\n        base_color_subblock1_RGB &= 0xF0;\n        base_color_subblock2_RGB &= 0x0F;\n        \n        base_color_subblock1_RGB |= base_color_subblock1_RGB >> 4;\n        base_color_subblock2_RGB |= base_color_subblock2_RGB << 4;\n    }\n    int table_codeword1 = int((bitstring[3] & 224u) >> 5);\n    int table_codeword2 = int((bitstring[3] & 28u) >> 2);\n    uint pixel_index_word = (bitstring[4] << 24) | (bitstring[5] << 16) | (bitstring[6] << 8) | bitstring[7];\n\n    int pixel_index = int(((pixel_index_word & (1u << id)) >> id) | ((pixel_index_word & (0x10000u << id)) >> (16 + id - 1)));    \n    ivec3 col = ivec3(0);\n    if (flipbit == 0){\n        // Two 2x4 blocks side-by-side.\n        if (id < 8){\n            // Subblock 1.\n            int modifier = modifier_table[table_codeword1][pixel_index];\n            col = base_color_subblock1_RGB+modifier;\n        }\n        else{\n            // Subblock 2.\n            int modifier = modifier_table[table_codeword2][pixel_index];\n            col = base_color_subblock2_RGB+modifier;\n        }\n    }\n    else{\n        // Two 4x2 blocks on top of each other.\n        if ((id & 2) == 0){\n            // Subblock 1.\n            int modifier = modifier_table[table_codeword1][pixel_index];\n            col = base_color_subblock1_RGB+modifier;\n        }\n        else{\n            // Subblock 2.\n            int modifier = modifier_table[table_codeword2][pixel_index];\n            col = base_color_subblock2_RGB+modifier;\n        }\n    }\n    return col;\n}\n\nvoid GetBlock(ivec2 U){\n    vec4 values = texelFetch(iChannel0,U>>2,0);//x,y,z,w 16,16,16,16\n\tblockdata.block_part_1 = packUnorm2x16(values.st);\n    blockdata.block_part_2 = packUnorm2x16(values.pq);\n}\n\nvoid GetBytes(){\n\tbitstring[0] =  blockdata.block_part_1 & 0xFFu;\n    bitstring[1] = (blockdata.block_part_1 & 0xFF00u) >> 8;\n    bitstring[2] = (blockdata.block_part_1 & 0xFF0000u) >> 16;\n    bitstring[3] = (blockdata.block_part_1 & 0xFF000000u) >> 24;\n    \n    bitstring[4] =  blockdata.block_part_2 & 0xFFu;\n    bitstring[5] = (blockdata.block_part_2 & 0xFF00u) >> 8;\n    bitstring[6] = (blockdata.block_part_2 & 0xFF0000u) >> 16;\n    bitstring[7] = (blockdata.block_part_2 & 0xFF000000u) >> 24;\n}\nivec3 ETC2_Decode(int x,int y){\n\tint id = y + x*4;\n    ivec3 col;\n    if ((bitstring[3] & 2u) != 0u){\n        int B = int((bitstring[2] & 0xF8u)) + complement3bitshifted_table[bitstring[2] & 7u];\n        if ((B & 0xFF07) > 0)\n            // Planar mode.\n            col = ETC2_Planar_mode(x,y,id);\n        else\n            // with ETC1 mode.\n            col = ETC1_Decode_mode(x,y,id);\n    }\n    else\n        // direct ETC1 mode.\n        col = ETC1_Decode_mode(x,y,id);\n    return clamp(col,0,255);\n}\nvec4 Customer_ETC2_Decoder (in vec2 U ){\n\tivec2 iU = ivec2(floor(U - 0.5));\n    if(any(greaterThan (iU,ivec2(255,15)))){\n    \treturn vec4(1./3.);\n    }\n    //init and get values\n    GetBlock(iU);\n    GetBytes();\n    iU = iU % 4;\n    ivec3 col = ETC2_Decode(iU.x,iU.y);\n    return vec4(col,255.)/255.;\n}\n//-----------------------------------------------\n#define R iResolution.xy\nvoid mainImage(out vec4 C,in vec2 U){\n\tif(iFrame == 0)\n    \tC = StoreData(U);\n    else if(iFrame == 1)\n    \tC = Customer_ETC2_Decoder(U);\n    else {\n        C = texture(iChannel0,U/R);\n    }\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define GI_DEPTH 3\n\n/*\n\tif we use the \"Multiple Importance Sample\"\n\thttps://graphics.stanford.edu/courses/cs348b-03/papers/veach-chapter9.pdf\n\tcombine direct light sample and bsdf light sample\n*/\nconst bool UseMIS = true;\n/*\n\tSkylighting form skybox,as well as known the IBL \"Image Base Lighting\"\n\thum...but here no HDR,:)\n*/\nconst float SkyLightIntensity = 2.;//1.7 up for bright,0.15 lower for weak lighting show AO\nconst float AreaLightIntersity = 10.;\n//------------------------------------Debug-----------------------------------\n//#define Linux //else for Windows system\n\n/*Scene Objects*/\n#define N_SPHERES 1\n#define N_QUADS 2\n#define N_BOXES 1\n\n/*Type*/\n#define LIGHT 0\n#define DIFF 1\n#define WOOD 10\n\n\n/*Material ID Name*/\n#define CenterSphere 0\n#define Floor 1\n#define AreLighing 2\n#define Cuboid 3\n#define RotBot 4\n#define RotBotEYE 11\nint Raymarching_ID = RotBot;\n\nconst vec3 LIGHTCOLOR = vec3(0.8,0.8,0.75);\nconst vec3 BACKGROUND_COL = vec3(0.336,0.336,0.336);\n\nconst vec3 ZERO = vec3(0.,0.,0.);\nconst vec3 ONE  = vec3(1.,1.,1.);\nconst vec3 UP   = vec3(0.,1.,0.);\n\n/* \n\thum...you can skip it,it's just intersection primary polygon,\n\tand you can easy find more free on public internet.:)\n*/\nstruct Ray { vec3 origin; vec3 direction; };\nstruct Sphere { float radius; vec3 position; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Quad { vec3 normal; vec3 v0; vec3 v1; vec3 v2; vec3 v3; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Box { vec3 minCorner; vec3 maxCorner; vec3 emission; vec3 color; float roughness; int type; int id;};\nstruct Intersection {vec3 surface;vec3 direction;float distance;vec2 uv; vec3 normal; vec3 emission; vec3 color; float roughness; int type; int id;};\n\nstruct Light{float radius;vec3 direction;vec3 emission;float radiance;float pdf;int type;};\nstruct Material{float id;vec2 uv;vec3 normal;vec3 specular;vec3 diffuse;vec3 emission;float roughness;int type;}; \n\nSphere spheres[N_SPHERES];\nQuad quads[N_QUADS];\nBox boxes[N_BOXES];\n\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1){\n\tfloat discrim = B*B-4.0*A*C;\n\tif ( discrim < 0.0 )\n        \treturn false;\n\tfloat rootDiscrim = sqrt(discrim);\n\tfloat Q = (B > 0.0) ? -0.5 * (B + rootDiscrim) : -0.5 * (B - rootDiscrim); \n\tfloat t_0 = Q / A; \n\tfloat t_1 = C / Q;\n\tt0 = min( t_0, t_1 );\n\tt1 = max( t_0, t_1 );\n\treturn true;\n}\nfloat SphereIntersect( float rad, vec3 pos, Ray ray ){\n\tfloat t = INFINITY;\n\tfloat t0, t1;\n\tvec3 L = ray.origin - pos;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - (rad * rad);\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn INFINITY;\n\tif ( t1 > 0.0 )\n\t\tt = t1;\n\tif ( t0 >= 0.0 )\n\t\tt = t0;\n\treturn t;\n}\nfloat QuadIntersect( vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 normal, Ray r ){\n\tvec3 u, v, n;    // triangle vectors\n\tvec3 w0, w, x;   // ray and intersection vectors\n\tfloat rt, a, b;  // params to calc ray-plane intersect\n\t// get first triangle edge vectors and plane normal\n\tv = v2 - v0;\n\tu = v1 - v0; // switched u and v names to save calculation later below\n\t//n = cross(v, u); // switched u and v names to save calculation later below\n\tn = -normal; // can avoid cross product if normal is already known\n\tw0 = r.origin - v0;\n\ta = -dot(n,w0);\n\tb = dot(n, r.direction);\n\tif (b < 0.0001)   // ray is parallel to quad plane\n\t\treturn INFINITY;\n\t// get intersect point of ray with quad plane\n\trt = a / b;\n\tif (rt < 0.0)          // ray goes away from quad\n\t\treturn INFINITY;   // => no intersect\n\tx = r.origin + rt * r.direction; // intersect point of ray and plane\n\t// is x inside first Triangle?\n\tfloat uu, uv, vv, wu, wv, D;\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\tvv = dot(v,v);\n\tw = x - v0;\n\twu = dot(w,u);\n\twv = dot(w,v);\n\tD = 1.0 / (uv * uv - uu * vv);\n\t// get and test parametric coords\n\tfloat s, t;\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0){\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0){\n\t\t\treturn rt;\n\t\t}\n\t}\n\t// is x inside second Triangle?\n\tu = v3 - v0;\n\t///v = v2 - v0;  //optimization - already calculated above\n\tuu = dot(u,u);\n\tuv = dot(u,v);\n\t///vv = dot(v,v);//optimization - already calculated above\n\t///w = x - v0;   //optimization - already calculated above\n\twu = dot(w,u);\n\t///wv = dot(w,v);//optimization - already calculated above\n\tD = 1.0 / (uv * uv - uu * vv);\n\t// get and test parametric coords\n\ts = (uv * wv - vv * wu) * D;\n\tif (s >= 0.0 && s <= 1.0){\n\t\tt = (uv * wu - uu * wv) * D;\n\t\tif (t >= 0.0 && (s + t) <= 1.0){\n\t\t\treturn rt;\n\t\t}\n\t}\n\treturn INFINITY;\n}\nfloat BoxIntersect( vec3 minCorner, vec3 maxCorner, Ray r, out vec3 normal ){\n\tvec3 invDir = 1.0 / r.direction;\n\tvec3 tmin = (minCorner - r.origin) * invDir;\n\tvec3 tmax = (maxCorner - r.origin) * invDir;\n\tvec3 real_min = min(tmin, tmax);\n\tvec3 real_max = max(tmin, tmax);\n\tfloat minmax = min( min(real_max.x, real_max.y), real_max.z);\n\tfloat maxmin = max( max(real_min.x, real_min.y), real_min.z);\n\tif (minmax > maxmin){\n        if (maxmin > 0.0){ // if we are outside the box\n\t\t\tnormal = -sign(r.direction) * step(real_min.yzx, real_min) * step(real_min.zxy, real_min);\n\t\t\treturn maxmin;\t\n\t\t}\n        else if (minmax > 0.0){ // else if we are inside the box\n\t\t\tnormal = -sign(r.direction) * step(real_max, real_max.yzx) * step(real_max, real_max.zxy);\n\t\t\treturn minmax;\n\t\t}\n\t}\n\treturn INFINITY;\n}\n\nvoid SetupScene(){\n   \tspheres[0] = Sphere( 0.9, vec3(-0.1, 0.3,-0.75),vec3(0.,0.,0.),vec3(1.,1.,1.), 1., DIFF,CenterSphere);\n    quads[0] = Quad(normalize(vec3(0.,-0.37,1.)),vec3(4.45624,2.70023,-16.2667), vec3(-4.45624,2.70023,-16.2667), vec3(-4.45624 ,11.247,-13.7397), vec3(4.45624,11.247,-13.7397), 2.*LIGHTCOLOR, vec3(1.),0.4, LIGHT,AreLighing);\n    quads[1] = Quad(vec3(0.,1.,0.),vec3(-300000,0.,-200000.), vec3(300000.,0.,-200000.), vec3(200000.,0.,200000.), vec3(-200000.,0.,200000.), vec3(0.,0.,0.), vec3(1.),0.05, DIFF,Floor);\n    //boxes[0] =  Box(vec3(-0.7,1.,2.2),vec3(0.7,0.0,0.94), vec3(0.,0.,0.), vec3(0.,1.,0.), 1., DIFF,Cuboid);\n}\n\nfloat sphere(vec3 p,float r){\n\treturn length(p)-r;\n}\nfloat Cube(vec3 p,vec3 size,float r){\n\treturn length(max(abs(p)-size,0.))-r;\n}\nvec3 RotX(vec3 p, float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\nvec3 RotY(vec3 p, float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\nvec3 RotZ(vec3 p, float a){\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x - sa*p.y, sa*p.x + ca*p.y, p.z);\n}\nmat3 RotXYZ(vec3 v, float angle){\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(\n        c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t);\n}\n\nfloat scene(vec3 p){\n    \n\t//float d1 = sphere(p-vec3(1.,0.,0.),0.5);\n    vec3 bodyWhere = vec3(0.,1.2,1.4);\n\tfloat body = Cube(p-bodyWhere,vec3(0.3,0.35,0.15),0.001);\n   \t\n    vec3 headWhere = vec3(0.,0.68,0.) + bodyWhere;\n    float head = Cube(p-headWhere,vec3(0.34,0.3,0.3),0.001);\n    \n    vec3 eyesWhere = vec3(0.15,0.1,-.3) + headWhere;\n    float eyes = sphere(abs(p)-eyesWhere,0.05);\n    \n    if(head < -eyes){\n    \thead = -eyes;\n        Raymarching_ID = RotBotEYE;\n    }\n    \n    vec3 RightlegWhere = vec3(0.2,-0.85,0.) + bodyWhere;\n    float Rightleg = Cube(p-RightlegWhere,vec3(0.1,0.4,0.15),0.001);\n    \n    vec3 LeftLegWhere = vec3(-0.2,-0.85,0.) + bodyWhere;\n    float Leftleg = Cube(p-LeftLegWhere,vec3(0.1,0.4,0.15),0.001);\n\t\n    Rightleg = min(Rightleg,Leftleg);\n    body = min(body,Rightleg);\n\n    {\n        vec3 RightHandWhere = vec3(0.5,0.0,0.) + bodyWhere;\n        float RightHand = Cube(RotZ(p-RightHandWhere,-0.4),vec3(0.1,0.4,0.12),0.001);\n    \n    \tvec3 LeftHandWhere = vec3(-0.4,-.2,-0.3) + bodyWhere;\n        float LeftHand = Cube(RotX(p-LeftHandWhere,-0.8),vec3(0.1,0.4,0.12),0.001);\n    \t\n    \tRightHand = min(RightHand,LeftHand);\n\t\tbody = min(body,RightHand);\n    }    \n    float d = min(body,head);\n    return d;\n}\nvec3 GetNormal(vec3 p){\n\tconst vec2 e = vec2(0.001,0.);\n    vec3 nDir = vec3(\n    \tscene(p+e.xyy),\n        scene(p+e.yxy),\n        scene(p+e.yyx)\n    )-scene(p);\n    return normalize(nDir);\n}\nfloat RayMarching(Ray ray,out vec3 normal){\n\tfloat dd = 0.1;\n    float d = 0.;\n    for(int i = 0;i<30;i++){\n        d = scene(ray.origin + dd*ray.direction);\n    \tdd += d;\n        if(d < 0.02){\n        \tbreak;\n        }\n        if(dd >= 30.){\n        \tdd = INFINITY;\n        \tbreak;\n        }\n\t\t\n    }\n    vec3 surface = ray.origin + dd * ray.direction;\n    normal = GetNormal(surface);\n    return dd;\n}\nfloat SceneIntersect( Ray r, inout Intersection intersec ){\n    float d = INFINITY;\t\n    float t = 0.;\n    vec3 normal = vec3(0.);\n    for(int i=0;i<spheres.length();i++){\n        t = SphereIntersect(spheres[i].radius,spheres[i].position,r);\n        if (t < d){\n            d = t;\n            intersec.normal = normalize((r.origin + r.direction * t) - spheres[i].position);\n            intersec.emission = spheres[i].emission;\n            intersec.color = spheres[i].color;\n            intersec.roughness = spheres[i].roughness;\n            intersec.type = spheres[i].type;\n            intersec.id = spheres[i].id;\n\t\t}\n    }\n    for(int i=0;i<quads.length();i++){\n        t = QuadIntersect( quads[i].v0, quads[i].v1, quads[i].v2, quads[i].v3, quads[i].normal, r );\n        if (t < d){\n        \td = t;\n            intersec.normal = normalize(quads[i].normal);\n            intersec.emission = quads[i].emission;\n            intersec.color = quads[i].color;\n            intersec.roughness = quads[i].roughness;\n            intersec.type = quads[i].type;\n            intersec.id = quads[i].id;\n        }\n    }\n    for(int i=0;i<boxes.length();i++){\n    \tt = BoxIntersect(boxes[0].minCorner,boxes[0].maxCorner,r,normal);\n        if(t < d){\n        \td = t;\n            intersec.normal = normalize(normal);\n            intersec.emission = boxes[i].emission;\n            intersec.color = boxes[i].color;\n            intersec.roughness = boxes[i].roughness;\n            intersec.type = boxes[i].type;\n        \tintersec.id = boxes[i].id;\n        }\n    }\n    \n    float dd = RayMarching(r,normal);\n    if(dd < d){\n    \td = dd;\n        intersec.normal = normal; \n    \tintersec.color = intersec.normal;\n        intersec.roughness = 1.;\n        intersec.type = DIFF;\n        //intersec.id = RotBot;\n        intersec.id = Raymarching_ID;\n    }\n    /**/\n    intersec.distance = d;\n    intersec.surface  = r.origin + r.direction * d + intersec.normal*0.00001;\n    return d;\n}\n\n/* \n\tAll feature materials infomation\n\tMaterial GetMaterial(Intersection _intersec){\n\tMaterial mat;\n    mat.type = _intersec.type;\n    mat.uv = _intersec.surface.xz*0.1 - 0.5;\n    mat.normal = _intersec.normal;\n   \n    mat.diffuse = sRGB2Linear(texture(iChannel1,mat.uv).rgb);\n    mat.specular = LIGHTCOLOR;\n    mat.roughness = _intersec.roughness;\n    return mat;\n}\n*/\n/*\n\tfrom Inigo Quilez (hum...who is also a talent at more something)\n\thttps://www.shadertoy.com/view/MtsGWH\n*/\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    vec3 m = pow( abs(n), vec3(k) );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\nOrenNayarBsdf GetOrenNayarMaterial(Intersection _intersec){\n\tOrenNayarBsdf mat;\n    mat.id = _intersec.id;\n    mat.uv = fract(_intersec.surface.zx/4.-0.5);\n    if(mat.id == Floor){\n    \tvec3 tex1 = pow(texture(iChannel1,mat.uv).rgb,vec3(2.2)).rgb/3.2;\n        vec3 tex2 = pow(texture(iChannel3,1.-mat.uv).rgb,vec3(2.2)).rgb/4.2;\n        mat.albedo = mix(tex2,tex1,0.55);\n        mat.emission = mat.albedo;\n    }\n    else if(mat.id == Cuboid){\n        //mat.albedo = vec3(0.1);\n    \tvec3 tex1 = pow(boxmap(iChannel1,_intersec.surface,_intersec.normal,3.).rgb,vec3(2.2))/4.2;\n    \tvec3 tex2 = pow(boxmap(iChannel3,_intersec.surface,_intersec.normal,5.).rgb,vec3(2.2))/4.2;\n        \n        mat.albedo = mix(tex2,tex1,0.9);\n    }\n    else if(mat.id == CenterSphere){\n        _intersec.surface -= spheres[0].position;\n        mat.uv.x = fract(atan(_intersec.surface.z,_intersec.surface.x)/M_2PI_F);\n        float theta = acos(dot(vec3(0.,1.,0.),normalize(_intersec.surface)));\n        mat.uv.y = theta/M_PI_F - 0.5;\n        //mat.albedo = pow(texture(iChannel3,mat.uv).rgb,vec3(2.2))/2.;//clamp(vec3(mat.uv,0.),0.,1.);\n    \t/*\n\t\t\twith Shane's suggestion,it looks more good at before.\n\t\t*/\n        mat.albedo = pow(boxmap(iChannel3, _intersec.surface/3.5, _intersec.normal, 4.).xyz, vec3(2.2))/2.;\n    }\n    else if(mat.id == RotBot){\n    \t//mat.albedo = vec3(0.1);\n        _intersec.surface = fract(_intersec.surface.xyz/3.-0.5);\n    \tvec3 tex1 = pow(boxmap(iChannel2,_intersec.surface,_intersec.normal,3.).rgb,vec3(2.2))/3.;\n    \tvec3 tex2 = pow(boxmap(iChannel3,_intersec.surface,_intersec.normal,5.).rgb,vec3(2.2))/3.;\n        \n        mat.albedo = mix(tex2,tex1,0.5)/1.2;\n    }\n    else if(mat.id == RotBotEYE){\n        //vec3 tex1 = pow(texture(iChannel1,mat.uv).rgb,vec3(2.2)).rgb/3.2;\n        mat.albedo = vec3(0.);\n    }\n\t//mat.nDir = _intersec.normal;\n\tmat.roughness = _intersec.roughness;\n    return mat;\n}\n\nvec3 GetLightIntensity(){\n\treturn AreaLightIntersity*LIGHTCOLOR;\n}\n\nfloat PDF_Area2Angle(float pdf,float dist,float costhe){\n    if(costhe > 0.)\n\t\treturn pdf*dist*dist/costhe;\n\treturn 0.;\n}\n\n/*\n\tJust for area lighting\n\tThe below simple diagrammatic is implement form my method,it descripts how \n\tO (a random point on the Area Surface) position is calculated;\n \n vec3 v0; vec3 v1; vec3 v2; vec3 v3\n       A\t\tB         C        D\n    v3------v2\n\t|\t O\t |\n\tv0------v1\n\tO = v0 + v0v1*X1 + v0v3*X2.       X1 and X2 is uniform random distribute.\n\n\tHere is descript the direct light sample,\n\twe intersect the area light surface within solid angle,\n\tand the solid angle is object surface direct to light ray set.\n\n\tThe fist pdf is on the Area Surface,we easy know every emit point on the Light Area\n\tis uniform distribute,the we can get the probability density is 1/S (S is area)\n\tbut we interesting on the solid angle pdf,so the convert is necessary.\n*/\nvec3 LightSample(vec3 p,float x1,float x2,out vec3 wo,out float dist,out float pdf){\n\tvec3 v0v1 = quads[0].v1 - quads[0].v0;\n    vec3 v0v3 = quads[0].v3 - quads[0].v0;\n    float width  = length(v0v1);\n    float height = length(v0v3);\n    vec3 O = quads[0].v0 + v0v1*x1 + v0v3*x2;\n    wo = O - p;\n    dist = length(wo);\n    wo = normalize(wo);\n    float costhe = dot(-wo,quads[0].normal);\n    pdf = PDF_Area2Angle(1./(width*height),dist,clamp(costhe,0.00001,1.));\n    return costhe>0. ? GetLightIntensity(): vec3(0.);\n}\n/*\n\tYep!if we catch the light ray is on the Area Lighing Surface,\n\twe get the solid angle pdf as same as the up.\n*/\nfloat GetLight_PDF(in Intersection intersecNow,in Intersection intersecNext){\n\tfloat pdf = 0.;\n    if(intersecNext.type == LIGHT){\n        vec3 v0v1 = quads[0].v1 - quads[0].v0;\n    \tvec3 v0v3 = quads[0].v3 - quads[0].v0;\n    \tfloat width  = length(v0v1);\n    \tfloat height = length(v0v3);\n        vec3 lDir = intersecNext.surface - intersecNow.surface;\n        float dist = length(lDir);\n        float costhe = dot(-lDir,quads[0].normal);\n        pdf = PDF_Area2Angle(1./(width*height),dist,costhe);\n    }\n    return pdf;\n}\n\n/*\n\tHum...just get wi (it called omiga) which is descript \n\ta ray that object surface to light.\n*/\nvec3 DirectLightSample(in Intersection intersecNow,out vec3 wi,out float pdf){\n\tvec3 Li = vec3(0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    float dist = INFINITY;\n    vec3 AssumeLi = LightSample(intersecNow.surface,x1,x2,wi,dist,pdf);\n    Ray shadowRay = Ray(intersecNow.surface,wi);\n    Intersection intersecNext;\n    SceneIntersect(shadowRay, intersecNext);\n    if(intersecNext.type == LIGHT){\n    \tLi = AssumeLi;\n    }\n    return Li;\n}\n/*\n\tI implement the BRDF Light Sample direct in Radiance() for clearly read.\n\tand just adopt a Oren Nayar diffuse model\n\tvec3 BRDFLightSample(in Intersection intersecNow,out Intersection intersecNext,out vec3 wi,out float pdf){\n\tvec3 Li = vec3(0.);\n    float x1 = GetRandom(),x2 = GetRandom();\n    wi = sample_uniform_hemisphere(intersecNow.normal,x1,x2,pdf);\n    Ray shadowRay = Ray(intersecNow.surface,wi);\n    SceneIntersect(shadowRay, intersecNext);\n    return Li;\n}\n*/\n\n/*\n\tGet Radiance all the path lighting\n*/\nvec3 Radiance(Ray ray){\n\tvec3 Lo = vec3(0.);\n    Intersection intersecNow;\n\tIntersection intersecNext;\n\tMaterial mat;\n    \n    float d = SceneIntersect(ray,intersecNow);\n    intersecNow.direction = ray.direction;\n    if(d == INFINITY){\n    \t//return texture(iChannel2,ray.direction).rgb*0.2;//BACKGROUND_COL;\n    }\n    else if(intersecNow.type == LIGHT){\n    \t//return texture(iChannel2,ray.direction).rgb*0.2;//BACKGROUND_COL;//GetLightIntensity();\n    }\n    \n    vec3 BSDFThroughout = vec3(1.);\n    vec3 DirectThroughout = vec3(1.);\n    for(int i=0;i<GI_DEPTH;i++){\n        float BSDF_pdf = 0.;\n        float Direct_pdf = 0.;\n        vec3 Li = vec3(0.);\n\t\tOrenNayarBsdf bsdf = GetOrenNayarMaterial(intersecNow);\n\t\tvec3 eval = vec3(0.);\n        /*\n\t\t  (Light Direct Sample) Calculate Direct Lighing and Indirect Lighing\n        */\n\t\t{\n            vec3 wi = vec3(0.);\n        \tLi = DirectLightSample(intersecNow,wi,Direct_pdf);\n            //intersecNow.normal = faceforward(-intersecNow.normal,wi,intersecNow.normal);\n            BSDF_Oren_Nayar_Setup(bsdf);\n            eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n            DirectThroughout *= bsdf.albedo;\n            \n            //use Multiple Importance sample\n            float Light_Weight = 1.;\n            if(UseMIS){\n            \tfloat bsdf_pdf = GetCosWeightSpherePDF(intersecNow.normal,wi);\n                Light_Weight = MISWeight(1.,Direct_pdf,1.,bsdf_pdf);\n            }\n            if(Direct_pdf > 0.){\n            \tLo += Li*DirectThroughout*Light_Weight/Direct_pdf;\n            }\n            \n        }\n        \n        //(BRDF Sample) Calculate Direct Lighing and Indirect Lighing\n        {\n        \tfloat x1 = GetRandom(),x2 = GetRandom();\n            vec3 wi = sample_cos_hemisphere(intersecNow.normal,x1,x2,BSDF_pdf);\n           \tSceneIntersect(Ray(intersecNow.surface,wi),intersecNext);\n            \n            //use Multiple Importance sample\n            float BSDF_Weight = 1.0;\n            if(UseMIS){\n            \tfloat light_pdf = GetLight_PDF(intersecNow,intersecNext);\n                BSDF_Weight = MISWeight(1.,BSDF_pdf,1.5,light_pdf);\n            }\n            if(BSDF_pdf > 0.){\n            \tBSDFThroughout *= bsdf.albedo / BSDF_pdf;\n            }\n            /*\n\t\t\t\tuse Russian Roulette teminal \n            \tfor adapt very bright and very dark,\n\t\t\t\tAs one words for in short,elevate unbias,reduce noise.\n\t\t\t*/\n\t\t\tfloat probability = max(max(BSDFThroughout.x,BSDFThroughout.y),BSDFThroughout.z);\n            #ifdef Linux\n            \tif(probability > 0.){\n            \t\t//if(GetRandom() < probability)\n                    BSDFThroughout /= probability;\n                }\n            #else\n                if(any(greaterThan(BSDFThroughout,vec3(1.))) ){\n                    if(GetRandom() < probability)\n                        BSDFThroughout /= probability;\n                }\n            #endif\n\t\t\tif(intersecNext.distance == INFINITY){\n                Li = vec3(2.);//texture(iChannel2,wi).rgb*SkyLightIntensity;//BACKGROUND_COL;\n                eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n                Lo += Li * eval * BSDFThroughout * BSDF_Weight;\n                break;\n            }\n            else if(intersecNext.type == LIGHT){\n                Li = GetLightIntensity();\n                eval = BSDF_Oren_Nayar_GetIntensity(bsdf,intersecNow.normal,ray.direction,wi);\n                Lo += Li * eval * BSDFThroughout * BSDF_Weight;\n                break;\n            }\n        }\n        \n        //for next tracing path\n        intersecNow = intersecNext;\n        \n    }\n    return Lo;\n}\n\nconst vec2 FRAME_START_UV = vec2(0.,0.);\nvec4 readValues(vec2 xy){\n\treturn texture(iChannel0,(xy+0.5)/R);\n}\nmat3 CameraCoordBase(vec3 campos,vec3 lookAt,vec3 up){\n\tvec3 LookForward = normalize(lookAt - campos);\n    vec3 BaseRight = normalize(cross(LookForward,up));\n    vec3 BaseUp    = normalize(cross(BaseRight,LookForward));\n    mat3 mat = mat3(BaseRight,BaseUp,LookForward);\n\treturn mat;\n}\n\nvoid mainImage( out vec4 C, in vec2 U ){\n\tvec2 iU = U - 0.5;\n    seed = iTime*sin(iTime) + (U.x+R.x*U.y)/(R.y);\n    vec2 uv = (U+U-R)/R.y;\n    vec2 mousePos = readValues(FRAME_START_UV).yz;\n    if(iFrame <= 1){\n         mousePos = vec2(0.,R.y/2.3);\n\t}\n    mousePos.y = clamp(mousePos.y,R.y*0.33,R.y*0.6);\n    mousePos = mousePos/R*20.;\n    vec3 pos = vec3(cos(mousePos.x),mousePos.y/2.-0.5,sin(mousePos.x));\n    \t pos.xz *= 2.5;\n    vec3 dir = normalize(vec3(uv,2.));\n\tpos.xy += cos(GetRandom()*M_2PI_F+vec2(0.,M_H_PI_F))*(dir.xy*GetRandom()*length(R/R.x)*0.17);\n    dir = RotVector(CameraCoordBase(pos,vec3(-.3,0.05,0.),vec3(0.,1.,0.)),dir);\n    dir = normalize(dir);\n    \n    SetupScene();\n    //vec2 dither = TriangularNoise2DShereRay(uv,iTime);\n    //pos += (RotVector(cameraSpace,vec3(dither,0.)))*0.004;\n    Ray ray = Ray(pos,dir);\n    vec3 col = Radiance(ray);\n    if(all(equal(iU,FRAME_START_UV))){\n        if(iFrame == 0){\n            C = vec4(1.,vec2(0.,R.y/2.3),0.);\n        }\n        else{\n            if(iMouse.z > 1.){\n                vec2 mousePos_Before = readValues(FRAME_START_UV).yz;\n                C = vec4(1.,iMouse.xy,0.);\n                \n            }\n            else{\n                C = readValues(FRAME_START_UV);\n                ++C.r;\n            }\n        }\n    }\n    else{\n        if(iFrame == 0){\n        \tC = vec4(col.rgb,0.);\n        }\n        else{\n            vec4 Frame_data = readValues(FRAME_START_UV);\n            C = texture(iChannel0,U/R);\n            /*\n\t\t\t\t蒙特卡洛 积分(Monte Carlo Integration)\n\t\t\t\tthe math is: sum(x1+x2+x2+...+xn)/N     \n\t\t\t\tC = C*(1-1/n) + col *(1/n)    the n is ∈(1,N)\n\t\t\t*/\n            C = mix(C,vec4(col,1.),1./Frame_data.r);\n        }\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "#define M_PI_F\t 3.14159274101257\n#define M_H_PI_F 1.5707963267948966\n#define M_2PI_F  6.2831853071795864 \n#define M_1_PI_F 0.3183098861837067\n#define INFINITY 1000000.0\n#define INFINITY_MIN 1.175494351e-38\n#define OFFSET_VALUE 0.00001\n#define R iResolution.xy\n\nstruct OrenNayarBsdf {\n\t//vec3 weight;\n    int id;\n    vec2 uv;\n    vec3 albedo;\n    vec3 emission;\n\t//float sample_weight;\n\tvec3 nDir;\n\tfloat roughness;\n\tfloat a;\n\tfloat b;\n};\n    \nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}    \n    \nvoid frisvad(in vec3 n, out vec3 f, out vec3 r){\n    if(n.z < -0.999999) {\n        f = vec3(0.,-1,0);\n        r = vec3(-1, 0, 0);\n    } else {\n    \tfloat a = 1./(1.+n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n}\nmat3 CoordBase(vec3 n){\n\tvec3 x,y;\n    frisvad(n,x,y);\n    return mat3(x,y,n);\n}\nvec3 ToOtherSpaceCoord(mat3 otherSpaceCoord,vec3 vector){\n\treturn vector * otherSpaceCoord;\n}\nvec3 RotVector(mat3 otherSpaceCoord,vec3 vector){\n\treturn otherSpaceCoord * vector;\n}\n\n/* cosin weight */\nfloat GetCosWeightSpherePDF(in vec3 nDir,in vec3 wi){\n\tfloat pdf = 1.;\n    float costheta = max(0.,dot(nDir,wi));\n    pdf = costheta*M_1_PI_F;\n    return pdf;\n}\nvec3 sample_cos_hemisphere(in vec3 N,float x1, float x2,out float pdf){\n    float phi = M_2PI_F * x1;\n\tfloat r = sqrt(x2);\n\tx1 = r * cos(phi);\n\tx2 = r * sin(phi);\n\tvec3 T, B;\n\tfrisvad (N, T, B);\n\tfloat costheta = sqrt(max(1.0f - x1 * x1 - x2 * x2, 0.0));\n\tpdf = M_1_PI_F;\n\treturn x1 * T + x2 * B + costheta * N;\n}\n/* sample direction uniformly distributed in hemisphere */\nfloat GetUniformDiffusePDF(){\n    return 0.5 * M_1_PI_F;\n}\nvec3 sample_uniform_hemisphere(in vec3 N,float x1, float x2, out float pdf){\n\tfloat z = x1;\n\tfloat r = sqrt(max(0., 1. - z*z));\n\tfloat phi = M_2PI_F * x2;\n\tfloat x = r * cos(phi);\n\tfloat y = r * sin(phi);\n\tvec3 T, B;\n\tfrisvad (N, T, B);\n\tpdf = 0.5 * M_1_PI_F;\n    return x * T + y * B + z * N;\n}\n\nvoid BSDF_Oren_Nayar_Setup(inout OrenNayarBsdf bsdf){\n\tfloat sigma = bsdf.roughness;\n\tsigma = clamp(sigma,0.,1.);\n\tfloat div = 1. / (M_PI_F + ((3. * M_PI_F - 4.) / 6.) * sigma);\n\tbsdf.a = div;\n\tbsdf.b = sigma * div;\n}\n\n//BSDF Oren-Nayar evalution\nvec3 BSDF_Oren_Nayar_GetIntensity(OrenNayarBsdf bsdf,vec3 n,vec3 v,vec3 l){\n\tfloat nl = max(dot(n, l), 0.);\n\tfloat nv = max(dot(n, v), 0.);\n\tfloat t = max(dot(l, v),0.) - nl * nv;\n\tif(t > 0.)\n\t\tt /= max(nl, nv) + INFINITY_MIN;\n\tfloat is = nl * (bsdf.a + bsdf.b * t);\n\treturn vec3(is);\n}\n\n\n//!!!!!! For BSDF light sample\nvec3 BSDF_Oren_Nayar_Sample(OrenNayarBsdf bsdf,vec3 Ng,vec3 vDir,float x1, float x2,out vec3 eval,out vec3 wi,out float pdf){\n\t//pre values\n    BSDF_Oren_Nayar_Setup(bsdf);\n    wi = sample_uniform_hemisphere(bsdf.nDir, x1, x2, pdf);\n\tif(dot(Ng, wi) > 0.){\n\t\teval = BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);\n\t}\n\telse{\n\t\tpdf = 0.;\n\t\teval = vec3(0.);\n\t}\n\treturn eval;\n}\n//!!!!!! For Single Scatter Sample\nvec3 BSDF_Oren_Nayar_Eval_Reflect(OrenNayarBsdf bsdf, vec3 vDir, vec3 wi, float pdf){\n\tif(dot(bsdf.nDir, wi) > 0.) {\n\t\tpdf = 0.5 * M_1_PI_F;\n\t\treturn BSDF_Oren_Nayar_GetIntensity(bsdf, bsdf.nDir, vDir, wi);\n\t}\n\telse {\n\t\tpdf = 0.0f;\n\t\treturn vec3(0.);\n\t}\n}\n\n\n\n//------------Multiple Importance Sample Weight-----------\n/*\n\theuristic\n\there βis 2;so power of coeff\n*/\nfloat MISWeight(float a,float b){\n\tfloat a2 = a*a;\n\tfloat b2 = b*b;\n\treturn a2/(a2+b2);\n}\nfloat MISWeight(float coffe_a,float aPDF,float coffe_b,float bPDF){\n    return MISWeight(coffe_a * aPDF,coffe_b*bPDF);\n}\n\n/*\n\thttps://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ToneMapping.hlsl\n*/\nvec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = (color.r < 0.0031308) ? x.r : y.r;\n    clr.g = (color.g < 0.0031308) ? x.g : y.g;\n    clr.b = (color.b < 0.0031308) ? x.b : y.b;\n    return clr;\n}\nvec3 sRGB2Linear(vec3 color){\n    vec3 x = color / 12.92f;\n    vec3 y = pow(max((color+0.055f)/1.055, 0.0),vec3(2.4));\n    vec3 clr = color;\n    clr.r = color.r <= 0.04045 ? x.r : y.r;\n    clr.g = color.g <= 0.04045 ? x.g : y.g;\n    clr.b = color.b <= 0.04045 ? x.b : y.b;\n    return clr;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}