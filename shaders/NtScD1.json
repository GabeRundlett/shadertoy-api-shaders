{
    "Shader": {
        "info": {
            "date": "1649605292",
            "description": "Simple Cornell box scene, so far I've implemented diffuse reflection, glossy reflection, refraction, and emission.\nworking on DOF rn\n\nMove your mouse around to change the camera orientation, wait for the picture to clear up.",
            "flags": 48,
            "hasliked": 0,
            "id": "NtScD1",
            "likes": 5,
            "name": "Dog God's path tracer",
            "published": 3,
            "tags": [
                "reflection",
                "refraction",
                "cornellbox",
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "dog_god",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "vec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), -1.0f, 1.0f);\n}\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float exposure = 1.;\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color *= exposure;\n    color = ACESFilm(color);\n    color = LinearToSRGB(color);\n    fragColor = vec4(color, 1.0f);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float fresnel(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n\nvec3 rot(in vec3 inp, in vec3 rot){\n    float s1 = sin(rot.x);\n    float c1 = cos(rot.x);\n    float s2 = sin(rot.y);\n    float c2 = cos(rot.y);\n    float s3 = sin(rot.z);\n    float c3 = cos(rot.z);\n    \n    float a = c2 * c3 * inp.x;\n    float b = (s1*s2*c3 - c1*s3)*inp.y;\n    float g = (c1*s2*c3 + s1*s3)*inp.z;\n    \n    float a1 = c2 * s3 * inp.x;\n    float b1 = (s1*s2*s3 + c1*c3)*inp.y;\n    float g1 = (c1*s2*s3 - s1*c3)*inp.z;\n    \n    float a2 = -s2*inp.x;\n    float b2 = s1*c2*inp.y;\n    float g2 = c1*c2*inp.z;\n    \n    \n    return vec3((a+b+g),(a1+b1+g1),(a2+b2+g2));\n}\n\n\n\nvec3 torNormal( in vec3 pos, vec2 tor )\n{\n    return normalize( pos*(dot(pos,pos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nstruct HitInfo\n{\n    vec3 normal;\n    float distance;\n    bool inside;\n\n};\n\nstruct Material{\n    vec3 emission;\n    vec3 albedo;\n    float roughness;\n    float specularity;\n    vec3 specularColor;\n    float IOR;\n    float refChance;\n    float refRoughness;\n    vec3 refColor;\n};\n\nMaterial stock(){\n    Material mat;\n    mat.emission = vec3(0.);\n    mat.albedo = vec3(1.);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    mat.IOR = 1.33;\n    mat.refChance = 0.;\n    mat.refRoughness = 0.;\n    mat.refColor = vec3(1.);\n    return mat;\n}\n\n\n\nfloat c_twopi = 6.28318530718;\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RUV(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat BIG = 100000.;\n\n// axis aligned box centered at the origin, with size boxSize\nvec3 box( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    bool i = true;\n    if ( tN>tF || tF<0.0) i = false;\n    if( tN>tF || tF<0.0) return vec3(vec2(BIG),i); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    if (tN < 0.){\n    tN = BIG;\n    }\n    return vec3( tN, tF,i);\n}\n\n// plane degined by p (p.xyz must be normalized)\nvec2 plane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    float m = -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n    bool i = false;\n    if (m > 0.){i = true;}\n    if (m < 0.){\n    return vec2(BIG,i);}\n    return vec2(m,i);\n}\nfloat torus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        if (t < .01){\n        t = BIG;\n        }\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return BIG;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\n\n\n\n// sphere of size ra centered at point ce\nvec4 Sphere( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    if(b > 0.){\n    return vec4( BIG );\n    }\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec4(BIG); // no intersection\n    h = sqrt( h );\n    if( h==0.0 ) return vec4(BIG);\n    vec3 hit = (ro + (rd*(-b-h)));\n    vec3 ohit = (ro + (rd*(-b+h)));\n    vec3 normal = normalize((hit - ce)/ra);\n    float d = -b-h;\n    if(distance(ro,ce)<ra){\n        d = -b+h;\n        //normal = normalize((ohit - ce)/ra);\n    }\n    return vec4(normal, d );\n}\n\n\n\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 Scene(in vec3 pos, in vec3 ray, inout HitInfo hit, out Material mat){\n    vec3 BoxSize = vec3(2,.5,2);\n    vec4 PlaneNormal = vec4(0.,1.,0.,0.);\n    vec2 TorusSettings = vec2(2.,.5);\n    vec3 BoxNormal1;\n    vec3 BoxNormal2;\n    vec3 BoxNormal3;\n    vec3 BoxNormal4;\n    vec3 BoxNormal5;\n    vec3 BoxNormal6;\n    vec3 BoxNormal7;\n    vec3 BoxNormal8;\n    vec3 BoxNormal9;\n    vec3 BoxOrigin1 = vec3(0.,13.5,0.);//light\n    vec3 BoxOrigin2 = vec3(10.,0.1,10.);//floor\n    vec3 BoxOrigin3 = vec3(3.,1.2,-3.);//tiny cube on the right\n    vec3 BoxOrigin4 = vec3(-3,8.,6.);//back wall mirror\n    vec3 BoxOrigin5 = vec3(7.,10.,0.);//red wall\n    vec3 BoxOrigin6 = vec3(-7.,10.,0.);//green wall\n    vec3 BoxOrigin7 = vec3(0.,10.,10.);//z wall\n    vec3 BoxOrigin8 = vec3(0.,14.,0.);//ceiling\n    vec3 BoxOrigin9 = vec3(-4.,2.,-3.);//tiny cube\n    vec3 TorOrigin = vec3(-4,4.,0.);\n    vec3 R = vec3(0.2,.5,0.2);\n    vec3 R1 = vec3(0.,0.2,0.);\n    vec3 R2 = vec3(1.5,-0.6,0.);\n    vec3 R3 = vec3(0.,-0.2,0.);\n    vec3 SphereOrigin = vec3(2.,4.,4.);\n    vec3 SphereOrigin2 = vec3(4.,8,2.);\n    vec3 BoxIntersect1 = box(pos-BoxOrigin1,ray,BoxSize,BoxNormal1);\n    vec3 BoxIntersect2 = box(pos,ray,BoxOrigin2,BoxNormal2);\n    vec3 BoxIntersect3 = box(rot(pos-BoxOrigin3,R3),rot(ray,R3),vec3(1.,1.2,1.),BoxNormal3);\n    vec3 BoxIntersect4 = box(rot(pos-BoxOrigin4,R),rot(ray,R),vec3(3.,4.,.2),BoxNormal4);\n    vec3 BoxIntersect5 = box(pos-BoxOrigin5,ray,vec3(.5,10.,10.),BoxNormal5);\n    vec3 BoxIntersect6 = box(pos-BoxOrigin6,ray,vec3(.5,10.,10.),BoxNormal6);\n    vec3 BoxIntersect7 = box(pos-BoxOrigin7,ray,vec3(10.,10.,.5),BoxNormal7);\n    vec3 BoxIntersect8 = box(pos-BoxOrigin8,ray,vec3(10.,.5,10.),BoxNormal8);\n    vec3 BoxIntersect9 = box(rot(pos-BoxOrigin9,R1),rot(ray,R1),vec3(1,2,1),BoxNormal9);\n    float TorusIntersect = torus(rot(pos-TorOrigin,R2),rot(ray,R2),TorusSettings);\n    vec3 TorusNormals = torNormal(rot(pos+ray*TorusIntersect-TorOrigin,R2),TorusSettings);\n    vec4 SphereIntersect = Sphere(pos,ray,SphereOrigin,2.);\n    vec4 SphereIntersect2 = Sphere(pos,ray,SphereOrigin2,1.2);\n    \n    BoxNormal9 = rot(BoxNormal9,-R1);\n    TorusNormals = rot(TorusNormals,-R2);\n    BoxNormal3 = rot(BoxNormal3,-R3);\n    \n    float SceneDepth = min(min(BoxIntersect1.x,BoxIntersect2.x),TorusIntersect);\n    SceneDepth = min(SceneDepth,BoxIntersect3.x);\n    SceneDepth = min(min(SceneDepth,BoxIntersect4.x),BoxIntersect5.x);\n    SceneDepth = min(SceneDepth, BoxIntersect6.x);\n    SceneDepth = min(SceneDepth, SphereIntersect.w);\n    SceneDepth = min(min(SceneDepth, SphereIntersect2.w),BoxIntersect7.x);\n    SceneDepth = min(SceneDepth,BoxIntersect7.x);\n    SceneDepth = min(SceneDepth,BoxIntersect8.x);\n    SceneDepth = min(SceneDepth,BoxIntersect9.x);\n    //decide all the object parameters\n    if (TorusIntersect == SceneDepth){\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = TorusNormals;\n    mat.specularity = 1.;\n    mat.specularColor = vec3(1.);\n    mat.roughness = 0.6;\n    }\n    if (BoxIntersect1.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.8,0);\n    mat.emission = vec3(10.,4.,3.);\n    hit.normal = normalize(BoxNormal1);\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect2.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = normalize(BoxNormal2);\n    mat.roughness = 1.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect3.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal3);\n    mat.roughness = 0.1;\n    mat.specularity = .2;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect4.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.3,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(rot(BoxNormal4,-R));\n    mat.roughness = 0.1;\n    mat.specularity = 1.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect5.x == SceneDepth){\n    mat = stock();\n    mat.albedo = vec3(1.,0.3,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal5);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }\n    if (BoxIntersect6.x == SceneDepth){\n    mat.albedo = vec3(.3,1.,0.2);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal6);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }    \n\n    if (SphereIntersect.w == SceneDepth){\n    mat.albedo = vec3(1.);\n    mat.emission = vec3(0.);\n    hit.normal = vec3(SphereIntersect.xyz);\n    mat.specularity = 1.;\n    mat.roughness = 0.5;\n    mat.specularColor = vec3(1.);\n    }\n    if (SphereIntersect2.w == SceneDepth){\n    mat = stock();\n    mat.refChance = 1.;\n    hit.normal = vec3(SphereIntersect2.xyz);\n    mat.IOR = (1.2);\n    mat.specularity = 0.1;\n    mat.roughness = 0.1;\n    mat.refRoughness = 0.1;\n    }\n    \n    if (BoxIntersect7.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal7);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }  \n    if (BoxIntersect8.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal8);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    } \n    if (BoxIntersect9.x == SceneDepth){\n    mat.albedo = vec3(1.,1.,1.);\n    mat.emission = vec3(0.,0.,0.);\n    hit.normal = normalize(BoxNormal9);\n    mat.roughness = 1.;\n    mat.specularity = 0.;\n    mat.specularColor = vec3(1.);\n    }  \n    hit.distance = SceneDepth;\n    hit.normal = normalize(hit.normal);\n    return hit.normal;\n}\nvec3 PathTrace(in vec3 pos, in vec3 ray, inout uint rngstate, out HitInfo Hit){\n    vec3 StartNormal;\n    vec3 T = vec3(1.);\n    vec3 R = vec3(0.);\n    \n    Material Mat;\n    for(int i = 0; i <= 10; i++){\n    \n    Mat = stock();\n    Hit.distance = BIG;\n    Hit.inside = false;\n    Scene(pos,ray,Hit,Mat);\n    //if(Hit.distance < -1.){\n    //    break;\n    //}\n    //for(int j = 0; j < 20; j++){\n    //if(Hit.distance == BIG){\n    \n    //R += SRGBToLinear((texture(iChannel1, ray).rgb * T)*0.7);\n    //Scene(pos,ray,Hit,Mat);\n     \n    //break;\n    \n    //}\n    //}\n    \n    if(Hit.inside){\n    T *= exp(-Mat.refColor*Hit.distance);\n    \n    }\n    \n    float specChance = Mat.specularity;\n    float refChance = Mat.refChance;\n    float rayProb = 1.;\n    \n    if(specChance > 0.){\n        specChance = fresnel(\n        Hit.inside ? Mat.IOR : 1.0,\n        !Hit.inside ? Mat.IOR : 1.0,\n        ray, Hit.normal, Mat.specularity, 1.0);  \n        float chanceMult = (1.-specChance)/(1.-Mat.specularity);\n        refChance *= chanceMult;\n    }\n    \n    // calculate whether we are going to do a diffuse, specular, or refractive ray\n    float doSpec = 0.;\n    float doRef = 0.;\n    float raySelRoll = RandomFloat01(rngstate);\n    \n    if(specChance > 0. && raySelRoll < specChance){\n        doSpec = 1.;\n        rayProb = specChance;\n    }\n    else if (refChance > 0. && raySelRoll < specChance + refChance)\n    \n    {\n        doRef = 1.;\n        rayProb = refChance;\n    }\n    \n    else \n    \n    {\n        rayProb = 1.0-(specChance + refChance);\n    }\n    \n    rayProb = max(rayProb,0.001);\n    \n    if(doRef == 1.)\n    \n    {\n        pos = (pos+ray * Hit.distance) - Hit.normal * 0.01;\n    }\n    \n    else \n    \n    {\n        pos = (pos+ray * Hit.distance) + Hit.normal * 0.01;\n    }\n    \n    float spec = (RandomFloat01(rngstate) < specChance) ? 1.0f : 0.0f;\n    \n    // avoid numerical issues causing a divide by zero\n    rayProb = max(rayProb, 0.001f);  \n    \n    \n    \n    vec3 dif = normalize(Hit.normal + RUV(rngstate));\n    \n    \n    \n    vec3 glos = reflect(ray,Hit.normal);\n    glos = normalize(mix(glos, dif, Mat.roughness * Mat.roughness));\n    \n    \n    vec3 ref = refract(ray, Hit.normal,Hit.inside ? Mat.IOR : 1. / Mat.IOR );\n    ref = normalize(mix(ref,normalize(-Hit.normal+RUV(rngstate)),Mat.refRoughness * Mat.refRoughness));\n    \n    \n    ray = mix(dif, glos, doSpec);\n    \n    ray = mix(ray, ref, doRef);\n    \n    R += Mat.emission * T;\n    \n    \n    if(doRef == 0.){\n    \n    T *= mix(Mat.albedo,Mat.specularColor,doSpec);\n    \n    }\n    \n    \n    \n    T /= rayProb;\n    \n    \n    //roulette \n    float p = max(T.r, max(T.g, T.b));\n    if (RandomFloat01(rngstate) > p)\n        break;\n \n    // Add the energy we 'lose' by randomly terminating paths\n    \n    T *= 1.0f / p;\n    \n    }\n    return R;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float mx = iMouse.x/iResolution.x;//normalized mouse xy\n    float my = iMouse.y/iResolution.y;\n    vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;\n    vec2 angle;\n    float fov = 150.;\n    float cameraDistance = 1.0f / tan(fov * 0.5f * 3.14159 / 180.0); \n    angle = -(vec2(mx,my)-.5)*3.14*2.;//get angle for the camera rotation\n    vec3 pos = vec3(0.,0.,0.);//camera coord position, change z for distance\n    vec3 ray = vec3((fragCoord+jitter-iResolution.xy*.5)/iResolution.x,cameraDistance);//normalize shit\n    Rotate(pos,angle);//Rotate position, remove for fps camera\n    Rotate(ray,angle);//Rotate the ray angle\n    ray = normalize(ray);\n    pos = pos + vec3(0.,5.,-10.0);\n    HitInfo M;\n    Material M2;\n    Scene(pos,ray,M,M2);\n    HitInfo J; \n    vec3 color = PathTrace(pos,ray,rngState,J);\n    //bool spacePressed = (texture(iChannel2, vec2(32.5/256.0,0.25)).x > 0.1);\n    bool mouseDown = iMouse.z > 0.0;\n    // average the frames together\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f || mouseDown) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n    fragColor = vec4(color, blend);\n    //fragColor = vec4(J.normal,0.);\n    \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}