{
    "Shader": {
        "info": {
            "date": "1580465254",
            "description": "basic operations, trig functions, hyperbolic trig functions.",
            "flags": 0,
            "hasliked": 0,
            "id": "3l3SzN",
            "likes": 5,
            "name": "Complex numbers",
            "published": 3,
            "tags": [
                "complex"
            ],
            "usePreview": 0,
            "username": "hazenn",
            "viewed": 438
        },
        "renderpass": [
            {
                "code": "\n//A few functions that implement complex number operations for vec2\n\nconst vec2 c_i = vec2(0,1);\nconst float PI = 3.1415926535897;\nvec2 c_cjg(in vec2 c) {\n\treturn vec2(c.x, -c.y);\n}\n\nvec2 c_mul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 c_pow(in vec2 c, int p) {\n    vec2 temp = vec2(1.0,0.0);\n\tfor (int i = 0; i < p; ++i) {\n\t\ttemp = c_mul(temp, c);\n\t}\n    return temp;\n}\nvec2 c_div(in vec2 a, in vec2 b) {\n    return\n        vec2(a.x*b.x + a.y*b.y,\n             a.y*b.x - a.x * b.y)\n        / (b.x * b.x + b.y * b.y)\n        ;\n}\nvec2 c_exp(in vec2 c) {\n    return exp(c.x) * vec2(cos(c.y),sin(c.y));\n}\n//uses the even-odd split formula, there are probably better ways\nvec2 c_sin(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c_mul(c_i , c))\n            -c_exp(c_mul(-c_i , c))\n            ,\n            2.*c_i\n\n        );\n}\nvec2 c_cos(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c_mul(c_i , c))\n            +c_exp(c_mul(-c_i , c))\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_sinh(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c)\n            -c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\nvec2 c_cosh(in vec2 c) {\n    return \n        c_div(\n        \tc_exp(c)\n            +c_exp(-c)\n            ,\n            2. * vec2(1.,0.)\n\n        );\n}\n\n//below is an use case : displaying various mandelbrot-style fractals i found on wikipedia\n\n\nvec2 uv_scaled(vec2 uv, vec2 top_left, vec2 bot_right)\n{\n    return mix(top_left.xy,bot_right.xy,uv.xy);\n}\nfloat F (float x)\n{\n\treturn (cos(PI * (x+1.0))+1.0)/2.0;\n}\nvec2 f(vec2 c,vec2 z, float t)\n{\n    //the function used to define the sequence\n\treturn\n        c_sinh(z + c_div(c_i.yx * t, c_mul(c,c)));\n        \n}\n/*\nreturn \n        c_cjg(\n            c_pow(z,2)\n            +\n            c_sin(c_pow(c,3) + c_i * t)\n            )\n        ; \n*/\nfloat fractal(vec2 c, int n, float t)\n{\n    vec2 z = vec2(1.,0.1);\n    for (int i = 0; i < n;i++)\n    {\n        if (sqrt(z.x*z.x + z.y*z.y)  > 200.0)\n        {\n            return (1.0-float(i)*float(i)/float(n)*float(n));\n\t\t}\n        z = f(c,z,t);\n        \n    }\n    return 0.0;\n}\nvec3 colorA = vec3(0.03137254901,0.05882352941,0.05882352941);\nvec3 colorB = vec3(0.6431372549,0.7294117647,0.7294117647);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 c = uv_scaled(uv,vec2(-1.5,1.5),vec2(1.5,-1.5));\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = mix(colorA,colorB,F(fractal(c/(0.15*0.15) + vec2(0.25,0.),300,iTime)));\n    //col.x = c.x;\n    //col.y = c.y;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}