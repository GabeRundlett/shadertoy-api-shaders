{
    "Shader": {
        "info": {
            "date": "1472143212",
            "description": "trying to fix, merge and optimize hex-tiling-code of multiple sources, i find them rather inaccurate and therefore incompatible.\n\nthis illustrates how inaccurate even iq is when it comes to hexagons, not caring how deformed it is.",
            "flags": 0,
            "hasliked": 0,
            "id": "4ltGDf",
            "likes": 10,
            "name": "fixing hexagonal tiling",
            "published": 3,
            "tags": [
                "hexagon",
                "hex"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 1275
        },
        "renderpass": [
            {
                "code": "//hex tiling merger with various issues:\n//press pause when zoomed in to notice them:\n//or take a screenshot and rotate it by 90 or 60 degree and overlay it transparent.\n//the circles are not round.\n//the circle centers are not bilateral triangles.\n//yet this is the commonly used hex-tiling code.\n\n//this is the result of ollj, trying to fix the errors of iq hex-tiling code (its .w value is bad)\n//by inserting a (scaled) commonly used (optimitzed) hex-tiling code to get a better .w value\n//and both are to inaccurate that i had to twiddle values to make them overlap a bit.\n\n//firstly, both used hex-tiling-function sources lack symetry so much they are not even trying!\n//the hex centers are not forming equilateral triangles. not even close! only bilateral!\n//for the commonly used hex function!\n//and iq's hex function seems to not care ro return a precise hexagon.\n\n//secondly this needs some tweaking of all the used constants\n//to better approximate y=sin(PI/3) and y=cos(pi/3) and their inverses and x=1-y and whatever ratios of them are used.\n//Wherever these values appear, they seem to noticably lack precision when you look at this up close:\n//.5773503;\n//1.53\n//1.73\n//and these 2 twiddle factors, masking inaccuracies.\n//1.969\n//1.15\n\n//thirdly, i needed to twiddle a subroutine and the initial scaling, \n//causing the circles to not be circular or the hexagon not to be hexagonal. its pretty pathethic.\n\n//quaterly, the HexID.xy code of IQ seems to come with some rounding errors\n//on very smooth gradients. \n//possibly just an illusion of having a visible ceiling\n//for values being shown with color ranges.\n\n//you can see that functions are inaccurate in their x/y scaling of hex-centers\n//as the blue hex borders are only from IQs hex tiling code, and they are not hexagonal!\n//seeing that centers only form bilateral triangles and not equilateral triangles\n//... because both hex functions that i merged use poorly rounded x/y scaling values.\n//\n//you can also see that iq code is VERY inaccirate in the diagonals angle of a hex tile, \n//or is this an effect of (trying to hide) the above?\n\n//may use below function to check on precision:\n//return circle-circle-intersection.x; .x>.y -> 2 radii; .z= distance of circle centers.\n//float cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//circle-circle-intersection.y=sqrt((circle-circle-intersection.x*circle-circle-intersection.x)-(.x*.x));\n\n//return f[x] of a SeeSaw curve with [w]avelength and [a]mplitude; returns range [0..amp]\nfloat seeSaw(float x,float w,float a){return mod(x,w)*a;}\n//set [a]mplitude = 1/[w]avelength\nfloat seeSaw2(float x,float w){return seeSaw(x,w,1./w);}\n///return sin(t), shifted to range [0...1]\nfloat sinP(float t){return(sin(t)+1.)*.5;}\n\n//return mat2 rotation; r=2*PI -> full rotation\nmat2 rot2(float r){float c=cos(r),s=sin(r);return mat2(c,s,-s,c);}\n\n//return distance to center of hex Tile. //taken from a most commonly used hextile function.\nfloat hexC(vec2 i){const float w=1.53,q=w*.5;//i.x*=iResolution.x/iResolution.y;\n vec2 u=i;u*=mat2(1.,-1./w,0.,1./q);\n vec3 g=vec3(u,1.-u.xy);u=floor(g).xy*mat2(1.,.5,0.,q)-i;\n return min(min(length(u),length(vec2(1,0)+u)),min(length(vec2(.5,q)+u),length(vec2(1.5,q)+u)));}\n\n//Created by inigo quilez - iq/2014 , .w replaced by ollj 2016.\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//return hex vec4(cellId.xy,DistanceToBorder.z,DistnaceToCenter.w)\nvec4 hex(vec2 p){float z=p.x*.5773503;\n vec2 q=vec2(2.*z,p.y+z),i=floor(q),f=fract(q),m=step(f.xy,f.yx);\n float v=mod(i.x+i.y,3.),//WTF???\n a=step(1.0,v),b=step(2.0,v);// distance to borders\t\n float e=dot(m,1.-f.yx+a*(f.x+f.y-1.)+b*(f.yx-2.*f));\nreturn vec4(i+a-b*m,e,hexC(p/vec2(1.73,1.969)));}\n//1.969 is a bit fiddly, rounded and likely not very accurate.\n//i assume it should be 2.0 if 1.53 and 1.73 are more precise.\n\n\n//distance to a single hexagon.\n//float hexSingle(vec2 p){p.y+=1.-.5773503;p=vec2(1)-abs(p);return min(p.x,(p*rot2(3.14/3.)).x);}\n\nvoid mainImage(out vec4 o,in vec2 i){\n vec2 p=i/iResolution.xy; \n p.y*=1.15*iResolution.y/iResolution.x; //its already sad that this needs the *1.15 twiddle factor to make circles roughly circullar.\n float t=sin(iTime*.2)*.5+.52;\n p-=iMouse.xy/iResolution.xy-vec2(.5,.0);//mouse movement\n p*=32.*t;\n vec4 h=hex(p);\n h.xy/=16.;h.xy-=0.5;//ID-color-shift\n h.w=seeSaw2(h.w-iTime*.1,.1);\n h.y+=seeSaw2(h.z-.01,.1);\n o=vec4(h.wxy,1.0);\n //float d=hexSingle(p);d=SeeSaw2(d,.03);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}