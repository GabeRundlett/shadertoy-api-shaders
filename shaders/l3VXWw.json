{
    "Shader": {
        "info": {
            "date": "1720047888",
            "description": "showing that atan(v.y, v.x) == acos(dot(v, x-axis)) * left-or-right-side-of-the-x-axis.\n\nouter circle is atan(), inner circle is acos(dot()).\n",
            "flags": 0,
            "hasliked": 0,
            "id": "l3VXWw",
            "likes": 12,
            "name": "atan() & acos(dot()) equivalence",
            "published": 3,
            "tags": [
                "math",
                "atan",
                "acos",
                "dot"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 164
        },
        "renderpass": [
            {
                "code": "/*\n    Roses are red and violets are blue,\n    I write this boilerplate every single time.\n*/\n\nconst float gZoom       = 0.8;\n      float gT;         // set in main\n      float gLineWidth; // set in main\n      float gAAEps;     // set in main\n      \nfloat len(vec2 p, float k) {\n    float x = pow(abs(p.x), k);\n    float y = pow(abs(p.y), k);\n    return    pow(x + y, 1.0 / k);\n    \n}\n\nvec3 palette(float a) {\n    return mix(vec3(1, 0, 0), vec3(0, 1, 0), a);\n}\n\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    gT         = iTime;\n    gLineWidth = VIEWFROMSCREEN_DIST(20.0);\n    gAAEps     = VIEWFROMSCREEN_DIST(2.0);\n    vec2 p     = VIEWFROMSCREEN     (XY );\n    \n    vec3 rgb = vec3(0.0, 0.4, 1.0) * 0.3;\n\n\n    // outer circle\n    float q1   = atan(p.y, p.x);\n    \n    // inner circle\n    float side = sign(p.y);\n    float q2   = acos(dot(normalize(p), vec2(1, 0))) * side;\n    \n    // map [-pi, pi] -> [0, 1]\n    q1 = (q1 / pi) * 0.5 + 0.5;\n    q2 = (q2 / pi) * 0.5 + 0.5;\n\n    float d, c;\n\n    d   = abs(length(p) - 1.0) - gLineWidth;\n    c   = smoothstep(gAAEps, -gAAEps, d);\n    rgb = mix(rgb, palette(q1), c);\n\n    d   = abs(length(p) - 0.8) - gLineWidth;\n    c   = smoothstep(gAAEps, -gAAEps, d);\n    rgb = mix(rgb, palette(q2), c);\n\n    RGBA.rgb  = rgb;\n    \n    // housekeeping\n    RGBA.rgb *= 1.0 - pow(LENGTHSQR(XY/RES - 0.5) * 1.5, 3.0);\n    RGBA.rgb  = pow(RGBA.rgb, vec3(1.0 / 2.2));\n    RGBA.a    = 1.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const vec2  v01 = vec2(0.0, 1.0);\nconst vec3  vX  = v01.yxx;\nconst vec3  vY  = v01.xyx;\nconst vec3  vZ  = v01.xxy;\nconst vec3  v0  = v01.xxx;\nconst vec3  v1  = v01.yyy;\nconst float pi  = 3.14159265359;\n\n#define RES    (iResolution.xy)\n#define MINRES (min(RES.x, RES.y))\n\n#define VIEWFROMSCREEN_DIST(distance)                     \\\n        ( (distance) / MINRES / gZoom                     )\n#define VIEWFROMSCREEN(xy)                                \\\n        ( vec2(VIEWFROMSCREEN_DIST((xy).x * 2.0 - RES.x), \\\n               VIEWFROMSCREEN_DIST((xy).y * 2.0 - RES.y)) )\n               \n#define LENGTHSQR(a) ( dot((a), (a)) )\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}