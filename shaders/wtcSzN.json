{
    "Shader": {
        "info": {
            "date": "1580500099",
            "description": "Something for [url]https://cineshader.com/view/wtcSzN[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "wtcSzN",
            "likes": 216,
            "name": "DVD Bounce",
            "published": 3,
            "tags": [
                "waves",
                "logo",
                "bounce",
                "dvd",
                "cineshader"
            ],
            "usePreview": 1,
            "username": "tdhooper",
            "viewed": 275047
        },
        "renderpass": [
            {
                "code": "\n#define PI 3.14159265359\n\n\n//#define DEBUG\n\n  \n    \nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat ellip(vec2 p, vec2 s) {\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\nfloat halfEllip(vec2 p, vec2 s) {\n    p.x = max(0., p.x);\n    float m = vmin(s);\n\treturn (length(p / s) * m) - m;\n}\n\n\nfloat fBox(vec2 p, vec2 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat dvd_d(vec2 p) {\n    float d = halfEllip(p, vec2(.8, .5));\n    d = max(d, -p.x - .5);\n    float d2 = halfEllip(p, vec2(.45, .3));\n    d2 = max(d2, min(-p.y + .2, -p.x - .15));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd_v(vec2 p) {\n    vec2 pp = p;\n    p.y += .7;\n    p.x = abs(p.x);\n    vec2 a = normalize(vec2(1,-.55));\n    float d = dot(p, a);\n    float d2 = d + .3;\n    p = pp;\n    d = min(d, -p.y + .3);\n    d2 = min(d2, -p.y + .5);\n    d = max(d, -d2);\n    d = max(d, abs(p.x + .3) - 1.1);\n\treturn d;\n}\n\n\nfloat dvd_c(vec2 p) {\n    p.y += .95;\n\tfloat d = ellip(p, vec2(1.8,.25));\n    float d2 = ellip(p, vec2(.45,.09));\n    d = max(d, -d2);\n    return d;\n}\n\nfloat dvd(vec2 p) {\n    p.y -= .345;\n    p.x -= .035;\n    p *= mat2(1,-.2,0,1);\n\tfloat d = dvd_v(p);\n    d = min(d, dvd_c(p));\n    p.x += 1.3;\n    d = min(d, dvd_d(p));\n    p.x -= 2.4;\n    d = min(d, dvd_d(p));\n    return d;\n}\n\n\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\n// https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\nvoid drawHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist) {\n\n    float d = length(p - hitPos);\n    \n    #ifdef DEBUG\n    col = mix(col, vec4(0,1,1,0), step(d, .1)); return;\n    #endif\n    \n    float wavefront = d - hitDist * 1.5;\n    float freq = 2.;\n    \n    vec3 spec = (1. - spectrum(-wavefront * freq + hitDist * freq));\n    float ripple = sin((wavefront * freq) * PI*2. - PI/2.);\n    \n    float blend = smoothstep(3., 0., hitDist);\n    blend *= smoothstep(.2, -.5, wavefront);\n    blend *= rangec(-4., .0, wavefront);\n    \n    col.rgb *= mix(vec3(1), spec, pow(blend, 4.));\n    float height = (ripple * blend);\n    col.a -= height * 1.9 / freq;\n}\n\nvec2 ref(vec2 p, vec2 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal) + offset;\n\tp -= (2. * t) * planeNormal;\n    return p;\n}\n\nvoid drawReflectedHit(inout vec4 col, vec2 p, vec2 hitPos, float hitDist, vec2 screenSize) {\n    col.a += length(p) * .0001; // fix normal when flat\n\t//drawHit(col, p, hitPos, hitDist); return;\n    drawHit(col, p, ref(hitPos, vec2(0,1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(0,-1), 1.), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(1,0), screenSize.x/screenSize.y), hitDist);\n    drawHit(col, p, ref(hitPos, vec2(-1,0), screenSize.x/screenSize.y), hitDist);\n}\n\n\n// Flip every second cell to create reflection\nvoid flip(inout vec2 pos) {\n    vec2 flip = mod(floor(pos), 2.);\n    pos = abs(flip - mod(pos, 1.));\n}\n\nfloat stepSign(float a) {\n    //return sign(a);\n\treturn step(0., a) * 2. - 1.;\n}\n\nvec2 compassDir(vec2 p) {\n    //return sign(p - sign(p) * vmin(abs(p))); // this caused problems on some GPUs\n    vec2 a = vec2(stepSign(p.x), 0);\n    vec2 b = vec2(0, stepSign(p.y));\n    float s = stepSign(p.x - p.y) * stepSign(-p.x - p.y);\n    return mix(a, b, s * .5 + .5);\n}\n\nvec2 calcHitPos(vec2 move, vec2 dir, vec2 size) {\n    vec2 hitPos = mod(move, 1.);\n    vec2 xCross = hitPos - hitPos.x / (size / size.x) * (dir / dir.x);\n    vec2 yCross = hitPos - hitPos.y / (size / size.y) * (dir / dir.y);\n   \thitPos = max(xCross, yCross);\n    hitPos += floor(move);\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    #ifdef DEBUG\n    \t//p.xy += vec2(1.2, .6);\n    \t//p *= 3.5;\n    \tp *= 2.;\n   \t#endif\n    \n    vec2 screenSize = vec2(iResolution.x/iResolution.y, 1.) * 2.;\n\n    float t = iTime;\n    vec2 dir = normalize(vec2(9.,16) * screenSize );\n    vec2 move = dir * t / 1.5;\n    float logoScale = .1;\n    vec2 logoSize = vec2(2.,.85) * logoScale * 1.;\n\n    vec2 size = screenSize - logoSize * 2.;\n    \n    // Remap so (0,0) is bottom left, and (1,1) is top right\n    move = move / size + .5;\n\n    // Calculate the point we last crossed a cell boundry\n    vec2 lastHitPos = calcHitPos(move, dir, size);\n    vec4 col = vec4(1,1,1,0);\n    vec4 colFx = vec4(1,1,1,0);\n    vec4 colFy = vec4(1,1,1,0);\n    vec2 e = vec2(.8,0)/iResolution.y;\n\n    #ifdef DEBUG\n\t\tcol.rgb = vec3(0.);\n    #endif\n    \n   \t#ifdef DEBUG\n\t\tconst int limit = 1;\n   \t#else\n    \tconst int limit = 5;\n    #endif\n\t\n    for (int i = 0; i < limit; i++) {\n        vec2 hitPos = lastHitPos;\n \n        if (i > 0) {\n            // Nudge it before the boundry to find the previous hit point\n            hitPos = calcHitPos(hitPos - .00001/size, dir, size);\n        }\n        \n        lastHitPos = hitPos;\n        \n    \t// How far are we from the hit point\n    \tfloat hitDist = distance(hitPos, move);\n        \n        // Flip every second cell to create reflection\n        flip(hitPos);\n\n\t\t// Remap back to screen space\n    \thitPos = (hitPos - .5) * size;\n\t\t\n        // Push the hits to the edges of the screen\n        hitPos += logoSize * compassDir(hitPos / size);\n    \n\t    drawReflectedHit(col, p, hitPos, hitDist, screenSize);\n \t   \tdrawReflectedHit(colFx, p + e, hitPos, hitDist, screenSize);\n    \tdrawReflectedHit(colFy, p + e.yx, hitPos, hitDist, screenSize);\n    }\n        \n    // Flip every second cell to create reflection\n    flip(move);\n\n    // Remap back to screen space\n    move = (move - .5) * size;\n    \n    // Calc normals\n\tfloat bf = .1; // Bump factor\n    float fx = (col.a - colFx.a) * 2.; // Nearby horizontal samples.\n    float fy = (col.a - colFy.a) * 2.; // Nearby vertical samples.\n    vec3 nor = normalize(vec3(fx, fy, e.x/bf)); // Bumped normal.\n    float ff = length(vec2(fx, fy));\n    float ee = rangec(0., 10./iResolution.y, ff);\n    nor = normalize(vec3(vec2(fx, fy)*ee, ff));\n\n    // invert colours\n    col.rgb = clamp(1. - col.rgb, vec3(0), vec3(1));\n    col.rgb /= 3.;\n    \n\n    #ifndef DEBUG\n\t\n    \t// lighting\n    \t// iq https://www.shadertoy.com/view/Xds3zN\n        vec3 lig = normalize(vec3(1,2,2.));\n        vec3 rd = normalize(vec3(p, -10.));\n        vec3  hal = normalize( lig - rd );\n\n        float dif = clamp(dot(lig, nor), 0., 1.);\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                        dif *\n                        (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.);\n        lin += 5. * dif;\n        lin += .2;\n        col.rgb = col.rgb * lin;\n        col.rgb += 5. * spe;\n\t#endif\n    \n    #ifdef DEBUG\n        float b = vmin(abs(fract(p / screenSize) - .5) * 2.);\n        b /= fwidth(b) * 2.;\n        b = clamp(b, 0., 1.);\n        b = 1. - b;\n        col.rgb = mix(col.rgb, vec3(0), b);\n    #endif\n    \n    // dvd logo\n\tfloat d = dvd((p - move) / logoScale);\n    d /= fwidth(d);\n    d = 1. - clamp(d, 0., 1.);\n    col.rgb = mix(col.rgb, vec3(1), d);\n    \n    // banding be gone\n    col += (texture(iChannel0, fragCoord / iChannelResolution[0].xy) * 2. - 1.) * .005;\n\n    // gamma\n    col.rgb = pow(col.rgb, vec3(1./1.5));\n\n    col.a = col.a * .5 + .5;\n\tcol.a *= .3;\n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"DVD\",\n\t\"description\": \"\",\n\t\"model\": \"person\"\n}\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}