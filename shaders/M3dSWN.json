{
    "Shader": {
        "info": {
            "date": "1719083911",
            "description": "similar to: whirling inferno, but the light tornados are clearer and I added a surface, changed colors and other parameters",
            "flags": 32,
            "hasliked": 0,
            "id": "M3dSWN",
            "likes": 7,
            "name": "solar convection",
            "published": 3,
            "tags": [
                "raymarch",
                "volumetric",
                "mandelbox"
            ],
            "usePreview": 0,
            "username": "pb",
            "viewed": 153
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Gaussian blur effect\n    vec2 texel = 1.0 / iResolution.xy;\n    vec4 total_color = vec4(0.0);\n\n    // Gaussian kernel from common tab\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    // Apply Gaussian blur to the texture from channel 0\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i) - 2.0;\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j) - 2.0;\n            vec4 color = texture(iChannel0, uv + vec2(texel.x * fi, texel.y * fj));\n            total_color += color * gk1s[i * 5 + j];\n        }\n    }\n\n\n    // Output the final color\n    fragColor = total_color;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "float glow2=0., mmaxDist=100.;\nvec3 ro ;\n\nmat2 rot(float an) {return mat2(cos(an),-sin(an),sin(an),cos(an));}\n\nfloat random(vec2 p) {\n    //a random modification of the one and only random() func\n    return fract( sin( dot( p, vec2(12., 90.)))* 1e5 );\n}\n\n\nfloat de(vec3 p) {\n \n  float py = p.y;\n  \n  float nn = 3.;\n  p = mod(p  + nn, 2.*nn) -nn;\n \n  p.xz *= rot(iTime*2.);\n  \n  vec4 q0 = vec4 (p, 1), q = q0; float i=0.;\n  \n  for (; i<7.; i ++) {\n  \n    q.xyz = clamp (q.xyz, -1.2, 1.5) * 2.3\n            - 1.4*q.xyz;\n            \n    q.xz *= rot(i*i + iTime );\n    \n    q = q * .7\n        / clamp (  max( dot(q.yz,q.yz), max(dot (q.xz, q.xz),  dot(q.xy,q.xy) ) ), \n        .3, 1.) + q0;     \n        \n  } \n\n  if (py < -2.7 ) {  return -q.w/ length(q.xyz) ; }\n  \n  return length (q.xyz) / q.w - .02*random(p.xz)*(1.+sin(iTime)); \n}\n\nfloat march(vec3 ro, vec3 rd, float mx) {\n    \n    float t=0.;\n    for(int i = 0; i < 100; i++) {\n        vec3 pos = ro + rd*t;\n        float d = de(pos);      \n           \n\n        if ( t > 15. ) break;\n        t += .5*d;\n        \n        glow2 += exp(-d*d/10.)*exp(-t*t/40.);\n        \n    }\n    return t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    \n    float t = march(ro, rd, mmaxDist);\n \n    return   1e-8*pow(glow2,6.)*vec3(.05,.04,.001)   ; \n                \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p  = (2.*fragCoord.xy-iResolution.xy)/iResolution.y*2.;    \n    \n    vec3 rd = normalize( vec3(p,1.6 ) );\n    \n    ro = vec3(.2,-1., iTime/2.);\n    \n    rd.xz *= rot(.2);\n    rd.yz *=rot(-.5);\n\n \n    vec3 col = clamp(render(ro, rd),1e-4,1e6);\n    col = 1. - exp(-sqrt(col));\n    \n    fragColor = vec4( col, 1.);\n    \n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}