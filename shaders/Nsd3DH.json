{
    "Shader": {
        "info": {
            "date": "1630091066",
            "description": "my first path tracing test with a larger scene. Please don't kill me, I'm just learning.\n\nUse mouse.x to control blur strength.",
            "flags": 32,
            "hasliked": 0,
            "id": "Nsd3DH",
            "likes": 1,
            "name": "path marching scene",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "sirjofri",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "vec2 uv;\nfloat dev;\n\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvec3 tex(vec2 t)\n{\n    t.y *= iResolution.x/iResolution.y;\n    t *= dev;\n    return texture(iChannel0, uv+t).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n    float fd = t.a;\n    float dt = sin(iTime*2.5)*.5+5.5; // focus distance\n    float pd = fd - dt;\n    float r = rand(vec2(iTime, float(iFrame)*45.753)+uv*345.54);\n    dev = min(pd*.001+r*.001, .003);\n    vec3 oimg = t.rgb;\n    \n    // distance-based depth of field\n    vec3 a = tex(vec2(-1., -1.));\n    vec3 b = tex(vec2(0., -1.));\n    vec3 c = tex(vec2(1., -1.));\n    vec3 d = tex(vec2(-1., 0.));\n    vec3 e = tex(vec2(1., 0.));\n    vec3 f = tex(vec2(-1., 1.));\n    vec3 g = tex(vec2(0., 1.));\n    vec3 h = tex(vec2(1., 1.));\n    \n    vec3 j = (a+b+c+d+e+f+g+h)/8.;\n\n    fragColor = vec4(mix(oimg, j, iMouse.x/iResolution.x), fd);\n    //fragColor = vec4(vec3(abs(dev*10.)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define bounces 5\n#define maxsteps 400\n#define maxdist 0.00001\n\n#define Msky     0\n#define Mred     1\n#define Mfloor   2\n#define Mblue    3\n#define Mmirror  4\n#define Mwall    5\n#define Mlight   6\n\nstruct M {\n    int materialID;\n    float dist;\n};\n\nstruct Mat {\n    float refl;\n    vec3 bc;\n};\n\nvec3 rotation = vec3(0.);\nvec2 ouv;\nvec3 campos;\nfloat depth = 0.;\n\n/* stolen: https://www.shadertoy.com/view/Md2BWW */\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udQuad(vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 p)\n{\n    #if 1\n    // handle ill formed quads\n    if( dot( cross( v2-v1, v4-v1 ), cross( v4-v3, v2-v3 )) < 0.0 )\n    {\n        vec3 tmp = v3;\n        v3 = v4;\n        v4 = tmp;\n    }\n    #endif\n\n    \n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                            dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                       min( dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3),\n                            dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) ))\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) ) -.01;\n}\n\nfloat rand(vec2 n)\n{\n    return fract(sin(dot(n, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvec3 rvec(vec3 wp)\n{\n    float t = rand(vec2(iTime, float(iFrame)*45.753));\n    float u = rand(vec2(float(iFrame)*3.6428, iTime));\n    vec2 v = vec2(t, u);\n    return normalize(vec3(\n        rand(wp.xy+v),\n        rand(wp.yz+v),\n        rand(wp.zx+v)\n    )*2.-1.);\n}\n\nvec3 rotate(vec3 p)\n{\n    mat3 yaw = mat3(\n        cos(rotation.x), -sin(rotation.x), 0.,\n        sin(rotation.x),  cos(rotation.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(rotation.y), -sin(rotation.y),\n        0., sin(rotation.y),  cos(rotation.y)\n    );\n    mat3 roll = mat3(\n         cos(rotation.z), 0., sin(rotation.z),\n               0., 1.,       0.,\n        -sin(rotation.z), 0., cos(rotation.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nfloat t_floor(vec3 wp)\n{\n    return textureLod(iChannel1, wp.xy*vec2(.3, .5)*1.5, distance(campos, wp)*.15).r;\n}\n\nMat getMaterial(int mID, vec3 wp)\n{\n    switch(mID){\n    case Msky: // sky\n        return Mat(0., mix(vec3(.2, .1, .05), vec3(.9, .9, 1.), clamp(wp.z/100., 0., 100.))*150.);\n    case Mred: // red sphere\n        return Mat(0.2, vec3(0.9, 0.5, 0.4));\n    case Mfloor: // floor\n        float d = t_floor(wp);\n        return Mat(d*.35, vec3(0.8, 0.8, 0.8)*pow(d, .3));\n    case Mblue: // blue sphere\n        return Mat(.8, vec3(.5, .5, 1.));\n    case Mmirror: // mirror sphere\n        return Mat(.9, vec3(1.));\n    case Mwall: // wall material\n        return Mat(0.2, vec3(1., 1., 0.9));\n    case Mlight: // light material\n        return Mat(0., vec3(1., 1., .9)*100.);\n    }\n    return Mat(0., vec3(0.));\n}\n\nM sdSphere(vec3 p, vec3 pos, float r, int m)\n{\n    M ret;\n    ret.dist = distance(p, pos) - r;\n    ret.materialID = m;\n    return ret;\n}\n\nM sdQuad( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4, in vec3 p, in int m)\n{\n    M ret;\n    ret.dist = udQuad(v1, v2, v3, v4, p);\n    ret.materialID = m;\n    return ret;\n}\n\nM opUnion(M a, M b)\n{\n    if (a.dist < b.dist)\n        return a;\n    return b;\n}\n\nM PleftWall(vec3 p)\n{\n    vec3 front_p = vec3(-1.2, -8., 3.);\n    vec3 rear_p = vec3(-2., 6., 3.);\n    M front = sdQuad(\n        vec3(front_p.x, front_p.y, -.5),\n        vec3(front_p.x, -1.5, -.5),\n        vec3(front_p.x, -1.5, front_p.z),\n        vec3(front_p.x, front_p.y, front_p.z),\n        p, Mwall);\n    M rear = sdQuad(\n        vec3(rear_p.x, rear_p.y, -.5),\n        vec3(rear_p.x, -1.5, -.5),\n        vec3(rear_p.x, -1.5, rear_p.z),\n        vec3(rear_p.x, rear_p.y, rear_p.z),\n        p, Mwall);\n    return opUnion(front, rear);\n}\n\nM PrightWall(vec3 p)\n{\n    vec3 front_p = vec3(2., 6., 3.);\n    M front = sdQuad(\n        vec3(front_p.x, front_p.y, 0.),\n        vec3(front_p.x, -8., 0.),\n        vec3(front_p.x, -8., front_p.z),\n        vec3(front_p.x, front_p.y, front_p.z),\n        p, Mwall);\n    return front;\n}\n\nM Proof(vec3 p)\n{\n    float z = 3.;\n    M roof = sdQuad(\n        vec3(-2., -8., z),\n        vec3(-2., 6., z),\n        vec3(2., 6., z),\n        vec3(2., -8., z),\n        p, Mwall);\n    return roof;\n}\n\nM Plights(vec3 p)\n{\n    M l1 = sdSphere(p, vec3(1., 2., 3.), .1, Mlight);\n    M l2 = sdSphere(p, vec3(1.3, 0., 0.6), 0.05, Mlight);\n    return opUnion(l1, l2);\n}\n\nM map(vec3 p)\n{\n    M sky = sdSphere(p, vec3(0.), 200., Msky);\n    sky.dist *= -1.;\n    M ground = sdSphere(p, vec3(0., 0., -1000.), 1000., Mfloor);\n    ground.dist -= t_floor(p)*.02;\n    M sph1 = sdSphere(p, vec3(0., 0., 1.)+sin(p.z*30.)*.01*abs(p.x), 1., Mred);\n    M sph2 = sdSphere(p, vec3(0.5, -.5, .5), .5, Mblue);\n    M sph3 = sdSphere(p, vec3(.7, -1.1, .1), .1, Mmirror);\n    M sph = opUnion(opUnion(sph1, sph2), sph3);\n    M walls = opUnion(Proof(p), opUnion(PleftWall(p), PrightWall(p)));\n    M light = Plights(p);\n    return opUnion(light, opUnion(walls, opUnion(sky, opUnion(ground, sph))));\n}\n\nM march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    for (int i=0; i<maxsteps; i++){\n        M n = map(ro + rd*d);\n        d += n.dist;\n        if (n.dist < maxdist){\n            n.dist = d;\n            return n;\n        }\n    }\n}\n\nvec3 normal(vec3 wp)\n{\n    float s = .0001;\n    float c = map(wp).dist;\n    float x = map(wp+vec3(s, 0., 0.)).dist;\n    float y = map(wp+vec3(0., s, 0.)).dist;\n    float z = map(wp+vec3(0., 0., s)).dist;\n    return normalize(vec3(x-c, y-c, z-c));\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(1.);\n    vec3 wp = ro;\n    vec3 nrd = rd;\n    float fulld = 0.;\n    int i;\n    for (i=0; i<bounces; i++){\n        M m = march(wp+nrd*0.00015, nrd);\n        fulld += m.dist;\n        if (i == 0)\n            depth = m.dist;\n        wp += nrd*m.dist;\n        Mat mat = getMaterial(m.materialID, wp);\n        col *= mat.bc;\n        if (length(mat.bc) > 10.)\n            return col/fulld;\n        if (length(wp) > 150.0)\n            return col/fulld;\n        vec3 n = normal(wp);\n        float r = mat.refl;\n        nrd = mix(rvec(wp), reflect(nrd, n), r);\n        float dit = dot(nrd, n);\n        if (dit < 0.)\n            return vec3(-1.);\n    }\n    return col/fulld;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    ouv = uv;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0., -6., 2.);\n    campos = ro;\n    rotation = vec3(0., -.2, 0.);\n    vec3 rd = mix(rotate(normalize(vec3(uv.x, 2., uv.y))), rvec(vec3(iTime, float(iFrame)*.0001, ro.z)), 0.0001);\n    \n    M ms = march(ro, rd);\n\n    vec3 col = render(ro, rd);\n    vec3 ocol = texture(iChannel0, ouv).rgb;\n    if (col.x < 0.) // discard swallowed rays\n        discard; //col = ocol;\n    if (distance(col, ocol) > 50.) // noise reduction: filter out extremes\n        discard; //col = ocol;\n    vec3 ncol = mix(ocol, col, 0.01);\n\n    fragColor = vec4(ncol, depth);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "float f(vec2 uv)\n{\n    uv.x += floor(uv.y)*.5;\n    vec2 mn = smoothstep(0.52, .5, 1.-abs(mod(uv, 1.)-.5));\n    float n = 1.-max(mn.x, mn.y);\n    return clamp(n, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.;\n    vec3 n = vec3(f(uv));\n    \n    // high quality, but with much more noise\n#if 0\n    n -= texture(iChannel0, uv).r*.1;\n#endif\n    fragColor = vec4(n, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 7,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}