{
    "Shader": {
        "info": {
            "date": "1678369616",
            "description": "Running some Truchet cables through a lit up apollonian object.",
            "flags": 32,
            "hasliked": 0,
            "id": "DsK3zh",
            "likes": 90,
            "name": "Apollonian Construction",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "dof",
                "bloom",
                "glow",
                "truchet",
                "apollonian"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1313
        },
        "renderpass": [
            {
                "code": "/*\n\n    Apollonian Construction\n    -----------------------\n\n    Rendering the buffer.\n \n    See Buffer A for an explanation.\n    \n*/\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// This is an amalgamation of old blur and DOF functions with a couple of borrowed \n// lines from Dave Hoskins's much nicer Fibonacci based \"Bokeh disc\" function, which \n// you can find here: https://www.shadertoy.com/view/4d2Xzw\n//\n// This function is only really suitable for this example. If you're interested in \n// bokeh, Dave's function above and some of Shadertoy user, Hornet's, are probably\n// the one's you should be looking at. Xor has some cool simple ones on here that I'm\n// yet to dig into, but they might worth a look also.\nvec4 bloom(sampler2D iCh, vec2 uv){\n\n\tvec4 tot = vec4(0);\n    \n    // UV based DOF. Focused on the horizontal line, then blurring further away.\n    //float r = smoothstep(0., 1., abs(uv.y - .57)/.57)*2.;\n    // Focal point and circle of confusion.\n    const float focD = 2.5, coc = 1.;\n    // Linear distance from either side of the focal point.\n    float l = abs(texture(iCh, uv).w - focD - coc) - coc;\n    // Using it to calculate the DOF.\n    float r = clamp(l/coc, 0., 1.);\n    \n    const int n = 4;\n    for (int j = -n; j<=n; j++){\n        for (int i = -n; i<=n; i++){\n           \n            // Random offset contained within a disk or radius n.\n            vec2 rnd2 = vec2(hash21(vec2(i, j)), hash21(vec2(i, j) + .1)*6.2831);\n            vec2 offs = float(n)*rnd2.x*vec2(cos(rnd2.y), sin(rnd2.y));\n            \n            vec4 c = texture(iCh, uv + offs/vec2(800, 450)*r, r*iResolution.y/450.*.7); \n            tot += mix(c, pow(c, vec4(1.25))*3.4, rnd2.x*rnd2.x); //ow(c, vec4(1.5))*4.\n            \n        }\n    }\n    \n\treturn tot/float((n*2 + 1)*(n*2 + 1));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, uv);\n   \n    // Custom DOF bloom-like function.\n    col = bloom(iChannel0, uv);\n    \n    \n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = pow(max(col, 0.), vec4(1./2.2));\n    \n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/*\n\n    Apollonian Construction\n    -----------------------\n    \n    I'm not sure what random scene this is supposed to be... A moon base \n    under construction? Either way, I love apollonian objects. The fractal \n    formula that produces this particular one is surprisingly succinct for \n    such an intricate object.\n    \n    I won't go into the details regarding apollonian formation, suffice to\n    say that you iteratively subdivide and transform space in a manner \n    similar to a Mobius transform... It's been a while, so I'll leave the\n    proper explanation to IQ, Knighty, Kali, MLA et al. :)\n    \n    I've had this example sitting in my account for way too long, so \n    figured it was time to put in some finishing touches and post it. I\n    went for a dark scene with glowy lights, which is what you do when you\n    want something to look interesting without having to use creativity. :D\n    \n    I did at least run some cables through the object to give the lights\n    some context. The cables are just a distorted 3D Truchet object. There's \n    a trick to making 3D Truchet objects fast that I wasn't able to utilize \n    here on a account of the glowing lights, so it's in need of some \n    tweaking, which I'll do at a later date.\n    \n    \n    \n    Related examples:\n    \n    // Most of Dave Hoskins's examples are really popular,\n    // and this one is no different.\n    Fractal Explorer - Dave_Hoskins\n    https://www.shadertoy.com/view/4s3GW2\n    \n    // One of the original examples on here and the one\n    // most of us refer to.\n    Apollonian - IQ\n    https://www.shadertoy.com/view/4ds3zn\n    \n    // Awesome 2D example.\n    It's a Question of Time - Rigel\n    https://www.shadertoy.com/view/lljfRD\n    \n    // Much less code than this one. :)\n    [SH17A] Apollonian Structure - Shane\n    https://www.shadertoy.com/view/4d2BW1\n\n    \n*/\n\n// Maximum ray distance.\n#define MAXDIST 15.\n\n// Light color - Reddish purple: 0, Greenish blue: 1 \n#define COLOR 0\n\n// Standard 2D rotation formula.\nmat2 r2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash31(vec3 p){  \n    return fract(sin(dot(p, vec3(113.619, 57.583, 27.897)))*43758.5453); \n} \n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n \n    //return vec2(0); // Straight path.\n    \n    // Windy weaved path.\n    float c = cos(z*3.14159265/4.);\n    float s = sin(z*3.14159265/4.);\n    //return vec2(1. + c*2.15 - .15, 1. + s*2.15 - .15); \n    return vec2(1. + c*2. - .0, 1. + s*2. - .0); \n    \n}\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n*/\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    // Matching the texture rotation with the object warping. Matching transformed texture \n    // coordinates can be tiring, but it needs to be done if you want things to line up. :)\n    //p.xy *= rot(p.z*ZTWIST); \n    //n.xy *= rot(p.z*ZTWIST); \n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.yz).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n \n    \n// Apollonian sphere packing of sorts, based on IQ's cool example here:\n// https://www.shadertoy.com/view/4ds3zn\n//\nfloat apollonian(vec3 p){\n\n    // Initial radius and scale.\n    const float rad = 1.545;\n    float scale = 1.;\n\n    // I'd liken the following to iterative hyperbolic transform subdivision... \n    // Although, I'd definitely look it up for a more formal description. :)\n    for( int i=0; i<8; i++ ){\n        // Repeat space.\n        p = mod(p - 1., 2.) - 1.;\n        // Sphere inversion. You perform something similar in \n        // hyperbolic geometry.\n        float k = rad/dot(p, p);\n        // Scale.\n        p *= k;\n        scale *= k;\n    }\n    \n    // Rendering tiny spheres at each point. After several iterative space inversions\n    // above, the thousands of tiny spheres will form a 3D Apollonian gasket, or whatever\n    // you wish to call it. Because we're repeating space from the start, there will be\n    // infinite overlapping gasket objects sitting side by side.\n    return length(p)/scale/4. - .0025;\n}\n\n/*\n// Toroidal distance. (Not used).\nfloat lengthT(vec2 p){\n\n    // Circular.\n    return length(p);\n    \n    // Superelliptical.\n    //float n = 4.;\n    //return pow(dot(pow(abs(p), vec2(n)), vec2(1)), 1./n);\n    \n    // Square, octagon or dodecahedron.\n    //p = abs(p);\n    //return max(p.x, p.y);\n    //return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    //return max(max(dot(p, vec2(.8660254, .5)), p.y), max(dot(p.yx, vec2(.8660254, .5)), p.x));\n    \n}\n*/\n\n\n// Poloidal distance.\nfloat lengthP(vec2 p){\n\n    // Circular.\n    return length(p);\n    \n    // Square, hexagon or octagon.\n    //p = abs(p);\n    //return max(p.x, p.y);\n    //return max(dot(p, vec2(.8660254, .5)), p.y);\n    //return max(max(p.x, p.y), (p.x + p.y)*.7071);\n    \n}\n\n\nfloat gID; // Object ID.\nvec3 glow; // Glow.\n\nfloat map(vec3 p) {\n    \n    \n    // The Truchet cabel object.\n    \n    // Warping the cables just a bit.\n    vec3 q = p - sin(p*8. - cos(p.yzx*8.))*.035; \n    \n    // Local cell ID and coordinates. \n    vec3 iq = floor(q/2.);\n    q -= (iq + .5)*2.;\n    \n    // Random cell -- and as such, Truchet cable -- rotation.\n    float rnd = hash31(iq + .12);\n    if(rnd<.33) q = q.yxz;\n    else if(rnd<.66) q = q.xzy;\n    \n    // Repeat light object along the cable, and angle and cell number.\n    float aN = 8., a, n;\n    \n    // Truchet (cable) and light objects. \n    float lat, light;\n    \n\n    // First arc edge point.\n    vec3 rq = q - vec3(1, 1, 0); \n    // Torus coordinates around the edge point.\n    vec2 tor = vec2(length(rq.xy) - 1., rq.z); \n    tor = abs(abs(tor) - .45); // Repeating the torus four more times.\n    lat = lengthP(tor); // Torus (cable) object.\n    // Repeat lights on this torus.\n    a = atan(rq.y, rq.x)/6.2831;\n    n = (floor(a*aN) + .5)/aN;\n    rq.xy *= r2(-6.2831*n);\n    rq.x -= 1.;   \n    rq.xz = abs(abs(rq.xz) - .45); // Repeating the lights four more times.\n    //\n    // Constructing the light object, if applicable.\n    float bx = 1e5;\n    if(hash31(iq - vec3(1, 1, 0) + n*.043)<.25) bx = length(rq);\n    light = bx;     \n    \n    // Doing the same for the second arc edge point.\n    rq = q - vec3(0, -1, -1); \n    a = atan(rq.z, rq.y)/6.2831;\n    tor = vec2(length(rq.yz) - 1., rq.x);\n    tor = abs(abs(tor) - .45);\n    lat = min(lat, lengthP(tor)); \n    n = (floor(a*aN) + .5)/aN;\n    rq.yz *= r2(-6.2831*n);\n    rq.y -= 1.;\n    rq.xy = abs(abs(rq.xy) - .45);\n    bx = 1e5;\n    if(hash31(iq - vec3(0, -1, -1) + n*.043)<.25) bx = length(rq);\n    light = min(light, bx);\n   \n    // Doing the same for the third arc edge point.\n    rq = q - vec3(-1, 0, 1);\n    a = atan(rq.z, rq.x)/6.2831;\n    tor = vec2(length(rq.xz) - 1., rq.y);\n    tor = abs(abs(tor) - .45);\n    lat = min(lat, lengthP(tor));\n    n = (floor(a*aN) + .5)/aN;\n    rq.xz *= r2(-6.2831*n);\n    rq.x -= 1.;\n    rq.xy = abs(abs(rq.xy) - .45);    \n    bx = 1e5;\n    if(hash31(iq - vec3(-1, 0, 1) + n*.043)<.25) bx = length(rq);\n    light = min(light, bx);\n  \n\n    // Alternative lighting.\n    //if(hash31(iq + .03)<.35) ball = 1e5;\n    //if(mod(iq.x + iq.y + iq.z, 2.)<.5) ball = 1e5;\n    \n    // Giving the lattice and lights some thickness.\n    lat -= .01;\n    light -= .05;\n    \n    // Use the wire distance to create a diode looking object.\n    light = max(light, abs(lat - .015) - .01);\n  \n  \n    // Construct the repeat apollonian object to thread the cables through.\n    float ga = apollonian(p);\n    \n     \n    // Repeat sphere space to match the repeat apollonian objects.\n    q = mod(p, 2.) - 1.;\n    //ga = max(ga, (length(q) - 1.22)); // Hollow out.\n    // Smooth combine with the main chamber sphere to give a \n    // slightly smoother surface.\n    ga = smax(ga, -(length(q) - 1.203), .005);\n    \n     \n    // Object ID.\n    gID = lat<ga && lat<light? 2. : ga<light? 1. : 0.;//\n    \n    // If we've hit the light object, add some glow.\n    if(gID==0.){\n      \n         glow += vec3(1, .2, .1)/(1. + light*light*256.); // Truchet cable lights.\n    }\n    \n\n    // Minimum scene object.\n    return min(lat, min(ga, light)); \n}\n\n\nfloat march(vec3 ro, vec3 rd) {\n\n    // Closest and total distance.\n    float d, t = hash31(ro + rd)*.15;// Jittering to alleviate glow artifacts.\n    \n    glow = vec3(0);\n    \n    vec2 dt = vec2(1e5, 0); // IQ's clever desparkling trick.\n    \n    int i;\n    const int iMax = 128;\n    for (i = 0; i<iMax; i++) \n    {        \n        d = map(ro + rd*t);\n        dt = d<dt.x? vec2(d, dt.x) : dt; // Shuffle things along.\n        if (abs(d)<.001*(1. + t*.1) || t>MAXDIST) break;\n        \n        // Limit the marching step. It's a bit slower but produces better glow.\n        t += min(d*.8, .3); \n    \n        \n    }\n    \n     \n    // If we've run through the entire loop and hit the far boundary, \n    // check to see that we haven't clipped an edge point along the way. \n    // Obvious... to IQ, but it never occurred to me. :)\n    if(i>=iMax - 1) t = dt.y;\n   \n    return min(t, MAXDIST);\n}\n\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 nrm(in vec3 p) {\n\t\n    //const vec2 e = vec2(.001, 0);\n    //return normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\t\n    //                      map(p + e.yyx) - map(p - e.yyx)));\n     \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    vec3 e = vec3(.001, 0, 0), mp = e.zzz; // Spalmer's clever zeroing.\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp.x += map(p + sgn*e)*sgn;\n        sgn = -sgn;\n        if((i&1)==1){ mp = mp.yzx; e = e.zxy; }\n    }\n    \n    return normalize(mp);\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat shadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not always affordable. :)\n    const int maxIterationsShad = 48; \n    \n    ro += n*.0015; // Coincides with the hit condition in the \"trace\" function.  \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*d/t)); // Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += clamp(d, .01, stepDist), etc.\n        t += clamp(d*.8, .005, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 1.5, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.35/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\nvec4 render(vec3 ro, vec3 rd, vec3 lp){ \n\n\n    // Raymarch.\n\tfloat t = march(ro, rd);\n    \n    // Saving the object ID.\n    float svID = gID;\n    // Saving the glow.\n    vec3 svGlow = glow;\n    \n    \n    // Initialize to the scene color to zero.\n    vec3 col = vec3(0);\n    \n    // If we've hit the surface color it.\n    if (t<MAXDIST){ \n    \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n    \n        // Normal.\n        vec3 sn = nrm(sp); \n         \n        // Light direction vector and attenuation.\n        vec3 ld = (lp - sp);\n        float atten = max(length(ld), .001);\n        ld /= atten;\n        // Light attenuation.\n        atten = 1./(1. + atten*.125);\n        \n        // Diffuse and specular.\n        float diff = max(dot(ld, sn), 0.);\n        //diff = pow(diff, 4.)*2.;\n        float spec = pow(max(dot(reflect(rd, sn), ld), 0.), 8.);\n        \n        // Ambient occlusion and shadows.\n        float ao = cAO(sp, sn);\n        float sh = shadow(sp, lp, sn, 8.); \n\n        \n        // Manipulate the glow color.\n        float sinF = dot(sin(sp - cos(sp.yzx)*1.57), vec3(1./6.)) + .5;\n        //sinF = smoothstep(0., 1., sinF);\n        #if COLOR == 0\n        svGlow = mix(svGlow, svGlow.zyx, sinF);\n        #else\n        svGlow = mix(svGlow.zxy, svGlow.zyx, sinF);\n        #endif\n        \n        // Texturing the scene objcts.\n        vec3 tx = tex3D(iChannel1, sp*2., sn);\n        col = tx;\n        \n\n        if (svID==1.) col /= 8.; // Darken the apollonian structure.\n        else if (svID==2.) col /= 4.; // Darken the wires a little less.\n        \n        \n        // Applying the diffuse and specular.\n        col = col*(diff*sh + .2) + spec*sh*.5;\n \n        \n        // Adding the glow. In a path tracer, emitters are influenced by and\n        // influence everything else, but here, we just add in some glow and hope\n        // people don't look into it too much. :)\n        col += col*(svGlow)*32.;\n    \n        /// Attenuation and ambient occlusion.\n        col *= atten*ao;\n\n    \n    }\n    \n    \n    // Fog out the background.\n    col = mix(col, vec3(0), smoothstep(.0, .8, t/MAXDIST));\n    \n    \n    // Color and distance.\n   \treturn vec4(col, t);\n}\n\n// The following is based on John Hable's Uncharted 2 tone mapping, which\n// I feel does a really good job at toning down the high color frequencies\n// whilst leaving the essence of the gamma corrected linear image intact.\n//\n// To arrive at this non-tweakable overly simplified formula, I've plugged\n// in the most basic settings that work with scenes like this, then cut things\n// right back. Anyway, if you want to read about the extended formula, here\n// it is.\n//\n// http://filmicworlds.com/blog/filmic-tonemapping-with-piecewise-power-curves/\n// A nice rounded article to read. \n// https://64.github.io/tonemapping/#uncharted-2\nvec4 uTone(vec4 x){\n    return ((x*(x*.6 + .1) + .004)/(x*(x*.6 + 1.)  + .06) - .0667)*1.933526;    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\t\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    //if(abs(uv.y)>.4){ fragColor = vec4(0); return; }\n    \n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*.25); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, -.05, .25);  // \"Look At\" position.\n    vec3 lp = ro + vec3(0, 0, .75); // Light position.\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/1.5; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);  \n   \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/24.);\n    rd.yz *= r2(-sw.y/16.);    \n    \n   \n    // Render.\n    vec4 col4 = render(ro, rd, lp);\n    \n    // Applying tone mapping. I use it to tone down really high intensity lights, \n    // so I want something that does that. A lot of tone mappers completely change\n    // the look, which is fine, if that's what you're going for... It's not really\n    // my area, but there is a link in the \"uTone\" function for those interested.\n    col4.xyz = uTone(col4).xyz; // Don't apply this to the alpha channel.\n    \n    #if 1\n    // Mix the previous frames in with no camera reprojection.\n    // It's OK, but full temporal blur will be experienced.\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./3.; \n    fragColor = mix(preCol, vec4(clamp(col4.xyz, 0., 1.), col4.w), blend);\n    #else\n    // Output to screen.\n    fragColor = vec4(clamp(col4.xyz, 0., 1.), col4.w);\n    #endif\n    \n    \n\t\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}