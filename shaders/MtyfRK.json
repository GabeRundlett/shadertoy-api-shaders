{
    "Shader": {
        "info": {
            "date": "1543133549",
            "description": "Nice test for implicit surfaces (and your GLSL compiler). Comparison with DE would be interesting.",
            "flags": 16,
            "hasliked": 0,
            "id": "MtyfRK",
            "likes": 7,
            "name": "Chmutov Surface",
            "published": 3,
            "tags": [
                "implicit",
                "surface",
                "chebyshev",
                "chmutov"
            ],
            "usePreview": 0,
            "username": "mla",
            "viewed": 960
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Chmutov implicit surfaces\n//\n// 'c' changes color scheme\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Select function here (and uncomment down below).\n#define CHMUTOV Chmutov16\n#define QUALITY\n//#define FAST\n\n\nconst float PI =  3.141592654;\n\n// (T)Chebyshev polynomials\n// Could also use T(2n,x) = T(n,x)*T(n,x)-1\n// Some macro magic might be good.\n\nfloat T6(float x) {\n   return -1.0+x*x*(18.0+x*x*(-48.0+x*x*32.0));\n}\n\nfloat Chmutov6(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T6(x)+T6(y)+T6(z)+1.0;\n}\n\nfloat T9(float x) {\n  float x2 = x*x;\n  return x*(9.0+x2*(-120.0+x2*(432.0+x2*(-576.0+x2*256.0))));\n}\n\nfloat T10(float x) {\n  float x2 = x*x;\n  return -1.0 + x2*(50.0 + x2*(-400.0 + x2*(1120.0 + x2*(-1280.0 + x2*512.0))));\n}\n\nfloat Chmutov10(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T10(x)+T10(y)+T10(z)+1.0;\n}\n\n// These recurrences take a while to compile.\nfloat T11(float x) {\n  return 2.0*x*T10(x) - T9(x);\n}\nfloat T12(float x) {\n  return 2.0*x*T11(x) - T10(x);\n}\nfloat Chmutov12(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T12(x)+T12(y)+T12(z)+1.0;\n}\n\nfloat T13(float x) {\n  return 2.0*x*T12(x) - T11(x);\n}\nfloat T14(float x) {\n  return 2.0*x*T13(x) - T12(x);\n}\nfloat Chmutov14(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T14(x)+T14(y)+T14(z)+1.0;\n}\n\nfloat T15(float x) {\n  return 2.0*x*T14(x) - T13(x);\n}\nfloat T16(float x) {\n  return 2.0*x*T15(x) - T14(x);\n}\nfloat Chmutov16(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T16(x)+T16(y)+T16(z)+1.0;\n}\n\n// These functions might stress your compiler\n#if 0\nfloat T17(float x) {\n  return 2.0*x*T16(x) - T15(x);\n}\nfloat T18(float x) {\n  return 2.0*x*T17(x) - T16(x);\n}\nfloat Chmutov18(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T18(x)+T18(y)+T18(z)+1.0;\n}\n\nfloat T19(float x) {\n  return 2.0*x*T18(x) - T17(x);\n}\nfloat T20(float x) {\n  return 2.0*x*T19(x) - T18(x);\n}\nfloat Chmutov20(vec3 p) {\n  float x = p.x, y = p.y, z = p.z;\n  return T20(x)+T20(y)+T20(z)+1.0;\n}\n#endif\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 map(vec3 p) {\n  float k = 0.1*iTime;\n  p.xz = rotate(p.xz, k);\n  return p;\n}\n\nfloat Fun(vec3 p) {\n  return CHMUTOV(map(p));\n}\n\nconst int CHAR_C = 67;\nconst int CHAR_G = 71;\nconst int CHAR_N = 78;\n\nbool keypress(int code) {\n  return texelFetch(iChannel2, ivec2(code,2),0).x != 0.0;\n}\n\nvec3 selectColor(vec3 q, vec3 eye, vec3 n) {\n  if (keypress(CHAR_C)) {\n    // Shouldn't need sqrt but nice to brighten a little\n    vec3 color = texture(iChannel0,map(reflect(eye,n))).rgb;\n    return sqrt(color);\n  } else {\n    // Octamap\n    vec3 p = abs(reflect(eye,n));\n    p /= dot(p,vec3(1));\n    vec3 color = texture(iChannel1,p.xy).rgb;\n    return sqrt(color);\n  }\n}\n\n// Solution parameters.\n#if defined FAST\nconst int iterations = 100;    // Maximum number of iterations\nconst float maxincrease = 1.1; // Largest allowed step increase.\n#elif defined QUALITY\nconst int iterations = 300;    // Maximum number of iterations\nconst float maxincrease = 1.03; // Largest allowed step increase.\n#else\nconst int iterations = 150;    // Maximum number of iterations\nconst float maxincrease = 1.06; // Largest allowed step increase.\n#endif\n\nconst float maxstep = 1.0;     // The largest step that can be taken.\nconst float minstep = 0.001;  // The smallest step\nconst float initstep = 0.1;\n\nbool solve(vec3 p0, vec3 r, out float k) {\n  float k0 = 0.0, k1;\n  float a0 = Fun(p0), a1;\n  bool bracketed = false;\n  bool found = false;\n  float step = initstep;\n  vec3 p;\n  float expected = 0.0;\n  for (int i = 0; i < iterations; i++) {\n    if (bracketed) {\n      // Once we are bracketed, just use bisection\n      if (k1-k0 < minstep) {\n        found = true;\n        break;\n      }\n      float k2 = (k0 + k1)/2.0;\n      //x = x0+k2*a, y = y0+k2*b, z = z0+k2*c, w = 1.0;\n      p = p0+k2*r;\n      float a2 = Fun(p);\n      if (a0*a2 <= 0.0) {\n        k1 = k2; a1 = a2;\n      } else {\n        k0 = k2; a0 = a2;\n      }\n    } else {\n      k1 = k0 + step;\n      p = p0 + k1*r;\n      a1 = Fun(p);\n      //The idea here is to try and correct the\n      // step size by seeing how close we are to\n      // the curve, but it doesn't seem to work\n      // very well.\n      float q = abs((a1-expected)/(a1+expected));\n      if (false && expected != 0.0 && q > 0.25) {\n        step *= 0.5;\n        expected = a0 + 0.5*(expected - a0);\n      } else if (a0*a1 <= 0.0) {\n        // We can hit exactly 0 - this counts as bracketed.\n        bracketed = true;\n      } else {\n        float step0 = step;\n        step = a1*step/(a0-a1);\n        step = abs(step);\n        step = min(step,maxstep);\n        // Don't grow step by more than a certain amount\n        // A better strategy should be possible\n        // Detect overstepping & retreat maybe.\n        step = max(step,minstep);\n        step = min(step,maxincrease*step0);\n        if (a1 <= a0) expected = 0.0;\n        else expected = a1 + step*(a1-a0)/(k1-k0);\n        k0 = k1; a0 = a1;\n      }\n    }\n  }\n  if (!found) return false;\n  k = 0.5*(k0+k1);\n  return true;\n}\n\nvec3 surface(vec3 p0, vec3 r) {\n  float k;\n  if (!solve(p0,r,k)) return vec3(0);\n\n  // Compute gradient & normal\n  // Should probably scale eps here\n  float eps = 1e-3;\n  vec2 delta = vec2(eps,0.0);\n  vec3 p = p0 + k*r;\n  float a = Fun(p);\n#if 0\n  vec3 n = vec3(Fun(p + delta.xyy), Fun(p + delta.yxy), Fun(p + delta.yyx)) - a;\n#else\n  // Two sided numeric derivative.\n  // Not sure how much difference this makes\n  vec3 n = vec3(Fun(p + delta.xyy) - Fun(p - delta.xyy),\n                Fun(p + delta.yxy) - Fun(p - delta.yxy),\n                Fun(p + delta.yyx) - Fun(p - delta.yyx));\n#endif\n  float grad = abs(length(n));\n  n = normalize(n);\n\n  vec3 eye = r.xyz;\n  // Point normal towards eye\n  if (dot(eye,n) > 0.0) n *= -1.0;\n  return selectColor(p,eye,n);\n}\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  p.yz = rotate(p.yz,iTime * 0.125);\n  p.zx = rotate(p.zx,-iTime * 0.2);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Projection parameters\n  float scale = 2.5;\n  float x = scale * (fragCoord.x - 0.5*iResolution.x)/iResolution.y;\n  float y = scale * (fragCoord.y - 0.5*iResolution.y)/iResolution.y;\n  float camera = 10.0;\n\n  vec3 p0 = vec3(0.0,0.0,camera);\n  vec3 r = normalize(vec3(x,y,-camera));\n\n  p0 = transform(p0);\n  r = transform(r);\n  fragColor = vec4(surface(p0,r),1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}