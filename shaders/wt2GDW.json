{
    "Shader": {
        "info": {
            "date": "1559664613",
            "description": "An artistic dispersive lens effect based on https://web.archive.org/web/20061128135550/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf. Use the mouse to move the lens. Inspired by https://www.taylorpetrick.com/blog/post/dispersion",
            "flags": 0,
            "hasliked": 0,
            "id": "wt2GDW",
            "likes": 80,
            "name": "rygcbv dispersion lens",
            "published": 3,
            "tags": [
                "refraction",
                "lens",
                "educational",
                "chromatic",
                "dispersion"
            ],
            "usePreview": 0,
            "username": "j2rgb",
            "viewed": 2653
        },
        "renderpass": [
            {
                "code": "// Created by Justin Shrake - @j2rgb/2019\n// Created in https://github.com/jshrake/grimoire\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// An artistic lens dispersion effect. This is not intended to be physically realistic.\n\n// Resources:\n// - https://web.archive.org/web/20061128135550/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf\n// - inspired by https://www.taylorpetrick.com/blog/post/dispersion-opengl\n\n// Use the mouse to move the lens\n\n// Comment to hide the lens ring\n#define SHOW_RING\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 lens_uv = fragCoord / iResolution.y;\n  vec2 lens_pos = iMouse.xy / iResolution.y;\n  if (iMouse.xy == vec2(0, 0)) {\n\tlens_pos = vec2(1.0, 0.5);\n  }\n  vec2 lens_delta = (lens_uv - lens_pos);\n  float lens_dist = length(lens_delta);\n\n  // Knobs to control the size and the \"zoom\" amount of the lens\n  float lens_radius = 0.45;\n  float lens_zoom = 2.0;\n\n  // pretend that the lens is spherical\n  // For the z component, see https://www.desmos.com/calculator/5p0apo0bqm\n  // Fudge the z component for stylistic control\n  float lens_radius_fudge = 0.5;\n  vec3 lens_normal =\n      normalize(vec3(lens_delta.xy, lens_zoom * sqrt(lens_radius_fudge * lens_radius - lens_dist*lens_dist)));\n  // the incoming light direction\n  vec3 incident = normalize(vec3(0.0, 0.0, -1.0));\n    \n  // ior ratios of (medium A)/(medium B). \n  // medium A is outside the lens, medium B is inside the lens\n  // - Use an ior of 1.0, corresponding to air, for medium A\n  // - Use a slightly higher ior for medium B. Tune to taste!\n  // See \n  // - https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\n  // - https://pixelandpoly.com/ior.html\n  float eta_r = 1.0 / 1.15;\n  float eta_y = 1.0 / 1.17;\n  float eta_g = 1.0 / 1.19;\n  float eta_c = 1.0 / 1.21;\n  float eta_b = 1.0 / 1.23;\n  float eta_v = 1.0 / 1.25;\n\n\n  // Calculate different refraction vectors for each color channel\n  vec2 refract_r = refract(incident, lens_normal, eta_r).xy;\n  vec2 refract_y = refract(incident, lens_normal, eta_y).xy;\n  vec2 refract_g = refract(incident, lens_normal, eta_g).xy;\n  vec2 refract_c = refract(incident, lens_normal, eta_c).xy;\n  vec2 refract_b = refract(incident, lens_normal, eta_b).xy;\n  vec2 refract_v = refract(incident, lens_normal, eta_v).xy;\n\n  vec3 tex = texture(iChannel0, uv).rgb;\n  vec3 tex_r = texture(iChannel0, refract_r + uv).rgb;\n  vec3 tex_y = texture(iChannel0, refract_y + uv).rgb;\n  vec3 tex_g = texture(iChannel0, refract_g + uv).rgb;\n  vec3 tex_c = texture(iChannel0, refract_c + uv).rgb;\n  vec3 tex_b = texture(iChannel0, refract_b + uv).rgb;\n  vec3 tex_v = texture(iChannel0, refract_v + uv).rgb;\n\n  float r = tex_r.r * 0.5;\n  float g = tex_g.g * 0.5;\n  float b = tex_b.b * 0.5;\n  float y = dot(vec3(2.0, 2.0, -1.0), tex_y)/6.0;\n  float c = dot(vec3(-1.0, 2.0, 2.0), tex_c)/6.0;\n  float v = dot(vec3(2.0, -1.0, 2.0), tex_v)/6.0;\n\n  float R = r + (2.0 * v + 2.0 * y - c)/3.0;\n  float G = g + (2.0 * y + 2.0 * c - v)/3.0;\n  float B = b + (2.0 * c + 2.0 * v - y)/3.0;\n\n  vec3 color = mix(tex, vec3(R, G, B), step(lens_dist, lens_radius));\n    \n#ifdef SHOW_RING\n  float ring = smoothstep(\n      0.0, 3.0 / iResolution.y,\n      abs(length((lens_uv - lens_pos)) - lens_radius) - 0.002);\n  color *= ring;\n#endif\n  fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 11,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}