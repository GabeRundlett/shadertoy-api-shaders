{
    "Shader": {
        "info": {
            "date": "1693922731",
            "description": "3D projection of the interior of a torus, calculated by solving a cubic equation.\nPros: efficient - no 'for' loops (except for oversampling).\nCons: complex math; less flexible than raymarching.\nSimilar shader: https://www.shadertoy.com/view/4sBGDy",
            "flags": 0,
            "hasliked": 0,
            "id": "DtXfzB",
            "likes": 6,
            "name": "Fast Torus",
            "published": 3,
            "tags": [
                "torus",
                "tokamak"
            ],
            "usePreview": 0,
            "username": "ruudhelderman",
            "viewed": 224
        },
        "renderpass": [
            {
                "code": "// Fast Torus\n// by Ruud Helderman, August-September 2023 - MIT License\n\n// A torus is such a simple mathematical object that you can do\n// a 3D projection by solving a quartic or even a cubic equation.\n// Pros: efficient - no 'for' loops (except for oversampling).\n// Cons: complex math; less flexible than raymarching.\n\nconst float PI = 3.1415926536;\n\n//---------------------------------------------------------------------------------------\n// Torus\n//---------------------------------------------------------------------------------------\n\n// Torus, centered at (0, 0, 0), with center axis along the Z axis.\n// Formula: (x^2 + y^2 + z^2 + R^2 - r^2)^2 = 4R^2(x^2 + y^2)\n// (see https://en.wikipedia.org/wiki/Torus)\n\nconst float R = 3.0;   // major radius (distance between center axis and center of tube)\nconst float r = 2.0;   // minor radius (radius of tube)\n\n// Given a point on the surface of the torus, get its skin coordinates.\nvec2 torus_to_skin(vec3 p)\n{\n    return atan(p.yz, vec2(p.x, length(p.xy) - R)) / PI;\n}\n\n// Given a point on the surface of the torus, get its normal vector (normalized).\nvec3 torus_normal(vec3 p)\n{\n    return (vec3(normalize(p.xy) * R, 0) - p) / r;\n}\n\n// Dot product of normal vector with ray from source. Used for lighting.\nfloat torus_normal_dot(vec3 p, vec3 source)\n{\n    return dot(torus_normal(p), normalize(source - p));\n}\n\n//---------------------------------------------------------------------------------------\n// Ray\n//---------------------------------------------------------------------------------------\n\n// Formula: y = uv.x * (x+R+r), z = uv.y * (x+R+r)\n\n// Camera is located at surface of torus (on negative part of X axis).\n// That location greatly simplifies our calculation as we already know one intersection\n// between ray and torus, leaving us with only a cubic equation to solve.\nconst vec3 camera = vec3(-R-r, 0, 0);\n\n// Camera looks inside (toward center axis), along X axis in positive direction.\n// Given the X coordinate of a point on the ray, calculate the remaining coordinates.\nvec3 ray_point(float x, vec2 uv)\n{\n    return vec3(x, (x - camera.x) * uv);\n}\n\n//---------------------------------------------------------------------------------------\n// Solve cubic equation\n//---------------------------------------------------------------------------------------\n\nfloat cubic_1_root(float q, float sd)\n{\n    vec2 v = vec2(sd, -sd) - q;\n    v = sign(v) * pow(abs(v), vec2(1.0/3.0));\n    return v.x + v.y;\n}\n\nfloat cubic_smallest_of_3_roots(float p, float sp, float q)\n{\n    return -2.0 * sp * cos(acos(q / (p * sp)) / 3.0);\n}\n\n// Calculate the smallest real root of the depressed cubic equation x^3-3px+2q=0\nfloat cubic_smallest_real_root(float p, float q)\n{\n    float d = q*q - p*p*p;\n    return d > 0.0 ? cubic_1_root(q, sqrt(d)) : cubic_smallest_of_3_roots(p, sqrt(p), q);\n}\n\n//---------------------------------------------------------------------------------------\n// Intersect ray with torus\n//---------------------------------------------------------------------------------------\n\n// Calculate coordinates of intersection between ray and torus\nvec3 intersect_torus(vec2 uv)\n{\n    vec2 uv2 = uv*uv;\n    float k = uv2.x + uv2.y;\n    \n    vec2 v = mat4x2(1, 2, -1, -5, -3, -9, -3, 18) * vec4(R*R+r*r, R*r, R*r*k, R*R*uv2.y);\n    \n    float p = 4.0/9.0*v.x;\n    float q = 4.0/27.0*(R+r)*v.y;\n    \n    float x = (cubic_smallest_real_root(p, q) - (R+r)*(k-1.0/3.0)) / (k+1.0);\n    \n    return ray_point(x, uv);\n}\n\n//---------------------------------------------------------------------------------------\n// Skin of torus\n//---------------------------------------------------------------------------------------\n\nconst float number_of_skins = 10.0;\nconst float time_between_transitions = 5.0;\nconst float transition_duration = 0.4;\nconst float animation_speed = 0.03;\n\nfloat transition_step(float n)\n{\n    return smoothstep(0.0, transition_duration / time_between_transitions, n);\n}\n\nfloat timeslot(float n)\n{\n    float m = mod(-n, number_of_skins);\n    return transition_step(m) - transition_step(m - 1.0);\n}\n\nfloat square_wave(float x)\n{\n    return 0.5 + 0.5 * tanh(16.0 * cos(2.0 * PI * x));\n}\n\nfloat squares(vec2 uv, float n)\n{\n    vec2 s = tanh(n * sin(12.0 * PI * uv));\n    return s.x * s.y;\n}\n\nvec3 skin_toothpaste(vec2 uv)\n{\n    return mix(vec3(0.2, 0.4, 1), vec3(1), square_wave(dot(uv, vec2(1, 3))));\n}\n\nvec3 skin_grid(vec2 uv)\n{\n    return mix(vec3(0), vec3(1, 0.3, 0.3), abs(squares(uv, 8.0)));\n}\n\nvec3 skin_morph(vec2 uv, float t)\n{\n    return mix(vec3(0.8, 0, 1), vec3(0.4, 0, 0.5), square_wave(length(sin(t * 0.25) + sin(8.0 * PI * uv))));\n}\n\nvec3 skin_eight(vec2 uv)\n{\n    return mix(vec3(0.5), vec3(1), square_wave(uv.x + uv.y));\n}\n\nvec3 skin_checkered(vec2 uv)\n{\n    return mix(vec3(0.8, 0.6, 0), vec3(0.6, 0.4, 0), squares(uv, 32.0));\n}\n\nvec3 skin_wired(vec2 uv)\n{\n    return mix(vec3(0), vec3(0.6, 0.8, 1), 0.5 + 0.5 * sin(32.0 * PI * (uv.x + uv.y)));\n}\n\nvec3 skin_channel(vec2 uv, sampler2D s)\n{\n    return texture(s, acos(cos(uv * PI)) / PI).rgb;\n}\n\n// Every few seconds a different skin\nvec3 skin(vec2 uv, float t)\n{\n    uv += t * animation_speed;\n    float s = t / time_between_transitions;\n    //s = 2.0;        // uncomment and specify number to stick to that skin\n    vec3 c = vec3(0);\n    float a;\n    a = timeslot(--s); if (a > 0.0) c += a * skin_toothpaste(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_grid(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_morph(uv, t);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_eight(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_checkered(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_wired(uv);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel0);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel1);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel2);\n    a = timeslot(--s); if (a > 0.0) c += a * skin_channel(uv, iChannel3);\n    return c;\n}\n\n//---------------------------------------------------------------------------------------\n// Projection of torus onto 2D screen\n//---------------------------------------------------------------------------------------\n\n// Light source is at the same point as the camera;\n// helps keep the implementation simple (no visible shadow of the axis on the outer wall).\n\nconst float dark = 0.3;\nconst float light = 1.0;\n\n// Find a balance between horizontal and vertical resolution while maintaining aspect ratio.\nfloat average(vec2 res)\n{\n    return 0.5 * (res.x + res.y);\n}\n\n// Convert from pixels to normalized centered coordinates, roughly [-1, 1]\nvec2 normalize_screen(vec2 uv, vec2 res)\n{\n    return (2.0 * uv - res) / average(res);\n}\n\n// Get the color of the pixel at the given screen coordinates and the given time\nvec3 projection(vec2 uv, float t)\n{\n    vec3 p = intersect_torus(normalize_screen(uv, iResolution.xy));\n    return skin(torus_to_skin(p), t) * mix(dark, light, torus_normal_dot(p, camera));\n}\n\n//---------------------------------------------------------------------------------------\n// Anti-aliasing\n//---------------------------------------------------------------------------------------\n\n// Easy adaptive sampling, by Fabrice Neyret\n// https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n\nvec3 oversampled_projection(vec2 uv)\n{\n    vec3 color = projection(uv, iTime);\n    if (fwidth(length(color)) > .01)\n    {\n        for (int k = 0; k < 9; k += k==3?2:1)\n        {\n            color += projection(uv + vec2(k%3-1,k/3-1)/3.0, iTime);\n        }\n        color /= 9.0;\n        //color.r++;        // uncomment to see where the oversampling occurs\n    }\n    return color;\n}\n\n//---------------------------------------------------------------------------------------\n// Main\n//---------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(oversampled_projection(fragCoord), 1);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 4,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}