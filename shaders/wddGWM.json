{
    "Shader": {
        "info": {
            "date": "1568730847",
            "description": "The code is really rough (lots hardcoded), but I'm pretty happy with the result. It runs differently every time. Each color eats around the color wheel.\nI based the code off MadScientistMoses' \"Simple Chaos\" shader https://www.shadertoy.com/view/wd3GWN .",
            "flags": 32,
            "hasliked": 0,
            "id": "wddGWM",
            "likes": 23,
            "name": "HSL Cellular Automata",
            "published": 3,
            "tags": [
                "colorful",
                "automata",
                "cellular",
                "hsl",
                "buffer",
                "vibran",
                "cineshadert"
            ],
            "usePreview": 0,
            "username": "Jordan",
            "viewed": 7662
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Output to screen\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\n\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nint xorshift(in int value) // For random number generation\n{\n    // Xorshift*32\n    // Based on George Marsaglia's work: http://www.jstatsoft.org/v08/i14/paper\n    value ^= value << 13;\n    value ^= value >> 17;\n    value ^= value << 5;\n    return value;\n}\n\nint nextInt(inout int seed)  // RNG\n{\n    seed = xorshift(seed);\n    return seed;\n}\n\nfloat nextFloat(inout int seed) // RNG\n{\n    seed = xorshift(seed);\n    return abs(fract(float(seed) / 31416.592898653));\n}\n\nfloat nextFloat(inout int seed, in float max) // RNG\n{\n    return nextFloat(seed) * max;\n}\n\nvec3 nearby(in vec2 fragCoord, in vec2 offset) // For getting pixels from prev. frame\n{\n    vec2 uv = (fragCoord + offset)/iResolution.xy;\n    return vec3(texture(iChannel0, uv));\n}\n\n\nfloat hueDiff(in float a, in float b) // Finds the shortest difference between two hues\n{\t\n    float diff=fract(a)-fract(b);\n    if(abs(diff)<0.5)\n        return diff;\n    else\n        return diff - 1.*sign(diff);\n}\n\nfloat checkfunction(in float near_hue, in float prev_hue) // used to determine the likelyhood of a pixel moving\n{\n    return (sign(hueDiff(near_hue,prev_hue)) + 4.*hueDiff(near_hue,prev_hue))/abs(hueDiff(near_hue,prev_hue));\n}\n\n\n\nconst float threshold = 0.4; // Amount of randomness\n#define PI 3.14159\n#define initial_cols (vec3(atan((uv.x-0.5)/(uv.y-0.5))/PI,1.,2.-2.*((uv.x-0.5)*(uv.x-0.5)+(uv.y-0.5)*(uv.y-0.5))))\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int rngSeed = int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) + int(iTime * 1000.0);\n\t\n    float mouseDown = iMouse.z;\n    vec2 uvMouse = vec2(iMouse)/iResolution.xy;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 previous = rgb2hsv(vec3(texture(iChannel0, uv)));\n    vec3 next = previous;\n    \n    \n    if(next[2]>0.05)    // Slowly fade un-updated pixels to black \n    \tnext[2]*=0.99;\n\n    \n    \n    if(nextFloat(rngSeed, 1.0) > threshold) // randomly update pixels\n    {\n        \n        // Adjacent pixles\n        vec3 up = rgb2hsv(nearby(fragCoord, vec2(0.0, -1.0)));\n        vec3 down = rgb2hsv(nearby(fragCoord, vec2(0.0, 1.0)));\n        vec3 left = rgb2hsv(nearby(fragCoord, vec2(-1.0, 0.0)));\n        vec3 right = rgb2hsv(nearby(fragCoord, vec2(1.0, 0.0)));\n        \n        // NOTE: everything is now [hue, sat, val] rather than [red, green, blue]\n        \n        // Weights of this pixel becoming the same color as one of the adjacents\n        float upweight = up[2]*up[2]*up[1]*up[1]*(abs(hueDiff(up[0],previous[0]))-0.3)*(0.7-abs(hueDiff(up[0],previous[0])))*(0.1+0.6*up[2])*checkfunction(up[0],previous[0]);\n        float downweight = down[2]*down[2]*down[1]*down[1]*(abs(hueDiff(down[0],previous[0]))-0.3)*(0.7-abs(hueDiff(down[0],previous[0])))*(0.1+0.6*down[2])*checkfunction(down[0],previous[0]);\n        float leftweight = left[2]*left[2]*left[1]*left[1]*(abs(hueDiff(left[0],previous[0]))-0.3)*(0.7-abs(hueDiff(left[0],previous[0])))*(0.1+0.6*left[2])*checkfunction(left[0],previous[0]);\n        float rightweight = right[2]*right[2]*right[1]*right[1]*(abs(hueDiff(right[0],previous[0]))-0.3)*(0.7-abs(hueDiff(right[0],previous[0])))*(0.1+0.6*right[2])*checkfunction(right[0],previous[0]);\n        float _max = max(max(upweight,downweight),max(leftweight,rightweight));\n\t\t\n        // Only update if the best option is strong enough\n        if(_max>((previous[2]*previous[1]))*3.0)\n        {\n            if( _max == upweight)\n                next = up;\n            \n            if (_max == downweight)\n                next = down;\n\n            if (_max == leftweight)\n                next = left;\n\n            if (_max == rightweight)\n                next = right;\n            // Inject some saturation and lightness to new pixles\n            if(next[2]<1.)\n                next[2]+=0.5+0.5*(abs(hueDiff(next[0],previous[0]))-1.);\n            if(next[1]<1.)\n                next[1]+=0.0008; \n        }\n        else // make pixels diffuse if they can't update. Stops single-pixel islands\n        {\n            vec3 up_rgb = (nearby(fragCoord, vec2(0.0, -1.0)));\n            vec3 down_rgb = (nearby(fragCoord, vec2(0.0, 1.0)));\n            vec3 left_rgb = (nearby(fragCoord, vec2(-1.0, 0.0)));\n            vec3 right_rgb = (nearby(fragCoord, vec2(1.0, 0.0)));\n            vec3 prev_rgb = vec3(texture(iChannel0, uv));\n            next = rgb2hsv(prev_rgb*0.7 + 0.3*(up_rgb+down_rgb+left_rgb+right_rgb)/4.);\n        }\n    }\n\n\t// Mouse click\n    if(length(uvMouse-uv)<.13 && mouseDown > 0.5) \n        next = vec3(0.,1.,0.);//vec3(nextFloat(rngSeed, 1.0),nextFloat(rngSeed, 1.0),nextFloat(rngSeed, 1.0));\n\t// Set up the first frame\n    if((iFrame == 0)&&length(uv-0.5)>0.2) \n    {\n        next = initial_cols;\n        previous = next;\n    }\n\n    // Output to screen\n    fragColor = vec4(hsv2rgb(next),1.0);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}