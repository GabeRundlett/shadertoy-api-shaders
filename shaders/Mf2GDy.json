{
    "Shader": {
        "info": {
            "date": "1704609074",
            "description": "a buffer which tracks the mouse nicely across mouse ups.\noptions for wrapping, clamping, etc.",
            "flags": 32,
            "hasliked": 0,
            "id": "Mf2GDy",
            "likes": 12,
            "name": "utility: stable mouse",
            "published": 3,
            "tags": [
                "mouse",
                "utility"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 245
        },
        "renderpass": [
            {
                "code": "// Code is in Buffer C.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord), 0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// mouse handling.\n// outputs non-normalized mouse as (0,0).xy.\n// defaults to iResolution.xy / 2.\n// resets when mouse is in lower-left.\n// https://www.shadertoy.com/view/Mf2GDy\n// orion elenzil January 2024.\n\n// Wrapping mode for X and Y:\n// 0u = unconstrained\n// 1u = clamp\n// 2u = wrap\nconst uvec2 wrap = uvec2(2u, 1u);\n\n// initial position (normalized)\nconst vec2  p0   = vec2(0.5, 0.5);\n\n// when actual mouse is within this radius\n// in the lower-right, reset to p0.\nconst float resetCircle = 75.0;\n\n// 1 to visualize the mouse position and reset circle.\n#define VISUALIZE 1\n\n// special texels\nconst ivec2 pos = ivec2(0, 0);\nconst ivec2 btn = ivec2(1, 0);\nconst ivec2 res = ivec2(2, 0);\nconst ivec2 hrt = ivec2(3, 0);\n\n\n// data[0] <- bool mouseIsDown\n// data[1] <- bool mouseJustBecameDown\n// data.zw <- current mouse pos\nvoid trackButton(inout vec4 data) {\n    bool mouseIsDown         = iMouse.z > 0.0;\n    bool mouseWasDown        = bool(data[0]);\n    bool mouseJustBecameDown = !mouseWasDown && mouseIsDown;\n    \n    data[0] = float(mouseIsDown);\n    data[1] = float(mouseJustBecameDown);\n    data.zw = iMouse.xy;\n}\n\n// data.xy <- cumulative mousePos\n// data.zw <- raw last mousePos\nvoid trackMouse(inout vec4 data, in vec4 button) {\n    bool mouseIsDown = bool(button[0]);\n    bool mouseJustBecameDown = bool(button[1]);\n    vec2 mouse = button.zw;\n\n    vec2 home = p0 * iResolution.xy;\n    \n    if (iFrame == 0) {\n        data.xy = home;\n        data.zw = mouse;\n        return;\n    }\n\n    vec2 prevRes = texelFetch(iChannel2, res, 0).xy;\n    if (prevRes != vec2(0) && prevRes != iResolution.xy) {\n        // iMouse.xy goes to 0,0 on resolution change,\n        // and there's nothing to do about that,\n        // but this logic makes the edges a little smoother\n        // when changing to fullscreen and then right back again.\n        data.xy = data.xy * iResolution.xy / prevRes;\n        return;\n    }\n\n    if (dot(iMouse.xy, iMouse.xy) < resetCircle * resetCircle) {\n        data.xy = mix(data.xy, home, 0.1);\n        data.zw = mouse;\n        return;\n    }\n    \n    if (!mouseIsDown) {\n        return;\n    }\n    \n    if (mouseJustBecameDown) {\n        data.zw = mouse;\n    }\n    \n    vec2 prevMouse = data.zw;\n    vec2 deltMouse = mouse - prevMouse;\n    \n    data.xy += deltMouse;\n    \n    for (int n = 0; n < 2; ++n) {\n        switch (wrap[n]) {\n            case 0u:\n                break;\n            case 1u:\n                // clamp\n                data[n] = clamp(data[n], 0.0, iResolution[n] - 1.0);\n                break;\n            case 2u:\n                // wrap\n                data[n] = mod(data[n], iResolution[n]);\n                break;\n        }\n    }\n    \n    data.zw = mouse;\n}\n\nvoid trackResolution(inout vec4 RGBA) {\n    RGBA.xy = vec2(iResolution.xy);\n}\n\n// buffers are currently 100% broken on all browsers on iOS.\n// this provides a work-around so shaders can detect that.\nvoid trackHeartbeat(inout vec4 RGBA) {\n    RGBA.r = 1.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    ivec2 IJ = ivec2(XY);\n    \n    RGBA = texelFetch(iChannel2, IJ, 0);\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0);\n    }\n    \n    if (IJ == btn) {\n        trackButton(RGBA);\n        return;\n    }\n    \n    vec4 button = texelFetch(iChannel2, btn, 0);\n    \n    if (IJ == pos) {\n        trackMouse(RGBA, button);\n        return;\n    }\n    \n    if (IJ == res) {\n        trackResolution(RGBA);\n        return;\n    }\n    \n    if (IJ == hrt) {\n        trackHeartbeat(RGBA);\n        return;\n    }\n    \n    \n#if VISUALIZE\n    vec4 mouse = texelFetch(iChannel2, pos, 0);\n    \n    vec2  p = XY;\n    float d = 1e9;\n    d = min(d, abs(length(p) - resetCircle));\n    float a = atan(p.y, p.x) * 20.0 - iTime;\n    d += smoothstep(-0.2, 0.2, sin(a));\n    d = min(d, abs(length(p - mouse.xy) - 20.0) - 2.0);\n    d = min(d, abs(length(p - mouse.zw) - 10.0) - 2.0);\n    float c = smoothstep(2.0, 0.0, d);\n    \n    RGBA.rgb = vec3(c);\n#else\n    discard;\n#endif\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}