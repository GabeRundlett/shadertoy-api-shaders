{
    "Shader": {
        "info": {
            "date": "1677081096",
            "description": "3D",
            "flags": 0,
            "hasliked": 0,
            "id": "Dd3GR4",
            "likes": 2,
            "name": "Volumetric Media Rendering",
            "published": 3,
            "tags": [
                "3d",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "FifthStateOfMatter",
            "viewed": 133
        },
        "renderpass": [
            {
                "code": "//const vec3 lightDir = normalize(vec3(-10, -10, 10));\nconst float mediaDensity = 0.3;\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n//Dave_Hoskins' Hash Without Sine\nfloat random3(vec3 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.zyx + 31.32);\n    return max(fract((p.x + p.y)*p.z)*2.0 - 1.0, 0.0);\n}\n\nfloat random2(vec2 p){\n    p = fract(p*0.1031);\n    p += dot(p, p.yx + 31.32);\n    return max(fract(p.x + p.y)*2.0 - 1.0, 0.0);\n}\n\nfloat noise3(vec3 p){\n    /*vec3 fc = floor(p);\n    vec3 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random3(fc + vec3(0, 1, 0));\n    float trf = random3(fc + vec3(1, 1, 0));\n    float blf = random3(fc + vec3(0, 0, 0));\n    float brf = random3(fc + vec3(1, 0, 0));\n    float tlb = random3(fc + vec3(0, 1, 1));\n    float trb = random3(fc + vec3(1, 1, 1));\n    float blb = random3(fc + vec3(0, 0, 1));\n    float brb = random3(fc + vec3(1, 0, 1));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    float lerpTopBack = mix(tlb, trb, frc.x);\n    float lerpBottomBack = mix(blb, brb, frc.x);\n    \n    float lerpFront = mix(lerpBottomFront, lerpTopFront, frc.y);\n    float lerpBack = mix(lerpBottomBack, lerpTopBack, frc.y);\n    \n    return mix(lerpFront, lerpBack, frc.z);*/\n    return texture(iChannel0, p*0.03).g*0.7;\n}\n\nfloat noise2(vec2 p){\n    vec2 fc = floor(p);\n    vec2 frc = fract(p);\n    frc = frc*frc*(3.0 - 2.0*frc);\n    \n    float tlf = random2(fc + vec2(0, 1));\n    float trf = random2(fc + vec2(1, 1));\n    float blf = random2(fc + vec2(0, 0));\n    float brf = random2(fc + vec2(1, 0));\n    \n    float lerpTopFront = mix(tlf, trf, frc.x);\n    float lerpBottomFront = mix(blf, brf, frc.x);\n    \n    return mix(lerpBottomFront, lerpTopFront, frc.y);\n}\n\nfloat fbm(vec3 p){\n    /*float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise3(p*f)*h;\n    for(int i = 0; i < 2; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise3(rotate2D(p, vec2(0, r))*f)*h;\n    }*/\n    //return n/1.0;\n    return (texture(iChannel0, p*0.001).r + texture(iChannel0, p*0.002).g*0.5 + texture(iChannel0, p*0.004).g*0.25)*(1.0/1.75);\n}\n\nfloat fbm2(vec3 p){\n    float f = 1.0;\n    float r = radians(57.0);\n    float h = 1.0;\n    float n = noise2(p.xz*f)*h;\n    for(int i = 0; i < 4; i++){\n        f *= 2.0;\n        r += radians(57.0);\n        h /= 2.0;\n        n += noise2(rotate2D(p, vec2(0, r)).xz*f)*h;\n    }\n    return n/1.0;\n}\n\nstruct box{\n    vec3 pos;\n    vec3 size;\n};\n\nbox b1 = box(vec3(0, 2, 0), vec3(60, 2, 60));\n\nbool raytraceBox(vec3 o, vec3 d, out float ct, out float ft, box b){\n    vec3 tMin;\n    vec3 tMax;\n\n    vec3 halfSize = b.size/2.0;\n\n    vec3 lbf = b.pos - halfSize;\n    vec3 rtb = b.pos + halfSize;\n\n    tMin = (lbf - o)/d;\n    tMax = (rtb - o)/d;\n\n    if(tMin.x > tMax.x){\n        float tempT = tMin.x;\n        tMin.x = tMax.x;\n        tMax.x = tempT;\n    }\n\n    if(tMin.y > tMax.y){\n        float tempT = tMin.y;\n        tMin.y = tMax.y;\n        tMax.y = tempT;\n    }\n\n    if(tMin.z > tMax.z){\n        float tempT = tMin.z;\n        tMin.z = tMax.z;\n        tMax.z = tempT;\n    }\n\n    if((tMin.x > tMax.y) || (tMin.y > tMax.x)){\n        return false;\n    }\n\n    if(tMin.y > tMin.x){\n        tMin.x = tMin.y;\n    }\n\n    if(tMax.y < tMax.x){\n        tMax.x = tMax.y;\n    }\n\n    if((tMin.x > tMax.z) || (tMin.z > tMax.x)){\n        return false;\n    }\n\n    if(tMin.z > tMin.x){\n        tMin.x = tMin.z;\n    }\n\n    if(tMax.z < tMax.x){\n        tMax.x = tMax.z;\n    }\n    \n    if(ct < 0.0){\n        return false;\n    }\n    ct = max(tMin.x, 0.0);\n    ft = max(tMax.x, 0.0);\n    return true;\n}\n\nfloat densityAtPoint(vec3 p){\n    return max(fbm((p - vec3(iTime, 0, 0))*vec3(0.5, 1, 0.5))*10.0 - noise3((p - vec3(iTime, 0, 0))*0.3)*20.0, 0.0);\n}\n\nfloat getDensityOnRay(vec3 o, vec3 d, float ct, float ft, int res){\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = d*stepLength;\n    float density = 1.0;\n    for(int i = 0; i < res; i++){\n        float currDensity = exp(-mediaDensity*stepLength*densityAtPoint(samplePos));\n        density *= currDensity;\n        samplePos += stepDir;\n        if(density >= 0.99) break;\n    }\n    return density;\n}\n\nvec2 renderVolume(vec3 o, vec3 d, float ct, float ft, int res){\n    vec3 samplePos = o + d*ct;\n    float stepLength = (ft - ct)/float(res);\n    vec3 stepDir = stepLength*d;\n    float density = 1.0;\n    float outDensity = 0.0;\n    float transmittance = 0.0;\n    for(int i = 0; i < res; i++){\n        //vec3 lightDir = normalize(vec3(0, 10, cos(iTime)*100.0 - 100.0) - samplePos);\n        vec3 lightDir = normalize(vec3(-10, -10, 10));\n        float lct;\n        float lft;\n        bool lightHit = raytraceBox(samplePos, lightDir, lct, lft, b1);\n        float currDensity = exp(-mediaDensity*stepLength*densityAtPoint(samplePos));\n        density *= currDensity;\n        if(lightHit){\n            float lDensity = getDensityOnRay(samplePos, lightDir, lct, lft, 15);\n            transmittance += density*lDensity*densityAtPoint(samplePos)*mediaDensity*stepLength;\n        }\n        outDensity += (1.0 - currDensity)*(1.0 - outDensity);\n        samplePos += stepDir;\n        if(outDensity >= 0.999 || transmittance >= 0.999) break;\n    }\n    return vec2(outDensity, transmittance);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    //vec3 o = vec3(sin(-iTime)*8.0, 0, cos(-iTime)*8.0);\n    //vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(0, iTime - radians(180.0))));\n    vec3 o = vec3(0, 0, -8);\n    vec3 d = normalize(rotate2D(vec3(uv, 1), vec2(0, 0)));\n    float ct;\n    float ft;\n    bool hitBox = raytraceBox(o, d, ct, ft, b1);\n    \n    vec3 skyCol = mix(vec3(0.7, 0.9, 1), vec3(0.4, 0.5, 1), uv.y/2.0 + 0.5);\n    \n    if(hitBox){\n        vec2 renderMedia = renderVolume(o, d, ct, ft, 50);\n        \n        col = mix(skyCol, mix(mix(vec3(1, 0.8, 0.7), vec3(0), renderMedia.y), skyCol, 1.0 - exp(-ct*vec3(0.1, 0.1, 0.15))), renderMedia.x);\n    }else{\n        col = skyCol;\n    }\n    fragColor = vec4(pow(col, vec3(1.0/2.2)), 1);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 40,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}