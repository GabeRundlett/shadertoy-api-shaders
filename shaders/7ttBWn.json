{
    "Shader": {
        "info": {
            "date": "1662962355",
            "description": "Test",
            "flags": 32,
            "hasliked": 0,
            "id": "7ttBWn",
            "likes": 1,
            "name": "A simple PathTracing test22912",
            "published": 3,
            "tags": [
                "pathtracing"
            ],
            "usePreview": 0,
            "username": "feiqi3",
            "viewed": 309
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n\nconst int STEPMAX = 32;\nconst float START = 0.0001;\nconst float END = 50.001;\nconst float EPS = 0.00001; \nconst int bounces = 4;\n\nstruct record{\n    float t;\n    vec3 p;\n    mediump vec3 nor;\n    int mat;\n};     \n\nstruct matInfo{\n    vec3 attenuation;\n    bool emitted;\n};\n\n\n//https://iquilezles.org/articles/distfunctions/\nvec2 sdSphere( vec3 p,vec3 pos, float r,int mat )\n{\n  return vec2(length(p - pos)-r,mat);\n}\n\nvec2 Box(vec3 p,vec3 c,vec3 pos,int mat){\n    vec3 p2surf = abs(p - pos) - c;\n    return vec2(length(max(p2surf,0.)) + min(max(max(p2surf.x,p2surf.y),p2surf.z),0.),mat);\n}\n\n\n//https://iquilezles.org/articles/distfunctions/\nvec2 udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ,int mat)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return vec2(sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) )\n    ,mat);\n}\n\nvec2 map(vec3 p){\n    vec2 lightTop = udQuad( p, vec3(-8,3.,0), vec3(-8,3,-10), vec3(8,3,-10), vec3(8,3,0),5);\n    vec2 sphere1 =  sdSphere(p,vec3(-2,0.3,-3),1.,2);\n    vec2 sphere2 =  sdSphere(p,vec3(0,1,-5),1.,1);\n    vec2 lightdown = udQuad( p, vec3(-8,-3.,0), vec3(-8,-3,-10), vec3(8,-3,-10), vec3(8,-3,0),5);\n    return uSDF(sphere1,sphere2);\n}\n\nfloat random(float x)\n{\n    float y = fract(sin(x * iTime)*234.567);\n    return y;\n}\n\nvec3 randDirInSph(vec3 seed){\n    return normalize(vec3(2.*(random(seed.y)-.5),2.*(random(seed.z) -.5), 2.*(random(seed.x)-.5)));\n}\n\nvec3 getRay(float fov_degree,vec2 fragCoord,vec2 imgSize){\n    vec2 img_center = imgSize / 2.;\n    float z_cam = ((imgSize.y/2.)/tan(radians(fov_degree)/2.)); \n    return normalize(vec3(fragCoord,0.) - vec3(img_center,z_cam));\n}\n\nvec3 calcNormal( in vec3 p ){ // for function f(p)\n    const float h = 0.0003; // replace by an appropriate value\n    const vec2 k = vec2(1,-1)*0.5773;\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}    \n\nbool intersection(vec3 ro,vec3 rd,inout record rec){\n    float t = START;\n    for(int i = 0; i < STEPMAX; i++){\n        vec3 p = vec3(ro + t * rd);\n        vec2 dis = map(p);\n        if(dis.x < EPS){\n            rec.p = p;\n            rec.t = t;\n            rec.mat = int(dis.y);\n            rec.nor = calcNormal(rec.p);\n            return true;\n        }\n        t += dis.x;\n        if(t > END){\n            return false;\n        }\n    }\n    return false;\n}    \n\nvec3 getMatAndDir(vec3 seed,int mat,vec3 nor,vec3 inDir,inout matInfo info){\n    vec3 dir = vec3(0);\n    //mirror\n    switch(mat){\n        case 1:\n        {\n            info.attenuation = vec3(.7, .7, .7);\n            return reflect(inDir, nor);\n            break;\n        }\n        //red\n        case 2:\n        {\n            info.attenuation = vec3(.65, .05, .05);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //white\n        case 3:\n        {\n            info.attenuation = vec3(.73, .73, .73);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //green\n        case 4:\n        {\n            info.attenuation = vec3(.12, .45, .15);\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n        //light\n        case 5:\n        {\n            info.attenuation = vec3(1,1,1);\n            info.emitted = true;\n            return normalize(nor + randDirInSph(seed));\n            break;\n        }\n    }\n    return dir;\n}\n\nvec3 pathTracing(vec3 ro,vec3 rd){\n    vec3 r_ori = ro;\n    vec3 r_dir = rd;\n    vec3 clr = vec3(1,1,1);\n    record rec;\n    matInfo info;\n    for(int i = 0; i < bounces; i++){\n        if(intersection(r_ori,r_dir,rec)){\n            r_dir = getMatAndDir(rec.p,rec.mat,rec.nor,r_dir,info);\n            r_ori = rec.p;\n            clr *= info.attenuation;\n            if(info.emitted){\n                return clr;\n            }\n        }\n    }\n    return texture(iChannel1,r_dir).rgb * clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //AA\n    vec2 jitter = randDirInSph(fragCoord.xyy).xz/2.;\n    vec3 camPos =vec3(0,0,10);\n    vec3 dir = getRay(45.0,fragCoord+jitter,iResolution.xy);  \n    vec4 clr =vec4(pathTracing(camPos,dir),1.);\n    vec4 lastFrame;\n    if(iFrame == 0){\n        fragColor = clr;\n        return;\n    }else{\n        lastFrame = texture(iChannel0,fragCoord/iResolution.xy);\n    }\n    fragColor = mix(lastFrame,clr,1./ float(iFrame+1));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 24,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "vec2 uSDF(vec2 a,vec2 b){\n    return a.x < b.x ? a : b;\n}\nvec2 iSDF(vec2 a,vec2 b){\n    return a.x > b.x ? a : b;\n}\nvec2 dSDF(vec2 a,vec2 b){\n    return a.x > -b.x ? a : b;\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}