{
    "Shader": {
        "info": {
            "date": "1506971538",
            "description": "a grid of 4d spheres and cubes.\nworking on truchet",
            "flags": 0,
            "hasliked": 0,
            "id": "XtlyDl",
            "likes": 4,
            "name": "4d raymarching",
            "published": 3,
            "tags": [
                "raymarching",
                "simple",
                "4d"
            ],
            "usePreview": 0,
            "username": "abje",
            "viewed": 739
        },
        "renderpass": [
            {
                "code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define pi acos(-1.0)\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat box(vec4 p, float size) {\n    vec4 p2 = abs(p)-size;\n    return length(max(p2,0.0))+min(0.0,max(max(max(p2.x,p2.y),p2.z),p2.w));\n}\n\nfloat torus(vec4 p, vec2 r) {//creates 4 toruses\n    return length(vec2(abs(length(p.xyz)-r.x),p.w))-r.y;\n}\n\nfloat torus2(vec4 p, vec2 r) {//creates 4 toruses\n    return length(vec3(abs(length(p.xy)-r.x),p.zw))-r.y;\n}\n\n/*float map(vec4 p) {\n    vec4 p2 = mod(p,4.0)-2.0;\n    \n    //float transition = clamp(abs(mod(iTime*0.2,2.0)-1.0)*5.0-2.0,0.0,1.0);\n    //return min(box(p2,1.0-transition)-transition,length(abs(p2)-1.0)-0.5);\n    //return box(p2,1.0-transition)-transition;\n    return torus(p2,vec2(1.0,0.3));\n}*/\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat map(vec4 p) {\n    \n    \n    \n    //vec4 p2 = abs(mod(p,4.0)-2.0)-1.0;\n    //return box(p2,0.5);\n    vec4 p2 = mod(p,2.0)-1.0;\n    vec4 floorpos = floor(p*0.5);\n    float len = 1e10;\n    \n    //the truchet flipping\n    vec4 orientation = floor(hash44(floorpos)+0.5)*2.0-1.0;\n    //orientation.yz = vec2(1.0);\n    \n    //actually flipping the truchet\n    vec4 p3 = p2*orientation;\n    \n    //positions relative to truchet centers\n    \n    float x = 1.0;\n    \n    vec4[4] truchet = vec4[4] (\n        vec4(p3.xy+vec2(+1,-1),p3.zw),// +x +y\n        vec4(p3.xz+vec2(-1,-1),p3.yw),// +x    +z\n        vec4(p3.yw+vec2(+1,-1),p3.xz),//    +y    +w\n        vec4(p3.zw+vec2(+1,+1),p3.xy) //       +z +w\n    );\n    \n    //finding distance to truchet\n    len = min(min(min(\n        torus2(truchet[0],vec2(1.0,0.05)),\n        torus2(truchet[1],vec2(1.0,0.05))),\n        torus2(truchet[2],vec2(1.0,0.05))),\n        torus2(truchet[3],vec2(1.0,0.05)));\n    \n    return len;\n}\n\nvec4 findnormal(vec4 p, float len) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-len,\n        map(p+eps.yxyy)-len,\n        map(p+eps.yyxy)-len,\n        map(p+eps.yyyx)-len));\n}\n\nvec4 findnormal(vec4 p) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec4(\n        map(p+eps.xyyy)-map(p-eps.xyyy),\n        map(p+eps.yxyy)-map(p-eps.yxyy),\n        map(p+eps.yyxy)-map(p-eps.yyxy),\n        map(p+eps.yyyx)-map(p-eps.yyyx)));\n}\n\nvec4 shade(vec4 p, vec4 d, vec4 objnorm, float depth) {\n    vec4 sun = normalize(vec4(-1.0));\n    vec4 reflectnorm = reflect(d,objnorm);\n    vec4 color = objnorm*0.5+0.5;\n    vec4 fragColor = vec4(color*max(0.4,0.8*dot(objnorm,sun)));\n    fragColor /= depth*depth*0.01+1.0;\n    fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*3.0/depth/depth);\n    return clamp(fragColor,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n\t\n    float time = iTime*0.5;\n    \n    vec4 pos4d = vec4(0,0,time+sin(time*pi)/pi,0).wxyz;\n    vec4 dir4d = normalize(vec4(uv,1,0));\n    //dir4d.xy *= rot(iTime*0.1);\n    //dir4d.yz *= rot(iTime*0.1);\n    //dir4d.zw *= rot(iTime*0.1);\n    //dir4d.wx *= rot(iTime*0.1);\n    \n    float dist = 0.0;\n    bool hit = false;\n    \n    float reflections = 1.0;\n    float colorlength = 0.0;\n    float len;\n    for (int i = 0; i < 100; i++) {\n        len = map(pos4d);\n        if (abs(len) < 0.01) {\n            hit = true;\n            /*vec4 normal = findnormal(pos4d,len);\n        \tfragColor += shade(pos4d,dir4d, normal,dist)*reflections;\n            dir4d = reflect(dir4d,normal);\n            pos4d += dir4d*0.1;\n            colorlength += reflections;\n            if (reflections < 0.5) break;\n            reflections *= 0.5;*/\n            \n            break;\n        }\n        pos4d += dir4d*abs(len);\n        dist += abs(len);\n    }\n    fragColor /= colorlength;\n    if (hit)\n    {\n        /*\n        fragColor = (mod(pos4d,3.0)-1.5);\n        /*\n        vec4 sun = normalize(vec4(-1.0));\n        vec4 objnorm = findnormal(pos4d);\n        vec4 reflectnorm = reflect(dir4d,objnorm);\n        fragColor = objnorm*0.5+0.5;\n        fragColor = vec4(fragColor*max(0.6,dot(objnorm,sun)));\n        */\n        fragColor = shade(pos4d,dir4d, findnormal(pos4d,len), dist);\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}