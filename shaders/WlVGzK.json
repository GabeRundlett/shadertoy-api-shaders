{
    "Shader": {
        "info": {
            "date": "1579375693",
            "description": "This shader dynamically calculates, and shows the intensity and field lines of two positive charges, moving apart.\nBy clicking and holding somewhere, a negative charge can be inserted at that point.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlVGzK",
            "likes": 7,
            "name": "Electric field lines interactive",
            "published": 3,
            "tags": [
                "2d",
                "interactive",
                "field",
                "physics",
                "vectorfield",
                "equipotential"
            ],
            "usePreview": 0,
            "username": "frhun",
            "viewed": 625
        },
        "renderpass": [
            {
                "code": "vec3 colorGradiantBlackRedWhite( in float val ){ // generate color gradient from black over red and yellow to white\n    vec3 col;\n    col.r = val * 1.5;\n    col.g = (clamp(val, 0.33, 1.) - 0.33) * 1.5;\n    col.b = (clamp(val, 0.66, 1.) - 0.66) * 3.0;\n    return col;\n}\n\nvec2 grad1(in float dist, in vec2 uv){ //calculate field gradient, only for the two positive charges\n    return vec2(\n        ((dist-uv.x)/sqrt(pow(pow(dist - uv.x, 2.0) + pow(uv.y, 2.0), 3.0))) - ((dist+uv.x)/sqrt(pow(pow(dist + uv.x, 2.0) + pow(uv.y, 2.0), 3.0))),\n        (- (uv.y)/sqrt(pow(pow(dist - uv.x, 2.0) + pow(uv.y, 2.0), 3.0))) - ((uv.y)/sqrt(pow(pow(dist + uv.x, 2.0) + pow(uv.y, 2.0), 3.0))));\n}\n\nvec2 grad2(in float dist, in vec2 pos3, in vec2 uv){ //calculate field gradient, including user movable negative charge\n    return vec2(\n    \t((uv.x-pos3.x)/pow(pow(uv.x-pos3.x, 2.0) + pow(uv.y-pos3.y, 2.0), 1.5))\n        -((uv.x-dist)/pow(pow(uv.x-dist, 2.0) + pow(uv.y, 2.0), 1.5))\n        -((uv.x+dist)/pow(pow(uv.x+dist, 2.0) + pow(uv.y, 2.0), 1.5)) ,\n        \n        ((uv.y-pos3.y)/pow(pow(uv.x-pos3.x, 2.0) + pow(uv.y-pos3.y, 2.0), 1.5))\n        -((uv.y)/pow(pow(uv.x-dist, 2.0) + pow(uv.y, 2.0), 1.5))\n        -((uv.y)/pow(pow(uv.x+dist, 2.0) + pow(uv.y, 2.0), 1.5))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); //make square coordinates with 0,0 in center\n    uv *= 2.0;\n    \n    float dist = sin(iTime/10.0 * 3.14); //current distance of the charges from center\n    \n    vec2 e1coord = vec2(-dist,0);\n    vec2 e2coord = vec2(dist,0);\n    vec2 e3coord = (iMouse.xy * 2.0 - iResolution.xy)/min(iResolution.x, iResolution.y); //get coordinates of user movable negative charge\n    e3coord *= 2.0;\n    \n    float e1 = 1.0/length(uv-e1coord);\n    float e2 = 1.0/length(uv-e2coord);\n    float e3 = 1.0/length(uv-e3coord);\n    \n    float e = e1 + e2 - (iMouse.z > 0.0 ? e3 : 0.0);\n    \n    bool eneg = e < 0.0;\n    \n    bool fieldLines = false; //is this point on a field line, originating with a target angle\n    vec2 currPos = uv;\n    if(!(min(length(e1coord - currPos), length(e2coord - currPos)) < 0.1\n            || (iMouse.z > 0.0 ? length(e3coord - currPos) < 0.1 : false))) //only try iteration when far enough from charge\n    for(int i = 200; i > 0; i--){ \t\t\t\t\t\t\t\t\t\t\t//iteration to find if point is on path of field line\n        vec2 grad = (iMouse.z > 0.0 ? grad2(dist, e3coord, currPos) : grad1(dist, currPos));\n        if(\n            min(length(e1coord - currPos), length(e2coord - currPos)) < 0.1\t//check if iteration came close to charge\n            || (iMouse.z > 0.0 ? length(e3coord - currPos) < 0.1 : false)\t//optionally check for interactive charge\n        ){\t\t\t\t\t\t\t\t\t\t\t// â†“ uncomment for \"rotating\" field lines\n        \tfloat gradAngle = mod(atan(grad.y/grad.x) + iTime/2.0, 3.14159 / 4.0);\n            if(gradAngle < max(abs(e), 1.0)/50.0) //expect more precision in target start angle; make field lines roughly same width\n            \tfieldLines = true;\n            break;\n        }\n        \tcurrPos += (grad / (length(grad) * 10.0)) * (min(1.0/length(grad), 1.0));\n    }\n    \n    \n    //combine field intensity, and show individual gradient components (red = -log(x of grad(E)); green = -log(y of grad(E))\n    /*\n\tvec2 grad = (iMouse.z > 0.0 ? grad2(dist, e3coord, uv) : grad1(dist, uv));\n\tvec3 col = mix(\n                \tclamp(colorGradiantBlackRedWhite(e/10.0), 0.0, 1.0),\n                \tclamp(vec3(-log(grad), -(-log(grad)).x), 0.0, 1.0),\n                    0.5\n                );*/\n    \n    //only show the field, repeating on equipotential lines\n    vec3 col = clamp(colorGradiantBlackRedWhite(mod(e, 1.0)), 0.0, 1.0);\n    \n    if(fieldLines){\n        if(eneg) // make field lines black in negative areas\n            col = vec3(0.0, 0.0, 0.0);\n        else\n        \tcol = vec3(1.0, 1.0, 1.0);\n    }\n    \n    //add blue for negative field\n    //if(eneg)\n    //    col.z = 1.0;\n\t\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}