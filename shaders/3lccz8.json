{
    "Shader": {
        "info": {
            "date": "1608842653",
            "description": "Ray Tracing in One Weekend implementation\nbased on Peter Shirley's course on raytracing, modified to function in GLSL for shadertoy\nand a couple of personal changes made\nhttps://raytracing.github.io\n\n",
            "flags": 0,
            "hasliked": 0,
            "id": "3lccz8",
            "likes": 0,
            "name": "idw_RTIOW",
            "published": 3,
            "tags": [
                "raytracing"
            ],
            "usePreview": 0,
            "username": "ivandewolf",
            "viewed": 356
        },
        "renderpass": [
            {
                "code": "\n// ---------- STRUCTS ----------------\n\nstruct camera {\n  vec3 origin;\n  vec3 lower_left_corner;\n  vec3 horizontal;\n  vec3 vertical;\n  vec3 u, v, w;\n  float lens_radius;\n};\n\nstruct ray\n{\n  vec3 origin;\n  vec3 dir;\n};\n\n// contains a combination of all possible\nstruct material_texture {\n  int type;\n  vec3 albedoA;\n  vec3 albedoB;\n  float checkerboard_freq;\n  float metal_fuzz;\n  float dialectric_IoR;\n};\n\nstruct hit_record {\n    vec3 p;\n    vec3 normal;\n    material_texture mat;\n    float t;\n    bool front_face;\n};\n\nstruct sphere {\n  vec3 cen;\n  float rad;\n  material_texture mat;\n};\n\n// ---------- rtweekend.h ---------------\n\n#define PI 3.1415926535897932384626433832795\n\n// Hash functions by Nimitz\n// copied from \n// https://www.shadertoy.com/view/llVcDz\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n// thank you, reinder and iq\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n & (0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_unit_vector()\n{\n  return normalize(random_in_unit_sphere(g_seed));\n}\n\nvec3 random_in_unit_disk() {\n    while (true) {\n        vec3 p = vec3(hash2(g_seed)-vec2(.5), 0.0);\n        if (dot(p,p) >= 1.0) continue;\n        return p;\n    }\n}\n\n//----------- camera.h ------------------\ncamera cameraCreator(vec3 orig, vec3 lookat, vec3 up, float vfov, float aspect_ratio, float aperture, float focus_dist) {\n    camera outCam;\n    outCam.origin = orig;\n    float theta = radians(vfov);\n    float h = tan(theta/2.0);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n\n    vec3 w = normalize(orig - lookat);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n\n    outCam.origin = orig;\n    outCam.horizontal = focus_dist * viewport_width * u;\n    outCam.vertical = focus_dist * viewport_height * v;\n    outCam.lower_left_corner = orig - outCam.horizontal/2.0 - outCam.vertical/2.0 - focus_dist * w;\n    outCam.lens_radius = aperture / 2.0;\n    outCam.u = u;\n    outCam.v = v;\n    outCam.w = w;\n    return outCam;\n}\n\nray get_ray(camera cam, float s, float t) {\n    vec3 rd = cam.lens_radius * random_in_unit_disk();\n    vec3 offset = cam.u * rd[0] + cam.v * rd[1];\n\n    return ray(\n        cam.origin + offset,\n        cam.lower_left_corner + s*cam.horizontal + t*cam.vertical - cam.origin - offset);\n}\n\n// ---------------- ray.h -----------------------\n\nvec3 at(ray r, float t) {\n  return r.origin + (t*r.dir);\n}\n\n// ---------------- sphere.h ---------------------\n\nbool hit_sphere(sphere sph, ray r, float t_min, float t_max, out hit_record rec) {\n    vec3 oc = r.origin - sph.cen;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc,oc) - (sph.rad*sph.rad);\n    float discriminant = (half_b*half_b) - (a*c);\n\n    if (discriminant < 0.0) return false;\n    float sqrtd = sqrt(discriminant);\n    \n    float root = (-half_b - sqrtd) / a;\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root)\n            return false;\n    }\n\n    rec.t = root;\n    rec.p = at(r, rec.t);\n    rec.normal = (rec.p - sph.cen) / sph.rad;\n    rec.mat = sph.mat;\n    rec.front_face = dot(r.dir, rec.normal) < 0.0;\n    if(!rec.front_face) rec.normal = -rec.normal;\n    return (discriminant >= 0.);\n}\n\n\n//------------- material.h -------------------\n\n// this is kinda from the second book, a checkerboard-ish\nvec3 textureColor(hit_record rec)\n{\n    vec3 color = rec.mat.albedoA;\n    if(rec.mat.type != 2) return color;// type 2 is checkered.... \n    vec3 scaled = rec.p*rec.mat.checkerboard_freq;\n    float val = sin(scaled.x)*sin(scaled.y)*sin(scaled.z);\n    if(val > -0.01) color = rec.mat.albedoB;\n    return color;\n}\n\nbool lambertian_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 scatter_direction = (rec.normal*1.00001) + random_unit_vector();\n    r = ray(rec.p, scatter_direction);\n    attenuation *= textureColor(rec);\n    return true;\n}\n\nbool metal_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    vec3 reflected = reflect(normalize(r.dir), rec.normal);\n    r = ray(rec.p, reflected + rec.mat.metal_fuzz*random_in_unit_sphere(g_seed));\n    attenuation *= rec.mat.albedoA;\n    return (dot(r.dir, rec.normal) > 0.0);\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\n\n\nbool dialectric_scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    attenuation *= rec.mat.albedoA;//vec3(1.0, 1.0, 1.0);\n    float refraction_ratio = rec.front_face ? (1.0/rec.mat.dialectric_IoR) : rec.mat.dialectric_IoR;\n\n    vec3 unit_direction = normalize(r.dir);\n    float cos_theta = min(dot(-unit_direction, rec.normal), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n\n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    vec3 direction;\n    float rnd = hash1(g_seed);\n    if (cannot_refract || reflectance(cos_theta, refraction_ratio) > rnd)\n        direction = reflect(unit_direction, rec.normal);\n    else\n        direction = refract(unit_direction, rec.normal, refraction_ratio);\n\n    r = ray(rec.p, direction);\n    return true;\n}\n\nbool scatter(inout ray r, hit_record rec, inout vec3 attenuation)\n{\n    if(rec.mat.type == 1) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 2) \n        return lambertian_scatter(r, rec, attenuation);\n    if(rec.mat.type == 3) \n        return metal_scatter(r, rec, attenuation);\n    if(rec.mat.type == 4) \n        return dialectric_scatter(r, rec, attenuation);\n}\n\n// ------------- httable_list.h and world --------------\n\n#define NPRIMS 20\n\nvoid primList(out sphere sphList[NPRIMS], int seedOffset)\n{\n    int i = -1;\n    for(i = 0; i < NPRIMS-4; ++i){\n        float iseed = float(i+seedOffset);\n        vec2 randLoc = (hash2(iseed)-vec2(.5))*10.0;\n        float switchVal = hash1(iseed);\n         material_texture randomMat;\n        if(switchVal<.3)\n            randomMat = material_texture(1, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        else if(switchVal<.6)\n            randomMat = material_texture(3, hash3(iseed), vec3(0), 1.0, hash1(iseed)*.25, 1.5);\n        else\n            randomMat = material_texture(4, hash3(iseed), vec3(0), 1.0, 0.0, 1.5);\n        sphList[i+0] = sphere(vec3(randLoc.y,-.6,randLoc.x),.4, randomMat);\n        \n    }\n\n    material_texture matr0 = material_texture(3, vec3(1,.06,.06), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+0] = sphere(vec3(-2.1,0,1),1.0, matr0);\n\n    material_texture matr1 = material_texture(4, vec3(.6,1,.6), vec3(1,.4,1), 1.0, 0.0, 1.5);\n    sphList[i+1] = sphere(vec3(0,0,0),1.0, matr1);\n\n    material_texture matr2 = material_texture(2, vec3(.6,.6,1), vec3(10,8,1), 4.0, 0.0, 1.5);\n    sphList[i+2] = sphere(vec3(2.1,0,.5),1.0, matr2);\n\n    material_texture matr3 = material_texture(2, vec3(0.2, 0.3, 0.1), vec3(0.9, 0.9, 0.9), 10.0, 0.0, 0.0);\n    sphList[i+3] = sphere(vec3(0,-100.9,0),100.0, matr3);\n}\n\nbool hittable_list_hit(ray r, float t_min, float t_max, out hit_record rec, sphere sphList[NPRIMS]) {\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n\n    for (int i = 0; i < sphList.length(); ++i){\n        if(hit_sphere(sphList[i], r, t_min, closest_so_far, temp_rec)){\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    return hit_anything;\n}\n// ------------------ hello world ------------------\n\nvec3 ray_color(in ray r, sphere sphList[NPRIMS]) {\n  hit_record rec;\n  vec3 albedoAccum = vec3(1.);\n  for(int i = 0; i < 8; ++i){\n      if(!hittable_list_hit(r, 0.00001, 1000.0, rec, sphList)){\n        vec3 unit_direction = normalize(r.dir);\n        float t = 0.5*(unit_direction.y + 1.0);\n        return (1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0) * albedoAccum;\n      }\n      scatter(r, rec, albedoAccum);\n  }\n  return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // initialize the hash seed\n  g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n  float aspect = iResolution.x/iResolution.y;\n  vec2 off = vec2(-6,3) - abs(iMouse.xy)/iResolution.xy*vec2(-12.0, 4.0);\n  float aperture = .4;\n  float focus_dist = 7.0;\n  camera cam = cameraCreator(vec3(off,-6), vec3(0), vec3(0,1,0), 30.0, aspect, aperture, focus_dist);\n  vec2 uv = fragCoord.xy / iResolution.xy;  \n  sphere sphList[NPRIMS];\n  primList(sphList, int(iTime/1.0));\n  vec3 Caccum = vec3(0);\n  int nSamples = 16;\n  for(int i = 0; i < nSamples; ++i){\n      vec2 sloc = 2.0*(hash2(g_seed) / iResolution.xy)+uv;\n      ray rLoop = get_ray(cam, sloc.x, sloc.y);\n      Caccum += ray_color(rLoop, sphList);\n  }\n\n  fragColor = vec4(Caccum / float(nSamples), 1.0);\n\n \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}