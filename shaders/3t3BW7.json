{
    "Shader": {
        "info": {
            "date": "1612832352",
            "description": "Experimenting with ray-tracing for a triangularized mesh. This shader is a work-in-progress. ",
            "flags": 48,
            "hasliked": 0,
            "id": "3t3BW7",
            "likes": 2,
            "name": "Triangularized Mesh Raytracer",
            "published": 3,
            "tags": [
                "rtx"
            ],
            "usePreview": 0,
            "username": "jstrom2002",
            "viewed": 566
        },
        "renderpass": [
            {
                "code": "//POST-PROCESSING PASS\n// Luminance factor for tone mapping\nconst vec3 Luminance = vec3(0.2126, 0.7152, 0.0722);\n\n\n// FXAA code from Morgan McGuire's 'Ray March Framework': https://www.shadertoy.com/view/Ms2SWw\n#define RES iResolution.xy\nvec3 tex(vec2 p) {\n    return texture(iChannel1, p).rgb; \n}\nvec3 fxaa(vec2 p) \n{\n\tconst float FXAA_SPAN_MAX   = 24.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 0.0;//1.0 / 128.0;\n\n    // 1st stage - Find edge\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);//vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    // 2nd stage - Blur\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);    \n    vec4 out_col = vec4(0,0,0,1);\n    \n    if(FXAA_ON != 0)\n        out_col.rgb = fxaa(uv);\n    else\n        out_col.rgb = texture(iChannel1, uv).rgb;\n    \n   // Apply Reinhard tonemap as necessary.\n   if(TONEMAP_RESULTS != 0)   \n       out_col.rgb = pow(out_col.rgb * 1.0 / \n           (1.0 + dot(out_col.rgb, Luminance)), vec3(1.0 / 2.2));       \n   \n   if(out_col.rgb != vec3(0.0))\n       fragColor = vec4(out_col.rgb,1.0);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//KEYBOARD/MOUSE INPUT-HANDLING PASS\n\n// Code from: https://www.shadertoy.com/view/4lVXRm\n// Created by genis sole - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(iChannel1, ivec2(P), 0)\n#define key(K)  step(0.5, texelFetch(iChannel0, ivec2(K, 0), 0).x)\n\nconst ivec2 MEMORY_BOUNDARY = ivec2(4, 3);\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\nconst ivec2 PMOUSE = ivec2(2, 1);\nconst ivec2 TARGET = ivec2(0, 2);\nconst ivec2 RESOLUTION = ivec2(3, 1);\n\n// Keyboard constants definition\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\n\n#define KEY_BINDINGS(FORWARD, BACKWARD, RIGHT, LEFT) const int KEY_BIND_FORWARD = FORWARD; const int KEY_BIND_BACKWARD = BACKWARD; const int KEY_BIND_RIGHT = RIGHT; const int KEY_BIND_LEFT = LEFT;\n#define ARROWS  KEY_BINDINGS(KEY_UP, KEY_DOWN, KEY_RIGHT, KEY_LEFT)\n#define WASD  KEY_BINDINGS(KEY_W, KEY_S, KEY_D, KEY_A)\n#define ESDF  KEY_BINDINGS(KEY_E, KEY_D, KEY_F, KEY_S)\n\n#define INPUT_METHOD  ARROWS\nvec2 KeyboardInput() {\n    INPUT_METHOD\n    \n\tvec2 i = vec2(key(KEY_BIND_RIGHT)   - key(KEY_BIND_LEFT), \n                  key(KEY_BIND_FORWARD) - key(KEY_BIND_BACKWARD));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*inversesqrt(2.0));\n}\n\nvec3 CameraDirInput(vec2 vm) {\n    vec2 m = vm/iResolution.x;\n    \n    return CameraRotation(m) * vec3(KeyboardInput(), 0.0).xzy;\n}\n\n\nvoid Collision(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, min(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    if (any(greaterThan(ivec2(fragCoord), MEMORY_BOUNDARY))) return;\n    \n    fragColor = load(fragCoord);\n    \n    vec2 resolution = load(RESOLUTION).xy;\n    store(RESOLUTION, vec4(iResolution.xy, 0.0, 0.0));\n    \n    if (iTime == 0.0 || iFrame == 0 || any(notEqual(iResolution.xy, resolution))) {\n        store(POSITION, vec4(0.0, 0.0, 0.0, 0.0));\n        store(TARGET, vec4(0.0, 0.0, -1.0, 0.0));\n        store(VMOUSE, vec4(0.0));\n        store(PMOUSE, vec4(0.0));\n        \n        return;\n    }\n\n    vec3 target      = load(TARGET).xyz;   \n    vec3 position    = load(POSITION).xyz;\n    vec2 pm          = load(PMOUSE).xy;\n    vec3 vm          = load(VMOUSE).xyz;\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy) * iTimeDelta * 5.0;\n    \n    Collision(ptarget, target);\n    \n    position += (target - position) * iTimeDelta * 5.0;      \n    \n    store(TARGET, vec4(target, 0.0));\n    store(POSITION, vec4(position, 0.0));\n    \n\tif (iMouse.z > 0.0) {\n    \tstore(VMOUSE, vec4(pm + (abs(iMouse.zw) - iMouse.xy), 1.0, 0.0));\n\t}\n    else if (vm.z != 0.0) {\n    \tstore(PMOUSE, vec4(vm.xy, 0.0, 0.0));\n    }\n\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Global definitions\n#define BOUNCES 2\n#define BOUNCE_OFFSET 0.001\n#define BOUNCE_STRENGTH 0.2\n#define FXAA_ON 1\n#define INTERSECT_EPSILON 0.00001\n//#define INTERSECTION_METHOD_1\n#define JITTER_STRENGTH 0.000\n#define MAX_DISTANCE 99.9\n#define ROTATE_ON 0\n#define SAMPLES 1\n#define TONEMAP_RESULTS 0\n\n#define PI 3.1415926535897932384626433832795\n#define TWO_PI 6.283185307179586476925286766559\n\n\n// Triangularized Cornell box mesh data:\nconst int maxIndexVal = 20;\nvec3 vertices[maxIndexVal] = vec3[maxIndexVal](\nvec3(-10.0,10.0,10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(10.0,10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,-10.0,10.0),\nvec3(-10.0,-10.0,-10.0),\nvec3(-10.0,10.0,-10.0),\nvec3(-10.0,10.0,10.0),\nvec3(10.0,-10.0,-10.0),\nvec3(10.0,-10.0,10.0),\nvec3(10.0,10.0,10.0),\nvec3(10.0,10.0,-10.0)\n);\n\nvec2 uvs[maxIndexVal] = vec2[maxIndexVal](\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000),\nvec2(0.000000, 0.000000),\nvec2(0.000000, 1.000000),\nvec2(1.000000, 0.000000),\nvec2(1.000000, 1.000000)\n);\n\nvec3 normals[maxIndexVal] = vec3[maxIndexVal](\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000,-1.0000, 0.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 0.0000, 1.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 0.0000, 1.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3( 1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000),\nvec3(-1.0000, 0.0000, 0.0000)\n);\n\n// Mesh vertex data is aligned to use a single index for position/normal/uv values.\nconst int numIndices = 30;\nint indices[numIndices] = int[numIndices]\n(\n0,1,2,\n0,2,3,\n4,5,6,\n\n4,6,7,\n8,9,10,\n8,10,11,\n\n12,13,14,\n12,14,15,\n16,17,18,\n\n16,18,19\n);\n\n\n\n\n// For buffer A 'free camera':\nmat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);    \n    return rotY * rotX;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "//LIGHTING PASS -- WORK-IN-PROGRESS\n\n// Vars from 'Free Camera'\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 VMOUSE = ivec2(1, 1);\n#define load(P) texelFetch(iChannel2, ivec2(P), 0)\n\n\nmat4 RotateScaleTranslate( vec3 r, vec3 s, vec3 t )\n{\n    float a = sin(r.x); float b = cos(r.x); \n    float c = sin(r.y); float d = cos(r.y); \n    float e = sin(r.z); float f = cos(r.z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f*s.x,  d*e,          -c,      0.0,\n                 ac*f-b*e, ac*e+b*f*s.y, a*d,     0.0,\n                 bc*f+a*e, bc*e-a*f,     b*d*s.z, 0.0,\n                 t.x,      t.y,          t.z,     1.0 );\n}\nvec3 applyTransform(mat4 M, vec3 v)\n{\n    vec4 v_ = vec4(v, 1.0);\n    v_ = M * v_;\n    return v_.xyz / v_.w;\n}\n\nstruct Model\n{\n    vec3 position;\n    vec3 scale;\n    vec3 rotation;\n    \n    mat4 transform;   \n};\n\nstruct Camera\n{\n    vec3 position;\n    vec3 front;\n    vec3 up;\n    vec3 right;\n};\nCamera camera;\n\nstruct Light\n{\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n    float intensity;\n    int type;//enum: 0 = directional, 1 = point, 2 = spot.\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specular;\n    vec3 emissive;\n    float roughness;\n    float metalness;\n    float opacity;\n};\n\nstruct Scene\n{\n    // For now, array sizes are hardcoded for scene objects.\n    Model models[1];\n    int numModels;\n    \n    Material materials[3];\n    int numMaterials;\n    \n    Light lights[1]; \n    int numLights;\n};\nScene scene;\n\nstruct Ray\n{\n    vec3 o;//origin\n    vec3 d;//direction\n    float t;\n    float dist;//total distance ray has travelled\n    int bounce_number;\n};\n\nstruct Triangle \n{\n    vec3 v0,v1,v2;\n    int mtlidx;//material index.\n};\n\n//==================================================\n\nvoid update(inout Model m)\n{\n    m.transform = RotateScaleTranslate(m.rotation, m.scale, m.position);\n}\n\nvec2 barycenterToUV(vec3 bary, vec2 uv1, vec2 uv2, vec2 uv3){\n    return (bary.x * uv1) + (bary.y * uv2) + (bary.z * uv3);\n}\n\n\n// Generic function to test triangle intersection methods.\nbool IntersectTriangle(in Ray ray, in Triangle tri, out float hit, out vec3 barycentricCoord, out vec3 triangleNormal)\n{\n\n#ifdef INTERSECTION_METHOD_1\n    vec3 e0 = tri.v1 - tri.v0;\n    vec3 e1 = tri.v0 - tri.v2;    \n    triangleNormal = cross( e1, e0 );\n\n    // Check if the ray has hit the opposing face. \n    if (dot(ray.d, normalize(triangleNormal)) > 0.0) \n        return false;\n\n    vec3 e2 = ( tri.v0 - ray.o ) / dot( triangleNormal, ray.d );\n    vec3 i  = cross( ray.d, e2 );\n\n    barycentricCoord.y = dot( i, e1 );\n    barycentricCoord.z = dot( i, e0 );\n    barycentricCoord.x = 1.0 - (barycentricCoord.z + barycentricCoord.y);\n    hit = dot( triangleNormal, e2 );\n\n    return \n        (hit > INTERSECT_EPSILON)\n        && all(greaterThanEqual(barycentricCoord, vec3(0.0)));\n\n// ----------------------------------------------------------------\n\n#else\n    ray.o -= tri.v0; tri.v1 -= tri.v0; tri.v2 -= tri.v0; tri.v0 = vec3(0.0);\n    vec3 ba = tri.v1 - tri.v0, cb = tri.v2 - tri.v1, ac = tri.v0 - tri.v2;\n\n    // Intersect plane\n    vec3 n = cross(ba, -ac);\n    \n    // Check if the ray has hit the opposing face. \n    if (dot(ray.d, normalize(n)) > 0.0) \n        return false;\n    \n    float denom = dot(ray.d, n);\n    if (denom != 0.0) {\n        float t = -dot(ray.o, n) / denom;\n\n        // Triangle subareas for point in triangle test and computing barycoords\n        vec3 p = ray.o + ray.d * t;\n        vec3 pa = p - tri.v0, pb = p - tri.v1, pc = p - tri.v2;\n\n        float abc = length(n);\n        float u = length(cross(ba, pa)) / abc;\n        float v = length(cross(cb, pb)) / abc;\n        float w = length(cross(ac, pc)) / abc;\n\n        bool isHit = abs(u + v + w - 1.0) < 0.001;\n        if(isHit == true)\n        {\n            hit = t;\n            triangleNormal = n;\n            barycentricCoord = vec3(u,v,w);        \n            return true;\n        }\n    }\n#endif\n\n\n    return false;    \n}\n\n// Specular GGX code from: https://www.shadertoy.com/view/4tXXzM\nfloat G1V(float NdotV, float k)\n{\n\treturn 1.0/(NdotV*(1.0-k)+k);\n}\nfloat SpecGGX(vec3 N, vec3 V, vec3 L, float roughness, float F0 )\n{\n\tfloat SqrRoughness = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat NdotL = clamp(dot(N,L),0.0,1.0);\n\tfloat NdotV = clamp(dot(N,V),0.0,1.0);\n\tfloat NdotH = clamp(dot(N,H),0.0,1.0);\n\tfloat LdotH = clamp(dot(L,H),0.0,1.0);\n\n\t// Geom term\n\tfloat RoughnessPow4 = SqrRoughness*SqrRoughness;\n\tfloat denom = NdotH * NdotH *(RoughnessPow4-1.0) + 1.0;\n\tfloat D = RoughnessPow4/(PI * denom * denom);\n\n\t// Fresnel term \n\tfloat LdotH5 = 1.0-LdotH;\n    LdotH5 = LdotH5*LdotH5*LdotH5*LdotH5*LdotH5;\n\tfloat F = F0 + (1.0-F0)*(LdotH5);\n\n\t// Vis term \n\tfloat k = SqrRoughness/2.0;\n\tfloat Vis = G1V(NdotL,k)*G1V(NdotV,k);\n\n\tfloat specular = NdotL * D * F * Vis;\n    \n\treturn specular;\n}\nvec3 CalculateLighting(Ray ray, Material material, Light light,\n    vec3 pos, vec3 V, vec3 N, vec3 L, bool applySpec)\n{\n    // Fresnel\n    float NdotV = clamp(dot(N,V),0.0,1.0);\n\tNdotV = pow(1.0-NdotV, 5.0);//NOTE: Fresnel strength hardcoded to 5.0 here.\n\tfloat Fresnel = material.metalness + (1.0-material.metalness)*(NdotV);\n\n\t // Lambertian diffuse light w/ fresnel factor.\n\t vec3 diffuse_val = light.color * material.albedo \n         * dot(N, L) * (1.0 - Fresnel);\n\t \n\t // Specular term.\n\t float spec = SpecGGX(N,V,L,material.roughness,material.metalness);\n     if(!applySpec)\n         spec = 0.0;\n\t vec3 specular_val = material.specular * spec * light.color;\t\n\t \n\t // Attenutate/combine terms.\n     float attenuation = 1.0;\n     if(light.type != 0)\n     {\n         float light_dist = length(light.position-pos);\n         float light_falloff = 1.0 / pow(light_dist, 2.0);\n         float bounce_falloff = BOUNCE_STRENGTH / pow(float(ray.bounce_number + 1), 2.0);\n         attenuation = pow(light_falloff, 1.0) * bounce_falloff;\n     }\n\t return scene.lights[0].intensity * (diffuse_val + specular_val) * attenuation; \n}\n\n\nbool IntersectRayScene(inout Ray ray, out vec3 pass_col)\n{\n    // Setup variables for loop.\n    vec3 N, bary;\n    float t;\n    bool isHit = false;\n    int mtlidx = 0;      \n    mat4 M;\n    vec3 initial = ray.o;\n    Material material;\n    \n    for(int n = 0; n < SAMPLES; ++n)\n    {\n        vec3 sample_col = vec3(0.0);\n        ray.o = initial;\n        if(SAMPLES > 1)\n        {\n           // Add blue noise value and jitter in spherical offset pattern.\n           float theta = PI * float(n)/float(SAMPLES);\n           ray.o += JITTER_STRENGTH * vec3(\n               cos(theta) * sin(theta), \n               cos(theta), \n               sin(theta) * sin(theta)) *\n               texture(iChannel1, vec2(iTimeDelta * iTime)).rgb;\n           ray.d = normalize(ray.d);\n        }\n        \n        Light currLight = scene.lights[0];\n        \n        for(int bnc = 0; bnc < BOUNCES; ++bnc)\n        {        \n            if(ray.dist >= MAX_DISTANCE)\n                break;\n            \n            for(int m = 0; m < scene.numModels; ++m)\n            {\n                M = scene.models[m].transform;\n\n                // Iterate through scene triangles and check for a ray hit.\n                for(int i=0; i<numIndices; i+=3)\n                {\n                    // Get mesh triangle vertices.\n                    Triangle tri;\n                    tri.v0 = vertices[indices[i+0]];\n                    tri.v1 = vertices[indices[i+1]];\n                    tri.v2 = vertices[indices[i+2]];\n\n                    // Transform triangle vertices.\n                    tri.v0 = applyTransform(M, tri.v0);\n                    tri.v1 = applyTransform(M, tri.v1);\n                    tri.v2 = applyTransform(M, tri.v2);\n\n                    // Hardcoded material indexing\n                    mtlidx = 0;\n                    if(i >= 18 && i < 24)\n                        mtlidx = 1;\n                    else if(i >= 24 && i < 30)\n                        mtlidx = 2;\n                    else if(i >= 30)\n                        mtlidx = 0;\n                    material = scene.materials[mtlidx];\n\n                    // Use mesh normal.\n\n                    vec3 dummy_n;\n                    isHit = bool(IntersectTriangle(ray,tri,t,bary,dummy_n));\n                    //N = normalize(dummy_n);\n                    N = normalize(bary.x * normals[indices[i+0]] + bary.y * normals[indices[i+1]] + bary.z * normals[indices[i+2]]);\n\n                    if(isHit)\n                    {\t  \n                        // Get mesh triangle texture coordinates.\n                        vec2 uv1 = uvs[indices[i+0]];\n                        vec2 uv2 = uvs[indices[i+1]];\n                        vec2 uv3 = uvs[indices[i+2]];\n                        vec3 texCoord = vec3(barycenterToUV(bary,uv1,uv2,uv3), 1.0);\n\n                        // Get intersection coordinate of shared ray/triangle point.\n                        vec3 ray_coord = ray.o + ray.d * t;\t       \n                        vec3 L = vec3(0.0);\n                        if(currLight.type == 0)\n                            L = normalize(-currLight.direction);\n                        else\n                            L = normalize(currLight.position - ray_coord);\n                        vec3 V = normalize(camera.position - ray_coord);\t\t\n                        sample_col.rgb += CalculateLighting(\n                            ray, material, currLight, ray_coord, \n                            V, N, L, ray.bounce_number == 0);\n                        sample_col.rgb += material.emissive;\n\n                        // Save new reflected light bounce origin and direction and continue.\n                        ray.d = normalize(reflect(ray.d, N));\n                        ray.o = ray_coord + ray.d * BOUNCE_OFFSET;//add slight offset to new origin.\n                        ray.t = t;\n                        ray.dist += t;\n                        ray.bounce_number++;\n\n                        break;\n                    }                                                               \n                }                                                   \n            }\n            \n            if(bnc == 0 && isHit == false)\n            {\n                pass_col.rgb = texture(iChannel0, ray.d * vec3(1,-1,1)).rgb;\n                bnc = BOUNCES;\n                n = SAMPLES;\n            }\n            \n        }       \n        \n        pass_col += sample_col;\n    }\n    \n    pass_col /= float(SAMPLES);\n        \n    return isHit;\n}\n\nCamera InitCamera(in vec2 uv) \n{\n    Camera cam;\n    cam.position = load(POSITION).xyz;\n    \n    vec2 m = load(VMOUSE).xy/iResolution.x;    \n    float a = 1.0/max(iResolution.x, iResolution.y);\n    cam.front = normalize(vec3((uv - iResolution.xy*0.5)*a, 0.5));    \n    cam.front = CameraRotation(m) * cam.front;\n    \n    cam.up = vec3(0,1,0);\n    cam.right = cross(cam.front, cam.up);\n    \n    return cam;\n}\n\nRay InitRay(in Camera cam, out vec3 ray_initial_dir, vec2 uv)\n{\n    Ray ray;\n    ray.dist = 0.0;\n    ray.bounce_number = 0;\n    \n    // Setup ray direction\n    float angle = tan(0.5*45.0);//fov angle\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    float x = uv.x * aspect * angle;//aspect correction\n    float y = uv.y * angle;\n    ray.o = cam.position;\n    ray_initial_dir = normalize(x * cam.right + uv.y * -cam.up + cam.front);\n    ray.d = ray_initial_dir;\n    \n    return ray;\n}\n\nScene InitScene()\n{\n    Scene scene;    \n    Material material;\n    Model model;\n    Light light;\n    \n    // White.\n    material.albedo = vec3(0.75);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0, 0.0, 0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[0] = material;\n    \n    // Green.\n    material.albedo = vec3(0.0, 0.35, 0.0);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[1] = material;\n    \n    // Red.\n    material.albedo = vec3(0.65, 0.0, 0.0);\n    material.specular = vec3(1.0);\n    material.emissive = vec3(0.0);\n    material.roughness = 1.0;\n    material.metalness = 0.0;\n    material.opacity = 1.0;\n    scene.materials[2] = material;\n    \n    scene.numMaterials = 3;\n    \n    // Add lights.\n    light.position =  vec3(0.0, -5.0, 50.0);\n    light.direction = vec3(0.0, -0.8, 0.2);\n    light.color =     vec3(1.0, 1.0, 0.90);\n    light.intensity = 6.0e3;\n    light.type = 1;//0 = directional, 1 = point light, 2 = spot light.\n    scene.lights[0] = light;\n    \n    scene.numLights = 1;\n    \n    // Add models.\n    model.position = vec3(0.0,0.0,40.0);\n    model.scale = vec3(2.0,2.0,2.5);\n    model.rotation = vec3(0.0);\n    update(model);\n    scene.models[0] = model;\n    \n    scene.numModels = 1;\n    \n    return scene;\n}\n\nvoid rotateObjects()\n{\n    // Per-frame rotation for models.\n    for(int i=0 ;i<scene.numModels; ++i)\n    {\n        if(ROTATE_ON > 0)  \n        {\n            scene.models[i].rotation = vec3(iTime);\n            update(scene.models[i]);\n        }\n    }\n    \n    // Per-frame rotation for light.\n    float tmr = iTime * 0.35;\n    int typ = scene.lights[0].type;\n    if(typ == 0)\n    {\n        scene.lights[0].direction = \n            normalize(scene.lights[0].direction + 1.5 * TWO_PI \n            * vec3(cos(tmr), sin(tmr), cos(tmr)*sin(iTime)));\n    }\n    else\n    {\n        scene.lights[0].position += 1.5 * TWO_PI * vec3(\n            cos(tmr), \n            sin(tmr), \n            cos(tmr)*sin(iTime)\n        );\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;    \n        \n    // Init global variables. \n    camera = InitCamera(uv);\n    scene = InitScene();    \n    vec3 ray_initial_dir;\n    Ray ray = InitRay(camera, ray_initial_dir, uv);\n    vec3 out_col = vec3(0.0);\n    \n    rotateObjects();\n      \n    // Gather light from ray.\n    IntersectRayScene(ray, out_col);\n   \n    fragColor = vec4(out_col,1.0);   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}