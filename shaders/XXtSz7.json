{
    "Shader": {
        "info": {
            "date": "1718822367",
            "description": "Colorized Mandelbrot",
            "flags": 48,
            "hasliked": 0,
            "id": "XXtSz7",
            "likes": 4,
            "name": "Mandelbrot Striped",
            "published": 3,
            "tags": [
                "mandelbrot"
            ],
            "usePreview": 0,
            "username": "kosalos",
            "viewed": 95
        },
        "renderpass": [
            {
                "code": "/*\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<E>   : animate just focused value (A,Z affect amount)\n<X>   : toggle animation\n<Spc> : reset\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n \nRadial Symmetry\n   When value is zero (set to lowest value), the image renders as normal.\n   When active (non-zero, specifying pie wedge size in radians),\n   a pie slice shaped region of the image is repeated to form a mandala.\n\nfoam style:             https://fractalforums.org/programming/11/mandelbrot-foam/2360\nvariations:             https://fractalforums.org/share-a-fractal/22/a-few-mandelbrot-variations-i-discovered-stay-tuned-for-more/216\nColoring:               https://www.shadertoy.com/view/NdXBzr\nDistance functions:     https://iquilezles.org/articles/distfunctions2d/\nText display:           https://www.shadertoy.com/view/mdsSD7\nKeyboard:               https://www.shadertoy.com/view/lsXGzf\nJavascript rendition:   https://openprocessing.org/sketch/1987170\n\n*/\n\nvec3 data[PDATA_ADDR_COUNT]; // copy of storage data for animation and drawing\n\n#define qpanx           data[0].x\n#define qpany           data[0].y\n#define qzoom           data[0].z\n#define qvariation      data[1].x\n#define qparam1         data[1].y\n#define qparam2         data[1].z\n#define qparam3         data[2].x\n#define qparam4         data[2].y\n#define qskip           data[2].z\n#define qpower          data[3].x\n#define qinitpower      data[3].y\n#define qstripedensity  data[3].z\n#define qescaperadius   data[4].x\n#define qmultiplier     data[4].y\n#define qbright         data[4].z\n#define qcontrast       data[5].x\n#define qcolorstyle     data[5].y\n#define qcolorr         data[5].z\n#define qcolorg         data[6].x\n#define qcolorb         data[6].y\n#define qavgstyle       data[6].z\n#define qavgp1          data[7].x\n#define qavgp2          data[7].y\n#define qp0active       data[7].z\n#define qp0posx         data[8].x\n#define qp0posy         data[8].y\n#define ql0active       data[8].z\n#define ql0posx         data[9].x\n#define ql0posy         data[9].y\n#define qlp0slope       data[9].z\n#define qradialangle    data[10].x\n\n#define focus           data[11].x\n#define displayCount    data[11].y\n#define animationEnable data[11].z\n\n// --------------------------------------------------------\n\nconst ivec2[] legends = ivec2[](\n    cP,ca,cn,cX,c0,c0,c0,c0,\n    cP,ca,cn,cY,c0,c0,c0,c0,\n    cZ,co,co,cm,c0,c0,c0,c0,\n    cE,cq,cu,ca,ct,ci,co,cn,\n    cP,ca,cr,ca,cm,c1,c0,c0,\n    cP,ca,cr,ca,cm,c2,c0,c0,    \n    cP,ca,cr,ca,cm,c3,c0,c0,\n    cP,ca,cr,ca,cm,c4,c0,c0,\n    cS,ck,ci,cp,c0,c0,c0,c0,\n    cP,co,cw,ce,cr,c0,c0,c0,\n    cI,cn,ci,ct,cP,cw,cr,c0,\n    cS,ct,cr,ci,cp,ce,c0,c0, \n    cE,cs,cc,cR,ca,cd,c0,c0,\n    cM,cu,cl,ct,c0,c0,c0,c0,\n    cB,cr,ci,cg,ch,ct,c0,c0,\n    cC,co,cn,ct,cr,ca,cs,ct,\n    cC,co,cl,cS,ct,cy,cl,ce,\n    cC,co,cl,co,cr,cR,c0,c0,\n    cC,co,cl,co,cr,cG,c0,c0,\n    cC,co,cl,co,cr,cB,c0,c0,\n    cA,cv,cg,cS,ct,cy,cl,ce,\n    cA,cv,cg,cP,c1,c0,c0,c0,\n    cA,cv,cg,cP,c2,c0,c0,c0,\n    cP,co,cr,cb,ci,ct,c0,c0,\n    cP,cO,cr,cb,cX,c0,c0,c0,\n    cP,cO,cr,cb,cY,c0,c0,c0,\n    cL,co,cr,cb,ci,ct,c0,c0,\n    cL,cO,cr,cb,cX,c0,c0,c0,\n    cL,cO,cr,cb,cY,c0,c0,c0,\n    cL,cO,cr,cb,cS,cl,cp,c0,\n    cR,ca,cd,ci,ca,cl,c0,c0);\n\nvoid displayData(inout vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > iResolution.x * 0.38) return; // no printing in that region\n    if(fragCoord.y < iResolution.y * 0.93) return;\n\n    Font f;\n    setFont(f,iChannelResolution[3].xy / vec2(16, 16),iChannelResolution[3].xy);\n\n    TextCursor t;\n    const vec2 charScale = vec2(30,30);\n    t.startPos = vec2(0, iResolution.y);\n    t.coord = ivec2(0.);\n    t.font = f;\n    t.color = vec4(1.);\n    t.charSize = charScale;\n    t.charSpace = vec2(0.7, 1) * charScale;\n    t.pageWidth = int(iResolution.x / t.charSize.x);\n    t.fragCoord = fragCoord;\n    \n    int ifocus = int(focus); \n    int index = ifocus / 3;\n    int field = ifocus % 3;\n\n    printInt(ifocus+1,t);\n    printChar(cSp,t);\n    \n    int legendIndex = ifocus * 8;\n    for(int i=0;i<8;++i) {\n        ivec2 chr = legends[legendIndex+i];\n        if(chr == c0) break;\n        printChar(chr,t);\n    }\n    \n    bool isInteger = pData[ifocus].delta == INTEGER || pData[ifocus].delta == SLOWINTEGER;\n    \n    printChar(cSp,t);\n    printFloat(data[index][field], t,isInteger ? 0 : 4);\n    drawText(t, iChannel3, fragColor);\n}\n\n// animation routines ----------------------------------------\n\nvoid cycleValue(int pDataIndex,inout float value, float deviation, float speed) {\n    float ratio = 1.0 + cos(iTime * speed);  // 0 ... 2\n    value = clamp(value-deviation + deviation * ratio, pData[pDataIndex].vmin, pData[pDataIndex].vmax);\n}\n\nvoid alterparams() {\n    float amt = 0.05;\n    \n    for(int i=9;i<16;++i) { \n        int index = i/3;\n        int field = i%3;\n        cycleValue(i,data[index][field],amt,0.1 + float(i) * 0.05);\n    }\n    for(int i=17;i<20;++i) { \n        int index = i/3;\n        int field = i%3;\n        cycleValue(i,data[index][field],amt,0.2 + float(i) * 0.05);\n    }\n}\n\nvoid animate() {\n    if(animationEnable == 0.) return;\n    alterparams();\n}\n\n// --------------------------------------------------------\n\nvec2 complexConjugate(vec2 v) { return vec2(v.x,-v.y); }\nvec2 complexAdd(vec2 v1, vec2 v2) { return vec2(v1.x + v2.x, v1.y + v2.y); }\nvec2 complexSub(vec2 v1, vec2 v2) { return vec2(v1.x - v2.x, v1.y - v2.y); }\nvec2 complexMul(vec2 v1, vec2 v2) { return vec2(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x); }\nvec2 complexFloatMul(vec2 v1, float amount) { return vec2(v1.x * amount, v1.y * amount); }\nvec2 csqr(vec2 z) { return vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y); }\n\nvec2 complexDiv(vec2 v1, vec2 v2) {\n    float rr = v2.x * v2.x + v2.y * v2.y; // radius squared\n    vec2 con = complexConjugate(v2);\n    \n    vec2 cn = vec2(con.x / rr, con.y / rr);\n    return complexMul(v1, cn);\n}\n\nvec2 complexPower(vec2 value, float power) {\n    float rr = value.x * value.x + value.y * value.y; // radius squared\n    if(rr == 0.0) return vec2(0.0001,0.0001);\n    \n    float p1 = pow(rr, power / 2.0);\n    float arg = atan(value.y, value.x);\n    return vec2(cos(power * arg) * p1, sin(power * arg) * p1);\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)  // get copy of storage data\n        data[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n    animate();                           // optionally alter some of the values\n    \n    float zoomY = qzoom * iResolution.y / iResolution.x; // square aspect ratio\n    vec2 pixel = fragCoord / iResolution.xy;  // 0...1\n    \n\tvec2 q,w,z = vec2(0.);\n\tint count = 0;\n\tint iSkip = int(qskip);\n\tfloat z2,avg = 0.0;\n\tfloat lastAdded = 0.0;\n\tfloat minDist = 999.9;\n\tvec2 p1,p2,f3 = vec2(qparam1,qparam2);\n\tbool evenOdd = true;\n\t\n    // apply radial symmetry? ---------\n    if(qradialangle > 0.01) { // 0 = don't apply\n        float dx = pixel.x - 0.5;\n        float dy = pixel.y - 0.5;\n        float angle = abs(atan(dy,dx));\n\n        float dRatio = 0.01 + qradialangle;\n        for(int test=0;test<100;++test) {\n        if(angle <= dRatio) break;\n        angle -= dRatio;\n        }\n        if(angle > dRatio * 0.5) angle = dRatio - angle;\n\n        float dist = sqrt(dx * dx + dy * dy);\n        pixel.x = 0.5 + cos(angle) * dist;\n        pixel.y = 0.5 + sin(angle) * dist;\n    }\n\n\tvec2 cc = vec2(qpanx + (pixel.x  - 0.5) * qzoom,qpany + (pixel.y - 0.5) * zoomY);\n\t\n\tcc = complexPower(cc,qinitpower);\n\t\n    int variation = int(qvariation);\n    \n\tif(variation > 0) {  \n\t\tz = vec2(1.0/qpower,0.);\n\t\tq = vec2(qparam1, 0.);\n\t\tw = vec2(qparam2, 0.);\n\t}\n\n\tfor(int i=0;i<50;i++) {\n\t\n\t\t// C alter ====================================================\n\t\tif(i > 5) {   // let orbit settle down before alterations\n\t\t\tp1 = complexSub(z,cc);\n\t\t\tp1 = complexPower(p1,qparam3);\n\t\t\tp2 = csqr(p1);\n\t\t\tp2 = complexFloatMul(p2,qparam4);\n\t\t\tcc = complexAdd(cc,p2);\n\t\t}\n\t\t\n\t\t// ============================================================\n\t\tif(variation == 0) { // original Mandelbrot\n\t\t\tz = complexPower(z,qpower) + cc;\n\t\t}\n\n\t\tif(variation == 1) {  // foam\n\t\t \tw = complexDiv( complexMul(q,w),z);\n\t\t \tz = complexAdd( complexAdd( csqr(z), csqr(w)),cc);\n\t\t}\n\n\t\tif(variation == 2) {\n\t\t\tw = complexDiv( complexMul(q,w),z);\n\t\t\tz = complexAdd( complexAdd( csqr(z), csqr(w)),cc);\n\t\t\t\n\t\t\tq = complexMul(q,z);\n\t\t\tw = complexMul(w,z);\n\t\t}\n\n\t\tif(variation == 3) {\n\t\t\tw = complexDiv( complexMul(q,w),z);\n\t\t\tz = complexAdd( complexAdd( csqr(z), csqr(w)),cc);\n\t\t\t\n\t\t\tq = complexMul(q,vec2(qparam2,qparam1));\n\t\t\tw = complexMul(w,vec2(qparam1,qparam2));\n\t\t}\n\t\t\n\t\tif(variation == 4) {\t\t\n\t\t\tz = complexPower(z,qpower) - complexMul(f3,z) + cc;\n\t\t}\n\t\t\n\t\tif(variation == 5) {\t\t\n\t\t\tz = complexPower(z,qpower) - csqr(complexMul(f3,z)) + csqr(cc);\n\t\t}\n\t\t\n\t\tif(variation == 6) { // cycle add/sub of C\n\t\t\tw = complexDiv( complexMul(q,w),z);\n\t\t\tz = complexAdd( csqr(z), csqr(w));\n\t\t\t\n\t\t\tif(evenOdd) \n\t\t\t\tz = complexAdd(z,cc);\n\t\t\telse\n\t\t\t\tz = complexSub(z,cc);\n\t\t\tevenOdd = !evenOdd;\n\t\t\t\n\t\t\tq = complexMul(q,z);\n\t\t\tw = complexMul(w,z);\n\t\t}\n\n\t\t// ============================================================\n\n\t\tif(i >= iSkip) {\n\t\t\tcount += 1;\n            int avgStyle = int(qavgstyle);\n\t\t\tif(avgStyle == 0) lastAdded = qavgp1 + qavgp2 * sin(qstripedensity * atan(z.y, z.x));\n\t\t\tif(avgStyle == 1) lastAdded = qavgp1 * sin(qstripedensity * atan(z.y + z.x, z.x)) * qavgp2;\n\t\t\tif(avgStyle == 2) lastAdded = qavgp1 * cos(qstripedensity * atan(z.y, z.x)) * qavgp2;\n\t\t\tif(avgStyle == 3)\t{\n\t\t\t\tfloat zd = (z.x != 0.0) ? z.y * qavgp2 / z.x : 1.0;\n\t\t\t\tlastAdded = qavgp1 * cos(qstripedensity * log(zd));\n\t\t\t}\n\t\t\tif(avgStyle == 4)\t{\n\t\t\t\tfloat zd = (z.x != 0.0) ? pow(z.y / z.x,qavgp1) : 1.0;\n\t\t\t\tlastAdded = 0.62 * cos(qstripedensity * log(zd / qavgp2));\n\t\t\t}\n\t\t\t\n\t\t\tavg += lastAdded;\n\t\t}\n\n\t\tz2 = dot(z,z);\n\t\tif(z2 > qescaperadius && i > iSkip) break;\n\n\t\tif(qp0active > 0.) {\n\t\t\tvec2 diff = complexSub(z,vec2(qp0posx,qp0posy)); \n\t\t\tminDist = min(minDist, diff.x*diff.x + diff.y*diff.y); \n\t\t}\n\t\t\n\t\tif(ql0active > 0.) {\n\t\t\tfloat A = z.x - ql0posx;\n\t\t\tfloat B = z.y - ql0posy;\n\t\t\tfloat C = 1.0;  // x2 - x1\n\t\t\tfloat D = qlp0slope; // y2 - y1\n\t\t\tfloat dist = abs(A * D - C * B) / sqrt(C * C + D * D);\n\t\t\tminDist = min(minDist, dist * dist);\n\t\t}\n\t}\n\n\tfloat fracDen = (minDist > 900.) ? log(z2) : minDist*minDist;\t\n\n    float prevAvg = (avg - lastAdded) / float(count - 1);\n\tavg = avg / float(count);\n\n\tfloat frac = 1.0 + (log2(log(qescaperadius) / fracDen));\n\tfloat mix = frac * avg + (1.0 - frac) * prevAvg;\n\tfloat co = mix * pow(10.0,qmultiplier) * 30.0; \n\n\t// ----------------------------------\n\tvec4 color = vec4(qbright,qbright,qbright,1.);\n\t\n    int colorStyle = int(qcolorstyle);\n \tif(colorStyle == 0) {\n \t\tcolor.x += 0.5 * cos(co + qcolorr);\n \t\tcolor.y += 0.5 * cos(co + qcolorg);\n \t\tcolor.z += 0.5 * cos(co + qcolorb);\n \t}\n \tif(colorStyle == 1) {\n \t\tcolor.x += 0.5 * sin(co + qcolorr);\n \t\tcolor.y += 0.5 * cos(co + qcolorg);\n \t\tcolor.z += 0.5 * cos(co + qcolorb);\n \t}\n \tif(colorStyle == 2) {\n \t\tcolor.x += 0.5 * cos(co + qcolorr);\n \t\tcolor.y += 0.5 * sin(co + qcolorg);\n \t\tcolor.z += 0.5 * cos(co + qcolorb);\n \t}\n \tif(colorStyle == 3) {\n \t\tcolor.x -= 0.5 * cos(co - qcolorr);\n \t\tcolor.y -= 0.5 * cos(co - qcolorg);\n \t\tcolor.z -= 0.5 * cos(co - qcolorb);\n\t}\n\n    // -----------------------------------\n\tcolor.x = 0.5 + (color.x - 0.5) * qcontrast;\n\tcolor.y = 0.5 + (color.y - 0.5) * qcontrast;\n\tcolor.z = 0.5 + (color.z - 0.5) * qcontrast;\n\n    fragColor = color;\n\n    if(displayCount > 0.) \n        displayData(fragColor,fragCoord);\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 49,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const int maxStringLength = 8;\nconst ivec2 cNl    = ivec2(-1, -1);\nconst ivec2 cSp    = ivec2( 0, 13);\nconst ivec2 cPlus  = ivec2(11, 13);\nconst ivec2 cMinus = ivec2(13, 13);\nconst ivec2 cDot   = ivec2(14, 13);\n\nconst ivec2[10] Digits = ivec2[10]\n(\n    ivec2(0, 12), ivec2(1, 12), ivec2(2, 12), ivec2(3, 12), ivec2(4, 12),\n    ivec2(5, 12), ivec2(6, 12), ivec2(7, 12), ivec2(8, 12), ivec2(9, 12)\n);\n#define chd(name, index) const ivec2 name = Digits[index];\nchd(c0,  0) chd(c1,  1) chd(c2,  2) chd(c3,  3) chd(c4,  4)\nchd(c5,  5) chd(c6,  6) chd(c7,  7) chd(c8,  8) chd(c9,  9)\n\nconst ivec2[26] Uppercase = ivec2[26]\n(\n    ivec2( 1, 11), ivec2( 2, 11), ivec2( 3, 11), ivec2( 4, 11), ivec2( 5, 11),\n    ivec2( 6, 11), ivec2( 7, 11), ivec2( 8, 11), ivec2( 9, 11), ivec2(10, 11),\n    ivec2(11, 11), ivec2(12, 11), ivec2(13, 11), ivec2(14, 11), ivec2(15, 11),\n    ivec2( 0, 10), ivec2( 1, 10), ivec2( 2, 10), ivec2( 3, 10), ivec2( 4, 10),\n    ivec2( 5, 10), ivec2( 6, 10), ivec2( 7, 10), ivec2( 8, 10), ivec2( 9, 10),\n    ivec2(10, 10)\n);\n#define chu(name, index) const ivec2 name = Uppercase[index];\nchu(cA,  0) chu(cB,  1) chu(cC,  2) chu(cD,  3) chu(cE,  4)\nchu(cF,  5) chu(cG,  6) chu(cH,  7) chu(cI,  8) chu(cJ,  9)\nchu(cK, 10) chu(cL, 11) chu(cM, 12) chu(cN, 13) chu(cO, 14)\nchu(cP, 15) chu(cQ, 16) chu(cR, 17) chu(cS, 18) chu(cT, 19)\nchu(cU, 20) chu(cV, 21) chu(cW, 22) chu(cX, 23) chu(cY, 24)\nchu(cZ, 25)\n\nconst ivec2[26] Lowercase = ivec2[26]\n(\n    ivec2( 1,  9), ivec2( 2,  9), ivec2( 3,  9), ivec2( 4,  9), ivec2( 5,  9),\n    ivec2( 6,  9), ivec2( 7,  9), ivec2( 8,  9), ivec2( 9,  9), ivec2(10,  9),\n    ivec2(11,  9), ivec2(12,  9), ivec2(13,  9), ivec2(14,  9), ivec2(15,  9),\n    ivec2( 0,  8), ivec2( 1,  8), ivec2( 2,  8), ivec2( 3,  8), ivec2( 4,  8),\n    ivec2( 5,  8), ivec2( 6,  8), ivec2( 7,  8), ivec2( 8,  8), ivec2( 9,  8),\n    ivec2(10,  8)\n);\n#define chl(name, index) const ivec2 name = Lowercase[index];\nchl(ca,  0) chl(cb,  1) chl(cc,  2) chl(cd,  3) chl(ce,  4)\nchl(cf,  5) chl(cg,  6) chl(ch,  7) chl(ci,  8) chl(cj,  9)\nchl(ck, 10) chl(cl, 11) chl(cm, 12) chl(cn, 13) chl(co, 14)\nchl(cp, 15) chl(cq, 16) chl(cr, 17) chl(cs, 18) chl(ct, 19)\nchl(cu, 20) chl(cv, 21) chl(cw, 22) chl(cx, 23) chl(cy, 24)\nchl(cz, 25)\n\nstruct String {\n    int count;\n    ivec2[maxStringLength] chars;\n};\n\n\n// ========================================================================\n// visit: https://www.shadertoy.com/view/mdsSD7\n// This code is released into the public domain.\n// If you need a license instead, consider this CC0, MIT or BSD licensed, take your pick.\n\n// If you want to print numbers larger than 32 digits, increase maxStringLength\n\n#define setString(string, n, contents)\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n#define declString(string, n, contents)\\\nString string;\\\n{\\\n    ivec2[n] _s_ = ivec2[n] contents ;\\\n    for(int _i_ = 0; _i_ < min(maxStringLength, n); _i_++)\\\n    {\\\n        string.chars[_i_] = _s_[_i_];\\\n    }\\\n    string.count = n;\\\n}\n\nstruct Font {\n    vec2 texSize;\n    vec2 charSize;\n    vec2 ct;\n};\n\n#define setFont(ff,c,t) ff.charSize = c; ff.texSize = t; ff.ct = c/t;\n\nstruct TextCursor {\n    vec2 startPos;\n    ivec2 coord;\n    Font font;\n    vec4 color;\n    vec2 charSize;\n    vec2 charSpace;\n    int pageWidth;\n    vec2 fragCoord;\n    vec2 outUV;\n    vec4 outColor;\n};\n\nvec4 getFontCharRect(in Font f, ivec2 char) {\n    return vec4(char, char+ivec2(1)) * f.ct.xyxy;\n}\n\nvec4 getCharScreenRect(in TextCursor t)\n{\n    vec2 leftTop = t.startPos + t.charSpace * vec2(t.coord.x, -t.coord.y);\n    vec2 rightBottom = leftTop + t.charSize * vec2(1, -1);\n    \n    return vec4(leftTop.x, rightBottom.y, rightBottom.x, leftTop.y);\n}\n\nvoid updateOutUV(ivec2 char, inout TextCursor t) {\n    vec4 fontRect = getFontCharRect(t.font, char);\n    vec4 screenRect = getCharScreenRect(t);\n    vec2 screenRectUV = (t.fragCoord - screenRect.xy) / (screenRect.zw - screenRect.xy);\n    \n    if(clamp(screenRectUV, vec2(0), vec2(1)) != screenRectUV) return;\n    \n    t.outUV = screenRectUV * (fontRect.zw - fontRect.xy) + fontRect.xy;\n    t.outColor = t.color;\n}\n\nvoid incrementCursor(inout TextCursor t)\n{\n    t.coord.x += 1;\n    if(t.coord.x >= t.pageWidth)\n    {\n        t.coord.x = 0;\n        t.coord.y += 1;\n    }\n}\n\nvoid newlineCursor(inout TextCursor t)\n{\n    t.coord.x = 0;\n    t.coord.y += 1;\n}\n\nvoid printChar(ivec2 char, inout TextCursor t)\n{\n    if(char == cNl)\n    {\n        newlineCursor(t);\n        return;\n    }\n    \n    updateOutUV(char, t);\n    incrementCursor(t);\n}\n\nvoid printString(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n}\n\n/*\nvoid blend(vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);\n}\n\nvoid printLine(String s, inout TextCursor t)\n{\n    for(int i = 0; i < min(s.count, maxStringLength); i++)\n    {\n        printChar(s.chars[i], t);\n    }\n    printChar(cNl, t);\n}\n*/\nvoid printInt(int val, inout TextCursor t) {\n    if(val < 0)\n    {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    for(;;)  {\n        digits[count++] = val % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        val /= 10;\n        \n        if(val == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n}\n\n\nvoid printFloat(float val, inout TextCursor t,int fractCount) {\n    if(val < 0.0) {\n        printChar(cMinus, t);\n        val = -val;\n    }\n    \n    int[maxStringLength] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        \n        if(count >= maxStringLength)\n            break;\n        \n        iVal /= 10;\n        \n        if(iVal == 0)\n            break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(Digits[digits[i]], t);\n    \n    if(fractCount == 0)  return;\n    printChar(cDot, t);\n        \n    for(int i = 0; i < fractCount; i++) {\n        val *= 10.0;\n        \n        int digit = int(val);\n        val -= float(digit);\n        \n        printChar(Digits[digit], t);\n        \n        if(val <= 0.0)\n            break;\n    }\n}\n\nvoid drawText(TextCursor t, sampler2D fontTexture, inout vec4 fragColor) {\n    fragColor = t.outColor;\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = vec4(0.4,0.4,0.4,10.);\n/*\n    fragColor = vec4(0.);\n    if(texture(fontTexture, t.outUV).r < 0.2)\n        fragColor = t.outColor;\n*/\n}\n\n// =====================================================================================\n// =====================================================================================\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n#define INTEGER 1.\n#define SLOWINTEGER 1.001\n#define UNUSED  999.\n#define UNUSEDP ParamData(0.,0.,0.,0.)\n\nconst ParamData[] pData = ParamData[](\n    //  0 p0 ---------------\n    ParamData(-1.0934, -4.0, 4.0, 0.001),    // center x\n    ParamData(-0.2918, -4.0, 4.0, 0.001 ),    // center y\n    ParamData( 0.7137, 0.002, 200.0, 0.001), // zoom\n    //  3 p1 ---------------\n    ParamData( 0., 0., 6.,SLOWINTEGER ),     // variation\n    ParamData(-0.5, -1., 2., 0.001),         // param 1\n    ParamData(0.2, -1., 2., 0.001),          // param 2\n    //  6 p2 ---------------\n    ParamData(0., -5., 5., 0.01),            // param 3\n    ParamData( 0.01, -5., 5., 0.001),        // param 4\n    ParamData(1., 1., 100., INTEGER),        // skip\n    //  9 p3 ---------------\n    ParamData( 2., 0.5, 25., 0.002),         // power\n    ParamData(1.0, -2., 5., 0.002),          // init power\n    ParamData(0.2268, -10., 10., 0.01),      // stripeDensity\n    // 12 p4 ---------------\n    ParamData(60., 2., 100., 0.1),           // escapeRadius\n    ParamData(-0.11, -2., 2., 0.01),         // multiplier\n    ParamData( 0.5, 0., 1., 0.005),          // bright\n    // 15 p5 ---------------\n    ParamData(0.8, 0.1, 5., 0.05 ),          // contrast\n    ParamData(0., 0., 3., SLOWINTEGER ),     // colorStyle\n    ParamData( 0., 0., 4., 0.008),           // color R\n    // 18 p6 ---------------\n    ParamData( 0., 0., 4., 0.008),           // color G\n    ParamData( 1., 0., 4., 0.008),           // color B\n    ParamData(1., 0., 4., SLOWINTEGER ),     // avgStyle\n    // 21 p7 ---------------\n    ParamData(0.4580, -1., 5., 0.001),       // p1\n    ParamData(-0.5, -1., 5., 0.001),         // p2\n    ParamData(0., 0., 1., SLOWINTEGER ),     // PointOrbit\n    // 24 p8 ---------------\n    ParamData(0.0291, -4.0, 4.0, 0.001),     // x\n    ParamData(0.0291, -4.0, 4.0, 0.001),     // y \n    ParamData(0., 0., 1., SLOWINTEGER ),     // LineOrbit\n    // 27 p9 ---------------\n    ParamData(0.0291, -4.0, 4.0, 0.001),     // x\n    ParamData(0.0291, -4.0, 4.0, 0.001),     // y \n    ParamData(0.0291, -4.0, 4.0, 0.001),     // slope \n    // 30 p10 ---------------\n    ParamData(0.0, 0.0, 3.15, 0.03),         // radial sym\n    UNUSEDP,  // unused\n    UNUSEDP,  // unused\n    // 33 p11 ---------------\n    UNUSEDP,  // focus\n    UNUSEDP,  // displayCount\n    UNUSEDP   // animationFlag\n);\n\n\nconst int UI_SIZE = 31;  // #fields user interface\n\nconst ivec2 P0_ADDR =  ivec2( 0, 0);\nconst ivec2 P1_ADDR =  ivec2( 1, 0);\nconst ivec2 P2_ADDR =  ivec2( 2, 0);\nconst ivec2 P3_ADDR =  ivec2( 3, 0);\nconst ivec2 P4_ADDR =  ivec2( 4, 0);\nconst ivec2 P5_ADDR =  ivec2( 5, 0);\nconst ivec2 P6_ADDR =  ivec2( 6, 0);\nconst ivec2 P7_ADDR =  ivec2( 7, 0);\nconst ivec2 P8_ADDR =  ivec2( 8, 0);\nconst ivec2 P9_ADDR =  ivec2( 9, 0);\nconst ivec2 P10_ADDR = ivec2(10, 0);\nconst ivec2 P11_ADDR = ivec2(11, 0);\nconst int PDATA_ADDR_COUNT = 12;\n\n#define FOCUS_ADDR P11_ADDR\n\nconst ivec2[] storeAddr = ivec2[](P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR,P4_ADDR,P5_ADDR,P6_ADDR,P7_ADDR,P8_ADDR,P9_ADDR,\n    P10_ADDR,P11_ADDR);\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n#define storeData(buf_pos, addr,data) if(ivec2(buf_pos) == addr) fragColor = data\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void initializeStorage(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) fragColor.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<PDATA_ADDR_COUNT;++i) {\n        if(storeDataAddr(fragCoord, storeAddr[i])) {\n            fragColor.xyz = vec3(0.);\n            if(pIndex+0 < UI_SIZE) fragColor.x = pData[pIndex+0].start;\n            if(pIndex+1 < UI_SIZE) fragColor.y = pData[pIndex+1].start;\n            if(pIndex+2 < UI_SIZE) fragColor.z = pData[pIndex+2].start;\n        }\n        \n        pIndex += 3;\n    }\n}\n\n// --------------------------------------------------------\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\n\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis,inout vec3[PDATA_ADDR_COUNT] memory) {\n    if(focus > UI_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 3;  // memory index\n    int focusField = focus % 3;  // x,y,z field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        memory[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.25;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n            \n                if(pData[focus].delta == SLOWINTEGER) { \n                    if(getKeyClick(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyClick(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                } else {\n                    if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                    if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n                }\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            memory[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    memory[focusIndex][focusField] = clamp(memory[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 20.0 || fragCoord.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 10 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(fragColor, fragCoord);\n        return; \n    }\n    \n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry) ---------\n    vec3[PDATA_ADDR_COUNT] memory; \n           \n    // fetch current values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            memory[i] = fetchData(iChannel0, storeAddr[i]).xyz;\n\n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    if(alterFocusedVariable(focus,  0,memory)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1,memory)) resetDisplayCount = true;\n    \n    // output possibly altered values\n    for(int i=0;i<PDATA_ADDR_COUNT;++i)\n        if (storeDataAddr(fragCoord, storeAddr[i])) \n            fragColor.xyz = memory[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount. toggle animationEnable --------\n    if (storeDataAddr(fragCoord, FOCUS_ADDR)) {\n        fragColor = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                fragColor.x += focusChange;\n                if(fragColor.x < 0.0) fragColor.x = float(UI_SIZE-1);\n                if(fragColor.x >= float(UI_SIZE)) fragColor.x = 0.0;\n                \n                if(pData[int(fragColor.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) fragColor.y = iFrameRate; else\n        if(--fragColor.y < 0.0) fragColor.y = 0.0;  // so widget display times out \n        \n        bool kx = getKeyClick(88); // 'X'  animationEnable\n        if(kx) fragColor.z = (fragColor.z == 0.) ? 1. : 0.;\n    }   \n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}