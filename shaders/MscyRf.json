{
    "Shader": {
        "info": {
            "date": "1519677851",
            "description": "multiplicative Perlin noise with hole bubble inflating from left to right.\nP: type of push profile.                     O: bubbles order-dependent or not\nM: multiplicative vs additive noise.  Space: noise type.",
            "flags": 48,
            "hasliked": 0,
            "id": "MscyRf",
            "likes": 25,
            "name": "Perlin with pushing bubbles",
            "published": 3,
            "tags": [
                "procedural",
                "sun",
                "texture",
                "perlin",
                "push",
                "holes",
                "pushhole"
            ],
            "usePreview": 1,
            "username": "FabriceNeyret2",
            "viewed": 1730
        },
        "renderpass": [
            {
                "code": "// value-noise pseudo-Perlin engine from https://shadertoy.com/view/Ms3czX\n\n#define JIT 1      // bubbles location = 1: jittered grid 0: pure random\n#define CHECKER 0  // texture = 0: Perlin noise 1: checker texture\n#define EMIT 1     // display 1: emissivity  0: absorption\nfloat MUL = 1.,    // multiplicative vs additive Perlin  (keyboard control)\n      TEX = 3.,    // noise unsigned, signed, abs, 1-abs   (keyboard control)\n     PUSH = 1.,    // bubble push profile: gauss vs parabolic (keyboard control)\n    ORDER = 1.,    // bubble effect: 1: order-dependant  0: independant\n        k = 1.,    // amount of jittering\n        d = .4,    // length between bubbles ( = grid step ) \n       r0 = .8;    // bubble scale ( modulated later )\n\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n#define  SQR(v) ( (v) * (v) )\n#define rot(a)   mat2(cos(a),-sin(a),sin(a),cos(a))\n#define cross2(a,b) determinant(mat2(a,b))\n\nvec4 t( vec2 U ) { // --- apply chosen turbulence function\n    vec4 T = texture(iChannel0,U); // note that this is value noise, so not true Perlin\n         if (TEX==0.) return              T ;\n    else if (TEX==1.) return          2.* T -1. ;\n    else if (TEX==2.) return     abs( 2.* T -1. );\n    else              return 1.- abs( 2.* T -1. );\n}\n\nvec4 T(vec2 U) {   // --- apply either multiplicative or additive cascade\n#if CHECKER\n    U = floor(U*8.); return vec4(mod(U.x+U.y,2.));\n#endif\n    U /= 16.;\n    mat2 M = rot(1.3);\n    if (MUL==1.) return   t(U) * t(2.*U*M)*2. * t(4.*M*U)*2. * t(8.*U*M*M)*2. ;\n    else         return ( t(U) + t(2.*U*M)/2. + t(4.*M*U)/4. + t(8.*U*M*M)/8. ) / 2. ;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec4 K = texelFetch(iChannel3,ivec2(0),0); // keyboard commands\n    TEX = K.x; MUL = K.y; PUSH = K.z; ORDER = K.w;\n\n    vec2 R = iResolution.xy, S, dU=vec2(0);\n    float x = U.x/R.x,\n          t = .5*iTime + 15.;\n    U =  (U+U-R)/R.y;\n    U.y -= t;\n    \n    float i,l,   r = r0*x*d;                   // bubble radius\n          \n#if JIT                                        // bubbles along jittered grid\n    for (float x=-R.x/R.y; x < R.x/R.y; x+= d)\n      for (float y=-2.; y < 1.4; y+= d) {\n        S = vec2(x,y-floor(t/d)*d);            // time-windowing of seeds\n        i = S.x+S.y/d;\n        S += d/2. + k*d/2.*srnd(i);\n      //S+= .2* vec2( cos(3.*t+i) , sin(3.*t+i) ); // moving bubbles\n#else                                          // bubbles placed pure random\n      for (float i=0.; i < 13./d/d; i++) {\n        S = srnd(i)*R/R.y; \n        S.y = mod( 2.*S.y + t ,4.)-2. - t;     // time-windowing of seeds\n#endif\n        S -= U;                                // distance and length to \n        l = length(S)/r;                       //     bubble center.\n      //l = max(0., sqrt(1.-l*l));             // sphere push\n        if (PUSH==0.) l = max(0., 1.-l*l);     // parabolic push\n        else          l = exp(-.5*SQR(l/.7));  // gaussian push\n        if (l>0.) \n            if (ORDER==1.) U += l*S;           // do push\n            else          dU += l*S;           // cumulate push applied later\n    }\n          \n    O = T(U+=dU);                              // apply texture\n    \n    if (TEX==1.) O = .5+.5*O;                  // signed -> displayable\n    \n    O = O.rrrr;                                // use only grey noise\n\n  //O *= abs(cross2(dFdx(U*R.y),dFdy(U*R.y))) /5.;// Jacobian (bubbles empty)\n    O *= length(fwidth(U*R.y)) /4.;            // pseudo Jacobian\n // O *= length(mat2(dFdx(U*R.y),dFdy(U*R.y))) /4.;         // pseudo Jacobian\n // O *= determinant(mat2(dFdx(U*R.y),dFdy(U*R.y))) /4.;    // true  Jacobian\n  \n#if EMIT                                       // gas IR emission\n    if (MUL == 0.) O *= 4.;      \n    O *= .5 * vec4(1,.5,0,1);\n#else                                          // gas visible absorption          \n         if (TEX == 1.) O = 1.-O;\n    else if (MUL == 0.) O = exp(-O/2.);\n    else                O = exp(-O/4.);     \n#endif\n}\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// bits of \"key group toggles\" https://www.shadertoy.com/view/MlffW2\n\n#define keypressed(ascii) ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O =  iFrame == 0 ? vec4(-1)                   // initialized at -1\n\t                 : texelFetch(iChannel0,ivec2(U),0);  \n    if (U.y>1.) return;\n    \n \tint x = int(U.x);  \n    if ( x == 0 ) {\n        \n        if ( O.x < 0. )     O.x = 3. ;             //    TEX default value\n        if (keypressed(32)) O.x = mod(O.x+1.,4.);  // SPACE: 4 states\n\n        if ( O.y < 0. )     O.y = 1. ;             //    MUL default value\n        if (keypressed(77)) O.y = 1.-O.y;          //     T: 2 states\n\n        if ( O.z < 0. )     O.z = 1. ;             //    PUSH default value\n        if (keypressed(80)) O.z = 1.-O.z;          //     P: 2 states\n\n        if ( O.w < 0. )     O.w = 1. ;             //    ORDER default value\n        if (keypressed(79)) O.w = 1.-O.w;          //     O: 2 states\n     }\n               \n // FYI: LEFT:37  UP:38  RIGHT:39  DOWN:40   PAGEUP:33  PAGEDOWN:34  END : 35  HOME: 36 F1:112\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}