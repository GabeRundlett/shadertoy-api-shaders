{
    "Shader": {
        "info": {
            "date": "1555976338",
            "description": "shining balls",
            "flags": 0,
            "hasliked": 0,
            "id": "Wtf3Wn",
            "likes": 2,
            "name": "RTX ON",
            "published": 3,
            "tags": [
                "sdfreflection"
            ],
            "usePreview": 0,
            "username": "Karambit",
            "viewed": 707
        },
        "renderpass": [
            {
                "code": "\n#define ANTIALIASING\n#define REFLECTION_BOUNCES 5\n\nfloat metallic = 1.0;\nfloat roughness = 0.0;\n\nconst float PI = 3.14159265359;\n\nfloat smin( float a, float b )\n{\n\tfloat k = 0.2;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat orenNayarDiffuse(vec3 ld,vec3 vd,vec3 sn,float r,float a) {\n  \n  float LdotV = dot(ld, vd);\n  float NdotL = dot(ld, sn);\n  float NdotV = dot(sn, vd);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1., max(NdotL, NdotV), step(.0, s));\n\n  float sigma2 = r * r;\n  float A = 1. - .5 * (sigma2/((sigma2 + .33) + .000001));\n  float B = .45 * sigma2 / (sigma2 + .09) + .00001;\n    \n  float ga = dot(vd-sn*NdotV,sn-sn*NdotL);\n\n  return max(0., NdotL) * (A + B * max(0., ga) * sqrt((1.0-NdotV*NdotV)*(1.0-NdotL*NdotL)) / max(NdotL, NdotV));\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n  \n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n  \n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n  \n    return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n  \n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nvec3 lighting(in vec3 n, in vec3 lp, in vec3 p)\n{\n    vec3 ld = normalize(lp - p);\n    vec3 vd = normalize(vec3(0., 0., 5.) - p);\n\tfloat diff = orenNayarDiffuse(ld, vd, n, roughness, 1.0);\n\n\n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n\n    vec3 F = fresnelSchlickRoughness(max(dot(n, vd), 0.0), F0, roughness);\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n\n\tvec3 H = normalize(vd + ld);\n        float distance = length(lp - p);\n        float attenuation = 1.0/pow(distance, 2.0);\n        vec3 radiance     = vec3(1.0) * attenuation;        \n        \n        /* Cook-Torrance BRDF*/\n        float NDF = DistributionGGX(n, H, clamp(roughness, 0.03, 1.0));        \n        float G   = GeometrySmith(n, vd, ld, roughness);      \n        \n        vec3 nominator    = NDF * G * F;\n        float denominator = (4.0 * max(dot(vd, n), 0.0) * max(dot(ld, n), 0.0)) + 0.001; \n        vec3 brdf = nominator / denominator;\n                       \n        vec3 Lo = ((kD * vec3(1.0) / PI + brdf) * radiance * diff) + 0.005; \n   \n        \n\treturn vec3(diff) + Lo;\n}\n\nstruct material {\n\tfloat roughness;\n    float metallic;\n    vec3 color;\n};\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return min(dot(p,n.xyz), 0.0) + n.w;\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 map(in vec3 p)\n{\n    float plane = sdBox(p + vec3(0.0, 2.0, 0.0), vec3(5.0, 1.0, 5.0));\n    \n    float sphere = sdSphere(p + vec3(1.5, .0, .0), 1.0);\n    \n    float sphere2 = sdSphere(p - vec3(1.5, -1.0, -1.0), 1.0);\n    \n    float sphere3 = sdSphere(p - vec3(0.5, 0.5, 1.5), 1.5);\n    \n    float material = 0.0; \n    \n    if(sphere < plane && sphere < sphere2 && sphere < sphere3)\n        material = 0.0;\n    else if(sphere2 < plane && sphere2 < sphere && sphere2 < sphere3)\n        material = 2.0;\n    else if(sphere3 < plane && sphere3 < sphere2 && sphere3 < sphere)\n        material = 1.0;\n    else\n        material = 3.0;\n    \n    return vec2(min(smin(min(sphere, plane), sphere2), sphere3), material);\n}\n\nvec2 intersect(in vec3 ro, in vec3 rd, out int steps)\n{\n    float maxD = 200.0;\n    const int iterations = 150;\n    vec2 h = vec2(1.0);\n    float t = 0.0;\n\tint j;\n    for(int i = 0; i < iterations; i++)\n    {\n        j = i;\n        if(h.x < 0.002 || t > maxD)\n            break;\n        h = map(ro+rd*t);\n        t += h.x;\n    }\n    if( t>maxD ) t=-1.0;\n    steps = j;\n    return vec2(t, h.y);\n    \n}\nvec3 getNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n    \n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x));\n}\n\nvec3 lightPos;\n\nmaterial mats[4];\n\nvec3 shadow(vec3 pos) {\n    vec3 LightDir = normalize(pos-lightPos);\n    int steps;\n    vec2 sh = intersect(lightPos, LightDir, steps);\n    \n    vec3 LightHitPos = lightPos+LightDir*sh.x;\n    \n\tfloat l1 = length(lightPos - LightHitPos);\n\tfloat l2 = length(pos - lightPos);\n    \n    float umbra = smoothstep(0.3, 0.0, ((l2-l1)));\n    //return normalize(vec3(float(steps)/150.0, 1.0/float(steps), 0.0));\n    return vec3(umbra * smoothstep(50.0, 0.0, float(steps)));\n}\n\nvec3 reflection(vec3 ro, vec3 pos, vec3 rayDir, int bounces)\n{\n    vec3 color = vec3(0.0);\n    vec3 normal = normalize(getNormal(pos));\n    float ff = dot(ro-pos, normal);\n    vec3 kD;\n    vec3 nF = vec3(1.0 - dot(rayDir, -normal));\n    for(int i = 0; i < REFLECTION_BOUNCES; i++){\n    \tnormal = normalize(getNormal(pos));\n        rayDir = normalize(reflect(rayDir, normal));\n        int steps;\n        vec2 t = intersect(pos+(0.009*rayDir), rayDir, steps);\n        pos = pos+rayDir*t.x;\n        normal = normalize(getNormal(pos));\n\t\tvec3 matcolor;\n        if(t.x > 0.0){\n        \tmatcolor = vec3(mats[int(t.y)].color);\n            if(int(t.y) == 3){\n            \tmatcolor = mix(matcolor, vec3(0.0, 0.0, 0.0), max(vec3(int(mod(pos.x, 1.05))), vec3(int(mod(pos.z, 1.05)))));\n            }\n        \tvec3 ambient = texture(iChannel1, normal).rgb*0.08 + matcolor*0.08;\n            color += vec3(matcolor * lighting(normal, lightPos,  pos)*shadow(pos) + ambient * nF) / max((float(i)*2.0), 1.0);\n        }\n        else if(t.x < 0.0) {\n        \tcolor += texture(iChannel1, normalize(reflect(ro-pos, normal)), 0.0).rgb * max(1.0-ff, 0.1) * nF;\n            return color*1.0;\n        }\n    }\n    return color;\n}\n\nvoid camera( vec3 hp, vec3 i , vec2 fragCoord, out vec3 rd) {\n    float fRatio = iResolution.x / iResolution.y; // Aspect Ratio\n\n    vec3 f   = normalize(i - hp);\n    vec3 vUp = vec3(0.0, 1.0, 0.0);\n    vec2 vvc = 2.*fragCoord.xy/iResolution.xy-1.;\n    vvc.y /= fRatio;\n\n    vec3 ro = hp;\n    vec3 r = normalize(cross(f, vUp));\n    vUp    = cross(r, f);\n    rd = normalize( r * vvc.x + vUp * vvc.y + f);\n}\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.25*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.6;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\nvec3 reflectpos;\nfloat rt;\nvec3 drawscene(vec3 ro, vec3 rd) \n{\n    int steps;\n    vec2 t = intersect(ro, rd, steps);\n    vec3 pos = ro+rd*t.x;\n    vec3 normal = normalize(getNormal(pos));\n    float ff = dot(ro-pos, normal);\n    vec3 color = texture(iChannel1, rd).rgb;\n\tvec3 F0 = vec3(0.04);\n    F0      = mix(F0, vec3(1.0), metallic);\n    vec3 matcolor = color;\n    vec3 F = vec3(1.0 - dot(rd, -normal));\n    rt = t.x;\n    if(t.x > 0.0)\n    {\n        reflectpos = pos;\n        matcolor = vec3(mats[int(t.y)].color);\n        \n        if(int(t.y) == 3 || int(t.y) == 2 ){\n            matcolor = mix(matcolor, vec3(0.0, 0.0, 0.0), max(vec3(int(mod(pos.x, 1.05))), vec3(int(mod(pos.z, 1.05))) ));\n        }\n        vec3 ambient = texture(iChannel1, normal, 8.0).rgb*0.08 + matcolor*0.08;\n        color = matcolor * lighting(normal, lightPos, pos)* vec3(shadow(pos))+ambient; \n        \n        color *= calcAO(pos, normal);\n    }\n    return color;\n}\n\nvec2 offsetPixel(float x, float y)\n{\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    return pixelSize * vec2(x, y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = (iResolution.x/iResolution.y)*uv.x;\n    lightPos = vec3(sin(iTime*0.5) * cos(iTime*0.5), 1.0, cos(iTime*0.5) * cos(iTime*0.5)) * 4.0;\n    vec2 m = vec2(0.0); \n    \n    float nRotate = iTime *0.09; \n\n    float h  = PI * (m.x - nRotate);\n    float e  = mix(0.0, 2.5, m.y); \n    float d  = 5.0; // eye distance\n\n    // ro RayOrigin\n    vec3 ro  = vec3(sin(h) * cos(e), 0.25, cos(h) * cos(e)) * d;\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 rd;\n    camera( ta + ro, ta, fragCoord, rd);\n    rd += ta;\n    \n    mats[0].roughness = 0.0;\n    mats[0].metallic = 1.0;\n    mats[0].color =  normalize(vec3(1.1, 0.1, 0.1));\n    \n    mats[1].roughness = 1.0;\n    mats[1].metallic = 0.0;\n    mats[1].color = normalize(vec3(0.1, 0.1, 1.1));\n    \n    \n    mats[2].roughness = 1.0;\n    mats[2].metallic = 0.0;\n    mats[2].color = normalize(vec3(0.1, 0.1, 0.1));\n    \n    mats[3].roughness = 1.0;\n    mats[3].metallic = 0.0;\n    mats[3].color = normalize(vec3(0.1, 0.1, 0.1));\n    #ifdef ANTIALIASING\n    vec3 color = drawscene(ro, rd)*0.5;\n    color += drawscene(ro + vec3(offsetPixel(-2.0, 2.0), 0.0), rd)*0.125;\n    color += drawscene(ro + vec3(offsetPixel(2.0, 2.0), 0.0), rd)*0.125;\n    color += drawscene(ro + vec3(offsetPixel(-2.0, -2.0), 0.0), rd)*0.125;\n    color += drawscene(ro + vec3(offsetPixel(2.0, -2.0), 0.0), rd)*0.125;\n    #else\n    vec3 color = drawscene(ro, rd);\n    #endif\n    if(rt > 0.0)\n    \tcolor += reflection(ro, reflectpos, rd, REFLECTION_BOUNCES);\n    \n    color = pow(color, vec3(1.5));\n    \n    vec2 fragcoord = fragCoord / iResolution.xy;\n    float vignete = 1.0 - smoothstep(0.5, 1.5, length(vec2(0.0) - (fragcoord * 2.0 - 1.0)));\n\n    // Output to screen\n    fragColor = vec4(color*vignete,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 27,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}