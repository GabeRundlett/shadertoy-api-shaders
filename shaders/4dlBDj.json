{
    "Shader": {
        "info": {
            "date": "1500394726",
            "description": "Create a pop art effect by deforming shapes and using a toon shader. Try turning the color off- the dots still show shape pretty well. Fair warning- moving the camera causes some nasty aliasing that i'm not sure how to fix w/o slowing down the render. ",
            "flags": 0,
            "hasliked": 0,
            "id": "4dlBDj",
            "likes": 3,
            "name": "Pop Art",
            "published": 3,
            "tags": [
                "npr"
            ],
            "usePreview": 0,
            "username": "divya_mahadevan",
            "viewed": 955
        },
        "renderpass": [
            {
                "code": "#define COLOR 1\n#define ROTATE 0\nfloat displacement(vec3 p) {\n\n\treturn 0.03*sin(60.0*p.x)*sin(60.0*p.y)*sin(60.0*p.z);\n\n}\n\n\t\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdPlane(vec3 p)\n{\n\n\treturn p.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn (length(p)-s);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\nvec2 opUnion (vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opDisplacement(in float d1, in vec3 pos) \n{\n\n\treturn d1+displacement(pos);\n\n}\n\nvec2 mapShape (in vec3 pos) {\n\tfloat sphere = sdSphere(pos-vec3( 0.0,0.5, 0.0), 0.5);\n\t vec2 res = opUnion( vec2( opDisplacement(udRoundBox(pos+vec3(0.2, 0.75, -0.5), vec3(1.6, 0.7, 1.6), 0.1), pos), 1.0 ),\n\t             vec2( opDisplacement(sphere, pos), 46.9 )) ;\n    res = opUnion(res, vec2(opDisplacement(sdCone(pos-vec3(-1.1, 0.65, 0.90), vec3(0.5, 0.4, 0.5)), pos), 40.0));\n    res = opUnion(res, vec2(opDisplacement(sdTorus(pos-vec3(-1.2, 0.3, -0.6), vec2(0.4, 0.1)), pos), 45.0)); \n    return res;\n\n}\nvec2 map (in vec3 pos) {\n\tfloat sphere = sdSphere(pos-vec3( 0.0,0.5, 0.0), 0.5);\n\t vec2 res = opUnion( vec2( udRoundBox(pos+vec3(0.2, 0.75, -0.5), vec3(1.6, 0.7, 1.6), 0.1), 1.0 ),\n\t             vec2( sphere, 46.9 ) );\n    res = opUnion(res, vec2(sdCone(pos-vec3(-1.1, 0.65, 0.90), vec3(0.5, 0.4, 0.5)), 51.0));\n    res = opUnion(res, vec2((sdTorus(pos-vec3(-1.2, 0.3, -0.6), vec2(0.4, 0.1))), 45.0)); \n    return res;\n    /*float sphere = sdSphere(pos-vec3( 0.0,0.5, 0.0), 0.5);\n\t vec2 res = opUnion( vec2( opDisplacement(sdPlane(pos), pos), 1.0 ),\n\t             vec2( opDisplacement(sphere, pos), 46.9 )) ;\n    res = opUnion(res, vec2(opDisplacement(sdCone(pos-vec3(-1.4, 0.5, 0.50), vec3(0.5, 0.4, 0.5)), pos), 40.0));\n    \n    return res;*/\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in vec2 uv )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n   \n\tfloat tp1 = (0.0-ro.y)/rd.y;\n    if (tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y)/rd.y;\n    if (tp2 > 0.0) {\n    \tif (ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax,tp2);\n    }\n    \n    float t = tmin;\n    float m = -1.0;\n    for (int i = 0; i < 64; i++)\n    {\n\t    float delta = 0.0005*t;\n\t    vec2 res = mapShape( ro + rd*t);\n        if( res.x<delta || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec2 e = vec2(1.0, -1.0) * 0.5773*0.005;\n    return normalize( e.xyy*map(pos+e.xyy).x +\n                     e.yyx*map(pos + e.yyx).x +\n                     e.yxy*map(pos+e.yxy).x +\n                     e.xxx*map(pos + e.xxx).x);\n\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++){\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos = nor*hr + pos;\n        float dd = map(aopos).x;\n        occ+= -(dd-hr)*sca;\n        sca *=0.95;\n    \n    }\n    return clamp(1.0-3.0*occ, 0.0, 1.0);\n\n}\n\nfloat softshadow (in vec3 eye, in vec3 rd, in float mint, in float tmax)\n{\n\n\tfloat res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++) {\n    \tfloat h = map(eye+rd*t).x;\n        res = min(res, 8.0*h/t);\n        t+=clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax) break;\n    \n    }\n    return clamp(res, 0.0, 1.0);\n\n\n}\nvec3 render (in vec3 eye, in vec3 rd, in vec2 uv)\n{\n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(eye, rd, uv);\n    float t = res.x;\n    float m = res.y;\n    if (m > -0.5) {\n    \tvec3 pos = eye + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        \n        col = 0.25 + 0.25*(sin(vec3(0.75, 0.8, 0.70)*(m-1.0)));\n        \n        if(m < 1.5) {\n        \n            col = 0.3 + 0.1*vec3(1.0);\n        \n        }\n\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n        dif = ceil(dif*2.0)/2.0;\n        vec3 lin = vec3(0.0);\n        lin+=1.30*dif; \n        col = col*lin;\n        if (col.x > 0.0 && col.y > 0.0 && col.z > 0.0 && COLOR == 0) {\n        \tcol = vec3(0.99, 0.98, 0.9);\n        \n       }\n\t\t\n    \n    } else {\n    \n    \tcol = vec3(1.0, 0.98, 0.9);\n    \n    }\n    \n    return vec3(clamp(col, 0.0, 1.0));\n    \n\n\n}\n\n\n//sets the camera transformation\nmat3 setCamera(in vec3 eye, in vec3 look, in vec3 up)\n{\n\n\tvec3 cam_w = normalize(look - eye);\n    vec3 cam_u = normalize(cross(cam_w, up));\n    vec3 cam_v = normalize(cross(cam_u, cam_w));\n    return mat3(cam_u, cam_v, cam_w);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mo = iMouse.xy/iResolution.xy;\n    vec2 pix_loc = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float time = 15.0 + iTime;\n    vec3 ro = vec3( -2.5, 1.5, -2.0);\n    if (ROTATE == 1) {\n    \tro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 1.0*sin(0.1*time + 6.0*mo.x) );\n    }\n    vec3 look = vec3(-0.5, 0.0, 0.5);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat3 cam_to_world = setCamera(ro, look, up);\n    \n    vec3 ray_dir = cam_to_world*normalize(vec3(pix_loc.xy, 2.0));\n    \n    vec3 col = render(ro, ray_dir, pix_loc.xy);\n    \n    col = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}