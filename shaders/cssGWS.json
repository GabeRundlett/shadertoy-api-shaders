{
    "Shader": {
        "info": {
            "date": "1666763902",
            "description": "This shader is almost just my attempt to understand jt's voxel experiments.\n[url]https://www.shadertoy.com/view/flyfRz[/url]\n\n I tweaked it to make it easier to use in my shaders.\nAnd also, now we can use a cuboid as a cell of the voxel :)",
            "flags": 0,
            "hasliked": 0,
            "id": "cssGWS",
            "likes": 56,
            "name": "BLF Voxel Accelerated Ray March",
            "published": 3,
            "tags": [
                "voxel",
                "random"
            ],
            "usePreview": 1,
            "username": "iY0Yi",
            "viewed": 754
        },
        "renderpass": [
            {
                "code": "// This shader is almost just my attempt to understand jt's voxel experiments.\n// \"primitives in voxels\" https://www.shadertoy.com/view/flyfRz\n// \"Cast Voxels March Sub-Objects\" https://www.shadertoy.com/view/NstSR8\n// I tweaked it to make it easier to use in my shaders.\n// Also now we can use cuboid as cell of voxel :)\n\n// the size of voxel cell. (only integers are allowed)\n//--------------------------------------------------------------------------------------\n#define I_CELL_SIZE ivec3(5,3,5)\n#define V_CELL_SIZE vec3(I_CELL_SIZE)\n\n#define CELL_NUM vec3(4,4,4)\n\n// get cell by ray position.\n//--------------------------------------------------------------------------------------\nivec3 getCell(vec3 p){\n    return ivec3(floor(p/V_CELL_SIZE)*V_CELL_SIZE);\n}\n\n// define active cells of voxel by sdf.\n//--------------------------------------------------------------------------------------\nfloat sdVoxelBound(ivec3 cell){\n    vec3 p = vec3(cell);\n    return length(p)-max(.1,cos(iTime)+.5)*40.;\n}\n\n// return ID of cell.\n// \"0u\" means the cell is empty.\n//--------------------------------------------------------------------------------------\nuint getCellID(ivec3 cell){\n    if(sdVoxelBound(cell)>0.) return 0u;\n    if(any(lessThan(cell, -ivec3(CELL_NUM)*I_CELL_SIZE)) || any(greaterThan(cell, ivec3(CELL_NUM)*I_CELL_SIZE))) return 0u;\n    return 1u + (uhash(uvec3(cell/I_CELL_SIZE)) % 3u);\n}\n\n// the map function of each cell.\n//--------------------------------------------------------------------------------------\nvec4 sdCell(vec3 p, ivec3 icell){\n    vec4 res = vec4(MAX_DIST,MAT_VOID);\n\n    uint id = getCellID(icell);\n    \n    vec3 cell = vec3(icell);\n    float diff = hash13(cell)*PI;\n    vec3 rnd = hash33(cell);\n\n    vec2 sp = bx_cossin((iTime*3.+diff)*sign(rnd.x-.5));\n    float r = .8;\n    vec3 op = vec3(sp.x, abs(sin(5.*(iTime*3.+diff))), sp.y);\n    uint underCellId = getCellID(icell-ivec3(0,V_CELL_SIZE.y,0));\n    if(id == 1u && (underCellId==2u || underCellId==3u)) res = vec4(sdSphere(p+op*(V_CELL_SIZE*.5-r), r), vec3(1.000,0.902,0.6)+rnd*.002);\n    if(id == 2u) res = vec4(sdBoxFrame(p, vec3(.5)*V_CELL_SIZE-.125, .05)-.125, vec3(.3,.8,.5)+rnd*.1);\n    if(id == 3u) res = vec4(sdBox(p, vec3(.5)*V_CELL_SIZE-.125)-.125, vec3(.2,.7,.5)+rnd*.1);\n\n    return res;\n}\n\n// ray march the cell.\n//--------------------------------------------------------------------------------------\nvec4 marchCell(vec3 ro, vec3 rd, float tmin, float tmax, ivec3 cell){\n    for(float t = tmin; t < tmax;){\n        vec4 res = sdCell(ro+rd*t, cell);\n        if(res.x<MIN_DIST)return vec4(t, res.yzw);\n        t += res.x;\n    }\n    return vec4(MAX_DIST,MAT_VOID);\n}\n\n// main function to attempt to intersect\n// http://lodev.org/cgtutor/raycasting.html\n//--------------------------------------------------------------------------------------\nvec4 intersectVoxel(vec3 ro, vec3 rd){\n    ivec3 cell = getCell(ro);\n    \n    // \"Branchless Voxel Raycasting\" by fb39ca4\n    // https://www.shadertoy.com/view/4dX3zl\n    ivec3 rayStep = ivec3(sign(rd))*I_CELL_SIZE;\n    vec3 deltaDist = V_CELL_SIZE/abs(rd);\n    vec3 sideDist = (sign(rd) * (vec3(cell)-ro)/V_CELL_SIZE + sign(rd)*.5+.5) * deltaDist;\n\n    for (int i=0; i<MAX_RAY_STEPS; i++){\n        // if the cell is not empty, do ray marching.\n        if(getCellID(cell)>0u){ \n            vec3 p = ro-vec3(cell)-V_CELL_SIZE*.5;\n            // bounding box\n            vec2 bounds = iBox(p, rd, V_CELL_SIZE*.5);\n            // ray marching in the cell\n            vec4 res = marchCell(p, rd, bounds.x, bounds.y, cell);\n            if(res.x>=bounds.x && res.x<=bounds.y && res.x>0.) return res;\n        }\n        \n        // the branchless tricks\n        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        cell += ivec3(vec3(mask)) * rayStep;\n    }\n    return vec4(MAX_DIST,MAT_VOID);\n}\n\n// to calculate ao, mix distances with neighbor cells.\n//--------------------------------------------------------------------------------------\nfloat sdCellNeighbors(ivec3 cell, vec3 offset){\n    float d = MAX_DIST;\n    // kastorp's optimization: traverse only 2x2x2 cells (instead of 3x3x3),\n    // chosen depending on where in the cell the current point is located.\n    // https://www.shadertoy.com/view/Nl3BDj\n    ivec3 off = -ivec3(step(vec3(0), offset));\n    for(int z=off.z; z<=off.z+1; z++)\n    for(int y=off.y; y<=off.y+1; y++)\n    for(int x=off.x; x<=off.x+1; x++){\n        ivec3 ncell = cell-ivec3(x,y,z)*I_CELL_SIZE;\n        if(getCellID(ncell) > 0u){\n            d = min(d, sdCell(offset+vec3(x,y,z)*V_CELL_SIZE, ncell).x);\n        }\n    }\n    return d;\n}\n\n// normal calcutation\n//--------------------------------------------------------------------------------------\nvec3 normalCell(vec3 p, ivec3 cell) {\n    vec3 n = vec3(0.0);\n    for(int i = 0; i < 4; i++) {\n        vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);\n        n += e * sdCell(p + MIN_DIST * e, cell).x;\n    }\n    return normalize(n);\n}\n\n// \"Multi Level AO\" by iY0Yi\n// https://www.shadertoy.com/view/fsBfDR\nfloat aoSeed = 0.;\nconst float MAX_SAMP = 4.;\nfloat ao(vec3 p, vec3 n, float radius) {\n    float ao = 0.;\n    for(float i = 0.; i <= MAX_SAMP; i++) {\n        vec2 rnd = hash21(i + 1. + aoSeed);\n\n        float scale = (i + 1.)/MAX_SAMP;\n        scale = mix(.0, 1., pow(scale, .5));\n\n        rnd.x = (rnd.x * 2. - 1.) * PI * .5;\n        rnd.y = (rnd.y * 2. - 1.) * PI;\n        vec3 rd = normalize(n + hash21(i + 2. + aoSeed).xyx);\n        rd.xy *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n        rd.xz *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n\n        rd *= sign(dot(rd, n));\n\n        float raylen = radius * scale;\n        vec3 rndp = p + normalize(n + rd) * raylen;\n        ivec3 cell = getCell(rndp);\n\n        float res = sdCellNeighbors(cell, rndp-vec3(cell)-.5*V_CELL_SIZE);\n        ao += res;\n        aoSeed++;\n    }\n    return ao/float(MAX_SAMP);\n}\n\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld) {\n  float norm_factor = (shininess + 5.) / (2. * PI);\n  vec3 h = normalize(-vd + ld);\n  return pow(max(0., dot(h, n)), shininess) * norm_factor;\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x * (a * x + b))/(x * (c * x + d) + e);\n}\n\nvoid camera(vec2 uv) {\n    const float pY = .5;\n    const float cL = 150.;\n    const vec3 focus = V_CELL_SIZE*.5;\n    const float fov = .1;\n    vec3 up = vec3(0, 1, 0);\n    vec3 pos = vec3(0, .0, -1) * cL;\n    R(pos.xz, iTime*.5);\n    \n    if(iMouse.z > .5) {\n        pos = vec3(\n            -sin(iMouse.x/iResolution.x * PI*2. + PI * .5),\n            sin(iMouse.y/iResolution.y * PI * 2.),\n            -cos(iMouse.x/iResolution.x * PI*2. + PI * .5)\n            ) * cL;\n        R(pos.xz, PI);\n    }\n    \n    vec3 dir = normalize(focus - pos);\n    vec3 target = pos - dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    mat3 camMat = mat3(cu, cv, cw);\n    rd = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n    ro = pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = (uv * 2. - 1.);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // set ray vectors\n    camera(uv);\n    \n    // optimization: skip empty voxels\n    ro += rd*iBox(vec3(ro)-V_CELL_SIZE*.5, rd, V_CELL_SIZE*(CELL_NUM+.5)+MIN_DIST ).x;\n\n    // attempt to intersect\n    vec4 res = intersectVoxel(ro, rd);\n\n    // sky color\n    vec3 col = vec3(.5,.8,.8)*(1./PI)*2.;\n    \n    // hit\n    if(res.x < MAX_DIST){\n        vec3 pos = ro+rd*res.x;\n        \n        // calc normal\n        ivec3 cell = getCell(pos+rd*MIN_DIST);\n        vec3 n = normalCell(pos-vec3(cell)-.5*V_CELL_SIZE, cell);\n        \n        vec3 ldir = normalize(vec3(0, 1., 1.));\n        R(ldir.xz, -iTime*.5);\n        \n        // calc shading\n        float diff = max(0., dot(n, ldir))*(1./PI);\n        float indr = (dot(n, -ldir) * .5 + .5)*(1./PI);\n        float rgh = (distance(res.yzw, vec3(1.000,0.902,0.7))<.2) ? .125 : .01;\n        float spec = normalizedBlinnPhong(1./rgh, n, rd, ldir);\n        float a = ao(pos, n, .1);\n        a += ao(pos, n, .9)*.25;\n        a /= 2.;\n        \n        // shadow\n        float sdw = step(MAX_DIST,intersectVoxel(pos,ldir).x);\n\n        col = diff*2.8*sdw*vec3(1.000,0.929,0.541);\n        col += vec3(.65,.8,.8)*.4*(.3+.7*a);\n        col += vec3(.2,.7,.5)*1.*indr*(.3+.7*a);\n        #if 0\n            col *= .8*(.75+.25*sin(res.yzw*5.+vec3(3.+sin(floor(iTime*.125)),1,2.+sin(2.+floor(iTime*.125)))+floor(iTime*.125)));\n        #else\n            col *= res.yzw;\n        #endif\n        col += spec * .25 * sdw;\n    }\n    col = ACESFilm(col);\n\n    // contrast curve\n    col = smoothstep(.05,.9,col);\n\n    fragColor = vec4(pow(col,vec3(.4545)),1);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Hash without Sine\" by Dave_Hoskins:\n#define PI 3.1415926\n#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n#define MAX_RAY_STEPS 20\n#define MAT_VOID vec3(-1)\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// \"Best\" Integer Hash by FabriceNeyret2\n// https://www.shadertoy.com/view/WttXWX\nuint triple32(uint x){\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x){\n    return float(triple32(x))/float(0xffffffffU);\n}\n\nuint uhash(uvec2 v){\n    return triple32(v.x + triple32(v.y));\n}\n\nuint uhash(uvec3 v){\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 iBox( in vec3 ro, in vec3 rd, vec3 boxSize){\n    vec3 m = 1./rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.);\n    return vec2( tN, tF );\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e ){\n    p = abs(p  )-b;\n    vec3 q = abs(p+e)-e;\n    return min(min(\n    length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    length(max(vec3(q.x,q.y,p.z) ,0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://www.shadertoy.com/view/XdV3W3\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a,8.0)-4.0)-2.0,-1.0,1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a,a-2.0));}\n\nvec3 ro, rd;",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}