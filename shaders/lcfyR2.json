{
    "Shader": {
        "info": {
            "date": "1721313845",
            "description": "Shader to be used in touchdesigner",
            "flags": 0,
            "hasliked": 0,
            "id": "lcfyR2",
            "likes": 1,
            "name": "Square Tiles Cube Room",
            "published": 3,
            "tags": [
                "sdf",
                "texture",
                "fisheye",
                "dome"
            ],
            "usePreview": 0,
            "username": "WilstonOreo",
            "viewed": 112
        },
        "renderpass": [
            {
                "code": "/*\n{\n  \"DESCRIPTION\": \"Data Transfer\",\n\n  \"IMPORTED\" : [\n  ],\n  \"CATEGORIES\" : [\n  ],\n\n  \"INPUTS\" : [\n  {\n  \t\"NAME\": \"colorImage\",\n  \t\"TYPE\": \"image\"\n  },\n  {\n    \"NAME\": \"cam_yaw\",\n    \"LABEL\": \"Yaw\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -180.0,\n    \"MAX\": 180.0\n  },\n  {\n    \"NAME\": \"cam_pitch\",\n    \"LABEL\": \"Pitch\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -180.0,\n    \"MAX\": 180.0\n },\n {\n \"NAME\": \"cam_roll\",\n \"LABEL\" : \"Roll\",\n \"TYPE\": \"float\",\n \"DEFAULT\": 0.0,\n \"MIN\": -180.0,\n \"MAX\": 180.0\n },\n  {\n    \"NAME\": \"scale_x\",\n    \"LABEL\": \"Scale X\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.1,\n    \"MAX\": 10.0\n  },\n  {\n    \"NAME\": \"scale_y\",\n    \"LABEL\": \"Scale Y\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 1.0,\n    \"MIN\": 0.1,\n    \"MAX\": 10.0\n  },\n  {\n    \"NAME\": \"cam_pos_x\",\n    \"LABEL\": \"Cam Position X\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n  {\n    \"NAME\": \"cam_pos_y\",\n    \"LABEL\": \"Cam Position Y\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n  {\n    \"NAME\": \"cam_pos_z\",\n    \"LABEL\": \"Cam Position Z\",\n    \"TYPE\": \"float\",\n    \"DEFAULT\": 0.0,\n    \"MIN\": -1.0,\n    \"MAX\": 1.0\n  },\n {\n \"NAME\": \"speed\",\n \"LABEL\" : \"Speed\",\n \"TYPE\": \"float\",\n \"DEFAULT\": 0.5,\n \"MIN\": -2.0,\n \"MAX\": 2.0\n },\n {\n \"NAME\": \"map_mode\",\n \"VALUES\": [\n 0,\n 1,\n 2\n ],\n \"LABELS\": [\n \"Equirectangular\",\n \"Fisheye\",\n \"Cubic\"\n ],\n \"DEFAULT\": 0,\n \"TYPE\": \"long\"\n },\n  ],\n\t\"PERSISTENT_BUFFERS\": [\n\t\t\"timeBuffer\"\n\t],\n\t\"PASSES\": [\n\t\t{\n\t\t\t\"TARGET\": \"timeBuffer\",\n\t\t\t\"WIDTH\": \"1\",\n\t\t\t\"HEIGHT\": \"1\",\n\t\t\t\"FLOAT\": true\n\t\t}, {\n\t\t}\n\t]\n}\n*/\n\nfloat currentTime;\n\n////////// shaders/camera.h //////////\n//#define MAP_DYNAMIC\n//#define MAP_ROTATE\n//#define MAP_SPHERICAL 0\n#define MAP_FISHEYE 1\n//#define MAP_CUBE 2\n\nuniform float cam_roll; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pitch; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_yaw; // default = 0.0, min = -180.0, max = 180.0\nuniform float cam_pos_x; // default = 0.0, min = -1.0, max = 1.0\nuniform float cam_pos_y; // default = 0.0, min = -1.0, max = 1.0\nuniform float cam_pos_z; // default = 0.0, min = -1.0, max = 1.0\n\n#ifdef TOUCHDESIGNER\nuniform float scale_x; // default = 1.0, min = 0.1, max = 10.0\nuniform float scale_y; // default = 1.0, min = 0.1, max = 10.0\n#else\nconst float scale_x = 1.0; // default = 1.0, min = 0.1, max = 10.0\nconst float scale_y = 1.0; // default = 1.0, min = 0.1, max = 10.0\n#endif\n\n\n////////// shaders/direction.h //////////\n////////// shaders/util.h //////////\n\nconst float PI = 3.14159265358979323846264;\n\nstruct Ray\n{\n  vec3 org;\n  vec3 dir;\n};\n\n/// Convert degrees to radians\nfloat deg2rad(in float deg)\n{\n  return deg * PI / 180.0;\n}\n\n\n/// Convert degrees to radians\nfloat rad2deg(in float rad)\n{\n  return rad / PI * 180.0;\n}\n\nfloat sqr(in float a)\n{\n  return a*a;\n}\n\n/// Calculates the rotation matrix of a rotation around X axis with an angle in radians\nmat3 rotateAroundX( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(1.0,0.0,0.0,\n              0.0,  c, -s,\n              0.0,  s,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Y axis with an angle in radians\nmat3 rotateAroundY( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c,0.0,  s,\n              0.0,1.0,0.0,\n               -s,0.0,  c);\n}\n\n/// Calculates the rotation matrix of a rotation around Z axis with an angle in radians\nmat3 rotateAroundZ( in float angle )\n{\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat3(  c, -s,0.0,\n                s,  c,0.0,\n              0.0,0.0,1.0);\n}\n\n/// Calculate rotation by given yaw and pitch angles (in degrees!)\nmat3 rotationMatrix(in float yaw, in float pitch, in float roll)\n{\n  return rotateAroundZ(deg2rad(yaw)) *\n         rotateAroundY(deg2rad(-pitch)) *\n         rotateAroundX(deg2rad(roll));\n}\n\nfloat solveQuadraticEquation(\n    in float a,\n    in float b,\n    in float c)\n{\n  float disc = b*b - 4.0 * a * c;\n  if (disc < 0.0) return -1.0;\n\n  float distSqrt = sqrt(disc);\n  float q;\n  if (b < 0.0)\n  {\n    q = (-b - distSqrt)*0.5;\n  }\n  else\n  {\n    q = (-b + distSqrt)*0.5;\n  }\n  if (q == 0.0) return -1.0;\n\n  float t = c / q;\n  if (t < 0.0)\n    t = q / a;\n\n  return t;\n}\n\n\n#ifdef MAP_FISHEYE\n// Get fisheye camera ray from screen coordinates\nfloat fisheye_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n\tuv = uv - 0.5;\n  float phi = atan(uv.x,uv.y);\n  float l = length(uv);\n\n  if (l > 0.5)\n  {\n    return -1.0;\n  }\n  float theta  = l * PI;\n  rd = normalize(vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));\n  return 1.0;\n}\n#endif\n\n#ifdef MAP_SPHERICAL\nfloat spherical_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  float theta = (uv.t) * PI,\n        phi = (uv.s - 0.5)* 2.0 * PI;\n  rd = vec3(sin(theta) * sin(phi), sin(theta) * cos(phi), cos(theta));\n  return 1.0;\n}\n#endif\n#ifdef MAP_CUBE\nfloat cubemap_direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n\tvec2 uv = screenCoord.xy / res;\n  uv.x *= 6.0;\n\n  if (uv.x < 1.0) // EAST\n  {\n    uv -= 0.5;\n    rd = vec3(2.0*uv.x,1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 2.0) // WEST\n  {\n    uv -= 0.5;\n    uv.x -= 1.0;\n    rd = vec3(-2.0*uv.x,-1.0,-2.0*uv.y);\n  } else\n  if (uv.x < 3.0) // NORTH\n  {\n    uv -= 0.5;\n    uv.x -= 2.0;\n    rd = vec3(1.0,-2.0*uv.xy);\n  } else\n  if (uv.x < 4.0) // SOUTH\n  {\n    uv -= 0.5;\n    uv.x -= 3.0;\n    rd = vec3(-1.0,2.0*uv.x,-uv.y*2.0);\n  } else\n  if (uv.x < 5.0) // Top\n  {\n    uv -= 0.5;\n    uv.x -= 4.0;\n    rd = vec3(2.0*uv,1.0);\n  } else\n  if (uv.x < 6.0) // Bottom\n  {\n    uv -= 0.5;\n    uv.x -= 5.0;\n    rd = vec3(-uv.x*2.0,uv.y*2.0,-1.0);\n  }\n\n  rd = normalize(rd);\n\n  return 1.0;\n}\n#endif\n#ifdef MAP_DYNAMIC\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n#ifdef MAP_SPHERICAL\n  if (map_mode == MAP_SPHERICAL)\n  {\n    return spherical_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_FISHEYE\n  if (map_mode == MAP_FISHEYE)\n  {\n    return fisheye_direction(screenCoord,res,rd);\n  }\n#endif\n#ifdef MAP_CUBE\n  if (map_mode == MAP_CUBE)\n  {\n    return cubemap_direction(screenCoord,res,rd);\n  }\n#endif\n  return -1.0;\n}\n\n#endif\n\n#ifndef MAP_DYNAMIC\n#ifdef MAP_SPHERICAL\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return spherical_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_FISHEYE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return fisheye_direction(screenCoord,res,rd);\n}\n#endif\n#ifdef MAP_CUBE\nfloat direction(in vec2 screenCoord, in vec2 res, out vec3 rd)\n{\n  return cubemap_direction(screenCoord,res,rd);\n}\n#endif\n#endif\n\n\n\n\n// Get fisheye camera ray from screen coordinates with rotation\nfloat direction(in vec2 screenCoord, in vec2 res, float rotX, float rotY, float rotZ, out vec3 rd)\n{\n  if (direction(screenCoord,res,rd) < 0.0)\n  {\n    return -1.0;\n  }\n  rd *= rotateAroundZ(rotZ)*rotateAroundY(rotY)*rotateAroundX(rotX);\n  return 1.0;\n}\n\n\nfloat setup_camera_ray(in vec2 uv, out vec3 ray)\n{\n  return direction(uv,vec2(1.0),deg2rad(90.0+cam_yaw),deg2rad(cam_roll),deg2rad(cam_pitch),ray);\n}\n\n////////// shaders/time.h //////////\n\n// Returns a pyramid-like periodic signal.\nfloat pyramid(float x)\n{\n\tx = fract(x);\n\treturn min(x * 2.0, (1.0 - x) * 2.0);\n}\n\n// Returns a semicircular periodic signal.\nfloat circ(float x)\n{\n\tx = fract(x) * 2.0 - 1.0;\n\treturn sqrt(1.0 - x * x);\n}\n\nfloat mp(float x)\n{\n\tfloat y=0.3;\n\treturn clamp((pyramid(x)-0.5)*2.0-0.4,-y,y);\n}\n\nmat3 transpose_(mat3 m)\n{\n\treturn mat3(vec3(m[0].x,m[1].x,m[2].x),\n\t\t\t\tvec3(m[0].y,m[1].y,m[2].y),\n\t\t\t\tvec3(m[0].z,m[1].z,m[2].z));\n}\n\nfloat sceneDist(vec3 p)\n{\n\tfloat d=1e3;\n\n\tp+=vec3(0.0,1.0,0.0);\n\tp.z+=cos(p.y*2.0+currentTime)*0.1;\n\tfloat tm=fract(currentTime*1.0-0.1);\n\tp.x-=(smoothstep(0.0,0.3,tm)-smoothstep(0.4,1.0,tm))*smoothstep(0.5,2.0,p.y)*0.2;\n\n\treturn d;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n\tp*=15.0;//scene_scale;\n\tfloat c=sceneDist(p);\n\tfloat e=1e-3;\n\treturn normalize(vec3(sceneDist(p+vec3(e,0,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,e,0))-c,\n\t\t\t\t\t\t  sceneDist(p+vec3(0,0,e))-c));\n}\n\nvec2 unitSquareInterval(vec2 ro, vec2 rd)\n{\n\tvec2 slabs0 = (vec2(+1.0) - ro) / rd;\n\tvec2 slabs1 = (vec2(-1.0) - ro) / rd;\n\n\tvec2 mins = min(slabs0, slabs1);\n\tvec2 maxs = max(slabs0, slabs1);\n\n\treturn vec2(max(mins.x, mins.y),\n\t\t\t\tmin(maxs.x, maxs.y));\n}\n\nvec3 squaresColours(in vec2 p)\n{\n\tp+=vec2(currentTime*0.005);\n\treturn texture(iChannel0,fract(p*vec2(scale_x,scale_y))).xyz;\n}\n\nvec3 squaresTex(vec2 p,float border)\n{\n\tfloat sm=0.02;\n\tvec2 res=vec2(8.0);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\nvec3 room(vec3 ro,vec3 rd,out vec3 rp,out vec3 n)\n{\n\tvec2 box_size=vec2(1.0,5.0+3.0/8.0);\n\tvec2 cp=vec2(0.0),ct=vec2(1e3);\n\tvec3 ci=ro+rd*ct.y;\n\tvec2 cu=vec2(atan(ci.z-cp.y,ci.x-cp.x)/3.1415926*0.5,(ci.y+0.5/8.0)*4.0);\n\n\tfloat wt=max(0.0,unitSquareInterval(ro.xy * box_size, rd.xy * box_size).y);\n\tfloat t=min(ct.y,wt);\n\trp=ro+rd*t;\n\n\tn.z=0.0;\n\tif(abs(rp.x*box_size.x)>abs(rp.y*box_size.y))\n\t\tn.xy=vec2(rp.x/abs(rp.x),0.0);\n\telse\n\t\tn.xy=vec2(0.0,rp.y/abs(rp.y));\n\n\tif(ct.y<wt)\n\t{\n\t\tn.y=0.0;\n\t\tn.xz=normalize(rp.xz-ci.xz);\n\t}\n\n\tfloat l=1.0-smoothstep(0.0,3.0,abs(rp.z-ro.z));\n\n\tvec3 wc=mix(squaresTex(rp.zy+vec2(0.0,0.5/8.0),0.5),squaresTex(rp.xz,0.44),step(0.999/box_size.y,abs(rp.y)));\n\tvec3 cc=squaresTex(cu,0.45)+0.8*vec3(smoothstep(0.83/5.0,0.86/5.0,abs(rp.y)));\n\n\treturn l*mix(cc,wc,step(wt,t));\n}\n\nvec3 scene(vec2 uv)\n{\n\tfloat lt=0.0;\n\tvec3 ro = vec3(cam_pos_x,cam_pos_y,cam_pos_z);\n  vec3 rd;\n\n\tif (setup_camera_ray(uv, rd) < 0.0)\n  {\n    return vec3(0.0);\n  }\n\n\trd=normalize(rd);\n\n\tvec3 n,rp;\n\n\tvec3 c;\n\tvec3 c0=room(ro,rd,rp,n);\n\t\tvec3 r=reflect(rd,n);\n\t\tvec3 c1=room(rp,r,rp,n);\n\t\tc=c0+c1*c0*0.4;\n\n\treturn c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tfragColor = vec4(vec3(scene(uv)),1.0);\n }\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}