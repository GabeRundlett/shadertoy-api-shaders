{
    "Shader": {
        "info": {
            "date": "1616258032",
            "description": "forkable common setup I tend to want for every shader I start.",
            "flags": 32,
            "hasliked": 0,
            "id": "7dX3R2",
            "likes": 4,
            "name": "boilerplate stuff",
            "published": 3,
            "tags": [
                "boilerplate"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 310
        },
        "renderpass": [
            {
                "code": "\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    setupCoords(iResolution.xy, 0.78);\n    setupTime(iTime);\n\n    // pixel epsilon for smoothstep\n    float smoothEps = gWorldFromScreenFac * 2.5;\n    \n    vec4 mouseData = texelFetch(iChannel0, ivec2(0), 0);\n\n    \n    // draw something\n    \n    vec2 p = worldFromScreen(XY);\n    vec2 m = worldFromScreen(mouseData.xy);\n    p -= m;\n    \n    const vec3 colBG  = vec3(0.2, 0.3, 0.4);\n    const vec3 colFG1 = vec3(1.0, 0.9, 1.0);\n    const vec3 colFG2 = vec3(0.8, 0.9, 0.6);\n    const vec3 colFG3 = vec3(0.0, 0.8, 0.5);\n    const vec3 colFG4 = vec3(0.6, 0.5, 0.6);\n\n    float angPt = atan(p.y, p.x);\n    float angMs = 0.0; // atan(m.y, m.x);\n    float rad = 1.0;\n    rad += 0.02 * sin((angPt - angMs * 1.0) *  7.0 - gTime);\n    rad += 0.02 * sin((angPt - angMs * 1.0) * 14.0 + gTime);\n    float len = length(p);\n    \n    vec3 col = colBG;\n    \n    vec3 colBand = mix(colFG2, colFG3, 0.5 + 0.5 * sin(angPt *  5.0 - gTime * 0.3 + rad * 33.0 + 0.2 * sin(len * 200.0 - gTime * 4.0)));\n    \n    // dashed lines w/ dashing size in screenspace\n    vec3 colLine = mix(colFG1, colFG4, smoothstep(-0.5, 0.5, sin((angPt - angMs) *  0.25 * gScreenFromWorldFac)));\n    \n    float bandRad = mix(0.0, 0.2, sin(gTime * 0.3) * 0.5 + 0.5);\n    \n    col = mix(col, colBand, 0.1 * smoothstep(smoothEps, -smoothEps, abs(rad           - len) - bandRad));\n    col = mix(col, colLine,       smoothstep(smoothEps, -smoothEps, abs(rad + bandRad - len)          ));\n    col = mix(col, colLine,       smoothstep(smoothEps, -smoothEps, abs(rad - bandRad - len)          ));\n    \n    RGBA = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI  = 3.14159265359;\nconst float TAO = PI * 2.0;\n\n// global time parameter\nfloat gTime;\n\nvec2  gCanvasRes;\nfloat gCanvasSmallRes;\nfloat gZoom;\nfloat gScreenFromWorldFac;\nfloat gWorldFromScreenFac;\n\n// set up world coordinates where a unit circle fits\n// in the smallest dimension of the canvas, plus a zoom factor.\nvoid setupCoords(in vec2 canvasResolution, in float zoom) {\n\n    gCanvasRes = canvasResolution;\n\n    // the smallest dimension of the canvas\n    gCanvasSmallRes = min(canvasResolution.x, canvasResolution.y);\n    \n    // small = shrink\n    gZoom = zoom;\n    \n    // factor to get from world scale to screen scale\n    gScreenFromWorldFac = gZoom * gCanvasSmallRes / 2.0;\n    \n    // factor to get from screen scale to world scale\n    gWorldFromScreenFac = 1.0 / gScreenFromWorldFac;\n}\n\nvec2 worldFromScreen(in vec2 screenPt) {\n    return (screenPt - gCanvasRes / 2.0) * gWorldFromScreenFac;;\n    \n}\n\n// in case we want to speed or slow down things from iTime.\n// this needs to be called in each pass.\nvoid setupTime(in float time) {\n    gTime = time;\n}\n\n\n\nfloat sdDisk(in vec2 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sdCircle(in vec2 p, in float r) {\n    return abs(sdDisk(p, r));\n}\n\nfloat sdAnnulus(in vec2 p, in float r1, in float r2) {\n    return abs(sdDisk(p, (r1 + r2) / 2.0)) - (r2 - r1) / 2.0;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    ivec2 IJ = ivec2(XY);\n    \n    if (IJ != ivec2(0)) {\n        RGBA = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        RGBA = vec4(0.0, 0.0, -1e9, 0.0);\n    }\n    \n    // data.xy = use this as mouse point, other buffers.\n    // data.zw = actual last mouse position, if mouse was down. else -1e9.\n \n    vec4 data = texelFetch(iChannel0, IJ, 0);\n     \n     \n    bool prevMouseDown = data.z   > -1e8;\n    bool currMouseDown = iMouse.z > -1.0;\n     \n    vec2 prevMp = prevMouseDown ? data.zw : iMouse.xy;\n    data.xy += iMouse.xy - prevMp;\n    data.xy = clamp(data.xy, iResolution.xy * -0.25, iResolution.xy * 1.25);\n    data.zw = currMouseDown ? iMouse.xy : vec2(-1e9);\n     \n    \n    RGBA = data;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}