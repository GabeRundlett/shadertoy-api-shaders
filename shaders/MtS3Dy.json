{
    "Shader": {
        "info": {
            "date": "1432087629",
            "description": "Use mouse to control the green control point.\nUsing distance from each pixel to the quadratic bezier curve to render the curve.",
            "flags": 0,
            "hasliked": 0,
            "id": "MtS3Dy",
            "likes": 41,
            "name": "2D Quadratic Bezier",
            "published": 3,
            "tags": [
                "2d",
                "bezier"
            ],
            "usePreview": 0,
            "username": "demofox",
            "viewed": 8734
        },
        "renderpass": [
            {
                "code": "/*\nInfo on curves:\nhttp://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nhttp://research.microsoft.com/en-us/um/people/cloop/LoopBlinn05.pdf\nhttp://www.pouet.net/topic.php?which=9119&page=1\nhttp://blog.gludion.com/2009/08/distance-to-quadratic-bezier-curve.html\n\nThe top link is where the get_distance_vector comes from.\n\nThanks also to other bezier curve shadertoys:\nhttps://www.shadertoy.com/view/XsX3zf\nhttps://www.shadertoy.com/view/lts3Df\n*/\n\n#define EDGE   0.005\n#define SMOOTH 0.0025\n\n// signed distance function for Circle, for control points\nfloat SDFCircle( in vec2 coords, in vec2 offset )\n{\n    coords -= offset;\n    float v = coords.x * coords.x + coords.y * coords.y - EDGE*EDGE;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0, 1.0); // ð‘¡Ì…\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // ð‘£ð‘– = ð‘(ð‘¡Ì…)\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n//-----------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 percent = ((fragCoord.xy / iResolution.xy) - vec2(0.25,0.5));\n    percent.x *= aspectRatio;\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - vec2(0.25,0.5);\n    mouse.x *= aspectRatio;\n    vec2 A = vec2(0.0,0.0);\n    vec2 B = length(iMouse.xy) > 0.0 ? mouse : vec2(-0.3,0.2);\n    vec2 C = vec2(1.0,0.0);\n\n    vec3 color = vec3(1.0,1.0,1.0);\n    float dist = SDFCircle(percent, A);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }\n    \n    dist = SDFCircle(percent, B);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,1.0,0.0),vec3(1.0,1.0,1.0),dist);\n    }    \n    \n    dist = SDFCircle(percent, C);\n\tif (dist < EDGE + SMOOTH)\n    {\n        dist = max(dist, 0.0);\n        dist = smoothstep(EDGE,EDGE + SMOOTH,dist);\n        color *= mix(vec3(0.0,0.0,1.0),vec3(1.0,1.0,1.0),dist);\n    }    \n\n    dist = approx_distance(percent, A, B, C);\n    if (dist < EDGE + SMOOTH)\n    {\n        dist = smoothstep(EDGE - SMOOTH,EDGE + SMOOTH,dist);\n        color *= vec3(dist);\n    }\n       \n\tfragColor = vec4(color,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "",
                "outputs": [],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}