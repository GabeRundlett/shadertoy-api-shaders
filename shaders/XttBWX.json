{
    "Shader": {
        "info": {
            "date": "1543756590",
            "description": "glsl compo for tokyo demo fest 2018, 3rd place\n\nNice to be there, thanks tdf!",
            "flags": 0,
            "hasliked": 0,
            "id": "XttBWX",
            "likes": 31,
            "name": "[TDF2018]Time_machine",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "tdf",
                "doraemon"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 1200
        },
        "renderpass": [
            {
                "code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.1415926535\n#define FAR 30.0\n\nvec2 hash22(vec2 p)\n{\n    float f=p.x+p.y*37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p * vec3(5.3983, 5.4472, 6.9371));\n    p += dot(p.yzx, p.xyz + vec3(21.5351, 14.3137, 15.3219));\n    return fract(p.x * p.y * p.z * 95.4337);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec2 line(vec3 pos, vec3 a, vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\nfloat line(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat line(vec2 pos, vec2 a, vec2 b, float r)\n{\n    vec2 pa=pos-a;\n    vec2 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p)-0.5;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d=abs(vec2(length(p.xz),p.y))-h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0=length(p/r);\n    float k1=length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 swing(vec3 p)\n{\n    p.xy*=rot(0.15*sin(1.5*iTime));\n\n    p+=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n// for bounding sphere\nvec3 inverse_swing(vec3 p)\n{\n    p.xy*=rot(-0.15*sin(1.5*iTime));\n\n    p-=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n#define HEAD 1\n#define BODY 2\n#define NOSE 3\n#define HAND 4\n#define BELL 5\n// machine\n#define BASE 6\n#define CONTROL 7\n#define CONTROL_FRONT 8\n#define FUEL 9\n#define HANDLE1 10\n#define HANDLE2 11\n#define SOFA 12\n#define LIGHT 13\n\nint obj_id, machine_id;\n\nvoid body(vec3 p, inout float d0)\n{\n    float d1=line(p+vec3(0.,.6,0.),vec3(0),vec3(0.,0.2,0.),0.32);\n    if(d1<d0) obj_id=BODY;\n    d0=smin(d0,d1,0.03);\n}\n\nvoid brace(vec3 p, inout float d0)\n{\n    float d2=torus(p+vec3(0.,.4,0.),vec2(0.31,0.03));\n    if(d2<d0) {obj_id=NOSE;d0=d2;}\n}\n\nvoid legs(vec3 p, inout float d0)\n{\n    vec3 q=vec3(abs(p.x)-.18,p.y,p.z);\n    float d3=line(q+vec3(0,.95,0.),vec3(0),vec3(0.,0.2,0.),0.15);\n    d0=smin(d0,d3,0.13);\n    \n    // feet\n    q.x=abs(p.x)-0.2;\n    float d4=torus(q+vec3(0.,1.05,0.),vec2(0.08,0.09));\n    if(d4<d0) {obj_id=HAND;d0=d4;}\n}\n\nvoid arms(vec3 p, inout float d0)\n{\n    vec2 d5=line(p+vec3(-.28,0.5,0.),vec3(0),vec3(0.27,0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0) obj_id=BODY;\n    d0=smin(d0,d5.x,.02);\n    d5.x=length(p+vec3(-.6,0.2,0.))-0.09;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n    \n    d5=line(p+vec3(.28,0.5,0.),vec3(0),.9*vec3(-0.27,-0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0){obj_id=BODY;d0=d5.x;}\n    d5.x=length(p+vec3(.55,0.75,0.))-0.08;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n}\n\nvoid nose_tail(vec3 p, inout float d0)\n{\n    float d6=length(p+vec3(0.,-0.15,0.5))-0.05;\n    if(d6<d0) {obj_id=NOSE;d0=d6;}\n    \n    // tail\n    float d7=line(p+vec3(0.,0.77,-0.1),vec3(0),vec3(0.,-0.1,0.25),0.01);\n    float dt=length(p+vec3(0.,0.87,-0.35))-0.04;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    if(d7<d0) {obj_id=BODY;d0=d7;}\n\n}\n\nvoid bag(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    q.yz*=rot(0.14);\n    float d8=cylinder(vec3(q.x,q.z+.16,abs(q.y+0.55)), vec2(0.1,.19))-0.05;\n    float d9=box(q+vec3(0.,.1,.0),vec3(1.,.44,1.));\n    d8=smax(-d9,d8,.02);\n    d0=smin(d0,d8,0.01);\n    \n    // bell\n    float d10=length(p+vec3(0.,0.46,0.36))-0.06;\n    float d11=torus(p+vec3(0.,0.46,0.36),vec2(0.06,0.009));\n    d10=min(d10,d11);\n    if(d10<d0) {obj_id=BELL;d0=d10;}\n}\n\nvoid mouth(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    \n    p.yz*=rot(0.2);\n    float d12=cylinder(vec3(p.x,p.z+.6,abs(p.y-0.11)), vec2(0.25,.19))-0.05;\n    float d13=box(p+vec3(0.,-1.11,.0),vec3(1.,1.,1.));\n    d12=smax(-d13,d12,.06);\n    if(-d12>d0) obj_id=NOSE;\n    d0=smax(-d12,d0,.03); \n    float dt=length(vec3(abs(p.x)-.05,p.y+.18,p.z+.2))-0.2;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    \n    \n    q.x=abs(q.x);\n    \n    vec2 d5=line(q+vec3(0.,-0.03,0.41),vec3(0),vec3(0.27,-0.01,-0.02));\n    //if(d14<d0) obj_id=NOSE;\n    d5.x-=0.07+0.01*(1.-d5.y);\n    d0=smin(d0,d5.x,0.01);\n}\n\nfloat doraemon(vec3 p)\n{\n    p=swing(p);\n    \n    obj_id=HEAD;\n    float d0=length(p)-0.5;\n    \n    body(p,d0);\n    brace(p,d0);\n    legs(p,d0);\n    arms(p,d0);\n    nose_tail(p,d0);\n    bag(p,d0);\n    mouth(p,d0);\n    return d0;\n}\n\nvoid main_control(vec3 p, inout float d0)\n{\n    float d2=box(p+vec3(0.,-0.4,.9), vec3(.87,.4, .2));    \n    if(d2<d0){machine_id=CONTROL;d0=d2;}\n    float d3=prism(vec3(p.z+1.,p.y-0.24,p.x), vec2(0.4,0.87));\n    if(d3<d0){machine_id=CONTROL_FRONT;d0=d3;}\n    \n    float d4=box(p+vec3(0.,-0.8,.85),vec3(0.8,0.2,0.2));\n    d0=max(-d4,d0);\n    \n    float d5=cylinder(p+vec3(-0.5,-0.7,.8),vec2(0.015,0.2));\n    if(d5<d0){machine_id=CONTROL;d0=d5;}\n    \n    float d6=length(p+vec3(-0.5,-0.88,.8))-0.05;\n    if(d6<d0) {machine_id=HANDLE1; d0=d6;}\n}\n\nvoid lamp(vec3 p, inout float d0)\n{\n    float d7=cylinder(p+vec3(-1.17,-1.,.8),vec2(0.025,1.));\n    float d8=line(p+vec3(-1.17,-2.,.8),vec3(0.),vec3(-0.35,0.35,0.),0.025);\n    d8=min(d7,d8);\n    if(d8<d0){machine_id=CONTROL;d0=d8;}\n    \n    vec3 q=p;\n    q.xy*=rot(0.8);\n    float d9=ellipsoid(q+vec3(1.32,-2.22,.8),vec3(0.25,0.07,0.2));\n    if(d9<d0){machine_id=LIGHT;d0=d9;}\n}\n\nvoid handles(vec3 p, inout float d0)\n{\n    float d=cylinder(vec3(p.x+1.35,p.z-1.2, p.y-.1),vec2(0.3,.25));\n    d=max(d,-box(p+vec3(1.65,-.2,-1.2),vec3(0.3,0.4,0.3)));\n    d=max(d,-box(p+vec3(1.25,.4,-1.2),vec3(0.3,0.4,0.3)));\n    if(d<d0){machine_id=CONTROL;d0=d;}\n    \n    p=p+vec3(1.15,-.3,-1.1);\n    \n    for(int i=0;i<3;++i)\n    {\n        d=line(p,vec3(0),vec3(0.1,0.2,0.),0.01);\n        d0=min(d0,d);\n        d=length(p+vec3(-0.1,-0.2,0.))-0.04;\n        if(d<d0){machine_id=HANDLE2;d0=d;}\n        p.z-=0.11;\n    }\n}\n\nvoid sofa(vec3 p, inout float d0)\n{\n    float d12=rbox(p+vec3(0.,-.5,-.8),vec3(0.6,0.5,0.04), 0.05);\n    float d13=rbox(p+vec3(0.,-.15,-.4),vec3(0.6,0.15,0.3), 0.05);\n    d13=smin(d12,d13,0.2);  \n    if(d13<d0){machine_id=SOFA;d0=d13;}\n}\n\nfloat timemachine(vec3 p)\n{\n    p=swing(p+vec3(0,0,0));p.y+=1.15;\n    \n    machine_id=BASE;\n    \n    float d0=box(p+vec3(0.,0.02,0.), vec3(1.5,0.06,1.8));\n    \n    main_control(p,d0);\n    lamp(p,d0);\n    handles(p,d0);\n    sofa(p,d0);\n    \n    p.x=abs(p.x)-1.17;\n    float d1=line(p+vec3(0.,-0.1,1.45),vec3(0),vec3(0.,0.,1.5),0.2);\n    if(d1<d0) {machine_id=FUEL; d0=d1;}\n    return d0;\n}\n\n\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.025)*18., 0.,0.);\n}\n\n/// from Klem's Olympian: https://www.shadertoy.com/view/XltyRf\nvec3 tunnel(vec3 rd, float pos, float speed) \n{\n    const float max_r = 5.;\n    vec3 col;//=vec3(1.);\n    for (float r=1.0;r<max_r+float(min(0,iFrame));r+=1.0) \n    {\n        // calculate where the ray intersects several fixed radius cylinders\n        // using cylindrical coordinates\n        // (phi, r, z)\n        // phi=arctan(rd.y/rd.x)\n        // r=r\n        // length(rd.xy) / r = rd.z / z ==> z=rd.z*r/length(rd.xy)\n        float phi=atan(rd.x, rd.y);\n        float z=rd.z*r/length(rd.xy);\n        if(r<1.5)col=vec3(abs(z)*.005);\n        // adjust the uv acoording to cylinder size and position\n        vec2 uv=vec2(phi*r, pos+z);\n        uv.x+=1.717*hash13(vec3(floor(uv),r))*r;\n        \n        vec2 cell_center=floor(uv)+0.5;\n        cell_center+=hash22(cell_center+vec2(0.,r))-.5;\n\n        vec2 size=vec2(.01);\n        size.y+=speed/r;\n        size.y/=sin(atan(r/abs(z)));\n        \n        //float d=(length((uv-cell_center)/size)-1.)*size.y;\n        //col+=vec3(1,.9,.6)*smoothstep(0.105,-0.105,d)/(.5*r*r+.3*z*z);\n\n        \n        float redshift=0.01+speed/r;\n        cell_center.y-=redshift;\n        for (int i=0; i<3+min(0,iFrame); i++) \n        {\n            cell_center.y+=redshift;\n            \n            // draw stars\n            vec2 p=uv-cell_center;\n            float d=(length(p/size)-1.0)*size.y;\n            float dist=(r*r+z*z);\n            col[i]+=smoothstep(0.02, -0.02, d)/dist;\n        }\n        \n    }\n    return 3.*col;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1+float(min(0,iFrame)); i++)\n    {\n        d=i/5.0;\n        r+=w*(d-min(doraemon(p+n*d),timemachine(p+n*d)));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\n\nvec3 material_doraemon(vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 col=vec3(0);\n    float d; \n    pos=swing(pos);\n    \n    if(obj_id==HEAD)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x*0.9,pos.y+0.05))<0.38)col=vec3(0.9);\n        \n        // eyes\n        if(pos.z<0.)\n        {\n            vec2 p=vec2(abs(pos.x)-0.1,pos.y*.7-0.2);\n            float r=length(p.xy);\n            col*=pow(1.-smoothstep(0.08,0.09,r)*smoothstep(0.1,0.09,r),1.);\n            if(r<0.085) col=vec3(1.);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            r=length(p);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            float r1=length(p);\n            col*=pow(1.-smoothstep(0.0,0.025,r)*smoothstep(0.03,0.025,r),7.0);\n            \n            // beards\n            if(pos.y>0.&&pos.y<0.11)\n            col*=smoothstep(0.,0.01,abs(pos.x));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y), vec2(0.,0.14),vec2(0.14,0.18),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.04), vec2(0.,0.14),vec2(0.15,0.15),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.08), vec2(0.,0.14),vec2(0.15,0.13),0.001));\n        }\n    }\n    else if(obj_id==BODY)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x,pos.y+.6))<.22)col=vec3(0.9);\n    }\n    else if(obj_id==NOSE)\n        col=vec3(.4,0.,0.);\n    else if(obj_id==BELL)\n        col=vec3(1.2,0.7,0.);\n    else if(obj_id==HAND)\n        col=vec3(.9);\n    else if(obj_id==BASE)\n        col=vec3(0.05,0.1,0.2);\n    else if(obj_id==CONTROL)\n        col=vec3(.9,.7,.5);\n    else if(obj_id==CONTROL_FRONT)\n    {\n        col=vec3(.9,.7,.5);\n        // pos.y -1.x -> -0.7\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.8),vec2(0.5,-0.8),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.9),vec2(0.5,-0.9),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-1.),vec2(0.5,-1.),0.001)),40.));\n        \n    }\n    else if(obj_id==HANDLE1)\n        col=vec3(0.,0.1,0.3);\n    else if(obj_id==FUEL)\n        col=vec3(0.01,0.04,0.1);\n    else if(obj_id==HANDLE2||obj_id==SOFA)\n        col=vec3(0.1,0.,0.04);\n    else if(obj_id==LIGHT)\n    {\n        // pixel light\n        vec2 frp=abs(fract(pos.xz*10.));\n        frp=pow(frp, vec2(4.));\n        float edge=max(0.,1.-(frp.x+frp.y));\n        vec2 flp=floor(pos.xz*10.);\n        float k=dot(sin(flp+cos(flp.yx*2.+iTime*2.)),vec2(.5));\n        col=nor.y<0.? 10.*edge*vec3(pow(k,.7)*2., 4.*pow(k, 1.5), pow(k,2.)) : vec3(.9,.7,.5);\n    }\n    return col;\n}\n\nvec3 get_doraemon_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*doraemon(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 get_timemachine_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*timemachine(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 lighting_doraemon(vec3 rd, vec3 pos, float ps,float hitinfo, float t)\n{\n    vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n    vec3 l1col=vec3(1.,0.8,0.8);\n    \n    vec3 e=vec3(0.5*ps,0.0,0.0); \n    vec3 nor;\n\n    if(hitinfo<.9)\n        nor=get_doraemon_normal(pos);\n    else\n        nor=get_timemachine_normal(pos);\n    \n    if(timemachine(pos)<doraemon(pos))obj_id=machine_id;\n    if(t>FAR&&obj_id==LIGHT)obj_id=CONTROL; // avoid weird artifacts, should find a bettwe way\n    \n    vec3 mate=material_doraemon(rd,pos,nor);\n    float ao=get_ao(pos,nor);\n    float dif=max(0.0,dot(nor,l1dir));\n    float bac=max(0.0,dot(nor,-l1dir));\n    float spe=max(0.0, pow(clamp(dot(l1dir, reflect(rd, nor)), 0.0, 1.0), 32.0));\n\n    vec3 lin=6.0*dif*l1col*ao;\n    lin+=1.*bac*l1col;\n    lin+=3.*spe*vec3(1.);\n    return lin*0.2*mate;\n}\n\nfloat pixel_size;\n\nvec4 intersect_doraemon(vec3 ro, vec3 rd, out vec3 hitinfo)\n{\n    hitinfo=vec3(0.,0.,1.);\n    float d_first=100.0, t_first=0.0;\n    float old_d=1000.0;\n    float d_max=1000.0, t_max=0.0;\n    float t=1.0;\n    float d=100.0;\n    float hitwho=0.,old_hitwho=0.;\n    \n    for(int i=0; i<64+min(0,iFrame); ++i) \n    {\n        hitwho=0.;\n        // splitting them is just for not crashing my windows laptop....\n        d=doraemon(ro+rd*t);\n        float d1=timemachine(ro+rd*t);\n        if(d1<d){hitwho=1.;d=d1;}\n\n        \n        if(d_first == 100.0)  // the first edge\n        {\n            hitinfo.x=hitwho;\n            if(d>old_d) \n            {\n                if(old_d<pixel_size * (t-old_d))\n                {\n                    d_first=old_d;\n                    t_first=t-old_d;\n                    hitinfo.x=old_hitwho;\n                }\n            }\n            old_d=d;\n            old_hitwho=hitwho;\n        }\n        if(d<d_max) // save the max occluder\n        { \n            t_max=t; \n            d_max=d;\n            hitinfo.y=hitwho;\n        }  \n        \n        if(d<0.00001 || t>FAR)\n            break;\n        t += d;\n        hitinfo.z=t;\n    }\n    return vec4(t_max, d_max, t_first, d_first);\n}\n\nfloat bounding_sphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 p=sph.xyz;\n    p=inverse_swing(p);\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nvec3 render_doraemon(vec3 ro, vec3 rd, vec3 bg)\n{\n    float t=bounding_sphere(ro,rd,vec4(0.,-0.35,0.,2.5));\n    if(t<=0. || t>1000.)\n        return bg;\n    \n    // first hit, max hit, t\n    vec3 hitinfo;\n    vec4 res=intersect_doraemon(ro,rd,hitinfo);\n    \n    float d_max, t_max, d_first, t_first;\n    t_max=res.x;\n    d_max=res.y;\n    t_first=res.z;\n    d_first=res.w;\n    vec3 nor,pos;\n    \n    vec3 col=bg;\n    \n    if(d_max < pixel_size*t_max) \n    {\n        pos=ro+rd*t_max;\n        col=mix(lighting_doraemon(rd, pos, pixel_size*t_max,hitinfo.y, hitinfo.z), col, \n                  clamp(d_max/(pixel_size * t_max), 0.0, 1.0));\n    }\n    float ratio=0.0;\n\n    if(d_first==100.0 || t_max==t_first)\n    {\n        t_first=t_max;\n        d_first=d_max;\n        ratio=0.5;\n    }\n    \n    pos=ro+rd*t_first;\n    col=mix(lighting_doraemon(rd, pos, pixel_size*t_first,hitinfo.x, hitinfo.z),\n              col, clamp(ratio+d_first/(pixel_size*t_first), 0.0, 1.0));\n    \n    return col;\n}\n\n\n#define CITY_MENGER 1\n#define CITY_ROAD 2\n\n#define VOXEL_GAP 0.1\n\nconst mat3 ma=mat3(0.6,0.,0.8,\n                   0.,1.,0.,\n                   -0.8,0.,0.6);\n\nvec4 city(vec3 p)\n{\n    p.y-=0.3;\n    obj_id=CITY_MENGER;\n    vec2 flp=floor(p.xz);\n    vec2 frp=fract(p.xz);\n    \n    frp-=0.5;\n    \n    vec2 rand;\n    rand=hash22(flp);\n    float height=0.4+rand.x*rand.x*1.7;\n    float d0=box(vec3(frp.x,p.y,frp.y),vec3(0.1,height,.4));   \n    \n    vec4 res=vec4(d0, 1.0, 0.0, 0.0);\n    \n    // menger spone from iq\n    // larger value gives higher density of rooms\n    // I like 1.1, 1.2, 1.7\n    float s=1.+.2*rand.y*(1.-step(1.6,height)); \n    vec3 q=p;\n    for(int m=0; m<4+min(0,iFrame); m++)\n    {      \n        p.y+=rand.y;\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=3.;\n        vec3 r=abs(1. - 3.0*abs(a));\n        float da=max(r.x,r.y);\n        float db=r.y;//max(r.y,r.z);\n        float dc=max(r.z,r.x);\n        float c=(min(da,min(db,dc))-1.)/s;\n\n        if(c>d0)\n        {\n          d0=c;\n          res=vec4(d0, min(res.y,.2*da*db*dc), (1.0+float(m))/4.0, 0. );\n        }\n    }\n   \n    if(q.y<res.x){obj_id=CITY_ROAD;res.x=q.y;}\n    return res;\n}\n\n\nvec3 get_city_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*city(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n#define CITY_ITER 250\n#define CITY_FAR 50.\n\nvec4 intersect_city_voxel(vec3 ro, vec3 rd)\n{\n    vec4 h=vec4(100.),res=vec4(-1);\n    float t = 0.05;\n    vec3 p=vec3(0.0);\n\n    for (int i=0; i<CITY_ITER+min(0,iFrame); i++)\n    {\n        if(h.x<0.0001+0.000125*t||t>CITY_FAR)\n        {\n            continue;\n        }\n        p=ro+rd*t;\n\n        h=city(p);\n\n        // 2d voxel marching the city blocks, as the boundaries are not continues\n        \n        float dx=-fract(p.x);\n        if (rd.x>0.) \n            dx=fract(-p.x);\n        \n        float dz=-fract(p.z);\n        if (rd.z>0.)\n            dz=fract(-p.z);\n        \n        float nearest=min(fract(dx/rd.x), fract(dz/rd.z))+VOXEL_GAP;\n        nearest=max(VOXEL_GAP, nearest);\n        \n        t+= min(h.x, nearest); \n        res=vec4(t,h.yzw);\n        \n    }\n    return res;\n}\n\nvec3 material_city(vec3 p, float night)\n{\n    vec3 col=vec3(0.4,0.6,1.0)*0.15;\n    vec4 res=city(p);\n    if(obj_id==CITY_MENGER)\n    {\n        res.z=1.-res.z;\n        col=(1.2*(1.-night)+0.8)* vec3(.5+res.z*res.z,.3+pow(res.z, 3.), res.z*res.z*0.9);\n        //col=vec3(res.z);  \n\n        if(night>0.5)\n        {\n            if(res.z<.25)\n                col=50.*vec3(1.2,0.3,0.);\n            else if(res.z<0.75)\n                col*=6.;\n        }\n        \n    }\n    else\n    {\n        p.z-=iTime*2.;\n        col+=(1.-smoothstep(0.01,0.025,abs(abs(p.x)-.25)))*vec3(1);\n        col=mix(col,vec3(1.2,0.7,0.),floor(fract(p.z)+.5)*(1.-smoothstep(0.01,0.02,abs(p.x)-0.001)));//*vec3(1);\n        // fake shadow\n        col*=(0.06+smoothstep(0.4,0.6,abs(abs(p.x+0.13)-0.7))); \n        col*=(0.06+smoothstep(0.4,0.6,-p.x+1.47))*vec3(1); \n    }\n    return col;\n}\n\nvec3 city_bg(vec3 ro, vec3 rd, float night)\n{\n    const vec3 moon_col=vec3(0.8,1.,1.);\n    const vec3 moon_dir=vec3(0,0,-1.);    \n    vec3 col;\n    \n    col=vec3(1.)-moon_col*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n\n    if(night>0.)\n        col=vec3(0.)+vec3(0.3,0.,0.)*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    \n    return col;\n}\n\n\nfloat curve(in vec3 p, in float w)\n{\n    vec2 e=vec2(-1., 1.)*w;\n    \n    float t1=city(p+e.yxx).x, t2=city(p+e.xxy).x;\n    float t3=city(p+e.xyx).x, t4=city(p+e.yyy).x;\n    \n    return 0.0125/(w*w)*(t1+t2+t3+t4-4.*city(p).x);\n}\n\nvec4 render_city(vec3 ro, vec3 rd, float night)\n{\n    vec4 res=intersect_city_voxel(ro,rd);\n    vec3 col=city_bg(ro,rd,night);\n\n    if(res.x<CITY_FAR)\n    {\n       // if(city(ro+res.x*rd).x>0.005/res.x)\n         //   res.x=res.w;\n        vec3 pos=ro+res.x*rd;\n        vec3 nor=get_city_normal(pos);\n        vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n        vec3 l1col=vec3(1.2,0.8,0.5);\n        \n        float ao=res.y*res.y;\n        if(obj_id==CITY_ROAD)\n            ao=1.;\n\n        vec3 mate=material_city(pos,night);\n        float dif=max(0.0,dot(nor,l1dir));\n        float bac=max(0.0,dot(nor,-l1dir));\n        float sky=0.5+0.5*nor.y;\n        float spe=pow(max(dot(reflect(-l1dir, nor), -rd), 0.0), 16.0);\n        float crv=clamp(1.-abs(curve(pos,0.0015)),0.,1.);\n\n        vec3 lin=4.0*(1.-night)*dif*l1col*ao;\n        lin+=3.*sky*vec3(0.1,0.2,0.5)*ao;\n        lin+=1.*bac*l1col*ao;\n        lin+=1.*spe*vec3(1.);\n        col=lin*crv*0.2*mate;\n        \n        vec3 skycol=vec3(1.-night);\n        if(rd.z<0.)\n            col=mix(col,vec3(.15,0,0),1.-exp(-0.005*res.x*res.x));\n        else col=mix(col,skycol,1.-exp(-0.001*res.x*res.x));\n       //col=vec3(lin);\n    }\n    return vec4(col,res.x);\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    pixel_size=1.0/(iResolution.y);\n   \n     // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //vec3 ro=vec3(0.,0.9,-2.*iTime)+vec3(cos(y_rot)*cos(x_rot),0.,cos(y_rot)*sin(x_rot))*10.;\n    //vec3 ta=vec3(0.,0.,-2.*iTime);\n   \n    float time=mod(iTime,40.);\n    vec3 ro,ro2;\n    if(time < 20.)\n    {\n        ro=vec3(0.,.9,-9.);\n        ro2=ro;\n        \n        if(time>10.)\n        {\n            ro.xz*=rot(-(time-10.)*0.07);\n        }\n    }\n    else\n    {\n        ro=vec3(0.,.9,9.);\n        ro2=ro;\n    }\n\n    ro.z-=2.*iTime;\n    ro2.z-=2.*iTime;\n    vec3 ta=vec3(0.,0.,-2.*iTime);\n    \n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(r*p.x + u*p.y + f*2.3);\n    \n    vec3 timetunnel=tunnel(rd,-iTime*8.,.05);\n    vec3 menger=render_city(ro2,rd, 1.0-step(0.0,sin(0.05*(iTime+40.-14.)))).xyz;\n    \n    vec3 bg=mix(timetunnel,menger,1.-smoothstep(0.,1.,sin(0.1*(iTime+40.))));\n    vec3 col=render_doraemon(ro,rd,bg);\n    \n    // post processing\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n    fragColor=vec4(col,1.);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}