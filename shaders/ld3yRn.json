{
    "Shader": {
        "info": {
            "date": "1517713799",
            "description": "Voronoi Edge distance function continuous across the whole domain and smooth at non-zero distance.\nSimilar to [url=https://www.shadertoy.com/view/MdByzD]TinyTexel's function[/url].\nCheck also [url=http://polycu.be/edit/?h=X3sd5D]PolyCube edition[/url].\n",
            "flags": 0,
            "hasliked": 0,
            "id": "ld3yRn",
            "likes": 37,
            "name": "Rounder Voronoi Edge Distance",
            "published": 3,
            "tags": [
                "voronoi",
                "worley",
                "distance",
                "smooth"
            ],
            "usePreview": 0,
            "username": "tomkh",
            "viewed": 2574
        },
        "renderpass": [
            {
                "code": "// ST_MODE = \"ShaderToy mode\". Do not undefine. It is here for PolyCube compatibility.\n#define ST_MODE\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// by Tomasz Dobrowolski' 2018\n\n// Use mouse (X/Y) to control two smoothness parameters.\n\n// PolyCube edition:\n// http://polycu.be/edit/?h=X3sd5D\n\n// This is continuation of a quest to formulate\n// smooth and continuous across whole domain\n// distance function to edges of random Voronoi cells.\n\n// I just had a very simple idea today (2018-02-03)\n// how to make this function continuous and smooth\n// at non-zero distance at the same time, and it works!\n// See \"voronoi_rounder\" function for details.\n\n// My previous shader with analysis of discontinuities\n// in Shane's attempt.\n// https://www.shadertoy.com/view/MdSfzD\n\n// Shane's original shader.\n// https://www.shadertoy.com/view/lsSfz1\n\n// My previous attempt to optimize distance to edges.\n// https://www.shadertoy.com/view/llG3zy\n\n// Smooth cell noise function by TinyTexel.\n// https://www.shadertoy.com/view/MdByzD\n\n// Try out generalized assocative smin,\n// based on LogSumExp smooth maximum function\n// https://en.wikipedia.org/wiki/LogSumExp\n// that is generalization over TinyTexel's and IQ's functions.\n#define GENERALIZED_SMIN 0\n\n// Play with some options (1 = enable, 0 = disable).\n#define DOMAIN_DEFORM 0\n#define ANIMATE 1\n\n// How far cells can go off center during animation (must be <= .5)\n#define ANIMATE_D .45\n\n// Points cannot be closer than sqrt(EPSILON)\n#define EPSILON .00001\n\n#ifdef ST_MODE\n#define template_time iTime\n#endif\n\nvec2 hash2(vec2 p)\n{\n    #if 1\n       // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n       vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n       p3 += dot(p3, p3.yzx+19.19);\n       vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n    #else\n       // Texture-based\n       vec2 o = texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    #endif\n    #if ANIMATE\n       o = 0.5 + ANIMATE_D*sin( template_time*.5 + o*6.2831853 );\n    #endif\n   return o;\n}\n\n#if GENERALIZED_SMIN\n\n// Commutative and associative function.\n// It is based on LogSumExp smooth maximum function idea\n// https://en.wikipedia.org/wiki/LogSumExp\n// This one is a generalization of TinyTexels'a and IQ's versions.\n// Set \"bias\" to 1.0 to make it ala TinyTexel's.\n//         or to 0.0 to make it ala IQ's.\nfloat sminRcpExp(float a, float b, float s, float bias)\n{\n    float d = 1.0 / (exp2(a * s) - bias)\n            + 1.0 / (exp2(b * s) - bias);\n   \treturn log2(1.0 / d + bias) / s;\n}\n\nfloat smin(float a, float b, float r)\n{\n    return sminRcpExp(a, b, 4./r, 1.0);\n}\n\n#elif 1\n\n// Commutative smin function taken\n// from Alex Evans aka Statix talk \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// credited to Dave Smith @media molecule\nfloat smin(float a, float b, float r)\n{\n   float f = max(0.,1.-abs(b-a)/r);\n   return min(a,b) - r*.25*f*f;\n}\n\n#else\n\n// A varation that prevents division by zero.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0.,1.-abs(b-a)/max(1e-32,r));\n   return min(a,b) - r*.25*f*f;\n}\n\n#endif\n\n// Smooth abs.\n// This one is equivalent to -smin(x, -x, r) - r*.25\nfloat sabs(float x, float r)\n{\n   float f = max(0.,1.-abs(x + x)/r);\n   return abs(x) + r*.25*(f*f - 1.);\n}\n\n// This is bullet-proof version of finding closest point\n// in 4x4 area around query point \"q\".\n// In fact 12 cells (4x4 without corners) would be enough,\n// but it's less elegant to implement.\n// We pass n=|q|, f=q-n, as an optimization.\nfloat closest( in vec2 n, in vec2 f, out vec2 mr, out vec2 mg )\n{\n    // take half-cell position\n    vec2 h = step(.5,f) - 2.;\n    vec2 n2 = n + h;\n    vec2 f2 = f - h;\n\n    float md = 8.0;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    for( int j=0; j<=3; j++ )\n    for( int i=0; i<=3; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        vec2 o = hash2( n2 + g );\n        vec2 r = g + o - f2;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    mg += h; // return cell position relative to \"n\"\n    \n    return md;\n}\n\n// A continuous and smooth at non-zero distance\n// distance function to Voronoi edges.\n// by Tomasz Dobrowolski' 2018\n// Extending it to 3d (and more) is trivial.\n// x = input coordinate\n// s = smooth min cutoff parameter (smoothness inside cell)\n// e = smooth abs cutoff parameter (smoothness between cells)\nvec3 voronoi_rounder( in vec2 x, in float s, in float e )\n{\n#if DOMAIN_DEFORM\n\tx += sin(x.yx*10.)*.07;\n#endif\n\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mr, mg;\n    float md = closest(n,f,mr,mg);\n\n    //----------------------------------\n    // second pass: distance to edges\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        vec2 o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>EPSILON ) // skip the same cell\n        {\n            float d = dot( 0.5*(mr+r), normalize(r-mr) );\n\n            // The whole trick to get continuous function\n            // across whole domain and smooth at non-zero distance\n            // is to use smooth minimum (as usual)\n            // and multiple smoothness factor by distance,\n            // so it becomes minimum at zero distance.\n            // Simple as that!\n            // If you keep smoothness factor constant (i.e. multiple by \"s\" only),\n            // the distance function becomes discontinuous\n            // (see https://www.shadertoy.com/view/MdSfzD).\n            md = smin(d, md, s*d);\n        }\n    }\n\n    // Totally empirical compensation for\n    // smoothing scaling side-effect.\n    md *= .5 + s;\n\n    // At the end do some smooth abs\n    // on the distance value.\n    // This is really optional, since distance function\n    // is already continuous, but we can get extra\n    // smoothness from it.\n    md = sabs(md, e);\n\n    return vec3( md, mr );\n}\n\n#ifdef ST_MODE\nvec3 plot( vec2 p, float ss )\n{\n#else\nvec3 plot( vec2 p )\n{\n    float ss = template_tr.z;\n#endif\n#ifdef ST_MODE\n    float s = clamp(iMouse.x/iResolution.x,.0,1.)*.95+.05;\n    float e = max(.01,iMouse.y/iResolution.y)*.5;\n    if (length(iMouse.xy) < .5) {\n\t\ts = .5;\n        e = .005;\n    }\n#else\n    const float s = .5;\n    const float e = .01;\n#endif\n    vec3 c = voronoi_rounder(p, s, e);\n\n    const float pd = 40.;\n#if 0\n    vec3 norm = normalize(vec3(dFdx(c.x),dFdy(c.x),ss*1.5));\n    float fw1 = fwidth(c.x);\n#else\n    const vec2 eps = vec2(.001,0);\n    float fdx = (voronoi_rounder(p + eps.xy, s, e).x - c.x)/eps.x;\n    float fdy = (voronoi_rounder(p + eps.yx, s, e).x - c.x)/eps.x;\n    vec3 norm = normalize(vec3(fdx, fdy, 1.5));\n    float fw1 = (abs(fdx) + abs(fdy))*ss;\n#endif\n    float fw2 = fw1*(pd/3.141592653589793*2.7);\n\n    const float f0 = sin(.7/pd);\n    float f = sin(c.x*pd-.7);\n    float od = abs(f);\n    vec3 ldir = normalize(vec3(-.2,-.3,.6));\n    float dd = dot(norm,ldir);\n    float rd = pow(max(0.,reflect(-ldir,norm).z),16.);\n    float ld = dd*dd*.7+.35;\n    float c0 = c.x*.7-step(0.,f)*.05+.6;\n    float c1 = c.x*.7+.33;\n    vec3 col = mix(vec3(c0*ld+rd*.23), vec3(c1*ld), smoothstep(fw2,0.,od)*.7);\n    col = mix(col, vec3(.1,.15,.1), smoothstep(f0+fw1,f0,c.x)*.5);\n    col = sqrt(col)*1.5-.53; // some final grading\n    return col;\n}\n\n#ifdef ST_MODE\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = step(512., iResolution.y)*2. + 3.; // scale differently for fullscreen\n    float ss = sc / iResolution.y; // size of 1 pixel\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) * ss;\n    fragColor = vec4(plot(uv, ss), 1.);\n}\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}