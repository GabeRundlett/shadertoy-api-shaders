{
    "Shader": {
        "info": {
            "date": "1699362656",
            "description": "Managed to recreate a classic optical illusion. Anti-aliasing would be a nice improvement if anyone wants something to do.",
            "flags": 0,
            "hasliked": 0,
            "id": "DttcRS",
            "likes": 18,
            "name": "Sliding circle optical illusion",
            "published": 3,
            "tags": [
                "opticalillusion",
                "moving",
                "vision"
            ],
            "usePreview": 0,
            "username": "thepinkpanzer",
            "viewed": 266
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265\n// converts phase to color\nvec4 color(float t)\n{\n    vec4 c = 0.5 + 0.5*cos(vec4(0, 0.6667*PI, 1.3333*PI, 0)+t);\n    c = tanh(2.5*normalize(c));\n    c*= c;\n    //c/= max(max(c.x, c.y), c.z);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates relative to screen center and direction of travel\n    vec2 centered = fragCoord - iResolution.xy/2.;\n    float d0      = random(floor(iTime*DIRFREQ)*PI);\n    float d1      = random( ceil(iTime*DIRFREQ)*PI);\n    float dd      = d1 - d0;\n    // always ensure we take the shortest path to the next direction (rotate by less than 180 deg)\n    dd            = fract(dd + 0.5);\n    dd           -= 0.5;\n    float theta   = 2.*PI*mix(d0, d0+dd, smoothstep(0.5-MOVETIME, 0.5+MOVETIME, fract(iTime*DIRFREQ)));\n    vec2 direc    = vec2(sin(theta), cos(theta));\n    \n    // background color\n    fragColor = vec4(0.5);\n    \n    // inside the ring\n    if (abs(length(centered) - CIRCLERADIUS) < CIRCLEWIDTH/2.)\n    {\n        // generate padding phase offset\n        float padding = (CIRCLEWIDTH*CIRCLEWIDTH/4.-(length(centered) - CIRCLERADIUS)*(length(centered) - CIRCLERADIUS));\n        padding /= (CIRCLEWIDTH/2.);\n        padding /= PADTHICKNESS;\n        padding  = min(1., padding);\n        // padding = 0 inside the ring\n        padding  = 1.-padding;\n        // padding is a different sign on the inner edge to outer (grad(padding) is the same)\n        padding *= sign(CIRCLERADIUS - length(centered));\n        \n        fragColor = color(CYCLEFREQ*iTime + atan(centered.y, centered.x)+padding*dot(normalize(centered), direc)*PADSTRENGTH);\n    }\n    else if (length(centered) < CIRCLERADIUS)\n    {\n        // inner circle (draw arrow)\n        // normal to direc and rotated-coordinates position\n        vec2 ndirec = vec2(direc.y, -direc.x);\n        vec2 rotpos = vec2(dot(ndirec, centered), dot(direc, centered));\n        \n        bool arrow  = (0.4*CIRCLERADIUS-(rotpos.y) > 2.*abs(rotpos.x) && (rotpos.y) > CIRCLERADIUS/20.) || (abs(rotpos.x) < CIRCLERADIUS/20. && rotpos.y > -0.4*CIRCLERADIUS && rotpos.y < CIRCLERADIUS/19.);\n        \n        \n        if (arrow)\n        {\n            fragColor *= 0.7;\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Size and thickness of the circle\n#define CIRCLERADIUS iResolution.y/3.5\n#define CIRCLEWIDTH  iResolution.y/8.\n// Size of the 'pad' which has a different phase to the rest\n#define PADTHICKNESS 7.\n// Amount by which the pad's phase changes relative to the main ring\n#define PADSTRENGTH  2.\n// Frequency at which directions change, and (half) the fraction of time spent changing directions\n#define DIRFREQ      0.4\n#define MOVETIME     0.3\n// Frequency of colour cycling\n#define CYCLEFREQ    20.\n\nfloat random(float seed)\n{\n    seed  = fract(seed) + 12.14243;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 1.54324;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 1.54324;\n    seed *= 182.4342 - 352.8142*seed;\n    seed  = fract(seed) + 15.4324;\n    return fract(seed*seed);\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}