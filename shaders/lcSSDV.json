{
    "Shader": {
        "info": {
            "date": "1706819248",
            "description": "TEN shaders squeezed into 650 chars ... That's an average of 65 chars per shader!!\nThanks to Smake's DigEggs shader: [url]https://www.shadertoy.com/view/wdlfDH[/url]\nThanks to P Malin's SmallStars [url]https://www.shadertoy.com/view/Ml2XDt[/url]\n",
            "flags": 64,
            "hasliked": 0,
            "id": "lcSSDV",
            "likes": 15,
            "name": "65 char Shaders!",
            "published": 3,
            "tags": [
                "2d",
                "3d",
                "raymarching",
                "short",
                "halftweet",
                "golf",
                "multiple"
            ],
            "usePreview": 0,
            "username": "GregRostami",
            "viewed": 354
        },
        "renderpass": [
            {
                "code": "// TEN shaders squeezed into 650 chars ... That's an average of 65 chars per shader!!\n// This is a fork of my previous shader (SIX Shaders in 487 chars)\n// I tried to combine shaders together in a way that saves chars and embed multiple \n// calculations in one loop for greater efficiency.\n\n// HUGE thanks to Fabrice, Xor, and IQ for helping me golf these shaders. \n\n// I invite all of our fellow code golfers (Fabrice, Xor, Coyote, etc) to combine some of their \n// small shaders in clever ways to reduce the average size per shader ... How LOW can you GO?!\n\n// 65 char Shaders! - 650 chars - iq removed 3 chars, Fabrice removed 1, Greg added 10th shader\n#define L length//\n#define F fract\nvoid mainImage( out vec4 O, vec2 u )\n{  \n    vec4 m, r, o, n, w, f, z,\n         C = vec4(u/=iResolution.x,++o.y,0); // Vec4 used for raymarching shaders\n    float T = r.z = iTime,               // Time\n          i, D,                          // i is the counter for raymarching\n          d = L(u-=.4),\n          a = atan(u.x, u.y), \n          c = ceil(a * 6e2),\n          h = cos(c);\n          f.y = .1*T;\n                                   \n    for (n = sin( T - 8.*C.zzzx / (u.y-.2) ); i++<98.;//Mandelzoom, Black Spheres, Rainbow Spheres loop\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.3*T)) // Calculate Mandelzoom\n          o += C*(L(cos(o.xyz + T)) - .3),                // Raymarch Black Spheres\n          f += C/4. * (.7 - L(O=F (f+f+.5)-.5)),          // Raymarch Rainbow Elevator\n          r += C*(L(cos(r.xyz    )) - .6);                // Raymarch Rainbow Spheres\n          \n    for(;D<texture(iChannel2, u-T/D/i).r; D+=.1);         // Calculate Debris\n    \n    for (ivec3 b; (b.x^b.y^b.z)%99 > b.z-7; )  // Loop for 3D XOR Towers\n        b = ivec3( T + 6.*u*w.x, w+=.1 );\n    \n    O = vec4[](                                // Determine which shader to display\n           d*d/h / exp(F(h/d/d + h*c +T) * i) - z       // SmallStars by P_Malin\n         , o/50.                                        // 3D Black Spheres\n         , texture(iChannel1,vec2(T + .3/d, a))         // 3D Tunnel\n         , max ( u = F( u/d/d-T ), u.x-u ).y + z        // Inversion\n         , m                                            // Mandelzoom\n         , .5 + (n+n.w)/fwidth(n)                       // 3D Checkerboard\n         , F(r+r) - (r.z-T)/30.                         // 3D Rainbow Spheres\n         , O/f.z                                        // 3D Rainbow Elevator\n         , D + z                                        // 3D Debris by Xor\n         , w/74.                                        // 3D XOR Towers\n     ) [int(T-u)/5 %10];  // The transition variable \n}\n\n// 67 char Shaders! - 603 chars - Fabrice removed another char, Greg added a new shader!!!\n/*\n#define L(A) A+=C*(length(cos(A.xyz\n\nvoid mainImage( out vec4 O, vec2 u )\n{  \n    vec4 m, r, o, n, w, f,\n         C = vec4(u/=iResolution.x,++o.y,0); // Vec4 used for raymarching Sphere shaders\n    float T = r.z = iTime,               // Time\n          i,                             // i is the counter for raymarching\n          d = dot(u-=.4,u),\n          a = atan(u.x, u.y), \n          c = ceil(a * 6e2),\n          h = cos(c);\n          f.y = .1*T;\n                                   \n    for (n = sin( T - 8.*C.zzzx / (u.y-.2) ); i++<98.;//Loop for Mandelzoom, Black Spheres, & Rainbow Spheres\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.3*T)) // Calculate Mandelzoom\n          L(o) + T)) - .3),                               // Raymarch Black Spheres\n          f += C/4. * (.7 - length(O=fract(f+f+.5)-.5)),  // Raymarch Rainbow Elevator\n          L(r)    )) - .6);                               // Raymarch Rainbow Spheres\n    \n    for (ivec3 b; (b.x^b.y^b.z)%99 > b.z-7; )  // Loop for 3D XOR Towers\n        b = ivec3( T + 6.*u*w.x, w+=.1 );\n    \n    O = vec4[](                                // Determine which shader to display\n           d/h / exp(fract(h/d + h*c +T) * 1e2) - C       // Star field\n         , o/50.                                          // 3D Black Spheres\n         , texture(iChannel1,vec2(T + .3/sqrt(d), a))     // 3D Tunnel\n         , max ( u=fract( u/d-T ), u.x-u ).yyyy           // Inversion\n         , .5 + (n+n.w)/fwidth(n)                         // 3D Checkerboard\n         , m                                              // Mandelzoom\n         , fract(r+r) - (r.z-T)/30.                       // 3D Rainbow Spheres\n         , w/74.                                          // 3D XOR Towers\n         , O/f.z                                          // 3D Rainbow Elevator\n     ) [int(T-u)/5 %9];  // The transition variable \n}\n*/\n\n// 69 char Shaders! - 547 chars - IQ removed 4 chars and Fabrice removed another 7 chars!!!\n/*\n#define L(A) A+=C*(length(cos(A.xyz\n\nvoid mainImage( out vec4 O, vec2 u )\n{  \n    vec4 m, r, o, n, w,\n         C = vec4(u/=iResolution.x,o.y=1.,0); // Vec4 used for raymarching Sphere shaders\n    float T = r.z = iTime,               // Time\n          i,                             // i is the counter for raymarching\n          d = dot(u-=.4,u),\n          a = atan(u.x, u.y), \n          c = ceil(a * 6e2),\n          h = cos(c);\n                                   \n    for ( n = sin( T - 8.*C.zzzx / (u.y-.2) ); i++<98.;   // Loop for Mandelzoom, Black Spheres, & Rainbow Spheres\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.4*T))   // Calculate Mandelzoom\n          L(o) + T)) - .3),                // Raymarch Black Spheres\n          L(r)    )) - .6);                // Raymarch Rainbow Spheres\n    \n    for (ivec3 b; (b.x^b.y^b.z)%99 > b.z-7; )  // Loop for 3D XOR Towers\n        b = ivec3( T + 6.*u*w.x, w+=.1 );\n    \n    O = vec4[](                                // Determine which shader to display\n           d/h / exp(fract(h/d + h*c +T) * 1e2) - C       // Star field\n         , o/50.                                          // 3D Black Spheres\n         , texture(iChannel1,vec2(T + .3/sqrt(d), a))     // 3D Tunnel\n         , max ( u=fract( u/d-T ), u.x-u ).yyyy           // Inversion\n         , .5 + (n+n.w)/fwidth(n)                         // 3D Checkerboard\n         , m                                              // Mandelzoom\n         , fract(r+r) - (r.z-T)/30.                       // 3D Rainbow Spheres\n         , w/74.                                          // 3D XOR Towers\n     ) [int(T-u)/5 %8];  // The transition variable \n}\n*/\n\n// 70 char Shaders! Fabrice reduced the shader to 559 chars total.\n/*\nvoid mainImage (out vec4 O, vec2 u)\n{  \n    vec3 m, r, o, n,\n         C = vec3(u/=iResolution.x, 1); // Vec3 used for raymarching Sphere shaders\n    u -= .4;                            // Offset u by 0.4        \n    float T = iTime,                    // Time\n          i,                            // i is the counter for raymarching\n          a = atan(u.x, u.y),           // set up arc tangent for polar coordinates \n          d = dot(u,u),\n          b = ceil(a * 6e2), h = cos(b);\n          n = sin( T - 8.*C.zzx / (u.y-.2) ); // Calculate 3D Checkerboard pattern\n                             \n    O *= i;                                   // Initialize O (fragColor) to 0.0\n    r.z = T;                                  // Move Z variable for Rainbow Spheres\n    \n    for ( o.y++; i++<98.;   // Loop for Mandelzoom, Black Spheres, & Rainbow Spheres\n          o += C * (length (cos (o + T)) - .3) )            // Raymarch Black Spheres\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.4*T),   // Calculate Mandelzoom\n          r += C * (length (cos (r)) - .6);                 // Raymarch Rainbow Spheres\n    \n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )               // Loop for 3D XOR Towers\n        b = ivec4 ( T + 6.*u*O.a, O+=.1 );\n        \n    O.rgb = vec3[](                                         // Determine which shader to display\n           d/h / exp(fract(h/d + h*b +T) * 1e2) - C         // Star field\n         , o/50.                                            // 3D Black Spheres\n         , texture(iChannel1,vec2(T + .3/length(u), a)).rgb // 3D Tunnel\n         , max ( u = fract( u/d-T ), u.x-u ).yyy            // Inversion\n         , .5 + (n+n.b)/fwidth(n)                           // 3D Checkerboard\n         , m                                                // Mandelzoom\n         , fract(r+r-T) - (r.z-T)/30.                         // 3D Rainbow Spheres\n         , O.rgb / 74.                                      // 3D XOR Towers\n     ) [int(T-u)%50/5];  // The transition variable \n}\n*/\n\n// 75 char shader! - 595 chars - Original Shader\n/*\nvoid mainImage (out vec4 O, vec2 u)\n{  \n    vec3 m, r, o, n,\n         C = vec3(u/=iResolution.x, 1); // Vec3 used for raymarching Sphere shaders\n    u -= .4;                            // Offset u by 0.4\n         \n    float T = iTime,                    // Time\n          t = fract (.02*(T-u.x)),      // Time wipe transition variable\n          i,                            // i is the counter for raymarching\n          a = atan(u.x, u.y),\n          d = dot(u,u),\n          b = ceil(a * 6e2), h = cos(b), z = h / d;\n                                  \n    n = sin( T - 8.*C.zzx / (u.y-.2) ); // Calculate 3D Checkerboard pattern\n    O *= i;                             // Initialize O (fragColor) to 0.0\n    r.z = T;\n    \n    for ( o.y++; i++<98.;   // Loop for Mandelzoom, Black Spheres, & Rainbow Spheres\n          o += C * (length (cos (o + T)) - .3) )           // Raymarch Black Spheres\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.4*T),  // Calculate Mandelzoom\n          r += C * (length (cos (r)) - .6);                // Raymarch Rainbow Spheres\n    \n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )              // Loop for 3D XOR Towers\n        b = ivec4 ( T + 6.*u*O.a, O+=.1 );\n        \n    O.rgb =                                                   // Determine which shader to display\n        t < .1 ? exp(fract(z + h * b + C-C+T) * -1e2) / z     // Star field\n      : t < .2 ? o/50.                                        // 3D Black Spheres\n      : t < .3 ? max ( u = fract( u/d-T ), u.x-u ).yyy        // Inversion\n      : t < .4 ? .5 + (n+n.b)/fwidth(n)                       // 3D Checkerboard\n      : t < .5 ? m                                            // Mandelzoom\n      : t < .7 ? fract(r+r) - (r.z-T)/30.                     // 3D Rainbow Spheres\n      :(t < .8 ? texture(iChannel1,vec2(T + .3/length(u), a)) // 3D Tunnel\n      : O / 74.).rgb;                                         // 3D XOR Towers\n}\n*/\n\n//Code without comments:\n/*\nvoid mainImage (out vec4 O, vec2 u) {  \n    vec3 m, r, o, n, C = vec3(u/=iResolution.x, 1); u -= .4;                                   \n    float T = iTime, i, a = atan(u.x, u.y),           \n          d = dot(u,u), b = ceil(a * 6e2), h = cos(b);\n          n = sin( T - 8.*C.zzx / (u.y-.2) );         \n    O *= i; r.z = T;\n    for ( o.y++; i++<98.; o += C * (length (cos (o + T)) - .3) )\n          m.xy = .55 - mat2(-m.y,m.x,m)*m.yx+u*cos(.4*T),\n          r += C * (length (cos (r)) - .6);\n    for (ivec4 b; (b.x^b.y^b.z)%99 > b.z-7; )\n        b = ivec4 ( T + 6.*u*O.a, O+=.1 );      \n    O.rgb = vec3[](d/h / exp(fract(h/d + h*b +T) * 1e2) - C, o/50.\n         , texture(iChannel1,vec2(T + .3/length(u), a)).rgb\n         , max ( u = fract( u/d-T ), u.x-u ).yyy\n         , .5 + (n+n.b)/fwidth(n), m, fract(r+r) - (r.z-T)/30., O.rgb / 74.\n         ) [int(T-u)%50/5]; }\n*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 9,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 35920,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/claude-debussy/clair-de-lune"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}