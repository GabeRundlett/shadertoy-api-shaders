{
    "Shader": {
        "info": {
            "date": "1668270895",
            "description": "Playing with neon attenuation, space repetition, randomness and camera movement",
            "flags": 0,
            "hasliked": 0,
            "id": "msj3D3",
            "likes": 98,
            "name": "Inside the System",
            "published": 3,
            "tags": [
                "raymarching",
                "illumination",
                "random",
                "space",
                "repetition",
                "glow",
                "infinite",
                "neon"
            ],
            "usePreview": 0,
            "username": "kishimisu",
            "viewed": 3311
        },
        "renderpass": [
            {
                "code": "/* \"Inside the System\" by @kishimisu (2022) - https://www.shadertoy.com/view/msj3D3\n   \n   This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)\n\n   3 torus, 3 lights, infinite domain repetition.\n   Mouse interactive.\n   \n   I got inspired to create this after seeing\n   https://www.shadertoy.com/view/3dlcWl which \n   plays with similar neon colors. The key equation that\n   allow this intensity fallout is 1./(1. + pow(abs(d), n))\n*/\n\n#define LOW_PERF      0   // set to 1 for better performances\n\n// spacing controls\n#define spacing       7.  // columns repetition spacing\n#define light_spacing 2.  // light   repetition spacing (try 1. for a psychedelic effect!)\n\n#define attenuation  22.  // light   attenuation\n\n// speed controls\n#define GLOBAL_SPEED  .7\n#define camera_speed  1.\n#define lights_speed 30.\n#define columns_speed 4.\n\n#if LOW_PERF\n    #define iterations 30.\n    #define max_dist   30.\n#else\n    #define iterations 50.\n    #define max_dist   80.\n#endif\n\n#define epsilon 0.005\n#define iTime (iTime*GLOBAL_SPEED)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rep(p, r) (mod(p+r/2., r)-r/2.)\n#define torus(p) (length( vec2(length(p.xz)-.6,p.y) ) - .06)\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 getLight(vec3 p, vec3 color) {\n    return max(vec3(0.), color / (1. + pow(abs(torus(p) * attenuation), 1.3)) - .001);\n}\n\nvec3 geo(vec3 po, inout float d, inout vec2 f) {\n    // shape repetition\n    float r = hash12(floor(po.yz/spacing+vec2(.5)))-.5;\n    vec3  p = rep(po + vec3(iTime*r*columns_speed, 0., 0.), vec3(.5, spacing, spacing));\n    p.xy   *= rot(1.57);\n    d       = min(d, torus(p));\n    \n    // light repetition\n    f       = floor(po.yz/(spacing*light_spacing)-vec2(.5));\n    r       = hash12(f)-.5;\n    if (r > -.45) p = rep(po + vec3(iTime*lights_speed*r, 0., 0.), spacing*light_spacing*vec3(r+.54, 1., 1.));\n    else p  = rep(po + vec3(iTime*lights_speed*.5*(1.+r*0.003*hash12(floor(po.yz*spacing))), 0., 0.), spacing*light_spacing);\n    p.xy   *= rot(1.57);\n    f       = (cos(f.xy)*.5+.5)*.4;\n    \n    return p;\n}\n\nvec4 map(vec3 p) {\n    float d = 1e6;\n    vec3 po, col = vec3(0.);\n    vec2 f;\n    \n    po = geo(p, d, f);\n    col  += getLight(po, vec3(1., f));        // x\n    \n    p.z  += spacing/2.;\n    p.xy *= rot(1.57);\n    po    = geo(p, d, f);\n    col  += getLight(po, vec3(f.x, .5, f.y)); // y\n    \n    p.xy += spacing/2.;\n    p.xz *= rot(1.57);\n    po    = geo(p, d, f);\n    col  += getLight(po, vec3(f, 1.));        // z\n     \n    return vec4(col, d);\n}\n\nvec3 getOrigin(float t) {\n    t = (t+35.)*-.05*camera_speed;\n    float rad = mix(50., 80., cos(t*1.24)*.5+.5);\n    return vec3(rad*sin(t*.97), rad*cos(t*1.11), rad*sin(t*1.27));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    vec2 m = iMouse.xy/iResolution.xy*2.-1.; \n    \n    ro = getOrigin(iTime+m.x*10.);\n    \n    vec3 f = normalize(getOrigin(iTime+m.x*10.+.5) - ro);    \n    vec3 r = normalize(cross(normalize(ro), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n\nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col;\n    \n    initRayOriginAndDirection(uv, ro, rd);\n    \n    float t = 2.;\n    for (float i = 0.; i < iterations; i++) {\n        p = ro + t*rd;\n        \n        vec4 res = map(p);\n        col += res.rgb;\n        t += abs(res.w);\n\n        if (abs(res.w) < epsilon) t += epsilon;\n        \n        if (col.r >= 1. && col.g >= 1. && col.b >= 1.) break;\n        if (t > max_dist) break;\n    }\n            \n    col = pow(col, vec3(.45));\n    O = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}