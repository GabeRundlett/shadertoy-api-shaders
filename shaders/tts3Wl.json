{
    "Shader": {
        "info": {
            "date": "1558116542",
            "description": "testing three methods of calculating distance^2.\nMouse:\nY = num iters. max = 1e5.\nx1 -> dot(a-b, a-b)\nx2 -> dot(tmp, tmp)\nx3 -> length(a-b)^2\nx4 -> length(a-b)",
            "flags": 0,
            "hasliked": 0,
            "id": "tts3Wl",
            "likes": 2,
            "name": "dist squared speed tests",
            "published": 3,
            "tags": [
                "speed",
                "lengthsquared"
            ],
            "usePreview": 0,
            "username": "elenzil",
            "viewed": 523
        },
        "renderpass": [
            {
                "code": "float triWave(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 center = iResolution.xy / 2.0;\n    \n    float chunk = iResolution.y / 10.0;\n    float My = float(int(iMouse.y / chunk + 0.5)) * chunk;\n    \n    const float maxIters = 1e5;\n    \n    // on some platforms (iOS ShaderToy app, eg), iMouse.y can be < 0,\n    // so do max(1, ..) instead of (1 + ..).\n    int numIters = max(1, int(My / iResolution.y * maxIters));\n    float scale = 1.0;\n    \n    float f = 0.0;\n    if (iMouse.x < iResolution.x / 4.0 * 1.0) {\n        for (int n = 0; n < numIters; ++n) {\n            f = dot(XY - center, XY - center);\n        }\n        scale = 0.00011;\n    }\n    else if (iMouse.x < iResolution.x / 4.0 * 2.0) {\n        for (int n = 0; n < numIters; ++n) {\n            vec2 tmp = XY - center;\n            f = dot(tmp, tmp);\n        }\n        scale = 0.00012;\n    }\n    else if (iMouse.x < iResolution.x / 4.0 * 3.0) {\n        for (int n = 0; n < numIters; ++n) {\n            f = length(XY - center);\n            f *= f;\n        }\n        scale = 0.00013;\n    }\n    else {\n        for (int n = 0; n < numIters; ++n) {\n            f = length(XY - center);\n        }\n        scale = 0.05;\n    }\n    \n    \n    f *= scale;\n    f = 0.8 + 0.04 * smoothstep(0.4, 0.6, triWave(f));\n    \n    RGBA = vec4(vec3(f), 1.0);\n    \n    // bar rising once per frame\n    RGBA.rgb = mix(RGBA.rgb, vec3(1.0, 0.3, 0.0), 0.8 * smoothstep(3.0, 0.0, abs(mod(float(iFrame), iResolution.y) - XY.y)));\n    \n    // segment dividers\n    RGBA.rgb = mix(RGBA.rgb, vec3(0.3, 0.0, 0.0), 0.2 * smoothstep(4.0, 3.0, mod(2.0 + XY.x, iResolution.x / 4.0)));\n    \n    // framerate meter\n    vec3 tmp = mix(vec3(1.0), vec3(0.0, 0.5, 0.9), smoothstep(1.5, -1.5, XY.x - (iFrameRate / 60.0 * iResolution.x)));\n    RGBA.rgb = mix(RGBA.rgb, tmp, float(XY.y < 10.0));\n\n    // vert. mouse\n    RGBA.rgb = mix(RGBA.rgb, vec3(0.3, 0.0, 0.0), 0.2 * smoothstep(3.0, 0.0, abs(XY.y - My)));\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}