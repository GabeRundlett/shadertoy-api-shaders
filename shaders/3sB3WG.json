{
    "Shader": {
        "info": {
            "date": "1549822308",
            "description": "Orthogonal ellipsoidal coordinates on the ellipsoid (i.e. 3rd coordinate = 0).\nTune ellipsoid radii (a,b,c) and number of subdiv n.\ncf [url]https://en.wikipedia.org/wiki/Ellipsoidal_coordinates[/url]\n[url]https://www.desmos.com/calculator/nm8yvhj5zi[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3sB3WG",
            "likes": 14,
            "name": "ellipsoidal confocal coordinates",
            "published": 3,
            "tags": [
                "raymarching",
                "ellipsoid",
                "short",
                "confocal"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "// fork from https://www.shadertoy.com/view/4lBczR\n\nconst float a = 2., b = 1.5, c = 1., n=8.;               // ellipsoid\nconst vec3 Rell = vec3(a,b,c);\n    \nvoid mainImage(out vec4 O, vec2 U) {                     // === render cube\n    float t = iTime, s =  10.; \n    vec3  q = iResolution, \n          D = normalize( vec3( (U+U-q.xy)/q.y, -8) ),    // ray direction (normalized)\n          p = 1.5*s/q, N, H,                             // p: ray origin\n          L = vec3(0,0,1);                               // light direction (normalized)\n    mat2  R = mat2( sin(t+1.57*vec4(1,2,0,1)) );         // animation\n    L.xz *= R; L.yz *= R;                                // to object frame\n    p.xz *= R; p.yz *= R;                                //   ( turntable: can factor rot out of ray loop )\n    D.xz *= R; D.yz *= R;\n\n    for (int i=0; i<50; i++) {                           // --- ray march\n        t = length( p / Rell ) - 1.;                     // distance to ellipsoid\n        if (t < .01) { s=0.; break; }                    // hit\n        p += t*D;                                        // step forward by dist\n    }\n\n    O -= O;\n    if (s==0.) {                                         // --- if hit\n        p = normalize(p/Rell) * Rell;                    // reproject on ellipsoid for precision\n        \n        float a2 = a*a, b2 = b*b, c2 = c*c,\n              a4 = a2*a2, b4 = b2*b2,                    // ellispoidal coordinates https://en.wikipedia.org/wiki/Ellipsoidal_coordinates\n            X = p.x*p.x / a2 *(a2-b2)*(a2-c2), \n            Y = p.y*p.y / b2 *(b2-a2)*(b2-c2),\n            s = (Y-X -b4+a4) / (b2-a2),\n            m = X -a4 -a2*s,\n            d = s*s-4.*m,\n            u0 = (s+sqrt(d))/2., v0 = s-u0;              // ellipsoidal coordinates\n                                                         // draw them:\n        u0 = (-u0 - c2)/(b2-c2);                         // normalized on [0,1]\n        v0 = (-v0 - b2)/(a2-b2);\n#if 0   // integer isos\n        O = vec4(floor(u0*n)/(n-1.),floor(v0*n)/(n-1.),0,0); \n#  define S(v) smoothstep( 0., .1, abs(fract(v+.5)-.5) )\n#else   // half-int isos\n        O = vec4(round(u0*n)/n,round(v0*n)/n,0,0); \n#  define S(v) smoothstep( 0., .1, abs(fract(v)-.5) )\n#endif\n        O *= min(S(u0*n),S(v0*n));\n      //O *= smoothstep( 0., .01, abs(v0*n) );\n      //O = vec4(1.-S(u0*n),1.-S(v0*n),0,0); O += 1.-max(O.r,O.g);\n\n        N = normalize(p/(Rell*Rell));                    // Normal\n        O *= (.3 + .7 * max( 0., dot(N,L) ));            // ambiant + diffuse\n        H = normalize(L-D); \n        O += pow( max( 0., dot(N,H) ), 200.);            // specular\n    }\n    else O = vec4(.3);                                   // background\n}\n\n\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}