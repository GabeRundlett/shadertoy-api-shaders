{
    "Shader": {
        "info": {
            "date": "1524571128",
            "description": "( see next versions for color )\ndefine 3 polylines for the 6 brick segments:\n .---1---.---2---.\n |                   |\n 3                 3\n |                   |\n .---2---.---1---.\n",
            "flags": 0,
            "hasliked": 0,
            "id": "MstBR7",
            "likes": 2,
            "name": "escherized tiling 1",
            "published": 3,
            "tags": [
                "escher",
                "pattern",
                "tile",
                "mz"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 537
        },
        "renderpass": [
            {
                "code": "float  CELL = 10.,                  // grid size vertically -> cell size\n      RATIO = 2.,                  // brick length / brick width\n      BEVEL = .1,                  // bevel width ( cell %  )\n       GAP  = 0.;                  // inter brick gap ( cell % )\n//vec2  CYCLE = vec2(0);             // pattern repeat scale ( in #brick )     \n//bool  BRICK = true;                // tiling or bricks\n\n// .---1---.---2---.\n// |               |\n// 3               3\n// |               |\n// .---2---.---1---.\n// polylines must pass to corners and mid-side of brick.\nvec2 polyline1[] = vec2[]( vec2(0,0), vec2(.25,.1), vec2(.75,-.1),vec2(1,0) );\nvec2 polyline2[] = vec2[]( vec2(0,0), vec2(.25,.3), vec2(.5,.1), vec2(.75,-.3),vec2(1,0) );\nvec2 polyline3[] = vec2[]( vec2(0,0), vec2(.1,-.25), vec2(0,-.4), vec2(-.1,-.75),vec2(0,-1) );\n\nfloat line( vec2 p, vec2 a, vec2 b )\n{\n    p -= a; b -= a;\n\tfloat h = dot(p,b)/dot(b,b),   // projection index on line in [0,1]\n         hs = clamp( h, 0., 1. ); \n\treturn length( p - b*hs );     // with round edges\n  //return h==hs ? length( p - b*hs ) : 1e5; // without round edge\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy; U /= R.y;          // normalized coordinates \n    O -= O;\n    vec2 W = vec2(RATIO,1);                     // normalize in cells units\n    U *= CELL/W;\n    BEVEL = 1.5*CELL/R.y;                       // <- for demo\n    \n    //if (BRICK) \n        U.x += .5* mod(floor(U.y),2.);\n    //ivec2 H = ivec2( CYCLE==vec2(0) ? U : mod(U,CYCLE) ); // vec2 tile id\n    //float id = hash3(uvec3(H,2)).r;\n    vec2 S = W* (fract(U) - 1./2.);             // centered coords in a brick\n\n    float d = 1e5;\n    for (int i=0; i < polyline1.length()-1; i++) {\n        d = min( d, line( S-vec2(-1, .5), polyline1[i], polyline1[i+1])) ; \n        d = min( d, line( S-vec2( 0,-.5), polyline1[i], polyline1[i+1])) ;\n      //d = min( d, line( S-vec2( 1, .5), polyline1[i], polyline1[i+1])) ; \n      //d = min( d, line( S-vec2(-2,-.5), polyline1[i], polyline1[i+1])) ;\n    }\n    for (int i=0; i < polyline2.length()-1; i++) {\n        d = min( d, line( S-vec2( 0, .5), polyline2[i], polyline2[i+1])) ; \n        d = min( d, line( S-vec2(-1,-.5), polyline2[i], polyline2[i+1])) ; \n    }\n    for (int i=0; i < polyline3.length()-1; i++) {\n        d = min( d, line( S-vec2( 1, .5), polyline3[i], polyline3[i+1])) ; \n        d = min( d, line( S-vec2(-1, .5), polyline3[i], polyline3[i+1])) ; \n    }\n    O += clamp ( (d-GAP)/BEVEL, 0., 1.); \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}