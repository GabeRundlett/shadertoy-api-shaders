{
    "Shader": {
        "info": {
            "date": "1591414479",
            "description": "Fork of \"10 years old nattou\" by tomohiro\nhttps://www.shadertoy.com/view/MtGGWc\n\nMain changes:\n- Use original noise result to mix between two colors\n---- colors determined by relative mouse coords as the hue\n- move long skewF() comment to end of file",
            "flags": 0,
            "hasliked": 0,
            "id": "WllyR8",
            "likes": 5,
            "name": "mouseworms",
            "published": 3,
            "tags": [
                "2d",
                "simplexnoise"
            ],
            "usePreview": 0,
            "username": "kowbell",
            "viewed": 420
        },
        "renderpass": [
            {
                "code": "// /////////////////////////////////////////////////////////////////////////////\n// HSV/RGB by iq, MIT License: https://www.shadertoy.com/view/lsS3Wc\n// /////////////////////////////////////////////////////////////////////////////\n\nconst float eps = 0.0000001; vec3 hsv2rgb( in vec3 c ){ vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 ); return c.z * mix( vec3(1.0), rgb, c.y); } vec3 rgb2hsv( in vec3 c) { vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0); vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0); vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0); float d = q.x - min(q.w, q.y); return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x); }\n\n// /////////////////////////////////////////////////////////////////////////////\n// Fork of \"10 years old nattou\" by tomohiro\n// https://www.shadertoy.com/view/MtGGWc\n//\n// Main changes:\n// - Use original noise result to mix between two colors\n// ---- colors determined by relative mouse coords as the hue\n// - move long skewF() comment to end of file\n// /////////////////////////////////////////////////////////////////////////////\n\n//Number of layers.\n//Higher value shows more layers of effects.\n//Lower value higher FPS.\nconst int numLayers = 16;\n\n//Length of worm\nconst int wormLength = 8;\n\n//Write output color from anywhere to see value of temporary variable.\nvec3 cout;\n\nfloat rand(vec3 pos)\n{\n\tvec3 p = pos + vec3(2.);\n\tvec3 fp = fract(p*p.yzx*222.)+vec3(2.);\n\tp.y *= p.z * fp.x;\n\tp.x *= p.y * fp.y;\n\treturn\n\tfract\n\t(\n\t\tp.x*p.x\n\t);\n}\n\nfloat skewF(float n)\n{\n\treturn (sqrt(n + 1.0) - 1.0)/n;\n}\n\nfloat unskewG(float n)\n{\n\treturn (1.0/sqrt(n + 1.0) - 1.0)/n;\n}\n\nvec2 smplxNoise2DDeriv(vec2 x, float m, vec2 g)\n{\n\tvec2 dmdxy = min(dot(x, x) - vec2(0.5), 0.0);\n\tdmdxy = 8.*x*dmdxy*dmdxy*dmdxy;\n\treturn dmdxy*dot(x, g) + m*g;\n}\n\nfloat smplxNoise2D(vec2 p, out vec2 deriv, float randKey, float roffset)\n{\n\t//i is a skewed coordinate of a bottom vertex of a simplex where p is in.\n\tvec2 i0 = floor(p + vec2( (p.x + p.y)*skewF(2.0) ));\n\t//x0, x1, x2 are unskewed displacement vectors.\n\tfloat unskew = unskewG(2.0);\n\tvec2 x0 = p - (i0 + vec2((i0.x + i0.y)*unskew));\n\n\tvec2 ii1 = x0.x > x0.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\tvec2 ii2 = vec2(1.0);\n\n//  vec2 i1 = i0 + ii1;\n//  vec2 x1 = p - (i1 + vec2((i1.x + i1.y)*unskew));\n//          = p - (i0 + ii1 + vec2((i0.x + i0.y + 1.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii1 - vec2(1.0)*unskew;\n\tvec2 x1 = x0 - ii1 - vec2(unskew);\n//  vec2 i2 = i0 + ii2;\n//  vec2 x2 = p - (i2 + vec2((i2.x + i2.y)*unskew));\n//          = p - (i0 + ii2 + vec2((i0.x + i0.y + 2.0)*unskew));\n//          = p - (i0 + vec2((i0.x + i0.y)*unskew)) - ii2 - vec2(2.0)*unskew;\n\tvec2 x2 = x0 - ii2 - vec2(2.0*unskew);\n\n\tvec3 m = max(vec3(0.5) - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n\tm = m*m;\n\tm = m*m;\n\n\tfloat r0 = 3.1416*2.0*rand(vec3(mod(i0, 16.0)/16.0, randKey));\n\tfloat r1 = 3.1416*2.0*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey));\n\tfloat r2 = 3.1416*2.0*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey));\n\n\tfloat randKey2 = randKey + 0.01;\n\tfloat spmin = 0.5;\n\tfloat sps = 2.0;\n\tfloat sp0 = spmin + sps*rand(vec3(mod(i0, 16.0)/16.0, randKey2));\n\tfloat sp1 = spmin + sps*rand(vec3(mod(i0 + ii1, 16.0)/16.0, randKey2));\n\tfloat sp2 = spmin + sps*rand(vec3(mod(i0 + ii2, 16.0)/16.0, randKey2));\n\n\tr0 += iTime*sp0 + roffset;\n\tr1 += iTime*sp1 + roffset;\n\tr2 += iTime*sp2 + roffset;\n\t//Gradients;\n\tvec2 g0 = vec2(cos(r0), sin(r0));\n\tvec2 g1 = vec2(cos(r1), sin(r1));\n\tvec2 g2 = vec2(cos(r2), sin(r2));\n\n\tderiv = smplxNoise2DDeriv(x0, m.x, g0) + smplxNoise2DDeriv(x1, m.y, g1) + smplxNoise2DDeriv(x2, m.z, g2);\n\treturn dot(m*vec3(dot(x0, g0), dot(x1, g1), dot(x2, g2)), vec3(1.0));\n//    return dot(m*vec3(length(x0), length(x1), length(x2)), vec3(1.0));\n}\n\nvec3 norm(vec2 deriv)\n{\n\tderiv *= 2000.0;\n\tvec3 tx = vec3(1.0, 0.0, deriv.x);\n\tvec3 ty = vec3(0.0, 1.0, deriv.y);\n\treturn normalize(cross(tx, ty));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n\n\tvec3 color = vec3(0.0);\n\tfloat s = 1.0;\n\tfor(int i=0; i<numLayers; ++i)\n\t{\n\t\tfloat sn = 0.0;\n\t\tfloat y = 0.0;\n\t\t\n\t\tvec2 deriv;\n\t\tfloat nx = smplxNoise2D(uv*s*4.0, deriv, 0.1+1./s, 0.0);\n\t\tfloat ny = smplxNoise2D(uv*s*4.0, deriv, 0.11+1./s, 0.0);\n\t\tfor(int j=0; j<wormLength; ++j)\n\t\t{\n\t\t\tvec2 deriv;\n\n\t\t\tsn += smplxNoise2D(uv*s+vec2(1./s, 0.)+vec2(nx,ny)*4., deriv, 0.2+1./s, y);\n\t\t\tcolor += vec3(norm(deriv).z)/s;\n\t\t\ty += 0.1;\n\t\t}\n\t\ts *= 1.1;\n\t}\n\tcolor /= 4.;\n\n\tvec2 deriv;\n\tfloat delay = smplxNoise2D(uv*s*1.0, deriv, 0.111, 0.0);\n\tcolor = mix(color, vec3(1.0) - color, clamp(sin(iTime*0.25+uv.x*0.5+delay*32.)*32., 0.0, 1.0));\n\n\tcout = color;\n\t\n\t\n\tfloat rgb = color.r * color.g * color.b;\n\t\n\t\n\tfloat mouseX = iMouse.x/iResolution.x;\n\tfloat mouseY = iMouse.y/iResolution.y;\n    \n    // offset mouseX a bit so when you start it isn't just red\n    // (mouse.x and mouse.y are 0 at start)\n    mouseX += 0.2;\n\t\n\tvec3 colA = hsv2rgb(vec3(mouseX*2., 1., 1.));\n\tvec3 colB = hsv2rgb(vec3(mouseY*1., 1., 1.));\n\t\n\tcout = mix( colA, colB, rgb);\n\n\tfragColor = vec4(cout, 1.0);\n}\n\n\n// Original comment from skewF()\n/*\nn∈N\nX∈R^n\nX'∈R^n\nA∈R^n ∧ |A| = 1\ns∈R\nf is a non-uniform scaling along direction A and s is the scaling factor.\nf:R^n → R^n\nX' = f(X)\n   = X・A*s*A - X・A*A + X\n   = X・A*(s-1)*A + X\n\n∀B(B∈R^n ∧ B・A = 0 ⇒ f(X)・B = X)\n\nX' = f^-1(X)\n   = X・A*(1/s-1)*A + X\n\nf^-1(f(X)) = X\nX' = X・A*(s-1)*A + X\nX = X'・A*(1/s-1)*A + X'\n  = (X・A*(s-1)*A + X)・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(s-1)*(A・A)*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X・A*(1-s-1/s+1)*A          + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = -X・A*(s-1)*A - X・A*(1/s-1)*A + X・A*(1/s-1)*A + X・A*(s-1)*A + X\n  = X\n\nWhen creating simplex noise, A is a unit vector parallel to a unit hypercube's longest diagonal.\nA = (1/√(n), 1/√(n), ...)\n  = 1/√(n)(1, 1, ...)\n\nX' = f(X) = (s-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nIn skewed coordinate system, basis is not orthogonal.\nAny points P in skewed coordinate system such that P∈Z^n become a vertex of a simplex.\nIn the Cartesian coordinate, all edge of a simplex should have a same length.\nBut it is not possible in 3D and higher dimension.\nEquilateral triangle alone can fill space, but regular tetrahedra alone do not.\nFind 's' such that |f^-1((1, 0, 0, ...))| = |f^-1((1, 1, 1, ...))|\n|(1/s-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)/n*(1, 1, ...)・(1, 1, ...)*(1, 1, ...) + (1, 1, 1)|\n|(1/s-1)/n*(1, 1, ...) + (1, 0, 0, ...)| = |(1/s-1)*(1, 1, ...) + (1, 1, 1)|\n((1/s-1)/n+1)^2 + (((1/s-1)/n)^2)*(n-1) = ((1/s)^2)*n\n(1/s-1)*(1/s-1)/(n*n)+ 2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*(n-1)/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)*n/(n*n) = n/(s*s)\n2*(1/s-1)/n + 1 + (1/s-1)*(1/s-1)/n = n/(s*s)\n(1/s-1)/n*(2 + (1/s-1)) + 1 = n/(s*s)\n(1/s-1)/n*(1 + 1/s) + 1 = n/(s*s)\n(1-s)/n*(s + 1) + s*s = n\n(1-s)*(s + 1) + s*s*n = n*n\n(n-1)*s*s + 1 = n*n\ns*s = (n*n - 1)/(n-1) = (n+1)(n-1)/(n-1) = n+1\ns = sqrt(n+1)\n\nX' = f(X) = (√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\nf^-1(X) = (1/√(n+1)-1)/n*X・(1, 1, ...)*(1, 1, ...) + X\n\nLength of edge of a simplex in Cartesian coordinate system:\n f^-1((1, 0, 0, ...))  = (1/√(n+1)-1)/n*(1, 0, 0, ...)・(1, 1, ...)*(1, 1, ...) + (1, 0, 0, ...)\n\t\t\t\t\t   = (1/√(n+1)-1)/n*(1, 1, ...) + (1, 0, 0, ...)\n|f^-1((1, 0, 0, ...))| = √( ((1/√(n+1)-1)/n+1)^2 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n\t\t\t\t\t   = √( ((1/√(n+1)-1)/n)^2 + 2*(1/√(n+1)-1)/n + 1 + (((1/√(n+1)-1)/n)^2)*(n-1) )\n\t\t\t\t\t   = √( (((1/√(n+1)-1)/n)^2)*n + 2*(1/√(n+1)-1)/n + 1 )\n\t\t\t\t\t   = √( (1/√(n+1)-1)/n*(1/√(n+1)-1 + 2) + 1 )\n\t\t\t\t\t   = √( (1/(n+1) - 1)/n + 1 )\n\t\t\t\t\t   = √( -n/(n+1)/n + 1 )\n\t\t\t\t\t   = √( -1/(n+1) + 1 )\n\t\t\t\t\t   = √( n/(n+1) )\nhttps://www.wolframalpha.com/input/?i=sqrt(+((1%2Fsqrt(n%2B1)-1)%2Fn%2B1)^2+%2B+(((1%2Fsqrt(n%2B1)-1)%2Fn)^2)*(n-1)+)\n\nLength of edges of a simplex in Cartesian coordinate system in 3 or higher dimension are not equal.\nY∈{0,1}^n\nm = Y・(1, 1, ...)\nf^-1(Y) = m*(1/√(n+1)-1)/n*(1, 1, ...) + Y\n|f^-1(Y)| = √( ((m*(1/√(n+1)-1)/n+1)^2)*m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n\t\t  = √( ((m*(1/√(n+1)-1)/n)^2)*m + 2*m*m*(1/√(n+1)-1)/n + m + ((m*(1/√(n+1)-1)/n)^2)*(n-m) )\n\t\t  = √( ((m*(1/√(n+1)-1)/n)^2)*n + 2*m*m*(1/√(n+1)-1)/n + m )\n\t\t  = √( (m*(1/√(n+1)-1)/n)*( (m*(1/√(n+1)-1)) + 2*m ) + m )\n\t\t  = √( (m*(1/√(n+1)-1)/n)*m*( 1/√(n+1)+1 ) + m )\n\t\t  = √( m*m*(1/(n+1)-1)/n + m )\n\t\t  = √( m*m*(-n)/(n+1)/n + m )\n\t\t  = √( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*m/(n+1))/√( -m*m/(n+1) + m )\nd/dm(|f^-1(Y)|) = 0 when m = 0.5*(n+1)\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2/(n+1))/√( n/(n+1) )\n\t\t\t\t= 0.5*(n-1)/√( n*(n+1) ) > 0 when m = 1\nd/dm(|f^-1(Y)|) = 0.5*(1 - 2*n/(n+1))/√( n/(n+1) )\n\t\t\t\t= 0.5*(1-n)/√( n*(n+1) ) < 0 when m = n\n\nSo length of edge is shortest when m = 1 or m = n and other edge is longer than them.\n\nShortest distance between a vertex on simplex and the opposite edge:\nL = √( n/(n+1) )*√(3)/2\n\nReferences:\nhttps://en.wikipedia.org/wiki/Simplex_noise\nhttp://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n*/",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}