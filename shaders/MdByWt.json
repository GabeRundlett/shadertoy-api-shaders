{
    "Shader": {
        "info": {
            "date": "1494325695",
            "description": "a good basis for something i wanted for 2 years...\npracticing and learning by twiddling around with\nparent= https://www.shadertoy.com/view/XsBczc",
            "flags": 0,
            "hasliked": 0,
            "id": "MdByWt",
            "likes": 5,
            "name": "hex tile march",
            "published": 3,
            "tags": [
                "voxel",
                "raytrace",
                "hex"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 655
        },
        "renderpass": [
            {
                "code": "//self  = https://www.shadertoy.com/view/MdByWt\n//parent= https://www.shadertoy.com/view/XsBczc\n\n/* hexwaves, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Uses the hex grid traversal code I developed in https://www.shadertoy.com/view/XdSyzK\n\n*/\n\n\n\n// square root of 3 over 2 for hex tiling.x,sixth rotation, sin(acos(-1.)/3.)\n//#define hex_factor (pow(3.,.5)*.5)\n//pow(x,y) is internally doing exp(log(x)*y):\n#define p322 (exp(log(3.)*.5)*.5)\n\nfloat df(vec3 p){\n return length(p)-1.;\n}\n\n#define rmIterations 100\n#define eps .001\nfloat rm3(vec3 o,vec3 r){float t=0.;for(int i=0;i<rmIterations;++i){\n  //float d2=df(o+r*t2);\n  // if(d2>eps)t2+=d2*.5;\n  float d=df(o+r*t);\n  t+=d*.5;\n  #ifdef dynamicEps\n  d=pow(d,pow(t,.5));\n  #endif\n  if(d<eps*.05)break;}return t;}\n// From Dave Hoskins' https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash32(vec2 p) {\n vec3 p3=fract(vec3(p.xyx) * HASHSCALE3);\n p3+=dot(p3, p3.yxz+19.19);\n return\nfract((p3.xxy+p3.yzz)*p3.zyx);}\n/**/\n\n// Used to draw top borders on top of hex\nfloat hexDist(vec2 p){p=abs(p);\n return max(dot(p,vec2(p322,.5)),p.y)-1.;}\n\n//return  center of nearest hex from p;\nvec2 nearestHexCenter(in vec2 p) {\n //integer coords in hex center grid\n vec2 hex_int=floor(vec2(p.x/p322,p.y));\n float sy=step(2.,mod(hex_int.x+1.,4.));\n hex_int+=mod(vec2(hex_int.x, hex_int.y + sy),2.);\n vec2 r=hex_int*vec2(p322,1.);//cartesian hexagon center\n p=p-r;\n //figure out which side of line we are on \n //and modify hex center if necessary\n if(dot(abs(p),vec2(p322,.5))>1.){\n  hex_int+=sign(p)*vec2(2,1);\n  return hex_int*vec2(p322,1);\n }\n return r;}\n\n//Flip normal if necessary to have positive dot product with d\nvec2 alignNormal(vec2 n,vec2 d){return n*sign(dot(n,d));}\n//Intersect a ray with a hexagon wall with normal n\nvec3 rayHexIntersect(vec2 o,vec2 d, vec2 n){\n return vec3(n,(1.-dot(n,o))/dot(n,d));}\n\n//Choose the vector whose z coordinate is minimal\nvec3 rayMin(vec3 a,vec3 b){return mix(a,b,step(b.z,a.z));}\n\n//Return the cell height for the given cell center\nfloat height_for_pos(vec2 p){\n p*=.1;p+=p.x+p.y;\n //shift origin a bit randomly\n //p+=vec2(2.*sin(iTime*.3+.2),2.*cos(iTime*0.1+0.5));\n //cosine of distance from origin, modulated by Gaussian\n float q=dot(p,p),x=sqrt(q);\n return 6.*cos(x*.2+iTime)*exp(-q/128.);   \n}\n\n//return fully saturated hue.rgb of [h]; 0=1=red, 1/3=green, 2/3=blue \nvec3 hue(float h){return clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=variance       \nvec3 hsv2rgb(vec3 c){return c.z*mix(vec3(1),hue(c.x),c.y);}\n//return color.rgb of c.xyz .x=hue .y=saturation .z=lightness\nvec3 hsl2rgb(vec3 c){return c.z+c.y*(hue(c.x)-.5)*(1.-abs(2.*c.z-1.));}\n//https://www.shadertoy.com/view/lsS3Wc\n/*\nvec3 rgb2hsv(vec3 c){vec4 k=vec4(0,-1,2,-3)/3.,\n p=mix(vec4(c.zy,k.wz),vec4(c.yz, k.xy),(c.z<c.y)?1.:0.),\n q=mix(vec4(p.xyw,c.x),vec4(c.x, p.yzx),(p.x<c.x)?1.:0.);\n float d=q.x-min(q.w,q.y);\n return vec3(abs(q.z+(q.w- q.y)/(6.*d+eps)),d/(q.x+eps),q.x);}\nvec3 rgb2hsl(vec3 c){float n=vmin(c),m=vmax(c);\n vec3 a=step(c.grr,c.rgb)*step(c.bbg,c.rgb),\n h=a*(vec3(0,2,4)+(c.gbr-c.brg)/(m-n + eps))/6.;\n return vec3(fract(1.+vsum(h)),//H\n    (m-n)/(1.-abs(n+m-1.)+eps),//S\n   (n+m)*.5 );}                //L\n*/\n\nvoid hitWallOfadj(in vec2 c,in float prev_cell_height,in vec3 i,inout float h, inout float bdist,inout vec4 hit_nt,inout bool hit,inout vec3 hs,out vec3 n){  \n hit_nt=vec4(n.xy,0.,n.z);\n hit=true;\n hs=vec3(.3,1.,.7);\n //distance to wall top: ... //distance to wall bottom:\n bdist=min(h-i.z,i.z-prev_cell_height);\n vec2 p=i.xy-c;//distance to wall outer side corner\n p=p-n.xy*dot(p,n.xy);\n n=min(n,abs(length(p)-.5/p322));\n }\n\nvoid hitfloor(in vec2 c,in vec3 o,in vec3 d,in float tz,out bool hit,out vec4 hit_nt,out float bdist){\n hit =true;\n hit_nt=vec4(0,0,1,tz);   \n vec2 pinter=o.xy+d.xy*tz;\n bdist=hexDist(pinter-c);// distance to hex border\n}\n\nvoid leavingCell2(inout float prev_cell_height,inout vec3 i,in vec3 o,in vec3 d,out vec3 hs,in vec3 n,inout vec2 c,in float h){\n hs=vec3(.8,1.,1.);\n //update the cell center by twice the normal of intersection\n c+=2.*n.xy;\n prev_cell_height=h;\n h=height_for_pos(c);\n i=o+d*n.z;//ray intersection point with cell wall\n}\n\nvoid leavingCell(out vec3 j,in vec3 o,in vec3 d,out float prev_cell_height,inout float h,inout vec2 c,in vec3 n,out vec3 hs){\n prev_cell_height=h;\n hs=vec3(.8,1.,1.);\n c+=2.*n.xy;//set cell center to +twice_normal_of_intersection\n h=height_for_pos(c);\n j=o+d*n.z;//ray intersection point with cell wall\n}\n\nvoid noHit(in float h,in vec2 c,in vec3 o, in vec3 d,out vec3 n, out float tz){\n // needed to hit against line of a horizon\n //n.xy holds normal, n.z holds ray distance\n //3 possible plane normals to intersect with:\n #define ise(a) rayHexIntersect(o.xy-c,d.xy,alignNormal(a,d.xy))\n n=rayMin(rayMin(ise(vec2(0,1)),ise(vec2(p322,.5))),ise(vec2(p322,-.5)));\n tz=(h-o.z)/d.z; //try to intersect with top of cell\n}\n    \n//Return color for ray with origin o and direction d\n#define border_size .4\n#define border_scale (2./iResolution.y)\nvec3 shade(in vec3 o,in vec3 d) {\n const vec3 fog_color = vec3(1,1,1)*.5;\n vec3 r=fog_color;\n vec2 c=nearestHexCenter(o.xy);//nearest hex center to ray origin\n float h=height_for_pos(c);//cell height\n bool hit=false;\n vec4 hit_nt;\n vec3 hs;//hsv color\n float bdist=1e5;\n float prev_cell_height;\n vec3 j;\n for(int i=0; i<99; ++i){//march one iteration per cell\n  if(!hit){\n   float tz;vec3 n;\n   noHit(h,c,o,d,n,tz);\n   if(o.z >h&&d.z<0.&&tz<n.z)//if(hit floor in this cell)\n    hitfloor(c,o,d,tz,hit,hit_nt,bdist);\n   else{//if(hit cell wall before hitting top)\n    vec3 j=vec3(0);\n    leavingCell(j,o,d,prev_cell_height,h,c,n,hs);\n   if(j.z<h)//if(intersected below the height of neibor cell)\n    hitWallOfadj(c,prev_cell_height,j,h,bdist,hit_nt,hit,hs,n);  \n }}}if (hit){// compute color if hit\n  vec3 n=hit_nt.xyz;// get normal\n  //noise makes a nice \"disco ball\" look in background\n  vec3 noise = (hash32(nearestHexCenter(c))-.5);\n  //n = normalize(n + noise);  \n  hs.x=noise.x+noise.y; \n  float c=1.;\n  c=smoothstep(c,border_scale*hit_nt.w,abs(bdist)-border_size);      \n  //c=mix(c,.5,smoothstep(18.,45.,hit_nt.w));//anti-moidre-fade\n  r=mix(hsv2rgb(hs),vec3(1), 0.);//mix color\n  //vec3 L=normalize(vec3(3,1,4));//ambient direction\n  //r*=(clamp(dot(n,L),0.,1.)*.8+.2);//diffuse/ambient\n        \n  //r=mix(r, texture(iChannel0, reflect(rd,n)).yzx,.4*border);//cubemap\n  //r=mix(fog_color, color,exp(-length(hit_nt.w*d)*.01));//fog\n  return r;}return r;}\t\n\n// Pretty much my boilerplate rendering code, just a couple of \n// fancy twists like radial distortion and vingetting.\n\nvoid camera(out vec3 o,out vec3 d,in vec2 In){\n const float f=500.;\n vec2 uvn=(In.xy-.5*iResolution.xy)/iResolution.y;\n vec2 u=uvn*720.;\n o=vec3(-12,0,10);//cam pos\n vec3 tgt=vec3(0);\n vec3 up=vec3(0,0,1);\n vec3 rz=normalize(tgt-o);\n vec3 rx=normalize(cross(rz,up));\n vec3 ry=cross(rx,rz);\n float s=1.+dot(uvn,uvn)*1.;//radial distortion\n d=mat3(rx,ry,rz)*normalize(vec3(u*s,f));\n float thetax=-.35-.2*cos(.031513*iTime); \n float thetay=-.2*iTime;\n if(any(greaterThan(iMouse.xy,vec2(10.)))){\n  thetax=(iMouse.y-.5*iResolution.y)*-1./iResolution.y;\n  thetay=(iMouse.x-.5*iResolution.x)*6./iResolution.x; \n }/**/\n float cx=cos(thetax),sx=sin(thetax),cy=cos(thetay),sy=sin(thetay);\n mat3 Rx=mat3(1,0,0,0,cx,sx,0,-sx,cx),\n Ry=mat3(cy,0,-sy,0,1,0,sy,0,cy),\n R=mat3(0,0,1,-1,0,0,0,1,0),\n Rt=transpose(R);\n d=Rt*Ry*Rx*R*d;\n o=Rt*Ry*Rx*R*(o-tgt)+tgt;}\n\nvoid mainImage( out vec4 Out,in vec2 In){\n vec3 o,d;camera(o,d,In);\n vec3 r=shade(o,d);\n //r=sqrt(r);\n //vec2 q=In.xy/iResolution.xy;\n //r *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),.1);//iq's vingette       \n Out=vec4(r,1);}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}