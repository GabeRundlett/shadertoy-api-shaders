{
    "Shader": {
        "info": {
            "date": "1464278660",
            "description": "music: [url=https://www.youtube.com/watch?v=H64GF0Vf9JY]sZempol - Yeah[/url]\n\nFirst experiment with lighting and reflections. I took a figure-it-out-as-we-go approach here, let me know if I screwed up something.",
            "flags": 64,
            "hasliked": 0,
            "id": "XsySDW",
            "likes": 9,
            "name": "Everybody Dance",
            "published": 3,
            "tags": [
                "raymarching",
                "reflection",
                "lighting"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 2875
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define SPHERES 6\n#define REFLECTIONS 2\n\n#define saturate(x) clamp(x, 0., 1.)\n#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n\nfloat fft[SPHERES];\n\nvec3 hsv2rgb (in vec3 hsv) {\n    return hsv.z * (1.0 + 0.5 * hsv.y * (cos (2.0 * PI * (hsv.x + vec3 (0.0, 0.6667, 0.3333))) - 1.0));\n}\n\nfloat sphere(vec3 p, vec3 o) {\n    return length(p - o) - 1.;\n}\n\nfloat plane(vec3 p) {\n    return p.y + .25;\n}\n\n// distance function\nfloat map(vec3 p) {\n    float d = plane(p);\n    for (int i = 0; i < SPHERES; ++i) {\n        float a = PI * 2. * float(i) / float(SPHERES);\n        d = min(d, sphere(p, 5. * vec3(sin(a), fft[i] + .25, cos(a))));\n    }\n    return d;\n}\n\n// raymarching function\nfloat trace(vec3 o, vec3 r, int steps) {\n\n    float t = 0.;\n    \n    for (int i = 0; i < 100; ++i) {\n        float d = map(o + r * t);\n        t += d;\n        if (d < .01 || i > steps) break;\n    }\n    \n    return t;\n}\n\n// rendering function: o - ray origin, r - ray vector, dist - distance traveled, steps - raymarching iterations\nvec3 render(inout vec3 o, inout vec3 r, inout float dist, in int steps) {\n    \n    // march to first object\n    float f = trace(o, r, steps);\n    \n    // get intersection point\n    vec3 p = o + f * r;\n    \n    // get normal vector\n    vec2 eps = vec2(0, .0001);\n    vec3 normal = normalize(vec3(\n    \tmap(p + eps.yxx) - map(p - eps.yxx),\n    \tmap(p + eps.xyx) - map(p - eps.xyx),\n    \tmap(p + eps.xxy) - map(p - eps.xxy)\n\t));\n    \n    // light source\n    vec3 light = vec3(0, 3, 2);\n    light = normalize(light - p);\n    \n    // reflection point\n    vec3 ref = reflect(r,normal);\n    \n    vec3 color = vec3(0);\n    \n    // add ambient light (hue from angle)\n    if (p.y > .0) {\n        // color the balls\n    \tcolor += hsv2rgb(vec3(atan(p.x, p.z)/ PI / 2., 1, .1));\n    } else {\n        // create patter for the floor\n        color += saturate(sin(p.x) * sin(p.z) * 50. + sin(iTime) * 10. + .5);\n    }\n    \n    // add diffuse light\n    color += vec3(dot(normal, light));\n    \n    // add specular light\n    color += saturate(vec3(pow(saturate(dot(light, ref)), 15.)) / 2.);\n    \n    // new origin becomes the point hit\n    o = p;\n    \n    // new ray vector becomes the reflection vector\n    r = normalize(ref);\n    \n    // go a bit further on the ray, so we don't hit the same surface\n    o += r * .1;\n    \n    // add marched distance to distance traveled\n    f = max(0., f);\n    dist += f;\n    \n    // return divided by the fog\n    return saturate(color / (1. + dist * dist * .01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // transform viewport coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // store the fft data so we don't bother texture with every distance calculation \n    for (int i = 0; i < SPHERES; ++i) {\n        fft[i] = texture(iChannel0, vec2(float(i) / float(SPHERES), .25)).x;\n    }\n    \n    // ray from screen coordinates\n    vec3 r = normalize(vec3(uv, 3.));\n    \n    // eye for origin\n    vec3 o = vec3(0, 2, -13);\n    \n    // transform mouse coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    if (iMouse.x == 0. && iMouse.y == 0.) mouse = vec2(0);\n\n    mouse *= 2. * PI;\n    \n    // rotate camera around the center\n    float a = clamp(-mouse.y + .4, PI / 20., PI / 20. * 16.);\n    o.yz *= rot(a);\n    r.yz *= rot(a);\n    a = -mouse.x + iTime * .5;\n    o.xz *= rot(a);\n    r.xz *= rot(a);\n    \n    float f = 0.;\n    int steps = 50;\n    \n    // render scene\n    vec3 c = render(o, r, f, steps);\n    \n    // render reflections\n    for (int i = 0; i < REFLECTIONS; ++i) {\n        steps /= 2;\n    \tc += c * render(o, r, f, steps);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 3369,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/szempol/yeah-live"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}