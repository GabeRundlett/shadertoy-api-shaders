{
    "Shader": {
        "info": {
            "date": "1616561722",
            "description": "slapping crap together like it's play-doh",
            "flags": 0,
            "hasliked": 0,
            "id": "sdf3D2",
            "likes": 0,
            "name": "Real-Time Raytracing (Not PTGI!)",
            "published": 3,
            "tags": [
                "raytracer",
                "raytracer",
                "raytracer",
                "ray",
                "raytrace",
                "raytrace",
                "raytrace",
                "raytraced",
                "raytraced",
                "raytraced"
            ],
            "usePreview": 0,
            "username": "Zi7ar21",
            "viewed": 345
        },
        "renderpass": [
            {
                "code": "// ####### Real-Time Ray-Traced (Not PTGI!) #######\n// Made by Zi7ar21 (Jacob Bingham)\n\n// Made on March 23rd, 2021\n// Last Updated: March 23rd, 2021 at 22:35 Mountain Standard Time\n\n// This shader ray-traces a sphere and an infinite plane. It has GGX, Hard Shadows, and Fresnel.\n// That's about it really... not Path-Traced in any way, shape, or form.\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/sdf3D2\n\n// You can remove these social media links when using elsewhere:\n// Discord: @Zi7ar21#2168\n//\n// Twitter: @Zi7ar21\n// https://twitter.com/Zi7ar21\n//\n// YouTube: Jacob Bingham\n// https://www.youtube.com/channel/UCuOqD4WwtUZMOquSIeJ-AAA\n\n// ##### PARAMETERS #####\n// Camera Field of View\n#define camfov 1.0\n\n// Mouse Control Sensitivity (Comment to Disable Mouse)\n#define mousesensitivity 8.0\n\n// Maximum Ray Bounces (UNUSED)\n#define maxbounces 32U\n\n// Hard-Shadow Threshold (because 0.0 gives yucky artifacts on the backs of surfaces!)\n#define hardshadow 1e-4\n\n// Shadow Strength\n#define shadowbias 0.5\n\n// Light Source Direction\n#define lightdir vec3(1.0)\n\n// Super-Sample Anti-Aliasing\n// Comment to disable SSAA, otherwise resolution is multiplied by 2.0*n\n#if HW_PERFORMANCE >= 0\n#define SSAA 1\n#endif\n// (If Shadertoy detects that you are on a potato, it should be disabled by default)\n// Examples:\n// SSAA 1: 2.0*iResolution.xy (4x Slower)\n// SSAA 2: 4.0*iResolution.xy (8x Slower)\n// SSAA 3: 6.0*iResolution.xy (12x Slower)\n// SSAA 4: 8.0*iResolution.xy (16x Slower)\n\n// ##### CONSTANTS #####\n// Octuple Precision, even though Shadertoy is Full Precision (32-Bit Floating Point)\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### TEXTURES #####\n// Fractal Brownian Motion (FBM) Noise Octaves\n#define octaves 8U\n\n// Gradient Noises (from Samplers)\nfloat noise(vec3 pos){\n    return texture(iChannel0, pos).r;\n}\n\nfloat noise(vec2 pos){\n    return texture(iChannel1, pos).r;\n}\n\n// Fractal Brownian Motion Noises\nfloat fbm(vec3 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.zyx*2.0;\n    }\n    return outCol;\n}\n\nfloat fbm(vec2 pos){\n    float outCol = 0.0, attenuation = 0.5;\n    for(uint i = 0U; i < octaves; i++){\n        outCol += attenuation*noise(pos);\n        attenuation *= 0.5;\n        pos = pos.yx*2.0;\n    }\n    return outCol;\n}\n\n// ##### OTHER FUNCTIONS #####\n// Rotation Matrix\nmat3 rotmat(vec3 rotation){\n    // Precalculate the Trig Functions\n    vec3 s = sin(rotation), c = cos(rotation);\n\n    // X Rotation\n    mat3 rx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n\n    // Y Rotation\n    mat3 ry = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n\n    // Z Rotation\n    mat3 rz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    // Output the Final Matrix\n    return rx*ry*rz;\n}\n\n// ##### INTERSECTION FUNCTIONS #####\n// Almost everything is from the great Inigo Quilez:\n// https://iquilezles.org/articles/intersectors\n// Sphere Intersection Function\nfloat sphere(vec3 raydir, vec3 rayori, vec3 sphpos, float sphrad){\n    vec3 oc = rayori-sphpos;\n    float b = dot(oc, raydir);\n    float c = dot(oc, oc)-sphrad*sphrad;\n    float h = b*b-c;\n    if(h < 0.0){return -1.0;}\n    h = sqrt(h);\n    return -b-h;\n}\n\n// Unused\n/*// Triangle Intersection Function\nvec3 tri(vec3 raydir, vec3 rayori, mat3 triangle){\n    vec3 v1v0 = triangle[1]-triangle[0];\n    vec3 v2v0 = triangle[2]-triangle[0];\n    vec3 rov0 = rayori-triangle[0];\n    vec3 n = cross(v1v0, v2v0);\n    vec3 q = cross(rov0, raydir);\n    float d = 1.0/dot(raydir, n);\n    float u = d*dot(-q, v2v0);\n    float v = d*dot( q, v1v0);\n    float t = d*dot(-n, rov0);\n    if(u < 0.0 || u > 1.0 || v < 0.0 || (u+v) > 1.0 ){t = -1.0;}\n    return vec3(t, u, v);\n}*/\n\n// Plane Intersection Function (with help from LoicVDB)\n// https://www.shadertoy.com/user/loicvdb\nfloat plane(vec3 raydir, vec3 rayori, vec3 point, vec3 norm){\n    float normdotp = dot(raydir, norm);\n    if(normdotp >= 0.0){return -1.0;}\n    return dot(point-rayori, norm)/normdotp;\n}\n\n// Scene Intersection Function\nfloat intersect(vec3 raydir, vec3 rayori, out vec3 norm, out uint objectid){\n    // Compute all intersections, and find the closest object\n    float int0 = plane(raydir, rayori, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    float int1 = sphere(raydir, rayori, vec3(0.0, 0.5, 0.0), 0.5);\n    float minimum = min(int0, int1);\n    if(int0 <= 0.0){minimum = int1;}\n    if(int1 <= 0.0){minimum = int0;}\n\n    // Find the Normal and Intersection of the Nearest Object\n    if(minimum == int0){\n        norm = vec3(0.0, 1.0, 0.0);\n        objectid = 1U;\n        return int0;\n    }\n\n    if(minimum == int1){\n        norm = normalize((rayori+(raydir*int1))-vec3(0.0, 0.5, 0.0));\n        objectid = 2U;\n        return int1;\n    }\n\n    // NULL Object (just to be safe)\n    norm = vec3(0.0);\n    objectid = 0U;\n    return -1.0;\n}\n\n// ##### PBR AND MATERIALS #####\n// Poorly Based on: https://learnopengl.com/PBR/Theory\n// Trowbridge-Reitz GGX Normal Distribution Function\nfloat GGX(vec3 norm, vec3 highlightdir, float roughness){\n    float a2     = roughness*roughness;\n    float NdotH  = max(dot(norm, highlightdir), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom    = a2;\n    float denom  = (NdotH2*(a2-1.0)+1.0);\n          denom  = pi*denom*denom;\n    return nom/denom;\n}\n\n// Fresnel Schlick\nvec3 fresnel(vec3 raydir, vec3 normal, vec3 F0){\n    return F0+(1.0-F0)*pow(1.0-dot(-raydir, normal), 5.0);\n}\n\n// Get the Material Properties of an Object\nvoid getmat(in uint objectid, in vec3 raypos, out vec3 albedo, out vec3 spec, inout vec3 norm, out float rough){\n    if(objectid == 1U){\n        albedo = vec3(1.0);\n        spec = vec3(0.6);\n        rough  = (fbm(raypos.xz*0.01)/10.0)+0.5;\n        return;\n    }\n\n    if(objectid == 2U){\n        albedo = vec3(1.0);\n        spec = vec3(0.6);\n        rough  = (fbm(normalize(raypos-vec3(0.0, 0.5, 0.0))*0.05)*0.5)+0.25;\n        return;\n    }\n\n    // NULL Object\n    albedo = vec3(0.0);\n    spec = vec3(0.0);\n    rough  = 0.0;\n    return;\n}\n\n// Compute Shading\nvoid calcshading(inout vec3 outCol, in vec3 raydir, in vec3 albedo, in vec3 spec, in vec3 norm, in float rough){\n    float shadeGGX = GGX(reflect(raydir, norm), normalize(vec3(1.0)), rough);\n    vec3 shadefresnel = fresnel(raydir, norm, spec);\n    outCol = shadefresnel*shadeGGX*albedo;\n    return;\n}\n\n// ##### RENDERING #####\n// Sky\nvec3 skycol(vec3 raydir){\n    vec3 outCol;\n\n    // Light Source\n    if(length(raydir-normalize(lightdir)) < 0.25){\n        outCol = vec3(10.0);\n        return outCol;\n    }\n\n    // Background Gradient\n    outCol = vec3(dot(raydir+vec3(0.0, 0.125, 0.0), vec3(0.0, 1.0, 0.0)));\n    return outCol;\n}\n\n// Hard Shadows\nfloat calcshadow(vec3 raydir, vec3 rayori){\n    // We need these to use the intersection function, and then we can just yeet them\n    // (We could make another intersection that doesn't but that would take up a lot of space\n    // and be tedious to make one match the other when laying out a scene)\n    vec3 norm = vec3(0.0);\n    uint objectid = 0U;\n\n    // Find the intersection\n    float intersection = intersect(raydir, rayori, norm, objectid);\n\n    // If we intersected with the scene, then a shadow is being cast\n    if(intersection >= 0.0){return 0.0;}\n\n    // Otherwise the light source is shining on our surface\n    return 1.0;\n}\n\n// Ray-Tracing\nvec3 raytrace(vec3 raydir, vec3 rayori){\n    vec3 raypos = rayori, outCol = vec3(1.0), col, albedo, spec, norm;\n    float rough;\n    uint objectid;\n    for(uint i = 0U; i < maxbounces; i++){\n        float intersection = intersect(raydir, raypos, norm, objectid);\n        if(intersection <= 0.0){break;}\n        raypos += raydir*intersection;\n        getmat(objectid, raypos, albedo, spec, norm, rough);\n        calcshading(outCol, raydir, albedo, spec, norm, rough);\n        outCol = mix(outCol, outCol*calcshadow(normalize(lightdir), raypos-raydir*hardshadow), shadowbias);\n\n        // For Pure Reflections (Mirrors)\n        //raydir = reflect(raydir, norm);\n\n        // Return Shaded Output\n        return outCol;\n    }\n\n    // Return the Color of the Sky\n    return skycol(raydir);\n}\n\n// ##### OUTPUT IMAGE #####\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 color = vec3(0.0);\n    #ifdef SSAA\n    for(int y = -SSAA; y < SSAA; y++){\n    for(int x = -SSAA; x < SSAA; x++){\n        // Normalized Screen UV Coordinates Centered on (0.0, 0.0)\n        vec2 uv = 2.0*((fragCoord+(vec2(x, y)/float(SSAA*2)))-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n        // Calculate the Ray Direction\n        vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n        #ifdef mousesensitivity\n        if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n        #endif\n        mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n        vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n        // Render the Image\n        color += raytrace(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n    }\n    }\n\n    // Convert the sum to the average\n    color = color/float(SSAA*SSAA*4);\n    #endif\n    #ifndef SSAA\n    // Normalized Screen UV Coordinates Centered on (0.0, 0.0)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Calculate the Ray Direction\n    vec2 mouse = vec2(iTime*pi*0.125, 0.0);\n    #ifdef mousesensitivity\n    if(iMouse.z > 0.0){mouse = mousesensitivity*(iMouse.xy-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);}\n    #endif\n    mat3 rotmatrix = rotmat(vec3(0.0, mouse.x, 0.0));\n    vec3 raydir = normalize(camfov*(uv.x*rotmatrix[0]+uv.y*rotmatrix[1])+rotmatrix[2]);\n\n    // Render the Image\n    color = raytrace(raydir, vec3(-sin(mouse.x)*2.0, 0.5, -cos(mouse.x)*2.0));\n    #endif\n\n    // HDR to SDR Tonemapping\n    color = pow(color/(1.0+color), vec3(1.0/2.2));\n\n    // Output to Screen\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 17,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "volume",
                        "id": 39,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}