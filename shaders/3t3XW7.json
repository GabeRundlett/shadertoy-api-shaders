{
    "Shader": {
        "info": {
            "date": "1581024553",
            "description": "kinda broken and theres some old code snippet in there",
            "flags": 0,
            "hasliked": 0,
            "id": "3t3XW7",
            "likes": 5,
            "name": "Day 49",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 381
        },
        "renderpass": [
            {
                "code": "#define iTime (iTime + 16.)\n\n#define mx (10.*iMouse.x/iResolution.x)\n#define dmin(a,b) (a.x < b.x) ? a : b\n\n#define pi acos(-1.)\n/*\nfloat random( vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.1);\n}*/\n\nfloat random(vec2 u){\n\treturn fract(sin(u.y*4125.1 + u.x *125.625)*225.5235);\n} \n\nfloat noise(vec2 p) {\n\tvec2 i = ceil(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3. - 2. * f);\n   \tfloat a = random(i);\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat r31(vec3 u){\n\treturn fract(sin(u.y*125.1 + u.x *125.125 + u.z*525.5215)*115.125235);\n} \nfloat valueNoise(vec3 uv){\n    vec3 id = floor(uv);\n    vec3 fd = fract(uv);\n    fd = smoothstep(0.,1., fd);\n    \n    float ibl = r31(id + vec3(0,-1,0));\n    float ibr = r31(id + vec3(1,-1,0));\n    float itl = r31(id + vec3(0));\n    float itr = r31(id + vec3(1,0,0));\n    \n    \n    float jbl = r31(id + vec3(0,-1,1));\n    float jbr = r31(id + vec3(1,-1,1));\n    float jtl = r31(id + vec3(0,0, 1));\n    float jtr = r31(id + vec3(1,0, 1));\n    \n    \n    float ibot = mix(ibl, ibr, fd.x); \n    float iup = mix(itl, itr, fd.x);\n    float jbot = mix(jbl, jbr, fd.x);\n    float jup = mix(jtl, jtr, fd.x);\n    \n    float i = mix(ibot, iup, fd.y);\n    float j = mix(jbot, jup, fd.y);\n    \n    return mix(i, j, fd.z); \n}\n\nfloat fbm(vec2 p) { \n\tfloat s = .0;\n\tfloat m = .0;\n\tfloat a = .5;\t\n\tfor(int i = 0; i < 6; i++) {\n\t\ts += a * noise(p);\n\t\tm += a;\n\t\ta *= .5;\n\t\tp *= 2.;\n\t}\n\treturn s / m;\n}\nfloat fbm(vec3 p){\n\n    float n = 0.;\n    p *= 0.1;\n    \n    float f = valueNoise(p); \n    \n    float q = valueNoise(p*1.4);\n    float i = valueNoise(p*5.4 + q*2.);\n    float z = valueNoise(p*f*1.4);\n    \n    n += f*1.8 + q*0.5 + z*0.2 + i*0.3;\n    //n += f*1.8 + q*0.5 + z*0.5 + i*0.3;\n    \n\treturn n;\n}\nvec3 carToPol(vec3 p) { \n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nfloat Noise(vec2 p) {\n\tvec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    gv = smoothstep(0.,1.,gv);\n    \n    float b = mix(random(id+vec2(0,0)), random(id+vec2(1, 0)), gv.x);\n    float t = mix(random(id+vec2(0,1)), random(id+vec2(1, 1)), gv.x);\n    \n    return mix(b, t, gv.y);\n}\n\n\nvec3 colourBackground(vec3 p, vec3 ro, vec3 rd){\n\tvec3 col = vec3(0.);\n    \n    vec3 rayNormal = normalize(p - ro);\n    // ---- stardust----// uses bounding circle  and polar coordinates\n    vec3 q = vec3(0) + rd ;\n    q.xz *= rot(-0.4);\n    q.zy*= rot(0.5*pi);\n    vec3 pC;\n    pC = carToPol(q);\n    \n    //return abs(sin( (pC.x + pC.y ) *20. ))*vec3(1);\n    \n    pC.y += 0.2;\n    float k = fbm(vec2(pC.y, pC.z)); \n    k = abs(k);\n    k = pow(k, 5.);\n    k *= 4.;\n    float k2= fbm(vec2(pC.y, pC.z)*10.4); \n    float k3= fbm(vec2(pC.y, pC.z) + 14.4); \n    vec3 c;\n    c.x = k*k2;\n    c.y = k*k3;\n    c.z = k*(sin(pC.z)*0.5 + 1.);\n    \n    col += c;\n    // ---- stars2 ---- //\n    \n    vec2 t = vec2(pC.y, pC.z);\n    \n    \n    // ---- stars ---- //\n   \n    //float nA = Noise(t*200.14);\n    float nA = Noise(t*200.14);\n    float nB = Noise(t*944.14);\n    col += pow(nA*nB, 10.);\n    \n    \n    // ---- sun ---- //\n    \n    vec3 pSun = vec3 (14,15, 40.);\n    float powSun = dot(normalize(pSun - ro)*1.01, rayNormal);\n    vec3 sunCol = vec3(40,30, 40)/100.;\n    powSun = pow(powSun, 100.) ;\n    vec3 fSun = powSun * sunCol;\n    fSun.r = pow(fSun.r, 2.);\n    fSun.g *= 0.3*powSun*fSun.b;\n    //if(length(fSun)>0.1){col = vec3(0.);}\n    //col += fSun;\n    //col = pC;\n    return col;\n}\nfloat total;\n\nfloat mountainNoise = 0.;\nfloat noiseOther = 0.;\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n\n    p.z -= 2.;\n    \n    d = dmin(d, vec2(length(p) - 0.1, 2.));\n    \n    #define mWidth 29.\n    #define mountain vec3(0.9,1,0.)\n    p.y += 0.;\n    p.x += mWidth;\n    //float n = fbm(q*2.3);\n\t//float asdgasd = r31(p*0.1);\n    \n    float nA = fbm(p.xz*0.2);\n    mountainNoise = nA;\n    \n    float v = valueNoise(vec3(p.xz*0.4, 4.));\n    noiseOther = v;\n\n    vec3 q = p;\n\tq = p;    \n    q.xz += iTime*0.2;\n    q.y += iTime*0.7;\n    float n = fbm(q*1.3)*2.;\n    \n    //d = dmin(d, vec2(dMountains, 3.));\n    \n    float dGround = p.y + 0.1;\n    dGround -= n*0.595;\n    dGround -= sin(p.z + p.x*1.4 + n*20.)*0.17;\n    dGround -= v*2.;\n    d = dmin(d, vec2(dGround, 1.));\n    \n    //d.x *= 0.4;\n    d.x *= (0.24 + smoothstep(0.,1.,total*0.004));\n\treturn d;\n}\n\nvec2 march(vec3 ro,vec3 rd,inout vec3 p,inout float t,inout bool hit){\n\tvec2 d = vec2(10e6);\n\t//t = 0.99;\n    t = 1.1;\n    hit = false;\n    p = ro + rd*t;\n    for(int i = 0;i < 171; i++){\n    \td = map(p);\n        \n    \ttotal = t;\n        if(d.x < 0.004){\n        \thit = true;\n        \tbreak;\n        }\n    \tt += d.x;\n        p = ro + rd*t;\n    }\n    \n    \n    return d;\n}\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0,1,0), dir));\n\tvec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001, 0);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p - t.xyy).x,\n    \tmap(p - t.yxy).x,\n    \tmap(p - t.yyx).x\n    ));\n}\n\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return max(vec3(.0), min(vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e) ) );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0);\n    \n    uv *= 1. + length(uv)*0.4;\n\n    \n    ro.z += mx + iTime;\n    ro.y += 4.5;\n    vec3 lookAt = ro + vec3(0,0,17);\n    lookAt.y = 0.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    rd.xz *= rot(-0.4 + sin(iTime*0.2)*0.7);\n    vec3 p; float t; bool hit;\n    \n    //rd.xz *= rot(mx*0.1 + 0.1);\n\tvec2 d = march(ro, rd, p, t, hit);\n    vec3 background = colourBackground(p, ro, rd);\n    background.g *= 2.8;\n    if(hit){\n        \n        vec3 l = normalize(vec3(-0.2,0.8,-0.6));\n    \tvec3 n = getNormal(p);\n        vec3 h = normalize(l - rd);\n        vec3 lightCol = vec3(0.7,0.3,0.9)*0.1;\n        \n        float diff = max(dot(l, n),0.);\n    \tfloat spec = pow(max(dot(h, n),0.), 5.);\n    \tfloat fres = pow(1. - max(dot(-rd, n),0.), 5.);\n        \n        vec3 albedo = vec3(1);\n        \n        if (d.y == 1.){\n            //\\ro = p;\n            rd = reflect(rd, n);\n            background = colourBackground(p, ro, rd);\n\t\t\tbackground *= 0.3;\n            col += background*fres;\n            col += background*spec;   \n            \n        } else if (d.y == 3.){\n            //col += 0.6;\n            //albedo = vec3(0.4,0.2,0.8)*0.05;\n            albedo = vec3(0.16,0.12,0.18)*0.01;\n            spec *= pow(spec, 3.);\n        \tcol += mix(diff*albedo, (fres + spec)*lightCol, 0.7 - mountainNoise*0.7);\n        } else {\n            col += mix(diff*albedo, (fres + spec)*lightCol, 0.3);\n        }\n    } else {\n    \t\n        background *= 0.3;\n    \tcol += background;\n    }\n    \n    if(!hit){\n    \t//t = 500;\n        t = 500.;\n        p = ro + rd * 40.;\n    }\n    \n    float tt = t*0.018;\n    p.y -= 3.5;\n    p.y *= 0.9;\n    col = mix(col, vec3(0.), smoothstep(0.,1.,tt*( 0.2*exp(-p.y*1.)) ));\n    col *= 0.7;\n    \n    //col += 0.004;\n    col = pow(col, vec3(0.4545));\n    col *= 0.7;\n    col = ACESFilm(col);\n    float md=sin(valueNoise(vec3(p.xz*2., iTime*0.1)));\n    float mdB=sin(valueNoise(vec3(p.xz*0.2, iTime*0.1)));\n    if(!hit){\n        col.g *= 1.1 - md*0.3;\n        col.r *= 1. + md;\n    \n    } else {\n        col.b *= 1.1 - mdB*0.8;\n        col.r *= 1. + mdB;\n    \tcol *= 0.8 ;\n    }\n    \n    uv *= 0.7;\n    col *= 1. - dot(uv,uv)*0.4;\n    \n    col *= 1.4;\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}