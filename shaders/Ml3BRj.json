{
    "Shader": {
        "info": {
            "date": "1540221510",
            "description": "#define numElfs 2.\n#define numElf (iResolution.y/numElfs)\nleads to some cute almostIdentities, thst define this parametric tilie-pattern with derivatives.\nlines 160,162 164 are all optional permutations",
            "flags": 32,
            "hasliked": 0,
            "id": "Ml3BRj",
            "likes": 4,
            "name": "galois tile symmetry",
            "published": 3,
            "tags": [
                "tile",
                "differential",
                "galois"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 533
        },
        "renderpass": [
            {
                "code": "//parent: https://www.shadertoy.com/view/XsScD1\n\n//i keep breaking things on my way to enlightment\n//somethimes usefull insigths/utilities remain, akin to\n// https://www.shadertoy.com/view/Xl3fz2\n\n// MODE 0: trilinear-golden-rainbow mix of modes [1..3]\n// MODE 1: Rainbow\n// MODE 2: Greyscale\n// MODE 3: Just the zeros of the equation\n// MODE 4: Just the zeros of the equation, smoothstepped\n#define RENDER_MODE 0\n\n/*\ntodo:\n- remove sliders a and b (top 2/6)\n- ,and represent the other 4 sliders by iMouse\n*/\n\n// For a Galios field, [nef] must be a reciprocal of prime (or prime power)\n// to ensures that multiplicative inverses exist for all non-zero elements\nconst float nef = 1./3.;\n\n//numElf rasterization-scaling is inverse-squared\n#define numElfs 2.\n#define numElf (iResolution.y/numElfs)\n//#define numElf (iResolution.y/1.)\n//#define numElf (iResolution.y/5.)\n\n#define vec1 float\n#define pi acos(-1.)\n#define sat(a) clamp(a,0.,1.)\n\n#define dd(a) dot(a,a)\n#define u2(a) ((a)*2.-1.)\n#define u5(a) ((a)*.5+.5)\n#define sat(a) clamp(a,0.,1.)\n#define pow2 exp2\n#define TT(d) mod(mod(time,1.0)-d,1.0)\n#define trunc(a) float(int(a))\n#define ma0(a) max(0.,a)\nvec2 fr(float a){return vec2(fract(a),floor(a));}\nfloat su(vec4 a){return a.x+a.y+a.z+a.w;}\n\n//rgba colorspace matrices\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nvec3 rainbowt(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbowt(float a){return rainbowt(-a,1./3.);}\nvec3 rainbows(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbows(float a){return rainbows(-a,1./3.);}\n#define ToRgb(w) return c.z*mix(vec3(1.),sat(w(-c.x)),c.y);}\nvec3 rainbows(vec3 c){ToRgb(rainbows)//3 tri waves, most blurry  , fast and precise cos-mix (blurriest because it is only linear)\nvec3 rainbowt(vec3 c){ToRgb(rainbowt)//3 cos waves, medium blurry, linear-mix not identical to hsv2rgb ,but close\n//hsv2rgb uses a capped triangle-wave, as such it appears to be the brighttest/sharpest because at any moment only 2/3 colors swap.\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008, but code is lost\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt //3 tri waves, most blurry, fast and precise, considder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n//vec3 HsvToRgb(vec3 c){vec3 p;p=abs(fract(c.xxx+vec3(3,2,1)/3.)*6.-3.);return c.z*mix(vec3(1),sat(p-1.),c.y);}\n//porter duff alpha compositing:\n//i do not define ut ..., because its a too short namespace to be spent on a define.\nvec4 ut(vec4 a,vec1 b){return a*(1.-b);}//#define ut(a,b) (a*(1.-b))\n//note; colors atop of identical color is a too easy debugging culpit.\n//note,that atop may returns the alpha of a,and not the alpha max(a,b)\nvec4 pdOut(vec4 a,vec4 b){return ut(b,a.w);}\nvec4 pdOver(vec4 a,vec4 b){return ut(b,a.w)+a;}\nvec4 pdAtop(vec4 a,vec4 b){return ut(b,a.w)+a*b.w;}\nvec4 pdXor(vec4 a,vec4 b){return ut(b,a.w)+ut(a,b.w);}\n\n\n// shoutouts to the amazing tool at\n//   http://dev.thi.ng/gradients/\n// for generating these color palettes\nvec3 color(float t){\n ;//return hsv2rgb(vec3(t*3.,1,1))//triangle capped  //max contrast (only 1=4 colors ever changes)\n ;//return rainbowt(t*3.)         //triangle\n ;//return rainbows(t*3.)         //sine          //more contrast than rainbowt(), less contrast than hsv2rgb()\n ;//return rainbowt(t*3.,1./6.)     //triangle, second parameter sets channels-phase-offset\n ;return rainbows(t*3.,1./6.)     //sine    , second parameter sets channels-phase-offset\n     //phase offset of 1./6. is a nice pseudo-blackBody-gradient, but its periodic!\n /*\n  vec3 a = vec3(0.500, 0.500, 0.500);\n  vec3 b = vec3(0.508, 0.508, 0.500);\n  vec3 c = vec3(1.000, 1.000, 1.000);\n  vec3 d = vec3(0.000, 0.333, 0.667);\n  vec3 ret = a + b * cos(2.0 * 3.14159 * (c * t + d));\n  return clamp(ret, 0.0, 1.0);*/\n ;}\n\nfloat absCircular(float t)\n{\n    float a = floor(t + 0.5);\n    return mod(abs(a - t), 1.0);\n}\n\n\nint m(int x\n){int n = x/int(numElf)\n ;return x - n * int(numElf)\n ;}\n\nint funcInt(int x, int y\n){\n    int a = int(numElf * texture(iChannel0, vec2(0.5, 1.0/6.0 - 1.0/12.0)).x);\n    int b = int(numElf * texture(iChannel0, vec2(0.5, 2.0/6.0 - 1.0/12.0)).x);\n    int c = int(numElf * texture(iChannel0, vec2(0.5, 3.0/6.0 - 1.0/12.0)).x);\n    int d = int(numElf * texture(iChannel0, vec2(0.5, 4.0/6.0 - 1.0/12.0)).x);\n    int e = int(numElf * texture(iChannel0, vec2(0.5, 5.0/6.0 - 1.0/12.0)).x);\n    int f = int(numElf * texture(iChannel0, vec2(0.5, 6.0/6.0 - 1.0/12.0)).x);\n    \n    return m(a*x*x + b*x + c*x*y + d*y*y + e*y + f);\n}\n\n\n// This was going to be used to show the difference between the Gallios \n// field and the real-valued function of the same equation, but I couldn't\n// get it to look nice. If you want to take a crack at it, be my guest.\nfloat funcReal(float x, float y\n){float a=numElf*texture(iChannel0, vec2(.5,1./6.-1./12.0)).x\n ;float b=numElf*texture(iChannel0, vec2(.5,2./6.-1./12.0)).x\n ;float c=numElf*texture(iChannel0, vec2(.5,3./6.-1./12.0)).x\n ;float d=numElf*texture(iChannel0, vec2(.5,4./6.-1./12.0)).x\n ;float e=numElf*texture(iChannel0, vec2(.5,5./6.-1./12.0)).x\n ;float f=numElf*texture(iChannel0, vec2(.5,6./6.-1./12.0)).x\n ;return 2.0* mod(a*x*x + b*x + c*x*y + d*y*y + e*y + f, numElf) \n  //  /length( vec2( 2.0*a*x + b*y + d, 2.0*c*y + b*x + e ) ) \n  //normalization at this point is a bad idea (bad timing)\n ;}\n\n\n//i fail to make sense of this, find no GOOD utility.\n//other then creating some NANs by dividing by a [length of 0]\nfloat funcRealNorm(float x, float y\n){float a = numElf * texture(iChannel0, vec2(0.5, 1.0/6.0 - 1.0/12.0)).x\n ;float b = numElf * texture(iChannel0, vec2(0.5, 2.0/6.0 - 1.0/12.0)).x\n ;float c = numElf * texture(iChannel0, vec2(0.5, 3.0/6.0 - 1.0/12.0)).x\n ;float d = numElf * texture(iChannel0, vec2(0.5, 4.0/6.0 - 1.0/12.0)).x\n ;float e = numElf * texture(iChannel0, vec2(0.5, 5.0/6.0 - 1.0/12.0)).x\n ;float f = numElf * texture(iChannel0, vec2(0.5, 6.0/6.0 - 1.0/12.0)).x\n ;return 2.*mod(a*x*x +b*x+c*x*y +  d*y*y +e*y + f,numElf) \n / length(vec2(2.*a*x +b*y+d    ,2.*c*y  +b*x + e))\n ;}\n\n\nvec3 drawFunction(vec2 p\n){vec3 r\n  ;float x = (p.x * (numElf))\n  ;float y = (p.y * (numElf))\n  ;float f=0.\n  ;float i=  floor(x)*(floor(numElf)/iResolution.y)/floor(numElfs)\n  ;float j=  floor(y)*(floor(numElf)/iResolution.y)/floor(numElfs)\n  ;int k=int(floor(x)*(floor(numElf)/iResolution.y))/int(numElfs)\n  ;int l=int(floor(y)*(floor(numElf)/iResolution.y))/int(numElfs)\n  ;f-=float(funcInt((k),(l)))               //optional SSrasterized      //fast\n  ;//above and below overlap perfectly and are very similar.\n  ;f-=(funcReal   (floor(i),floor(j))) //optional __rasterized real //slow\n  //above and below are so close to being the same, its not even funny, but offset by 1px.\n  ;f+=(funcReal   (floor(x/numElfs/numElfs),floor(y/numElfs/numElfs))) //optional              real (bad scaling)\n  //below function is just bullshit?\n  ;//f+=((funcRealNorm(         (i),     (j))))//optional NAN creator (nonsense?)\n  ;//f=fract(f)//optionally confusing fun\n  ;f=abs(f)//does more good than harm.\n  ;float diff = float(f) / numElf\n  ;r=.5+.5*cos((iTime+0.)*vec3(1,.61,1.61))//aperiodic golden rainbow\n  ;//ass= smoothstep(256.,0.,float(f))\n  ;if(RENDER_MODE==0)\n   r= mix(vec3(mix(1.-diff    ,smoothstep(256.,0. ,float(f)     ),r.y))\n          ,    mix(color(diff),vec3(mix(0.,1.,step(float(f),0.))),r.x)\n                                                                 ,r.z)//trilinear by [golden rainbow]\n  ;else{\n   ;if      (RENDER_MODE==1)r=color(diff)\n   ;else if (RENDER_MODE==3)r=vec3(mix(0.,1.,step(float(f),0.)))\n   ;else if (RENDER_MODE==2)r=vec3(diff)\n   ;else if (RENDER_MODE==4)r=vec3(k)  //vec3(mix(0.,1.,ass))\n  ;}\n  ;return r;\n}\n\n\nvec3 drawSidebar(vec2 p\n){p.x-=1.\n ;p.x*=iResolution.y / iResolution.x\n ;float t=texture(iChannel0,p).x\n ;vec3 r=vec3(0.85)\n ;r=mix(color(1.),r,pow(smoothstep(0.,.004,absCircular(p.x - t)),3.))//lines red\n ;r=mix(color(.4),r,pow(smoothstep(0.,.04 ,absCircular(p.y*6.0)),3.))//lines green\n ;return r;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat frameWidth = iResolution.y / numElf;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec3 final = vec3(0,0,0);\n    \n    if (uv.x > 1.0)\n        final = drawSidebar(uv);\n    else\n        final = drawFunction(uv);\n    \n\tfragColor = vec4(final,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tfloat final = texture(iChannel0, fragCoord.xy / iResolution.xy).x;\n    \n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.y;\n    mouse.x -= 1.0;\n    mouse.x *= iResolution.y / iResolution.x;\n    \n    float sliderNumMouse = floor(mouse.y * 6.0);\n    float sliderNumUV = floor(uv.y * 6.0);\n    if (mouse.x >= 0.0 && sliderNumMouse == sliderNumUV)\n    {\n        final = mouse.x;\n    }\n    \n    final = clamp(final, 0.0, 1.0);\n    \n    fragColor = vec4(final);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}