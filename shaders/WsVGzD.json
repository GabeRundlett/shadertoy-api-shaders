{
    "Shader": {
        "info": {
            "date": "1569853668",
            "description": "raymarching and boolean operations",
            "flags": 0,
            "hasliked": 0,
            "id": "WsVGzD",
            "likes": 2,
            "name": "Spinning Chair",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "atsn",
            "viewed": 358
        },
        "renderpass": [
            {
                "code": "mat4 scale(vec3 p){\n\treturn mat4(\n        1./p.x, 0.,  0.,  0.,\n        0.,  1./p.y, 0.,  0.,\n        0.,  0.,  1./p.z, 0.,\n        0.,  0.,  0.,  1.\n    );\n}\nmat4 translate(vec3 p){\n\treturn mat4(\n        1., 0., 0., p.x,\n        0., 1., 0., p.y,\n        0., 0., 1., p.z,\n        0., 0., 0., 1.\n    );\n}\nmat4 rotate(vec3 u,float rad){\n    u = normalize(u);\n\tfloat c = cos(rad);\n    float s = sin(rad);\n    float ic = 1.-c;\n    float is = 1.-s;\n    return mat4(\n        u.x*u.x*ic+c,     u.x*u.y*ic-u.z*s, u.x*u.z*ic+u.y*s, 0.,\n        u.y*u.x*ic+u.z*s, u.y*u.y*ic+c,     u.y*u.z*ic-u.x*s, 0.,\n        u.z*u.x*ic-u.y*s, u.z*u.y*ic+u.x*s, u.z*u.z*ic+c,     0.,\n        0.,               0.,               0.,               1.\n    );\n}\n\nfloat cube(vec4 p){\n\treturn max(abs(p.x),max(abs(p.y),abs(p.z)))-.5;\n}\nfloat sphere(vec4 p){\n\treturn length(p.xyz)-.5;\n}\n\nvoid add(inout float dist,float shape){\n    dist = min(dist,shape);\n}\nvoid remove(inout float dist,float shape){\n    dist = max(dist,-shape);\n}\nvoid intersect(inout float dist,float shape){\n    dist = max(dist,shape);\n}\nfloat world(vec4 p){\n    float dist = 100.;\n    \n    \n    add(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)\n    ));\n    intersect(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\tscale(vec3(0.8,1.2,1.2))\n    ));\n    remove(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.,0.8,0.))*\n\t\tscale(vec3(.9,1.,0.9))\n    ));\n    \n    remove(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.1,-0.2,0.))*\n\t\tscale(vec3(.9,.9,0.9))\n    ));\n    \n    add(dist,cube(p*\n        translate(vec3(0.,-.1,-2.3))*\n\t\trotate(vec3(1.,1.,0.),iTime+1.)*\n\t\ttranslate(vec3(0.,0.15,0.))*\n\t\tscale(vec3(.7,.2,0.85))\n    ));\n    \n    \n    /*add(dist,sphere(p*\n        translate(vec3(-1.5,0.,-2.4))\n    ));*/\n    \n    add(dist,cube(p*\n        translate(vec3(0.,1.5,-2.3))*\n                  scale(vec3(8.,1.,8.))\n    ));\n    \n    \n    /*add(dist,sphere(p*\n        translate(vec3(0.,-1.,-1.))*\n                    scale(vec3(2.,2.,2.))\n    ));*/\n    \n    return dist;\n}\n\n#define STEP 0.01\nvec4 normal(vec4 p){\n\treturn vec4(\n        normalize(vec3(\n            world(vec4(p.x+STEP,p.y,p.z,1.)),\n        \tworld(vec4(p.x,p.y+STEP,p.z,1.)),\n        \tworld(vec4(p.x,p.y,p.z+STEP,1.))\n\t\t)),\n        0.\n    );\n}\n\nvoid dither(inout vec4 dir,vec4 p,float soft){\n    dir = normalize(dir+vec4(\n        sin(p.y*10000.),\n        sin(p.z*10000.),\n        sin(p.x*10000.),\n        0.\n    )*soft);\n}\n\nfloat rayCastSun(vec4 p, vec4 dir, float softness, float maxSteps, float minDist, float maxDist){\n    float dist = 0.;\n    while(maxSteps-->0.){\n        dist = world(p);\n        dither(dir,p,softness);\n        p += dir*dist;\n        if(dist<minDist){\n            return 0.;\n        }\n        if(dist>maxDist){\n            break;\n        }\n    }\n    return 1.;\n}\n\nfloat sun(vec4 p, vec4 n, vec4 a,float soft,float maxSteps, float minDist, float maxDist){\n    a = normalize(a);\n    float alignment = max(0.,dot(n,a));\n    return alignment * rayCastSun(p,a,soft,maxSteps,minDist,maxDist);\n}\nfloat lamp(vec4 p, vec4 n, vec4 s,float soft,float d,float maxSteps, float minDist, float maxDist){\n    float dist = length(s-p);\n    if(dist>d) return 0.;\n    vec4 a = normalize(s-p);\n    float alignment = max(0.,dot(n,a));\n    return alignment * rayCastSun(p,a,soft,maxSteps,minDist,dist) * pow(1.-dist/d,2.);\n}\nvec3 lights(vec4 p,vec4 n,float maxSteps, float minDist, float maxDist){\n\tvec3 c = vec3(.1);\n    \n    c += vec3(.8,.8,.8) * sun(p,n,vec4(0.,1.,-.1,0.),0.002,maxSteps,minDist,maxDist);\n    //c += vec3(.0,.0,.8) * sun(p,n,vec4(1.,1.,-1.,0.),0.02,maxSteps,minDist,maxDist);\n    \n    c += vec3(.3,.3,2.) * lamp(p,n,vec4(cos(iTime)*2.,.8,1.+sin(iTime)*2.,0.),0.0,5.,maxSteps,minDist,maxDist);\n    \n    //c += rayCastLights(p,normalize(vec4(0.,1.,-1.,0.)),maxSteps,minDist,maxDist) * vec3(.0,.8,0.);\n    \n\treturn c;\n}\n\nvec3 rayCast(vec4 p, vec4 dir, float maxSteps, float minDist, float maxDist, float maxBounce){\n    float dist = 0.;\n    vec3 col = vec3(1.);\n    float influence = 1.;\n    while(maxSteps-->0. && maxBounce>0.){\n        dist = min(maxDist,world(p));\n        \n        //col += 0.01*(dist/maxDist)*influence;\n        \n        p += dir*dist;\n        //col = vec3(dist);\n        //return;\n        if(dist<minDist){\n            maxBounce--;\n            vec3 albedo = vec3(.5,.5,.5);\n            \n            \n            vec4 n = normal(p);\n            float glance = dot(dir.xyz,n.xyz);\n            float fresnel = pow(1.+glance,4.45);\n            float reflective = min(1.,.01+fresnel);\n            //return vec3(reflective);\n            vec4 dif = dir-n;\n            vec4 bounce = normalize(dir-dif*2.);\n            dir = bounce;\n            \n            \n            vec3 lighting = lights(p+n*minDist*2.,n,maxSteps,minDist,maxDist);\n            \n            p += dir;\n            \n            col = (1.-influence)*col + (influence)*albedo*lighting;\n            //return lighting;\n            influence *= reflective;\n            //return col;\n            //col = dif.xyz;\n            //return;\n        }\n        if(dist>maxDist){\n            break;\n        }\n    }\n    //col += influence * lights(p,dir,maxSteps,minDist,maxDist);\n    return col;\n}\n\n/*\n   FEATURES\n--------------\n[k] Fresnel\n[k] Boolean Operations\n[k] Fog\n[k] Reflections\n[k] Shadows\n[k] Sun lights\n[k] Lamps\n\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = rayCast(\n        vec4(uv.x,uv.y,0.,1.),\n        normalize(vec4(uv.x,uv.y,1.,0.)),\n        200.,0.00001,1000.,10.\n    );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}