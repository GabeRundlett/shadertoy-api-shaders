{
    "Shader": {
        "info": {
            "date": "1674506830",
            "description": "An excuse to learn shader stuff...\n\nKeys:\nm               - toggle magnitude levels\np                - toggle phase levels\ntab             - toggle video source\nmouse x    - Interpolate domain warping on/off",
            "flags": 16,
            "hasliked": 0,
            "id": "clfSRM",
            "likes": 6,
            "name": "Domain coloring w/ level curves",
            "published": 3,
            "tags": [
                "video",
                "warping",
                "complex",
                "contours"
            ],
            "usePreview": 0,
            "username": "eo",
            "viewed": 251
        },
        "renderpass": [
            {
                "code": "/*\n\nVisualization of the (complex) function:\n\n           z - 1\n  f(z) = ──────────\n         z² + z + 1\n\nTrying to replicate the domain coloring + level curves from:\nhttps://complex-analysis.com/content/domain_coloring.html\n\nThe magnitude & phase level curves (toggle on/off with m, p keys)\nact a bit like grid lines on graph paper, but for polar coordinates.\nClick/drag to the left to see the undistorted xy plane for reference.\n\nSince this function distorts 2d space, the distorted coordinates\ncan be used to sample from images/video. Press tab to see the effect.\nFor a more comprehensive demonstration of this effect,\nI'd recommend the following YouTube video:\nhttps://www.youtube.com/watch?v=CMMrEDIFPZY\n*/\n\n// Control appearance\n#define MAG_LEVELS 4\n#define PHASE_LEVELS 12\n#define LEVELS_CONTRAST 0.25\n#define ZOOM 0.5\n\n\nvec2 calculate_f_of_z(vec2 xy, float zoom) {\n\n    /*\n    Calculates the function f(z) described above\n    \n    We can think of z as an xy coordinate (i.e. vec2),\n    and then just follow the arithimetic rules\n    for complex numbers to get the f(z) result\n    \n    Additional interpolating terms have been added, so that\n    the mouse x controls a 'nice' transistion between applying\n    the function above, versus no function (or f(z) = z)\n    */\n    \n    // Define an interpolating term, controlled by the mouse\n    float t = smoothstep(0.0, 1.0, get_mouse_x_norm(iMouse, iResolution));\n\n    // Calculate the function terms separately for readability\n    vec2 z = xy / zoom;\n    vec2 numer = z - vec2(1, 0)*t;    \n    vec2 z_squared = mult2d(z, z);\n    vec2 denom = (z_squared + z)*t + vec2(1, 0);\n    \n    return div2d(numer, denom);    \n}\n\n\nfloat get_level_scale(vec2 polar_mag_angle, bool enable_mag, bool enable_phase) {\n\n    /*\n    Calculates a scaling term used to darken the resulting image\n    in such a way that magnitude/phase contour lines appear,\n    acting a bit like polar coordinate grid-lines\n    */\n\n    // Set up the number of magnitude & phase levels\n    float mag_level = fract(float(MAG_LEVELS) * polar_mag_angle.x);\n    float phase_level = fract(float(PHASE_LEVELS) * polar_mag_angle.y);\n    \n    // Include mag/phase leveling, based on enabling inputs\n    mag_level = mix(1.0, mag_level, float(enable_mag));\n    phase_level = mix(1.0, phase_level, float(enable_phase));\n    float leveling = mag_level * phase_level;\n    \n    // Adjust scaling for better aesthetics\n    return (1.0 - LEVELS_CONTRAST) + LEVELS_CONTRAST * leveling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read keyboard\n    bool show_video = get_key_toggle(iChannel0, KEY_tab);\n    bool show_mag_levels = !get_key_toggle(iChannel0, KEY_m);\n    bool show_phase_levels = !get_key_toggle(iChannel0, KEY_p);\n\n    // Calculate warped z\n    vec2 cartesian_xy = get_cartesian_coords(fragCoord.xy, iResolution);\n    vec2 f_of_z = calculate_f_of_z(cartesian_xy, ZOOM);\n    vec2 polar = get_polar(f_of_z);\n    \n    // Calculate scaling for constant mag/phase level indicators\n    float level_scale = get_level_scale(polar, show_mag_levels, show_phase_levels);   \n    \n    // Toggle video imagery vs. domain coloring image\n    vec3 out_rgb;   \n    if (show_video) {\n        out_rgb = sample_video_warped(iChannel1, f_of_z * ZOOM, iResolution);\n    } else {\n        vec3 phase_color = angle_to_rgb(polar.y);\n        out_rgb = phase_color * level_scale;\n    }\n    \n    fragColor = vec4(out_rgb, 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    },
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\n// For clarity\n#define TWOPI 6.28318530718\n#define KEY_tab   9\n#define KEY_m    77\n#define KEY_p    80\n#define is_near_zero(v) abs(v) < 0.0001\n\n\n// From iq:\n// https://www.shadertoy.com/view/ll2GD3\nvec3 angle_to_rgb(float num_0_to_1)\n{\n    vec3 brightness = vec3(0.6);\n    vec3 saturation = vec3(0.525);\n    vec3 rgb_phase = vec3(0.0, 0.33, 0.67);\n    return brightness + saturation * cos( TWOPI * (num_0_to_1 + rgb_phase) );\n}\n\n\n// -------------------------------------------------------------------------------\n// Sampling functions\n\nvec2 get_cartesian_coords(vec2 xy_px, vec3 res) {\n\n    /*\n    Maps xy 'pixel' coordinates (eg. fragCoord or iMouse)\n    into centered normalized cartesian (not stretched) coordinates.\n    Can think of the result as being 'graph paper' coordinates\n    - The center of the screen maps to (0, 0)\n    - The top of the screen has a y value of +1\n    - The bottom of the screen has a y value of -1\n    - The left & right edge x values will be -/+ the aspect ratio (ex: 16/9)\n    */\n\n    return (2.0*xy_px - res.xy) / res.y;\n}\n\nbool get_key_toggle(sampler2D keyboard_channel, int key_code) {\n    return bool(texelFetch(keyboard_channel, ivec2(key_code, 2), 0).x);\n}\n\nfloat get_mouse_x_norm(vec4 mouse, vec3 res) {\n\n    /* Grab mouse x position, between 0 and 1, with some dead space on edges */\n\n    float is_mouse_down = clamp(mouse.z, 0., 1.);\n    float mouse_x_norm = clamp(2.0*mouse.x / res.x - 0.5, 0., 1.);\n    float default_mouse_not_down = 1.0;\n    return mix(default_mouse_not_down, mouse_x_norm, is_mouse_down);\n}\n\nvec3 sample_video_warped(sampler2D channel, vec2 warp_uv, vec3 res) {\n\n    /*\n    Helper used to sample from videos using warped coordinates.\n    The coords are assumed to be calculated on a centered,\n    non-stretched coordinate system, which must be undone\n    to properly sample the video\n    */\n    \n    vec2 aspect_correction = vec2(res.y / res.x, 1.0);\n    vec2 sample_coords = 0.5 * (1.0 + warp_uv * aspect_correction);\n    return texture(channel, fract(sample_coords)).rgb;\n}\n\n\n// -------------------------------------------------------------------------------\n// Functions for complex number arthimetic\n\nvec2 mult2d(vec2 a, vec2 b) {\n\n    /*\n    Multiplication defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    \n    a*b = (ax + i*ay)*(bx + i*by)\n        = ax*bx + ax*i*by + i*ay*bx + i*ay*i*by\n        = ax*bx - ay*by + i*ax*by + i*ay*bx\n        = (ax*bx - ay*by) + i*(ax*by + ay*bx)\n    */\n    \n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);    \n}\n\nvec2 div2d(vec2 a, vec2 b) {\n\n    /*\n    Division defined for 2D coordinates\n    (i.e. complex numbers)\n    \n    a = ax + i*ay\n    b = bx + i*by\n    b' = bx - i*by  ->  (aka 'b conjugate')\n    \n    a   a   b'  ax + i*ay   bx - i*by \n    ─ = ─ * ─ = ───────── * ─────────\n    b   b   b'  bx + i*by   bx - i*by\n    \n        (ax*bx + ay*by) + i*(ay*bx - ax*by)\n      = ───────────────────────────────────\n                  bx*bx + by*by\n    */\n    \n    // Bail on divide-by-zero\n    if (is_near_zero(b.x) && is_near_zero(b.y)) {\n        return vec2(0,0);\n    }\n\n    float numer_real = a.x*b.x + a.y*b.y;\n    float numer_imag = a.y*b.x - a.x*b.y;\n    float denom = b.x*b.x + b.y*b.y;\n    \n    return vec2(numer_real, numer_imag)/denom;\n}\n\nvec2 get_polar(vec2 xy) {\n    \n    /*\n    Get polar coordinates from xy\n    Resulting magnitude is stored in .x, angle in .y\n    Note, the angle value is unitless, 0 to 1 (not radians!)\n    */\n\n    float magnitude = sqrt(length(xy));\n    float angle_minus_pi_to_pi = atan(-xy.y, xy.x);\n    float angle_norm = angle_minus_pi_to_pi/TWOPI;\n    \n    return vec2(magnitude, fract(angle_norm));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}