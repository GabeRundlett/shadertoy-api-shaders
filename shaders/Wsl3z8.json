{
    "Shader": {
        "info": {
            "date": "1544954470",
            "description": "If I use \"udQuad\" function a lot, fps will be low, so I used symmetry trick to approach to create my stealth modeling. A \"polygon\" function is not what I expected. It should fill out the color. Well... Today's study is over...",
            "flags": 0,
            "hasliked": 0,
            "id": "Wsl3z8",
            "likes": 9,
            "name": "Stealth:Study 3D modeling",
            "published": 3,
            "tags": [
                "modeling"
            ],
            "usePreview": 0,
            "username": "yasuo",
            "viewed": 490
        },
        "renderpass": [
            {
                "code": "#define PI 3.14159265359\n#define degToRad (PI * 2.0) / 360.0\n\nmat3 matRotateX(float rad)\n{\n    return mat3(1,       0,        0,\n                0,cos(rad),-sin(rad),\n                0,sin(rad), cos(rad));\n}\n\nmat3 matRotateY(float rad)\n{\n    return mat3(cos(rad), 0, -sin(rad),\n\t\t\t\t\t0, 1, 0,\n\t\t\t\t\tsin(rad), 0, cos(rad));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// based on udquad function\nfloat polygon( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, vec3 e, vec3 f )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ed = e - d; vec3 pd = p - d;\n    vec3 fe = f - e; vec3 pe = p - e;\n    vec3 af = a - f; vec3 pf = p - f;\n    vec3 nor = cross( ba, ed );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ed,nor),pd)) +\n     sign(dot(cross(fe,nor),pe)) +\n     sign(dot(cross(af,nor),pf))<5.0)\n     ?\n     min( min( min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ed*clamp(dot(ed,pd)/dot2(ed),0.0,1.0)-pd) ),\n     dot2(fe*clamp(dot(fe,pe)/dot2(fe),0.0,1.0)-pe) ),\n     dot2(af*clamp(dot(af,pf)/dot2(af),0.0,1.0)-pf) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat floorDist(vec3 p)\n{\n    return p.y+3.0;\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    if ( val1.w < val2.w ) return val1;\n    return val2;\n}\n\nvec4 map(vec3 p){\n    vec3 op = p;\n    float t = 100.0;\n\tfloat r = 0.05;\n    \n    // A 3D Model created by udquads\n    p.x = -abs(p.x);\n\tvec4 left = vec4(0.3,0.3,0.30,udQuad(p, vec3(-2.95924, 0.0, 2.09304), vec3(-0.498879, 0.0, -0.90205), vec3(-0.666666, 0.0, 1.33333),vec3(-2.77433, 0.0, 2.51385))-r);\n\tvec4 left2 = vec4(0.31,0.31,0.31,udQuad(p, vec3(-0.597683, 0.0, 0.496091), vec3(0.0, 0.29306, 0.130684), vec3(0.0, 0.19306, -1.59247),vec3(-0.498879, 0.0, -0.90205))-r);\n\tvec4 left3 = vec4(0.35,0.35,0.35,udQuad(p, vec3(-0.597683, 0.0, 0.496091), vec3(0.0, 0.29306, 0.130684), vec3(0.0, 0.35306, 1.65346),vec3(-0.666666, 0.0, 1.33333))-r);\n\tvec4 tailWingL = vec4(0.36,0.36,0.36,udQuad(p, vec3(-0.265, 0.3, 1.373111), vec3(-0.481232, 1.29927, 2.538658), vec3(-0.435489,1.09346, 2.138658),vec3(-0.22672, 0.3, 1.181444))-r);\n\tp = op;\n    \n    // A 3D Model created by a modified version of udquads\n    op = p;\n\tp.x = -abs(p.x);\n    p.y += 1.5;\n\n    float pol = polygon(p,vec3(0.0, 0.5, 2.0*-1.0),\n                        vec3(-0.5, 0.0, 1.4*-1.0), \n                        vec3(-3.55924, 0.0, 0.15*-1.0),\n                        vec3(-3.17433, 0.0, -0.3*-1.0), \n                        vec3(-0.6, 0.0, -0.5*-1.0),\n                        vec3(0.0, 0.5, -1.0*-1.0))-r;\n    p = op;\n    \n\tvec4 res = combine(left,left2);\n    vec4 res2 = combine(left3,tailWingL);\n    vec4 res3 = combine(vec4(0.3,0.3,0.3,pol),vec4(1.0,1.0,1.0,floorDist(p)));\n    vec4 res4 = combine(res,res2);\n    vec4 res5 = combine(res3,res4);\n    return res5;\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    mat3 camRotY = matRotateY(-(iTime*30.0)*degToRad)*matRotateX(20.*degToRad);\n\t//mat3 camRotY = matRotateX(-90.0*degToRad); // Check top view of modeling.\n\n\tvec3 ro=vec3(0.,-.1,-8.);\n    vec3 rd=normalize(vec3(p,1.8));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 60; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t)*camRotY;\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.35,1.35,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}