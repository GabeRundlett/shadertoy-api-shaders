{
    "Shader": {
        "info": {
            "date": "1569304001",
            "description": "Computer Graphics HW 2",
            "flags": 48,
            "hasliked": 0,
            "id": "ws33D2",
            "likes": 1,
            "name": "ray tracing_HW2",
            "published": 3,
            "tags": [
                "jiayaozhang"
            ],
            "usePreview": 0,
            "username": "JiayaoZhang",
            "viewed": 335
        },
        "renderpass": [
            {
                "code": "#define PI 3.1415926\nconst int KEY_r     = 82;\nconst int KEY_b     = 66;\nconst int KEY_t     = 84;\n\nfloat intersectSphere(in vec3 ro, in vec3 rd, in vec4 pr)\n{\n    vec3 v_surface_camera = ro - pr.xyz;\n    float sphere_rad = pr.w;\n    \n    float b = 2.0 * dot(v_surface_camera, rd);\n    float c = dot(v_surface_camera, v_surface_camera) - sphere_rad * sphere_rad;\n    float h = b*b - 4.0 * c;\n\n    if(h < 0.0) \n    {\n        return -1.0;\n    }\n    return (-b - sqrt(h)) / 2.0; //Again a = 1.\n}\n\nvec3 normalSphere(in vec3 pos, in vec4 pr)\n{\n    return (pos - pr.xyz)/pr.w;\n}\n\nfloat intersectPlane(in vec3 ro, in vec3 rd, vec3 op)\n{\n    return ( (-ro.y + op.y) / rd.y);\n}\n\nvec3 normalPlane(in vec3 pos)\n{\n    return vec3(0.0, 1.0,  0.0);\n}\n\n\n// objects in the scene\nint num_objects = 4;\n\nvec3 obj_pos[]   = vec3[](vec3(0, -1.4, 0), vec3(0,1,1), vec3(-1.5, 1.2, 1.5), vec3(0.5,0.3,-0.1));\nvec4 obj_prop[]  = vec4[](vec4(0), vec4(0.7), vec4(0.4), vec4(0.45));\nvec3 obj_color[] = vec3[](vec3(0.5), vec3(1,0,0), vec3(0,1,0), vec3(0,0,1) );\nint  obj_type[]  =  int[](0, 1, 1, 1); // 2 ellipse ...\n\n\n\n    \n    \n    vec3 light = vec3(1,5,1);\n    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    \n    vec3 light_color = vec3(55);\n\n              \n              \nbool RayIntersectsObject(int id, vec3 ro, vec3 rd, out float od, out vec3 op, out vec3 on)\n{\n    int type = obj_type[id];\n    \n    if(type == 0) // plane\n    {\n        od = intersectPlane(ro, rd, obj_pos[id]);\n        \n        if (od > 0.0)\n        {\n            op = ro + od * rd;\n            on = normalPlane(op);\n            //od = length(op - ro);\n            return true;\n        }\n    }\n    if(type == 1) // sphere\n    {\n        vec4 pr = vec4(obj_pos[id], obj_prop[id].x);\n        od = intersectSphere( ro, rd, pr);\n        \n        if(od > 0.0)\n        {\n            op = ro + od * rd;\n            on = normalSphere(op, pr);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvec4 chan3(float x){return texture(iChannel3,vec2(x,.5)/iResolution.xy,-100.);}\n\n\nmat3 newCam( in vec3 o, in vec3 a) {\n    vec3 w = normalize(a-o);\n    vec3 p = vec3(0.0, 1.0, 0.0);\n    vec3 u = normalize(cross(w,p));\n    vec3 v = cross(u,w);\n    return mat3( u, v, w );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 wasd = chan3(.5).xyz;\n    vec3 pos = vec3(mouse.x, mouse.y, 0.0);\n    \n    \n    //!!!!!!!!!!!!!!!!!!!!!!!!!!task 1!!!!!!!!!!!\n    if(texelFetch( iChannel0, ivec2(KEY_t,2),0 ).x <=0.0){\n     obj_pos[1].xy += (mouse.xy - vec2(0.5))*10.;  \n       \n     obj_prop[1].x = mouse.x *1.5;\n      \n    }\n    \n     //obj_pos[1] .x = 0.5 * cos(iTime);\n     //obj_pos[1] .z = 0.5 * sin(iTime);\n     obj_pos[2] .x = 0.5 * cos(iTime);\n     obj_pos[2] .z = 0.5 * sin(iTime);\n     obj_pos[3] .x = 0.5 * cos(iTime);\n     obj_pos[3] .z = 0.5 * sin(iTime);\n     if(texelFetch( iChannel0, ivec2(KEY_b,2),0 ).x > 0.0){\n        obj_prop[1].x = 0.5;\n         obj_pos[1].xy = vec2(0.5);  \n\n         obj_pos[1] .x = 0.3 ;\n         obj_pos[1] .z = 0.1 ;\n         obj_pos[2] .x = 0.6 ;\n         obj_pos[2] .z = 0.5 ;\n         obj_pos[3] .x = 0.9 ;\n         obj_pos[3] .z = 0.9 ;\n     }\n    \n    light.xz += vec2(sin(iTime), cos(iTime))*5.;\n    \n    \n    // shading parameters\n    float Ka = 0.3; // ambient\n    float Kd = 0.7; // diffuse\n    float Ks = 0.35; // specular\n    \n    // pixel coordinates from 0 to 1\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    // generate a ray with origin ro and direction rd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n    vec3 ro = vec3(0.0, 0.5, -15.0); // vec3(0,0,-1)\n    vec3 vpp = wasd* 0.5 + vec3((-1.0 + uv * 2.0) * vec2(2.0, 2.0) * vec2(1.78*sin(iTime), 1.0 * sin(iTime)), 0);\n    if(texelFetch( iChannel0, ivec2(KEY_r,2),0 ).x > 0.0){\n        vpp = wasd* 0.5 + vec3((-1.0 + uv * 2.0) * vec2(2.0, 2.0) * vec2(1.78, 1.0), 0);\n    \n    }\n    vec3 rd = normalize(vpp - ro);\n    //vec3 rd_mouse = vpp + mouse.xy *rd ;\n    \n    // background color\n    vec3 col = vec3(0.0);\n    float intersection_dist = -1.0;\n    \n    \n    //Rotate Camera\n    if(texelFetch( iChannel0, ivec2(KEY_t,2),0 ).x > 0.0){\n        vec2 uv = fragCoord/iResolution.xy;\n        uv -= 0.5;\n        uv.x *= iResolution.x/iResolution.y;\n        \n        vec3 col = vec3(0.0);\n        vec2 mouse_tap = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n        mouse_tap -= 0.5;\n        \n        ro = vec3(3.0+ 8.0 * cos(mouse_tap.x * 2.0 * PI), 3.0 + 10.0 * mouse_tap.y, 10.0 * sin(mouse_tap.x *2.0 * PI));\n        vec3 ta = vec3(0.0, 2.0, 0.0);\n        mat3 cam = newCam(ro, ta);\n        rd = normalize(cam * vec3(uv, 1.0));\n    }\n    \n\n    // ray twds objects\n    int obj_idx = -1;\n    for(int i=0; i<num_objects; i++)\n    {        \n        float od;\n        vec3 op, on;\n\n        // ro = ray origin, rd = ray dir, od = obj dist, op = obj pos, on = obj normal\n        if(RayIntersectsObject(i, ro, rd, od, op, on))\n        {\n            // first intersection\n            if(intersection_dist < 0.0) \n            {\n                intersection_dist = od;\n            }\n            else\n            {\n                // object is further away\n                if(od > intersection_dist) continue;\n                // object is closer than previous obj_pos[3] .x = 0.5 * cos(iTime);\n    \n                else intersection_dist = od;\n            }\n        }\n    }\n    \n\n    \n    \n    // ray twds objects\n    for(int i=0; i<num_objects; i++)\n    {        \n        float od;\n        vec3 op, on;\n\n        // ro = ray origin, rd = ray dir, od = obj dist, op = obj pos, on = obj normal\n        if(RayIntersectsObject(i, ro, rd, od, op, on))\n        {\n            if(intersection_dist < 0.0) \n            {\n                intersection_dist = od;\n            }\n            else\n            {\n                if(od > intersection_dist) continue;\n                else intersection_dist = od;\n            }\n            \n            // lambert shading\n            vec3 L = normalize(light - op);\n            float NdotL = dot(on, L);\n            vec3 H = normalize( -rd + L);\n            float NdotH = pow(dot(on, H), 46.0);\n            vec3 I = light_color * 1.0 / pow(length(light - op), 2.0);\n            vec3 col_ambient  = Ka * I * obj_color[i];\n            vec3 col_diffuse  = Kd * I * obj_color[i] * max(0.0, NdotL);\n            vec3 col_specular = Ks * I * vec3(1) * max(0.0, NdotH);\n           \n\n            // ray twds light source\n            bool not_in_shadow = true;\n            for(int j=0; j<num_objects; j++)\n            {\n                if(i == j) continue;\n                \n                float nothing_f;\n                vec3 nothing_v;\n                if(RayIntersectsObject(j, op, normalize(light-op), nothing_f, nothing_v, nothing_v))\n                {\n                    not_in_shadow = false;\n                    break;\n                }\n            }\n            \n            col = col_ambient + col_diffuse * float(not_in_shadow) + col_specular;\n        }\n        \n    }\n\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(mouse.xy,0,1.0)*1.;\n   \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//WASD-Movement\n//Ben Quantock 2016\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//shortened&modified by ollj \n#define fl float\n#define ff const fl\nff minY=0.;//minimum height.\nff yMul=-1.;//negate to invert y-axis in controls\nff acc =.001;//acceleration \nff fri =.95;//friction\n\n//if both are disabled, it uses both (zq=wa)+sd+f+space\n//#define wasd\n//#define zqsd\n\n#define cf 256.;\n#define cfc cf ff\nff Key_left=37.5/cfc Key_up=38.5/cfc Key_right=39.5/cfc Key_down=40.5/cfc Key_Space=32.5/cfc \nKey_0=48.5/cfc Key_1=49.5/cfc Key_2=50.5/cfc Key_3=51.5/cfc Key_4=52.5/cfc Key_5=53.5/cfc Key_6=54.5/cfc Key_7=55.5/cfc Key_8=56.5/cfc Key_9=57.5/cfc \nKey_A=65.5/cfc Key_B=66.5/cfc Key_C=67.5/cfc Key_D=68.5/cfc Key_E=69.5/cfc Key_F=70.5/cfc Key_G=71.5/cfc Key_H=72.5/cfc Key_I=73.5/cfc Key_J=74.5/cfc Key_K=75.5/cfc Key_L=76.5/cfc Key_M=77.5/cfc Key_N=78.5/cfc Key_O=79.5/cfc Key_P=80.5/cfc Key_Q=81.5/cfc Key_R=82.5/cfc Key_S=83.5/cfc Key_T=84.5/cfc Key_U=85.5/cfc Key_V=86.5/cfc Key_W=87.5/cfc Key_X=88.5/cfc Key_Y=89.5/cfc Key_Z=90.5/cf\nfl rkInternal(fl k,fl t){return texture(iChannel3,vec2(k,t)).x;}\nfl rk      (fl k){return rkInternal(k,.25);}\nfl rkToggle(fl k){return rkInternal(k,.75);}\nvec4 chan0(fl x){return texture(iChannel0,vec2(x,.5)/iResolution.xy,-100.);}\n\nvoid mainImage(out vec4 r, in vec2 i){r=vec4(0.,0.,0.,1.);if(int(i.y)==0){\n if(int(i.x)==0){//x=0 stores CameraPosition.xyz; .w stores if the camera is flying: if(camPos.w>.0) is flying, no gravity|jumping\n  vec4 camPos=chan0(.5);\n  vec4 camVel=chan0(3.5);\n  r=camPos+camVel;\n  //if(camPos.y<.0)r.y=minY;//no flying below .y<minY\n  r.w=rkToggle(Key_F);\n }else if(int(i.x)<2){//x=1. stores [cameraRot=0] in radians; .w stores iMouse.z, if mouse was held down at the last frame.\n  vec4 b=chan0(2.5);vec4 o=chan0(1.5);\n  vec2 m=(iMouse.yx/iResolution.yx-.5)*vec2(.5*yMul,1.);\n  o.w=iMouse.z;bool p=o.w>.0;\n  if(p&&!(b.w >.0))b.xy-=m;if(p)o.xy=b.xy+m;else b=o;b.w=o.w;\n  r=(int(i.x)==1)?o:b;\n  //x=2. stores [BASE-cameraRot=b] in radians; the last [camRot=o] were the mouse was being held down.\n }else if(int(i.x)==3){//x=3. stores [cameraVel=v] for acceleration and friction.\n  vec4 p=chan0(.5);vec4 v=chan0(3.5);vec4 o=chan0(1.5)*6.28318530718;\n  bool fly=p.w>.0;\n  vec3 f=acc*vec3(0,0,1);vec3 l=f.zxx;\n  if(!fly){fl s=sin(o.x);fl c=cos(o.x);\n   f.zy=f.zy*c+s*vec2(1,-1)*f.yz;\n   l.zy=l.zy*c+s*vec2(1,-1)*l.yz;}\n  fl s=sin(o.y);fl c=cos(o.y);\n  f.xz=f.xz*c+s*vec2(1,-1)*f.zx;\n  l.xz=l.xz*c+s*vec2(1,-1)*l.zx;\n#ifdef wasd\n v.xyz+=(rk(Key_W)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_A))*l;\n#elseif zqsd\n v.xyz+=(rk(Key_Z)-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-rk(Key_Q))*l;  \n#else \n v.xyz+=(max(rk(Key_W),rk(Key_Z))-rk(Key_S))*f;\n v.xyz+=(rk(Key_D)-max(rk(Key_A),rk(Key_Q)))*l; \n#endif\n v.xyz+=(rk(Key_up)-rk(Key_down))*f;\n v.xyz+=(rk(Key_right)-rk(Key_left))*l;\n v*=fri;\n  if(fly){v.y-=.01;\n   if(p.y<=.0)v.y=(rk(Key_Space)!=.0)?.3:minY;\n  }r=v;}}}",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}