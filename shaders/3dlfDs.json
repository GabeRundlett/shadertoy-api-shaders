{
    "Shader": {
        "info": {
            "date": "1589378062",
            "description": "generalization of a cube and a sphere, complete with closest-point calculation!",
            "flags": 0,
            "hasliked": 0,
            "id": "3dlfDs",
            "likes": 12,
            "name": "Cube + Sphere SDF",
            "published": 3,
            "tags": [
                "sdf"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 750
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 nonzero_sign(vec3 p) {\n    return max(sign(p),vec3(0))*2.-1.;\n}\n\nmat3 sort(vec3 p) {\n    mat3 perm = mat3(1);\n    //there must be a more elegant way to do this...\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    if (p.y > p.z) { p.yz = p.zy; perm *= mat3(1,0,0,0,0,1,0,1,0); }\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    return perm;\n}\n\nvec4 rounded_square(vec3 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the cube symmetries\n    vec3 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat3 perm = sort(p);\n    p *= perm;\n    p.z += sharpness;\n\n    //get closest point on defining sphere for this axis\n    float rad = sharpness + radius;\n    vec3 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.y > closest.z-sharpness) {\n        float a = closest.x;\n        float d = closest.y+closest.z;\n        float k = sharpness;\n        float z = (k + sqrt(d*d*(2.*rad*rad-k*k)/(2.*a*a+d*d)))/2.;\n        float y = z - k;\n        float x = a*(2.*z-k)/d;\n        closest = vec3(x,y,z);\n    \tif (closest.x > closest.z-sharpness) {\n            z = (2.*k + sqrt(3.*rad*rad - 2.*k*k))/3.;\n        \ty = z - k;\n            x = z - k;\n        \tclosest = vec3(x,y,z);\n    \t}\n    }\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec3 closest_global = (closest-vec3(0,0,sharpness))*transpose(perm)*sgn;\n\n\treturn vec4(dist-offset, closest_global);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r, g*g, b*b);\n}\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nfloat PI = acos(-1.);\nvec3 objcol_glob;\nfloat scene(vec3 p) {\n    float radius = sin(iTime*1.2)*0.2+0.7;\n    float sharpness = pow(asin(sin(iTime*0.7))/PI+1.,8.);\n    float offset = 1.-radius;\n    float dist = rounded_square(p, radius, sharpness, offset).x;\n\tobjcol_glob = srgb(0.5,0.35,0.6);\n    \n    vec3 probe = normalize(vec3(cos(iTime*2.), sin(iTime*2.), cos(iTime*.7)*.3+.3))*2.;\n    vec3 closest = rounded_square(probe, radius, sharpness, offset).yzw;\n    float closestball = length(p-closest)-0.1;\n    float probeball = length(p-probe)-0.1;\n    float probeline = linedist(p, probe, closest) - 0.03;\n    \n    if (closestball < dist) {\n        objcol_glob = srgb(0.2,0.6,0.3);\n        dist = closestball;\n    }\n    if (probeball < dist) {\n        objcol_glob = srgb(0.6,0.2,0.1);\n        dist = probeball;\n    }\n    if (probeline < dist) {\n        objcol_glob = srgb(0.3);\n        dist = probeline;\n    }\n\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p)- vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n\nvec3 shade(vec3 n, vec3 r, vec3 cam, float harmonic, vec3 col, vec3 rot) {\n    float ang = length(rot); vec3 ax = normalize(rot);\n    \n    col = abs(erot(col, vec3(0,0,1), ang*0.1));\n    float fresnel = 1.-abs(dot(cam,n))*0.98;\n    r = erot(r, ax, -ang);\n    float spec = length(sin(r*harmonic)*0.5+0.5)/sqrt(3.);\n    return col*pow(spec+.2,3.) + pow(spec, 12.)*fresnel*1.6;\n}\n\nfloat bayer(vec2 uv) {\n    return (texelFetch(iChannel0, ivec2(uv)%8, 0).x - 0.5)/128.;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.6, uv));\n    vec3 init = vec3(-7,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 2.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    vec3 objcol = objcol_glob;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    \n    vec3 l1 = vec3(0,0,.1);\n    vec3 l2 = vec3(0,1.,0);\n    vec3 l3 = vec3(4.,0,0);\n\n    vec3 col = shade(n, r, cam, 2., objcol, l1);\n    vec3 bg = shade(cam, cam, vec3(0), 2., srgb(0.3), l1);\n    col += shade(n, r, cam, 3.3, objcol, l2)*.6;\n    bg += shade(cam, cam, vec3(0), 3.3, srgb(0.1), l2)*.6;\n    col += shade(n, r, cam, 4., objcol, l3)*.3;\n    bg += shade(cam, cam, vec3(0), 4., srgb(0.3), l3)*.3;\n    fragColor.xyz = sqrt(hit ? col : bg*.4) + bayer(fragCoord);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}