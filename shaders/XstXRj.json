{
    "Shader": {
        "info": {
            "date": "1460491953",
            "description": "A classic, remixed",
            "flags": 0,
            "hasliked": 0,
            "id": "XstXRj",
            "likes": 35,
            "name": "Bouncy Icosahedron",
            "published": 3,
            "tags": [
                "raytracing",
                "reflection",
                "refraction",
                "secondreality"
            ],
            "usePreview": 1,
            "username": "finalman",
            "viewed": 1358
        },
        "renderpass": [
            {
                "code": "const int MAX_INNER_REFLECTIONS = 8; // Kill framerate here\nconst float GLASS_IOR = 1.7;\nconst float GLASS_REFLECTION = 0.15;\nconst float GLASS_FRESNEL_POWER = 2.5;\nconst vec3 GLASS_ABSORPTION = vec3(0.08, 0.02, 0.01);\nconst float DISPERSION = 0.05;\nconst float EXPOSURE = 1.5;\n\nvec3 BOARD_SIZE = vec3(4.5, 0.1, 4.5);\nfloat BOARD_TOP = -3.0;\nfloat BOARD_REFLECTION = 0.2;\nvec3 LIGHT_DIR = normalize(vec3(-1.0, 3.0, -1.5));\nvec3 SHADOW_COLOR = vec3(0.45, 0.45, 0.55);\nvec3 SKY_COLOR = vec3(0.3, 0.4, 0.6);\nvec3 GROUND_COLOR = vec3(0.2, 0.2, 0.1);\n\nconst vec3 RGB_IOR_MULTIPLIER = exp(DISPERSION * vec3(647.0, 510.0, 440.0) / 589.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TAU = 2.0 * PI;\nconst float BIG = 1e15;\nconst float EPSILON = 1e-10;\nconst float THETA = 1.61803398875;\nconst float INV_THETA = 0.61803398875;\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Intersection\n{\n    float dist;\n    vec3 normal;\n};\n\nstruct Result\n{\n    Intersection start;\n    Intersection end;\n};\n    \nmat4 rotateX(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float v)\n{\n    float c = cos(v);\n    float s = sin(v);\n    \n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translate(vec3 v)\n{\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        v.x, v.y, v.z, 1.0\n    );\n}\n\nmat4 translate(float x, float y, float z)\n{\n    return translate(vec3(x, y, z));\n}\n\nmat4 scale(vec3 v)\n{\n    return mat4(\n        v.x, 0.0, 0.0, 0.0,\n        0.0, v.y, 0.0, 0.0,\n        0.0, 0.0, v.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 scale(float x, float y, float z)\n{\n    return scale(vec3(x, y, z));\n}\n\nmat4 transposem(mat4 m)\n{\n    return mat4(\n        m[0].x, m[1].x, m[2].x, m[3].x,\n        m[0].y, m[1].y, m[2].y, m[3].y,\n        m[0].z, m[1].z, m[2].z, m[3].z,\n        m[0].w, m[1].w, m[2].w, m[3].w\n    );\n}\n\nRay transform(mat4 m, Ray ray)\n{\n    ray.o = (m * vec4(ray.o, 1.0)).xyz;\n    ray.d = normalize((m * vec4(ray.d, 0.0)).xyz);\n    \n    return ray;\n}\n\nIntersection transform(mat4 m, mat4 itm, Ray ray, Intersection is)\n{\n    vec3 pos = ray.o + ray.d * is.dist;\n    ray = transform(m, ray);\n    pos = (m * vec4(pos, 1.0)).xyz;\n    \n    is.dist = dot(pos - ray.o, ray.d); \n    is.normal = normalize((itm * vec4(is.normal, 0.0)).xyz);\n    \n    return is;\n}\n\nResult transform(mat4 m, mat4 itm, Ray ray, Result r)\n{\n    r.start = transform(m, itm, ray, r.start);\n    r.end = transform(m, itm, ray, r.end);\n    return r;\n}\n\nResult intersect(Result a, Result b)\n{\n    Result result;\n    result.start = a.start;\n    result.end = a.end;\n    \n    if (b.start.dist > a.start.dist)\n    {\n        result.start = b.start;\n    }\n    \n    if (b.end.dist < a.end.dist)\n    {\n        result.end = b.end;\n    }\n    \n    return result;\n}\n    \nResult sphere(vec3 center, float radius, Ray ray)\n{\n    ray.o -= center;\n    \n    float p = 2.0 * dot(ray.o, ray.d);\n    float q = dot(ray.o, ray.o) - radius * radius;\n    float r = p * p / 4.0 - q;\n    \n    Result result;\n    result.start.dist = BIG;\n    result.end.dist = -BIG;\n    \n    if (r >= 0.0)\n    {\n        float m = -p / 2.0;\n        float sr = sqrt(r);\n        result.start.dist = m - sr;\n        result.start.normal = (ray.o + ray.d * result.start.dist) / radius;\n        result.end.dist = m + sr;\n        result.end.normal = (ray.o + ray.d * result.end.dist) / radius;\n    }\n    \n    return result;\n}\n\nResult plane(vec3 pos, vec3 normal, Ray ray)\n{\n    ray.o -= pos;\n    \n    float rdn = dot(ray.d, normal);\n    float ron = dot(ray.o, normal);\n    \n    Result result;\n    result.start.normal = normal;\n    result.end.normal = normal;\n    \n    if (ron > 0.0)\n    {\n        // Outside\n        result.start.dist = BIG;\n        result.end.dist = -BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n            else\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n        }\n    }\n    else\n    {\n        // Inside\n        result.start.dist = -BIG;\n        result.end.dist = BIG;\n        \n        if (abs(rdn) > EPSILON)\n        {\n            float d = -ron / rdn;\n            \n            if (d > 0.0)\n            {\n                result.start.dist = -BIG;\n                result.end.dist = d;\n            }\n            else\n            {\n                result.start.dist = d;\n                result.end.dist = BIG;\n            }\n        }\n    }\n    return result;\n}\n\nResult cube(vec3 center, vec3 size, Ray ray)\n{\n    Result r;\n    r.start.dist = -BIG;\n    r.end.dist = BIG;\n    \n    r = intersect(r, plane(center + size * vec3(1.0, 0.0, 0.0),  vec3(1.0, 0.0, 0.0),  ray));\n    r = intersect(r, plane(center + size * vec3(0.0, 1.0, 0.0),  vec3(0.0, 1.0, 0.0),  ray));\n    r = intersect(r, plane(center + size * vec3(0.0, 0.0, 1.0),  vec3(0.0, 0.0, 1.0),  ray));\n    r = intersect(r, plane(center + size * vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), ray));\n    r = intersect(r, plane(center + size * vec3(0.0, -1.0, 0.0), vec3(0.0, -1.0, 0.0), ray));\n    r = intersect(r, plane(center + size * vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, -1.0), ray));\n    \n    return r;\n}\n\nResult icosahedron(Ray ray)\n{\n    Result r;\n    r.start.dist = -BIG;\n    r.end.dist = BIG;\n    \n    vec3 n;\n    \n    // What's a for loop?\n    n = normalize(vec3(1, 1, 1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(1, 1, -1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(1, -1, 1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(1, -1, -1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-1, 1, 1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-1, 1, -1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-1, -1, 1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-1, -1, -1));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(0, INV_THETA, THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(0, INV_THETA, -THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(0, -INV_THETA, THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(0, -INV_THETA, -THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(INV_THETA, THETA, 0));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(INV_THETA, -THETA, 0));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-INV_THETA, THETA, 0));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-INV_THETA, -THETA, 0));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(THETA, 0, INV_THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-THETA, 0, INV_THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(THETA, 0, -INV_THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    n = normalize(vec3(-THETA, 0, -INV_THETA));\n    r = intersect(r, plane(n, n, ray));\n    if (r.start.dist > r.end.dist) return r;\n    \n    return r;\n}\n\nvec3 renderBackground(Ray ray)\n{\n    float tolight = pow(dot(ray.d, LIGHT_DIR) * 0.5 + 0.5, 6.0) * 5.0;\n    vec3 color = vec3(tolight) + mix(GROUND_COLOR, SKY_COLOR, ray.d.y * 0.5 + 0.5);\n    return mix(color, texture(iChannel0, ray.d).xyz, 0.2);\n}\n\nvec3 boardTexture(vec3 pos)\n{\n    float square = (fract(pos.x * 2.1) < 0.5 == fract(pos.z * 2.1) < 0.5) ? 0.0 : 1.0;\n    if (abs(pos.x* 2.1) >= 2.0 || abs(pos.z * 2.1) >= 2.0)\n    {\n        square = 0.5;\n    }\n    \n    vec3 base = mix(vec3(0.345, 0.245, 0.329), vec3(0.231, 0.176, 0.231), square);\n    float scratches = texture(iChannel1, (scale(0.05, 0.05, 0.7) * rotateY(1.0) * vec4(pos, 1.0)).xz).x;\n    scratches = smoothstep(0.6, 1.0, scratches) * 0.4;\n    \n    return mix(base * 1.3, vec3(0.9, 0.9, 0.9), scratches);\n}\n\nvec3 renderBoard(Ray ray, mat4 m, mat4 im, mat4 tm, mat4 itm)\n{\n    Result result = cube(vec3(0.0, BOARD_TOP - BOARD_SIZE.y, 0.0), BOARD_SIZE, ray);\n    \n    if (result.start.dist < 0.0 || result.start.dist >= result.end.dist)\n    {\n        return renderBackground(ray);\n    }\n    \n    vec3 pos = ray.o + ray.d * result.start.dist;\n    vec3 color = boardTexture(pos / BOARD_SIZE);\n    \n    Ray shadowRay;\n    shadowRay.o = pos;\n    shadowRay.d = -LIGHT_DIR;\n    \n    Ray shadowRayt = transform(m, shadowRay);\n    Result shadowResult = icosahedron(shadowRayt);\n    shadowResult = transform(im, tm, shadowRayt, shadowResult);\n    \n    float shadow = clamp(shadowResult.end.dist - shadowResult.start.dist, 0.0, 1.0);\n    float spotlight1 = smoothstep(5.0, 0.0, length(pos.xz));\n    float spotlight2 = smoothstep(10.0, 0.0, length(pos.xz));\n    \n    Ray reflectedRay;\n    reflectedRay.o = pos;\n    reflectedRay.d = reflect(ray.d, result.start.normal);\n    \n    vec3 reflection = renderBackground(reflectedRay);\n    \n    vec3 c = color * (dot(result.start.normal, LIGHT_DIR) + 1.0) * 0.5 * mix(vec3(spotlight2), SHADOW_COLOR, shadow * spotlight1);\n    return mix(c, reflection, BOARD_REFLECTION);\n}\n\nvec3 renderIcosahedronInside(Ray ray, mat4 m, mat4 im, mat4 tm, mat4 itm, float wl)\n{\n    float dist = 0.0;\n    Ray refractedRay;\n    Result result;\n    \n    for (int i = 0; i < MAX_INNER_REFLECTIONS; i++)\n    {\n        Ray rayt = transform(m, ray);\n        result = icosahedron(rayt);\n        result = transform(im, tm, rayt, result);\n        \n        dist += result.end.dist - result.start.dist;\n\n        vec3 pos = ray.o + ray.d * result.end.dist;\n        \n        refractedRay.o = pos;\n        refractedRay.d = refract(ray.d, -result.end.normal, wl * GLASS_IOR);\n        ray.o = pos;\n        ray.d = reflect(ray.d, -result.end.normal);\n        \n        if (length(refractedRay.d) > EPSILON)\n        {\n            break;\n        }\n    }\n    \n    if (length(refractedRay.d) < EPSILON)\n    {\n        refractedRay.d = ray.d;\n    }\n    \n    float fresnel = pow(1.0 - abs(dot(refractedRay.d, result.end.normal)), GLASS_FRESNEL_POWER);\n    float reflectiveness = mix(fresnel, 1.0, GLASS_REFLECTION);\n    \n    return renderBoard(refractedRay, m, im, tm, itm) * exp(-dist * GLASS_ABSORPTION) * (1.0 - reflectiveness);\n}\n\nvec3 renderScene(Ray ray)\n{\n    float phase = fract(iTime * 0.5);\n    float height = (phase - phase * phase) * 4.0 * 5.0;\n    phase = fract(phase + 0.025);\n    float squish = exp(-phase * 1.5) * sin(phase * 12.0) * 0.5;\n    float s = exp(squish);\n    float is = 1.0 / s;\n    \n    mat4 m = \n        rotateX(iTime * 0.6) * \n        rotateY(iTime * 0.4) *\n        scale(is, s, is) *\n        translate(0.0, -height - BOARD_TOP - 0.75, 0.0);\n    mat4 im = \n        translate(0.0, height + BOARD_TOP + 0.75, 0.0)*\n        scale(1.0 / is, 1.0 / s, 1.0 / is) *\n        rotateY(-iTime * 0.4) * \n        rotateX(-iTime * 0.6);\n    mat4 tm = transposem(m);\n    mat4 itm = transposem(im);\n    \n    Ray rayt = transform(m, ray);\n    Result result = icosahedron(rayt);\n    result = transform(im, tm, rayt, result);\n    \n    if (result.start.dist > 0.0 && result.start.dist < result.end.dist)\n    {   \n        vec3 pos = ray.o + ray.d * result.start.dist;\n        \n        Ray reflectedRay;\n        reflectedRay.o = pos;\n        reflectedRay.d = reflect(ray.d, result.start.normal);\n        float fresnel = pow(1.0 - abs(dot(ray.d, result.start.normal)), GLASS_FRESNEL_POWER);\n        float reflectiveness = mix(fresnel, 1.0, GLASS_REFLECTION);\n        \n        vec3 fromInside;\n        \n        for (int i = 0; i < 3; i++)\n        {\n            float wl = RGB_IOR_MULTIPLIER[i];\n            \n            Ray refractedRay;\n            refractedRay.o = pos;\n            refractedRay.d = normalize(refract(ray.d, result.start.normal, 1.0 / (wl * GLASS_IOR)));\n            \n            \n            vec3 c = renderIcosahedronInside(refractedRay, m, im, tm, itm, wl);\n            fromInside[i] = c[i];\n        }\n        \n        return fromInside + renderBoard(reflectedRay, m, im, tm, itm) * reflectiveness;\n    }\n    else\n    {\n        return renderBoard(ray, m, im, tm, itm);\n    }\n}\n\nvec3 toneMap(vec3 color)\n{\n    return 1.0 - exp(-color * EXPOSURE);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray;\n    ray.o = vec3(0.0, 0.0, 0.0);\n    ray.d = normalize(vec3((fragCoord.xy - iResolution.xy * 0.5) / iResolution.y, 1.0));\n    \n    ray = transform(\n        rotateY(iTime * 0.05) * translate(0.0, 0.0, -9.0)\n        /* * rotateY(-iMouse.x / iResolution.x + 0.5)  * rotateX(iMouse.y / iResolution.y - 0.5)*/,\n        ray);\n    \n    vec3 color = renderScene(ray);\n    color = toneMap(color);\n    fragColor = vec4(color, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}