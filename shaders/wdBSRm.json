{
    "Shader": {
        "info": {
            "date": "1554293840",
            "description": "Octagonal diamond Truchet pattern. Just a reworking of Fizzer's \"4.8^2 Truchet\" example.",
            "flags": 0,
            "hasliked": 0,
            "id": "wdBSRm",
            "likes": 38,
            "name": "Diamond Octagon Truchet Pattern",
            "published": 3,
            "tags": [
                "diamond",
                "truchet",
                "pattern",
                "arc",
                "octagon"
            ],
            "usePreview": 1,
            "username": "Shane",
            "viewed": 1599
        },
        "renderpass": [
            {
                "code": "/*\n\n\n\tDiamond Octagon Truchet Pattern\n\t-------------------------------\n\n\tFizzer's already made one of these, so I had the benefit of taking a peek at his \n\tcode before starting this. It kind of felt like looking up the answers at the back\n\tof the book, but it definitely made it a much quicker process. :) I took a similar\n\tapproach to the grid setup, but used a slightly different heuristic approach to \n    determine the tile combinations. I was pretty happy with Fizzer's \"solveCircle\" \n    method, so used that directly. If you'd like to reproduce one of these patterns, \n    I'd definitely refer to his original work, which I've linked to below. \n\n    In theory, all Truchet patterns are simple enough to produce: Partition the grid\n\tvia some kind of regular, semi-regular, or aperiodic tiling method, render \n\tsymmetrical patterns onto each tile, then randomly orientate the tile in accordance\n\twith the symmetry you've chosen.\n\n\tIn this particular case, the canvas is tessellated in a semi-regular fashion with\n\tdiamonds and octagons. A couple of arcs are renderd onto the diamond, and four arcs \n    (two different lengths) are rendered onto the octagonal tile (refer to the shader \n    imagery). To achieve the random pattern, the diamonds and octagons are randomly \n    rotated.\n\n\tOn a side note, it's a trivial matter to render the arcs in an overlapped fashion to \n\tproduce a pretty interesting looking weave. However, I thought I'd leave that for \n    another time. I might also produce a quasi 3D version at some stage.\n\n\n\n    Based on the following:\n\n\t// Like all of Fizzer's examples, it's aesthetically pleasing, and well written.\n\t4.8^2 Truchet - Fizzer\n\thttps://www.shadertoy.com/view/MlyBRG\n\n\n\t// Same principles, but more involved. Very cool looking pattern. The weaved\n\t// version would look pretty crazy.\n\t4.6.12 Truchet - Fizzer\n\thttps://www.shadertoy.com/view/llyBRG\n\n\n*/\n\n\n\n// Arc shape - Circle: 0, Octagon: 1, Hexadecagon: 2.\n//\n// The circular shape is probably the only one that looks pleasing, but I \n// wanted to show that octagonal and hexadecagonal (16 sides) arcs are possilbe.\n// Technically, the octagon option is a mixture of the two latter options.\n#define SHAPE 0\n\n\n// Root 2, or more precisely, an approximation to the principle square root of 2. :)\n#define sqrt2 1.414213562373\n\n\n//  vec2 to float hash.\nfloat hash12(vec2 p){\n\n\treturn fract(sin(dot(p ,vec2(12.9898, 78.233)))*43758.5453);\n}\n\n \n//  vec2 to vec2 hash.\nvec2 hash22(vec2 p){\n\n    return fract(sin(vec2(dot(p,vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))))*43758.5453);\n}\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n\tThis is Fizzer's circle solving function. It's very useful, and not just for this\n\tparticular example. I put in some rough comments, for anyone who wants to know how\n\tit comes about. Although, I'd doulbe check the reasoning. \n\n\tI spent quite some time trying to tackle the geometry from a different perspective, \n\tthen realized that since the points A and B would be in constant form, a lot of this \n\twould be optimized by the compiler... Would that be right? Either way, even if it \n\twasn't, it'd be possible to precalculate a lot of this anyway.\n\n\n            A\n             \\\n              \\\n  O------------C (0, 0)\n              /\n             B\n*/\n\n/*\n// Returns the origin and radius of a circle intersecting A and B, with tangents\n// at A and B pointing towards C (vec2(0)). This is for drawing the circular arcs.\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n\n    // Angle between two vectors (AC and BC) defined using an inner product.\n    // cos(th) = a.b/|a||b|\n    float th = acos(dot(normalize(a), normalize(b)))/2.; // Angle OCA\n    float adj = length(a); // Length AC.\n    r = tan(th)*adj; // r is not length OC, it's OA... 15 minutes of my life I won't get back. :)\n    o = normalize(a + b)*sqrt(r*r + adj*adj); // Direction and length of OC.\n \n}\n*/\n\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\n// The following function takes in the color, fractional coordinates, tangential arc \n// end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n// amount of arc lines.\n//\n// A lot of this is just window dressing, so I wouldn't take it too seriously. Without the\n// decoration, this'd be a pretty short function.\nvec3 doArc(vec3 col, float w, float arc, vec2  p, float aNum, float r){\n    \n    \n    // Indexing into the texture prior to coordinate manipulation.\n    vec3 tx = texture(iChannel0, p).xyz; tx *= tx;\n     \n    // Rotating the lines to a different position. Not absolutely necessary, but\n    // I thought they looked neater here.\n    p = rot2(3.14159/aNum)*p;\n    \n \n    // Using the arc distance field for a bit of sinusoidal shading. Not that important,\n    // and not the only way to do it, but it enhances the borders a bit.\n    float shade = min(abs(arc)/.1*1.25, 1.);\n    shade = clamp(-sin(shade*2.*6.283) + .25, 0., 1.);\n\n    \n    // Cell pixel angle.\n    float ang = atan(p.y, p.x); \n    // Quantizing and repeating the angle, whilst snapping to the center.\n    float ia = (floor(ang/6.2831*aNum) + .5)/aNum;\n    \n    // Polar coordinates -- Radial and angular.\n    p = rot2(ia*6.2831)*p;\n    p.x -= r; // Moving the center of the cell out to the arc radius.\n    \n\n    // Thin rectangles (spaced out around the arc), to emulated dividing lines. \n    p = abs(p);\n    float d = max(p.x - .05, p.y + .005);\n    // Cheaper, but not as nice. It's there for comparison.\n    //float d = clamp(cos(ang*aNum)*1. + .25, 0., 1.);\n    \n    // Combining the dividing lines with the arc to create the partitioned squares.\n    d = max(arc + .045, -d);\n    \n    // Dots: Interesting, but not as well suited to the example.\n    //float d = length(p) - .05;\n    \n    \n    // Arc coloring, slightly blended into  the background.\n    vec3 arcCol = mix(tx*1.5, vec3(1, .9, .8), .75);\n    \n    // Texture colored border lines.\n    col = mix(col, vec3(0), (1. - smoothstep(-w*8., w*8., arc - .04))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(-w, w, arc - .015));\n    col = mix(col, arcCol*shade*vec3(1.2, .8, .6)*vec3(1.5, .9, .6), 1. - smoothstep(-w, w, arc + .015));\n    \n     \n    // Applying the white partitioned squares.\n    col = mix(col, vec3(0), (1. - smoothstep(-w*2., w*2., d - .01))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(-w, w, d));\n    col = mix(col, arcCol, 1. - smoothstep(-w, w, d + .02));\n    \n    // Return the decorated arc color.\n    return col;\n}\n\n\n\n\n// Distance metric.\nfloat dist(vec2 p, float sc){\n    \n    #if SHAPE == 0\n    return length(p); // Circle.\n    #elif SHAPE == 1\n    p = abs(p);\n    float oct = max((p.y + p.x)/sqrt2, max(p.x, p.y)); // Octagon.\n    p *= rot2(3.14159/8.);\n    float dec = max(oct, max((p.y + p.x)/sqrt2, max(p.x, p.y)));\n    return sc<32.?  oct : dec;\n    #else    \n    p = abs(p);\n    float d = max((p.y + p.x)/sqrt2, max(p.x, p.y));\n    p *= rot2(3.14159/8.);\n    return max(d, max((p.y + p.x)/sqrt2, max(p.x, p.y))); // Hexadecagon.\n    #endif\n    \n}\n\n// The following function takes in the color, fractional coordinates, tangential arc \n// end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n// amount of arc lines.\nvec3 renderArc(vec3 col, vec2 p, vec2 a, vec2 b, float aw, float sc){\n      \n    // Falloff factor.\n    float w = 3./iResolution.y;\n\n    // Applying Fizzer's \"solveCircle\" function, which returns the\n    // origin and radius of the circle that cuts through the end-points\n    // \"a\" and \"b\".\n    vec2 o; float r;\n    solveCircle(a, b, o, r);   \n\n    // Circular distance.\n    float arc = dist(p - o, sc);\n    // Just the outer rim of the circle. \"aw\" is the width.\n    arc = abs(arc - r) - aw; \n    \n    // Render the arc. You could make this function as simple or as\n    // esoteric as you want, depending on the level of detail required.\n    col = doArc(col, w, arc, p - o, sc, r);\n\n    // Return the decorated arc color.\n    return col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Normalized pixel coordinates.\n    vec2 uv = fragCoord/min(iResolution.y, 650.);\n    \n    // Scaling and translation.\n    vec2 p = uv*4. + vec2(.5, .125)*iTime;   \n    p = rot2(3.14159/8.)*p;\n    vec2 oP = p; // Keeping a copy for later.\n    \n    // Falloff factor, based on resolution. \n    float w = 1./iResolution.y;\n    // Fizzer's falloff factor. It works, but I get a bit paranoid when it comes to\n    // the behaviour of differnt GPUs. :)\n    //float w = max(length(dFdx(p)), length(dFdy(p)))/2.;\n    \n    \n    \n    // Rendering variables.\n    \n    // Just a quick debug hack. Set the first slot to zero to omit the diamond\n    // background, and\\or the second slot to omit the octagonal background.\n    const vec2 doBg = vec2(1, 1);\n    \n    // Load in a texture, perform some round sRGB to linear conversion, then\n    // set a version of it to the background.\n    vec3 tx = texture(iChannel0, oP/4. + .3).xyz; tx *= tx;\n    vec3 bg = tx*vec3(2, 1.45, 1);\n    \n    // Initiate the color to the background.\n    vec3 col = bg;\n \n    \n    const float aw = .1; // Arc width.\n    const float scL = 80.; // Large arc scale.\n    const float scS = 16.; // Small arc scale.\n    \n    \n    // Performing a diamond octagon partitioning: It's slightly more involved than\n    // a single tile partitioning, but not that difficult.\n    //    \n    vec2 ip = floor(p); // Diamond ID.\n    p -= ip + .5; // Fractional coordinates. Equivalent to: fract(p) - .5.\n    \n    // 2D diamond field... The dimensions are calculated using basic trigonometry. \n    // Although, I was still too lazy to do it myself.\n    float dia = abs(p.x) + abs(p.y) - (1. - sqrt2/2.);\n    \n    \n    // If we're inside a diamond, then render the diamond tile. Anything outside of this\n    // will obviously be inside an octagon tile.\n    if(dia<.0){\n        \n        \n        if(doBg.x>.5){\n            \n            //vec3 dCol = mix(bg*1.5, vec3(1, .9, .8), .65);\n            vec3 dCol = bg*2.;\n            float snD = clamp(-cos(dia*6.2831*16. + 3.14159/2.)*1. + .75, 0., 1.);\n            dCol *= vec3(1, .8, .6)*snD;\n            //dCol = bg*vec3(1, 2, 3)*snD;\n            //dCol = bg*vec3(1.5, 2.125, 2.75)*snD;\n             \n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, dia - .015));\n            col = mix(col, dCol, 1. - smoothstep(-w, w, dia + .015));\n        }\n        \n        \n        // Obtain a random ID for the diamond cell, and if it's over a certain threshold,\n        // rotate it by 90 degrees; It's a standard square Truchet move.\n        if(hash12(ip + .59)>.5) p = p.yx;\n        \n        \n        // Render the two arcs (refer to the shader imagery). By the way, we're using Fizzer's \n        // \"solveCircle\" method for completeness, but you could calculate it pretty easily by hand, \n        // if necessary.\n        const float k = .5 - sqrt2/4.;\n        \n        // The following function takes in the color, fractional coordinates, tangential arc end-points, \n        // arc width, and a scaling factor -- which is necessary to plot the correct amount of arc lines.\n        col = renderArc(col, p, vec2(k, k), vec2(k, -k), aw, scS);\n        col = renderArc(col, p, vec2(-k, k), vec2(-k, -k), aw, scS);\n        \n    }\n    else {\n        \n        // If we're inside an octagon cell (outside a diamond), then obtain the \n        // ID (similar to the diaomond ID, but offset by half a cell) and \n        // fractional coordinates.\n        p = oP - .5;\n        vec2 ip = floor(p);\n        p -= ip + .5; // Equivalent to: fract(p) - .5;\n        \n        \n        // 2D octagonal bound: There's a few ways to achieve the same, but this will\n        // do. We're giving it a diameter of one, to fill up the cell. By the way, we're\n        // only using this for background decoration. Otherwise, we wouldn't need it.\n        float oct = max((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n \n        \n        // Some random numbers. It's a bit hacky, but it'll do. In fact, I should \n        // probably lash out and use one of Dave Hoskins's hash formulae.\n        vec3 rnd3 = vec3(hash22(ip + vec2(37.73, 132.57)), hash12(ip)); \n       \n        \n        \n        // If applicable, render the octagonal background pattern. I wouldn't pay too much \n        // attention to any of this. A lot of it was made up as I went along. :)\n        if(doBg.y>.5){\n            \n            \n            // Weird hack: The drop shadows make the the octagon backgrounds covered with double\n            // arcs look a little dark, so I've lit them up a little. \n            if(rnd3.x>.5 && rnd3.y>.5) col *= 1.25;\n            \n            // Random octagonal cell coloring, if you like that kind of thing.\n            //if(hash(rnd3.z*37.2 + .53)>.5) col *= vec3(1, .5, 1.5); \n            //if(hash(rnd3.z*71.3 + .71)>.5) col = mix(col.zyx, dot(col, vec3(.299, .587, .114))*vec3(1), .5);\n            // Subtle checkerboard coloring.\n            //if(mod(ip.x + ip.y, 2.)>.5) col = mix(col, col.xzy, .35);\n            //if(mod(ip.x + ip.y, 2.)<.5) col = mix(col.zyx, dot(col, vec3(.299, .587, .114))*vec3(1), .5);\n             \n            \n            // A cheap way to render some repeat lines... There are better ways, but this works.\n            float snD = clamp(cos(oct*6.2831*20. + 3.14159/2.)*2. + 1.5, 0., 1.);\n            //col *= (clamp(cos(length(p)*6.2831*20. + 3.14159/2.)*2. + 1.5, 0., 1.)*.8 + .2);\n            \n            // The octagonal border.\n            float octTor = abs(oct + .1666/2. - .015) - .1666/2. + .015;\n            col = mix(col, vec3(0), (1. - smoothstep(-w*5., w*5., octTor - .03))*.5);\n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, octTor - .015));\n            col = mix(col, bg/1.25*(snD*.75 + .25), 1. - smoothstep(-w, w, octTor + .015));\n\n           \n            // The circular or octagonal pattern inside the octagon.\n            \n            #if SHAPE == 0\n                // A circular decoration.\n                float shp = length(p) - .14;\n            #else\n                // A star variation, if that's you're thing.\n                //oct = min((abs(p.x) + abs(p.y))/sqrt2, max(abs(p.x), abs(p.y))) - .5;\n                // An octagonal center decoration.\n                float shp = oct + .1666 + .2;//max(abs(p.x), abs(p.y)) - .15;// - (1. - sqrt2/2.);\n            #endif\n            \n            snD = clamp(-sin(shp*6.2831*20. + 3.14159/2.)*1. + .5, 0., 1.); // Concentric rings.\n            \n            // Render the central bullseye pattern.\n            col = mix(col, vec3(0), 1. - smoothstep(-w, w, shp - .065));\n            col = mix(col, mix(bg*1.5, vec3(1, .9, .8), .65), (1. - smoothstep(-w*2., w*2., shp - .03)));\n            col = mix(col, vec3(0), 1. - smoothstep(-w*2., w*2., shp - .015));\n            col = mix(col, bg/1.*(snD*.95 + .05)*vec3(1.5, 2.125, 2.75), 1. - smoothstep(-w, w, shp + .015));\n          \n          \n        }\n        \n        \n        // Rendering the octagonal arc patterns over the background.\n        \n        // Use the unique octagonal ID to produce a random integer that can be used to\n        // randomly rotate the octagonal coordinates about its rotationally symmetric axes.\n        float iRnd = floor(rnd3.z*8.);\n        p = rot2(3.14159/4.*iRnd)*p;\n        \n        // A point that cuts the midway point of the top side... prior to rotation.\n        vec2 a = vec2(0, .5);\n        \n        // Rotational matrices -- to help rotate mid-points.\n        mat2 r1 = rot2(3.14159/4.), r2 = rot2(3.14159/2.), r3 = rot2(3.14159/4.*3.);\n        \n        \n        \n        \n        // I came up with this logic pretty quickly, but I think it's sound... Having said that, \n        // you'd be much better off referring to Fizzer's workings, as it's more elegant.\n        //\n        // On one side of the octagon, render either a long arc surrounding a small arc, or\n        // two adjacent small arcs. On the other side of the octagon, use another random number\n        // to do the same.\n            \n        \n        // One half of the octagon.\n        if(rnd3.x>.5){\n\n            // The following function takes in the color, fractional coordinates, tangential arc \n            // end-points, arc width, and a scaling factor -- which is necessary to plot the correct \n            // amount of arc lines.\n            col = renderArc(col, p, a, r3*a, aw, scL);\n            col = renderArc(col, p, r1*a, r2*a, aw, scS);\n        }\n        else {\n           \n            col = renderArc(col, p, a, r1*a, aw, scS);\n            col = renderArc(col, p, r2*a, r3*a, aw, scS);\n        }\n           \n        a = -a; // Simple way to render the other half.\n   \n        // Other half of the octagon.\n        if(rnd3.y>.5){\n       \n            col = renderArc(col, p, a, r3*a, aw, scL);\n            col = renderArc(col, p, r1*a, r2*a, aw, scS);\n        }\n        else {\n            \n            col = renderArc(col, p, a, r1*a, aw, scS);\n            col = renderArc(col, p, r2*a, r3*a, aw, scS);\n        }\n\n        \n    }\n    \n     \n    // Mixing in a bit of pink down the bottom of the canvas, to give a sunset feel? :)\n    col = mix(col.xzy, col, pow(uv.y, .25));\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\n\n    \n    \n    // Rough gamma correction and output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}