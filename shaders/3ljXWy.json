{
    "Shader": {
        "info": {
            "date": "1567753354",
            "description": "Experiment with fractals and raymarching, based on my previous raymarcher: https://www.shadertoy.com/view/3lsSWr\nIt supports multiple lights, adding them into the SceneInit method",
            "flags": 0,
            "hasliked": 0,
            "id": "3ljXWy",
            "likes": 2,
            "name": "Planet Broccoli",
            "published": 3,
            "tags": [
                "raymarching",
                "fractal",
                "mandelbulb"
            ],
            "usePreview": 0,
            "username": "LudusEstArs",
            "viewed": 750
        },
        "renderpass": [
            {
                "code": "vec2 NormalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat CheckersGradBox(vec2 p)\n{ // iquilezles.org/articles/checkerfiltering\n    vec2 w = fwidth(p) + .001;\n    vec2 i = 2.0 * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    return .5 - .5*i.x*i.y;\n}\n\nmat3 ComputeRotationMatrix(const float x, const float y, const float z)\n{ // NOTE: mat = (firstCOLUMN, secondCOLUMN, thirdCOLUMN);\n    mat3 o = mat3(0);\n    \n   \to  = mat3( 1.0, 0.0\t,  0.0,\t\t\n             0.0, cos(x), -sin(x),\n             0.0, sin(x), cos(x)  );\n    \n\to *= mat3( cos(y), 0.0, sin(y),\n               0.0\t , 1.0, 0.0,\n               -sin(y), 0.0, cos(y) );\n    \n\to *= mat3( cos(z), -sin(z), 0.0,\n               sin(z), cos(z) , 0.0,\n               0.0\t , 0.0    , 1.0 );\n    return o;\n}\n///////////////////////////////////////////////////////////////////////////////\n\n// Configure the scene\nvoid SceneInit(out Scene s)\n{\n    // Setup camera\n    s.cam.pos \t  = vec3(0,0,-2.5);\n    s.cam.forward = vec3(0,0,1);\n    s.cam.right   = normalize(cross(vec3(0, 1, 0), s.cam.forward));\n    s.cam.up      = normalize(cross(s.cam.forward, s.cam.right));\n    s.cam.fPersp  = 2.0;\n\n    // Main Light\n    Light dirLight;\n\tdirLight.type      = DIRECTIONAL;//POINT;\n    dirLight.pos       = vec3(2,3,-1);\n    dirLight.dir       = normalize(-dirLight.pos);\n    dirLight.color \t   = vec3(0.35,0.30,0.25);\n    dirLight.range     = MAX_DISTANCE;\n    dirLight.intensity = 3.;\n\n    s.lights[0] = dirLight;\n    \n    // Mandelbulb\n    Shape mb;\n    mb.blendType = NO_OP;\n    mb.type      = MANDELBULB;\n    mb.radii     = vec2(8.+ 2.*-cos(iTime*.1), 2);\n    mb.pos       = vec3(0);\n    mb.scale     = vec3(1);\n    mb.rot  \t = ComputeRotationMatrix(cos(iTime*.25), sin(iTime*.25), 0.);\n    mb.color     = vec4(VERMILION, 1);\n    mb.normal    = vec4(0);\n    mb.glossy    = 0.;\n    \n    s.objects[0] = mb;\n\n    return;\n}\n\nvoid Blend(inout Shape current, inout float currentD,\n           Shape candidate, float candidateD)\n{ // Based on IÃ±igo Quilez's smooth min algorithm:\n  // iquilezles.org/articles/smin\n    \n    float b = (candidate.blendStrength > 0.) ? candidate.blendStrength : EPSILON;\n    float h = clamp(.5+.5*(candidateD-currentD)/b, 0., 1.);\n    \n    currentD       = mix(candidateD, currentD, h) -\n                         candidate.blendStrength * h * (1.- h);\n    current.color  = mix(candidate.color, current.color, h);\n    current.normal = mix(candidate.normal, current.normal, h);\n    \n    // TODO: Find a better way to interpolate the texture / patterns\n    current.type   = (h>=.5) ? current.type   : candidate.type;\n\t// TODO: Find a better way to interpolate glossiness\n    current.glossy = (h>=.5) ? current.glossy : candidate.glossy;\n}\n\nfloat GetShapeDst(Shape s, vec3 eye, out vec4 aux)\n{\n    float o = MAX_DISTANCE + 1.;\n    vec3 p = s.rot * (s.pos-eye);\n    \n    switch(s.type)\n    {\n        case FLOOR_PLANE:\n        \to = PlaneSDF(eye, s.pos, s.normal);\n        \tbreak;\n        case SPHERE:\n           \to = SphereSDF(eye, s.pos, s.radii.x);\n        \tbreak;\n        case BOX:\n           \to = BoxSDF(p, s.scale);\n        \tbreak;\n        case TORUS:\n        \to = TorusSDF(p, s.radii);\n        \tbreak;\n        case MANDELBULB:\n        \to = MandelbulbSDF(p, s.radii.x, s.radii.y, aux);\n        \tbreak;\n        default:\n        \tbreak;\n    }\n    \n    return o;\n}\n\nRayIntersection GetNearestShape(vec3 origin)\n{\n    RayIntersection o;\n    o.dist = MAX_DISTANCE;\n    \n    float shapeD;\n    Shape s;\n    \n    for (int i=0; i<NUM_SHAPES; i++)\n    {\n        s = scene.objects[i];\n\t\t\n        \n        if (s.type == MANDELBULB)\n        {\n            shapeD = GetShapeDst(s, origin, s.color);\n        }\n        else\n        {\n            vec4 trash = vec4(0);\n            shapeD = GetShapeDst(s, origin, trash);\n        }\n        \n        switch (s.blendType)\n        {\n            case NO_OP:\n                if (shapeD<o.dist)\n        \t\t{\n            \t\to.shape = s;\n            \t\to.dist  = shapeD;\n        \t\t}\n            \tbreak;\n            \n  \t\t\tcase BLEND:\n            \tBlend(o.shape, o.dist, s, shapeD);\n            \tbreak;\n            \n            case CUT: // TODO\n            \tbreak;\n            \n            case MASK: // TODO\n            \tbreak;\n\t\t\t\n            default:\n            \tbreak;\n        }\n    }\n    \n    return o;\n}\n\nvec3 ComputeNormals(vec3 p)\n{\n    vec3 o;\n    \n    vec3 epsilonX = vec3(EPSILON, 0, 0);\n    vec3 epsilonY = vec3(0, EPSILON, 0);\n    vec3 epsilonZ = vec3(0, 0, EPSILON);\n    \n    // To estimate the normal in an axis, from a surface point, we move slightly\n    // in that axis and get the changing in the distance to the surface itself.\n    // If the change is 0 or really small it means the surface doesn't change in that\n    // direction, so its normal in that point won't have that axis component.\n    float reference = GetNearestShape(p).dist;\n    o.x = GetNearestShape(p+epsilonX).dist - reference;\n    o.y = GetNearestShape(p+epsilonY).dist - reference;\n    o.z = GetNearestShape(p+epsilonZ).dist - reference;\n    \n    return normalize(o);\n}\n\nRayIntersection CastRay(const Ray r, const float max_dst)\n{\n    RayIntersection o;\n    o.ray         = r;\n \to.dist        = MAX_DISTANCE;\n    o.shadow      = MAX_DISTANCE;\n    o.shape.type  = NO_SHAPE;\n    \n    int i = 0;\n    float travelDist = EPSILON * .5;\n    RayIntersection tmpRI;\n    \n    while (travelDist<max_dst && i<MAX_ITERATIONS)\n    {\n        i++;\n\n\t\ttmpRI = GetNearestShape(r.o + r.d*travelDist);\n        \n        travelDist += tmpRI.dist;\n        \n        // Soft shadows\n        o.shadow = min(o.shadow, SOFT_SHADOWS_C*tmpRI.dist/travelDist);\n        \n        if (tmpRI.dist < EPSILON)\n        { // We collided\n            o.pos      = r.o + r.d*travelDist;\n            o.shape    = tmpRI.shape;\n            o.dist     = travelDist;\n\n            if (o.shape.normal == vec4(0))\n            { // Avoid computing the normals of shapes that already have them\n              // (such as planes)\n            \to.shape.normal = vec4(ComputeNormals(o.pos), 1);\n            }\n            break;\n        }\n    }\n    \n    if (o.shape.type == FLOOR_PLANE)\n    {\n    \to.shape.color = vec4(vec3(CheckersGradBox(o.pos.xz*.5)*.5 + .25), 1);\n        o.shape.glossy *= o.shape.color.r;\n    }\n\n    o.numIt = i;\n    return o;\n}\n\nRay GetCameraRay(Camera cam, const vec2 uv)\n{\n    Ray o;\n    \n    o.o = cam.pos;\n  \to.d = normalize(uv.x * cam.right +\n                    uv.y * cam.up +\n                    cam.forward * cam.fPersp);\n    return o;\n}\n\nvoid ApplyFog(inout vec3 c, const float d)\n{\n    float m = exp(-d*d*.001);\n    c = mix(FOG_COLOR, c, m);\n}\n\nvoid SmoothCubeMapHorizon(inout vec3 c, const vec3 cm, float d)\n{\n    float m = exp(-d*d*.001);\n    c = mix(cm, c, m);\n}\n\nfloat ComputeShadow(const vec3 p, const vec3 n, const vec3 L, const float d2l)\n{\n    float shadow = 1.0;\n    \n    Ray r;\n    r.o = p + n*SHADOW_BIAS; // Without this, the ray doesn't leave the surface\n    r.d = L;\n    \n    RayIntersection ri = CastRay(r, d2l);\n    if (ri.shape.type != NO_SHAPE) shadow = 0.0;\n    else shadow = clamp(ri.shadow, .0,1.0);\n\n    return shadow;\n}\n\nfloat ComputeAO(const vec3 p, const vec3 n)\n{\n    float ao = 0.0;\n    \n    int   i = 0;\n    float r,d;\n    while (i<AO_NUM_STEPS)\n    {\n        i++;\n        d = AO_STEP_SIZE * float(i);\n    \tr = GetNearestShape(p + n*d).dist;\n   \n        ao += max(0.0, (d-r)/d);\n    }\n    \n    return 1.0 - ao*AO_INTENSITY;\n}\n\nvoid DoTheLighting(RayIntersection ri, out vec4 c)\n{\n    float attByDst;\n    float NoL, specAngle;\n    float shadow, ao;\n    float d2l = MAX_DISTANCE;\n    vec3  diffuse, specular;\n    vec3  L, halfVec;\n    vec4  ambient;\n    \n    if (ri.shape.type == MANDELBULB)\n    {           \n        // Base orbit trap color\n        vec3 orbitColor = vec3(0.01);\n        orbitColor = mix(orbitColor, vec3(0.6, 0.37, 0.22),\n                         clamp(pow(abs(ri.shape.color.y), 1.), 0., 1.));\n        orbitColor = mix(orbitColor, vec3(0.6, 0.37, 0.22),\n                         clamp(pow(abs(ri.shape.color.z), 1.), 0., 1.));\n        orbitColor = mix(orbitColor, vec3(0.1, 0.3, 0.1),\n                         clamp(pow(abs(ri.shape.color.w), 16.), 0., 1.));\n        \n        // Ambient Occlusion\n        // NOTE: The orbit trap based AO estimation is more aesthetically pleasing\n        //       (and cheaper) than the more precise version I already had in the\n        //\t\t 'DoTheLighting' function.\n        ao = clamp(0.1 * log(ri.shape.color.x), 0., 1.);\n        \n        ri.shape.color.rgb = orbitColor;\n    }\n    else\n    {\n        ao = ComputeAO(ri.pos, ri.shape.normal.xyz);\n    }\n    \n\tfor (int i=0; i<NUM_LIGHTS; i++)\n    {\n        if (scene.lights[i].type == DIRECTIONAL)\n        {\n\n            L \t\t = -scene.lights[i].dir;\n            attByDst = 1.0;\n        }\n        else if (scene.lights[i].type == POINT)\n        {\n            vec3  p2l = scene.lights[i].pos - ri.pos;\n            d2l = length(p2l); \n            if (d2l > scene.lights[i].range) continue;\n            attByDst = (scene.lights[i].range - d2l) /\n                \t\tmax(scene.lights[i].range, EPSILON);\n            L = normalize(p2l);\n        }\n\n        // BLINN-PHONG\n        // Diffuse component\n        NoL      = clamp(dot(L, ri.shape.normal.xyz), .0, 1.0);\n        diffuse += NoL * attByDst *\n            \t   scene.lights[i].color * scene.lights[i].intensity;\n        \n        // Specular component\n        if (NoL >= .0 && ri.shape.glossy > .0)\n        {\n            halfVec    = normalize(-ri.ray.d + L);\n            specAngle  = clamp(dot(ri.shape.normal.rgb, halfVec), .0, 1.0);\n            specular  += pow(abs(specAngle), ri.shape.glossy*512.) * attByDst *\n                \t\t scene.lights[i].color * scene.lights[i].intensity;\n        }\n\n        shadow += ComputeShadow(ri.pos, ri.shape.normal.xyz, L, d2l);\n    }\n    \n    ambient = vec4(AMBIENT_LIGHT, 1);\n\n    // Combine all the illumination components\n    c  = ri.shape.color * vec4(diffuse, 1);\n    c *= shadow * ao;\n    c += ri.shape.color * ambient;\n\tc += vec4(specular, 0);\n    \n    // DEBUG: Normals\n    //c = ri.shape.normal;\n    // DEBUG: Ambient Occlusion\n    //c = vec4(ao,ao*.5,0,1);\n    \n    // NOTE: Applying the fog here keeps the sky gradient,\n    // but makes the horizon look too sharp\n\t//ApplyFog(c.rgb, ri.distance);\n}\n\nvec3 ComputeReflection(inout Ray r, const float g)\n{\n    RayIntersection ri = CastRay(r, MAX_REFLECTION_DIST);\n    \n    r = ri.ray;\n    \n    vec4 o = vec4(BLACK,1);\n    DoTheLighting(ri, o);\n    \n    return mix(BLACK, o.rgb, g).rgb * REFLECTION_INTENSITY * g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SceneInit(scene);\n    \n    vec2 uv = NormalizeScreenCoords(fragCoord);\n    Ray ray = GetCameraRay(scene.cam, uv);\n    \n    RayIntersection ri = CastRay(ray, MAX_DISTANCE);\n    \n\tif (ri.shape.type != NO_SHAPE)\n    { // Illuminate the object\n        DoTheLighting(ri, fragColor);\n    }\n    else\n    { // Sky\n        fragColor.rgb = mix(TEAL, SKY_COLOR, uv.y);\n    }\n    \n\t// \"Mist\"\n    fragColor.rgb += vec3(float(ri.numIt)/float(MAX_ITERATIONS)) *\n        \t\t\t FOG_DENSITY * FOG_COLOR;\n    \n    // Gamma\n    fragColor.rgb  = sqrt(fragColor.rgb);\n    // Vignette\n    fragColor.rgb *= 1. - VIGNETTE_STR * length(uv);\n    \n    // Just in case\n    fragColor.w = 1.;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// CONSTANTS ///////////////////////////////////////////\n// Usual colors\nconst vec3 BLACK     = vec3(0);\nconst vec3 WHITE     = vec3(1);\nconst vec3 RED    \t = vec3(1,0,0);\nconst vec3 GREEN  \t = vec3(0,1,0);\nconst vec3 BLUE   \t = vec3(0,0,1);\nconst vec3 TEAL   \t = vec3(.21, .46, .53);\nconst vec3 VERMILION = vec3(.89, .26, .2); \n\n// Scene info\nconst int   NUM_SHAPES    = 1;\nconst int   NUM_LIGHTS    = 1;\nconst float FOG_DENSITY   = 0.175;\nconst float VIGNETTE_STR  = 0.25;\nconst vec3  SKY_COLOR     = vec3(0, .25, .5);\nconst vec3  FOG_COLOR     = WHITE;\nconst vec3  AMBIENT_LIGHT = TEAL*0.1;\n\n// Ray marching variables\nconst int   MAX_ITERATIONS = 256;\nconst float MAX_DISTANCE   = 128.0;\nconst float EPSILON        = 0.0025;\n\n// Shadows\nconst float SHADOW_BIAS    = EPSILON * 50.0;\nconst float SOFT_SHADOWS_C = 16.0;\n\n// Ambient Occlusion\nconst int   AO_NUM_STEPS = 3;\nconst float AO_STEP_SIZE = 0.05;\nconst float AO_INTENSITY = 0.25;\n\n// Shape types\nconst int FLOOR_PLANE = 0;\nconst int SPHERE      = 1;\nconst int BOX         = 2;\nconst int TORUS       = 3;\nconst int MANDELBULB  = 4;\nconst int NO_SHAPE    = 999;\n\n// Blend operations\nconst int NO_OP = 0;\nconst int BLEND = 1;\nconst int CUT   = 2;\nconst int MASK  = 3;\n\n// Light types\nconst int DIRECTIONAL = 0;\nconst int POINT       = 1;\n\n// Reflections\nconst int   MAX_REFLECTION_STEPS = 1;\nconst float MAX_REFLECTION_DIST  = MAX_DISTANCE * .5;\nconst float REFLECTION_INTENSITY = .5;\n////////////////////////////////////////////////////////\n\n// SDFs ////////////////////////////////////////////////\n// iquilezles.org/articles/distfunctions\nfloat PlaneSDF(vec3 eye, vec3 p, vec4 n)\n{ // NOTE: n must be normalized\n    return dot(eye-p, n.xyz) + n.w;\n}\n\nfloat SphereSDF(vec3 eye, vec3 p, float r)\n{ \n\treturn distance(p,eye) - r;\n}\n\nfloat BoxSDF(vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) +\n        \tmin(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat TorusSDF(vec3 p, vec2 radii)\n{\n\tvec2 q = vec2(length(p.xz) - radii.x, p.y);\n    return length(q) - radii.y;\n}\n\nfloat MandelbulbSDF(vec3 position,\n                    float power, float limit,\n                    inout vec4 orbitTraps)\n{\n    float rad,phi,theta; // radius, azimuth and inclination\n    float dr   = 1.0;\n    float rad2 = dot(position, position);\n    vec3  c = position;\n    \n    orbitTraps = vec4(abs(position), rad2);\n    \n    for (int i=0; i<4; i++)\n    {\n    \t// Convert to polar coordinates\n        rad   = length(c);\n        theta = acos(c.y / rad);\n        phi   = atan(c.x, c.z);\n        \n        dr = power * pow(rad, power-1.) * dr + 1.;\n        \n        // Scale and rotate\n    \trad    = pow(rad, power);\n   \t\tphi   *= power;\n    \ttheta *= power;\n        \n        // Back to cartesian\n        c.x  = sin(phi) * sin(theta);\n    \tc.y  = cos(theta);\n    \tc.z  = sin(theta) * cos(phi);\n    \tc   *= rad;\n    \t\n        c += position;\n        \n        orbitTraps = min(orbitTraps, vec4(abs(c), rad2));\n        \n        rad2 = dot(c,c);\n        if (rad2 > limit*limit) break;\n    }\n    \n    orbitTraps = vec4(rad2, orbitTraps.xyw); // Magnitude^2 | In X | In Y | Previous Magnitude^2\n\n    //color = vec4(rad, color.xyw);\n    return 0.25*log(rad2) * sqrt(rad2) / dr;\n}\n////////////////////////////////////////////////////////\n\n// DATA STRUCTS ////////////////////////////////////////\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Camera\n{\n    float fPersp;\n    vec3  pos, forward, up, right;\n};\n\nstruct Light\n{\n    int   type;\n    float range, intensity;\n    vec3  pos, dir;\n    vec3  color;\n};\n    \nstruct Shape\n{\n    int    type, blendType;\n    float  glossy, blendStrength;\n    vec2   radii; // SPHERE: X\n    \t\t\t  // TORUS: X=external, Y=internal\n    \t\t\t  // MANDELBULB: X=power, Y=limit\n    vec3   pos, scale;\n    vec4   color, normal;\n    mat3   rot;\n};\n    \nstruct RayIntersection\n{\n\tint   numIt;\n    float dist;\n    float shadow;\n    vec3  pos;\n    Ray   ray;\n    Shape shape;\n};\n    \nstruct Scene\n{\n    vec4 ambientLight;\n    Camera cam;\n    Light[NUM_LIGHTS] lights;\n    Shape[NUM_SHAPES] objects;\n};\n////////////////////////////////////////////////////////\n    \n// GLOBALS /////////////////////////////////////////////\nScene scene;\n////////////////////////////////////////////////////////",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}