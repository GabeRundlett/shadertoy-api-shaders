{
    "Shader": {
        "info": {
            "date": "1597004965",
            "description": "My first shader on shadertoy",
            "flags": 0,
            "hasliked": 0,
            "id": "WtffzB",
            "likes": 6,
            "name": "Library by MareeBree",
            "published": 3,
            "tags": [
                "library"
            ],
            "usePreview": 0,
            "username": "mareebree",
            "viewed": 318
        },
        "renderpass": [
            {
                "code": "#define eNISTA 0\n#define eFIOKA 1\n#define eKNJIGE 2\n\n#define BROWN vec3(0.647,0.325,0.094)\n#define GOLD vec3(1.0,0.843,0.0)\n\n#define LOCAL_UV_SIZE \tvec2(4.0,6.0)\n#define LOCAL_UV_OFFSET vec2(0.05*iTime,0.5*iTime)\n\n#define ASPECT_RATIO iResolution.x/iResolution.y\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// -------------b\n// |\t\t\t|\n// |\t\t\t|\n// a-------------\nbool inRect(vec2 x ,vec2 a, vec2 b)\n{\n    return x.x > a.x && x.x < b.x && x.y > a.y && x.y < b.y;\n}\n\nfloat aspectDist(vec2 x,vec2 y)\n{\n    return length((x-y)*vec2(ASPECT_RATIO,1.0));\n}\n\nvec2 localUVSpace(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    uv *= LOCAL_UV_SIZE;\n    uv = fract(uv);\n    return uv;\n}\n\nvec2 localUVIndex(vec2 uv)\n{\n    uv += LOCAL_UV_OFFSET;\n    vec2 uvRatio = 1.0/LOCAL_UV_SIZE;\n    return floor(uv/uvRatio);\n}\n\nint getItem(vec2 index)\n{\n    float r = rand(index/1000.0);\n    if(r > 0.7) \t\t\treturn eFIOKA;\n    else if(r > 0.1) \t\treturn eKNJIGE;\n    else \t\t\t\t\treturn eNISTA;\n}\n\nvec3 drawFioka(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.2;\n    float fd = 0.15;\n    \n    vec3 col = BROWN;\n    vec2 edge_col = smoothstep(0.85,0.98,uv);\n    col -= max(edge_col.x,edge_col.y);\n    edge_col = smoothstep(0.80,0.98,vec2(1.0)-uv);\n    edge_col += smoothstep(0.85,0.98,vec2(1.0)-uv);\n    col -= max(edge_col.x,edge_col.y);\n    col = max(col,0.4*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.6*BROWN);\n    \n    float handleSize = 0.1;\n    vec3 handleColor = 0.6*BROWN;\n    float handleDist = aspectDist(uv,vec2(0.5));\n    handleColor *= smoothstep(0.15,0.11,handleDist);\n    col -= handleColor;\n\n    vec2 reflectionOffset = uvIndex*vec2(0.01,0.02);\n    reflectionOffset.x = clamp(-0.03,0.03,reflectionOffset.x);\n    reflectionOffset.y = clamp(-0.03,0.03,reflectionOffset.y);\n\n    vec2 reflectionPos = vec2(0.5) + reflectionOffset;\n    float reflectionDist = aspectDist(uv,reflectionPos);\n    col += smoothstep(0.04,0.001,reflectionDist);    \n\t\n    return col;\n}\n\nvec3 drawKnjige(vec2 uv,vec2 uvIndex)\n{\n    int numBooks = 6;\n    \n    vec2 bookUV = uv;\n\tbookUV.x = fract(uv.x*float(numBooks));\n    int bookIndex = int(uv/(1.0/float(numBooks)));\n    \n    float r = rand(vec2(bookIndex,uvIndex.x + uvIndex.y/2.0));\n    vec3 bookColorHSV = vec3(r,0.8,0.6);\n    vec3 bookColor = hsv2rgb(bookColorHSV);\n    \n    float bookMask = sin(3.14*bookUV.x);\n    \n    float trakaPos = bookUV.y+0.05*bookMask-0.05*r;\n   \t\n    float t = smoothstep(0.13,0.14,trakaPos);\n    float traka = min(t,smoothstep(0.20,0.19,trakaPos));\n    \n    traka *= bookMask*0.4;\n    vec3 trakaColor = GOLD*0.4;\n    \n    vec3 col = bookColor*bookMask + traka*trakaColor;\n    col += smoothstep(0.2,0.1,bookMask)*0.6*BROWN;\n    col += vec3(traka)*bookMask;\n    \n    col = clamp(col,0.0,1.0);\n    return col;\n}\n\nvec3 drawPolica(vec2 uv, vec2 uvIndex)\n{\n    float fs = 0.15; // Frame size\n    float fd = 0.10; // Frame depth\n    \n    vec3 col = vec3(0.0);\n\tcol = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.x)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.x)*BROWN);\n    col = max(col,smoothstep(1.0-fs,1.0-fs+fd,uv.y)*BROWN);\n    col = max(col,smoothstep(fs,fs-fd,uv.y)*BROWN);\n    col = max(col,0.5*BROWN);\n    \n    bool shouldDrawBooks = inRect(uv,vec2(fs),vec2(1.0-fs));\n    vec2 booksUV = uv;\n    booksUV -= vec2(fs);\n    booksUV /= 1.0-2.0*fs;\n    col = mix(col,drawKnjige(booksUV,uvIndex),float(shouldDrawBooks));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= (1.3 + 0.3*sin(iTime))*iResolution.x/800.0;\n    uv.x += 0.03*uv.y*(-uv.x);\n    \n    vec2 localUV = localUVSpace(uv);\n    vec2 localIndex = localUVIndex(uv);\n    vec3 col = vec3(0);\n    \n    int item = getItem(localIndex);\n    if(item == eFIOKA)\n    {\n\t   col = drawFioka(localUV,localIndex);\n    }\n    else if(item == eKNJIGE)\n    {\n        col = drawPolica(localUV,localIndex);\n    }\n\telse\n    {\n       col = BROWN;\n    }\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}