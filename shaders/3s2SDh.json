{
    "Shader": {
        "info": {
            "date": "1553625587",
            "description": "Three scenes, 45s in total.\n\ntunnel, chaos, branches, text, poem, haiku\n\nEnglish version:\n[url=https://www.shadertoy.com/view/3djXDh]I had a dream about it[/url]\n",
            "flags": 32,
            "hasliked": 0,
            "id": "3s2SDh",
            "likes": 2,
            "name": "Egyszer álmodtam róla",
            "published": 3,
            "tags": [
                "tunnel",
                "text",
                "chaos",
                "haiku",
                "branches",
                "poem"
            ],
            "usePreview": 0,
            "username": "gambhiro",
            "viewed": 439
        },
        "renderpass": [
            {
                "code": "/*\n\n  Egyszer álmodtam róla\n  ----------------------\n\n  https://www.shadertoy.com/view/3s2SDh\n\n  English version: I had a dream about it\n  https://www.shadertoy.com/view/3djXDh\n\n  (2019-03-26)\n\n  egyszer álmodtam róla\n  hol a kiút, mit kell tenni\n  próbálok rá emlékezni\n\n  az ismeretlen változik\n  hiába a szokott minta\n  a káosz nem illeszkedik\n\n  ami eddig is igaz volt\n  azt nem nekem kell létrehozni\n  -- akár szerethetem is.\n\n  tunnel, chaos, branches, text, poem, haiku\n\n*/\n\n// image composition pass\n\n#define i_time iTime\n#define i_resolution iResolution\n\n#define tex_tunnel iChannel0\n#define tex_chaos iChannel1\n#define tex_branches iChannel2\n#define tex_text iChannel3\n\nvec3 print_line(sampler2D tex_sampler, int line, float scale, vec2 offset, vec2 uv);\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec3 col = vec3(0.0);\n\n  float flash, txt1, txt2, txt3 = 0.0;\n\n  float t, t0, t1 = 0.;\n  // three stages: 15s, 10s, 20s\n  t = mod(i_time, 45.0);\n\n  // sampling in texture plane, (0,0) is lower-left, (1,1) is top-right\n  vec2 uv = frag_coord.xy / i_resolution.xy;\n\n  if (t < 15.0) {\n\n    t0 = 0.; t1 = 15.;\n    txt1 = smoothstep(t0, t1-5., t); txt2 = 0.0; txt3 = 0.0;\n\n    col = texture(tex_tunnel, uv).rgb;\n\n    // a 2s flash at the end\n    flash = smoothstep(t1-2., t1-.5, t);\n\n  } else if (t < 25.) {\n\n    t0 = 15.; t1 = 25.;\n    txt1 = 0.0; txt2 = smoothstep(t0, t1-5., t); txt3 = 0.0;\n\n    col = texture(tex_chaos, uv).rgb;\n\n    // a 2s flash at the end\n    flash = smoothstep(t1-2., t1-.5, t);\n\n  } else if (t < 45.) {\n\n    t0 = 25.; t1 = 45.;\n    txt1 = 0.0; txt2 = 0.0; txt3 = smoothstep(t0, t1-5., t);\n\n    col = texture(tex_branches, uv).rgb;\n\n    // a 3s flash at the end\n    flash = smoothstep(t1-3., t1-.5, t);\n\n  }\n\n  // --- Flash ---\n\n  col = mix(col, vec3(1.), flash);\n\n  // --- Gamma ---\n\n  col = pow(col, vec3(2.01)); // stronger colours\n  col = vec3(1.0) - exp(-col * 1.5); // exposure hdr\n  col = pow(col, vec3(1.0/2.2)); // gamma\n\n  // --- Text Overlay ---\n\n  vec2 o = vec2(0.);\n  float sc = 1.9;\n\n  o = vec2(0.1, 0.0);\n  col += txt1 * print_line(tex_text, 2, sc, o, uv);\n  col += txt1 * print_line(tex_text, 3, sc, o, uv);\n  col += txt1 * print_line(tex_text, 4, sc, o, uv);\n\n  o = vec2(0.35, 0.2);\n  col += txt2 * print_line(tex_text, 2, sc, o, uv);\n  col += txt2 * print_line(tex_text, 3, sc, o, uv);\n  col += txt2 * print_line(tex_text, 4, sc, o, uv);\n\n  o = vec2(0.6, 0.1);\n  col += txt3 * print_line(tex_text, 2, sc, o, uv);\n  col += txt3 * print_line(tex_text, 3, sc, o, uv);\n  col += txt3 * print_line(tex_text, 4, sc, o, uv);\n\n  frag_color = vec4(col, 1.0);\n}\n\nvec3 print_line(sampler2D tex_sampler, int line, float scale, vec2 offset, vec2 uv) {\n  vec3 col = vec3(0.);\n\n  float r = i_resolution.x / i_resolution.y;\n  vec2 txt_uv = (uv - offset) * scale;\n  float lh = 1.0/10.0; // line height\n\n  if (txt_uv.x < (1.0/r) && txt_uv.x > 0.0 &&\n      txt_uv.y < (1.0 - float(line)*lh) && txt_uv.y > (1.0 - float(line+1)*lh)) {\n\n    txt_uv.x *= r;\n    vec3 txt = texture(tex_sampler, txt_uv).rgb;\n\n    vec2 eps = vec2(0.001);\n    txt += texture(tex_sampler, txt_uv + eps).rgb;\n    txt += texture(tex_sampler, txt_uv - eps).rgb;\n    txt /= 3.0;\n    col += vec3(1.0) - txt;\n  }\n\n  return col;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Torus Tunnel\n\n#define i_resolution iResolution\n#define i_time mod(iTime, 45.0)\n\n#define scene_time i_time*0.1\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2.0*PI;\n\nvec3 g_camera_pos = vec3(0.);\nvec3 g_camera_front = vec3(0.);\nvec3 g_light_pos = vec3(0.);\n\nconst float g_tunnel_rad = 50.0;\nconst float g_tunnel_tube_rad = 10.0;\n\nvec2 hash(vec2 x);\nfloat iq_noise(in vec2 p);\nfloat lightAttenuation(vec3 light_pos, vec3 surf_pos, float radius);\nvec2 opU(vec2 d1, vec2 d2);\nvoid pR(inout vec2 p, float a);\nfloat opModPolar(inout vec2 p, float repetitions);\nfloat sdTorus(vec3 p, vec2 t);\nfloat sdBox(vec3 p, vec3 b);\nvec3 checkerBoard(vec2 pos);\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin);\nvec3 calcNormal(in vec3 pos);\nfloat calcAO( in vec3 pos, in vec3 nor );\n\n// iq https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 x ) {\n  const vec2 k = vec2( 0.3183099, 0.3678794 );\n  x = x*k + k.yx;\n  return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat sdTunnel(in vec3 p) {\n  float res = -sdTorus(p, vec2(g_tunnel_rad, g_tunnel_tube_rad));\n\n  // spotty bumps\n  vec3 q = p;\n  float theta = atan(abs(q.z), q.x) / PI;\n  float phi = atan(abs(q.y), length(q.xz) - g_tunnel_rad) / PI;\n  res += clamp((iq_noise(vec2(theta, phi)*200.0))*2.5*sin(phi*0.05), -0.005, 0.005);\n\n  return res;\n}\n\nfloat sdBoxes(in vec3 p) {\n  vec3 q = p;\n  float cell = opModPolar(q.zx, 44.0);\n  q -= vec3(0.0, 0.0, 50.0);\n  pR(q.zy, cell*radians(11.0));\n\n  float res = sdBox(q, vec3(2.9));\n\n  return res;\n}\n\nvec2 map(in vec3 p) {\n  pR(p.zx, scene_time);\n  vec2 res = vec2(sdTunnel(p), 1.0);\n  res = opU(res, vec2(sdBoxes(p), 2.0));\n  // show the light position\n  //res = opU(res, vec2(sdBox(p - g_light_pos, vec3(.2)), 4.0));\n  return res;\n}\n\nvec3 tunnel_color(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 nor) {\n  pR(pos.zx, scene_time);\n  vec3 final_col = vec3(0.);\n  vec3 view_dir = normalize(ro - pos);\n  vec3 light_dir = normalize(pos - g_light_pos);\n\n  float diff = max(dot(nor, -light_dir), 0.0);\n  float att = lightAttenuation(g_light_pos, pos, 80.0);\n\n  vec3 col = checkerBoard(vec2(1.0, pos.x * 20.0 / 360.0));\n\n  col = diff * col + 0.2 * col;\n  col *= max(att, 0.3);\n\n  col = pow(col, vec3(4.0));\n  final_col = clamp(col, 0.0, 1.0);\n  return final_col;\n}\n\nvec3 material_color(in vec3 ro, in vec3 rd, in float mat_id, in vec3 pos) {\n  vec3 final_col = vec3(0.);\n  vec3 nor = vec3(0.);\n\n  if (mat_id > -1.0) {\n    nor = calcNormal(pos);\n  }\n\n  if (mat_id == 1.0) {\n\n    // Tunnel\n\n    final_col = tunnel_color(ro, rd, pos, nor);\n\n  } else if (mat_id == 2.0) {\n\n    // Cube\n\n    vec3 col = vec3(0.);\n    vec3 view_dir = normalize(ro - pos);\n\n    // reflection\n    vec3 ref_dir = reflect(-view_dir, nor);\n    vec2 ref_res = castRay(pos, ref_dir, 0.1);\n    vec3 p = pos + ref_dir * ref_res.x;\n\n    vec3 ref_col = vec3(0.);\n\n    if (ref_res.y == 1.0) {\n      // reflection hit = tunnel\n      vec3 n = calcNormal(p);\n      ref_col = tunnel_color(pos, ref_dir, p, n);\n    } else if (ref_res.y == 2.0) {\n      // reflection hit = the cube again\n      ref_col = col;\n    }\n\n    col = ref_col;\n\n    final_col = clamp(col, 0.0, 1.0);\n  }\n\n  return final_col;\n}\n\n// === Main ===\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  // normalized image plane\n  vec2 p = -1.0 + 2.0 * frag_coord.xy / iResolution.xy;\n  p.x *= iResolution.x / iResolution.y;\n\n  // === Camera ===\n\n  g_camera_pos = vec3(48.0, -7.5, 0.0);\n  g_camera_front = vec3(-0.16, 0.4, 1.5);\n  g_light_pos = vec3(15.0, 10.0, 1.0);\n\n  // camera position\n  vec3 ro = g_camera_pos;\n\n  // camera matrix\n  vec3 ww = normalize(g_camera_front);\n  vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  // view ray\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  // === Render ===\n\n  vec2 res = castRay(ro, rd, 0.1);\n  vec3 col = material_color(ro, rd, res.y, ro+rd*res.x);\n\n  // extra gamma on the tunnel (image buf also applies gamma)\n  col = vec3(1.0) - exp(-col * 1.5); // exposure hdr\n  col = pow(col, vec3(1.0/2.2)); // gamma\n\n  // FIXME Can't clamp. Very dark without the *20.\n  frag_color = vec4(col*20.0, 1.0);\n\n  //frag_color = vec4(clamp(col, 0., 1.), 1.0);\n}\n\n// === Supporting Functions ===\n\n// iq https://www.shadertoy.com/view/XdXGW8\nfloat iq_noise( in vec2 p ) {\n  vec2 i = floor( p );\n  vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n  return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                   dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n              mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                   dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin) {\n  // target end distance (clip far)\n  float tmax = 100.0;\n  // closeness precision, if we're this close, we've hit it\n  float precis = 0.002;\n  // smaller steps\n  float sm = 0.9;\n\n  float t = tmin; // result target distance\n  float m = -1.0; // material id, -1.0 for no hit (background)\n  for (int i=0; i<150; i++) {\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x * sm;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n\n  return vec2(t,m);\n}\n\n// Light Attenuation\n// http://gamedev.stackexchange.com/a/56934\nfloat lightAttenuation(vec3 light_pos, vec3 surf_pos, float radius) {\n  float dist = distance(surf_pos, light_pos);\n  float att = clamp(1.0 - dist / radius, 0.0, 1.0);\n  att *= att;\n  return att;\n}\n\n// iq's, glsl-sdf-normal\n// https://www.shadertoy.com/view/ldfSWs\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\n// iq's\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ ) {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvec3 checkerBoard(vec2 uv) {\n  float f = mod(floor(5.0*uv.x) + floor(5.0*uv.y), 2.0);\n  vec3 col = 0.4 + 0.1 * f * vec3(1.0);\n  return col;\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat opModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Chaos Noise\n\n// Started with \"Noise animation - Electric\" by nimitz and kept adding bits and\n// pieces.\n//\n// https://www.shadertoy.com/view/ldlXRS\n\n#define i_resolution iResolution\n#define i_time mod(iTime - 15.0, 45.0)\n\n#define scene_time i_time*0.15\n#define noise_time i_time*0.15\n#define wave_time i_time*0.15\n#define ring_time scene_time*10.0\n\n#define tex_rgba_noise iChannel0\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2.0*PI;\n\nmat2 rotate(in float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat2(c,-s,s,c);\n}\n\nfloat chaos_noise(in vec2 x) {\n  return texture(tex_rgba_noise, x*.01).x;\n}\n\nfloat fbm(in vec2 p) {\n  float z=2.;\n  float rz = 0.;\n  vec2 bp = p;\n  for (float i= 1.;i < 6.;i++) {\n    rz += abs((chaos_noise(p)-0.5)*2.)/z;\n    z = z*2.;\n    p = p*2.;\n  }\n  return rz;\n}\n\nfloat dual_fbm(in vec2 p) {\n  //get two rotated fbm calls and displace the domain\n\tvec2 q = p*.7;\n\tvec2 basis = vec2(fbm(q - scene_time*1.6),\n                    fbm(q + scene_time*1.7));\n\tbasis = (basis-.5)*.2;\n\n\tp += basis;\n\n\t// coloring\n\t//return fbm(p*rotate(scene_time*0.2));\n\treturn fbm(p);\n}\n\nfloat circ(vec2 p) {\n\tfloat r = length(p);\n\tr = log(sqrt(r));\n\treturn abs(mod(r*4., TWO_PI) - PI)*5.+.2;\n}\n\n// Gavoronoise\n\nfloat hash_ga( in vec2 p ) {\n  return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\nvec2 hash2_ga(vec2 p) {\n  return vec2(hash_ga(p*.754),hash_ga(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 ga_m = vec2(.8,.2);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec2 p) {\n  vec2 ip = floor(p);\n  vec2 fp = fract(p);\n  float f = 2.*PI;//frequency\n  float v = .8;//cell variability <1.\n  float dv = .4;//direction variability <1.\n  vec2 dir = ga_m;// direction scale\n  float va = 0.0;\n  float wt = 0.0;\n  for (int i=-1; i<=1; i++) {\n    for (int j=-1; j<=1; j++) {\n      vec2 o = vec2(i, j)-.5;\n      vec2 h = hash2_ga(ip - o);\n      vec2 pp = fp +o  -h;\n      float d = dot(pp, pp);\n      float w = exp(-d*4.);\n      wt +=w;\n      h = dv*h+dir;//h=normalize(h+dir);\n      va += cos(dot(pp,h)*f/v)*w;\n    }\n  }\n  return va/wt;\n}\n\nfloat fbmabs_ga( vec2 p ) {\n  float f = 0.8;\n  float r = 0.0;\n  for(int i=0; i<6; i++) {\n    r += abs(gavoronoi3( p*f ))/f;\n    f *= 2.2;\n    p+=vec2(-.01,.07)*r+.2*ga_m*wave_time/(.1-f);\n  }\n  return r;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  // normalized image plane\n  vec2 p = -1.0 + 2.0 * frag_coord.xy / i_resolution.xy;\n  p.x *= i_resolution.x / i_resolution.y;\n  p*=4.0;\n\n  // noise displacement\n\n  vec2 q = p*rotate(scene_time*0.2);\n  float rz = dual_fbm(q + vec2(noise_time, 0.0));\n  rz += dual_fbm(q*vec2(-1.0, 1.) + vec2(0.0, noise_time));\n  rz *= pow(abs((0.1 - rz)), 0.3);\n\n  // horizontals\n  //float t = ring_time;\n  float t = 12.0;\n  q = p + vec2(0., 0.8 + t*0.01);\n  q.x = abs(q.y*1.5*t);\n  rz *= pow(abs((0.01 - circ(q))), 0.7);\n\n  // gavoronoi\n  q = p * -0.08 + -0.2*ga_m;\n  rz *= pow(abs(0.8 - fbmabs_ga(q)), 0.4);\n\n  vec3 bg = vec3(0.15, 0.25, 0.4);\n  vec3 charge = vec3(0.15, 0.25, 0.4);\n\n  charge /= rz;\n  charge = pow(abs(charge), vec3(.9));\n\n  vec3 col = bg + charge;\n\n  col = vec3(0.8) - exp(-col * 1.0); // exposure hdr\n\n  // desaturate\n  vec3 balance = vec3(1.5, 0.25, 1.5);\n  col = vec3((col.r*balance.r + col.g*balance.g + col.b*balance.b)/3.0);\n\n  frag_color = vec4(clamp(col, 0., 1.), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Branches\n\n#define i_resolution iResolution\n#define i_time mod(iTime - 25.0, 45.0)\n\n#define wall_time i_time*0.3\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2.0*PI;\n\nvec3 g_camera_pos = vec3(0.);\nvec3 g_camera_front = vec3(0.);\nvec3 g_light_pos = vec3(0.);\n\nfloat iq_noise(vec3 p);\nvec3 nim_tri(in vec3 x);\nfloat lightAttenuation(vec3 light_pos, vec3 surf_pos, float radius);\nvec2 opU(vec2 d1, vec2 d2);\nfloat opSmin(float a, float b, float k);\nvoid pR(inout vec2 p, float a);\nfloat opModPolar(inout vec2 p, float repetitions);\nmat3 rotXY(vec2 angle);\nfloat sdSphere(vec3 p, float s);\nfloat sdTorus(vec3 p, vec2 t);\nfloat sdBox(vec3 p, vec3 b);\nfloat sdCylinder(vec3 p, float r, float height);\nfloat sdCapsule(vec3 p, float r, float c);\nvec3 checkerBoard(vec2 pos);\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin);\nvec3 calcNormal(in vec3 pos);\nfloat calcAO( in vec3 pos, in vec3 nor );\n\nmat2 rot2D(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\nfloat noiseBranchShape(float x) {\n  x += -7.5;\n  float y = (abs(sin(2.0*x)/x)*0.5 +\n             sin(-2.0 * x)/x +\n             iq_noise(vec3(x + i_time*0.8))*0.6)\n    * (1.0 - smoothstep(0.0, 15.0, x))\n    + sin(x*0.2)\n    + 2.0;\n\n  return y;\n}\n\nfloat sdTable(in vec3 p) {\n  vec3 q = p;\n  // mirror on the X axis\n  q.x = abs(p.x);\n\n  // top board\n  float res = sdBox(q - vec3(.0, .4, .0), vec3(.55, .02, .25));\n  // top depression\n  res = max(res, -sdBox(q - vec3(.0, .435, .0), vec3(.5, .02, .2)));\n\n  // board separator notch\n  //res = max(res, -sdBox(q - vec3(.0, .4, .0), vec3(.555, .001, .255)));\n\n  // legs\n  res = min(res, sdBox(q - vec3(.45, .2, -.17), vec3(.02, .2, .02)));\n  res = min(res, sdBox(q - vec3(.45, .2, .17), vec3(.02, .2, .02)));\n\n  // board connecting the legs\n  float a = sdBox(q - vec3(.0, .35, .0), vec3(.455, .038, .175));\n  a = max(a, -sdBox(q - vec3(.0, .35, .0), vec3(.440, .040, .160)));\n  res = min(res, a);\n\n  return res;\n}\n\nfloat sdVase(in vec3 p) {\n  vec3 q = p;\n  q.y = abs(q.y);\n  vec3 s = vec3(1., 4.0, 1.);\n  float res = sdCapsule((q - vec3(.0,  .03, .0)) * s, .05, .15);\n  s = vec3(1.0 - p.y*6.0, 1., 1.0 - p.y*6.0);\n  res = opSmin(res, sdCylinder((p - vec3(.0, .08, .0)) * s, .008, .02), 0.02);\n  res = max(res, -sdCylinder(p - vec3(.0, .08, .0), 0.01, 0.05));\n  return res;\n}\n\nfloat sdBranch(in vec3 p, in vec3 p_base, float branch_length, float shape_offset) {\n  shape_offset += 0.75;// offset to start with branch-bend part of the function\n  float r = 15.0 / branch_length;// to normalize branch_length in world-space to 0..15 in \"function space\"\n\n  float x = (-p_base.y + shape_offset)*r;\n  float a = noiseBranchShape(x) * 0.02;\n\n  x = -p_base.y*r;\n  float b = noiseBranchShape(x) * 0.02;\n\n  vec3 d = vec3(a, 0.0, b);\n  // NOTE: p coord changes (translation) shouldn't affect the branch shape, but it does. Oh well.\n  float res = sdCylinder(p - d, .003, branch_length);\n  return res;\n}\n\nfloat sdWall(in vec3 p) {\n  // distortion\n  vec3 q = p * 20.0;\n  opModPolar(q.xy, 8.0);\n  q -= vec3(wall_time, 0., wall_time);\n  float n = dot(nim_tri(q*0.2 + nim_tri(q*0.3).yzx),\n                vec3(0.7, 0.2, 0.8)) * 0.01;\n\n  float res = sdBox(p, vec3(2.0, 2.0, 0.05)) - n;\n  return res;\n}\n\nfloat sdRoom(in vec3 p) {\n  return sdBox(p - vec3(0.), vec3(5., 5., 5.));\n}\n\nfloat sdLampCase(in vec3 p) {\n  float res = sdBox(p, vec3(.05, .05, .05));\n  res = max(res, -sdCylinder(p, 0.035, 0.6));\n  return res;\n}\n\nvec2 map(in vec3 p) {\n  // bounding sphere\n  if (length(p) > 3.0) {\n    return vec2(200.0, -1.0);\n  }\n\n  vec3 q = p;\n  // Room\n  vec2 res = vec2(-sdRoom(p - vec3(0.)), 4.0);\n  // NOTE: show only when distance debugging is off\n  // floor\n  //res = opU(res, vec2(p.y - 0.01, 4.0));\n\n  // Table\n  res = opU(res, vec2(sdTable(p - vec3(0.)), 1.0));\n\n  // Vase\n  res = opU(res, vec2(sdVase(p - vec3(0.0, 0.49, 0.0)), 2.0));\n\n  // Branches\n\n  // One\n\n  q = p - vec3(0.04, 0.8, -0.07);\n  mat2 m = rot2D(radians(30.0));\n  q = vec3(q.xy*m, q.z);\n  res = opU(res, vec2(sdBranch(q, p, 0.2, 0.0), 3.0));\n\n  // Two\n\n  q = p - vec3(-0.01, 0.81, -0.01);\n  q = vec3(q.xy * rot2D(radians(20.0)), q.z);\n  vec2 n = q.xz * rot2D(radians(60.0));\n  q = vec3(n.x, q.y, n.y);\n  res = opU(res, vec2(sdBranch(q, p, 0.2, -0.1), 3.0));\n\n  // Three\n\n  q = p - vec3(-0.04, 0.78, 0.01);\n  q = vec3(q.xy * rot2D(radians(15.0)), q.z);\n  n = q.xz * rot2D(radians(60.0));\n  q = vec3(n.x, q.y, n.y);\n  res = opU(res, vec2(sdBranch(q, p, 0.2, 0.1), 3.0));\n\n  // Wall\n  res = opU(res, vec2(sdWall(p - vec3(.0, 1.0, .35)), 4.0));\n  // Lamp case\n  res = opU(res, vec2(sdLampCase(p - vec3(.0, 1.5, 0.245)), 5.0));\n\n  // show the light position\n  //res = opU(res, vec2(sdBox(p - g_light_pos, vec3(.01)), 100.0));\n\n  return res;\n}\n\nvec3 material_color(in vec3 ro, in vec3 rd, in float mat_id, in vec3 pos) {\n  vec3 final_col = vec3(0.);\n  vec3 nor = vec3(0.);\n\n  if (mat_id > -1.0) {\n    nor = calcNormal(pos);\n  }\n\n  if (mat_id == 1.0) {\n    // table\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n    float att = lightAttenuation(g_light_pos, pos, 10.0);\n\n    vec3 col = vec3(.49, .48, .46);\n\n    col = diff * col + 0.2 * col;\n    col *= max(att, 0.3);\n\n    col = pow(col, vec3(4.0));\n\n    final_col = clamp(col, 0.0, 1.0);\n\n  } else if (mat_id == 2.0) {\n    // vase\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n    float att = lightAttenuation(g_light_pos, pos, 10.0);\n\n    vec3 col = vec3(.5, .4, .4);\n\n    col = diff * col + 0.2 * col;\n    col *= max(att, 0.3);\n\n    col = pow(col, vec3(4.0));\n\n    final_col = clamp(col, 0.0, 1.0);\n\n  } else if (mat_id == 3.0) {\n    // branch\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n    float att = lightAttenuation(g_light_pos, pos, 10.0);\n\n    vec3 col = vec3(.5, .3, .3);\n\n    col = diff * col + 0.2 * col;\n    col *= max(att, 0.3);\n\n    col = pow(col, vec3(4.0));\n\n    final_col = clamp(col, 0.0, 1.0);\n\n  } else if (mat_id == 4.0) {\n    // wall\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n    float att = lightAttenuation(g_light_pos, pos, 6.0);\n\n    vec3 col = vec3(.55, .55, .5);\n\n    col = diff * col + 0.3 * col;\n    col *= max(att, 0.3);\n\n    col = pow(col, vec3(6.0));\n\n    // extra gamma on the wall (will do again in image buf)\n    col = vec3(1.0) - exp(-col * 0.5); // exposure hdr\n    col = pow(col*4.0, vec3(1.0/2.2)); // gamma\n\n    final_col = clamp(col, 0.0, 1.0);\n\n  } else if (mat_id == 5.0) {\n    // lamp case\n    vec3 view_dir = normalize(ro - pos);\n    vec3 light_dir = normalize(pos - g_light_pos);\n\n    float diff = max(dot(nor, -light_dir), 0.0);\n    //float att = lightAttenuation(g_light_pos, pos, 10.0);\n\n    vec3 col = vec3(.7, .7, .7);\n\n    col = diff * col + 0.2 * col;\n    //col *= max(att, 0.3);\n\n    col = pow(col, vec3(5.0));\n\n    final_col = clamp(col, 0.0, 1.0);\n  }\n\n  return final_col;\n}\n\n// === Main ===\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  // normalized image plane\n  vec2 p = -1.0 + 2.0 * frag_coord.xy / iResolution.xy;\n  p.x *= iResolution.x / iResolution.y;\n\n  // === Camera ===\n\n  g_camera_pos = vec3(0.0, 0.9, -1.5 + abs(sin(i_time*0.03)));\n  g_camera_front = vec3(0.0, -0.01, 0.4);\n  g_light_pos = vec3(.0, 1.45, 0.22);\n\n  // camera position\n  vec3 ro = g_camera_pos;\n\n  // camera matrix\n  vec3 ww = normalize(g_camera_front);\n  vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  // view ray\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  // === Render ===\n\n  vec2 res = castRay(ro, rd, 0.1);\n  vec3 col = material_color(ro, rd, res.y, ro+rd*res.x);\n\n  // FIXME Can't clamp. Very dark without the *10.\n  frag_color = vec4(col*10.0, 1.0);\n\n  //frag_color = vec4(clamp(col, 0., 1.), 1.0);\n}\n\n// === Supporting Functions ===\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, float tmin) {\n  // target end distance (clip far)\n  float tmax = 100.0;\n  // closeness precision, if we're this close, we've hit it\n  float precis = 0.0001;// was: 0.002\n  // smaller steps\n  float sm = 0.6;// was: 0.9\n\n  float t = tmin; // result target distance\n  float m = -1.0; // material id, -1.0 for no hit (background)\n  for (int i=0; i<150; i++) {\n    vec2 res = map(ro + rd * t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x * sm;\n    m = res.y;\n  }\n\n  if (t > tmax) m = -1.0;\n\n  return vec2(t,m);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ ) {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\n// IQ's\nfloat iq_noise(vec3 p) {\n\tvec3 ip = floor(p);\n  p -= ip;\n  vec3 s = vec3(7, 157, 113);\n  vec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n  p *= p * (3.-2.*p);\n  h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), p.x);\n  h.xy = mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\n// Nimitz's triangle\nvec3 nim_tri(in vec3 x){return abs(x-floor(x)-.5);}\n\nvec2 opU(vec2 d1, vec2 d2) {\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opSmin(float a, float b, float k) {\n  float h = clamp(.5+.5*(b-a)/k, 0.0, 1.0 );\n  return mix(b,a,h)-k*h*(1.-h);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat opModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// general rotation matrix for pitch and yaw\nmat3 rotXY(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(c.y      ,   0.0,  -s.y,\n              s.y * s.x,   c.x,   c.y * s.x,\n              s.y * c.x,  -s.x,   c.y * c.x);\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Cylinder standing upright on the xz plane\nfloat sdCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat sdCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Light Attenuation\n// http://gamedev.stackexchange.com/a/56934\nfloat lightAttenuation(vec3 light_pos, vec3 surf_pos, float radius) {\n  float dist = distance(surf_pos, light_pos);\n  float att = clamp(1.0 - dist / radius, 0.0, 1.0);\n  att *= att;\n  return att;\n}\n\nvec3 checkerBoard(vec2 uv) {\n  float f = mod(floor(5.0*uv.x) + floor(5.0*uv.y), 2.0);\n  vec3 col = 0.4 + 0.1 * f * vec3(1.0);\n  return col;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Text rendering\n\n/*\n  egyszer álmodtam róla\n  hol a kiút, mit kell tenni\n  próbálok rá emlékezni\n\n  az ismeretlen változik\n  hiába a szokott minta\n  a káosz nem illeszkedik\n\n  ami eddig is igaz volt\n  azt nem nekem kell létrehozni\n  -- akár szerethetem is.\n */\n\n// text drawing pass\n\n// Extended with accents:\n// óőö á úűü é í\n// Ó\n//\n// árvíztűrő tükörfúrógép\n\n// Based on:\n\n// Shadertext proportional spacing by Andre\n// https://www.shadertoy.com/view/4s3XDn\n\n#define line1 BOLD e_ g_ y_ s_ z_ e_ r_  _ a_ACU_ l_ m_ o_ d_ t_ a_ m_  _ r_ o_ACU_ l_ a_\n#define line2 BOLD h_ o_ l_  _ a_  _ k_ i_ u_ACU_ t_ _comma  _ m_ i_ t_  _ k_ e_ l_ l_  _ t_ e_ n_ n_ i_\n#define line3 BOLD p_ r_ o_ACU_ b_ a_ACU_ l_ o_ k_  _ r_ a_ACU_  _ e_ m_ l_ e_ACU_ k_ e_ z_ n_ i_\n\n#define line4 BOLD a_ z_  _ i_ s_ m_ e_ r_ e_ t_ l_ e_ n_  _ v_ a_ACU_ l_ t_ o_ z_ i_ k_\n#define line5 BOLD h_ i_ a_ACU_ b_ a_  _ a_  _ s_ z_ o_ k_ o_ t_ t_  _ m_ i_ n_ t_ a_\n#define line6 BOLD a_  _ k_ a_ACU_ o_ s_ z_  _ n_ e_ m_  _ i_ l_ l_ e_ s_ z_ k_ e_ d_ i_ k_\n\n#define line7 BOLD a_ m_ i_  _ e_ d_ d_ i_ g_  _ i_ s_  _ i_ g_ a_ z_  _ v_ o_ l_ t_\n#define line8 BOLD a_ z_ t_  _ n_ e_ m_  _ n_ e_ k_ e_ m_  _ k_ e_ l_ l_  _ l_ e_ACU_ t_ r_ e_ h_ o_ z_ n_ i_\n#define line9 BOLD _ndash _ a_ k_ a_ACU_ r_  _ s_ z_ e_ r_ e_ t_ h_ e_ t_ e_ m_  _ i_ s_ _dot\n\n// #define line4 BOLD a_ACU_ r_ v_ i_ACU_ z_ t_ u_DACU_ r_ o_DACU_  _ t_ u_DIA_ k_ o_DIA_ r_ f_ u_ACU_ r_ o_ACU_ g_ e_ACU_ p_\n\n#define i_time iTime\n#define i_resolution iResolution\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n  return length(vec2(\n                     abs(length(vec2(uv.x,\n                                     max(0.0,-(.4-v)-uv.y) ))-w)\n                     ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n  uv.x+=.2;\n  uv.y+=.55;\n  float x = uv.x>0.&&uv.y<0.?\n    abs(length(uv)-.25)\n    :min(length(uv+vec2(0.,.25)),\n         length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n  return x;\n}\nfloat _l(vec2 uv) {\n  uv.y -= .2;\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\n\nfloat aa(vec2 uv) {\n  uv = -uv;\n  float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n  x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n  return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\n\n// 'á' letter a with acute\nfloat aa_ACU(vec2 uv) {\n  float x = aa(uv);\n  vec2 q = uv + vec2(0.05, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\n\nfloat bb(vec2 uv) {\n  float x = _o(uv);\n  uv.x += .25;\n  return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n  float x = _o(uv);\n  uv.y= abs(uv.y);\n  return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right\n        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n  uv.x *= -1.;\n  return bb(uv);\n}\n\nfloat ee(vec2 uv) {\n  float x = _o(uv);\n  return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n             length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\n\n// 'é' letter e with acute\nfloat ee_ACU(vec2 uv) {\n  float x = ee(uv);\n  vec2 q = uv + vec2(0.05, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\n\nfloat ff(vec2 uv) {\n  uv.x *= -1.;\n  uv.x += .05;\n  float x = _j(vec2(uv.x,-uv.y));\n  uv.y -= .4;\n  x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n  return x;\n}\nfloat gg(vec2 uv) {\n  float x = _o(uv);\n  return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n             _u(uv,0.25,-0.2):\n             length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n  uv.y *= -1.;\n  float x = _u(uv,.25,.25);\n  uv.x += .25;\n  uv.y *= -1.;\n  return min(x,_l(uv));\n}\n\nfloat ii(vec2 uv) {\n  float a = length(vec2(uv.x,uv.y-.6))*.6;\n  return min(_i(uv), a);\n}\n\n// 'í' letter i with acute\nfloat ii_ACU(vec2 uv) {\n  float x = _i(uv);\n  vec2 q = uv + vec2(0.05, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\n\nfloat jj(vec2 uv) {\n  uv.x+=.05;\n  float a = length(vec2(uv.x-.05,uv.y-.6))*0.6;\n  return min(_j(uv), a);\n}\n\nfloat kk(vec2 uv) {\n  float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n  x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n  uv.x+=.25;\n  return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n  return _l(uv);\n}\nfloat mm(vec2 uv) {\n  //uv.x *= 1.4;\n  uv.y *= -1.;\n  uv.x-=.175;\n  float x = _u(uv,.175,.175);\n  uv.x+=.35;\n  x = min(x,_u(uv,.175,.175));\n  uv.x+=.175;\n  return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n  uv.y *= -1.;\n  float x = _u(uv,.25,.25);\n  uv.x+=.25;\n  return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n  return _o(uv);\n}\n\n// 'ő' letter o with double acute\nfloat oo_DACU(vec2 uv) {\n  float x = _o(uv);\n  vec2 q = uv + vec2(0.15, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  q = uv + vec2(-0.15, -0.6);\n  a = min(a, line(q, vec2(.0, .0), vec2(0.15, 0.1)));\n  return min(x, a);\n}\n\n// 'ö' letter o with diaeresis\nfloat oo_DIA(vec2 uv) {\n  float x = _o(uv);\n  // right dot accent\n  vec2 q = uv + vec2(0.15, 0.);\n  float a = length(vec2(q.x, q.y-.6))*0.6;\n  x = min(x, a);\n  // left dot accent\n  q = uv + vec2(-0.15, 0.);\n  a = length(vec2(q.x, q.y-.6))*0.6;\n  x = min(x, a);\n  return x;\n}\n\n// 'ó' letter o with acute\nfloat oo_ACU(vec2 uv) {\n  float x = _o(uv);\n  vec2 q = uv + vec2(0.05, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\nfloat pp(vec2 uv) {\n  float x = _o(uv);\n  uv.x += .25;\n  uv.y += .4;\n  return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n  uv.x = -uv.x;\n  return pp(uv);\n}\nfloat rr(vec2 uv) {\n  uv.x -= .05;\n  float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n\n  //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n\n  uv.x+=.25;\n  return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n  if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n    uv = -uv;\n  float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n  float b = length(vec2(uv.x-.231505,uv.y-.284));\n  float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n  return x;\n}\nfloat tt(vec2 uv) {\n  uv.x *= -1.;\n  uv.y -= .4;\n  uv.x += .05;\n  float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n  return x;\n}\n\nfloat uu(vec2 uv) {\n  return _u(uv,.25,.25);\n}\n\n// 'ú' letter u with acute\nfloat uu_ACU(vec2 uv) {\n  float x = _u(uv,.25,.25);\n  vec2 q = uv + vec2(0.05, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\n\n// 'ű' letter u with double acute\nfloat uu_DACU(vec2 uv) {\n  float x = _u(uv,.25,.25);\n  vec2 q = uv + vec2(0.15, -0.6);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  q = uv + vec2(-0.15, -0.6);\n  a = min(a, line(q, vec2(.0, .0), vec2(0.15, 0.1)));\n  return min(x, a);\n}\n\n// 'ü' letter u with diaeresis\nfloat uu_DIA(vec2 uv) {\n  float x = uu(uv);\n  // right dot accent\n  vec2 q = uv + vec2(0.15, 0.);\n  float a = length(vec2(q.x, q.y-.6))*0.6;\n  x = min(x, a);\n  // left dot accent\n  q = uv + vec2(-0.15, 0.);\n  a = length(vec2(q.x, q.y-.6))*0.6;\n  x = min(x, a);\n  return x;\n}\n\nfloat vv(vec2 uv) {\n  uv.x=abs(uv.x);\n  return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n  uv.x=abs(uv.x);\n  return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n             line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n  uv=abs(uv);\n  return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n  return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n             line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n  float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n  uv.y=abs(uv.y);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n  return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        max(0.0,uv.y-.35) ))-0.25)\n                        ,min(0.,uv.y+.4)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n  uv.y -=.1;\n  uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.25))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y -= .1;\n  uv.y= abs(uv.y);\n  return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right\n        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n  uv.y -=.1;\n  //uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        max(0.0,abs(uv.y)-.25)))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n  uv.y -=.1;\n  uv.y = abs(uv.y);\n  float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n  uv.y -=.1;\n  float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y -= .1;\n  float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n  x = uv.x<0.||a<1.14 || a>3.?x:\n    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right\n        length(uv+vec2(-.22734,-.354)));\n  x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n  return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n  uv.y -=.1;\n  uv.x = abs(uv.x);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n  return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n  uv.y -= .1;\n  float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n  uv.y = abs(uv.y);\n  return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n  uv.x += .125;\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        min(0.0,uv.y+.15) ))-0.25)\n                        ,max(0.,max(-uv.x,uv.y-.6))));\n  return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n  float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n  x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n  //    uv.x+=.25;\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n  uv.y -=.1;\n  float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n  return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n  uv.y-=.1;\n  float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n  x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n  return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n  uv.y-=.1;\n  float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\n\nfloat OO(vec2 uv) {\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\n\n// 'Ó' letter O with acute\nfloat OO_ACU(vec2 uv) {\n  float x = OO(uv);\n  vec2 q = uv + vec2(0.05, -0.75);\n  float a = line(q, vec2(.0, .0), vec2(0.15, 0.1));\n  return min(x, a);\n}\n\nfloat PP(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.35))-0.25)\n                        ,min(0.,uv.x+.25)));\n  return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n  float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n  uv.y += .3;\n  uv.x -= .2;\n  return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(max(0.0,uv.x),\n                                        uv.y-.35))-0.25)\n                        ,min(0.,uv.x+.25)));\n  x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n  return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n  uv.y -= .1;\n  if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n    uv = -uv;\n  float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n  float b = length(vec2(uv.x-.236,uv.y-.332));\n  float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n  return x;\n}\nfloat TT(vec2 uv) {\n  uv.y -= .1;\n  float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n  float x = length(vec2(\n                        abs(length(vec2(uv.x,\n                                        min(0.0,uv.y+.15) ))-0.25)\n                        ,max(0.,uv.y-.6)));\n  return x;\n}\nfloat VV(vec2 uv) {\n  uv.x=abs(uv.x);\n  return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n  uv.x=abs(uv.x);\n  return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n             line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n  uv.y -= .1;\n  uv=abs(uv);\n  return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n  return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                 line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n             length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n  float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n  uv.y-=.1;\n  uv.y=abs(uv.y);\n  float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n  return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n  return min(min(\n                 line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n                 length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n\n}\nfloat _22(vec2 uv) {\n  float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n  uv.y-=.35;\n  uv.x += 0.025;\n  return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n             length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n    min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n  float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n  return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n  float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n  uv.y += 0.1;\n  uv.x += 0.05;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n  return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n             length(uv+vec2(.2,.224))\n             :c);\n}\nfloat _66(vec2 uv) {\n  uv.y-=.075;\n  uv = -uv;\n  float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n  uv.y-=.175;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n  return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n             length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n  return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n             line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n  float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  uv.y-=.245;\n  return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n  uv.y-=.125;\n  float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n  uv.y-=.175;\n  float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n  return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n             length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n  uv.y-=.1;\n  return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n// Symbols\n\nfloat ddot(vec2 uv) {\n  uv.y+=.4;\n  return length(uv)*0.97*0.6;\n}\nfloat comma(vec2 uv) {\n  return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n  return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n  float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n  uv.y-=.35;\n  uv.x += 0.025;\n  return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n             length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n  uv.x-=.62;\n  return abs(atan(uv.x,uv.y)+1.57)<1.?\n    abs(length(uv)-.8)\n    :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n  uv.x = -uv.x;\n  return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n  uv.y -= .1;\n  float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n  uv.y = abs(uv.y);\n  uv.y-=.25;\n  return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n  uv.y -= .1;\n  return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n             length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\n\nfloat ssub(vec2 uv) {\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\n\nfloat ndash(vec2 uv) {\n  uv.x -= 0.1;\n  return length(vec2(max(0.,abs(uv.x)-.35),uv.y-.1));\n}\n\nfloat mmul(vec2 uv) {\n  uv.y -= .1;\n  uv = abs(uv);\n  return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n             ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n  return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n  uv.y-=.1;\n  uv.y = abs(uv.y);\n  return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n  uv.x=-uv.x;\n  return lt(uv);\n}\nfloat hash(vec2 uv) {\n  uv.y-=.1;\n  uv.x -= uv.y*.1;\n  uv = abs(uv);\n  return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n             length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n  uv.y-=.44;\n  uv.x+=.05;\n  float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n  x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n  x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n  uv.x-=.025;\n  uv.y+=.54;\n  x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n  return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n  uv.y -= .1;\n  return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n  return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n             length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n  uv.x=-uv.x;\n  return open2(uv);\n}\nfloat open3(vec2 uv) {\n  uv.y -= .1;\n  uv.y = abs(uv.y);\n  float x = length(vec2(\n                        abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                                        max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n                        ,max(0.,abs(uv.x)-.2)));\n  return  x;\n\n}\nfloat close3(vec2 uv) {\n  uv.x=-uv.x;\n  return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n  return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n  return abs((cp+=w)-uv.x)<w+.2;\n}\n\n//Render char if it's up\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n//Render char always (no effects anymore)\n//#define ch(l,w) x = min(x,l(clc(uv,cp+=w,w,ital)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n// 'á' letter a with acute\n#define a_ACU_ ch(aa_ACU,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n// 'é' letter e with acute\n#define e_ACU_ ch(ee_ACU,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n// 'í' letter i with acute\n#define i_ACU_ ch(ii_ACU,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n// 'ó' letter o with acute\n#define o_ACU_ ch(oo_ACU,0.7);\n// 'ő' letter o with double acute\n#define o_DACU_ ch(oo_DACU,0.7);\n// 'ö' letter o with diaeresis\n#define o_DIA_ ch(oo_DIA,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n// 'ú' letter u with acute\n#define u_ACU_ ch(uu_ACU,0.7);\n// 'ű' letter u with double acute\n#define u_DACU_ ch(uu_DACU,0.7);\n// 'ü' letter u with diaeresis\n#define u_DIA_ ch(uu_DIA,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n// 'Ó' letter O with acute\n#define O_ACU_ ch(OO_ACU,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _ndash ch(ndash,0.9);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n\n//Space\n#define _ cp+=.5;\n\n//Markup\n#define BOLD cur.w = 1.5-cur.w;\n#define ITAL ital = 0.15-ital;\n#define RED cur.r = 0.8-cur.r;\n#define GREEN cur.g = 0.6-cur.g;\n#define BLUE cur.b = 1.0-cur.b;\n\n//Next line\n#define crlf uv.y += 2.0; cp = 0.;\n\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  float scale = 1.0;\n  vec2 uv = (frag_coord-.5*i_resolution.xy) / i_resolution.x * 22.0 * scale;\n  uv.y *= i_resolution.x / i_resolution.y;\n\n  //float ofs = floor(uv.x)+8.;\n  //uv.x = mod(uv.x,1.0)-.5;\n\n  float px = 22.0/i_resolution.x*scale;\n  float x = 100.;\n  float cp = 0.;\n  vec4 cur = vec4(0.,0.,0.,0.5);\n  vec4 us = cur;\n  float ital = 0.0;\n  //uv+= .03*cos(uv*7.+i_time);\n  //uv.y += 2.;\n  uv.x += 10.1;\n  //uv.y -= 3.;\n  //uv.x += 5.;\n\n  int lnr = 2-int(floor(uv.y/2.));\n  uv.y = mod(uv.y,2.0)-1.0;\n\n  float t = 0.;\n  // three stages: 15s, 10s, 20s\n  t = mod(i_time, 45.0);\n\n  if (t < 15.0) {\n\n    if (lnr==0) {line1}\n    if (lnr==1) {line2}\n    if (lnr==2) {line3}\n\n  } else if (t < 25.) {\n\n    if (lnr==0) {line4}\n    if (lnr==1) {line5}\n    if (lnr==2) {line6}\n\n  } else if (t < 45.) {\n\n    if (lnr==0) {line7}\n    if (lnr==1) {line8}\n    if (lnr==2) {line9}\n\n  }\n\n  vec3 clr = vec3(0.0);\n\n  float weight = 0.01+us.w*0.02;\n\n  frag_color = vec4(mix(us.rgb, vec3(1.0), smoothstep(weight-px,weight+px, x)), 1.0);\n\n}\n",
                "description": "",
                "inputs": [],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}