{
    "Shader": {
        "info": {
            "date": "1591844362",
            "description": "riff on https://www.shadertoy.com/view/XlSfzz to create desktop backgrounds.",
            "flags": 32,
            "hasliked": 0,
            "id": "WtlcDr",
            "likes": 4,
            "name": "metal grid screensaver",
            "published": 3,
            "tags": [
                "grid",
                "metal",
                "pattern"
            ],
            "usePreview": 0,
            "username": "mds2",
            "viewed": 434
        },
        "renderpass": [
            {
                "code": "#define MULTI_SAMPLE_4 0\n#define MULTI_SAMPLE_8 0\n#define MULTI_SAMPLE_3 0\n#define MULTI_SAMPLE_2 1\n\n#define ONLY_BLURRY_REFLECTIONS 1 // set to 0 to make parts of reflection crisp\n\nconst float tor_rad1 = 0.5;\nconst float tor_rad2 = 0.2;\n\nvec4 background(vec3 orig, vec3 dir, float bounced) {\n   \n    vec4 c1 = texture(iChannel1, dir);\n#if ONLY_BLURRY_REFLECTIONS\n    vec4 c0 = c1;\n#else\n    vec4 c0 = texture(iChannel2, dir);\n#endif\n    return mix(c1, c0, smoothstep(0.0, 0.2, bounced));\n}\n\n\nvec3 raymarch(in vec3 orig, in vec3 dir) {\n    float d = -orig.z/dir.z;\n    vec3 p = orig + d * dir;\n    return p;\n}\n\n\n\n\nvec2 tor_angles(in vec3 point) {\n    return mod(point.xy * 1.0, vec2(1.0));\n}\n\nvec3 tor_norm(in vec3 point, out float glow_mag) {\n    vec3 n = vec3(0.0, 0.0, 1.0);\n    vec2 uv =tor_angles(point);\n    vec3 t1 = vec3(1.0, 0.0, 0.0);\n    vec3 t2 = vec3(0.0, 1.0, 0.0);\n    \n    float h = 1.0 / min(iResolution.x, iResolution.y);\n    float img_samp = length(texture(iChannel0, uv).rg);\n    glow_mag = img_samp;\n    vec2 img_grad =\n        vec2(length(texture(iChannel0, \n                            mod(uv + vec2(h, 0.0), vec2(1.0))).rg) - img_samp,\n             length(texture(iChannel0,\n                            mod(uv + vec2(0.0, h), vec2(1.0))).rg) - img_samp) / h;\n\treturn n - 0.1 * (img_grad.x * t1 + img_grad.y * t2);\n}\n\n\nvec4 getSample(in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec4 color_mul = vec4(1.0);\n    vec4 color_add = vec4(0.0);\n    \n    float stheta = 0.0; // sin(0.125 * iTime);\n    float ctheta = 1.0; // cos(0.125 * iTime);\n    float pitch = -0.0;\n    mat3 turn_mat = \n        mat3(ctheta, 0.0, stheta,\n             0.0, 1.0, 0.0,\n             -stheta, 0.0, ctheta) *\n        mat3(1.0, 0.0, 0.0,\n                         0.0, cos(pitch), sin(pitch),\n                         0.0, -sin(pitch), cos(pitch));\n    \n    vec3 ray_orig = turn_mat * vec3(0.0, 0.0, -0.5);\n    \n    vec3 ray_dir = normalize(turn_mat * vec3(uv, 0.5));\n    \n    float bounced = 0.0;\n    \n\tvec3 hit = raymarch(ray_orig, ray_dir);\n    if (true) {\n        float glow;\n    \tvec3 n = tor_norm(hit, glow);\n        ray_dir = normalize(reflect(ray_dir, n));\n        ray_orig = hit;\n        \n        color_add.b = 0.5 * smoothstep(0.3, 0.9, glow);\n        bounced = 1.0 - glow;\n        \n    }\n    \n\treturn color_mul * background(ray_orig, ray_dir, bounced) + color_add;\n}\n\n\nvec2 offsets[8] = vec2[8](vec2(-0.4, -0.4), \n                         vec2(-0.45, 0.1),\n                         vec2(-0.4, 0.4),\n                         vec2(0.1, 0.45),\n                         vec2(0.4, 0.4),\n                         vec2(0.45, -0.1),\n                         vec2(0.4, -0.4),\n                         vec2(0.0, 0.0));\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 result = vec4(0.0);\n    \n    float nsamps = 0.0;\n    \n    result += getSample(fragCoord + offsets[0]);\n    nsamps += 1.0;\n    \n#if MULTI_SAMPLE_8\n    result += getSample(fragCoord + offsets[1]);\n    result += getSample(fragCoord + offsets[2]);\n    result += getSample(fragCoord + offsets[3]);\n    result += getSample(fragCoord + offsets[4]);\n    result += getSample(fragCoord + offsets[5]);\n    result += getSample(fragCoord + offsets[6]);\n    result += getSample(fragCoord + offsets[7]);\n    nsamps += 7.0;\n#elif MULTI_SAMPLE_4\n    result += getSample(fragCoord + offsets[2]);\n    result += getSample(fragCoord + offsets[4]);\n    result += getSample(fragCoord + offsets[6]);\n    nsamps += 3.0;\n#elif MULTI_SAMPLE_3\n    result += getSample(fragCoord + offsets[3]);\n    result += getSample(fragCoord + offsets[6]);\n    nsamps += 2.0;\n#elif MULTI_SAMPLE_2\n    result += getSample(fragCoord + offsets[4]);\n    nsamps += 1.0;\n#endif\n    \n    \n    \n    fragColor = result / nsamps;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 26,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "\nvec2 to_uv(in vec2 in_pixels) {\n    return in_pixels / iResolution.xy;\n\t// return 0.1 + mod(vec2(0.8) + in_pixels / iResolution.xy, vec2(0.9));\n}\n\nvec2 fetch_dir(in vec2 in_pixels) {\n    vec2 dir = texture(iChannel0, to_uv(in_pixels)).rg;\n    dir = step(vec2(0.5), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n    return dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    float refresh_period = 3.0 * iResolution.y / 300.0;\n    float t = iTime - mod(iTime, refresh_period);\n    mat2 rotator = mat2(cos(t), sin(t),\n                          -sin(t), cos(t));\n    vec2 dir = step(vec2(0.999), texture(iChannel1, to_uv(rotator * p)).rg);\n    dir = vec2(step(dir.y, dir.x), step(dir.x, dir.y)) * dir;\n \n    if (mod(iTime, refresh_period) < 0.1) {\n      fragColor = vec4(dir, 0.0, 1.0);\n        return;\n    }\n   \n    if (dot(dir, dir) < 0.5) {\n\t    dir = step(vec2(0.9), texture(iChannel0, to_uv(p)).rg);\n    }\n     \n    if (dot(dir, dir) < 0.01) {\n    \tvec2 dir1 = vec2(1.0, 0.0);\n    \tvec2 dir2 = dir1.yx;\n        \n        \n    \tfloat val1 = max(abs(dot(dir1, fetch_dir(p + dir1))),\n                     \tabs(dot(dir1, fetch_dir(p - dir1))));\n        \n            \n    \tfloat val2 = max(abs(dot(dir2, fetch_dir(p + dir2))),\n        \t             abs(dot(dir2, fetch_dir(p - dir2))));\n        \n    \t\n        if (val1 > val2) {\n            val2 = 0.0;\n        } else {\n            val1 = 0.0;\n        }\n        \n        val1 = step(0.9, val1);\n        val2 = step(0.9, val2);\n        \n    \n    \tdir = mix(dir, dir1, val1);\n    \tdir = mix(dir, dir2, val2);\n    }\n    \n    dir = step(vec2(0.9), dir) * vec2(step(dir.y, dir.x), step(dir.x, dir.y));\n \n    fragColor = vec4(dir,0.0,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pix_delta = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * pix_delta;\n    vec4 result = 16.0 * texture(iChannel0, uv);\n    result = result + texture(iChannel0, uv + pix_delta * vec2( 1.1, 0.0));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(-1.1, 0.0));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(0.0,  1.1));\n    result = result + texture(iChannel0, uv + pix_delta * vec2(0.0, -1.1));\n    fragColor = mix(0.05 * result, texture(iChannel1, uv), 0.025);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}