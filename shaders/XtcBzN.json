{
    "Shader": {
        "info": {
            "date": "1538728740",
            "description": "Flying sheet based on ball-and-spring grid subject to external forces (mouseable)",
            "flags": 32,
            "hasliked": 0,
            "id": "XtcBzN",
            "likes": 11,
            "name": "Surface Skimmer",
            "published": 3,
            "tags": [
                "dynamics",
                "physics",
                "flight"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 610
        },
        "renderpass": [
            {
                "code": "// \"Surface Skimmer\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Flying surface based on ball-and-spring grid subject to external forces (mouseable).\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvec4 Loadv4 (vec2 vId);\n\nconst int nBallE = 33;\nconst int nsMax = 3000;\n\nvec3 sunDir;\nvec2 qgHit;\nfloat dstFar, tCur, todCur, spLen;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 fqRot;\n  vec2 q;\n  float h, a;\n  fqRot = 2. * mat2 (0.6, -0.8, 0.8, 0.6);\n  q = 0.02 * p;\n  h = 0.;\n  a = 10.;\n  for (int j = 0; j < 5; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 0.5;\n    q *= fqRot;\n  }\n  return h;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.5 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nfloat SheetRay (vec3 ro, vec3 rd)\n{\n  vec3 r, q;\n  vec2 g;\n  float d, dMin, sz, szMax, szMin, grLen;\n  bvec2 ilt;\n  bool bkTrak;\n  grLen = 0.92 * spLen;\n  dMin = dstFar / grLen;\n  rd /= grLen;\n  szMax = float (nBallE - 1);\n  szMin = 1./32.;\n  g = vec2 (0.);\n  bkTrak = false;\n  sz = szMax;\n  for (int ns = 0; ns < nsMax; ns ++) {\n    if (sz == szMin) {\n      r = GetR (g) - ro;\n      q = cross (r, rd);\n      if (dot (q, q) < sz * sz) {\n       d = dot (rd, r);\n        if (d < dMin) {\n          dMin = d;\n          qgHit = g;\n        }\n      }\n      bkTrak = true;\n    }\n    q = cross (GetR (g + 0.5 * sz) - ro, rd);\n    bkTrak = bkTrak || (dot (q, q) > sz * sz);\n    if (bkTrak) {\n      bkTrak = false;\n      ilt = lessThan (fract (g / (2. * sz)), vec2 (0.5));\n      g.x += ilt.x ? sz : - sz;\n      if (! ilt.x) {\n        g.y += ilt.y ? sz : - sz;\n        if (! ilt.y) {\n          sz *= 2.;\n          if (sz == szMax) break;\n          bkTrak = true;\n        }\n      }\n    } else if (sz > szMin) sz *= 0.5;\n  }\n  return dMin * grLen;\n}\n\nvec3 GetRC (vec2 v)\n{\n  return GetR (clamp (v, vec2 (0.), vec2 (nBallE - 1)));\n}\n\nvec3 SheetNf () \n{\n  vec3 c;\n  vec2 e = vec2 (1., 0.);\n  c = GetRC (qgHit);\n  return normalize (cross (GetRC (qgHit + e.yx) - c, GetRC (qgHit + e) - c));\n}\n\nfloat SheetSilHit (vec3 ro, vec3 rd)\n{\n  vec3 blkSize, pMin, pMax, v, tm, tp;\n  float dn, df;\n  pMin = Loadv4 (vec2 (1, nBallE)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE)).xyz;\n  ro -= 0.5 * (pMin + pMax);\n  blkSize = 0.5 * (pMax - pMin) + 0.5;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  v = ro / rd;\n  tp = blkSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = max (max (tm.x, tm.y), tm.z);\n  df = min (min (tp.x, tp.y), tp.z);\n  return (df > 0. && dn < df) ? dn : dstFar;\n}\n\nfloat GrndAO (vec3 p)\n{\n  vec3 pMin, pMax, s;\n  float ao;\n  ao = 1.;\n  pMin = Loadv4 (vec2 (1, nBallE)).xyz;\n  pMax = Loadv4 (vec2 (2, nBallE)).xyz;\n  s = abs (p - 0.5 * (pMin + pMax)) - 0.5 * (pMax - pMin) - 1.5;\n  if (s.x < 0. && s.z < 0.) {\n    for (int iy = 0; iy < nBallE; iy ++) {\n      for (int ix = 0; ix < nBallE; ix ++) {\n        ao = min (ao, smoothstep (0.1, 2., length (GetR (vec2 (ix, iy)) - p) - 0.5));\n      }\n    }\n  }\n  return 0.7 + 0.3 * ao;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  rd.y = abs (rd.y);\n  ro.xz += 2. * tCur;\n  col = vec3 (0.1, 0.2, 0.4) + 0.1 * (1. - rd.y) +\n     0.1 * pow (max (dot (rd, sunDir), 0.), 16.);\n  col = mix (col, vec3 (0.8), clamp (0.2 + Fbm2 (0.1 *\n     (ro.xz + rd.xz * (100. - ro.y) / max (rd.y, 0.001))) * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, bgCol;\n  vec2 b;\n  float dstGrnd, dstSheet, spec, f;\n  bool doRefl;\n  bgCol = BgCol (ro, rd);\n  dstSheet = (SheetSilHit (ro, rd) < dstFar) ? SheetRay (ro, rd) : dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  if (min (dstGrnd, 1.01 * dstSheet) < dstFar) {\n    doRefl = false;\n    if (dstSheet < dstGrnd) {\n      vn = SheetNf ();\n      b = Rot2D (qgHit / vec2 (nBallE - 1), pi / 4.);\n      f = mod (16. * (2. * b.x * b.x + b.y), 1.);\n      col = vec3 (SmoothBump (0.01, 0.33, 0.02, f), SmoothBump (0.33, 0.67, 0.02, f),\n         SmoothBump (0.67, 0.99, 0.02, f));\n      f = length (vec2 (abs (b.x), b.y) - vec2 (0.07, 1.2));\n      if (f < 0.04) col = vec3 (1., 1., 0.1) * (0.3 + 0.7 * step (0.02, f));\n      spec = 0.3;\n      doRefl = true;\n    } else if (dstGrnd < dstFar) {\n      ro += dstGrnd * rd;\n      vn = GrndNf (ro);\n      f = 1. - clamp (0.5 * pow (vn.y, 4.) + Fbm2 (0.5 * ro.xz) - 0.5, 0., 1.);\n      vn = VaryNf (4. * ro, vn, 8. * f * f);\n      col = 1.4 * mix (vec3 (0.4, 0.2, 0.), vec3 (0.3, 0.1, 0.), f) *\n        (1. - 0.1 * Noisefv2 (64. * ro.xz));\n      col *= (1. - 0.3 * SmoothBump (0.45, 0.55, 0.02, mod (2. * GrndHt (ro.xz), 1.))) *\n         GrndAO (ro);\n      spec = 0.;\n    }\n    col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n       spec * pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    if (doRefl) col = mix (col, BgCol (ro, reflect (rd, vn)), 0.4);\n    col = mix (col, bgCol, clamp (4. * min (dstSheet, dstGrnd) / dstFar - 3., 0., 1.));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, stDat;\n  vec3 ro, rd, col, pMid, vd;\n  vec2 canvas, uv;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.03 * pi * tCur;\n  el = pi * 0.1 * (2. + sin (0.021 * pi * tCur));\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  el = clamp (el, 0.02 * pi, 0.4 * pi);\n  pMid = 0.5 * (Loadv4 (vec2 (1, nBallE)).xyz + Loadv4 (vec2 (2, nBallE)).xyz);\n  ro = pMid + 90. * vec3 (cos (el) * cos (az), sin (el), cos (el) * sin (az));\n  ro.y = max (ro.y, GrndHt (ro.xz) + 10.);\n  vd = normalize (pMid - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  zmFac = 3.6;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  stDat = Loadv4 (vec2 (0, nBallE));\n  spLen = stDat.x;\n  dstFar = 240.;\n  sunDir = normalize (vec3 (1., 2., -1.));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// \"Surface Skimmer\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBallE = 33;\n\nvec3 rLead, pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat spLen, fOvlap, grav, ntStep;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 fqRot;\n  vec2 q;\n  float h, a;\n  fqRot = 2. * mat2 (0.6, -0.8, 0.8, 0.6);\n  q = 0.02 * p;\n  h = 0.;\n  a = 10.;\n  for (int j = 0; j < 5; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 0.5;\n    q *= fqRot;\n  }\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fDamp;\n  fSpring = 200.;\n  fDamp = 0.5;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  spLenD = spLen * sqrt (2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += 5. * fSpring * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd, fBend;\n  bool doInt;\n  fBend = 500.;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= fBend * cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - 10. * dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f;\n  vec2 s;\n  float fDamp, dt, rSep, w, t;\n  IdNebs ();\n  fDamp = 0.5;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = PairForce (r) + SpringForce (iv, r, v) + BendForce (iv, r) +\n     NormForce (iv, r, v);\n  dr.xz = -0.55 * GrndNf (r).xz;\n  dr.y = r.y + 0.55 - GrndHt (r.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n  f -= fDamp * v;\n  f.y -= grav;\n  s = float (nBallE) - vec2 (iv);\n  w = max (1. - dot (s, s) / 8., 0.);\n  f += 100. * w * (rLead - r);\n  t = mod (ntStep / 500., 8.);\n  f.y += 200. * w * ((t < 6.) ? t : 3. * (8. - t));\n  dt = 0.02;\n  v += dt * f;\n  r += dt * v;\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, 0., iy);\n        r.xz -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n        r.y += GrndHt (r.xz) + 3. * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v, rLeadS;\n  ivec2 pxIv, iv;\n  int mId, pxId, ms;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  ms = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * ms + 4) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  fOvlap = 1000.;\n  grav = 0.5;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    ntStep = 0.;\n    rLeadS.xz = 0.5 * (vec2 (nBallE, nBallE) - 1.) * 0.97 * spLen;\n    rLeadS.y = GrndHt (rLeadS.xz) + 2.;\n    if (mId < ms) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    ntStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    rLeadS = stDat.xyz;\n    ++ ntStep;\n    rLeadS.xz += 0.02;\n    rLead = rLeadS;\n    rLead.y = GrndHt (rLead.xz) + 2.;\n    if (mId < ms) Step (iv, r, v);\n  }\n  if (pxId == 2 * ms + 1 || pxId == 2 * ms + 2) SheetLims ();\n  if (pxId < 2 * ms) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * ms + 0) stDat = stDat = vec4 (spLen, ntStep, 0., 0.);\n    else if (pxId == 2 * ms + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * ms + 2) stDat = vec4 (pMax, 0.);\n    else if (pxId == 2 * ms + 3) stDat = vec4 (rLeadS, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Surface Skimmer\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBallE = 33;\n\nvec3 rLead, pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat spLen, fOvlap, grav, ntStep;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 fqRot;\n  vec2 q;\n  float h, a;\n  fqRot = 2. * mat2 (0.6, -0.8, 0.8, 0.6);\n  q = 0.02 * p;\n  h = 0.;\n  a = 10.;\n  for (int j = 0; j < 5; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 0.5;\n    q *= fqRot;\n  }\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fDamp;\n  fSpring = 200.;\n  fDamp = 0.5;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  spLenD = spLen * sqrt (2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += 5. * fSpring * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd, fBend;\n  bool doInt;\n  fBend = 500.;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= fBend * cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - 10. * dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f;\n  vec2 s;\n  float fDamp, dt, rSep, w, t;\n  IdNebs ();\n  fDamp = 0.5;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = PairForce (r) + SpringForce (iv, r, v) + BendForce (iv, r) +\n     NormForce (iv, r, v);\n  dr.xz = -0.55 * GrndNf (r).xz;\n  dr.y = r.y + 0.55 - GrndHt (r.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n  f -= fDamp * v;\n  f.y -= grav;\n  s = float (nBallE) - vec2 (iv);\n  w = max (1. - dot (s, s) / 8., 0.);\n  f += 100. * w * (rLead - r);\n  t = mod (ntStep / 500., 8.);\n  f.y += 200. * w * ((t < 6.) ? t : 3. * (8. - t));\n  dt = 0.02;\n  v += dt * f;\n  r += dt * v;\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, 0., iy);\n        r.xz -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n        r.y += GrndHt (r.xz) + 3. * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v, rLeadS;\n  ivec2 pxIv, iv;\n  int mId, pxId, ms;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  ms = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * ms + 4) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  fOvlap = 1000.;\n  grav = 0.5;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    ntStep = 0.;\n    rLeadS.xz = 0.5 * (vec2 (nBallE, nBallE) - 1.) * 0.97 * spLen;\n    rLeadS.y = GrndHt (rLeadS.xz) + 2.;\n    if (mId < ms) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    ntStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    rLeadS = stDat.xyz;\n    ++ ntStep;\n    rLeadS.xz += 0.02;\n    rLead = rLeadS;\n    rLead.y = GrndHt (rLead.xz) + 2.;\n    if (mId < ms) Step (iv, r, v);\n  }\n  if (pxId == 2 * ms + 1 || pxId == 2 * ms + 2) SheetLims ();\n  if (pxId < 2 * ms) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * ms + 0) stDat = stDat = vec4 (spLen, ntStep, 0., 0.);\n    else if (pxId == 2 * ms + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * ms + 2) stDat = vec4 (pMax, 0.);\n    else if (pxId == 2 * ms + 3) stDat = vec4 (rLeadS, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// \"Surface Skimmer\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashff (float p);\nfloat Noisefv2 (vec2 p);\nvec4 Loadv4 (vec2 vId);\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nconst int nBallE = 33;\n\nvec3 rLead, pMin, pMax;\nivec2 idNeb[4], idNebD[4];\nfloat spLen, fOvlap, grav, ntStep;\nconst float pi = 3.14159;\n\nfloat GrndHt (vec2 p)\n{\n  mat2 fqRot;\n  vec2 q;\n  float h, a;\n  fqRot = 2. * mat2 (0.6, -0.8, 0.8, 0.6);\n  q = 0.02 * p;\n  h = 0.;\n  a = 10.;\n  for (int j = 0; j < 5; j ++) {\n    h += a * Noisefv2 (q);\n    a *= 0.5;\n    q *= fqRot;\n  }\n  return h;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  const vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvec3 GetR (vec2 v)\n{\n  return Loadv4 (v).xyz;\n}\n\nvec3 GetV (vec2 v)\n{\n  return Loadv4 (vec2 (v.x + float (nBallE), v.y)).xyz;\n}\n\nvec3 SpringForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 dr, f;\n  ivec2 ivn;\n  float spLenD, fSpring, fDamp;\n  fSpring = 200.;\n  fDamp = 0.5;\n  f = vec3 (0.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNeb[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += fSpring * (spLen - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  spLenD = spLen * sqrt (2.);\n  for (int n = 0; n < 4; n ++) {\n    ivn = iv + idNebD[n];\n    if (ivn.y >= 0 && ivn.y < nBallE && ivn.x >= 0 && ivn.x < nBallE) {\n      dr = r - GetR (vec2 (ivn));\n      f += 5. * fSpring * (spLenD - length (dr)) * normalize (dr) -\n         fDamp * (v - GetV (vec2 (ivn)));\n    }\n  }\n  return f;\n}\n\nvec3 BendForce (ivec2 iv, vec3 r)\n{\n  vec3 dr1, dr2, rt, f;\n  ivec2 ivd, ivp, ivm;\n  float s, c11, c22, c12, cd, fBend;\n  bool doInt;\n  fBend = 500.;\n  f = vec3 (0.);\n  for (int nd = 0; nd < 2; nd ++) {\n    ivd = (nd == 0) ? ivec2 (1, 0) : ivec2 (0, 1);\n    for (int k = 0; k < 3; k ++) {\n      doInt = false;\n      if (nd == 0) {\n        if (k == 0 && iv.x > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.x < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.x > 0 && iv.x < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      } else {\n        if (k == 0 && iv.y > 1) {\n          ivp = iv - ivd;\n          ivm = ivp - ivd;\n          doInt = true;\n        } else if (k == 2 && iv.y < nBallE - 2) {\n          ivm = iv + ivd;\n          ivp = ivm + ivd;\n          doInt = true;\n        } else if (k == 1 && (iv.y > 0 && iv.y < nBallE - 1)) {\n          ivp = iv + ivd;\n          ivm = iv - ivd;\n          doInt = true;\n        }\n      }\n      if (doInt) {\n        if (k == 0) {\n          rt = GetR (vec2 (ivp));\n          dr1 = rt - GetR (vec2 (ivm));\n          dr2 = r - rt;\n          s = -1.;\n        } else if (k == 2) {\n          rt = GetR (vec2 (ivm));\n          dr1 = rt - r;\n          dr2 = GetR (vec2 (ivp)) - rt;\n          s = -1.;\n        } else {\n          dr1 = r - GetR (vec2 (ivm));\n          dr2 = GetR (vec2 (ivp)) - r;\n          s = 1.;\n        }\n        c11 = 1. / dot (dr1, dr1);\n        c12 = dot (dr1, dr2);\n        c22 = 1. / dot (dr2, dr2);\n        cd = sqrt (c11 * c22);\n        s *= fBend * cd * (c12 * cd - 1.);\n        if (k <= 1) f += s * (dr1 - c12 * c22 * dr2);\n        if (k >= 1) f += s * (c12 * c11 * dr1 - dr2);\n      }\n    }\n  }\n  return f;\n}\n\nvec3 PairForce (vec3 r)\n{\n  vec3 dr, f;\n  float rSep;\n  int nx, ny;\n  f = vec3 (0.);\n  nx = 0;\n  ny = 0;\n  for (int n = 0; n < nBallE * nBallE; n ++) {\n    dr = r - GetR (vec2 (nx, ny));\n    rSep = length (dr);\n    if (rSep > 0.01 && rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n    if (++ nx == nBallE) {\n      nx = 0;\n      ++ ny;\n    }  \n  }\n  return f;\n}\n\nvec3 NormForce (ivec2 iv, vec3 r, vec3 v)\n{\n  vec3 f, n;\n  ivec2 e = ivec2 (1, 0);\n  f = vec3 (0.);\n  if (iv.y > 0 && iv.y < nBallE - 1 && iv.x > 0 && iv.x < nBallE - 1) {\n    n = normalize (cross (GetR (vec2 (iv + e.yx)) - GetR (vec2 (iv - e.yx)),\n       GetR (vec2 (iv + e)) - GetR (vec2 (iv - e))));\n    f = - 10. * dot (v, n) * n;\n  }\n  return f;\n}\n\nvoid IdNebs ()\n{\n  idNeb[0] = ivec2 (1, 0);\n  idNeb[1] = - idNeb[0];\n  idNeb[2] = ivec2 (0, 1);\n  idNeb[3] = - idNeb[2];\n  idNebD[0] = ivec2 (1, 1);\n  idNebD[1] = - idNebD[0];\n  idNebD[2] = ivec2 (1, -1);\n  idNebD[3] = - idNebD[2];\n}\n\nvoid Step (ivec2 iv, out vec3 r, out vec3 v)\n{\n  vec3 dr, f;\n  vec2 s;\n  float fDamp, dt, rSep, w, t;\n  IdNebs ();\n  fDamp = 0.5;\n  r = GetR (vec2 (iv));\n  v = GetV (vec2 (iv));\n  f = PairForce (r) + SpringForce (iv, r, v) + BendForce (iv, r) +\n     NormForce (iv, r, v);\n  dr.xz = -0.55 * GrndNf (r).xz;\n  dr.y = r.y + 0.55 - GrndHt (r.xz - dr.xz);\n  rSep = length (dr);\n  if (rSep < 1.) f += fOvlap * (1. / rSep - 1.) * dr;\n  f -= fDamp * v;\n  f.y -= grav;\n  s = float (nBallE) - vec2 (iv);\n  w = max (1. - dot (s, s) / 8., 0.);\n  f += 100. * w * (rLead - r);\n  t = mod (ntStep / 500., 8.);\n  f.y += 200. * w * ((t < 6.) ? t : 3. * (8. - t));\n  dt = 0.02;\n  v += dt * f;\n  r += dt * v;\n}\n\nvoid Init (ivec2 iv, out vec3 r, out vec3 v)\n{\n  float fn;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      if (iv.x == ix && iv.y == iy) {\n        r = vec3 (ix, 0., iy);\n        r.xz -= 0.5 * (vec2 (nBallE, nBallE) - 1.);\n        r *= 0.97 * spLen;\n        r.y += GrndHt (r.xz) + 3. * spLen;\n      }\n    }\n  }\n  fn = float (iv.y * nBallE + iv.x);\n  v = 1. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff (fn + 0.6)) - 0.5);\n}\n\nvoid SheetLims ()\n{\n  vec3 p;\n  pMin = vec3 (1e6);\n  pMax = - pMin;\n  for (int iy = 0; iy < nBallE; iy ++) {\n    for (int ix = 0; ix < nBallE; ix ++) {\n      p = GetR (vec2 (ix, iy));\n      pMin = min (pMin, p);\n      pMax = max (pMax, p);\n    }\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 stDat;\n  vec3 r, v, rLeadS;\n  ivec2 pxIv, iv;\n  int mId, pxId, ms;\n  pxIv = ivec2 (fragCoord);\n  pxId = pxIv.x + 2 * nBallE * pxIv.y;\n  ms = nBallE * nBallE;\n  if (pxIv.x >= 2 * nBallE || pxId >= 2 * ms + 4) discard;\n  stDat = Loadv4 (vec2 (2, nBallE));\n  iv = pxIv;\n  if (iv.x >= nBallE) iv.x -= nBallE;\n  mId = iv.y * nBallE + iv.x;\n  fOvlap = 1000.;\n  grav = 0.5;\n  if (iFrame <= 5) {\n    spLen = 1.1;\n    ntStep = 0.;\n    rLeadS.xz = 0.5 * (vec2 (nBallE, nBallE) - 1.) * 0.97 * spLen;\n    rLeadS.y = GrndHt (rLeadS.xz) + 2.;\n    if (mId < ms) Init (iv, r, v);\n  } else {\n    stDat = Loadv4 (vec2 (0, nBallE));\n    spLen = stDat.x;\n    ntStep = stDat.y;\n    stDat = Loadv4 (vec2 (3, nBallE));\n    rLeadS = stDat.xyz;\n    ++ ntStep;\n    rLeadS.xz += 0.02;\n    rLead = rLeadS;\n    rLead.y = GrndHt (rLead.xz) + 2.;\n    if (mId < ms) Step (iv, r, v);\n  }\n  if (pxId == 2 * ms + 1 || pxId == 2 * ms + 2) SheetLims ();\n  if (pxId < 2 * ms) stDat = vec4 (((pxIv.x >= nBallE) ? v : r), 0.);\n  else {\n    if (pxId == 2 * ms + 0) stDat = stDat = vec4 (spLen, ntStep, 0., 0.);\n    else if (pxId == 2 * ms + 1) stDat = vec4 (pMin, 0.);\n    else if (pxId == 2 * ms + 2) stDat = vec4 (pMax, 0.);\n    else if (pxId == 2 * ms + 3) stDat = vec4 (rLeadS, 0.);\n  }\n  Savev4 (vec2 (pxIv), stDat, fragColor, fragCoord);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 - 0.5 * (b - a) / r, 0., 1.);\n  return r * h * (1. - h) - mix (b, a, h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (vec2 vId)\n{\n  return texture (txBuf, (vId + 0.5) / txSize);\n}\n\nvoid Savev4 (vec2 vId, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d = abs (fCoord - vId - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}