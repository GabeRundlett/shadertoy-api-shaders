{
    "Shader": {
        "info": {
            "date": "1585770189",
            "description": "No idea what this could be, so I call it a gentle bloby thing... Just for fun.",
            "flags": 0,
            "hasliked": 0,
            "id": "tslyWf",
            "likes": 4,
            "name": "Gentle Bloby Thing",
            "published": 3,
            "tags": [
                "raymarching",
                "blob",
                "softshadows"
            ],
            "usePreview": 0,
            "username": "propagant",
            "viewed": 382
        },
        "renderpass": [
            {
                "code": "//#define WALLS_ENABLED\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n    \n#define opu(a, b) a.w < b.w ? a : b\n\nvec4 geo(vec3 p)\n{\n    float sXsin = sin(iTime * 0.8)*0.3; // Horizontal movement\n    float sXsin2 = sin(iTime * 0.8)*0.23;\n    float sXsinDouble = 0.2+sin(iTime * 1.5 )*0.1; // Horizontal movement 2xSpeed\n    float sBlob = sin(iTime * 3. + p.y * 8.); // 'Sphere blob'\n    \n\tvec4 o0 = vec4(0.2,0.6,1.0, length(p - vec3(sXsin,0.,1.5)) - 0.2 + sBlob * 0.0999);\n    o0.w *= smoothstep(0.1,0.05, -p.y-0.22) + clamp(abs(sXsin),0.05,0.2); // The 'slimy' effect below the 'blob'\n    \n    #ifdef WALLS_ENABLED\n    o0.w *= smoothstep(0.02,0.01, abs(p.x)*0.02); // The 'Wall' generation\n    #endif\n    \n\tvec4 o0eye = vec4(vec3(1.0,1.0,1.0)*1.5, abs(length(p - vec3(sXsin,sXsinDouble,1.2)) - 0.01 + clamp(sBlob,-0.3,-0.1) * 0.0999)*0.45);\n    vec4 o0eyeb = vec4(vec3(0.0,0.0,0.0)*1.5, abs(length(p - vec3(sXsin2,sXsinDouble,1.15)) - 0.08 * 0.0999)*0.5);\n    vec4 o2 = vec4(0.2,0.4,0.5, p.y + 0.35);\n\t\n    // Final mix\n    vec4 g = opu(o2, o0);\n    vec4 g2 = opu(g, o0eye);\n    vec4 g3 = opu(g2, o0eyeb);\n    return g3;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001,0.0);\n\tvec4 copy = geo(p);\n\treturn normalize(copy.w - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w));\n}\n\nfloat shadows(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.0;\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tfloat g = geo(ro+rd*t).w;\n\t\tres = min(res, b * g / t); // Soft shadows\n\t\tt += g;\n\t\tif(g < 0.0005|| g > 3.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\treturn clamp(res,0.1,1.0);\n}\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\tvec3 lPos = normalize(lp - p);\n\tvec3 n = normal(p);\n    \n    float spec = pow(max(dot(lPos, n),0.),80.)*0.2; // BlinnPhong\n\t\n\tfloat light = clamp(dot(n, lPos), 0.6, 1.); // Lambert\n\treturn light * shadows(p, normalize(lp), 1.0) + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    ray r;\n\tr.o = vec3(0.);\n\tr.d = vec3(uv, 1.0);\n\tvec4 mm = march(r);\n\n\tvec3 m = r.o + r.d * mm.w;\n\tvec3 lPos = vec3(0.,2.5,1.);\n    #ifdef WALLS_ENABLED\n    #else\n        lPos = vec3(sin(iTime * 1.0)*1.5,1.5,cos(iTime * 1.0)*1.5);\n    #endif\n\tvec3 col = mm.rgb * lighting(m, lPos);\n\tcol *= exp(-0.2 * mm.w * mm.w * mm.w * mm.w) *  5.; // Fog + quick gamma\n    if(mm.w > 2.5) col = mix(col, vec3(0.2,0.3,0.8), uv.y-0.1); // Simple background gradient\n\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}