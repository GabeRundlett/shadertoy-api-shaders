{
    "Shader": {
        "info": {
            "date": "1534515016",
            "description": "Quake (1996) starting area, ray-traced.\n\nKey map (Buffer A):[code]\nmenu        \tTab/Esc\nresolution  \t1-5, +/-\nperf. info  \tP\nmove        \tWASD/ZQSD/arrows/space\nfire        \tE/F\nrespawn     \tHome/Bksp\ntex. filter \tT\nlight shafts\tL[/code]Aim for the sky ;)",
            "flags": 48,
            "hasliked": 0,
            "id": "lsKfWd",
            "likes": 267,
            "name": "Quake / Introduction",
            "published": 3,
            "tags": [
                "game",
                "text",
                "logo",
                "raytrace",
                "font",
                "start",
                "tribute",
                "quake",
                "lightmap"
            ],
            "usePreview": 1,
            "username": "adx",
            "viewed": 30157
        },
        "renderpass": [
            {
                "code": "#if __VERSION__ < 300\n#\terror Sorry, this shader requires WebGL 2.0!\n#endif\n\n/***************************************************************\n  Quake / Introduction\n  A textureless* shader recreating the first room of Quake (1996)\n  Andrei Drexler 2018\n\n  For some details on how this shader was made, see this Twitter thread:\n  https://twitter.com/andrei_drexler/status/1217945589989748742\n\n  Many thanks to:\n\n- id Software - for creating not only a great game/series, but also\n  a thriving modding community around it through the release of\n  dev tools, code, and specs, inspiring new generations of game developers:\n  https://github.com/id-Software/Quake\n\n- John Romero - for creating such memorable designs in the first place,\n  and then releasing the original map files:\n  https://rome.ro/news/2016/2/14/quake-map-sources-released\n\n- Inigo Quilez (@iq) - for his many articles/code samples on signed distance fields,\n  ray-marching, noise and more:\n  https://iquilezles.org/articles/distfunctions\n  https://iquilezles.org/articles/smin\n  https://iquilezles.org/articles/voronoilines\n  https://iquilezles.org/www/index.htm\n\n- Jamie Wong (@jlfwong) - for his article on ray-marching/SDF's (and accompanying samples):\n  http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n\n- Mercury - for the hg_sdf library:\n  http://mercury.sexy/hg_sdf\n\n- Paul Malin (@P_Malin) - for his awesome QTest shader, that prompted me to resume work and replace\n  the AO+TSS+negative/capsule lights combo with proper lightmaps, somewhat similar to his solution:\n  https://www.shadertoy.com/view/MdGXDK\n\n- Brian Sharpe - for his GPU noise library/blog:\n  https://github.com/BrianSharpe/GPU-Noise-Lib\n  https://briansharpe.wordpress.com\n\n- Dave Hoskins (@Dave_Hoskins) - for his 'Hash without Sine' functions:\n  https://www.shadertoy.com/view/4djSRW\n\n- Marc B. Reynolds (@MBR) - for his 2D Weyl hash code\n  https://www.shadertoy.com/view/Xdy3Rc\n  http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\n\n- Morgan McGuire (@morgan3d) - hash functions:\n  https://www.shadertoy.com/view/4dS3Wd\n  http://graphicscodex.com\n\n- Fabrice Neyret (@FabriceNeyret2) - for his 'Shadertoy - Unofficial' blog:\n  https://shadertoyunofficial.wordpress.com\n\n- Alan Wolfe (@demofox) - for his blog post on making a ray-traced snake game in Shadertoy,\n  which inspired me to get started with this shader:\n  https://blog.demofox.org/2016/01/16/making-a-ray-traced-snake-game-in-shadertoy/\n  https://www.shadertoy.com/view/XsdGDX\n\n- Playdead - for their presentation/code on temporal reprojection antialiasing:\n  http://twvideo01.ubm-us.net/o1/vault/gdc2016/Presentations/Pedersen_LasseJonFuglsang_TemporalReprojectionAntiAliasing.pdf\n  https://github.com/playdeadgames/temporal\n\n- Sebastian Aaltonen (@sebbbi) - for his 'Advection filter comparison' shader:\n  https://www.shadertoy.com/view/lsG3D1\n\n- Bart Wronski - for his Poisson sampling generator:\n  https://github.com/bartwronski/PoissonSamplingGenerator\n\n- And, of course, Inigo Quilez and Pol Jeremias - for Shadertoy.\n  \n  ---\n\n  If you're interested in other recreations of id Software games,\n  you might also like:\n  \n- Wolfenstein 3D by @reinder:\n  https://www.shadertoy.com/view/4sfGWX\n\n- [SH16C] Doom by @P_Malin - fully playable E1M1, pushing the Shadertoy game concept to its limits:\n  https://www.shadertoy.com/view/lldGDr\n\n- Doom 2 by @reinder:\n  https://www.shadertoy.com/view/lsB3zD\n\n- QTest by @P_Malin:\n  https://www.shadertoy.com/view/MdGXDK\n\n  ---\n\n  * The blue noise texture doesn't count!\n***************************************************************/\n\n////////////////////////////////////////////////////////////////\n// Image buffer:\n// - loading screen/console\n// - rendered image presentation + motion blur\n// - pain blend\n// - performance graph\n// - text (console/skill selection/demo stage)\n////////////////////////////////////////////////////////////////\n\n// config.cfg //////////////////////////////////////////////////\n\n#define FPS_GRAPH_MAX\t\t\t60\n#define PRINT_SKILL_MESSAGE\t\t1\n#define GAMMA_MODE\t\t\t\t0\t\t// [0=RGB; 1=luma]\n\n#define USE_CRT_EFFECT\t\t\t1\n#define CRT_MASK_WEIGHT\t\t\t1./16.\n#define CRT_SCANLINE_WEIGHT\t\t1./16.\n\n#define USE_MOTION_BLUR\t\t\t1\n#define MOTION_BLUR_FPS\t\t\t60\n#define MOTION_BLUR_AMOUNT\t\t0.5\t\t// fraction of frame time the shutter is open\n#define MOTION_BLUR_SAMPLES\t\t9\t\t// recommended range: 7..31\n\n#define DEBUG_LIGHTMAP\t\t\t0\t\t// 1=packed (RGBA); 2=unpacked (greyscale)\n#define DEBUG_ATLAS\t\t\t\t0\n#define DEBUG_TEXTURE\t\t\t-1\n#define DEBUG_CLICK_ZOOM\t\t4.0\t\t// zoom factor when clicking\n\n// For key bindings/input settings, check out Buffer A\n\n// For a more enjoyable experience, try my Shadertoy FPS mode script\n// https://github.com/andrei-drexler/shadertoy-userscripts\n\n// TODO (maybe) ////////////////////////////////////////////////\n\n// - Improve texture quality\n// - Clean-up & optimizations\n// - Functional console\n// - Gameplay & HUD polish\n\n// Snapshots ///////////////////////////////////////////////////\n\n// For a comparison with the initial release, check out\n// https://www.shadertoy.com/view/MtVBzV\n\n// For a comparison with the last version to use negative/capsule lights,\n// ambient occlusion and temporal reprojection (for denoising), check out\n// https://www.shadertoy.com/view/Ws2SR1\n\n// Changelog ///////////////////////////////////////////////////\n\n// 2021-01-06\n// - Added support for +/- in Firefox (different keycodes...)\n//\n// 2020-11-15\n// - Changed mouselook code to be compatible with recent Shadertoy update\n//\n// 2020-03-26\n// - Slightly more Quake-like acceleration/friction\n//\n// 2020-03-21\n// - Improved mouse movement handling for less common aspect ratios (e.g. portrait)\n// - Switched to centered motion blur sampling (better near screen edges)\n// - Moved scene quantization to Buffer D (before motion blur)\n//\n// 2020-03-20\n// - Added workarounds for old ANGLE error (length can only be called on array names, not on array expressions)\n//   https://github.com/google/angle/commit/bb2bbfbbf443fe0c1f8af12bacfdf1a945aea5a4#diff-b7bae477c1aea4edd01d4479fda69a87L5488\n//\n// 2019-09-03\n// - Added window projection when light shafts are enabled\n//\n// 2019-09-01\n// - Added basic/subtle CRT effect, with menu option (off by default)\n//\n// 2019-08-26\n// - Added subtle light shaft animation (VOLUMETRIC_ANIM in Buffer D)\n//\n// 2019-08-24\n// - Bumped default brightness up another notch\n// - Fixed muzzle flash texture\n//\n// 2019-08-22\n// - Added 'light shafts' menu option (off by default)\n//\n// 2019-08-21\n// - Added volumetric lighting player shadow\n// - Tweaked volumetric lighting falloff\n//\n// 2019-08-20\n// - Added light shafts (RENDER_VOLUMETRICS 1 in Buffer D)\n//\n// 2019-07-02\n// - Switched entity rotations to quaternions in order to reduce register\n//   pressure => ~35% GPU usage @800x450, down from ~40% (both at 1974 MHz)\n// - Bumped default brightness up a notch\n// - Tweaked WINDOW02_1 texture\n//\n// 2019-06-30\n// - Added texture filter menu option (shortcut: T)\n//\n// 2019-06-19\n// - Tweaked console id logo background\n// - Added motion blur menu option\n//\n// 2019-06-12\n// - Tweaked QUAKE, WINDOW02_1 and WBRICK1_5 textures\n// - Tweaked weapon model SDF, textures and movement anim range\n// - Tweaked console background and text\n// - Added back optional motion blur (USE_MOTION_BLUR 1 in Image tab)\n// - Simplified naming scheme for Dave Hoskins' Hash without Sine functions\n//\n// 2019-06-07\n// - Replaced FOV-based weapon model offset with pitch adjustment, eliminating\n//   severe perspective distortion at higher vertical FOV's (e.g portrait mode)\n// - Fixed console version string misalignment on aspect ratios other than 16:9\n//\n// 2019-06-06\n// - Added FOV-based weapon model offset\n// - Added BAKE_LIGHTMAP macro in Buffer B (for lower iteration times)\n// - Tweaked weapon model SDF\n// - Tweaked QUAKE texture\n//\n// 2019-06-04\n// - Baked collision map planes to Buffer A, reducing its compilation time by ~6%\n//   (~8.3 vs ~8.8 seconds) on my system\n// - Baked font glyphs to Buffer C, reducing Image buffer compilation time by ~14%\n//   (~3.7 vs ~4.3 seconds)\n// - Removed unused UV visualisation code, reducing Buffer D compilation time by ~47%\n//   (~1.0 vs ~1.9 seconds)\n// - Optimized pow10 function used in number printing\n//\n// 2019-05-10\n// - Fixed infinite loading screen on OpenGL (out vs inout)\n//\n// 2019-05-05\n// - Freeze entity and texture animations when menu is open\n//\n// 2019-05-02\n// - Added 'Show weapon' and 'Noclip' options\n// - Tweaked WBRICK1_5 texture\n//\n// 2019-04-24\n// - Switched to MBR's 2D Weyl hash for UI textures (for consistency across platforms)\n// - More UI texture tweaks\n//\n// 2019-04-22\n// - Tweaked engraved textures (QUAKE, Options title)\n// - Added QUAKE/id image on the left side of the menu\n// - Added 'Show lightmap' menu option\n// - Removed left-over guard band code\n//\n// 2019-04-18\n// - Tweaked brushwork for slightly better lightmap utilization\n// - Changed lightmap dimensions to potentially accomodate another UI texture\n//   in Buffer C even in 240x135 mode (smallest? Shadertoy thumbnail size)\n// - Tweaked menu title texture\n//\n// 2019-04-17\n// - Wired all options\n// - Changed menu definition to array of structs (from array of ints), fixing menu\n//   behavior on Surface 3 (codegen bug?)\n// - Paused gameplay when menu is open\n// - Changed default GAMMA_MODE (Image tab) to RGB (authentic)\n//\n// 2019-04-16\n// - Added Options menu stub\n//\n// 2019-04-11\n// - Added strafe key (Alt)\n// - Added FPS display in demo mode\n//\n// 2019-04-10\n// - Added macro-based RLE for runs of 0 in the lightmap tile array (-~270 chars)\n// - Changed lightmap encoding and sample weighting\n// - Changed lightmap padding to 0.5 texels (from 2), reduced number of dilation\n//   passes to 1 (from 2) and disabled lightmap blur pass\n// - Added zoom click for DEBUG_* modes (Image tab)\n//\n// 2019-04-09\n// - More texture tweaks\n// - Added LOD_SLOPE_SCALE option (Buffer D)\n// - Reduced potentially lit surface set (4.3k smaller shader code)\n// - Added basic compression for the lightmap tile array in Buffer A (-1k)\n// - Changed default rendering scale to 1 (was 0.5)\n//\n// 2019-03-31\n// - Changed GENERATE_TEXTURES macro (Buffer A) from on/off switch to bit mask,\n//   enabling selective texture compilation (for faster iteration)\n// - Tweaked WBRICK1_5 and WIZMET1_1 textures\n//\n// 2019-03-26\n// - Tweaked CITY4_6, BRICKA2_2 and WINDOW02_1 textures\n//\n// 2019-03-24\n// - Snapped console position to multiples of 2 pixels to avoid shimmering\n//\n// 2019-03-23\n// - Robust thumbnail mode detection (based on iTime at iFrame 0)\n// - Increased brightness, especially in thumbnail mode\n// - Disabled weapon rendering for demo mode cameras 1 and 3 and tweaked their locations\n//\n// 2019-03-22\n// - Fixed shadow discontinuities on the floor at the start of the skill hallways\n// - Increased lightmap padding to 2 px\n// - Optimized brushwork to reduce lightmapped area\n// - Added 3 more viewpoints for the demo mode/thumbnail view\n//\n// 2019-03-20\n// - Lightmap baking tweaks: 8xAA + 1 blur step, ignored solid samples,\n//   extrapolation, better (but still hacky) handling of liquid brushes,\n//   uv quantization, reduced baking time on low-end devices (e.g. Surface 3)\n// - Added color quantization for console & composited scene\n//\n// 2019-03-18\n// - Replaced AO+TSS combo with actual lightmaps. Saved old version as\n//   https://www.shadertoy.com/view/Ws2SR1\n//\n// 2019-03-17\n// - Octahedral encoding for gbuffer normals\n//\n// 2019-03-15\n// - Major performance improvement for Intel iGPUs: 45+ fps\n//   on a Surface 3 (Atom x7-Z8700), up from ~1.4 fps (window mode)\n// - Added luminance gamma option (GAMMA_MODE in Image tab)\n//\n// 2019-03-07\n// - Tighter encoding for axial brushes & atlas tiles\n// - Added experimental TSS_FILTER (Buffer D), based on\n//   https://www.shadertoy.com/view/lsG3D1 (by sebbbi)\n//\n// 2019-01-10\n// - Added workaround for Shadertoy double-buffering bug on resize.\n//   This fixes partially black textures when pausing the shader,\n//   shrinking the window and then maximizing it again\n//\n// 2019-01-05\n// - Reduced overall compilation time by ~30% on my system (~28.5s -> ~20s),\n//   mostly from Buffer A optimizations (~14s -> ~6s) :>\n//\n// 2019-01-03\n// - Minor map compiler tweaks: flat (degenerate) liquid brushes,\n//   improved precision of certain operations\n// - Added extra wall sliding friction\n//\n// 2018-12-21\n// - Added Z/Q bindings for AZERTY users\n//\n// 2018-12-20\n// - Added # of targets left to HUD\n// - Added HUD line spacing, shadow box and color highlight effect\n//\n// 2018-12-16\n// - Blue noise (instead of white) for the motion blur trail offset\n//\n// 2018-12-14\n// - Disabled TSS/motion blur when teleporting\n// - Minor motion blur tweaks\n//\n// 2018-12-10\n// - Added experimental motion blur code (Buffer D),\n//   mostly for video recording; off by default\n//\n// 2018-12-04\n// - Slightly more compact map material assignment\n// - Removed overly cautious fudge factor (-5%) from slide move code\n//\n// 2018-11-28\n// - Disabled continuous texture generation (~11% perf boost)\n//\n// 2018-11-26\n// - Changed USE_PARTITION macro (in Buffer B) to axial/non-axial bitmask\n//\n// 2018-11-25\n// - Added BVL for axial brushes\n// - Removed BVH code (USE_PARTITION 2), keeping just the BVLs\n//\n// 2018-11-24\n// - Minor map brushwork optimization\n// - Increased number of leaves in non-axial brush BVH from 7 to 10\n// - Further reduced Buffer B compilation time by about 40%\n//\n// 2018-11-22\n// - Reduced Buffer B compilation time (~10.8s vs ~12.6s) using Klems'\n//   loop trick in normal estimation function\n// - Added USE_ENTITY_AABB macro in Buffer B\n//\n// 2018-11-19\n// - Resolution-dependent ray marching epsilon scale\n//\n// 2018-11-18\n// - Tweaked loading screen sparks\n// - Disabled weapon firing before console slide-out\n// - Invalidated ground plane when noclipping\n//\n// 2018-11-14\n// - More BVH/BVL tweaks: greedy split node selection instead of recursive,\n//   leaf count limit instead of primitive count, sorted BVL elements\n//   based on distance to world center\n//\n// 2018-11-13\n// - Tweaked SAH builder to consider all axes, not just the largest one\n//\n// 2018-11-12\n// - Added non-axial brush partition (USE_PARTITION in Buffer B)\n//\n// 2018-11-10\n// - Fixed weapon model TSS ghosting\n//\n// 2018-11-09\n// - Moved teleporter effect to Buffer C (lower resolution) and optimized\n//   its hashing\n// - Added lightning flash on game start\n//\n// 2018-11-08\n// - Added fast path for axial brush rendering\n//\n// 2018-11-07\n// - Added entity AABB optimization (and DEBUG_ENTITY_AABB option in Buffer B)\n//\n// 2018-11-06\n// - Slightly optimized raymarching using bounding spheres\n//   (~5% lower overall GPU usage at max frequency for 800x450 @144 fps)\n//\n// 2018-11-03\n// - Started adding persistent state structs/macros to improve\n//   code readability (e.g. game_state.level instead of fragColor.x);\n//   see end of Common buffer\n// - Reduced Buffer B compilation time (~6.9s vs ~7.5s on my system)\n//\n// 2018-11-02\n// - Added credits\n//\n// 2018-10-29\n// - Removed demo mode voronoi halftoning\n// - Added two more balloon sets to provide some round-to-round variation\n// - Tweaked round timing: can you make it to level 18?\n//\n// 2018-10-27\n// - Added INVERT_MOUSE option (Buffer A)\n// - Desaturated/darkened balloons during the game over transition\n//\n// 2018-10-26\n// - Fixed bug that caused popped balloons to reappear during\n//   the game over animation\n// - Disabled balloon popping during game over animation\n// - Added 'Game over' message\n//\n// 2018-10-25\n// - Minor polish: blinking timer when almost out of time,\n//   animated balloon scale-out when game is over\n//\n// 2018-10-24\n// - Added level start countdown\n// - Added game timer; game is over when time expires\n// - Match particle color with balloon color, if a balloon was hit\n//\n// 2018-10-23\n// - Added very basic target practice mode and reduced shotgun spread;\n//   aim for the sky!\n//\n// 2018-10-17\n// - Added automatic pitch adjustment when moving and not using the mouse\n//   for looking around; see LOOKSPRING_DELAY in Buffer A\n//\n// 2018-10-16\n// - Fixed occasional stair detection stutter at low FPS\n//\n// 2018-10-12\n// - Optimized entity normal estimation: ~6.2 seconds to compile Buffer B,\n//   down from ~8.6\n//\n// 2018-10-11\n// - Sample weapon lighting at the ground level instead of a fixed distance\n//   below the camera\n// - Added sliding down slopes\n//\n// 2018-10-10\n// - Fixed weapon model lighting seam when crossing a power-of-two boundary\n// - Clamped lighting to prevent weapon model overdarkening from negative lights\n// - Minor collision map brushwork tweak\n//\n// 2018-10-09\n// - Optimized Buffer A compilation time a bit (~14.1 vs ~14.8 seconds on my system)\n// - Fixed cloud tiling on Linux\n//\n// 2018-10-08\n// - Added weapon firing on E/F (not Ctrl, to avoid closing the window on Ctrl+W)\n// - Fixed TSS artifact when climbing stairs\n//\n// 2018-10-07\n// - Tweaked ray-marching loop to eliminate silhouette sparkles\n// - Tweaked weapon model colors (this time without f.lux...)\n// - Disabled TSS for the weapon model\n//\n// 2018-10-06\n// - Added shotgun model. Set RENDER_WEAPON to 0 in Buffer B to disable it\n// - Minor brushwork optimizations\n//\n// 2018-10-04\n// - Fixed brushwork that deviated from the original design in the playable area\n// - Tightened up map definition some more (-13 lines)\n//\n// 2018-10-03\n// - Added NOCLIP option (Buffer A)\n//\n// 2018-10-01\n// - Faked two-sided lava/water surfaces\n// - Added simple lava pain effect\n//\n// 2018-09-30\n// - Tweaked player movement a bit (air control, smoother accel/decel, head bobbing)\n// - Changed console typing animation :>\n//\n// 2018-09-29\n// - Added basic collision detection; needs more work\n//\n// 2018-09-19\n// - Reduced BufferC compilation time (~3s vs ~4.2s on my system)\n//\n// 2018-09-18\n// - Added particle trail early-out (using screen-space bounds)\n//\n// 2018-09-17\n// - Tightened up map definition even more (<100 lines now)\n//\n// 2018-09-15\n// - Particle trail tweaks\n//\n// 2018-09-14\n// - Made particles squares instead of disks (more authentic)\n// - Added proper occlusion between particles\n//\n// 2018-09-11\n// - Added fireball particle trail (unoptimized)\n//\n// 2018-09-10\n// - Lighting tweaks\n//\n// 2018-09-08\n// - Added option to reduce TSS when in motion (by 50% by default).\n//   Seems counter-intuitive, but the end result is that the image\n//   stays sharp in motion, and static shots are still denoised\n// - Fixed temporal supersampling artifacts due to unclamped RGB input\n// - Increased sky layer resolution (128x128, same as in Quake) and\n//   adjusted atlas accordingly (mip 0 is 512x256 now, filled 100%)\n// - Increased sky speed to roughly match Quake (super fast)\n// - Added manual shadows for the spikes in the 'hard' area\n//\n// 2018-09-07\n// - YCoCg for temporal supersampling (USE_YCOCG in the Common tab)\n// - More map optimizations (~23% smaller now compared to first version)\n//\n// 2018-09-06\n// - Added temporal supersampling (Buffer D), mostly to denoise AO\n// - Disabled map rendering during loading screen\n//\n// 2018-09-05\n// - Map optimizations: ~17% fewer brushes/planes, tweaked material\n//   assignment, aligned some non-axial planes\n// - Added basic FPS display (mostly for full-screen mode)\n// - Added text scaling based on resolution\n//\n// 2018-09-03\n// - Added depth/depth+angle mip-mapping (USE_MIPMAPS 2/3 in Buffer C)\n// - Added mip level dithering (LOD_DITHER in Buffer C)\n// - Even more compact map data storage (Buffer B)\n// - Tweaked lava and water textures a bit\n//\n// 2018-08-30\n// - Tweaked entity SDF's a bit\n// - Slightly more compact map data formatting\n//\n// 2018-08-27\n// - Added version number and id logo to console\n// - More thumbnail time-shifting\n//\n// 2018-08-26\n// - Rewrote font code\n// - Added console loading/typing intro\n//\n// 2018-08-24\n// - Added (static) console text\n// - Added skill selection message triggers\n//\n// 2018-08-23\n// - Added demo mode captions (with basic fixed-width font code).\n//   Had to move some of the demo code, including the master switch,\n//   to the Common tab.\n//\n// 2018-08-22\n// - Enabled demo mode automatically for thumbnails and adjusted\n//   thumbnail time again\n//\n// 2018-08-21\n// - Added mouse filtering (Buffer A). Useful for video recording;\n//   off by default\n// - Added voronoi halftoning and DEMO_MODE_HALFTONE in Buffer C\n//\n// 2018-08-20\n// - Use halftoning instead of blue noise dither for demo mode\n//   transition (doesn't confuse video encoders as much)\n//\n// 2018-08-19\n// - Reduced compilation time for Buffer B by almost 5 seconds\n//   on my machine (~7.6 vs ~12.5)\n//\n// 2018-08-18\n// - Generate lower-res atlas/mip chain when resolution is too low\n//   to fit a full-res one (e.g. thumbnails, really small windows)\n// - Show intro in thumbnail mode (by offsetting time by ~10s)\n//\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define SETTINGS_CHANNEL\tiChannel0\n#define PRESENT_CHANNEL\t\tiChannel2\n#define NOISE_CHANNEL\t\tiChannel1\n#define LIGHTMAP_CHANNEL\tiChannel3\n\n////////////////////////////////////////////////////////////////\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n// Font ////////////////////////////////////////////////////////\n\nconst int\n    _A_= 1, _B_= 2, _C_= 3, _D_= 4, _E_= 5, _F_= 6, _G_= 7, _H_= 8, _I_= 9, _J_=10, _K_=11, _L_=12, _M_=13,\n    _N_=14, _O_=15, _P_=16, _Q_=17, _R_=18, _S_=19, _T_=20, _U_=21, _V_=22, _W_=23, _X_=24, _Y_=25, _Z_=26,\n    _0_=27, _1_=28, _2_=29, _3_=30, _4_=31, _5_=32, _6_=33, _7_=34, _8_=35, _9_=36,\n    _SPACE_         =  0,\n    _CARET_         = 45,\n    _PLUS_          = 37,\n    _MINUS_         = 38,\n    _SLASH_         = 39,\n    _DOT_           = 40,\n    _COMMA_         = 41,\n    _SEMI_          = 42,\n    _EXCL_          = 43,\n    _LPAREN_        = 46,\n    _RPAREN_        = 47,\n    _LBRACKET_      = 49,\n    _RBRACKET_      = 50,\n    _HOURGLASS_     = 53,\n    _BALLOON_       = 54,\n    _RIGHT_ARROW_   = 55\n;\n\nconst ivec2 CHAR_SIZE\t\t\t\t\t\t= ivec2(8);\nint g_text_scale_shift\t\t\t\t\t\t= 0;\n\nivec2 raw_text_uv(vec2 fragCoord)\t\t\t{ return ivec2(floor(fragCoord)); }\nivec2 text_uv(vec2 fragCoord)\t\t\t\t{ return ivec2(floor(fragCoord)) >> g_text_scale_shift; }\nint text_width(int num_chars)\t\t\t\t{ return num_chars << 3; }\nint line_index(int pixels_y)\t\t\t\t{ return pixels_y >> 3; }\nint glyph_index(int pixels_x)\t\t\t\t{ return pixels_x >> 3; }\nint cluster_index(int pixels_x)\t\t\t\t{ return pixels_x >> 5; }\nint get_byte(int index, int packed)\t\t\t{ return int((uint(packed) >> (index<<3)) & 255u); }\n\nvoid init_text_scale()\n{\n\tg_text_scale_shift = int(max(floor(log2(iResolution.x)-log2(799.)), 0.));\n}\n\nvec2 align(int num_chars, vec2 point, vec2 alignment)\n{\n    return point + alignment*-vec2(num_chars<<(3+g_text_scale_shift), 8<<g_text_scale_shift);\n}\n\nvec4 glyph_color(uint glyph, ivec2 pixel)\n{\n    uint x = glyph & 7u,\n         y = glyph >> 3u;\n    pixel = ivec2(ADDR2_RANGE_FONT.xy) + (ivec2(x, y) << 3) + (pixel & 7);\n    return texelFetch(LIGHTMAP_CHANNEL, pixel, 0);\n}\n\nvoid print_glyph(inout vec4 fragColor, ivec2 pixel, int glyph, vec4 color)\n{\n    color *= glyph_color(uint(glyph), pixel);\n    fragColor.rgb = mix(fragColor.rgb, color.rgb, color.a);\n}\n\nconst int MAX_POW10_EXPONENT = 7;\n\nuint pow10(uint e)\n{\n    uint result = (e & 1u) != 0u ? 10u : 1u;\n    if ((e & 2u) != 0u) result *= 100u;\n    if ((e & 4u) != 0u) result *= 10000u;\n    return result;\n}\n\nint int_glyph(int number, int index)\n{\n    if (uint(index) >= uint(MAX_POW10_EXPONENT))\n        return _SPACE_;\n    if (number <= 0)\n        return index == 0 ? _0_ : _SPACE_;\n    uint power = pow10(uint(index));\n    return uint(number) >= power ? _0_ + int((uint(number)/power) % 10u) : _SPACE_;\n}\n\n// Perf overlay ////////////////////////////////////////////////\n\nvec3 fps_color(float fps)\n{\n    return\n        fps >= 250. ? vec3(.75, .75,  1.) :\n        fps >= 144. ? vec3( 1., .75,  1.) :\n        fps >= 120. ? vec3( 1.,  1.,  1.) :\n    \tfps >= 60.  ? vec3( .5,  1.,  .5) :\n    \tfps >= 30.  ? vec3( 1.,  1.,  0.) :\n    \t              vec3( 1.,  0.,  0.);\n}\n\nfloat shadow_box(vec2 fragCoord, vec4 box, float border)\n{\n    vec2 clamped = clamp(fragCoord, box.xy, box.xy + box.zw);\n    return clamp(1.25 - length(fragCoord-clamped)*(1./border), 0., 1.);\n}\n\nvoid draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box, float border)\n{\n    fragColor.rgb *= mix(1.-shadow_box(fragCoord, box, border), 1., .5);\n}\n\nconst float DEFAULT_SHADOW_BOX_BORDER = 8.;\n\nvoid draw_shadow_box(inout vec4 fragColor, vec2 fragCoord, vec4 box)\n{\n    draw_shadow_box(fragColor, fragCoord, box, DEFAULT_SHADOW_BOX_BORDER);\n}\n\nvoid draw_perf(inout vec4 fragColor, vec2 fragCoord)\n{\n    Options options;\n    LOAD(options);\n\n    if (uint(g_demo_stage - DEMO_STAGE_FPS) < 2u)\n        options.flags |= OPTION_FLAG_SHOW_FPS;\n    \n    if (!test_flag(options.flags, OPTION_FLAG_SHOW_FPS|OPTION_FLAG_SHOW_FPS_GRAPH))\n        return;\n\n    float margin = 16. * min(iResolution.x * (1./400.), 1.);\n    vec2 anchor = iResolution.xy  - margin;\n    \n    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS_GRAPH))\n    {\n        const vec2 SIZE = vec2(ADDR_RANGE_PERF_HISTORY.z, 32.);\n        vec4 box = vec4(anchor - SIZE, SIZE);\n        draw_shadow_box(fragColor, fragCoord, box);\n\n        if (is_inside(fragCoord, box) > 0.)\n        {\n            vec2 address = ADDR_RANGE_PERF_HISTORY.xy + vec2(ADDR_RANGE_PERF_HISTORY.z-(fragCoord.x-box.x),0.);\n            vec4 perf_sample = load(address);\n            if (perf_sample.x > 0.)\n            {\n                float sample_fps = 1000.0/perf_sample.x;\n                float fraction = sample_fps * (1./float(FPS_GRAPH_MAX));\n                //fraction = 1./sqr(perf_sample.y/MIN_DOWNSCALE);\n                if ((fragCoord.y-box.y) / box.w <= fraction)\n                    fragColor.rgb = fps_color(sample_fps);\n            }\n            return;\n        }\n        \n        anchor.y -= SIZE.y + DEFAULT_SHADOW_BOX_BORDER * 2.;\n    }\n\n    int fps = int(round(iFrameRate));\n    if (test_flag(options.flags, OPTION_FLAG_SHOW_FPS) && uint(fps - 1) < 9999u)\n    {\n        const int FPS_TEXT_LENGTH = 8; // 1234 FPS\n        const int FPS_SUFFIX_GLYPHS = (_SPACE_<<24) | (_F_<<16) | (_P_<<8) | (_S_<<0);\n    \n    \tvec2 text_pos = anchor - vec2((CHAR_SIZE << g_text_scale_shift) * ivec2(FPS_TEXT_LENGTH,1));\n    \n        ivec2 uv = text_uv(fragCoord - text_pos);\n        if (line_index(uv.y) == 0)\n        {\n            int glyph = FPS_TEXT_LENGTH - 1 - glyph_index(uv.x);\n            if (uint(glyph) < 4u)\n                glyph = get_byte(glyph, FPS_SUFFIX_GLYPHS);\n            else if (uint(glyph) < uint(FPS_TEXT_LENGTH))\n                glyph = int_glyph(fps, glyph-4);\n            else\n                glyph = _SPACE_;\n\n\t\t\tif (glyph != _SPACE_)\n            {\n                vec4 color = vec4(vec3(.875), 1.);\n                print_glyph(fragColor, uv, glyph, color);\n            }\n        }\n    }\n}\n\n// Console state ///////////////////////////////////////////////\n\nstruct Console\n{\n    float loaded;\n    float expanded;\n    float typing;\n};\n    \nConsole g_console;\n\nvoid update_console()\n{\n    const float\n        T0 = 0.,\n    \tT1 = T0 + CONSOLE_XFADE_DURATION,\n    \tT2 = T1 + CONSOLE_SLIDE_DURATION,\n    \tT3 = T2 + CONSOLE_TYPE_DURATION,\n    \tT4 = T3 + CONSOLE_SLIDE_DURATION;\n    \n    // snap console position to multiples of 2 pixels to avoid shimmering\n    // due to the use of noise and dFd* functions\n    float ysnap = iResolution.y * .5;\n    \n    g_console.loaded = linear_step(T0, T1, g_time);\n    g_console.expanded = 1.+-.5*(linear_step(T1, T2, g_time) + linear_step(T3, T4, g_time));\n    g_console.expanded = floor(g_console.expanded * ysnap + .5) / ysnap;\n    g_console.typing = linear_step(0., CONSOLE_TYPE_DURATION, g_time - T2);\n}\n\n// Console text ////////////////////////////////////////////////\n\nWRAP(GCONSOLE_TEXT,CONSOLE_TEXT,int,145)(33,0,9,16,16,28,28,29,29,60,60,60,80,98,117,133,151,179,179,203,203,204,204,230\n,250,269,289,289,305,328,355,373,398,423,439,0xc030f0e,0xf001009,0xf0e320e,269028355,303304201,51708943,0xe0f0914,\n302323238,0xe0f0913,455613440,85131297,302323218,522006016,2302498,788730371,50665477,462345,0xf141501,50665477,\n0x7060328,50665477,462345,0x60e0f03,52954889,402982662,0xe090305,84148231,0xc150106,0x6032814,85460231,0x70e0903,\n18157824,304612619,420416003,50926611,0xf0e000b,0xf060014,0x9040e15,85078030,0xf0a0401,0x9141319,2755331,301993742,\n0xf101305,470094606,336921126,921364,320147213,369164293,17565953,637864962,0xe150f13,18022404,0x90c100d,301991694,\n704975873,454827008,85336093,0xf091312,2031630,318767635,336724244,320147477,462345,68868,0xe010803,787726,353309470,\n0x900040e,0x914090e,436800513,0xf091401,403968526,336530944,335873024,85197573,1970948,0xf030e09,302977042,67441665,\n303300648,522260233,18023702,455613696,0xd0f0300,17370128,16782350,336593156,472519173,2369566,17237261,85203202,\n17106944,85460240,488308778,707010602,318775067,503320581,605814811,85139748,0xc010912,0x9120400,1180950,336137737,\n0x90c0109,0x904051a,0xe001810,67113999,50664453,263444));\n\nvec2 closest_point_on_segment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return ab*t + a;\n}\n\nvec2 lit_line(vec2 uv, vec2 a, vec2 b, float thickness)\n{\n    const vec2 LIGHT_DIR = vec2(0, 1);\n    uv -= closest_point_on_segment(uv, a, b);\n    float len = length(uv);\n    return vec2(len > 0. ? dot(uv/len, LIGHT_DIR) : 1., len + -.5*thickness);\n}\n\nvoid print_console_version(inout vec4 fragColor, vec2 uv, vec2 mins, vec2 size)\n{\n    size.y *= .25;\n    mins.y -= size.y * 1.75;\n    \n    if (is_inside(uv, vec4(mins, size)) < 0.)\n        return;\n    uv -= mins;\n    uv *= 1./size;\n    \n    ivec2 iuv = ivec2(vec2(CHAR_SIZE) * vec2(4, 1) * uv);\n    \n    int glyph = glyph_index(iuv.x);\n    if (uint(glyph) >= 4u)\n        return;\n    \n    const int GLYPHS = (_1_) | (_DOT_<<8) | (_0_<<16) | (_6_<<24);\n    const vec4 color = vec4(.62, .30, .19, 1);\n    \n    fragColor.rgb *= .625;\n    glyph = get_byte(glyph, GLYPHS);\n    print_glyph(fragColor, iuv, glyph, color);\n}\n\nvoid print_console_text(inout vec4 fragColor, vec2 fragCoord)\n{\n    float MARGIN = 12. * iResolution.x/800.;\n    const vec4 COLORS[2] = vec4[2](vec4(vec3(.54), 1), vec4(.62, .30, .19, 1));\n    const uint COLORED = (1u<<3) | (1u<<7);\n    const int TYPING_LINE = 1;\n    \n    fragCoord.y -= iResolution.y * (1. - g_console.expanded);\n    ivec2 uv = text_uv(fragCoord - MARGIN);\n    bool typing = g_console.typing < 1.;\n    int cut = int(mix(float(CONSOLE_TEXT.data[0]-1), 2., g_console.loaded));\n    if (g_console.typing > 0.)\n        --cut;\n    \n    int line = line_index(uv.y);\n    if (uint(line) >= uint(CONSOLE_TEXT.data[0]-cut))\n        return;\n    line += cut;\n    int start = CONSOLE_TEXT.data[1+line];\n    int num_chars = CONSOLE_TEXT.data[2+line] - start;\n    \n    if (num_chars == 1)\n    {\n        const vec3 LINE_COLOR = vec3(.17, .13, .06);\n        float LINE_END = min(iResolution.x - MARGIN*2., 300.);\n        vec2 line = lit_line(vec2(uv.x, uv.y & 7) + .5, vec2(4. ,4.), vec2(LINE_END-4., 4.), 4.);\n        line.x = mix(1. + .5 * line.x, 1., linear_step(-.5, -1.5, line.y));\n        line.x *= 1. + -.25*random(vec2(uv));\n\t\tfragColor.rgb = mix(fragColor.rgb, LINE_COLOR * line.x, step(line.y, 0.));\n        return;\n    }\n    \n    int glyph = glyph_index(uv.x);\n    if (line == TYPING_LINE)\n    {\n        float type_fraction = clamp(2. - abs(g_console.typing * 4. + -2.), 0., 1.);\n        num_chars = clamp(int(float(num_chars-1)*type_fraction) + int(typing), 0, num_chars + int(typing));\n    }\n    if (uint(glyph) >= uint(num_chars))\n        return;\n\n    if (typing && line == TYPING_LINE && glyph == num_chars - 1)\n    {\n        glyph = fract(iTime*2.) < .5 ? _CARET_ : _SPACE_;\n    }\n    else\n    {\n        glyph += start;\n        glyph = get_byte(glyph & 3, CONSOLE_TEXT.data[CONSOLE_TEXT.data[0] + 2 + (glyph>>2)]);\n    }\n    \n    uint is_colored = line < 32 ? ((COLORED >> line) & 1u) : 0u;\n    vec4 color = COLORS[is_colored];\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n// Menu ////////////////////////////////////////////////////////\n\nWRAP(GOPTIONS,OPTIONS,int,53)(13,0,11,23,33,44,58,72,86,97,109,119,132,143,149,320147213,269680645,0x9040505,302323214,0xf0d0014\n,33886997,0x8070912,319098388,302191379,918789,85592339,386861075,17958400,17958157,0x8130514,0x600170f,0x7001310,0x8100112,\n337118484,332309,336333062,0xf0d1205,0xe0f0914,353108480,0x7090c12,318772232,335937800,336724755,0x6060500,320078597,1511176,\n0x807090c,268504340,386861075,17110784,0xe0e0f10,0x90c030f,16));\n\nvoid draw_menu(inout vec4 fragColor, vec2 fragCoord, Timing timing)\n{\n    MenuState menu;\n    LOAD(menu);\n\n    if (menu.open <= 0)\n        return;\n\n    vec4 options = load(ADDR_OPTIONS);\n\n    if (!test_flag(int(options[get_option_field(OPTION_DEF_SHOW_LIGHTMAP)]), OPTION_FLAG_SHOW_LIGHTMAP))\n    {\n        // vanilla\n        fragColor.rgb *= vec3(.57, .47, .23);\n        fragColor.rgb = ceil(fragColor.rgb * 24. + .01) / 24.;\n    }\n    else\n    {\n        // GLQuake\n       \tfragColor.rgb *= .2;\n    }\n\n    //g_text_scale_shift = 1;\n    int text_scale = 1 << g_text_scale_shift;\n    float image_scale = float(text_scale);\n    vec2 header_size = ADDR2_RANGE_TEX_OPTIONS.zw * image_scale;\n    vec2 left_image_size = ADDR2_RANGE_TEX_QUAKE.wz * image_scale;\n    float left_image_offset = 120. * image_scale;\n\n    vec2 ref = iResolution.xy * vec2(.5, 1.);\n    ref.y -= min(float(CHAR_SIZE.y) * 4. * image_scale, iResolution.y / 16.);\n\n    ref.x += left_image_size.x * .5;\n    if (fragCoord.x < ref.x - left_image_offset)\n    {\n        fragCoord.y -= ref.y - left_image_size.y;\n        fragCoord.x -= ref.x - left_image_offset - left_image_size.x;\n        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;\n        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_QUAKE.w) && uint(addr.y) < uint(ADDR2_RANGE_TEX_QUAKE.z))\n\t        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr.yx + ivec2(ADDR2_RANGE_TEX_QUAKE.xy), 0).rgb;\n        return;\n    }\n\n    ref.y -= header_size.y;\n    if (fragCoord.y >= ref.y)\n    {\n        fragCoord.y -= ref.y;\n        fragCoord.x -= ref.x - header_size.x * .5;\n        ivec2 addr = ivec2(floor(fragCoord)) >> g_text_scale_shift;\n        if (uint(addr.x) < uint(ADDR2_RANGE_TEX_OPTIONS.z) && uint(addr.y) < uint(ADDR2_RANGE_TEX_OPTIONS.w))\n\t        fragColor.rgb = texelFetch(LIGHTMAP_CHANNEL, addr + ivec2(ADDR2_RANGE_TEX_OPTIONS.xy), 0).rgb;\n        return;\n    }\n\n    ref.y -= float(CHAR_SIZE.y) * 1. * image_scale;\n\n    const int\n        BASE_OFFSET\t\t= CHAR_SIZE.x * 0,\n        ARROW_OFFSET\t= CHAR_SIZE.x,\n        VALUE_OFFSET\t= CHAR_SIZE.x * 3,\n        MARGIN\t\t\t= 0,\n        LINE_HEIGHT\t\t= MARGIN + CHAR_SIZE.y;\n\n    ivec2 uv = text_uv(fragCoord - ref);\n    uv.x -= BASE_OFFSET;\n    int line = -uv.y / LINE_HEIGHT;\n    if (uint(line) >= uint(NUM_OPTIONS))\n        return;\n    \n    uv.y = uv.y + (line + 1) * LINE_HEIGHT;\n    if (uint(uv.y - MARGIN) >= uint(CHAR_SIZE.y))\n        return;\n    uv.y -= MARGIN;\n    \n    int glyph = 0;\n    if (uv.x < 0)\n    {\n        int begin = OPTIONS.data[1 + line];\n        int end = OPTIONS.data[2 + line];\n        int num_chars = end - begin;\n        uv.x += num_chars * CHAR_SIZE.x;\n    \tglyph = glyph_index(uv.x);\n        if (uint(glyph) >= uint(num_chars))\n            return;\n        glyph += begin;\n        glyph = get_byte(glyph & 3, OPTIONS.data[OPTIONS.data[0] + 2 + (glyph>>2)]);\n    }\n    else if (uint(uv.x - ARROW_OFFSET) < uint(CHAR_SIZE.x))\n    {\n        const float BLINK_SPEED = 2.;\n        uv.x -= ARROW_OFFSET;\n        if (menu.selected == line && (fract(iTime * BLINK_SPEED) < .5 || test_flag(timing.flags, TIMING_FLAG_PAUSED)))\n            glyph = _RIGHT_ARROW_;\n    }\n    else if (uv.x >= VALUE_OFFSET)\n    {\n        uv.x -= VALUE_OFFSET;\n\n        int item_height = CHAR_SIZE.y << g_text_scale_shift;\n\n        MenuOption option = get_option(line);\n        int option_type = get_option_type(option);\n        int option_field = get_option_field(option);\n        if (option_type == OPTION_TYPE_SLIDER)\n        {\n            const float RAIL_HEIGHT = 7.;\n            vec2 p = vec2(uv.x, uv.y & 7) + .5;\n            vec2 line = lit_line(p, vec2(8, 4), vec2(8 + 11*CHAR_SIZE.x, 4), RAIL_HEIGHT);\n            float alpha = linear_step(-.5, .5, -line.y);\n            line.y /= RAIL_HEIGHT;\n            float intensity = 1. + line.x * step(-.25, line.y);\n            intensity = mix(intensity, 1. - line.x * .5, line.y < -.375);\n            fragColor.rgb = mix(fragColor.rgb, vec3(.25, .23, .19) * intensity, alpha);\n\n            float value = options[option_field] * .1;\n            float thumb_pos = 8. + value * float(CHAR_SIZE.x * 10);\n            p.x -= thumb_pos;\n            p -= vec2(4);\n            float r = length(p);\n            alpha = linear_step(.5, -.5, r - 4.);\n            intensity = normalize(p).y * .25 + .75;\n            p *= vec2(3., 1.5);\n            r = length(p);\n            intensity += linear_step(.5, -.5, r - 4.) * (safe_normalize(p).y * .125 + .875);\n\n            fragColor.rgb = mix(fragColor.rgb, vec3(.36, .25, .16) * intensity, alpha);\n            return;\n        }\n        else if (option_type == OPTION_TYPE_TOGGLE)\n        {\n            glyph = glyph_index(uv.x);\n            if (uint(glyph) >= 4u)\n                return;\n    \t\tconst int\n                OFF = (_O_<<8) | (_F_<<16) | (_F_<<24),\n    \t\t\tON  = (_O_<<8) | (_N_<<16);\n            int value = test_flag(int(options[option_field]), get_option_range(option)) ? ON : OFF;\n            glyph = get_byte(glyph & 3, value);\n        }\n    }\n    else\n    {\n        return;\n    }\n    \n    vec4 color = vec4(.66, .36, .25, 1);\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n// Loading screen/console //////////////////////////////////////\n\nvec3 loading_spinner(vec2 fragCoord)\n{\n    float radius = max(32./1920. * iResolution.x, 8.);\n    float margin = max(96./1920. * iResolution.x, 12.);\n    vec2 center = iResolution.xy - vec2(margin + radius);\n    float angle = atan(fragCoord.y-center.y, fragCoord.x-center.x) / (PI*2.);\n    float dist = length(fragCoord - center)/radius;\n    angle += smoothen(fract(iTime*SQRT2));\n    angle = fract(-angle);\n\n    const float MAX_ANGLE = .98;\n    const float MIN_ANGLE = .12;\n    float angle_alpha = angle < MAX_ANGLE ? max((angle-MIN_ANGLE)/(MAX_ANGLE-MIN_ANGLE), 0.) :\n    \t1.-(angle-MAX_ANGLE)/(1.-MAX_ANGLE);\n    float radius_alpha = around(.85, mix(.09, .1, angle_alpha), dist);\n\n    vec3 color = sqr(1.-clamp(dist*.375, 0., 1.)) * vec3(.25,.125,0.);\n    color += sqrt(radius_alpha) * angle_alpha;\n    \n    return color;\n}\n\nvec3 burn_xfade(vec3 from, vec3 to, float noise_mask, float fraction)\n{\n    const float HEADROOM = .7;\n    fraction = mix(-HEADROOM, 1.+HEADROOM, fraction);\n    float burn_mask = linear_step(fraction-HEADROOM, fraction, noise_mask);\n    from *= burn_mask;\n    to = mix(from, to, linear_step(fraction, fraction-HEADROOM, noise_mask));\n    \n    const bool GARISH_FLAMES = false;\n    if (GARISH_FLAMES)\n    {\n        to *= 1. - around(.5, .49, burn_mask);\n        to += vec3(1.,.3,.2) * around(.80, .19, burn_mask);\n        to += vec3(1.,.5,.3) * around(.84, .15, burn_mask) * .25;\n        to += vec3(1.,1.,.4) * around(.94, .05, burn_mask);\n    }\n\n    return to;\n}\n\nfloat sdf_apply_light(float sdf, vec2 dir)\n{\n    vec2 grad = normalize(vec2(dFdx(sdf), dFdy(sdf)));\n    return dot(dir, grad);\n}\n\nfloat sdf_shadow(float sdf, float size, vec2 light_dir)\n{\n    vec2 n = sdf_normal(sdf);\n    float thresh = size * max(abs(dFdx(sdf)), abs(dFdy(sdf)));\n    float mask = clamp(sdf/thresh, 0., 1.);\n    return clamp(1. - sdf/size, 0., 1.) * clamp(-dot(light_dir, n), 0., 1.) * mask;\n}\n\nfloat sdf_modern_nail(vec2 uv, vec2 top, vec2 size)\n{\n    const float head_flat_frac = .025;\n    const float head_round_frac = .05;\n    const float body_thickness = .5;\n\n    float h = clamp((top.y - uv.y) / size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_modern_Q(vec2 uv, float age)\n{\n    float aspect_ratio = iResolution.x/iResolution.y;\n    float noise = turb(uv * vec2(31.7,27.9)/aspect_ratio, .7, 1.83);\n    float dist = sdf_disk(uv, vec2(.5, .68), .315);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .727), .267));\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, 1.1), .21));\n    dist = sdf_union(dist, sdf_modern_nail(uv, vec2(.5, .59), vec2(.08, .52)));\n    return dist + (noise * .01 - .005) * sqr(age);\n}\n\nvec2 embossed_modern_Q(vec2 uv, float age, float bevel, vec2 light_dir)\n{\n    float px = 2./iResolution.y, EPS = .1 * px;\n    vec3 sdf;\n    for (int i=0; i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_modern_Q(uv2, age);\n    }\n    vec2 gradient = normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, px);\n    bevel = clamp(1. + sdf.z/bevel, 0., 1.);\n    return vec2(mask * (.5 + sqrt(bevel) * dot(gradient, light_dir)), mask);\n}\n\nvoid print_console_logo(inout vec4 fragColor, vec2 uv, vec2 mins, vec2 size, float noise)\n{\n    float inside = is_inside(uv, vec4(mins, size));\n    float fade = noise * -.01;\n    if (inside < fade)\n        return;\n    vec3 background = mix(vec3(.09, .05, 0), vec3(.38, .17, .11), sqr(smoothen(noise)));\n    fragColor.rgb = mix(fragColor.rgb, background, sqr(linear_step(fade, .001, inside)));\n    const float QUANTIZE = 32.;\n    uv = (uv - mins) / size;\n    uv = round(uv * QUANTIZE) * (1./QUANTIZE);\n    float logo = (sdf_id(uv) + noise*.015) * QUANTIZE;\n    float mask = clamp(2.-logo, 0., 1.) * linear_step(1., .25, noise);\n    fragColor.rgb = mix(fragColor.rgb, vec3(0), mask * .5);\n    mask = clamp(1.-logo, 0., 1.) * linear_step(1., .25, noise);\n    fragColor.rgb = mix(fragColor.rgb, vec3(.43, .22, .14), mask);\n}\n\nfloat sparks(vec2 uv, vec2 size)\n{\n    vec2 cell = floor(uv) + .5;\n    vec2 variation = hash2(cell);\n    cell += (variation-.5) * .9;\n    return sqr(variation.x) * clamp(1.-length((cell - uv)*(1./size)), 0., 1.);\n}\n\nvoid draw_console(inout vec4 fragColor, vec2 fragCoord, Lighting lighting)\n{\n    fragColor.rgb *= linear_step(1., .5, g_console.expanded);\n\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tif (uv.y < 1. - g_console.expanded)\n        return;\n    \n    float loaded = lighting.progress;\n    float xfade = clamp(g_time / CONSOLE_XFADE_DURATION, 0., 1.);\n    \n    uv.y -= 1. - g_console.expanded;\n    float vignette = 1. - clamp(length(uv - .5)*2., 0., 1.);\n  \n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = (uv.x - 0.5) * aspect_ratio + 0.5;\n\n    float base = turb(uv * vec2(31.7,27.9)/aspect_ratio, .7, 2.5);\n    \n    // loading screen (modern style) //\n    \n    vec3 modern = vec3(linear_step(.45, .7, base) * 0.1);\n    if (xfade < 1.)\n    {\n        modern *= sqr(vignette);\n\n        const float MODERN_LOGO_SCALE = .75;\n\n        vec2 logo_uv = (uv - .5) * (1./MODERN_LOGO_SCALE) + .5;\n        vec4 modern_logo = embossed_modern_Q(logo_uv, loaded, .006, vec2(.7, .3)).xxxy;\n\n        float flame_flicker = mix(.875, 1., smooth_noise(2.+iTime*7.3));\n        float scratches = linear_step(.35, .6, turb(vec2(480.,8.)*rotate(uv, 22.5), .5, 2.) * base);\n        scratches += linear_step(.25, .9, turb(vec2(480.,16.)*rotate(uv, -22.5), .5, 2.) * base);\n\n        modern_logo.rgb *= vec3(.32,.24,.24);\n        modern_logo.rgb *= smoothstep(.75, .0, abs(uv.x-.5));\n        modern_logo.rgb *= 1.8 - 0.8 * linear_step(.55, mix(.15, .35, loaded), base);\n        modern_logo.rgb *= 1. - scratches * .4;\n        modern_logo.rgb *= 1. + 4. * sqr(clamp(1. - length(uv - vec2(.76, .37))*2.3, 0., 1.));\n        modern_logo.rgb *= 1. + flame_flicker*2.5*vec3(1.,0.,0.) * sqr(clamp(1. - length(uv - vec2(.20, .40))*3., 0., 1.));\n\n        modern = mix(modern, modern_logo.rgb, modern_logo.a);\n\n        float flame_vignette = length((uv - vec2(.5,0.))*vec2(.5, 1.3));\n        float flame_intensity = flame_vignette;\n        flame_intensity = sqr(sqr(clamp(1.-flame_intensity, 0., 1.)) * flame_flicker);\n        flame_intensity *=\n            turb(uv * vec2(41.3,13.6)/aspect_ratio + vec2(0.,-iTime), .5, 2.5) +\n            turb(uv * vec2(11.3,7.6)/aspect_ratio + vec2(0.,-iTime*.9), .5, 2.5);\n        modern += vec3(.25,.125,0.) * flame_intensity;\n\n        vec2 spark_uv = vec2(uv + vec2(turb(uv*1.3, .5, 2.)*.6, -iTime*.53));\n        float spark_intensity =\n            sparks(vec2(11.51, 3.13) * spark_uv,\t\t\t\tvec2(.06,.05)) * 2. +\n            sparks(vec2(4.19, 1.37) * spark_uv + vec2(1.3,3.7),\tvec2(.06,.05)) * 1.;\n        spark_intensity *= flame_intensity;\n\n        spark_uv = vec2(uv*.73 + vec2(turb(uv*1.25, .7, 1.9)*.4, -iTime*.31));\n        float spark_intensity2 = turb(vec2(25.1, 11.5) * spark_uv, .5, 2.);\n        spark_intensity2 = 0.*linear_step(.43, .95, spark_intensity2) * flame_intensity*.2;\n        modern += vec3(1.,1.,.3) * (spark_intensity + spark_intensity2);\n\n        modern += loading_spinner(fragCoord);\n    }\n    \n    // console (classic style) //\n\n    const float CLASSIC_LOGO_SCALE = 1.1;\n    const vec2 CLASSIC_LOGO_CENTER = vec2(.5, .45);\n    const vec2 CLASSIC_LIGHT_DIR = vec2(0, 1.5);\n    float classic_shadow_size = mix(.01, .05, base);\n    vec2 CLASSIC_SHADOW_OFFSET = CLASSIC_LIGHT_DIR * classic_shadow_size;\n    float classic_logo_distortion = base * .015 - .01;\n    float classic_logo = sdf_Q((uv-CLASSIC_LOGO_CENTER) / CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;\n    \n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.);\n    vec2 box_size = vec2(.5) * aspect - mix(.005, .03, sqr(base));\n    float classic_console_box = sdf_centered_box(uv, vec2(.5), box_size);\n    \n    const vec2 CLASSIC_ID_LOGO_MARGIN = vec2(24./450., 48./450.);\n    const float CLASSIC_ID_LOGO_SIZE = 64./450.;\n    const float CLASSIC_ID_LOGO_BOX_JAGGEDNESS = 0.; //0.02;\n    \n    vec2 logo_mins = vec2((.5+.5*aspect.x)-CLASSIC_ID_LOGO_MARGIN.x-CLASSIC_ID_LOGO_SIZE, CLASSIC_ID_LOGO_MARGIN.y);\n    \n    classic_console_box = sdf_exclude(classic_console_box,\n                                      4.*sdf_box(uv, logo_mins, logo_mins + CLASSIC_ID_LOGO_SIZE) +\n                                      (base*2.-1.) * CLASSIC_ID_LOGO_BOX_JAGGEDNESS);\n   \n    float noise2 = turb(uv*43.7, .5, 2.0)-.15;\n    classic_console_box = sdf_exclude(classic_console_box, noise2*.1);\n    \n    float bevel_size = mix(.001, .07, sqr(base));\n    float classic_sdf = sdf_exclude(classic_console_box, classic_logo+.01);\n    float classic_base = sdf_emboss(classic_sdf, bevel_size, CLASSIC_LIGHT_DIR).x;\n\n#if 1\n    // slightly odd, gradient-based automatic shadow\n    float classic_shadow = sdf_shadow(classic_sdf, classic_shadow_size, CLASSIC_LIGHT_DIR);\n#else\n    // smooth version with secondary SDF sample\n    // only sampling the Q logo SDF, not the composite one!\n    float classic_shadow_sample = sdf_Q((uv+CLASSIC_SHADOW_OFFSET-CLASSIC_LOGO_CENTER) / CLASSIC_LOGO_SCALE + .5) + classic_logo_distortion;\n    float classic_shadow = sdf_mask(classic_logo) * clamp(classic_shadow_sample/classic_shadow_size+.3, 0., 1.);\n#endif\n\n    vec4 classic = vec4(mix(vec3(.07,.03,.02)*(1.+base*2.)*(1.-classic_shadow), vec3(.24,.12,.06), classic_base), 1.);\n    classic.rgb *= 1. - .05*linear_step(.35, .3, base);\n    classic.rgb *= 1. + .05*linear_step(.6, .65, base);\n    \n    print_console_logo(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE), base);\n\tprint_console_version(classic, uv, logo_mins, vec2(CLASSIC_ID_LOGO_SIZE));\n    print_console_text(classic, fragCoord);\n    \n    classic.rgb = floor(classic.rgb * 64. + random(floor(uv*128.))) * (1./64.);\n\n\tfloat burn_fraction = xfade * (2.-clamp(length(uv-vec2(.5,0.)), 0., 1.));\n    fragColor.rgb = burn_xfade(modern, classic.rgb, base, burn_fraction);\n}\n\n// Skill selection message /////////////////////////////////////\n\nWRAP(GSKILL_MESSAGES,SKILL_MESSAGES,int,27)(3,0,28,58,86,319358996,0xc010800,85131276,335742220,17104915,318773523,\n0xc0c090b,319358996,0xc010800,85131276,335742220,0xf0e0013,0xc010d12,0x90b1300,0x8140c0c,0x8001309,789505,84673811,\n1250307,68288776,0x90b1300,3084));\n\nvoid print_skill_message(inout vec4 fragColor, in vec2 fragCoord, vec3 cam_pos)\n{\n#if PRINT_SKILL_MESSAGE\n    float time = fract(iTime*.5);\n    if (time > .9375)\n        return;\n\n    MenuState menu;\n    LOAD_PREV(menu);\n    if (menu.open > 0)\n        return;\n    \n    ivec2 uv = text_uv(fragCoord - iResolution.xy*vec2(.5,.64));\n    if (line_index(uv.y) != 0)\n        return;\n    \n\tvec4 cam_angles = load(ADDR_CAM_ANGLES);\n    if (min(cam_angles.x, 360.-cam_angles.x) >= 90.)\n        return;\n\n    const vec3 PLAYER_DIMS = vec3(16., 16., 48.);\n    const vec3 SKILL_TRIGGER_BOUNDS[] = vec3[](\n        vec3(112,832,-32),vec3(336,1216,16),\n        vec3(448,832,-8),vec3(656,1232,40),\n        vec3(752,800,-24),vec3(976,1248,24)\n\t);\n    \n    int line = -1;\n    int num_skills = NO_UNROLL(3);\n    for (int i=0; i<num_skills; ++i)\n    {\n        int i2 = i + i;\n        vec3 mins = SKILL_TRIGGER_BOUNDS[i2];\n        vec3 maxs = SKILL_TRIGGER_BOUNDS[i2+1];\n        vec3 delta = clamp(cam_pos.xyz, mins, maxs) - cam_pos.xyz;\n        if (max_component(abs(delta) - PLAYER_DIMS) <= 0.)\n            line = i;\n    }\n    \n    if (line == -1)\n        return;\n\n    int start = SKILL_MESSAGES.data[1+line];\n    int num_chars = SKILL_MESSAGES.data[2+line] - start;\n    uv.x += text_width(num_chars) >> 1;\n    \n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return;\n    \n    glyph += start;\n    glyph = get_byte(glyph & 3, SKILL_MESSAGES.data[SKILL_MESSAGES.data[0] + 2 + (glyph>>2)]);\n\n    vec4 color = vec4(vec3(.6), 1);\n    print_glyph(fragColor, uv, glyph, color);\n#endif // PRINT_SKILL_MESSAGE\n}\n\n// Level start countdown ///////////////////////////////////////\n\nWRAP(GGAME_OVER,GAME_OVER,int,4)(9,84738311,85331712,18));\n\nbool print_countdown(inout vec4 fragColor, vec2 fragCoord)\n{\n    GameState game_state;\n    MenuState menu;\n    LOAD(game_state);\n    LOAD(menu);\n    if (game_state.level <= 0. && game_state.level == floor(game_state.level) || menu.open > 0)\n        return false;\n    \n    float remaining = fract(abs(game_state.level)) * 10.;\n    if (remaining <= 0. || remaining >= BALLOON_SCALEIN_TIME + LEVEL_COUNTDOWN_TIME)\n        return true;\n    \n    ivec2 uv = text_uv(fragCoord - iResolution.xy*vec2(.5,.66)) >> 1;\n    if (line_index(uv.y) != 0)\n        return true;\n    \n    bool go = remaining < BALLOON_SCALEIN_TIME;\n    \n    int num_chars = (game_state.level < 0.) ? GAME_OVER.data[0] : go ? 4 : 1;\n    \n    uv.x += (num_chars * CHAR_SIZE.x) >> 1;\n\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return true;\n    \n    const int GO_MESSAGE = (_SPACE_<<0) | (_G_<<8) | (_O_<<16) | (_SPACE_<<24);\n    \n    if (game_state.level < 0.)\n    \tglyph = get_byte(glyph & 3, GAME_OVER.data[1 + (glyph>>2)]);\n    else if (go)\n        glyph = (GO_MESSAGE >> (glyph<<3)) & 255;\n    else\n    \tglyph = _0_ + int(ceil(remaining - BALLOON_SCALEIN_TIME));\n    \n    vec4 color = vec4(vec3(.875), 1.);\n    if (fract(remaining - BALLOON_SCALEIN_TIME) > .875)\n        color.rgb = vec3(.60, .30, .23);\n    print_glyph(fragColor, uv, glyph, color);\n    \n    return true;\n}\n\n// Pain blend, skill message ///////////////////////////////////\n\nvoid add_effects(inout vec4 fragColor, vec2 fragCoord, bool is_thumbnail)\n{\n    if (is_demo_mode_enabled(is_thumbnail))\n        return;\n\n    vec4 cam_pos = load(ADDR_CAM_POS);\n    vec3 fireball = get_fireball_offset(g_animTime) + FIREBALL_ORIGIN;\n    float pain = linear_step(80., 16., length(cam_pos.xyz - fireball));\n    vec3 lava_delta = abs(cam_pos.xyz - clamp(cam_pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1]));\n    float lava_dist = max3(lava_delta.x, lava_delta.y, lava_delta.z);\n    if (lava_dist <= 32.)\n        pain = mix(.5, .75, clamp(fract(g_animTime*4.)*2.+-1., 0., 1.));\n    if (lava_dist <= 0.)\n        pain += .45;\n   \tfragColor.rgb = mix(fragColor.rgb, vec3(1., .125, .0), sqr(clamp(pain, 0., 1.)) * .75);\n    \n    if (!print_countdown(fragColor, fragCoord))\n    \tprint_skill_message(fragColor, fragCoord, cam_pos.xyz);\n}\n\n// Demo stage descriptions /////////////////////////////////////\n\nWRAP(GDEMO_STAGES,DEMO_STAGES,int,24)(6,0,12,19,29,37,45,64,1638674,336791812,84086273,0xd120f0e,353569793,17638934,\n0xe091010,402985991,85071124,0x7090c13,0xe091408,402985991,85071124,2424851,0x807090c,0x70e0914));\n\nvoid describe_demo_stage(inout vec4 fragColor, vec2 fragCoord)\n{\n    int line = -1;\n    switch (g_demo_stage)\n    {\n        case DEMO_STAGE_DEPTH:\t\tline = 0; break;\n        case DEMO_STAGE_NORMALS:\tline = 1; break; \n        case DEMO_STAGE_UV:\t\t\tline = 2; break; \n        case DEMO_STAGE_TEXTURES:\tline = 3; break;\n        case DEMO_STAGE_LIGHTING:\tline = 4; break;\n        case DEMO_STAGE_COMPOSITE:\tline = 5; break;\n        default:\t\t\t\t\treturn;\n    }\n\n    int start = DEMO_STAGES.data[1+line];\n    int num_chars = DEMO_STAGES.data[2+line] - start;\n\n    vec2 margin = iResolution.xy * 16./450.;\n    vec2 ref = vec2(iResolution.x - margin.x, margin.y);\n    vec2 pos = align(num_chars, ref, vec2(1, 0));\n\n    vec4 box = vec4(pos, (ivec2(num_chars, 1) * CHAR_SIZE) << g_text_scale_shift);\n    float radius = 16. * exp2(float(g_text_scale_shift));\n    box += radius * (.25 * vec4(1, 1, -2, -2));\n    float intensity = (g_demo_stage == DEMO_STAGE_LIGHTING) ? .5 : .625;\n    fragColor.rgb *= mix(1., intensity, sqr(shadow_box(fragCoord, box, radius)));\n\n    ivec2 uv = text_uv(fragCoord - pos);\n    if (line_index(uv.y) != 0)\n        return;\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) >= uint(num_chars))\n        return;\n\n    glyph += start;\n    glyph = get_byte(glyph & 3, DEMO_STAGES.data[DEMO_STAGES.data[0] + 2 + (glyph>>2)]);\n\n    vec4 color = vec4(1);\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n////////////////////////////////////////////////////////////////\n\nWRAP(GGAME_HUD_STATS,GAME_HUD_STATS,int,12)(3,0,9,18,27,85329164,12,302060544,320079111,581<<18,1293,0));\n\nvoid draw_game_info(inout vec4 fragColor, vec2 fragCoord)\n{\n    GameState game_state;\n    LOAD(game_state);\n    if (game_state.level == 0.)\n        return;\n\n    const int NUM_LINES = GAME_HUD_STATS.data[0];\n    const int PREFIX_LENGTH = GAME_HUD_STATS.data[2] - GAME_HUD_STATS.data[1];\n    const int NUM_DIGITS = 4;\n    const int LINE_LENGTH = PREFIX_LENGTH + NUM_DIGITS;\n    \n    const float MARGIN = 16.;\n    vec2 anchor = vec2(MARGIN, iResolution.y - MARGIN - float((CHAR_SIZE*NUM_LINES) << g_text_scale_shift));\n    \n    ivec2 uv = text_uv(fragCoord - anchor);\n    int line = NUM_LINES - 1 - line_index(uv.y);\n    \n    // ignore last 2 lines (time/targets left) if game is over\n    int actual_num_lines = NUM_LINES - (int(game_state.level < 0.) << 1);\n    \n    vec4 box = vec4(MARGIN, iResolution.y-MARGIN, ivec2(LINE_LENGTH, (actual_num_lines<<1)-1)<<g_text_scale_shift);\n    box.zw *= vec2(CHAR_SIZE);\n    box.y -= box.w;\n    draw_shadow_box(fragColor, fragCoord, box);\n    \n    // line spacing\n    if ((line & 1) != 0)\n        return;\n    line >>= 1;\n    \n    if (uint(line) >= uint(actual_num_lines))\n        return;\n       \n    int start = GAME_HUD_STATS.data[1+line];\n    int num_chars = GAME_HUD_STATS.data[2+line] - start;\n    int glyph = glyph_index(uv.x);\n    if (uint(glyph) < uint(num_chars))\n    {\n        glyph += start;\n        glyph = get_byte(glyph & 3, GAME_HUD_STATS.data[GAME_HUD_STATS.data[0] + 2 + (glyph>>2)]);\n    }\n    else\n    {\n        glyph -= num_chars;\n        if (uint(glyph) >= uint(NUM_DIGITS))\n            return;\n        \n        int stat;\n        switch (line)\n        {\n            case 0: stat = int(abs(game_state.level)); break;\n            case 1: stat = int(game_state.targets_left); break;\n            case 2: stat = int(game_state.time_left); break;\n            default: stat = 0; break;\n        }\n\t\tglyph = NUM_DIGITS - 1 - glyph;\n        glyph = int_glyph(stat, glyph);\n    }\n\n    const vec3 HIGHLIGHT_COLOR = vec3(.60, .30, .23);\n    vec4 color = vec4(vec3(.75), 1.);\n    if ((line == 0 && fract(game_state.level) > 0.) ||\n        (line == 1 && fract(game_state.targets_left) > 0.))\n    {\n\t\tcolor.rgb = HIGHLIGHT_COLOR;\n    }\n    else if (line == 2 && game_state.time_left < 10.)\n    {\n        float blink_rate = game_state.time_left < 5. ? 2. : 1.;\n        if (fract(game_state.time_left * blink_rate) > .75)\n            color.rgb = HIGHLIGHT_COLOR;\n    }\n\n    print_glyph(fragColor, uv, glyph, color);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid apply_motion_blur(inout vec4 fragColor, vec2 fragCoord, vec4 camera_pos)\n{\n#if !USE_MOTION_BLUR\n    return;\n#endif\n\n    // not right after teleporting\n    float teleport_time = camera_pos.w;\n    if (teleport_time > 0. && abs(iTime - teleport_time) < 1e-4)\n        return;\n    \n    vec3 camera_angles = load(ADDR_CAM_ANGLES).xyz;\n    vec3 prev_camera_pos = load(ADDR_PREV_CAM_POS).xyz;\n    vec3 prev_camera_angles = load(ADDR_PREV_CAM_ANGLES).xyz;\n    mat3 view_matrix = rotation(camera_angles.xyz);\n    mat3 prev_view_matrix = rotation(prev_camera_angles.xyz);\n\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame, iResolution.xy, g_downscale);\n    ndc_scale_bias.xy /= iResolution.xy;\n    vec2 actual_res = ceil(iResolution.xy / g_downscale);\n    vec4 coord_bounds = vec4(vec2(.5), actual_res - .5);\n\n    vec3 dir = view_matrix * unproject(fragCoord * ndc_scale_bias.xy + ndc_scale_bias.zw);\n    vec3 surface_point = camera_pos.xyz + dir * VIEW_DISTANCE * fragColor.w;\n    dir = surface_point - prev_camera_pos;\n    dir = dir * prev_view_matrix;\n    vec2 prev_coord = project(dir).xy;\n    prev_coord = (prev_coord - ndc_scale_bias.zw) / ndc_scale_bias.xy;\n    float motion = length(prev_coord - fragCoord);\n\n    if (fragColor.w <= 0. || motion * g_downscale < 4.)\n        return;\n    \n    // Simulating a virtual shutter to avoid excessive blurring at lower FPS\n    const float MOTION_BLUR_SHUTTER = MOTION_BLUR_AMOUNT / float(MOTION_BLUR_FPS);\n    float shutter_fraction = clamp(MOTION_BLUR_SHUTTER/iTimeDelta, 0., 1.);\n\n    vec2 rcp_resolution = 1./iResolution.xy;\n    vec4 uv_bounds = coord_bounds * rcp_resolution.xyxy;\n    vec2 trail_start = fragCoord * rcp_resolution;\n    vec2 trail_end = prev_coord * rcp_resolution;\n    trail_end = mix(trail_start, trail_end, shutter_fraction * linear_step(4., 16., motion * g_downscale));\n\n    float mip_level = log2(motion / (float(MOTION_BLUR_SAMPLES) + 1.)) - 1.;\n    mip_level = clamp(mip_level, 0., 2.);\n\n    const float INC = 1./float(MOTION_BLUR_SAMPLES);\n    float trail_offset = BLUE_NOISE(fragCoord).x * INC - .5;\n    float trail_weight = 1.;\n    for (float f=0.; f<float(MOTION_BLUR_SAMPLES); ++f)\n    {\n        vec2 sample_uv = mix(trail_start, trail_end, trail_offset + f * INC);\n        if (is_inside(sample_uv, uv_bounds) < 0.)\n            continue;\n        vec4 s = textureLod(iChannel2, sample_uv, mip_level);\n        // Hack: to avoid weapon model ghosting we'll ignore samples landing in that area.\n        // This introduces another artifact (sharper area behind the weapon model), but\n        // this one is harder to notice in motion...\n        float weight = step(0., s.w);\n        fragColor.rgb += s.xyz * weight;\n        trail_weight += weight;\n    }\n    \n    fragColor.rgb /= trail_weight;\n}\n\nvoid present_scene(out vec4 fragColor, vec2 fragCoord, Options options)\n{\n    fragCoord /= g_downscale;\n    vec2 actual_res = ceil(iResolution.xy / g_downscale);\n\n    // cover up our viewmodel lighting hack\n    bool is_ground_sample = is_inside(fragCoord, iResolution.xy - 1.) > 0.;\n    if (is_ground_sample)\n        fragCoord.x--;\n\n    vec4 camera_pos = load(ADDR_CAM_POS);\n    vec3 lava_delta = abs(camera_pos.xyz - clamp(camera_pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1]));\n    float lava_dist = max3(lava_delta.x, lava_delta.y, lava_delta.z);\n    if (lava_dist <= 0.) \n    {\n        fragCoord += sin(iTime + 32. * (fragCoord/actual_res).yx) * actual_res * (1./192.);\n        fragCoord = clamp(fragCoord, vec2(.5), actual_res - .5);\n    }\n\n    fragColor = texelFetch(PRESENT_CHANNEL, ivec2(fragCoord), 0);\n    \n    if (test_flag(options.flags, OPTION_FLAG_MOTION_BLUR))\n    \tapply_motion_blur(fragColor, fragCoord, camera_pos);\n\n    fragColor.rgb = linear_to_gamma(fragColor.rgb);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid color_correction(inout vec4 fragColor, vec2 fragCoord, bool is_thumbnail)\n{\n    if (g_demo_stage != DEMO_STAGE_NORMALS)\n    {\n        Options options;\n        LOAD(options);\n    \t\n        float gamma = is_thumbnail ? .8 : 1. - options.brightness * .05;\n#if GAMMA_MODE\n    \tfragColor.rgb = gamma_to_linear(fragColor.rgb);\n    \tfloat luma = dot(fragColor.rgb, vec3(0.2126, 0.7152, 0.0722));\n    \tif (luma > 0.)\n\t    \tfragColor.rgb *= pow(luma, gamma) / luma;\n\t    fragColor.rgb = linear_to_gamma(fragColor.rgb);\n#else\n\t    fragColor.rgb = pow(fragColor.rgb, vec3(gamma));\n#endif\n    }\n    \n    // dithering, for smooth depth/lighting visualisation (when not quantized!)\n    fragColor.rgb += (BLUE_NOISE(fragCoord).rgb - .5) * (1./127.5);\n}\n\n////////////////////////////////////////////////////////////////\n\nbool draw_debug(out vec4 fragColor, vec2 fragCoord)\n{\n    if (iMouse.z > 0.)\n        fragCoord = (fragCoord - iMouse.xy) / DEBUG_CLICK_ZOOM + iMouse.xy;\n    ivec2 addr = ivec2(fragCoord);\n\n#if defined(DEBUG_TEXTURE) && (DEBUG_TEXTURE >= 0) && (DEBUG_TEXTURE < NUM_MATERIALS)\n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    vec4 tile = get_tile(DEBUG_TEXTURE);\n    vec2 uv = fragCoord / min_component(iResolution.xy/tile.zw) + tile.xy;\n    fragColor = is_inside(uv, tile) < 0. ? vec4(0) :\n    \ttexelFetch(SETTINGS_CHANNEL, ivec2(ATLAS_OFFSET + uv * atlas_scale), 0);\n    return true;\n#endif\n\n#if DEBUG_ATLAS\n    fragColor = texelFetch(SETTINGS_CHANNEL, addr, 0);\n    return true;\n#endif\n\n#if DEBUG_LIGHTMAP >= 2\n    int channel = addr.x & 3;\n    addr.x >>= 2;\n    if (uint(addr.y) < LIGHTMAP_SIZE.x && uint(addr.x) < LIGHTMAP_SIZE.y/4u)\n    {\n        LightmapSample s = decode_lightmap_sample(texelFetch(LIGHTMAP_CHANNEL, addr.yx, 0));\n        float l = s.values[channel], w = s.weights[channel];\n#if DEBUG_LIGHTMAP >= 3\n    \tfragColor = vec4(w <= 0. ? vec3(1,0,0) : l == 0. ? vec3(0,0,1) : vec3(l), 1);\n#else\n        fragColor = vec4(vec3(clamp(l, 0., 1.)), 1);\n#endif\n    }\n    else\n    {\n        fragColor = vec4(0,0,0,1);\n    }\n    return true;\n#elif DEBUG_LIGHTMAP\n    vec4 texel = texelFetch(LIGHTMAP_CHANNEL, addr, 0);\n    fragColor =\n        uint(addr.x) < LIGHTMAP_SIZE.x && uint(addr.y) < LIGHTMAP_SIZE.y/4u ?\n        \tdecode_lightmap_sample(texel).values :\n    \t\ttexel;\n    return true;\n#endif\n\n    return false;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid crt_effect(inout vec4 fragColor, vec2 fragCoord, Options options)\n{\n#if USE_CRT_EFFECT\n\tif (!test_flag(options.flags, OPTION_FLAG_CRT_EFFECT))\n        return;\n    \n    vec2 uv = fragCoord / iResolution.xy, offset = uv - .5;\n    fragColor.rgb *= 1. + sin(fragCoord.y * (TAU/4.)) * (CRT_SCANLINE_WEIGHT);\n    fragColor.rgb *= clamp(1.6 - sqrt(length(offset)), 0., 1.);\n    \n    const float\n        MASK_LO = 1. - (CRT_MASK_WEIGHT) / 3.,\n        MASK_HI = 1. + (CRT_MASK_WEIGHT) / 3.;\n\n    vec3 mask = vec3(MASK_LO);\n    float i = fract((floor(fragCoord.y) * 3. + fragCoord.x) * (1./6.));\n    if (i < 1./3.)\t\tmask.r = MASK_HI;\n    else if (i < 2./3.)\tmask.g = MASK_HI;\n    else\t\t\t\tmask.b = MASK_HI;\n\n\tfragColor.rgb *= mask;\n#endif // USE_CRT_EFFECT\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (draw_debug(fragColor, fragCoord))\n        return;\n    \n    Options options;\n    LOAD(options);\n    \n    g_downscale = get_downscale(options);\n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    \n    Lighting lighting;\n    LOAD(lighting);\n\n    UPDATE_TIME(lighting);\n    UPDATE_DEMO_STAGE_EX(fragCoord/g_downscale, g_downscale, is_thumbnail);\n    init_text_scale();\n    update_console();\n\n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n\n    present_scene\t\t(fragColor, fragCoord, options);\n    add_effects\t\t\t(fragColor, fragCoord, is_thumbnail);\n    describe_demo_stage\t(fragColor, fragCoord);\n    draw_game_info\t\t(fragColor, fragCoord);\n    draw_perf\t\t\t(fragColor, fragCoord);\n    draw_menu\t\t\t(fragColor, fragCoord, timing);\n    draw_console\t\t(fragColor, fragCoord, lighting);\n    color_correction\t(fragColor, fragCoord, is_thumbnail);\n    crt_effect\t\t\t(fragColor, fragCoord, options);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n// config.cfg //////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define DEMO_MODE\t\t\t\t0\n#define DEMO_STAGE_DURATION\t\t1.5\n#define DEMO_MODE_HALFTONE\t\t1\t\t// 0=blue noise dither; 1=disks\n\n#define GRAVITY\t\t\t\t\t800.0\n#define LOADING_TIME\t\t\t2.5\t\t// lower bound, in seconds\n#define LIGHTMAP_AA_SAMPLES\t\t8\n\n// Used for mipmap generation, texture filtering and light shafts\n// Lighting is performed in 'gamma' (non-linear) space for a more authentic look\n#define USE_GAMMA_CORRECTION\t2\t\t// 0=off; 1=sRGB; 2=gamma 2.0\n\n#define VIEW_DISTANCE\t\t\t2048.0\n\n// Debug switches //////////////////////////////////////////////\n\n#define COMPILE_FASTER\t\t\t1\n#define USE_DISCARD\t\t\t\t1\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#if COMPILE_FASTER\n\t#define NO_UNROLL(k)\t\t((k)+min(iFrame,0))\n#else\n\t#define NO_UNROLL(k)\t\t(k)\n#endif\n\n#if USE_DISCARD\n\t#define DISCARD\t\t\t\tdiscard\n#else\n\t#define DISCARD\t\t\t\treturn\n#endif\n\n// Speed up your shaders on Intel iGPUs with this one weird trick!\n// No, seriously - on a Surface 3 (Atom x7-Z8700), wrapping global\n// arrays in structs increased framerate from ~1.4 FPS to 45+!\n\n// Side note: token pasting would be really handy right about now...\n#define WRAP(struct_name, name, type, count)\\\n    const struct struct_name { type data[count]; } name = struct_name(type[count]\n\n// Standard materials (cached in Buffer A) /////////////////////\n\n#define MATERIAL_WIZMET1_2      0\n#define MATERIAL_WBRICK1_5      1\n#define MATERIAL_WIZMET1_1      2\n#define MATERIAL_WIZ1_4         3\n#define MATERIAL_CITY4_7        4\n#define MATERIAL_BRICKA2_2      5\n#define MATERIAL_CITY4_6        6\n#define MATERIAL_WIZWOOD1_5     7\n#define MATERIAL_TELEPORT       8\n#define MATERIAL_WINDOW02_1     9\n#define MATERIAL_COP3_4         10\n#define MATERIAL_WATER1         11\n#define MATERIAL_LAVA1          12\n#define MATERIAL_WATER2         13\n#define MATERIAL_DEM4_1         14\n#define MATERIAL_QUAKE          15\n#define MATERIAL_SKY1           16\n#define MATERIAL_SKY1B          17\n#define MATERIAL_FLAME          18\n#define MATERIAL_ZOMBIE         19\n#define NUM_MATERIALS           20\n\nconst int\n\tATLAS_WIDTH                 = 512,\n\tATLAS_HEIGHT                = 256;\n// atlas usage: 100%\n\nWRAP(Tiles,tiles,int,10)(1703961,1835035,393221,851975,67633173,917533,1441807,16777246,38470217,2031639));\n\nvec4 get_tile(int index)\n{\n    int data = (tiles.data[index >> 1] >> ((index & 1) << 4)) & 4095;\n    return vec4(ivec4(data & 7, (data >> 3) & 7, ((data >> 6) & 7) + 1, ((data >> 9) & 7) + 1) << 6);\n}\n\n// Extra materials /////////////////////////////////////////////\n\nconst int\n    BASE_SHOTGUN_MATERIAL\t\t= NUM_MATERIALS,\n    MATERIAL_SHOTGUN_PUMP\t\t= 0 + BASE_SHOTGUN_MATERIAL,\n    MATERIAL_SHOTGUN_BARREL\t\t= 1 + BASE_SHOTGUN_MATERIAL,\n    MATERIAL_SHOTGUN_FLASH\t\t= 2 + BASE_SHOTGUN_MATERIAL,\n    NUM_SHOTGUN_MATERIALS\t\t= 3,\n\n    BASE_TARGET_MATERIAL\t\t= BASE_SHOTGUN_MATERIAL + NUM_SHOTGUN_MATERIALS,\n    NUM_TARGETS\t\t\t\t\t= 8;\n\n// Material helpers ////////////////////////////////////////////\n\nconst int\n    MATERIAL_MASK_SKY\t\t\t= (1<<MATERIAL_SKY1) | (1<<MATERIAL_SKY1B),\n    MATERIAL_MASK_LIQUID\t\t= (1<<MATERIAL_WATER1) | (1<<MATERIAL_WATER2) | (1<<MATERIAL_LAVA1) | (1<<MATERIAL_TELEPORT);\n\nbool is_material_viewmodel(const int material)\n{\n    return uint(material-BASE_SHOTGUN_MATERIAL) < uint(NUM_SHOTGUN_MATERIALS);\n}\n\nbool is_material_balloon(const int material)\n{\n    return uint(material-BASE_TARGET_MATERIAL) < uint(NUM_TARGETS);\n}\n\nbool is_material_any_of(const int material, const int mask)\n{\n    return uint(material) < 32u && (mask & (1<<material)) != 0;\n}\n\nbool is_material_sky(const int material)\n{\n    return is_material_any_of(material, MATERIAL_MASK_SKY);\n}\n\nbool is_material_liquid(const int material)\n{\n    return is_material_any_of(material, MATERIAL_MASK_LIQUID);\n}\n\n////////////////////////////////////////////////////////////////\n\nconst vec3 LAVA_BOUNDS[]=vec3[2](vec3(704,768,-176),vec3(1008,1232,-112));\n\n////////////////////////////////////////////////////////////////\n\nconst vec2\tATLAS_OFFSET\t\t= vec2(0, 24);\nconst vec2\tATLAS_SIZE\t\t\t= vec2(ATLAS_WIDTH, ATLAS_HEIGHT);\nconst float\tATLAS_CHAIN_WIDTH\t= float(ATLAS_WIDTH) * 1.5;\nconst vec2\tATLAS_CHAIN_SIZE\t= vec2(ATLAS_CHAIN_WIDTH, ATLAS_HEIGHT);\nconst int\tMAX_MIP_LEVEL\t\t= 6;\n\nfloat exp2i(lowp int exponent)\n{\n    return intBitsToFloat(floatBitsToInt(1.) + (exponent << 23));\n}\n\nvec2 mip_offset(lowp int level)\n{\n    return level < 2 ?\n        vec2(level, 0) :\n    \tvec2(1.5 - exp2i(1 - level), .5);\n}\n\nvec4 atlas_chain_bounds(float scale)\n{\n    return vec4(ATLAS_OFFSET, ATLAS_CHAIN_SIZE*scale);\n}\n\nvec4 atlas_mip0_bounds(float scale)\n{\n    return vec4(ATLAS_OFFSET, ATLAS_SIZE*scale);\n}\n\n////////////////////////////////////////////////////////////////\n\nconst float\n\tPI\t\t\t= 3.1415926536,\n\tHALF_PI \t= PI * 0.5,\n    TAU\t\t\t= PI * 2.0,\n    PHI\t\t\t= 1.6180340888,\n\tSQRT2\t\t= 1.4142135624,\n\tINV_SQRT2\t= SQRT2 * 0.5;\n\n// Rotations ///////////////////////////////////////////////////\n\nmat3 rotation(vec3 angles)\n{\n    angles = radians(angles);\n\tfloat sy = sin(angles.x), sp = sin(angles.y), sr = sin(angles.z);\n\tfloat cy = cos(angles.x), cp = cos(angles.y), cr = cos(angles.z);\n    \n    return mat3\n\t(\n        cr*cy+sy*sp*sr,\t\tcr*sy-cy*sp*sr,\t\tcp*sr,\n        -sy*cp,\t\t\t\tcy*cp,\t\t\t\tsp,\n        cr*sy*sp-cy*sr,\t\t-cr*cy*sp-sy*sr,\tcr*cp\n\t);\n}\n\nmat3 rotation(vec2 angles)\n{\n    angles = radians(angles);\n\tfloat\tsy = sin(angles.x), sp = sin(angles.y);\n\tfloat\tcy = cos(angles.x), cp = cos(angles.y);\n   \n    return mat3\n\t(\n        cy,\t\tsy,\t\t0.,\n        -sy*cp,\tcy*cp,\tsp,\n        sy*sp,\t-cy*sp,\tcp\n\t);\n}\n\nmat2 rotation(float angle)\n{\n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 rotate(vec2 p, float angle)\n{\n    return rotation(angle)*p;\n}\n\nvec3 rotate(vec3 p, float yaw)\n{\n    p.xy = rotate(p.xy, yaw);\n    return p;\n}\n\nvec3 rotate(vec3 p, vec2 angles)\n{\n    p.yz = rotate(p.yz, angles.y);\n    p.xy = rotate(p.xy, angles.x);\n    return p;\n}\n\nvec3 rotate(vec3 p, vec3 angles)\n{\n    return rotation(angles)*p;\n}\n\n////////////////////////////////////////////////////////////////\n\n// TODO: make sure these values are used explicitly where needed\n\nconst float FOV = 90.;\nconst float FOV_FACTOR = tan(radians(FOV*.5));\nconst int FOV_AXIS = 0;\n\nfloat scale_fov(float fov, float scale)\n{\n    return 2. * degrees(atan(scale * tan(radians(fov * .5))));\n}\n\nvec2 get_resolution_fov_scale(vec2 resolution)\n{\n    return resolution / resolution[FOV_AXIS];\n}\n\nvec2 compute_fov(vec2 resolution)\n{\n    vec2 scale = get_resolution_fov_scale(resolution);\n    return vec2(scale_fov(FOV, scale.x), scale_fov(FOV, scale.y));\n}\n\nvec3 unproject(vec2 ndc)\n{\n    return vec3(ndc.x, 1., ndc.y);\n}\n\nvec3 project(vec3 direction)\n{\n    return vec3(direction.xz/direction.y, direction.y);\n}\n\nvec2 taa_jitter(int frame)\n{\n#if 0\n    const float SCALE = 1./8.;\n    const float BIAS = .5 * SCALE - .5;\n    frame &= 7;\n    int ri = ((frame & 1) << 2) | (frame & 2) | ((frame & 4) >> 2);\n    return vec2(frame,ri)*SCALE + BIAS;\n#else\n    return vec2(0);\n#endif\n}\n\n// xy=scale, zw=bias\nvec4 get_viewport_transform(int frame, vec2 resolution, float downscale)\n{\n    vec2 ndc_scale = vec2(downscale);\n    vec2 ndc_bias = vec2(0);//ndc_scale * taa_jitter(frame) / resolution.xy;\n    ndc_scale *= 2.;\n    ndc_bias  *= 2.;\n    ndc_bias  -= 1.;\n    ndc_scale.y *= resolution.y / resolution.x;\n    ndc_bias.y  *= resolution.y / resolution.x;\n    return vec4(ndc_scale, ndc_bias);\n}\n\nvec2 hammersley(int i, int total)\n{\n    uint r = uint(i);\n\tr = ((r & 0x55u) << 1u) | ((r & 0xAAu) >> 1u);\n\tr = ((r & 0x33u) << 2u) | ((r & 0xCCu) >> 2u);\n\tr = ((r & 0x0Fu) << 4u) | ((r & 0xF0u) >> 4u);\n    return vec2(float(i)/float(total), float(r)*(1./256.)) + .5/float(total);\n}\n\n////////////////////////////////////////////////////////////////\n\nbool test_flag(int var, int flag)\n{\n    return (var & flag) != 0;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat max3(float a, float b, float c)\n{\n    return max(a, max(b, c));\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat min_component(vec2 v)\t\t{ return min(v.x, v.y); }\nfloat min_component(vec3 v)\t\t{ return min(v.x, min(v.y, v.z)); }\nfloat min_component(vec4 v)\t\t{ return min(min(v.x, v.y), min(v.z, v.w)); }\nfloat max_component(vec2 v)\t\t{ return max(v.x, v.y); }\nfloat max_component(vec3 v)\t\t{ return max(v.x, max(v.y, v.z)); }\nfloat max_component(vec4 v)\t\t{ return max(max(v.x, v.y), max(v.z, v.w)); }\n\n////////////////////////////////////////////////////////////////\n\nint dominant_axis(vec3 nor)\n{\n    nor = abs(nor);\n    float max_comp = max(nor.x, max(nor.y, nor.z));\n    return\n        (max_comp==nor.x) ? 0 : (max_comp==nor.y) ? 1 : 2;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat smoothen(float x)\t\t\t{ return x * x * (3. - 2. * x); }\nvec2  smoothen(vec2 x)  \t\t{ return x * x * (3. - 2. * x); }\nvec3  smoothen(vec3 x)\t\t\t{ return x * x * (3. - 2. * x); }\n\nfloat quintic(float t)\t\t\t{ return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfloat sqr(float x)\t\t\t\t{ return x * x; }\n\n////////////////////////////////////////////////////////////////\n\nfloat length_squared(vec2 v) \t{ return dot(v, v); }\nfloat length_squared(vec3 v) \t{ return dot(v, v); }\nfloat length_squared(vec4 v) \t{ return dot(v, v); }\n\nvec2 safe_normalize(vec2 v)\t\t{ return all(equal(v, vec2(0))) ? vec2(0) : normalize(v); }\nvec3 safe_normalize(vec3 v)\t\t{ return all(equal(v, vec3(0))) ? vec3(0) : normalize(v); }\n\n////////////////////////////////////////////////////////////////\n\nfloat around(float center, float max_dist, float var)\n{\n    return 1. - clamp(abs(var - center)*(1./max_dist), 0., 1.);\n}\n\nfloat linear_step(float low, float high, float value)\n{\n    return clamp((value-low)*(1./(high-low)), 0., 1.);\n}\n\nfloat triangle_wave(float period, float t)\n{\n    return abs(fract(t*(1./period))-.5)*2.;\n}\n\n// UV distortions //////////////////////////////////////////////\n\nvec2 skew(vec2 uv, float factor)\n{\n    return vec2(uv.x + uv.y*factor, uv.y);\n}\n\n// Gamma <-> linear ////////////////////////////////////////////\n\nfloat linear_to_gamma(float f)\n{\n#if USE_GAMMA_CORRECTION == 2\n    return sqrt(f);\n#elif USE_GAMMA_CORRECTION == 1\n    return f <= 0.0031308 ? f * 12.92 : (1.055 * pow(f, (1./2.4)) - 0.055);\n#else\n    return f;\n#endif\n}\n\nvec3 linear_to_gamma(vec3 c)\n{\n    return vec3(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b));\n}\n\nvec4 linear_to_gamma(vec4 c)\n{\n    return vec4(linear_to_gamma(c.r), linear_to_gamma(c.g), linear_to_gamma(c.b), c.a);\n}\n\nfloat gamma_to_linear(float f)\n{\n#if USE_GAMMA_CORRECTION == 2\n    return f * f;\n#elif USE_GAMMA_CORRECTION == 1\n    return f <= 0.04045 ? f * (1./12.92) : pow((f + 0.055) * (1./1.055), 2.4);\n#else\n    return f;\n#endif\n}\n\nvec3 gamma_to_linear(vec3 c)\n{\n    return vec3(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b));\n}\n\nvec4 gamma_to_linear(vec4 c)\n{\n    return vec4(gamma_to_linear(c.r), gamma_to_linear(c.g), gamma_to_linear(c.b), c.a);\n}\n\n// Noise functions /////////////////////////////////////////////\n\n// Dave Hoskins/Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\n\nconst vec4 HASHSCALE = vec4(.1031, .1030, .0973, .1099);\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE.x);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash3(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nvec3 hash3(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 hash3(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE.xyz);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec4 hash4(float p)\n{\n\tvec4 p4 = fract(vec4(p) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 hash4(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p)  { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n// 2D Weyl hash #1, by MBR\n// https://www.shadertoy.com/view/Xdy3Rc\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nfloat weyl_hash(vec2 c)\n{\n    c *= fract(c * vec2(.5545497, .308517));\n    return fract(c.x * c.y);\n}\n\n// by iq\nvec2 hash2(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n#define SMOOTH_NOISE_FUNC(p, hash_name)\t\t\t\t\t\t\t\\\n\tvec2 i = floor(p);\t\t\t\t\t\t\t\t\t\t\t\\\n    p -= i;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    p *= p * (3. - 2.*p);\t\t\t\t\t\t\t\t\t\t\\\n    float\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    \ts00 = hash_name(i),\t\t\t\t\t\t\t\t\t\t\\\n        s01 = hash_name(i + vec2(1, 0)),\t\t\t\t\t\t\\\n        s10 = hash_name(i + vec2(0, 1)),\t\t\t\t\t\t\\\n        s11 = hash_name(i + vec2(1, 1));\t\t\t\t\t\t\\\n\treturn mix(mix(s00, s01, p.x), mix(s10, s11, p.x), p.y)\t\t\\\n\nfloat smooth_noise(vec2 p)\n{\n    SMOOTH_NOISE_FUNC(p, random);\n}\n\nfloat smooth_weyl_noise(vec2 p)\n{\n    SMOOTH_NOISE_FUNC(p, weyl_hash);\n}\n\nfloat smooth_noise(float f)\n{\n    float i = floor(f);\n    f -= i;\n    f *= f * (3. - 2.*f);\n    return mix(hash(i), hash(i + 1.), f);\n}\n\n#define FBM_FUNC(uv, gain, lacunarity, noise)\t\t\\\n\tfloat accum = noise(uv);\t\t\t\t\t\t\\\n    float octave_weight = gain;\t\t\t\t\t\t\\\n    float total_weight = 1.;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity;\t\t\t\t\t\t\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity; octave_weight *= gain;\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    uv *= lacunarity; octave_weight *= gain;\t\t\\\n    accum += noise(uv) * octave_weight;\t\t\t\t\\\n    total_weight += octave_weight;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    return accum / total_weight\t\t\t\t\t\t\\\n\nfloat turb(vec2 uv, float gain, float lacunarity)\n{\n    FBM_FUNC(uv, gain, lacunarity, smooth_noise);\n}\n\nfloat weyl_turb(vec2 uv, float gain, float lacunarity)\n{\n    FBM_FUNC(uv, gain, lacunarity, smooth_weyl_noise);\n}\n\nvec4 blue_noise(vec2 fragCoord, sampler2D channel, int frame)\n{\n    ivec2 uv = ivec2(fragCoord) + frame * ivec2(19, 23);\n    return texelFetch(channel, uv & (textureSize(channel, 0) - 1), 0);\n}\n\n#define BLUE_NOISE(fragCoord) blue_noise(fragCoord, NOISE_CHANNEL, iFrame)\n\n// SDF operations //////////////////////////////////////////////\n\nfloat sdf_exclude(float from, float what)\n{\n    return max(from, -what);\n}\n\nfloat sdf_union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat sdf_intersection(float a, float b)\n{\n    return max(a, b);\n}\n\n// polynomial smooth min\n// https://iquilezles.org/articles/smin\nfloat sdf_smin(float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// SDF effects /////////////////////////////////////////////////\n\nfloat sdf_mask(float sdf, float px)\n{\n    return clamp(1. - sdf/px, 0., 1.);\n}\n\nfloat sdf_mask(float sdf)\n{\n    float px = max(abs(dFdx(sdf)), abs(dFdy(sdf)));\n    return sdf_mask(sdf, px);\n}\n\nvec2 sdf_normal(float sdf)\n{\n    vec2 n = vec2(dFdx(sdf), dFdy(sdf));\n\tfloat sqlen = dot(n, n);\n    return n * ((sqlen > 0.) ? inversesqrt(sqlen) : 1.);\n}\n\nvec2 sdf_emboss(float sdf, float bevel, vec2 light_dir)\n{\n    float mask = sdf_mask(sdf);\n    bevel = clamp(1. + sdf/bevel, 0., 1.);\n    return vec2(mask * (.5 + sqrt(bevel) * dot(sdf_normal(sdf), light_dir)), mask);\n}\n\n// SDF generators //////////////////////////////////////////////\n\nfloat sdf_disk(vec2 uv, vec2 center, float radius)\n{\n    return length(uv - center) - radius;\n}\n\nfloat sdf_ellipse(vec2 uv, vec2 center, vec2 r)\n{\n    return (length((uv-center)/r) - 1.) / min(r.x, r.y);\n}\n\nfloat sdf_centered_box(vec2 uv, vec2 center, vec2 size)\n{\n    return max(abs(uv.x-center.x) - size.x, abs(uv.y-center.y) - size.y);\n}\n\nfloat sdf_box(vec2 uv, vec2 mins, vec2 maxs)\n{\n    return sdf_centered_box(uv, (mins+maxs)*.5, (maxs-mins)*.5);\n}\n\nfloat sdf_line(vec2 uv, vec2 a, vec2 b, float thickness)\n{\n    vec2 ab = b-a;\n    vec2 ap = uv-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return length(uv - (ab*t + a)) - thickness*.5;\n}\n\nfloat sdf_seriffed_box(vec2 uv, vec2 origin, vec2 size, vec2 top_serif, vec2 bottom_serif)\n{\n    float h = clamp((uv.y - origin.y) / size.y, 0., 1.);\n    float xmul = h < bottom_serif.y ? mix(1.+bottom_serif.x, 1., sqrt(1.-sqr(1.-(h/bottom_serif.y)))) :\n    \t\th > (1.-top_serif.y) ? 1.+top_serif.x*sqr(1.-(1.-h)/(top_serif.y)) :\n            1.;\n    return sdf_centered_box(uv, vec2(origin.x, origin.y+size.y*.5), vec2(size.x*xmul*.5, size.y*.5));\n}\n\nfloat sdf_nail(vec2 uv, vec2 top, vec2 size)\n{\n    const float head_flat_frac = .02;\n    const float head_round_frac = .08;\n    const float body_thickness = .5;\n\n    float h = clamp((top.y - uv.y) / size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_Q(vec2 uv)\n{\n    float dist = sdf_disk(uv, vec2(.5, .67), .32);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .735), .27));\n    dist = sdf_union(dist, sdf_nail(uv, vec2(.5, .59), vec2(.09, .52)));\n    return dist;\n}\n\nfloat sdf_id(vec2 uv)\n{\n    float d = .06*sdf_ellipse(uv, vec2(.52, .38), vec2(.26, .28));\n    d = sdf_exclude(d, .02*sdf_ellipse(uv, vec2(.57, .39), vec2(.12, .18)));\n    d = sdf_union(d, sdf_centered_box(uv, vec2(.75, .51), vec2(.09, .30)));\n    d = sdf_union(d, sdf_centered_box(uv, vec2(.80, .80), vec2(.04, .10)));\n    d = sdf_smin(d, sdf_centered_box(uv, vec2(.78, .15), vec2(.12, .05)), .05);\n    d = sdf_smin(d, sdf_centered_box(uv, vec2(.66, .81), vec2(.10, .05)), .05);\n    float i = sdf_centered_box(uv, vec2(.25, .40), vec2(.09, .23));\n    i = sdf_union(i, sdf_disk(uv, vec2(.24, .79), .09));\n    i = sdf_smin(i, sdf_centered_box(uv, vec2(.25, .15), vec2(.15, .05)), .05);\n    i = sdf_smin(i, sdf_centered_box(uv, vec2(.20, .60), vec2(.10, .03)), .05);\n    return sdf_exclude(sdf_union(i, d), sdf_intersection(i, d));\n}\n\nvec2 add_knob(vec2 uv, float px, vec2 center, float radius, vec2 light_dir)\n{\n    float light = dot(normalize(uv-center), light_dir)*.5 + .5;\n    float mask = sdf_mask(sdf_disk(uv, center, radius), px);\n    return vec2(light, mask);\n}\n\nvec3 closest_point_on_segment(vec3 p, vec3 a, vec3 b)\n{\n    vec3 ab = b-a, ap = p-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return ab*t + a;\n}\n\n// QUAKE text //////////////////////////////////////////////////\n\nfloat sdf_nail_v2(vec2 uv, vec2 top, vec2 size)\n{\n    const float\n        head_flat_frac = .1,\n    \thead_round_frac = .1,\n    \tbody_thickness = .5;\n\n    float h = clamp((top.y - uv.y) / size.y, 0., 1.);\n    float w = (h < head_flat_frac) ? 1. :\n        (h < head_flat_frac + head_round_frac) ? mix( body_thickness, 1., sqr(1.-(h-head_flat_frac)/head_round_frac)) :\n    \th > .6 ? ((1.05 - h) / (1.05 - .6)) * body_thickness : body_thickness;\n    return sdf_centered_box(uv, top - vec2(0., size.y*.5), size*vec2(w, .5));\n}\n\nfloat sdf_Q_top(vec2 uv)\n{\n    uv.y -= .01;\n    float dist = sdf_disk(uv, vec2(.5, .64), .36);\n    dist = sdf_exclude(dist, sdf_disk(uv, vec2(.5, .74), .29));\n    dist = sdf_union(dist, sdf_nail_v2(uv, vec2(.5, .61), vec2(.125, .57)));\n    dist = sdf_exclude(dist, .95 - uv.y);\n    return dist;\n}\n\nfloat sdf_U(vec2 uv)\n{\n    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.58, .6), vec2(.25, .35), vec2(-.7,.3));\n    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .34), vec2(.3, .58), vec2(-.5, .35), vec2(-.75, .2)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .3), vec2(.04, .15)));\n    return sdf;\n}\n\nfloat sdf_A(vec2 uv)\n{\n    float h = linear_step(.3, .9, uv.y);\n\tfloat sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(mix(.7, .01, h), .6), vec2(0.,.3), vec2(.2,.3));\n    h = linear_step(.1, .65, uv.y);\n\tsdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.45, .1), vec2(mix(.7, .01, h), .55), vec2(0.,.3), vec2(0.,.3)));\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.45, .47), vec2(.18, .02)));\n    return sdf;\n}\n\nfloat sdf_K(vec2 uv)\n{\n\tfloat sdf = sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2));\n\tsdf = sdf_disk(uv, vec2(.17, .17), .5);\n\tsdf = sdf_exclude(sdf, sdf_disk(uv, vec2(.1, -.05), .6));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(-.32, .3), vec2(.4, .8)));\n    sdf = sdf_union(sdf, sdf_seriffed_box(uv, vec2(.1, .3), vec2(.15, .6), vec2(.5,.2), vec2(.5,.2)));\n\tsdf = sdf_union(sdf, sdf_seriffed_box(skew(uv+vec2(.25,-.3),-1.3), vec2(.1, .3), vec2(mix(.25, .01, linear_step(.5, 1., uv.y)), .3), vec2(0.,.3), vec2(.5,.3)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.5, .1), vec2(.4, .2)));\n    return sdf;\n}\n\nfloat sdf_E(vec2 uv)\n{\n    float sdf_r = sdf_centered_box(uv, vec2(.66, .6), vec2(.1, .3));\n    sdf_r = sdf_exclude(sdf_r, sdf_disk(uv, vec2(.58, .6), .25));\n    sdf_r = sdf_exclude(sdf_r, sdf_centered_box(uv, vec2(.33, .6), vec2(.25, .35)));\n    float sdf = sdf_seriffed_box(uv, vec2(.5, .3), vec2(.55, .6), vec2(.2, .15), vec2(-.5,.3));\n    sdf = sdf_exclude(sdf, sdf_seriffed_box(uv, vec2(.5, .33), vec2(.3, .57), vec2(-.5, .15), vec2(-.75, .2)));\n    sdf = sdf_exclude(sdf, sdf_centered_box(uv, vec2(.65, .6), vec2(.2, .35)));\n    sdf = sdf_union(sdf, sdf_r);\n    float t = linear_step(.4, .5, uv.x);\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.4, .6), vec2(.1, mix(.03, .01, t))));\n    return sdf;\n}\n\n// Time ////////////////////////////////////////////////////////\n\nconst float\n    CONSOLE_XFADE_DURATION\t= 1.,\n\tCONSOLE_SLIDE_DURATION\t= .5,\n\tCONSOLE_TYPE_DURATION\t= 2.,\n    WORLD_RENDER_TIME\t\t= CONSOLE_XFADE_DURATION,\n\tINPUT_ACTIVE_TIME\t\t= (CONSOLE_XFADE_DURATION + CONSOLE_SLIDE_DURATION + CONSOLE_TYPE_DURATION),\n    \n    // TODO: s/TIME/DURATION/\n    LEVEL_COUNTDOWN_TIME\t= 3.,\n    BALLOON_SCALEIN_TIME\t= .5,\n    LEVEL_WARMUP_TIME\t\t= LEVEL_COUNTDOWN_TIME + BALLOON_SCALEIN_TIME,\n    HUD_TARGET_ANIM_TIME\t= .25,\n    \n    THUMBNAIL_MIN_TIME\t\t= 5.\n;\n\nfloat g_time = 0.;\n\nvoid update_time(float bake_time, float uniform_time)\n{\n    if (bake_time > 0.)\n    \tg_time = uniform_time - bake_time;\n    else\n        g_time = -uniform_time;\n}\n\n#define UPDATE_TIME(lighting)\t\tupdate_time(lighting.bake_time, iTime)\n\n// GBuffer /////////////////////////////////////////////////////\n\nconst int GBUFFER_NORMAL_BITS = 8;\nconst float\n    GBUFFER_NORMAL_SCALE = float(1 << GBUFFER_NORMAL_BITS),\n    GBUFFER_NORMAL_MAX_VALUE = GBUFFER_NORMAL_SCALE - 1.;\n\n// http://jcgt.org/published/0003/02/01/paper.pdf\nvec2 signNotZero(vec2 v)\n{\n\treturn vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);\n}\n\n// Assume normalized input. Output is on [-1, 1] for each component.\nvec2 vec3_to_oct(vec3 v)\n{\n\t// Project the sphere onto the octahedron, and then onto the xy plane\n\tvec2 p = v.xy * (1.0 / (abs(v.x) + abs(v.y) + abs(v.z)));\n\t// Reflect the folds of the lower hemisphere over the diagonals\n\treturn (v.z <= 0.0) ? ((1.0 - abs(p.yx)) * signNotZero(p)) : p;\n}\n\nvec3 oct_to_vec3(vec2 e)\n{\n    vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));\n    if (v.z < 0.0)\n        v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);\n    return normalize(v);\n}\n\nfloat compress(vec2 v, vec2 noise)\n{\n    v = floor(clamp(v, 0., 1.) * GBUFFER_NORMAL_MAX_VALUE + noise);\n    return v.y * GBUFFER_NORMAL_SCALE + v.x;\n}\n\nvec2 uncompress(float f)\n{\n    vec2 v = vec2(mod(f, GBUFFER_NORMAL_SCALE), f / GBUFFER_NORMAL_SCALE);\n    return clamp(floor(v) / GBUFFER_NORMAL_MAX_VALUE, 0., 1.);\n}\n\nstruct GBuffer\n{\n    vec3\tnormal;\n    float\tz;\n    float\tlight;\n    int\t\tmaterial;\n    int\t\tuv_axis;\n    bool\tedge;\n};\n\nvec4 gbuffer_pack(GBuffer g, vec2 noise)\n{\n    int props =\n        (g.material \t<< 3) |\n        (g.uv_axis \t\t<< 1) |\n        int(g.edge);\n    return vec4(compress(vec3_to_oct(g.normal) * .5 + .5, noise), g.light, g.z, float(props));\n}\n\nGBuffer gbuffer_unpack(vec4 v)\n{\n    int props = int(round(v.w));\n    \n    GBuffer g;\n    g.normal\t= oct_to_vec3(uncompress(v.x) * 2. - 1.);\n    g.light\t\t= v.y;\n    g.z\t\t\t= v.z;\n    g.material\t= props >> 3;\n    g.uv_axis\t= (props >> 1) & 3;\n    g.edge\t\t= (props & 1) != 0;\n    \n    return g;\n}\n\n// Lightmap encoding ///////////////////////////////////////////\n\nconst float LIGHTMAP_OVERBRIGHT = 2.;\n\nstruct LightmapSample\n{\n    vec4 weights;\n    vec4 values;\n};\n\nLightmapSample empty_lightmap_sample()\n{\n    return LightmapSample(vec4(0), vec4(0));\n}\n\nLightmapSample decode_lightmap_sample(vec4 encoded)\n{\n    return LightmapSample(floor(encoded), fract(encoded) * LIGHTMAP_OVERBRIGHT);\n}\n\nvec4 encode(LightmapSample s)\n{\n    return floor(s.weights) + clamp(s.values * (1./LIGHTMAP_OVERBRIGHT), 0., 1.-1./1024.);\n}\n\n// Fireball ////////////////////////////////////////////////////\n\nconst vec3 FIREBALL_ORIGIN = vec3(864, 992, -168);\n\nstruct Fireball\n{\n    float launch_time;\n    vec3 velocity;\n};\n    \nvoid get_fireball_props(float time, out Fireball props)\n{\n    const float INTERVAL\t= 5.;\n    const float MAX_DELAY\t= 2.;\n    const float BASE_SPEED\t= 600.;\n\n    float interval_start = floor(time*(1./INTERVAL)) * INTERVAL;\n    float delay = hash(interval_start) * MAX_DELAY;\n    \n    props.launch_time = interval_start + delay;\n    props.velocity.x = hash(interval_start + .23) * 100. - 50.;\n    props.velocity.y = hash(interval_start + .37) * 100. - 50.;\n    props.velocity.z = hash(interval_start + .71) * 200. + BASE_SPEED;\n}\n\nvec3 get_fireball_offset(float time, Fireball props)\n{\n    float elapsed = max(0., time - props.launch_time);\n\n    vec3 offset = elapsed * props.velocity;\n    offset.z -= GRAVITY * .5 * elapsed * elapsed;\n    offset.z = max(offset.z, 0.);\n    \n    return offset;\n}\n\nvec3 get_fireball_offset(float time)\n{\n    Fireball props;\n    get_fireball_props(time, props);\n    return get_fireball_offset(time, props);\n}\n\nfloat get_landing_time(Fireball props)\n{\n    return props.launch_time + props.velocity.z * (2./GRAVITY);\n}\n\n// Classic (dot) halftoning ////////////////////////////////////\n\nvec2 halftone_point(vec2 fragCoord, float grid_size)\n{\n    const mat2 rot = INV_SQRT2 * mat2(1,1,-1,1);\n    fragCoord = rot * fragCoord;\n    vec2 fc2 = fragCoord * (1./grid_size);\n    vec2 nearest = (floor(fc2) + .5) * grid_size;\n    nearest.x += grid_size*.5 * step(.5, fract(fc2.y * .5)) * sign(round(fc2.x)*grid_size - fragCoord.x);\n    return nearest * rot;\n}\n\nfloat halftone(vec2 fragCoord, vec2 center, float grid_size, float fraction)\n{\n    fraction *= grid_size * INV_SQRT2;\n    return step(length_squared(fragCoord - center), sqr(fraction));\n}\n\nfloat halftone_classic(vec2 fragCoord, float grid_size, float fraction)\n{\n    vec2 point = halftone_point(fragCoord, grid_size);\n    return halftone(fragCoord, point, grid_size, fraction);\n}\n\n// Demo mode ///////////////////////////////////////////////////\n\nconst int\n\tDEMO_STAGE_NONE\t\t\t= 0,\n\tDEMO_STAGE_DEPTH\t\t= 2,\n\tDEMO_STAGE_NORMALS\t\t= 3,\n\tDEMO_STAGE_UV\t\t\t= -1,\t// disabled for now\n\tDEMO_STAGE_TEXTURES\t\t= 4,\n\tDEMO_STAGE_LIGHTING\t\t= 5,\n\tDEMO_STAGE_COMPOSITE\t= 6,\n\tDEMO_STAGE_FPS\t\t\t= 7,\n\tDEMO_NUM_STAGES\t\t\t= 9;\n\nint g_demo_stage = DEMO_STAGE_NONE;\nint g_demo_scene = 0;\n\nbool is_demo_mode_enabled(bool thumbnail)\n{\n#if !DEMO_MODE\n    if (!thumbnail)\n        return false;\n#endif // !DEMO_MODE\n    return true;\n}\n\nbool is_demo_stage_composite(int stage)\n{\n    return uint(stage - DEMO_STAGE_DEPTH) >= uint(DEMO_STAGE_COMPOSITE - DEMO_STAGE_DEPTH);\n}\n\nbool is_demo_stage_composite()\n{\n    return is_demo_stage_composite(g_demo_stage);\n}\n\nvoid update_demo_stage(vec2 fragCoord, vec2 resolution, float downscale, sampler2D noise, int frame, bool thumbnail)\n{\n    float time = g_time;\n\n    if (!is_demo_mode_enabled(thumbnail))\n    {\n\t\tg_demo_stage = DEMO_STAGE_NONE;\n        return;\n    }\n    \n    resolution *= 1./downscale;\n    vec2 uv = clamp(fragCoord/resolution, 0., 1.);\n        \n    const float TRANSITION_WIDTH = .125;\n    const vec2 ADVANCE = vec2(.5, -.125);\n\n    time = max(0., time - INPUT_ACTIVE_TIME);\n    time *= 1./DEMO_STAGE_DURATION;\n    time += dot(uv, ADVANCE) - ADVANCE.y;\n\n#if !DEMO_MODE_HALFTONE\n    time += TRANSITION_WIDTH * sqrt(blue_noise(fragCoord, noise, frame).x);\n#else\n    const float HALFTONE_GRID = 8.;\n    float fraction = clamp(1. - (round(time) - time) * (1./TRANSITION_WIDTH), 0., 1.);\n    time += TRANSITION_WIDTH * halftone_classic(fragCoord, HALFTONE_GRID, fraction);\n#endif // !DEMO_MODE_HALFTONE\n\n    g_demo_stage = int(mod(time, float(DEMO_NUM_STAGES)));\n    g_demo_scene = int(time * (1./float(DEMO_NUM_STAGES)));\n}\n\t\n#define UPDATE_DEMO_STAGE_EX(fragCoord, downscale, thumbnail)\t\\\n\tupdate_demo_stage(fragCoord, iResolution.xy, downscale, NOISE_CHANNEL, iFrame, thumbnail)\n\n#define UPDATE_DEMO_STAGE(fragCoord, downscale, thumbnail)\t\\\n\tUPDATE_DEMO_STAGE_EX(fragCoord, downscale, thumbnail)\n\nconst struct DemoScene\n{\n    vec3 pos;\n    vec2 angles;\n}\ng_demo_scenes[] = DemoScene[4]\n(\n    DemoScene(vec3(544,272,49),\t\tvec2(0,5)),\n    DemoScene(vec3(992,1406,196),\tvec2(138,-26)),\n    DemoScene(vec3(323,890,-15),\tvec2(35.5,4)),\n    //DemoScene(vec3(1012,453,73),\tvec2(38.25,-8))\n    DemoScene(vec3(1001,514,37),\tvec2(42.3,.2))\n);\n\nDemoScene get_demo_scene()\n{\n    return g_demo_scenes[g_demo_scene % g_demo_scenes.length()];\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat get_viewmodel_offset(vec3 velocity, float bob_cycle, float attack)\n{\n    const float BOB_FRACTION = .003;\n    float speed = length(velocity.xy);\n    float bob = speed * BOB_FRACTION * (.3 + .7 * sin(TAU * bob_cycle));\n    bob = clamp(bob, -.5, 1.);\n    attack = attack * attack * -4.;\n    return bob + attack;\n}\n\n////////////////////////////////////////////////////////////////\n// Persistent state ////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n// https://www.shadertoy.com/view/XsdGDX\n\nfloat is_inside(vec2 fragCoord, vec2 address)\n{\n    vec2 d = abs(fragCoord - (0.5 + address)) - 0.5;\n    return -max(d.x, d.y);\n}\n\n// changed from original: range is half-open\nfloat is_inside(vec2 fragCoord, vec4 address_range)\n{\n    vec2 d = abs(fragCoord - (address_range.xy + address_range.zw*0.5)) + -0.5*address_range.zw;\n    return -max(d.x, d.y);\n}\n\nvec4 load(vec2 address, sampler2D channel)\n{\n    return texelFetch(channel, ivec2(address), 0);\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, vec2 address, vec4 value)\n{\n    if (is_inside(fragCoord, address) > 0.0) fragColor = value;\n}\n\nvoid store(inout vec4 fragColor, vec2 fragCoord, vec4 address_range, vec4 value)\n{\n    if (is_inside(fragCoord, address_range) > 0.0) fragColor = value;\n}\n\nvoid assign(out float dst,\tfloat src)\t\t{ dst = src; }\nvoid assign(out float dst,\tint src)\t\t{ dst = float(src); }\nvoid assign(out int dst,\tint src)\t\t{ dst = src; }\nvoid assign(out int dst,\tfloat src)\t\t{ dst = int(src); }\nvoid assign(out vec2 dst,\tvec2 src)\t\t{ dst = src; }\nvoid assign(out vec3 dst,\tvec3 src)\t\t{ dst = src; }\n\n// Serialization codegen macros ////////////////////////////////\n\n#define FN_DEFINE_FIELD(pack, field_type, field_name, init)\t\tfield_type field_name;\n#define FN_CLEAR_FIELD(pack, field_type, field_name, init)\t\tassign(data.field_name, init);\n#define FN_LOAD_FIELD(pack, field_type, field_name, init)\t\tassign(data.field_name, v.pack);\n#define FN_STORE_FIELD(pack, field_type, field_name, init)\t\tassign(v.pack, data.field_name);\n\n////////////////////////////////////////////////////////////////////////////////\n#define DEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\\\n\tstruct type_name\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_DEFINE_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid from_vec4(out type_name data, const vec4 v)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_LOAD_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid to_vec4(out vec4 v, const type_name data)\t\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        v = vec4(0);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_STORE_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tvoid clear(out type_name data)\t\t\t\t\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        field_list(FN_CLEAR_FIELD)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n////////////////////////////////////////////////////////////////////////////////\n#define DEFINE_STRUCT(type_name, address, field_list)\t\t\t\t\t\t\t\\\n\tDEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\t\\\n    void load(out type_name data, sampler2D channel)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        from_vec4(data, load(address, channel));\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    void store(inout vec4 fragColor, vec2 fragCoord, const type_name data)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        if (is_inside(fragCoord, address) > 0.)\t\t\t\t\t\t\t\t\t\\\n        \tto_vec4(fragColor, data);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n////////////////////////////////////////////////////////////////////////////////\n#define DEFINE_STRUCT_RANGE(type_name, address_range, field_list)\t\t\t\t\\\n\tDEFINE_STRUCT_BASE(type_name, field_list)\t\t\t\t\t\t\t\t\t\\\n    void load(vec2 offset, out type_name data, sampler2D channel)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        from_vec4(data, load(address_range.xy + offset, channel));\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n    void store(inout vec4 fragColor, vec2 fragCoord, const type_name data)\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n        if (is_inside(fragCoord, address_range) > 0.)\t\t\t\t\t\t\t\\\n        \tto_vec4(fragColor, data);\t\t\t\t\t\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n////////////////////////////////////////////////////////////////////////////////\n\n#define LOAD(what) \t\t\t\tload(what, SETTINGS_CHANNEL)\n#define LOADR(ofs, what)   \t\tload(ofs, what, SETTINGS_CHANNEL)\n#define LOAD_PREV(what)\t\t\tif (iFrame==0) clear(what); else LOAD(what)\n#define LOAD_PREVR(ofs, what)\tif (iFrame==0) clear(what); else LOADR(ofs, what)\n\n// Persistent state addresses //////////////////////////////////\n        \nconst uvec2 LIGHTMAP_SIZE \t\t\t= uvec2(180,256);\n\nconst int\n\tNUM_MAP_AXIAL_BRUSHES           = 88,\n\tNUM_MAP_AXIAL_PLANES            = NUM_MAP_AXIAL_BRUSHES * 6,\n\tNUM_MAP_NONAXIAL_PLANES         = 502,\n\tNUM_MAP_NONAXIAL_BRUSHES        = 89,\n\tNUM_MAP_PLANES                  = NUM_MAP_AXIAL_PLANES + NUM_MAP_NONAXIAL_PLANES,\n\tNUM_MAP_PACKED_BRUSH_OFFSETS    = (NUM_MAP_NONAXIAL_BRUSHES + 3) / 4,\n\tNUM_LIGHTS                      = 61,\n\tNUM_LIGHTMAP_SAMPLES            = clamp(LIGHTMAP_AA_SAMPLES, 1, 128),\n\tNUM_LIGHTMAP_POSTPROCESS_STEPS  = 4,\n\tNUM_LIGHTMAP_REGIONS            = 4 /*RGBA*/,\n\tNUM_LIGHTMAP_FRAMES             = NUM_LIGHTMAP_SAMPLES * NUM_LIGHTMAP_REGIONS,\n\tNUM_WAIT_FRAMES                 = NUM_LIGHTMAP_FRAMES + NUM_LIGHTMAP_POSTPROCESS_STEPS;\n\nconst int\n    NUM_MAP_COLLISION_BRUSHES\t\t= 28,\n    NUM_MAP_COLLISION_PLANES\t\t= 167;\n\nconst vec2\n\tADDR_POSITION\t\t\t\t\t= vec2(0,0),\n\tADDR_VELOCITY\t\t\t\t\t= vec2(0,1),\t// W=jump key state\n\tADDR_GROUND_PLANE\t\t\t\t= vec2(0,2),\n\tADDR_CAM_POS\t\t\t\t\t= vec2(1,0),\n\tADDR_TRANSITIONS\t\t\t\t= vec2(1,1),\t// X=stair step offset; Y=bob phase; Z=attack phase; W=# of shots fired\n\tADDR_CAM_ANGLES\t\t\t\t\t= vec2(1,2),\n    ADDR_ANGLES\t\t\t\t\t\t= vec2(2,0),\t// X=yaw; Y=pitch; Z=ideal pitch; W=autopitch delay\n\n    ADDR_PREV_MOUSE\t\t\t\t\t= vec2(3,1),\n\tADDR_PREV_CAM_POS\t\t\t\t= vec2(4,0),\n\tADDR_PREV_CAM_ANGLES\t\t\t= vec2(4,1),\n\tADDR_RESOLUTION\t\t\t\t\t= vec2(5,0),\t// XY=resolution; Z=flags\n\tADDR_ATLAS_INFO\t\t\t\t\t= vec2(5,1),\t// X=max mip; Y=lod\n\tADDR_PERF_STATS\t\t\t\t\t= vec2(6,0),\t// X=filtered frame time; W=UI state\n\tADDR_GAME_STATE\t\t\t\t\t= vec2(6,1),\t// X=level; Y=time left; Z=score; W=last shot #\n\tADDR_LIGHTING\t\t\t\t\t= vec2(6,2),\n\tADDR_TIMING\t\t\t\t\t\t= vec2(7,0),\n    ADDR_MENU\t\t\t\t\t\t= vec2(7,1),\n    ADDR_OPTIONS\t\t\t\t\t= vec2(7,2);\n\nconst vec4\n\tADDR_RANGE_PHYSICS\t\t\t\t= vec4(0,0, 3,3),\n\tADDR_RANGE_PERF_HISTORY\t\t\t= vec4(8,0, 192,1),\n\tADDR_RANGE_SHOTGUN_PELLETS\t\t= vec4(8,1, 24,1),\n    ADDR_RANGE_TARGETS\t\t\t\t= vec4(8,2, NUM_TARGETS+1,1),\t// X=level; Y=last shot #; Z=hits\n    ADDR_RANGE_LIGHTS\t\t\t\t= vec4(0,3, NUM_LIGHTS,1),\n    ADDR_RANGE_COLLISION_PLANES\t\t= vec4(0,4, NUM_MAP_COLLISION_PLANES,1),\n\tADDR_RANGE_NONAXIAL_PLANES\t\t= vec4(0,8, 128,(NUM_MAP_NONAXIAL_PLANES+127)/128),\n    ADDR_RANGE_LMAP_TILES\t\t\t= vec4(0,ADDR_RANGE_NONAXIAL_PLANES.y + ADDR_RANGE_NONAXIAL_PLANES.w,\n                                           128, (NUM_MAP_PLANES+127)/128),\n    ADDR_RANGE_ATLAS_MIP0\t\t\t= vec4(ATLAS_OFFSET, ATLAS_SIZE),\n    ADDR_RANGE_ATLAS_CHAIN\t\t\t= vec4(ATLAS_OFFSET, ATLAS_CHAIN_SIZE),\n\tADDR_RANGE_PARAM_BOUNDS\t\t\t= vec4(0,0, ATLAS_CHAIN_SIZE + ATLAS_OFFSET);\n\n// Secondary buffer (Buffer C) addresses\nconst vec4\n    ADDR2_RANGE_LIGHTMAP\t\t\t= vec4(0,0,\t\tLIGHTMAP_SIZE.x, LIGHTMAP_SIZE.y / 4u),\n    ADDR2_RANGE_TEX_OPTIONS\t\t\t= vec4(0,ADDR2_RANGE_LIGHTMAP.w, 144,24),\n    ADDR2_RANGE_TEX_QUAKE\t\t\t= vec4(0,ADDR2_RANGE_TEX_OPTIONS.y+ADDR2_RANGE_TEX_OPTIONS.w, 144,32),\n    ADDR2_RANGE_FONT\t\t\t\t= vec4(ADDR2_RANGE_TEX_OPTIONS.zy, 64,56),\n    ADDR2_RANGE_PARAM_BOUNDS\t\t= vec4(0,0, \tmax(ADDR2_RANGE_LIGHTMAP.xy + ADDR2_RANGE_LIGHTMAP.zw,\n                                                        max(ADDR2_RANGE_TEX_QUAKE.xy + ADDR2_RANGE_TEX_QUAKE.zw,\n                                                           \tADDR2_RANGE_FONT.xy + ADDR2_RANGE_FONT.zw)));\nconst vec2\n    SKY_TARGET_OFFSET\t\t\t\t= vec2(NUM_TARGETS, 0);\n\nconst int\n    RESOLUTION_FLAG_CHANGED\t\t\t= 1 << 0,\n    RESOLUTION_FLAG_THUMBNAIL\t\t= 1 << 1;\n\n// Persistent state structs (x-macros) /////////////////////////\n\n#define PERF_STATS_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tsmooth_frametime,\t0.)\t\t\\\n\t_(w, float,\tui_state,\t\t\t0.)\nDEFINE_STRUCT(PerfStats, ADDR_PERF_STATS, PERF_STATS_FIELD_LIST)\n\n#define TRANSITIONS_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tstair_step,\t\t0.)\t\t\t\\\n\t_(y, float,\tbob_phase,\t\t0.)\t\t\t\\\n\t_(z, float,\tattack,\t\t\t0.)\t\t\t\\\n\t_(w, float,\tshot_no,\t\t0.)\nDEFINE_STRUCT(Transitions, ADDR_TRANSITIONS, TRANSITIONS_FIELD_LIST)\n\n#define TARGET_FIELD_LIST(_)\t\t\t\t\\\n    _(x, float,\tlevel,\t\t\t0.)\t\t\t\\\n\t_(y, float,\tshot_no,\t\t0.)\t\t\t\\\n\t_(z, float,\thits,\t\t\t0.)\nDEFINE_STRUCT_RANGE(Target, ADDR_RANGE_TARGETS, TARGET_FIELD_LIST)\n        \n#define LIGHTING_FIELD_LIST(_)\t\t\t\t\t\\\n\t_(x, int,\tnum_lights,\t\tNUM_LIGHTS)\t\t\\\n\t_(y, int,\tnum_tiles,\t\tNUM_MAP_PLANES)\t\\\n\t_(z, float, bake_time,\t\t0.)\t\t\t\t\\\n\t_(w, float, progress,\t\t0.)\nDEFINE_STRUCT(Lighting, ADDR_LIGHTING, LIGHTING_FIELD_LIST)\n\n////////////////////////////////////////////////////////////////\n\n#define GAME_STATE_FIELD_LIST(_)\t\t\t\\\n    _(x, float,\tlevel,\t\t\t0.)\t\t\t\\\n\t_(y, float,\ttime_left,\t\t0.)\t\t\t\\\n\t_(z, float,\ttargets_left,\t0.)\nDEFINE_STRUCT(GameState, ADDR_GAME_STATE, GAME_STATE_FIELD_LIST)\n\nbool in_progress(GameState game_state) { return game_state.level > 0.; }\n\n////////////////////////////////////////////////////////////////\n\nconst int\n    OPTION_TYPE_SLIDER\t\t\t\t\t\t= 0,\n    OPTION_TYPE_TOGGLE\t\t\t\t\t\t= 1,\n\n\tOPTION_FLAG_INVERT_MOUSE\t\t\t\t= 1 << 0,\n\tOPTION_FLAG_SHOW_FPS\t\t\t\t\t= 1 << 1,\n\tOPTION_FLAG_SHOW_FPS_GRAPH\t\t\t\t= 1 << 2,\n\tOPTION_FLAG_SHOW_LIGHTMAP\t\t\t\t= 1 << 3,\n\tOPTION_FLAG_SHOW_WEAPON\t\t\t\t\t= 1 << 4,\n\tOPTION_FLAG_NOCLIP\t\t\t\t\t\t= 1 << 5,\n\tOPTION_FLAG_MOTION_BLUR\t\t\t\t\t= 1 << 6,\n\tOPTION_FLAG_TEXTURE_FILTER\t\t\t\t= 1 << 7,\n\tOPTION_FLAG_LIGHT_SHAFTS\t\t\t\t= 1 << 8,\n\tOPTION_FLAG_CRT_EFFECT\t\t\t\t\t= 1 << 9,\n    \n    DEFAULT_OPTION_FLAGS\t\t\t\t\t= OPTION_FLAG_SHOW_WEAPON | OPTION_FLAG_MOTION_BLUR;\n\n#define MENU_STATE_FIELD_LIST(_)\t\t\t\\\n\t_(x, int,\tselected,\t\t0)\t\t\t\\\n\t_(y, int,\topen,\t\t\t0)\nDEFINE_STRUCT(MenuState, ADDR_MENU, MENU_STATE_FIELD_LIST)\n\n#define OPTIONS_FIELD_LIST(_)\t\t\t\t\\\n\t_(x, float, brightness,\t\t5.)\t\t\t\\\n\t_(y, float, screen_size,\t10.)\t\t\\\n\t_(z, float, sensitivity,\t5.)\t\t\t\\\n\t_(w, int,\tflags,\t\t\tDEFAULT_OPTION_FLAGS)\nDEFINE_STRUCT(Options, ADDR_OPTIONS, OPTIONS_FIELD_LIST)\n\nstruct MenuOption { int data; };\nint get_option_type(MenuOption option)\t\t{ return option.data & 1; }\nint get_option_field(MenuOption option)\t\t{ return (option.data >> 1) & 3; }\nint get_option_range(MenuOption option)\t\t{ return option.data >> 3; }\n\n#define MENU_OPTION_SLIDER(index)\t\t\tMenuOption(OPTION_TYPE_SLIDER | ((index) << 1))\n#define MENU_OPTION_TOGGLE(index, bit)\t\tMenuOption(OPTION_TYPE_TOGGLE | ((index) << 1) | ((bit) << 3))\n\nconst MenuOption\n    // must match Options struct defined above\n\tOPTION_DEF_BRIGHTNESS\t\t\t\t\t= MENU_OPTION_SLIDER(0),\n    OPTION_DEF_SCREEN_SIZE\t\t\t\t\t= MENU_OPTION_SLIDER(1),\n\tOPTION_DEF_SENSITIVITY\t\t\t\t\t= MENU_OPTION_SLIDER(2),\n    OPTION_DEF_INVERT_MOUSE\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_INVERT_MOUSE),\n    OPTION_DEF_SHOW_FPS\t\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_FPS),\n    OPTION_DEF_SHOW_FPS_GRAPH\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_FPS_GRAPH),\n    OPTION_DEF_MOTION_BLUR\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_MOTION_BLUR),\n    OPTION_DEF_TEXTURE_FILTER\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_TEXTURE_FILTER),\n    OPTION_DEF_SHOW_LIGHTMAP\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_LIGHTMAP),\n    OPTION_DEF_SHOW_WEAPON\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_SHOW_WEAPON),\n    OPTION_DEF_NOCLIP\t\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_NOCLIP),\n    OPTION_DEF_LIGHT_SHAFTS\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_LIGHT_SHAFTS),\n    OPTION_DEF_CRT_EFFECT\t\t\t\t\t= MENU_OPTION_TOGGLE(3, OPTION_FLAG_CRT_EFFECT),\n\n    // must match string table used in draw_menu (Image tab)\n\tOPTION_DEFS[] = MenuOption[]\n\t(\n        OPTION_DEF_SENSITIVITY,\n        OPTION_DEF_INVERT_MOUSE,\n        OPTION_DEF_BRIGHTNESS,\n        OPTION_DEF_SCREEN_SIZE,\n        OPTION_DEF_SHOW_FPS,\n        OPTION_DEF_SHOW_FPS_GRAPH,\n        OPTION_DEF_TEXTURE_FILTER,\n        OPTION_DEF_MOTION_BLUR,\n        OPTION_DEF_LIGHT_SHAFTS,\n        OPTION_DEF_CRT_EFFECT,\n        OPTION_DEF_SHOW_LIGHTMAP,\n        OPTION_DEF_SHOW_WEAPON,\n        OPTION_DEF_NOCLIP\n\t)\n;\n\nconst int NUM_OPTIONS\t\t\t\t\t\t= OPTION_DEFS.length();\nMenuOption get_option(int index)\t\t\t{ return OPTION_DEFS[index]; }\n\nfloat get_downscale(Options options)\t\t{ return max(6. - options.screen_size * .5, 1.); }\n\n////////////////////////////////////////////////////////////////\n\nconst int\n    TIMING_FLAG_PAUSED\t\t\t\t\t\t= 1 << 0;\n\n#define TIMING_FIELD_LIST(_)\t\t\t\t\\\n    _(x, float,\tanim,\t\t\t0.)\t\t\t\\\n\t_(y, float,\tprev,\t\t\t0.)\t\t\t\\\n\t_(z, int,\tflags,\t\t\t0)\nDEFINE_STRUCT(Timing, ADDR_TIMING, TIMING_FIELD_LIST)\n\n////////////////////////////////////////////////////////////////\n\nvec4 load_camera_pos(sampler2D settings, bool thumbnail)\n{\n    if (!is_demo_mode_enabled(thumbnail))\n        return load(ADDR_CAM_POS, settings);\n    return vec4(get_demo_scene().pos, 0);\n}\n\nvec4 load_camera_angles(sampler2D settings, bool thumbnail)\n{\n    if (!is_demo_mode_enabled(thumbnail))\n        return load(ADDR_CAM_ANGLES, settings);\n    return vec4(get_demo_scene().angles, 0, 0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n// Buffer A: persistent state handling\n// - procedural texture generation\n// - mipmap generation\n// - player input/physics\n// - partial map data serialization\n// - perf stats\n////////////////////////////////////////////////////////////////\n\n// config.cfg //////////////////////////////////////////////////\n\n#define INVERT_MOUSE\t\t\t0\n#define NOCLIP\t\t\t\t\t0\n\n#define MOVE_FORWARD_KEY1\t\tKEY_W\n#define MOVE_FORWARD_KEY2\t\tKEY_UP\n#define MOVE_FORWARD_KEY3\t\tKEY_Z\t\t\t// azerty\n#define MOVE_LEFT_KEY1\t\t\tKEY_A\n#define MOVE_LEFT_KEY2\t\t\tKEY_Q\t\t\t// azerty\n#define MOVE_BACKWARD_KEY1\t\tKEY_S\n#define MOVE_BACKWARD_KEY2\t\tKEY_DOWN\n#define MOVE_RIGHT_KEY1\t\t\tKEY_D\n#define MOVE_RIGHT_KEY2\t\t\tunassigned\n#define MOVE_UP_KEY1\t\t\tKEY_SPACE\n#define MOVE_UP_KEY2\t\t\tunassigned\n#define MOVE_DOWN_KEY1\t\t\tKEY_C\n#define MOVE_DOWN_KEY2\t\t\tunassigned\n#define RUN_KEY1\t\t\t\tKEY_SHIFT\n#define RUN_KEY2\t\t\t\tunassigned\n#define LOOK_LEFT_KEY1\t\t\tKEY_LEFT\n#define LOOK_LEFT_KEY2\t\t\tunassigned\n#define LOOK_RIGHT_KEY1\t\t\tKEY_RIGHT\n#define LOOK_RIGHT_KEY2\t\t\tunassigned\n#define LOOK_UP_KEY1\t\t\tKEY_PGDN\n#define LOOK_UP_KEY2\t\t\tunassigned\n#define LOOK_DOWN_KEY1\t\t\tKEY_DELETE\n#define LOOK_DOWN_KEY2\t\t\tunassigned\n#define CENTER_VIEW_KEY1\t\tKEY_END\n#define CENTER_VIEW_KEY2\t\tunassigned\n#define STRAFE_KEY1\t\t\t\tKEY_ALT\n#define STRAFE_KEY2\t\t\t\tunassigned\n#define RESPAWN_KEY1\t\t\tKEY_BKSP\n#define RESPAWN_KEY2\t\t\tKEY_HOME\n#define ATTACK_KEY1\t\t\t\tKEY_E\n#define ATTACK_KEY2\t\t\t\tKEY_F\n\n#define MENU_KEY1\t\t\t\tKEY_ESC\n#define MENU_KEY2\t\t\t\tKEY_TAB\n\n#define SHOW_PERF_STATS_KEY\t\tKEY_P\n#define TOGGLE_TEX_FILTER_KEY\tKEY_T\n#define TOGGLE_LIGHT_SHAFTS_KEY\tKEY_L\n#define TOGGLE_CRT_EFFECT_KEY\tKEY_V\n\nconst float\n\tSENSITIVITY\t\t\t\t\t= 1.0,\n\tMOUSE_FILTER\t\t\t\t= 0.0,\t\t// mostly for video recording\n\tTURN_SPEED\t\t\t\t\t= 180.0,\t// keyboard turning rate, in degrees per second\n\tWALK_SPEED\t\t\t\t\t= 400.0,\n\tJUMP_SPEED\t\t\t\t\t= 270.0,\n    STAIR_CLIMB_SPEED\t\t\t= 128.0,\n    STOP_SPEED\t\t\t\t\t= 100.0,\n    \n    GROUND_ACCELERATION\t\t\t= 10.0,\n    AIR_ACCELERATION\t\t\t= 1.0,\n\n    GROUND_FRICTION\t\t\t\t= 4.0,\n\tNOCLIP_START_FRICTION\t\t= 18.0,\n\tNOCLIP_STOP_FRICTION\t\t= 12.0,\n\n    ROLL_ANGLE\t\t\t\t\t= 2.0,\t\t// maximum roll angle when moving sideways\n\tROLL_SPEED\t\t\t\t\t= 200.0,\t// sideways speed at which the roll angle reaches its maximum\n\tBOB_CYCLE\t\t\t\t\t= 0.6,\t\t// seconds\n\tBOB_SCALE\t\t\t\t\t= 0.02,\n\n    AUTOPITCH_DELAY\t\t\t\t= 2.0,\t\t// seconds between last mouse look and automatic pitch adjustment\n    STAIRS_PITCH\t\t\t\t= 10.0,\n\n    RECOIL_ANGLE\t\t\t\t= 2.0,\n    WEAPON_SPREAD\t\t\t\t= 0.05,\t\t// slightly higher than in Quake, for dramatic effect\n    RATE_OF_FIRE\t\t\t\t= 2.0;\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n//#define GENERATE_TEXTURES\t\t(1<<MATERIAL_WIZMET1_1) | (1<<MATERIAL_WBRICK1_5)\n#define GENERATE_TEXTURES\t\t-1\n#define ALWAYS_REFRESH\t\t\t0\n#define WRITE_MAP_DATA\t\t\t1\n#define ENABLE_MENU\t\t\t\t1\n\n////////////////////////////////////////////////////////////////\n\nconst int\n\tKEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70, KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74,\n\tKEY_K = 75, KEY_L = 76, KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82, KEY_S = 83, KEY_T = 84,\n\tKEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88, KEY_Y = 89, KEY_Z = 90,\n\n    KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51, KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,\n\n\tKEY_PLUS\t\t= 187,\n\tKEY_MINUS\t\t= 189,\n\tKEY_EQUAL\t\t= KEY_PLUS,\n\n    // firefox...\n    KEY_PLUS_FF\t\t= 61,\n    KEY_MINUS_FF\t= 173, \n\n    KEY_SHIFT\t\t= 16,\n\tKEY_CTRL\t\t= 17,\n\tKEY_ALT\t\t\t= 18,\n    \n    KEY_ESC\t\t\t= 27,\n\t\n    KEY_BKSP \t\t=  8,\n    KEY_TAB\t\t\t=  9,\n\tKEY_END\t\t\t= 35,\n\tKEY_HOME\t\t= 36,\n\tKEY_INS\t\t\t= 45,\n\tKEY_DEL\t\t\t= 46,\n\tKEY_INSERT\t\t= KEY_INS,\n\tKEY_DELETE\t\t= KEY_DEL,\n\n\tKEY_ENTER\t\t= 13,\n\tKEY_SPACE \t\t= 32,\n\tKEY_PAGE_UP \t= 33,\n\tKEY_PAGE_DOWN \t= 34,\n\tKEY_PGUP \t\t= KEY_PAGE_UP,\n\tKEY_PGDN \t\t= KEY_PAGE_DOWN,\n\n\tKEY_LEFT\t\t= 37,\n\tKEY_UP\t\t\t= 38,\n\tKEY_RIGHT\t\t= 39,\n\tKEY_DOWN\t\t= 40,\n\t\n\tunassigned\t\t= 0;\n\n////////////////////////////////////////////////////////////////\n\nfloat is_key_down(int code)\t\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 0), 0).r : 0.; }\nfloat is_key_pressed(int code)\t\t\t{ return code != 0 ? texelFetch(iChannel0, ivec2(code, 1), 0).r : 0.; }\n\n////////////////////////////////////////////////////////////////\n\nfloat cmd(int code1, int code2)\t\t\t{ return max(is_key_down(code1), is_key_down(code2)); }\nfloat cmd(int c1, int c2, int c3)\t\t{ return max(is_key_down(c1), max(is_key_down(c2), is_key_down(c3))); }\nfloat cmd_press(int code1, int code2)\t{ return max(is_key_pressed(code1), is_key_pressed(code2)); }\n\nfloat cmd_move_forward()\t\t\t\t{ return cmd(MOVE_FORWARD_KEY1,\t\tMOVE_FORWARD_KEY2,\t\tMOVE_FORWARD_KEY3); }\nfloat cmd_move_backward()\t\t\t\t{ return cmd(MOVE_BACKWARD_KEY1,\tMOVE_BACKWARD_KEY2); }\nfloat cmd_move_left()\t\t\t\t\t{ return cmd(MOVE_LEFT_KEY1,\t\tMOVE_LEFT_KEY2); }\nfloat cmd_move_right()\t\t\t\t\t{ return cmd(MOVE_RIGHT_KEY1,\t\tMOVE_RIGHT_KEY2); }\nfloat cmd_move_up()\t\t\t\t\t\t{ return cmd(MOVE_UP_KEY1,\t\t\tMOVE_UP_KEY2); }\nfloat cmd_move_down()\t\t\t\t\t{ return cmd(MOVE_DOWN_KEY1,\t\tMOVE_DOWN_KEY2); }\nfloat cmd_run()\t\t\t\t\t\t\t{ return cmd(RUN_KEY1,\t\t\t\tRUN_KEY2); }\nfloat cmd_look_left()\t\t\t\t\t{ return cmd(LOOK_LEFT_KEY1,\t\tLOOK_LEFT_KEY2); }\nfloat cmd_look_right()\t\t\t\t\t{ return cmd(LOOK_RIGHT_KEY1,\t\tLOOK_RIGHT_KEY2); }\nfloat cmd_look_up()\t\t\t\t\t\t{ return cmd(LOOK_UP_KEY1,\t\t\tLOOK_UP_KEY2); }\nfloat cmd_look_down()\t\t\t\t\t{ return cmd(LOOK_DOWN_KEY1,\t\tLOOK_DOWN_KEY2); }\nfloat cmd_center_view()\t\t\t\t\t{ return cmd(CENTER_VIEW_KEY1,\t\tCENTER_VIEW_KEY2); }\nfloat cmd_strafe()\t\t\t\t\t\t{ return cmd(STRAFE_KEY1,\t\t\tSTRAFE_KEY2); }\nfloat cmd_respawn()\t\t\t\t\t\t{ return cmd_press(RESPAWN_KEY1,\tRESPAWN_KEY2); }\nfloat cmd_attack()\t\t\t\t\t\t{ return cmd(ATTACK_KEY1,\t\t\tATTACK_KEY2); }\nfloat cmd_menu()\t\t\t\t\t\t{ return cmd_press(MENU_KEY1,\t\tMENU_KEY2); }\n\nfloat is_input_enabled()\t\t\t\t{ return step(INPUT_ACTIVE_TIME, g_time); }\n\n////////////////////////////////////////////////////////////////\n\n#define SETTINGS_CHANNEL iChannel1\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n////////////////////////////////////////////////////////////////\n//\n// World data\n//\n// Generated from a trimmed/tweaked version of\n// the original map by John Romero\n// https://rome.ro/news/2016/2/14/quake-map-sources-released\n//\n// Split between Buffer A and B to even out compilation time\n////////////////////////////////////////////////////////////////\n\nconst float H0=0.707107,H1=0.992278,H2=0.124035,H3=0.83205,H4=0.5547,H5=0.948683,H6=0.316228,H7=0.894427,\nH8=0.447214,H9=0.863779,H10=0.503871,H11=0.913812,H12=0.406138,H13=0.970143,H14=0.242536;\n\n#define V(x,y,z,w) vec4(x,y,z,w),\n#define D(w) V( 1,0,0,float(w)*16.+-1040.)\n#define G(w) V(-1,0,0,float(w)*16.+48.)\n#define E(w) V(0, 1,0,float(w)*16.+-1424.)\n#define H(w) V(0,-1,0,float(w)*16.+176.)\n#define F(w) V(0,0, 1,float(w)*16.+-336.)\n#define I(w) V(0,0,-1,float(w)*16.+-192.)\n#define X(v0,v1) D(v0)G(v1)\n#define Y(v0,v1) E(v0)H(v1)\n#define Z(v0,v1) F(v0)I(v1)\n\nWRAP(Planes,planes,vec4,NUM_MAP_NONAXIAL_PLANES+1)(X(6.5,53.5)Y(55,21)V(.6,0,-.8,-574.4)V(-.6,0,.8,561.6)X(1.5,58.5)Y(55,21)V(.6\n,0,.8,-590.4)V(-.6,0,-.8,577.6)Z(20,10)V(H0,H0,0,-1052.17)V(H0,-H0,0,-305.47)V(H3,0,H4,-781.018)V(-H3,0,-H4,767.705)Z(20,10)V(H3\n,0,-H4,-829.832)V(-H0,H0,0,305.47)V(-H0,-H0,0,1052.17)V(-H3,0,H4,816.519)Z(20,10)V(H0,-H0,0,-305.47)V(-H0,-H0,0,1052.17)V(0,H3,\n-H4,-470.386)V(0,-H3,H4,457.073)Z(20,10)V(H0,H0,0,-1052.17)V(-H0,H0,0,305.47)V(0,H3,H4,-421.572)V(0,-H3,-H4,408.259)X(56,4)Y(\n57.5,18.5)V(0,.6,-.8,-315.2)V(0,-.6,.8,302.4)X(56,4)Y(52.5,23.5)V(0,.6,.8,-331.2)V(0,-.6,-.8,318.4)X(58.5,1.5)Y(55,21)V(.6,0,-.8\n,-75.2)V(-.6,0,.8,62.4)X(53.5,6.5)Y(55,21)V(.6,0,.8,-91.2)V(-.6,0,-.8,78.4)Z(20,10)V(H0,H0,0,-463.862)V(H0,-H0,0,282.843)V(H3,0,\nH4,-88.752)V(-H3,0,-H4,75.4392)Z(20,10)V(H0,-H0,0,282.843)V(-H0,-H0,0,463.862)V(0,H3,-H4,-470.386)V(0,-H3,H4,457.073)Z(20,10)V(\nH3,0,-H4,-137.566)V(-H0,H0,0,-282.843)V(-H0,-H0,0,463.862)V(-H3,0,H4,124.253)X(4,56)Y(57.5,18.5)V(0,.6,-.8,-315.2)V(0,-.6,.8,\n302.4)Z(20,10)V(H0,H0,0,-463.862)V(-H0,H0,0,-282.843)V(0,H3,H4,-421.572)V(0,-H3,-H4,408.259)X(4,56)Y(52.5,23.5)V(0,.6,.8,-331.2)\nV(0,-.6,-.8,318.4)Y(59,12)Z(22,10)V(H0,H0,0,-837.214)V(-H0,H0,0,-67.8823)Y(55,12)Z(24,8)V(H0,H0,0,-927.724)V(-H0,H0,0,-158.392)Y\n(63,12)Z(21,11)V(H0,H0,0,-791.96)V(-H0,H0,0,-22.6274)Y(57,12)Z(23,9)V(H0,H0,0,-882.469)V(-H0,H0,0,-113.137)X(1,49)Y(63,13)F(2)V(\n-H10,0,-H9,667.989)X(49,1)Y(63,13)F(2)V(H10,0,-H9,119.777)X(30,30)Y(65,1)F(2)V(0,H10,-H9,55.2819)X(46,14)Y(65,1)F(2)V(0,H10,-H9,\n55.2819)X(14,46)Y(65,1)F(2)V(0,H10,-H9,55.2819)X(14.5,14.5)Y(75.5,1)V(0,H6,H5,-189.737)V(0,H6,-H5,22.7684)X(1,59.5)Z(7.5,8)V(-H6\n,H5,0,-78.4245)V(-H6,-H5,0,680.522)Y(75.5,1)Z(7.5,12)V(H5,H6,0,-333.936)V(-H5,H6,0,166.968)X(59.5,1)Z(7.5,8)V(H6,H5,0,-422.48)V(\nH6,-H5,0,336.466)Y(75.5,1)Z(7.5,12)V(H5,H6,0,-865.199)V(-H5,H6,0,698.231)D(14)H(14)Z(1,30)V(-H0,H0,0,271.529)G(14)H(14)Z(1,30)V(\nH0,H0,0,-497.803)G(1)H(1)Z(5,8)V(H0,H0,0,-316.784)D(1)H(1)Z(5,8)V(-H0,H0,0,452.548)X(7,7)H(1)F(2)V(0,H10,-H9,69.1023)X(49,1)Y(47\n,29)F(2)V(H10,0,-H9,119.777)X(59.5,1)Y(49,15)V(H6,0,H5,-149.259)V(H6,0,-H5,63.2456)X(59.5,1)Z(7.5,8)V(H6,H5,0,-665.343)V(H6,-H5,\n0,579.329)G(1)Y(41,7)F(2)V(H10,0,-H9,133.598)X(1,49)Y(47,29)F(2)V(-H10,0,-H9,667.989)X(1,59.5)Y(49,15)V(-H6,0,H5,194.796)V(-H6,0\n,-H5,407.301)X(1,59.5)Z(7.5,8)V(-H6,H5,0,-321.287)V(-H6,-H5,0,923.385)D(1)Y(41,7)F(2)V(-H10,0,-H9,681.809)Y(33,41)Z(24.5,7.5)V(\nH7,H8,0,-1230.73)V(-H7,H8,0,314.838)X(46,15)H(37)Z(25,7)V(H7,H8,0,-658.298)X(42,19)H(37)Z(25,7)V(H8,H7,0,-887.272)H(37)Z(26,1)V(\nH0,H0,0,-848.528)V(-H0,H0,0,-294.156)H(37)Z(26,1)V(H0,H0,0,-1063.49)V(-H0,H0,0,-79.196)G(7)H(37)Z(26,1)V(H0,H0,0,-678.823)D(2)H(\n37)Z(26,1)V(-H0,H0,0,147.078)X(3,42)Y(37,37)Z(25,7)V(-H8,H7,0,-400.703)X(23,36)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118\n)X(36,23)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118)X(27,27)Y(29,41)V(0,H14,-H13,-271.64)V(0,-H14,H13,256.118)E(21)Z(24,8\n)V(H7,-H8,0,-343.46)V(-H4,-H3,0,1402.28)H(45)Z(24.5,7.5)V(.8,.6,0,-1280)V(-H4,H3,0,-257.381)H(45)Z(24.5,7.5)V(H7,H8,0,-1187.8)V(\n-H0,H0,0,-45.2549)E(21)Z(24,8)V(H0,-H0,0,135.764)V(-H7,-H8,0,1245.04)H(45)Z(24.5,7.5)V(H4,H3,0,-1207.03)V(-H7,H8,0,314.838)E(21)\nZ(24,8)V(H4,-H3,0,434.885)V(-.8,-.6,0,1292.8)Y(17,57)Z(24,8)V(H7,-H8,0,-343.46)V(-H7,-H8,0,1202.11)D(22)E(12)Z(24,1)V(-H0,-H0,0,\n1335.02)X(2,2)Y(1,65)Z(23,9)V(-.524097,-.851658,0,1186.56)G(41)E(12)Z(25,1)V(H0,-H0,0,350.725)D(2)E(12)Z(25,1)V(-H0,-H0,0,\n1561.29)Y(37,37)Z(5,24)V(.8,0,-.6,-217.6)V(-.8,0,-.6,409.6)X(51,2)Y(25,51)F(2)V(H12,0,-H11,172.203)X(22,31)Y(25,51)F(2)V(-H12,0,\n-H11,484.117)Y(8,66)Z(5,24)V(.8,0,-.6,-217.6)V(-.8,0,-.6,409.6)Y(12,41)Z(2,27)V(H12,0,-H11,56.8594)V(-H12,0,-H11,368.774)X(31,11\n)Y(25,51)Z(2,26)V(H12,0,-H11,42.2384)V(-H12,0,-H11,354.153)G(3)Y(37,37)F(5)V(.501036,0,-.865426,106.812)G(3)Y(8,66)F(5)V(.501036\n,0,-.865426,106.812)X(22,2)E(1)F(2.5)V(0,-.393919,-.919145,782.586)D(22)Y(12,41)F(2)V(-H12,0,-H11,498.738)G(2)Y(12,41)F(2)V(H12,\n0,-H11,186.824)Y(37,37)Z(5,24)V(.8,0,-.6,-460.8)V(-.8,0,-.6,652.8)D(2)V(-H2,H1,0,-1002.2)V(-H2,-H1,0,1220.5)V(-H2,0,H1,-128.996)\nV(-H2,0,-H1,347.297)G(41)V(H2,H1,0,-992.278)V(H2,-H1,0,785.884)V(H2,0,H1,-254.023)V(H2,0,-H1,47.6293)D(2)V(-H2,H1,0,-811.683)V(\n-H2,-H1,0,1029.98)V(-H2,0,H1,-41.6757)V(-H2,0,-H1,259.977)D(2)V(-H2,H1,0,-875.189)V(-H2,-H1,0,1093.49)V(-H2,0,H1,-128.996)V(-H2,\n0,-H1,347.297)G(41)V(H2,H1,0,-1151.04)V(H2,-H1,0,944.649)V(H2,0,H1,-341.344)V(H2,0,-H1,134.95)D(3)Y(37,37)F(5)V(-.501036,0,\n-.865426,651.939)Y(8,66)Z(5,24)V(.8,0,-.6,-460.8)V(-.8,0,-.6,652.8)G(41)V(H2,H1,0,-1278.05)V(H2,-H1,0,1071.66)V(H2,0,H1,-341.344\n)V(H2,0,-H1,134.95)E(1)V(H1,-H2,0,-591.398)V(-H1,-H2,0,916.865)V(0,-H2,H1,-75.4131)V(0,-H2,-H1,400.88)E(1)V(H1,-H2,0,-797.791)V(\n-H1,-H2,0,1123.26)V(0,-H2,H1,-75.4131)V(0,-H2,-H1,400.88)E(1)V(H1,-H2,0,-694.594)V(-H1,-H2,0,1020.06)V(0,-H2,H1,-51.5984)V(0,-H2\n,-H1,377.066)D(3)Y(8,66)F(5)V(-.501036,0,-.865426,651.939)vec4(0)));\n\n#define L(x,y,z) vec4(x,y,z,300),\n#define LR(x,y,z,r) vec4(x,y,z,r),\n\nWRAP(Lights,lights,vec4,NUM_LIGHTS+1)(LR(224,880,248,200)LR(224,1008,248,200)LR(224,1136,248,200)L(88,1024,64)L(362,1034,20)L(\n200,712,120)LR(128,624,-32,220)LR(128,528,-48,220)L(126,526,12)LR(128,432,-32,220)LR(224,528,-32,220)L(224,352,120)L(864,352,120\n)L(544,312,104)LR(544,496,40,250)LR(544,584,424,500)LR(960,432,-32,220)LR(864,528,-32,220)LR(960,624,-32,220)L(958,526,12)L(394,\n762,84)LR(544,864,-8,200)L(698,762,84)LR(960,528,-48,220)LR(408,928,96,120)LR(680,1056,96,120)L(544,1016,72)LR(544,1136,248,200)\nLR(544,880,248,200)L(336,1152,-144)L(336,1024,-144)L(336,896,-144)LR(448,1152,-56,120)LR(480,1032,-152,200)LR(488,840,-152,200)\nLR(600,840,-152,200)LR(608,1032,-152,200)LR(608,1120,-152,200)LR(544,1192,-152,200)L(728,1080,-144)L(984,1080,-144)L(984,904,-\n144)L(728,904,-144)LR(864,888,-32,120)LR(720,992,64,120)LR(864,1112,-24,150)LR(992,928,64,120)LR(992,1056,128,120)L(976,928,312)\nL(976,1056,312)LR(976,1184,312,200)L(736,992,312)L(736,1120,312)LR(736,864,312,200)LR(720,1120,128,120)L(912,1360,296)L(808,1360\n,296)L(888,712,120)L(864,1336,48)L(544,1336,48)LR(232,1336,48,350)vec4(0)));\n\n// Lightmap layout /////////////////////////////////////////////\n\n#define O2 0,0\n#define O4 O2,O2\n\nWRAP(LightmapTiles,LIGHTMAP_TILES,int,NUM_MAP_PLANES)(O2,0x8f4187a,0,1725<<18,0,68020022,32849,16467,85,51243860,0,114779,0,\n28927,68013914,53467,O2,119,201,827,51242336,0,68024118,49153,81923,65541,64795,0,114699,0,12351,68020528,51246926,O2,16391,\n98313,114699,57403,O2,68010330,113,147,51246920,0,201,0,877,99231,57403,0,57006602,28673,0,50935528,420042758,913857,122891,\n118797,0,487963,159755,107069,O2,59542636,474001,42751174,3665,291297534,O4,O2,381,O4,O2,0xd84711e,O2,0,34466650,45217,39113892,\n0,55904432,O2,0,99887226,0,0xcf4007a,O2,0,34972748,0,85321998,O2,54855936,51493674,134753,286368892,200817,553,0,190651,186557,\n200891,77837,0x70dd504,147585,0x7159d04,O4,54855970,52793124,433,287679594,77825,0x81da4ee,98305,0,0x815b4ee,O4,0,38851790,\n0x6510f26,3969,0x774d80a,O4,O4,0,517494784,0,0xe141956,749457,O2,84778338,0,0x70dc704,O2,0x729d8ae,O4,0,0x96d520a,O2,51753790,O2\n,0,84474618,0,0xa0d515c,376049,0xa1de6ae,373553,O2,376587,401181,373707,21725,O4,0x72570dc,O4,0,38089418,0,88420998,369,41455390\n,8193,O2,504403290,65,186539,O2,0,507024694,353,O2,0,0x955ec0a,O2,0xe1558a4,204801,O2,84515926,O4,O4,O4,O4,O4,0,38589724,3921,0,\n88942328,404082688,246305,403757192,321,O4,38589762,978113,88942290,O2,555013120,554505728,159745,84724578,O2,0,0x6510e86,321,\n89201366,321,O2,40971,973,3979,973,404059212,450577,403757208,65,O2,437611574,0,437351492,435169,85046040,O2,0,0x64d2686,337,O2,\n454400512,778609,453809506,O2,0,338548804,0,336163926,O2,0,0x615ab0e,110849,O2,0,84686178,111211,O4,84522180,0x915b4dc,45057,O4,\n540316746,369,537433258,0,0xd09aaaa,0,0xb1592b4,827217,O2,84489060,934497,0xd1590a4,O4,0,0x9157edc,487425,O4,457776138,0xfd001,0\n,453830200,O2,408737882,O2,403284032,O2,0,546608128,O4,539530386,1889,0,537433254,O2,0xf155490,594577,0xf11549a,401505,O2,300891\n,189,78059,401645,O2,336910684,0,336147546,33,O2,0,320167002,319380610,300833,O4,99366124,20481,0,251749,371263578,952497,O4,\n37092458,O2,37277978,0xd39cc86,0,388028716,129,O4,O2,0,34995438,401,277923,O2,0,278219,278109,0,0x909e8e6,437265,0,0x90db2e6,\n34449250,O2,382269,0,465963,391915,O4,35519150,265585,O4,265707,0,262671,0x7094806,O2,0x70dd8c2,O2,0,0x909deaa,0,0x90dd6e6,O2,0,\n0x7098a06,0,0x70de4f6,O4,0,34656594,622673,O4,536651,0,549087,0x90992c4,O2,0x90dc4e6,O4,O4,O4,O4,O4,O2,0,329275598,44060278,O4,\n391174312,O2,0,51242330,68274464,49217,51501628,28673,O2,81995,32845,27515,27581,0x80c3f62,50985632,68286752,16385,68791088,\n69242034,0xfdcab,68017474,0,68528968,171873,109,52787528,51753810,217,85051160,86339822,69047626,520411,51500866,68528988,106683\n,68791076,3965,68272416,O2,51242324,68015932,49889,85056280,0,217,0,50075,50093,O2,68286232,45505,51497294,233633,51243842,0,\n127371,110989,233579,234413,0x70d9d0e,28685,68282656,98305,68530996,0,35519578,34725208,114699,249,69334106,68785496,0x811c4ee,\n68012336,197943,68530976,85311758,85564758,0,68284184,0,51247804,68010318,913,52532492,34989178,85058840,106497,85815642,0xfd001\n,0,180233,51231586,0,68010288,114881,39375992,0,0x990591e,0,35718476,36043976,41717966,0,0xcd400f4,0,36810926,57345,O2,74277898,\n0,34700078,873377,40162374,0,0xbac766c,0,36295880,36459858,O2,0xa353cc8,817,53839534,20481,O2,0x93550ae,225057,950075,282381,O4,\n0xd0daaa4,225281,0xa35e86a,30561,O2,237579,974381,435275,435389,O2,0xd0d92ae,810609,O2,59526924,0,3667,60373,0,319914586,O2,\n319671904,299185,0xf11728e,O2,0,0xf0dae98,201,319894626,O2,0,319642724,299505,0xf11908e,O2,0,0xf0dae9e,193,O2,68024624,115329,\n51493682,O2,51242312,41041,102739,O4,355807850,O4,356059242,O2,0,0xec418f4,0xfc4586c,O2,0x93574ae,45057,53812046,28673,54343370,\nO2,0,0xf0d729e,450657,319924314,O2,0,319642748,457,O2,0,523539686,3889,O2,0xa353d30,305,53813582,450113,0,71119656,O2,0xf0dae8c,\n127121,0,319914594,O2,319642736,209,O2,0,523801774,801,52793160,54342470,0x63d3c86,237569,51753800,52006746,O2,0,0xa09e6a0,69713\n,34726224,O2,0,67724352,304977,34145530,O2,0,0x711b904,192449,O2,0,36873,229323,O4,0x711acfc,O4,192521,O2,37566790,0,88680222,\n737,34973526,0,86339876,O2,0x911c6dc,147921,153,O2,0,90123,61453,O4,0x925d8c8,102401,0,51493706,193,34197568,34726216,0,234473,\n234411,51246914,233583,0,68747612,348705,51497302,65,0,51755808,17377,34700096,340097,0,34471234,57617,51245384,50883428,0,\n51750590,0xfa011,34725216,95,0,35950860,87896842,3889,34995470,175569,O4,0x911a0e6,O2,0,45631724,0xdec3400,945,37278006,O4,\n0x8119cfc,O4,0x80dd4f6,0x6295148,993,O2,0x6159d4c,85309198,O2,0x62db4ae,237569,0,53334702,O2,0x62964c8,161,53042504,306177,455,\n3689,O2,0x6159d24,85314318,O2,442067978,0,439146564,926545,O2,0x654fafe,369,55904390,0,53235538,794593,0,0x6296518,417,0,\n86614216,0,713,619,0,61449,O4,0x99c7ece,O2,0,438897732,155649,O2,0,439197730,439459850,0x62970c8,24577,O2,0x6159d1a,85319438,0,\n69819620,69566254,53042484,52793142,0,295,3769,3659,29501,0,69566272,507905,739,86339858,0,508793,508651,52793088,508511,0,\n69568248,69819640,53071560,3963,0,0x62988c8,57345,0,86616776,442727,442761,O2,0x6159d38,85316878,0,69819660,69568230,355,511395,\n0,52532508,0,0x811d4ee,0x711bafc,O2,395,98313,233481,0,69072110,200337,0x70de304,36865,0,0x629510c,353,0,86619336));\n\n// Collision map ///////////////////////////////////////////////\n\n#undef D\n#undef E\n#undef F\n#undef G\n#undef H\n#undef I\n\n#define D(w) V( 1,0,0,float(w)*16.+-1040.)\n#define G(w) V(-1,0,0,float(w)*16.+48.)\n#define E(w) V(0, 1,0,float(w)*16.+-1440.)\n#define H(w) V(0,-1,0,float(w)*16.+176.)\n#define F(w) V(0,0, 1,float(w)*16.+-320.)\n#define I(w) V(0,0,-1,float(w)*16.+-192.)\n#define B(x0,y0,z0,x1,y1,z1) D(x0)G(x1)E(y0)H(y1)F(z0)I(z1)\n\nWRAP(CMPlanes,cm_planes,vec4,NUM_MAP_COLLISION_PLANES+1)(B(1,53.5,19,53.5,18.5,8)B(0,2,0,59,0,0)B(59,2,0,0,0,8)B(1,38,24,41,0,0)\nB(28,2,13,28,75,10)B(47.5,2,13,8.5,75,10)B(8,2,13,48,75,10)B(20,2,0,39,37,0)B(3,76.5,0,3,0,8)B(0,0,0,0,77,0)B(3,13,31,42,37,0)B(\n3,67,20,3,2.5,8)B(39,2,0,20,37,0)B(42,2,23,3,65,8)B(21,62,20,21,15,8)B(21,2,24,0,0,0)B(53.5,53.5,19,1,18.5,8)B(2,2,23,41,61,0)D(\n23)G(22)E(14)F(21.5)I(8)V(0,-.242536,.970142,256.118)E(64)H(12)F(20)I(8)V(H0,H0,0,-791.96)V(-H0,H0,0,-22.6274)E(60)H(12)F(21)I(8\n)V(H0,H0,0,-837.214)V(-H0,H0,0,-67.8823)E(58)H(12)F(22)I(8)V(H0,H0,0,-882.469)V(-H0,H0,0,-113.137)E(56)H(12)F(23)I(8)V(H0,H0,0,\n-927.724)V(-H0,H0,0,-158.392)E(32.5)H(41)F(23.5)I(1)V(.910366,.413803,0,-1218.24)V(-.910366,.413803,0,354.877)E(18)H(55.5)F(23)I\n(1)V(.910366,-.413803,0,-397.251)V(-.910366,-.413803,0,1175.86)G(3)H(2.5)F(0)I(12)V(H0,H0,0,-328.098)D(3)H(2.5)F(0)I(12)V(-H0,H0\n,0,441.235)D(3)G(2)E(0)H(65)F(22)I(8)V(-.524097,-.851658,0,1186.56)vec4(0)));\n\n#define S(d,b) b,b+d,b+d*2,b+d*3,\n#define S4(d,b) S(d,b)S(d,b+d*4)S(d,b+d*8)S(d,b+d*12)\n\nWRAP(CMBrushes,cm_brushes,int,NUM_MAP_COLLISION_BRUSHES+1)(S4(6,0)S(6,96)S(6,120)144,150,155,160,167));\n\n// Map data serialization //////////////////////////////////////\n\nbool is_inside(vec2 fragCoord, vec4 box, out ivec2 offset)\n{\n    offset = ivec2(floor(fragCoord - box.xy));\n    return all(lessThan(uvec2(offset), uvec2(box.zw)));\n}\n\nvoid write_map_data(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_LIGHTING) > 0.)\n    {\n        Lighting lighting;\n        if (iFrame == 0)\n            clear(lighting);\n        else\n            from_vec4(lighting, fragColor);\n\n        lighting.progress = clamp(min(float(iFrame)/float(NUM_WAIT_FRAMES), iTime/LOADING_TIME), 0., 1.);\n        if (lighting.progress >= 1. && lighting.bake_time <= 0.)\n            lighting.bake_time = iTime;\n        \n        to_vec4(fragColor, lighting);\n        return;\n    }\n    \n#if WRITE_MAP_DATA\n    if (iFrame > 0)\n#endif\n        return;\n    \n    ivec2 offset;\n\n    if (is_inside(fragCoord, ADDR_RANGE_NONAXIAL_PLANES, offset))\n    {\n        int index = offset.y * int(ADDR_RANGE_NONAXIAL_PLANES.z) + offset.x;\n        if (uint(index) < uint(NUM_MAP_NONAXIAL_PLANES + 1))\n            fragColor = planes.data[index];\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_LIGHTS, offset))\n    {\n        if (uint(offset.x) < uint(NUM_LIGHTS + 1))\n        \tfragColor = lights.data[offset.x];\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_LMAP_TILES, offset))\n    {\n        int index = offset.y * int(ADDR_RANGE_LMAP_TILES.z) + offset.x;\n        if (uint(index) < uint(NUM_MAP_PLANES))\n        {\n            int tile = LIGHTMAP_TILES.data[index];\n            bool delta_encoded = (tile & 1) != 0;\n            if (delta_encoded)\n            {\n                int offset = (tile >> 1) & 7;\n                tile = (tile >> 3) ^ LIGHTMAP_TILES.data[index - offset - 1];\n            }\n            tile >>= 1;\n            \n            int x = tile & 255,\n                y = (tile >> 8) & 511,\n                w = (tile >> 17) & 63,\n                h = (tile >> 23) & 63;\n            \n            fragColor = vec4(x, y, w, h);\n        }\n    }\n    else if (is_inside(fragCoord, ADDR_RANGE_COLLISION_PLANES, offset))\n    {\n        if (uint(offset.x) < uint(NUM_MAP_COLLISION_PLANES + 1))\n        \tfragColor = cm_planes.data[offset.x];\n    }\n}\n\n\n// Collision detection / response //////////////////////////////\n\nvec4 get_collision_plane(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_COLLISION_PLANES.xy);\n    addr.x += index;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nfloat get_player_radius(vec3 direction)\n{\n    const float HORIZONTAL_RADIUS = 16., VERTICAL_RADIUS = 48.;\n\n    direction = abs(direction);\n    return direction.z > max(direction.x, direction.y) ? VERTICAL_RADIUS : HORIZONTAL_RADIUS;\n}\n\nfloat get_player_distance(vec3 position, vec4 plane)\n{\n    return dot(position, plane.xyz) + plane.w - get_player_radius(plane.xyz);\n}\n\nbool is_touching_ground(vec3 position, vec4 ground)\n{\n    return ground.z > 0. && abs(get_player_distance(position, ground)) < 1.;\n}\n\nbool is_valid_ground(vec3 position, vec4 ground)\n{\n    return ground.z > 0. && get_player_distance(position, ground) > -1.;\n}\n\nvoid find_collision(inout vec3 start, inout vec3 delta, out int hit_plane, out float step_height)\n{\n    const float STEP_SIZE = 18.;\n\n    // We iterate through all the collision brushes, tracking the closest plane the ray hits and the top plane\n    // of the colliding brush.\n    // If, at the end of the loop, the closest hit plane is vertical and the corresponding top plane\n    // is within stepping distance, we move the start position up by the height difference, update the stepping\n    // offset for smooth camera interpolation and defer all forward movement to the next step (handle_collision).\n    // If we're not stepping up then we move forward as much as possible, discard the remaining forward movement\n    // blocked by the colliding plane and pass along what's left (wall sliding) to the next phase.\n    \n    step_height = 0.;\n    hit_plane = -1;\n    float travel_dist = 1.;\n    int ground_plane = -1;\n    float ground_dist = 0.;\n    float eps = 1./(length(delta) + 1e-6);\n    vec3 dir = normalize(delta);\n\n    int num_brushes = NO_UNROLL(NUM_MAP_COLLISION_BRUSHES);\n    for (int i=0; i<num_brushes; ++i)\n    {\n        int first_plane = cm_brushes.data[i];\n        int last_plane = cm_brushes.data[i + 1];\n        int plane_enter = -1;\n        int brush_ground_plane = -1;\n        float brush_ground_dist = 1e+6;\n        float t_enter = -1e+6;\n        float t_leave = 1e+6;\n        for (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_collision_plane(j);\n            float dist = get_player_distance(start, plane);\n            \n            // Note: top plane detection only takes into account fully horizontal planes.\n            // This means that stair stepping won't work with brushes that have an angled top surface, \n            // such as the ramp in the 'Normal' hallway. If you stop on the ramp and let gravity slide\n            // you down you'll notice the sliding continues for a bit after the ramp ends - the collision\n            // map doesn't fully match the rendered geometry (and now you know why).\n            \n            if (abs(dir.z) < .7 && plane.z > .99 && brush_ground_dist > dist)\n            {\n                brush_ground_dist = dist;\n                brush_ground_plane = j;\n            }\n            float align = dot(plane.xyz, delta);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                {\n                    t_enter = 2.;\n                    break;\n                }\n                continue;\n            }\n            align = -1./align;\n            dist *= align;\n            if (align > 0.)\n            {\n                if (t_enter < dist)\n                {\n                    plane_enter = j;\n                    t_enter = dist;\n                }\n            }\n            else\n            {\n                t_leave = min(t_leave, dist);\n            }\n\n            if (t_leave <= t_enter)\n                break;\n        }\n\n        if (t_leave > max(t_enter, 0.) && t_enter > -eps)\n        {\n            if (t_enter <= travel_dist)\n            {\n                if (brush_ground_plane != -1 && -brush_ground_dist > ground_dist)\n                {\n                    ground_plane = brush_ground_plane;\n                    ground_dist = -brush_ground_dist;\n                }\n                hit_plane = plane_enter;\n                travel_dist = t_enter;\n            }\n        }\n    }\n\n    vec4 plane;\n    bool blocked = hit_plane != -1;\n    if (blocked)\n    {\n        plane = get_collision_plane(hit_plane);\n        if (abs(plane.z) < .7 && ground_plane != -1 && ground_dist > 0. && ground_dist <= STEP_SIZE)\n        {\n            ground_dist += .05;\t// fixes occasional stair stepping stutter at low FPS\n            step_height = ground_dist;\n            start.z += ground_dist;\n            return; // defer forward movement to next step\n        }\n    }\n\n    start += delta * clamp(travel_dist, 0., 1.);\n    delta *= 1. - clamp(travel_dist, 0., 1.);\n\n    if (blocked)\n    {\n        start += 1e-2 * plane.xyz;\n        delta -= dot(plane.xyz, delta) * plane.xyz;\n    }\n}\n\n\nvoid handle_collision(inout vec3 start, vec3 delta, int slide_plane, out int hit_plane, out int ground_plane)\n{\n    // We iterate again through all the collision brushes, this time performing two ray intersections:\n    // one determines how far we can actually move, while the other does a ground check from the starting\n    // point, giving us an approximate ground plane.\n    // Note that the ground plane isn't computed from the final position - that would require another pass\n    // through all the brushes!\n    \n    const float LARGE_NUMBER = 1e+6;\n\n    hit_plane = -1;\n    ground_plane = -1;\n    float travel_dist = 1.;\n    float ground_dist = LARGE_NUMBER;\n    float eps = 1./(length(delta) + 1e-6);\n\n    int num_brushes = NO_UNROLL(NUM_MAP_COLLISION_BRUSHES);\n    for (int i=0; i<num_brushes; ++i)\n    {\n        int first_plane = cm_brushes.data[i];\n        int last_plane = cm_brushes.data[i + 1];\n        int plane_enter = -1;\n        int plane_enter_ground = -1;\n        float t_enter = -LARGE_NUMBER;\n        float t_leave = LARGE_NUMBER;\n        float t_enter_ground = t_enter;\n        float t_leave_ground = t_leave;\n        for (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_collision_plane(j);\n            float dist = get_player_distance(start, plane);\n\n            // handle ground ray\n            if (plane.z == 0.)\n            {\n                if (dist > 0.)\n                    t_enter_ground = LARGE_NUMBER;\n            }\n            else\n            {\n                float height = dist / plane.z;\n                if (plane.z > 0.)\n                {\n                    if (t_enter_ground < height)\n                    {\n                        plane_enter_ground = j;\n                        t_enter_ground = height;\n                    }\n                }\n                else\n                {\n                    t_leave_ground = min(t_leave_ground, height);\n                }\n            }\n\n            // handle movement ray\n            float align = dot(plane.xyz, delta);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                    t_enter = LARGE_NUMBER;\n                continue;\n            }\n            align = -1./align;\n            dist *= align;\n            if (align > 0.)\n            {\n                if (t_enter < dist)\n                {\n                    plane_enter = j;\n                    t_enter = dist;\n                }\n            }\n            else\n            {\n                t_leave = min(t_leave, dist);\n            }\n        }\n\n        if (t_leave_ground > t_enter_ground && t_enter_ground > -8.)\n        {\n            if (t_enter_ground < ground_dist)\n            {\n                ground_plane = plane_enter_ground;\n                ground_dist = t_enter_ground;\n            }\n        }\n\n        if (t_leave > max(t_enter, 0.) && t_enter > -eps)\n        {\n            if (t_enter < travel_dist)\n            {\n                hit_plane = plane_enter;\n                travel_dist = t_enter;\n            }\n        }\n    }\n\n    start += delta * clamp(travel_dist, 0., 1.);\n    delta *= 1. - clamp(travel_dist, 0., 1.);\n\n    if (hit_plane != -1)\n    {\n        vec4 plane = get_collision_plane(hit_plane);\n        start += 1e-2 * plane.xyz;\n        delta -= dot(plane.xyz, delta) * plane.xyz;\n    }\n}\n\nvoid clip_velocity(inout vec3 velocity, int first_hit_plane, int second_hit_plane, float step_size)\n{\n    if (step_size > 0.)\n    {\n        first_hit_plane = second_hit_plane;\n    \tsecond_hit_plane = -1;\n    }\n\n    if (first_hit_plane != -1)\n    {\n        vec4 first = get_collision_plane(first_hit_plane);\n        if (second_hit_plane != -1)\n        {\n            vec4 second = get_collision_plane(second_hit_plane);\n            vec3 crease = normalize(cross(first.xyz, second.xyz));\n            velocity = dot(velocity, crease) * crease;\n        }\n        else\n        {\n            float align = dot(first.xyz, normalize(velocity));\n            velocity -= 1.001 * dot(velocity, first.xyz) * first.xyz;\n            velocity *= mix(1., .5, abs(align)); // extra friction\n        }\n    }\n}\n\nvoid slide_move(inout vec3 position, inout vec3 velocity, inout vec4 ground, inout float step_transition)\n{\n    vec3 dir = velocity * iTimeDelta;\n\n    int first_hit_plane = -1,\n    \tsecond_hit_plane = -1,\n    \tground_plane = -1;\n    float step_size = 0.;\n\n    find_collision(position, dir, first_hit_plane, step_size);\n    handle_collision(position, dir, first_hit_plane, second_hit_plane, ground_plane);\n    clip_velocity(velocity, first_hit_plane, second_hit_plane, step_size);\n    \n    ground = vec4(0);\n    if (ground_plane != -1)\n    {\n        vec4 plane = get_collision_plane(ground_plane);\n        if (is_valid_ground(position, plane))\n            ground = plane;\n    }\n\n    step_transition += step_size;\n}\n\n// UV distortions //////////////////////////////////////////////\n\nvec2 running_bond(vec2 uv, float rows)\n{\n    uv.x += floor(uv.y * rows) * .5;\n    return uv;\n}\n\nvec2 running_bond(vec2 uv, float cols, float rows)\n{\n    uv.x += floor(uv.y * rows) * (.5 / cols);\n    return uv;\n}\n\nvec3 herringbone(vec2 uv)\n{\n    uv *= 4.;\n    float horizontal = step(1., mod(uv.x + floor(uv.y) + 3., 4.) - 1.);\n    uv = mix(-uv.yx + vec2(3. - floor(uv.x), 0.), uv.xy + vec2(3. - floor(uv.y), 0.), horizontal);\n    return vec3(uv * .25, horizontal);\n}\n\n// 3D effects //////////////////////////////////////////////////\n\n// centered on 0; >0 for lightness, <0 for darkness\nfloat add_bevel(vec2 uv, float cols, float rows, float thickness, float light, float dark)\n{\n    uv = fract(uv * vec2(cols, rows));\n    vec4 d = clamp(vec4(uv.xy, 1.-uv.xy)/vec2(thickness*cols, thickness*rows).xyxy, 0., 1.);\n    return light*(2. - d.x - d.w) - dark*(2. - d.y - d.z);\n}\n\n// QUAKE text //////////////////////////////////////////////////\n\nfloat sdf_QUAKE(vec2 uv)\n{\n    uv.x *= .9375;\n    float sdf\t\t\t\t\t\t   = sdf_Q_top(uv);\n    uv.x -= .875;\tsdf = sdf_union(sdf, sdf_U(uv));\n    uv.x -= .8125;\tsdf = sdf_union(sdf, sdf_A(uv));\n    uv.x -= 1.0625;\tsdf = sdf_union(sdf, sdf_K(uv));\n    uv.x -= .625;\tsdf = sdf_union(sdf, sdf_E(uv));\n    return sdf;\n}\n\nvec2 engraved_QUAKE(vec2 uv, float size, vec2 light_dir)\n{\n    const float EPS = .1/64.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_QUAKE(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1./64.);\n    float bevel = clamp(1. + sdf.z/size, 0., 1.);\n    float intensity = .5 + sqr(bevel) * dot(gradient, light_dir);\n    intensity = mix(1.125, intensity, mask);\n    mask = sdf_mask(sdf.z - 1./64., 1./64.);\n    return vec2(intensity, mask);\n}\n\n////////////////////////////////////////////////////////////////\n\n// waves.x = amplitude; .y = frequency; .z = phase offset\nfloat sdf_flame_segment(vec2 uv, vec2 size, vec3 waves)\n{\n    float h = linear_step(0., size.y, uv.y);\n    float width = mix(.5, .005, sqr(h)) * size.x;\n    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));\n}\n\nfloat sdf_flame_segment2(vec2 uv, vec2 size, vec3 waves)\n{\n    float width = mix(size.x*.005, size.x*.5, smoothen(around(size.y*.5, size.y*.5, uv.y)));\n    float h = linear_step(0., size.y, uv.y);\n    return sdf_centered_box(uv, vec2(.5 + sin((h+waves.z)*TAU*waves.y)*waves.x, size.y*.5), vec2(width, size.y*.5));\n}\n\nfloat sdf_window_flame(vec2 uv)\n{\n    bool left = uv.x < .5;\n    float sdf = uv.y - 1.;\n    uv.y -= .95;\n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, -.02), vec2(.4, 1.9), vec3(.11, 1., .0)));\n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .21)-vec2(-.13, 0.), vec2(.3, 1.2), vec3(.08, 1.2, .95)));\n\tsdf = sdf_union(sdf, sdf_flame_segment(skew(uv, .0)-vec2(.31, 0.), vec2(.3, 1.4), vec3(.1, 1.2, .55)));\n    \n    sdf = sdf_union(sdf, sdf_flame_segment(skew(uv, left ? .3 : -.3) - (left ? vec2(-.28, 0.) : vec2(.37, -.1)),\n                                           vec2(.2, left ? .31 : .35), vec3(left ? -.03 : .03, 1., .5)));\n    \n    sdf = sdf_union(sdf, sdf_flame_segment2(uv - (left ? vec2(-.35, 1.25) : vec2(.17, 1.5)), vec2(.11, left ? .4 : .35),\n                                            vec3(-.02, 1., .5)));\n    sdf = sdf_union(sdf, sdf_flame_segment2(skew(uv-vec2(.35, 1.35), -.0), vec2(.11, .24), vec3(.02, 1., .5)));\n    return sdf;\n}\n\nfloat sdf_window_emblem(vec2 uv)\n{\n    vec2 uv2 = vec2(min(uv.x, 1.-uv.x), uv.y);\n\t\n    float sdf = sdf_centered_box(uv, vec2(.5, .25), vec2(.375, .1));\n    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.36, .1), .15));\n    \n    float h = linear_step(.35, .8, uv.y);\n    float w = mix(.27, .35, sqr(triangle_wave(.5, h))) + sqrt(h) * .15;\n    sdf = sdf_union(sdf, sdf_centered_box(uv, vec2(.5, .6), vec2(w, .26)));\n    \n    h = linear_step(.95, .6, uv.y);\n    w = .6 - around(.9, .8, h) * .5;\n    sdf = sdf_exclude(sdf, .75*sdf_centered_box(uv, vec2(.5, .75), vec2(w, .21)));\n    \n    // eyes\n    sdf = sdf_exclude(sdf, sdf_line(uv2, vec2(.45, .4), vec2(.4, .45), .04));\n\n    sdf = sdf_exclude(sdf, sdf_disk(uv2, vec2(.15, .2), .15));\n\tsdf = sdf_union(sdf, sdf_line(uv, vec2(.5, .125), vec2(.5, .875), .0625));\n    return sdf;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat line_sqdist(vec2 uv, vec2 a, vec2 b)\n{\n    vec2 ab = b-a, ap = uv-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    return length_squared(uv - (ab*t + a));\n}\n\nfloat sdf_chickenscratch(vec2 uv, vec2 mins, vec2 maxs, float thickness)\n{\n    uv -= mins;\n    maxs -= mins;\n    \n    vec2 p0, p1, p2, p3;\n    if (uv.x < maxs.x*.375)\n    {\n        p0 = vec2(0.);\n        p1 = vec2(.3, 1.);\n        p2 = vec2(.3, 0.);\n        p3 = vec2(.09, .28);\n    }\n    else\n    {\n        p0 = vec2(.45, 0.);\n        p1 = vec2(.45, 1.);\n        p2 = vec2(.75, 0.);\n        p3 = p0;\n    }\n    p0 *= maxs;\n    p1 *= maxs;\n    p2 *= maxs;\n    p3 *= maxs;\n\n    float dist = line_sqdist(uv, p0, p1);\n    dist = min(dist, line_sqdist(uv, p1, p2));\n    dist = min(dist, line_sqdist(uv, p2, p3));\n\n    #define LINE(a, b) line_sqdist(uv, maxs*a, maxs*b)\n    \n    dist = min(dist, LINE(vec2(.65, 1.), vec2(.95, 0.)));\n    dist = min(dist, LINE(vec2(.85, 1.), vec2(.65, .65)));\n\n\t#undef LINE\n    \n    return sqrt(dist) + thickness * -.5;\n}\n\n////////////////////////////////////////////////////////////////\n//  Cellular noise code by Brian Sharpe\n//  https://briansharpe.wordpress.com/\n//  https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  Modified to add tiling\n////////////////////////////////////////////////////////////////\n\n//\n//\tFAST32_hash\n//\tA very fast hashing function.  Requires 32bit support.\n//\thttp://briansharpe.wordpress.com/2011/11/15/a-fast-and-simple-32bit-floating-point-hash-function/\n//\n//\tThe 2D hash formula takes the form....\n//\thash = mod( coord.x * coord.x * coord.y * coord.y, SOMELARGEFLOAT ) / SOMELARGEFLOAT\n//\tWe truncate and offset the domain to the most interesting part of the noise.\n//\tSOMELARGEFLOAT should be in the range of 400.0->1000.0 and needs to be hand picked.  Only some give good results.\n//\tA 3D hash is achieved by offsetting the SOMELARGEFLOAT value by the Z coordinate\n//\n\nconst vec2 OFFSET = vec2( 26.0, 161.0 );\nconst vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n\nvoid FAST32_hash_2D_tile( vec2 gridcell, vec2 gridsize, out vec4 hash_0, out vec4 hash_1 )\n{\n    //    gridcell is assumed to be an integer coordinate\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n    P = P - floor(P * ( 1.0 / gridsize.xyxy )) * gridsize.xyxy;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n}\n\nvec4 FAST32_hash_2D_tile( vec2 gridcell, vec2 gridsize )\n{\n    //    gridcell is assumed to be an integer coordinate\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n    P = P - floor(P * ( 1.0 / gridsize.xyxy )) * gridsize.xyxy;\n    P += OFFSET.xyxy;\n    P *= P;\n    P = P.xzxz * P.yyww;\n    return fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n}\n\nfloat FAST32_smooth_noise(vec2 P, vec2 gridsize)\n{\n    P *= gridsize;\n    vec2 Pi = floor(P), Pf = smoothen(P - Pi);\n    vec4 hash = FAST32_hash_2D_tile(Pi, gridsize);\n    return mix(mix(hash.x, hash.y, Pf.x), mix(hash.z, hash.w, Pf.x), Pf.y);\n}\n\n//\tconvert a 0.0->1.0 sample to a -1.0->1.0 sample weighted towards the extremes\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\n//\n//\tCellular Noise 2D\n//\tBased off Stefan Gustavson's work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//\thttp://briansharpe.files.wordpress.com/2011/12/cellularsample.jpg\n//\n//\tSpeed up by using 2x2 search window instead of 3x3\n//\tproduces a range of 0.0->1.0\n//\nfloat Cellular2D(vec2 P, vec2 gridsize)\n{\n    P *= gridsize;\t// adx: multiply here instead of requiring callers to do it\n    //\testablish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec2 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D_tile( Pi, gridsize, hash_x, hash_y );\n\n    //\tgenerate the 4 random points\n#if 0\n    //\trestrict the random point offset to eliminate artifacts\n    //\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.25;\t// 0.25 will guarentee no artifacts.  0.25 is the intersection on x of graphs f(x)=( (0.5+(0.5-x))^2 + (0.5-x)^2 ) and f(x)=( (0.5+x)^2 + x^2 )\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n#else\n    //\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    //\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x = hash_x * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y = hash_y * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    //\treturn the closest squared distance\n    vec4 dx = Pf.xxxx - hash_x;\n    vec4 dy = Pf.yyyy - hash_y;\n    vec4 d = dx * dx + dy * dy;\n    d.xy = min(d.xy, d.zw);\n    return min(d.x, d.y) * ( 1.0 / 1.125 );\t//\tscale return value from 0.0->1.125 to 0.0->1.0  ( 0.75^2 * 2.0  == 1.125 )\n}\n\n\n////////////////////////////////////////////////////////////////\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n////////////////////////////////////////////////////////////////\n\n// XY=offset, Z=dist\nvec3 voronoi(vec2 x, vec2 grid)\n{\n    x *= grid; // adx: multiply here instead of requiring callers to do it\n    vec2 n = floor(x);\n    vec2 f = x - n;\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for (int j=-1; j<=1; j++)\n    for (int i=-1; i<=1; i++)\n    {\n        vec2 g = vec2(i, j);\n\t\tvec2 o = hash2(mod(n + g, grid));\t// adx: added domain wrapping\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if (d < md)\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for (int j=-2; j<=2; j++)\n    for (int i=-2; i<=2; i++)\n    {\n        vec2 g = mg + vec2(i, j);\n\t\tvec2 o = hash2(mod(n + g, grid));\t// adx: added domain wrapping\n        vec2 r = g + o - f;\n        float d = length_squared(mr - r);\n\n        if (d > 0.00001)\n        \tmd = min(md, -inversesqrt(d)*dot(mr+r, mr-r));\n    }\n\n    return vec3(mr, 0.5*md); // adx: changed order\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat tileable_smooth_noise(vec2 p, vec2 scale)\n{\n#if 0\n    p *= scale;\n    vec2 pi = floor(p);\n    p = smoothen(p - pi);\n    vec4 seed = fract(vec4(pi, pi + 1.) * (1./scale).xyxy);\n    float s00 = random(seed.xy);\n    float s01 = random(seed.zy);\n    float s10 = random(seed.xw);\n    float s11 = random(seed.zw);\n    return mix(mix(s00, s01, p.x), mix(s10, s11, p.x), p.y);\n#else\n    return FAST32_smooth_noise(p, scale);\n#endif\n}\n\nfloat tileable_turb(vec2 uv, vec2 scale, float gain, float lacunarity)\n{\n\tfloat accum = tileable_smooth_noise(uv, scale);\n    float octave_weight = gain;\n    float total_weight = 1.;\n\n    scale *= lacunarity;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    scale *= lacunarity; octave_weight *= gain;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    scale *= lacunarity; octave_weight *= gain;\n    accum += tileable_smooth_noise(uv, scale) * octave_weight;\n    total_weight += octave_weight;\n\n    return accum / total_weight;\n}\n\n////////////////////////////////////////////////////////////////\n\nvec4 generate_texture(const int material, vec2 uv)\n{\n    vec2 tile_size = get_tile(material).zw;\n\n\tvec3 clr;\n    float shaded = 1.;\t// 0 = fullbright; 0.5 = lit; 1.0 = lit+AO\n    \n    float grain = random(uv*128.);\n    \n    // gathering FBM parameters first and calling the function once\n    // instead of per material reduces the compilation time for this buffer\n    // by about 4 seconds (~9.4 seconds vs ~13.4) on my machine...\n    \n    // array-based version compiles about 0.7 seconds faster\n    // than the equivalent switch (~14.1 seconds vs ~14.8)...\n\n    const vec4 MATERIAL_SETTINGS[]=vec4[7](vec4(3,5,1,3),vec4(3,5,1,4),vec4(6,6,.5,3),vec4(10,10,.5,2),vec4(3,5,1,2),vec4(7,3,.5\n    ,2),vec4(7,5,.5,2));\n    const int MATERIAL_INDICES[]=int[NUM_MATERIALS+1](1,1,1,0,1,0,1,0,0,0,1,6,6,6,1,1,2,3,4,5,0);\n\n    vec4 settings = MATERIAL_SETTINGS[MATERIAL_INDICES[min(uint(material), uint(NUM_MATERIALS))]];\n    vec2 base_grid = settings.xy;\n    float base_gain = settings.z;\n    float base_lacunarity = settings.w;\n\n    if (is_material_sky(material))\n        uv += sin(uv.yx * (3.*PI)) * (4./128.);\n\n    vec2 aspect = tile_size / min(tile_size.x, tile_size.y);\n    float base = tileable_turb(uv * aspect, base_grid, base_gain, base_lacunarity);\n    \n    // this switch compiles ~2.2 seconds faster on my machine\n    // than an equivalent if/else if chain (~11.5s vs ~13.7s)\n    \n\t#define GENERATE(mat) ((GENERATE_TEXTURES) & (1<<(mat)))\n\n    switch (material)\n    {\n#if GENERATE(MATERIAL_WIZMET1_2) || GENERATE(MATERIAL_QUAKE)\n        case MATERIAL_WIZMET1_2:\n        case MATERIAL_QUAKE:\n        {\n            uv.x *= tile_size.x/tile_size.y;\n            uv += vec2(.125, .0625);\n            base = mix(base, grain, .2);\n            clr = mix(vec3(.16, .13, .06), vec3(.30, .23, .12), sqr(base));\n            clr = mix(clr, vec3(.30, .23, .13), sqr(linear_step(.5, .9, base)));\n            clr = mix(clr, vec3(.10, .10, .15), smoothen(linear_step(.7, .1, base)));\n            if (material == MATERIAL_WIZMET1_2 || (material == MATERIAL_QUAKE && uv.y < .375))\n            {\n                vec2 knob_pos = floor(uv*4.+.5)*.25;\n                vec2 knob = add_knob(uv, 1./64., knob_pos, 3./64., vec2(-.4, .4));\n                clr = mix(clr, vec3(.22, .22, .28)*mix(1., knob.x, .8), knob.y);\n                knob = add_knob(uv, 1./64., knob_pos, 1.5/64., vec2(.4, -.4));\n                clr = mix(clr, .7*vec3(.22, .22, .28)*mix(1., knob.x, .7), knob.y);\n            }\n            if (material == MATERIAL_QUAKE)\n            {\n                uv -= vec2(1.375, .15625);\n                uv.x = mod(uv.x, 5.);\n                uv.y = fract(uv.y);\n                vec2 engraved = engraved_QUAKE(uv, 5./64., vec2(0, -1));\n                clr *= mix(1., mix(1., engraved.x*1.25, .875), engraved.y);\n            }\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZMET1_1)\n        case MATERIAL_WIZMET1_1:\n        {\n            base = mix(base, grain, .4);\n            float scratches = linear_step(.15, .9, smooth_noise(vec2(32,8)*rotate(uv, 22.5).x) * base);\n            clr = vec3(.17, .17, .16) * mix(.5, 1.5, base);\n            clr = mix(clr, vec3(.23, .19, .15), scratches);\n            scratches *= linear_step(.6, .25, smooth_noise(vec2(16,4)*rotate(uv, -45.).x) * base);\n            clr = mix(clr, vec3(.21, .21, .28) * 1.5, scratches);\n            float bevel = .6 *mix(3.5/64., 11./64., base);\n            float d = min(1., min(uv.x, 1.-uv.y) / bevel);\n            float d2 = min(d, 3. * min(uv.y, 1.-uv.x) / bevel);\n            clr *= 1. - (1. - d2) * mix(.3, .8, base);\n            clr = mix(clr, vec3(.39, .39, .57) * base, around(.6, .4, d));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZ1_4)\n        case MATERIAL_WIZ1_4:\n        {\n            base = mix(smoothen(base), grain, .3);\n            clr = mix(vec3(.37, .28, .21), vec3(.52, .41, .33), smoothen(base));\n            clr = mix(clr, vec3(.46, .33, .15), around(.45, .05, base));\n            clr = mix(clr, vec3(.59, .48, .39), around(.75, .09, base)*.75);\n            float bevel = mix(4./64., 12./64., FAST32_smooth_noise(uv, vec2(21)));\n            vec2 mins = vec2(bevel, bevel * 2.);\n            vec2 maxs = 1. - vec2(bevel, bevel * 2.);\n            uv = running_bond(uv, 1., 2.) * vec2(1, 2);\n            vec2 duv = (fract(uv) - clamp(fract(uv), mins, maxs)) * (1./bevel) * vec2(2, 1);\n            float d = mix(length(duv), max_component(abs(duv)), .75);\n            clr *= clamp(2.1 - d*mix(.75, 1., sqr(base)), 0., 1.);\n            clr *= 1. + mix(.25, .5, base) * max(0., dot(duv, INV_SQRT2*vec2(-1,1)) * step(d, 1.2));\n        }\n\t\tbreak;\n#endif\n\n#if GENERATE(MATERIAL_WBRICK1_5)\n        case MATERIAL_WBRICK1_5:\n        {\n            vec2 uv2 = uv + sin(uv.yx * (3.*PI)) * (4./64.);\n            uv = running_bond(uv + vec2(.5, 0), 1., 2.) * vec2(1, 2);\n            base = mix(smoothen(base), grain, .3);\n            float detail = tileable_smooth_noise(uv2, vec2(11));\n            detail = sqr(around(.625, .25, detail)) * linear_step(.5, .17, base);\n            clr = mix(vec3(.21, .17, .06)*.75, vec3(.30, .26, .15), base);\n            clr *= mix(.95, 2., sqr(sqr(base)));\n            clr = mix(clr, vec3(.41, .32, .14), detail);\n            float bevel = mix(4./64., 8./64., base);\n            vec2 mins = vec2(bevel, bevel * 1.75);\n            vec2 maxs = 1. - vec2(bevel, bevel * 2.);\n            vec2 duv = (fract(uv) - clamp(fract(uv), mins, maxs)) * (1./bevel) * vec2(2, 1);\n            float d = length(duv);\n            if (uv.y > 1. || uv.y < .5)\n                d = mix(d, max_component(abs(duv)), .5);\n            //clr *= mix(1., mix(.25, .625, base), linear_step(1., 2., d)*step(1.5, d));\n            clr *= clamp(2.1 - d*mix(.75, 1., sqr(base)), 0., 1.);\n            clr *= 1. + mix(.25, .5, base) * max(0., dot(duv, INV_SQRT2*vec2(-1,1)) * step(d, 1.2));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_CITY4_7)\n        case MATERIAL_CITY4_7:\n        {\n            base = mix(base, grain, .4);\n            vec3 brick = herringbone(uv);\n            uv = brick.xy;\n            clr = mix(vec3(.23, .14, .07), vec3(.29, .16, .08), brick.z) * mix(.3, 1.7, base);\n            clr = mix(clr, vec3(.24, .18, .10), linear_step(.6, .9, base));\n            clr = mix(clr, vec3(.47, .23, .12), linear_step(.9, 1., sqr(grain))*.6);\n            clr *= (1. + add_bevel(uv, 2., 4., mix(1.5/64., 2.5/64., base), -mix(.05, .15, grain), 0.6));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_CITY4_6)\n\t\tcase MATERIAL_CITY4_6:\n        {\n            base = mix(base, grain, .5);\n            vec3 brick = herringbone(uv);\n            uv = brick.xy;\n            clr = mix(vec3(.09, .08, .01)*1.25, 2.*vec3(.21, .15, .08), sqr(base));\n            clr *= mix(.85, 1., brick.z);\n            clr = mix(clr, mix(.25, 1.5, sqr(base))*vec3(.11, .11, .22), around(.8, mix(.24, .17, brick.z), (grain)));\n            clr = mix(clr, mix(.75, 1.5, base)*vec3(.26, .20, .10), .75*sqr(around(.8, .2, (base))));\n            clr *= (1. + add_bevel(uv, 2., 4., 2.1/64., .0, .25));\n            clr *= (1. + add_bevel(uv, 2., 4., mix(1.5/64., 2.5/64., base), mix(.25, .05, grain), .35));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_DEM4_1)\n        case MATERIAL_DEM4_1:\n        {\n            base = mix(base, grain, .2);\n            clr = mix(vec3(.18, .19, .21), vec3(.19, .15, .06), linear_step(.4, .7, base));\n            shaded = .75; // lit, half-strength AO\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_COP3_4)\n        case MATERIAL_COP3_4:\n        {\n            float sdf = sdf_chickenscratch(uv, vec2(.25, .125), vec2(.75, .375), 1.5/64.);\n            base = mix(base, grain, .2);\n            base *= mix(1., .625, sdf_mask(sdf, 1./64.));\n            clr = mix(vec3(.14, .15, .13), vec3(.41, .21, .12), base);\n            clr = mix(clr, vec3(.30, .32, .34), linear_step(.6, 1., base));\n            float bevel = mix(2./64., 6./64., sqr(FAST32_smooth_noise(uv, vec2(13))));\n            clr *= (1. + add_bevel(uv, 1., 1., bevel, .5, .5));\n            clr *= 1.5;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_BRICKA2_2) || GENERATE(MATERIAL_WINDOW02_1)\n        case MATERIAL_BRICKA2_2:\n        case MATERIAL_WINDOW02_1:\n        {\n            vec2 grid = (material == MATERIAL_BRICKA2_2) ? vec2(6., 5.) : vec2(8., 24.);\n            uv = (material == MATERIAL_WINDOW02_1) ? fract(uv + vec2(.5, .5/3.)) : uv;\n            vec3 c = voronoi(uv, grid);\n            if (material == MATERIAL_BRICKA2_2)\n            {\n                float dark_edge = linear_step(.0, mix(.05, .45, base), c.z);\n                float lit_edge = linear_step(.35, .25, c.z);\n                float lighting = -normalize(c.xy).y * .5;\n                clr = vec3(.25, .18, .10) * mix(.8, 1.2, grain);\n                clr *= (1. + lit_edge * lighting) * mix(.35, 1., dark_edge);\n                uv = fract(running_bond(uv, 1., 2.) * vec2(1, 2));\n                clr *=\n                    mix(1., min(1., 4.*min(uv.y, 1.-uv.y)), .5) *\n                \tmix(1., min(1., 8.*min(uv.x, 1.-uv.x)), .3125);\n                clr *= 1.25;\n            }\n            else\n            {\n                // Note: using x*48 instead of x/fwidth(x) reduces compilation time\n                // for this buffer by ~23% (~10.3 seconds vs ~13.4) on my system\n                float intensity = mix(1.25, .75, hash1(uv*grid + c.xy)) * (1. - .5*length(c.xy));\n                uv.y *= 3.;\n                float flame = sdf_window_flame(uv) * 48.;\n                float emblem = sdf_window_emblem(uv) * 48.;\n                float edge = linear_step(.0, .15, c.z);\n                clr = mix(vec3(1., .94, .22) * 1.125, vec3(.63, .30, .19), clamp(flame, 0., 1.));\n                clr = mix(clr, vec3(.55, .0, .0), clamp(1.-emblem, 0., 1.));\n                clr = mix(vec3(dot(clr, vec3(1./3.))), clr, intensity);\n                edge *= clamp(abs(flame), 0., 1.) * clamp(abs(emblem), 0., 1.);\n                edge *= step(max(abs(uv.x - .5) - .5, abs(uv.y - 1.5) - 1.5), -2./64.);\n                clr *= intensity * edge;\n                shaded = .75; // lit, half-strength AO\n            }\n    \t}\n        break;\n#endif\n\n#if GENERATE(MATERIAL_LAVA1) || GENERATE(MATERIAL_WATER2) || GENERATE(MATERIAL_WATER1)\n        case MATERIAL_LAVA1:\n        case MATERIAL_WATER2:\n        case MATERIAL_WATER1:\n        {\n            vec2 grid = (material == MATERIAL_WATER1) ? vec2(5., 7.) : vec2(5., 5.);\n            uv += base * (1./31.) * sin(PI * 7. * uv.yx);\n            float cellular = Cellular2D(uv, grid);\n            float grain_amount = (material == MATERIAL_LAVA1) ? .125 : .25;\n            float high_point = (material == MATERIAL_WATER2) ? .8 : .9;\n            base = mix(base, grain, grain_amount);\n            cellular = sqrt(cellular) + mix(-.3, .3, base);\n            base = linear_step(.1, high_point, cellular);\n            if (material == MATERIAL_LAVA1)\n            {\n                clr = mix(vec3(.24,.0,.0), vec3(1.,.40,.14), base);\n                clr = mix(clr, vec3(1.,.55,.23), linear_step(.5, 1., base));\n            }\n            else if (material == MATERIAL_WATER2)\n            {\n                clr = mix(vec3(.10,.10,.14)*.8, vec3(.17,.17,.24)*.8, base);\n                clr = mix(clr, vec3(.16,.13,.06)*mix(.8, 2.5, sqr(sqr(base))), around(.5, .1, grain));\n                clr = mix(clr, vec3(.20,.20,.29)*.8, linear_step(.5, 1., base));\n            }\n            else // if (material == MATERIAL_WATER1)\n            {\n                clr = mix(vec3(.08,.06,.04), vec3(.30,.23,.13), base);\n                clr = mix(clr, vec3(.36,.28,.21), linear_step(.5, 1., base));\n            }\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_WIZWOOD1_5)\n\t\tcase MATERIAL_WIZWOOD1_5:\n        {\n            const vec2 GRID = vec2(1, 4);\n            uv = running_bond(fract(uv.yx), GRID.x, GRID.y);\n            vec2 waviness = vec2(sin(3. * TAU * uv.y), 0) * .0;\n            waviness.x += smooth_noise(uv.y * 16.) * (14./64.);\n            base = tileable_turb(uv + waviness, vec2(2, 32), .5, 3.);\n            clr = mix(vec3(.19, .10, .04)*1.25, vec3(.64, .26, .17), around(.5, .4, smoothen(base)));\n            clr = mix(clr, vec3(.32, .17, .08), around(.7, .3, base)*.7);\n            \n            float across = fract(uv.y * GRID.y);\n            clr *= 1. + .35 * linear_step(1.-4./16., 1.-2./16., across) * step(across, 1.-2./16.);\n            across = min(across, 1. - across);\n            clr *= mix(1., linear_step(0., 2./16., across), mix(.25, .75, base));\n\t\t\tfloat along = fract(uv.x * GRID.x);\n            clr *= 1. + .25 * linear_step(2./64., 0., along);\n            clr *= mix(1., linear_step(1., 1.-2.5/64., along), mix(.5, .75, base));\n            \n            const vec2 LIGHT_DIR = INV_SQRT2 * vec2(-1, 1);\n            uv = fract(uv * GRID);\n            vec2 side = sign(.5 - uv); // keep track of side before folding to 'unmirror' light direction\n            uv = min(uv, 1. - uv) * (1./GRID);\n            vec2 nail = add_knob(uv, 1./64., vec2(4./64.), 1./64., side * LIGHT_DIR);\n            clr = mix(clr, vec3(.64, .26, .17) * nail.x, nail.y * .75);\n\n            clr *= .9 + grain*.2;\n            clr *= .75;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_TELEPORT)\n        case MATERIAL_TELEPORT:\n        {\n            uv *= 64./3.;\n            vec2 cell = floor(uv);\n            vec4 n = hash4(cell);\n            uv -= cell;\n            float radius = mix(.15, .5, sqr(sqr(n.z)));\n            n.xy = mix(vec2(radius), vec2(1.-radius), smoothen(n.xy));\n            uv = clamp((n.xy - uv) * (1./radius), -1., 1.);\n            clr = (1.-length_squared(uv)) * (1.-sqr(sqr(n.w))) * vec3(.44, .36, .26);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_FLAME)\n        case MATERIAL_FLAME:\n        {\n            base = mix(base, grain, .1);\n            clr = mix(vec3(.34, .0, .0), vec3(1., 1., .66), smoothen(base));\n            clr = clamp(clr * 1.75, 0., 1.);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_ZOMBIE)\n        case MATERIAL_ZOMBIE:\n        {\n            base = mix(base, grain, .2);\n            clr = vec3(.57, .35, .24) * mix(.6, 1., sqr(base));\n            clr = mix(clr, vec3(.17, .08, .04), linear_step(.3, .7, base));\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_SKY1)\n        case MATERIAL_SKY1:\n        {\n            clr = vec3(.18, .10, .12) * 1.5 * smoothen(base);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n#if GENERATE(MATERIAL_SKY1B)\n        case MATERIAL_SKY1B:\n        {\n            clr = vec3(.36, .19, .23) * 1.125 * smoothen(base);\n            shaded = 0.;\n        }\n        break;\n#endif\n\n        default:\n        {\n            clr = vec3(base * .75);\n        }\n        break;\n    }\n    \n\t#undef GENERATE\n    \n    clr = clamp(clr, 0., 1.);\n\n    return vec4(clr, shaded);\n}\n\nvoid generate_tiles(inout vec4 fragColor, vec2 fragCoord, float lod)\n{\n    float atlas_scale = exp2(-lod);\n    if (is_inside(fragCoord, atlas_mip0_bounds(atlas_scale)) < 0.)\n        return;\n    \n    int material = -1;\n    vec4 bound;\n    \n    int num_materials = NO_UNROLL(NUM_MATERIALS);\n    for (int i=0; i<num_materials; ++i)\n    {\n        bound = get_tile(i) * atlas_scale;\n        bound.xy += ATLAS_OFFSET;\n        if (is_inside(fragCoord, bound) > 0.)\n        {\n            material = i;\n            break;\n        }\n    }\n    \n    if (material == -1)\n        return;\n    \n    vec2 local_uv = (fragCoord - bound.xy) / bound.zw;\n    fragColor = generate_texture(material, local_uv);\n}\n\nvoid update_mips(inout vec4 fragColor, vec2 fragCoord, float atlas_lod, inout int available_mips)\n{\n    int mip_start = ALWAYS_REFRESH > 0 ? 1 : available_mips;\n    available_mips = min(available_mips + 1, MAX_MIP_LEVEL + 1 - int(atlas_lod));\n    \n    float atlas_scale = exp2(-atlas_lod);\n\n    if (is_inside(fragCoord, atlas_chain_bounds(atlas_scale)) < 0.)\n        return;\n    if (is_inside(fragCoord, atlas_mip0_bounds(atlas_scale)) > 0.)\n        return;\n\n    int mip_end = available_mips;\n    int mip;\n    vec2 atlas_size = ATLAS_SIZE * atlas_scale;\n    vec2 ofs;\n    for (mip=mip_start; mip<mip_end; ++mip)\n    {\n        float fraction = exp2(-float(mip));\n        ofs = mip_offset(mip) * atlas_size + ATLAS_OFFSET;\n        vec2 size = atlas_size * fraction;\n        if (is_inside(fragCoord, vec4(ofs, size)) > 0.)\n            break;\n    }\n    \n    if (mip == mip_end)\n        return;\n    \n    vec2 src_ofs = mip_offset(mip-1) * atlas_size + ATLAS_OFFSET;\n    vec2 uv = fragCoord - ofs - .5;\n\n    // A well-placed bilinear sample would be almost equivalent,\n    // except the filtering would be done in sRGB space instead\n    // of linear space. Of course, the textures could be created\n    // in linear space to begin with, since we're rendering to\n    // floating-point buffers anyway... but then we'd be a bit too\n    // gamma-correct for 1996 :)\n\n    ivec4 iuv = ivec2(uv * 2. + src_ofs).xyxy + ivec2(0, 1).xxyy;\n    vec4 t00 = gamma_to_linear(texelFetch(iChannel1, iuv.xy, 0));\n    vec4 t01 = gamma_to_linear(texelFetch(iChannel1, iuv.xw, 0));\n    vec4 t10 = gamma_to_linear(texelFetch(iChannel1, iuv.zy, 0));\n    vec4 t11 = gamma_to_linear(texelFetch(iChannel1, iuv.zw, 0));\n\n    fragColor = linear_to_gamma((t00 + t01 + t10 + t11) * .25);\n}\n\nvoid update_tiles(inout vec4 fragColor, vec2 fragCoord)\n{\n    const vec4 SENTINEL_COLOR = vec4(1, 0, 1, 0);\n    \n    vec4 resolution = vec4(iResolution.xy, 0, 0);\n    vec4 old_resolution = (iFrame==0) ? vec4(0) : load(ADDR_RESOLUTION);\n    int flags = int(old_resolution.z);\n    if (iFrame == 0 && iTime >= THUMBNAIL_MIN_TIME)\n        flags |= RESOLUTION_FLAG_THUMBNAIL;\n    vec4 atlas_info = (iFrame==0) ? vec4(0) : load(ADDR_ATLAS_INFO);\n    int available_mips = int(round(atlas_info.x));\n   \n    vec2 available_space = (resolution.xy - ATLAS_OFFSET) / ATLAS_CHAIN_SIZE;\n    float atlas_lod = max(0., -floor(log2(min(available_space.x, available_space.y))));\n    if (atlas_lod != atlas_info.y)\n        available_mips = 0;\n    if (max(abs(resolution.x-old_resolution.x), abs(resolution.y-old_resolution.y)) > .5)\n        flags |= RESOLUTION_FLAG_CHANGED;\n    \n    // Workaround for Shadertoy double-buffering bug on resize\n    // (this.mBuffers[i].mLastRenderDone = 0; in effect.js/Effect.prototype.ResizeBuffer)\n    vec2 sentinel_address = ATLAS_OFFSET + ATLAS_CHAIN_SIZE * exp2(-atlas_lod) - 1.;\n    vec4 sentinel = (iFrame == 0) ? vec4(0) : load(sentinel_address);\n    if (any(notEqual(sentinel, SENTINEL_COLOR)))\n    {\n        available_mips = 0;\n        flags |= RESOLUTION_FLAG_CHANGED;\n    }\n    \n    resolution.z = float(flags);\n\n    if (available_mips > 0)\n    \tupdate_mips(fragColor, fragCoord, atlas_lod, available_mips);\n    \n    if (ALWAYS_REFRESH > 0 || available_mips == 0)\n    {\n        if (available_mips == 0)\n        \tstore(fragColor, fragCoord, ADDR_RANGE_ATLAS_CHAIN, vec4(0.));\n        generate_tiles(fragColor, fragCoord, atlas_lod);\n        available_mips = max(available_mips, 1);\n    }\n    atlas_info.x = float(available_mips);\n    atlas_info.y = atlas_lod;\n\n    store(fragColor, fragCoord, ADDR_RESOLUTION, resolution);\n    store(fragColor, fragCoord, ADDR_ATLAS_INFO, atlas_info);\n    store(fragColor, fragCoord, sentinel_address, SENTINEL_COLOR);\n}\n\n////////////////////////////////////////////////////////////////\n\n#define T(x0,y0,z0,x1,y1,z1) vec3(x0,y0,z0),vec3(x1,y1,z1)\n\nWRAP(Teleporters,teleporters,vec3,6)(T(208,1368,-0,256,1384,96),T(520,1368,-0,568,1384,96),T(840,1368,-0,888,1384,96)));\n\nbool touch_tele(vec3 pos, float radius)\n{\n    radius *= radius;\n    bool touch = false;\n    for (int i=0; i<6; i+=2)\n    {\n        vec3 mins = teleporters.data[i];\n        vec3 maxs = teleporters.data[i+1];\n        vec3 delta = clamp(pos, mins, maxs) - pos;\n        if (dot(delta, delta) <= radius)\n            touch = true;\n    }\n    return touch;\n}\n\n////////////////////////////////////////////////////////////////\n\n// returns true if processing should stop\nbool fire_weapon(inout vec4 fragColor, vec2 fragCoord,\n                 vec3 old_pos, vec3 old_angles,\n                 inout float attack_cycle, inout float shots_fired)\n{\n\tconst float ATTACK_DURATION = .75;\n    const float ATTACK_WAIT = 1. - 1./(ATTACK_DURATION*RATE_OF_FIRE);\n\n    if (attack_cycle > 0.)\n        attack_cycle = max(0., attack_cycle - iTimeDelta * (1./ATTACK_DURATION));\n    \n    bool wants_to_fire = cmd_attack() > 0.;\n    bool resolution_changed = any(notEqual(load(ADDR_RESOLUTION).xy, iResolution.xy));\n    if (attack_cycle > ATTACK_WAIT || !wants_to_fire || iFrame <= 0 || resolution_changed)\n        return false;\n\n    attack_cycle = 1.;\n    shots_fired += 1.;\n    if (is_inside(fragCoord, ADDR_RANGE_SHOTGUN_PELLETS) < 0.)\n        return false;\n    \n    Options options;\n    LOAD_PREV(options);\n    \n    float prev_downscale = get_downscale(options);\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame-1, iResolution.xy, prev_downscale);\n    vec2 ndc = hash2(iTime + fragCoord) * (WEAPON_SPREAD*2.) + -WEAPON_SPREAD;\n    vec2 coord = iResolution.xy * (ndc - ndc_scale_bias.zw) / ndc_scale_bias.xy;\n    mat3 prev_view_matrix = rotation(old_angles);\n    vec3 fire_dir = prev_view_matrix * unproject(ndc);\n    GBuffer gbuffer = gbuffer_unpack(texelFetch(iChannel2, ivec2(coord), 0));\n    vec3 normal = gbuffer.normal;\n\n    fragColor.xyz = old_pos + fire_dir * (gbuffer.z * VIEW_DISTANCE);\n    int material = (gbuffer.z > 12./VIEW_DISTANCE) ? gbuffer.material : MATERIAL_SKY1B;\n    fragColor.w = float(material);\n    \n    // prevent particles from clipping the ground when falling\n    // not using 0 as threshold since reconstructed normal isn't 100% accurate\n    if (normal.z > .01)\t\n        fragColor.z += 8.;\n    \n    return true;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid update_ideal_pitch(vec3 pos, vec3 forward, vec3 velocity, inout float ideal_pitch)\n{\n    if (iMouse.z > 0. || length_squared(velocity.xy) < sqr(WALK_SPEED/4.))\n        return;\n    \n    if (dot(forward, normalize(velocity)) < .7)\n    {\n        ideal_pitch = 0.;\n        return;\n    }\n    \n    // look up/down near stairs\n    // totally ad-hoc, but it kind of works...\n\tconst vec3 STAIRS[] = vec3[](vec3(272, 496, 24), vec3(816, 496, 24));\n\n    vec3 to_stairs = closest_point_on_segment(pos, STAIRS[0], STAIRS[1]) - pos;\n    float sq_dist = length_squared(to_stairs);\n    if (sq_dist < sqr(48.))\n        return;\n    \n    float facing_stairs = dot(to_stairs, forward);\n    if (sq_dist > (facing_stairs > 0. ? sqr(144.) : sqr(64.)))\n    {\n        ideal_pitch = 0.;\n        return;\n    }\n    \n    if (facing_stairs * inversesqrt(sq_dist) < .7)\n        return;\n\n    ideal_pitch = to_stairs.z < 0. ? -STAIRS_PITCH : STAIRS_PITCH;\n}\n\n////////////////////////////////////////////////////////////////\n\n#if 0 // 4:3\nconst vec3 SPAWN_POS\t\t= vec3(544, 296, 49);\nconst vec4 DEFAULT_ANGLES\t= vec4(0);\n#else\nconst vec3 SPAWN_POS\t\t= vec3(544, 272, 49);\nconst vec4 DEFAULT_ANGLES\t= vec4(0, 5, 5, 0);\n#endif\nconst vec4 DEFAULT_POS\t\t= vec4(SPAWN_POS, 0);\n\nvoid update_input(inout vec4 fragColor, vec2 fragCoord)\n{\n    float allow_input\t= is_input_enabled();\n    vec4 pos\t\t\t= (iFrame==0) ? DEFAULT_POS : load(ADDR_POSITION);\n    vec4 angles\t\t\t= (iFrame==0) ? DEFAULT_ANGLES : load(ADDR_ANGLES);\n    vec4 old_pos\t\t= (iFrame==0) ? DEFAULT_POS : load(ADDR_CAM_POS);\n    vec4 old_angles\t\t= (iFrame==0) ? DEFAULT_ANGLES : load(ADDR_CAM_ANGLES);\n    vec4 velocity\t\t= (iFrame==0) ? vec4(0) : load(ADDR_VELOCITY);\n    vec4 ground_plane\t= (iFrame==0) ? vec4(0) : load(ADDR_GROUND_PLANE);\n    bool thumbnail\t\t= (iFrame==0) ? true : (int(load(ADDR_RESOLUTION).z) & RESOLUTION_FLAG_THUMBNAIL) != 0;\n    \n    Transitions transitions;\n    LOAD_PREV(transitions);\n    \n    MenuState menu;\n    LOAD_PREV(menu);\n    if (iFrame > 0 && menu.open > 0)\n        return;\n    \n    if (iFrame == 0 || is_demo_mode_enabled(thumbnail))\n        allow_input = 0.;\n\n    if (allow_input > 0. && fire_weapon(fragColor, fragCoord, old_pos.xyz, old_angles.xyz, transitions.attack, transitions.shot_no))\n        return;\n    \n    Options options;\n    LOAD_PREV(options);\n\n    angles.w = max(0., angles.w - iTimeDelta);\n    if (angles.w == 0.)\n    \tangles.y = mix(angles.z, angles.y, exp2(-8.*iTimeDelta));\n\n\tvec4 mouse_status\t= (iFrame==0) ? vec4(0) : load(ADDR_PREV_MOUSE);\n    if (allow_input > 0.)\n    {\n        float mouse_lerp = MOUSE_FILTER > 0. ?\n            min(1., iTimeDelta/.0166 / (MOUSE_FILTER + 1.)) :\n        \t1.;\n        if (iMouse.z > 0.)\n        {\n            float mouse_y_scale = INVERT_MOUSE != 0 ? -1. : 1.;\n            if (test_flag(options.flags, OPTION_FLAG_INVERT_MOUSE))\n                mouse_y_scale = -mouse_y_scale;\n            float sensitivity = SENSITIVITY * exp2((options.sensitivity - 5.) * .5);\n            \n            if (iMouse.z > mouse_status.z)\n                mouse_status = iMouse;\n            vec2 mouse_delta = (iMouse.z > mouse_status.z) ?\n                vec2(0) : mouse_status.xy - iMouse.xy;\n            mouse_delta.y *= -mouse_y_scale;\n            angles.xy += 360. * sensitivity * mouse_lerp / max_component(iResolution.xy) * mouse_delta;\n            angles.z = angles.y;\n            angles.w = AUTOPITCH_DELAY;\n        }\n        mouse_status = vec4(mix(mouse_status.xy, iMouse.xy, mouse_lerp), iMouse.zw);\n    }\n    \n    float strafe = cmd_strafe();\n    float run = (cmd_run()*.5 + .5) * allow_input;\n    float look_side = cmd_look_left() - cmd_look_right();\n    angles.x += look_side * (1. - strafe) * run * TURN_SPEED * iTimeDelta;\n    float look_up = cmd_look_up() - cmd_look_down();\n    angles.yz += look_up * run * TURN_SPEED * iTimeDelta;\n    // delay auto-pitch for a bit after looking up/down\n    if (abs(look_up) > 0.)\n        angles.w = .5;\n    if (cmd_center_view() * allow_input > 0.)\n        angles.zw = vec2(0);\n    angles.x = mod(angles.x, 360.);\n    angles.yz = clamp(angles.yz, -80., 80.);\n\n#if NOCLIP\n    const bool noclip = true;\n#else\n    bool noclip = test_flag(options.flags, OPTION_FLAG_NOCLIP);\n#endif\n\n    mat3 move_axis = rotation(vec3(angles.x, noclip ? angles.y : 0., 0));\n\n    vec3 input_dir\t\t= vec3(0);\n    input_dir\t\t\t+= (cmd_move_forward() - cmd_move_backward()) * move_axis[1];\n    float move_side\t\t= cmd_move_right() - cmd_move_left();\n    move_side\t\t\t= clamp(move_side - look_side * strafe, -1., 1.);\n    input_dir\t \t\t+= move_side * move_axis[0];\n    input_dir.z \t\t+= (cmd_move_up() - cmd_move_down());\n    float wants_to_move = step(0., dot(input_dir, input_dir));\n    float wish_speed\t= WALK_SPEED * allow_input * wants_to_move * (1. + -.5 * run);\n\n    float lava_dist\t\t= max_component(abs(pos.xyz - clamp(pos.xyz, LAVA_BOUNDS[0], LAVA_BOUNDS[1])));\n\n\tif (noclip)\n    {\n        float friction = mix(NOCLIP_STOP_FRICTION, NOCLIP_START_FRICTION, wants_to_move);\n        float velocity_blend = exp2(-friction * iTimeDelta);\n        velocity.xyz = mix(input_dir * wish_speed, velocity.xyz, velocity_blend);\n        pos.xyz += velocity.xyz * iTimeDelta;\n        ground_plane = vec4(0);\n    }\n    else\n    {\n        // if not ascending, allow jumping when we touch the ground\n        if (input_dir.z <= 0.)\n            velocity.w = 0.;\n        \n        input_dir.xy = safe_normalize(input_dir.xy);\n        \n        bool on_ground = is_touching_ground(pos.xyz, ground_plane);\n        if (on_ground)\n        {\n            // apply friction\n            float speed = length(velocity.xy);\n            if (speed < 1.)\n            {\n                velocity.xy = vec2(0);\n            }\n            else\n            {\n                float drop = max(speed, STOP_SPEED) * GROUND_FRICTION * iTimeDelta;\n                velocity.xy *= max(0., speed - drop) / speed;\n            }\n        }\n        else\n        {\n            input_dir.z = 0.;\n        }\n\n        if (lava_dist <= 0.)\n            wish_speed *= .25;\n\n        // accelerate\n\t\tfloat current_speed = dot(velocity.xy, input_dir.xy);\n\t\tfloat add_speed = wish_speed - current_speed;\n\t\tif (add_speed > 0.)\n        {\n\t\t\tfloat accel = on_ground ? GROUND_ACCELERATION : AIR_ACCELERATION;\n\t\t\tfloat accel_speed = min(add_speed, accel * iTimeDelta * wish_speed);\n            velocity.xyz += input_dir * accel_speed;\n\t\t}\n\n        if (on_ground)\n        {\n            velocity.z -= (GRAVITY * .25) * iTimeDelta;\t// slowly slide down slopes\n            velocity.xyz -= dot(velocity.xyz, ground_plane.xyz) * ground_plane.xyz;\n\n            if (transitions.stair_step <= 0.)\n                transitions.bob_phase = fract(transitions.bob_phase + iTimeDelta * (1./BOB_CYCLE));\n\n            update_ideal_pitch(pos.xyz, move_axis[1], velocity.xyz, angles.z);\n\n            if (input_dir.z > 0. && velocity.w <= 0.)\n            {\n                velocity.z += JUMP_SPEED;\n                // wait for the jump key to be released\n                // before jumping again (no auto-hopping)\n                velocity.w = 1.;\n            }\n        }\n        else\n        {\n            velocity.z -= GRAVITY * iTimeDelta;\n        }\n\n        if (is_inside(fragCoord, ADDR_RANGE_PHYSICS) > 0.)\n            slide_move(pos.xyz, velocity.xyz, ground_plane, transitions.stair_step);\n    }\n\n    bool teleport = touch_tele(pos.xyz, 16.);\n    if (!noclip)\n    \tteleport = teleport || ((DEFAULT_POS.z - pos.z) > VIEW_DISTANCE); // falling too far below the map\n\n    if (cmd_respawn() * allow_input > 0. || teleport)\n    {\n        pos = vec4(DEFAULT_POS.xyz, iTime);\n        angles = teleport ? vec4(0) : DEFAULT_ANGLES;\n        velocity.xyz = vec3(0, teleport ? WALK_SPEED : 0., 0);\n        ground_plane = vec4(0);\n        transitions.stair_step = 0.;\n        transitions.bob_phase = 0.;\n    }\n    \n    // smooth stair stepping\n    transitions.stair_step = max(0., transitions.stair_step - iTimeDelta * STAIR_CLIMB_SPEED);\n\n    vec4 cam_pos = pos;\n    cam_pos.z -= transitions.stair_step;\n    \n    // bobbing\n    float speed = length(velocity.xy);\n    if (speed < 1e-2)\n        transitions.bob_phase = 0.;\n    cam_pos.z += clamp(speed * BOB_SCALE * (.3 + .7 * sin(TAU * transitions.bob_phase)), -7., 4.);\n    \n    vec4 cam_angles = vec4(angles.xy, 0, 0);\n    \n    // side movement roll\n    cam_angles.z += clamp(dot(velocity.xyz, move_axis[0]) * (1./ROLL_SPEED), -1., 1.) * ROLL_ANGLE;\n\n    // lava pain roll\n    if (lava_dist <= 32.)\n    \tcam_angles.z += 5. * clamp(fract(iTime*4.)*-2.+1., 0., 1.);\n    \n    // shotgun recoil\n    cam_angles.y += linear_step(.75, 1., transitions.attack) * RECOIL_ANGLE;\n\n    store(fragColor, fragCoord, ADDR_POSITION, pos);\n    store(fragColor, fragCoord, ADDR_ANGLES, angles);\n    store(fragColor, fragCoord, ADDR_CAM_POS, cam_pos);\n    store(fragColor, fragCoord, ADDR_CAM_ANGLES, cam_angles);\n    store(fragColor, fragCoord, transitions);\n    store(fragColor, fragCoord, ADDR_PREV_CAM_POS, old_pos);\n    store(fragColor, fragCoord, ADDR_PREV_CAM_ANGLES, old_angles);\n    store(fragColor, fragCoord, ADDR_PREV_MOUSE, mouse_status);\n    store(fragColor, fragCoord, ADDR_VELOCITY, velocity);\n    store(fragColor, fragCoord, ADDR_GROUND_PLANE, ground_plane);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid update_perf_stats(inout vec4 fragColor, vec2 fragCoord)\n{\n    vec4 perf = (iFrame==0) ? vec4(0) : load(ADDR_PERF_STATS);\n    perf.x = mix(perf.x, iTimeDelta*1000., 1./16.);\n    store(fragColor, fragCoord, ADDR_PERF_STATS, perf);\n    \n\t// shift old perf samples\n    const vec4 OLD_SAMPLES = ADDR_RANGE_PERF_HISTORY + vec4(1,0,-1,0);\n    if (is_inside(fragCoord, OLD_SAMPLES) > 0.)\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord)-ivec2(1,0), 0);\n\n    // add new sample\n    if (is_inside(fragCoord, ADDR_RANGE_PERF_HISTORY.xy) > 0.)\n    {\n        Options options;\n        LOAD_PREV(options);\n        fragColor = vec4(iTimeDelta*1000., get_downscale(options), 0., 0.);\n    }\n}\n\nvoid update_game_rules(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_RANGE_TARGETS) > 0.)\n    {\n        Target target;\n        Transitions transitions;\n        GameState game_state;\n        \n        from_vec4(target, fragColor);\n        LOAD_PREV(game_state);\n        LOAD_PREV(transitions);\n        float level = floor(game_state.level);\n        float index = floor(fragCoord.x - ADDR_RANGE_TARGETS.x);\n\n        if (target.level != level)\n        {\n            target.level = level;\n            target.shot_no = transitions.shot_no;\n            if (level > 0. || index == SKY_TARGET_OFFSET.x)\n            \ttarget.hits = 0.;\n            to_vec4(fragColor, target);\n            return;\n        }\n\n        // already processed this shot?\n        if (target.shot_no == transitions.shot_no)\n            return;\n        target.shot_no = transitions.shot_no;\n        \n        // disable popping during game over animation\n        if (game_state.level < 0. && game_state.level != floor(game_state.level))\n            return;\n\n        float target_material = index < float(NUM_TARGETS) ? index + float(BASE_TARGET_MATERIAL) : float(MATERIAL_SKY1);\n        int hits = 0;\n\n        // The smart thing to do here would be to split the sum over several frames\n        // in a binary fashion, but the shader is already pretty complicated,\n        // so to make my life easier I'll go with a naive for loop.\n        // To save face, let's say I'm doing this to avoid the extra latency\n        // of log2(#pellets) frames the smart method would incur...\n\n        for (float f=0.; f<ADDR_RANGE_SHOTGUN_PELLETS.z; ++f)\n        {\n            vec4 pellet = load(ADDR_RANGE_SHOTGUN_PELLETS.xy + vec2(f, 0.));\n            hits += int(pellet.w == target_material);\n        }\n        \n        // sky target is all or nothing\n        if (target_material == float(MATERIAL_SKY1))\n            hits = int(hits == int(ADDR_RANGE_SHOTGUN_PELLETS.z));\n        \n        target.hits += float(hits);\n        to_vec4(fragColor, target);\n\n        return;\n    }\n    \n    if (is_inside(fragCoord, ADDR_GAME_STATE) > 0.)\n    {\n        const float\n            ADVANCE_LEVEL\t\t\t= 1. + LEVEL_WARMUP_TIME * .1,\n        \tFIRST_ROUND_DURATION\t= 15.,\n        \tMIN_ROUND_DURATION\t\t= 6.,\n        \tROUND_TIME_DECAY\t\t= -1./8.;\n        \n        GameState game_state;\n        from_vec4(game_state, fragColor);\n        \n        MenuState menu;\n        LOAD(menu);\n        float time_delta = menu.open > 0 ? 0. : iTimeDelta;\n\n        if (game_state.level <= 0.)\n        {\n            float level = ceil(game_state.level);\n            if (level < 0. && game_state.level != level)\n            {\n                game_state.level = min(level, game_state.level + time_delta * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            Target target;\n            LOADR(SKY_TARGET_OFFSET, target);\n            if (target.hits > 0. && target.level == game_state.level)\n            {\n                game_state.level = ADVANCE_LEVEL;\n                game_state.time_left = FIRST_ROUND_DURATION;\n                game_state.targets_left = float(NUM_TARGETS);\n            }\n        }\n        else\n        {\n            float level = floor(game_state.level);\n            if (level != game_state.level)\n            {\n                game_state.level = max(level, game_state.level - time_delta * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            \n            game_state.time_left = max(0., game_state.time_left - time_delta);\n            if (game_state.time_left == 0.)\n            {\n                game_state.level = -(level + BALLOON_SCALEIN_TIME * .1);\n                to_vec4(fragColor, game_state);\n                return;\n            }\n            \n            float targets_left = 0.;\n            Target target;\n            for (vec2 addr=vec2(0); addr.x<ADDR_RANGE_TARGETS.z-1.; ++addr.x)\n            {\n                LOADR(addr, target);\n                if (target.hits < ADDR_RANGE_SHOTGUN_PELLETS.z * .5 || target.level != level)\n                    ++targets_left;\n            }\n            \n            if (floor(game_state.targets_left) != targets_left)\n                game_state.targets_left = targets_left + HUD_TARGET_ANIM_TIME * .1;\n            else\n                game_state.targets_left = max(floor(game_state.targets_left), game_state.targets_left - time_delta * .1);\n\n            if (targets_left == 0.)\n            {\n                game_state.level = level + ADVANCE_LEVEL;\n                game_state.time_left *= .5;\n                game_state.time_left += mix(MIN_ROUND_DURATION, FIRST_ROUND_DURATION, exp2(level*ROUND_TIME_DECAY));\n                game_state.targets_left = float(NUM_TARGETS);\n            }\n        }\n\n        to_vec4(fragColor, game_state);\n        return;\n    }\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid update_menu(inout vec4 fragColor, vec2 fragCoord)\n{\n#if ENABLE_MENU\n    if (is_inside(fragCoord, ADDR_MENU) > 0.)\n    {\n        MenuState menu;\n        if (iFrame == 0)\n            clear(menu);\n        else\n            from_vec4(menu, fragColor);\n\n    \tif (is_input_enabled() > 0.)\n        {\n            if (cmd_menu() > 0.)\n            {\n                menu.open ^= 1;\n            }\n            else if (menu.open > 0)\n            {\n                menu.selected += int(is_key_pressed(KEY_DOWN) > 0.) - int(is_key_pressed(KEY_UP) > 0.) + NUM_OPTIONS;\n                menu.selected %= NUM_OPTIONS;\n            }\n        }\n       \n        to_vec4(fragColor, menu);\n        return;\n    }\n    \n    if (is_inside(fragCoord, ADDR_OPTIONS) > 0.)\n    {\n        if (iFrame == 0)\n        {\n            Options options;\n            clear(options);\n            to_vec4(fragColor, options);\n            return;\n        }\n        \n        MenuState menu;\n        LOAD(menu);\n\n        int screen_size_field = get_option_field(OPTION_DEF_SCREEN_SIZE);\n        float screen_size = fragColor[screen_size_field];\n        if (is_key_pressed(KEY_1) > 0.) \tscreen_size = 10.;\n        if (is_key_pressed(KEY_2) > 0.) \tscreen_size = 8.;\n        if (is_key_pressed(KEY_3) > 0.) \tscreen_size = 6.;\n        if (is_key_pressed(KEY_4) > 0.) \tscreen_size = 4.;\n        if (is_key_pressed(KEY_5) > 0.) \tscreen_size = 2.;\n        if (max(is_key_pressed(KEY_MINUS), is_key_pressed(KEY_MINUS_FF)) > 0.)\n            screen_size -= 2.;\n        if (max(is_key_pressed(KEY_PLUS), is_key_pressed(KEY_PLUS_FF)) > 0.)\n            screen_size += 2.;\n        fragColor[screen_size_field] = clamp(screen_size, 0., 10.);\n        \n        int flags_field = get_option_field(OPTION_DEF_SHOW_FPS);\n        int flags = int(fragColor[flags_field]);\n\n        if (is_key_pressed(TOGGLE_TEX_FILTER_KEY) > 0.)\n            flags ^= OPTION_FLAG_TEXTURE_FILTER;\n        if (is_key_pressed(TOGGLE_LIGHT_SHAFTS_KEY) > 0.)\n            flags ^= OPTION_FLAG_LIGHT_SHAFTS;\n        if (is_key_pressed(TOGGLE_CRT_EFFECT_KEY) > 0.)\n            flags ^= OPTION_FLAG_CRT_EFFECT;\n        \n        if (is_key_pressed(SHOW_PERF_STATS_KEY) > 0.)\n        {\n            const int MASK = OPTION_FLAG_SHOW_FPS | OPTION_FLAG_SHOW_FPS_GRAPH;\n            // https://fgiesen.wordpress.com/2011/01/17/texture-tiling-and-swizzling/\n            // The line below combines Fabian Giesen's trick (offs_x = (offs_x - x_mask) & x_mask)\n            // with another one for efficient bitwise integer select (c = a ^ ((a ^ b) & mask)),\n            // which I think I also stole from his blog, but I can't find the link\n            flags ^= (flags ^ (flags - MASK)) & MASK;\n            \n            // don't show FPS graph on its own when using keyboard shortcut to cycle through options\n            if (test_flag(flags, OPTION_FLAG_SHOW_FPS_GRAPH))\n                flags |= OPTION_FLAG_SHOW_FPS;\n        }\n        \n        fragColor[flags_field] = float(flags);\n\n        if (menu.open <= 0)\n            return;\n        float adjust = is_key_pressed(KEY_RIGHT) - is_key_pressed(KEY_LEFT);\n\n        MenuOption option = get_option(menu.selected);\n        int option_type = get_option_type(option);\n        int option_field = get_option_field(option);\n        if (option_type == OPTION_TYPE_SLIDER)\n        {\n            fragColor[option_field] += adjust;\n            fragColor[option_field] = clamp(fragColor[option_field], 0., 10.);\n        }\n        else if (option_type == OPTION_TYPE_TOGGLE && (abs(adjust) > .5 || is_key_pressed(KEY_ENTER) > 0.))\n        {\n            int value = int(fragColor[option_field]);\n            value ^= get_option_range(option);\n            fragColor[option_field] = float(value);\n        }\n        \n        return;\n    }\n#endif // ENABLE_MENU\n}\n\nvoid advance_time(inout vec4 fragColor, vec2 fragCoord)\n{\n    if (is_inside(fragCoord, ADDR_TIMING) > 0.)\n    {\n        MenuState menu;\n        LOAD_PREV(menu);\n        \n        Timing timing;\n        if (iFrame == 0)\n            clear(timing);\n        else\n        \tfrom_vec4(timing, fragColor);\n\n        bool paused = timing.prev == iTime;\n        if (paused)\n            timing.flags |= TIMING_FLAG_PAUSED;\n        else\n            timing.flags &= ~TIMING_FLAG_PAUSED;\n        \n        // Note: on 144 Hz monitors, in thumbnail mode, iTimeDelta\n        // seems to be incorrect (1/60 seconds instead of 1/144)\n        float time_delta = iTime - timing.prev;\n        if (!paused && menu.open == 0 && g_time > WORLD_RENDER_TIME)\n            timing.anim += time_delta;\n        timing.prev = iTime;\n        \n        to_vec4(fragColor, timing);\n        return;\n    }\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tif (iFrame > 0 && is_inside(fragCoord, ADDR_RANGE_PARAM_BOUNDS) < 0.)\n    \tDISCARD;\n\n    fragColor = (iFrame==0) ? vec4(0) : texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    Lighting lighting;\n    LOAD_PREV(lighting);\n    \n    UPDATE_TIME(lighting);\n\n    write_map_data\t\t(fragColor, fragCoord);\n    update_tiles\t\t(fragColor, fragCoord);\n    update_input\t\t(fragColor, fragCoord);\n    update_game_rules\t(fragColor, fragCoord);\n    update_perf_stats\t(fragColor, fragCoord);\n    update_menu\t\t\t(fragColor, fragCoord);\n    advance_time\t\t(fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n// Buffer B: map/lightmap rendering\n// - ray-tracing for the world brushes\n// - ray-marching for the entities\n// - GBuffer output\n////////////////////////////////////////////////////////////////\n\n#define RENDER_WORLD\t\t\t\t3\t\t// 0=off; 1=axial brushes; 2=non-axial brushes; 3=all\n#define RENDER_ENTITIES\t\t\t\t1\n#define RENDER_WEAPON\t\t\t\t1\n\n#define USE_PARTITION\t\t\t\t3\t\t// 0=off; 1=axial brushes; 2=non-axial brushes; 3=all\n#define USE_ENTITY_AABB\t\t\t\t1\n\n#define DEBUG_ENTITY_AABB\t\t\t0\n\n#define ENTITY_RAYMARCH_STEPS\t\t96\n#define ENTITY_RAYMARCH_TOLERANCE\t1.0\n#define ENTITY_LIGHT_DIR\t\t\tnormalize(vec3(.5, 1, -.5))\n#define ENTITY_MIN_LIGHT\t\t\t0.3125\n#define DITHER_ENTITY_NORMALS\t\t1\n\n#define LIGHTMAP_FILTER\t\t\t\t1\t\t// 0=off; 1=linear, 1/16 UV increments; 2=linear\n#define QUANTIZE_LIGHTMAP\t\t\t24\t\t// only when texture filtering is off; comment out to disable\n#define QUANTIZE_DYNAMIC_LIGHTS\t\t32\t\t// only when texture filtering is off; comment out to disable\n\n// Lightmap baking settings: changing these requires a restart\n#define LIGHTMAP_HEIGHT_OFFSET\t\t0.1\n#define LIGHTMAP_EXTRAPOLATE\t\t1.0\t\t// max distance from brush edge, in texels\n\n#define LIGHTMAP_SCALEDIST\t\t\t1.0\n#define LIGHTMAP_SCALECOS\t\t\t0.5\n#define LIGHTMAP_RANGESCALE\t\t\t0.7\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define BAKE_LIGHTMAP\t\t\t\t1\n#define COMPRESSED_BRUSH_OFFSETS\t1\n#define SETTINGS_CHANNEL\t\t\tiChannel0\n#define NOISE_CHANNEL\t\t\t\tiChannel2\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n////////////////////////////////////////////////////////////////\n//\n// World data\n//\n// Generated from a trimmed/tweaked version of\n// the original map by John Romero\n// https://rome.ro/news/2016/2/14/quake-map-sources-released\n//\n// Split between Buffer A and B to even out compilation time\n////////////////////////////////////////////////////////////////\n\nconst vec3 AXIAL_MINS=vec3(48,176,-192), AXIAL_MAXS=vec3(1040,1424,336);\n\nWRAP(AxialBrushes,axial_brushes,int,NUM_MAP_AXIAL_BRUSHES*2)(1073156,8464628,8431646,0xa8b822,8431622,0xa8b80a,8431854,0xa8b8f2,\n8431830,0xa8b8da,8426512,0xa89c18,8426720,0xa89ce8,8439008,0xa8cce8,8438800,0xa8cc18,31483956,33630264,31484096,33630404,\n31483960,33583296,8419328,25241604,8419572,25241848,0xc0003c,25168060,0xb07854,0xc088a4,8390660,0xc060f4,0xc02874,0xc44884,\n0x998890,0xaa089c,0x99885c,0xaa0868,1134788,7430356,0x99886c,0xaa088c,1167556,8519892,8513700,9572592,1124376,7473180,75804,\n1183984,1140816,0xe18858,1181720,7477308,1183804,9574562,8493060,0xa1b808,1151088,0x99a088,1171568,0x99f088,1126508,7422092,\n7415900,8472732,7415872,8523852,7415816,8523836,1183906,9574640,1157280,0xe1c8a4,3745880,3805344,5318820,5378288,3221532,3280976\n,29435992,29968544,1124432,25249884,34154584,34687136,1124588,34687220,29435916,34687064,29436064,34687212,1124508,25249960,\n8464384,34686988,29960280,34162848,1132624,28403800,8472580,28416008,23160912,28411992,23173124,28424200,0xe1a8a2,23185572,\n1132704,33663140,23177376,33671332,0xa19800,23181316,0xe16850,23169110,1149008,28446808,8501252,32663560,1132784,33712372,\n1165472,33689764,0xa2109c,25309352,0xa21050,25309276,9572360,29503500,0xa210ec,29503728,29495304,33698032,0xa23054,32139352,\n8521736,9594940,0xa230a0,33712292,19028166,20078802,0xb258c6,0xc260d2,0xb258c0,20078790,0xb258d2,20078808,0xb25870,0xc26088,\n19028080,20078728,0xc25870,19030134,0xb25834,20078650,0xc25882,19030152,0xb25828,0xc26034,19028008,20078644,0xb25822,20078632,\n0xc25c28,19030068,0xc25c76,19030146,0xc25cc6,19030226,0xa26808,29520034,0xa268a4,33714416));\n\nWRAP(Brushes,brushes,int,NUM_MAP_PACKED_BRUSH_OFFSETS)(18822,805254,1591686,2378118,3164550,3950982,4737414,5522822,6241605,\n6931846,7685510,8439174,9160005,9913734,0xa23d45,0xac4966,0xb7c565,0xc35186,0xcfbd45,0xd9c166,0xe43d45,0xeebd45,0xf894a5));\n\n#define M(x)  x*0x111111,\n#define M2(x) M(x)M(x)\n#define M4(x) M2(x)M2(x)\n#define M8(x) M4(x)M4(x)\n\nconst int NUM_MATERIAL_ENTRIES = 162;\nWRAP(Materials,materials,int,NUM_MATERIAL_ENTRIES)(1315089,M8(2)M2(0)M(0)M2(1)M(1)M2(6)M(10)M4(0)M2(0)M4(1)M2(1)M2(3)M(3)M2(4)M(\n4)M(5)1118485,M(11)M(12)M(13)M8(0)61440,M4(1)5592549,1118485,1118485,M(9)1118494,M2(1)M(5)1118485,M4(0)M(0)M(1)M(4)1118485,M8(0)\nM4(0)M2(8)M(8)M(1)M(5)M8(2)M8(2)M4(6)M4(0)M(0)M4(3)M(3)M(0)17<<16,M(1)7829265,7,3355440,M(3)7829363,M(0)M2(3)489335,1<<22,M(4)\n1328196,M2(1)M(1)4473921,68,M8(0)1118464,4473921,5592388,M(5)M4(0)M(7)M2(0)M(0)M2(7)1911,0));\n\n// Geometry partitions /////////////////////////////////////////\n\nconst int\n    NUM_AXIAL_NODES = 10,\n    NUM_NONAXIAL_NODES = 10\n;\n\nstruct PackedNode\n{\n    int begin;\n    int end;\n};\n    \nconst struct BVL\n{\n    PackedNode axial[NUM_AXIAL_NODES];\n    PackedNode nonaxial[NUM_NONAXIAL_NODES];\n}\nbvl = BVL\n(\n\t#define N PackedNode\n\n\tN[10](N(687940864,857812285),N(855714048,991967529),N(301999361,688800572),N(17306113,0x90b1a3d),N(68609,17311037),N(\n\t989931777,0x3f204d3d),N(289<<19,304096574),N(0x3f084102,0x47204d3c),N(0x470b4b08,0x56134c36),N(0x560a4d02,0x58204e3c)),\n\n\tN[10](N(721429511,856174140),N(856041751,0x3c0a3937),N(0x4c132524,0x531b3c3d),N(461825,336403005),N(0x41162501,\n\t0x4c1e4d28),N(587663104,656286989),N(654772016,723395901),N(0x3c003902,0x41094d3c),N(336003073,589238333),N(0x53163d24,\n\t0x591b4d3b))\n\n    #undef N\n);\n\nconst vec3\n\tAXIAL_BVL_MINS      = vec3(48,176,-192),\n\tNONAXIAL_BVL_MINS   = vec3(48,176,-176);\n\nstruct Node\n{\n    vec3 mins;\n    int begin;\n    vec3 maxs;\n    int end;\n};\n    \nivec3 unpack888(int n)\n{\n    return (ivec3(n) >> ivec3(0,8,16)) & 255;\n}\n\nNode unpack(const PackedNode p, vec3 bias)\n{\n    Node n;\n    n.mins\t= vec3(unpack888(p.begin)) * 16. + bias;\n    n.begin\t= int(uint(p.begin) >> 24);\n    n.maxs\t= vec3(unpack888(p.end)) * 16. + bias;\n    n.end\t= int(uint(p.end >> 24));\n    return n;\n}\n\n// Lightmap UV-mapping /////////////////////////////////////////\n\nconst float LIGHTMAP_SCALE = 16.;\nconst vec2 LIGHTMAP_OFFSET = vec2(-169.5,-260.5);\n#define _ -1\nWRAP(LightmapOffsets,LIGHTMAP_OFFSETS,int,NUM_MAP_PLANES)(_,_,121456,_,145069,_,6702,2603,4629,6677,24073,_,8747,_,6169,12800,\n22534,_,_,12831,12870,12873,25655,_,2606,4654,8774,10822,20096,_,12843,_,4120,6168,19465,_,_,8238,10316,12364,22592,_,_,16415,\n16442,16448,22592,_,16427,_,16405,4124,25609,_,21180,22716,_,63045,57526,86682,18108,19644,_,21639,74457,52412,_,_,106628,115243\n,123991,123956,75844,_,_,_,_,_,_,75867,_,_,_,_,_,_,104492,_,_,_,7190,2588,78447,_,78953,_,_,_,120944,_,139376,_,_,_,25763,_,\n16450,_,_,64101,18491,2141,56466,47767,64067,_,7333,8869,47758,65157,7772,22100,22107,_,_,_,_,64084,29749,29758,56466,65170,\n20087,24183,_,15974,_,_,_,_,_,76910,100930,100970,72404,_,_,_,_,_,_,_,_,_,135347,_,121398,32399,_,_,56335,_,11379,_,_,6747,_,_,_\n,_,_,41142,_,_,20040,_,_,_,100912,_,41528,3205,3185,41572,_,_,3218,24721,41565,1710,_,_,_,_,33369,_,_,_,_,_,52318,_,79488,79471,\n94282,95306,_,_,119823,119827,76500,_,_,_,119827,119841,_,_,_,1743,_,_,39575,46743,_,_,60585,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_\n,_,_,_,87092,87111,_,82502,8921,19127,72316,72304,_,_,_,_,89121,75861,82521,_,_,73433,56551,39655,106038,_,_,_,72300,72280,85572\n,85552,_,_,69265,72277,85569,85629,32435,19122,72327,72331,_,_,38078,_,35978,24720,46624,_,_,_,66175,66156,_,_,22749,68806,89615\n,_,_,_,10427,_,35970,_,_,_,29274,32842,_,_,_,148495,32838,_,_,_,_,53323,22651,27259,_,_,_,_,89784,89771,89727,_,50815,_,35471,\n138298,_,_,87586,101952,29845,_,_,_,_,_,36467,31859,_,_,_,_,55008,68832,_,68772,_,_,75966,_,_,24717,_,_,_,89821,_,_,_,_,89764,\n89774,_,89729,_,_,45230,102037,45190,29832,_,_,16057,45235,37501,29821,_,_,76360,_,52865,52863,_,_,_,43209,43174,14004,_,_,_,_,\n128056,125496,_,152750,64717,76884,_,_,_,_,1216,_,_,77857,54379,_,76900,76892,_,_,_,_,_,_,_,6246,47215,80432,_,_,_,35906,80459,_\n,7820,51789,_,21609,69163,_,_,46303,_,46639,105665,_,_,_,_,3185,80456,_,_,_,_,39487,_,80465,49404,_,_,12391,_,_,_,10410,_,12358,\n_,_,_,32508,_,9297,_,_,_,_,_,79373,54282,_,_,_,_,15881,_,55314,29853,_,_,16961,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,\n109639,158323,_,_,_,_,76929,_,_,_,7708,14929,12877,28355,29891,_,_,8786,10834,29245,29249,132145,20116,3130,5175,23087,96365,\n32876,27716,_,23078,3189,23082,54845,38970,23073,15934,37994,28733,48696,29251,23065,4160,23121,37473,16950,_,_,7686,27666,29696\n,10303,_,7689,_,32265,32268,_,_,3105,8733,32774,36352,6184,_,14878,16926,36369,36373,43047,25614,7226,11319,21038,_,21121,28163,\n13370,21045,4224,28674,32827,32793,28745,21050,17472,26653,_,5178,_,2182,33341,33350,45096,25714,8251,13371,37889,96769,_,17983,\n18483,_,35916,21584,77957,_,122411,_,65562,2140,94293,_,144951,_,20585,21609,_,_,53945,_,35881,79379,77468,_,114816,_,11868,\n110103,_,_,57465,57478,45702,44166,_,_,52822,57864,126985,76294,_,_,_,_,30328,23672,13440,13938,_,_,17000,110602,57412,57399,_,_\n,36483,133162,_,_,116276,_,119383,118399,_,32403,_,_,12983,42156,38513,_,_,_,23145,38505,52368,_,_,_,42107,12928,30868,_,_,_,\n23142,23154,_,_,16450,30762,29224,_,_,22038,18969,22033,_,_,_,_,52864,_,_,_,_,63615,_,_,_,133177,116349,_,_,43606,48214,81414,\n82950,56926,_,_,_,51806,36452,22692,_,_,_,42095,22651,_,_,_,104506,104493,_,_,57413,57426,79926,24218,_,57391,_,_,36513,44184,_,\n32415,_,_,42159,42162,_,_,_,104581,104567,28727,52277,78997,75925,19513,28720,_,_,_,33387,42086,7735,_,_,_,66719,30826,64066,_,_\n,_,14935,3675,_,_,_,18519,7259,_,_,_,_,18011,_,_,_,_,90,_,_,50742,_,82503,82485,22571,_,36427,_,_,43618,57949,36418,_,_,_,34389,\n38997,_,_,_,_,39011,34403,_,53819,53815,12492,8252,_,45125,45121,2112,13884,_,96302,52816,13878,13874,_,53838,55856,34378,9282,_\n,31802,38955,3639,103471,_,59004,146045,9260,1095,_,94293,89683,89698,1126,22675,_,_,_,_,21120,_,_,_,113221,158894,158835,78355,\n_,_,_,_,22133,_,_,_,_,7801,52761,52771,_,_,33331,27218,_,_,28758,25686,_,45654,_,_,49255,49245,75815,48231,47685,47675,_,_,33380\n,22127,_,_,66737,_,104607,87199,_,_,76344,76367,97396,_,144920,47200,_,47651,47641,_,51275,_,47631,47621,_,58443,_,_,_,_,141895,\n_,_,_,91305,77993,_,_,_,53405,53416,44652,41580,_,_,33356,16978,_,50798,42057,79430,66629,_,39504,39513,63074,66609,_,39488,\n37440,64594,67671,_,40009,40018,62560,64603,_,40025,50777,48241,64606,_,38522,35450,_,48762,52830,52820,_,_,33370,19567,_,50767,\n40034,80965,72236,_,36972,_,54880,62041,_,_,36964,50797,58470,_,11396,35933,51804,48220,_,52824,52814,_,61050));\n#undef _\n\n////////////////////////////////////////////////////////////////\n\nuvec3 unpack(int data, const ivec3 bits)\n{\n    uvec3 mask = (uvec3(1) << bits) - 1u;\n\tuvec3 shift = uvec3(0, bits.x, bits.x + bits.y);\n    return (uvec3(data) >> shift) & mask;\n}\n\nvec3 get_axial_point(int index)\n{\n    return vec3(unpack(axial_brushes.data[index], ivec3(9))) * 4. + AXIAL_MINS;\n}\n\nint get_nonaxial_brush_start(int index)\n{\n#if COMPRESSED_BRUSH_OFFSETS\n    int data = brushes.data[index >> 2], base = data >> 15;\n    return base + (((data << 5) >> (uint(index & 3) * 5u)) & 31);\n#else\n    return brushes.data[index];\n#endif\n}\n\nvec4 get_nonaxial_plane(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_NONAXIAL_PLANES.xy) + ivec2(index&127,index>>7);\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nvec4 get_plane(int index)\n{\n    vec4 plane;\n    \n    if (index < NUM_MAP_AXIAL_PLANES)\n    {\n        uint\n            brush = uint(index) / 6u,\n        \tside = uint(index) % 6u,\n        \taxis = side >> 1,\n        \tfront = side & 1u;\n        vec3 p = get_axial_point(int(brush * 2u + (front ^ 1u)));\n        plane = vec4(0);\n        plane[axis] = front == 1u ? -1. : 1.;\n        plane.w = -p[axis] * plane[axis];\n    }\n    else\n    {\n        plane = get_nonaxial_plane(index - NUM_MAP_AXIAL_PLANES);\n    }\n    \n    return plane;\n}\n\nint get_plane_material(mediump int plane_index)\n{\n    // An encoding that only needs bit shifts/masks to decode\n    // (like 4x8b, 4x4b or 8x4b) would be a much smarter choice.\n    // On the other hand, 6x4b leads to a shorter textual encoding\n    // for the array (and a slower decoding sequence).\n    // Let's pretend character count matters and go with 6x4b...\n    \n    // Side note: we can use just 4 bits for each plane material id\n    // because the material list is sorted by frequency of use\n    // before the id's are assigned, and it just so happens that the map\n    // currently uses only 16 materials. If we wanted to add just one more\n    // we'd have to bump up the number of bits per face to 5.\n    \n    // better division/modulo codegen for unsigned ints:\n    // http://shader-playground.timjones.io/a05d99ce3e6e1ae57ef111c8323e52d2\n    mediump uint index = uint(plane_index);\n    \n    mediump uint unit_index = index / 6u;\n    lowp uint bit_index = index % 6u;\n    bit_index <<= 2;\n    int code = uint(unit_index) < uint(NUM_MATERIAL_ENTRIES) ? materials.data[uint(unit_index)] : 0;\n\n    return 15 & (code >> bit_index);\n}\n\nint get_axial_brush_material(int brush, lowp int side)\n{\n    // Since we chose 6x4b and axial brushes happen to have 6 sides, the math gets easier\n    int code = uint(brush) < uint(NUM_MATERIAL_ENTRIES) ? materials.data[uint(brush)] : 0;\n    return 15 & (code >> (side << 2));\n}\n\n// Axial UV mapping ////////////////////////////////////////////\n\nvec2 uv_map_axial(vec3 pos, int axis)\n{\n    return (axis==0) ? pos.yz : (axis==1) ? pos.xz : pos.xy;\n}\n\nvec3 uv_unmap(vec2 uv, vec4 plane, int axis)\n{\n    switch (axis)\n    {\n        case 0: return vec3(-(plane.w + dot(plane.yz, uv)) / plane.x, uv.x, uv.y);\n        case 1: return vec3(uv.x, -(plane.w + dot(plane.xz, uv)) / plane.y, uv.y);\n        case 2: return vec3(uv.x, uv.y, -(plane.w + dot(plane.xy, uv)) / plane.z);\n        default:\n        \treturn vec3(0);\n    }\n}\n\nvec3 uv_unmap(vec2 uv, vec4 plane)\n{\n    return uv_unmap(uv, plane, dominant_axis(plane.xyz));\n}\n\n///////////////////////////////////////////////////////////////\n\nvec2 sdf_union(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat sdf_ellipsoid(vec3 p, vec3 r)\n{\n    return (length(p/r) - 1.) / min3(r.x, r.y, r.z);\n}\n\nfloat sdf_sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdf_box(vec3 p, vec3 center, vec3 half_bound)\n{\n    p = abs(p - center) - half_bound;\n    return max3(p.x, p.y, p.z);\n}\n\n// iq\nfloat sdf_round_box(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p) - b, 0.)) - r;\n}\n\nfloat sdf_torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xy), p.z );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// http://mercury.sexy/hg_sdf\n// Cone with correct distances to tip and base circle. Z is up, 0 is in the middle of the base.\nfloat sdf_cone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xy), p.z);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound(float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    return sdf_sphere(p - mix(a, b, t), radius);\n}\n\n// this is not quite right\n// see https://www.shadertoy.com/view/4lcBWn for a correct solution\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float radius_a, float radius_b)\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    return sdf_sphere(p - mix(a, b, t), mix(radius_a, radius_b, t));\n}\n\n////////////////////////////////////////////////////////////////\n\nstruct Closest\n{\n    vec3 point;\n    float distance_squared;\n};\n\nClosest init_closest(vec3 p, vec3 first)\n{\n    return Closest(first, length_squared(p - first));\n}\n\nvoid update_closest(vec3 p, inout Closest closest, vec3 candidate)\n{\n    float distance_squared = length_squared(p - candidate);\n    if (distance_squared < closest.distance_squared)\n    {\n        closest.distance_squared = distance_squared;\n        closest.point = candidate;\n    }\n}\n\n#define FIND_CLOSEST(point, closest, vecs, len)\t\\\n\tclosest = init_closest(point, vecs[0]);\t\t\\\n    for (int i=1; i<len; ++i)\t\t\t\t\t\\\n        update_closest(p, closest, vecs[i])\t\t\\\n\n////////////////////////////////////////////////////////////////\n\nfloat overshoot(float x, float amount)\n{\n    amount *= .5;\n    return x + amount + amount*sin(x * TAU + -PI/2.);\n}\n\nfloat fast_sqrt(float x2)\n{\n    return x2 * inversesqrt(x2);\n}\n\nvec2 bounding_sphere(const float distance_squared, const float radius, const int material)\n{\n    return vec2(fast_sqrt(distance_squared)+-radius, material);\n}\n\nbool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, float max_t, vec3 aabb_mins, vec3 aabb_maxs)\n{\n    vec3 t0 = (aabb_mins - ray_origin) * rcp_ray_delta;\n    vec3 t1 = (aabb_maxs - ray_origin) * rcp_ray_delta;\n    vec4 tmin = vec4(min(t0, t1), 0.);\n    vec4 tmax = vec4(max(t0, t1), max_t);\n    return max_component(tmin) <= min_component(tmax);\n}\n\nbool ray_vs_aabb(vec3 ray_origin, vec3 rcp_ray_delta, vec3 aabb_mins, vec3 aabb_maxs)\n{\n    return ray_vs_aabb(ray_origin, rcp_ray_delta, 1., aabb_mins, aabb_maxs);\n}\n\n// Minimalistic quaternion support /////////////////////////////\n\nstruct Quaternion\n{\n    float s;\n    vec3 v;\n};\n\nQuaternion axis_angle(vec3 axis, float angle)\n{\n    angle = radians(angle * .5);\n    return Quaternion(cos(angle), sin(angle) * axis);\n}\n\nQuaternion mul(Quaternion lhs, Quaternion rhs)\n{\n    return Quaternion(lhs.s * rhs.s - dot(lhs.v, rhs.v), lhs.s * rhs.v + rhs.s * lhs.v + cross(lhs.v, rhs.v));\n}\n\nQuaternion conjugate(Quaternion q)\n{\n    return Quaternion(q.s, -q.v);\n}\n\nQuaternion euler_to_quat(vec3 angles)\n{\n    Quaternion\n        q0 = axis_angle(vec3(0, 0, 1), angles.x),\n        q1 = axis_angle(vec3(1, 0, 0), angles.y),\n        q2 = axis_angle(vec3(0, 1, 0),-angles.z);\n    return mul(q0, mul(q1, q2));\n}\n\nvec3 rotate(Quaternion q, vec3 v)\n{\n    // https://fgiesen.wordpress.com/2019/02/09/rotating-a-single-vector-using-a-quaternion/\n    vec3 t = 2. * cross(q.v, v);\n    return v + q.s * t + cross(q.v, t);\n}\n\n////////////////////////////////////////////////////////////////\n\nconst int\n    NUM_TORCHES\t\t\t\t\t= 3,\n    NUM_LARGE_FLAMES\t\t\t= 2,\n    NUM_ZOMBIES\t\t\t\t\t= 4,\n    NUM_BALLOONS\t\t\t\t= 14,\n    NUM_BALLOON_SETS\t\t\t= 3\n;\n\nconst struct EntityPositions\n{\n    vec3 torches[NUM_TORCHES];\n    vec3 large_flames[NUM_LARGE_FLAMES];\n    vec3 zombies[NUM_ZOMBIES];\n    vec3 balloons[NUM_BALLOONS];\n    uint balloon_sets[NUM_BALLOON_SETS];\n}\ng_ent_pos = EntityPositions\n(\n\tvec3[3](vec3(698,764,84),vec3(394,762,84),vec3(362,1034,20)),\n\tvec3[2](vec3(126,526,12),vec3(958,526,12)),\n\tvec3[4](vec3(1004,928,72),vec3(1004,1048,124),vec3(708,992,52),vec3(708,1116,120)),\n\tvec3[14](vec3(848,896,152),vec3(128,528,144),vec3(960,528,144),vec3(344,1064,168),vec3(440,1344,208),vec3(696,744,224),\n             vec3(664,1056,136),vec3(984,1336,176),vec3(392,744,200),vec3(120,1336,208),vec3(104,1000,96),vec3(656,1328,216),\n             vec3(472,1096,-112),vec3(416,936,112)),\n\tuint[3](0xa9865320u,0xdcba8510u,0x76543210u)\n);\n\nconst uint\n    ENTITY_BIT_TARGET\t\t\t= 0u,\n    ENTITY_BIT_VIEWMODEL\t\t= uint(NUM_TARGETS),\n    ENTITY_BIT_LARGE_FLAMES\t\t= ENTITY_BIT_VIEWMODEL + 1u,\n    ENTITY_BIT_TORCHES\t\t\t= ENTITY_BIT_LARGE_FLAMES + 1u,\n    ENTITY_BIT_FIREBALL\t\t\t= ENTITY_BIT_TORCHES + 1u,\n\n    ENTITY_MASK_TARGETS\t\t\t= (1u << NUM_TARGETS) - 1u,\n    ENTITY_MASK_LARGE_FLAMES\t= (1u << NUM_LARGE_FLAMES) - 1u,\n    ENTITY_MASK_TORCHES\t\t\t= (1u << NUM_TORCHES) - 1u\n;\n    \nstruct FlameState\n{\n    float loop;\n    vec2 sin_cos;\n};\n\nstruct FireballState\n{\n    vec3 offset;\n    Quaternion rotation;\n};\n\nstruct TargetState\n{\n    uint indices;\n    float scale;\n};\n    \nstruct ViewModelState\n{\n    vec3 offset;\n    float attack;\n    Quaternion rotation;\n};\n\nstruct EntityState\n{\n    FlameState\t\tflame;\n    FireballState\tfireball;\n    ViewModelState\tviewmodel;\n    TargetState\t\ttarget;\n    uint\t\t\tmask;\n};\n    \nEntityState g_entities;\n\nvoid update_entity_state(vec3 camera_pos, vec3 camera_angles, vec3 direction, float depth, bool is_thumbnail)\n{\n    g_entities.mask = 0u;\n    \n    g_entities.flame.loop\t\t\t= fract(floor(g_animTime * 10.) * .1);\n    g_entities.flame.sin_cos\t\t= vec2(sin(g_entities.flame.loop * TAU), cos(g_entities.flame.loop * TAU));\n    g_entities.fireball.offset\t\t= get_fireball_offset(g_animTime);\n    g_entities.fireball.rotation\t= axis_angle(normalize(vec3(1, 8, 4)), g_animTime * 360.);\n\n    float base_fov_y = scale_fov(FOV, 9./16.);\n    float fov_y = compute_fov(iResolution.xy).y;\n    float fov_y_delta = base_fov_y - fov_y;\n\n    vec3 velocity = load(ADDR_VELOCITY).xyz;\n    Transitions transitions;\n    LOAD(transitions);\n    float offset = get_viewmodel_offset(velocity, transitions.bob_phase, transitions.attack);\n    g_entities.viewmodel.offset\t\t= camera_pos;\n    g_entities.viewmodel.rotation\t= mul(euler_to_quat(camera_angles), axis_angle(vec3(1,0,0), fov_y_delta*.5));\n    g_entities.viewmodel.offset\t\t+= rotate(g_entities.viewmodel.rotation, vec3(0,1,0)) * offset;\n    g_entities.viewmodel.rotation\t= conjugate(g_entities.viewmodel.rotation);\n    g_entities.viewmodel.attack\t\t= linear_step(.875, 1., transitions.attack);\n    \n#if USE_ENTITY_AABB\n    #define TEST_AABB(pos, rcp_delta, mins, maxs) ray_vs_aabb(pos, rcp_delta, mins, maxs)\n#else\n    #define TEST_AABB(pos, rcp_delta, mins, maxs) true\n#endif\n    \n    Options options;\n    LOAD(options);\n    \n    const vec3 VIEWMODEL_MINS = vec3(-1.25,       0, -8);\n    const vec3 VIEWMODEL_MAXS = vec3( 1.25,      18, -4);\n    vec3 viewmodel_ray_origin = vec3(    0, -offset,  0);\n    vec3 viewmodel_ray_delta  = rotate(g_entities.viewmodel.rotation, direction);\n    bool draw_viewmodel = is_demo_mode_enabled(is_thumbnail) ? (g_demo_scene & 1) == 0 : true;\n    draw_viewmodel = draw_viewmodel && test_flag(options.flags, OPTION_FLAG_SHOW_WEAPON);\n    if (draw_viewmodel && TEST_AABB(viewmodel_ray_origin, 1./viewmodel_ray_delta, VIEWMODEL_MINS, VIEWMODEL_MAXS))\n        g_entities.mask |= 1u << ENTITY_BIT_VIEWMODEL;\n    \n    vec3 inv_world_ray_delta = 1./(direction*depth);\n\n    const vec3 TORCH_MINS = vec3(-4, -4, -28);\n\tconst vec3 TORCH_MAXS = vec3( 4,  4,  18);\n    for (int i=0; i<NUM_TORCHES; ++i)\n        if (TEST_AABB(camera_pos - g_ent_pos.torches[i], inv_world_ray_delta, TORCH_MINS, TORCH_MAXS))\n            g_entities.mask |= (1u<<ENTITY_BIT_TORCHES) << i;\n    \n    const vec3 LARGE_FLAME_MINS = vec3(-10, -10, -18);\n\tconst vec3 LARGE_FLAME_MAXS = vec3( 10,  10,  34);\n    for (int i=0; i<NUM_LARGE_FLAMES; ++i)\n        if (TEST_AABB(camera_pos - g_ent_pos.large_flames[i], inv_world_ray_delta, LARGE_FLAME_MINS, LARGE_FLAME_MAXS))\n            g_entities.mask |= (1u<<ENTITY_BIT_LARGE_FLAMES) << i;\n        \n\tconst vec3 FIREBALL_MINS = vec3(-10);\n\tconst vec3 FIREBALL_MAXS = vec3( 10);\n    if (g_entities.fireball.offset.z > 8. &&\n        TEST_AABB(camera_pos - FIREBALL_ORIGIN - g_entities.fireball.offset, inv_world_ray_delta, FIREBALL_MINS, FIREBALL_MAXS))\n        g_entities.mask |= 1u << ENTITY_BIT_FIREBALL;\n\n    GameState game_state;\n    LOAD(game_state);\n    g_entities.target.scale = 0.;\n    g_entities.target.indices = 0u;\n    if (abs(game_state.level) >= 1.)\n    {\n        vec2 scale_bias = game_state.level > 0. ? vec2(1, 0) : vec2(-1, 1);\n        float fraction = linear_step(BALLOON_SCALEIN_TIME * .1, 0., fract(abs(game_state.level)));\n        g_entities.target.scale = fraction * scale_bias.x + scale_bias.y;\n        if (g_entities.target.scale > 1e-2)\n        {\n            float level = floor(abs(game_state.level));\n            int set = int(fract(level * PHI + .15) * float(NUM_BALLOON_SETS));\n            uint indices = g_ent_pos.balloon_sets[set];\n            g_entities.target.scale = overshoot(g_entities.target.scale, .5);\n        \tg_entities.target.indices = indices;\n            \n            vec3 BALLOON_MINS = vec3(-28, -28, -20) * g_entities.target.scale;\n            vec3 BALLOON_MAXS = vec3( 28,  28,  64) * g_entities.target.scale;\n            for (int i=0; i<NUM_TARGETS; ++i, indices>>=4)\n            {\n                Target target;\n                LOADR(vec2(i, 0.), target);\n                if (target.hits < ADDR_RANGE_SHOTGUN_PELLETS.z * .5)\n                    if (TEST_AABB(camera_pos - g_ent_pos.balloons[indices & 15u], inv_world_ray_delta, BALLOON_MINS, BALLOON_MAXS))\n\t                    g_entities.mask |= (1u << i);\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 map_torch_handle(vec3 p)\n{\n    p = rotate(p, 45.);\n    float dist = sdf_box(p, vec3(0, 0, -17), vec3(1, 1, 10));\n    dist = sdf_smin(dist, sdf_box(p, vec3(0, 0, -9), vec3(2, 2, 3)), 3.);\n    vec2 wood = vec2(dist, MATERIAL_WIZWOOD1_5);\n    dist = sdf_box(p, vec3(0, 0, p.z > -20.5 ? -14.5 : -26.5), vec3(1.25, 1.25, .75));\n    return sdf_union(wood, vec2(dist, MATERIAL_WIZMET1_1));\n}\n\nvec2 map_flame(vec3 p)\n{\n    const float scale = 1.;\n    p *= 1./scale;\n\n    p.z += 6.;\n    \n    float loop = g_entities.flame.loop;\n    float angle_jitter = hash(g_entities.flame.loop) * 360.;\n\n    vec3 ofs = vec3(-.5, -.5, 0);\n    vec3 p1 = rotate(p, angle_jitter + p.z * (360./16.)) + ofs;\n    float dist = sdf_cone(p1, 2.5, 16.);\n\n    ofs = vec3(-1, -1, -2);\n    p1 = rotate(p, angle_jitter + 180. - p.z * (360./32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 1.75, 10.), 1.);\n    \n    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 4), 2.5, 1.), 3.);\n\n    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));\n    p1 = vec3(loop_rotation * p.xy, p.z - 2.);\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2,  2, mix(8., 20., loop)), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2,  1, mix(12., 22., fract(loop + .3))), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1, -2, mix(10., 16., fract(loop + .6))), .25));\n\n    return vec2(dist*scale, MATERIAL_FLAME);\n}\n\nvec2 map_large_flame(vec3 p)\n{\n    const float scale = 2.;\n    p *= 1./scale;\n    p.z += 6.;\n\n    float loop = g_entities.flame.loop;\n    float angle_jitter = hash(g_entities.flame.loop) * 360.;\n\n    vec3 ofs = vec3(-.5, -.5, 0.);\n    vec3 p1 = rotate(p, angle_jitter + p.z * (360./16.)) + ofs;\n    float dist = sdf_cone(p1, 2., 14.);\n    \n    ofs = vec3(1., 1., 0.);\n    p1 = rotate(p, angle_jitter + p.z * (360./32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);\n\n    ofs = vec3(-.75, -.75, -1.5);\n    p1 = rotate(p, angle_jitter + 180. - p.z * (360./32.)) + ofs;\n    dist = sdf_smin(dist, sdf_cone(p1, 2., 10.), .25);\n\n    dist = sdf_smin(dist, sdf_capsule(p, vec3(0, 0, 1), vec3(0, 0, 5), 3.25, 1.5), 2.);\n\n    mat2 loop_rotation = mat2(g_entities.flame.sin_cos.yxxy * vec4(1, 1, -1, 1));\n    p1 = vec3(loop_rotation * p.xy, p.z);\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3( 2, 2, mix(8., 20., loop)), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-2, 1, mix(12., 22., fract(loop + .3))), .25));\n    dist = sdf_union(dist, sdf_sphere(p1 - vec3(-1,-2, mix(10., 16., fract(loop + .6))), .25));\n\n    return vec2(dist*scale, MATERIAL_FLAME);\n}\n\nvec2 map_torch(vec3 p, vec3 origin)\n{\n    p -= origin;\n    return sdf_union(map_torch_handle(p), map_flame(p));\n}\n\nvec2 map_fireball(vec3 p, vec3 origin)\n{\n    vec3 current_pos = origin + g_entities.fireball.offset;\n    p -= current_pos;\n    p = rotate(g_entities.fireball.rotation, p);\n    float dist = sdf_sphere(p, 3.);\n    dist = sdf_smin(dist, sdf_sphere(p - vec3(1.5, 1.5, 4), 4.), 3.);\n    dist = sdf_smin(dist, sdf_sphere(p - vec3(2.5,-1.5, 3), 2.5), 3.);\n    return vec2(dist, MATERIAL_LAVA1);\n}\n\n// very rough draft; work in progress\nvec2 map_zombie(vec3 p)\n{\n    const vec3\n        hip = vec3(2, 3, 2),\n    \tknee = vec3(-1, 1.5, -9),\n    \tankle = vec3(4, 1.25, -21),\n    \ttoe1 = vec3(1.5, 1.6, -24),\n    \ttoe2 = vec3(1, 1.1, -24),\n    \n        spine1 = vec3(1.5, 0, 2),\n        spine2 = vec3(1, 0, 13.5),\n\n        shoulder = vec3(2, 6, 16),\n        elbow = vec3(2, 14, 20),\n        wrist = vec3(2, 22, 26),\n\n        neck = vec3(1, 0, 18),\n        head = vec3(-1.5, 0, 22),\n        mouth = vec3(-1.5, 0, 20)\n\t;\n    \n    vec3 mp = p;\n    mp.y = abs(mp.y);\n\n    float dist = sdf_capsule(mp, ankle, knee, 1., 1.5);\n    dist = sdf_smin(dist, sdf_capsule(mp, knee, hip, 1.5, 2.), .05);\n    dist = sdf_smin(dist, sdf_capsule(mp, ankle, toe1, 1., .5), .5);\n\tdist = sdf_smin(dist, sdf_capsule(mp, ankle, toe2, 1., .5), .5);\n    \n    dist = sdf_smin(dist, sdf_capsule(mp, shoulder, elbow, 1.3, 1.2), 2.);\n    dist = sdf_smin(dist, sdf_capsule(mp, elbow, wrist, 1.2, .9), .5);\n\n    dist = sdf_smin(dist, sdf_round_box(p - spine1, vec3(.25, 3., 3.), .25), 1.5);\n    dist = sdf_smin(dist, sdf_capsule(p, spine1, spine2, 1.), 4.);\n    dist = sdf_smin(dist, sdf_round_box(p - spine2, vec3(.75, 2.5, 2.5), 1.25), 4.);\n\n    dist = sdf_smin(dist, sdf_capsule(p, neck, head, 1.5, 1.1), 1.);\n    dist = sdf_smin(dist, sdf_sphere(p - head, 2.5), 2.);\n    dist = sdf_smin(dist, sdf_round_box(p - mouth, vec3(.5, .5, .5), 1.), 1.);\n\n    //return vec2(dist, MATERIAL_COP3_4);\n    return vec2(dist, MATERIAL_ZOMBIE);\n}\n\nvec2 map_viewmodel(vec3 p)\n{\n    p -= g_entities.viewmodel.offset;\n    float sq_dist = length_squared(p);\n    if (sq_dist > sqr(32.))\n        return bounding_sphere(sq_dist, 24., MATERIAL_SHOTGUN_BARREL);\n    \n    p = rotate(g_entities.viewmodel.rotation, p);\n    \n    const vec3\n        BARREL_0\t= vec3(0,    4, -4.375),\n    \tBARREL_1\t= vec3(0, 13.5, -4.375),\n    \tFLASH_0\t\t= vec3(0, 14.6, -4.375),\n    \tFLASH_1\t\t= vec3(0, 16.1, -4.375),\n    \tBODY_0\t\t= vec3(0,    2, -4.7),\n    \tBODY_1\t\t= vec3(0,  7.5, -4.7),\n        INDENT\t\t= vec3(0,  7.5, -4.7),\n\t\tPUMP_0\t\t= vec3(0,    9, -6.),\n    \tPUMP_1\t\t= vec3(0, 12.9, -6.),\n        PUMP_GROOVE\t= vec3(0, 12.7, -6.)\n\t;\n    \n    vec2 body = vec2(sdf_capsule(p, BARREL_0, BARREL_1, .5), MATERIAL_SHOTGUN_BARREL);\n    body.x = sdf_smin(body.x, sdf_capsule(p, BODY_0, BODY_1, .875), .05);\n    body.x = sdf_smin(body.x, sdf_torus(p - INDENT, vec2(.7, .3)), .05);\n    \n    float attack = g_entities.viewmodel.attack;\n    if (attack > 0.)\n        body = sdf_union(body, vec2(sdf_capsule(p, FLASH_0, FLASH_1, .6, .2), MATERIAL_SHOTGUN_FLASH));\n\n    const float GROOVE_SPACING = .675;\n    vec2 pump = vec2(sdf_capsule(p, PUMP_0, PUMP_1, 1.4), MATERIAL_SHOTGUN_PUMP);\n    p -= PUMP_GROOVE;\n    p.y = fract(p.y * GROOVE_SPACING - .25) * (1./GROOVE_SPACING) - .5;\n    pump.x = fOpDifferenceRound(pump.x, sdf_torus(p, vec2(1.3125, .375)), .125);\n    \n    return sdf_union(body, pump);\n}\n\nvoid add_targets(vec3 p, inout vec2 result)\n{\n    uint mask = g_entities.mask & ENTITY_MASK_TARGETS;\n    if (mask == 0u)\n        return;\n\n    float best_sq_dist = 1e+8;\n    int best_index = -1;\n    int best_material = 0;\n    uint indices = g_entities.target.indices;\n    for (int i=0; i<NUM_TARGETS; ++i, mask>>=1, indices>>=4)\n    {\n        if ((mask & 1u) == 0u)\n            continue;\n        int index = int(indices & 15u);\n        float sq_dist = length_squared(p - g_ent_pos.balloons[index]);\n        if (sq_dist < best_sq_dist)\n        {\n            best_sq_dist = sq_dist;\n            best_index = index;\n            best_material = i;\n        }\n    }\n\n    best_material += BASE_TARGET_MATERIAL;\n    if (best_sq_dist > sqr(64.))\n    {\n        result = sdf_union(result, bounding_sphere(best_sq_dist, 56., best_material));\n        return;\n    }\n    \n    vec3 target = g_ent_pos.balloons[best_index];\n    target.z += 8. * sin(TAU * fract(g_animTime * .25 + dot(target.xy, vec2(1./137., 1./163.))));\n    float scale = g_entities.target.scale;\n    result = sdf_union(result, vec2(sdRoundCone(p - target, 8.*scale, 24.*scale, 28.*scale), best_material));\n}\n\nvec2 map_entities(vec3 p)\n{\n    // Finding the closest instance and only mapping it instead of the whole list (even for such tiny lists)\n    // shaves about 4.9 seconds off the compilation time on my machine (~7.6 vs ~12.5)\n\n    vec2 entities = vec2(1e+8, MATERIAL_SKY1);\n    Closest closest;\n    \n    if (0u != (g_entities.mask & (ENTITY_MASK_TORCHES << ENTITY_BIT_TORCHES)))\n    {\n        FIND_CLOSEST(p, closest, g_ent_pos.torches, NUM_TORCHES);\n        if (closest.distance_squared > sqr(40.))\n            entities = bounding_sphere(closest.distance_squared, 32., MATERIAL_FLAME);\n        else\n            entities = map_torch(p, closest.point);\n    }\n\n    if (0u != (g_entities.mask & (ENTITY_MASK_LARGE_FLAMES << ENTITY_BIT_LARGE_FLAMES)))\n    {\n        FIND_CLOSEST(p, closest, g_ent_pos.large_flames, NUM_LARGE_FLAMES);\n        if (closest.distance_squared > sqr(48.))\n            entities = sdf_union(entities, bounding_sphere(closest.distance_squared, 40., MATERIAL_FLAME));\n        else\n            entities = sdf_union(entities, map_large_flame(p - closest.point));\n    }\n    \n#if 0\n    FIND_CLOSEST(p, closest, ZOMBIES);\n\tentities = sdf_union(entities, map_zombie(p - closest.point));\n    //int num_zombies = NO_UNROLL(NUM_ZOMBIES);\n    //for (int i=0; i<num_zombies; ++i)\n    //    entities = sdf_union(entities, map_zombie(p - zombies[i]));\n#endif\n    \n    if (0u != (g_entities.mask & (1u << ENTITY_BIT_FIREBALL)))\n    \tentities = sdf_union(entities, map_fireball(p, FIREBALL_ORIGIN));\n\n    add_targets(p, entities);\n\n    #if RENDER_WEAPON\n    {\n        if ((g_entities.mask & (1u << ENTITY_BIT_VIEWMODEL)) != 0u)\n    \t\tentities = sdf_union(entities, map_viewmodel(p));\n    }\n\t#endif\n    \n    return entities;\n}\n\nvec3 estimate_entity_normal(vec3 p, float dist)\n{\n    const float EPSILON = 1e-3;\n    vec3 normal = vec3(-dist);\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec3 p2 = p;\n        p2[i] += EPSILON;\n        normal[i] += map_entities(p2).x;\n    }\n    return normalize(normal);\n}\n\n////////////////////////////////////////////////////////////////\n\nstruct Intersection\n{\n    float\tt;\n    vec3\tnormal;\n    int\t\tplane;\n    int\t\tmaterial;\n    int\t\tuv_axis;\n    bool\tmips;\n};\n\nvoid reset_intersection(out Intersection result)\n{\n    result.t\t\t\t= 1.;\n    result.normal\t\t= vec3(0.);\n    result.plane\t\t= -1;\n    result.material\t\t= -1;\n    result.mips\t\t\t= false;\n    result.uv_axis\t\t= 0;\n}\n\nvoid intersect_entities(vec3 campos, vec3 angles, vec3 dir, bool is_thumbnail, inout Intersection result)\n{\n#if RENDER_ENTITIES\n    update_entity_state(campos, angles, dir, result.t, is_thumbnail);\n    if (g_entities.mask == 0u)\n        return;\n\n    float t = 0.;\n    float rcp_length = 1./length(dir);\n    int max_steps = NO_UNROLL(ENTITY_RAYMARCH_STEPS);\n    vec2 current = vec2(2, -1);\n    float tolerance = 1e-4;\n    float max_tolerance = ENTITY_RAYMARCH_TOLERANCE * VIEW_DISTANCE * FOV_FACTOR * .5 * g_downscale / iResolution[FOV_AXIS];\n    for (int i=0; i<max_steps; ++i)\n    {\n        current = map_entities(campos + dir * t);\n        tolerance = t*max_tolerance + .015;\n        if (current.x < tolerance)\n            break;\n        t += current.x * rcp_length;\n        if (t >= result.t)\n            break;\n    }\n    \n    if (t < result.t && t > 0. && current.x < tolerance)\n    {\n        vec3 hit_point = campos + dir * t;\n        \n        result.t\t\t\t= t;\n        result.material\t\t= int(current.y);\n        result.plane\t\t= -1;\n        result.normal\t\t= estimate_entity_normal(hit_point, current.x);\n        result.mips\t\t\t= true;\n        result.uv_axis\t\t= 3;\n    }\n#if DEBUG_ENTITY_AABB\n    else\n    {\n        result.material\t\t= BASE_TARGET_MATERIAL;\n    }\n#endif // DEBUG_ENTITY_AABB\n#endif // RENDER_ENTITIES\n}\n\nvoid intersect_axial_brushes\n(\n    int brush_begin, int brush_end,\n    vec3 campos, vec3 rcp_delta, float znear,\n    inout float best_dist, inout int best_index\n)\n{\n#if RENDER_WORLD & 1\n    brush_begin = brush_begin << 1;\n    brush_end = NO_UNROLL(brush_end) << 1;\n    for (int i=brush_begin; i<brush_end; i+=2)\n    {\n        vec3 mins = get_axial_point(i);\n        vec3 maxs = get_axial_point(i+1);\n        vec3 t0 = (mins - campos) * rcp_delta;\n        vec3 t1 = (maxs - campos) * rcp_delta;\n        vec3 tmin = min(t0, t1);\n        vec4 tmax = vec4(max(t0, t1), best_dist);\n        float t_enter = max_component(tmin);\n        float t_exit = min_component(tmax);\n        if (t_exit >= max(t_enter, 0.) && t_enter > znear)\n        {\n            best_dist = t_enter;\n            best_index = i;\n        }\n    }\n#endif // RENDER_WORLD & 1    \n}\n\nvoid resolve_axial_intersection(vec3 campos, vec3 rcp_delta, inout Intersection result, int best_index)\n{\n    if (best_index == -1)\n        return;\n\n    vec3 mins = get_axial_point(best_index);\n    vec3 maxs = get_axial_point(best_index+1);\n    vec3 t0 = (mins - campos) * rcp_delta;\n    vec3 t1 = (maxs - campos) * rcp_delta;\n    vec3 tmin = min(t0, t1);\n    float t = max_component(tmin);\n    int axis =\n        (t == tmin.x) ? 0 :\n    \t(t == tmin.y) ? 1 :\n    \t2;\n    bool side = rcp_delta[axis] > 0.;\n    int face = (axis << 1) + int(side);\n\n    result.plane\t\t= (best_index + (best_index<<1)) + face;\n    result.material\t\t= get_axial_brush_material(best_index>>1, face);\n    result.normal\t\t= vec3(0);\n    result.normal[axis]\t= side ? -1. : 1.;\n    result.uv_axis\t\t= axis;\n    result.mips\t\t\t= fwidth(float(result.plane)) < 1e-4;\n}\n\nvoid intersect_nonaxial_brushes\n(\n    int brush_begin, int brush_end,\n    vec3 campos, vec3 dir, float znear, \n    inout float best_dist, inout int best_plane\n)\n{\n#if RENDER_WORLD & 2\n    if (brush_begin >= brush_end)\n        return;\n    brush_end = NO_UNROLL(brush_end);\n    for (int i=brush_begin, first_plane=get_nonaxial_brush_start(i), last_plane; i<brush_end; ++i, first_plane=last_plane)\n    {\n       \tlast_plane = get_nonaxial_brush_start(i + 1);\n        int best_brush_plane = -1;\n        float t_enter = -1e6;\n        float t_leave = 1.;\n       \tfor (int j=first_plane; j<last_plane; ++j)\n        {\n            vec4 plane = get_nonaxial_plane(j);\n            float dist = dot(plane.xyz, campos) + plane.w;\n            float align = dot(plane.xyz, dir);\n            if (align == 0.)\n            {\n                if (dist > 0.)\n                {\n                    t_enter = 2.;\n                    break;\n                }\n                continue;\n            }\n            dist /= -align;\n            best_brush_plane = (align < 0. && t_enter < dist) ? j : best_brush_plane;\n            t_enter = (align < 0.) ? max(t_enter, dist) : t_enter;\n            t_leave = (align > 0.) ? min(t_leave, dist) : t_leave;\n            if (t_leave <= t_enter)\n                break;\n        }\n        if (t_leave > max(t_enter, 0.) && t_enter > znear && best_dist > t_enter)\n        {\n            best_plane = best_brush_plane;\n            best_dist = t_enter;\n        }\n    }\n#endif // RENDER_WORLD & 2\n}\n\nvoid resolve_nonaxial_intersection(inout Intersection result, int best_index)\n{\n    if (best_index == -1)\n        return;\n    \n    vec4 plane = get_nonaxial_plane(best_index);\n    \n    result.normal = plane.xyz;\n    result.uv_axis = dominant_axis(plane.xyz);\n    result.plane = best_index + NUM_MAP_AXIAL_PLANES;\n    result.material = get_plane_material(result.plane);\n\n    // pixel quad straddling geometric planes? no mipmaps for you!\n    float plane_hash = dot(plane, vec4(17463.12, 25592.53, 15576.84, 19642.77));\n    result.mips = fwidth(plane_hash) < 1e-4;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid intersect_world(vec3 campos, vec3 dir, float znear, inout Intersection result)\n{\n    vec3 inv_world_dir = 1./dir;\n    int best_index = -1;\n    \n    // axial brushes //\n    \n\t#if USE_PARTITION & 1\n    {\n        for (int i=NO_UNROLL(0); i<NUM_AXIAL_NODES; ++i)\n        {\n            Node n = unpack(bvl.axial[i], AXIAL_BVL_MINS);\n            if (ray_vs_aabb(campos, inv_world_dir, result.t, n.mins, n.maxs))\n                intersect_axial_brushes(int(n.begin), int(n.end), campos, inv_world_dir, znear, result.t, best_index);\n        }\n    }\n\t#else\n    {\n    \tintersect_axial_brushes(0, NUM_MAP_AXIAL_BRUSHES, campos, inv_world_dir, znear, result.t, best_index);\n    }\n\t#endif\n    resolve_axial_intersection(campos, inv_world_dir, result, best_index);\n    \n    // non-axial brushes //\n    \n    best_index = -1;\n\n\t#if USE_PARTITION & 2\n    {\n        for (int i=NO_UNROLL(0); i<NUM_NONAXIAL_NODES; ++i)\n        {\n            Node n = unpack(bvl.nonaxial[i], NONAXIAL_BVL_MINS);\n            if (ray_vs_aabb(campos, inv_world_dir, result.t, n.mins, n.maxs))\n                intersect_nonaxial_brushes(int(n.begin), int(n.end), campos, dir, znear, result.t, best_index);\n        }\n    }\n\t#else\n    {\n    \tintersect_nonaxial_brushes(0, NUM_MAP_NONAXIAL_BRUSHES, campos, dir, znear, result.t, best_index);\n    }\n\t#endif\n    resolve_nonaxial_intersection(result, best_index);\n}\n\n////////////////////////////////////////////////////////////////\n\nvec4 get_light(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_LIGHTS.xy);\n    addr.x += index;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nvec4 get_lightmap_tile(int index)\n{\n    ivec2 addr = ivec2(ADDR_RANGE_LMAP_TILES.xy);\n    addr.x += index & 127;\n    addr.y += index >> 7;\n    return texelFetch(SETTINGS_CHANNEL, addr, 0);\n}\n\nint find_tile(vec2 fragCoord, int num_tiles)\n{\n#if BAKE_LIGHTMAP\n    for (int i=NO_UNROLL(0); i<num_tiles; ++i)\n\t\tif (is_inside(fragCoord, get_lightmap_tile(i)) > 0.)\n            return i;\n#endif\n    return -1;\n}\n\nivec2 get_brush_and_side(int plane_index)\n{\n    if (plane_index < NUM_MAP_AXIAL_PLANES)\n        return ivec2(uint(plane_index) / 6u, uint(plane_index) % 6u);\n    \n    plane_index -= NUM_MAP_AXIAL_PLANES;\n\t\n    #define TEST(dist) (int((get_nonaxial_brush_start(brush + (dist)) <= plane_index)) * (dist))\n    \n\tint brush = 0;\n    brush  = TEST(NUM_MAP_NONAXIAL_BRUSHES-64);\n    brush += TEST(32);\n    brush += TEST(16);\n    brush += TEST(8);\n    brush += TEST(4);\n    brush += TEST(2);\n    brush += TEST(1);\n\n    #undef TEST\n\n    return ivec2(brush + NUM_MAP_AXIAL_BRUSHES, plane_index - get_nonaxial_brush_start(brush));\n}\n\nfloat find_edge_distance(vec3 p, int brush, int side)\n{\n    float dist = -1e8;\n    \n    if (brush < NUM_MAP_AXIAL_BRUSHES)\n    {\n        vec3[2] deltas;\n        deltas[0] = get_axial_point(brush*2) - p;\n        deltas[1] = p - get_axial_point(brush*2+1);\n        int axis = side >> 1;\n        int front = side & 1;\n        for (int i=0; i<6; ++i)\n            if (i != side)\n            \tdist = max(dist, deltas[1&~i][i>>1]);\n    }\n    else\n    {\n        int begin = get_nonaxial_brush_start(brush - NUM_MAP_AXIAL_BRUSHES);\n        int end = get_nonaxial_brush_start(brush - (NUM_MAP_AXIAL_BRUSHES - 1));\n        for (int i=begin; i<end; ++i)\n        {\n            if (i == begin + side)\n                continue;\n            vec4 plane = get_nonaxial_plane(i);\n            dist = max(dist, dot(p, plane.xyz) + plane.w);\n        }\n    }\n    \n    return dist;\n}\n\nvec2 get_lightmap_offset(int plane_index)\n{\n\tconst int NUM_BITS = 9, MASK = (1 << NUM_BITS) - 1;\n\tint packed_offset = LIGHTMAP_OFFSETS.data[plane_index];\n    return (packed_offset >= 0) ?\n        LIGHTMAP_OFFSET + vec2(packed_offset & MASK, packed_offset >> NUM_BITS) :\n        LIGHTMAP_OFFSET + vec2(-1);\n}\n\nfloat fetch_lightmap_texel(ivec2 addr)\n{\n    addr = clamp(addr, ivec2(0), ivec2(LIGHTMAP_SIZE) - 1);\n    int channel = addr.y & 3;\n    addr.y >>= 2;\n    return decode_lightmap_sample(texelFetch(iChannel1, addr, 0)).values[channel];\n}\n\nfloat sample_lightmap(vec3 camera_pos, vec3 dir, Options options, Intersection result)\n{\n    if (result.uv_axis == 3)\n        return clamp(-dot(result.normal, ENTITY_LIGHT_DIR), ENTITY_MIN_LIGHT, 1.);\n    if (result.plane == -1)\n        return 1.;\n\n    float unmapped_light = is_material_any_of(result.material, MATERIAL_MASK_LIQUID|MATERIAL_MASK_SKY) ? 1. : 0.;\n    vec3 point = camera_pos + dir * result.t;\n    vec2 offset = get_lightmap_offset(result.plane);\n    if (any(lessThan(offset, LIGHTMAP_OFFSET)))\n        return unmapped_light;\n\n    vec2 uv = uv_map_axial(point, result.uv_axis);\n#if LIGHTMAP_FILTER == 1 // snap to world texels\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tuv = floor(uv) + .5;\n#endif\n    uv = uv / LIGHTMAP_SCALE - offset;\n    \n#if LIGHTMAP_FILTER > 0\n    uv -= .5;\n#endif\n    \n    vec2 base = floor(uv);\n    ivec2 addr = ivec2(base);\n    if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y)\n        return unmapped_light;\n    \n    uv -= base;\n#if !LIGHTMAP_FILTER\n    uv = vec2(0);\n#endif\n    \n    float\n        s00 = fetch_lightmap_texel(addr + ivec2(0,0)),\n        s01 = fetch_lightmap_texel(addr + ivec2(0,1)),\n        s10 = fetch_lightmap_texel(addr + ivec2(1,0)),\n        s11 = fetch_lightmap_texel(addr + ivec2(1,1)),\n        light = mix(mix(s00, s01, uv.y), mix(s10, s11, uv.y), uv.x);\n\n#ifdef QUANTIZE_LIGHTMAP\n    const float LEVELS = float(QUANTIZE_LIGHTMAP);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) && g_demo_stage != DEMO_STAGE_LIGHTING)\n        light = floor(light * LEVELS + .5) * (1./LEVELS);\n#endif\n    \n    return light;\n}\n\nvec3 lightmap_to_world(vec2 fragCoord, int plane_index)\n{\n    fragCoord += get_lightmap_offset(plane_index);\n    vec4 plane = get_plane(plane_index);\n    return uv_unmap(fragCoord * LIGHTMAP_SCALE, plane) + plane.xyz * LIGHTMAP_HEIGHT_OFFSET;\n}\n\nfloat compute_light_atten(vec4 light, vec3 surface_point, vec3 surface_normal)\n{\n    vec3 light_dir = light.xyz - surface_point;\n\tfloat\n        dist = length(light_dir) * LIGHTMAP_SCALEDIST,\n    \tangle = mix(1., dot(surface_normal, normalize(light_dir)), LIGHTMAP_SCALECOS);\n    return max(0., (light.w - dist) * angle * (LIGHTMAP_RANGESCALE / 255.));\n}\n\n// dynamic lights didn't seem to be taking normals into account\n// (fireball light showing up on the right wall of the Normal hallway)\nfloat compute_dynamic_light_atten(vec4 light, vec3 surface_point)\n{\n    vec3 light_dir = light.xyz - surface_point;\n    float dist = length(light_dir);\n    float radius = light.w;\n    return clamp(1.-dist/abs(radius), 0., 1.) * sign(radius);\n}\n\nvec3 simulate_lightmap_distortion(vec3 surface_point)\n{\n    surface_point = floor(surface_point);\n    surface_point *= 1./LIGHTMAP_SCALE;\n    vec3 f = fract(surface_point + .5);\n    return (surface_point + f - smoothen(f)) * LIGHTMAP_SCALE;\n}\n\nfloat sample_lighting(vec3 camera_pos, vec3 dir, Options options, Intersection result)\n{\n#if !BAKE_LIGHTMAP\n    return 1.;\n#endif\n\n    Transitions transitions;\n    LOAD(transitions);\n    \n    float lightmap = sample_lightmap(camera_pos, dir, options, result);\n    \n    float dynamic_lighting = 0.;\n    vec3 surface_point = camera_pos + dir * result.t;\n    surface_point = simulate_lightmap_distortion(surface_point);\n    \n    vec3 fireball_offset = get_fireball_offset(g_animTime);\n    vec4 fireball_light = vec4(fireball_offset + FIREBALL_ORIGIN, 150);\n    if (fireball_offset.z > 8.)\n    \tdynamic_lighting += compute_dynamic_light_atten(fireball_light, surface_point);\n    if (transitions.attack > .875)\n        dynamic_lighting += compute_dynamic_light_atten(vec4(camera_pos, 200), surface_point);\n    \n#ifdef QUANTIZE_DYNAMIC_LIGHTS\n    const float LEVELS = float(QUANTIZE_DYNAMIC_LIGHTS);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tdynamic_lighting = floor(dynamic_lighting * LEVELS + .5) * (1./LEVELS);\n#endif\n    \n    return lightmap + dynamic_lighting;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    ivec2 addr = ivec2(fragCoord);\n    \n    vec3 pos, dir, angles;\n    float light_level = -1., znear = 0.;\n    bool is_ground_sample = false;\n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    vec4 plane;\n\n    Lighting lighting;\n    LOAD(lighting);\n    \n    Options options;\n    LOAD(options);\n\n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n    \n    // initial setup //\n\n    bool baking = iFrame < NUM_LIGHTMAP_FRAMES;\n    if (baking)\n    {\n        if (uint(addr.x) >= LIGHTMAP_SIZE.x || uint(addr.y) >= LIGHTMAP_SIZE.y/4u)\n            DISCARD;\n        fragColor = vec4(-1);\n        \n        int region = iFrame & 3;\n        int frame = iFrame >> 2;\n        addr.y += region * int(LIGHTMAP_SIZE.y/4u);\n        vec2 lightmap_coord = vec2(addr);\n        \n        int plane_index = find_tile(lightmap_coord + .5, lighting.num_tiles);\n        if (plane_index == -1)\n            return;\n        lightmap_coord += hammersley(frame % NUM_LIGHTMAP_SAMPLES, NUM_LIGHTMAP_SAMPLES);\n\n        ivec2 brush_side = get_brush_and_side(plane_index);\n        int brush = brush_side.x;\n        int side = brush_side.y;\n\n        pos = lightmap_to_world(lightmap_coord, plane_index);\n        if (find_edge_distance(pos, brush, side) > LIGHTMAP_SCALE * LIGHTMAP_EXTRAPOLATE)\n            return;\n\n        plane = get_plane(plane_index);\n        znear = -1e8;\n    }\n    else\n    {\n        g_downscale = get_downscale(options);\n        is_ground_sample = all(equal(ivec2(fragCoord), ivec2(iResolution.xy)-1));\n        vec2 actual_res = min(ceil(iResolution.xy / g_downscale * .125) * 8., iResolution.xy);\n        if (max_component(fragCoord - .5 - actual_res) > 0. && !is_ground_sample)\n        \tDISCARD;\n\n        vec2 demo_coord = is_ground_sample ?\n            iResolution.xy * vec2(.5, .25) / g_downscale :\n        \tfragCoord;\n\n        UPDATE_TIME(lighting);\n        UPDATE_DEMO_STAGE(demo_coord, g_downscale, is_thumbnail);\n\n        pos = load_camera_pos(SETTINGS_CHANNEL, is_thumbnail).xyz;\n        angles = load_camera_angles(SETTINGS_CHANNEL, is_thumbnail).xyz;\n        if (!is_ground_sample)\n        {\n            vec2 uv = (fragCoord * 2. * g_downscale - iResolution.xy) / iResolution.x;\n            dir = unproject(uv) * VIEW_DISTANCE;\n            dir = rotate(dir, angles);\n        }\n        else\n        {\n            dir = vec3(0, 0, -VIEW_DISTANCE);\n            angles = vec3(0, -90, 0);\n        }\n    }\n\n    // render loop //\n    \n    Intersection result;\n    \n#if !BAKE_LIGHTMAP\n    lighting.num_lights = 0;\n#endif\n\n    int num_iter = baking ? lighting.num_lights : 1;\n    for (int i=0; i<num_iter; ++i)\n    {\n        float contrib;\n        if (baking)\n        {\n            vec4 light = get_light(i);\n            contrib = compute_light_atten(light, pos, plane.xyz);\n            if (contrib <= 0.)\n                continue;\n            dir = light.xyz - pos;\n        }\n\n        reset_intersection(result);\n    \tintersect_world(pos, dir, znear, result);\n\n        if (baking)\n        {\n            if (result.t >= 1. || is_material_liquid(result.material))\n                light_level = max(light_level, 0.) + contrib;\n            else if (result.t > 0.)\n                light_level = max(light_level, 0.);\n\t\t}\n    }\n\n    if (!baking && !is_ground_sample)\n\t    intersect_entities(pos, angles, dir, is_thumbnail, result);\n\n    // output //\n\n    if (baking)\n    {\n        fragColor.rgb = vec3(light_level);\n    }\n    else\n    {\n        if (result.material == -1)\n        {\n            result.t = 1.;\n            result.material = MATERIAL_SKY1;\n            result.normal = vec3(0, 0, -1);\n            result.mips = true;\n        }\n\n        GBuffer g;\n        g.normal\t= result.normal;\n        g.light\t\t= sample_lighting(pos, dir, options, result);\n        g.z\t\t\t= result.t;\n        g.material\t= result.material;\n        g.uv_axis\t= result.uv_axis;\n        g.edge\t\t= !result.mips;\n\n        // In demo mode, we can have the shotgun model rendered at two different map locations\n        // at the same time (during the stage transitions). We only take a single lightmap sample\n        // for the ground point per frame, so to avoid harsh transitions between different light\n        // levels, we just use a default light value for the weapon model if demo mode is enabled\n        if (is_ground_sample && test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL))\n            g.light\t= .5;\n        \n#if DITHER_ENTITY_NORMALS\n        vec2 noise = result.plane == -1 ? fract(BLUE_NOISE(fragCoord).xy) : vec2(.5);\n#else\n        vec2 noise = vec2(.5);\n#endif\n\n        fragColor = gbuffer_pack(g, noise);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n// Buffer C:\n// - lightmap accumulation and post-processing\n// - UI textures\n// - font glyphs\n////////////////////////////////////////////////////////////////\n\n// config.cfg //////////////////////////////////////////////////\n\nconst int TEXTURE_AA = 4;\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define ALWAYS_REFRESH_TEXTURES\t\t0\n#define DEBUG_TEXT_MASK\t\t\t\t0\n\n////////////////////////////////////////////////////////////////\n\nconst int\n    NUM_DILATE_PASSES\t\t\t\t= 1,\n    NUM_BLUR_PASSES\t\t\t\t\t= 0,\n    NUM_POSTPROCESS_PASSES\t\t\t= NUM_DILATE_PASSES + NUM_BLUR_PASSES;\n\n#define USE_DIAGONALS\t\t\t\t0\n\nvoid accumulate(inout LightmapSample total, LightmapSample new)\n{\n    total.values = (total.values*total.weights + new.values*new.weights) / max(total.weights + new.weights, 1.);\n    total.weights += new.weights;\n}\n\nvoid accumulate(inout LightmapSample total, vec4 encoded_new)\n{\n    accumulate(total, decode_lightmap_sample(encoded_new));\n}\n\nbool postprocess(inout vec4 fragColor, ivec2 address)\n{\n\tif (iFrame < NUM_LIGHTMAP_FRAMES)\n        return false;\n\n    int pass = iFrame - NUM_LIGHTMAP_FRAMES;\n    bool blur = pass >= NUM_DILATE_PASSES;\n\n    const ivec2 MAX_COORD = ivec2(LIGHTMAP_SIZE.x - 1u, LIGHTMAP_SIZE.y/4u - 1u);\n    vec4\n        N  = texelFetch(iChannel1, clamp(address + ivec2( 0, 1), ivec2(0), MAX_COORD), 0),\n        S  = texelFetch(iChannel1, clamp(address + ivec2( 0,-1), ivec2(0), MAX_COORD), 0),\n        E  = texelFetch(iChannel1, clamp(address + ivec2( 1, 0), ivec2(0), MAX_COORD), 0),\n        W  = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0),\n        NE = texelFetch(iChannel1, clamp(address + ivec2( 1, 1), ivec2(0), MAX_COORD), 0),\n        SE = texelFetch(iChannel1, clamp(address + ivec2( 1,-1), ivec2(0), MAX_COORD), 0),\n        NW = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0),\n        SW = texelFetch(iChannel1, clamp(address + ivec2(-1, 0), ivec2(0), MAX_COORD), 0);\n\n    N  = vec4(fragColor.yzw, N.x);\n    NE = vec4(E.yzw, NE.x);\n    NW = vec4(W.yzw, NW.x);\n    S  = vec4(S .w, fragColor.xyz);\n    SE = vec4(SE.w, E.xyz);\n    SW = vec4(SW.w, W.xyz);\n\n    LightmapSample\n        current = decode_lightmap_sample(fragColor),\n        total = empty_lightmap_sample();\n\n    accumulate(total, N);\n    accumulate(total, S);\n    accumulate(total, E);\n    accumulate(total, W);\n#if USE_DIAGONALS\n    accumulate(total, NE);\n    accumulate(total, NW);\n    accumulate(total, SE);\n    accumulate(total, SW);\n#endif\n\n    if (blur)\n    {\n        accumulate(total, current);\n\t    fragColor = encode(total);\n    }\n    else\n    {\n        vec4 neighbors = encode(total);\n        fragColor = mix(fragColor, neighbors, lessThanEqual(current.weights, vec4(0)));\n    }\n    \n    return true;\n}\n\nvoid accumulate_lightmap(inout vec4 fragColor, ivec2 address)\n{\n    if (uint(address.x) >= LIGHTMAP_SIZE.x || uint(address.y) >= LIGHTMAP_SIZE.y/4u)\n        return;\n    if (iFrame >= NUM_LIGHTMAP_FRAMES + NUM_POSTPROCESS_PASSES)\n        return;\n\n    if (postprocess(fragColor, address))\n        return;\n    \n    int region = iFrame & 3;\n    int base_y = region * int(LIGHTMAP_SIZE.y/16u);\n    if (uint(address.y - base_y) >= LIGHTMAP_SIZE.y/16u)\n        return;\n\n    address.y = (address.y - base_y) * 4;\n    vec4 light = vec4\n        (\n            texelFetch(iChannel0, address + ivec2(0,0), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,1), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,2), 0).x,\n            texelFetch(iChannel0, address + ivec2(0,3), 0).x\n\t\t);\n\n    vec4 weights = step(vec4(0), light);\n    vec4 values = max(light, 0.);\n    \n    LightmapSample total = decode_lightmap_sample(fragColor);\n    accumulate(total, LightmapSample(weights, values));\n    fragColor = encode(total);\n}\n\n// Options text ////////////////////////////////////////////////\n\nfloat sdf_Options(vec2 p)\n{\n    const float\n        OFFSET_P = 15.,\n        OFFSET_T = 35.,\n        OFFSET_I = 53.,\n        OFFSET_O = 63.,\n        OFFSET_N = 81.,\n        OFFSET_S = 98.;\n\n    vec4 box = vec4(0);\n    vec3 disk1 = vec3(0), disk2 = vec3(0,0,1), disk3 = vec3(0,0,2);\n    float vline_x = 1e3, vline_thickness = 2.5;\n    float max_ydist = 6.;\n    \n    p.x -= 15.;\n    \n\t#define MIRROR(compare, midpoint, value) (compare <= midpoint ? value : midpoint*2.-value)\n    \n    if (p.x <= 20.)\n    {\n    \tmax_ydist = 7.;\n        disk1 = vec3(MIRROR(p.x, 8.5, 7.5), 11.5, 8.);\n        disk2 = vec3(MIRROR(p.x, 8.5, 12.), 11.5, 9.);\n    }\n    else if (p.x <= OFFSET_T)\n    {\n        p.x -= OFFSET_P;\n        vline_x = 9.;\n        disk1 = vec3(14.5, 13.5, 4.);\n        disk2 = vec3(10.5, 13.5, 5.);\n    }\n    else if (p.x <= OFFSET_I)\n    {\n        const float\n            BOX_X = 4., BOX_Y = 15.5, BOX_SIZE = 1.5,\n            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y-BOX_SIZE, R3 = BOX_SIZE * 2.;\n        \n        p.x -= OFFSET_T;\n        disk3 = vec3(MIRROR(p.x, 9., X3), Y3, R3);\n        box   = vec4(MIRROR(p.x, 9., BOX_X), BOX_Y, BOX_SIZE, BOX_SIZE);\n        vline_x = 9.;\n    }\n    else if (p.x <= OFFSET_O)\n    {\n        vline_x = OFFSET_I + 4.5;\n    }\n    else if (p.x <= OFFSET_N)\n    {\n        p.x -= OFFSET_O;\n        disk1 = vec3(MIRROR(p.x, 9., 8.), 11.5, 7.);\n        disk2 = vec3(MIRROR(p.x, 9., 12.), 11.5, 8.);\n    }\n    else if (p.x <= OFFSET_S)\n    {\n        p.x -= OFFSET_N;\n        vline_x = p.x < 9. ? 4.5 : 15.;\n        vline_thickness = 2.;\n        box = vec4(clamp(p.x, 5., 14.) * vec2(1, -.75) + vec2(0, 18), 1., 2.);\n    }\n    else\n    {\n        const float\n            X1 = 8., Y1 = 14., R1 = 3.5,\n            X2 = 9.5, Y2 = 15.5, R2 = 2.5,\n            BOX_X = 6., BOX_Y = 7., BOX_SIZE = 1.5,\n            X3 = BOX_X+BOX_SIZE, Y3 = BOX_Y+BOX_SIZE, R3 = BOX_SIZE * 2.;\n        \n        p.x -= OFFSET_S;\n        // TODO: simplify\n        if (p.x < 9.)\n        {\n            disk1 = vec3(X1, Y1, R1);\n            disk2 = vec3(X2, Y2, R2);\n            disk3 = vec3(X3, Y3, R3);\n            box   = vec4(BOX_X, BOX_Y, BOX_SIZE, BOX_SIZE);\n        }\n        else\n        {\n            disk1 = vec3(18. - X1, 23. - Y1, R1);\n            disk2 = vec3(18. - X2, 23. - Y2, R2);\n            disk3 = vec3(18. - X3, 23. - Y3, R3);\n            box   = vec4(18. - BOX_X, 23. - BOX_Y, BOX_SIZE, BOX_SIZE);\n        }\n    }\n    \n    #undef MIRROR\n    \n    float dist;\n    dist = sdf_disk(p, disk1.xy, disk1.z);\n    dist = sdf_exclude(dist, sdf_disk(p, disk2.xy, disk2.z));\n    \n    dist = sdf_union(dist, sdf_seriffed_box(p, vec2(vline_x, 5.5), vec2(vline_thickness, 12.), vec2(1,.2), vec2(1,.2)));\n                       \n\tfloat d2 = sdf_centered_box(p, box.xy, box.zw);\n    d2 = sdf_exclude(d2, sdf_disk(p, disk3.xy, disk3.z));\n    dist = sdf_union(dist, d2);\n    dist = sdf_exclude(dist, max_ydist - abs(p.y - 11.5));\n   \n    return dist;\n}\n\nvec2 engraved_Options(vec2 uv)\n{\n    const float EPS = .1, BEVEL_SIZE = 1.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_Options(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1.);\n    float bevel = clamp(1. + sdf.z/BEVEL_SIZE, 0., 1.);\n    float intensity = .4 + sqr(bevel) * dot(gradient, vec2(0, -1.1));\n    intensity = mix(1.5, intensity, mask);\n    mask = sdf_mask(sdf.z - 1., 1.);\n    return vec2(intensity, mask);\n}\n\n// QUAKE text //////////////////////////////////////////////////\n\nfloat sdf_QUAKE(vec2 uv)\n{\n    uv /= 28.;\n    uv.y -= 4.;\n    uv.x -= .0625;\n    \n    float sdf\t\t\t\t\t\t   = sdf_Q_top(uv);\n    uv.y += .875;   sdf = sdf_union(sdf, sdf_U(uv));\n    uv.y += .75;\tsdf = sdf_union(sdf, sdf_A(uv));\n    uv.y += .75;\tsdf = sdf_union(sdf, sdf_K(uv - vec2(.2, 0)));\n    uv.y += .8125;\tsdf = sdf_union(sdf, sdf_E(uv));\n    \n    sdf *= 28.;\n    uv += sin(uv.yx * TAU) * (5./28.);\n    sdf = sdf_union(sdf, 28. * (.75 - around(.3, .25, smooth_weyl_noise(2. + uv * 3.24))));\n    return sdf_exclude(sdf, (uv.y - .15) * 28.);\n}\n\nvec2 engraved_QUAKE(vec2 uv)\n{\n    const float EPS = .1, BEVEL_SIZE = 2.;\n    vec3 sdf;\n    for (int i=NO_UNROLL(0); i<3; ++i)\n    {\n        vec2 uv2 = uv;\n        if (i != 2)\n            uv2[i] += EPS;\n        sdf[i] = sdf_QUAKE(uv2);\n    }\n    vec2 gradient = safe_normalize(sdf.xy - sdf.z);\n    float mask = sdf_mask(sdf.z, 1.);\n    float bevel = clamp(1. + sdf.z/BEVEL_SIZE, 0., 1.);\n    float intensity = .75 + sqr(bevel) * dot(gradient, vec2(0, -3));\n    intensity = mix(1.5, intensity, mask);\n    mask = sdf_mask(sdf.z - 1., 1.);\n    return vec2(intensity, mask * .7);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid generate_ui_textures(inout vec4 fragColor, vec2 fragCoord)\n{\n#if !ALWAYS_REFRESH_TEXTURES\n    if (iFrame != 0)\n        return;\n#endif\n    \n    const int\n\t\tUI_TEXTURE_OPTIONS\t\t= 0,\n\t\tUI_TEXTURE_QUAKE_ID\t\t= 1,\n        AA_SAMPLES\t\t\t\t= clamp(TEXTURE_AA, 1, 128);\n    int id = -1;\n\n    vec2 texture_size, bevel_range;\n    vec3 base_color;\n    \n    if (is_inside(fragCoord, ADDR2_RANGE_TEX_OPTIONS) > 0.)\n    {\n        id = UI_TEXTURE_OPTIONS;\n        fragCoord -= ADDR2_RANGE_TEX_OPTIONS.xy;\n        texture_size = ADDR2_RANGE_TEX_OPTIONS.zw;\n        bevel_range = vec2(1.7, 3.9);\n        base_color = vec3(.32, .21, .13);\n    }\n\n    if (is_inside(fragCoord, ADDR2_RANGE_TEX_QUAKE) > 0.)\n    {\n        id = UI_TEXTURE_QUAKE_ID;\n        fragCoord -= ADDR2_RANGE_TEX_QUAKE.xy;\n        fragCoord = fragCoord.yx;\n        texture_size = ADDR2_RANGE_TEX_QUAKE.wz;\n        bevel_range = vec2(2.7, 4.9);\n        base_color = vec3(.16, .12, .07);\n    }\n    \n    if (id == -1)\n        return;\n\n    vec2 base_coord = floor(fragCoord);\n    float grain = random(base_coord);\n\n    vec3 accum = vec3(0);\n    for (int i=NO_UNROLL(0); i<AA_SAMPLES; ++i)\n    {\n        fragCoord = base_coord + hammersley(i, AA_SAMPLES);\n        vec2 uv = fragCoord / min_component(texture_size);\n\n        float base = weyl_turb(3.5 + uv * 3.1, .7, 1.83);\n        if (id == UI_TEXTURE_QUAKE_ID && fragCoord.y < 26. + base * 4. && fragCoord.y > 3. - base * 2.)\n        {\n            base = mix(base, grain, .0625);\n            fragColor.rgb = vec3(.62, .30, .19) * linear_step(.375, .85, base);\n            vec2 logo_uv = (uv - .5) * vec2(1.05, 1.5) + .5;\n            logo_uv.y += .0625;\n            float logo_sdf = sdf_id(logo_uv);\n            float logo = sdf_mask(logo_sdf + .25/44., 1.5/44.);\n            fragColor.rgb *= 1. - sdf_mask(logo_sdf - 2./44., 1.5/44.);\n            fragColor.rgb = mix(fragColor.rgb, vec3(.68, .39, .17) * mix(.5, 1.25, base), logo);\n        }\n        else\n        {\n            base = mix(base, grain, .3);\n            fragColor.rgb = base_color * mix(.75, 1.25, smoothen(base));\n        }\n\n        float bevel_size = mix(bevel_range.x, bevel_range.y, smooth_weyl_noise(uv * 9.));\n        vec2 mins = vec2(bevel_size), maxs = texture_size - bevel_size;\n        vec2 duv = (fragCoord - clamp(fragCoord, mins, maxs)) * (1./bevel_size);\n        float d = mix(length(duv), max_component(abs(duv)), .75);\n        fragColor.rgb *= clamp(1.4 - d*mix(1., 1.75, sqr(base)), 0., 1.);\n        float highlight = \n            (id == UI_TEXTURE_OPTIONS) ?\n            \tmax(0., duv.y) * step(d, .55) :\n        \t\tsqr(sqr(1. + duv.y)) * around(.4, .4, d) * .35;\n        fragColor.rgb *= 1. + mix(.75, 2.25, base) * highlight;\n\n        if (DEBUG_TEXT_MASK != 0)\n        {\n            float sdf = (id == UI_TEXTURE_OPTIONS) ? sdf_Options(fragCoord) : sdf_QUAKE(fragCoord);\n            fragColor.rgb = vec3(sdf_mask(sdf, 1.));\n            accum += fragColor.rgb;\n            continue;\n        }\n\n        vec2 engrave = (id == UI_TEXTURE_OPTIONS) ? engraved_Options(fragCoord) : engraved_QUAKE(fragCoord);\n        fragColor.rgb *= mix(1., engrave.x, engrave.y);\n\n        if (id == UI_TEXTURE_OPTIONS)\n        {\n            vec2 side = sign(fragCoord - texture_size * .5); // keep track of side before folding to 'unmirror' light direction\n            fragCoord = min(fragCoord, texture_size - fragCoord);\n            vec2 nail = add_knob(fragCoord, 1., vec2(6), 1.25, side * vec2(0, -1));\n            fragColor.rgb *= mix(clamp(length(fragCoord - vec2(6, 6.+2.*side.y))/2.5, 0., 1.), 1., .25);\n            nail.x += pow(abs(nail.x), 16.) * .25;\n            fragColor.rgb = mix(fragColor.rgb, vec3(.7, .54, .43) * nail.x, nail.y * .75);\n        }\n\n        accum += fragColor.rgb;\n    }\n    fragColor.rgb = accum * (1./float(AA_SAMPLES));\n}\n\n////////////////////////////////////////////////////////////////\n\nconst int NUM_GLYPHS = 56;\n\nWRAP(FontBitmap,FONT_BITMAP,int,NUM_GLYPHS*2)(0,0,0x7c2c3810,25190,0x663e663e,15974,0x606467c,31814,0x6666663e,15974,0x61e467e,\n31814,0x61e467c,1542,0x7303233e,1062451,0x637f6363,25443,404232216,6168,808464432,792624,991638339,17251,0x6060606,32326,\n0x6f7f7763,26989,0x5f4f4743,6320505,0x6363633e,15971,0x6666663e,1598,0x6b436322,526398,0x663e663e,17990,0x603c067c,15970,\n404249214,530456,0x66666666,15462,0x3e367763,2076,0x7f7b5b5b,8758,941379271,58230,0xc1c3462,3084,473461374,32334,0x66663c00,\n15462,404233216,6168,0x7c403e00,32258,945831424,536672,909651968,12415,0x3c043c00,536672,0x3e061c00,15462,541097472,12336,\n0x3c663c00,15462,0x7c663c00,536672,0x7e181800,6168,63<<25,0,0xc183060,774,0,1542,0,198150,1579008,6168,404232216,6144,406347838,\n6144,0x3f3f3f3f,16191,0xc0c1830,3151884,808458252,792624,0,32256,0xc0c0c3c,15372,808464444,15408,0xc183000,6303768,806882304,\n396312,0x83e7f7f,8355646,0x7f7f3e1c,67640382,0x3f3f0f03,783));\n\nint glyph_bit(uint glyph, int index)\n{\n    if (glyph >= uint(NUM_GLYPHS))\n        return 0;\n    uint data = uint(FONT_BITMAP.data[(glyph<<1) + uint(index>=32)]);\n    return int(uint(data >> (index & 31)) & 1u);\n}\n\nvec4 glyph_color(uint glyph, ivec2 pixel, float variation)\n{\n    pixel &= 7;\n    pixel.y = 7 - pixel.y;\n    int bit_index = pixel.x + (pixel.y << 3);\n    int bit = glyph_bit(glyph, bit_index);\n    int shadow_bit = min(pixel.x, pixel.y) > 0 ? glyph_bit(glyph, bit_index - 9) : 0;\n    return vec4(vec3(bit > 0 ? variation : .1875), float(bit|shadow_bit));\n}\n\nvoid bake_font(inout vec4 fragColor, vec2 fragCoord)\n{\n#if !ALWAYS_REFRESH_TEXTURES\n    if (iFrame != 0)\n        return;\n#endif\n\n    ivec2 addr = ivec2(floor(fragCoord - ADDR2_RANGE_FONT.xy));\n    if (any(greaterThanEqual(uvec2(addr), uvec2(ADDR2_RANGE_FONT.zw))))\n        return;\n    \n    const int GLYPHS_PER_LINE = int(ADDR2_RANGE_FONT.z) >> 3;\n    \n    int glyph = (addr.y >> 3) * GLYPHS_PER_LINE + (addr.x >> 3);\n    float variation = mix(.625, 1., random(fragCoord));\n    fragColor = glyph_color(uint(glyph), addr, variation);\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (is_inside(fragCoord, ADDR2_RANGE_PARAM_BOUNDS) < 0.)\n        DISCARD;\n\n    ivec2 address = ivec2(fragCoord);\n    fragColor = (iFrame == 0) ? vec4(0) : texelFetch(iChannel1, address, 0);\n    \n    accumulate_lightmap\t\t(fragColor, address);\n    generate_ui_textures\t(fragColor, fragCoord);\n    bake_font\t\t\t\t(fragColor, fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "////////////////////////////////////////////////////////////////\n// Buffer D:\n// - UV/texture mapping\n// - particles (fireball trail, shotgun pellets, teleporter effect)\n// - volumetric light shafts\n// - demo mode stages\n// - GBuffer debug vis\n////////////////////////////////////////////////////////////////\n\n// config.cfg //////////////////////////////////////////////////\n\n#define TEXTURE_FILTER\t\t\t\t1\t\t// [0=nearest; 1=linear]\n#define USE_MIPMAPS\t\t\t\t\t2\t\t// [0=off; 1=derivative-based; 2=depth+slope]\n#define LOD_SLOPE_SCALE\t\t\t\t0.9\t\t// [0.0=authentic/sharp/aliased - 1.0=smooth]\n#define LOD_BIAS\t\t\t\t\t0.0\n#define LOD_DITHER\t\t\t\t\t0.0\t\t// 1.0=discount linear mip filtering\n\n// I know, mixing my Marvel and my DC here...\n// Note: if you enable UV dithering, make sure to also\n// comment out QUANTIZE_SCENE below\n// and set LIGHTMAP_FILTER to 2 in Buffer B\n#define USE_UV_DITHERING\t\t\t0\n#define UV_DITHER_STRENGTH\t\t\t1.00\n\n#define QUANTIZE_SCENE\t\t\t\t48\t\t// comment out to disable\n\n#define RENDER_PARTICLES\t\t\t1\n#define CULL_PARTICLES\t\t\t\t1\n\n#define RENDER_VOLUMETRICS\t\t\t1\n#define RENDER_WINDOW_PROJECTION\t1\n#define VOLUMETRIC_STRENGTH\t\t\t0.125\n#define VOLUMETRIC_SAMPLES\t\t\t8\t\t// 4=low..8=medium..16=high\n#define VOLUMETRIC_MASK_LOD\t\t\t1\n#define VOLUMETRIC_FALLOFF\t\t\t400.\t// comment out to disable\n#define VOLUMETRIC_SOFT_EDGE\t\t64.\t\t// comment out to disable\n#define VOLUMETRIC_SUN_DIR\t\t\tvec3(8, -2, -3)\n#define VOLUMETRIC_PLAYER_SHADOW\t2\t\t// [0=off; 1=capsule; 2=capsule+sphere]\n#define VOLUMETRIC_ANIM\t\t\t\t1\n#define WINDOW_PROJECTION_STRENGTH\t64.\n\n#define DEBUG_DEPTH\t\t\t\t\t0\n#define DEBUG_NORMALS\t\t\t\t0\n#define DEBUG_TEXTURES\t\t\t\t0\t\t// aka fullbright mode\n#define DEBUG_MIPMAPS\t\t\t\t0\n#define DEBUG_LIGHTING\t\t\t\t0\n#define DEBUG_PARTICLE_CULLING\t\t0\n#define DEBUG_VOLUMETRICS\t\t\t0\n\n////////////////////////////////////////////////////////////////\n// Implementation //////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n\n#define NOISE_CHANNEL\t\t\t\tiChannel1\n#define SETTINGS_CHANNEL\t\t\tiChannel3\n\nfloat g_downscale = 2.;\nfloat g_animTime = 0.;\n\nvec4 load(vec2 address)\n{\n    return load(address, SETTINGS_CHANNEL);\n}\n\n// Texturing ///////////////////////////////////////////////////\n\nvec2 uv_map_axial(vec3 pos, int axis)\n{\n    return (axis==0) ? pos.yz : (axis==1) ? pos.xz : pos.xy;\n}\n\nvec2 tri(vec2 x)\n{\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nvec3 rainbow(float hue)\n{\n    return clamp(vec3(min(hue, 1.-hue), abs(hue-1./3.), abs(hue-2./3.))*-6.+2., 0., 1.);\n}\n\nvec4 get_balloon_color(const int material, const float current_level)\n{\n    vec4 color = vec4(vec3(.25),.35);\n    float hue = float(material-BASE_TARGET_MATERIAL)*(1./float(NUM_TARGETS));\n    hue = fract(hue + current_level * 1./6.);\n    color.rgb += rainbow(hue) * .5;\n    return color;\n}\n\n// iq: https://iquilezles.org/articles/checkerfiltering\nfloat checkersGrad(vec2 uv, vec2 ddx, vec2 ddy)\n{\n    vec2 w = max(abs(ddx), abs(ddy)) + 1e-4;    // filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nstruct SamplerState\n{\n    vec4 tile;\n    float atlas_scale;\n    int flags;\n};\n\nvec4 texture_lod(SamplerState state, vec2 uv, int lod)\n{\n    float texel_scale = state.atlas_scale * exp2i(-lod);\n    bool use_filter = test_flag(state.flags, OPTION_FLAG_TEXTURE_FILTER);\n\tif (use_filter)\n    \tuv += -.5 / texel_scale;\n    \n    uv = fract(uv / state.tile.zw);\n    state.tile *= texel_scale;\n    uv *= state.tile.zw;\n  \n    vec2 mip_base = mip_offset(lod) * ATLAS_SIZE * state.atlas_scale + state.tile.xy + ATLAS_OFFSET;\n\n    if (use_filter)\n    {\n        ivec4 address = ivec2(mip_base + uv).xyxy;\n        address.zw++;\n        if (uv.x >= state.tile.z - 1.) address.z -= int(state.tile.z);\n        if (uv.y >= state.tile.w - 1.) address.w -= int(state.tile.w);\n\n        vec4 s00 = gamma_to_linear(texelFetch(iChannel3, address.xy, 0));\n        vec4 s10 = gamma_to_linear(texelFetch(iChannel3, address.zy, 0));\n        vec4 s01 = gamma_to_linear(texelFetch(iChannel3, address.xw, 0));\n        vec4 s11 = gamma_to_linear(texelFetch(iChannel3, address.zw, 0));\n\n        uv = fract(uv);\n        return linear_to_gamma(mix(mix(s00, s10, uv.x), mix(s01, s11, uv.x), uv.y));\n    }\n    else\n    {\n        return texelFetch(iChannel3,  ivec2(mip_base + uv), 0);\n    }\n}\n\nvec4 sample_tile(GBuffer gbuffer, vec2 uv, float depth, float alignment, int flags, vec2 noise)\n{\n    int material = gbuffer.material;\n    \n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    \n#if USE_MIPMAPS\n    int max_lod = clamp(int(round(atlas_info.x)) - 1, 0, MAX_MIP_LEVEL - int(atlas_lod));\n    float lod_bias = LOD_BIAS - atlas_lod;\n    lod_bias += LOD_DITHER * (noise.y - .5);\n\n    #if USE_MIPMAPS >= 2\n    \tfloat deriv = depth*VIEW_DISTANCE * FOV_FACTOR * g_downscale / (iResolution[FOV_AXIS]*.5 * alignment);\n\t#else\n    \tfloat deriv = max(fwidth(uv.x), fwidth(uv.y));\n    \tif (gbuffer.edge)\n    \t\tmax_lod = int(max(LOD_BIAS, atlas_lod));\n\t#endif\n\n    int lod = int(floor(log2(max(1., deriv)) + lod_bias));\n    lod = clamp(lod, 0, max_lod);\n#else\n    const int lod = 0;\n#endif // USE_MIPMAPS\n    //lod = 0;\n    \n#if USE_UV_DITHERING\n    if (!test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n    \tuv += (noise - .5) * UV_DITHER_STRENGTH * exp2(float(lod)+atlas_lod);\n#endif\n    \n#if DEBUG_MIPMAPS\n\treturn vec4(vec3(float(lod)/6.), 0.);\n#endif\n    \n    return texture_lod(SamplerState(get_tile(material), atlas_scale, flags), uv, lod);\n}\n\nvec4 apply_material(GBuffer gbuffer, vec3 surface_point, vec3 surface_normal, vec3 eye_dir, float depth, int flags, vec2 noise)\n{\n    int material = gbuffer.material;\n    int on_edge = int(gbuffer.edge);\n    int axis = gbuffer.uv_axis;\n    \n    if (material == MATERIAL_SHOTGUN_FLASH)\n        material = MATERIAL_FLAME;\n\n    GameState game_state;\n    LOAD(game_state);\n    if (is_material_balloon(material))\n    {\n        vec4 color = get_balloon_color(material, floor(abs(game_state.level)));\n        if (game_state.level < 0.)\n        {\n            float fraction = linear_step(0., BALLOON_SCALEIN_TIME*.1, fract(-game_state.level));\n            color.rgb = mix(vec3(.25), color.rgb, sqr(fraction));\n        }\n        return color;\n    }\n    \n    if (is_material_viewmodel(material))\n    {\n        const vec4 SHOTGUN_COLORS[NUM_SHOTGUN_MATERIALS] = vec4[](vec4(.25,.18,.12,.5), vec4(.0,.0,.0,.5), vec4(0));\n        vec4 color = SHOTGUN_COLORS[min(material - NUM_MATERIALS, NUM_SHOTGUN_MATERIALS)];\n        float light = clamp(dot(vec2(abs(surface_normal.y), surface_normal.z), normalize(vec2(1, 8))), 0., 1.);\n        vec2 uv = surface_point.xy * 8.;\n#if USE_UV_DITHERING\n        uv += (noise - .5) * UV_DITHER_STRENGTH;\n#endif\n        color.rgb *= .125 + .875*light;\n        if (material == MATERIAL_SHOTGUN_BARREL)\n        {\n            color.rgb = mix(vec3(.14,.11,.06), color.rgb, sqr(sqr(light)));\n            color.rgb = mix(color.rgb, vec3(.2,.2,.25), around(.87, .17, light));\n            float specular = pow(light, 16.) * .75;\n            color.rgb += specular;\n        }\n        else\n        {\n        \tlight = clamp(dot(surface_normal.yz, normalize(vec2(-1, 1))), 0., 1.);\n            float highlight = pow(light, 4.) * .125;\n            color.rgb *= 1. + highlight;\n        }\n        if (!test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n            uv = round(uv);\n        float variation = mix(1., .83, smooth_noise(uv));\n        return vec4(color.rgb * variation, color.a);\n    }\n    \n    // brief lightning flash when shooting the sky to start a new game\n    const float LIGHTNING_DURATION = .125;\n    bool lightning =\n        game_state.level <= 1.+.1*LEVEL_WARMUP_TIME &&\n        game_state.level >= 1.+.1*(LEVEL_WARMUP_TIME - LIGHTNING_DURATION);\n    \n#if USE_MIPMAPS >= 2\n    float alignment = abs(dot(normalize(eye_dir), surface_normal));\n    alignment = mix(1., alignment, LOD_SLOPE_SCALE);\n#else\n    float alignment = 1.;\n#endif\n    \n    vec2 sample_uv[3];\n    int material2 = material;\n    int num_uvs;\n    \n    if (material == MATERIAL_SKY1)\n    {\n    \t// ellipsoidal mapping for the sky\n        const float SKY_FLATTEN = 4.;\n        sample_uv[0] = 512. * normalize(eye_dir*vec3(1.,1.,SKY_FLATTEN)).xy;\n        sample_uv[1] = rotate(sample_uv[0] + g_animTime * 24., 30.);\n        sample_uv[0] += g_animTime * 12.;\n        material2 = MATERIAL_SKY1B;\n        \n        num_uvs = 2;\n        depth = 0.;\n        alignment = 1.;\n    }\n    else if (axis != 3)\n    {\n        // world brushes, project using dominant axis\n        sample_uv[0] = uv_map_axial(surface_point, axis);\n        if (is_material_liquid(material))\n            sample_uv[0] += sin(g_animTime + sample_uv[0].yx * (1./32.)) * 12.;\n        num_uvs = 1;\n    }\n    else\n    {\n    \t// triplanar mapping (for entities)\n        const float SCALE = 2.; // higher res\n        vec3 uvw = surface_point * SCALE;\n        vec2 uv_bias = vec2(0);\n        if (material == MATERIAL_FLAME)\n        {\n        \tfloat loop = floor(g_animTime * 10.) * .1;\n        \tuv_bias.y = -fract(loop) * 64.;\n        }\n        \n        sample_uv[0] = uvw.xy + uv_bias;\n        sample_uv[1] = uvw.yz + uv_bias;\n        sample_uv[2] = uvw.xz + uv_bias;\n        num_uvs = 3;\n        depth *= SCALE;\n    }\n    \n    vec4 colors[3];\n    gbuffer.material = material;\n    colors[0] = sample_tile(gbuffer, sample_uv[0], depth, alignment, flags, noise);\n    \n    gbuffer.material = material2;\n    if (num_uvs >= 2)\n    \tcolors[1] = sample_tile(gbuffer, sample_uv[1], depth, alignment, flags, noise);\n    \n    gbuffer.material = material;\n    if (num_uvs >= 3)\n    \tcolors[2] = sample_tile(gbuffer, sample_uv[2], depth, alignment, flags, noise);\n    \n    vec4 textured;\n    if (material == MATERIAL_SKY1)\n    {\n        //textured = (dot(colors[1].rgb, vec3(1)) + noise.y*.1 < .45) ? colors[0] : colors[1];\n        textured = mix(colors[0], colors[1], linear_step(.35, .45, dot(colors[1].rgb, vec3(1))));\n        textured.rgb *= mix(1., 2., lightning);\n    }\n    else if (axis != 3)\n    {\n        textured = colors[0];\n    }\n\telse\n    {\n        vec3 axis_weights = abs(surface_normal);\n        axis_weights *= 1. / (axis_weights.x + axis_weights.y + axis_weights.z);\n\n        textured =\n            colors[0] * axis_weights.z +\n            colors[1] * axis_weights.x +\n            colors[2] * axis_weights.y ;\n    }\n    \n    // disable AO and reduce shadowing during flash\n    textured.a = mix(textured.a, min(textured.a, .35), lightning);\n    \n    return textured;\n}\n\n// Fireball particle trail /////////////////////////////////////\n\nvoid add_to_aabb(inout vec3 min_point, inout vec3 max_point, vec3 point)\n{\n    min_point = min(min_point, point);\n    max_point = max(max_point, point);\n}\n\nvoid get_fireball_bounds\n(\n    const Fireball fireball,\n    const vec3 camera_pos, const mat3 view_matrix,\n    float zslack,\n    out vec3 mins, out vec3 maxs\n)\n{\n    float apex_time = fireball.velocity.z * (1./GRAVITY);\n    vec3 apex;\n    apex.z = sqr(fireball.velocity.z) * (.5/GRAVITY);\n    apex.xy = fireball.velocity.xy * apex_time;\n    \n    vec3 pos = FIREBALL_ORIGIN - camera_pos;\n    mins = maxs = project(pos * view_matrix);\n    \n    vec3 p;\n    p = (pos + vec3(fireball.velocity.xy * (apex_time*2.), 0.));\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n\n    p = pos + fireball.velocity * fireball.velocity.z * (.5/GRAVITY);\n    p.z += zslack;\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n    \n    p = mix(p, pos + vec3(apex.xy, apex.z+zslack), 2.);\n    add_to_aabb(mins, maxs, project(p * view_matrix));\n}\n\nvoid add_teleporter_effect(inout vec4 fragColor, vec2 fragCoordNDC, vec3 camera_pos, float teleport_time)\n{\n    if (teleport_time <= 0.)\n        return;\n    \n    const float TELEPORT_EFFECT_DURATION = .25;\n\n    // at 144 FPS the trajectories are too obvious/distracting\n    const float TELEPORT_EFFECT_FPS = 60.;\n    float fraction = floor((iTime - teleport_time)*TELEPORT_EFFECT_FPS+.5) * (1./TELEPORT_EFFECT_FPS);\n    \n    if (fraction >= TELEPORT_EFFECT_DURATION)\n        return;\n    fraction = fraction * (1./TELEPORT_EFFECT_DURATION);\n\n    const int PARTICLE_COUNT = 96;\n    const float MARGIN = .125;\n    const float particle_radius = 12./1080.;\n    float aspect = min_component(iResolution.xy) / max_component(iResolution.xy);\n    float pos_bias = (-1. + MARGIN) * aspect;\n    float pos_scale = pos_bias * -2.;\n\n    // this vignette makes the transition stand out a bit more using just visuals\n    // Quake didn't have it, but Quake had sound effects...\n    float vignette = clamp(length(fragCoordNDC*.5), 0., 1.);\n    fragColor.rgb *= 1. - vignette*(1.-fraction);\n\n    int num_particles = NO_UNROLL(PARTICLE_COUNT);\n    for (int i=0; i<num_particles; ++i) // ugh... :(\n    {\n        vec4 hash = hash4(teleport_time*13.37 + float(i));\n        float speed = mix(1.5, 2., hash.z);\n        float angle = hash.w * TAU;\n        float intensity = mix(.25, 1., fract(float(i)*PHI + .1337));\n        vec2 direction = vec2(cos(angle), sin(angle));\n        vec2 pos = hash.xy * pos_scale + pos_bias;\n        pos += (fraction * speed) * direction;\n        pos -= fragCoordNDC;\n        float inside = step(max(abs(pos.x), abs(pos.y)), particle_radius);\n        if (inside > 0.)\n            fragColor = vec4(vec3(intensity), 0.);\n    }\n}\n\nvoid add_particles\n(\n    inout vec4 fragColor, vec2 fragCoordNDC,\n    vec3 camera_pos, mat3 view_matrix, float depth,\n    float attack, float teleport_time\n)\n{\n#if RENDER_PARTICLES\n    const float\n        WORLD_RADIUS\t\t= 1.5,\n    \tMIN_PIXEL_RADIUS\t= 2.,\n    \tSPAWN_INTERVAL\t\t= .1,\n    \tLIFESPAN\t\t\t= 1.,\n    \tLIFESPAN_VARIATION\t= .5,\n    \tMAX_GENERATIONS\t\t= ceil(LIFESPAN / SPAWN_INTERVAL),\n    \tBUNCH\t\t\t\t= 4.,\n        ATTACK_FADE_START\t= .85,\n        ATTACK_FADE_END\t\t= .5,\n        PELLET_WORLD_RADIUS\t= .5;\n    const vec3 SPREAD\t\t= vec3(3, 3, 12);\n    \n    add_teleporter_effect(fragColor, fragCoordNDC, camera_pos, teleport_time);\n    \n    float depth_scale = MIN_PIXEL_RADIUS * g_downscale/iResolution.x;\n    depth *= VIEW_DISTANCE;\n    \n    // shotgun pellets //\n    if (attack > ATTACK_FADE_END)\n    {\n        // Game stage advances immediately after the last balloon is popped.\n        // When we detect a warmup phase (fractional value for game stage)\n        // we have to use the previous stage for coloring the particles.\n\n        vec4 game_state = load(ADDR_GAME_STATE);\n        float level = floor(abs(game_state.x));\n        if (game_state.x != level && game_state.x > 0.)\n            --level;\n\n        float fade = sqrt(linear_step(ATTACK_FADE_START, ATTACK_FADE_END, attack));\n        vec3 base_pos = camera_pos;\n        base_pos.z += (1. - attack) * 8.;\n\n        float num_pellets = ADDR_RANGE_SHOTGUN_PELLETS.z + min(iTime, 0.);\n        for (float f=0.; f<num_pellets; ++f)\n        {\n            vec2 address = ADDR_RANGE_SHOTGUN_PELLETS.xy;\n            address.x += f;\n            vec2 props = hash2(address);\n            if (props.x <= fade)\n                continue;\n            vec4 pellet = load(address);\n            int hit_material = int(pellet.w + .5);\n            if (is_material_sky(hit_material))\n                continue;\n            vec3 pos = pellet.xyz - base_pos;\n            float particle_depth = dot(pos, view_matrix[1]) + (-2.*PELLET_WORLD_RADIUS);\n            if (particle_depth < 0. || particle_depth > depth)\n                continue;\n            vec2 ndc_pos = vec2(dot(pos, view_matrix[0]), dot(pos, view_matrix[2]));\n            float radius = max(PELLET_WORLD_RADIUS, particle_depth * depth_scale);\n            vec2 delta = abs(ndc_pos - fragCoordNDC * particle_depth);\n            if (max(delta.x, delta.y) <= radius)\n            {\n                fragColor = vec4(vec3(.5 * (1.-sqr(props.y))), 0.);\n                depth = particle_depth;\n\t\t\t    if (is_material_balloon(hit_material))\n                    fragColor.rgb *= get_balloon_color(hit_material, level).rgb * 2.;\n            }\n        }\n    }\n    \n    Fireball fireball;\n    get_fireball_props(g_animTime, fireball);\n\n\t#if CULL_PARTICLES\n    {\n        vec3 mins, maxs;\n        get_fireball_bounds(fireball, camera_pos, view_matrix, 40., mins, maxs);\n        if (maxs.z <= 0. || mins.z > depth)\n            return;\n\n        float slack = 8./mins.z + depth_scale;\n        mins.xy -= slack;\n        maxs.xy += slack;\n        if (mins.z > 0. && is_inside(fragCoordNDC, vec4(mins.xy, maxs.xy - mins.xy)) < 0.)\n            return;\n    }\n\t#endif\n    \n\t#if DEBUG_PARTICLE_CULLING\n    {\n        fragColor.rgb = mix(fragColor.rgb, vec3(1.), .25);\n    }\n\t#endif\n    \n    float end_time = min(get_landing_time(fireball), g_animTime);\n    float end_generation = ceil((end_time - fireball.launch_time) * (1./SPAWN_INTERVAL) - .25);\n    \n    for (float generation=max(0., end_generation - 1. - MAX_GENERATIONS); generation<end_generation; ++generation)\n    {\n        float base_time=fireball.launch_time + generation * SPAWN_INTERVAL;\n        float base_age = (g_animTime - base_time) * (1./LIFESPAN) + (LIFESPAN_VARIATION * -.5);\n        if (base_age > 1.)\n            continue;\n        \n        vec3 base_pos = get_fireball_offset(base_time, fireball) + FIREBALL_ORIGIN;\n\n        for (float f=0.; f<BUNCH; ++f)\n        {\n            float age = base_age + hash(f + base_time) * LIFESPAN_VARIATION;\n            if (age > 1.)\n                continue;\n            vec3 pos = base_pos - camera_pos;\n            pos += hash3(base_time + f*(SPAWN_INTERVAL/BUNCH)) * (SPREAD*2.) - SPREAD;\n            pos.z += base_age * 32.;\n            float particle_depth = dot(pos, view_matrix[1]);\n            if (particle_depth < 0. || particle_depth > depth)\n                continue;\n            vec2 ndc_pos = vec2(dot(pos, view_matrix[0]), dot(pos, view_matrix[2]));\n            float radius = max(WORLD_RADIUS, particle_depth * depth_scale);\n            vec2 delta = abs(ndc_pos - fragCoordNDC * particle_depth);\n            if (max(delta.x, delta.y) <= radius)\n            {\n                fragColor = vec4(mix(vec3(.75,.75,.25), vec3(.25), linear_step(.0, .5, age)), 0.);\n                depth = particle_depth;\n            }\n        }\n    }\n#endif // RENDER_PARTICLES\n}\n\n////////////////////////////////////////////////////////////////\n\nconst vec3\n    VOL_SUN_DIR\t\t= normalize(VOLUMETRIC_SUN_DIR),\n    VOL_WINDOW_MINS\t= vec3(64, 992, -32),\n    VOL_WINDOW_MAXS\t= vec3(64, 1056, 160),\n    VOL_WALL_POS\t= vec3(368, VOL_WINDOW_MINS.y, -72);\n\n#define MAKE_PLANE(dir, point) vec4(dir, -dot(point, dir))\n\nconst vec4 VOL_PLANES[7] = vec4[7]\n(\n\tMAKE_PLANE(normalize(cross(vec3(0, 0,-1), VOL_SUN_DIR)), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0, 0, 1), VOL_SUN_DIR)), VOL_WINDOW_MAXS),\n\tMAKE_PLANE(vec3( 1, 0, 0), VOL_WALL_POS),\n\tMAKE_PLANE(vec3(-1, 0, 0), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0, 1, 0), VOL_SUN_DIR)), VOL_WINDOW_MINS),\n\tMAKE_PLANE(normalize(cross(vec3(0,-1, 0), VOL_SUN_DIR)), VOL_WINDOW_MAXS),\n\tMAKE_PLANE(vec3(0, 0, -1), VOL_WALL_POS)\n);\n\nfloat volumetric_falloff(float dist)\n{\n#if defined(VOLUMETRIC_FALLOFF)\n    float x = clamp(sqr(1. - dist * (1./float(VOLUMETRIC_FALLOFF))), 0., 1.);\n    return x;\n    return (x * x + x) * .5;\n#else\n    return 1.;\n#endif\n}\n\nfloat volumetric_player_shadow(vec3 p, vec3 rel_cam_pos)\n{\n#if VOLUMETRIC_PLAYER_SHADOW\n    vec3 occluder_p0 = rel_cam_pos;\n    vec3 occluder_p1 = occluder_p0 - vec3(0, 0, 48);\n#if VOLUMETRIC_PLAYER_SHADOW >= 2\n    occluder_p0.z -= 20.;\n#endif // VOLUMETRIC_PLAYER_SHADOW >= 2\n\n    float window_dist = p.x * (1. / VOL_SUN_DIR.x);\n    float occluder_dist = occluder_p0.x * (1. / VOL_SUN_DIR.x);\n    p -= VOL_SUN_DIR * max(0., window_dist - occluder_dist);\n    vec3 occluder_point = closest_point_on_segment(p, occluder_p0, occluder_p1);\n    float vis = linear_step(sqr(16.), sqr(24.), length_squared(p - occluder_point));\n\n#if VOLUMETRIC_PLAYER_SHADOW >= 2\n    vis = min(vis, linear_step(sqr(8.), sqr(12.), length_squared(p - rel_cam_pos)));\n#endif // VOLUMETRIC_PLAYER_SHADOW >= 2\n\n    return vis;\n#else\n    return 1.;\n#endif // VOLUMETRIC_PLAYER_SHADOW\n}\n\nvoid add_volumetrics\n(\n    inout vec4 fragColor,\n    vec3 camera_pos, vec3 dir, float depth01,\n    vec3 normal, int uv_axis, bool viewmodel,\n    int flags, float noise, bool thumbnail\n)\n{\n#if RENDER_VOLUMETRICS\n    if (is_demo_mode_enabled(thumbnail))\n    {\n        if (!is_demo_stage_composite() || g_demo_scene < 2)\n            return;\n    }\n    else\n    {\n        if (!test_flag(flags, OPTION_FLAG_LIGHT_SHAFTS) || test_flag(flags, OPTION_FLAG_SHOW_LIGHTMAP))\n            return;\n    }\n\n    dir *= VIEW_DISTANCE;\n\n    float t_enter = 0.;\n    float t_leave = depth01;\n    for (int i=0; i<7; ++i)\n    {\n        vec4 plane = VOL_PLANES[i];\n        float dist = dot(plane.xyz, camera_pos) + plane.w;\n        float align = dot(plane.xyz, dir);\n        if (align == 0.)\n        {\n            if (dist > 0.)\n                return;\n            continue;\n        }\n        dist /= -align;\n        t_enter = (align < 0.) ? max(t_enter, dist) : t_enter;\n        t_leave = (align > 0.) ? min(t_leave, dist) : t_leave;\n        if (t_leave <= t_enter)\n            return;\n    }\n\n    if (t_leave <= t_enter)\n        return;\n    \n#if DEBUG_VOLUMETRICS\n    fragColor.rgb = clamp(fragColor.rgb * 4., 0., 1.);\n    return;\n#endif\n\n    vec4 atlas_info = load(ADDR_ATLAS_INFO);\n    float num_mips = atlas_info.x;\n    float atlas_lod = atlas_info.y;\n    float atlas_scale = exp2(-atlas_lod);\n    int mask_lod = clamp(VOLUMETRIC_MASK_LOD - int(atlas_lod), 0, int(num_mips) - 1);\n\n    SamplerState sampler_state;\n    sampler_state.tile\t\t\t= get_tile(MATERIAL_WINDOW02_1);\n\tsampler_state.atlas_scale\t= atlas_scale;\n    sampler_state.flags\t\t\t= flags;\n    vec2 uv_offset = -vec2(.5, .5/3.) * sampler_state.tile.zw;\n\n    vec3 relative_cam_pos = camera_pos - VOL_WINDOW_MINS;\n    vec3 enter = relative_cam_pos + dir * t_enter;\n    vec3 travel = dir * (t_leave - t_enter);\n\n#if RENDER_WINDOW_PROJECTION\n    sampler_state.flags = flags | OPTION_FLAG_TEXTURE_FILTER;\n    float n_dot_l = dot(-VOL_SUN_DIR, normal);\n    if (abs(t_leave - depth01) < 1e-3/VIEW_DISTANCE && n_dot_l > 0.)\n    {\n        vec3 p = relative_cam_pos + dir * depth01;\n        if (uint(uv_axis) < 3u && !test_flag(flags, OPTION_FLAG_TEXTURE_FILTER))\n        {\n            vec3 snap = .5 - fract(p);\n            p += snap * vec3(notEqual(ivec3(uv_axis), ivec3(0, 1, 2)));\n        }\n        float window_dist = p.x * (1. / VOL_SUN_DIR.x);\n        float weight = WINDOW_PROJECTION_STRENGTH * volumetric_falloff(window_dist);\n        weight *= clamp(n_dot_l, 0., 1.);\n        weight *= volumetric_player_shadow(p, relative_cam_pos);\n        weight *= linear_step(0., 2., p.z - (VOL_WALL_POS.z - VOL_WINDOW_MINS.z));\n        \n        vec2 uv = (p - window_dist * VOL_SUN_DIR).yz + uv_offset;\n        vec3 color = gamma_to_linear(texture_lod(sampler_state, uv, 0).rgb);\n\t\t\n        fragColor.rgb += fragColor.rgb * color * weight;\n    }\n    sampler_state.flags = flags;\n#endif // RENDER_WINDOW_PROJECTION\n\n    const float SAMPLE_WEIGHT = 1. / float(VOLUMETRIC_SAMPLES);\n    float base_weight = VOLUMETRIC_STRENGTH * SAMPLE_WEIGHT;\n\n#if defined(VOLUMETRIC_SOFT_EDGE)\n    float travel_dist = (t_leave - t_enter) * VIEW_DISTANCE;\n    base_weight *= linear_step(0., sqr(VOLUMETRIC_SOFT_EDGE), sqr(travel_dist));\n#endif\n\n\tfor (float f=noise*SAMPLE_WEIGHT; f<1.; f+=SAMPLE_WEIGHT)\n    {\n        vec3 p = enter + travel * f;\n        float window_dist = p.x * (1. / VOL_SUN_DIR.x);\n        float weight = base_weight * volumetric_falloff(window_dist);\n\n        vec2 uv = (p - window_dist * VOL_SUN_DIR).yz + uv_offset;\n        vec4 sample_color = texture_lod(sampler_state, uv, mask_lod);\n        sample_color = gamma_to_linear(sample_color);\n\n#if VOLUMETRIC_ANIM\n        float time = g_animTime;\n        time += smooth_noise(window_dist * (1./16.));\n        uv += time * vec2(7., 1.3);\n        uv += sin(uv.yx * (1./15.) + time * .3) * 3.;\n        weight *= smooth_noise(uv * (7./64.)) * 1.5 + .25;\n#endif // VOLUMETRIC_ANIM\n\n        weight *= volumetric_player_shadow(p, relative_cam_pos);\n        \n        fragColor.rgb += sample_color.rgb * weight;\n    }\n\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n#endif // RENDER_VOLUMETRICS\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    Options options;\n    LOAD(options);\n    \n    g_downscale = get_downscale(options);\n    vec2 actual_res = min(ceil(iResolution.xy / g_downscale * .125) * 8., iResolution.xy);\n    if (max_component(fragCoord - .5 - actual_res) > 0.)\n        DISCARD;\n    \n    bool is_thumbnail = test_flag(int(load(ADDR_RESOLUTION).z), RESOLUTION_FLAG_THUMBNAIL);\n    Lighting lighting;\n    LOAD(lighting);\n    \n\tUPDATE_TIME(lighting);\n    UPDATE_DEMO_STAGE(fragCoord, g_downscale, is_thumbnail);\n\n    vec4 current = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    GBuffer gbuffer = gbuffer_unpack(current);\n    if (current.z <= 0.)\n    {\n        fragColor = vec4(vec3(1./16.), 1);\n        return;\n    }\n    \n    Timing timing;\n    LOAD(timing);\n    g_animTime = timing.anim;\n    \n    bool is_viewmodel = is_material_viewmodel(gbuffer.material);\n    vec4 noise = BLUE_NOISE(fragCoord);\n    \n\tvec4 camera_pos = load_camera_pos(SETTINGS_CHANNEL, is_thumbnail);\n    vec3 camera_angles = load_camera_angles(SETTINGS_CHANNEL, is_thumbnail).xyz;\n    vec3 velocity = load(ADDR_VELOCITY).xyz;\n    Transitions transitions; LOAD(transitions);\n    mat3 view_matrix = rotation(camera_angles.xyz);\n    if (is_viewmodel)\n    {\n        float base_fov_y = scale_fov(FOV, 9./16.);\n        float fov_y = compute_fov(iResolution.xy).y;\n        float fov_y_delta = base_fov_y - fov_y;\n        view_matrix = view_matrix * rotation(vec2(0, fov_y_delta*.5));\n    }\n\n    vec4 ndc_scale_bias = get_viewport_transform(iFrame, iResolution.xy, g_downscale);\n    ndc_scale_bias.xy /= iResolution.xy;\n    vec2 fragCoordNDC = fragCoord * ndc_scale_bias.xy + ndc_scale_bias.zw;\n    \n    vec4 plane;\n    plane.xyz = gbuffer.normal;\n    if (is_viewmodel)\n    \tplane.xyz = plane.xyz * view_matrix;\n    vec3 dir = view_matrix * unproject(fragCoordNDC);\n    vec3 surface_point = dir * VIEW_DISTANCE * current.z;\n    plane.w = -current.z * dot(plane.xyz, dir);\n    \n    if (is_viewmodel)\n    {\n        float light_level =\n            is_demo_mode_enabled(is_thumbnail) ?\n            mix(.4, .6, hash1(camera_pos.xy)) :\n        \tgbuffer_unpack(texelFetch(iChannel0, ivec2(iResolution.xy)-1, 0)).light;\n        gbuffer.light = mix(gbuffer.light, 1., .5) * light_level * 1.33;\n        surface_point = surface_point * view_matrix;\n        surface_point.y -= get_viewmodel_offset(velocity, transitions.bob_phase, transitions.attack);\n    }\n    else\n    {\n        surface_point += camera_pos.xyz;\n    }\n    \n    fragColor = apply_material(gbuffer, surface_point, plane.xyz, dir, current.z, options.flags, noise.zw);\n\tadd_particles(fragColor, fragCoordNDC, camera_pos.xyz, view_matrix, current.z, transitions.attack, camera_pos.w);\n\n    if (g_demo_stage == DEMO_STAGE_DEPTH || DEBUG_DEPTH != 0)\n        fragColor = vec4(vec3(sqrt(current.z)), 0);\n    if (g_demo_stage == DEMO_STAGE_LIGHTING || DEBUG_LIGHTING != 0 || test_flag(options.flags, OPTION_FLAG_SHOW_LIGHTMAP))\n        fragColor.rgb = vec3(1);\n    if (g_demo_stage == DEMO_STAGE_NORMALS || DEBUG_NORMALS != 0)\n        fragColor = vec4(plane.xyz*.5+.5, 0);\n    if (g_demo_stage == DEMO_STAGE_TEXTURES || DEBUG_TEXTURES != 0)\n        fragColor.a = 0.;\n    \n    fragColor.rgb *= mix(1., min(2., gbuffer.light), linear_step(.0, .5, fragColor.a));\n    fragColor.rgb = clamp(fragColor.rgb, 0., 1.);\n\n#ifdef QUANTIZE_SCENE\n    const float LEVELS = float(QUANTIZE_SCENE);\n    const int SMOOTH_STAGES = (1<<DEMO_STAGE_DEPTH) | (1<<DEMO_STAGE_LIGHTING) | (1<<DEMO_STAGE_NORMALS);\n    if (!test_flag(options.flags, OPTION_FLAG_TEXTURE_FILTER) &&\n        !test_flag(SMOOTH_STAGES, 1<<g_demo_stage) &&\n        !test_flag(options.flags, OPTION_FLAG_SHOW_LIGHTMAP))\n    \tfragColor.rgb = round(fragColor.rgb * LEVELS) * (1./LEVELS);\n#endif\n    \n    fragColor.rgb = gamma_to_linear(fragColor.rgb);\n    \n    add_volumetrics\n\t(\n        fragColor,\n        camera_pos.xyz, dir, current.z,\n        gbuffer.normal, gbuffer.uv_axis, is_viewmodel,\n        options.flags, noise.y, is_thumbnail\n    );\n\n    // hack: disable motion blur for the gun model\n    fragColor.a = is_viewmodel ? -1. : current.z;\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}