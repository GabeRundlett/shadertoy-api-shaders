{
    "Shader": {
        "info": {
            "date": "1580802117",
            "description": "Use mouse to move. See comments.",
            "flags": 64,
            "hasliked": 0,
            "id": "wldXWr",
            "likes": 62,
            "name": "Corona Virus",
            "published": 3,
            "tags": [
                "coronavirus"
            ],
            "usePreview": 0,
            "username": "BigWIngs",
            "viewed": 3594
        },
        "renderpass": [
            {
                "code": "// \"Corona Virus\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Music: Xerxes - early-morning-crystals\n//\n// This effect depicts my idea of what a virus could\n// look like taking a huge artistic license. I started making what\n// I imagine to be a lipid bilayer and then realized.. a virus\n// doesn't have one! So then I just figured I'd make it look 'mean'\n// \n// At first I tried using sphere coordinates but they distort too \n// much and have poles, so I ended up with projected cubemap\n// coordinates instead. I think the function WorldToCube below\n// is extremely usefull if you want to bend stuff around a sphere\n// without too much distortion.\n//\n// As usual, the code could be a lot better and cleaner but I figure\n// that by the time its all clean, I've lost interest and the world\n// has moved on. Better ship it while its hot ;)\n//\n// uncomment the MODEL define to see once particle by itself\n// you can change the amount of particles by changing the\n// FILLED_CELLS define\n\n\n//#define MODEL\n#define FILLED_CELLS .3\n\n#define PI 3.1415\n#define TAU 6.2831\n\n#define MAX_STEPS 400\n#define MAX_DIST 40.\n#define SURF_DIST .01\n\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat N31(vec3 p) {\n\tvec3 a = fract(vec3(p) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a + 79.76);\n    return fract(a.x * a.y * a.z);\n}\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec3 SphereCoord(vec3 p) {\n\tfloat x = atan(p.x, p.z);\n    float y = atan(length(p.xz), p.y);\n    \n    return vec3(x/TAU, length(p), 2.*y/TAU);\n}\n\n// returns cubemap coordinates\n// xy = uv coords for face of cube, z = cube index (-3,-2,-1, 1, 2, 3)\nvec3 WorldToCube(vec3 p) {\n\tvec3 ap = abs(p);\n    vec3 sp = sign(p);\n    float m = max(ap.x, max(ap.y, ap.z));\n    vec3 st;\n    if(m==ap.x)\n        st = vec3(p.zy, 1.*sp.x);\n    else if(m==ap.y)\n        st = vec3(p.zx, 2.*sp.y);\n    else\n        st = vec3(p.xy, 3.*sp.z);\n    \n    st.xy /= m;\n    \n    // mattz' distortion correction\n    st.xy *= (1.45109572583 - 0.451095725826*abs(st.xy));\n       \n    return st;\n}\n\nfloat Lipid(vec3 p, float twist, float scale) {\n    vec3 n = sin(p*20.)*.2;\n    p *= scale;\n    \n\tp.xz*=Rot(p.y*.3*twist);\n    p.x = abs(p.x);\n    \n    float d = length(p+n)-2.;\n    \n    float y = p.y*.025;\n    float r = .05*scale;\n    float s = length(p.xz-vec2(1.5,0))-r+max(.4,p.y);\n    d = smin(d, s*.9,.4);\n    \n    return d/scale;\n}\n\nfloat sdTentacle(vec3 p) {\n    float offs = sin(p.x*50.)*sin(p.y*30.)*sin(p.z*20.);\n    \n    p.x += sin(p.y*10.+iTime)*.02;\n    p.y *= .2;\n    \n    float d = sdCapsule(p, vec3(0,0.1,0), vec3(0,.8,0), .04);\n    \n    p.xz = abs(p.xz);\n    \n    d = min(d, sdCapsule(p, vec3(0,.8,0), vec3(.1,.9,.1), .01));\n    d += offs*.01;\n    \n    return d;\n}\n\n\nfloat Particle(vec3 p, float scale, float amount) {  \n    float t = iTime;\n \n    vec3 st = WorldToCube(p);\n    vec3 cPos = vec3(st.x, length(p), st.y);\n    vec3 tPos = cPos;\n    \n    vec3 size = vec3(.05);\n  \t\n    cPos.xz *= scale;\n    vec2 uv = fract(cPos.xz)-.5;\n    vec2 id = floor(cPos.xz);\n    \n    uv = fract(cPos.xz)-.5;\n    id = floor(cPos.xz);\n    \n    \n    float n = N21(id);\n    \n    t = (t+st.z+n*123.32)*1.3;\n    float wobble = sin(t)+sin(1.3*t)*.4;\n    wobble /= 1.4;\n    \n    wobble *= wobble*wobble;\n    \n    wobble = wobble*amount/scale;\n    vec3 ccPos = vec3(uv.x, cPos.y, uv.y);\n    vec3 sPos = vec3(0, 3.5+wobble, .0);\n    \n    vec3 pos = ccPos-sPos;\n    \n    pos.y *= scale/2.;\n   \n    float r = 16./scale;\n    r/=sPos.y; // account for height\n    float d = length(pos)-r;\n    d = Lipid(pos, n, 10.)/scale;\n    \n    d = min(d, length(p)-.2*scale);\t// inside blocker\n    \n    \n    float tent = sdTentacle(tPos);\n    d = min(d, tent);\n    \n    return d;\n}\n\nfloat dCell(vec3 p, float size) {\n    p = abs(p);\n    float d = max(p.x, max(p.y, p.z));\n    \n    return max(0., size - d);\n}\n\nfloat GetDist(vec3 p) {\n\tfloat t = iTime;\n    \n    float scale=8.;\n    \n    #ifndef MODEL\n    p.z += t;\n    vec3 id = floor(p/10.);\n    p = mod(p, vec3(10))-5.;\n    float n = N21(id.xz);\n    p.xz *= Rot(t*.2*(n-.5));\n    p.yz *= Rot(t*.2*(N21(id.zx)-.5));\n    scale = mix(4., 16., N21(id.xz));//mod(id.x+id.y+id.z, 8.)*2.;\n    \n    n = N31(id);\n    if(n>FILLED_CELLS) {\t\t\t// skip certain cells\n        return dCell(p, 5.)+.1;\n    }\n    #endif\n    \n   \n    \n    p += sin(p.x+t)*.1+sin(p.y*p.z+t)*.05;\n    \n   \n    float surf = sin(scale+t*.2)*.5+.5;\n    surf *= surf;\n    surf *= 4.;\n    surf += 2.;\n    float d = Particle(p, scale, surf);\n    \n    p.xz *= Rot(.78+t*.08);\n    p.zy *= Rot(.5);\n    \n    d = smin(d, Particle(p, scale, surf), .02);\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float cone = .0005;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST+dO*cone) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, vec3 up, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(up, f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.xy;\n    if(m.x<-0.45&&m.y<-.45) m += .5;\n    \n    float t = iTime;\n    \n    vec3 col = vec3(0);\n    \n    #ifdef MODEL\n    vec3 ro = vec3(0, 0, -7);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,0,0), vec3(0,1,0), .5);\n    //ro += 3.;\n    #else\n    vec3 ro = vec3(0, 0, -1);\n    //ro.y += sin(t*.1)*3.;\n    ro.yz *= Rot(-m.y*2.);\n    ro.xz *= Rot(iTime*.0-m.x*6.2831);\n    \n    vec3 up = vec3(0,1,0);\n    up.xy *= Rot(sin(t*.1));\n    vec3 rd = R(uv, ro, vec3(0,0,0), up, .5);\n    \n    ro.x += 5.;\n    ro.xy *= Rot(t*.1);\n    ro.xy -= 5.;\n    #endif\n    \n    float d = RayMarch(ro, rd);\n    \n    float bg = rd.y*.5+.3;\n    float poleDist = length(rd.xz);\n    float poleMask = smoothstep(.5, 0., poleDist);\n    bg += sign(rd.y)*poleMask;\n    \n    float a = atan(rd.x, rd.z);\n    bg += (sin(a*5.+t+rd.y*2.)+sin(a*7.-t+rd.y*2.))*.2;\n    float rays = (sin(a*5.+t*2.+rd.y*2.)*sin(a*37.-t+rd.y*2.))*.5+.5;\n    bg *= mix(1., rays, .25*poleDist*(sin(t*.1)*.5+.5));//*poleDist*poleDist*.25;\n    col += bg;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n   \n    \tvec3 n = GetNormal(p);\n       \n        #ifndef MODEL\n        p = mod(p, vec3(10))-5.;\n        #endif\n        \n        float s = dot(n, normalize(p))-.4;\n        float f = -dot(rd, n);\n        \n        col += dot(n,-rd)*.5+.5;\n    \t//col += (1.-f*f)*s*1.5;\n        \n        col *= 0.;\n        float r = 3.7;\n        float ao = smoothstep(r*.8, r, length(p));\n        col += (n.y*.5+.5)*ao*2.;\n        //col *= 2.;\n        col *= smoothstep(-1., 6., p.y);\n        \n        //col += n*.5+.5;\n    }\n    \n    col = mix(col, vec3(bg), smoothstep(0., 40., d));\n    \n    //col *= vec3(1., .9, .8);\n    //col = 1.-col;\n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 21108,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/spiral-trax/xerxes-early-morning-crystals"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}