{
    "Shader": {
        "info": {
            "date": "1725841562",
            "description": "I tried to create a an implicit surface with the Trefoil knot topology with the lowest degree polynomial that I could. So far, this is degree 8.",
            "flags": 0,
            "hasliked": 0,
            "id": "lfSBzt",
            "likes": 65,
            "name": "Simplified Trefoil",
            "published": 3,
            "tags": [
                "procedural",
                "3d",
                "raymarching",
                "implicit",
                "trefoil",
                "know",
                "implicitfield"
            ],
            "usePreview": 1,
            "username": "iq",
            "viewed": 785
        },
        "renderpass": [
            {
                "code": "// Copyright Inigo Quilez, 2024 - https://iquilezles.org/\n// I am the sole copyright owner of this Work. You cannot host, display,\n// distribute or share this Work neither as it is or altered, here on\n// Shadertoy or anywhere else, in any form including physical and digital.\n// You cannot use this Work in any commercial or non-commercial product,\n// website or project. You cannot sell this Work and you cannot mint an\n// NFTs of it, and you cannot use it to train a Machine Learning model.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// The experiment here was to crate a Trefoil shape with an implicit field\n// that is a polynomial of the lowest degree possible. Of course, once can\n// put some quadratic or cubic bezier segments together, but that would be\n// just a piecewise solution, not a simple implicit function.\n//\n// I followed https://en.wikipedia.org/wiki/Trefoil_knot, and modified the\n// the stereographic projection (broke it really), so the final polynomial\n// is only of degree 8. See also https://www.shadertoy.com/view/fdyXWK\n\n\n// make higher for a cleaner image\n#define AA 2\n\n// randoms\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; } // oldschool rand() from Visual Studio\nfloat frand(void) { return float(rand())/32767.0; }\nint   hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }// hash to initialize the random sequence (copied from Hugo Elias)\n\n// intersect sphere (https://iquilezles.org/articles/intersectors/)\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n    return vec2(-b-h,-b+h);\n}\n\n#define ZERO (min(iFrame,0))\n//===============================================================================================\n\nvec3 texture_3d( sampler2D sam, in vec3 q )\n{\n    q *= 0.5;\n    return max(max(textureLod(sam,q.xy,1.0).xyz,\n                   textureLod(sam,q.yz,1.0).xyz ),\n                   textureLod(sam,q.zx,1.0).xyz );\n}\n\nvec3 transform( in vec3 p )\n{\n    float an = 6.283185*(iTime-0.0)/40.0;\n    p.xz *= mat2(cos(an),-sin(an),sin(an),cos(an));\n    return p.yxz;\n}\n\n//===============================================================================================\n\nconst float kBound = 2.2;\n\n// The inverse stereographic projection has the following form:\n// (see https://en.wikipedia.org/wiki/Stereographic_projection)\n//\n// q = { 2p, |p|²-1 } / (|p|²+1);\n//\n// But the following simplification, while distorting a bit too\n// much, does the trick too and reduces the degree of the final\n// implicit by half.\n//\n// q = { p, |p|²-1 }\n//\n// From there nthe rest goes just like in this previous shader:\n// https://www.shadertoy.com/view/fdyXWK. I don't think there's\n// getting around the complex cube and square to make the curve\n// turn 3 times in one direction and 2 in the other.\n//\n// float x = p.x;\n// float y = p.y;\n// float z = p.z;\n// float w = x*x + y*y + z*z - 1.0;\n//    \n// float s =  x*x*x - 3.0*x*y*y + z*z - w*w;\n// float t = -y*y*y + 3.0*x*x*y + 2.0*z*w;\n\nfloat map( in vec3 p )\n{\n    // rotate\n    p = transform(p);\n   \n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    \n    float s =  \n    - 1.0*x*x*x*x \n    - 1.0*y*y*y*y\n    - 1.0*z*z*z*z \n    - 2.0*x*x*y*y \n    - 2.0*x*x*z*z \n    - 2.0*y*y*z*z \n    + 1.0*x*x*x \n    - 3.0*x*y*y\n    + 2.0*x*x \n    + 2.0*y*y \n    + 3.0*z*z\n    - 1.0;\n    float t = \n    - 1.0*y*y*y \n    + 3.0*x*x*y \n    + 2.0*z*x*x \n    + 2.0*z*y*y \n    + 2.0*z*z*z \n    - 2.0*z;\n\n    float u = s*s + t*t;\n    \n// s is degree 4 and t is degree 3, so u is degree 8. The field\n// map(p) is f(x,y,z) = u - r = 0, our degree 8 polynomial; for\n// example we could do r = 0.1. But to make rendering easier, I\n// \"linearize\" the field by taking its 8th root. Also, I expand\n// the radius r to compensate for the inverse projection.\n    \n    float d = pow(u,1.0/8.0) - 0.75 - 0.12*dot(p,p);\n    \n    // aesthetics - displace a bit\n    if( d<0.02 ) d -= 0.01*(texture_3d(iChannel0,p).x-0.5);\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*eps);\n       //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif   \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float k )\n{\n    vec2 bb = iSphere( ro, rd, vec4(0.0,0.0,0.0,kBound) );\n\n    float tmax = bb.y;\n    float t = 0.001;\n    float sh = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        sh = min( sh, clamp(k*d/t,0.0,1.0) );\n        if( sh<0.001 ) break;\n        t += clamp(d,0.01,0.1);\n        if( t>tmax ) break;\n    }\n    return sh*sh;\n}\n\n// https://iquilezles.org/articles/nvscene2008/\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    const int num = 32;\n\tfor( int i=ZERO; i<num; i++ )\n\t{\n\t\tfloat h = frand();\n        vec3 kv = normalize( vec3(frand(), frand(), frand()) );\n        kv *= sign(dot(kv,nor));\n\t\tao += clamp( map(pos+nor*0.001+kv*h*kBound), 0.0, 1.0 );\n        if( ao>float(num) ) break;\n\t}\n\tao /= float(num);\n\t\n\treturn clamp( ao*1.1-0.1, 0.0, 1.0 );\n}\n\n// regular SDF raymarching within a bounding sphere\nfloat raycast( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n    \n    vec2 bs = iSphere( ro, rd, vec4(0.0,0.0,0.0,kBound) ); // bounding sphere\n    if( bs.y>0.0 )\n    {\n        float t = max(bs.x,0.0);\n        for( int i=0; i<512; i++ )\n        {\n            vec3 pos = ro + rd*t;\n            float d = map(pos);\n            if( abs(d)<0.0002 ) { res=t; break; }\n            t += 0.45*d;\n            if( t>bs.y ) break;\n        }\n    }\n    \n    return res;\n}\n\nconst vec3  kLigPos[2] = vec3[2]( 4.0*normalize(vec3(1.0,0.6,0.1)), 4.0*normalize(vec3(-1.0,0.3,-0.5)) );\nconst vec3  kLigCol[2] = vec3[2]( 1.5*vec3(16.0,12.0,8.0), 0.6*vec3(8.0,12.0,16.0) );\nconst float kLigSpe[2] = float[2]( 3.0, 1.5 );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(iFrame))));\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n        // camera movement\t\n        float an = 0.0*iTime/20.0;\n        vec3  ta = vec3( 0.0, 0.20, 0.0 );\n        vec3  ro = ta + 5.5*vec3( sin(6.283185*an), 0.1, cos(6.283185*an) );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 3.0*ww );\n        \n        // dof\n        vec3 fp = ro + rd * 4.75;\n        float ra = 6.283185*frand();\n        ro += sqrt(frand())*(uu*cos(ra)+vv*sin(ra))*0.03;\n        rd = normalize( fp - ro );\n\n        // background\n        vec3 col = 0.0*vec3(0.0,0.004,0.02)/(1.0+4.0*dot(p,p));\n \n        // raycast\n        float t = raycast( ro, rd );\n        if( t>0.0 )\n        {\n            // material\n            vec3  pos = ro + rd*t;\n            vec3  nor = calcNormal( pos, 0.0001 );\n            float occ = calcAO( pos+nor*0.001, nor );\n\n            vec3 opos = transform(pos);\n            vec3 mate = texture_3d(iChannel0,opos);\n            occ *= 0.2 + 0.8*mate.x;            \n            float ks = 0.2+0.8*mate.x;\n            mate *= 0.35;\n\n            // lighting\n            col = vec3(0.0);\n\n            // 2 lamps\n            for( int i=ZERO; i<2; i++ )\n            {\n                vec3 ligPos = kLigPos[i];\n                vec3 lig = normalize(ligPos-pos);\n\n                float dif = 1.0;\n                dif *= clamp(dot(nor,lig),0.0,1.0);\n                dif *= pow( dot( lig, normalize(ligPos) ), 12.0 );\n                dif *= 5.0/dot(ligPos-pos,ligPos-pos);\n                if( dif>0.001 )\n                dif *= shadow(pos+nor*0.001, lig, 4.0);\n                col += mate*dif*kLigCol[i];\n\n                vec3 hal = normalize(lig-rd);\n                float spe = pow(clamp(dot(nor,hal),0.0,1.0),48.0);\n                spe *= 0.04 + 0.96*pow( clamp(1.0-max(dot(hal,rd),0.0), 0.0, 1.0), 5.0 );\n                col += spe*dif*ks*kLigSpe[i];\n            }\n\n            // bounce\n            col += 0.02*vec3(1.2,0.7,0.5)*mate*occ*max(0.0,0.5-0.5*nor.y);\n            // top\n            col += 0.05*vec3(1.0,1.0,1.0)*mate*occ*pow(0.5+0.5*nor.y,4.0);\n            \n            col = pow( col, vec3(0.9,0.95,1.0) );\n        }\n\n        // glare\n        col += 0.0002*kLigCol[0]*pow( max(0.0,dot(normalize(kLigPos[0]-ro),rd)), 48.0 );\n        col += 0.0002*kLigCol[1]*pow( max(0.0,dot(normalize(kLigPos[1]-ro),rd)), 48.0 );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    // gain\n    tot = tot*1.5/(1.0+tot);\n\n    // to gamma space\n    tot = pow( tot, vec3(0.4545) );\n\n    // remove color banding through dithering\n    tot += (1.0/255.0)*frand();\n \n    fragColor = vec4( tot, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 10,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}