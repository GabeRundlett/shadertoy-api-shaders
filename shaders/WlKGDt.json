{
    "Shader": {
        "info": {
            "date": "1580183934",
            "description": "Weird looking moons spinning around planets. This is only my second real shader and realize this was not done efficiently, but don't know how to do it better!\nI still am learning how to add colors.",
            "flags": 0,
            "hasliked": 0,
            "id": "WlKGDt",
            "likes": 1,
            "name": "Four Planets With Moons",
            "published": 3,
            "tags": [
                "raymarching"
            ],
            "usePreview": 0,
            "username": "timF",
            "viewed": 285
        },
        "renderpass": [
            {
                "code": "#define MAX_STEPS 30.0\n#define MIN_DISTANCE 0.1\n#define MAX_DISTANCE 100.0\n#define PI 3.14159265359\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat4 rotationMatrix(float angle, vec3 axis)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\nfloat map(vec3 p){\n \n    vec3 boxPos = p;\n    boxPos.y -= 2.0;\n    \n    float box = sdBox( boxPos, vec3(.5,.2,1.0 ));\n    \n    vec4 pPos = vec4(p,0.0);\n    \n    vec4 planets[4] = vec4[4](pPos,pPos,pPos,pPos);\n    \n    float finalShape = 0.0;\n    \n    float planetShapes[4];\n    \n    float speed = 3.0;\n    \n  \tfloat moonShapes[4];\n    \n    for (int i = 0; i < 4; i++){\n        float iAsFloat = float(i);\n        \n        float randomSpeed = rand(iAsFloat+1.0);\n        \n        \n        float curRotation =  randomSpeed * speed ;\n     \tplanets[i] = rotationMatrix(iTime * curRotation, vec3(0.0,1.0,0.0)) * planets[i];   \n    \tplanets[i].x += 3.0+ iAsFloat*3.0;\n        float newPlanet = sdSphere(planets[i].xyz, .30 * randomSpeed * 2.5);\n\t\n        planetShapes[i] = newPlanet;\n        \n        speed -= .3;\n        \n        vec4 newMoonPos = planets[i];\n        newMoonPos.x += .6* randomSpeed;\n        newMoonPos = rotationMatrix(iTime*20. * randomSpeed, vec3(0.0,1.0,0.0)) * newMoonPos;\n        //newMoonPos += 1.3;\n        //planets[i];\n        \n        \n        \n        newMoonPos = rotationMatrix(iTime*15., vec3(0.0,1.0,0.0))*planets[i]+.7;\n        newMoonPos.y -= 1.0;\n        //newMoonPos = rotationMatrix(iTime, vec3(0.0,1.0,0.0)) * newMoonPos;\n        float newMoon = sdSphere(newMoonPos.xyz, .1);\n        moonShapes[i] = newMoon;\n    }\n    \n    \n\n    float sun = sdSphere(p, 1.50);\n    \n    finalShape = min(planetShapes[0],planetShapes[1]);\n    finalShape = min(sun,finalShape);\n    finalShape = min(planetShapes[2], finalShape);\n    finalShape = min(planetShapes[3], finalShape);\n    \n    // moons\n    finalShape = min(moonShapes[0],finalShape);\n    finalShape = min(moonShapes[1], finalShape);\n    finalShape = min(moonShapes[2],finalShape);\n    finalShape = min(moonShapes[3],finalShape);\n    \n\treturn finalShape;\n}\n\n\nvec3 getNormal(vec3 p){\n\t//sampling around the point\n\tvec2 e = vec2(0.01, 0.0); //eplison - small offset\n\tfloat d = map(p);\n\tvec3 n = d - vec3(\n\t\t\t\t\tmap(p-e.xyy),\n\t\t\t\t\tmap(p-e.yxy),\n\t\t\t\t\tmap(p-e.yyx));\n\treturn normalize(n);\n}\n\nfloat diffuseLighting(vec3 p) {\n    vec3 lightPosition = vec3(3,9,-3);\n    vec3 light = normalize(lightPosition - p); // normalize the vector\n    vec3 normal = getNormal(p);\n\n    float diffuse = clamp( dot(normal, light), 0., 1.); // percentage of similarity\n    return diffuse;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv.st * 2.0 - 1.0 ; // 0 is the center\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 8.0, -3.5); // change this to change the camera\n    \n    float camOffset = sin(iTime*.2)*-.6-1.0;\n    float camOffsetPos = cos(iTime*.3)*-2.0+.7;//sin(iTime * 5.0);\n    mat4 camRotMat = rotationMatrix(camOffset, vec3(1.0,0.0,0.0));\n    rayOrigin.y -= camOffsetPos;\n    \n    vec3 rayDirection = normalize(camRotMat * vec4(uv, 1.,0.0)).xyz;\n        \n        //normalize();\n    float diffuse;\n    float distanceOrigin = 0.0; // initial distance from cam is 0\n\n    vec3 normal;\n    // you must define a max limit for marching...\n    // good upper limit is 128\n    for ( int i = 0; i < 128; i++ ) {\n\n        // start with camera origin + the incremented value, * ray Direction\n        vec3 position = rayOrigin + distanceOrigin * rayDirection;\n        //formula to create a sphere\n        float map = map(position); // just for naming\n        distanceOrigin += map; // check again after hitting the radius of the sphere\n\n        //set the near and far clipping plane\n        if (distanceOrigin < MIN_DISTANCE || distanceOrigin > MAX_DISTANCE) break;\n        diffuse = diffuseLighting(position);\n\n    }\n\n    distanceOrigin /= 2.; // couldn't see the map, so divide by 2\n\n    vec3 shape = vec3(1,1,1) * diffuse;\n    \n\n    vec4 color = vec4(shape,1);\n\n    // Output to screen\n    fragColor = vec4(color);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}