{
    "Shader": {
        "info": {
            "date": "1634348671",
            "description": "It's commented but messy. I'll put up a way shorter version later that should be clearer.\nI only use euclidean distance no step size moves. I guess there could be a fully integer version if we made each level's cell size an int power of 2",
            "flags": 0,
            "hasliked": 0,
            "id": "7dVSRh",
            "likes": 43,
            "name": "QuadTree Traversal [Commented]",
            "published": 3,
            "tags": [
                "commented",
                "quadtree",
                "traversal"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 1312
        },
        "renderpass": [
            {
                "code": "/* \n   This leads directily into my 3D version (Octree):\n   https://www.shadertoy.com/view/fdyXDR\n   \n   \n   SPOILERS:\n\n   The Basic Idea\n    \n   It might not be obvious from this code as it's a bit\n   convoluted, but there are three main concepts\n   \n   Quadtrees, DDA algorithms, and traversing a grid\n   \n   Together it is traversing a quadtree grid with a modified dda algo\n   \n   1. \n   \"Build the quad tree\" which really is just running that\n   space partitioning until a random stop level for each pixel\n   in a given cell at that level. \n   I can paint the quatree to final color using just the ending level \n   or the ending scale\n   \n   Important is this returns the cellsize (1./levelScale)\n  \n   2. \n   Most dda algos have an intialization phase where you have to snap\n   the start position to the nearest axis in the rd direction. I use\n   cellSize to calculate that based on the cellsize of the level the ro \n   is in, in the quadtree. Thats just a slight modification from the\n   fixed cellsize dda algorithm in lodev's tutorial. I scale the\n   ro, floor(ro), ceil(ro) by 1./cellSize to get to the local uv of the\n   quadtree, do the subtraction to get dist to nearest wall of that cell,\n   and then scale by cellSize to get back to global coordinates.\n   This dda initialization gives us the t value (euclidian distance)\n   to the nearest axis in the quadtree.\n   \n   3. \n   Carrying on from step two I basically do the same thing at every \n   step as I step through with t values based on current cell size,\n   and then calculate new t values and make new steps. I paint green \n   dots at every iteration.\n   \n   -----------------------------\n   \n   I have a version now that is a lot more simple.\n   It has just one quadtree function, since having a \n   quadtree and then a \"map\" that does almost the same is\n   redundant. There are also variables that are unessesary, \n   and some parts of the code can be branchless and some can\n   take advantage of the componentwise operations of min,max,abs,etc\n   more.\n        \n    \n   Random Note \n   \n   ------------\n   \n   Nudging the current position a bit in the ray direction was critical\n   otherwise we remain at the last floor value and the calculations\n   of t values in my code depend on that not being the case\n   \n   Another option might have been subtracting the cellsize of that\n   level by the result so that if the result was 0 (meaning\n   we were infact on a boundary, we would get a full cellsize instead of 0.\n   This wasn't nessesary though\n   \n   \n  \n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 6.\n#define debugCoord vec2(-1.,0.)\n#define debug 1.\n#define globalScale 2.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n//  1 out, 2 in...\nfloat rnd(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Drawing stuff\nfloat drawPoint(vec2 uv, vec2 p, float r){\n    float c = length(uv - p);\n    float ss = eps * 4.;\n    c = 1.-smoothstep(r-ss, r+ss, c);\n  return c;\n}\n//Drawing stuff\nfloat distLine(vec2 p, vec2 A, vec2 B){\n    vec2 AB = B-A;\n  float t =  clamp(dot(AB,p-A)/dot(AB,AB),0.,1.);\n  vec2 P3 = A + (B-A)*t;\n  return length(P3-p);\n}\n//Drawing stuff\nfloat drawLine(vec2 uv, vec2 A, vec2 B, float r){\n    float ss = eps*3.;\n    float d = distLine(uv,A,B);\n    d = smoothstep(r+ss, r-ss, d);\n  return d;\n}\n\n//The map that partitions space until we reach the level\n//where the hash of the cellID gives back a value < 0.5\nfloat map(vec2 pos){\n  \n  vec2 localUV;\n  vec2 cellID;\n  float currentCellSize = 2.;// ?\n  float s = 1.;\n\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    \n      localUV = s * pos;\n      cellID = floor(localUV);\n      float rndID = rnd(cellID);\n\n      \n      s *= 2.;\n    \n    //starting cellSize at 2 because we only break after dividing by 2.\n     currentCellSize /=2.;\n    //divide by 2 AFTER currentCellSize because otherwise you don't\n    //calculate the steps properly at the random exit points\n    if( rndID < 0.5 ) break;\n  }\n  //give back cellsize, that's critical\n  return currentCellSize;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n  \n  vec3 col = vec3(0.);\n  uv *= globalScale;\n  \n  //step 1. Quad Tree ----------------------------------------\n  \n  //way too many variables for a quatree \n  vec2 globalUV = uv;\n  vec2 localUV = uv;\n  float level = 0.;\n  vec2 cellUV;\n  vec2 cellID;\n  float currentCellSize = 1.;\n  float s = 1.;\n  float extraLevel = float(floor(uv) == debugCoord)*debug;\n  \n  \n  \n  //if( max( abs(uv.x), abs(uv.y) ) > currentCellSize)\n  for(float i = 1.; i < MAX_LEVEL; i++){\n      level++;\n      localUV = s * globalUV;\n      cellUV = fract(localUV);\n      cellID = floor(localUV);\n    \n     //interessant float rndID = rnd(vec2(cellID.x,0.));\n      float rndID = rnd(cellID);\n    \n      if( max(abs(cellUV.x-0.5),\n           abs(cellUV.y-0.5) ) > 0.49-s/200.) {\n               level = 0.;\n               break;\n             }\n             \n     if( rndID < 0.5 ) break;\n     s *= 2.;\n     //currentCellSize /=2.;\n             \n  }\n  \n  \n  //drawing the quad tree\n  col = vec3(level/MAX_LEVEL);\n  \n  \n  \n  //Step 2. Ray and DDA Initialize  //------------------------------------\n  \n  \n  //starting a new section of initializing\n  //(maybe for this one we'll go simplified\n  //so start point is always 0,0\n  \n  vec2 ro = vec2(sin(iTime/8.)*.25,cos(iTime/8.)*.25);\n  vec2 rd = vec2(-1.,0.);\n  rd *= rot(iTime/4.);\n  float lineLength = 4.*globalScale;\n  \n  //drawing the ray\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro, 0.02));\n  col=mix(col, vec3(1.,0.,0.), drawLine(uv, ro, ro+rd*lineLength, 0.014));\n  col=mix(col, vec3(1.,0.,0.), drawPoint(uv, ro+rd*lineLength, 0.02));\n  col=mix(col, vec3(0.,1.,0.), drawPoint(uv, ro, 0.02));\n  \n  //get delta (from lodev raycasting tutorial\n  vec2 delta;\n       delta.x  = abs(rd.x) < eps ? 1e30 : abs(1./rd.x);\n       delta.y  = abs(rd.y) < eps ? 1e30 : abs(1./rd.y);\n \n  \n  \n  //this would only evaulate the first level of the quad tree no matter where the ro\n  //was. \n  //We need to replace t with the distance to the first cell regardless of size\n  //to do that we need to find the distance from ro to that \n  \n  //This right here is the final cellsize for the ro position in the tree\n  float cellSize = map(ro);\n  \n  \n  //get the initial t value (basic version of this is in the lodev tutorial)\n  //I use \"cellSize\" to transform the ro back to the local coordinates and get what the difference\n  //would be locally which is how we get the initial t value in any level of the quadtree\n  \n  vec2 tStart;\n  tStart.x = rd.x < 0. ? ( ro.x/cellSize - floor(ro.x/cellSize) ) * cellSize * delta.x \n                           : ( ceil(ro.x/cellSize) - ro.x/cellSize ) * cellSize * delta.x;\n                           \n  tStart.y = rd.y < 0. ? ( ro.y/cellSize - floor(ro.y/cellSize) ) * cellSize * delta.y \n                           : ( ceil(ro.y/cellSize) - ro.y/cellSize ) * cellSize * delta.y;\n  \n \n //we'll hit the closest axis first\n  float tCurr = min(tStart.x,tStart.y);\n  vec2 currentPos;\n  vec2 tNext;\n  \n  \n  //Step 3. Running the Modified DDA---------------------------------------\n  \n  \n  for( float i = 0.; i < 30.; i++ ){\n     \n    currentPos = ro + rd*tCurr*1.01;//this slight nudge in the rd direction is critical\n    //without it, you are stuck on the floor values\n    //if it's too low, like 1.00001 you get too much flickering\n    \n    col=mix(col, vec3(0.,1.,0.), drawPoint(uv, currentPos, 0.02));\n    \n    float newSize = map(currentPos);\n    \n    //because I nudge a bit along the rd direction, the currentPos\n    //is never on an axis, so these calculations work fine. Otherwise\n    //I'd need something like what I mentioned at the top.\n    \n    tNext.x = rd.x < 0. ? ( ( currentPos.x/newSize - floor(currentPos.x/newSize)) * newSize ) * delta.x \n                        : (  ( ceil(currentPos.x/newSize) - currentPos.x/newSize ) * newSize ) * delta.x;\n    \n    tNext.y = rd.y < 0. ? (( currentPos.y/newSize - floor(currentPos.y/newSize))  * newSize ) * delta.y \n                        : ( ( ceil(currentPos.y/newSize) - currentPos.y/newSize)  * newSize ) * delta.y;\n    \n    \n    tCurr += min(tNext.x, tNext.y);\n    \n  } \n \n\tfragColor = vec4(col,1.0);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}