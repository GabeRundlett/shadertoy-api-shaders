{
    "Shader": {
        "info": {
            "date": "1572586008",
            "description": "playing with neighbors and differences. This effect looks radically different on 60 HZ monitors, which makes the bump effect do almost nothing, so you can turn it off at the top of main. Thanks Wyatt for introducing me to this world, theres much to explor",
            "flags": 32,
            "hasliked": 0,
            "id": "wscSRl",
            "likes": 9,
            "name": "Hue Pond",
            "published": 3,
            "tags": [
                "2d",
                "color",
                "bump",
                "buffer"
            ],
            "usePreview": 0,
            "username": "Plento",
            "viewed": 440
        },
        "renderpass": [
            {
                "code": "\n// Skip the bump calculations if your on 60 HZ and the bump effect isnt doing much to the picture.\n// For whatever reason it looks much different between my 2 monitors.\n#define bump\n\n\nvec2 R;\n\nvec4 t(vec2 p){\n    return texture(iChannel0, p/R);   \n}\n\nfloat height(vec2 p){\n    return t(p).r;\n}\nvec3 BumpedNormal(vec2 uv, float strength)\n{\n    float h = 0.07;\n    \n    \n    float dx = height(uv) - height(uv + vec2(h, .0));\n    float dy = height(uv) - height(uv + vec2(0., h));\n    \n    return normalize( vec3(0., 0., -1.) + vec3(dx, dy, 0.)*strength);\n    \n}\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    //vec col = t(u);\n    \n    vec2 m = iMouse.xy / iResolution.xy-.5; \n    m.x *= iResolution.x/iResolution.y;\n    \n    vec2 cuv =  vec2(u.xy - 0.5*R.xy)/R.y; \n    \n    #ifdef bump\n    vec3 lp = vec3(0.0, 0.0, -1.0); // light pos\n    vec3 sp = vec3(cuv, 0.0); // surface pos\n    vec3 ro = vec3(0, 0, -1.0); // origin pos\n    vec3 rd = normalize(sp - ro); // origin to screen plane pos\n    vec3 ld = lp - sp;\n    \n    float dist = max(length(ld), 0.001);\n    ld /= dist;\n    \n    vec3 dir = t(u).xyz;\n    dir = sin(dir*1.3);\n    \n    vec3 objCol =dir;\n    \n    vec3 norm = BumpedNormal(u, 2.0);\n    \n    float dif = max(dot(norm, ld), 0.);  \n    float spec = pow(max(dot( reflect(-ld, norm), -rd), 0.), 16.); \n    \n    float falloff = 2.4/(1. + dist*0.15 + dist*dist*2.15);\n    \n    \n    vec3 col = (objCol*(dif + .5) + vec3(0.3, 0.3, 0.7)*spec*1.3)*falloff;\n    \n    #else\n     vec3 dir = t(u).xyz;\n    dir = sin(dir*1.3);\n    \n    vec3 objCol =dir;\n    vec3 col = objCol; \n    #endif\n    \n    \n    \n    f = vec4(col, 0.);\n    \n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "vec2 R;\n\nvec4 t(vec2 p){\n    return texture(iChannel0, p/R);   \n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 m = vec2(iMouse.xy / R) - 0.5;\n    m.x *= R.x / R.y;\n    \n    vec3 dir = t(u).xyz;\n   \n    vec3 up = t(u+vec2(.0, 1.)).xyz;\n    vec3 dwn = t(u+vec2(.0, -1.)).xyz;\n    vec3 lft = t(u+vec2(-1.0, 0.)).xyz;\n    vec3 rgt = t(u+vec2(1.0, 0.)).xyz;\n    \n    vec3 avg = (up + dwn + lft + rgt) / 4.0;\n    \n    vec3 dif = dir - avg;\n    \n    //float d = dot(dif, dir);\n    \n    dir -= avg;\n    \n    dir = normalize(dir);\n   \n    dir.xy *= rot(0.03);\n    \n    float div = 0.0;\n    \n    if(iFrame < 2){\n    \tdir = vec3(hash22(u), hash11(u.x));\n    }\n    \n    \n    \n    dir = clamp(dir, vec3(-1), vec3(1));\n    \n    f = vec4(dir, 0.0);\n    \n}\n\n\n\n\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}