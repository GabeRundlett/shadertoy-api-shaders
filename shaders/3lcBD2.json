{
    "Shader": {
        "info": {
            "date": "1613442932",
            "description": "See [url=https://youtu.be/I8fmkLK1OKg]the tutorial video this is from[/url]",
            "flags": 0,
            "hasliked": 0,
            "id": "3lcBD2",
            "likes": 22,
            "name": "Perfect Pistons Example 2",
            "published": 3,
            "tags": [
                "domainrepetition",
                "pistons"
            ],
            "usePreview": 0,
            "username": "blackle",
            "viewed": 906
        },
        "renderpass": [
            {
                "code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//In this example we extend the \"assume-the-worst\" trick to 2 dimensional domain repetition.\n\nfloat piston(vec2 p, float width, float height) {\n    p.x = abs(p.x) - width;\n    p.y -= height;\n    return length(max(p,0.0)) + min(0.0, max(p.x,p.y));\n}\n\nfloat piston3D(vec3 p, float width, float height) {\n    vec2 p2 = vec2(length(p.xy), p.z);\n    return piston(p2, width, height);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\nfloat scene(vec3 p) {\n    vec2 center = floor(p.xy) + .5;\n    vec2 neighbour = center + edge(p.xy - center);\n    float height = sin(center.y + center.x+iTime)*2.;\n    float width = .3;\n    float me = piston3D(p - vec3(center, 0), width, height)-.03;\n    float next = piston3D(p - vec3(neighbour, 0), width, 2.)-.03;\n    return min(me, next);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-7,0,0);\n    \n    float yrot = .5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot = clamp(1.-4.*mouse.y,-0.,3.14/2.);\n        zrot = 4.*mouse.x;\n    }\n    \n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += 1.;\n\n    vec3 p =init;\n    bool hit = false;\n    for (int i = 0; i < 200 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist*cam;\n        if(distance(p,init)>50.)break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float col = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    col = col*.1 + pow(col, 6.);\n    fragColor = hit ? vec4(col) : vec4(0.03);\n    fragColor = sqrt(fragColor);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}