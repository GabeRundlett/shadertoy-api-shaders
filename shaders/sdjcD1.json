{
    "Shader": {
        "info": {
            "date": "1645894338",
            "description": "hatching",
            "flags": 32,
            "hasliked": 0,
            "id": "sdjcD1",
            "likes": 5,
            "name": " Cross Hatching Exp 1b",
            "published": 3,
            "tags": [
                "3d",
                "shading",
                "stripes",
                "rendering",
                "cross",
                "hatching",
                "style"
            ],
            "usePreview": 0,
            "username": "Yusef28",
            "viewed": 627
        },
        "renderpass": [
            {
                "code": "\nfloat getEdge(vec2 fragCoord, float th)\n{\n\n    vec2 p = fragCoord.xy;\n    \n    vec2 uv = (p.xy) / iResolution.xy;\n    \n   \n\t// simple sobel edge detection\n    float gxr = texture(iChannel0, uv.xy+vec2(th, 0.)).w\n    - texture(iChannel0, uv.xy-vec2(th, 0.)).w;\n    \n    float gyr = texture(iChannel0, uv.xy+vec2(0., th)).w\n    - texture(iChannel0, uv.xy-vec2(0., th)).w;\n    \n\n\t// hack: use g^2 to conceal noise in the video\n    float gr = gxr*gxr + gyr*gyr;\n\n    float g = pow(gr,9.99);\n    return clamp(g*1.,0.,1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.);\n   \n    //col = col1;\n    col = clamp(texture(iChannel0,uv).rgb,0.,1.);\n   // col = vec3(t);\n    col = mix(col, vec3(0.8,0.6,0.1)*1.,vec3(getEdge(fragCoord,0.0025)));\n    col = mix(col, vec3(0.0,0.3,0.8)*1.,vec3(getEdge(fragCoord, 0.0009)));\n    \n   //col = s40;\n   // col *= clamp(texture(iChannel1,uv*2.).rgb,0.,1.).x*1.2;\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 25.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.5); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig*1.2,1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define TEXTURE_STEP 1./6.\n#define EPS 0.001\n#define FAR 40.\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,-c);\n}\nfloat roundedBox(vec3 sp, vec3 dim, float r){\n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) \n    + length(max(sp, 0.0)) - r;    \n\n\n}\nfloat map(vec3 pos){\n    float d = 1000.;\n    vec3 flpos = floor((pos)/6.);\n    float rf = hash13(flpos);\n    pos = mod(pos,6.)-3.;\n    \n    if(hash13(flpos+100.)<0.5){\n    d = min(d, length(pos)-2.3+rf*0.4);}\n    else{\n    \n    d = min(d, roundedBox(pos, vec3(.5), 1.+rf*0.7));\n    }\n    //pos.xy *= rot(iTime);\n    //d = min(d, roundedBox(pos, vec3(1.), 0.1));\n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float d,t=0.;\n    for(float i = 0.; i < 96.; i++){\n        d = map(ro + rd*t);\n        \n        if(abs(d) < EPS || t > FAR){\n            break;\n        }\n        \n        t += d*0.95;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(EPS, 0.);\n    float dx = map(p - e.xyy) - map(p + e.xyy);\n    float dy = map(p - e.yxy) - map(p + e.yxy);\n    float dz = map(p - e.yyx) - map(p + e.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 getCameraDirection(vec2 uv, vec3 ro, vec3 ta){\n\n    vec3 fwd = normalize(ta-ro);\n    vec3 uu = vec3(0.,1.,0.);\n    vec3 ri = cross(uu,fwd);\n    vec3 up = cross(fwd,ri);\n    return normalize(uv.x*ri + uv.y*up + fwd*1.);\n}\n\nvec2 render(vec2 fragCoord, inout vec3 lightColor)\n{\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec3 col =vec3(0.);\n    vec3 ta = vec3(0.,0.,iTime*0.5);\n    vec3 ro = ta +  vec3(0.,0.,-2.);\n    if(iMouse.z > 0.5){\n        float rotScale = 4.;\n        ro.xz *= rot(8.*(iMouse.x/iResolution.x)-rotScale/2.);\n       // ro.yz *= rot(4.*(iMouse.y/iResolution.y)-rotScale/2.);\n    }\n    else{\n         //ro.xz *= rot(iTime*0.15);\n    }\n    vec3 lp1 = ro + vec3(50.,10.,1.);\n    vec3 lp2 = ro +  vec3(-50.,7.,2.);\n    \n    vec3 rd = getCameraDirection(uv,ro,ta);\n    float cs = cos(iTime*0.25);\n    float si = sin(iTime*0.25); \n    rd.xy*= mat2(cs, si, -si, cs);\n    rd.xz*= mat2(cs, si, -si, cs);\n    float t = trace(ro, rd);\n    float diff1 = 0., diff2 = 0., totalLight;\n    if(t < FAR){\n        vec3 pos = ro + rd*t;\n        vec3 flpos = floor((pos)/6.);\n        vec3 cc = hash33(flpos);\n        vec3 n = getNormal(pos);\n        diff1 = max(0.,dot(n,normalize(lp1-pos)));\n        lightColor = diff1*vec3(0.7,0.3,0.1)*2.;\n        diff2 =  max(0.,dot(n,normalize(lp2-pos)));\n        lightColor = mix(lightColor, vec3(0.2,0.8,0.8), diff2)*2.;\n        lightColor = lightColor*0.8 + 0.2*(hash13(flpos+8410.) < 0.5 ? \n                                       vec3(0.7,0.3,0.1) : \n                                       vec3(0.2,0.8,0.8));\n        lightColor += cc*0.25;\n        totalLight = diff1+diff2;\n        float stripe_Payments = smoothstep(0.23,0.25,abs(fract(pos.y/2./hash13(flpos))-0.5));\n        lightColor -= stripe_Payments*0.125;\n    }\n    else{\n        t = FAR;\n    }\n    \n\n    \n    return vec2(totalLight*0.5,t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(.9);\n    //uv/=3.;\n    \n    vec2 pointInTex1 = uv;\n    vec2 pointInTex2 = uv;\n    vec2 pointInTex3 = uv;\n    \n    //vec3 col1 = texture(iChannel0,pointInTex1).rgb;\n    //vec3 col2 = texture(iChannel0,pointInTex2).rgb;\n    //vec3 col3 = texture(iChannel0,pointInTex3).rgb;\n    //uv.y += iTime*0.01;\n    \n    \n   vec3 s20 = vec3(1.,0.,0.);//singleLines(uv,col,vec2(0.4,0.9),0.43);\n    vec3 s30 = vec3(1.,1.,0.);//singleLines(uv,col,vec2(0.3,1.4),0.36);\n    vec3 s40 = vec3(1.,0.,1.);//singleLines(uv,col,vec2(0.8,1.4),0.1);\n    s20 = singleLines(uv,col,vec2(0.4,0.9),0.43, 1.);\n    s30 = singleLines(uv,col,vec2(0.3,1.4),0.36, 2.);\n    s40 = singleLines(uv,col,vec2(0.8,1.4),0.28, 3.);\n    \n    vec3 d20 = vec3(0.,1.,0.);//singleLines(uv,col,vec2(0.4,0.9),0.43);\n    vec3 d30 = vec3(0.,1.,1.);//singleLines(uv,col,vec2(0.3,1.4),0.36);\n    vec3 d40 = vec3(0.,1.,0.);\n    d20 = doubleLines(uv,col,vec2(4.),0.3, 1.);\n    d30 = doubleLines(uv,col,vec2(4.),0.23, 2.);\n    d40 = doubleLines(uv,col,vec2(4.),0.11, 3.);\n    \n    \n   // vec3 mixCol1 = mix(col1,col2,clamp(uv.x,0.,0.6)/0.6);\n    //vec3 mixCol2 = mix(col2,col3,clamp(uv.x-TEXTURE_STEP,0.,1.)/0.6);\n   // col = mix(mixCol1,mixCol2,uv.x);\n    //mixCol1 = mix(col1,col2,clamp(uv.x,0.,0.6)/0.6);\n    //mixCol2 = mix(mixCol1,col3,clamp(uv.x-TEXTURE_STEP,0.,.6)/0.6);\n    ///col = mix(mixCol1,mixCol2,uv.x);\n    vec3 lightCol;\n    vec2 res = render(fragCoord, lightCol);\n    float d = (1.-clamp(res.x,0.,1.));\n    d = pow(d,1./1.5);\n    float t = res.y;\n    \n    vec3 tmp = mix(s20,s30,pow(clamp(d,0.,0.333)/0.333,1.));\n    \n    tmp = mix(tmp,s40,pow(clamp(d-TEXTURE_STEP*1.,0.,0.333)/0.333,1.));\n    tmp = mix(tmp,d20,clamp(d-TEXTURE_STEP*2.,0.,0.3333)/0.333);\n    tmp = mix(tmp,d30,clamp(d-TEXTURE_STEP*3.,0.,0.333)/0.333);\n    col = mix(tmp,d40,clamp(d-TEXTURE_STEP*4.,0.,.333)/0.33);\n    col = mix(col,s40*1.,float(t>= FAR));\n   /* d = 1.-d;\n    if(d > 0.9 )col = s20;\n    else if(d > 0.5)col = s30;\n    else col = s40;\n    col = tmp;*/\n    //;//col = singles40;//mix(col1,col2,t);\n    //col = col1;\n    //col = texture(iChannel0,uv).rgb;\n   // col = vec3(t);\n    //col = s40;\n    col = mix(col, lightCol, d*0.9);\n    col -= s40*0.05;\n    fragColor = vec4(col,t);\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "\nfloat rnd(float a){\n    return fract(sin(a*8194.561)*45279.194);\n}\n\n//from Dave_Hoskins\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nfloat noise1d(float x){\n    float xl = floor(x);\n    float xr = fract(x);\n    return mix(rnd(xl),rnd(xl+1.),xr);\n}\n\nfloat randPath(vec2 uvFloor, float fr){\n    float xFloor = uvFloor.x;\n    float yFloor = uvFloor.y;\n    float path = mix(rnd(yFloor*593.+xFloor),\n                     rnd(yFloor*593.+xFloor + 1.), \n                     fr);\n    return smoothstep(0.,1.,path);\n}\n\n#define shadowCol1 vec3(0.2,0.3,0.4)*2.\n#define shadowCol2 vec3(0.3,0.2,0.1)*2.\n\nvec3 singleLines(vec2 uv, vec3 col, vec2 scale, float theStep, float shade){\n   \n   // vec2 scale = vec2((2.+floor(uv*3.))*20.);\n    vec2 flUV = floor(uv*scale*80.);\n    vec2 frUV = fract(uv*scale*80.);\n    //col -= flUV.y/12.;\n    shade = shade/4.;\n    float lineNoise = noise1d(uv.x*80.+flUV.y*80.);\n    float line = smoothstep(theStep,\n                            theStep+0.1,\n                            0.5-abs(frUV.y-0.5-randPath(flUV,frUV.x)*0.43)\n                            );\n    col = mix(col,vec3(0.1),max(0.,line-lineNoise*0.64));\n    \n   /* line = smoothstep(0.4,\n                      0.5,\n                      0.5-abs(frUV.x-0.5-randPath(flUV.yx,frUV.y)*0.3)\n                      );*/\n    //col += line;\n    return col+shade;\n}\n\nvec3 doubleLines(vec2 uv, vec3 col, vec2 scale, float theStep, float shade){\n\n    //vec2 scale = vec2((2.+floor(uv*3.))*20.);\n    \n    vec2 flUV = floor(uv*scale*60.);\n    vec2 frUV = fract(uv*scale*60.);\n    //col -= flUV.y/12.;\n    float lineNoise = noise1d(uv.x*80.+flUV.y*80.);\n    \n    float line = smoothstep(theStep,\n                            theStep+0.1,\n                            0.5-abs(frUV.y-0.5-randPath(flUV,frUV.x)*0.3)\n                            );\n    col = mix(col,shadowCol1,max(0.,line-lineNoise*0.65));\n    \n    line = smoothstep(theStep,\n                      theStep+0.1,\n                      0.5-abs(frUV.x-0.5-randPath(flUV.yx,frUV.y)*0.3)\n                      );\n    col = mix(col,shadowCol2,max(0.,line-lineNoise*0.65));\n    shade = shade/5.;\n    return col-shade;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}