{
    "Shader": {
        "info": {
            "date": "1533286270",
            "description": "iMouse.y modifies the hashes (based on mod(a,17*17)/7 ring)\niMouse.x sets jitter (how close to the border of a cell a point is allowed to be)\ncode looks like simplex noise by ashima (with permute() and min max sorting) but the result looks like voronoi.",
            "flags": 0,
            "hasliked": 0,
            "id": "lltyzj",
            "likes": 3,
            "name": "ashima cellular worley L1 L2 ",
            "published": 3,
            "tags": [
                "voronoi",
                "noise",
                "worley",
                "simplex",
                "ashima",
                "gems",
                "gustavson"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 783
        },
        "renderpass": [
            {
                "code": "//code looks like simplex-noise by ashima (with permute() and min+max sorting) \n//but but the result looks like 3d cellular vorley noise on a cube-lattice\n//because it is 2d+3d-cellular-vorley (cubic, not simplex) by ashima.\n//from https://github.com/ashima/webgl-noise/tree/master/src\n//in matrix-form for smaller code (likely also parses and runs faster?)\n//with more jitter-parameters.\n\n//lower left is 2d voronoi-noise,all others are 3d voronoi-noise\n//ashima seems to LOVE permute() , and permuted-congurntial-generators \n//, that extend LCGs by permuting multiple of them\n//,seem to agree that permute() efficiently makes much better hashes->noises from cheapest LCGs.\n//https://en.wikipedia.org/wiki/Permuted_congruential_generator\n\n//fast 3d cellular vorley noise, ashima-noice, (likely) optimized and extended by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares, 1 is maximum jitter.  (known bug, iMouse.x-scaling for lower left quadrant is a bit bad here)\n//iMouse.x sets jitter (how close to the border of a cell a point is allowed to be)\n//iMouse.y modifies the hashes (base is mod(a,17*17)/7 rings)\n//imouse.z sets hash dividend, is ideally 1/7, but others can be fine too. use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime. \n// the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1, .y is L2 according to [worley noise]\n//this uses a lot of mat2, or the v33 struct, and permute() functions similar to ahsima-simplex noise, defers the sorting, for performance.\n\n\n//other quadrants are 3d noise (2d hyperslices, 3rd domain is time, orthogonal to view)\n\n\n\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n//the hyperplanes are aligned to the lattice, and because of that alignment the animation does not look too \"random\"\n//is addressed below, but complicated\n\n\n//open challenge:\n//there exist ways to do a 2pass of 2 voronoi, first pass is 3x3 square lattice 9tap, with 3 buffered values.\n//, second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here, with a planar distance and/or a 3d distance to a cell border\n\n//i messed up the zoom within the frame, not sure how. its a bit hyperplanar\n//2d zoom\n#define ViewZoom 8.\n\n\n\n//divide by /aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n//usually first function of mainImage(), not typecast.\n\n\n#define pi acos(-1.)\n//trig definition for 3.14... can be better for smarter compilers.\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define ab012(a,b) (a+b*vec3(0,1,2))//desaturation.rgb kernel; b scales offset\n//rainbow*() ro from purple to purple for range[0..1], this makes ab012() desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets, desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets, desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n\n\n\n#define mous (iResolution.xyxy-iMouse.xyzw)\n//flip mouse everywhere, for shadertoy fun\n\nmat3 fr(mat3 a){return mat3(fract(a[0]),fract(a[1]),fract(a[2]));}\nmat3 fl(mat3 a){return mat3(floor(a[0]),floor(a[1]),floor(a[2]));}\nmat3 add(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n\n//th7 is for the 2d noise, should be (iResolution.y/7.) , BUT i managed to make other values look fine, too\n#define th7 (mous.y/iResolution.y)\n//usually ==1./7., because mod(a,7) is famous for old LCGs.\n//th8 is for the 3d noise, should be (iResolution.y/7.) , other values may work, but they tend to barely work at all, try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))\n//seems to be fine bounds, not too sure.\nvec3 mod2893d(vec3 x){return x-floor(x*(1./289.))*289.;}// Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}// Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}// Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n\n// Permutation polynomial: (34x^2+x) mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n\n\n#define K 1./th8 \n// 1/7\n#define K2 1./th8/th8 \n// 1/(7*7)\n#define Ko (1.-K)*.5 \n// 1/2-K/2\n#define Kz 1./(th8-1.) \n// 1/6\n#define Kzo .5-2./(th8-1.)//0.416666666667 \n// 1/2-1/6*2\n#define jitter mous.x/iResolution.x \n// smaller jitter gives more regular pattern\n\nmat3 perm3(vec3 p){\n ;vec3 p1=permute3d(p-1.) \n ;vec3 p2=permute3d(p)\n ;vec3 p3=permute3d(p+1.)\n ;return mat3(p1,p2,p3);}\n \nmat3 perm3(vec3 p,vec3 b){\n ;vec3 p1=permute3d(p+b.x-1.) \n ;vec3 p2=permute3d(p+b.y)\n ;vec3 p3=permute3d(p+b.z+1.)\n ;return mat3(p1,p2,p3);}\n\n#define maa(a,b,c)  ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a) a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c) mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\n\n//ollj optimized these by putting vec3 and vec4 into higher doimain structs (like matrices)\n//todo, make it traversable by getting distance2Border.\nvec2 cellular(vec3 P,float m\n//code looks a lot like simplex3d moise (by ashima, with permute()\n//but is 3d voronoi/vorley with L1 and L2.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=add(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perm3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perm3(pp[0]+p.z)\n ;mat3 p2=perm3(pp[1]+p.z)\n ;mat3 p3=perm3(pp[2]+p.z)\n ;mat3 ox=fr(p1*K)-Ko\n ;mat3 ox2=fr(p2*K)-Ko\n ;mat3 ox3=fr(p3*K)-Ko \n ;mat3 oz=fl(p1*K2)*Kz-Kzo\n ;mat3 oz2=fl(p2*K2)*Kz-Kzo\n ;mat3 oz3=fl(p3*K2)*Kz-Kzo \n ;mat3 oy=mod73d(fl(p1*K))*K-Ko\n ;mat3 oyy=mod73d(fl(p2*K))*K-Ko\n ;mat3 oy3=mod73d(fl(p3*K))*K-Ko\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=add(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=add(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n \n ;mat3 a\n \n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared == is dot(r,r)\n\n\n // Sort out the two smallest distances (F1, F2)\n#if 0\n // Cheat and sort out only F1 //shortcut if you do not need L2\n ;vec3 d1=min(min(d11,d12), d13);\n vec3 d2=min(min(d21,d22), d23);\n vec3 d3=min(min(d31,d32), d33);\n vec3 d=min(min(d1,d2), d3);//shortest of 9 distances, except its 9*vec3()\n d.x=min(min(d.x,d.y),d.z);\n return vec2(sqrt(d.x)) ;} // F1 F1\n#else\n // Do it right and sort out both F1 and F2\n ;vec3 d1a=min(d11, d12);\n d12=max(d11, d12);\n d11=min(d1a, d13); // Smallest now not in d12 or d13\n d13=max(d1a, d13);\n d12=min(d12, d13); // 2nd smallest now not in d13\n vec3 d2a=min(d21, d22);\n d22=max(d21, d22);\n d21=min(d2a, d23); // Smallest now not in d22 or d23\n d23=max(d2a, d23);\n d22=min(d22, d23); // 2nd smallest now not in d23\n vec3 d3a=min(d31, d32);\n d32=max(d31, d32);\n d31=min(d3a, d33); // Smallest now not in d32 or d33\n d33=max(d3a, d33);\n d32=min(d32, d33); // 2nd smallest now not in d33\n vec3 da=min(d11, d21);\n d21=max(d11, d21);\n d11=min(da, d31); // Smallest now in d11\n d31=max(da, d31); // 2nd smallest now not in d31\n d11.xy=(d11.x < d11.y) ? d11.xy : d11.yx;\n d11.xz=(d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy) // nor in d12.yz\n ;d11.y=min(d11.y,d12.z) // Only two more to go\n ;d11.y=min(d11.y,d11.z) // Done! (Phew!)\n ;return sqrt(d11.xy);} // F1, F2\n//ollj multiple times vectorized/matrixed this, and then had trouble debugging it, too sleepy, so i let it as is.\n//3d cells are tricky to debug is all\n#endif\n\n\n//above is 3d , below is 2d\n//above is 3d , below is 2d\n//above is 3d , below is 2d\n\n\n//crunched by ollj\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license of: // https://github.com/stegu/webgl-noise\n\nstruct v33{vec3 a;vec3 b;};//mat3 is likely faster\nstruct v22{vec2 a;vec2 b;};//mat2 i likely faster\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 sub(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\nv33 mul(float a,v33 b){return v33(a*b.a,a*b.b);}\n\n//float miv(vec2 a){return min(a.x,a.y);}\n//float miv(vec3 a){return min(miv(a.xy),a.z);}\n\n\n//mod(a,289.) without a division (only multiplications), because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}// Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}// Permutation polynomial: (34x^2+x) mod 289\n\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n\n#define tt3(p,f,j,m,a) square(sub(j,sub(v33(vec3(a),f),mul(m,mul(m,modth7(ff(p*th7)))))))\n//vec3 tt3(vec3 p,vec3 f,vec2 j,float m,float a){return square(sub(j,sub(v33(vec3(a),f),mul(m,mul(m,modth7(ff(p*th7)))))));}\n //;v33 g=modth7(ff(p*th7))g=mul(m,g);v33 t=v33(vec3(a),f);t=sub(t,g);t=sub(j,t);return t.a*t.a+t.b*t.b;}//operand-separated\n\n//the [-Ko] results in offsetting the whole thing, within a raster, which is pretty useless, and therefore removed.\n#define permi(c) p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c) r[d]=tt3(p,f,k.a,m,e);permi(c)\n\n//2d Cellular noise,returning F1 and F2 in a vec2 //3x3 search window reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity) m=1./7., by sqiveling this parameter, you get +0.7 domain very cheaply\n//as in by making m a 3rd parameter, you ALMMOST get cheap cellular3d noise, BUT it is likely a bit flawed, more repetitive, shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop. the permute() function marks +1 iteration/tap //is 4tap voronoi in O(3)\n){mat3 r;\n ;v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1)\n ;vec3 f=o+.5\n ;vec3 px=permute(o+k.b.x)\n ;vec3 permi(x)\n ;ppm(0,-.5,y)\n ;ppm(1,+.5,z)\n //it seems that the loop got unrolles and al lits min() fucntions fold into the below\n //which is quite a lot of symmetry folding, surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line , because r[0].y is a return value. \n ;r[0].y=min(miv(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n\n\nmat2 rot(float a){float s=sin(a);float c=cos(a);return mat2(c,-s,s,c);}\n\n\n//above is subroutines\n//above is subroutines\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec2 u=fra(U)\n ;vec2 m=fra(mous.xy)\n //;vec2 n=fra2(mous.zw)/iResolution\n //;float p=(length(m.xy-u)*5.)\n //;float q=(length(n.xy-u)*7.)\n //;m=1.-m //flip m for shadertoy preview\n // ;vec2 d=cellular(u,m.x/ViewZoom)\n ;m.x/=ViewZoom\n ;vec2 d=vec2(0)\n ;if(U.x<iResolution.x*.5\n ){\n  if(U.y<iResolution.y*.5){\n   ;m.x=clamp(m.x*iResolution.y/iResolution.x*.5+.5,0.,.78)\n   //;m.x=max(-ViewZoom*.5,m.x)\n   //;m.x*=iResolution.y/iResolution.x\n   ;d=cellular(u,m.x)\n  ;}else{   \n   ;m.x/=iResolution.x/mous.x\n   ;d=cellular(vec3(u,iTime),m.x)\n   ;}\n  ;\n ;}else{\n  ;if(U.y<iResolution.y*.5){\n   ;d=cellular(vec3(iTime,u),m.x)//3d noise u.xy\n   ;}else{\n   ;vec3 a=vec3(u,iTime);\n   //the hyperplanes are aligned to the lattice, and because of that alignment the animation does not look too \"random\"\n   //the plane should be rotated by pi*(sqrt(5.)*5.+.5) t avoid repetition any synchronization.\n   //a=vec3(u,0);a.zx*=rot(iTime*.2) ;a.zx*=rot(iTime*.61*.1)//yes you can easily see 3d rotation of a simplex4d in its 2d slice.\n   ;d=cellular(a.xzy,m.x)\n ;}}\n //;d.x=d.y//only L2\n //;d.y=d.x//only L2 \n //;d=1.-d\n ;O=vec4(d,0,1)//3d noise u.xy\n ;}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}