{
    "Shader": {
        "info": {
            "date": "1666705824",
            "description": "Using elongated hexagons as a base to radially tile a plane and produce a Truchet pattern.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlcBRs",
            "likes": 84,
            "name": "Radial Tiling Truchet",
            "published": 3,
            "tags": [
                "2d",
                "spiral",
                "radial",
                "truchet",
                "pattern",
                "polar",
                "polygon",
                "tile"
            ],
            "usePreview": 0,
            "username": "Shane",
            "viewed": 719
        },
        "renderpass": [
            {
                "code": "/*\n\n    Radial Tiling Truchet\n    ---------------------\n    \n    Using an elongated hexagon base pattern to radially tile a plane and\n    produce a Truchet pattern. The other day, Fabrice Neyret reproduced a \n    really cool spiral Truchet pattern that he'd come across on Twitter -- \n    I've provided the link to his version and the original below. Like many\n    of his examples, it involved subject matter that wasn't widely known and \n    visually interesting enough to investigate further.\n    \n    Like everyone else, I've seen spriral patterns that consist of single \n    polygons, or simple mixes of regular polygons, etc, but have never really \n    looked into how they are created. Given the lack of content on the web, \n    it doesn't appear that many other people know much about the process \n    either. \n    \n    As usual, the solution wasn't difficult, but it took a while to figure \n    out. As it turns out, the trick is to use elongated hexagons grouped\n    together in wedged sections that neatly stitch together in a radial\n    fashion. For a simple visual, go to the defines below and set POLYGON\n    to \"0\", TRUCHET to \"0\" then uncomment the CONSTRUCTION_WEDGES define.\n    Alternatively, have a look at some of the imagery in the links below.\n    \n    Fron a code perspective, this, and patterns like it, consist of nothing \n    more than seperate hexagon grids placed together in a radial fashion using \n    polar coordinates. Things that you may not be used to is putting together \n    a grid full of elongated hexagons, but that just involves adding a few \n    things to the regular hexagon grid code. After that, you have to restrict \n    the pattern to a fan shape, but that is literally two extra lines. Once \n    you have access to the local elongated hexagon coordinates and central ID, \n    you can do whatever you want.\n     \n    Since this is a simple demonstration, I've chosen the most basic radial\n    elongated hexagon pattern arrangement, but there are a heap of others,\n    and you can look at some of them in the links provided below. I've \n    found that a lot of the other common polygon patterns (quads, pentagons, \n    etc) can be created via the base hexagon pattern.\n    \n    This was thrown together quickly as more of a visual guide than anything \n    else. I wanted to show how different arrangements are related, which \n    required a heap of spaghetti logic, so the code isn't fantastic. However, \n    it works fine, and the base code is much more streamlined, so hopefully, \n    it will give anyone who wishes to make radial or spriral polygon patterns, \n    spiral Truchet patterns, etc, a start -- There's a few defines that \n    should help. I intend to do something more interesting with this at a \n    later date.\n \n \n    \n    References:\n    \n    // I love examples like this. I didn't bother looking at the code, \n    // but the visual itself was enough to give me a start.\n    Damasdi tiling - FabriceNeyret2\n    https://www.shadertoy.com/view/stcBRj\n    //\n    // Based on the following:\n    Symmetry - Math and art by Gábor Damásdi\n    https://szimmetria-airtemmizs.tumblr.com/post/144161547163/\n    an-other-pattern-that-uses-only-a-single\n    \n    Elongated triangular tiling - Wikipedia\n    https://en.wikipedia.org/wiki/Elongated_triangular_tiling\n    \n    Order-Six Radial Tessellations of the Plane, Using Elongated and \n    Equilateral Hexagons, Rendered with Twelve Different Coloring-Schemes\n    https://RobertLovesPi.net    \n    \n    \n*/\n\n// Polygon type - Hexagon base: 0, Quadrilateral: 1, Triangle-Square:2.\n#define POLYGON 1\n\n// Truchet type: No Truchet: 0, White Truchet: 1, Black: 2\n#define TRUCHET 2\n\n// Display the multiple tile wedges that radially tile the plane.\n//#define CONSTRUCTION_WEDGES\n\n// Dual pattern -- This is the dual to the regular triangle and square\n// pattern (POLYGON 2). With the exception of the center, it's mostly\n// pentagons. Best viewed without the Truchet pattern.\n//#define DUAL\n\n// Polygon vertices.\n//#define VERTICES\n\n// Polygon edge midpoints.\n//#define MIDPOINTS\n\n// Displaying the hexagon base pattern overlay. It's redundant when using the\n// base hexagon, but can be helpful in visualizing how the quadrilateral or \n// triangle-square pattern is constructed. Best viewed without the Truchet\n// pattern or dual overlay.\n//#define BASE_OVERLAY\n\n// Bump map highlights.\n//#define BUMP\n\n\n// Flat top hexagon scaling.\nconst vec2 s = vec2(2. + 1.7320508, 1); // Normal hexagon plus square.\n \n// Hexagonal bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat getHex(vec2 p){\n \n    // Generalized elongated hexagon function, based on the \n    // partitioning rectangle above.\n    //\n    // I did this in a hurry. There'd be better ways to go \n    // about it, but it'll do for now.\n    float x = (s.x - s.y)/2.;//(1. + 1.7320508)/2.;\n    float ln;\n    p = abs(p);\n    ln =  distLineS(p, vec2(-.5, .5), vec2(.5, .5));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln, distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    return ln;\n    \n    /*    \n    float x = (1. + 1.7320508)/2.;\n    float ln =  distLineS(p, vec2(-.5, -.5), vec2(-x, 0));\n    ln =  max(ln, distLineS(p, vec2(-x, 0), vec2(-.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(-.5, .5), vec2(.5, .5)));\n    ln =  max(ln, distLineS(p, vec2(.5, .5), vec2(x, 0)));\n    ln =  max(ln,distLineS(p, vec2(x, 0), vec2(.5, -.5)));\n    ln =  max(ln, distLineS(p, vec2(.5, -.5), vec2(-.5, -.5)));\n    return ln;\n*/\n}\n\n// Hexagonal grid coordinates. This returns the local coordinates and the cell's center.\n// The process is explained in more detail here:\n//\n// Minimal Hexagon Grid - Shane\n// https://www.shadertoy.com/view/Xljczw\n//\nvec4 getGrid(vec2 p){\n  \n    \n    vec4 ip = floor(vec4(p/s, p/s - .5)) + .5;\n    vec4 q = p.xyxy - vec4(ip.xy, ip.zw + .5)*s.xyxy;\n    //return dot(q.xy, q.xy)<dot(q.zw, q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + offs);\n    return getHex(q.xy)<getHex(q.zw)? vec4(q.xy, ip.xy) : vec4(q.zw, ip.zw + .5);\n   \n} \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 10.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;\n    \n    // Scene field calculations.\n\n    vec2 op = p; // Global position copy.\n    \n    // Light for each block.\n    vec2 ld = normalize(vec2(-2, 1));\n    vec2 ld2 = ld;\n    \n    // Number of partitions for each block.\n    const float aN = 6.;\n    \n    // Creating three blocks of hexagon wedges.\n    p *= rot2(-iTime/12.);\n     \n    \n    float a = atan(p.y, p.x);\n    float na = floor(a/6.2831853*aN);\n    float ia = (na + .5)/aN;\n    //\n    p *= rot2(-ia*6.2831853);\n    ld *= rot2(-ia*6.2831853);\n    p.x -= (s.x - s.y)/2.; // Half hexagon width.\n     // Hexagonal grid coordinates.\n    vec4 p4A = getGrid(p);\n    \n    // Creating the other three blocks of hexagon wedges. These are \n    // pushed out from the center a little further.\n    p = rot2(3.14159/aN)*op;\n    ld2 = rot2(3.14159/aN)*ld2;\n    p *= rot2(-iTime/12.);\n    float a2 = atan(p.y, p.x);\n    float na2 = floor(a2/6.2831853*aN);\n    float ia2 = (na2 + .5)/aN;\n    //\n    p *= rot2(-ia2*6.2831853);\n    ld2 *= rot2(-ia2*6.2831853);\n    p.x -= (s.x - s.y)/2. + 1.; // Half hexagon width plus 1.\n     // Hexagonal grid coordinates.\n    vec4 p4B = getGrid(p);\n    \n    // Closest hexagon in each block and its offset block.\n    float dA = getHex(p4A.xy);\n    float dB = getHex(p4B.xy);\n    // Position based IDs.\n    vec2 idA = floor(p4A.zw*2.);\n    vec2 idB = floor(p4B.zw*2.);\n    // Eradicating all hexagons that fall outside each block.\n    if(abs(idA.y)>idA.x){ dA = 1e5; }\n    if(abs(idB.y)>idB.x){ dB = 1e5; }\n    \n    \n    // Obtaining the closest hexagon distance, its local coordinates,\n    // the block number, and ID.\n    float d = min(dA, dB);\n    vec4 p4 = dA<dB? p4A : p4B;\n    float n = dA<dB? na : na2 + 1.;\n    vec2 id = floor(p4.zw*2.);\n    \n    // Nearby sample for highlighting.\n    ld = dA<dB? ld : ld2;\n    float dHi = getHex(p4.xy - ld*.001);\n\n    vec4 svp4 = p4; // Local hexagon coordinate copy.\n   \n    // Using the block number and radial postion to calculate a unique\n    // position based ID for this particular hexagon.\n    float ip = (p4.z*2.) + n;\n\n    // Copy of the original local coordinate.\n    vec4 oP4 = p4;\n     \n   \n    \n    vec2 ctr = vec2(0); // Hexagon center.\n    \n    float x = (s.x - s.y)/2.; // Distance to triangle center.\n     \n    float lnL = (distLineS(p4.xy, vec2(-.5, .5), vec2(-.5, -.5))); // Left partition line.\n    float lnR = (distLineS(p4.xy, vec2(.5, .5), vec2(.5, -.5))); // Right partition line.\n    float ln = min(abs(lnL), abs(lnR));\n    \n    mat4x2 v; // Container for holding the square or triangle vertices.\n \n    int vNum = 3;\n     \n    // In the left triangle or the right triangle, adjust the midpoint.\n    // Otherwise, we're in the central square, so do nothing.\n    if(lnL<0.){\n    \n        // Left triangle.\n        ip -= .25;\n        p4.z -= .25;\n        //p4.x -= -(.5 + x/2.);\n        ctr = vec2(-(x + 1.)/3., 0); // Average of the vertices below.\n        \n        // There's a dummy variable on the end.\n        v = mat4x2(vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(1e5));\n    }\n    else if(lnR>0.){\n    \n        // Right triangle.\n        ip += .25;\n        p4.z += .25;\n        ctr = vec2((x + 1.)/3., 0); // Average of the vertices below.\n        \n        // There's a dummy variable on the end.\n        v = mat4x2(vec2(.5, -.5), vec2(.5, .5), vec2(x, 0), vec2(1e5));\n    }\n    else {\n    \n         vNum = 4; // Using all 4 vertices for the square.\n         // Square.\n         v = mat4x2(vec2(-.5, -.5), vec2(-.5, .5), vec2(.5, .5), vec2(.5, -.5));\n    }    \n \n    \n    // Calculating the vertex distance field, midpoint distance field, dual\n    // lines, etc, for the squares and triangles.\n    float dualLn = 1e5;\n    float vert = 1e5, mid = 1e5;\n    mat4x2 midV;\n    //mat4x2 tMidV;\n    \n    float poly = -1e5, polyHi = -1e5;\n    for(int i = 0; i<vNum; i++){\n    \n        vert = min(vert, length(p4.xy - v[i]));\n\n        vec2 vMid = mix(v[i], v[(i + 1)%vNum], .5);\n\n        midV[i] = vMid;\n        //tMidV[i] = normalize((v[i] - v[(i + 1)%vNum]).yx*vec2(-1, 1));\n\n        mid = min(mid, length(p4.xy - vMid));\n        dualLn = min(dualLn, distLine(p4.xy, ctr, vMid));\n\n        poly = max(poly, distLineS(p4.xy, v[i], v[(i + 1)%vNum]));\n        polyHi = max(polyHi, distLineS(p4.xy - ld*.001, v[i], v[(i + 1)%vNum]));\n \n    }\n\n    \n    // Quickly coding in a Truchet pattern.\n    float rnd1 = hash21(p4.zw + .101 + n);\n    float rnd2 = hash21(p4.zw + .102 + n);\n    float rnd3 = hash21(p4.zw + .103 + n);\n    float rnd4 = hash21(p4.zw + .104 + n);\n\n    float sL = 1.;\n    float th = .015*sc;\n    vec3 tr = vec3(1e5);\n\n\n    if(vNum==3){ \n\n        // Triangle Truchet pattern.\n\n        int rndI = int(floor(rnd4*3.))%3;\n        float v0 = length(p4.xy - v[rndI]);\n\n        tr.x = mid - th;\n        if(rnd1<.5) tr.x = min(tr.x, abs(v0 - .5) - th);\n        else if(rnd1<1.8) tr.x = -(vert - (sL/2. - th));\n\n        /* \n        tr.x = abs(length(p4.xy - v[0]) - .5) - th;\n        tr.y = abs(length(p4.xy - v[1]) - .5) - th;\n        tr.z = abs(length(p4.xy - v[2]) - .5) - th;\n        */ \n    }\n    else { \n\n        // Square Truchet pattern.\n\n        //if(rnd3<.5) p4.xy = p4.yx*vec2(1, -1);\n        p4.xy *= rot2(floor(rnd3*32.)*3.14159/2.);\n\n\n        float v0 = length(p4.xy - v[0]);\n\n        // All dots.\n        tr.x = mid - th;\n\n        if(rnd2<.333){\n            // Dots and one arc.\n            tr.x = min(tr.x, abs(v0 - .5) - th);\n        }\n        else if(rnd2<.5){  \n            // Two arcs.\n            v0 = min(v0, length(p4.xy - v[2]));\n            tr.x = min(tr.x, abs(v0 - .5) - th);\n        }\n        else if(rnd2<1.1){  \n            // Two lines.\n            tr.x = abs(p4.x) - th;\n            tr.y = abs(p4.y) - th;\n        }\n\n    }\n     \n     \n    #if POLYGON == 1\n\n    p4 = oP4;\n    ip = (p4.z*2.) + n;\n    lnL = (distLineS(p4.xy, vec2(.5, .5),vec2(-.5, -.5))); // Partition line.\n    ln = abs(lnL);\n    \n    vNum = 4;  \n    if(lnL<0.){\n        // Left quadrilateral.\n        ip -= .25;\n        p4.z -= .25;\n        // Center.\n        ctr = vec2(-(x + 1.)/3., 0); // Average of the vertices below.\n        // Vertices for this quad.\n        v = mat4x2(vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(.5,.5));\n       \n    }\n    else {\n        // Right quadrilateral.\n        ip += .25;\n        p4.z += .25;\n        // Center.\n        ctr = vec2((x + 1.)/3., 0); // Average of the vertices below.\n        // Vertices for this quad.\n        v = mat4x2(vec2(-.5, -.5), vec2(.5, .5), vec2(x, 0), vec2(.5, -.5));\n    }\n\n    poly = -1e5, polyHi = -1e5;\n    vert = 1e5, mid = 1e5;\n    for(int i = 0; i<vNum; i++){\n    \n        vert = min(vert, length(p4.xy - v[i])); // Vertices.\n\n        vec2 vMid = mix(v[i], v[(i + 1)%vNum], .5); // Midpoints.\n\n        // Dual lines and midpoints.\n        if(lnL>0. && i==3){ \n            vMid = vec2(0, -.5); \n            dualLn = min(dualLn, distLine(p4.xy, vec2(0), vMid)); \n        }\n        else if(lnL<0. && i==2) { \n            vMid = vec2(0, .5); \n            dualLn = min(dualLn, distLine(p4.xy, vec2(0), vMid)); \n        }\n\n   \n        mid = min(mid, length(p4.xy - vMid)); // Midpoint distance.\n\n        // Polygon distance, plus an extra highlight samples.\n        poly = max(poly, distLineS(p4.xy, v[i], v[(i + 1)%vNum]));\n        polyHi = max(polyHi, distLineS(p4.xy - ld*.001, v[i], v[(i + 1)%vNum]));\n \n    }\n    #elif POLYGON == 0\n    // Original hexagon base.\n    p4 = oP4;\n    ip = (p4.z*2.) + n;\n    vNum = 6;\n    poly = d;\n    polyHi = dHi;\n    mid = 1e5; // vert = 1e5;\n    vec2[6] vH = vec2[6](vec2(-.5, -.5), vec2(-x, 0), vec2(-.5, .5), vec2(.5, .5), \n                            vec2(x, 0), vec2(.5, -.5));\n    for(int i = 0; i<vNum; i++){\n            //vert = min(vert, length(p4.xy - vH[i]));\n            vec2 vMid = mix(vH[i], vH[(i + 1)%vNum], .5); // Midpoint.\n            mid = min(mid, length(p4.xy - vMid)); // Midpoint distance.\n    }\n    #endif\n     \n    // Giving the vertices and midpoints some size.\n    vert -= th;\n    mid -= .0125*sc;\n \n\n    //Debug: Restricting the pattern size.\n    //if(oP4.z>.8){ poly = 1e5; ln = 1e5; tr = vec3(1e5); }\n\n\n    // Restricting to six colors.\n    ip = mod(ip, 6.)/6.;\n    \n\n    #ifdef CONSTRUCTION_WEDGES\n    // Display the 12 wedge blocks that tile the plane.\n    ip = n/24. + mod(id.x, 2.)/2.;\n    vec3 hCol = .5 + .45*cos(6.2831*ip/4. + vec3(0, 1, 2)*1.5);\n    if(dA>dB) hCol = .5 + .45*cos(6.2831*ip/4. + vec3(0, 1,2)*1.5 + 3.14159);\n    #else \n    // Animated spectrum colors.\n    vec3 hCol = .5 + .45*cos(6.2831*ip + vec3(0, 1, 2)*1.5 - iTime);\n    //vec3 hCol = vec3(1, .1, .3);\n    //vec3 hCol = vec3(.9, .95, 1);\n    #endif\n\n \n    // Bump highlights.\n    #ifdef BUMP\n    float dSh = poly;//clamp(poly*4., -1., 0.);\n    float dShHi = polyHi;//clamp(polyHi*4., -1., 0.);\n    float b = max(dShHi - dSh, 0.)/.001;\n    //float b2 = max(dSh - dShHi, 0.)/.001;\n   \n    hCol *= .75 + b*.5;\n    #endif\n\n   // Scene color -- Set to black.\n    vec3 col = vec3(0); \n\n    // Rendering onto the background.\n\n    // Laying down the polygons first.\n    col = mix(col, hCol, 1. - smoothstep(0., sf, poly + .004*sc));\n    /*\n    // Polygons with borders.\n    col = mix(col, hCol*.75, 1. - smoothstep(0., sf, poly + .004*sc));\n    col = mix(col, hCol*.1, 1. - smoothstep(0., sf, poly + .012*sc));\n    col = mix(col, hCol, 1. - smoothstep(0., sf, poly + .0175*sc));\n    */\n\n \n    \n    \n    #if TRUCHET>0\n    // Rendering the Truchet pattern. The third Truchet field isn't used\n    // at the moment.\n    for(int i = 0; i<3; i++){\n        vec3 svCol = col;\n        \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., tr[i]))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, tr[i]));\n        col = mix(col, svCol*.5 + .75, 1. - smoothstep(0., sf, tr[i] + .006*sc));\n        #if TRUCHET==1\n        // White.\n        col = mix(col, svCol*.25 + .35, 1. - smoothstep(0., sf, abs(tr[i] + .015*sc) - .0015*sc));\n        #elif TRUCHET==2\n        // Black.\n        col = mix(col, svCol*.06, 1. - smoothstep(0., sf, tr[i] + th - .0045*sc));\n        #endif\n    }\n    #endif\n    \n    \n    #ifdef DUAL\n    // Display the dual pattern.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dualLn - .006*sc));\n    col = mix(col, vec3(.9, .95, 1), 1. - smoothstep(0., sf, dualLn - .002*sc));\n    // col = mix(col, vec3(1), (1. - smoothstep(0., sf, dualLn - .001*sc))*.5);\n    #endif\n\n\n    #ifdef VERTICES\n    // Polygon vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert));\n    col = mix(col, vec3(.9, .95, 1), 1. - smoothstep(0., sf, vert + .006*sc));\n    #endif\n    \n    #ifdef MIDPOINTS\n    // Polygon midpoints.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, mid));\n    col = mix(col, vec3(.6, .9, 1), 1. - smoothstep(0., sf, mid + .006*sc));\n    #endif\n    \n    #ifdef BASE_OVERLAY\n    // Hexagon base pattern overlay.\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, abs(d) - .007))); // Top layer.\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\n// Basic swap function.\nvoid swap(inout int a, inout int b){\n\n    int t = a; a = b; b = t;\n}\n*/\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Signed distance to a line passing through \"a\" and \"b\".\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}