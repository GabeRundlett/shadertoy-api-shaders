{
    "Shader": {
        "info": {
            "date": "1617660037",
            "description": "A bayer matrix dithered experiment.",
            "flags": 0,
            "hasliked": 0,
            "id": "Ns23RV",
            "likes": 5,
            "name": "Bayer Matrix Zone",
            "published": 3,
            "tags": [
                "dithering"
            ],
            "usePreview": 0,
            "username": "wilkie",
            "viewed": 411
        },
        "renderpass": [
            {
                "code": "\nconst float ResolutionDivisor = 4.0;\nconst float PaletteRGBSize = 4.0;\n\nfloat sineWave( float y ) {\n  return sin(y * 2.0 * 3.14159);\n}\n\nfloat triangleWave( float y ) {\n  return 2.0 / 3.14159 * asin(sin(2.0 * 3.14159 * y));\n}\n\nfloat quantize(float inp, float period)\n{\n\treturn floor((inp+period/2.)/period)*period;\n}\n\nfloat bayer4x4(vec2 uvScreenSpace, float divisor)\n{\n\tvec2 bayerCoord = floor(uvScreenSpace/divisor);\n\tbayerCoord = mod(bayerCoord, 4.);\n\n\tconst mat4 bayerMat = mat4(\n\t\t\t1,9,3,11,\n\t\t\t13,5,15,7,\n\t\t\t4,12,2,10,\n\t\t\t16,8,14,6) / 16.;\n\tint bayerIndex = int(bayerCoord.x + bayerCoord.y * 4.);\n\tif(bayerIndex == 0) return bayerMat[0][0];\n\tif(bayerIndex == 1) return bayerMat[0][1];\n\tif(bayerIndex == 2) return bayerMat[0][2];\n\tif(bayerIndex == 3) return bayerMat[0][3];\n\tif(bayerIndex == 4) return bayerMat[1][0];\n\tif(bayerIndex == 5) return bayerMat[1][1];\n\tif(bayerIndex == 6) return bayerMat[1][2];\n\tif(bayerIndex == 7) return bayerMat[1][3];\n\tif(bayerIndex == 8) return bayerMat[2][0];\n\tif(bayerIndex == 9) return bayerMat[2][1];\n\tif(bayerIndex == 10) return bayerMat[2][2];\n\tif(bayerIndex == 11) return bayerMat[2][3];\n\tif(bayerIndex == 12) return bayerMat[3][0];\n\tif(bayerIndex == 13) return bayerMat[3][1];\n\tif(bayerIndex == 14) return bayerMat[3][2];\n\treturn bayerMat[3][3];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,10,10));\n    \n    float timeEase = sin(iTime) / 32.0;\n    float timeStep = iTime / 4.0;\n\n    // Output to screen\n    float triangleWavePosition = 0.25 + triangleWave((uv.y + timeStep) * 8.0) / 64.0;\n    float sineWavePosition = 0.35 + timeEase * 2.0 + sineWave((uv.x + timeStep) * 6.0) / 32.0;\n    \n    if (uv.x < triangleWavePosition) {\n        fragColor = vec4(1.0, 0.5*col.x, 0.25*col.y, 1.0);\n    }\n    else if (uv.x < triangleWavePosition + 0.01) {\n        fragColor = vec4(0.5, 0.0, 0.0, 1.0);\n    }\n    else if (uv.y < sineWavePosition) {\n        col = 0.5 + 0.5 * cos(iTime / 2.0 + vec3(0,10,10));\n        vec3 color = vec3(0.5 * col.x, 0.25 + 0.5*col.y, 1.0);\n        vec3 quantizationPeriod = vec3(1./(PaletteRGBSize-1.));\n\n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 200.0));\n        color += (bayer4x4(fragCoord, bayerResolution) - 0.5) * (quantizationPeriod);\n        \n\t    color = vec3(\n\t\t\tquantize(color.r, quantizationPeriod.r),\n\t\t\tquantize(color.g, quantizationPeriod.g),\n\t\t\tquantize(color.b, quantizationPeriod.b)\n\t\t );\n\n        fragColor = vec4(color, 1.0);\n    }\n    else if (uv.y < sineWavePosition + 0.01) {\n        fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n    }\n    else {\n        // Number of circles horizontally\n        float numCirclesX = 10.0 * aspectRatio;\n        \n        // Number of circles veritically\n        float numCirclesY = 10.0;\n        \n        // Width of a circle\n        float circleW = 1.0 / numCirclesX;\n        float circleH = 1.0 / numCirclesY;\n        \n        // Get the position in this plane\n        float ux = uv.x + iTime / 64.0;\n        float uy = uv.y + iTime / 64.0;\n        \n        // Get the coordinate within the square that the circle resides within\n        float x = mod(ux, circleW);\n        float y = mod(uy, circleH);\n        \n        // And normalize it from 0.0 to 1.0\n        x /= circleW;\n        y /= circleH;\n        \n        // Get the x position of the circle in terms of 8 by 8 circles\n        float cx = mod(ux, (circleW * 8.0)) / (circleW * 8.0);\n        cx = floor(cx / (1.0 / 8.0));        \n        float cy = mod(uy, (circleH * 8.0)) / (circleH * 8.0);\n        cy = floor(cy / (1.0 / 8.0));\n        \n        // `cx` and `cy` are now a value between 0. and 7.\n        // Add cx and cy together to step them diagonally\n        cx = mod(cx + cy, 8.0);\n        \n        // Circle radii\n        float r = 0.25 + sin(iTime + cx/2.0) * 0.1;\n                       \n        // Assign a color (between 0.0 and 0.5)\n        cx = (abs(cx - 4.0)) / 8.0;\n        \n        float bayerResolution = max(1.0, floor(1.0 * iResolution.x / 800.0));\n        \n        if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r, 2.0)) {\n            // Circle interior\n            vec3 color = vec3(0.7, cx, 0.7);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            fragColor = vec4(color, 1.0);\n        }\n        else if (pow(x - 0.5, 2.0) + pow(y - 0.5, 2.0) < pow(r + 0.025 + 0.01 * -sin(iTime), 2.0)) {\n            // Circle border\n            fragColor = vec4(0.4, 0.1, 0.4, 1.0);\n        }\n        else {\n            // Circle exterior background\n            vec3 color = vec3(0.9, 0.9, 0.9);\n            color += (bayer4x4(vec2(uv.x * iResolution.x, uv.y * iResolution.y), bayerResolution) - 0.5) * (1.0);\n            \n            vec3 quantizationPeriod = vec3(1.0);\n            \n            color = vec3(\n                quantize(color.r, quantizationPeriod.r),\n                quantize(color.g, quantizationPeriod.g),\n                quantize(color.b, quantizationPeriod.b)\n            );\n            \n            if (color.x == 1.0) {\n                fragColor = vec4(color, 1.0);\n            }\n            else {\n                fragColor = vec4(0.9, 0.9, 0.9, 1.0);\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}