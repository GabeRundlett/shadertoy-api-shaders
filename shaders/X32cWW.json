{
    "Shader": {
        "info": {
            "date": "1727281272",
            "description": "lines, cube",
            "flags": 0,
            "hasliked": 0,
            "id": "X32cWW",
            "likes": 2,
            "name": "lines to cube",
            "published": 3,
            "tags": [
                "cube",
                "lines"
            ],
            "usePreview": 0,
            "username": "nayk",
            "viewed": 55
        },
        "renderpass": [
            {
                "code": "\n// wireframe code modified from FabriceNeyret2: https://www.shadertoy.com/view/XfS3DK\n\n/* and other shader work*/\n/* MIT LICENCE*/\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n\n#define H2(a) (cos(radians(vec3(-30, 60, 150))+(a)*6.2832)*.5+.5)  // hue\n#define A(v) mat2(cos((v*3.1416) + vec4(0, -1.5708, 1.5708, 0)))  // rotate\n#define s(a, b) c = max(c, .01/abs(L( u, K(a, v, h), K(b, v, h) )+.02)*k*10.*o); // segment\n//#define s(a, b) c += .02/abs(L( u, K(a, v, h), K(b, v, h) )+.02)*k*o*(1.-i);  // alt segment\n\n// line\nfloat L(vec2 p, vec3 A, vec3 B)\n{\n    vec2 a = A.xy,\n         b = B.xy - a;\n         p -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b*h) + .01*mix(A.z, B.z, h);\n}\n\n// cam\nvec3 K(vec3 p, mat2 v, mat2 h)\n{\n    p.zy *= v; // pitch\n    p.zx *= h; // yaw\n    if (texelFetch(iChannel0, ivec2(80, 2), 0).x < 1.) // P key\n        p *= 4. / (p.z+4.); // perspective view\n    return p;\n}\n#define TAU 6.28318530718\n#define gradicalscale 0.3\nmat3 m1 = mat3(0.4122214708, 0.5363325363, +0.0514459929,\n               0.2119034982, 0.6806995451, +0.1073969566,\n               0.0883024619, 0.2817188376, +0.6299787005);\n\nmat3 inverse_m1 = mat3(+4.0767416621, -3.3077115913, +0.2309699292,\n                       -1.2684380046, +2.6097574011, -0.3413193965,\n                       -0.0041960863, -0.7034186147, +1.7076147010);\n\nmat3 m2 = mat3(0.2104542553, +0.7936177850, -0.0040720468,\n               1.9779984951, 2.4285922050, +0.4505937099,\n               0.0259040371, 0.7827717662, -0.8086757660);\n\nmat3 inverse_m2 = mat3(1., +0.3963377774, +0.2158037573,\n                       1., -0.1055613458, -0.0638541728,\n                       1., -0.0894841775, -1.2914855480);\n\nfloat cbrt( float x ) // https://www.shadertoy.com/view/wts3RX (needed for negative cube roots)\n{\nfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\nfor( int i = 0; i < 1; ++i )\n    y = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < 1; ++i )\n    {\n    float y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n   \n    return y;\n}\n\nvec3 cbrt( vec3 xyz )\n{\n    return vec3(cbrt(xyz.x), cbrt(xyz.y), cbrt(xyz.z));\n}\n\nvec3 rgb2oklab(vec3 rgb)\n{\n    return cbrt(rgb * m1)*m2;\n}\n\nvec3 oklab2rgb(vec3 oklab)\n{\n    return pow(oklab * inverse_m2, vec3(3.)) * inverse_m1;\n}\n\nvec3 oklab2oklch(vec3 oklab)\n{\n    return vec3(oklab.x,\n    sqrt(oklab.y * oklab.y + oklab.z * oklab.z),\n    atan(oklab.z, oklab.y)/TAU);\n}\n\nvec3 oklch2oklab(vec3 oklch)\n{\n    return vec3(oklch.x,\n    oklch.y * cos(oklch.z*TAU),\n    oklch.y * sin(oklch.z*TAU));\n}\nvec3 colorize(float t)\n{\n    float r = smoothstep(-.2, .55, t);\n    float g = smoothstep(0., 1., t);\n    float b = smoothstep(.45, 1.05, t);\n\n    return vec3(r, g, b);\n}\nvec3 rgb2oklch(vec3 rgb) { return oklab2oklch(rgb2oklab(rgb)); }\nvec3 oklch2rgb(vec3 oklch) { return oklab2rgb(oklch2oklab(oklch)); }\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec4  C2;\n     vec2 U;\n    float v2 = 0.;\n  vec2 uv = (C - .5 * iResolution.xy) / iResolution.y;\n    // faint red ring\n    v2 += .2 * smoothstep(.3, 0., abs(length(uv) - .2) - .01);\n\n    // blobs\n    const float ao[4] = float[](-.07, .53, -1.25, -.65);\n    const float r[4] = float[](.17, .3, .3, .4);\n    const float f[4] = float[](1.2, .9, .6, .2);\n\n    for (int i = 0; i < 4; ++i) {\n        float a = 3. * radians(-30.) * r[i] * iTime + radians(360.) * ao[i];\n        vec2 pos = r[i] * vec2(cos(a), sin(a));\n      \n        v2 += f[i] * smoothstep(1.02, 0., length(uv - pos) + .5);\n    }\n   \n \n    v2 -= .35 * smoothstep(.35, .1, abs(length(uv)) + .03);\n\n   \n    {\n        uv += .05 * sin(5. * uv + radians(90.));\n   \n        float a = .5 + atan(uv.y, uv.x) / radians(360.);\n        float r = length(uv);\n       \n        float p = 20. * (.5 * radians(360.) * (a + .1 * iTime) + radians(360.) * pow(r - .5, 2.));\n       \n        float vm = smoothstep(0., .3, r)\n            * smoothstep(.5, .1, r)\n            ;\n        v2 = v2 * (1. + .01 * vm) + .0 * vm;\n    }\n vec2 uv2 = C/iResolution.xy;\n vec2 center = vec2(iMouse.x, iMouse.y)/iResolution.xy;\n    vec2 off = uv2 - center;\n    vec4 col2 = vec4(0.);\n    for(int i= 0;i<32;i++)\n    {\n        float scale = 1.0 - gradicalscale*(float(i)/31.0);\n         col2 += texture(iChannel0, off*scale+center);\n    }\n    vec4 fragColor2 = col2/32.0;\n    vec3 col = oklch2rgb( vec3(.85, 0.1, -uv2.x + .167) );\n    vec2 R = iResolution.xy,\n         u = (C+C-R)/R.y*1.2,\n         m = (iMouse.xy*2.-R)/R.y;\nu*=4.;\n    float t = iTime/60.,\n          l = 15.,  // loop size\n          j = 1./l, // increment size\n          r2 = 0.8,   // scale size\n          o = .1,   // brightness\n          i = 0.;   // starting increment\n   \n\n      \n    mat2 v = A(5.+iTime), // pitch\n         h= A(1.+iTime); // yaw\n   \n    vec3 p = vec3(1, 1, -1),    // cube coords\n         c = 0.12*length(u)*H(t), // background\n         k;\n         p=R(p, vec3(1,1,1),iTime);\n             float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p.xy) + 0.27)) * 2.2;\nfloat si = sin(t2);\nfloat co = cos(t2);\nmat2 ma = mat2(co, si, -si, co);\n   \n    // cubes\n    for (; i<1.1; i+=j)\n    {\n     \n        k = H(i+iTime*1.)+.2; // cube color\n        h = A(iTime+i); // rotate\n        \n       ;\n      p=R(p, vec3(i,1,-i), i);\n       \n        s( p.yyz, p.yzz )\n        s( p.zyz, p.zzz )\n        s( p.zyy, p.zzy )\n        s( p.yyy, p.yzy )\n        s( p.yyy, p.zyy )\n        s( p.yzy, p.zzy )\n           p=R(p, vec3(i,i,-i), 0.1*iTime);\n        s( p.yyz, p.zyz )\n        s( p.yzz, p.zzz )\n        s( p.zzz, p.zzy )\n        s( p.zyz, p.zyy )\n        s( p.yzz, p.yzy )\n                 p=R(p, vec3(-i,i,i), 0.1*iTime);\n        s( p.yyz, p.yyy )\n       \n    }\n   \n    C2 = vec4(tanh(c*c*3.)*col, 1);\n   \n    O=C2;\n   \n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}