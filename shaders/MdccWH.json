{
    "Shader": {
        "info": {
            "date": "1518649614",
            "description": "Playing with truchet tiles, with color-filling of \"emergent\" regions. At the moment we don't fill them intelligently, we just use parity to choose one of two colors.",
            "flags": 64,
            "hasliked": 0,
            "id": "MdccWH",
            "likes": 6,
            "name": "Truchet regions",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "tiling"
            ],
            "usePreview": 0,
            "username": "huttarl",
            "viewed": 817
        },
        "renderpass": [
            {
                "code": "/*\nIdea: 2D truchet tiles\n Each tile is oriented according to some background data,\n e.g. some electric charges of various strengths and polarities\n moving around behind the scenes.\n\n Then once the tiles are oriented, the bonus is to color in\n the enclosed regions.\n - The hard part is to try to preserve the colors of most of the\n   regions, even as their shape changes ... then what determines their color?\n - An easy way is to do it with two colors (Duotone Surfaces -\n   http://oaktrust.library.tamu.edu/handle/1969.1/149501) that doesn't\n   rely on computation outside the single given tile? Yes... the corners'\n   color can rely solely on the parity of the tile's coordinates.\n   There may not be time to do any real filling, even using multipass buffers...\n\nTo try:\n- how about animating the changing of tiles: e.g. rotating them, or fading the center\n  diamond shape from one color to the other.\n  \n*/\n\n// Display grid lines?\n// #define GRIDLINES 1\n\nconst float tileSize = 0.1; // Tile size relative to viewport height\nconst float lineWidth = 0.05; // Line thickness relative to tile size\n\n// Determine orientation of tile at i,j.\nbool ori1(ivec2 ij) {\n    // Alternating: return (ij.x + ij.y) % 2 == 0;\n    // More varied, randomish pattern:\n    return fract(sin(float(ij.x) * 13493.45 + iTime * .01) +\n                 cos(float(ij.y) * 1706.93 - iTime * .013)) > .5;\n}\n\n// Determine orientation of tile at i,j.\nbool orientation(ivec2 ij) {\n    /* Mixing up the orientation based on orbiting electric charges.\n\tTo try: instead, determine orientation based on value v at (i, j, iTime)\n    in 3D gradient noise. We could animate the transition based on\n    smoothstep(.4, .6, v) if v goes from 0 to 1. */\n    const float nCharges = 29.;\n    vec2 totalEffect = vec2(0.);\n    \n    for (float i = 0.; i < nCharges; i += 1.) {\n        float strength = mod(i * .65, 2.) - 1.,\n\t        r = fract(i * .74) * 10. + .5,\n        \ta = iTime * (i + 5.) * .001 + i * 22.;\n        \n        vec2 c = vec2(r * cos(a), r * sin(a));\n        vec2 d = vec2(ij) - c;\n        totalEffect += normalize(d) * strength * 4. / dot(d, d);\n    }\n\t\n\treturn (totalEffect.x < 0. ^^ totalEffect.y < 0.);\n}\n\nvec3 color(vec2 uv) {\n    const vec3 line = vec3(.2);    \n\n    // Coordinates of current tile\n    vec2 ij1;\n    // Coordinate within current tile (0 to 1)\n    vec2 p = modf(uv / tileSize, ij1);\n    ivec2 ij = ivec2(ij1);\n    // Make ij row/column left of/below the origin = -1 instead of -0.\n    if (p.x < 0.) ij.x -= 1;\n    if (p.y < 0.) ij.y -= 1;\n\n    // Make p non-negative.\n    p = fract(p + vec2(1.));\n    \n    // Is this an odd or even-position tile?\n    bool parity = ((ij.x + ij.y) % 2 == 0);\n    // Which way do the lines go?\n    bool ori = orientation(ij);\n\n    // Corner point; swizzle to change corners.\n    vec2 c = vec2(0., 1.), c1, c2;\n    c1 = ori ? c.xx : c.xy;\n    c2 = ori ? c.yy : c.yx;\n    \n    const float arcR = .5;\n    \n    // Distance from arcs\n    float r1 = distance(p, c1) - arcR, r2 = distance(p, c2) - arcR;\n    bool inCorner = (min(r1, r2) < 0.);\n    \n    // Min abs distance from arcs\n    float d = min(abs(r1), abs(r2));\n\n    const vec3 A = vec3(.4), B = vec3(.82, .71, .55);\n    vec3 background = (parity ^^ ori ^^ inCorner) ? A : B;\n\n    vec3 col = mix(line, background, smoothstep(0., lineWidth, d));\n    \n    \n#ifdef GRIDLINES\n    float gridD = min(min(p.x, p.y), min(1. - p.x, 1. - p.y));\n    col = mix(line, col, smoothstep(0., .05, gridD));\n\t// origin dot:\n    col = mix(vec3(0.), col, smoothstep(.01, .02, length(uv)));\n#endif\n    return col;    \n}\n\n// Slowly panning camera.\nvec2 pan() {\n    float a = iTime * .11, a2 = iTime * .3;\n    float r = .3 + sin(a2) * .1;\n    return vec2(r * cos(a), r * sin(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.yy + pan();\n\n    // Time varying pixel color\n    vec3 col = color(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "musicstream",
                        "id": 13564,
                        "published": 0,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "https://soundcloud.com/edluhrs/counterpoint-542-bach"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}