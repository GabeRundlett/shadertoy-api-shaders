{
    "Shader": {
        "info": {
            "date": "1608578953",
            "description": "Fanart from the Solo movie. This is from the Kessel run scene. ",
            "flags": 0,
            "hasliked": 0,
            "id": "wdVBDd",
            "likes": 6,
            "name": "Maelstrom",
            "published": 3,
            "tags": [
                "modeling",
                "volumetric"
            ],
            "usePreview": 0,
            "username": "piluve",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "/*\n    Maelstrom by nachocpol@gmail.com\n    \n    From the SW Solo movie\n    Refs:\n        https://www.retrozap.com/wp-content/uploads/2018/04/Screen_Shot_2018_02_05_at_8_51_04_AM.png\n        https://www.the-blueprints.com/blueprints-depot-restricted/sciencefiction/star-wars-imperial/imperial_sd-02668.jpg\n*/\n\n#define PI 3.14159265359\n#define DEG_TO_RAD 0.0174533\n#define THUNDER 1 // Disable this if you are sensitive to flashing lights\n\nconst float k_Near = 1.0;\nconst float k_Far = 100.0;\nconst int k_MainSteps = 360;\nconst float k_HitDelta = 0.001;\n\nconst float k_ThunderRadius = 20.0;\nconst vec3 k_ThunderColor = vec3(0.5, 0.61, 0.75); \nconst vec3 k_Thunder0 = vec3(-15.0, -10.0, -5.0);\nconst vec3 k_Thunder1 = vec3(10.0, 9.0, -5.0);\nconst vec3 k_Thunder2 = vec3(-10.0, 9.0, 5.0);\nconst float k_SunRadius = 30.0;\nconst vec3 k_SunColor = vec3(1.0, 0.35, 0.0);\nconst vec3 k_Sun = vec3(-5.0, 10.0, 28.0);\n\nconst vec3 k_CloudAlbedo = vec3(0.2, 0.18, 0.28);\n\nfloat saturate(float v)\n{\n    return max(min(v,1.0),0.0);\n}\n\nmat3 RotX(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(1.0, 0.0, 0.0, 0.0, cos0, -sin0, 0.0, sin0, cos0);\n}\n\nmat3 RotY(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(cos0, 0.0, sin0, 0.0, 1.0, 0.0, -sin0, 0.0, cos0);\n}\n\nmat3 RotZ(float angle)\n{\n    float o = angle * DEG_TO_RAD;\n    float cos0 = cos(o);\n    float sin0 = sin(o);\n    return mat3(cos0, -sin0, 0.0, sin0, cos0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// Sphere (r radius)\nfloat SphereD(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat InfCylinderD(vec3 p, vec3 c)\n{\n    // Flipped to get the inside of the cylinder\n    return c.z - length(c.xy - p.xy );\n}\n\n// Box\nfloat BoxD(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Triangular prism (h.x hight, h.y length)\nfloat TriPrismD(vec3 p, vec2 h)\n{\n  vec3 q = abs(p);\n  return max(\n      q.z - h.y,\n      max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5\n  );\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) \n{ \n    p = fract(p * 0.011); \n    p *= p + 7.5; \n    p *= p + p; \n    return fract(p); \n}\n\nfloat ValueNoise1D(float x) \n{\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\nfloat ValueNoise3D(vec3 x)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod(iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat Fbm(vec3 p)\n{\n    float n = ValueNoise3D(p * 1.0) * 1.0;\n    n += ValueNoise3D(p * 2.4) * 0.55; \n    n += ValueNoise3D(p * 5.84) * 0.3025;\n    return n / 1.8525;\n}\n\nfloat ScaleNorm(vec3 s)\n{\n    return min(min(s.x, s.y), s.z);\n}\n\nfloat StarDestroyerDetail(vec3 p)\n{\n    float n = texture(iChannel0, p.xz * 0.01).r;\n    n *= 0.135;\n    return n;\n}\n\nfloat StarDestroyer(vec3 p)\n{\n    float hullLen = 20.0;\n    float halfHullLen = hullLen * 0.5;\n    float hull = 0.0;\n    {\n        vec3 pHull = RotZ(90.0) *  p;\n        float lenFactor = saturate((p.z + halfHullLen) / hullLen) + 0.025;\n        vec3 hullScale = vec3(lenFactor * 0.5, lenFactor , 1.0);\n        pHull.xyz /= hullScale;\n        pHull = abs(pHull);\n        hull = TriPrismD(pHull, vec2(10.0, halfHullLen)) * ScaleNorm(hullScale);\n    }\n    \n    float hullSmall = 0.0;\n    {\n        float halfHullSmallLen = 5.0;\n        vec3 pHullSmall = RotZ(90.0) *  (p - vec3(0.0,1.0,2.0));\n        float lenFactor = saturate((p.z + halfHullSmallLen) / hullLen) + 0.025;\n        vec3 hullScale = vec3(lenFactor * 0.7, lenFactor , 1.0);\n        pHullSmall.xyz /= hullScale;\n        pHullSmall = abs(pHullSmall);\n        hullSmall = TriPrismD(pHullSmall, vec2(10.0, halfHullSmallLen)) * ScaleNorm(hullScale);\n    }\n    \n    float bridgeNeck = 0.0;\n    {\n        vec3 bridgeP = p - vec3(0.0, 3.0, halfHullLen - 0.8);\n        bridgeNeck = BoxD(bridgeP, vec3(0.8, 2.5, 0.8));\n    }\n    \n    float bridgeHead = 0.0;\n    {\n        vec3 bridgeP = p - vec3(0.0, 4.5, halfHullLen - 0.8);\n        float yx = max(1.0 - abs(p.x / 3.0), 0.45);\n        bridgeHead = BoxD(bridgeP, vec3(4.0, 0.9 * yx, 0.8));\n    }\n    \n    float radarSphere = 0.0;\n    {\n        vec3 radarP = p;\n        radarP.x = abs(radarP.x);\n        radarP -=vec3(3.0, 5.3, halfHullLen - 0.8);\n        radarSphere = SphereD(radarP, 0.8);\n    }\n    \n    return min(min(hull,hullSmall), min(min(bridgeNeck, bridgeHead), radarSphere)) \n        + StarDestroyerDetail(p);\n}\n\nfloat SceneDistance(vec3 p)\n{\n    return StarDestroyer(p);\n}\n\nvec3 SceneNormal(vec3 p)\n{\n    vec2 delta = vec2(k_HitDelta, 0.0);\n    return normalize(vec3(\n        SceneDistance(p + delta.xyy) - SceneDistance(p - delta.xyy),\n        SceneDistance(p + delta.yxy) - SceneDistance(p - delta.yxy),\n        SceneDistance(p + delta.yyx) - SceneDistance(p - delta.yyx)\n    ));\n}\n\nfloat March(vec3 ro, vec3 rd)\n{\n    float dist = k_Near;\n    vec3 p = ro + rd * dist;\n    for(int i = 0; i < k_MainSteps; ++i)\n    {\n        float curDist = SceneDistance(p);\n        if(((curDist) < k_HitDelta) || (dist >= k_Far))\n        {\n            return dist;\n        }\n        dist += curDist;\n        p = ro + rd * dist;\n    }\n    return k_Far;\n}\n\nvec4 GetThunderActivation()\n{\n    vec4 act;\n    act.x = pow(abs(max(ValueNoise1D(iTime * 12.0), 0.0)-0.2), 5.0);\n    act.y = pow(abs(max(ValueNoise1D((iTime  - 10.0)* 12.0), 0.0)-0.2), 10.0);\n    act.z = pow(abs(max(ValueNoise1D((iTime  + 10.0) * 12.0), 0.0)-0.1), 10.0);\n    act.w = saturate(pow(abs(sin(iTime * 7.0) * cos(iTime * 3.0)), 1.0) + 0.5);\n    return act;\n}\n\nvec3 CumputePointLight(vec3 lightPosition, float lightRadius, vec3 lightColor, vec3 position, vec3 normal, vec3 baseColor)\n{\n    vec3 toLight = lightPosition - position;\n    vec3 l = normalize(toLight);\n    float dist = length(toLight);\n    float atten = saturate(1.0 - (dist / lightRadius));\n    atten *= atten;\n    float NdotL = max(dot(normal, l), 0.0);\n    return (baseColor / PI) * lightColor * atten * NdotL;\n}\n\nvec3 ShadeScene(vec3 ro, vec3 rd, float d)\n{\n    vec3 radiance = vec3(0.0);\n    \n    vec3 position = ro + rd * d;\n    vec3 normal = SceneNormal(position);\n    \n    vec3 colA = vec3(0.8);\n    vec3 colB = vec3(0.7);\n    vec3 baseColor = mix(colA, colB, texture(iChannel0, position.xy * 0.2).r);\n    \n    vec4 thunderAct = GetThunderActivation();\n    vec3 directLight = vec3(0.0);\n#if THUNDER\n    directLight += CumputePointLight(\n        k_Thunder0, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.x * 10.0;\n    directLight += CumputePointLight(\n        k_Thunder1, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.y * 10.0;\n    directLight += CumputePointLight(\n        k_Thunder2, k_ThunderRadius, k_ThunderColor, position, normal, baseColor\n    ) * thunderAct.z * 10.0;\n#endif\n    directLight += CumputePointLight(\n        k_Sun, k_SunRadius, k_SunColor * 25.0, position, normal, baseColor\n    ) * thunderAct.w;\n    \n    vec3 indirect = (k_CloudAlbedo * 0.05) * (baseColor / PI);\n    vec3 litColor = directLight + indirect;\n    \n    vec3 fogColor = vec3(0.01);\n    float fogIntensity = saturate(d / 50.0);\n    fogIntensity *= fogIntensity;\n    \n    return mix(litColor, fogColor, fogIntensity);\n}\n\nfloat CloudMask(vec3 p)\n{\n    float pz = max(p.z + 20.0, 0.0);\n    pz *= p.z;\n    p.x += (pz) * 0.01;\n    p.y -= (pz) * 0.007;\n    float cylRadius = 8.0;\n    float dist = InfCylinderD(p, vec3(0.0, 4.0, cylRadius));\n    float mask = saturate((1.0 - (dist/ cylRadius)) - 0.35);\n    return dist < 0.0 ? 1.0 : mask;\n}\n\nfloat GetCloudDensity(vec3 p)\n{\n    float mask = CloudMask(p);\n    p.z -= iTime * 0.25;\n    p.x += iTime * 0.05;\n    float density = saturate(Fbm(p * 0.3) - 0.25);\n    return density * mask;\n}\n\nvec4 ShadeClouds(vec3 ro, vec3 rd, float scene)\n{\n    vec3 cloudColor = vec3(0.0);\n    float absorption = 2.5;\n    float powderBeta = 1.035;\n    float powderAmmount = 1.151;\n    float transmittance = 1.0;\n    float opacity = 0.0;\n    float stepSize = 0.8;\n    float dist = 0.0;\n        \n    for(int i = 0; i < 128; ++i)\n    {\n        vec3 curPos = ro + rd * dist;\n        \n        float density = GetCloudDensity(curPos);\n        float transmitCoef = density * absorption;\n        float powderCoef = density * powderBeta;\n        float beer = exp(-transmitCoef * stepSize);\n        transmittance *= beer;\n        \n        if(transmittance < 0.01 || dist >= scene) \n        {\n            break;\n        }\n        \n        float powder = 1.0 - saturate(exp(-powderCoef * stepSize * 2.0) * powderAmmount);\n        cloudColor += transmittance * k_CloudAlbedo * powder;\n        \n        // Apply thunder:\n        vec4 thunderAct = GetThunderActivation();\n#if THUNDER\n        cloudColor += CumputePointLight(\n            k_Thunder0, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder0 - curPos), k_CloudAlbedo\n        ) * density * 300.0 * transmittance * thunderAct.x;\n        cloudColor += CumputePointLight(\n            k_Thunder1, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder1 - curPos), k_CloudAlbedo\n        ) * density * 500.0 * transmittance * thunderAct.y;\n        cloudColor += CumputePointLight(\n            k_Thunder2, k_ThunderRadius, k_ThunderColor, curPos, normalize(k_Thunder2 - curPos), k_CloudAlbedo\n        ) * density * 100.0 * transmittance * thunderAct.z;\n#endif\n         cloudColor += CumputePointLight(\n            k_Sun, k_SunRadius, k_SunColor, curPos, normalize(k_Sun - curPos), k_CloudAlbedo\n        ) * density * 3.0 * transmittance * thunderAct.w;\n        \n        // Ambient'ish term\n        cloudColor += k_CloudAlbedo * 0.001;\n        \n        opacity = opacity + (1.0 - beer) * (1.0 - opacity);\n        dist += stepSize;\n    }\n    \n    return vec4(cloudColor, opacity);\n}\n\nmat3 LookAt(vec3 origin, vec3 target, float roll) \n{\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 GetCamPos()\n{\n    float t = iTime * 0.3;\n    vec3 ro;\n    ro.x = sin(t) + 2.0;\n    ro.y = cos(t) + 3.0;\n    ro.z = -25.0;\n    \n    if(iMouse.z > 0.0)\n    {\n        ro.x = ((iMouse.x / iResolution.x) * 2.0 - 1.0) * 10.0;\n        ro.y = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * -10.0;\n    }\n    return ro;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    ndc.x *= aspect;\n    \n    // Setup camera:\n    vec3 ro = GetCamPos();    \n    mat3 view = LookAt(ro, vec3(0.0), 0.0);\n    vec3 rd = normalize(view * vec3(ndc, 1.3));\n    \n    // Shade the scene:\n    float sceneDist = March(ro, rd);\n    vec3 sceneColor = vec3(0.0); \n    if(sceneDist < k_Far)\n    {\n        sceneColor = ShadeScene(ro, rd, sceneDist);\n    }\n    // Shade and composite clouds:\n    vec4 clouds = ShadeClouds(ro, rd, sceneDist);\n    sceneColor = (sceneColor * (1.0 - clouds.a)) + clouds.rgb * clouds.a;\n    \n    \n    // Post:\n    fragColor.rgb = sceneColor;\n    float v = 1.0 - (length(uv * 2.0 - 1.0) / 1.4);\n    fragColor.rgb *= sqrt(v);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 15,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}