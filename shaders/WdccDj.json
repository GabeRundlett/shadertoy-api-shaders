{
    "Shader": {
        "info": {
            "date": "1601687394",
            "description": "wet",
            "flags": 0,
            "hasliked": 0,
            "id": "WdccDj",
            "likes": 11,
            "name": "moist",
            "published": 3,
            "tags": [
                "water"
            ],
            "usePreview": 0,
            "username": "jj99",
            "viewed": 533
        },
        "renderpass": [
            {
                "code": "// Fork of \"18 - Sea of Sinewaves\" by Krabcode. https://shadertoy.com/view/3ddcz2\n// 2020-10-02 16:01:39\n// forked again from https://www.shadertoy.com/view/WstcDB\n\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\nconst int MAX_STEPS = 1;\nconst float MAX_DIST = 1.;\nconst float SURF_DIST = 0.0001;\nconst float NORMAL_DIST = 0.001;\nconst float SHININESS = 10.;\nconst float DOWNSTEP = 0.1;\nconst float PI = 3.14159;\n\nvec2 uv;\nvec2 lightOffset; \nvec3 lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\nvec2 m;\n\nmat2 rotate(float a){\n  return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\n\n\nfloat wave(vec2 p) {\n  float v = sin(p.x*0.7 + sin(p.y*2.2) + sin(p.y * .43));\n  return v*v;\n}\n \nconst mat2 rot = mat2(0.5, 0.86, -0.86, 0.5);\n \nfloat get(vec2 p,float t)\n{\n  float v = 0.0;//abs(sin(p.x+p.y*1.4))*0.1;\n  v += wave(p);\n  p.y += t;\n  p *= rot;\n  v += wave(p);\n  p.y += t * .17;\t//0.17\n  p *= rot;\n  v += wave(p);\n  v+=pow(abs(sin(p.x+v)),2.0);\n\t\n  v = abs(1.5 - v);\n  return v;\n}\n \nfloat sdf(vec3 p){ \n    float v = get(p.xy*6.0,iTime)*0.1;\n     \tv = smoothstep(0.02,3.5,v)*2.5;\n\n    return p.z+v;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS*DOWNSTEP;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv+vec2(0., 0.25), 0.);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.)); \n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nfloat aaRender(vec2 uv){\n    vec2 third = vec2(1./iResolution.x, 1./iResolution.y) / 3.0;\n    vec2 mult = vec2(1, -1);\n    float c1 = render(uv+third*mult.xx);\n    float c2 = render(uv+third*mult.xy);\n    float c3 = render(uv+third*mult.yx);\n    float c4 = render(uv+third*mult.yy);\n    return (c1+c2+c3+c4) / 4.;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //m = iMouse.xy / iResolution.xy;\n    //time = 100.+float(iFrame)*.0005;\n    lightPos = vec3(0.,5.0,-16.0);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv); \n    lit *= smoothstep(MAX_DIST*.15, MAX_DIST*.05, hitDist);\n\tvec3 col = vec3(0.2,1.2,1.8)*lit;\n    fragColor = vec4(gammaCorrection(col),1.0);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}