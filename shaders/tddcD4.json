{
    "Shader": {
        "info": {
            "date": "1601041383",
            "description": "(mis)using ambient occlusion to show video content...\n...this surely will supersede LCD and LED technology ;-)",
            "flags": 0,
            "hasliked": 0,
            "id": "tddcD4",
            "likes": 12,
            "name": "Ambient Occlusion Display",
            "published": 3,
            "tags": [
                "shadow",
                "effect",
                "ao",
                "ambientocclusion"
            ],
            "usePreview": 0,
            "username": "flockaroo",
            "viewed": 564
        },
        "renderpass": [
            {
                "code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// shadow/occlusion display\n//\n// ...(mis)using ambient occlusion to show video content...\n//\n#define SHADOW\n#define GREENSCREEN\n#define PERIODIC\n//#define CLAMP\n\n#ifndef SHADEROO\n#define CUBEMAP\n#endif\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define PIH 1.57079632679\n\n#define ROTM(ang) mat2(cos(ang-vec2(0,PIH)),-sin(ang-vec2(0,PIH)))\n\nvec3 rotZ(float ang, vec3 p) { return vec3(ROTM(ang)*p.xy,p.z); }\nvec3 rotX(float ang, vec3 p) { return rotZ(ang,p.yzx).zxy; }\n\nfloat WireRadius=0.05;\nfloat Angle=0.;\n\n// iq's line distance\nfloat lineDist( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat getVal(vec2 p)\n{\n    vec2 uv=p*7./Res0+.5;\n    vec2 uv0=uv;\n#ifdef PERIODIC\n    uv=fract(uv);\n#endif\n    vec3 c=texture(iChannel0,uv).xyz;\n#ifdef GREENSCREEN\n   \tc=mix(c,vec3(0),dot(c,vec3(-1,2,-1)));\n#endif\n    float h=dot(c,vec3(.333))*1.5;\n    vec2 bstep=step(.5,abs(uv0-.5));\n    float b=max(bstep.x,bstep.y);\n#ifndef PERIODIC\n    h*=1.-b;\n#endif\n    h=clamp(h,0.,10.);\n#ifdef CLAMP\n    h-=2.*b;\n#endif\n    return h;\n}\n\n#define CS(x) cos(x+vec2(0,-PI*.5))\n\nvoid getTri(vec2 p, inout vec2 p1, inout vec2 p2, inout vec2 p3)\n{\n    mat2 m=mat2(CS(Angle),CS(Angle+60.*PI/180.));\n    vec2 q=inverse(m)*p;\n    vec2 qfr=fract(q);\n    p1=m*floor(q);\n    p2=p1+m*vec2(1,0);\n    p3=p1+m*vec2(0,1);\n    if(qfr.x+qfr.y>1.) p1+=m*vec2(1,1);\n}\n\nfloat distFloor(vec3 pos)\n{\n    vec4 r=textureLod(iChannel1,pos.xy*.2,0.);\n    float d=pos.z+WireRadius+.007+(r.x-.5)*.015;\n    return d;\n}\n\nfloat distGrid(vec3 pos)\n{\n    vec3 p1,p2,p3;\n    vec2 p10,p20,p30;\n    getTri(pos.xy,p10,p20,p30);\n    p1=vec3(p10,getVal(p10));\n    p2=vec3(p20,getVal(p20));\n    p3=vec3(p30,getVal(p30));\n    float d=10000.;\n    d=min(d,lineDist(pos,p1,p2)-WireRadius);\n    d=min(d,lineDist(pos,p2,p3)-WireRadius);\n    d=min(d,lineDist(pos,p3,p1)-WireRadius);\n    return d;\n}\n\nfloat dist(vec3 pos)\n{\n    float d=10000.;\n    d=min(d,distFloor(pos));\n    d=min(d,distGrid(pos));\n    return d;\n}\n\nvec3 getGrad(vec3 p, float eps) \n{ \n    vec2 d=vec2(eps,0); \n    float d0=dist(p);\n    return vec3(dist(p+d.xyy)-d0,dist(p+d.yxy)-d0,dist(p+d.yyx)-d0)/eps; \n}\n\nfloat march(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<eps) return 0.;\n    }\n    return 1.0;\n}\n\nfloat marchUntilSmaller(inout vec3 pos, vec3 dir)\n{\n    float eps=.001;\n    float dp=dist(pos);\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if (d<dp) return d;\n        dp=d;\n    }\n    return 1.0;\n}\n\nfloat marchUntil(inout vec3 pos, vec3 dir, float maxDist, inout vec3 minpos)\n{\n    float eps=.001;\n    float dsum=0.;\n    float dmin=100000.;\n    for(int i=0;i<80;i++)\n    {\n        float d=dist(pos);\n        pos+=dir*d*.7;\n        if(d<dmin) { dmin=d; minpos=pos; }\n        dsum+=d;\n        if (dsum>maxDist) break;\n        if (d<eps) return 0.;\n    }\n    return dmin;\n}\n\nvoid getTrafo(inout vec3 pos, inout vec3 dir, vec2 fc)\n{\n    vec2 sc=(fc-Res*.5)/Res.x*2.;\n    dir=normalize(vec3(0,0,-1.5)+vec3(sc,0));\n    float camDist=20.;\n    #ifdef SHADEROO\n    camDist*=exp(-iMouseData.z/3000.);\n    #endif\n    float ph = iMouse.x/Res.x*10.;\n    float th = iMouse.y/Res.y*10.;\n    if (iMouse.x<1.)\n    {\n        ph=iTime*.5;\n        th=.2+(1.+sin(iTime*.13))*.5;\n        camDist*=1.2-cos(iTime*.3);\n    }\n    pos=vec3(0,0,camDist);\n    pos.yz=ROTM(th)*pos.yz;\n    dir.yz=ROTM(th)*dir.yz;\n    pos.xy=ROTM(ph)*pos.xy;\n    dir.xy=ROTM(ph)*dir.xy;\n}\n\n#define RandTex iChannel1\nvec4 getRand(vec2 coord)\n{\n    vec4 c=vec4(0);\n    c+=texture(RandTex,coord+.003*iTime);\n    c+=texture(RandTex,coord/2.+.003*iTime)*2.;\n    c+=texture(RandTex,coord/4.+.003*iTime)*4.;\n    c+=texture(RandTex,coord/8.+.003*iTime)*8.;\n    return c/(1.+2.+4.+8.);\n}\n\n#define FloorZ -.66\n//#define HomePos vec3(0,0,-FloorZ*1.5)\n//#define CamDist0 18.\n\n// environment just a sky and some dark floor\nvec4 myenv(vec3 pos, vec3 dir, float period_)\n{\n#ifdef CUBEMAP    \n    return texture(iChannel2,dir.yzx);\n#endif\n    vec3 sun = normalize(vec3(1,1,1));\n    vec3 skyPos=pos+dir/abs(dir.z)*(120.-pos.z);\n    float cloudPat=(1.+.4*(getRand(skyPos.xy*.0002).x-.5));\n    vec3 colHor=vec3(.3,.4,.5)+.4;\n    float dirl=dot(dir,sun);\n    vec3 clouds=mix(vec3(1.)*(1.-2.*dirl),vec3(.8,1.,1.2),cloudPat);\n    vec3 colSky=mix(vec3(1.5,.75,0.)*3.,clouds,clamp(7.*dir.z,0.,1.));\n    //colSky=mix(colSky,vec3(1),cloudPat);\n    //colSky*=mix(1.,cloudPat,dir.z*5.);\n    vec3 colFloor=vec3(.45);\n    \n    vec3 col=mix(colSky,colFloor,1.-smoothstep(-.01,.01,dir.z));\n    col=mix(colHor,col,clamp(abs(dir.z*5.)-.1,0.,1.));\n    \n    col*=.9;\n    \n    //float sunang=acos(dot(dir,sun));\n    float sunang=atan(length(cross(dir,sun)),dot(dir,sun));\n    col+=15.*clamp(2.*exp(-sunang/.02),0.,1.);\n    col+=2.*clamp(2.*exp(-sunang/.20),0.,1.);\n    \n    return vec4(col*.7,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 light=normalize(vec3(1,1,1.5));\n    vec3 pos,dir;\n    getTrafo(pos,dir,fragCoord);\n    march(pos,dir);    \n    vec3 pos1=pos;\n    float d1=dist(pos1);\n    vec3 n=normalize(getGrad(pos,.001));\n    vec3 R=reflect(dir,n);\n    float ao=1.;\n    float sc=25.;\n    ao*=.9+.1*abs(dist(pos+n*.06*sc))/(.06*sc);\n    ao*=.7+.3*abs(dist(pos+n*.02*sc))/(.02*sc);\n    ao*=.6+.4*abs(dist(pos+n*.01*sc))/(.01*sc);\n    ao*=.5+.5*abs(dist(pos+n*.005*sc))/(.005*sc);\n    ao=clamp(ao,0.,1.);\n    float diff=max(dot(n,light),0.)*.7+.3;\n    pos+=light*.01;\n    #ifdef SHADOW\n    marchUntilSmaller(pos,light);\n    vec3 minpos;\n    float sh=marchUntil(pos,light,1000.,minpos);\n    sh=1.-smoothstep(0.,.1*length(minpos-pos1),sh);\n    //sh=(sh!=0.)?0.:1.;\n    sh*=exp(-length(minpos-pos1)/2.3);\n    diff=min(diff,(1.-sh)*.5+.5);\n    #endif\n    fragColor.xyz=vec3(1);\n    fragColor.xyz*=(n*.05+.95);\n    //diff=1.;\n    fragColor.xyz*=diff;\n    fragColor.xyz*=mix(1.,ao,diff);\n    vec4 refl=myenv(pos1,R,1.);\n    if(d1==distGrid(pos1)) { fragColor.xyz*=vec3(1.,.8,.6)*1.4*(.5+.7*refl.xyz); }\n    if(d1==distFloor(pos1)) fragColor.xyz*=vec3(1.3,1.1,.9)*1.4*(.8+.2*refl.xyz);\n    //fragColor.xyz*=vec3(1.,.8,.6)*1.3;\n    //vec4 refl=myenv(pos1,R,1.); fragColor.xyz*=(.7+.3*refl.xyz);\n    //if(d1==distFloor(pos1)) fragColor.xyz*=vec3(.9,.95,1.)*1.3;\n    fragColor.w=1.;\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 36,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}