{
    "Shader": {
        "info": {
            "date": "1505470962",
            "description": "Decided to make something a bit more complex this time. Used many types of Mod operations in my raymarch map. Hopefully you will enjoy this shader. Use mouse to interact. \n",
            "flags": 32,
            "hasliked": 0,
            "id": "MlfcR2",
            "likes": 77,
            "name": "Lighthouse Raymarch HighRes 1.01",
            "published": 3,
            "tags": [
                "3d",
                "reflection",
                "raymarch",
                "raycast",
                "cloud",
                "water",
                "shadows",
                "raytrace",
                "tower",
                "lightning",
                "shapes",
                "bridge",
                "lighthouse",
                "watchtower"
            ],
            "usePreview": 1,
            "username": "ingagard",
            "viewed": 9686
        },
        "renderpass": [
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n////////////////////// SPECIAL THANKS TO Inigo Quilez  ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n  #define TAU (2.*PI)\n  #define PHI (sqrt(5.)*0.5 + 0.5)\n  #define M_NONE -1.0\n  #define M_NOISE 1.0\n  #pragma optimize(off) \n  const vec3 sunPos = normalize(vec3(5.3, 2.7, -1.));\nconst vec3 sunColor = vec3(0.80, 0.7, 0.55);         \nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nfloat winDist=100000.0;\nfloat dekoDist=100000.0;\nfloat steelDist=100000.0;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steps;\n  float winDist;\n  float dekoDist;\n  float steelDist;\n  float glassDist;\n};\n\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.0;\n  f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  return (length( p/r.xyz ) - 1.0) * r.y;\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(in vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModSingle1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  if (p >= 0.)\n    p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nfloat SmallWindow( vec3 p)\n{\n  float d= sdBox(p-vec3(-.65, 1.17, 0.0), vec3(0.08, 0.4, 0.4));\n\n  if(d<1.) // AABB\n  {\n  d= max(d, -sdBox(p-vec3(-.06, 1.17, 0.0), vec3(0.54, 0.36, .36))); \n  d= max(d, -sdBox(p-vec3(-.22, 1.17, 0.0), vec3(0.54, 0.32, .32))); \n  d= min(d, sdBox(p-vec3(-0.58, 1.65, 0.), vec3(0.165, 0.04, 0.5)));\n  steelDist= min(steelDist, sdBox(p-vec3(-.64, 1.17, 0.0), vec3(0.02, 0.30, 0.02))); \n  vec3 winPos = p-vec3(-.64, 1.10, 0.0);\n  pModInterval1(winPos.y,0.25,0.,1.0);\n  steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.38))); \n  d= min(d, sdBox(p-vec3(-.59, .71, 0.), vec3(0.13, 0.05, 0.45)));\n  d= min(d, sdBox(p-vec3(-.59, 0.69, 0.), vec3(0.18, 0.025, 0.50)));\n\n  // lower decoration \n  d= min(d, sdBox(p-vec3(-0.70, .49, 0.), vec3(0.25, 0.2, 0.07)));   \n  d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.32, .25, 0.), 0.23, 1.63), 0.03);\n  }\n  return d;\n}\n\n\nfloat Window( vec3 p)\n{\n  float d= sdBox(p-vec3(-0.58, 1.17, 0.), vec3(0.075, 0.7, 0.4));\n\n    if(d<2.0)\n    {\n  d = max(d, -sdBox(p-vec3(-0.28, 1.17, 0.), vec3(0.25, 0.67, 0.37)));\n  d= fOpIntersectionChamfer(d, -sdBox(p-vec3(-0.21, 1.17, 0.), vec3(1.3, 0.55, 0.22)), 0.09); \n  d= min(d, sdBox(p-vec3(-0.58, 1.7, 0.), vec3(0.325, 0.06, 0.48)));\n\n  steelDist= min(steelDist, sdBox(p-vec3(-0.55, 1.17, 0.), vec3(0.01, 0.60, 0.02))); \n \n  vec3 winPos = p-vec3(-0.55, 0.80, 0.);\n  pModInterval1(winPos.y,0.30,0.,2.0);        \n  steelDist= min(steelDist, sdBox(winPos, vec3(0.01, 0.02, 0.4))); \n\n  d=min(d, max(max(fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.42, 0.13), -sdBox(p-vec3(-0.5, 1.49, 0.), vec3(1., 0.27, 1.5))), -fCylinderV(p-vec3(-0.5, 1.74, 0.), 0.38, 0.53)));\n\n  d= min(d, sdBox(p-vec3(-.52, .42, 0.), vec3(0.13, 0.05, 0.45)));\n  d= min(d, sdBox(p-vec3(-.52, 0.40, 0.), vec3(0.18, 0.025, 0.50)));\n\n  // lower decoration \n  d= min(d, sdBox(p-vec3(-0.55, .20, 0.4), vec3(0.15, 0.2, 0.05)));   \n  d= min(d, sdBox(p-vec3(-0.55, .20, -0.4), vec3(0.15, 0.2, 0.05)));\n  d = fOpIntersectionChamfer(d, -fCylinder(p-vec3(-0.3, .0, 0.), 0.23, 1.63), 0.02);\n\n  // upper decoration \n  dekoDist=min(dekoDist, sdBox(p-vec3(-0.55, 2.63, 0.), vec3(0.3, 0.45, 0.12)));    \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(p-vec3(-0.22, 2.45, -0.1), 0.21, 0.63), 0.03);\n    }\n  return d;\n}\n\n\nfloat MapStreeLight(  vec3 p)\n{\n  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);\n  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   \n  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        \n  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        \n  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); \n\n  return d;\n}\n\nfloat MapGlass(  vec3 p)\n{  \n  vec3 checkPos = p;\n\n  float dist = sdCappedCylinder(p-vec3(0.0, 5.0, 0), vec2(1.02, .8));\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dist = min(dist, sdBox(checkPos-vec3(1.60, 1.1, 0.), vec3(0.01, .60, 0.35)));   \n  checkPos.xz = pModPolar(p.xz, 5.0);\n  dist = min(dist, sdBox(checkPos-vec3(1.84, -3.33, 0.), vec3(0.01, 0.30, .3))); \n  return min(dist, sdBox(checkPos-vec3(2.12, -6.83, 0.), vec3(0.01, 0.30, .3)));\n}\n\n\n#define radius 1.6\n#define outRad 1.82\n#define inRad 1.12\nvec3 checkPos;\n\nfloat Map(  vec3 p)\n{\n  float  d=100000.0;\n  checkPos = p;\n  winDist=dekoDist=steelDist=100000.0;\n\n  d=sdCappedCylinder(p-vec3(0.0, -3.0, 0), vec2(4.0, 12.45));\n  if(d<1.0)\n  {\n  \n  d = sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45));\n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));\n\n  // lamp\n  d=min(d, sdSphere(p-vec3(0., 4.9, 0), 0.3));\n  d=min(d, sdCappedCylinder(p-vec3(0.0, 4.5, 0), vec2(0.12, 1.2)));\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, 5.8, 0), vec2(inRad, .15)));                  \n  dekoDist =min(dekoDist, sdTorus(p-vec3(0.0, 4., 0), vec2(inRad, .11)));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -.35, 0), vec2(radius-0.05, .15)));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, -.5, 0), radius+0.02, .15));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -0.6, 0), vec2(radius+0.15, .15)));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -1.65, 0), vec2(radius+0.08, .15))); \n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.18, 0), radius+0.35, 0.15));  \n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.7, 0), radius+0.14, .30));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 2.85, 0), radius+0.18, .18));\n  dekoDist=min(dekoDist, fCylinderH(p-vec3(0.0, 3.1, 0), radius+0.22, .18));\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -9., 0), vec2(radius+0.6, .25))); \n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -11.30, 0.), vec2(2.42, 0.25)));     \n\n  // lower border\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -2.35, 0), vec2(radius+0.25, .15)));\n\n  // deko and windows steel top\n  checkPos.xz = pModPolar(p.xz, 12.0);\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(outRad+0.05, 3.6, 0), vec2(0.03, .42)));\n  steelDist=min(steelDist, sdCapsule(checkPos-vec3(inRad-0.06, 4.2, 0), vec3(0, 0., 0), vec3(0, 1.45, 0), 0.02));\n  steelDist=min(steelDist, sdBox(checkPos-vec3(inRad-0.19, 6.25, 0), vec3(0.25, .3, 0.25)));\n  steelDist=fOpIntersectionChamfer(steelDist, -sdBox(checkPos-vec3(inRad+0.20, 6.25, 0), vec3(0.19, 0.24, 0.19)), 0.12);\n\n  // top\n  dekoDist=min(dekoDist, sdCappedCylinder(p-vec3(0.0, 6.2, 0), vec2(inRad, .45)));\n  dekoDist=min(dekoDist, sdSphere(p-vec3(0., 6.5, 0), 1.10));\n  steelDist=min(steelDist, sdCappedCylinder(p-vec3(0.0, 7.5, 0), vec2(0.5, .45)));\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 7.9, 0), 0.45));\n  steelDist=min(steelDist, sdSphere(p-vec3(0., 8.4, 0), 0.10));   \n     \n  vec3 pp = p-vec3(0.0, 4.4, 0);\n  pModInterval1(pp.y,0.4,0.0,2.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(inRad-0.02, .02)));\n      \n  pp = p-vec3(0.0, 3.55, 0);\n  pModInterval1(pp.y,0.15,0.0,3.);          \n  steelDist=min(steelDist, sdTorus(pp, vec2(outRad+0.05, .025)));\n\n  // upper decoration\n  checkPos.xz = pModPolar(p.xz, 6.0);\n  dekoDist = max(dekoDist, -fCylinderV(checkPos-vec3(0.0, 2.4, 0), 0.6, 2.63));\n\n  // windows cutouts   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  d=max(d, -sdBox(checkPos-vec3(2.20, 1.17, 0.), vec3(3.25, 0.7, 0.4))); \n  checkPos.xz = pModPolar(p.xz, 5.0); \n  pp = checkPos-vec3(2.50, -6.83, 0.);\n  pModInterval1(pp.y,3.5,0.0,1.);         \n  d= max(d, -sdBox(pp, vec3(1.3, 0.35, 0.35)));  \n\n  // upper windows   \n  checkPos.xz = pModPolar(p.xz, 6.0);   \n  winDist = min(winDist, Window(checkPos-vec3(2.20, 0, 0.))); \n\n  // middle windows (upper deco)\n  checkPos.xz = pModPolar(p.xz, 5.0); \n  dekoDist=min(dekoDist, sdBox(checkPos-vec3(2.10, -2.44, 0.0), vec3(0.3, 0.4, 0.12)));   \n  dekoDist = fOpIntersectionChamfer(dekoDist, -fCylinder(checkPos-vec3(2.40, -2.04, 0.0), 0.21, 0.63), .03); \n  dekoDist = max(dekoDist, -fCylinder(checkPos-vec3(2.50, -2.62, 0.0), 0.51, 0.63));\n  \n  // middle and lower windows      \n   pp = checkPos-vec3(2.78, -8.0, 0.);\n  float m=pModInterval1(pp.y, 3.5,0.,1.);\n  winDist = min(winDist, SmallWindow(pp+mix(vec3(0.),vec3(0.28,0.0, 0.),m)));   \n\n  // make tower hollow\n  d=max(d, -sdConeSection(p-vec3(0.0, -6.0, 0.), 5., 2.3, 1.55));\n\n  dekoDist=min(dekoDist, sdTorus(p-vec3(0.0, -15.2, 0), vec2(2.5, .75))); \n  dekoDist=min(dekoDist, sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.7, 1.4, 0.4)));    \n  dekoDist=min(dekoDist, fCylinder(p-vec3(-0., -13., 2.5), 0.7, 0.4)); \n\n  // create door opening    \n  float doorOpening = min(sdBox(p-vec3(-0., -14.3, 2.5), vec3(0.6, 1.3, 4.6)), fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));\n\n  dekoDist = min(fOpPipe(dekoDist, doorOpening, 0.13), max(dekoDist, -doorOpening));\n\n  checkPos.xz = pModPolar(p.xz, 8.0);\n  d=fOpIntersectionChamfer(d, -fCylinderH(checkPos-vec3(2.95, -15.4, 0), 0.2, 3.6), 0.5);    \n  checkPos.xz = pModPolar(p.xz, 16.0);\n  d=fOpUnionChamfer(d, fCylinderH(checkPos-vec3(2.2, -10.3, 0), 0.03, 0.8), 0.4);    \n\n  d=max(d, -sdBox(p-vec3(-0., -14.3, 2.7), vec3(0.6, 1.3, 4.6)));    \n  d=max(d, -fCylinder(p-vec3(-0., -13., 2.5), 0.6, 4.6));    \n\n  // door   \n  d=min(d, sdBox(p-vec3(-0., -13.6, 2.0), vec3(0.6, 1.3, 0.4))); \n    \n  // door cutout     \n  pp = p-vec3(-0.28, -13.3, 2.4);\n  pModInterval1(pp.x, 0.56,0.,1.);     \n  d=max(d, -sdBox(pp, vec3(0.25, 0.25, 0.08)));   \n  pp = p-vec3(-0.28, -14.1, 2.4);\n  pModInterval1(pp.x, 0.56,0.,1.);     \n  d=max(d, -sdBox(pp, vec3(0.25, 0.4, 0.08))); \n\n  dekoDist=max(dekoDist, -sdBox(p-vec3(-0., -16.2, 0), vec3(6.6, 1.3, 8.6)));  \n  }\n    \n  \n  // railing (platform) \n  checkPos.xz = pModPolar(p.xz, 32.0);   \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   \n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));\n  checkPos.xz = pModPolar(p.xz, 7.0); \n  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  \n  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));   \n  steelDist=max(steelDist, -sdBox(p-vec3(0.0, -16.05, 0), vec3(16.6, 1.2, 16.6)));  \n    \n  return  min(d, min(steelDist, min(dekoDist, winDist)));\n}\n\n\nvec3 calcNormal(  vec3 pos )\n{    \n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\n\nvec3 calcNoiseNormal(  vec3 pos )\n{    \n  return normalize( vec3(fbm(pos+eps.xyy) - fbm(pos-eps.xyy), 0.5*2.0*eps.x, fbm(pos+eps.yyx) - fbm(pos-eps.yyx) ) );\n}\n\nfloat SoftShadow(  vec3 origin,  vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<32; i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 6.5*h/t );\n    t += clamp( h, 0.07, 0.6 );\n    if ( h<0.0025 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\n\nRayHit March( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 70.0;\n  float t = 0.0, glassDist = 10000.0, dist = 0.0;\n  vec3 rayPos;\n\n  for ( int i=0; i<200; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n    glassDist=min(glassDist, MapGlass( rayPos));\n\n    if (abs(dist)<0.001 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steps = float(i);\n      result.winDist = winDist;\n      result.glassDist = glassDist;\n      result.dekoDist = dekoDist;\n      result.steelDist = steelDist;\n      break;\n    }\n    t += dist;\n  }    \n   \n\n  return result;\n}\n// Copyright © 2015 Inigo Quilez\nvec3 CubeMap( sampler2D sam, in vec3 d )\n{\n    vec3 n = abs(d);\n\n#if 0\n    // sort components (small to big)    \n    float mi = min(min(n.x,n.y),n.z);\n    float ma = max(max(n.x,n.y),n.z);\n    vec3 o = vec3( mi, n.x+n.y+n.z-mi-ma, ma );\n    return texture( sam, .1*o.xy/o.z ).xyz;\n#else\n    vec2 uv = (n.x>n.y && n.x>n.z) ? d.yz/d.x: \n              (n.y>n.x && n.y>n.z) ? d.zx/d.y:\n                                     d.xy/d.z;\n    return texture( sam, uv ).xyz;\n    \n#endif    \n}\n\nmat3 setCamera( vec3 ro,  vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n// Copyright © 2013 Inigo Quilez\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = Map( aopos );\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{        \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.99);  \n  dif *= SoftShadow( shadowPos, sunPos);\n  skylight *=SoftShadow(shadowPos, reflectDir);\n\n  vec3 lightTot = vec3(0.0);\n\n    \n    \n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));\n}\n\n\n\n\nvec4 GetMaterial( vec3 rayDir, inout RayHit rayHit)\n{\n  vec3 col = vec3(0.6);\n  float specLevel=1.30;\n\n  // windows\n  if (rayHit.winDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, rayHit.hitPos*.1).rgb*0.8; \n    col = vec3(0.9);\n    col = mix(col, dirt, fbm(rayHit.hitPos*1.71)); \n    specLevel = 0.4;\n  } \n  // decorations\n  else if (rayHit.dekoDist==rayHit.dist)\n  {    \n    col=vec3(0.6);\n    vec3 moss =  CubeMap(iChannel3, rayHit.hitPos*0.22).rgb*vec3(0.356, 0.455, 0.228);\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44)).rgb*1.5; \n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71)); \n    col = mix(col, moss, pow(fbm(rayHit.hitPos*0.71), 1.5)); \n    col = mix(col, moss, smoothstep(0.55+fbm(rayHit.hitPos*0.51), -.4, rayHit.winDist));\n    rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*10.9))*0.5, 0.25);\n    specLevel = 2.3;\n  } \n  // steel \n  else if (rayHit.steelDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44)).rgb*1.5; \n    col = vec3(0.3+(fbm(rayHit.hitPos*1.71)*.5));\n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71));         \n    specLevel = 6.0;\n  } \n  // tower base texture\n  else\n  {\n    vec3 moss =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*0.22).rgb*vec3(0.356, 0.455, 0.228);\n    vec3 dirt =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*.44).rgb*1.5; \n    // top part\n    if (rayHit.hitPos.y>-11.1)\n    {     \n      col=vec3(0.9);\n      col = mix(col, dirt*0.7, fbm(rayHit.hitPos*.71)); \n      col = mix(col, moss, smoothstep(-9., -11.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));  \n      col = mix(col, dirt, smoothstep(2.1+fbm(rayHit.hitPos*0.71), -.40, pow(rayHit.dekoDist, 3.00)));   \n      col = mix(col, dirt, smoothstep(1.1+fbm(rayHit.hitPos*0.51), -.4, pow(rayHit.winDist, 2.50)));\n      col = mix(dirt, col, smoothstep(2.0, 1.3, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));  \n      rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*10.))*0.5, 0.15);\n    } \n    // lower part\n    else\n    {\n      vec3 tex2 =  texture(iChannel3, vec2(atan(rayHit.hitPos.z,rayHit.hitPos.x)*2.0, rayHit.hitPos.y)*0.8).rgb;\n      col=mix(moss, tex2, 0.5);\n      col = mix(col, dirt*0.7, fbm(rayHit.hitPos*.21));\n      col = mix(moss, col, smoothstep(-10., -12.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71)));\n      col = mix(col, moss, smoothstep(-13., -15.01, rayHit.hitPos.y+fbm(rayHit.hitPos*3.71))); \n      rayHit.normal = mix(rayHit.normal, (rayHit.normal+calcNoiseNormal(rayHit.hitPos*8.))*0.5, 0.15);\n    }\n  }\n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  float camrot = 20.0+(iTime*0.2);\n  if (iMouse.w>0.1) camrot+=mo.x*16.; \n\n  vec3 rayOrigin = vec3(8.*cos(camrot), 1.+12.*sin(camrot*1.8), 13.5 + 24.0*sin(camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., -6., 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 skyColor = texture(iChannel0, uv).rgb;\n  vec3 color = skyColor;\n\n  RayHit marchResult = March(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n    vec4 col = GetMaterial(rayDir, marchResult);\n\n    // get lightning based on material\n    vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin);   \n    // apply lightning\n    color = col.rgb*light;\n  }\n\n    color = mix(mix(color, skyColor, 0.5),color,step(0.05,marchResult.glassDist));\n  \n\n  color = mix(color, skyColor, smoothstep(40., 140., marchResult.depth));  \n\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );  \n  color += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)/0.4, 0.0, 0.4);\n\n  fragColor = vec4(pow(color.rgb, vec3(1.0/1.1)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//////////////////////////////////////////////////////////////////////////////////////\n///////////////////// CREATED BY KIM BERKEBY, SEP 2017 ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n////////////////////// SPECIAL THANKS TO Inigo Quilez  ///////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////// Feel free to mail me at mr.kimb@hotmail.com /////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n#define WATER_LOD 0.27\n#define PI 3.14159265\n  #define TAU (2.*PI)\n  #define PHI (sqrt(5.)*0.5 + 0.5)\n  #define M_NONE -1.0\n  #define M_NOISE 1.0\n  #pragma optimize(off) \n  const vec3 sunPos = normalize(vec3(5.3, 2.7, -1.));\nconst vec3 sunColor = vec3(0.80, 0.7, 0.55);         \nconst vec3 eps = vec3(0.02, 0.0, 0.0);\nfloat steelDist=100000.0;\nfloat terrainDist=100000.0;\nfloat platformDist=100000.0;\nfloat waterDist=100000.0;\n\nstruct RayHit\n{\n  bool hit;  \n  vec3 hitPos;\n  vec3 normal;\n  float dist;\n  float depth;\n  float steelDist;\n  float terrainDist;\n  float platformDist;\n  float waterDist;\n};\n\nfloat hash(float h) \n{\n  return fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) \n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n\n  float n = p.x + p.y * 157.0 + 113.0 * p.z;\n  return mix(\n    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x), \n    mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y), \n    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x), \n    mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\nfloat noise2D( in vec2 pos , float lod)\n{\n  vec2 f = fract(pos);\n  f = f*f*(3.0-2.0*f);\n  vec2 rg = textureLod( iChannel1, (((floor(pos).xy+vec2(37.0, 17.0)) + f.xy)+ 0.5)/256.0, lod).yx;  \n  return -1.0+2.0*mix( rg.x, rg.y, 0.5 );\n}\nfloat noise2D( in vec2 pos )\n{\nreturn noise2D(pos,0.0);\n}\n\nvec3 calcWaterNormal( vec2 pos, float res )\n{   \n  return normalize(vec3(noise2D((pos + vec2(-0.001, 0))* res,WATER_LOD)-noise2D((pos + vec2(+0.001, 0))* res,WATER_LOD), noise2D((pos + vec2(0, -0.001))*res,WATER_LOD)-noise2D((pos + vec2(0, +0.001))* res,WATER_LOD), .005)) * 0.5 + 0.5;\n}\n\nfloat fbm(vec3 p) \n{\n  float f = 0.0;\n  f = 0.5000 * noise(p);\n  p *= 2.01;\n  f += 0.2500 * noise(p);\n  p *= 2.02;\n  f += 0.1250 * noise(p);\n  return f;\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2 )\n{\n  float d1 = -p.y - h;\n  float q = p.y - h;\n  float si = 0.5*(r1-r2)/h;\n  float d2 = max( sqrt( dot(p.xz, p.xz)*(1.0-si*si)) + q*si - r2, q );\n  return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n  float d = length(p.xy) - r;\n  d = max(d, abs(p.z) - height);\n  return d;\n}\n\nfloat fCylinderH(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat fCylinderV(vec3 p, float r, float height) {\n  float d = length(p.yz) - r;\n  d = max(d, abs(p.x) - height);\n  return d;\n}\n\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n  vec3 q = abs(p);\n  return max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n  return length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n  return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n  return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nvec2 pModPolar(vec2 p, float repetitions) {\n  float angle = 2.*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a, angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  if (abs(c) >= (repetitions/2.)) c = abs(c);\n  return p;\n}\n\nfloat pModSingle1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  if (p >= 0.)\n    p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n\nfloat MapTerrain( vec3 p)\n{\n  return   p.y+18.5-mix(\n    (textureLod(iChannel0, p.xz*0.001, 0.0).r*1.2) + \n    (textureLod(iChannel0, p.xz*0.01, 0.0).r*.7) + \n    (textureLod(iChannel0, p.xz*0.075, 0.0).r*0.91), \n    0., smoothstep(8.0, 18.0, min(distance(p, vec3(0.0, -17.3, 0.)), distance(p, vec3(10.5, -17.3, 2.))*3.5)));\n}\n\nfloat MapStreeLight(vec3 p)\n{\n  float d= fCylinder(p-vec3(0.31, -3.5, 0.), 0.7, 0.01);\n  d=fOpPipe(d, fCylinder(p-vec3(.31, -4., 0.), 0.7, 3.0), .05);   \n  d=min(d, fCylinderH(p-vec3(.98, -6.14, 0.), 0.05, 2.4));        \n  d=fOpUnionChamfer(d, fCylinderH(p-vec3(.98, -8., 0.), 0.1, 1.0), 0.12);  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.4, 0.), 0.2));  \n  d=min(d, sdSphere(p-vec3(-0.05, -3.75, 0.), 0.4));        \n  d=max(d, -sdSphere(p-vec3(-.05, -3.9, 0.), 0.45)); \n\n  return d;\n}\n\n\nconst float radius =1.6;\nconst float outRad = 1.82;\nconst float inRad = 1.12;\nvec3 checkPos;\n\nfloat Map(vec3 p)\n{\n  float  d=100000.0;\n  checkPos = p;\n  steelDist=platformDist=waterDist=terrainDist=100000.0;\n\n  d=min(d, sdCappedCylinder(p-vec3(0.0, 3.7, 0), vec2(inRad, .45)));\n  d=min(d, sdSphere(p-vec3(0., 4., 0), 0.50));\n  d=min(d, fCylinderH(p-vec3(0.0, 1.3, 0), radius, 1.80));\n  d=min(d, sdConeSection(p-vec3(0.0, -6.0, 0.), 5.3, 2.4, 1.7));\n  d=min(d, sdConeSection(p-vec3(0.0, -13.0, 0.), 1.8, 2.8, 2.6));\n    \n  if(sdCappedCylinder(p-vec3(0.0, -19.0, 0), vec2(22.0, 7.))<10.0)\n  {\n  // platform \n  platformDist = fHexagonCircumcircle(p-vec3(0.0, -16.05, 0), vec2(radius+8.2, 1.4));  \n  platformDist=fOpUnionChamfer(platformDist, fHexagonCircumcircle(p-vec3(0.0, -15.05, 0), vec2(radius+8.7, 0.15)), 0.25);  \n\n  checkPos.xz = pModPolar(p.xz, 12.0);   \n  platformDist= min(platformDist, fHexagonCircumcircle(p-vec3(0.0, -16.42, 0), vec2(radius+8.3, 0.2)));  \n  platformDist=fOpIntersectionChamfer(platformDist, -sdBox(checkPos-vec3(radius+8.8, -16.55, 0.), vec3(1.0, 1., 1.8)), 0.1); \n  platformDist=fOpIntersectionChamfer(platformDist, -sdCappedCylinder(p-vec3(0., -14.4, 0), vec2(radius+7.4, .25)), 0.5);   \n\n  // railing (platform) \n  checkPos.xz = pModPolar(p.xz, 32.0);   \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(radius+8., -14.4, 0), vec2(0.05, .46)));   \n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.2, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -14.35, 0), vec2(radius+8., 0.02)));\n  steelDist=min(steelDist, sdTorus(p-vec3(0., -13.9, 0), vec2(radius+8., 0.04)));\n\n  checkPos.xz = pModPolar(p.xz, 7.0); \n  steelDist = min(steelDist, MapStreeLight(checkPos-vec3(radius+6.7, -6.63, 0)));  \n  steelDist=max(steelDist, -sdBox(p-vec3(13.3, 0., 0.), vec3(6.6, 22.5, 3.7)));      \n  platformDist=max(platformDist, -sdBox(p-vec3(13.3, -12.5, 0.), vec3(4.6, 12.5, 3.5)));   \n       \n  terrainDist = MapTerrain(p);\n  }\n  \n  checkPos = p-vec3(11.70, -15.8, 0); \n    \n  pModSingle1(checkPos.x, 6.); \n  if(sdBox(checkPos-vec3(0,-1.0, 0), vec3(3.6, 2.3, 4.))<6.0)\n  {\n  float bridge = sdBox(checkPos-vec3(0, 0.8, 0), vec3(3.0, 0.1, 3.6)); \n  bridge=fOpUnionChamfer(bridge, sdBox(checkPos+vec3(0, 1., 0), vec3(3.0, 1.9, 3.3)), 0.15);   \n  bridge=fOpIntersectionChamfer(bridge, -sdBox(checkPos-vec3(0, 0.9, 0), vec3(6.0, 0.2, 3.3)), 0.10); \n  bridge=min(fOpPipe(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6), 0.15), max(bridge, -fCylinder(checkPos+vec3(0, 2.65, 0), 3., 4.6)));\n  platformDist = min(platformDist, bridge);\n\n    \n  // railing (bridge)\n  checkPos = p-vec3(9.50, -14.42, 0.); \n  pModSingle1(checkPos.x, 2.); \n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, 3.5), vec2(0.05, .45)));              \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, 3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, 3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, 3.5), 0.04, 29.45));  \n\n  steelDist=min(steelDist, sdCappedCylinder(checkPos-vec3(0, 0, -3.5), vec2(0.05, .45)));                    \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.4, -3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(39.0, -14.55, -3.5), 0.02, 29.45));  \n  steelDist=min(steelDist, fCylinderV(p-vec3(38.90, -13.95, -3.5), 0.04, 29.45));  \n  }\n\n \n  waterDist = p.y+17.5;\n\n  return  min(d, min(waterDist, min(terrainDist, min(platformDist, steelDist))));\n}\n\n\nvec3 calcNormal(  vec3 pos )\n{    \n  return normalize( vec3(Map(pos+eps.xyy) - Map(pos-eps.xyy), 0.5*2.0*eps.x, Map(pos+eps.yyx) - Map(pos-eps.yyx) ) );\n}\nvec3 calcTexNormal(in sampler2D sam, in vec2 pos )\n{    \n  return normalize(vec3(textureLod(sam, pos + vec2(-0.001, 0),0.0).r-textureLod(sam, pos + vec2(+0.001, 0),0.0).r, textureLod(sam, pos + vec2(0, -0.001),0.0).r-textureLod(sam, pos + vec2(0, +0.001),0.0).r, .03)) * 0.5 + 0.5;\n}\nvec3 calcNoiseNormal(  vec3 pos )\n{    \n  return normalize( vec3(fbm(pos+eps.xyy) - fbm(pos-eps.xyy), 0.5*2.0*eps.x, fbm(pos+eps.yyx) - fbm(pos-eps.yyx) ) );\n}\n\n\nfloat SoftShadow(  vec3 origin,  vec3 direction )\n{\n  float res = 2.0, t = 0.0, h;\n  for ( int i=0; i<32; i++ )\n  {\n    h = Map(origin+direction*t);\n    res = min( res, 6.5*h/t );\n    t += clamp( h, 0.07, 0.6 );\n    if ( h<0.0025 ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n\nRayHit MarchReflection( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 90.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n \n  for ( int i=0; i<32; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n \n\n    if (abs(dist)<0.05 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steelDist = steelDist;\n      result.platformDist = platformDist;\n      result.terrainDist =terrainDist;\n      result.waterDist =waterDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\nRayHit March( vec3 origin,  vec3 direction)\n{\n  RayHit result;\n  float maxDist = 380.0;\n  float t = 0.0, dist = 0.0;\n  vec3 rayPos;\n \n  for ( int i=0; i<200; i++ )\n  {\n    rayPos =origin+direction*t;\n    dist = Map( rayPos);\n \n\n    if (dist<0.01 || t>maxDist )\n    {             \n      result.hit=!(t>maxDist);\n      result.depth = t; \n      result.dist = dist;                              \n      result.hitPos = origin+((direction*t));   \n      result.steelDist = steelDist;\n      result.platformDist = platformDist;\n      result.terrainDist =terrainDist;\n      result.waterDist =waterDist;\n      break;\n    }\n    t += dist;\n  }\n\n  return result;\n}\n\n\nvec4 CubeMap( sampler2D sam,  vec3 hitPos,  vec3 n,  float k)\n{ \n    vec3 m = pow( abs( n ), vec3(k) );\n\tvec4 x = textureLod( sam, hitPos.yz,2. );\n\tvec4 y = textureLod( sam, hitPos.zx, 2. );\n\tvec4 z = textureLod( sam, hitPos.xy, 2. );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\nmat3 setCamera(  vec3 ro,  vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  return mat3( cu, cv, cw );\n}\n\n\nvec3 GetSkyColor( vec2 screenSpace,  vec3 rayDir,  vec3 rayOrigin)\n{\n\n  vec3 skyColor = mix(vec3(0.6, 0.7, 0.8), vec3(0.9), smoothstep(1.0, -.0, screenSpace.y)); \n  skyColor =  mix(skyColor, vec3(0.6, 0.7, 0.8), smoothstep(-0., -1., screenSpace.y*1.1));\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );\n  skyColor += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)/0.4, 0.0, 1.0);\n\n  float cloudScale = (200.0-rayOrigin.y)/abs(rayDir.y);\n    if(cloudScale>0.05)\n    {\n  vec2 cloudUV = ((rayOrigin+cloudScale*rayDir).xz+ vec2(iTime*12.4, iTime*7.2))*.00009;\n  vec3  cloudNormal = calcTexNormal(iChannel2, cloudUV);\n  float cloudShade = clamp( dot( cloudNormal, sunPos ), 0.0, .6 );\n  skyColor = mix(skyColor,mix( skyColor, vec3(1.)*cloudShade, pow(texture( iChannel2, cloudUV).x, 3.)),smoothstep(0. ,0.2, abs(distance(0.,rayDir.y))));\n            }\n    return skyColor;\n}\n\n\n\n\nvec3 GetSceneLight(float specLevel, vec3 normal, RayHit rayHit, vec3 rayDir, vec3 origin)\n{        \n  vec3 reflectDir = reflect( rayDir, normal );\n\n  float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n  float dif = clamp( dot( normal, sunPos ), 0.0, 1.0 );\n  float bac = clamp( dot( normal, normalize(vec3(-sunPos.x, 0.0, -sunPos.z))), 0.0, 1.0 )*clamp( 1.0-rayHit.hitPos.y, 0.0, 1.0);\n  float fre = pow( clamp(1.0+dot(normal, rayDir), 0.0, 1.0), 2.0 );\n  specLevel*= pow(clamp( dot( reflectDir, sunPos ), 0.0, 1.0 ), 16.0);\n\n  float skylight = smoothstep( -0.1, 0.1, reflectDir.y );\n  vec3 shadowPos = origin+((rayDir*rayHit.depth)*0.98);  \n  dif *= SoftShadow( shadowPos, sunPos);\n  skylight *=SoftShadow(shadowPos, reflectDir);\n\n  vec3 lightTot = vec3(0.0);\n\n    \n    \n  lightTot += 1.30*dif*vec3(1.00, 0.80, 0.55);\n  lightTot += 0.50*skylight*vec3(0.40, 0.60, 1.00);\n      lightTot += 1.20*specLevel*vec3(0.9, 0.8, 0.7)*dif;\n  lightTot += 0.50*bac*vec3(0.25, 0.25, 0.25);\n  lightTot += 0.25*fre*vec3(1.00, 1.00, 1.00);\n  return lightTot +(0.40*amb*vec3(0.40, 0.60, 1.00));\n}\n\n\nvec4 GetMaterial( vec3 rayDir, inout RayHit rayHit)\n{\n  vec3 col = vec3(0.6);\n  float specLevel=1.30;\n  \n  // steel \n  if (rayHit.steelDist==rayHit.dist)\n  {\n    vec3 dirt =  CubeMap(iChannel3, (rayHit.hitPos*.44), rayHit.normal, 4.0).rgb*1.5; \n    col = vec3(0.3+(fbm(rayHit.hitPos*1.71)*.5));\n    col = mix(col, dirt*0.7, fbm(rayHit.hitPos*10.71));         \n    specLevel = 6.0;\n  }\n  //stones and terrain \n  else if (rayHit.terrainDist==rayHit.dist)\n  {\n    vec3 moss =  CubeMap(iChannel3, rayHit.hitPos*0.22, rayHit.normal, 4.0).rgb*vec3(0.356, 0.455, 0.228);\n    col  =  CubeMap(iChannel3, (rayHit.hitPos*.44), rayHit.normal, 4.0).rgb; \n    col = mix( col, vec3(0.7), reflect( rayDir, rayHit.normal ).x);\n    col = mix(col, moss, smoothstep(-16.5, -18., rayHit.hitPos.y));\n    specLevel = .90;\n  } \n\n  // platform and bridge  \n  else if (rayHit.platformDist==rayHit.dist)\n  {\n    \n    vec3 dirt =  vec3(fbm(rayHit.hitPos*.41)); \n    vec3 dirt2 =  CubeMap(iChannel3, rayHit.hitPos*0.07, rayHit.normal, 4.0).rgb;  \n    vec3 dirt3 =  CubeMap(iChannel3, rayHit.hitPos*.002, rayHit.normal, 4.0).rgb;            \n    vec3 bNormal = calcNoiseNormal(rayHit.hitPos*15.)*0.55;\n    col = mix(mix(dirt2, dirt, 0.3), dirt3, 0.5);\n    col = mix(col, vec3(fbm(rayHit.hitPos*2.3)*0.3), smoothstep(-15.5, -18.01, rayHit.hitPos.y));          \n    specLevel=col.r*fbm(rayHit.hitPos*20.);       \n    rayHit.normal = mix(rayHit.normal, (rayHit.normal+bNormal)*0.5, 0.15);\n  \n  } \n\n  return vec4(col, specLevel);\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{  \n  vec2 mo = iMouse.xy/iResolution.xy;\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 screenSpace = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n\n  float camrot = 20.0+(iTime*0.2);\n  if (iMouse.w>0.1) camrot+=mo.x*16.; \n\n  vec3 rayOrigin = vec3(8.*cos(camrot), 1.+12.*sin(camrot*1.8), 13.5 + 24.0*sin(camrot) );\n  mat3 ca = setCamera( rayOrigin, vec3(0., -6., 0.5 ), 0.0 );\n  vec3 rayDir = ca * normalize( vec3(screenSpace.xy, 2.0) );\n\n  vec3 skyColor = GetSkyColor(screenSpace, rayDir, rayOrigin);\n  vec3 color = skyColor;\n\n  RayHit marchResult = March(rayOrigin, rayDir);\n\n  if (marchResult.hit)\n  {\n    marchResult.normal = calcNormal(marchResult.hitPos);  \n\n    vec4 col;\n\n    // water\n    if (marchResult.waterDist==marchResult.dist)\n    {       \n      col = vec4(skyColor*0.35, 12.90); \n      vec3 waterNormal = ((calcWaterNormal(marchResult.hitPos.xz + vec2(-iTime*0.4, -iTime*0.2), 1.66))*(calcWaterNormal(marchResult.hitPos.xz + vec2(iTime*0.4, iTime*0.2), 3.61)));      \n    marchResult.normal = (vec3(0.0, 1.0, 0.0)+waterNormal)*0.4;\n\n        \n      vec3 ref = normalize(reflect(rayDir, marchResult.normal));\n      RayHit reflectResult = MarchReflection(marchResult.hitPos + (ref*0.002), ref); \n\n      // draw reflected objects and mix with water color\n      if (reflectResult.hit==true)\n      {   \n          // advanced reflections\n\n         //  reflectResult.normal = calcNormal(reflectResult.hitPos); \n          // col.rgb = mix(col.rgb, GetMaterial(ref, reflectResult).rgb, 0.5);\n    \n          // fake reflections\n          col.rgb = mix(col.rgb, vec3(0.5).rgb, 0.5);\n     \n      }\n      marchResult.normal=(vec3(0.0, 1.0, 0.0)+waterNormal)*0.5;\n    }\n    // above water level\n    else\n    {\n      col = GetMaterial(rayDir, marchResult);\n    }\n\n    // get lightning based on material\n    vec3 light = GetSceneLight(col.a, marchResult.normal, marchResult, rayDir, rayOrigin);   \n\n    // apply lightning\n    color = col.rgb*light;\n        color = mix(color, skyColor, smoothstep(100., 200., marchResult.depth));  \n\n  }\n\n\n  float sun = clamp( dot(sunPos, rayDir), 0.0, 1.0 );  \n  color += vec3(.9, 0.4, 0.2)*sun*sun*clamp((rayDir.y+0.4)/0.4, 0.0, 0.4);\n\n  fragColor = vec4(pow(color.rgb, vec3(1.0/0.9)), 1.0 ) * (0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.2 ));\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 46,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 48,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg"
                    }
                ],
                "name": "Buf A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}