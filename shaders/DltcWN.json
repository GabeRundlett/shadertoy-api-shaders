{
    "Shader": {
        "info": {
            "date": "1699219227",
            "description": "Render complex mountain combined with sky light, mountain fog, cloud\nBased on [url=https://www.shadertoy.com/view/NscGWl]this terrain[/url]",
            "flags": 8,
            "hasliked": 0,
            "id": "DltcWN",
            "likes": 10,
            "name": "render desert cloud",
            "published": 3,
            "tags": [
                "noise",
                "fbm",
                "music",
                "mountainsdf"
            ],
            "usePreview": 0,
            "username": "jarble",
            "viewed": 333
        },
        "renderpass": [
            {
                "code": "/**\n    Render complex mountain combined with sky light, mountain fog, cloud\n*/\n\n#define ROTATE_MATRIX mat2(0.6, -0.8, 0.8, 0.6)\n#define PIXEL_COORD_REDUCTION_FACTOR 0.003         \n#define MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR 120.0*8.\n#define RAYMARCH_ITER_COUNT 256\n#define RAYMARCH_ITER_PRECISION 1e-4\n#define SOFTSHADOW_ITER_COUNT 80\n\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat random(in vec2 p) {\n    vec2 q = 55.1876653 * fract(p * 10.1321513);\n    return fract((q.x + q.y) * q.x * q.y);\n}\n\n// return noise value and noise gradient\nvec3 noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * f * (1.0 - f);\n\n    vec2 offset = vec2(1.0, 0.0);\n    float a = random(i);\n    float b = random(i + offset.xy);\n    float c = random(i + offset.yx);\n    float d = random(i + offset.xx);\n\n    float noiseV = a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y;\n    vec2 noiseG = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);\n    return vec3(noiseV, noiseG);\n}\n\nvec2 fluid(vec2 uv){\n //add some turbulence\n for (float i = 1.; i < 4.; i++)\n  {\n    float i1 = i/2.;\n    float s2 = (cos(uv.x*i1)/i1)/2.;\n    float s1 = (sin(uv.y*i1)/i1+iTime/i1/i1)/2.;\n    uv.x += s1;\n    uv.y += s2;\n  }\n  return uv;\n}\n\n// Fractal Brownian motion: generator cloud\nfloat fbm(vec2 p) {\n    p = fluid(p);\n    float res = 0.0;\n    float factor = 0.5;\n    for (int i = 0; i < 4; i++) {\n        res += factor * noise(p).x;\n        p = ROTATE_MATRIX * p * 2.0;\n        factor *= 0.5;\n    }\n    return res;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n\nfloat fbm(in vec2 uv,int octaves)\n{\n    //uv /= 2.;\n    //this function generates the terrain height\n    //uv *= .75;\n    float value = 0.;\n    float amplitude = .75,n2=0.;\n    //amplitude /= 16.;\n    vec2 n1 = vec2(0.);\n    mat2 r = rotate2D(12.);\n    float terrain_scale = 16.;\n    uv *= terrain_scale;\n    vec2 uv1 = uv;\n        \n        \n\n        \n    for (int i = 0; i < octaves; i++)\n    {\n        \n\n        //domain warping\n        float u1 = 2.;\n        for(int i = 0; i < 3; i++){\n            vec2 s3 = vec2(sin(uv.x/u1*amplitude+u1),cos(uv.y/u1*amplitude+u1));\n            n1 += s3.x*amplitude;\n            uv += s3*r;\n            u1 *= 2.;\n        }\n        \n        \n        \n        \n        n1 =\n            //vec2(sin(uv.x+cos(uv.y*.37)/.37),cos(uv.y+sin(uv.x*.37)/.37))\n            //vec2(sin(uv.x-n1.y*value),cos(uv.y-n1.x*value))\n            //vec2(sin(uv.x),cos(uv.y))\n            //vec2(sin(uv.x),cos(uv.y))*r //badlands\n            //(vec2(sin(uv.x),cos(uv.y))+n1)/2.\n            (n1+abs(n1-vec2(sin(uv.x),cos(uv.y))))/2.\n        ;\n        uv1 = uv;\n        n2 =\n            n1.x+n1.y\n            //((n1.x+n1.y)-n2)\n            //n1.x+n1.y+n2*.37\n        ;\n        value -=\n            abs(n2)*amplitude\n            //abs(n2-value) * amplitude\n        ;\n        \n        //waves\n        //value += sin(uv.x/1000.+iTime)/10.;\n        \n        //erosion\n        value = sqrt(value*value+.0001);\n        \n        amplitude *= .37;\n        \n        //This makes it somewhat more realistic\n        //amplitude *= (1.+sin(uv.x/4.)/4.);\n\n        uv = \n            //uv*2.05*r+vec2(0.,n2)\n            uv*2.0*r+n1\n        ;\n        //r = rotate2D(12.+(n2)*value/8.);\n    }\n    \n    return value/terrain_scale;\n}\n\n// Low precision mountain sdf, use to determine the position of camera\nfloat sdfMountainLowPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,4)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\n// Mid precision mountain sdf, use to raymarch \nfloat sdfMountainMidPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,8)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\nfloat sdfMountainHighPrecision(in vec2 p) {\n    p *= PIXEL_COORD_REDUCTION_FACTOR;\n    return fbm(p,8)*MOUNTAIN_HEIGHT_AMPLIFICATION_FACTOR;\n}\n\nvec3 calNormal(vec3 p, float t) {\n    vec2 delta = vec2(1e-3 * t, 0.0);\n    float px = sdfMountainHighPrecision(p.xz - delta.xy) - sdfMountainHighPrecision(p.xz + delta.xy);\n    float py = 2.0 * delta.x;\n    float pz = sdfMountainHighPrecision(p.xz - delta.yx) - sdfMountainHighPrecision(p.xz + delta.yx);\n    return normalize(vec3(px, py, pz));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i = 0; i < RAYMARCH_ITER_COUNT; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - sdfMountainMidPrecision(p.xz);\n        if (abs(h) < t * RAYMARCH_ITER_PRECISION || t > tmax) {\n            break;\n        }\n        t += 0.4 * h;\n    }   \n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float dis) {\n    float minStep = clamp(0.01 * dis, 0.5, 50.0);\n    float res = 1.0;\n    float t = 0.001;\n    for (int i = 0; i < SOFTSHADOW_ITER_COUNT; i++) {\n        vec3 p = ro + t * rd;\n        float h = p.y - sdfMountainMidPrecision(p.xz);\n        res = min(res, 8.0 * h / t);\n        t += max(minStep, h);\n        if (res < 0.001 || p.y > 200.0) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0.0);\n\n    vec3 baseSkyCol = vec3(0.3, 0.5, 0.85);\n    vec3 baseGraySkyBandCol = vec3(0.7, 0.75, 0.85);\n    vec3 baseSunCol1 = vec3(1.0, 0.7, 0.4);\n    vec3 baseSunCol2 = vec3(1.0, 0.8, 0.6);\n    vec3 baseSunCol3 = vec3(1.0, 0.8, 0.7);\n    float sunCol1Weight = 0.25;\n    float sunCol2Weight = 0.25;\n    float sunCol3Weight = 0.2;\n\n    vec3 cloudCol = vec3(1.0, 0.95, 1.0);\n    float cloudSparsity = 0.01;\n    float cloudH = 300.0;\n    \n    vec3 baseMountainCol = vec3(0.67, 0.57, 0.44);\n    vec3 baseMountainFogCol = vec3(0.5, 0.75, 1.0);\n\n    vec3 softShadowAmplificationCof = vec3(8.0, 5.0, 3.0); \n    vec3 ambientColComponentCof = vec3(0.4, 0.6, 1.0);\n    vec3 backgroundCompoentCof = vec3(0.4, 0.5, 0.6);\n\n    float angle = 0.05 * iTime;\n    float r = 300.0;\n    float forward_offset = 0.01;\n    vec2 px2 = vec2(r * sin(angle), r * cos(angle));\n    float h = sdfMountainLowPrecision(px2) + 25.0;\n    vec3 lookAt = vec3(r * sin(angle + forward_offset), h, r * cos(angle + forward_offset));\n    vec3 ro = vec3(px2.x, h, px2.y);\n    float focus_distance = 1.0;\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n\n    float tmin = 0.01;    // minimum iter distance of raymarch\n    float tmax = 1000.0;  // maximum iter distance of raymarch\n    float maxH = 300.0;   // maximum height of mountain\n    \n    // optimize: determine tmax and tmin by maximum height of mountain \n    float curMaxDistance = (maxH - ro.y) / rd.y; // distance of ro to highest mountain position\n    if (curMaxDistance > 0.0) {\n        if (maxH > ro.y) {\n            tmax = min(tmax, curMaxDistance);\n        } else {\n            tmin = max(tmin, curMaxDistance);\n        }\n    }\n    \n    vec3 sunDir = normalize(vec3(0.8, 0.5, -0.2));\n    float sunDot = clamp(dot(sunDir, rd), 0.0, 1.0);\n    float t = rayMarch(ro, rd, tmin, tmax);\n    \n    float difCof = 0.1;\n\n    // rendering\n    if (t < tmax) {\n        // rendering mountain\n        vec3 p = ro + t * rd;\n        vec3 n = calNormal(p, t);\n        vec3 difCol = difCof * baseMountainCol;\n        col = difCol; \n\n        vec3 linearColCof = vec3(0.0);\n        float difDot = clamp(dot(n, sunDir), 0.0, 1.0);\n        float softShadowCof = softShadow(p + 0.01 * sunDir, sunDir, t);\n        float softCofX = softShadowCof;\n        float softCofY = softShadowCof * softShadowCof * 0.5 + softShadowCof * 0.5;\n        float softCofZ = softShadowCof * softShadowCof * 0.8 + softShadowCof * 0.2;\n        float ambientCof = clamp(0.5 + 0.5 * n.y, 0.0, 1.0); // ambient occlusion cof\n        float backgroundCof = clamp(0.2 + 0.8 * dot(vec3(-sunDir.x, 0.0, sunDir.z), n), 0.0, 1.0);\n        linearColCof += difDot * softShadowAmplificationCof * vec3(softCofX, softCofY, softCofZ);\n        linearColCof += ambientCof * ambientColComponentCof * 5.0; \n        linearColCof += backgroundCof * backgroundCompoentCof;\n\n        col *= linearColCof;\n\n        // add fog effect to remote mountains: remote mountain means bigger t\n        col = mix(col, 0.75 * baseMountainFogCol, 1.0 - exp(-0.002 * t));\n    } else {\n        // rendering sky\n        col = baseSkyCol - rd.y * rd.y * rd.y * 0.3;\n        col = mix(col, 0.85 * baseGraySkyBandCol, pow(1.0 - max(rd.y, 0.0), 4.0));\n\n        // rendering sun\n        col += sunCol1Weight * baseSunCol1 * pow(sunDot, 16.0);\n        col += sunCol2Weight * baseSunCol2 * pow(sunDot, 256.0);\n        col += sunCol3Weight * baseSunCol3 * pow(sunDot, 512.0);\n\n        // rendering cloud\n        vec2 cloudPos = ro.xz + rd.xz * (cloudH - ro.y) / rd.y + iTime * 3.0;\n        // Effect1: The effect of the cloud is relatively continuous and dense\n        // col = mix(col, cloudCol, 0.5 * fbm(cloudSparsity * cloudPos)); \n        \n        // Effect2: The effect of the cloud is relatively not continuous and not dense\n        col = mix(col, cloudCol, 0.75 * smoothstep(0.4, 0.8, fbm(cloudSparsity * cloudPos)));\n    }\n\n    col += 0.3 * vec3(1.0, 0.7, 0.3) * pow(sunDot, 8.0);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//remix of https://www.shadertoy.com/view/mtSBzV\nfloat mod1(float a,float b){\n    return \n        mod(a,b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),3.); i++){\n        a /= 2.;\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b){\n    //distort(a,b);\n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        mod1(a1,4.)\n    ;\n    \n    return\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat prime_rhythm(float time){    \n    return (1.+fmod(time/2.,2.))/(1.+fmod(time/4.,2.));\n}\n\n#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 mainSound1(int samp, float time,float scale,int instrument){\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time/4.)/prime_rhythm(time/4.+4.)*2.\n  ,\n  t = s1*time/4./tempo1,\n  t4 = t/prime_rhythm(time+11.)/(1.+fmod(t/8.,2.)),\n  t1 = fmod(t4,2.),\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 = (1.+fmod(t5,2.)),\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod(t6,s1/2.)/2.),\n  m2 =\n      1. + fmod(t/t3/2.,s1/2.);\n  ;\n  vec2 a=\n      vec2(-(log(1./64.+fract1(t/2./prime_rhythm(time+14.))/4.)),-(log(1./64.+fract1(t/prime_rhythm(time+7.))/8.)))\n\n  ,\n  nb =\n      t*vec2(pow(2.,(m3+m2-t1*4.)/7.+scale),pow(2.,(m3+m2-t1*4.)/7.+scale))*tempo1\n  ,\n  //sitar = sitar(a,nb)\n  sitar =\n      //log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y*2.)))/2.)),\n      a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.))) \n  ,gamelan = a/16./4.*abs(log(1./4.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  +.5*log(1./4.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n  ,\n  steel_drum = a/16./4.*abs(log(1./2.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))))\n  + log(1./8.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.)))      \n  ,oud = oud(a,nb)\n  ;\n  switch(instrument){\n  case 1:\n  \n  return\n      gamelan\n      //oud\n      //steel_drum\n      //sitar\n      //hurdy-gurdy\n      //(abs(log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998*2.),fract1(nb.y*2.)))/2.))-log(1./16.+a*abs(1./16.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.))))\n\n      //log(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))*a)\n      \n      //abs(log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      //abs(1.+log(abs(.5-vec2(fract(nb.x*.998),fract(nb.y)))*a/2.))/2.\n      \n      //log(a*abs(1./4.-abs(.5-vec2(fract1(nb.x+.5),fract1(nb.y*2.)))))\n  ;\n  case 2: return sitar;\n  case 3: return oud;\n  case 4: return steel_drum;\n  default: return sitar;\n  }\n}\n\nvec2 mainSound(int a,float b){\n    return\n        (mainSound1(a,b,6.,3))\n        \n        //my favorite remix!\n        //(mainSound1(a,b/2.,7.5,4)+mainSound1(a,b,6.5,3))/2.\n        \n        //(mainSound1(a,b,5.5,4)+mainSound1(a,b*2.,6.5,3))/2.\n        \n        //gong remix (using oud)\n        //abs(mainSound1(a,b,6.5,3)-mainSound1(a,b,6.,3)/2.)\n        \n        //black metal!\n        //abs(mainSound1(a,b,6.5,3)-mainSound1(a,b*2.,6.,3))/2.\n\n        \n        //mainSound1(a,b/2.,6.5,1)+mainSound1(a,b,5.5,3)/2.+mainSound1(a,b*2.,4.5,1)/4.+mainSound1(a,b*4.,3.5,1)/8.\n        //(mainSound1(a,b,6.5,1)+mainSound1(a,b/2.,7.5,1)+mainSound1(a,b/4.,8.5,1))\n    ;\n}",
                "description": "",
                "inputs": [],
                "name": "Sound",
                "outputs": [],
                "type": "sound"
            }
        ],
        "ver": "0.1"
    }
}