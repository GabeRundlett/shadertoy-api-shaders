{
    "Shader": {
        "info": {
            "date": "1635514490",
            "description": "MFSDF Multi-Field Signed Distance Function( x,y,z,FieldType ) -> (r,g,b,sdf)\nA single function defines the entire scene objects and all materials\nEvery object SDF and every object material parameter\nNo material ids are used",
            "flags": 32,
            "hasliked": 0,
            "id": "7dySRc",
            "likes": 14,
            "name": "MFSDF Multi-Field SDF",
            "published": 3,
            "tags": [
                "pathtracing",
                "mfsdf"
            ],
            "usePreview": 0,
            "username": "PauloFalcao",
            "viewed": 737
        },
        "renderpass": [
            {
                "code": "// MFSDF Multi-Field Signed Distance Function\n// (x,y,z,FieldType) -> (r,g,b,sdf)\n//\n// By @PauloFalcao\n// https://www.shadertoy.com/view/7dySRc\n//\n// MFSDF is a scene description technique\n// \n// A single function defines the entire scene objects and all materials\n// Every object SDF and every object material parameter\n// No material ids are used\n//\n// It's a function were the 4ยบ input parameter (.w) identifies the field type to obtain\n// x,y,z identifies 3d position in space of the field\n// The output x,y,z is the field value, w is the sdf (used for blending materials)\n// \n// Field 0, just returns the SDF (at .w), this way we can avoid procedural material calculations\n// on the raymarching loop\n//\n// This kind of approach is very usefull for node based programs like Material Maker\n// No material IDs are used, it's possible to combine many objects and all the material\n// parameters in a single function vec4 -> vec4\n// When transforming a object (translation, rotation, etc) the materials are also transformed\n// And it's possible com combine different object materials for smooth transitions between objects\n// using the sdf information\n//\n// You can use this system using Material Maker with version 0.3 of my Ray Marching lib\n// https://github.com/paulofalcao/MaterialMakerRayMarching\n// A 2 hours seminar about MFSDF and Ray Marching in Material maker\n// https://www.youtube.com/watch?v=PvmIohbf93Q\n//\n// It also defines a standart way to describe the object material (based on Disney PBR plus a combination of\n// other renders parameters out there, mainly Blender, Godot, three.js, Unity, Unreal, Sketchfab,\n// Vray, Corona etc\n// This renders and more renders like Arnold, Redshift, Octane have many more parameters but I think\n// the main ones are here and a mapping can be done between them.\n// This way is also possible to decouple the render code / render nodes from the object / material definition\n// \n// I propose this table for field types but a different table with more, less or different parameters can be used\n// I suggest using field type 999 to output the table definition id\n// This is table (0,0,0,0)\n// where x=table id ,y=table id version ,z=table id sub version, w (not used)\n// A different table could use (1234,0,0,0) as ID for example\n// \n// TABLE (0,0,0,0) - MFSDF Standart 0\n//\n// FieldType=0 is just the SDF,  1 is BaseColor / Albedo, etc\n//\n// FIELD TYPE                 OUTPUT\n//\n// 0 - SDF                    (0,0,0,sdf)\n// 1 - BaseColor              (r,g,b,sdf) linear (0-1) \n// 2 - Metallic               (v,0,0,sdf)\n// 3 - Subsurface             (v,0,0,sdf)\n// 4 - Specular               (v,0,0,sdf)\n// 5 - Roughness              (v,0,0,sdf)\n// 6 - SpecularTint           (v,0,0,sdf)\n// 7 - Anisotropic            (v,0,0,sdf)\n// 8 - Sheen                  (v,0,0,sdf)\n// 9 - SheenTint              (v,0,0,sdf)\n//10 - Clearcoat              (v,0,0,sdf)\n//11 - Clearcoat Gloss        (v,0,0,sdf)\n//12 - Clearcoat Normal       (x,y,z,sdf)\n//13 - Emission               (r,g,b,sdf) linear (0-infinite)\n//14 - Normal                 (x,y,z,sdf)\n//15 - Alpha                  (v,0,0,sdf)\n//16 - IOR                    (v,0,0,sdf)\n//17 - Transmission           (v,0,0,sdf)\n//18 - Transmission Roughness (v,0,0,sdf)\n//19 - Ambient Occlusion      (v,0,0,sdf)\n//999 - Table ID - Identifies this table (0,0,0,0)\n//\n// Bibliography at the end\n//\n// One year ago, I briefly talked about this concept at\n// https://github.com/RodZill4/material-maker/commit/de29bddb45505ffbcb02348ff3169f60cde5cd39\n//\n//\n// ==== The path tracing render ===\n//\n// This a very basic / naive / beta path tracing render, many thing are not supported yet, and\n// many things are not correct, the idea of this code is just show the MFSDF ideia\n// \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(pow(color.xyz/color.w,vec3(1.0/1.7)), 1.0f);\n     \n}\n\n// \n// Bibliography\n//\n// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\n// https://www.realtimerendering.com/\n// https://www.pbr-book.org/\n// https://raytracing.github.io/books/RayTracingInOneWeekend.html\n// https://raytracing.github.io/books/RayTracingTheNextWeek.html\n// https://raytracing.github.io/books/RayTracingTheRestOfYourLife.html\n// https://seblagarde.wordpress.com/2015/07/14/siggraph-2014-moving-frostbite-to-physically-based-rendering/\n// https://www.scratchapixel.com/index.php\n// https://www.youtube.com/playlist?list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi\n// https://google.github.io/filament/Materials.html\n// https://blog.demofox.org/2017/01/09/raytracing-reflection-refraction-fresnel-total-internal-reflection-and-beers-law/\n// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/\n// https://blog.demofox.org/2020/06/06/casual-shadertoy-path-tracing-2-image-improvement-and-glossy-reflections/\n// https://blog.demofox.org/2020/06/14/casual-shadertoy-path-tracing-3-fresnel-rough-refraction-absorption-orbit-camera/\n// https://autodesk.github.io/standard-surface/\n// https://blog.selfshadow.com/publications/s2013-shading-course/hoffman/s2013_pbs_physics_math_notes.pdf\n// https://learnopengl.com/PBR/Theory\n// https://jcgt.org/published/0007/04/01/\n// \n// Shaders\n//\n// https://github.com/knightcrawler25/GLSL-PathTracer (not a shader, but good GLSL code)\n// https://www.shadertoy.com/view/XdyyDd by markusm\n// https://www.shadertoy.com/view/llGyRd by markusm\n// https://www.shadertoy.com/view/tsBBWW by demofox\n// https://www.shadertoy.com/view/WsBBR3 by demofox\n// https://www.shadertoy.com/view/ttfyzN by demofox\n// https://www.shadertoy.com/view/MlyyzW by reinder\n// https://www.shadertoy.com/view/3lB3DR by sschmidtix\n// https://www.shadertoy.com/view/XlXfDs by koiava\n// https://www.shadertoy.com/view/4ddcRn by otaviogood\n//\n// Renders PBRs Reference\n//\n// Disney    https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Godot     https://docs.godotengine.org/en/3.0/tutorials/3d/spatial_material.html\n// Unreal    https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n// Unity       https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html\n// Blender   https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/principled.html\n// Filament  https://google.github.io/filament\n// Sketchfab https://help.sketchfab.com/hc/en-us/articles/204429595-Materials-PBR-\n// Substance https://substance3d.adobe.com/tutorials/courses/the-pbr-guide-part-1\n// Cryengine https://www.youtube.com/watch?v=hGFP_4TYL2o\n// 3DSMax    https://help.autodesk.com/view/3DSMAX/2021/ENU/?guid=GUID-A16234A5-6500-4662-8B20-A5EC9FE1B255\n// Redshift  https://docs.redshift3d.com/display/RSDOCS/Material\n// Arnold    https://docs.arnoldrenderer.com/display/A5AF3DSUG/Standard+Surface\n// Octane    http://www.aoktar.com/octane/OCTANE%20HELP%20MANUAL.html?UniversalMaterial.html\n// VRay      https://docs.chaosgroup.com/display/VMAX/VRayMtl\n// Mitsuba2  https://mitsuba2.readthedocs.io/en/latest/generated/plugins.html#bsdfs\n//\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "//RENDER SETTINGS\nconst float maxDist=20.0;\nconst int maxIte=8;\nconst int samples=16; //change this number according to your GPU power\n\n//MATH\nconst float PI=3.14159265359;\nconst float TAU=6.28318530718;\n\nvoid Onb(in vec3 N, inout vec3 T, inout vec3 B){\n    vec3 UpVector=abs(N.z)<0.999?vec3(0,0,1):vec3(1,0,0);\n    T=normalize(cross(UpVector,N));\n    B=cross(N,T);\n}\n\n// RANDOM START\n//from https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/\nuint rand_pcg(inout uint seed){\n    uint state = seed;\n    seed = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat RandomFloat01(inout uint state){\n    uint r=rand_pcg(state);\n    r &= 0x007FFFFFu;\n    r |= 0x3F800000u;\n    return uintBitsToFloat(r) - 1.0f;\n}\n\n// RANDOM END\n\n\n// SAMPLING START\n\nvec3 uniformSampleSphere(float r1,float r2){\n    float z=1.0-2.0*r1;\n    float r=sqrt(max(0.0,1.0-z*z));\n    float phi=TAU*r2;\n    return vec3(r*cos(phi),r*sin(phi),z);\n}\n\nvec3 cosineSampleHemissphere(inout uint state,vec3 n){\n    float u1=RandomFloat01(state);\n    float u2=RandomFloat01(state);\n    return normalize(n+uniformSampleSphere(u1,u2)); \n}\n\n// Adapted from \"Sampling the GGX Distribution of Visible Normals\",\n// http://jcgt.org/published/0007/04/01/\nvec3 SampleGGXVNDF(inout uint state,vec3 Ve,float alpha_x,float alpha_y){\n    float U1=RandomFloat01(state);\n    float U2=RandomFloat01(state);\n    \n    //transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * Ve.x, alpha_y * Ve.y, Ve.z));\n\n    //orthonormal basis\n    vec3 T1;vec3 T2;\n    Onb(Vh,T1,T2);\n\n    //parameterization of the projected area\n    float r = sqrt(U1); \n    float phi = 2.0 * PI * U2;    \n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\n    //reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0f, 1.0f - t1*t1 - t2*t2))*Vh;\n\n    //transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0f, Nh.z))); \n\n    return Ne;\n}\n\nfloat schlickWeight(float cosTheta) {\n    float m=clamp(1.-cosTheta,0.,1.);\n    float m2=m*m;\n    return m2*m2*m;\n}\n\n// SAMPLING END\n\n\n//---------------------------------------------------------\n// MFSDF FUNCTION START\n//---------------------------------------------------------\n\n//MFSDF Combine functions \n\nvec4 mf_smooth_union(vec4 a, vec4 b, float k) {\n  float h = max( k-abs(a.w-b.w), 0.0 )/k;\n  h=h*h*k*0.25;\n  return vec4(mix(a.xyz,b.xyz,clamp(a.w*1.0/k,0.0,1.0)),min( a.w, b.w ) - h);\n}\n\nvec4 mf_min(vec4 a,vec4 b){\n  if (a.w<b.w) return a; else return b;\n}\n\nvec4 lights(vec4 p){\n  p.y-=6.0;\n  //p.xz=mod(p.xz,2.0)-1.0;\n  p.xz=mod(p.xz,8.0)-4.0;\n  float sdf=length(p.xyz)-0.9;\n  \n  //13-Emission (r,g,b,sdf) linear (0-infinite)\n  if ((p.w>12.5)&&(p.w<13.5)){\n   return vec4(vec3(40.0),sdf);\n  } else {\n   return vec4(vec3(0),sdf);\n  }\n}\n\nvec4 obj_a(vec4 p){\n  float sphereSize=0.9;\n\n  vec3 color=vec3(0.78,0.19,0.26);\n  p.y+=(sin(p.x*32.0)*sin(p.y*32.0)*sin(p.z*32.0))*0.1;\n  float sdf=length(p.xyz)-sphereSize;\n  \n  float v=sin(atan(p.x,p.z)*8.0)>0.0?1.0:0.0;\n\n  // 5 - Roughness (v,0,0,sdf)\n  if ((p.w>4.5)&&(p.w<5.5)){\n   return vec4(0.1,0.0,0.0,sdf);\n  } else\n  // 4 - Specular (v,0,0,sdf)\n  if ((p.w>3.5)&&(p.w<4.5)){\n   return vec4(0.6,0.0,0.0,sdf);\n  } else\n  // 2 - Metallic (v,0,0,sdf)\n  if ((p.w>1.5)&&(p.w<2.5)){\n   return vec4(v,0.0,0.0,sdf);\n  } else\n  // 1 - BaseColor (r,g,b,sdf) linear (0-1)\n  if ((p.w>0.5)&&(p.w<1.5)){\n   return vec4(color,sdf);\n  }\n  // 0 - SDF (0,0,0,sdf)\n  else {\n   return vec4(vec3(0.0),sdf*0.5);\n  }\n}\n\nvec4 floor_a(in vec4 p){\n  float sdf=p.y+1.0;\n  float v=sin(p.x*PI)*sin(p.z*PI)<0.0?1.0:0.0;\n\n  // 5 - Roughness (v,0,0,sdf)\n  if ((p.w>4.5)&&(p.w<5.5)){\n   return vec4(0.05,0.0,0.0,sdf);\n  } else\n  // 4 - Specular (v,0,0,sdf)\n  if ((p.w>3.5)&&(p.w<4.5)){\n   return vec4((1.0-v)*0.8+0.1,0.0,0.0,sdf);\n  } else\n  // 2 - Metallic (v,0,0,sdf)\n  if ((p.w>1.5)&&(p.w<2.5)){\n   return vec4(0.0,0.0,0.0,sdf);\n  } else\n  // 1 - BaseColor (r,g,b,sdf) linear (0-1)\n  if ((p.w>0.5)&&(p.w<1.5)){\n   //Because of an extremely odd reason this code does not work on some D3D11 backend\n   //It Renders ok on OpenGL backend\n   //So... I had to use sin to do a checkboard :(\n   //https://bugs.chromium.org/p/angleproject/issues/detail?id=6260\n   //\n   //return vec4(vec3(mod(floor(p.x)+floor(p.z),2.0))*0.8+0.1,sdf);\n   //\n   return vec4(vec3(v*0.8+0.1),sdf);\n  }\n  //0-SDF (0,0,0,sdf)\n  else {\n   return vec4(vec3(0),sdf);\n  }\n}\n\n//This is the main MFSDF (Multi-Field Signed Distance Function)\n//(x,y,z,FieldType) -> (r,g,b,sdf)\nvec4 mfsdf(vec4 p){\n  return mf_min(lights(p),\n     mf_smooth_union(floor_a(p),\n     obj_a(p),0.9));\n}\n\n//---------------------------------------------------------\n// MFSDF FUNCTION END\n//---------------------------------------------------------\n\n\n\nvec3 HDRI360(vec3 p){\n    p=p.xyz;\n    return pow(texture(iChannel1,p).xyz,vec3(2.2))+\n           pow(texture(iChannel2,p).xxx,vec3(2.2));\n}\n\n\n\n//tetrahedron normal by PauloFalcao\nvec3 normal(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=mfsdf(vec4(p+e.xyy,0.0)).w;\n  float v2=mfsdf(vec4(p+e.yyx,0.0)).w;\n  float v3=mfsdf(vec4(p+e.yxy,0.0)).w;\n  float v4=mfsdf(vec4(p+e.xxx,0.0)).w;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid raymarch(in vec3 o,in vec3 v,out vec3 p,inout float d){\n  float s;\n  for(int i=0;i<1024;i++){\n    p=o+v*d;\n    s=mfsdf(vec4(p,0.0)).w;\n    if (abs(s)<0.0001) break;\n    d+=s;\n    if (d>maxDist) break;\n  } \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // From https://www.shadertoy.com/view/tsBBWW by demofox\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n  \n    //Camera - Trackball style\n    float mx=(iMouse.x/iResolution.x)*PI*2.0;\n    float my=(iMouse.y/iResolution.y)*PI/2.01;\n    vec3 o=vec3(cos(my)*sin(mx),sin(my),cos(my)*cos(mx))*4.0; \n    \n    vec3 t=vec3(0.0,0.0,0.0);\n    vec3 u=vec3(0.0,1.0,0.0);\n    vec3 c=normalize(t-o);\n    vec3 cx=normalize(cross(u,c));\n    vec3 cy=normalize(cross(c,cx));\n    \n    vec3 sumrgb=vec3(0.0);\n    for(int aa=0;aa<samples;aa++){\n    \n        vec2 xy=((fragCoord.xy+vec2(RandomFloat01(rngState),RandomFloat01(rngState)))/iResolution.xy)-0.5;\n        xy.x*=(iResolution.x/iResolution.y);\n        vec3 v=normalize(c*1.5+cx*xy.x+cy*xy.y);\n\n        vec3 p;\n        float d=0.01;\n        vec3 rgb=vec3(1.0);\n        vec3 io=o;\n        int i;\n        for(i=0;i<maxIte;i++){\n        \n          raymarch(io/*in*/,v/*in*/,p/*out*/,d/*inout*/);\n          \n          vec3 n=normal(p);\n          \n          //View direction to tangent space\n          vec3 t;vec3 b;Onb(n,t,b);\n          vec3 vt=vec3(dot(-v,t),dot(-v,b),dot(-v,n));\n\n          if (d<maxDist){\n            vec3 obj_Emission=mfsdf(vec4(p,13.0)).rgb;\n            \n            if ((obj_Emission.x+obj_Emission.y+obj_Emission.z)>0.001){\n                rgb=max(obj_Emission*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                break;\n            } else {\n                float s=RandomFloat01(rngState);\n\n                vec3 obj_BaseColor=mfsdf(vec4(p,1.0)).rgb; // 1 - BaseColor  (r,g,b,sdf)\n                float obj_Metallic=mfsdf(vec4(p,2.0)).x;   // 2 - Metallic   (v,0,0,sdf)\n                float obj_Specular=mfsdf(vec4(p,4.0)).x;   // 4 - Specular   (v,0,0,sdf)\n                float obj_Roughness=mfsdf(vec4(p,5.0)).x;  // 5 - Roughness  (v,0,0,sdf)\n\n                if (s>obj_Specular*obj_Specular){\n                    rgb=max(obj_BaseColor-(obj_BaseColor*obj_Metallic)*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                    v=cosineSampleHemissphere(rngState,n);\n                } else {\n  \n                    float r2=obj_Roughness*obj_Roughness;\n                    vec3 vndf=SampleGGXVNDF(rngState,vt,r2,r2);\n                    vec3 nv=reflect(-vt,vndf);\n\n                    //Sample direction back to camera space\n                    nv=nv.x*t+nv.y*b+nv.z*n;\n \n                    float FH=schlickWeight(dot(n,nv));\n                    vec3 Cspec0=mix(vec3(obj_Specular*.08),obj_BaseColor,obj_Metallic);\n                    vec3 Fs=mix(Cspec0,vec3(1),FH);\n                    rgb=max(Fs*(1.0-d/(maxDist-1.0)),0.0)*rgb;\n                    \n                    v=nv;\n                }\n                io=p;\n                d=0.001;\n            }\n          } else {\n           rgb*=HDRI360(v);\n           break;\n          }\n        }//for(int i\n        if (i==maxIte) rgb=vec3(0.0);//did not hit any light source\n        sumrgb+=rgb;\n    }//for(int aa\n    \n    // average the frames together\n    sumrgb=sumrgb/float(samples);\n\n    if (iMouse.z<0.1){\n        vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n        fragColor = vec4(lastFrameColor+vec4(sumrgb,1.0));\n    } else {\n        fragColor = vec4(sumrgb,1.0);\n    }   \n\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}