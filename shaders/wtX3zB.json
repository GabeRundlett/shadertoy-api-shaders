{
    "Shader": {
        "info": {
            "date": "1556704447",
            "description": "See the source...",
            "flags": 0,
            "hasliked": 0,
            "id": "wtX3zB",
            "likes": 11,
            "name": "Almost My First Shader",
            "published": 3,
            "tags": [
                "raymarch",
                "landscape",
                "flight",
                "car"
            ],
            "usePreview": 0,
            "username": "dr2",
            "viewed": 856
        },
        "renderpass": [
            {
                "code": "// \"Almost My First Shader\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  We all know that Shadertoy is a great resource for learning shader programming. \n  Before my first contribution nearly five years ago I found many examples by the \n  Shadertoy pioneers that were helpful in learning what could be done and how to \n  do it. The second of the two shaders below is one of my initial attempts, but\n  because much of it is a cut-and-paste job based on their work I never bothered\n  to publish it. Since the visuals are not bad (ignoring artifacts) I have now\n  rewritten it in the usual style, and this is the first of the shaders here.\n*/\n\n#if 1   // shader version (1/0)\n\n// The new version\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 carMat;\nvec3 carPos, sunDir;\nfloat dstFar, szFac, carRoll, fanAng;\nint idObj;\nbool isRefl;\nconst int idRd = 1, idGrnd = 2, idTun = 3, idCar = 4;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (1.5 * cos (cos (0.2 * t) + 0.16 * t) * cos (0.1 * t),\n     2. * sin (0.11 * t) + 0.8 * cos (cos (0.07 * t) + 0.11 * t) * cos (0.03 * t), t);\n}\n\nfloat CarDf (vec3 p)\n{\n  float d;\n  p = carMat * (p - carPos) / szFac;\n  p.y -= -26.;\n  p.xy = Rot2D (p.xy, carRoll);\n  d = max (length (max (vec3 (abs (p.x) - 3.5,\n     length (vec2 (p.y + 12., p.z)) - 20., - (p.y - 1.6)), 0.)) - 0.5, p.z - 12.);\n  p.yz -= vec2 (2.2, -3.9);\n  p.xz = abs (p.xz) - vec2 (7.2, 10.6);\n  d = min (SmoothMin (d, length (vec2 (max (abs (p.z) - 2.4, 0.), length (p.xy) - 2.8)) - 0.2, 3.),\n     (length (vec3 (p.xy, 0.35 * p.z)) - 0.8));\n  return d * szFac;\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, r;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  d = max (q.y + 1., abs (q.x) - 0.75);\n  DMIN (idRd);\n  d = mix (q.y + 1.1, q.y - 36. * Fbm2 (0.03 * q.xz) + 12., smoothstep (3., 30., abs (q.x)));\n  DMIN (idGrnd);\n  r = q;\n  r.z = mod (r.z + 25., 50.) - 25.;\n  d = max (abs (r.y - 1. + 0.4 * r.x * r.x) - 0.1, abs (r.z) - 10.);\n  r.y += 0.7;\n  r.z = mod (r.z, 2.5) - 1.25;\n  d = max (d, 0.6 - length (r.yz));\n  DMIN (idTun);\n  if (! isRefl) {\n    d = CarDf (p);\n    DMIN (idCar);\n  }\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 350; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.001, -0.001);\n  v = vec4 (- ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat FanDf (vec3 p)\n{\n  float d;\n  p = carMat * (p - carPos) / szFac;\n  p.y -= -26.;\n  p.xy = Rot2D (p.xy, carRoll);\n  p.yz -= vec2 (2.2, -3.9);\n  p.xz = abs (p.xz) - vec2 (7.2, 10.6);\n  p.xy = Rot2D (p.xy, fanAng);\n  d = max (max (min (abs (p.x), abs (p.y)) * 0.15 - 0.05,\n     abs (p.z) - 2.), length (p.xy) - 2.8);\n  return d * szFac;\n}\n\nfloat FanRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 60; j ++) {\n    d = FanDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjCol (vec3 p, vec3 rd, vec3 vn)\n{\n  vec3 q, col, m;\n  float c, f, sh, spec;\n  q = p - vec3 (TrackPath (p.z).xy, 0.);\n  spec = 0.;\n  if (idObj == idRd) {\n    c = max (0., 1. - 5. * abs (0.4 - abs (q.x))) * step (0.5, cos (32. * pi * q.z / 50.));\n    col = vec3 (0.5) + 2. * pow (c, 8.) * vec3 (1., 0.8, 0.);\n  } else if (idObj == idGrnd) {\n    f = 0.55 * (clamp (Noisefv2 (p.xz * 0.1), 0., 1.) +\n       Noisefv2 (p.xz * 0.2 + vn.yz * 1.08) * 0.85);\n    m = mix (vec3 (0.63 * f + 0.2, 0.7 * f + 0.1, 0.7 * f + 0.1),\n       vec3 (f * 0.43 + 0.1, f * 0.3 + 0.2, f * 0.35 + 0.1), f * 0.65);\n    col = m * (f * m + vec3 (0.36, 0.30, 0.28));\n    if (vn.y < 0.5) {\n      c = (0.5 - vn.y) * 4.;\n      c = clamp (c * c, 0.1, 1.);\n      f = Noisefv2 (vec2 (p.x * 0.2, p.z * 0.2 + p.y * 0.3)) +\n         Noisefv2 (vec2 (p.x * 4.5, p.z * 4.5)) * 0.5;\n      col = mix (col, vec3 (0.4 * f), c);\n    }\n    if (p.y < 5. && vn.y > 0.65) {\n      m = vec3 (Noisefv2 (p.xz * 7.) * 0.4 + 0.1, Noisefv2 (p.xz * 11.) * 0.6 + 0.3, 0.);\n      m *= (vn.y - 0.55) * 0.85;\n      col = mix (col, m, clamp ((vn.y - 0.65) * (5. - p.y) * 0.13, 0., 1.));\n    }\n    if (p.y > 5. && vn.y > 0.2) {\n      col = mix (col, 1.3 * vec3 (0.95, 0.95, 1.),\n         clamp ((p.y - 5. - Noisefv2 (p.xz * 1.2)) * 0.2, 0., 1.));\n      spec = 0.1;\n    }\n  } else if (idObj == idTun) {\n    col = vec3 (0.8, 0., 0.);\n    if (abs (q.x) < 0.6 && vn.y < 0.) col += pow (max (0., 1.5 - 2.5 * abs (q.x)) *\n       step (0., cos (64. * pi * q.z / 50.)), 8.) * vec3 (0.8, 0.4, 0.7);\n  } else if (idObj == idCar) {\n    q = carMat * (p - carPos) / szFac;\n    q.y -= -26.;\n    q.xy = Rot2D (q.xy, carRoll);\n    q.xz = abs (q.xz);\n    col = ((abs (q.y - 6.5) < 1. - q.z * 0.1 && q.z < 3.5 ||\n       length (max (abs (vec2 (q.x - q.z * 0.03, q.z - 5.)) -\n       vec2 (1.5 + q.z * 0.03, 4.), 0.)) < 1.) ? 0.4 : 1.) * vec3 (0.2, 0.6, 1.);\n    spec = 0.5;\n  }\n  sh = ObjSShadow (p, sunDir);\n  return col * (0.2 + sh * 0.8 * max (0., dot (sunDir, vn))) +\n     spec * step (0.95, sh) * pow (max (0., dot (rd, reflect (sunDir, vn))), 32.);\n}\n\nvec3 SkyCol (vec3 rd)\n{\n  float sd;\n  rd.y = abs (rd.y);\n  sd = max (0., dot (rd, sunDir));\n  return mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (Fbm2 (2. * rd.xz / rd.y) - 0.1) * rd.y, 0., 1.)) + (pow (sd, 64.) * 0.15 +\n     pow (sd, 256.) * 0.15) * vec3 (1., 0.8, 0.5);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, vn;\n  float dstObj, dstFan, dstObjT;\n  int idObjT;\n  dstFan = FanRay (ro, rd);\n  isRefl = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObjT = idObj;\n    dstObjT = dstObj;\n    col = ObjCol (ro, rd, vn);\n  } else {\n    col = SkyCol (rd);\n  }\n  if (dstObj < dstFar && idObjT == 4) {\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    isRefl = true;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      colR = ObjCol (ro, rd, vn);\n    } else {\n      colR = SkyCol (rd);\n    }\n    col = mix (col, colR, 0.2);\n  }\n  if (dstFan < min (dstObjT, dstFar)) col += mix (col, vec3 (1., 0.5, 0.2), 0.5);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd, vd, col, dir, u;\n  vec2 canvas, uv;\n  float tCur, spd, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  szFac = 0.025;\n  spd = 8.;\n  fanAng = mod (20. * tCur, 2. * pi);\n  carPos = TrackPath (spd * tCur);\n  dir = normalize ((TrackPath (spd * tCur + 1.) - carPos));\n  u = normalize (vec3 (dir.z, 0., - dir.x));\n  carMat = mat3 (u, cross (u, - dir), - dir);\n  carRoll = dir.x * 0.8;\n  carPos.xy -= vec2 (dir.x, 0.2);\n  ro = TrackPath (spd * tCur - 1.7) - vec3 (1.5 * dir.x, 0.5, 0.);\n  vd = normalize (carPos - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  dstFar = 200.;\n  sunDir = normalize (vec3 (1., 1., 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 1.5));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\n#else\n\n// The ancient version\n\nconst float pi = 3.14159;\n\nvec4 Hashv4f (float p) {\n  return fract (sin (vec4 (p + 0., p + 1., p + 57., p + 58.)) * 43758.5453);\n}\n\nfloat Noisefv2 (vec2 s) {\n  vec2 p = floor (s);\n  vec2 f = fract (s);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (p.x + 57. * p.y);\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p) {\n  const mat2 mr = mat2 (0.6, -0.8, 0.8, 0.6);\n  float f = 0.;\n  float a = 1.;\n  float am = 0.5;\n  float ap = 2.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    p *= mr * ap;\n    a *= am;\n  }\n  return f;\n}\n\nvec3 colSky (vec3 rd) {\n  vec3 col;\n  if (rd.y < 0.) rd.y *= -1.;\n  vec2 xy = 1. * rd.xz / rd.y;\n  float w = 0.65;\n  float f = 0.;\n  for (int i = 0; i < 4; i ++) {\n    f += Noisefv2 (xy) * w;\n    w *= 0.5;\n    xy *= 2.3;\n  }\n  col = mix (vec3 (0.3, 0.35, 0.7), vec3 (0.8, 0.8, 0.8),\n     clamp (2. * (f - 0.2) * rd.y, 0., 1.));\n  return col;\n}\n\nvec3 carPos;\nmat3 carMat;\nmat2 carRoll;\nfloat fanDist;\nint isRefl;\nbool carOnly = false;\nbool needFan;\nvec3 lightDir;\nmat2 spinMat;\n\nfloat SmoothMin (float a, float b, float k)\n{\n  float h = clamp (.5 + .5 * (b - a) / k, 0., 1.);\n  return mix (b, a, h) - k * h * (1. - h);\n}\n\nvec3 path (float t)\n{\n  t *= 0.6;\n  float x = cos (cos (t * 0.36) + t * 0.28) * cos (t * 0.13) * 1.5;\n  float y = sin (t * 0.17) * 2. + cos (cos (t * 0.12) + t * 0.19) *\n     cos (t * 0.051) * 0.8;\n  return vec3 (x, y, t / 0.6);\n}\n\nfloat DfTunnel (vec3 p)\n{\n  p.z = mod (p.z, 50.) - 25.;\n  float d = max (abs (p.y - 1. + 0.4 * p.x * p.x) - 0.1, abs (p.z) - 10.);\n  p.z = mod (p.z, 2.5) - 1.25;\n  p.y += 0.7;\n  d = max (d, - (length (p.yz) - 0.6));\n  return d;\n}\n\nfloat DfCar (vec3 p)\n{\n  p *= 40.;\n  float d = max (length (max (vec3 (abs (p.x) - 3.5,\n     length (vec2 (p.y + 12., p.z)) - 20., - (p.y - 1.6)), 0.)) - 0.5, p.z - 12.);\n  vec3 q = p + vec3 (0., -2.2, 3.9);\n  q.xz = abs (q.xz) - vec2 (7.2, 10.6);\n  d = SmoothMin (d,\n     length (vec2 (max (abs (q.z) - 2.4, 0.), length (q.xy) - 2.8)) - 0.2, 3.);\n  d = min (d, (length (vec3 (q.xy, 0.35 * q.z)) - 0.8));\n  return d / 40.;\n}\n\nfloat DfFan (vec3 p)\n{\n  p *= 40.;\n  vec3 q = p + vec3 (0., -2.2, 3.9);\n  q.xz = abs (q.xz) - vec2 (7.2, 10.6);\n  q.xy *= spinMat;\n  float df = max (max (min (abs (q.x), abs (q.y)) * 0.15 - 0.05,\n     abs (q.z) - 2.), length (q.xy) - 2.8);\n  df = min (df, (length (q) - 0.5) * 0.07);\n  return min (fanDist, df / 40.);\n}\n\nfloat colCar (vec3 p)\n{\n  p *= 40.;\n  p.xz = abs (p.xz);\n  return (abs (p.y - 6.5) < 1. - p.z * 0.1 && p.z < 3.5 ||\n     length (max (abs (vec2 (p.x - p.z * 0.03, p.z - 5.)) -\n     vec2 (1.5 + p.z * 0.03, 4.), 0.)) < 1.) ? 0.4 : 1.;\n}\n\nint hitObj, hitObjP;\n\nfloat de (vec3 p)\n{\n  float d, dd;\n  float gd = p.y + 12. - 20. * Fbm2 (0.04 * p.xz);\n  hitObj = 0;\n  vec3 q = p;\n  if (! carOnly) q.xy -= path (q.z).xy;\n  d = q.y + 1.;\n  if (! carOnly) {\n    d = max (d, abs (q.x) - 0.75);\n    hitObj = 1;\n    float b = smoothstep (3., 25., abs (q.x));\n    dd = (q.y + 1.1) * (1. - b) + gd * b;\n    if (dd < d) {\n      d = dd;\n      hitObj = 2;\n    }\n    dd = DfTunnel (q);\n    if (dd < d) {\n      d = dd;\n      hitObj = 3;\n    }\n  }\n  if (isRefl == 0) {\n    q = p;\n    if (! carOnly) {\n      q -= carPos;\n      q = carMat * q;\n      q.y += 0.7;\n      q.xy *= carRoll;\n    }\n    dd = DfCar (q);\n    if (needFan) fanDist = DfFan (q);\n    if (dd < 0.001) hitObj = 4;\n    d = min (d, dd);\n  }\n  return d;\n}\n\nvec3 evalNorm (vec3 p)\n{\n  const vec3 e = 0.001 * vec3 (1., -1., 0.);\n  float v0 = de (p + e.xxx);\n  float v1 = de (p + e.xyy);\n  float v2 = de (p + e.yyx);\n  float v3 = de (p + e.yxy);\n  return normalize (vec3 (v0) + vec3 (v1 - v3 - v2, v3 - v1 - v2, v2 - v3 - v1));\n}\n\nfloat shadow (vec3 pos, vec3 sdir)\n{\n  float sh = 1.0;\n  float totdist = 0.004 * 10.;\n  float d;\n  for (int steps = 0; steps < 40; steps++) {\n    vec3 p = pos + totdist * sdir;\n    d = de (p);\n    sh = min (sh, 10. * max (0.0, d) / totdist);\n    sh *= sign (max (0., d - 0.004));\n    totdist += max (0.02, d);\n    if (totdist > 35. || d < 0.004) break;\n  }\n  return clamp (sh, 0., 1.0);\n}\n\n#define AMBIENT_COLOR vec3(.7,.85,1.)\n\nvec3 shade (vec3 p, vec3 dir, vec3 n)\n{\n  vec3 col = vec3 (0.);\n  if (hitObjP == 1) col = vec3 (0.5, 0.5, 0.5);\n  else if (hitObjP == 2) {\n    float f = 0.55 * (clamp (Noisefv2 (p.xz * 0.1), 0., 1.) +\n        Noisefv2 (p.xz * 0.2 + n.yz * 1.08) * 0.85);\n    vec3 m = mix (vec3 (0.63 * f + 0.2, 0.7 * f + 0.1, 0.7 * f + 0.1),\n\t    vec3 (f * 0.43 + 0.1, f * 0.3 + 0.2, f * 0.35 + 0.1), f * 0.65);\n    col = m * (f * m + vec3 (0.36, 0.30, 0.28));\n    if (n.y < 0.5) {\n      float c = (0.5 - n.y) * 4.;\n      c = clamp (c * c, 0.1, 1.);\n      f = Noisefv2 (vec2 (p.x * 0.2, p.z * 0.2 + p.y * 0.3)) +\n          Noisefv2 (vec2 (p.x * 4.5, p.z * 4.5)) * 0.5;\n      col = mix (col, vec3 (0.4 * f), c);\n    }\n    if (p.y < 5. && n.y > 0.65) {\n      m = vec3 (Noisefv2 (p.xz * 7.) * 0.4 + 0.1,\n\t\tNoisefv2 (p.xz * 11.) * 0.6 + 0.3, 0.);\n      m *= (n.y - 0.55) * 0.85;\n      col = mix (col, m, clamp ((n.y - 0.65) * 1.3 * (5. - p.y) * 0.1, 0., 1.));\n    }\n    if (p.y > 5. && n.y > 0.2) {\n      float snow = clamp ((p.y - 5. - Noisefv2 (p.xz * 1.2) * 1.) * 0.2, 0., 1.);\n      col = mix (col, vec3 (0.7, 0.7, 0.8), snow);\n    }\n  }\n  else if (hitObjP == 3) col = vec3 (0.8, 0., 0.);\n  vec3 q = p;\n  if (! carOnly) q -= vec3 (path (p.z).xy, 0.);\n  if (hitObjP == 1) {\n    float c = max (0., 0.2 - abs (0.4 - abs (q.x))) * 5. * abs (sin (q.z * 1.));\n    c *= c;\n    c *= c;\n    col += c * c * vec3(1.,.6,.25) * 2.4;\n  }\n  if (hitObjP == 3) {\n    if (abs (q.x) < 0.6 && n.y < 0.) {\n      float c = max (0., 0.3 - 0.5 * abs (q.x)) * 5. * abs (sin (q.z * 2.));\n      c *= c;\n      c *= c;\n      col += c * c * vec3(.8,.4,.7);\n    }\n  }\n  q = p;\n  if (! carOnly) {\n    q -= carPos;\n    q = carMat * q;\n    q.y += 0.7;\n    q.xy *= carRoll;\n  }\n  if (DfCar (q) < 0.001) {\n    col = colCar (q) * vec3 (1., 0.6, 0.3);\n  }\n  float diff, spec;\n  float sh = shadow (p, lightDir);\n  diff = max (0., dot (lightDir, n)) * 1.3;\n  float amb = (0.4 + 0.6 * max (0., dot (dir, - n))) * 0.6;\n  spec = pow (max (0., dot (dir, reflect (lightDir, n))), 20.) * 0.4;\n  return col * (amb * AMBIENT_COLOR + sh * (diff + spec) * vec3(1.,.85,.6));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec2 canvas, uv;\n  float tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  bool riding = true;\n  if (carOnly) riding = false;\n  lightDir = normalize (vec3 (-0.7, 0.7, 0.7));\n  fanDist = 250.;\n  float t = mod (tCur, 500.) * 8.;\n  spinMat = mat2 (cos (t * 2.), - sin (t * 2.), sin (t * 2.), cos (t * 2.));\n  vec3 ro, rd, col;\n  if (riding) {\n    vec3 trkCar, dirCar, fwc, rtc;\n    trkCar = path (t);\n    dirCar = normalize ((path (t + 1.) - trkCar));\n    fwc = normalize (- dirCar);\n    rtc = normalize (cross (fwc, vec3 (0., 1., 0.)));\n    carMat = mat3 (rtc, cross (rtc, fwc), fwc);\n    float a = - dirCar.x * 0.8;\n    carRoll = mat2 (cos (a), sin (a), -sin (a), cos (a));\n    carPos = vec3 (trkCar.xy - vec2 (dirCar.x, 0.2), t);\n    ro = path (t - 0.6) + vec3 (- dirCar.x * 2., -0.5, -0.6);\n    vec3 fw = normalize (carPos - ro);\n    vec3 rt = normalize (cross (fw, vec3 (0., 1., 0.)));\n    rd = mat3 (rt, cross (rt, fw), fw) * normalize (vec3 (uv, 1.2));\n  } else {\n    float az, el;\n    el = 0.4;\n    az = 1.;\n    if (mPtr.z > 0.) {\n      el -= 0.3 * pi * mPtr.y;\n      az += 2. * pi * mPtr.x;\n    }\n    float cEl = cos (el);\n    float sEl = sin (el);\n    float cAz = cos (az);\n    float sAz = sin (az);\n    rd = normalize (vec3 (uv, 6.));\n    rd = vec3 (rd.x, rd.y * cEl - rd.z * sEl, rd.z * cEl + rd.y * sEl);\n    rd = vec3 (rd.x * cAz + rd.z * sAz, rd.y, rd.z * cAz - rd.x * sAz); \n    ro = - 4. * vec3 (cEl * sAz, - sEl, cEl * cAz);\n  }\n  float d;\n  vec3 carHitPt;\n  vec3 carHitN;\n  vec3 rdo = rd;\n  isRefl = 0;\n  float dist = 0.;\n  for (int i = 0; i < 200; i ++) {\n    needFan = true;\n    d = de (ro + dist * rd);\n    needFan = false;\n    dist += d;\n    if (d < 0.001) {\n      if (hitObj == 4 && isRefl == 0) {\n        ro += dist * rd;\n        carHitN = evalNorm (ro);\n        carHitPt = ro;\n        rd = reflect (rd, carHitN);\n        dist = 0.01;\n        isRefl = 1;\n      } else break;\n    } else {\n      if (dist > 100.) break;\n    }\n  }\n  hitObjP = hitObj;\n  if (d < 0.5) {\n    ro += dist * rd;\n    col = shade (ro, rd, evalNorm (ro));\n  } else {\n    float ldDot = max (0., dot (normalize (rd), lightDir));\n    col = colSky (rd) +\n      (pow (ldDot, 50.) * 0.15 + pow (ldDot, 200.) * 0.15) * vec3(1.,.8,.5);\n  }\n  if (isRefl == 1) col = shade (carHitPt, rdo, carHitN) + col * 0.3;\n  fanDist *= 100.;\n  if (fanDist < 0.4) {\n    float mFan = 1. / (1. + fanDist * fanDist * 10.);\n    col += vec3 (0.2, 0.3, 0.4) * mFan * (mFan + 0.5);\n  }\n  col = pow (abs (clamp (col, vec3 (0.), vec3 (1.))), vec3 (1.1)) * 0.9;\n  col = mix (vec3 (length (col)), col, 0.85);\n  fragColor = vec4 (col, 1.);\n}\n\n#endif\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}