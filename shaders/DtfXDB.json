{
    "Shader": {
        "info": {
            "date": "1675416386",
            "description": "Toy Path tracer with BSDF, BTDF and importance sampling microfacet GGX.\n\nUse your mouse to rotate around scene center.",
            "flags": 32,
            "hasliked": 0,
            "id": "DtfXDB",
            "likes": 4,
            "name": "God damn Path Tracer",
            "published": 3,
            "tags": [
                "raytracing",
                "raytracer",
                "pathtracing",
                "pathtracer",
                "brdf",
                "ggx",
                "btdf"
            ],
            "usePreview": 0,
            "username": "phoshp",
            "viewed": 328
        },
        "renderpass": [
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    ivec2 o = ivec2(fragCoord);\n    vec4 data = texelFetch(iChannel0, o, 0);\n    vec3 col = data.rgb / data.w;\n    \n    col = pow(col, vec3(1.0 / GAMMA)); // gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define GAMMA 2.2\n#define SAMPLES 5.0\n#define MAX_RENDER_DISTANCE 10000.0\n#define EPSILON 0.001\n#define PATH_LENGTH 12\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat3 GetTangentSpace(vec3 normal)\n{\n    vec3 helper = vec3(1, 0, 0);\n    if (abs(normal.x) > 0.99) helper = vec3(0, 0, 1);\n    vec3 tangent = normalize(cross(normal, helper));\n    vec3 binormal = normalize(cross(normal, tangent));\n    return mat3(tangent, binormal, normal);\n}\n\nvec3 SampleHemisphere(float seed, vec3 normal, float alpha) {\n\tfloat cosTheta = pow(hash1(seed), 1.0 / (alpha + 1.0));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    float phi = 2.0 * PI * hash1(seed);\n    vec3 tangentSpaceDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    return GetTangentSpace(normal) * tangentSpaceDir;\n}\n\nfloat CosineSamplingPDF(float NdotL) {\n    return NdotL / PI;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0) {\n    return clamp(F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0), 0.0, 1.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom = a2;\n    float denom = max(NdotH2 * (a - 1.0) + 1.0, 0.0000001);\n    denom = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float nom = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = abs(dot(N, V));\n    float NdotL = abs(dot(N, L));\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 ImportanceSampleGGX(float x, float y, vec3 N, vec3 V, float roughness) {\n    float a = roughness * roughness;\n\n    float phi = 2.0 * PI * x;\n    float cosTheta = sqrt((1.0 - y) / (1.0 + (a * a - 1.0) * y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n    // from spherical coordinates to cartesian coordinates\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\n    // from tangent-space vector to world-space sample vector\n    vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\n    vec3 halfVec = tangent * H.x + bitangent * H.y + N * H.z;\n    halfVec = normalize(halfVec);\n    \n    return halfVec;\n\n}\n\nfloat ImportanceSampleGGX_PDF(float NDF, float NdotH, float VdotH) {\n    return NDF * NdotH / (4.0 * VdotH);\n}\n\nfloat CalculateFresnel(vec3 I, vec3 N, float ior) {\n    float kr;\n    float cosi = clamp(-1.0, 1.0, dot(I, N));\n    float etai = 1.0;\n\tfloat etat = ior;\n    if (cosi > 0.0) {\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n    }\n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    // Total internal reflection\n    if (sint >= 1.0) {\n        kr = 1.0;\n    } else {\n        float cost = sqrt(max(0.f, 1.0 - sint * sint));\n        cosi = abs(cosi);\n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n        kr = (Rs * Rs + Rp * Rp) / 2.0;\n    }\n    return kr;\n}\n\nvec3 RefractionBTDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N, vec3 H, float etaIn, float etaOut) {  \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n            \n    float VdotH = abs(dot(V, H));\n    float LdotH = abs(dot(L, H));\n            \n    \n    float term1 = VdotH * LdotH / (NdotV * NdotL);\n    vec3 term2 = etaOut * etaOut * (1.0 - F) * G * D;\n    float term3 = (etaIn * VdotH + etaOut * LdotH) * (etaIn * VdotH + etaOut * LdotH) + 0.001f;\n    vec3 refractionBrdf = term1 * term2 / term3;\n    \n    return refractionBrdf;\n}\n\nvec3 SpecularBRDF(float D, float G, vec3 F, vec3 V, vec3 L, vec3 N) {        \n    float NdotL = abs(dot(N, L));\n    float NdotV = abs(dot(N, V));\n    vec3 nominator = D * G * F;\n    float denominator = 4.0 * NdotV * NdotL + 0.001;\n    vec3 specularBrdf = nominator / denominator;\n    \n    return specularBrdf;\n}\n\nvec3 DiffuseBRDF(vec3 albedo) {\n    return albedo / PI;\n}\n\nvec3 Reinhard(vec3 color) {\n    return color / (color + 1.0);\n}\n\n#define SUN_DIR normalize(vec3(-0.4,0.3,-0.6))\n\nvec3 getSkyColor(vec3 rd) {\n    vec3 col = mix(vec3(1),vec3(1,0.7,0.5), 0.5+0.5*rd.y);\n    float sun = clamp(dot(SUN_DIR,rd), 0.0, 1.0);\n    float sun2 = pow(sun, 32.0);\n    col += vec3(1,0.6,0.1) * (pow(sun2, 12.0) + 2.0*pow(sun2, 16.0));\n    return max(col, vec3(0));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "struct Material {\n    vec3 albedo;\n    vec4 emissive;\n    float metallic;\n    float roughness;\n    vec3 specular;\n    float specTrans;\n    float ior;\n};\n\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    uint mat;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    uint mat;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n    vec3 color;\n    uint mat;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct HitData {\n    bool hit;\n    vec3 pos;\n    float dist;\n    vec3 normal;\n    vec3 albedo;\n    Material mat;\n};\n\nMaterial[4] g_materials;\nPlane[1] g_planes;\nSphere[3] g_spheres;\nBox[1] g_boxes;\n\nHitData createHitData() {\n    HitData hit;\n    hit.hit = false;\n    hit.pos = vec3(0);\n    hit.dist = MAX_RENDER_DISTANCE;\n    hit.normal = vec3(1.0);\n    hit.albedo = vec3(0.0);\n    \n    return hit;\n}\n\nRay setCamera(vec3 orig, vec3 forward, vec2 uv) {\n    const float focal_dist = 1.2;\n    const vec3 up_vec = vec3(0, 1, 0);\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    float i = (uv.x - 0.5) * focal_dist * aspect_ratio;\n    float j = (uv.y - 0.5) * focal_dist;\n    \n    vec3 right = cross(forward, up_vec);\n    vec3 up = cross(right, forward);\n    vec3 dir = normalize(forward + (right * i) + (up * j));\n    \n    return Ray(orig, dir);\n}\n\nvoid hitMaterial(Ray ray, inout HitData hit, float dist, vec3 color, uint matId) {\n    hit.hit = true;\n    hit.pos = ray.origin + ray.dir * dist;\n    hit.dist = dist;\n    hit.mat = g_materials[matId];\n    hit.albedo = color * hit.mat.albedo;\n}\n\nvoid hitSphere(Ray ray, inout HitData hit, Sphere sphere) {\n    vec3 base = sphere.pos - ray.origin;\n    float d1 = dot(base, ray.dir);\n    float d2Sqrt = d1 * d1 - dot(base, base) + sphere.radius * sphere.radius;\n    if (d2Sqrt < 0.0) {\n        return;\n    }\n    float d2 = sqrt(d2Sqrt);\n    float t = (d1 - d2) > 0.0 ? d1 - d2 : d1 + d2;\n    if (t > EPSILON && t < hit.dist) {\n        hitMaterial(ray, hit, t, sphere.color, sphere.mat);\n        hit.normal = normalize((hit.pos - sphere.pos) / sphere.radius);\n    }\n}\n\nvoid hitPlane(Ray ray, inout HitData hit, Plane plane) {\n    float d = dot(plane.normal, ray.dir);\n    if (d != 0.0) {\n        float t = dot(plane.pos - ray.origin, plane.normal) / d;\n        if (t > EPSILON && t < hit.dist) {\n            hitMaterial(ray, hit, t, plane.color, plane.mat);\n            hit.normal = plane.normal;\n            hit.albedo = hit.mat.albedo * texture(iChannel1, hit.pos.xz/ 2.0, 0.0).rgb;\n        }\n    }\n}\n\nfloat safe_inv(float v) {\n    return v == 0.0 ? v : 1.0 / v;\n}\n\nvec3 safe_inv3(vec3 v) {\n    return vec3(safe_inv(v.x), safe_inv(v.y), safe_inv(v.z));\n}\n\nvoid hitBox(Ray ray, inout HitData hit, Box box) {\n    vec3 t1 = safe_inv3(ray.dir) * (box.min - ray.origin);\n    vec3 t2 = safe_inv3(ray.dir) * (box.max - ray.origin);\n    vec3 tminv = min(t1, t2);\n    vec3 tmaxv = max(t1, t2);\n\n    float tmin = max(max(tminv.x, tminv.y), tminv.z);\n    float tmax = min(min(tmaxv.x, tmaxv.y), tmaxv.z);\n\n    if (tmin <= 0.0) tmin = tmax; // we are inside of box\n    \n    if (tmax > max(tmin, 0.0) && tmin < hit.dist) {\n        hitMaterial(ray, hit, tmin, box.color, box.mat);\n        vec3 norm = -sign(ray.dir) * step(tminv.yzx, tminv.xyz) * step(tminv.zxy, tminv.xyz);\n        hit.normal = norm;\n    }\n}\n\nHitData hitScene(Ray ray) {\n    HitData hit = createHitData();\n    for (int i = 0; i < g_spheres.length(); ++i) {\n        hitSphere(ray, hit, g_spheres[i]);\n    }\n    for (int i = 0; i < g_planes.length(); ++i) {\n        hitPlane(ray, hit, g_planes[i]);\n    }\n    for (int i = 0; i < g_boxes.length(); ++i) {\n        hitBox(ray, hit, g_boxes[i]);\n    }\n    return hit;\n}\n\nvec3 tracePath(Ray ray, bool daytime, inout float seed, inout vec3 radi, inout vec3 irradi) {\n    vec3 direct = vec3(0.0);\n    vec3 energy = vec3(1.0);\n    bool is_direct = true;\n    \n    for (int i = 0; i < PATH_LENGTH; ++i) {\n        HitData hit = hitScene(ray);\n        \n        if (!hit.hit) {\n            vec3 sky = daytime ? getSkyColor(ray.dir) : vec3(0);\n            radi += sky;\n            irradi += sky * energy;\n            return direct;\n        }\n        \n        vec4 e = hit.mat.emissive;\n        radi += e.rgb * e.w * e.w;\n        \n        float roulette = hash1(seed);\n        float blender = hash1(seed); //used to blend BSDF and BRDF\n        \n        if (blender < 1.0 - hit.mat.specTrans) {\n            if (is_direct) {\n                direct += hit.albedo * energy;\n            } else {\n                irradi += hit.albedo * energy;\n            }\n            vec3 reflectionDir;\n            \n            float diffuseRatio = 0.5 * (1.0 - hit.mat.metallic);\n            float specularRatio = 1.0 - diffuseRatio;\n            vec3 V = normalize(-ray.dir);\n            \n            if (roulette < diffuseRatio) { //sample diffuse\n                reflectionDir = SampleHemisphere(seed, hit.normal, 1.0);\n            } else {\n                vec3 halfVec = ImportanceSampleGGX(hash1(seed), hash1(seed), hit.normal, V, hit.mat.roughness);\n                reflectionDir = reflect(ray.dir, halfVec);\n                reflectionDir = normalize(reflectionDir);\n            }\n            \n            vec3 L = normalize(reflectionDir);\n            vec3 H = normalize(V + L);\n        \n            float NdotL = abs(dot(hit.normal, L));\n            float NdotH = abs(dot(hit.normal, H));\n            float VdotH = abs(dot(V, H));\n            \n            float NdotV = abs(dot(hit.normal, V));\n            \n            vec3 F0 = mix(hit.mat.specular, hit.albedo, hit.mat.metallic);\n        \n            float NDF = DistributionGGX(hit.normal, H, hit.mat.roughness);\n            float G = GeometrySmith(hit.normal, V, L, hit.mat.roughness);\n            vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n        \n            vec3 kS = F;\n            vec3 kD = (1.0 - kS) * (1.0 - hit.mat.metallic);\n        \n            vec3 specularBrdf = SpecularBRDF(NDF, G, F, V, L, hit.normal);\n            float specularPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            vec3 diffuseBrdf = DiffuseBRDF(hit.albedo);\n            float diffusePdf = CosineSamplingPDF(NdotL);\n\n            vec3 totalBrdf = (diffuseBrdf * kD + specularBrdf) * NdotL;\n            float totalPdf = diffuseRatio * diffusePdf + specularRatio * specularPdf;\n                \n            ray.origin = hit.pos + hit.normal * EPSILON;\n            ray.dir = reflectionDir;\n            if (totalPdf > 0.0) {\n                energy *= totalBrdf / totalPdf;\n            }\n        } else {\n            bool fromOutside = dot(ray.dir, hit.normal) < 0.0;\n            vec3 N = fromOutside ? hit.normal : -hit.normal;\n            vec3 bias = N * EPSILON;\n            \n            float etai = 1.0;\n            float etat = hit.mat.ior;\n            \n            vec3 V = normalize(-ray.dir);\n            vec3 H = ImportanceSampleGGX(hash1(seed), hash1(seed), N, V, hit.mat.roughness);\n            \n            vec3 F0 = hit.mat.specular;\n            vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n            \n            float kr = CalculateFresnel(ray.dir, hit.normal, hit.mat.ior);\n            \n            float specularRatio = kr;\n            float refractionRatio = 1.0 - kr;\n            \n            vec3 L; \n            if (roulette <= specularRatio) {\n                ray.origin = hit.pos + bias;\n                L = normalize(reflect(ray.dir, H));\n                ray.dir = L;\n            } else {\n                float eta = fromOutside ? etai / etat : etat / etai;\n                L = normalize(refract(ray.dir, H, eta));\n                ray.origin = hit.pos - bias;\n                ray.dir = L;\n                L = N;\n                if (!fromOutside) {\n                    //since the BTDF is not reciprocal, we need to invert the direction of our vectors.\n                    vec3 temp = L;\n                    L = V;\n                    V = temp;\n                        \n                    N = -N;\n                    H = -H;\n                }\n            }\n            \n            float NdotL = abs(dot(N, L));\n            float NdotV = abs(dot(N, V));\n            \n            float NdotH = abs(dot(N, H));\n            float VdotH = abs(dot(V, H));\n            float LdotH = abs(dot(L, H));\n            \n            float NDF = DistributionGGX(N, H, hit.mat.roughness);\n            float G = GeometrySmith(N, V, L, hit.mat.roughness);\n\n            vec3 specularBrdf = SpecularBRDF(NDF, G, F, V, L, N);\n            float specularPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //refraction\n            float etaOut = etat;\n            float etaIn = etai;\n            \n            vec3 refractionBtdf = RefractionBTDF(NDF, G, F, V, L, N, H, etaIn, etaOut);\n            float refractionPdf = ImportanceSampleGGX_PDF(NDF, NdotH, VdotH);\n            \n            //BSDF = BRDF + BTDF\n            vec3 totalBrdf = (specularBrdf + refractionBtdf * hit.albedo) * NdotL;\n            float totalPdf = specularRatio * specularPdf + refractionRatio * refractionPdf;\n            if (totalPdf > 0.0) {\n                energy *= totalBrdf / totalPdf;\n            }\n        }\n        is_direct = false;\n    }\n    return direct;\n}\n\nvoid initScene() {\n    Material mate1;\n    mate1.albedo = vec3(1.0);\n    mate1.emissive = vec4(0);\n    mate1.metallic = 0.0;\n    mate1.roughness = 0.2;\n    mate1.specular = vec3(0.2);\n    mate1.specTrans = 1.0;\n    mate1.ior = 1.05;\n    \n    Material mate2;\n    mate2.albedo = vec3(1.0);\n    mate2.emissive = vec4(0);\n    mate2.metallic = 0.6;\n    mate2.roughness = 0.35;\n    mate2.specular = vec3(0.2);\n    mate2.specTrans = 0.0;\n    mate2.ior = 1.0;\n    \n    Material mate3;\n    mate3.albedo = vec3(1.0);\n    mate3.emissive = vec4(0);\n    mate3.metallic = 1.0;\n    mate3.roughness = 0.01;\n    mate3.specular = vec3(1.0);\n    mate3.specTrans = 0.0;\n    mate3.ior = 1.0;\n    \n    Material mate4;\n    mate4.albedo = vec3(1.0);\n    mate4.emissive = vec4(1, 1, 1, 2);\n    mate4.metallic = 0.0;\n    mate4.roughness = 1.0;\n    mate4.specular = vec3(0.0);\n    mate4.specTrans = 0.0;\n    mate4.ior = 1.0;\n    \n    g_materials[0] = mate1;\n    g_materials[1] = mate2;\n    g_materials[2] = mate3;\n    g_materials[3] = mate4;\n    \n    g_planes[0] = Plane(vec3(0, 0, 0), vec3(0, 1, 0), vec3(1, 0, 0), 1u);\n    g_spheres[0] = Sphere(vec3(0, 5.01, 0.0), 5.0, vec3(0.9, 0.1, 0.1), 0u);\n    g_spheres[1] = Sphere(vec3(-14.3, 6.01, 8.7), 6.0, vec3(1, 0.1, 0), 2u);\n    g_spheres[2] = Sphere(vec3(13.2, 4.01, -6.2), 4.0, vec3(1, 1, 1), 3u);\n    \n    g_boxes[0] = Box(vec3(-15, 0, -15), vec3(-5, 10, -5), vec3(0.4, 0.5, 0.02), 0u);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n    float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n    initScene();\n    \n    const vec3 scene_center = vec3(0.0, 5.0, 0.0);\n    const float camera_dist = 30.0;\n    vec2 rot = abs(iMouse.xy) / iResolution.xy - 0.5;\n    vec3 ss = vec3(cos(1.5 + 6.0 * rot.x), 1.0 + 2.0 * rot.y, sin(1.5 + 6.0 * rot.x));\n    vec3 origin = scene_center + camera_dist * ss;\n    vec3 forward = normalize(scene_center - origin);\n    \n    bool reset = false;\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    float daytime = mod(floor(iTime / 5.0), 2.0);\n    \n    if (daytime != data.w\n        || round(rot * iResolution.xy) != round(data.xy)\n        || round(data.z) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n\t\tfragColor = vec4(rot * iResolution.xy, iResolution.x, daytime);\n        return;\n    }\n    \n    vec3 color = vec3(0);\n    vec3 radi = vec3(0);\n    vec3 irradi = vec3(0);\n    for (float i = 0.0; i < SAMPLES; ++i) {\n        Ray ray = setCamera(origin, forward, (fragCoord + hash2(seed)) / iResolution.xy);\n        \n        vec3 r = vec3(0);\n        vec3 ir = vec3(0);\n        vec3 t = tracePath(ray, daytime == 0.0, seed, r, ir);\n        radi += r;\n        irradi += ir;\n        color += t;\n    }\n    color /= SAMPLES;\n    radi /= SAMPLES;\n    irradi /= SAMPLES;\n    \n    color = (color + irradi) * radi;\n    \n    if (reset) {\n       fragColor = vec4(color, 1.0); \n    } else {\n       fragColor = vec4(color, 1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 28,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}