{
    "Shader": {
        "info": {
            "date": "1632031266",
            "description": "ASDW to draw wires while pressing mouse. ZQERTYU to place a multiplexer.\n` (backtick) for ground. 1 for power. X for intersection. L for reconfiguration port. Num 4-8-6-2: change parent pointer in the ownership tree.\nP to fill state with \"1\", G with \"0\".",
            "flags": 48,
            "hasliked": 0,
            "id": "7lj3Rw",
            "likes": 4,
            "name": "Greenforest Seed",
            "published": 3,
            "tags": [
                "cellular",
                "boolean",
                "circuit",
                "electronics"
            ],
            "usePreview": 0,
            "username": "brianhaak",
            "viewed": 474
        },
        "renderpass": [
            {
                "code": "// MUX VLSI Boolean logic Cellular Automata\n// ASDW to draw wires while pressing mouse. ZQERTYU to place a multiplexer.\n// ` (backtick) for ground. 1 for power. X for intersection.\n// L for reconfiguration port. Num 4-8-6-2: change parent pointer in the ownership tree.\n\n#define WIRE_THICK (0.5)\n#define HALF_WIRE_THICK (0.5 * WIRE_THICK)\n#define CENTER (4.5)\n#define SPACING (2.0)\n#define HALF_SPACING (0.5 * SPACING)\n\n// Old stuff: I had no idea what I was doing\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\n// Old stuff: I had no idea what I was doing\nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  vec2 rotated = rotate(vec2(x,y), iTime);\n  float d = max(abs(rotated.x), abs(rotated.y)) - size;\n  \n  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\n// Old stuff: I had no idea what I was doing\nfloat udSegment (vec2 p, float zoom, float th, vec2 a, vec2 b) {\n    vec2 ba = zoom * (b - a);\n    vec2 pa = p - zoom * a;\n    \n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    \n    vec2 sqrd = pa - h * ba;\n    vec2 sqrd2 = sqrd * sqrd;\n    return sqrd2.x + sqrd2.y - th;\n}\n\n// Old stuff: I had no idea what I was doing\nvec3 line(vec2 from, float dx, float dy, vec3 color, float th, float zoom, vec2 pos, vec3 mix_into) {\n    return mix(color, mix_into, step(0.0, udSegment(pos, zoom, th, from, from + vec2(dx, dy))));\n}\n\n// Geometry transformations\nvec2 rotate (vec2 point, float sine, float cosine, vec2 origin) {\n\n    // transform point position into origin's vector space:\n    vec2 point_in_origin_space = point - origin;\n\n    // rotate point\n    float Xnew = point_in_origin_space.x * cosine - point_in_origin_space.y * sine;\n    float Ynew = point_in_origin_space.x * sine + point_in_origin_space.y * cosine;\n    // TODO: simplify to mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n\n    // transform point back to the user vector space:\n    return vec2(Xnew, Ynew) + origin;\n}\n\nvec2 translate (vec2 point, float x, float y) {\n    return point + vec2(x, y);\n}\n\n// For composition to work, negative distance is where the the\n// composed \"internals\" of solids are.\nfloat right_of (float x, vec2 xy) {\n    return x - xy.x;\n}\n\nfloat left_of (float x, vec2 xy) {\n    return xy.x - x;\n}\n\n// We normalize 0 to be on top of the y axis\nfloat top_of (float y, vec2 xy) {\n    return xy.y - y;\n}\n\nfloat bottom_of (float y, vec2 xy) {\n    return y - xy.y;\n}\n\nfloat solid_rect (vec4 dim, vec2 xy) {\n    return max(right_of(dim.x, xy),\n        max(top_of(dim.w, xy),\n            max(bottom_of(dim.y, xy),\n                left_of(dim.z, xy)\n            )\n        )\n    );\n}\n\n// Constructive solid geometry: combintation operations\n\nfloat morph(float shape1, float shape2, float degree) {\n    return mix(shape1, shape2, degree);\n}\n\nfloat glue(float shape1, float shape2) {\n    return min(shape1, shape2);\n}\n\nfloat overlap(float shape1, float shape2) {\n    return max(shape1, shape2);\n}\n\nfloat subtract(float base, float removed) {\n    return max(base, -removed);\n}\n\nfloat xor(float d1, float d2) {\n    return max(min(d1, d2), -max(d1, d2)); // xor\n}\n\n// Constructive solid geometry: primitives\n\nfloat disc(vec2 pos, float diameter, vec2 xy) {\n    vec2 dist = xy - pos;\n    return dot(dist, dist) * 4.0 - diameter * diameter;\n}\n\n// DO NOT CHANGE THE ORDER of your calls to compose()\nvec3 compose(float shape, vec3 shape_color, vec3 color) {//, float anti_alias) {\n    //return mix(color, shape_color, step(shape, 0.0));\n    \n    //return mix(color, shape_color, smoothstep(5.0, -5.0, shape));\n    // return mix(color, shape_color, smoothstep(anti_alias, -anti_alias, shape));\n    return mix(color, shape_color, smoothstep(0.2, -0.3, 0.042 * zoom_factor * shape));\n}\n\n// Discs look better with different smooth factors to anti-alias\nvec3 compose_antialias(float shape, vec3 shape_color, vec3 color) {\n\n    return mix(color, shape_color, smoothstep(5.0, -1.0, 0.042 * zoom_factor * shape));\n}\n\nvec3 my_blend(vec3 source, vec3 dest, float alpha) {\n    return source * alpha + dest * (1.0 - alpha);\n}\n\nvec4 transparent_compose(float shape, vec4 shape_color, vec4 color) {\n    float shape_cutoff = step(shape, 0.0);\n\n    // Add two transparencies with saturation to 1.0 max.\n    float composed_alpha = min(shape_color.a + color.a, 1.0);\n    return vec4(mix(\n        color.rgb,\n        my_blend(shape_color.rgb * shape_cutoff,\n                 color.rgb,\n                 shape_color.a),\n                 shape_cutoff),\n        composed_alpha);\n}\n\n\n\nfloat consumes_from_the_left(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation < 0.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 1.5 && cell.orientation > 2.5) ||\n    (((cell.mode > 1.5 && cell.mode < 3.5) || cell.mode > 5.5)\n        && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 1.5 && cell.mode < 5.5\n        && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 3.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_left(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_bottom(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_right(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 2.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation > 2.5) ||\n    (cell.mode > 3.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 1.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 1.5 && cell.mode < 3.5 && cell.orientation < 0.5) ||\n    (cell.mode > 5.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_right(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_top(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_top(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 0.5 && cell.orientation < 1.5) ||\n    // a MUX with an input from the left\n    (cell.mode > 3.5 && cell.orientation > 2.5) ||\n    (cell.mode > 1.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.orientation < 1.5 && cell.orientation > 0.5) &&\n        ((cell.mode > 1.5 && cell.mode < 3.5) || (cell.mode > 5.5)) ||\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_top(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_left(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nfloat consumes_from_the_bottom(Element cell) {\n    \n    // crossbar\n    return (cell.mode < 0.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    // wire\n    (cell.mode > 0.5 && cell.mode < 1.5 && cell.orientation > 1.5 && cell.orientation < 2.5) ||\n    // a MUX with an input from the left\n    (cell.orientation > 2.5 && (\n        (cell.mode > 1.5 && cell.mode < 3.5) || cell.mode > 5.5)) ||\n    (cell.mode > 1.5 && cell.mode < 5.5 && cell.orientation < 2.5 && cell.orientation > 1.5) ||\n    (cell.mode > 3.5 && cell.orientation < 1.5 && cell.orientation > 0.5) ||\n    (cell.mode > 1.5 && cell.orientation < 0.5)\n    || is_reconf_port(cell) * is_bottom(cell.parent) > 0.5\n    || is_reconf_port(cell) * is_right(cell.parent) > 0.5\n    ? 1.0 : 0.0;\n}\n\nvec4 draw_crossbar_signal(vec2 center, float current, float next, vec4 visual, vec2 p) {\n\n    // TODO: I do too many computations based on black for \"1\" and white for \"0\".\n    // It will make it hard to adjust for bright and dark green palette, for example!\n    vec3 next_color = vec3(1.0 - next);\n    vec3 curr_color = vec3(1.0 - current);\n\n    float outer_disc = disc(center, 3.8 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    \n    float middle_disc = disc(center, 2.5 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    visual = vec4(compose_antialias(middle_disc, curr_color, visual.rgb), 1.0);\n    \n    //float inner_disc = disc(center, 2.0 * WIRE_THICK, p); // TODO: replace the diameter with spacing param\n    //visual = vec4(compose(inner_disc, next_color, visual.rgb), 1.0);\n\n    return visual;\n}\n\nvec4 cfg_dbg(float val, float x, float y, vec2 p, vec4 visual, vec3 color) {\n    // float s = disc(vec2(x, y), 1.1 * WIRE_THICK, p);\n    float s = disc(vec2(x, y), 0.001 * WIRE_THICK, p);\n    visual = vec4(compose_antialias(5.0 * s, 8.0 * color * val, visual.rgb), 1.0);\n    \n    return visual;\n}\n\nvec4 draw_a_cell (Element cell, Element left, Element top, Element right, Element bottom, vec2 p, vec4 visual) {\n\n    // p spans from 0.01 to 7.99. There's a small gap of 0.5 a cell lacks at the right and bottom,\n    // it's placed slightly asymmetric to provide a good resolution even at 8x8 pixels per cell.\n\n\n/*\n----\n\\  |\n \\ |\n  \\|\n*/\n\n    /*\n    \n        We combine the DFF ring with all output wires because they reflect the same physical entity.\n    \n        We draw an output if the adjacent cell has one of its inputs pointing to this cell.\n        Outputs are canonical: all cells no matter their type have 4 outputs.\n        \n        We ALWAYS draw all input wires. In advanced vis, the wires might contain signal color inside.\n            GND and PWR: 0 inputs\n            MUX: 3 inputs\n            Crossbar: 4 inputs (not clear if we should draw those lines when no consumers)\n            Wire: 1 input.\n\n        We draw diagonal lines for the active MUX input and a short one looking like --/\n        showing the selector input.\n    */\n\n    float show_in_left = consumes_from_the_left(cell);\n    float show_out_right = consumes_from_the_left(right);\n\n    float show_in_right = consumes_from_the_right(cell);\n    float show_out_left = consumes_from_the_right(left);\n\n    float show_in_top = consumes_from_the_top(cell);\n    float show_out_bottom = consumes_from_the_top(bottom);\n\n    float show_in_bottom = consumes_from_the_bottom(cell);\n    float show_out_top = consumes_from_the_bottom(top);\n    \n    float no_connections = show_in_left+show_out_right+show_in_right\n      +show_out_left+show_in_top+show_out_bottom+show_in_bottom+show_out_top;\n\n\n    // Outputs\n\n    if (show_out_right > 0.5) {\n        float out_right = solid_rect(vec4(\n            2.5, CENTER - HALF_SPACING - HALF_WIRE_THICK,\n            8.0, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(out_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_left > 0.5) {\n        float out_left = solid_rect(vec4(\n            0.0, CENTER + HALF_SPACING - HALF_WIRE_THICK,\n            6.5, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(out_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_bottom > 0.5) {\n        float out_bottom = solid_rect(vec4(\n            CENTER + HALF_SPACING - HALF_WIRE_THICK, 2.5,\n            CENTER + HALF_SPACING + HALF_WIRE_THICK, 8.0), p);\n        visual = vec4(compose(out_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    if (show_out_top > 0.5) {\n        float out_top = solid_rect(vec4(\n            CENTER - HALF_SPACING - HALF_WIRE_THICK, 0.0,\n            CENTER - HALF_SPACING + HALF_WIRE_THICK, 6.5), p);\n        visual = vec4(compose(out_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n\n    // ---------------------------------------\n    // Crossbar D flip-flop state bubbles\n    if (cell.mode < 0.5 && cell.orientation > 0.5 && cell.orientation < 1.5) {\n    \n        vec2 signal_bubble_center = vec2(1.9, 3.5);\n    \n        if (show_in_left * show_out_right > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.right, left.right, visual, p);\n        }\n        if (show_in_top * show_out_bottom > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.bottom, top.bottom, visual,\n                rotate(p, sin(radians(-90.0)), cos(radians(-90.0)), vec2(CENTER)));\n        }\n        if (show_in_right * show_out_left > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.left, right.left, visual,\n                rotate(p, sin(radians(-180.0)), cos(radians(-180.0)), vec2(CENTER)));\n        }\n        if (show_in_bottom * show_out_top > 0.5) {\n            visual = draw_crossbar_signal(signal_bubble_center, cell.top, bottom.top, visual,\n                rotate(p, sin(radians(-270.0)), cos(radians(-270.0)), vec2(CENTER)));\n        }\n    }\n\n    // Draw inputs on top of crossbar DFF state bubbles\n    if (show_in_left > 0.5) {\n        float in_left = solid_rect(vec4(\n            0.0, CENTER - HALF_SPACING - HALF_WIRE_THICK,\n            1.56, CENTER - HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(in_left, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_right > 0.5) {\n        float in_right = solid_rect(vec4(\n            7.35, CENTER + HALF_SPACING - HALF_WIRE_THICK,\n            8.0, CENTER + HALF_SPACING + HALF_WIRE_THICK), p);\n        visual = vec4(compose(in_right, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_top > 0.5) {\n        float in_top = solid_rect(vec4(\n            CENTER + HALF_SPACING - HALF_WIRE_THICK, 0.0,\n            CENTER + HALF_SPACING + HALF_WIRE_THICK, 1.56), p);\n        visual = vec4(compose(in_top, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (show_in_bottom > 0.5) {\n        float in_bottom = solid_rect(vec4(\n            CENTER - HALF_SPACING - HALF_WIRE_THICK, 7.35,\n            CENTER - HALF_SPACING + HALF_WIRE_THICK, 8.0), p);\n        visual = vec4(compose(in_bottom, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n    }\n    \n    if (cell.mode > 0.5 || cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {\n    \n        float next_value = 0.0;\n        float l = 0.0;\n        if (cell.mode > 1.5) {\n\n            if (cell.orientation > 2.5) {\n                next_value = mux_action(cell.mode, left.right, right.left, bottom.top, top.bottom);\n                l = left.right;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = mux_action(cell.mode, top.bottom, bottom.top, left.right, right.left);\n                l = top.bottom;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                next_value = mux_action(cell.mode, right.left, left.right, top.bottom, bottom.top);\n                l = right.left;\n            } else if (cell.orientation < 0.5) {\n                next_value = mux_action(cell.mode, bottom.top, top.bottom, right.left, left.right);\n                l = bottom.top;\n            }\n        } else if (cell.mode < 1.5 && cell.mode > 0.5) {\n            // wire\n            if (cell.orientation > 2.5) {\n                next_value = right.left;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = bottom.top;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                next_value = top.bottom;\n            } else if (cell.orientation < 0.5) {\n                next_value = left.right;\n            }\n        } else if (cell.mode < 0.5) {\n            if (cell.orientation > 2.5) {\n                next_value = 1.0;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                next_value = 0.0;\n            } else if (is_reconf_port(cell) > 0.5) {\n                //l = cell.parent;\n                \n                if (cell.parent > 2.5) {\n                    l = left.right;\n                } else if (cell.parent < 2.5 && cell.parent > 1.5) { \n                    l = bottom.top;\n                } else if (cell.parent < 1.5 && cell.parent > 0.5) {\n                    l = right.left;\n                } else if (cell.parent < 0.5) {\n                    l = top.bottom;\n                }\n            }\n        }\n    \n        // Not a crossbar or reconf port\n\n        // MUX, GND, PWR, WIRE D flip-flop state (current and next)\n        // There are 4 discs on top of each other\n        float inner_disc = 0.0;\n        float bigger_inner_disc = 0.0;\n        float outer_disc = 0.0;\n        float smaller_outer_disc = 0.0;\n        \n        float outer_disc_diameter = 5.0;\n        \n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            // If it's wire, make shapes smaller please!\n            inner_disc = 100.0; //disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);\n            bigger_inner_disc = disc(vec2(4.5, 4.5), 4.1 * WIRE_THICK, p);\n            outer_disc_diameter = 4.1;\n        } else {\n            inner_disc = disc(vec2(4.5, 4.5), 2.0 * WIRE_THICK, p);\n            bigger_inner_disc = disc(vec2(4.5, 4.5), 5.0 * WIRE_THICK, p);\n        }\n        \n        outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter, p);\n        smaller_outer_disc = disc(vec2(4.5, 4.5), outer_disc_diameter - 2.0 * WIRE_THICK, p);\n        \n\n        visual = vec4(compose_antialias(outer_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        \n        \n        if (cell.mode > 0.5 || cell.mode < 0.5 && cell.orientation > 1.5 || is_reconf_port(cell) > 0.5) {\n\n            if (cell.right < 0.5) {\n                visual = vec4(compose_antialias(smaller_outer_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n\n                // Don't draw if 0->1\n                //if (next_value < 0.5 || cell.right > 0.5) {\n                //    visual = vec4(compose(bigger_inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n                //}\n            } else {\n                visual = vec4(compose_antialias(bigger_inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n            }\n        }\n        \n      \n        // MUX currently switched input (s ? a : b => s = 1 -> a : s = 0 -> b)\n        float rotate_sel = (3.0 - cell.orientation) * -90.0;\n        float rotate_curr = rotate_sel;\n        \n        float rotate_alt = 0.0;\n        float mux_mode = 7.0 - cell.mode;\n     \n        // Switch over 6 modes\n        if (mux_mode < 0.5) {\n            // rotate_curr = l > 0.5 ? b : t;\n            rotate_curr += l > 0.5 ? 90.0 : -90.0;\n        } else if (mux_mode > 0.5 && mux_mode < 1.5) {\n            //result = l > 0.5 ? t : b;\n            rotate_curr += l > 0.5 ? -90.0 : 90.0;\n        } else if (mux_mode > 1.5 && mux_mode < 2.5) {\n            //result = l > 0.5 ? r : t;\n            rotate_curr += l > 0.5 ? 180.0 : 270.0;\n        } else if (mux_mode > 2.5 && mux_mode < 3.5) {\n            //result = l > 0.5 ? t : r;\n            rotate_curr += l > 0.5 ? 270.0 : 180.0;\n        } else if (mux_mode > 3.5 && mux_mode < 4.5) {\n            //result = l > 0.5 ? r : b;\n            rotate_curr += l > 0.5 ? 180.0 : 90.0;\n        } else if (mux_mode > 4.5 && mux_mode < 5.5) {\n            //result = l > 0.5 ? b : r;\n            rotate_curr += l > 0.5 ? 90.0 : 180.0;\n        }\n        \n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            // WIRE\n            if (cell.orientation > 2.5) {\n                rotate_curr = 180.0;\n            } else if (cell.orientation < 2.5 && cell.orientation > 1.5) {\n                rotate_curr = 90.0;\n            } else if (cell.orientation < 1.5 && cell.orientation > 0.5) {\n                rotate_curr = -90.0;\n            } else if (cell.orientation < 0.5) {\n                rotate_curr = 0.0;\n            }\n            \n            // visual = transparent_compose(-1.0, vec4(1.0, 0.0, 0.0, 0.5), visual);\n        } else if (is_reconf_port(cell) > 0.5) {\n            rotate_curr = (4.0 - cell.parent) * 90.0;\n        }\n        \n        //---------------------------------------------\n        // Currently selected input (A or B) for MUX or THE input for wires\n        vec2 input_vertex = vec2(1.5, CENTER - HALF_SPACING);\n        float mux_current_input_halo = solid_rect(vec4(\n            input_vertex.x, input_vertex.y - 2.0 * WIRE_THICK,\n            CENTER, CENTER - HALF_SPACING + 2.25 * WIRE_THICK),\n            \n            rotate(\n                rotate(p,\n                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),\n                    vec2(CENTER)\n                ),\n                sin(radians(-18.0)), cos(radians(-18.0)),\n                input_vertex + vec2(0.0, HALF_WIRE_THICK)\n            )\n        );\n        if (cell.mode > 0.5 && cell.mode < 1.5) {\n            ;\n        } else if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose(mux_current_input_halo, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n        }\n        \n        float mux_current_input = solid_rect(vec4(\n            input_vertex.x - 0.1, input_vertex.y - HALF_WIRE_THICK,\n            CENTER, CENTER - HALF_SPACING + HALF_WIRE_THICK),\n            rotate(\n                rotate(p,\n                    sin(radians(rotate_curr)), cos(radians(rotate_curr)),\n                    vec2(CENTER)\n                ),\n                sin(radians(-18.0)), cos(radians(-18.0)),\n                input_vertex + vec2(0.0, HALF_WIRE_THICK)\n            )\n        );\n\n        \n        // If 1 -> 0, don't draw this\n\n        /* if (cell.right < 0.5 && next_value < 0.5) {\n            // If 0 -> 0\n            visual = vec4(compose(inner_disc, vec3(1.0, 1.0, 1.0), visual.rgb), 1.0);\n        } else if (next_value > 0.5) {\n            // If 1->1 or 0->1\n            visual = vec4(compose(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        } */\n        \n        if (cell.mode > 0.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose_antialias(inner_disc, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n            visual = vec4(compose(mux_current_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        }\n        \n        \n        // ------- MUX Selector Input --------------\n        \n        vec2 selector_input_vertex = vec2(1.5, CENTER - HALF_SPACING);\n        \n        if (cell.mode < 0.5) {\n            // l = 0.0; // reconf port clock source\n            rotate_sel = (3.0 - cell.parent) * 90.0;\n        }\n        \n        float engaged_selector_offset = l > 0.5 ? -0.05 : 0.55;\n        \n        float mux_selector_input = solid_rect(vec4(\n            selector_input_vertex.x,\n            selector_input_vertex.y - 2.0,\n            selector_input_vertex.x + 0.1 + WIRE_THICK,\n            selector_input_vertex.y + 0.2),\n            translate(\n                rotate(\n                    rotate(p,\n                        sin(radians(rotate_sel)), cos(radians(rotate_sel)),\n                        vec2(CENTER)\n                    ),\n                    sin(radians(-18.0)), cos(radians(-18.0)),\n                    selector_input_vertex + vec2(0.0, HALF_WIRE_THICK)\n                ),\n                engaged_selector_offset, // 0.4: not engaged; -0.1: engaged\n                -1.0\n            )\n        );\n        \n        if (cell.mode > 1.5 || is_reconf_port(cell) > 0.5) {\n            visual = vec4(compose(mux_selector_input, vec3(0.0, 0.0, 0.0), visual.rgb), 1.0);\n        }\n        \n        if (cell.mode > 1.5) {\n            visual = vec4(compose(-0.15 * (24.0 / zoom_factor), 1.0 * visual.rgb, 1.0 * vec3(1.0, 0.69, 0.1)), 1.0);\n        }\n    }\n    \n    //if (cell.write_pointer_counter > 0.5) {\n        visual = vec4(compose(0.0, vec3(1.0 - 2.0 * cell.write_pointer_counter * (1.0/14.0), 1.0, 1.0), visual.rgb), 1.0);\n    //}\n    \n    // Debug config signals:\n    /*\n    vec3 dat_clr = vec3(1.0, 0.0, 0.0);\n    visual = cfg_dbg(cell.LDO, 1.5, 2.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.TDO, 6.5, 1.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.RDO, 7.0, 6.5, p, visual, dat_clr);\n    visual = cfg_dbg(cell.BDO, 2.5, 7.0, p, visual, dat_clr);\n    \n    vec3 clk_clr = vec3(0.0, 0.0, 1.0);\n    visual = cfg_dbg(cell.LCO, 1.5, 2.5 - 1.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.TCO, 6.5 + 1.0, 1.5, p, visual, clk_clr);\n    visual = cfg_dbg(cell.RCO, 7.0, 6.5 + 1.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.BCO, 2.5 - 1.0, 7.0, p, visual, clk_clr);\n\n    visual = cfg_dbg(cell.PREV_CLK, 4.5, 4.0, p, visual, clk_clr);\n    visual = cfg_dbg(cell.WE_ARE_FULL_DFF, 4.5, 5.0, p, visual, dat_clr);\n    */\n    if (is_reconf_port(cell) > 0.5) {\n        visual = vec4(compose(0.01 * (24.0 / zoom_factor), vec3(0.2, 0.0, 1.0), visual.rgb), 0.8);\n    } else if (no_connections < 0.5 && cell.mode < 0.5 && cell.orientation > 1.5 && cell.orientation < 2.5) {\n        // skip drawing the GND cells\n        \n        return vec4(1.0);\n    }\n\n\n    \n\n    return visual;\n}\n\nvec4 render (in vec2 fragCoord) {\n\n    vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n\n    \n    //Bitset8Bits cfg = cfgBlockFromTexel(texture(iChannel0, vec2(0.0)));\n    //if (cfg.bit0.r > 0.5) {\n    //    zoom_factor = 128.0;\n    //}\n    \n    vec2 mouse_cell = cell_from_visual(m.xy, zoom_factor);\n    \n    float scale = 1.0 / zoom_factor;\n    vec2 tex_coord_from_screen = 1.0 / iResolution.xy;\n    \n   \n    vec2 cell_coord = floor((fragCoord - 0.5) * scale + vec2(0.5, 0.5) * scale);\n    \n    vec2 gpgpu_coord = (0.5 + cell_coord + vec2(0.0, 0.0));\n    \n    if (is_config_param_block(gpgpu_coord) > 0.5) {\n        return vec4(0.0);\n    }\n    \n    vec2 fetch_coord = gpgpu_coord / iChannelResolution[0].xy;\n    \n    vec4 gpgpu_data = texture(iChannel0, fetch_coord);\n    \n    //return gpgpu_data;\n    \n    // Fetch neighbor elements or IO surface bits\n    Element left = elementFromTexel(texture(iChannel0, (0.5 + cell_coord - vec2(1.0, 0.0)) / iChannelResolution[0].xy));\n    Element right = elementFromTexel(texture(iChannel0, (0.5 + cell_coord + vec2(1.0, 0.0)) / iChannelResolution[0].xy));\n    Element top = elementFromTexel(texture(iChannel0, (0.5 + cell_coord - vec2(0.0, 1.0)) / iChannelResolution[0].xy));\n    Element bottom = elementFromTexel(texture(iChannel0, (0.5 + cell_coord + vec2(0.0, 1.0)) / iChannelResolution[0].xy));\n\n    vec4 green_background = vec4(0.0, 0.5, 0.0, 1.0);\n    vec4 white_background = vec4(1.0, 1.0, 1.0, 1.0);\n    // vec4 visual = green_background;\n    vec4 visual = white_background;\n    \n    // Position within a tile\n    // vec2 p = mod(fragCoord, zoom_factor);\n    vec2 p = 8.0 * mod(fragCoord * scale, 1.0);// + vec2(0.5);\n    \n    // p = vec2(p.x, 8.0 - p.y);\n    //p = vec2(8.0 - p.x, p.y);\n\n\n    Element cell = elementFromTexel(gpgpu_data);\n    \n    if (zoom_factor > 15.0) {\n    \n        vec4 cell_visual = draw_a_cell(cell, left, top, right, bottom, p, visual);\n    \n        // Compose the cell over the background (can be transparent)\n        visual = transparent_compose(-1.0, vec4(cell_visual.rgb, 2.0), visual);\n    } else {\n        visual = transparent_compose(-1.0, vec4(vec3(1.0 - cell.right), 1.0), visual);\n    }\n    \n \n    // Uncomment to only show the ownership spanning tree\n    // vec3 col = vec3(1.0);\n\n    vec3 col = visual.rgb;\n    \n\n    vec2 center = vec2(0.55, 0.55);\n    vec3 overlay_color = vec3(1.0);\n    \n    vec3 parent_color = cell.PREV_CLK < 0.5 ? vec3(0.6, 0.4, 0.1) : vec3(0.8, 0.1, 0.1);\n    \n    // vec3 parent_color = vec3(0.6, 0.0, 0.0);\n    vec3 twig_color_clocked = vec3(0.0, 0.0, 0.0);\n    vec3 twig_color = vec3(0.1, 0.5, 0.0);\n    \n    float parent_thickness = zoom_factor * zoom_factor / 128.0 * 0.5;\n    float twig_thickness = zoom_factor * zoom_factor / 128.0 * 0.15;\n\n    // Children twigs\n    \n    p = mod(fragCoord, zoom_factor);\n    if (is_right(left.parent) > 0.5) {\n        vec3 twig_color = cell.LCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, -0.5, 0.0, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_bottom(top.parent) > 0.5) {\n        vec3 twig_color = cell.TCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.0, -0.5, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_left(right.parent) > 0.5) {\n        vec3 twig_color = cell.RCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.5, 0.0, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_top(bottom.parent) > 0.5) {\n        vec3 twig_color = cell.BCO > 0.5 ? twig_color_clocked : twig_color;\n        overlay_color = line(center, 0.0, 0.5, twig_color, twig_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    // Parent twig\n    if (is_left(cell.parent) > 0.5) {\n        overlay_color = line(center - vec2(0.25, 0.0), -0.3, 0.0, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_top(cell.parent) > 0.5) {\n        overlay_color = line(center - vec2(0.0, 0.25), 0.0, -0.3, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_right(cell.parent) > 0.5) {\n        overlay_color = line(center + vec2(0.25, 0.0), 0.3, 0.0, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    if (is_bottom(cell.parent) > 0.5) {\n        overlay_color = line(center + vec2(0.0, 0.25), 0.0, 0.3, parent_color, parent_thickness, zoom_factor, p, overlay_color);\n    }\n    \n    col = compose(-0.09 * (24.0 / zoom_factor), visual.rgb, overlay_color);\n    \n    //col = overlay_color;\n    \n    \n    //col = 1.5 * transparent_compose(-1.0, vec4(0.5 * col, 0.95),\n    //   vec4(5.0 * overlay_color, 0.0)).rgb;\n    //col = 1.5 * transparent_compose(-1.0, vec4(0.5 * col, 0.95),\n    //   vec4(5.0 * overlay_color, 0.0)).rgb;\n    //col = 2.0 * compose(-0.15, 0.25 * visual.rgb, 2.0 * overlay_color);\n    // col = transparent_compose(-1.0, vec4(overlay_color, 0.5), vec4(2.0 * col, 1.0)).rgb;\n    \n    //if (cell.conf_signal < 0.5) {\n    //    col = transparent_compose(-1.0, vec4(1.0, 1.0, 1.0, 0.4), vec4(col, 1.0)).rgb;\n    //}\n    \n\n    // m.z is button pressed\n    // m.w is button state changed from \"not pressed\" to \"pressed\" (only one frame)\n    if (m.z > 0.5 && abs(mouse_cell - gpgpu_coord).x < 0.5 && abs(mouse_cell - gpgpu_coord).y < 0.5) {\n    \n        return transparent_compose(-1.0, vec4(1.0, 1.0, 0.0, 0.35), vec4(col, 1.0));\n    }\n    \n    return vec4(col, 1.0);\n}\n\n\n// Circles and a \"proper\" SDF composition\nvec4 render2 (in vec2 xy) {\n    vec3 white_background = vec3(1.0, 1.0, 1.0);\n    \n    vec3 color = white_background;\n  \n    vec2 c = vec2(700.0, 700.0);\n    \n    //xy = mod(3.0 * xy + 0.5 * c, c) - 0.1 * c;\n    \n    xy = 8.0 * mod(xy / 256.0, 1.0);\n    \n    color = compose(//xor(\n             //1.0, //\n             glue(disc(vec2(4.500, 4.500), 4.000, xy),\n             1.0 //solid_rect(vec4(2.000, 3.000, 4.000, 5.000), xy)\n             )\n             ,\n        vec3(0.5, 0.5, 1.0), color);\n\n    float innrshp = glue(1.0,\n        glue(\n             disc(vec2(4.500, 4.500), 4.000, xy),\n             1.0//solid_rect(vec4(2.200, 3.000, 3.800, 5.500), xy)\n             ));\n    \n    //color = transparent_compose(innrshp, vec4(0.0, 0.0, 0.0, 0.35), color);\n\n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    fragColor = render(vec2(fragCoord.x, iResolution.y - fragCoord.y));\n    //fragColor = render(fragCoord);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Random number generator. Borrowed from https://www.shadertoy.com/view/wltcRS\n//\n// Usage:\n    \n//   rng_initialize(fragCoord, iFrame);\n    \n//   fragColor = rand4();\n\n\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n\nfloat whenGt (float l, float r) {\n  return max(sign(l - r), 0.0);\n}\n\nlowp vec2 ctrlOffset (float dir) {\n    \n  return vec2(-1.0,  0.0) * whenGt(dir, 0.5) * whenGt(1.5, dir) +\n         vec2( 0.0, -1.0) * whenGt(dir, 1.5) * whenGt(2.5, dir) +\n         vec2( 0.0,  1.0) * whenGt(dir, 2.5) * whenGt(3.5, dir) +\n         vec2( 1.0,  0.0) * whenGt(dir, 3.5) * whenGt(4.5, dir);\n}\n\n\nfloat at(float x, float y, vec2 fragCoord) {\n    if (fragCoord.x > (x + 0.1) && fragCoord.x < (x + 0.9) &&\n        fragCoord.y > (y + 0.1) && fragCoord.y < (y + 0.9)\n    ) {\n        return 1.0;\n    }\n    \n    return 0.0;\n}\n\n// \"mode\" \"orientation\" \"at\"\nElement moa(float mode, float orientation, float x, float y, Element elt, vec2 fragCoord) {\n    if (at(x, y, fragCoord) > 0.5) {\n        elt.mode = mode;\n        elt.orientation = orientation;\n    }\n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.write_pointer_counter = 0.0;\n    return elt;\n}\n\n// \"mode\" \"orientation\" \"value\" \"at\"\nElement mova(float mode, float orientation, float value, float x, float y, Element elt, vec2 fragCoord) {\n    if (at(x, y, fragCoord) > 0.5) {\n        elt.mode = mode;\n        if (value < 1.5) { // > 1.0 will keep random\n            elt.left = elt.top = elt.bottom = elt.right = value;\n        }\n        elt.orientation = orientation;\n    }\n    \n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.write_pointer_counter = 0.0;\n    return elt;\n}\n\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint kBacktick = 192, k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\nint kNumLeft=100, kNumUp=104, kNumDown=98, kNumRight=102;\n\nElement computeElement (in Element old, in vec2 fragCoord) {\n\n    Element elt = old;\n    \n    Bitset8Bits cfg = cfgBlockFromTexel(texture(iChannel0, vec2(0.0)));\n    if (cfg.bit0.r > 0.5) {\n        return old;\n    }\n\n    vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n    vec2 mouse_cell = cell_from_visual(m.xy, zoom_factor);\n    \n    // m.z is button pressed\n    // m.w is button state changed from \"not pressed\" to \"pressed\" (only one frame)\n    if (m.z > 0.5 && abs(mouse_cell - fragCoord).x < 0.5 && abs(mouse_cell - fragCoord).y < 0.5) {\n\n        float y = 0.0;\n        // Ground\n        if (texelFetch(iChannel1, ivec2(kG, 0), 0).x > 0.5) {\n            elt.left = elt.top = elt.bottom = elt.right = 0.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kBacktick, 0), 0).x > 0.5) {\n            // GND\n            return mova(0., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kP, 0), 0).x > 0.5) {\n            elt.left = elt.top = elt.bottom = elt.right = 1.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(k1, 0), 0).x > 0.5) {\n            // PWR\n            return mova(0., 3., 1., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kA, 0), 0).x > 0.5) {\n            // Wire from left\n            return mova(1., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kW, 0), 0).x > 0.5) {\n            // Wire from up\n            return mova(1., 1., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kS, 0), 0).x > 0.5) {\n            // Wire down\n            return mova(1., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kD, 0), 0).x > 0.5) {\n            // Wire right\n            return mova(1., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kE, 0), 0).x > 0.5) {\n            // MUX type 1\n            return mova(7., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kQ, 0), 0).x > 0.5) {\n            // MUX type 2\n            return mova(3., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kR, 0), 0).x > 0.5) {\n            // MUX type 3 (selector from the bottom)\n            return mova(5., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kT, 0), 0).x > 0.5) {\n            // MUX type 4 (selector from the left but one of the inputs from the right)\n            return mova(3., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kZ, 0), 0).x > 0.5) {\n            // MUX type 5\n            return mova(2., 2., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kY, 0), 0).x > 0.5) {\n            // MUX type 6\n            return mova(6., 3., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kU, 0), 0).x > 0.5) {\n            // MUX type 7 (selector from the bottom)\n            return mova(4., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kX, 0), 0).x > 0.5) {\n            // Intersection\n            return mova(0., 1., 1., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n        } else if (texelFetch(iChannel1, ivec2(kL, 0), 0).x > 0.5) {\n            // Ownership subtree overlay entry (a reconfuguration port) \n            Element cfgport = mova(0., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n            cfgport.conf_signal = 0.0;\n            cfgport.parent = 0.0; // left\n            // cfgport.cfg_read = cfgport.cfg_write = 0.0;\n            // Subtree readback value\n            cfgport.left = cfgport.right = cfgport.top = cfgport.bottom = 0.0;\n            return cfgport;\n            \n        } else if (texelFetch(iChannel1, ivec2(kNumLeft, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 0.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumUp, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 1.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumRight, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 2.0;\n            return elt;\n        } else if (texelFetch(iChannel1, ivec2(kNumDown, 0), 0).x > 0.5) {\n            // Ownership parent supertree pointer (toward the tree spaning from the\n            // reconfuguration port)\n            elt.parent = 3.0;\n            return elt;\n        }\n    }\n\n    // On mouse release when this cell is being rendered\n    //if (m.z < 0.5 && cfg.bit0.g > 0.5 && abs(mouse_cell - gpgpu_coord).x < 0.5 && abs(mouse_cell - gpgpu_coord).y < 0.5) {\n    //}\n    \n    // Fetch neighbor elements or IO surface bits\n    Element left = elementFromTexel(texture(iChannel0, (fragCoord - vec2(1.0, 0.0))/iChannelResolution[0].xy));\n    Element right = elementFromTexel(texture(iChannel0, (fragCoord + vec2(1.0, 0.0))/iChannelResolution[0].xy));\n    Element top = elementFromTexel(texture(iChannel0, (fragCoord - vec2(0.0, 1.0))/iChannelResolution[0].xy));\n    Element bottom = elementFromTexel(texture(iChannel0, (fragCoord + vec2(0.0, 1.0))/iChannelResolution[0].xy));\n    \n    // Cell reconfiguration local clock\n    lowp float CLK = 0.0;\n    \n    if (is_config_param_block(fragCoord + vec2(0.0, -1.0)) > 0.5) {\n        top.parent = 3.0; // bottom\n        top.conf_signal = 0.0;\n        top.mode = 0.0;\n        top.orientation = 2.0;\n    } else if (is_config_param_block(fragCoord + vec2(-1.0, 0.0)) > 0.5) {\n        left.parent = 2.0; // right\n        left.conf_signal = 0.0;\n        left.mode = 0.0;\n        left.orientation = 2.0;\n    }\n    \n    if (fragCoord.x < 0.9) {\n        left.parent = 2.0; // right\n        left.conf_signal = 0.0;\n        left.mode = 0.0;\n        left.orientation = 2.0;\n    } else if (fragCoord.x > COMPUTER_WIDTH - 1.0) {\n        right.parent = 0.0; // left\n        right.conf_signal = 0.0;\n        right.mode = 0.0;\n        right.orientation = 2.0;\n    }\n    \n    if (fragCoord.y < 0.9) {\n        top.parent = 3.0; // bottom\n        top.conf_signal = 0.0;\n        top.mode = 0.0;\n        top.orientation = 2.0;\n    } else if (fragCoord.y > COMPUTER_HEIGHT - 1.0) {\n        bottom.parent = 1.0; // top\n        bottom.conf_signal = 0.0;\n        bottom.mode = 0.0;\n        bottom.orientation = 2.0;\n    }\n        \n    // If element not configured, don't flow data\n    // Disabled due to the new coarse-grained mini-FPGA model\n    // Enabled again to try the fine grained cellular model. FPGAs are not necessary.\n    //if (elt.conf_signal > 0.5) {\n    \n    lowp float is_crossbar = 0.0;\n    \n    lowp float LDI = left.RDO;\n    lowp float LCI = left.RCO;\n    lowp float TDI = top.BDO;\n    lowp float TCI = top.BCO;\n    lowp float RDI = right.LDO;\n    lowp float RCI = right.LCO;\n    lowp float BDI = bottom.TDO;\n    lowp float BCI = bottom.TCO;\n\n    lowp float PARENT_IS_LEFT = is_left(elt.parent);\n    lowp float PARENT_IS_TOP = is_top(elt.parent);\n    lowp float PARENT_IS_RIGHT = is_right(elt.parent);\n    lowp float PARENT_IS_BOTTOM = is_bottom(elt.parent);\n\n    lowp float LEFT_IS_A_CHILD = LDI > 0.5 && PARENT_IS_LEFT < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_A_CHILD = TDI > 0.5 && PARENT_IS_TOP < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_A_CHILD = RDI > 0.5 && PARENT_IS_RIGHT < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_A_CHILD = BDI > 0.5 && PARENT_IS_BOTTOM < 0.5 ? 1.0 : 0.0;\n    \n    lowp float LEFT_IS_FULL = LDI > 0.5 && LCI > 0.5 && PARENT_IS_LEFT < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_FULL = TDI > 0.5 && TCI > 0.5 && PARENT_IS_TOP < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_FULL = RDI > 0.5 && RCI > 0.5 && PARENT_IS_RIGHT < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_FULL = BDI > 0.5 && BCI > 0.5 && PARENT_IS_BOTTOM < 0.5 ? 1.0 : 0.0;\n    \n    // In the clockwise direction from the parent\n    lowp float PRIORITY_CHILD_LEFT = 0.0;\n    lowp float PRIORITY_CHILD_FRONT = 0.0;\n    lowp float PRIORITY_CHILD_RIGHT = 0.0;\n    \n    lowp float LEFT_IS_AN_EMPTY_CHILD = LEFT_IS_A_CHILD > 0.5 && LEFT_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float TOP_IS_AN_EMPTY_CHILD = TOP_IS_A_CHILD > 0.5 && TOP_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float RIGHT_IS_AN_EMPTY_CHILD = RIGHT_IS_A_CHILD > 0.5 && RIGHT_IS_FULL < 0.5 ? 1.0 : 0.0;\n    lowp float BOTTOM_IS_AN_EMPTY_CHILD = BOTTOM_IS_A_CHILD > 0.5 && BOTTOM_IS_FULL < 0.5 ? 1.0 : 0.0;\n    \n    lowp float CLK_LEFT = 0.0;\n    lowp float CLK_TOP = 0.0;\n    lowp float CLK_RIGHT = 0.0;\n    lowp float CLK_BOTTOM = 0.0;\n    \n    lowp float DATA_OUT_L = 0.0;\n    lowp float DATA_OUT_T = 0.0;\n    lowp float DATA_OUT_R = 0.0;\n    lowp float DATA_OUT_B = 0.0;\n    \n    lowp float DATA_IN = 0.0;\n    \n    if (PARENT_IS_LEFT > 0.5) {\n        CLK = LCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = LDI;\n        PRIORITY_CHILD_LEFT = TOP_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = RIGHT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = BOTTOM_IS_AN_EMPTY_CHILD;\n        \n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = LDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = LDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = LDI;\n        }\n    } else if (PARENT_IS_TOP > 0.5) {\n        CLK = TCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = TDI;\n        PRIORITY_CHILD_LEFT = RIGHT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = BOTTOM_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = LEFT_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = TDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = TDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = TDI;\n        }\n    } else if (PARENT_IS_RIGHT > 0.5) {\n        CLK = RCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = RDI;\n        PRIORITY_CHILD_LEFT = BOTTOM_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = LEFT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = TOP_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = RDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = RDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_BOTTOM = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_B = RDI;\n        }\n    } else if (PARENT_IS_BOTTOM > 0.5) {\n        CLK = BCI;\n        lowp float CLK_AND_WE_ARE_NOT_FULL_YET = CLK > 0.5 && elt.WE_ARE_FULL_DFF < 0.5 ? 1.0 : 0.0;\n        DATA_IN = BDI;\n        PRIORITY_CHILD_LEFT = LEFT_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_FRONT = TOP_IS_AN_EMPTY_CHILD;\n        PRIORITY_CHILD_RIGHT = RIGHT_IS_AN_EMPTY_CHILD;\n        if (PRIORITY_CHILD_RIGHT > 0.5) {\n            CLK_RIGHT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_R = BDI;\n        } else if (PRIORITY_CHILD_FRONT > 0.5) {\n            CLK_TOP = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_T = BDI;\n        } else if (PRIORITY_CHILD_LEFT > 0.5) {\n            CLK_LEFT = CLK_AND_WE_ARE_NOT_FULL_YET;\n            DATA_OUT_L = BDI;\n        }\n    }\n    \n    // We set this signal to 1 if the cell is a reconfiguration port.\n    // All reconfiguration ports are always terminal leaves of subtree by design.\n    lowp float ALL_CHILDREN_ARE_FULL = is_reconf_port(elt) > 0.5 ? 1.0 :\n        (((LEFT_IS_FULL > 0.5 || LEFT_IS_A_CHILD < 0.5)\n        &&\n        (TOP_IS_FULL > 0.5 || TOP_IS_A_CHILD < 0.5)\n        &&\n        (RIGHT_IS_FULL > 0.5 || RIGHT_IS_A_CHILD < 0.5)\n        &&\n        (BOTTOM_IS_FULL > 0.5 || BOTTOM_IS_A_CHILD < 0.5)) ? 1.0 : 0.0);\n        \n\n    elt.LCO = (PARENT_IS_LEFT > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (LEFT_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_LEFT > 0.5 && LEFT_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.TCO = (PARENT_IS_TOP > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (TOP_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_TOP > 0.5 && TOP_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.RCO = (PARENT_IS_RIGHT > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (RIGHT_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_RIGHT > 0.5 && RIGHT_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n\n    elt.BCO = (PARENT_IS_BOTTOM > 0.5 && elt.WE_ARE_FULL_DFF > 0.5) ||\n        (BOTTOM_IS_FULL > 0.5 && elt.WE_ARE_FULL_DFF > 0.5 && CLK > 0.5) ||\n        (CLK_BOTTOM > 0.5 && BOTTOM_IS_A_CHILD > 0.5\n          && (ALL_CHILDREN_ARE_FULL < 0.5 || elt.WE_ARE_FULL_DFF > 0.5))\n        ? 1.0 : 0.0;\n        \n\n    elt.LDO = (PARENT_IS_LEFT > 0.5 || DATA_OUT_L > 0.5 && PARENT_IS_LEFT < 0.5) ? 1.0 : 0.0;\n    elt.TDO = (PARENT_IS_TOP > 0.5 || DATA_OUT_T > 0.5 && PARENT_IS_TOP < 0.5) ? 1.0 : 0.0;\n    elt.RDO = (PARENT_IS_RIGHT > 0.5 || DATA_OUT_R > 0.5 && PARENT_IS_RIGHT < 0.5) ? 1.0 : 0.0;\n    elt.BDO = (PARENT_IS_BOTTOM > 0.5 || DATA_OUT_B > 0.5 && PARENT_IS_BOTTOM < 0.5) ? 1.0 : 0.0;\n\n    if (elt.PREV_CLK < 0.5 && CLK > 0.5) {\n        float next_write_ptr_ctr = 0.0;\n        if (elt.write_pointer_counter < 6.5) {\n            next_write_ptr_ctr = elt.write_pointer_counter + 1.0;\n        } else {\n            next_write_ptr_ctr = 0.0;\n        }\n        \n        if (elt.WE_ARE_FULL_DFF > 0.5) {\n            // Our cell config update happens here!\n            // Note we USE the previous values!\n            elt.orientation = float(elt.new_cfg[0] + 2.0 * elt.new_cfg[1]);\n            elt.mode = float(elt.new_cfg[2] + 2.0 * elt.new_cfg[3] + 4.0 * elt.new_cfg[4]);\n            elt.parent = float(elt.new_cfg[5] + 2.0 * elt.new_cfg[6]);\n            elt.right = elt.left = elt.top = elt.bottom = 0.0;\n            // ^^^ these will be patched slightly (PWR will make elt.right = 1.0 for example)\n            // below vvv\n        }\n\n        if (ALL_CHILDREN_ARE_FULL > 0.5) {\n            elt.write_pointer_counter = next_write_ptr_ctr;\n            elt.new_cfg[0] = elt.new_cfg[1];\n            elt.new_cfg[1] = elt.new_cfg[2];\n            elt.new_cfg[2] = elt.new_cfg[3];\n            elt.new_cfg[3] = elt.new_cfg[4];\n            elt.new_cfg[4] = elt.new_cfg[5];\n            elt.new_cfg[5] = elt.new_cfg[6];\n            elt.new_cfg[6] = DATA_IN;\n        }\n    } else if (elt.PREV_CLK > 0.5 && CLK < 0.5) {\n        // This DFF is clocked on falling edge.\n        // It's the only component which does that!\n        elt.WE_ARE_FULL_DFF = elt.write_pointer_counter > 6.5 ? 1.0 : 0.0;\n    }\n\n    // MUX\n    if (elt.mode > 1.5) {\n\n        if (elt.orientation > 2.5) {\n            elt.right = mux_action(elt.mode, left.right, right.left, bottom.top, top.bottom);\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            elt.right = mux_action(elt.mode, top.bottom, bottom.top, left.right, right.left);\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            elt.right = mux_action(elt.mode, right.left, left.right, top.bottom, bottom.top);\n        } else if (elt.orientation < 0.5) {\n            elt.right = mux_action(elt.mode, bottom.top, top.bottom, right.left, left.right);\n        }\n        \n    } else if (elt.mode > 0.5 && elt.mode < 1.5) {\n        // Wire\n        if (elt.orientation > 2.5) {\n            elt.right = right.left;\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            elt.right = bottom.top;\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            elt.right = top.bottom;\n        } else if (elt.orientation < 0.5) {\n            elt.right = left.right;\n        }\n\n    } else if (elt.mode < 0.5) {\n        if (elt.orientation > 2.5) {\n            // PWR\n            elt.right = 1.0;\n        } else if (elt.orientation < 2.5 && elt.orientation > 1.5) {\n            // GND\n            elt.right = 0.0;\n        } else if (elt.orientation < 1.5 && elt.orientation > 0.5) {\n            // Crossbar\n            elt.right = left.right;\n            elt.left = right.left;\n            elt.top = bottom.top;\n            elt.bottom = top.bottom;\n            is_crossbar = 1.0;\n        } else if (elt.orientation < 0.5) {\n            // Reconfiguration port\n            // Will interpret read/write request commands from\n            // the parent pointer direction\n            // clocked from \"parent + 1.0\" (clockwise)\n            float dat = 0.0;\n            float clk = 0.0;\n            if (is_left(elt.parent) > 0.5) {\n                dat = left.right;\n                clk = top.bottom;\n                elt.RCO = clk;\n                elt.RDO = dat;\n                elt.right = right.LCO;\n            } else if (is_top(elt.parent) > 0.5) {\n                dat = top.bottom;\n                clk = right.left;\n                elt.BCO = clk;\n                elt.BDO = dat;\n                elt.right = bottom.TCO;\n            } else if (is_right(elt.parent) > 0.5) {\n                dat = right.left;\n                clk = bottom.top;\n                elt.LCO = clk;\n                elt.LDO = dat;\n                elt.right = left.RCO;\n            } else if (is_bottom(elt.parent) > 0.5) {\n                dat = bottom.top;\n                clk = left.right;\n                elt.TCO = clk;\n                elt.TDO = dat;\n                elt.right = top.BCO;\n            }\n            \n            // Sample the clk and dat,\n            // execute operations on clk change.\n            \n            /* if (elt.prev_clk < 0.5 && clk > 0.5) {\n                // If neither reading or writing, let's begin\n                // depending on the data. Emulate DFF behavior using the prev_dat.\n                if (elt.cfg_read < 0.5 && elt.cfg_write < 0.5) {\n                    if (elt.prev_dat < 0.5) {\n                        elt.cfg_read = 1.0;\n                        // elt.right = 1.0;\n                    } else { // if the first bit of reconf bitstream is \"1\",\n                        // the client wants to write a bitstream into the port\n                        elt.cfg_write = 1.0;\n                        // Set the \"busy\" signal so the reprogrammer-parent\n                        // can identify when the writing is fully complete.\n                        elt.right = 1.0;\n                    }\n                }\n                \n                // Readout value\n                // elt.right = dat;//1.0 - elt.right;\n            }*/\n\n            // Read-out output\n            //elt.right = elt.right;// 0.0;\n            //elt.prev_clk = clk;\n            //elt.prev_dat = dat;\n        }\n    }\n    \n    if (is_crossbar < 0.5) {\n        elt.left = elt.right;\n        elt.top = elt.right;\n        elt.bottom = elt.right;\n    }\n    \n    //}\n    \n    // Disabled due to the new coarse-grained mini-FPGA model\n    // Enabled again\n    // Spanning tree integrity\n\n    if (is_left(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((left.conf_signal + is_reconf_port(left)) * (1.0 - is_right(left.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = left.prev_clk;\n        }\n    } else if (is_top(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((top.conf_signal + is_reconf_port(top)) * (1.0 - is_bottom(top.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = top.prev_clk;\n        }\n    } else if (is_right(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((right.conf_signal + is_reconf_port(right)) * (1.0 - is_left(right.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = right.prev_clk;\n        }\n    } else if (is_bottom(elt.parent) > 0.5) {\n        elt.conf_signal = clamp((bottom.conf_signal + is_reconf_port(bottom)) * (1.0 - is_top(bottom.parent)), 0.0, 1.0);\n        if (is_reconf_port(elt) < 0.5) {\n            // Propagate overlay clock to move serial reconfiguration bitstream\n            //elt.prev_clk = bottom.prev_clk;\n        }\n    }\n    \n    // At first, ran out of internal bits in a 32-bit pixel\n    // But then had to find one bit to sample clock.\n    // Had to give up on prototype inheritance of MUX states (for this shader code),\n    // Which decreased the range of the main counter from 0..8 to 0..7, releasing one more bit!\n    /*if (elt.conf_signal < 0.5) {\n        elt.parent = elt.parent + 1.0;\n        if (elt.parent > 3.5) {\n            elt.parent = 0.0;\n        }\n    } // TODO later make it work in another way. This feature is important,\n    */// it supports failed FPGAs and automatically unstucks accidental ownership tree cycles.\n    \n    elt.PREV_CLK = CLK;\n    \n    return elt;\n}\n\n\nvec4 update (in vec2 fragCoord) {\n\n   \n    // Use 1-byte color values for compatibility with mobile\n    vec4 gpgpu_data = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        // Skip processing of data not in computer core\n        // or not being in IO\n        // Note that we can write in this buffer realtime external inputs\n        // (mouse, keyboard, etc.)\n        return gpgpu_data;\n    } else if (is_config_param_block(fragCoord) > 0.5) {\n        // Configuration parameters block\n        Bitset8Bits cfg = cfgBlockFromTexel(gpgpu_data);\n\n        vec4 m = vec4(iMouse.x, iResolution.y - iMouse.y, iMouse.zw);\n        \n        if (m.z > 0.5) {\n            cfg.bit0.g = 1.0;\n        }\n        \n        if (m.z < -0.5) {\n            cfg.bit0.g = 0.0;\n        }\n\n        const int KEY_LEFT  = 37;\n        const int KEY_UP    = 38;\n        const int KEY_RIGHT = 39;\n        const int KEY_DOWN  = 40;\n        \n        if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x > 0.5) {\n            cfg.bit0.r = 1.0;\n        }\n        \n        if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x > 0.5) {\n            cfg.bit0.r = 0.0;\n        }\n\n        return texelFromCfgBlock(cfg);\n    }\n\n    return texelFromElement(computeElement(elementFromTexel(gpgpu_data), fragCoord));\n}\n\n\nElement init_circuit(Element e, vec2 p) {\n\n    float y = 0.0;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 1.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 2.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 3.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 4.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 5.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 6.;\n    e=mova(1.,3.,1., 1.,y,e,p);e=mova(1.,3.,1., 2.,y,e,p);e=mova(1.,2.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 7.;\n    e=mova(1.,1.,1., 1.,y,e,p);e=mova(1.,0.,0., 2.,y,e,p);e=mova(1.,0.,1., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n    \n    y = 8.;\n    e=moa(0.,0., 1.,y,e,p);    e=moa(0.,0., 2.,y,e,p);     e=moa(0.,0., 3.,y,e,p);e=moa(0.,0., 4.,y,e,p);e=moa(0.,0., 5.,y,e,p);e=moa(0.,0., 6.,y,e,p);e=moa(0.,0., 7.,y,e,p);e=moa(0.,0., 8.,y,e,p);e=moa(0.,0., 9.,y,e,p);\n\n    \n    return e;\n}\n\nvec4 init (in vec2 fragCoord) {\n    \n    if (fragCoord.x > COMPUTER_WIDTH || fragCoord.y > COMPUTER_HEIGHT) {\n        discard;\n    } else if (is_config_param_block(fragCoord) > 0.5) {\n        // Configuration parameters block\n        Bitset8Bits cfg;\n\n        cfg.bit0.r = 0.0;\n\n        return texelFromCfgBlock(cfg);\n    }\n    \n    // rng_initialize(fragCoord, 190); // with 24x13 size is interesting\n    rng_initialize(fragCoord, 115);//155);//198);//115); //155); //115; // 33 //119\n    \n    //rng_initialize(fragCoord, iFrame + 735375909);\n    //rng_initialize(fragCoord, iFrame + 42);\n    //rng_initialize(fragCoord, iFrame + 74974137);\n    \n    \n    vec4 randomValues = rand4();\n\n    Element elt = elementFromTexel(vec4(randomValues.r, randomValues.g, randomValues.b, 0.0));\n    //Element elt = elementFromTexel(vec4(0.0));\n    //Element elt;\n    //elt = mova(0., 0., 0., fragCoord.x, fragCoord.y, elt, fragCoord + vec2(0.5));\n    \n    //elt.parent = floor(4.0 * randomValues.r);\n    \n    /*\n    elt = elementFromTexel(randomValues);\n    \n    // Higher the probability of wires:\n    for (int i = 0; i < 4; ++i) {\n        vec4 moreRandomValues = rand4();\n        if (elt.mode > 1.5 || elt.mode < 0.5) {\n            elt.mode = floor(8.0 * moreRandomValues.r);\n        } else {\n            break;\n        }\n    }\n    \n    // Lower the probability of MUXes:\n    for (int i = 0; i < 3; ++i) {\n        vec4 moreRandomValues = rand4();\n        if (elt.mode > 1.5) {\n            elt.mode = floor(8.0 * moreRandomValues.r);\n        } else {\n            break;\n        }\n    }*/\n    \n    // Reset all core counters so it starts in the consistent mode:\n    elt.LCO = elt.RCO = elt.BCO = elt.TCO = 0.0;\n    elt.LDO = elt.RDO = elt.BDO = elt.TDO = 0.0;\n    elt.write_pointer_counter = 0.0;\n    elt.WE_ARE_FULL_DFF = 0.0;\n    elt.conf_signal = 0.0;\n    elt.PREV_CLK = 0.0;\n    elt.parent = 0.0;\n    \n    //elt = init_circuit(elt, fragCoord);\n\n    \n    // Four state bits to store outputs (three used only for crosses)\n    // lowp float right;  // 0..1\n    /* elt.right = elt.top = elt.bottom = elt.left = 1.0;\n\n    // --- 5 bits of wiring and control configuration ---\n    \n    // 4 orientations 0..3 for MUX or wire. For special mode diff. meaning:\n    // 0: reconf. port; 1: cross; 2: GND; 3: PWR.\n    // [2 bits]\n    // float orientation;\n    elt.orientation = 3.0;\n\n    // 8 modes: 0 - special; 1 - wire; 2..7 - MUX\n    // [3 bits]\n    // float mode;\n    elt.mode = 0.0;\n    \n    return texelFromElement(elt); */\n    /** /\n    vec4 moreRandomValues = rand4();\n    vec4 moreRandomValues2 = rand4();\n    \n    // Lower the probability of MUXes:\n\n    if (elt.mode > 1.5) {\n        elt.mode = floor(8.0 * moreRandomValues.a);\n    }\n\n    \n    // Up the probability of reconf ports:\n    if (elt.mode > 0.5 && elt.orientation > 0.5) {\n        elt.mode = floor(8.0 * moreRandomValues2.r);\n        elt.orientation = floor(4.0 * moreRandomValues2.g);\n    }\n\n    // Made higher the probability of wires:\n    if (elt.mode > 1.5 || elt.mode < 0.5) {\n        elt.mode = floor(8.0 * moreRandomValues.r);\n        //elt.orientation = floor(4.0 * moreRandomValues2.g);\n        \n        if (elt.mode > 1.5 || elt.mode < 0.5) {\n            elt.mode = floor(8.0 * moreRandomValues.g);\n            //elt.orientation = floor(4.0 * moreRandomValues.a);\n            \n            if (elt.mode > 1.5 || elt.mode < 0.5) {\n                elt.mode = floor(8.0 * moreRandomValues.b);\n                \n                if (elt.mode > 1.5 || elt.mode < 0.5) {\n                    elt.mode = floor(8.0 * moreRandomValues2.r);\n                    \n                    if (elt.mode > 1.5 || elt.mode < 0.5) {\n                        vec4 moreRandomValues3 = rand4();\n                        elt.mode = floor(8.0 * moreRandomValues3.r);\n                        \n                        // Higher the probability of crosses:\n                        if (elt.mode > 0.5 || elt.orientation < 0.5 && elt.orientation > 1.5) {\n                            elt.mode = floor(8.0 * moreRandomValues2.r);\n                            elt.orientation = floor(4.0 * moreRandomValues2.g);\n                        }\n                    }\n                        \n                }\n            }\n            /*\n            if (elt.orientation > 0.5) {\n                elt.orientation = floor(4.0 * moreRandomValues2.r);\n                if (elt.orientation > 0.5) {\n                    elt.orientation = floor(4.0 * moreRandomValues2.g);\n                    if (elt.orientation > 0.5) {\n                        elt.mode = floor(8.0 * moreRandomValues2.b);\n                        elt.orientation = floor(4.0 * moreRandomValues2.a);\n                    }\n                }\n            }* /\n        }\n    }\n    */\n    \n    //if ((fragCoord.x > 10.0 || fragCoord.y > 21.0) && is_reconf_port(elt) > 0.5) {\n    //    elt.mode = 1.0;\n    //}\n    return texelFromElement(elt);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  \n    if (iFrame > 1) {\n        fragColor = update(fragCoord);\n    } else {\n        fragColor = init(fragCoord);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n# else\nprecision mediump float;\nprecision lowp int;\nprecision lowp sampler2D;\n# endif\n\nfloat zoom_factor = 64.0;\n\n//float zoom_factor = 24.0; // Beautiful most miniature render to study very large arrays\n\n//float zoom_factor = 16.0;\n\n//float zoom_factor = 1.0;\n\n\n#define COMPUTER_WIDTH (119.0)\n#define COMPUTER_HEIGHT (74.0)\n\n//#define COMPUTER_WIDTH (119.0)\n//#define COMPUTER_HEIGHT (67.0)\n\n// Try this bizarre settings:\n//float zoom_factor = 1.0;\n//#define COMPUTER_WIDTH (1920.0)\n//#define COMPUTER_HEIGHT (1080.0)\n\n//#define COMPUTER_WIDTH (2.0 * 1920.0)\n//#define COMPUTER_HEIGHT (2.0 * 1080.0)\n\n// 32 bits on bit-by-bit access\nstruct Bitset8Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n    vec4 bit4;\n    vec4 bit5;\n    vec4 bit6;\n    vec4 bit7;\n};\n\nvec4 when_gt (vec4 l, vec4 r) {\n  return max(sign(l - r), 0.0);\n}\n\n// 3 * 4 bits\nstruct Bitset4Bits {\n\n    vec4 bit0;\n    vec4 bit1;\n    vec4 bit2;\n    vec4 bit3;\n};\n\nBitset4Bits unpack_4_numbers (vec4 numbers) {\n    Bitset4Bits result;\n\n    result.bit3 = when_gt(numbers, vec4(7.5));\n    \n    vec4 bits0to2 = numbers - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = numbers - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nBitset8Bits unpack_4_bytes (vec4 byte) {\n    Bitset8Bits result;\n    \n    result.bit7 = when_gt(byte, vec4(127.5));\n    \n    vec4 bits0to6 = byte - 128.0 * result.bit7;\n    result.bit6 = when_gt(bits0to6, vec4(63.5));\n    \n    vec4 bits0to5 = bits0to6 - 64.0 * result.bit6;\n    result.bit5 = when_gt(bits0to5, vec4(31.5));\n    \n    vec4 bits0to4 = bits0to5 - 32.0 * result.bit5;\n    result.bit4 = when_gt(bits0to4, vec4(15.5));\n    \n    vec4 bits0to3 = bits0to4 - 16.0 * result.bit4;\n    result.bit3 = when_gt(bits0to3, vec4(7.5));\n    \n    vec4 bits0to2 = bits0to3 - 8.0 * result.bit3;\n    result.bit2 = when_gt(bits0to2, vec4(3.5));\n    \n    vec4 bits0to1 = bits0to2 - 4.0 * result.bit2;\n    result.bit1 = when_gt(bits0to1, vec4(1.5));\n    \n    result.bit0 = when_gt(bits0to1 - 2.0 * result.bit1, vec4(0.5));\n\n    return result;\n}\n\nstruct Array32Bits {\n    float bit[32];\n};\n\nArray32Bits unpack_32_bits (vec4 byte) {\n    Bitset8Bits bits = unpack_4_bytes(byte);\n    \n    Array32Bits a;\n    a.bit[0] = bits.bit0.r;\n    a.bit[1] = bits.bit1.r;\n    a.bit[2] = bits.bit2.r;\n    a.bit[3] = bits.bit3.r;\n    a.bit[4] = bits.bit4.r;\n    a.bit[5] = bits.bit5.r;\n    a.bit[6] = bits.bit6.r;\n    a.bit[7] = bits.bit7.r;\n    \n    a.bit[8] = bits.bit0.g;\n    a.bit[9] = bits.bit1.g;\n    a.bit[10] = bits.bit2.g;\n    a.bit[11] = bits.bit3.g;\n    a.bit[12] = bits.bit4.g;\n    a.bit[13] = bits.bit5.g;\n    a.bit[14] = bits.bit6.g;\n    a.bit[15] = bits.bit7.g;\n\n    \n    a.bit[16] = bits.bit0.b;\n    a.bit[17] = bits.bit1.b;\n    a.bit[18] = bits.bit2.b;\n    a.bit[19] = bits.bit3.b;\n    a.bit[20] = bits.bit4.b;\n    a.bit[21] = bits.bit5.b;\n    a.bit[22] = bits.bit6.b;\n    a.bit[23] = bits.bit7.b;\n    \n    a.bit[24] = bits.bit0.a;\n    a.bit[25] = bits.bit1.a;\n    a.bit[26] = bits.bit2.a;\n    a.bit[27] = bits.bit3.a;\n    a.bit[28] = bits.bit4.a;\n    a.bit[29] = bits.bit5.a;\n    a.bit[30] = bits.bit6.a;\n    a.bit[31] = bits.bit7.a;\n\n    return a;\n}\n\nstruct Element {\n\n    // ==== First block - [8 bits] of core config determining cell's function\n\n    // --- 5 bits of wiring and control configuration ---\n    \n    // 4 orientations 0..3 for MUX or wire. For special mode diff. meaning:\n    // 0: reconf. port; 1: cross; 2: GND; 3: PWR.\n    // [2 bits]\n    float orientation;\n\n    // 8 modes: 0 - special; 1 - wire; 2..7 - MUX\n    // [3 bits]\n    float mode;\n\n    // --- 2 bits Cartilage tree engine ---\n    \n    // Pointer to the owner element\n    // [2 bits]\n    float parent; // 0..3\n    \n    // Main state bit to store the output value\n    // In silicon, it represents electric charge.\n    // There is no inherent clock or D flip-flops. This bit is ephemeral\n    // (but initialized from config to support prototype inheritance).\n    \n    lowp float right;  // 0..1\n    \n    // ==== Ephemeral [8 bits] of Intersin clock and data wires\n    // (the wires neighbor cells interface with\n    // in the reconfiguration trees overlay network) representing charges\n    // while reconfiguration happens.\n    lowp float LCO;\n    lowp float LDO;\n    lowp float TCO;\n    lowp float TDO;\n    lowp float RCO;\n    lowp float RDO;\n    lowp float BCO;\n    lowp float BDO;\n    \n    // [13 bits] of non-copy-able \"hidden\" state (real DFFs)\n    \n    // ====== Third block [8 bits] shift register of configuration data.\n    // Applied to the main bits (orientation/mode/parent/state bit)\n    // when one subtree is completely filled with config bits.\n    // CLOCKED(!) with config clock sourced from one of the inputs\n    // into the subtree's reconfiguration port at its root.\n    lowp float new_cfg[8];\n\n    // [4 bits]\n    // Pointer of the currently written bit into the new_cfg register.\n    float write_pointer_counter;\n    // D flip-flop marking the completion of collection of new config bits\n    // in the new_cfg[7..0] shift register.\n    // [1 bit]\n    lowp float WE_ARE_FULL_DFF;\n\n    // ^^^ 29 bits consumed! ^^^\n    \n\n    // The three state bits used only to store outputs for crosses,\n    // In silicon, these represent charges. There is no inherent clock\n    // or D flip-flops. These bits are ephemeral.\n\n    lowp float left;  // 0..1\n    lowp float top;  // 0..1\n    lowp float bottom;  // 0..1\n    \n    // Spanning tree integrity. A technical signal preventing\n    // hidden ownership loops. In FPGA chains, implemented as a hops counter.\n    // We gave up on it because exhausted all 32 bits to encode electrical signals\n    // in wires. This implementation will require additional D flip-flop\n    // and protocol to send the presence signal.\n    lowp float conf_signal;\n\n    // The signal is supposed to be reflected from every leaf to the root, then re-emitted.\n    // If another signal is coming from the root, it means we got a cycle.\n    // Not implemented.\n    //lowp float conf_signal_leaf_to_root;\n    \n    // We have to sample the previous value of CLK to detect raising and falling edges.\n    lowp float PREV_CLK;\n};\n\nBitset8Bits cfgBlockFromTexel(vec4 texel) {\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n\n    return bits;\n}\n\nElement elementFromTexel (in vec4 texel) {\n\n    Element elt;\n\n    Bitset8Bits bits = unpack_4_bytes(texel * 255.0);\n    \n  \n    elt.orientation = float(bits.bit0.r + 2.0 * bits.bit1.r);\n    elt.mode = float(bits.bit2.r + 2.0 * bits.bit3.r + 4.0 * bits.bit4.r);\n    elt.parent = float(bits.bit5.r + 2.0 * bits.bit6.r);\n\n    // Main state\n    elt.right = bits.bit7.r;\n\n    // Intersin signals\n    elt.LCO = bits.bit0.g;\n    elt.LDO = bits.bit1.g;\n    elt.TCO = bits.bit2.g;\n    elt.TDO = bits.bit3.g;\n    elt.RCO = bits.bit4.g;\n    elt.RDO = bits.bit5.g;\n    elt.BCO = bits.bit6.g;\n    elt.BDO = bits.bit7.g;\n\n    // New configuration buffer\n    elt.new_cfg[0] = bits.bit0.b;\n    elt.new_cfg[1] = bits.bit1.b;\n    elt.new_cfg[2] = bits.bit2.b;\n    elt.new_cfg[3] = bits.bit3.b;\n    elt.new_cfg[4] = bits.bit4.b;\n    elt.new_cfg[5] = bits.bit5.b;\n    elt.new_cfg[6] = bits.bit6.b;\n    // elt.new_cfg[7] = bits.bit7.b; // we needed a space :-/\n\n    // [4 bits]\n    // Pointer of the currently written bit into the new_cfg register.\n    // Counts from 0 to 7\n    elt.write_pointer_counter = float(\n        bits.bit0.a +\n        2.0 * bits.bit1.a +\n        4.0 * bits.bit2.a);/* +\n        8.0 * bits.bit3.a);*/\n        \n    // D flip-flop marking the completion of collection of new config bits\n    // in the new_cfg[7..0] shift register.\n    // Clocked on FALLING EDGE of CLK\n    // Its data input is sourced from the Boolean condition when\n    // elt.write_pointer_counter reaches 7.\n    // [1 bit]\n    elt.WE_ARE_FULL_DFF = bits.bit4.a;\n\n    // Used in cross only:\n    elt.left = bits.bit5.a;\n    elt.top = bits.bit6.a;\n    elt.bottom = bits.bit7.a;\n    \n    elt.PREV_CLK = bits.bit7.b;\n    elt.conf_signal = bits.bit3.a;\n\n    return elt;\n}\n\n\n//------------------------------------\n//\n//       structured data -> texels\n//\n\nvec4 pack_4_bytes (Bitset8Bits state) {\n\n  vec4 data;\n\n  data = vec4(state.bit0)\n    + 2.0 * vec4(state.bit1)\n    + 4.0 * vec4(state.bit2)\n    + 8.0 * vec4(state.bit3)\n    + 16.0 * vec4(state.bit4)\n    + 32.0 * vec4(state.bit5)\n    + 64.0 * vec4(state.bit6)\n    + 128.0 * vec4(state.bit7);\n\n  return data;\n}\n\nvec4 texelFromCfgBlock (Bitset8Bits bits) {\n\n    return pack_4_bytes(bits) / 255.0;\n}\n\nfloat is_config_param_block(vec2 fragCoord) {\n    // < 0.9 because normal fragCoord have 0.5 granularity\n    return fragCoord.x < 0.9 && fragCoord.y < 0.9 ? 1.0 : 0.0;\n}\n\nvec4 texelFromElement (in Element elt) {\n\n    Bitset8Bits bits;\n    \n    Bitset4Bits parameters = unpack_4_numbers(\n        vec4(elt.orientation, elt.mode, elt.parent,\n             elt.write_pointer_counter));\n    \n    // elt.orientation:\n    bits.bit0.r = parameters.bit0.r;\n    bits.bit1.r = parameters.bit1.r;\n    \n    // elt.mode:\n    bits.bit2.r = parameters.bit0.g;\n    bits.bit3.r = parameters.bit1.g;\n    bits.bit4.r = parameters.bit2.g;\n\n    // elt.parent:\n    bits.bit5.r = parameters.bit0.b;\n    bits.bit6.r = parameters.bit1.b;\n\n    // Main state\n    bits.bit7.r = elt.right;\n\n    bits.bit0.g = elt.LCO;\n    bits.bit1.g = elt.LDO;\n    bits.bit2.g = elt.TCO;\n    bits.bit3.g = elt.TDO;\n    bits.bit4.g = elt.RCO;\n    bits.bit5.g = elt.RDO;\n    bits.bit6.g = elt.BCO;\n    bits.bit7.g = elt.BDO;\n\n    bits.bit0.b = elt.new_cfg[0];\n    bits.bit1.b = elt.new_cfg[1];\n    bits.bit2.b = elt.new_cfg[2];\n    bits.bit3.b = elt.new_cfg[3];\n    bits.bit4.b = elt.new_cfg[4];\n    bits.bit5.b = elt.new_cfg[5];\n    bits.bit6.b = elt.new_cfg[6];\n    //bits.bit7.b = elt.new_cfg[7];\n    \n    // elt.write_pointer_counter:\n    bits.bit0.a = parameters.bit0.a;\n    bits.bit1.a = parameters.bit1.a;\n    bits.bit2.a = parameters.bit2.a;\n    //bits.bit3.a = parameters.bit3.a;\n    \n    \n    bits.bit4.a = elt.WE_ARE_FULL_DFF;\n\n    // Used in cross only:\n    bits.bit5.a = elt.left;\n    bits.bit6.a = elt.top;\n    bits.bit7.a = elt.bottom;\n    \n    bits.bit7.b = elt.PREV_CLK;\n    bits.bit3.a = elt.conf_signal;\n\n    return pack_4_bytes(bits) / 255.0;\n}\n\nfloat mux_action(float mode_code, lowp float l, lowp float r, lowp float b, lowp float t) {\n    float mode = 7.0 - mode_code;\n\n    float result = 0.0;\n    // Switch over 6 modes\n    if (mode < 0.5) {\n        result = l > 0.5 ? b : t;\n    } else if (mode > 0.5 && mode < 1.5) {\n        result = l > 0.5 ? t : b;\n    } else if (mode > 1.5 && mode < 2.5) {\n        result = l > 0.5 ? r : t;\n    } else if (mode > 2.5 && mode < 3.5) {\n        result = l > 0.5 ? t : r;\n    } else if (mode > 3.5 && mode < 4.5) {\n        result = l > 0.5 ? r : b;\n    } else if (mode > 4.5 && mode < 5.5) {\n        result = l > 0.5 ? b : r;\n    }\n    \n    return result;\n}\n\n\nfloat is_left(float ptr) {\n    return (ptr < 0.5) ? 1.0 : 0.0;\n}\n    \nfloat is_top(float ptr) {\n    return (ptr > 0.5 && ptr < 1.5) ? 1.0 : 0.0;\n}\n\nfloat is_right(float ptr) {\n    return (ptr > 1.5 && ptr < 2.5) ? 1.0 : 0.0;\n}\n\nfloat is_bottom(float ptr) {\n    return (ptr > 2.5 && ptr < 3.5) ? 1.0 : 0.0;\n}\n\nfloat is_reconf_port(Element elt) {\n    return (elt.mode < 0.5 && elt.orientation < 0.5) ? 1.0 : 0.0;\n}\n\n// Visual functions used due to inability of GPGPU shader to access mouse extent:\nvec2 cell_from_visual(vec2 visual, float zoom_factor) {\n\n    float scale = 1.0 / zoom_factor;\n   \n    vec2 cell_coord = floor((visual - 0.5) * scale + vec2(0.5, 0.5) * scale);\n    \n    vec2 gpgpu_coord = (0.5 + cell_coord + vec2(0.0, 0.0));\n    \n    return gpgpu_coord;\n}\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}