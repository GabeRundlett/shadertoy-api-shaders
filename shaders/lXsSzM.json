{
    "Shader": {
        "info": {
            "date": "1709378485",
            "description": "This shader alternates between two buffers to find the globalminimum or maximum of a texture using a search tree.",
            "flags": 32,
            "hasliked": 0,
            "id": "lXsSzM",
            "likes": 0,
            "name": "Global Minimum and Maximum",
            "published": 3,
            "tags": [
                "global",
                "tree",
                "min",
                "max",
                "minimum",
                "search",
                "search",
                "maximum"
            ],
            "usePreview": 0,
            "username": "gehtsiegarnixan",
            "viewed": 156
        },
        "renderpass": [
            {
                "code": "// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI did this not because it was easy, but because I thought it would be.\n\nI built a shader that finds the global minimum or maximum of a texture \nusing a  quad search tree. It was surprisingly tricky to implement this. \nI would recommend not bothering with using a shader and just using GPT \nto let it write you the 5 lines of Python code that does this way \nquicker for any texture you may have. \n\nYou can switch between the minimum and maximum in the Common section. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Coordinates of the texel fetch\n    ivec2 coords = ivec2(fragCoord);\n    \n    // Alternate between sampling buffer A or B\n    // See https://www.desmos.com/calculator/3ujv4zzme4\n    if (int(TIME) % 2 == 0) {\n        // Read from buffer A\n        fragColor = texelFetch(iChannel1, coords, 0);\n        \n    } else {\n        // Read from buffer B\n        fragColor = texelFetch(iChannel2, coords, 0);\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Enable this for the minimum, disable for the maximum\n//#define MINIMUM\n\n// Animation speed\n#define TIME iTime * 1.0\n\n// Find the highest mip level\nint getMaxLevel (sampler2D tex) {\n    // Size of the texture to search\n    vec2 texSize = vec2(textureSize(tex, 0)); \n\n    // Find the highest size\n    float maxSize = max(texSize.x, texSize.y);\n\n    // Return the highest mip level\n    return int(log2(maxSize))+1;\n}\n\n// Samples the texels (no interpolation between pixels)\nvec4 sampleTexel (sampler2D tex, ivec2 coords, int mipLevel) {\n\n        // Size of the texture to search\n        ivec2 texSize = ivec2(textureSize(tex, mipLevel));\n        \n        // Make texture repeat\n        coords = coords % texSize; \n        \n        // Sample pixels of texture\n        return texelFetch(tex, coords, mipLevel);\n}\n\n// Find the borders of 4 pixels\nvec4 findLocalMinMax(sampler2D tex, ivec2 coords, int level) {\n    \n    // If the level is negative return the original texture\n    if (level < 0) {\n        return sampleTexel(tex, coords, 0);\n    }\n    \n    // Pixelize size\n    ivec2 size = ivec2(pow(2.0, max(0.,float(level))));\n\n    // Pixelize the coordinates\n    ivec2 id = coords / size;\n    \n    // Initialize result with worst possible one\n    #ifdef MINIMUM \n        vec4 extrema = vec4(1);\n    #else\n        vec4 extrema = vec4(0);\n    #endif\n    \n    // Size of the texture to search\n    ivec2 texSize = ivec2(textureSize(tex, 0));        \n \n    // Iterate over all 4 neighbors \n    for (int i = 0; i < 4; ++i) {\n        \n        // Offset to (0,0), (0,1), (1,0), (1,1) * size so they check the neighbors\n        ivec2 offset = ivec2(i / 2, i % 2);\n        \n        // Current Cell to sample\n        ivec2 cell = (id + offset) * size;\n        \n        // make coordinates looping\n        cell = cell % texSize;\n        \n        // Test local coordinate\n        vec4 currentColor = texelFetch(tex, cell, 0);\n        \n        // Update minimum or maximum values\n        #ifdef MINIMUM            \n            extrema = min(extrema, currentColor);\n        #else\n            extrema = max(extrema, currentColor);\n        #endif\n    }   \n    return extrema;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Coordinates of the texel fetch\n    ivec2 coords = ivec2(fragCoord);\n    \n    // Check how large this buffer is\n    int maxLevel = getMaxLevel(iChannel0);\n    \n    // Make the index repeat at max tree depth\n    int index = (int(TIME) % (maxLevel+1)) -1;\n    \n    // When to write to itself or from the other buffer    \n    if (int(index) % 2 == 0) {\n        // Write to self\n        fragColor = texelFetch(iChannel1, coords, 0);\n        \n    } else {\n        if (index < 0) {\n            // Initial sample from texture\n            fragColor = findLocalMinMax(iChannel0, coords, index);\n            \n        } else {\n            // Read from neighbor buffer\n            fragColor = findLocalMinMax(iChannel2, coords, index);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n        \n    // Coordinates of the texel fetch\n    ivec2 coords = ivec2(fragCoord);\n    \n    // Check how large this buffer is\n    int maxLevel = getMaxLevel(iChannel0);\n    \n    // Make the index repeat at max tree depth\n    int index = (int(TIME) % (maxLevel+1)) -1;\n    \n    // When to write to itself or from the other buffer\n    if (int(index) % 2 == 1) {\n        // Write to self\n        fragColor = texelFetch(iChannel2, coords, 0);\n        \n    } else {\n        if (index < 0) {\n            // Initial sample from texture\n            fragColor = findLocalMinMax(iChannel0, coords, index);\n            \n        } else {\n            // Read from neighbor buffer\n            fragColor = findLocalMinMax(iChannel1, coords, index);\n        }\n    }\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}