{
    "Shader": {
        "info": {
            "date": "1619627299",
            "description": "An implementation of the paper:\nA SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\nhttps://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf",
            "flags": 32,
            "hasliked": 0,
            "id": "wldfWf",
            "likes": 5,
            "name": "2D SaintVenant",
            "published": 3,
            "tags": [
                "simulation",
                "water",
                "shallowwaterequation",
                "saintvenant"
            ],
            "usePreview": 1,
            "username": "EvilRyu",
            "viewed": 500
        },
        "renderpass": [
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2D Saint-Venant system of Shallow Water Equation\n// An implementation of the paper:\n// A SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\n// https://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf\n// 1D version here: https://www.shadertoy.com/view/wt3BDH\n\n#define FAR 200.\n#define PI 3.1415926535\n#define MATE_TERRIAN 0.\n#define MATE_WATER 1.\n\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct=cos(t),st=sin(t);\n    vec2 q=p;\n\tp.x=ct*q.x+st*q.y;\n    p.y=-st*q.x+ct*q.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 getCellUV(vec2 uv)\n{\n    return uv * vec2( NUM_CELLS_X / iResolution.x, NUM_CELLS_Y / iResolution.y);\n}\n\nfloat water(vec2 p)\n{\n    return textureLod(iChannel0, p, 0.).x;\n}\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\nbool refrRay = false;\n\nvec2 map(vec3 p)\n{\n    // the terrian is 100x100 size\n    float d = p.y - B(getCellUV((p.xz + 50.) / 100.));\n    float d1 = 1e5;\n\n    if(!refrRay)\n    {\n        d1 = p.y - water(getCellUV((p.xz + 50.) / 100.));\n        float mateid;\n        if(d < d1)  mateid = MATE_TERRIAN;\n        else        mateid = MATE_WATER;\n    \n        return vec2(smin(d, d1, .1), mateid);\n    }\n    \n    return vec2(d, MATE_TERRIAN);\n}\n\n\nvec3 getNormal(vec3 p, float t, float mate)\n{\n    vec2 e = vec2(0.001 * t , 0.);\n    if(mate == MATE_WATER) e.x = 0.1*t;\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nvec3 getTerrianNormal(vec2 pos, float t)\n{   \n    vec2 e = vec2(0.001*t,0.0);\n\treturn normalize(vec3(terrian(pos-e.xy)-terrian(pos+e.xy),\n                           2.0*e.x,\n                           terrian(pos-e.yx)-terrian(pos+e.yx)));\n}\n\n\nvec2 intersect(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float t = tmin;\n    vec2 res = vec2(1e5, 0.);\n    vec3 p;\n    for(int i = 0; i < 256; ++i)\n    {\n        if(res.x < 0.002 || t > tmax)\n        {\n            break;\n        }\n        \n        p = ro + t * rd;\n        \n        // the terrian is 100x100 size\n        if(abs(p.x) > 50. || abs(p.z) > 50.)\n        {\n            t = tmax;\n            break;\n        }\n        res = map(p);\n        t += res.x * .5;\n    }\n    \n    return vec2(t, res.y);\n}\n\nvec3 sunDir = normalize(vec3(1., 1., 0.));\nvec3 sunCol = vec3(1.000,0.980,0.898) * 2.;\nvec3 terrianBasecol = vec3(0.263,0.231,0.137);\nvec3 waterBaseCol = vec3(0.000,0.533,1.000);\n\nvec3 sceneRefr(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    refrRay = true;\n    vec3 col = vec3(0.004,0.318,0.557);\n    vec2 res = intersect(ro, rd, tmin, tmax);\n    if(res.x < tmax)\n    {\n        vec3 p = ro + rd * res.x;\n        vec3 n = getNormal(p, 1., res.y);\n        float dif = 1.*max(0., dot(sunDir, n));\n        col = terrianBasecol * dif;\n    }\n    \n    refrRay=false;\n    return col;\n}\n\nvec3 shading(vec3 pos, vec3 ro, vec3 rd, vec3 n, float t, float mateid)\n{\n    float dif = max(0., dot(sunDir, n));\n    float bac = max(0., dot(-sunDir, n));\n    float amb = max(0., dot(n, vec3(0,1,0)));\n    vec3 refl = normalize(reflect(rd, n));\n    vec3 refr = refract(rd, n, 1./1.33);\n    float spe = max(0.0, pow(clamp(dot(sunDir, refl), 0.0, 1.0), 32.0));\n    float fre = clamp(1.0 + dot(rd, n), .0, 1.); \n    vec3 col = vec3(0., 0.5, 1.);\n    \n    col += sunCol*(4.*dif + 1.*bac) + vec3(0.,.5,1.)*1.5*amb;\n    col *= terrianBasecol;\n    \n    if(mateid == MATE_WATER)\n    {\n        vec3 wcol = (1. * dif + 1. * spe + .5 * amb) * waterBaseCol * .3;\n        wcol += mix(sceneRefr(pos, refl, 0.1, 100.), sceneRefr(pos, refr, 0.01, 20.), .5);\n        float h = water(getCellUV((pos.xz + 50.)/100.)) - B(getCellUV((pos.xz+50.)/100.));\n        col = mix(col, wcol, smoothstep(.0, 0.3, h));\n    }\n    \n    col *= 0.2;\n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec3 col = vec3(0);\n    vec2 res = intersect(ro, rd, tmin, tmax);\n    float t = res.x, mateid = res.y;\n    if(t < tmax)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = getNormal(pos, 10., mateid);\n        col = shading(pos, ro, rd, n, t, mateid);\n    }\n    \n    col=mix(col, vec3(0.020,0.020,0.020), 1.-exp(-.0001*t*t));\n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51, b=0.03, c=2.43, d=0.59, e=0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(-0., 41., 20.);\n    vec3 ta = ro + vec3(0,-2.5,-1.);\n        \n    \n    vec3 f = normalize(ta - ro);\n    vec3 r = normalize(cross(f, vec3(0,1,0)));\n    vec3 u = normalize(cross(r, f));\n    \n    vec3 rd = normalize(mat3(r, u, f) * vec3(p.x, p.y, 1.2));\n    \n    // debugging camera\n    float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    if(iMouse.z>0.||iMouse.w>0.)\n    {\n        rot2d(rd.xz, iMouse.x*.1);\n    }\n    \n    vec3 col = scene(ro, rd, 0.01, FAR);\n    col=pow(col, vec3(0.9));\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\n// Limiter to ensure non-oscillatory reconstruction\nvec3 minmod(vec3 a1, vec3 a2, vec3 a3)\n{\n    vec3 res;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        if(a1[i] > 0. && a2[i] > 0. && a3[i] > 0.)\n        {\n            res[i] = min(min(a1[i], a2[i]), a3[i]);\n        }\n        else if(a1[i] < 0. && a2[i] < 0. && a3[i] < 0.)\n        {\n            res[i] = max(max(a1[i], a2[i]), a3[i]);\n        }\n        else res[i] = 0.;\n    }\n    \n    return res;\n}\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > NUM_CELLS_Y || fragCoord.x > NUM_CELLS_X * 4.)\n        return;\n            \n    // Buffer A is divided to 4 NUM_CELLS_X * NUM_CELLS_Y blocks\n    // for storing U_W, U_E, U_S, U_N respectively\n    float blockId = floor(fragCoord.x / NUM_CELLS_X);\n    vec2 uv = (fragCoord - vec2(NUM_CELLS_X * blockId, 0.)) / iResolution.xy;\n    \n\n    // water level: U.x = w\n    // discharge u: U.y = hu\n    // discharge v: U.z = hv\n    vec3 U = texture(iChannel1, uv).xyz;\n\n    // at (j+1, k), (j-1, k), (j, k+1), (j, k-1)\n    vec3 U_jp1 = texture(iChannel1, uv + oneCellX).xyz;\n    vec3 U_jm1 = texture(iChannel1, uv - oneCellX).xyz;\n    vec3 U_kp1 = texture(iChannel1, uv + oneCellY).xyz;    \n    vec3 U_km1 = texture(iChannel1, uv - oneCellY).xyz;\n\n\n    // Boundary\n    if((uv + oneCellX).x > (NUM_CELLS_X - 0.5)/iResolution.x)\n    {\n        U_jp1 = vec3(U.x, -U.y, U.z);\n    }\n\n    if((uv - oneCellX).x < 0.)\n    {\n        U_jm1 = vec3(U.x, -U.y, U.z);\n    }\n\n    if((uv + oneCellY).y > (NUM_CELLS_Y - 0.5)/iResolution.y)\n    {\n        U_kp1 = vec3(U.x, U.y, -U.z);\n    }\n\n    if((uv - oneCellY).y < 0.)\n    {\n        U_km1 = vec3(U.x, U.y, -U.z);\n    }\n\n\n    vec3 Ux, Uy;\n    vec3 a1 = theta * (U - U_jm1) / dx;\n    vec3 a2 = (U_jp1 - U_jm1) / (2.*dx);\n    vec3 a3 = theta * (U_jp1 - U) / dx;\n    Ux = minmod(a1, a2, a3);\n\n    a1 = theta * (U - U_km1) / dy;\n    a2 = (U_kp1 - U_km1) / (2.*dy);\n    a3 = theta * (U_kp1 - U) / dy;\n    Uy = minmod(a1, a2, a3); \n\n    // upwind at j-1/2,k and j,k-1/2\n    // downwind at j+1/2,k and j,k+1/2\n    vec3 U_W = U - dx * 0.5 * Ux;\n    vec3 U_E = U + dx * 0.5 * Ux;\n    vec3 U_N = U + dy * 0.5 * Uy;\n    vec3 U_S = U - dy * 0.5 * Uy;\n\n    // reconstruct water level for positivity preserving\n    // B_f: Bⱼ₊₁/₂,ₖ\n    // B_b: Bⱼ₋₁/₂,ₖ\n    // B_u: Bⱼ,ₖ₊₁/₂\n    // B_d: Bⱼ,ₖ₋₁/₂\n    float B_f = B(uv + halfCellX);\n    float B_b = B(uv - halfCellX);\n    float B_u = B(uv + halfCellY);\n    float B_d = B(uv - halfCellY);\n\n\n    if(U_E.x < B_f)\n    {\n        Ux.x = (B_f - U.x) / (0.5 * dx);\n        U_E.x = B_f;\n        U_W.x = 2. * U.x - B_f;\n    }\n\n    if(U_W.x < B_b)\n    {\n        Ux.x = (U.x - B_b) / (0.5 * dx);\n        U_E.x = 2. * U.x - B_b;\n        if(U_E.x < B_f)\n            U_E.x = B_f;\n        U_W.x = B_b;\n    }\n\n\n    if(U_N.x < B_u)\n    {\n        Uy.x = (B_u - U.x) / (0.5 * dy);\n        U_N.x = B_u;\n        U_S.x = 2. * U.x - B_u;\n    }\n\n    if(U_S.x < B_d)\n    {\n        Uy.x = (U.x - B_d) / (0.5 * dy);\n        U_S.x = B_d;\n        U_N.x = 2. * U.x - B_d;\n\n        if(U_N.x < B_u)\n            U_N.x = B_u;\n    }\n\n    // Also store bottom height at .w, so we don't have compute them again in the next pass\n    if(blockId == 0.)      fragColor = vec4(U_W, B_b);\n    else if(blockId == 1.) fragColor = vec4(U_E, B_f);\n    else if(blockId == 2.) fragColor = vec4(U_S, B_d);\n    else if(blockId == 3.) fragColor = vec4(U_N, B_u);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Saint-Venant system of Shallow Water Equation\n\n#define B0UV (uv)\n#define B1UV (uv + vec2(NUM_CELLS_X, 0.) / iResolution.xy)\n#define B2UV (uv + vec2(NUM_CELLS_X * 2., 0.) / iResolution.xy)\n#define B3UV (uv + vec2(NUM_CELLS_X * 3., 0.) / iResolution.xy)\n\n// bottom topology\nfloat B(vec2 uv)\n{\n    return terrian(uv * iResolution.x/64.);\n}\n\n// where and how much water at the begining\nvec3 initialCondition(vec2 uv, vec2 uv_f, vec2 uv_b)\n{\n    if(uv.x > 0.06 && uv.x < 0.15 && uv.y > 0.15 && uv.y < 0.3)\n    return vec3(2. + B(uv), 0., 0.);\n    else return vec3(B(uv), 0., 0.);\n    //return vec3(2. + B(uv), 0., 0.);\n}\n\nvec2 reconstructSpeed(float h, vec2 huv)\n{\n    float h4 = pow(h, 4.0);\n    return (sqrt(2.) * h * huv) / sqrt(h4 + max(h4, epsilon));\n}\n\nfloat localPropagationSpeedUpwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return max(max(u_p + sqrt(g * h_p), u_m + sqrt(g * h_m)), 0.00001);\n}\n\nfloat localPropagationSpeedDownwind(float u_p, float u_m, float h_p, float h_m)\n{\n    return min(min(u_p - sqrt(g * h_p), u_m - sqrt(g * h_m)), -0.00001);\n}\n\nvec3 F(vec2 huv, float h, float u)\n{\n    return vec3(huv.x, h * u*u + g * 0.5 * h*h, u * huv.y);\n}\n\nvec3 G(vec2 huv, float h, float v)\n{\n    return vec3(huv.y, v * huv.x, h * v*v + g * 0.5 * h*h);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x > NUM_CELLS_X || fragCoord.y > NUM_CELLS_Y)\n        return;\n        \n    vec2 uv = fragCoord/iResolution.xy;\n        \n    // Get upwind and downwind derivatives on the four edges\n\n    // U⁺ⱼ₊₁/₂,ₖ = U_jp1_W\n    // U⁻ⱼ₋₁/₂,ₖ = U_jm1_E\n    // U⁻ⱼ₊₁/₂,ₖ = U_E\n    // U⁺ⱼ₋₁/₂,ₖ = U_W\n    // U⁺ⱼ,ₖ₊₁/₂ = U_kp1_S\n    // U⁻ⱼ,ₖ₋₁/₂ = U_km1_N\n    // U⁻ⱼ,ₖ₊₁/₂ = U_N\n    // U⁺ⱼ,ₖ₋₁/₂ = U_S\n    \n    vec4 U_W = texture(iChannel0, B0UV);\n    vec4 U_E = texture(iChannel0, B1UV);\n    vec4 U_S = texture(iChannel0, B2UV);\n    vec4 U_N = texture(iChannel0, B3UV);\n    \n    vec3 U_jp1_W = texture(iChannel0, B0UV + oneCellX).xyz;\n    vec3 U_jm1_E = texture(iChannel0, B1UV - oneCellX).xyz;\n    vec3 U_kp1_S = texture(iChannel0, B2UV + oneCellY).xyz;\n    vec3 U_km1_N = texture(iChannel0, B3UV - oneCellY).xyz;\n\n\n    // B_f: Bⱼ₊₁/₂,ₖ\n    // B_b: Bⱼ₋₁/₂,ₖ\n    // B_u: Bⱼ,ₖ₊₁/₂\n    // B_d: Bⱼ,ₖ₋₁/₂\n    float B_b = U_W.w;\n    float B_f = U_E.w;\n    float B_d = U_S.w;\n    float B_u = U_N.w;\n    \n    \n    // Boundary\n    if((B0UV + oneCellX).x > NUM_CELLS_X / iResolution.x)\n    {\n        U_jp1_W = vec3(U_E.x, -U_E.y, U_E.z);\n    }\n    \n    if((B1UV - oneCellX).x < NUM_CELLS_X / iResolution.x)\n    {\n        U_jm1_E = vec3(U_W.x, -U_W.y, U_W.z);\n    }\n    \n    if((B2UV + oneCellY).y > NUM_CELLS_Y / iResolution.y)\n    {\n        U_kp1_S = vec3(U_N.x, U_N.y, -U_N.z);\n    }\n    \n    if((B3UV - oneCellY).y < 0.)\n    {\n        U_km1_N = vec3(U_S.x, U_S.y, -U_S.z);\n    }\n    \n    // reconstruct water depth and propagation speed\n    // h⁺⁻ⱼ₊₋₁/₂,ₖ = w⁺⁻ⱼ₊₋₁/₂,ₖ - Bⱼ₊₋₁/₂,ₖ\n    // h⁺⁻ⱼ,ₖ₊₋₁/₂ = w⁺⁻ⱼ,ₖ₊₋₁/₂ - Bⱼ,ₖ₊₋₁/₂\n    float h_E = max(U_E.x - B_f, 0.);\n    float h_W = max(U_W.x - B_b, 0.);\n    float h_S = max(U_S.x - B_d, 0.);\n    float h_N = max(U_N.x - B_u, 0.);\n    \n    float h_jp1_W = max(U_jp1_W.x - B_f, 0.);\n    float h_jm1_E = max(U_jm1_E.x - B_b, 0.);\n    float h_kp1_S = max(U_kp1_S.x - B_u, 0.);\n    float h_km1_N = max(U_km1_N.x - B_d, 0.);\n    \n    \n    // velocity desingularization in case of very small h\n    vec2 uv_E = reconstructSpeed(h_E, U_E.yz);\n    vec2 uv_W = reconstructSpeed(h_W, U_W.yz);\n    vec2 uv_S = reconstructSpeed(h_S, U_S.yz);\n    vec2 uv_N = reconstructSpeed(h_N, U_N.yz);\n    vec2 uv_jp1_W = reconstructSpeed(h_jp1_W, U_jp1_W.yz);\n    vec2 uv_jm1_E = reconstructSpeed(h_jm1_E, U_jm1_E.yz);\n    vec2 uv_kp1_S = reconstructSpeed(h_kp1_S, U_kp1_S.yz);\n    vec2 uv_km1_N = reconstructSpeed(h_km1_N, U_km1_N.yz);\n\n    \n    // Local speeds of propagation\n    // the upper and lower bounds of local speeds can be estimated using\n    // the largest and smallest eigenvalues of the Jacobian ∂F/∂U\n    // a⁺ⱼ₊₁/₂,ₖ = aᵂⱼ₊₁,ₖ\n    // a⁻ⱼ₊₁/₂,ₖ = aᴱⱼ,ₖ\n    // a⁻ⱼ₋₁/₂,ₖ = aᴱⱼ₋₁,ₖ\n    // a⁺ⱼ₋₁/₂,ₖ = aᵂⱼ,ₖ\n    // b⁺ⱼ,ₖ₊₁/₂ = bˢⱼ,ₖ₊₁\n    // b⁻ⱼ,ₖ₊₁/₂ = bᴺⱼ,ₖ\n    // b⁻ⱼ,ₖ₋₁/₂ = bᴺⱼ,ₖ₋₁\n    // b⁺ⱼ,ₖ₋₁/₂ = bˢⱼ,ₖ\n    float a_jp1_W = localPropagationSpeedUpwind(uv_E.x, uv_jp1_W.x, h_E, h_jp1_W);\n    float a_E     = localPropagationSpeedDownwind(uv_E.x, uv_jp1_W.x, h_E, h_jp1_W);\n    float a_jm1_E = localPropagationSpeedDownwind(uv_jm1_E.x, uv_W.x, h_jm1_E, h_W);\n    float a_W     = localPropagationSpeedUpwind(uv_jm1_E.x, uv_W.x, h_jm1_E, h_W);\n    float b_kp1_S = localPropagationSpeedUpwind(uv_N.y, uv_kp1_S.y, h_N, h_kp1_S);\n    float b_N     = localPropagationSpeedDownwind(uv_N.y, uv_kp1_S.y, h_N, h_kp1_S);\n    float b_km1_N = localPropagationSpeedDownwind(uv_km1_N.y, uv_S.y, h_km1_N, h_S);\n    float b_S     = localPropagationSpeedUpwind(uv_km1_N.y, uv_S.y, h_km1_N, h_S);\n\n    \n    // Recompute the discharge using reconstructed h and u\n    U_W.yz = h_W * uv_W;\n    U_E.yz = h_E * uv_E;\n    U_S.yz = h_S * uv_S;\n    U_N.yz = h_N * uv_N;\n    U_jp1_W.yz = h_jp1_W * uv_jp1_W;\n    U_jm1_E.yz = h_jm1_E * uv_jm1_E;\n    U_kp1_S.yz = h_kp1_S * uv_kp1_S;\n    U_km1_N.yz = h_km1_N * uv_km1_N;\n    \n    // Flux\n    vec3 F_W = F(U_W.yz, h_W, uv_W.x);\n    vec3 F_E = F(U_E.yz, h_E, uv_E.x);\n    vec3 F_jp1_W = F(U_jp1_W.yz, h_jp1_W, uv_jp1_W.x);\n    vec3 F_jm1_E = F(U_jm1_E.yz, h_jm1_E, uv_jm1_E.x);\n    \n    vec3 G_S = G(U_S.yz, h_S, uv_S.y);\n    vec3 G_N = G(U_N.yz, h_N, uv_N.y);\n    vec3 G_kp1_S = G(U_kp1_S.yz, h_kp1_S, uv_kp1_S.y);\n    vec3 G_km1_N = G(U_km1_N.yz, h_km1_N, uv_km1_N.y);\n    \n    \n    vec3 H_f = (a_jp1_W * F_E - a_E * F_jp1_W) / (a_jp1_W - a_E) + \n                (a_jp1_W * a_E) / (a_jp1_W - a_E) * (U_jp1_W - U_E.xyz);\n                \n    vec3 H_b = (a_W * F_jm1_E - a_jm1_E * F_W) / (a_W - a_jm1_E) + \n                (a_W * a_jm1_E) / (a_W - a_jm1_E) * (U_W.xyz - U_jm1_E);\n                \n    vec3 H_u = (b_kp1_S * G_N - b_N * G_kp1_S) / (b_kp1_S - b_N) + \n                (b_kp1_S * b_N) / (b_kp1_S - b_N) * (U_kp1_S - U_N.xyz);\n                \n    vec3 H_d = (b_S * G_km1_N - b_km1_N * G_S) / (b_S - b_km1_N) + \n                (b_S * b_km1_N) / (b_S - b_km1_N) * (U_S.xyz - U_km1_N);\n            \n    // Source Term\n    vec3 S = vec3(0., \n            -g * ((U_E.x + U_W.x) * 0.5 - (B_f+B_b)*0.5) * ((B_f-B_b) / dx),\n            -g * ((U_N.x + U_S.x) * 0.5 - (B_u+B_d)*0.5) * ((B_u-B_d) / dy));\n    \n\n    vec3 U_n = texture(iChannel1, uv).xyz;\n    \n    // Initial condition\n    if(iFrame ==0)\n    {\n        U_n = initialCondition(uv, uv+halfCellX, uv-halfCellX);\n    }\n    \n    \n    // Foward Eular\n    vec3 U = U_n + dt * (-(H_f - H_b)/dx - (H_u - H_d)/dy + S);\n\n    fragColor = vec4(U, 0.);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "nearest",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Created by evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// 2D Saint-Venant system of Shallow Water Equation\n// An implementation of the paper:\n// A SECOND-ORDER WELL-BALANCED POSITIVITY PRESERVING CENTRAL-UPWIND SCHEME FOR THE SAINT-VENANT SYSTEM\n// https://www.intlpress.com/site/pub/files/_fulltext/journals/cms/2007/0005/0001/CMS-2007-0005-0001-a006.pdf\n// 1D version here: https://www.shadertoy.com/view/wt3BDH\n\n// No larger than iResolution.xy / 2\n#define NUM_CELLS_X 150.\n#define NUM_CELLS_Y 150.\n#define dx 1.\n#define dy 1.\n#define theta 1.4\n#define epsilon (0.01 * max(1., min(dx, dy)))\n#define g 9.812\n// not bounded by CFL condition as it requires \n// calculation of the max of all local speeds of propagation\n#define dt .02\n\n#define oneCellX  vec2(1./iResolution.x,  0.)\n#define halfCellX vec2(0.5/iResolution.x, 0.)\n#define oneCellY  vec2(0.,  1./iResolution.y)\n#define halfCellY vec2(0., 0.5/iResolution.y)\n\n\nfloat hash1(vec2 p)\n{\n    p = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return (a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\nconst mat2 m2 = mat2(.8,.6,-.6, .8);\n                      \nfloat terrian(vec2 p)\n{    \n    float f = 1.7;\n    float s = 0.7;\n    float a = 0.0;\n    float b = 0.6;\n    \n    for(int i=0; i<8; i++)\n    {\n        float n = noise(p);\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\t\n    a=smoothstep(.5,1.2,a);\n    \n    return a*9.;\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}