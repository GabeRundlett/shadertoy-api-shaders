{
    "Shader": {
        "info": {
            "date": "1688126012",
            "description": "Inverse Kinematic with fabrik, gradientdescent (jacobian) and forward implementations",
            "flags": 32,
            "hasliked": 0,
            "id": "dsSczz",
            "likes": 6,
            "name": "Inverse Kinematic",
            "published": 3,
            "tags": [
                "2d",
                "ik",
                "physics",
                "fabrik",
                "gradientdescent",
                "jacobian"
            ],
            "usePreview": 0,
            "username": "l1ghtrider",
            "viewed": 247
        },
        "renderpass": [
            {
                "code": "#define SHOW_BUFFERA 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution; float aspect; vec2 uv; vec2 target;\n    GetCommonInfo(iResolution, fragCoord, iMouse, resolution, aspect, uv, target);\n    vec2 rootPos = ROOT_POS;\n\n#if SHOW_BUFFERA == 1\n    vec2 cacheUV = fragCoord / resolution;\n    cacheUV = vec2(float(JOINT_NUM) + 0.5f, 0) / resolution;\n    fragColor = texture(iChannel0, cacheUV);\n    return;\n#endif\n\nbool converged = false;\n\n#if USING_BUFFERA == 1\n    Joint joints[JOINT_NUM];\n    vec2 end;\n    Fetch(iChannel0, joints, end);\n    converged = length(end - target) <= ITERATION_THRESHOLD;\n#else\n    //initialize joints' states\n    Joint joints[JOINT_NUM];\n    InitJoints(joints);\n\n    mat3 matrixAcc;\n    vec2 end;\n    for (int it = 0; it < min(int(iTime / 0.5f), ITERATION_COUNT); it++)\n    {\n        Iterate(joints, converged, end, target);\n        if (converged) break;\n    }\n#endif\n\n    bool black = false;\n    bool white = false;\n    mat3 matrixCol = mat3(1.0f);\n    \n    float drawRadius = JOINT_RADIUS * 1.5f;\n    float len = length(uv.xy - rootPos);\n    black = black || len < drawRadius;\n    white = white || len < JOINT_RADIUS;\n    \n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        Joint joi = joints[i];\n        vec2 localPosition = i == 0 ? rootPos : vec2(joints[i].length, 0.0f);\n        matrixCol = matrixCol * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        vec2 pos = (matrixCol * vec3(joi.length, 0.0f, 1.0f)).xy;\n        float len = length(uv.xy - pos);\n        black = black || len < drawRadius;\n        black = black || box2dmat(vec3(uv.xy, 1.0f), inverse(matrixCol), drawRadius, joints[i].length);\n        white = white || len < JOINT_RADIUS;\n    }\n    \n    fragColor = vec4(0.7, 0.1, uv.y + 0.3, 0.0);\n    if (black) fragColor = vec4(0.0f);\n    if (white) fragColor = converged ? vec4(0.0f, 1.0f, 1.0f, 1.0f) : vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    fragColor += 1.0 - smoothstep(length(uv - target), 0.0, 0.01);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 resolution; float aspect; vec2 uv; vec2 target;\n    GetCommonInfo(iResolution, fragCoord, iMouse, resolution, aspect, uv, target);\n    vec2 rootPos = ROOT_POS;\n    \n    ivec2 coord = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, coord, 0); \n    \n    Joint joints[JOINT_NUM];\n    vec2 end;\n    Fetch(iChannel0, joints, end);\n    \n    for (int i = 0; i < ITERATION_PER_FRAME; i++)\n    {\n        if (length(end - target) > ITERATION_THRESHOLD)\n        {\n            bool converged;\n            Iterate(joints, converged, end, target);\n\n            if (coord.y == 0)\n            {\n                if (coord.x < JOINT_NUM)\n                {\n                    Joint joi = joints[coord.x];\n                    fragColor = vec4(vec2(0.0f), JOINT_LENGTH, joi.angle) / vec4(FLT_SCALE);\n                }\n                if (coord.x == JOINT_NUM)\n                {\n                    fragColor = vec4(end.xy, JOINT_LENGTH, 0.0f) / vec4(FLT_SCALE);\n                }\n            }\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "//IK_MODE 0 Jacobian\n//IK_MODE 1 FABRIK\n//IK_MODE 2 Forward\n#define IK_MODE 1\n#define USING_BUFFERA 1\n\n#if IK_MODE == 0\n#define ITERATION_PER_FRAME 10\n#define ITERATION_THRESHOLD 0.02f\n#elif IK_MODE == 1\n#define ITERATION_PER_FRAME 1\n#define ITERATION_THRESHOLD 0.001f\n#else\n#define ITERATION_PER_FRAME 10\n#define ITERATION_THRESHOLD 0.04f\n#endif\n\n#define JACOBIAN_SCALE 1.0f / 50.0f\n#define JOINT_NUM 5\n#define ROOT_X -0.35f\n#define ROOT_POS vec2(ROOT_X, 0.0f)\n#define JOINT_TOTAL_LENGTH 0.7f\n#define JOINT_LENGTH (JOINT_TOTAL_LENGTH / float(JOINT_NUM))\n#define JOINT_RADIUS 0.02f\n#define ITERATION_COUNT 100\n\n#define ITERATION_SCALE 0.2f\n#define PI 3.1415936f\n#define FLT_SCALE 1.0f\n\nstruct Joint\n{\n    float length;\n    float angle;\n    float radius;\n};\n\nvec2 rot2d(vec2 v,float d)\n{\n    float s = sin(d),c = cos(d);\n    mat2 rot = mat2(c,s,-s,c);\n    return rot * v;\n}\n\nmat3 rot2dmat(float angle)\n{\n    float s = sin(angle),c = cos(angle);\n    mat3 rot = mat3(c, s, 0, -s, c, 0, 0, 0, 1.0f);\n    return rot;\n}\n\nmat3 translate2dmat(vec2 pos)\n{\n    mat3 ret = mat3(1.0f);\n    ret[2][0] = pos.x;\n    ret[2][1] = pos.y;\n    return ret;\n}\n\nbool box2dmat(vec3 pos, mat3 w2l, float w, float h)\n{\n     pos = w2l * pos;\n     return pos.x > 0. && pos.x < h && pos.y > -w && pos.y < w;\n}\n\nbool box2d(vec2 uv, vec2 pos, vec2 pivot, float angle, float w, float h)\n{\n    uv -= pos;\n    uv = rot2d(uv, -angle) + pivot;\n    return (uv.x > 0.0f) && (uv.x < h) && (uv.y > -w) && (uv.y < w);\n}\n\nfloat CalculateGradient(vec2 pos, Joint root, mat3 matrixAcc, mat3 matrixRem, vec2 target)\n{\n    const float angleOff = 0.001f;\n    float dis = length((matrixAcc * translate2dmat(pos) * rot2dmat(root.angle) * matrixRem\n        * vec3(root.length, 0.0f, 1.0f)).xy  - target);\n    float disNew = length((matrixAcc * translate2dmat(pos) * rot2dmat(root.angle + angleOff) * matrixRem\n        * vec3(root.length, 0.0f, 1.0f)).xy  - target);\n    float slope = (disNew - dis) / angleOff;\n    return slope;\n}\n\nvoid GetCommonInfo(in vec3 iResolution, in vec2 fragCoord, in vec4 iMouse\n    , out vec2 resolution, out float aspect, out vec2 uv, out vec2 target)\n{\n    resolution = iResolution.xy;\n    aspect = iResolution.x / iResolution.y;\n    uv = fragCoord / resolution - vec2(0.5f);\n    uv.y /= aspect;\n    target = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) - vec2(0.5f); \n    target.y /= aspect;\n}\n\nvoid InitJoints(inout Joint joints[JOINT_NUM])\n{\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        joints[i].length = JOINT_LENGTH;\n        if (i == 2) joints[i].angle = 0.5f;\n        else joints[i].angle = 0.0f;\n        joints[i].radius = JOINT_RADIUS;\n    }\n}\n\nvoid Fetch(sampler2D iChannel0, inout Joint joints[JOINT_NUM], out vec2 end)\n{\n    ivec2 coord;\n    vec4 drawed;\n    \n    coord = ivec2(JOINT_NUM, 0);\n    drawed = texelFetch(iChannel0, ivec2(coord), 0);\n    drawed *= FLT_SCALE;\n    if (drawed != vec4(0.0f))\n    {\n        end = drawed.xy;\n        for (int i = 0; i < JOINT_NUM; i++)\n        {\n            coord = ivec2(i, 0);\n            drawed = texelFetch(iChannel0, ivec2(coord), 0);\n            drawed *= FLT_SCALE;\n            if (drawed != vec4(0.0f))\n            {\n                joints[i].length = drawed.z;\n                joints[i].angle = drawed.w;\n            }\n            else\n            {\n                joints[i].length = JOINT_LENGTH;\n                joints[i].angle = 0.0f;\n            }\n        }\n    }\n    else\n    {\n        end = vec2(1000.0f);\n        InitJoints(joints);\n    }\n}\n\nvoid Jacobian(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    vec3 jacobian[JOINT_NUM];\n    const vec3 unitZ = vec3(0.0f, 0.0f, 1.0f);\n    mat3 matrixAcc = mat3(1.0f);\n    vec2 lastPos,pos;\n    lastPos = ROOT_POS;\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        float lenEff = float(i) / float(JOINT_NUM - 1) * 0.1f + 0.9f;\n        lenEff = i == 0 ? 0.9f : 1.0f; \n        lenEff = 0.0f;\n        pos = (matrixAcc * vec3(joints[i].length * lenEff, 0.0f, 1.0f)).xy;\n        vec3 diffI = vec3(target - pos, 0.0f);\n        jacobian[i].xy = normalize(cross(unitZ, diffI).xy);\n        jacobian[i].z = min((length(diffI.xy) - ITERATION_THRESHOLD) * 0.005f, 0.001f);\n        //joints[i].angle += dot(jacobian[i].xy, lastPos - target) * 1.0f;\n        lastPos = pos;\n    }\n    end = (matrixAcc * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n\n    matrixAcc = mat3(1.0f);\n    vec2 diff = normalize(target - end);\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        float effect = 0.5f + float(i) / float(JOINT_NUM);\n        float joc = dot(jacobian[i].xy, diff.xy) * JACOBIAN_SCALE;  \n        joints[i].angle += joc;\n        //joints[i].angle -= dot(jacobian[i].xy, vec2(jacobian[i].z)) * 1.0f;\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n    }\n    end = (matrixAcc * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n    converged = converged || length(end  - target) <= ITERATION_THRESHOLD; \n}\n\nvoid FABRIK(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    mat3 matrixAcc = mat3(1.0f);\n    vec2 worldPoses[JOINT_NUM + 1]; worldPoses[0] = ROOT_POS;\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        worldPoses[i + 1] = (matrixAcc * vec3(joints[i].length, 0.0f, 1.0f)).xy;\n    }\n\n    for (int it = 0; it < 1; it++)\n    {\n        vec2 a,b;\n\n        worldPoses[JOINT_NUM] = target;\n        for (int i = JOINT_NUM - 1; i >= 0; i--)\n        {\n            Joint joi = joints[i];\n            a = worldPoses[i + 1] - worldPoses[i]; a = normalize(a);\n            worldPoses[i] = worldPoses[i + 1] - a * joi.length;;\n            b = i == 0 ? vec2(1.0f, 0.0f) : worldPoses[i] - worldPoses[i - 1]; b = normalize(b);\n            joints[i].angle = sign(cross(vec3(b.xy, 0.0f),vec3(a.xy, 0.0f)).z) *acos(clamp(dot(a,b), -1.0f, 1.0f));\n        }\n\n        worldPoses[0] = ROOT_POS;\n        for (int i = 0; i < JOINT_NUM; i++)\n        {\n            Joint joi = joints[i];\n            a = worldPoses[i + 1] - worldPoses[i]; a = normalize(a);\n            worldPoses[i + 1] = worldPoses[i] + a * joi.length;;\n            b = i == 0 ? vec2(1.0f, 0.0f) : worldPoses[i] - worldPoses[i - 1]; b = normalize(b);\n            joints[i].angle = sign(cross(vec3(b.xy, 0.0f),vec3(a.xy, 0.0f)).z) * acos(clamp(dot(a,b), -1.0f, 1.0f));\n        }\n\n        end = worldPoses[JOINT_NUM];\n        if (length(worldPoses[JOINT_NUM] - target) <= ITERATION_THRESHOLD)\n        {\n            converged = true;\n            break;\n        }\n    }\n}\n\nvoid Forward(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n    mat3 matrixAcc = mat3(1.0f);\n    for (int i = 0; i < JOINT_NUM; i++)\n    {\n        mat3 matrixRem = mat3(1.0f);\n        for (int j = i + 1; j < JOINT_NUM; j++)\n        {\n            matrixRem = matrixRem * translate2dmat(vec2(joints[j].length, 0.0f)) * rot2dmat(joints[j].angle);\n        }\n        vec2 localPosition = i == 0 ? ROOT_POS : vec2(joints[i].length, 0.0f);\n        float offAngle = CalculateGradient(localPosition, joints[i], matrixAcc, matrixRem, target) * ITERATION_SCALE;\n        joints[i].angle -= offAngle;\n        matrixAcc = matrixAcc * translate2dmat(localPosition) * rot2dmat(joints[i].angle);\n        end = (matrixAcc * matrixRem * vec3(joints[JOINT_NUM - 1].length, 0.0f, 1.0f)).xy;\n        float dis = length(end  - target);\n        if (dis < ITERATION_THRESHOLD) \n        {\n            converged = true;\n            break;\n        }\n    }\n}\n\nvoid Iterate(inout Joint joints[JOINT_NUM], inout bool converged, inout vec2 end, vec2 target)\n{\n#if IK_MODE == 0\n    Jacobian(joints, converged, end, target);\n#elif IK_MODE == 1\n    FABRIK(joints, converged, end, target);\n#else\n    Forward(joints, converged, end, target);\n#endif\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}