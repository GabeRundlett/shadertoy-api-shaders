{
    "Shader": {
        "info": {
            "date": "1671487788",
            "description": "Code mostly only from ChatGPT. That happens when a AI writes an raymarcher shader. :-)",
            "flags": 0,
            "hasliked": 0,
            "id": "dtf3RM",
            "likes": 6,
            "name": "ChatGPT \"modern car\"",
            "published": 3,
            "tags": [
                "raymarching",
                "car",
                "chatgpt"
            ],
            "usePreview": 0,
            "username": "BeRo",
            "viewed": 479
        },
        "renderpass": [
            {
                "code": "// Code mostly only from ChatGPT from a very long thread, where ChatGPT has \n// often corrected itself\n\n// GLSL function to calculate distance to a torus\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n// GLSL function to calculate distance to a box\nfloat sdBox(vec3 p, vec3 b, vec3 r) {\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// GLSL function to calculate distance to a sphere\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\nvec2 sdModernCar(vec3 p) {\n  float dist = 10000.0;\n  float materialIndex = 0.0;\n\n  // Calculate distance to car body\n  float bodyDist = sdBox(p - vec3(0.0, 0.5, 0.0), vec3(1.0, 0.5, 1.8), vec3(0.0));\n  dist = min(dist, bodyDist);\n  materialIndex = 1.0; // Body of car is material 1\n\n  // Calculate distance to front grill\n  float grillDist =\n      sdBox(p - vec3(0.0, 0.5, 1.8), vec3(1.0, 0.1, 0.2), vec3(0.0));\n  if (grillDist < dist) {\n    dist = grillDist;\n    materialIndex = 3.0; // Grill of car is material 3\n  }\n\n  // Calculate distance to front left headlight\n  float flhDist = sdSphere(p - vec3(0.9, 0.5, 1.8), 0.2);\n  if (flhDist < dist) {\n    dist = flhDist;\n    materialIndex = 4.0; // Headlights of car are material 4\n  }\n\n  // Calculate distance to front right headlight\n  float frhDist = sdSphere(p - vec3(-0.9, 0.5, 1.8), 0.2);\n  if (frhDist < dist) {\n    dist = frhDist;\n    materialIndex = 4.0; // Headlights of car are material 4\n  }\n\n  // Calculate distance to front left tire\n  float fltDist = sdTorus(p - vec3(0.7, 0.0, 1.0), vec2(0.2, 0.2));\n  if (fltDist < dist) {\n    dist = fltDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to front right tire\n  float frtDist = sdTorus(p - vec3(-0.7, 0.0, 1.0), vec2(0.2, 0.2));\n  if (frtDist < dist) {\n    dist = frtDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to back left tire\n  float bltDist = sdTorus(p - vec3(0.7, 0.0, -1.2), vec2(0.2, 0.2));\n  if (bltDist < dist) {\n    dist = bltDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  // Calculate distance to back right tire\n  float brtDist = sdTorus(p - vec3(-0.7, 0.0, -1.2), vec2(0.2, 0.2));\n  if (brtDist < dist) {\n    dist = brtDist;\n    materialIndex = 5.0; // Tires of car are material 5\n  }\n\n  return vec2(dist, materialIndex);\n}\n\nvec3 sdNormal(vec3 p, float eps) {\n  vec3 n;\n  n.x = sdModernCar(p + vec3(eps, 0.0, 0.0)).x - sdModernCar(p - vec3(eps, 0.0, 0.0)).x;\n  n.y = sdModernCar(p + vec3(0.0, eps, 0.0)).x - sdModernCar(p - vec3(0.0, eps, 0.0)).x;\n  n.z = sdModernCar(p + vec3(0.0, 0.0, eps)).x - sdModernCar(p - vec3(0.0, 0.0, eps)).x;\n  return normalize(n);\n}\n\n// Main GLSL function\nvec2 raymarchCar(vec3 start, vec3 direction) {\n  float t = 0.0;\n  float dist = 0.0;\n  float minDist = 10000.0;\n  float materialIndex = 0.0;\n  int i = 0;\n  \n  while (i < 300 && t < 30.0) {\n    vec3 pos = start + t * direction;\n\n    // Calculate distance and material index using sdModernCar function\n    vec2 result = sdModernCar(pos);\n    dist = result.x;\n    float tempMaterialIndex = result.y;\n\n    // Check if current distance is the minimum distance\n    if (dist < minDist) {\n      minDist = dist;\n      materialIndex = tempMaterialIndex;\n    }\n\n    t += dist;\n    i++;\n  }\n\n  return (minDist < 1e-4) ? vec2(minDist, materialIndex) : vec2(0.0, 0.0);\n}\n\n// View ray generation\nvoid generateRay(out vec3 resultRayOrigin, out vec3 resultRayDirection,\n                 in vec3 viewOrigin, in vec3 viewTarget, in vec2 uv) {\n  vec2 p = (2.0 * uv - iResolution.xy) / iResolution.y;\n\n  resultRayOrigin = viewOrigin;\n\n  // camera matrix\n  vec3 ww = normalize(viewTarget - viewOrigin);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  // create view ray\n  resultRayDirection = normalize(p.x * uu + p.y * vv + 2.2 * ww);\n}\n\n// Main GLSL entry function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n  // Ray origin\n  vec3 rayOrigin = vec3(0.0, 1.5, -5.0);\n\n  // Rotate ray origin towards car middle point\n  mat3 rotate = mat3(cos(iTime), 0.0, sin(iTime), 0.0, 1.0, 0.0, -sin(iTime), 0.0, cos(iTime));\n  rayOrigin = rotate * rayOrigin;\n  \n  // Generate view ray\n  vec3 viewTarget = vec3(0.0, 0.0, 0.0);\n  vec3 rayDirection;\n  generateRay(rayOrigin, rayDirection, rayOrigin, viewTarget, fragCoord);\n\n  // Calculate distance and material index using raymarchCar function\n  vec2 result = raymarchCar(rayOrigin, normalize(rayDirection));\n  float dist = result.x;\n  float materialIndex = result.y;\n\n  // Calculate final color based on material index and simple lambert lighting\n  vec3 finalColor;\n  if (materialIndex == 1.0) {\n    // Body of car is silver\n    finalColor = vec3(0.75, 0.75, 0.75);\n  } else if (materialIndex == 2.0) {\n    // Wheels of car are black\n    finalColor = vec3(0.0, 0.0, 0.0);\n  } else if (materialIndex == 3.0) {\n    // Grill of car is chrome\n    finalColor = vec3(0.9, 0.9, 0.9);\n  } else if (materialIndex == 4.0) {\n    // Headlights of car are white\n    finalColor = vec3(1.0, 1.0, 1.0);\n  } else if (materialIndex == 5.0) {\n    // Tires of car are black\n    finalColor = vec3(0.0, 0.0, 0.0);\n  } else {\n    // Any other material is white\n    finalColor = vec3(1.0, 1.0, 1.0);\n  }\n  \n  // Calculate lighting using simple lambert lighting model\n  if (materialIndex > 0.0) {\n    vec3 lightDirection = normalize(vec3(0.5, 0.5, 0.5));\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    // If we hit an object, calculate surface normal  \n    normal = sdNormal(rayOrigin + rayDirection * dist, 0.001);\n    finalColor *= max(dot(lightDirection, normal), 0.0);\n  }\n  \n  fragColor = vec4(finalColor, 1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}