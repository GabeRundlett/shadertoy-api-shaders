{
    "Shader": {
        "info": {
            "date": "1578562581",
            "description": "A basic raymarching demo",
            "flags": 0,
            "hasliked": 0,
            "id": "tly3RD",
            "likes": 2,
            "name": "RayMarching Sample",
            "published": 3,
            "tags": [
                "raymarchingsdf"
            ],
            "usePreview": 0,
            "username": "challenge",
            "viewed": 324
        },
        "renderpass": [
            {
                "code": "const vec3 ambientLight = vec3(0.1);\nconst vec3 specColor = vec3(0.04);\n\nconst float EPSILON = 0.00001;\n\nconst float UNITY_INV_PI = 0.31830988618f;\nconst float UNITY_PI = 3.14159265359f;\n\nconst int maxSteps = 256;\n\n#define SHOW_NORMAL 0\n#define SHOW_DEPTH 0\n#define SHOW_MATERIAL_BASECOLOR 0\n#define SHOW_MATERIAL_SMOTHNESS 0\n\n#define SHOW_FOG 1\n#define CAMERA_ROTATE 1\n#define LIGHT_ROTATE 0\n#define LIGHT_ADD 0\n\n#define SMOTHNESS_TEST 1\n\nfloat showNormal;\nfloat showDepth;\nfloat showReflection;\n\nstruct LightData\n{\n    vec3 pos;\n    float intensity;\n    vec3 color;\n};\n    \nLightData mainLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(30.32, 20.77, 0.56);\n    #if LIGHT_ROTATE\n    \tl.pos = vec3(30.32*sin(iTime), 20.77, 0.56*cos(iTime));\n    #endif\n    l.color = vec3(1.0, 1.0, 1.0) * l.intensity;\n    return l;\n}\n\nLightData addLight() {\n    LightData l;\n\n    l.intensity = 1.0;\n\tl.pos = vec3(-30.32, 20.77, 0.56);\n    l.color = vec3(0.2, 0.9, 0.67) * l.intensity;\n    return l;\n}\n\nstruct MaterialData\n{\n    vec3 diffColor;\n    float smoothness; \n};\n\nfloat sdPlane( vec3 p, vec3 o)\n{\n  return p.y;\n}\n\nfloat udBox( vec3 p, vec3 o, vec3 b )\n{\n  return length(max(abs(p - o)-b,0.0));\n}\n\nfloat sdSphere( vec3 p, vec3 o, float s )\n{\n  return length(p - o)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sceneSDF(vec3 samplePoint) {\n    \n    vec2 res = vec2(1e10, 0.0);\n    \n    vec2 cube = vec2(udBox(samplePoint,vec3(-1.0, 0.8, 0.0), vec3(0.8)), 4.0);\n    vec2 sphere = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, 2.0), 1.0), 2.0);\n    vec2 plane = vec2(sdPlane(samplePoint, vec3(0.0, 0.0, 0.0)), 0.0);\n    vec2 sphere2 = vec2(sdSphere(samplePoint, vec3(2.0, 1.0, -2.0), 1.0), 8.0);\n    \n\tres = opU(res, cube);\n    res = opU(res, sphere);\n    res = opU(res, sphere2);\n    res = opU(res, plane);\n    \n    return res;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\nfloat DisneyDiffuse(float NdotV, float NdotL, float LdotH, float perceptualRoughness)\n{\n    float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    float lightScatter   = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL, 5.0));\n    float viewScatter    = (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV, 5.0));\n\n    return lightScatter * viewScatter;\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return UNITY_INV_PI * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    float a = roughness;\n    float lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n    float lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);\n}\n\nvec3 FresnelTerm (vec3 F0, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\nvec3 FresnelLerp (vec3 F0, vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);   // ala Schlick interpoliation\n    return mix (F0, F90, t);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (2.5-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h =sceneSDF( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 BRDF(LightData light, vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n    float smoothness = mat.smoothness;\n    vec3 diffColor = mat.diffColor * 0.96;\n    float perceptualRoughness = 1.0 - smoothness;\n    float roughness = perceptualRoughness * perceptualRoughness;\n    roughness = max(roughness, 0.002);\n    \n    float sd = calcSoftshadow(p, light.pos, 0.03, 2.5);\n    \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.pos - p);\n    vec3 viewDir = normalize(eye - p);\n    vec3 H = normalize(L+viewDir);\n    vec3 R = normalize(reflect(-L, N));\n    \n    // 计算反射\n    vec3 ref = reflect(rd, N );\n    float dom = smoothstep( -0.2, 0.2, ref.y);\n    dom *= calcSoftshadow(p, ref, 0.2, 2.5);\n    \n  \n    //return vec3(dom);\n    vec3 reflectColor = smoothness*dom*vec3(0.40,0.60,1.30);\n    \n    if (showReflection > EPSILON) {\n\t\treturn reflectColor;\n    }\n    float NdotL = clamp(dot(N, L), 0.0, 1.0) * sd;\n    float NdotV = clamp(dot(N, viewDir), 0.0, 1.0);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0);\n    float NdotH = clamp(dot(N, H), 0.0, 1.0);\n    \n    float diffuseTerm = DisneyDiffuse(NdotV, NdotL, LdotH, perceptualRoughness) * NdotL;\n    float D = GGXTerm (NdotH, roughness);\n    float V = SmithJointGGXVisibilityTerm (NdotL, NdotV, roughness);\n    float specularTerm = V*D * UNITY_PI;\n    specularTerm = max(0.0, specularTerm * NdotL);\n    \n    float surfaceReduction = 1.0 / (roughness*roughness + 1.0);\n    vec3 grazingTerm = vec3(clamp(smoothness + 0.04, 0.0, 1.0));\n    \n    vec3 color = diffColor *(ambientLight + light.color * diffuseTerm)\n        \t\t+ specularTerm * light.color * FresnelTerm (specColor, LdotH) \n        \t\t+ surfaceReduction * reflectColor * FresnelLerp (specColor, grazingTerm, NdotV);\n    \n    return color;\n}\n\nvec3 illumination (vec3 p, vec3 eye, vec3 rd, MaterialData mat)\n{\n\tLightData light1 = mainLight();\n    \n    vec3 color = BRDF(light1, p, eye, rd, mat);\n    \n    #if LIGHT_ADD\n    \tLightData light2 = addLight();\n        vec3 addColor = BRDF(light2, p, eye, rd, mat);\n        color += addColor;\n    #endif\n    \n    return color;\n}\n\nvec3 ACESToneMapping(vec3 color, float adapted_lum)\n{\n\tconst float A = 2.51f;\n\tconst float B = 0.03f;\n\tconst float C = 2.43f;\n\tconst float D = 0.59f;\n\tconst float E = 0.14f;\n \n\tcolor *= adapted_lum;\n\treturn (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\n\nfloat checkers( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod(q.x+q.y,2.);\n}\n\nMaterialData GetDiffColor(vec3 p, float m) \n{\n    MaterialData material;\n    if (m < EPSILON) {\t\n        material.diffColor = checkers(p.xz) * vec3(0.5, 0.0, 0.0);\n        material.smoothness = 1.0;\n    } else if (m - 2.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.5, 0.0) ;\n        material.smoothness = 0.9;\n        #if SMOTHNESS_TEST\n        \tmaterial.smoothness = abs(sin(iTime));\n        #endif\n        \n    } else if (m - 4.0 < EPSILON) {\n        material.diffColor = vec3(0.0, 0.0, 0.5) ;\n        material.smoothness = 0.2;\n    } else if (m - 8.0 < EPSILON) {\n        material.diffColor = vec3(0.98, 0.51, 0.91) ;\n        material.smoothness = 0.2;\n    } else {\n        material.diffColor = vec3(0.5);\n    \tmaterial.smoothness = 0.5;\n    }\n    \n    return material;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv1 = fragCoord/iResolution.xy;\n\tvec2 uv = 2.0 * uv1;\n    //vec2 uv = uv1;\n    uv = fract(uv);\n\tuv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv1 -= .5;\n    uv1.x *= iResolution.x / iResolution.y;\n\n    showNormal = step(uv1.x, 0.0) * step(uv1.y, 0.0);\n    showDepth = step(-uv1.x, 0.0) * step(uv1.y, 0.0);\n    showReflection = step(-uv1.x, 0.0) * step(-uv1.y, 0.0);\n   \n    // 设置相机位置\n    vec3 ro = vec3(6.0,6.0, -6.0);\n    //ro += vec3( 4.5*cos(0.1*iTime + 16.0), 1.0 + 2.0, 4.5*sin(iTime + 16.0) );\n    #if CAMERA_ROTATE\n        ro = vec3(10.5*cos(iTime * 0.2), 5.0, -10.5*sin(iTime * 0.2));\n    #endif\n    \t\n\n    float zoom = 1.0;\n   \t// 设置看向的点\n    vec3 lookAt = vec3(0.5, 0.5, 0.5);\n    \n    // 格拉姆—施密特正交化\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    // 将2纬UV 升到 3纬坐标\n    vec3 i = c + uv.x*r + uv.y*u;\n    // 得到相机指向UV点的向量\n\tvec3 rd = i - ro;\n    \n    vec4 color = vec4(0.0);\n    \n    // Ray Marching\n    float t = 0.0;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n       \t\n        vec2 res = sceneSDF(p);\n        float d = res.x;\n        float m = res.y;\n        \n        if(d < EPSILON)\n        {\n            if (showNormal > EPSILON) {\n                color.rgb = (estimateNormal(p) + 1.0) * 0.5;\n            } else if (showDepth > EPSILON) {\n                color.rgb = vec3(t/20.0);\n            } else {\n                \n                // 获取命中物体的材质属性\n                MaterialData mat = GetDiffColor(p, m);\n\n                #if SHOW_MATERIAL_BASECOLOR\n                color.rgb = pow(mat.diffColor, vec3(0.4545));\n                #elif SHOW_MATERIAL_SMOTHNESS\n                color.rgb = vec3(mat.smoothness);\n                #else\n                // 渲染\n                color.rgb += illumination(p, ro, rd, mat);\n                #endif\n            }\n            \t\n\n            \n\n            \n            break;\n        }\n\n        float add = d;\n        \n        t += add;\n        \n        #if SHOW_FOG\n        \tcolor.rgb = mix( color.rgb, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n        #endif\n        \n    }\n    \n    // Tonemapping\n    color.rgb = ACESToneMapping(color.rgb, 1.0);\n    // 抵消屏幕Gamma矫正\n    color.rgb = pow( color.rgb, vec3(0.4545) );\n    \n    fragColor = color;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}