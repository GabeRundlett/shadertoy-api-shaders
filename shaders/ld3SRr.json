{
    "Shader": {
        "info": {
            "date": "1457308996",
            "description": "Importance sampling is used, since no cubemap mipmap available for blurry reflections. Cubemap sampling was HDR-ized and gamma balanced.",
            "flags": 32,
            "hasliked": 0,
            "id": "ld3SRr",
            "likes": 221,
            "name": "Image Based PBR Material",
            "published": 3,
            "tags": [
                "importancesampling",
                "hdr",
                "ibl",
                "pbr"
            ],
            "usePreview": 0,
            "username": "Bers",
            "viewed": 12088
        },
        "renderpass": [
            {
                "code": "// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Dec 2015\n// Modified : Jan 2016\n//\n// A ShaderToy implementation of Image Based PBR Material.\n// I struggled quite a bit with the TextureCubes available :\n// \t\t-One is gamma corrected, the other is not.\n//      -The skylight boundary between low and the high detail Cubemaps won't align\n//       with each other, unless the sky color value is cranked up very much where saturated.\n//       With the Cubemaps \"HDR remapped\", they finally aligned properly.\n//       \n// Importance Sampling is used, where mipmaps would usually be used in a game engine (much more efficient).\n// I ended up using a mix between random samples and a fixed sampling pattern.\n// Random sampling was too jittery, unless a very high sample count was used.\n//\n// Platic Materials lack a diffuse base. I have a WIP coming for this. It requires another cubemap lightness\n// hemisphere integration, for the diffuse part. Should be done in a seperate pass, not to kill the framerate.\n//\n// Regarding the IBL version of the PBR Equation, I also struggled to balance lighting. Most articles\n// and code examples are about point lights, and some pieces of code I found could not be used in the \n// IBL Scenario. A popular version of the geometric term as proposed by Disney, for example, has a modified \"k\" value \n// to \"reduce hotness\", which don't give good results with IBL (edges reflections, at grazing angles, would be\n// too dark, see Unreal4 2013SiggraphPresentationsNotes pdf link p.3 below).\n// Also, GGX Distribution term must not be used with IBL, because 1) it will look like garbage and 2)it makes no\n// sense (for \"perfect\" reflection angles (H==N), GGX value goes to the stratosphere, which you really don't want\n// with IBL). Energy conservation problems don't show as much with point lights, but they really do with Image Based\n// Lighting.\n//\n// HDR Color was choosen arbitrarily. You can change from red to blue using the second rightmost slider.\n// \n// Sources:\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n// https://seblagarde.wordpress.com/2011/08/17/feeding-a-physical-based-lighting-mode/\n// http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_slides_v2.pdf\n// https://www.youtube.com/watch?v=LP7HgIMv4Qo [impressive realtime materials with Substance, see 16m00s, 25m00s]\n// http://sirkan.iit.bme.hu/~szirmay/fresnel.pdf\n// http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n// http://refractiveindex.info/?shelf=3d&book=liquids&page=water\n// http://www.filmetrics.com/refractive-index-database/Al/Aluminium\n// https://www.shadertoy.com/view/4djSRW Dave Hoskin's hash without sine\n//\n// License : Creative Commons Non-commercial (NC) license\n//\n\n//----------------------\n// Constants \nconst float GEO_MAX_DIST   = 50.0;\nconst int MATERIALID_SKY    = 2;\nconst int MATERIALID_SPHERE = 3;\nconst vec3  F_ALU_N  = vec3(1.600,0.912,0.695); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\nconst vec3  F_ALU_K  = vec3(8.010,6.500,5.800); //(Red ~ 670 nm; Green ~ 540 nm; Blue ~ 475 nm)\n\n//----------------------\n// Slider bound globals. Use the slider, don't change the value here.\nfloat ROUGHNESS_AMOUNT       = 0.85;//Valid range : [0-1] 0=shiny, 1=rough map\nfloat SKY_COLOR              = 0.0; //[0.0=Red, 1.0=Blue)\nfloat ABL_LIGHT_CONTRIBUTION = 0.0; //[0-1] Additional ABL Light Contribution\n\n#define saturate(x) clamp(x,0.0,1.0)\n\n//PBR Equation for both (IBL) or (ABL), plastic or metal.\nvec3 PBR_Equation(vec3 V, vec3 L, vec3 N, float roughness, const vec3 ior_n, const vec3 ior_k, const bool metallic, const bool bIBL)\n{\n    float cosT = saturate( dot(L, N) );\n    float sinT = sqrt( 1.0 - cosT * cosT);\n\tvec3 H = normalize(L+V);\n\tfloat NdotH = dot(N,H);//Nn.H;\n\tfloat NdotL = dot(N,L);//Nn.Ln;\n\tfloat VdotH = dot(V,H);//Vn.H;\n    float NdotV = dot(N,V);//Nn.Vn;\n    \n    //Distribution Term\n    float PI = 3.14159;\n    float alpha2 = roughness * roughness;\n    float NoH2 = NdotH * NdotH;\n    float den = NoH2*(alpha2-1.0)+1.0;\n    float D = 1.0; //Distribution term is externalized from IBL version\n    if(!bIBL)\n        D = (NdotH>0.)?alpha2/(PI*den*den):0.0; //GGX Distribution.\n\t\n    //Fresnel Term\n\tvec3 F;\n    if(metallic)\n    {\n        float cos_theta = 1.0-NdotV;\n        F =  ((ior_n-1.)*(ior_n-1.)+ior_k*ior_k+4.*ior_n*pow(1.-cos_theta,5.))\n\t\t    /((ior_n+1.)*(ior_n+1.)+ior_k*ior_k);\n    }\n    else //Dielectric (Note: R/G/B do not really differ for dielectric materials)\n    {\n        float F0 = pow((1.0 - ior_n.x) / (1.0 + ior_n.x),2.0);\n  \t\tF = vec3(F0 + (1.-F0) * pow( 1. - VdotH, 5.));\n    }\n    \n    //Geometric term (Source: Real Shading in Unreal Engine 4 2013 Siggraph Presentation p.3/59)\n    //k = Schlick model (IBL) : Disney's modification to reduce hotness (point light)\n    float k = bIBL?(roughness*roughness/2.0):(roughness+1.)*(roughness+1.)/8.; \n    float Gl = max(NdotL,0.)/(NdotL*(1.0-k)+k);\n    float Gv = max(NdotV,0.)/(NdotV*(1.0-k)+k);\n    float G = Gl*Gv;\n    \n    float softTr = 0.1; // Valid range : [0.001-0.25]. Transition softness factor, close from dot(L,N) ~= 0\n    float angleLim = 0.;//2.75; // Valid range : [0-0.75]. Compensates for IBL integration suface size.\n    //sinT = 1.;\n    if(bIBL)\n        return (F*G*(angleLim+sinT)/(angleLim+1.0) / (4.*NdotV*saturate(NdotH)*(1.0-softTr)+softTr));\n    else\n        return D*F*G / (4.*NdotV*NdotL*(1.0-softTr)+softTr);\n}\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\nvec3 PBR_HDRCubemap(vec3 sampleDir, float LOD_01)\n{\n    vec3 linearGammaColor_sharp = PBR_HDRremap(pow(texture( iChannel2, sampleDir ).rgb,vec3(2.2)));\n    vec3 linearGammaColor_blur  = PBR_HDRremap(pow(texture( iChannel3, sampleDir ).rgb,vec3(1)));\n    vec3 linearGammaColor = mix(linearGammaColor_sharp,linearGammaColor_blur,saturate(LOD_01));\n    return linearGammaColor;\n}\n\n//Arbitrary axis rotation (around u, normalized)\nmat3 PBR_axisRotationMatrix( vec3 u, float ct, float st ) //u=axis, co=cos(t), st=sin(t)\n{\n    return mat3(  ct+u.x*u.x*(1.-ct),     u.x*u.y*(1.-ct)-u.z*st, u.x*u.z*(1.-ct)+u.y*st,\n\t              u.y*u.x*(1.-ct)+u.z*st, ct+u.y*u.y*(1.-ct),     u.y*u.z*(1.-ct)-u.x*st,\n\t              u.z*u.x*(1.-ct)-u.y*st, u.z*u.y*(1.-ct)+u.x*st, ct+u.z*u.z*(1.-ct) );\n}\n\nvec3 PBR_importanceSampling(vec3 sampleDir, float roughness, float e1, float e2, out float range)\n{\n    const float PI = 3.14159;\n    range = atan( roughness*sqrt(e1)/sqrt(1.0-e1) );\n    float phi = 2.0*PI*e2;\n    //Improve this? https://blog.selfshadow.com/2011/10/17/perp-vectors/\n    vec3 notColinear   = (abs(sampleDir.y)<0.8)?vec3(0,1,0):vec3(1,0,0);\n    vec3 othogonalAxis = normalize(cross(notColinear,sampleDir));\n\tmat3 m1 = PBR_axisRotationMatrix(normalize(othogonalAxis), cos(range), sin(range));\n\tmat3 m2 = PBR_axisRotationMatrix(normalize(sampleDir),     cos(phi),   sin(phi));\n\treturn sampleDir*m1*m2;\n}\n\nvec3 PBR_visitSamples(vec3 V, vec3 N, float roughness, bool metallic, vec3 ior_n, vec3 ior_k )\n{\n    const float MIPMAP_SWITCH  = 0.29; //sampling angle delta (rad) equivalent to the lowest LOD.\n    const ivec2 SAMPLE_COUNT = ivec2(05,15); //(5 random, 15 fixed) samples\n    const vec2 weight = vec2(1./float(SAMPLE_COUNT.x),1./float(SAMPLE_COUNT.y));\n    float angularRange = 0.;    \n    vec3 vCenter = reflect(-V,N);\n    \n    //Randomized Samples : more realistic, but jittery\n    float randomness_range = 0.75; //Cover only the closest 75% of the distribution. Reduces range, but improves stability.\n    float fIdx = 0.0;              //valid range = [0.5-1.0]. Note : it is physically correct at 1.0.\n    vec3 totalRandom = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[0]; ++i)\n    {\n        //Random noise from DaveHoskin's hash without sine : https://www.shadertoy.com/view/4djSRW\n        vec3 p3 = fract(vec3(fIdx*10.0+vCenter.xyx*100.0) * vec3(.1031,.11369,.13787)); \n    \tp3 += dot(p3.zxy, p3.yzx+19.19);\n    \tvec2 jitter = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x*randomness_range, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[0];\n    \ttotalRandom += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    //Fixed Samples : More stable, but can create sampling pattern artifacts (revealing the sampling pattern)\n    fIdx = 0.0;\n    vec3 totalFixed = vec3(0.0);\n    for(int i=0; i < SAMPLE_COUNT[1]; ++i)\n    {\n        vec2 jitter = vec2( clamp(weight[1]*fIdx,0.0,0.50), fract(weight[1]*fIdx*1.25)+3.14*fIdx); //Fixed sampling pattern.\n        vec3 sampleDir    = PBR_importanceSampling(vCenter, roughness, jitter.x, jitter.y, angularRange);\n        vec3 sampleColor  = PBR_HDRCubemap( sampleDir, angularRange/MIPMAP_SWITCH);\n        vec3 contribution = PBR_Equation(V, sampleDir, N, roughness, ior_n, ior_k, metallic, true)*weight[1];\n        totalFixed += contribution*sampleColor;\n\t\t++fIdx;\n    }\n    \n    return (totalRandom*weight[1]+totalFixed*weight[0])/(weight[0]+weight[1]);\n}\n\nvec4 MAT_triplanarTexturing(vec3 p, vec3 n)\n{\n    p = fract(p+0.5);\n    \n    float sw = 0.20; //stiching width\n    vec3 stitchingFade = vec3(1.)-smoothstep(vec3(0.5-sw),vec3(0.5),abs(p-0.5));\n    \n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    vec4 cX = abs(n.x)*texture(iChannel1,p.zy);\n    vec4 cY = abs(n.y)*texture(iChannel1,p.xz);\n    vec4 cZ = abs(n.z)*texture(iChannel1,p.xy);\n    \n    return  vec4(stitchingFade.y*stitchingFade.z*cX.rgb\n                +stitchingFade.x*stitchingFade.z*cY.rgb\n                +stitchingFade.x*stitchingFade.y*cZ.rgb,cX.a+cY.a+cZ.a)/fTotal;\n}\n\nstruct TraceData\n{\n    float rayLen; //Run Distance\n    vec3  rayDir; //Run Direction\n    vec3  normal; //Hit normal\n    int   matID;  //Hit material ID\n};\n\n//The main material function.\nvec3 MAT_apply(vec3 pos, TraceData traceData)\n{\n    //Roughness texture\n    vec4 roughnessBuffer = MAT_triplanarTexturing(pos*1.5,traceData.normal);\n    roughnessBuffer += MAT_triplanarTexturing(pos*1.5+0.75,traceData.normal);\n    float roughness = (roughnessBuffer.x+roughnessBuffer.y+roughnessBuffer.z)/3.0;\n    roughness = roughnessBuffer.w+saturate(roughness-1.00+ROUGHNESS_AMOUNT)*0.25;\n    \n    //IBL and ABL PBR Lighting\n    vec3 rd  = traceData.rayDir;\n    vec3 V = normalize(-traceData.rayDir);\n    vec3 N = traceData.normal;\n    vec3 L = normalize(vec3(1,1,0));\n    vec3 col = PBR_visitSamples(V,N,roughness, true, F_ALU_N, F_ALU_K);\n    vec3 L0  = PBR_Equation(V,L,N,roughness+0.01, F_ALU_N, F_ALU_K, true, false);\n    col     += PBR_HDRremap(vec3(1))*L0*ABL_LIGHT_CONTRIBUTION;\n    \n    //Anti-aliasing trick (normal-based)\n    vec3 backgroundColor = pow(texture( iChannel2, traceData.rayDir ).xyz,vec3(2.2));\n    float aaAmount = 0.095;\n    float smoothFactor = 1.0-clamp(-dot(N,traceData.rayDir)/(aaAmount), 0.0, 1.0);\n    col = (dot(N,-traceData.rayDir)<aaAmount)? mix(col, backgroundColor, smoothFactor) : col;\n    \n    return traceData.matID==MATERIALID_SKY?backgroundColor:col;\n}\n\nfloat map( in vec3 pos )\n{\n    const float GEO_SPHERE_RAD = 0.5;\n    return length(pos)-GEO_SPHERE_RAD;\n}\n\n//o=ray origin, d=ray direction\nTraceData TRACE_geometry(vec3 o, vec3 d)\n{\n    float t = 0.0;\n    float tmax = GEO_MAX_DIST;\n    float dist = GEO_MAX_DIST;\n    for( int i=0; i<50; i++ )\n    {\n\t    dist = map( o+d*t );\n        if( abs(dist)<0.001 || t>GEO_MAX_DIST ) break;\n        t += dist;\n    }\n    \n    vec3 dfHitPosition  = o+t*d;\n    bool bBackground = (dist>0.01 || t>GEO_MAX_DIST);\n    \n    return TraceData(t,d,normalize(dfHitPosition),bBackground?MATERIALID_SKY:MATERIALID_SPHERE);\n}\n\nvec4 processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel0,vec2(0,0));\n\tROUGHNESS_AMOUNT        = sliderVal[1];\n    SKY_COLOR               = sliderVal[2];\n    ABL_LIGHT_CONTRIBUTION  = sliderVal[3];\n    \n    if(length(fragCoord.xy-vec2(0,0))>1.)\n    {\n    \treturn texture(iChannel0,fragCoord.xy/iResolution.xy);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Camera & setup\n    vec4 cSlider = processSliders(fragCoord);\n    float rotX = ((iMouse.z>0.)&&any(lessThan(iMouse.xy/iResolution.xy,vec2(0.9,0.80))))?\n\t             ((iMouse.x/iResolution.x)*2.0*3.14) : (iTime*0.3);\n    vec2 uv = 2.5*(fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n    vec3 camO = vec3(cos(rotX),0.4,sin(rotX))*0.95;\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD,vec3(0,1,0)));\n    vec3 camU = cross(camR,camD);\n   \tvec3 dir =  normalize(uv.x*camR+uv.y*camU+camD);\n    \n    //Raytrace\n    TraceData geometryTraceData = TRACE_geometry(camO, dir);\n    vec3 ptGeo = (geometryTraceData.rayLen < GEO_MAX_DIST)? camO+dir*geometryTraceData.rayLen : vec3(0);\n    \n    //Material\n    vec3 c = MAT_apply(ptGeo,geometryTraceData).xyz;\n    \n    //Post-processing\n    float sin2 = dot(uv/1.6,uv/1.6);\n    float vignetting = pow(1.0-min(sin2*sin2,1.0),2.);\n    c = pow(c*vignetting,vec3(0.4545)); //2.2 Gamma compensation\n    \n    //Slider overlay\n    fragColor = vec4(mix(c,cSlider.rgb,cSlider.a),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 2,
                        "ctype": "cubemap",
                        "id": 22,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg"
                    },
                    {
                        "channel": 3,
                        "ctype": "cubemap",
                        "id": 23,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Buffer A : Sliders\n//\n// Author : SÃ©bastien BÃ©rubÃ©\n// Created : Dec 2015\n// Modified : Mar 2016\n#define saturate(x) clamp(x,0.0,1.0)\nvec4 sliderVal = vec4(0.30,0.75,0.0,0.10); //Default slider values [0-1]\n\nvoid SLIDER_setValue(float idx, float val)\n{\n    if(idx<0.) return;\n    else if(idx<0.25) sliderVal[0] = saturate(val);\n\telse if(idx<0.50) sliderVal[1] = saturate(val);\n\telse if(idx<0.75) sliderVal[2] = saturate(val);\n\telse if(idx<1.00) sliderVal[3] = saturate(val);\n}\n\nfloat SLIDER_getValue(float idx)\n{\n    if     (idx<0.25) return sliderVal[0];\n    else if(idx<0.50) return sliderVal[1];\n    else if(idx<0.75) return sliderVal[2];\n    else if(idx<1.00) return sliderVal[3];\n\telse return 0.;\n}\n\nvoid SLIDER_init(vec2 mousePos, vec2 cMin, vec2 cMax )\n{\n    vec4 cPingPong = texture(iChannel0,vec2(0));\n    if(length(cPingPong)>0.001)\n        sliderVal = cPingPong;\n        \n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    if(mousePos.x>cMin.x && mousePos.x<cMax.x &&\n       mousePos.y>cMin.y && mousePos.y<cMax.y )\n    {\n        float t = (mousePos.y-cMin.y)/height;\n        t = clamp(t/0.75-0.125,0.,1.); //25% top/bottom margins\n\t\tSLIDER_setValue((mousePos.x-cMin.x)/width, t);\n    }\n}\n\n//Returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\", and length(p-e) is dist.\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\n//uv = slider pixel in local space [0-1], t = slider value [0-1], ar = aspect ratio (w/h)\nvec4 SLIDER_drawSingle(vec2 uv, float t, vec2 ar, bool bHighlighted)\n{\n    const vec3  ITEM_COLOR = vec3(1);\n    const vec3  HIGHLIGHT_COLOR = vec3(0.2,0.7,0.8);\n    const float RAD = 0.05;  //Cursor radius, in local space\n    const float LW  = 0.030; //Line width\n    float aa  = 14./iResolution.x; //antialiasing width (smooth transition)\n    vec3 selectionColor = bHighlighted?HIGHLIGHT_COLOR:ITEM_COLOR;\n    vec3 cheapGloss   = 0.8*selectionColor+0.2*smoothstep(-aa,aa,uv.y-t-0.01+0.01*sin(uv.x*12.));\n    vec2 bottomCenter = vec2(0.5,0.0);\n\tvec2 topCenter    = vec2(0.5,1.0);\n    vec2 cursorPos    = vec2(0.5,t);\n    float distBar = UTIL_distanceToLineSeg(uv*ar, bottomCenter*ar, topCenter*ar);\n    float distCur = length((uv-cursorPos)*ar)-RAD;\n    float alphaBar = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distBar);\n    float alphaCur = 1.0-smoothstep(2.0*LW-aa,2.0*LW+aa, distCur);\n    vec4  colorBar = vec4(mix(   vec3(1),vec3(0),smoothstep(LW-aa,LW+aa, distBar)),alphaBar);\n    vec4  colorCur = vec4(mix(cheapGloss,vec3(0),smoothstep(LW-aa,LW+aa, distCur)),alphaCur);\n    return mix(colorBar,colorCur,colorCur.a);\n}\n\n#define withinUnitRect(a) (a.x>=0. && a.x<=1. && a.y>=0. && a.y<=1.0)\nvec4 SLIDER_drawAll(vec2 uv, vec2 cMin, vec2 cMax, vec2 muv)\n{\n    float width = cMax.x-cMin.x;\n    float height = cMax.y-cMin.y;\n    vec2 ar = vec2(0.30,1.0);\n    uv  = (uv -cMin)/vec2(width,height); //pixel Normalization\n    muv = (muv-cMin)/vec2(width,height); //mouse Normalization\n    if( withinUnitRect(uv) )\n    {\n        float t = SLIDER_getValue(uv.x);\n\t\tbool bHighlight = withinUnitRect(muv) && abs(floor(uv.x*4.0)-floor(muv.x*4.0))<0.01;\n\t\tuv.x = fract(uv.x*4.0); //repeat 4x\n\t\tuv.y = uv.y/0.75-0.125; //25% margins\n        return SLIDER_drawSingle(uv,t,ar,bHighlight);\n    }\n    return vec4(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cMinSliders = vec2(0.9,0.80);\n    vec2 cMaxSliders = vec2(1.0,1.00);\n    vec2 uvSliders = fragCoord.xy / iResolution.xy;\n    vec2 mousePos = iMouse.xy / iResolution.xy;\n    SLIDER_init(mousePos, cMinSliders, cMaxSliders);\n    vec4 cSlider = SLIDER_drawAll(uvSliders,cMinSliders, cMaxSliders, mousePos);\n    \n    if(length(fragCoord.xy-vec2(0,0))<1.) \n        fragColor = sliderVal;\n\telse fragColor = cSlider;\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Buffer B : Material Roughness map\n//\n// Author : SÃ©bastien BÃ©rubÃ©\n//\n// This is just noise, you could implement whatever roughness map you want.\n// This needs some clean-up, as it was originally coded as 3D noise, but only a 2D slice is used here.\n\n#define saturate(x) clamp(x,0.0,1.0)\nfloat UTIL_distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    //Scalar projection of ap in the ab direction = dot(ap,ab)/|ab| : Amount of ap aligned towards ab\n    //Divided by |ab| again, it becomes normalized along ab length : dot(ap,ab)/(|ab||ab|) = dot(ap,ab)/dot(ab,ab)\n    //The clamp provides the line seg limits. e is therefore the \"capped orthogogal projection\".\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\nvec2 noise(vec2 p)\n{\n    return texture(iChannel1,p,-100.0).xy;\n}\nstruct repeatInfo\n{\n\tvec2 pRepeated;\n    vec2 anchor;\n};\nrepeatInfo UTIL_repeat(vec2 p, float interval)\n{\n    repeatInfo rInfo;\n    rInfo.pRepeated = p / interval; //Normalize\n    rInfo.pRepeated = fract(rInfo.pRepeated+0.5)-0.5; //centered fract\n    rInfo.pRepeated *= interval; //Rescale\n    rInfo.anchor = p-rInfo.pRepeated;\n    return rInfo;\n}\nfloat MAT_scratchTexture(vec2 p)\n{\n    const float squareWidth = 0.10*2.0;\n    const float moveAmp   = squareWidth*0.75;\n    const float lineWidth = 0.0005;\n    float repeatInterval = squareWidth+moveAmp;\n    repeatInfo rInfo = UTIL_repeat(p,repeatInterval);\n    float margin = repeatInterval-squareWidth;\n    \n    vec2 a = moveAmp*noise(rInfo.anchor);\n    vec2 b = -moveAmp*noise(rInfo.anchor+10.0);\n    float dseg = 1000.0*UTIL_distanceToLineSeg(rInfo.pRepeated, a, b)/squareWidth;\n    return saturate(10.0/dseg-0.5)*0.25;\n}\n\nfloat MAT_layeredScratches(vec2 p)\n{\n    const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n    float I = MAT_scratchTexture(p);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.11+2.0);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.24+3.8);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n    p = m2*p;\n    I += MAT_scratchTexture(p*1.34+5.3);\n        \n    return I;\n}\n\nfloat MAT_triplanarScratches(vec3 p, vec3 n)\n{\n    //Idea from http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\n    //Figure 1-23 Triplanar Texturing\n    float fTotal = abs(n.x)+abs(n.y)+abs(n.z);\n    return ( abs(n.x)*MAT_layeredScratches(p.zy)\n            +abs(n.y)*MAT_layeredScratches(p.xz)\n            +abs(n.z)*MAT_layeredScratches(p.xy))/fTotal;\n}\n\nvec4 NOISE_trilinearWithDerivative(vec3 p)\n{\n    //Trilinear extension over noise derivative from (Elevated), & using the noise stacking trick from (Clouds).\n\t//Inspiration & Idea from :\n    //https://www.shadertoy.com/view/MdX3Rr (Elevated)\n    //https://www.shadertoy.com/view/XslGRr (Clouds)\n    \n    //For more information, see also:\n    //NoiseVolumeExplained : https://www.shadertoy.com/view/XsyGWz\n\t//2DSignalDerivativeViewer : https://www.shadertoy.com/view/ldGGDR\n    \n    const float TEXTURE_RES = 256.0; //Noise texture resolution\n    vec3 pixCoord = floor(p);//Pixel coord, integer [0,1,2,3...256...]\n    //noise volume stacking trick : g layer = r layer shifted by (37x17 pixels)\n    //(37x17)-> this value is the actual translation embedded in the noise texture, can't get around it.\n\t//Note : shift is different from g to b layer (but it also works)\n    vec2 layer_translation = -pixCoord.z*vec2(37.0,17.0)/TEXTURE_RES; \n    \n    vec2 c1 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,0)+0.5)/TEXTURE_RES,-100.0).rg;\n    vec2 c2 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,0)+0.5)/TEXTURE_RES,-100.0).rg; //+x\n    vec2 c3 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(0,1)+0.5)/TEXTURE_RES,-100.0).rg; //+z\n    vec2 c4 = texture(iChannel2,layer_translation+(pixCoord.xy+vec2(1,1)+0.5)/TEXTURE_RES,-100.0).rg; //+x+z\n    \n    vec3 x = p-pixCoord; //Pixel interpolation position, linear range [0-1] (fractional part)\n    \n    vec3 x2 = x*x;\n    vec3 t = (6.*x2-15.0*x+10.)*x*x2; //Quintic ease-in/ease-out function.\n    vec3 d_xyz = (30.*x2-60.*x+30.)*x2; //dt/dx : Ease-in ease-out derivative.\n    \n    //Lower quad corners\n    float a = c1.x; //(x+0,y+0,z+0)\n    float b = c2.x; //(x+1,y+0,z+0)\n    float c = c3.x; //(x+0,y+1,z+0)\n    float d = c4.x; //(x+1,y+1,z+0)\n    \n    //Upper quad corners\n    float e = c1.y; //(x+0,y+0,z+1)\n    float f = c2.y; //(x+1,y+0,z+1)\n    float g = c3.y; //(x+0,y+1,z+1)\n    float h = c4.y; //(x+1,y+1,z+1)\n    \n    //Trilinear noise interpolation : (1-t)*v1+(t)*v2, repeated along the 3 axis of the interpolation cube.\n    float za = ((a+(b-a)*t.x)*(1.-t.y)\n               +(c+(d-c)*t.x)*(   t.y));\n    float zb = ((e+(f-e)*t.x)*(1.-t.y)\n               +(g+(h-g)*t.x)*(   t.y));\n    float value = (1.-t.z)*za+t.z*zb;\n    \n    //Derivative scaling (texture lookup slope, along interpolation cross sections).\n    //This could be factorized/optimized but I fear it would make it cryptic.\n    float sx =  ((b-a)+t.y*(a-b-c+d))*(1.-t.z)\n               +((f-e)+t.y*(e-f-g+h))*(   t.z);\n    float sy =  ((c-a)+t.x*(a-b-c+d))*(1.-t.z)\n               +((g-e)+t.x*(e-f-g+h))*(   t.z);\n    float sz =  zb-za;\n    \n    return vec4(value,d_xyz*vec3(sx,sy,sz));\n}\n\nfloat ROUGHNESS_MAP_UV_SCALE = 6.00;//Valid range : [0.1-100.0]\n\n//Stacked perlin noise\nvec3 NOISE_volumetricRoughnessMap(vec3 p, float rayLen)\n{\n    vec4 sliderVal = vec4(0.5,0.85,0,0.5);\n    ROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);\n    \n    float f = iTime;\n    const mat3 R1  = mat3(0.500, 0.000, -.866,\n\t                     0.000, 1.000, 0.000,\n                          .866, 0.000, 0.500);\n    const mat3 R2  = mat3(1.000, 0.000, 0.000,\n\t                      0.000, 0.500, -.866,\n                          0.000,  .866, 0.500);\n    const mat3 R = R1*R2;\n    p *= ROUGHNESS_MAP_UV_SCALE;\n    p = R1*p;\n    vec4 v1 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021;\n    vec4 v2 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+1.204*v1.xyz;\n    vec4 v3 = NOISE_trilinearWithDerivative(p);\n    p = R1*p*2.021+0.704*v2.xyz;\n    vec4 v4 = NOISE_trilinearWithDerivative(p);\n    \n    return (v1\n\t      +0.5*(v2+0.25)\n\t      +0.4*(v3+0.25)\n\t      +0.6*(v4+0.25)).yzw;\n}\n\nvoid processSliders(in vec2 fragCoord)\n{\n    vec4 sliderVal = texture(iChannel0,vec2(0,0));\n\tROUGHNESS_MAP_UV_SCALE *= 0.1*pow(10.,2.0*sliderVal[0]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    processSliders(fragCoord);\n    vec2 uv = 3.0*fragCoord.xy/iResolution.xy;\n    vec3 roughnessNoise = NOISE_volumetricRoughnessMap(vec3(2.0*uv,0),1.0).rgb;\n    float scratchTex = MAT_scratchTexture(2.0*uv);\n    scratchTex += MAT_layeredScratches(uv+0.25);\n    scratchTex += MAT_layeredScratches(1.7*uv+vec2(0.35));\n    scratchTex += MAT_scratchTexture(uv+vec2(1.15));\n    scratchTex += MAT_scratchTexture(uv+vec2(2.75));\n    fragColor = vec4(roughnessNoise,scratchTex*0.3);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 16,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}