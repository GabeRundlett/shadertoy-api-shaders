{
    "Shader": {
        "info": {
            "date": "1605720479",
            "description": "An artistic Water shader, the perlin noise function is not written by me.",
            "flags": 0,
            "hasliked": 0,
            "id": "tdcBRf",
            "likes": 11,
            "name": "Artistic Water Foam",
            "published": 3,
            "tags": [
                "water",
                "artistic"
            ],
            "usePreview": 0,
            "username": "Daizuukee",
            "viewed": 468
        },
        "renderpass": [
            {
                "code": "float random (vec2 st) {\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 point (vec2 st) {\n  return vec2(random(st),random(st.yx)) / 2. + 0.5;\n}\n\nfloat dist (vec2 a, vec2 b) {\n  return sqrt(pow(a.x - b.x,2.) + pow(a.y - b.y,2.));\n}\n\nvec4 voronoi(vec2 p, float roundness, out vec2 smallestp) {\n  \n  int C = 2;\n  \n  float offset = 1.5;\n  \n  vec2 closest;\n  float mindist = float(C*C);\n  float secondmin = mindist;\n  vec2 secclosest;\n  \n  \n  for(int x = -C; x <= C; x++)\n    for(int y = -C; y <= C; y++) {\n      vec2 vp = point(floor(p) + vec2(x,y)) * offset;\n      float d = dist(vp + floor(p) + vec2(x,y),p);\n      \n      float size = pow(random(vp) / 4. + 0.5,roundness);\n      float comp = d * size;\n      \n      if(mindist > comp) {\n        secclosest = closest;\n        secondmin = mindist;\n        \n        closest = vp + vec2(x+y);\n        smallestp = floor(p) + vec2(x, y);\n        mindist = comp;\n      }\n      else if(secondmin > comp) {\n        secclosest = vp + vec2(x+y);\n        secondmin = comp;\n      }\n    }\n    \n  return vec4(fract(closest.x),fract(closest.y),mindist,(secondmin - mindist));\n}\n\nvec4 voronoi (vec2 p, float roundness) {\n  vec2 temp;\n  return voronoi(p,roundness,temp);\n}\n\n\n\n//\n\nvec3 permute( vec3 x){\n  return mod(((x*34.0) +1.0)*x,  289.0) ;\n}\nvec3 taylorInvSqrt (vec3 r){\n  return  1.79284291400159-0.85373472095314*r;\n  }\nfloat snoise(vec2 P){\n  const vec2 C = vec2 (0.211324865405187134,  // (3.0-sqrt ( 3 . 0 ) ) / 6 . 0 ;\n  0.366025403784438597) ;  //  0.5*( sqrt ( 3 . 0 )-1.0) ;\n  //  First  corner\n  vec2 i = floor(P+ dot (P,C.yy)  ) ;\n  vec2 x0=P-i+ dot (i,C.xx) ;// Other  corners\n  vec2 i1;\n  i1.x = step (x0.y,x0.x) ;  //  1.0 if(x0.x > x0.y ,  e l s e  0.0\n  i1.y = 1.0-i1.x;\n  // x1 = x0-i1 + 1.0*C. xx ;  x2 = x0-1.0 + 2.0*C. xx ;\n  vec4 x12 = x0.xyxy + vec4 (C.xx,C.xx*2.0-1.0) ;x12.xy-=i1;//  Permutations\n  i = mod(i,  289.0);  // Avoid  truncation  in  polynomial  evaluation\n  vec3 p = permute(permute(i.y+ vec3 (0.0 ,i1.y,  1.0  ) )+i.x+ vec3 (0.0 ,i1.x,  1.0  ) ) ;//  Circularly  symmetric  blending  kernel\n  vec3 m = max(0.5-vec3 ( dot (x0,x0) ,  dot (x12.xy,x12.xy) ,dot (x12.zw,x12.zw) ) ,  0.0) ;m=m*m;m=m*m;//  Gradients  from 41  points  on a  line ,  mapped onto a diamond\n  vec3 x= fract(p*(1.0  /  41.0) )*2.0-1.0  ;vec3 gy= abs (x)-0.5  ;vec3 ox= floor(x+ 0.5) ;  // round (x)  i s  a GLSL 1.30  feature\n  vec3 gx = x-ox;//  Normalise  gradients  i m p l i c i t l y  by  s c a l i n g m\n  m *= taylorInvSqrt(gx*gx+gy*gy) ;// Compute  f i n a l  noise  value  at P\n  vec3 g;g.x=gx.x*x0.x+gy.x*x0.y;g.yz=gx.yz*x12.xz+gy.yz*x12.yw;//  Scale  output  to  span  range  [-1 ,1]//  ( s c a l i n g  f a c t o r  determined by  experiments )\n  return  130.0*dot (m,g) ;\n}\n\n\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  float size = 12.;\n  uv *= size;\n  uv += iTime * vec2(1,0) + vec2(cos(iTime) * 0.2,0);\n  float PixelSize = 0.08;\n  //uv = floor(uv / PixelSize) * PixelSize;\n  \n  vec2 pos = vec2(0);\n  vec4 v = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.)) * 0.25),-4. + sin(iTime * 0.5) * 0.5,pos);\n  if(v.a < 0.3) {\n    out_color = vec4(1);\n  }\n  else {\n    vec4 waterv = vec4(0.5);\n    int iterations = 4;\n    for(int i = 0; i < iterations; i++) {\n    waterv += (random(voronoi(uv + random(vec2(i,float(i) + 0.9)) * pow(4.,float(i)), -2.).xy) - 0.5) * (float(iterations-i)/(float(iterations)/30.));\n    }\n    float depth = pow(floor((pos.y + 10. * size) / (size / 0.2)) / 8.,0.3) * pow(floor((-pos.y + 5. * size) / (0.4 * size)) / 12.,10.);\n    float noise = (snoise(uv / 10.) + 1.) + 0.5;\n    out_color = vec4(0.1,0.4,0.9,1) * pow(v.a,0.4) / 8. * pow(point(waterv.xy).y,0.4) * depth * noise * 4.;\n    \n    vec4 nv = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.) + 900.) * 0.25 + 0.4),-4.  + sin(iTime * 0.5) * 0.5,pos);\n    if(nv.a < 0.3) {\n      out_color *= 0.5;\n    }\n  }\n    vec2 position;\n    vec4 lastv = voronoi(uv*20.,20.,position);\n    out_color *= vec4(1.-random(position.xy)/8.);\n\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}