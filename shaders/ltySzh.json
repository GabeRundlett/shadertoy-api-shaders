{
    "Shader": {
        "info": {
            "date": "1482931613",
            "description": "how many shaders have you seen, where the camera is floating around aimlessly while traversing a fractal?\nit's my pleasure to present to you a 3d scene that gives the camera a very good reason to move!\n\nany tips on improving fps are more than welcome :D",
            "flags": 0,
            "hasliked": 0,
            "id": "ltySzh",
            "likes": 32,
            "name": "Menger Factory Meltdown",
            "published": 3,
            "tags": [
                "fractal",
                "menger",
                "steel",
                "melting",
                "factory"
            ],
            "usePreview": 0,
            "username": "s23b",
            "viewed": 1589
        },
        "renderpass": [
            {
                "code": "#define SPEED .1\n#define FOV 1.5\n\n#define MAX_STEPS 100\n#define SHADOW_STEPS 100\n#define SHADOW_SOFTNESS 10.\n#define EPS .0001\n#define RENDER_DIST 5.\n#define AO_SAMPLES 5.\n#define AO_RANGE 10.\n#define LIGHT_COLOR vec3(1.,.5,.3)\n\n#define PI 3.14159265359\n#define saturate(x) clamp(x, 0., 1.)\n\nvec3 _ballPos = vec3(0);\nfloat _ballSize = .5;\n\n// simple hash function\nfloat hash(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.009123898, .00231233, .00532234))) * 111111.5452313);\n    return f;\n}\n\n// 3d noise function (linear interpolation between hash of integer bounds)\nfloat noise(vec3 uv) {\n    vec3 fuv = floor(uv);\n    vec4 cell0 = vec4(\n        hash(fuv + vec3(0, 0, 0)),\n        hash(fuv + vec3(0, 1, 0)),\n        hash(fuv + vec3(1, 0, 0)),\n        hash(fuv + vec3(1, 1, 0))\n    );\n    vec2 axis0 = mix(cell0.xz, cell0.yw, fract(uv.y));\n    float val0 = mix(axis0.x, axis0.y, fract(uv.x));\n    vec4 cell1 = vec4(\n        hash(fuv + vec3(0, 0, 1)),\n        hash(fuv + vec3(0, 1, 1)),\n        hash(fuv + vec3(1, 0, 1)),\n        hash(fuv + vec3(1, 1, 1))\n    );\n    vec2 axis1 = mix(cell1.xz, cell1.yw, fract(uv.y));\n    float val1 = mix(axis1.x, axis1.y, fract(uv.x));\n    return mix(val0, val1, fract(uv.z));\n}\n\n// fractional brownian motion\nfloat fbm(vec3 uv) {\n    float f = 0.;\n    float r = 1.;\n    for (int i = 0; i < 3; ++i) {\n        f += noise((uv + 10.) * r) / (r *= 2.);\n    }\n    return f / (1. - 1. / r);\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// repeat 3d space\nvec3 tRepeat3(inout vec3 p, vec3 r) {\n    vec3 id = floor((p + r * .5) / r);\n    p = mod(p + r * .5, r) - r * .5;\n    return id;\n}\n\n// sphere distance\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// 3d cross distance\nfloat sdCross(vec3 p, vec3 r) {\n    p =abs(p) - r;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    p.yz = p.y < p.z ? p.yz : p.zy;\n    p.xy = p.x < p.y ? p.xy : p.yx;\n    return length(min(p.yz, 0.)) - max(p.y, 0.);\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\n// distance estimation of the scene without the ball (for shadow calculation)\nfloat scene(vec3 p) {\n    float size = 1.;\n    float d = -2.;\n    \n    for (int i = 0; i < 5; ++i) {\n        \n        // scale and repeat the cross SDF, then intersect with the calculated distance\n        size *= 3.;\n        vec3 q = p * size;\n        tRepeat3(q, vec3(3));\n    \td = opI(d, sdCross(q, vec3(.5)) / size);\n    }\n    \n    // add the floor\n    d = opU(d, p.y + .169);\n    return d;\n}\n\n// distance estimation of everything together\nfloat map(vec3 p) {\n    return opSU(scene(p), sdSphere(p - _ballPos, _ballSize), .15);\n}\n\n// trace the scene from ro (origin) to rd (direction, normalized)\n// until hit or reached maxDist, outputs distance traveled and the number of steps\nfloat trace(vec3 ro, vec3 rd, float maxDist, out float steps) {\n    float total = 0.;\n    steps = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i) {\n        ++steps;\n        float d = map(ro + rd * total);\n        total += d;\n        if (d < EPS || maxDist < total) break;\n    }\n    \n    return total;\n}\n\n// get the soft shadow value\nfloat softShadow(vec3 ro, vec3 rd, float maxDist) {\n    float total = 0.;\n    float s = 1.;\n    \n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        float d = scene(ro + rd * total);\n        if (d < EPS) {\n            s = 0.;\n            break;\n        }\n        if (maxDist < total) break;\n        s = min(s, SHADOW_SOFTNESS * d / total);\n        total += d;\n    }\n    \n    return s;\n}\n\n// calculate the normal vector\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0001, 0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n\t));\n}\n\n// ambient occlusion\nfloat calculateAO(vec3 p, vec3 n) {\n    \n    float r = 0., w = 1., d;\n    \n    for (float i = 1.; i <= AO_SAMPLES; i++){\n        d = i / AO_SAMPLES / AO_RANGE;\n        r += w * (d - scene(p + n * d));\n        w *= .5;\n    }\n    \n    return 1.-saturate(r * AO_RANGE);\n}\n\n// texture function\nvec3 _texture(vec3 p) {\n    vec3 t = fbm((p*50.)) * vec3(.9, .7, .5) * .75\n        + smoothstep(.4, .9, fbm((p*10. + 2.))) * vec3(1., .4, .3)\n        - smoothstep(.5, .9, fbm((p*100. + 4.))) * vec3(.4, .3, .2);\n    return saturate(t);\n}\n\n// the glow of the melting metal\nvec3 glow(vec3 p) {\n    return pow(smoothstep(_ballSize * 1.8,_ballSize, distance(p, _ballPos)), 5.) * LIGHT_COLOR * 3.;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat pausingWave(float x, float a, float b) { //    ___          ___          ___\n    x = abs(fract(x) - .5) * 1. - .5 + a;      //   /   \\        /   \\        /   \\ \n    return smoothstep(0., a - b, x);           // --     --------     --------     ------\n}\t\t\t\t\t\t\t\t\t\t\t   // basically like this :P\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // transform screen coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // transform mouse coordinates\n\tvec2 mouse = iMouse.xy / iResolution.xy * 2. - 1.;\n    mouse.x *= iResolution.x / iResolution.y;\n    mouse *= 2.;\n    \n    float time = iTime * SPEED + .5;\n    \n    // the frequency of the steps\n    float jump = time * 80.;\n    \n    // set the position of that menacing ball of melting steel\n    _ballPos = vec3(0, -.15, time);\n    _ballPos.xy+= (noise(_ballPos * 20.) - .5) * .1;\n    \n    // the camera is trying to escape its impending doom\n    vec3 ro =  vec3(0, abs(sin(jump)) * .01 - .07, .75 + _ballPos.z);\n    vec3 rd = normalize(vec3(uv, FOV));\n    \n    // the scene is illuminated by the melting blob\n    vec3 light = _ballPos;\n    \n    if (iMouse.z > 0.) {\n        // rotate the scene using the mouse\n        mouse.y = max(mouse.y, -.5); // limit the view vertically, so you don't realize that I was too lazy to render a running human\n        tRotate(rd.yz, -mouse.y);\n        tRotate(rd.xz, -mouse.x);\n    } else {\n        // or face down / forward\n        tRotate(rd.xy, sin(jump) * .002);\n        tRotate(rd.yz, .2);\n        tRotate(rd.xz, sin(jump) * .02);\n        \n        // occasionally look up to the skies, beg the gods for mercy\n        tRotate(rd.yz, -pausingWave(time * .25 - .005, .04, .01) * 1.5);\n        \n        // pick a random direction\n        float dir = sign(hash(vec3(0, 0, floor(time - .5))) - .5);\n        \n        // periodically look in that direction\n        tRotate(rd.xz, dir * pausingWave(time, .15, .1) * 2.5);\n    }\n    \n    // add a camera shake for over-the-top dramatic effect\n    ro += noise(ro * 10000.) / 300.;\n    \n    // march\n    float steps, dist = trace(ro, rd, RENDER_DIST, steps); \n    \n    // calculate hit point coordinates\n    vec3 p = ro + rd * dist;\n    \n    // calculate normal\n    vec3 normal = getNormal(p);\n    \n    // light direction\n    vec3 l = normalize(light - p);\n    \n    // calculate shadow\n    vec3 shadowStart = p + normal * EPS * 10.;\n    float shadowDistance = distance(shadowStart,light) - _ballSize * .5;\n    float shadow = softShadow(shadowStart, l, shadowDistance);\n    \n    // ambient light\n    float ambient = .25;\n    \n    // diffuse light\n    float diffuse = max(0., dot(l, normal));\n    \n    // specular light\n    float specular = pow(max(0., dot(reflect(-l, normal), -rd)), 8.);\n    \n    // \"ambient occlusion\"\n    float ao = calculateAO(p, normal);\n    \n    // add this all up\n\tfragColor.rgb = (ao * _texture(p)) * (ambient * (2. - LIGHT_COLOR) * .5 + (specular + diffuse) * shadow * LIGHT_COLOR) + glow(p);\n    \n    // edge glow\n    fragColor *= .3 + sqrt(steps / float(MAX_STEPS)) * .7;\n    \n    // fog\n    fragColor = mix(fragColor, vec4((1. - LIGHT_COLOR) * .02, 1.), saturate(dist * dist * .05));\n    \n    // gamma correction\n    fragColor = pow(fragColor, vec4(1. / 2.2));\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}