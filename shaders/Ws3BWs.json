{
    "Shader": {
        "info": {
            "date": "1606383072",
            "description": "lic edge flow referenced by Jan Eric Kyprianidis <www.kyprianidis.com>\n",
            "flags": 32,
            "hasliked": 0,
            "id": "Ws3BWs",
            "likes": 5,
            "name": "line integral convolution edge",
            "published": 3,
            "tags": [
                "edgedetection",
                "lic",
                "stylization"
            ],
            "usePreview": 0,
            "username": "between",
            "viewed": 595
        },
        "renderpass": [
            {
                "code": "// line integral convolution\n// this sigma controls the line length\nfloat sigma = 2.0;\n\nstruct lic_t {\n    vec2 p;\n    vec2 t;\n    float w;\n    float dw;\n};\n\nvoid step(inout lic_t s) {\n    vec2 imageSize = iResolution.xy;\n    vec2 t = texture(iChannel0, s.p).xy;\n    if (dot(t, s.t) < 0.0) t = -t;\n    s.t = t;\n    s.dw = (abs(t.x) > abs(t.y)) ? abs((fract(s.p.x) - 0.5 - sign(t.x)) / t.x)\n                                 : abs((fract(s.p.y) - 0.5 - sign(t.y)) / t.y);\n    s.p += t * s.dw / imageSize;\n    s.w += s.dw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 imageSize = iResolution.xy;\n    float twoSigma2 = 2.0 * sigma * sigma;\n    float halfWidth = 2.0 * sigma;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 c = texture(iChannel1, uv).xyz;\n    float w = 1.0;\n    \n    lic_t a;\n    lic_t b;\n    a.p = b.p = uv;\n    a.t = texture(iChannel0, uv).xy;\n    b.t = -a.t;\n    a.w = b.w = 0.0;\n\n    for (int i = 0; i < 20; i++) {\n        if (a.w < halfWidth) {\n            step(a);\n            float k = a.dw * exp(-a.w * a.w / twoSigma2);\n            c += k * texture(iChannel1, a.p).xyz;\n            w += k;\n        } else {\n            break;\n        }\n    }\n\n    for (int i = 0; i < 20; i++) {\n        if (b.w < halfWidth) {\n            step(b);\n            float k = b.dw * exp(-b.w * b.w / twoSigma2);\n            c += k * texture(iChannel1, b.p).xyz;\n            w += k;\n        } else {\n            break;\n        }\n    }\n\n    fragColor = vec4(clamp(vec3(0.0), vec3(1.0), vec3(1.0) - c / w), 1.0);\n    // or you can change the iChannel1 into a noise map to see the field, the recommend is RGBA Noise Medium\n    // and enlarge the sigma to get a obverious result\n    //fragColor = vec4(clamp(vec3(0.0), vec3(1.0), c / w), 1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 259,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer02.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 260,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer03.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// sst\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 d = vec2(1.0)/iResolution.xy;\n    \n    vec3 u = (\n        -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz +\n        -2.0 * texture(iChannel0, uv + vec2(-d.x,  0.0)).xyz + \n        -1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n        +1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n        +2.0 * texture(iChannel0, uv + vec2( d.x,  0.0)).xyz + \n        +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n        ) / 4.0;\n    vec3 v = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz + \n           -2.0 * texture(iChannel0, uv + vec2( 0.0, -d.y)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( 0.0,  d.y)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    fragColor = vec4(dot(u, u), dot(v, v), dot(u, v), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 5,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// gaussian blur(3x3)\n#define POS(x, y) \\\n    texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 c = ( 1.0 * POS(-1.0, -1.0) +\n               4.0 * POS( 0.0, -1.0) +\n               1.0 * POS( 1.0, -1.0) +\n               4.0 * POS(-1.0,  0.0) +\n              16.0 * POS( 0.0,  0.0) +\n               4.0 * POS( 1.0,  0.0) +\n               1.0 * POS(-1.0,  1.0) +\n               4.0 * POS( 0.0,  1.0) +\n               1.0 * POS( 1.0,  1.0)\n             ) / 36.0;\n    \n    fragColor = vec4(c, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// calculate tangent flow map\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord/iResolution.xy;\n     vec3 g = texture(iChannel0, uv).xyz;\n     float lambda1 = 0.5 * (g.y + g.x + sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n     float lambda2 = 0.5 * (g.y + g.x - sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n     vec2 v = vec2(lambda1 - g.x, -g.z);\n     vec2 t;\n     if (length(v) > 0.0) { \n         t = normalize(v);\n     } else {\n         t = vec2(0.0, 1.0);\n     }\n \n     float phi = atan(t.y, t.x);\n     float A = (lambda1 + lambda2 > 0.0)?(lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n     fragColor = vec4(t, 0.0, 0.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer C",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 259
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// sobel edge detection\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \t\n\tfragColor = texture(iChannel0, uv);\n\n    vec4 a = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y+1.0/iResolution.y));\n    vec4 b = texture(iChannel0, vec2(uv.x,      uv.y+1.0/iResolution.y));\n    vec4 c = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y+1.0/iResolution.y));\n    vec4 d = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y));\n    vec4 e = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y));\n    vec4 f = texture(iChannel0, vec2(uv.x-1.0/iResolution.x, uv.y-1.0/iResolution.y));\n    vec4 g = texture(iChannel0, vec2(uv.x,      uv.y-1.0/iResolution.y));\n    vec4 h = texture(iChannel0, vec2(uv.x+1.0/iResolution.x, uv.y-1.0/iResolution.y));\n    \n    vec4 sobelX = a*(-1.0) + c*(1.0) + d*(-2.0) + e*(2.0) + f*(-1.0) + h*(1.0);\n    vec4 sobelY = a*(-1.0) + b*(-2.0) + c*(-1.0) + f*(1.0) + g*(2.0) + h*(1.0);\n    \n    fragColor = vec4((sobelX + sobelY).x);\n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 12,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm"
                    }
                ],
                "name": "Buffer D",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 260
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}