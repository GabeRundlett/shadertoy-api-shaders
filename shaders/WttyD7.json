{
    "Shader": {
        "info": {
            "date": "1609278230",
            "description": "potato",
            "flags": 32,
            "hasliked": 0,
            "id": "WttyD7",
            "likes": 43,
            "name": "Day 377",
            "published": 3,
            "tags": [
                "terrain",
                "sun",
                "clouds",
                "grass",
                "landscape",
                "mdtmjvm",
                "cyclicnoise"
            ],
            "usePreview": 1,
            "username": "jeyko",
            "viewed": 1268
        },
        "renderpass": [
            {
                "code": "\n// Cyclic noise from nimitz\n// PBR atmospheric scattering from Sebastian Lague video tutorial on youtube\n// value noise from shane\n// triplanar blending from Shane, who got it from Ryan Geiss\n// smooth ops & sdfs from IQ\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    col = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    col *= vec3(0.9,0.8,0.96);\n    col *= exposure;\n    \n    col = mix(col,smoothstep(0.,1.,col*vec3(1.,1.,1.)),0.9);\n    col = mix(acesFilm(col), col, 0.);\n    col *= 1. - dot(uv,uv*0.4)*2.1;\n    \n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "bool hit = false;\n#define exposure 1.3\n#define groundOffs vec3(0,1.3,0)\n\n// Terrain\n#define marchSteps 200\n//#define marchEps  (mix(0.001,0.06,smoothstep(1.,0.,exp(-t*0.3) - 2.)))\n#define marchEps  (mix(0.005,0.26,smoothstep(0.,1.,t*0.1 - 2.)))\n#define distScale 0.8 \n\n// Moutains \n\n#define marchStMountains 20.\n#define marchEpsMount  0.4\n\n\n// Clouds\n\n#define cloudsLowerLimit 7.\n#define cloudsHigherLimit 14.\n\n#define cloudSteps 60.\n#define volumetricDithAmt .05\n\n// Wind\n#define windSteps 10.\n// Atmosphere\n#define sunCol vec3(1,0.9,0.6)*1.\n#define planetSz 2984.\n#define atmoSz (planetSz/63.)\n\n\n#define ambianceScale 0.4\n\n#define itersAtmo 14.\n#define itersOptic 14.\nconst float redLightLen = 740.;\nconst float greenLightLen = 550.;\nconst float blueLightLen = 450.;\n\nconst float transStrength = 0.02;\n\nfloat densFalloff = 1.9;\n\n\n#define sss(a) clamp(map(p + sunDir*a).x/a,0., 1.)\n#define ao(a) clamp(map(p + (n*0.8 + sunDir)*a).x/a,0., 1.)\n\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p - 0.*a,a) - 0.5*a\nfloat valueNoise(vec3 p, float pw);\nvec3 acesFilm(const vec3 x);\nvec2 dmin(vec2 a, float b, float cmp){return a.x < b ? a : vec2(b,cmp);}\nfloat turbulentNoise(vec3 p);\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra );\nfloat atmosphericDensity( vec3 p);\nfloat opticalDepth(vec3 p, vec3 rd, float len);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos);\nmat3 getRd(vec3 ro, vec3 lookAt);\nvec3 getRdSpherical(vec3 ro, inout vec2 uv);\nvec3 hash3(vec3 p);\nfloat r21(vec2 p);\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p );\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n/*\nfloat r24(vec2 p){\n    return texture(iChannel0,)[ int(mod(p.x))];\n}*/\n\n \n\nmat3 getOrthogonalBasis(vec3 direction){\n    direction = normalize(direction);\n    vec3 right = normalize(cross(vec3(0,1,0),direction));\n    vec3 up = normalize(cross(direction, right));\n    return mat3(right,up,direction);\n}\n\nfloat cyclicNoiseClouds(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 0.6;\n    const float gain = 0.6;\n    const float lacunarity = 1.8;\n    const int octaves = 6;\n    \n    const float warp = 0.26;    \n    float warpTrk = 1.2;\n    const float warpTrkGain = 1.1;\n    \n    vec3 seed = vec3(-1.4,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy  )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return max(-0. - (noise)*0.6,0.);\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseTerrain(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.6;\n    const float lacunarity = 1.4;\n    const int octaves = 4;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-1,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\nfloat cyclicNoiseRocks(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseWind(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 3;\n    \n    const float warp = 0.4;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\nfloat cyclicNoiseGrass(vec3 p, bool turbulent){\n    float noise = 0.;\n    \n    float amp = 1.;\n    const float gain = 0.3;\n    const float lacunarity = 2.5;\n    const int octaves = 2;\n    \n    const float warp = 0.9;    \n    float warpTrk = 1. ;\n    const float warpTrkGain = 1.2;\n    \n    vec3 seed = vec3(-5,-2.,0.5);\n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        \n        p += sin(p.zxy*warpTrk - 2.*warpTrk)*warp; \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n    \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    if(turbulent){\n        return 1. - abs(noise)*0.5;\n    \n    }{\n        return (noise*0.25 + 0.5);\n\n    }\n}\n\n\n/*\nfloat valueNoiseCheap(in vec3 p,float pw)\n{\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rz = textureLod( iChannel0, (tap+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rz.x, rz.y, fp.z );\n}*/\n\n\nfloat valueNoise(vec3 p, float pw){\n    \n\tvec3 s = vec3(1., 25, 75);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    if(pw == 1.){\n        p = p*p*(3. - 2.*p); \n    } else {\n    \n    \tp = p*p*(p*(p * 6. - 15.) + 10.);\n    }\n    \n    //p = smoothstep(0.,1.,p);\n    // Smoother version of the above. Weirdly, the extra calculations can sometimes\n    // create a surface that's easier to hone in on, and can actually speed things up.\n    // Having said that, I'm sticking with the simpler version above.\n\t//p = p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\nvec3 hash3(vec3 p) {\n\tp = vec3(dot(p, vec3(127.1, 311.7, 74.7)),\n\t\t\tdot(p, vec3(269.5, 183.3, 246.1)),\n\t\t\tdot(p, vec3(113.5, 271.9, 124.6)));\n\n\treturn -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 r23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nfloat turbulentNoise(vec3 p, bool md) {\n\tp += 8.;\n    vec3 i = floor(p);\n\tvec3 f = fract(p);\n\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    //f = u;\n\tfloat n0 = dot(hash3(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat n1 = dot(hash3(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat n2 = dot(hash3(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat n3 = dot(hash3(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat n4 = dot(hash3(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat n5 = dot(hash3(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat n6 = dot(hash3(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat n7 = dot(hash3(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\n\tfloat ix0 = mix(n0, n1, u.x);\n\tfloat ix1 = mix(n2, n3, u.x);\n\tfloat ix2 = mix(n4, n5, u.x);\n\tfloat ix3 = mix(n6, n7, u.x);\n\n\tfloat ret = mix(mix(ix0, ix1, u.y), mix(ix2, ix3, u.y), u.z) * 0.5 + 0.5;\n\tret = ret * 1.;\n    \n    //ret = 1.- ret;\n    //ret = abs(ret);\n    if (md)\n        ret = mix(ret,smoothstep(0.3,1.,ret*0.8),0.6);\n    return ret;\n}\n\n\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    //return -b+h;\n    //return max(max(-b-h,0.),max(-b+h,0.));\n    return vec2( -b-h, -b+h );\n}\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat atmosphericDensity( vec3 p){\n    float fact = (p.y - planetSz )/atmoSz;\n    fact = max(fact, 0.0001);\n    return exp(-fact*densFalloff)*pow(max(1. - fact,0.),0.04);//*pow(smoothstep(0.95,0.84,fact),1.);\n}\n\nfloat opticalDepth(vec3 p, vec3 rd, float len){\n    float stSz = len / (itersOptic-1.);\n    float depth = 0.;\n    for(float opticIdx = 0.; opticIdx < itersOptic; opticIdx++ ){\n        depth += atmosphericDensity(p) * stSz;\n        p += rd*stSz;\n     }\n    return depth;\n}\n\n\nvec3 scatteringCoefficients = transStrength*vec3(\n    pow(400./redLightLen,4.),\n    pow(400./greenLightLen,4.),\n    pow(400./blueLightLen,4.)\n);\nvec3 getAtmosphere(vec3 ro, vec3 rd, float t, out float opticalDepthView, vec3 sunPos){\n    vec3 accumAtmo = vec3(0);\n    float atmoMarchLen = 0.;\n    \n    vec3 offs = vec3(0,planetSz ,0);\n    vec3 p = ro;\n    sunPos += offs;\n    \n    p += offs*1.;\n    \n    \n    float lenViewDirToEndOfAtmosphere = sphIntersect( p, rd, vec3(0), planetSz + atmoSz ).y;\n    \n    if(hit){\n        atmoMarchLen = mix(t,lenViewDirToEndOfAtmosphere,smoothstep(0.,1.,t/50. - 1.));\n    } else {\n        atmoMarchLen = lenViewDirToEndOfAtmosphere;\n    }\n    float stepSz = atmoMarchLen/(itersAtmo - 1.);\n    \n\n    for(float atmoIdx = 0.; atmoIdx < itersAtmo ; atmoIdx++ ){\n        vec3 dirToSun = normalize(sunPos - p);\n        float lenSunDirToEndOfAtmosphere = sphIntersect( p, dirToSun, vec3(0), planetSz + atmoSz ).y;\n        lenViewDirToEndOfAtmosphere = sphIntersect( p, -rd, vec3(0), planetSz + atmoSz ).y;\n        \n        float opticalDepthSun = opticalDepth(p, dirToSun, lenSunDirToEndOfAtmosphere);\n        opticalDepthView = opticalDepth(p, -rd, stepSz*atmoIdx);\n        \n        float localDens = atmosphericDensity(p);\n        \n\n        vec3 transmittance = exp(-(opticalDepthSun + opticalDepthView) * scatteringCoefficients);        \n        accumAtmo += transmittance * localDens * scatteringCoefficients * stepSz;\n        \n        p += rd * stepSz;\n    }\n    \n    return accumAtmo;\n}\n\nmat3 getRd(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir,right));\n    \n    return mat3(right,up,dir); \n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 getRdSpherical(inout vec2 uv){\n    \n    // polar coords\n    uv = vec2(atan(uv.y,uv.x),length(uv));\n    \n    vec2 ouv = uv;\n    uv += 0.5;\n    uv.y *= pi;\n    \n    \n    // parametrized sphere\n    vec3 offs = vec3(cos(uv.y)*cos(uv.x),sin(uv.y),cos(uv.y)*sin(uv.x));\n    \n    // insert camera rotations here\n    offs.yz *= rot(-(1.)*pi);\n    \n    //vec3 lookAt = ro + offs;\n    //vec3 v = normalize(lookAt - ro);\n    vec3 v = offs;\n    //uv = ouv;\n    //uv.x = v.x;\n    //uv.y = v.y;\n    \n    return v;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            },
            {
                "code": "\n#define TAA false\n\nvec3 getNormal(vec3 p);\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp);\nfloat t = 0.;\nfloat grh = 0.;\nfloat ng = 0.;\n\nfloat rockTex = 0.;\nvec2 rocks;\nfloat rockn = 0.;\nfloat rockDsmooth = 0.;\n\nvec3 particlesAccum = vec3(0);\nfloat particles = 0.;\n\nfloat mapClouds(vec3 p){\n    float currHeight = p.y;\n    \n    p *= 0.5;\n    float cloudsRange = (cloudsHigherLimit - cloudsLowerLimit)*0.494;\n    float cloudsMid = cloudsLowerLimit + cloudsRange;\n    \n    float fb = cyclicNoiseClouds(p*1. + iTime*0., false);\n    float f = cyclicNoiseClouds(p*0.4 + iTime*0.04 + fb*0.3, true);\n    //f = (f*0.4 + cyclicNoise(p*0.5 + f*2. - fb*1.4 + iTime))*cyclicNoise(p*0.2 + 5.+ f*4.);\n        //f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    //f = fb;\n    f = max(f,0.);\n    f *= pow( smoothstep( 1.,0., abs(currHeight - cloudsHigherLimit + cloudsRange)/cloudsRange*0.9), 2.29);\n    \n    return f;\n}\n\n\n\n\nvec2 getGround(vec3 p){\n    float d = p.y;\n    vec3 pp = vec3(p.x,2.,p.z)*0.2;\n    float n = cyclicNoiseTerrain(pp, false);\n    float on = n;\n    //n = pow((n),1.9);\n    \n    d -= n*2.3;\n    \n    return vec2(d,1.);\n}\n\n\nvec2 getRocks(vec3 p){\n    float d = 10e4;\n    \n    \n    \n    float n = cyclicNoiseRocks(vec3(p.x,p.y*0.4,p.z)*0.4, false);\n    \n    n = smoothstep(0.6,1.,n);\n    \n    \n    rockDsmooth = p.y - ( n*1.6) - 0.6;\n    \n    rockTex = n*texture(iChannel1,p.xz*0.2).x*0.24; \n    \n    rockTex += texture(iChannel1,p.yx*0.4).x*0.03;\n    rockTex += texture(iChannel1,p.yz*0.3).x*0.03;\n    \n    n += rockTex;\n    \n    \n    d = p.y - ( rockn = n*1.6) - 0.6;\n    \n    \n    return vec2(d,2.);\n}\n\nvec2 getGrass(vec3 p, float groundHeight, float scale){\n    p.y = groundHeight;\n    vec3 op = p;\n    p.xz = pmod(p.xz,vec2(scale));\n    p = abs(p);\n    \n    p.xz -= scale * 0.25;\n    \n    \n    //p.xz += smoothstep(0.,1.,p.y)*cyclicNoiseGrass(op + vec3(0,iTime*2.,0), false)*0.4*(2. - 1.);\n    \n    //float d = sdVerticalCapsule( p, 0.4, 0.0001 );\n    float d = sdRoundCone( p, 0.04, 0.0001, 0.4 );\n    return vec2( d, 3.);\n}\nvec2 getFlowers(vec3 p, float groundHeight, float scale){\n    p.y = groundHeight;\n    vec3 op = p;\n    \n    p.xz *= rot(0.4);\n    p.xz = pmod(p.xz,vec2(scale));\n    //p = abs(p);\n    \n    p.y -= 0.5;\n    \n    p.xz = abs(p.xz);\n    p.xz -= 0.7;\n    p.xz = abs(p.xz);\n    \n    p.xz = abs(p.xz);\n    float d = max(length(p + vec3(0,0.04,0)) - 0.05,abs(p.y + 0.04) - 0.004);\n    p.xz -= 0.06;\n    \n    p.xz *= rot(0.25*pi);\n    p.yz *= rot(0.9);\n    \n    p.x *= 0.5;\n    d = min(\n            d,\n            max(length(p) - 0.05,abs(p.y) - 0.001)\n        );\n    \n    \n    return vec2( d, 4.);\n}\n\nfloat getParticles(vec3 p ){\n    \n    \n    p.x += iTime*2.;\n    \n    p += ng;\n    \n    \n    //p.x += sin(p.z*pi)*1.1;\n    //p = pmod(p,2.);\n    \n    \n    p = opRepLim( p, 5., vec3(1000000,1,100000) );\n    \n    float d = length(p);\n    \n    particlesAccum += (1. - particlesAccum)*smoothstep(0.02,0.0,d);\n    \n    return d - 0.003;\n}\n\nvec2 map(vec3 p){\n    vec2 d = vec2(10e5);\n    vec2 gr = getGround(p);\n    float og = gr.x;\n    vec2 rocks = getRocks(p);\n    \n    ng = cyclicNoiseGrass(vec3(p.x,p.y*0.1,p.z) + vec3(0,iTime*2.,0), false)*0.6*(2. - 1.) + 0.1;\n    grh = cyclicNoiseGrass(p + vec3(0,0.,0), false)*0.4*(2. - 1.);\n    vec3 gp = p;\n    gp.xz += smoothstep(0.,1.,gr)*ng;\n    \n    \n    vec2 flowers = getFlowers(gp, gr.x,5.4);\n    \n    vec2 grass = getGrass(gp, gr.x  + 0.4*(1.-grh*6.), 0.5);\n    gp.xz *= rot(0.25);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,4.4).x, 4.);\n    vec2 grassb = getGrass(gp + 0.2, gr.x - 0.4*grh, 0.5);\n    gp.xz *= rot(0.5);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,4.4).x, 4.5);\n    \n    vec2 grassc = getGrass(gp + vec3(0.25,0,-0.2), gr.x - 0.4*sin(grh*20.), 0.5);\n    gp.xz *= rot(0.25);\n    flowers = dmin(flowers, getFlowers(gp, gr.x,3.4).x, 4.5);\n    \n    vec2 grassd = getGrass(gp + vec3(0.14,0,-0.2), gr.x  - 0.4*sin(grh*22.), 0.5);\n    grass = dmin(grass, grassb.x,grassb.y );\n    grass = dmin(grass, grassc.x,grassc.y );\n    grass = dmin(grass, grassd.x,grassd.y );\n    \n    particles = getParticles(p);\n    \n    \n    \n    //grass.x = opSmoothSubtraction( -grass.x, -(rocks.x)*1.601 +0.804, 0.04 );\n    \n    \n    rocks.x -= gr.x*0.6;\n    //gr.x = opSmoothUnion( gr.x, rocks.x, 0.1 );\n    \n    \n    d = dmin(d,gr.x,gr.y);\n    d = dmin(d,rocks.x,rocks.y);\n    d = dmin(d,grass.x,grass.y);\n    d = dmin(d,flowers.x,flowers.y);\n    \n    \n    \n    if(d.y <= 2.)\n        d.y = mix(1.,2.,smoothstep(0.,1.,exp(-rocks.x) - exp(-og*5.1)*7.1));\n    \n    \n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevFrame = texture(iChannel2,fragCoord/iResolution.xy);\n\n    if(TAA){\n        vec2 taaidx = r23(vec3(fragCoord,float(iFrame)))*4.;\n        fragCoord += float(iMouse.z>0.)*.6*vec2(sin(float(taaidx.x)*pi/4.),cos(float(taaidx.x)*pi/4.))*taaidx.y/4.;\n\n    }\n    \n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 col = vec3(0);\n    \n    \n    \n    vec3 sunPos = vec3(-1,.4 + sin(iTime)*.12*0.,2.)*2300.;\n    vec3 sunDir = normalize(sunPos);\n\n    \n    vec3 ro = vec3(0);\n    \n    ro.z += iTime;\n    \n    \n    \n    \n    vec3 lookAt = vec3(0,0,ro.z + 15.*float(iMouse.z < 1.));\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    ro.y += muv.y*2210.;\n        \n        \n    float T = -iTime*0.1;\n    ro.xz -= vec2(cos(muv.x*6. + T),sin(muv.x*6. + T))*10.;\n        \n    if (iMouse.z > 0.) {\n        \n    }\n    \n    float ground = getGround(ro).x;\n    \n    ro.y -= ground;\n    \n    \n    float rocks = getRocks(ro).x*1.04; \n    \n    \n    ro.y -= rockDsmooth*1.7 * smoothstep(0.5,0.2,rocks);;\n    \n    \n    //ro.y -= smoothstep(rocks, 0.,rocks)*rocks*1.4;\n    \n    ro += groundOffs;\n    lookAt.y -= getGround(lookAt).x;\n    lookAt += groundOffs;\n    \n    \n    mat3 vp = getRd(ro,lookAt);\n    \n    vec3 rd = normalize(vec3(uv,1.))*vp;\n    \n    //vec2 sunViewSpace = sunDir.xy;\n    \n    \n    // Marching\n    \n    vec3 p = ro;\n    vec2 d;\n    for(int i = 0; i < marchSteps ; i++){\n        d = map(p);\n        \n        if(i< 20)\n            d.x = min(d.x,abs(particles) + 0.02);\n    \n        if(d.x < marchEps){\n            hit = true;\n            break;\n        } else if (t > 69.){\n            break;\n        }\n        \n        p = ro + rd*(t += d.x * distScale);\n    }\n    \n    \n    float depthView;\n    vec3 atmosphere = getAtmosphere(vec3(0,ro.y - 0.,0), rd, t, depthView, sunPos);\n    \n    \n    // Clouds\n    \n    float lowerCloudLimitDist = plaIntersect( ro - vec3(0,cloudsLowerLimit,0), rd, vec4(0,-1,0,0) );\n    float higherCloudLimitDist = plaIntersect( ro - vec3(0,cloudsHigherLimit,0), rd, vec4(0,-1,0,0) );\n    \n    float volumetricDith = r21(fragCoord + sin(iTime*20.)*20.)*volumetricDithAmt;\n    \n    float cloudLength = higherCloudLimitDist - lowerCloudLimitDist; \n    float cloudStepSz = cloudLength/(cloudSteps);\n    vec3 cloudP = ro + rd * ( lowerCloudLimitDist + volumetricDith*cloudLength );\n    \n    \n    float cloudDensTotal = 0.;\n    vec3 cloudAccum = vec3(0.);\n    \n    \n    for(float i = 0.; i < cloudSteps ; i++){\n        float d = mapClouds(cloudP);\n        \n        float difffact = clamp( d*1. - mapClouds(cloudP + sunDir*1.4)*1.4  + 0.22, 0., 1. );\n        vec3 diff = mix( atmosphere*0.2 + vec3(0.04,0.07,0.2)*(0.4 - smoothstep(0.,1.,1. - atmosphere*1.8)*0.1), (vec3(1,0.9,0.9)*1. + sunCol*0.4 + atmosphere*.4)*0.4, difffact );\n        vec3 absorption = mix( vec3(0.8,0.9,0.8), vec3(1,0.9,0.7)*0.6, clamp( cloudDensTotal*0.5, 0., 1. ) );\n        vec3 fringe = vec3(0.1,0.5,0.5)*clamp( 1. - d*3., 0.,1.);\n        \n        d = d*(1.-cloudDensTotal)*cloudStepSz;\n        \n        cloudDensTotal += d;\n        cloudAccum += d*(diff*3.7*absorption + fringe*(0.1 + diff*0.9)*2.64);\n\n        // map(cloudP).x < 0.\n\n            \n        if( cloudDensTotal > 1.){\n            break;\n        }\n        cloudP += rd*cloudStepSz;\n    }\n    \n    \n    // Wind\n    vec3 windP = ro + rd*volumetricDith*0.00 ;\n    float windStepSz = min(t,24.)/windSteps;\n    \n    float windAccum = 0.;\n    //vec3 windAccum = vec3(0.);\n    \n    for(float i = 0.; i < windSteps ; i++){\n        vec3 wp = windP*0.51 - vec3(-iTime*3.,smoothstep(0.,1.,windP.y*0.5 - 1.9),0.);\n            float dens = cyclicNoiseWind(wp,true)*0.019;\n        dens *= smoothstep(1.,0.,windP.y*0.15 + 0.4);\n        \n        windAccum += dens*(1.-windAccum)*windStepSz;\n        \n        if( windAccum > 1.){\n            break;\n        }\n        windP += rd*windStepSz;\n    }\n    \n    vec3 mountP = rd*50.;\n    float mountT = 0.;\n    bool hitMount = false;\n    // Background Mountains\n    if(false && !hit){\n        for(float i = 0.; i < marchStMountains ; i++){\n            float d = mountP.y - 1.- smoothstep(0.4,1.6,cyclicNoiseTerrain(mountP*0.17,false))*7.;\n             \n            if( d < marchEpsMount){\n                hitMount = true;\n                break;\n            }\n            mountP += rd*d*0.8;\n        }\n        if(hitMount){\n            p = mountP;\n            t = 20. + mountT;\n            d.y = 2.; \n            //hitCol = vec3(0.1);\n            hit = true;\n\n        }\n    }\n    \n    \n    // Coloring\n    \n    vec3 hitCol = vec3(0);\n    vec3 ambientCol = atmosphere*1.;\n    if(hit){\n        vec3 n = getNormal(p);\n        \n        if(d.y == 3.){\n            n = mix(n,vec3(0,1,0),1.);\n            n = normalize(n);\n        }\n        \n        vec3 hf = normalize(sunDir - rd);\n        float diff = max(dot(n,sunDir),0.);\n        float spec = pow(max(dot(n,hf),0.),6.);\n        float fres = pow( 1. - max(dot( n, -rd),0.001),5.);\n        fres = max(fres,0.);\n        \n        \n        float rockiness = d.y - 1.;\n        rockiness = clamp(rockiness,0.,1.);\n        float AO = ao(1.9)*ao(0.2)*ao(4.2)*ao(0.8)*2.;\n        float SSS = sss(.3)*sss(0.04)*sss(.1)*5.;\n        \n        float shad = diff;\n        float rtMod = pow(abs(rockTex*4.5),5.);\n        float rtModInv = pow(abs( 1.-rockTex*4.)*1.2,5.);\n        vec3 rock = vec3(0.4,0.4,0.35);\n        \n        {\n            vec3 ot = tex3D( iChannel3, p, n );\n            rock = mix(rock, rock*vec3(1.,0.6,0.6)*1., clamp(ot.r*1.,0.,1.));\n            \n            rock = mix(rock, rock*vec3(0.4,0.7,0.2)*1.7, clamp(ot.g*1.+ n.y*0.8,0.,1.));\n            \n            \n            \n            float rockAO = clamp(AO + 20.*rtMod + 0.02, 0., 1.);\n            rock += (spec + fres*0.4)*0.02;\n            //rock = mix( 0.4*(rock*(vec3(0.1,0.1,0.1) + ambientCol*0.3 + sunCol*1.3))*ambianceScale,rock*1.,shad);\n            rock = mix( (vec3(0.7,1.,0.6) -rtModInv*vec3(.9,0.5,0.6) + 0.6)*(rock*(0.2+ ambientCol*0.3 + sunCol*0.2))*ambianceScale,rock,rockAO*1.);\n        \n        \n            \n        }\n        \n        \n        vec3 grass = vec3(0.5,1.,0.05)*1.;\n        grass.x += sin(grh*20.)*0.2;\n        grass.yz += sin(grh*50. + 4.)*0.05;\n        grass.xyz -= (1.-grh)*pow(abs(sin(grh*20. + 4.)),4.)*0.6*vec3(0.,0.9,0.5);\n        \n        float cloudShad = pow(cyclicNoiseWind(p*0.2 + iTime*0.35,true)*1.,0.7);\n        \n        cloudShad -= ng*0.2;\n        \n        \n        grass = mix(grass, vec3(0.4,0.5,0.9)*grass*cloudShad, 0.9);        \n        { \n            //grass = mix( vec3(0.1,0.4,0.1)*0.5,grass,AO);\n            \n            shad = clamp(shad + SSS*.5, 0., 1.);\n            AO = clamp(AO + SSS*1. , 0., 1.)*0.5 + 0.4;\n            grass += (spec + fres*.4)*0.2;\n            //grass = mix( (grass*vec3(0.4,0.4,0.2) + ambientCol*0. + sunCol*(1. - diff)*0.54)*ambianceScale,grass*1.,shad);\n            grass = mix( vec3(0.1,0.4,0.1)*0.5,grass,AO);\n            float aoo = ao(1.9);\n            aoo = smoothstep(0.,0.6,aoo);    \n            grass = mix( grass*vec3(0.5,0.5,0.8)*0.8,grass, aoo );\n            \n        }\n        \n        \n        vec3 flower =vec3(0.5,0.5,0.05)*2.; \n        if(d.y == 4.5)\n            flower = vec3(0.95,0.62,0.95)*0.7;\n        {\n            flower *= pow(AO,0.7);\n        }\n        \n        hitCol = mix(grass,rock,rockiness);\n        \n        \n        if(d.y == 3.){\n            hitCol = grass;\n        } else if(d.y >= 4.){\n            hitCol = flower;\n        }\n        hitCol = mix(hitCol, hitCol*cloudShad,0.2);\n        \n    }\n    \n\n    // Compositing\n    \n    col += hitCol;\n    \n    if(hit){\n       atmosphere *= 1.-pow(exp(-(t)*.04 ),2.);\n    }\n    \n    atmosphere += getSun(rd.xy, sunDir.xy, sunPos, ro, vp);\n    float depthViewFac = smoothstep(0.,1.,exp(-depthView*0.02) + exp(-t*0.4));\n    \n    col = col * depthViewFac + atmosphere; \n    \n    if (!hit  && lowerCloudLimitDist > 0.){\n        cloudAccum = mix(cloudAccum,col,clamp(1.-exp(-lowerCloudLimitDist*0.01 + 0.4),0.,1.));\n        col = mix(col,cloudAccum*1. , pow(clamp(cloudDensTotal*1. - 0.,0.,1.),4.));\n    }\n    windAccum *= smoothstep(0.,1.,t*0.2 - 1.);\n    col = (col - windAccum) + 4.*windAccum*vec3(1,0.9,0.8);\n    \n    col += particlesAccum;\n    \n    if(TAA && iFrame >1 && iMouse.z < 1.){\n        fragColor = mix(prevFrame, col.xyzz,0.4);\n    } else {\n        fragColor = col.xyzz;\n    }\n    \n    \n    \n    \n    fragColor.w = cloudDensTotal + float(hit)*1.;\n}\n\n\nvec3 getNormal(vec3 p){\n      vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.04).x;\n    }\n    return normalize(n);\n}\n\n\nvec3 getSun(vec2 uv, vec2 sunPos, vec3 sunPosW, vec3 ro, mat3 vp){\n    \n    vec2 sunUVOriginal = uv;\n    \n    vec2 sunUV = uv - sunPos;\n    //float cloudDensPrevFrame = texture(iChannel2, ((sunUV*iResolution.y + 0.5*iResolution.xy)/iResolution.xy)).w;\n    \n    //vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(getRd(ro,sunPosW))).xy;\n    vec2 sunUvPrevFrame = (normalize(sunPosW - ro)*inverse(vp)).xy;\n    \n    sunUvPrevFrame = (sunUvPrevFrame*iResolution.y)/iResolution.xy + 0.5;\n    \n    float deltaUV = 0.04;\n    float cloudDensPrevFrame = \n        texture(iChannel2, sunUvPrevFrame + deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame - deltaUV).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(-deltaUV,deltaUV)).w\n        + texture(iChannel2, sunUvPrevFrame + vec2(deltaUV,-deltaUV)).w\n        ; \n    \n    cloudDensPrevFrame /= 4.;\n    \n    cloudDensPrevFrame = clamp(cloudDensPrevFrame,0.,1.);\n    // sun\n    vec3 sun = sunCol*smoothstep(0.07,0.,length(sunUV));\n    sun += sunCol*vec3(1.,0.4,0.6)*smoothstep(0.1,0.,length(sunUV));\n    sun += sunCol*vec3(0.7,0.4,0.6)*smoothstep(0.3,0.,length(sunUV))*0.5;\n    sun += sunCol*vec3(0.3,0.4,0.6)*smoothstep(0.6,0.,length(sunUV))*0.35;\n    \n    \n    // rays\n    \n    \n    vec3 sunRays = 0.4*sunCol * smoothstep(0.015*(1. + smoothstep(1.,0.,abs(sunUV.x)) ) ,0.,abs(sunUV.y))*smoothstep(0.5,0.,abs(sunUV.x));\n    \n    for(float i = 0.; i < 8.; i++){\n        sunUV *= rot(pi/8./1.);\n        float mda = sin(i*pi/4.);\n        float mdb = sin(i*pi/2.);\n        float w = 0.03;\n        float l = 0.1;\n        sunRays += (sunCol) *\n            mix(.8,.1,smoothstep(0.,0.25 +  sin(i*pi/ 4. + iTime)*0.1,length(sunUV))) *\n            smoothstep(w + mda*w/4.,0.,abs(sunUV.y))*smoothstep((l + mdb*0.1)*1.5,0.,abs(sunUV.x));\n    }   \n    sunUV = sunUVOriginal - sunPos;\n    vec3 flares = vec3(0);\n    vec2 toMid = sunPos;\n    vec2 dirToMid = -normalize(toMid);\n    float lenToMid = length(toMid);\n\n    // flares\n    for(float i = 0.; i < 12.; i++){\n          sunUV -= 2.*lenToMid*dirToMid/12.;\n          float dfl = length(sunUV) - (0.1 + 0.1*sin(i*5.))*0.5;\n          dfl *= 0.5;\n          vec3 flare = 0.01*(sunCol)*smoothstep(0.02,0.,dfl);\n          flare += 0.003*(sunCol*sunCol)*smoothstep(0.01,0.,abs(dfl - dFdx(uv.x)));\n          flares += flare*abs(sin(i*10.));\n    }   \n    \n    \n    return (sun + sunRays + flares*3.*sunCol) * (1. - cloudDensPrevFrame*1.);\n}\n\n",
                "description": "",
                "inputs": [
                    {
                        "channel": 3,
                        "ctype": "texture",
                        "id": 8,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 30,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "false",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 47,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png"
                    },
                    {
                        "channel": 2,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}