{
    "Shader": {
        "info": {
            "date": "1626256317",
            "description": "Using the Apple logo SDF.",
            "flags": 32,
            "hasliked": 0,
            "id": "ftfSzX",
            "likes": 3,
            "name": "California Daydream",
            "published": 3,
            "tags": [
                "raytracing",
                "sdf",
                "logo",
                "apple"
            ],
            "usePreview": 0,
            "username": "chenglou",
            "viewed": 373
        },
        "renderpass": [
            {
                "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "const float PI = 3.14159;\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat sdSphere( vec3 p, float r ) {\n    return length(p) - r;\n}\nfloat sdCircle( vec2 p, float r ) {\n    return length(p) - r;\n}\n\nmat3 rotate(float t) {\n    mat3 R = mat3(\n        vec3(cos(t), 0, sin(t)),\n        vec3(0, 1, 0),\n        vec3(-sin(t), 0, cos(t))\n    );\n    return R;\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 random_in_unit_sphere(vec2 p)\n{\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\nvec3 random_unit_vector(vec2 p) {\n    return normalize(random_in_unit_sphere(p));\n}\nbool near_zero(vec3 p) {\n    float s = 1e-8;\n    return p.x < s && p.y < s && p.z < s;\n}\n\nfloat sdApple(vec2 coord, float ra) {\n    float leaf1 = sdCircle(coord - vec2(-0.0161, 0.9658) * ra, 0.4447 * ra);\n    float leaf2 = sdCircle(coord - vec2(0.4628, 0.5473) * ra, 0.4567 * ra);\n\n    float shoulderLeft = sdCircle(coord - vec2(-0.3340, 0.0644) * ra, 0.4608 * ra);\n    float shoulderRight = sdCircle(coord - vec2(0.3964, 0.0382) * ra, 0.4909 * ra);\n\n    float bodyLeft = sdCircle(coord - vec2(-0.1227, -0.1831) * ra, 1.006 * ra);\n    float bodyCenter = sdCircle(coord - vec2(0.0141, -0.4889) * ra, 0.9256 * ra);\n    float bodyRight = sdCircle(coord - vec2(0.3662, -0.0483) * ra, 1.2052 * ra);\n    float bodyShoulderLeft = sdCircle(coord - vec2(-0.1791, -0.0624) * ra, 0.6640 * ra);\n\n    float buttLeft = sdCircle(coord - vec2(-0.2998, -0.7505) * ra, 0.2495 * ra);\n    float buttRight = sdCircle(coord - vec2(0.3803, -0.7505) * ra, 0.2495 * ra);\n\n    float bite = sdCircle(coord - vec2(1.0080, -0.0543) * ra, 0.4427 * ra);\n    float bottom = sdCircle(coord - vec2(0.0382, -1.4145) * ra, 0.4950 * ra);\n\n    float delimiterLeft = sdCircle(coord - vec2(-0.6398390342052314, 0.0201) * ra, 0.3320 * ra);\n\n    // assemble!\n    float leaf = opIntersection(leaf1, leaf2);\n    float tinyPieceLeft = opIntersection(delimiterLeft, bodyShoulderLeft) + 0.002 * ra; // random constant\n    float lowerPart = opIntersection(bodyLeft, opIntersection(bodyCenter, bodyRight));\n    float body;\n    body = opUnion(shoulderLeft, shoulderRight);\n    body = opSmoothUnion(body, lowerPart, 0.121 * ra); // random constant\n    body = opUnion(body, tinyPieceLeft);\n    body = opUnion(body, leaf);\n    body = opSubtraction(bite, body);\n    body = opSmoothSubtraction(bottom, body, 0.189 * ra); // random constant\n\n    return body;\n}\n\nfloat map(vec3 p, vec2 iMouse, float iTime) {\n    vec3 shift = (p - vec3(0., 0.06, 0.01)) * rotate(iTime);\n    \n    float s1 = sdApple(shift.xy, 1./3.);\n    s1 = opExtrussion(shift, s1, 0.066);\n    // if inside of apple, flip it\n    s1 = abs(s1);\n\n    float s2 = sdSphere(p - vec3(0., -1.7, 0.), 1.43);    \n\n    return opUnion(s1, s2);\n}\n\nvec3 calcNormal( in vec3 p, vec2 iMouse, float iTime) // for function f(p)\n{\n    const float eps = 1e-7; // or some other value\n    const vec2 h = vec2(eps, 0);\n    return normalize( vec3(map(p+h.xyy, iMouse, iTime) - map(p-h.xyy, iMouse, iTime),\n                           map(p+h.yxy, iMouse, iTime) - map(p-h.yxy, iMouse, iTime),\n                           map(p+h.yyx, iMouse, iTime) - map(p-h.yyx, iMouse, iTime) ) );\n}\n\nfloat maxT = 12.;\nbool rayMarch(vec3 ro, vec3 rd, vec2 iMouse, float iTime, out float t) {\n    t = 1e-4;\n    for(int i = 0; i < 18; i++) {\n        vec3 p = ro + t*rd;\n        float h = map(p, iMouse, iTime);\n        if( abs(h) < 1e-5) {\n            return true;\n        }\n\n        if (t > maxT) {\n            return false;\n        }\n        t += h;\n    }\n    return true;\n}\n\nvec3 skyCol = vec3(0.6, 0.7, .7);\nvec3 appleCol = vec3(0.5, 0.5, .8);\n\nvec3 rayColor(vec3 ro, vec3 rd, vec2 iMouse, float iTime, vec2 seed) {\n    vec3 color = vec3(1);\n    \n    vec3 ro_ = ro;\n    vec3 rd_ = rd;\n    for (int i = 0; i < 5; i++) {\n        float t;\n        if (rayMarch(ro_, rd_, iMouse, iTime, t)) {\n            vec3 pos = ro_ + rd_ * t;\n            vec3 normal = calcNormal(pos, iMouse, iTime);            \n            \n            vec3 scatter_direction = normal + random_unit_vector(seed + float(i));\n            // catch degenerate scatter direction\n            if (near_zero(scatter_direction)) {\n                scatter_direction = normal;\n            }\n            ro_ = pos;\n            rd_ = scatter_direction;\n            \n            color *= appleCol;\n        } else {\n            vec3 unit_direction = normalize(rd);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            color *= mix(appleCol, skyCol, t);\n            return color;\n        }\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = iResolution.xyxy;\n    } else {\n        vec3 ro = vec3(0., 0., 0.28);\n\n        vec2 rand = hash22(fragCoord + iTime * 999.);\n        vec2 coord = fragCoord + rand;\n        coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n        \n        vec3 rd = normalize(vec3(coord, 0) - ro);\n        vec3 col = rayColor(ro, rd, iMouse.xy, iTime, fragCoord + rand);\n\n        if (texelFetch(iChannel0, ivec2(0), 0).xy == iResolution.xy) {        \n            fragColor = vec4(col,1) * .1 + texelFetch(iChannel0, ivec2(fragCoord), 0) * .9;\n        } else {        \n            fragColor = vec4(col,1);\n        }\n    }\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    }
                ],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}