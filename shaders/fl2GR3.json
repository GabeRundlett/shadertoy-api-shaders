{
    "Shader": {
        "info": {
            "date": "1624380861",
            "description": "Trying to find an alternative to inverse bilinear interpolation. This method doesn't quite work but the goal is to get unique weights that sum to 1 and also map correctly to the expected quad shape which inverse bilinear doesn't always do.",
            "flags": 0,
            "hasliked": 0,
            "id": "fl2GR3",
            "likes": 5,
            "name": "Almost Quadcentric Coordinates",
            "published": 3,
            "tags": [
                "barycentric",
                "lerp",
                "interpolation",
                "quad"
            ],
            "usePreview": 0,
            "username": "oneshade",
            "viewed": 219
        },
        "renderpass": [
            {
                "code": "// Drawing utilities\n#define draw(d, c) color = mix(color, c, smoothstep(unit, 0.0, d))\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - t;\n}\n\nvec4 weightsInQuad(in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 pa = p - a, pb = p - b, pc = p - c, pd = p - d;\n    vec2 ba = b - a, cb = c - b, dc = d - c, da = d - a;\n    vec2 ca = c - a;\n\n    // Total quad area (sum of two triangles forming the quad)\n    float T = (abs(ba.x * ca.y - ba.y * ca.x) + abs(dc.x * ca.y - dc.y * ca.x)) * 0.5;\n\n    float A = abs(ba.x * pa.y - ba.y * pa.x) * 0.5; // Area of triangle ABP\n    float B = abs(cb.x * pb.y - cb.y * pb.x) * 0.5; // Area of triangle BCP\n    float C = abs(dc.x * pc.y - dc.y * pc.x) * 0.5; // Area of triangle CDP\n    float D = abs(da.x * pa.y - da.y * pa.x) * 0.5; // Area of triangle DAP\n\n    // Since there aren't unique triangles opposite each vertex\n    // I made the observation that the barycentric coordinate was\n    // also 1-(A+B)/T where A and B were triangles connected to the\n    // vertex so this might apply to a quad too. Summing this up for\n    // each vertex results in 2 instead of 1 though so I then scaled\n    // each of the weights by 1/2\n    float wa = (1.0 - (D + A) / T);\n    float wb = (1.0 - (A + B) / T);\n    //float wc = (1.0 - (B + C) / T);\n    //float wd = (1.0 - (C + D) / T);\n\n    return vec4(wa, wb, 1.0 - wa, 1.0 - wb) * 0.5; // Change suggested by @Yusef28\n}\n\nvec3 tex(in vec2 uv) {\n    return vec3(0.5 + 0.5 * mod(dot(floor(uv * 8.0), vec2(1.0)), 2.0), 0.0, 0.0);\n}\n\nvoid render(inout vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    vec3 color = vec3(0.5);\n\n    vec2 a = vec2(-1.0, 1.0) + vec2(cos(iTime), sin(iTime)) * 0.5;\n    vec2 b = vec2(-1.0, -1.0) + vec2(sin(3.0 * iTime), cos(3.0 * iTime)) * 0.2;\n    vec2 c = vec2(1.0, -1.0) + vec2(cos(2.0 * iTime), sin(2.0 * iTime)) * 0.5;\n    vec2 d = vec2(1.0, 1.0) + vec2(sin(iTime), cos(iTime)) * 0.2;\n\n    vec4 t = weightsInQuad(uv, a, b, c, d);\n    color = tex(vec2(0.0, 0.0) * t.x + vec2(0.0, 1.0) * t.y + vec2(1.0, 1.0) * t.z + vec2(1.0, 0.0) * t.w);\n\n    draw(sdLine(uv, a, b, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, b, c, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, c, d, 0.005), vec3(1.0, 0.8, 0.0));\n    draw(sdLine(uv, d, a, 0.005), vec3(1.0, 0.8, 0.0));\n\n    draw(sdDisc(uv, a, 0.05), vec3(1.0));\n    draw(sdDisc(uv, b, 0.05), vec3(1.0));\n    draw(sdDisc(uv, c, 0.05), vec3(1.0));\n    draw(sdDisc(uv, d, 0.05), vec3(1.0));\n\n    fragColor += vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    render(fragColor, fragCoord);\n    render(fragColor, fragCoord + vec2(0.5, 0.0));\n    render(fragColor, fragCoord + vec2(0.5, 0.5));\n    render(fragColor, fragCoord + 0.5);\n    fragColor /= 4.0;\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}