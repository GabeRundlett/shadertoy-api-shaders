{
    "Shader": {
        "info": {
            "date": "1609194054",
            "description": "potato",
            "flags": 0,
            "hasliked": 0,
            "id": "WtcyDM",
            "likes": 12,
            "name": "Day 376",
            "published": 3,
            "tags": [
                "mdtmjvm"
            ],
            "usePreview": 0,
            "username": "jeyko",
            "viewed": 404
        },
        "renderpass": [
            {
                "code": "\n// cyclic noise learned from nimitz\n// it is literally invented by nimitz\n\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define pmod(p,a) (mod(p - 0.5*a,a) - 0.5*a)\n\nvec3 glow = vec3(0);\nvec3 ro;\n\n\n#define xor(a,b,c) min(max(a,-(b)), max(-(a) + c,b))\n\nvec2 map(vec3 po){\n    vec2 d = vec2(10e5);\n    \n    vec4 p = vec4(po,1.);\n    \n    p.xz -= 2.;\n    \n    p = abs(p);\n    p.xz -= 2.;\n    \n    p.y = pmod(p.y,5.);\n    for(int i = 0; i <6; i++){\n    \n    \n        p.xyz = pmod(p.xyz,vec3(5,4,5));\n    \n        \n        p = abs(p);\n        \n        if(p.x - p.y < 0.) p.xy = p.yx;\n        if(p.x - p.z < 0.) p.xz = p.zx;\n        if(p.z - p.y < 0.) p.zy = p.yz;\n        \n    \n        \n        if(i == 5 || i == 3){\n            p.y -= .6 + sin(iTime*0.4)*1.4;\n            float dpp = dot(p.xyz,p.xyz);\n            dpp = clamp(dpp,0.,0.2 + sin(iTime)*0.05);\n            p = p/dpp;\n        }\n        \n    \n        p.xy *= rot(-0.25*pi);\n        p.xy -= 0.5;\n        p *= 1.4 + sin(iTime*0.5)*0.3;\n        \n        float ld = max(p.z,p.x)/p.w - 0.002;\n        \n        d.x = xor(-d.x, ld,0.4);\n    \n    }\n    \n    p.xyz /= p.w;\n    \n    \n    \n    p = abs(p);\n    \n    glow += exp(-d.x*40.);\n    \n    d.x *= 0.7;\n        \n    d.x = max(d.x,-length(po.xz) + 0.4);\n    d.x = mix(d.x,0.1,smoothstep(0.2,0.,length(po-ro)));\n    return d;\n}\n\n\nmat3 getOrthogonalBasis(vec3 lookAt){\n    vec3 dir = normalize(lookAt);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    return mat3(right,up,dir);\n}\n\n\nfloat cyclicNoise(vec3 p){\n    float noise = 0.;\n    \n    vec3 seed = vec3(-4. ,-2.,0.5);\n    \n    float amp = 1.;\n    float gain = 0.6;\n    float lacunarity = 1.4;\n    int octaves = 5;\n    \n    \n    float warp = 0.3+ sin(iTime)*0.;    \n    float warpTrk = 1.2 ;\n    float warpTrkGain = 1.5;\n    \n    mat3 rotMatrix = getOrthogonalBasis(seed);\n    \n    for(int i = 0; i < octaves; i++){\n        // Some domain warping. Similar to fbm.\n        p += sin(p.zxy*warpTrk*0.2 - 2.*warpTrk)*warp; \n        // Calculate some noise value. \n        noise += sin(dot(cos(p), sin(p.zxy )))*amp;\n        //noise += abs(sin(dot(cos(p), sin(p.zxy ))))*amp;\n        \n        p *= rotMatrix;\n        p *= lacunarity;\n        \n        warpTrk *= warpTrkGain;\n        amp *= gain;\n    }\n    \n    return noise*0.5;\n}\n\n\nfloat mapCloud(vec3 p){\n    \n    vec3 op = p;\n    float d = length(p.xz);\n    p *= 12.;\n    \n    p.y -= iTime*4.;\n    \n    float n = cyclicNoise(p)*0.4;\n\n    d -= sin(length(op.y)*4. + iTime*2.)*0.04;\n    d -= 0.4 +  n*0.3;\n    d = smoothstep(0.05,0.,d)*3.;\n    return d;\n}\n\n\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    return normalize(dir + right*uv.x + up*uv.y);\n}\nvec3 getNormal(vec3 p){\n    vec2 t = vec2(0.001,0.);\n    return normalize(map(p).x - vec3(\n        map(p - t.xyy).x,\n        map(p - t.yxy).x,\n        map(p - t.yyx).x\n    ));\n}\n\nfloat sdBox(vec2 p){\n    p = abs(p); return max(p.y,p.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    float db = 10e5;\n    vec2 buv = uv;\n    /*\n    for(int i = 0; i < 5; i++){\n        float bx = abs(sdBox(buv) - 0.4) - .54;\n        \n        buv = pmod(buv, 1.4);\n        buv = abs(buv);\n        if(buv.x + buv.y < 0.) buv.xy = buv.yx;\n        if(buv.x - buv.y < 0.) buv.xy = buv.yx;\n        buv.x -= 0.04 + sin(iTime)*.4;\n        buv *= rot(0.25*pi );\n        \n        db = xor(db,bx,0.4);\n    \n    }\n    \n    db -= 0.2;\n    if (db < 0.){\n        uv = uv.yx;\n    } \n    \n    */\n    buv = uv + 1000.;\n    vec3 col = vec3(0);\n    ro = vec3(0);\n    ro.xz += vec2(sin(iTime*0.5),cos(iTime));\n    \n    ro = normalize(ro)*( 0.75 + length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5));\n    ro.y += iTime*0.2;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.y = ro.y;\n    \n    lookAt.y += length(vec2(sin(iTime*0.6),cos(iTime*0.4))*0.5)*2. - 1.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    vec3 sunDir = normalize(vec3(1));\n    \n    \n    vec3 p = ro;\n    float t = 0.; bool hit = false;\n    vec2 d;\n    float marchi = 0.;\n    for(; marchi < 90.; marchi++){\n        d = map(p);\n        \n        if(d.x < 0.001){\n            hit = true;\n            break;\n        }\n        p = ro + rd*(t += d.x);\n    }\n    \n    vec3 hitC = vec3(0);\n    \n    if(hit){\n        vec3 n = getNormal(p);\n        vec3 albedo = n + 0.5;\n        \n        #define ao(a) smoothstep(0.,1.,map(p + (n + sunDir*0.4)*a).x/a)\n        \n        hitC += albedo*0.;\n        \n        float diff = max(dot(n,sunDir),0.);\n        \n        float aof = ao(0.01)*ao(0.1)*ao(0.07)*2. + 0.1;\n        hitC = mix(max(vec3(0.9,0.2,0.)*2. - sin(iTime*0.2) - 1.4,0.),hitC,diff);\n        \n        //hitC = mix(vec3(0.9,0.2,0.5)*0.9,hitC,diff);\n        hitC = mix(vec3(0.1,0.2,0.5)*0.2,hitC,aof);\n    }\n        \n        \n    \n    float volSteps = 7.;\n    float volDist = min(t, 1.6);\n    float volStSz = volDist/volSteps;\n    vec3 volP = ro;\n    vec3 volAccum = vec3(0);\n    \n    float tDens = 0.;\n    \n    \n    for(float i = 0.; i < volSteps; i++){\n        //float dens = pow(abs(sin(length(volP*25.)*1. + iTime)),12.)*1.44;\n        //float dens = smoothstep(0.1,0., length(volP) - 0.3);\n        float dens = mapCloud(volP);\n        float odens = mapCloud(volP + sunDir*0.3);\n        \n        float diff = clamp(dens - odens*0.95, 0., 1.);\n        vec3 absorption = mix(vec3(0.4,0.7,0.9),vec3(0.8,0.6,0.1)*0.2 ,clamp(tDens*.4, 0., 1.));\n        vec3 fringe = mix(vec3(1.8,0.1,0.1)*1., vec3(0.4,0.7,0.9)*0.0, pow(clamp(dens*0.8 - 1.9, 0., 1.),0.2));\n   \n        vec3 c = mix(vec3(0.1,0.1,0.4)*0.3,vec3(0.6,0.3,0.2)*1.,diff);\n        \n        c *= absorption;\n        \n        dens = dens*(1. - tDens)*volStSz;\n        \n        volAccum += c*dens*1.5 + fringe*dens;\n        \n        \n        \n        tDens += dens;\n        \n        if(tDens > 1.){\n            break;\n        }\n        \n        volP += rd*volStSz;\n    }\n    //col += marchi*0.02*(0.5 + 0.4*sin(vec3(1.,4.8,4.8) + uv.xyx));\n    \n    col += hitC*1.;\n    \n    col = mix(col,vec3(0.04,0.01,0.1),smoothstep(0.,1.,marchi*0.01));\n    \n    //col += glow*.02*(smoothstep(1.,0.,t*0.06));\n    \n    \n    col = mix(col + volAccum*0., volAccum*1., smoothstep(0.,1.,pow(tDens*1.,  1.)) );\n    \n    col = mix(col,smoothstep(0.,1.,col*1.5),0.4);\n    \n    \n    col = 1. - col*(3. + sin(iTime));\n    \n    \n    \n    if (abs(db) < 0.4){\n        col = 1. - col; \n    } \n    \n    //col.xz *= rot(iTime);\n    \n    //vec3 rotAround = normalize(vec3(sin(iTime),cos(iTime*0.5),sin(iTime*0.4)));\n    vec3 rotAround = normalize(vec3(-1.,1.,-1));\n    \n    mat3 matRotAround = mat3(\n        rotAround.x, 0., 0.,\n        0., rotAround.y, 0.,\n        0., 0., rotAround.z\n    );\n    col += 1.;\n    col *= matRotAround;\n    \n    //col.xy *= rot(-0.4+ sin(iTime)*0.4 + (uv.y)*0.2);\n    //col.xy *= rot(sin(iTime)*0.2);\n    \n    col *= inverse(matRotAround);\n    col -= 1.;\n    \n    col *= 1. - dot(uv,uv)*0.5;\n    col = pow(abs(col), vec3(0.45454));\n    \n    fragColor = vec4(col,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}