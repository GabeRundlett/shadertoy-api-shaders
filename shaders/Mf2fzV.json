{
    "Shader": {
        "info": {
            "date": "1725222007",
            "description": "w,s,d,a transform+ mouse look",
            "flags": 16,
            "hasliked": 0,
            "id": "Mf2fzV",
            "likes": 6,
            "name": "fractal explorer #2 visualizer",
            "published": 3,
            "tags": [
                "fractal"
            ],
            "usePreview": 0,
            "username": "orblivius",
            "viewed": 150
        },
        "renderpass": [
            {
                "code": "// Fork of \"fractal explorer # 2\" by nayk. https://shadertoy.com/view/XcBfzV\n// 2024-09-01 20:19:31\n\n// Audiovisualized by 0rblivius\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n#define DITHERED 1\n\nconst float TURN = 2. * acos(-1.);\n\n\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n\n#if DITHERED\nfloat dither(float z, float steps, float thres) {\n    return floor(z * steps) + step(thres, fract(z * steps));\n}\n#endif\n\nvec3 cmap(float h, float l, float thres) {\nconst vec3[] CMAP = vec3[](\n    vec3(149, 0, 54) / 255.,\n    vec3(126, 0, 0) / 255.,\n    vec3(67, 61, 0) / 255.,\n    vec3(0, 76, 0) / 255.,\n    vec3(0, 79, 68) / 255.,\n    vec3(0, 78, 148) / 255.,\n    vec3(0, 62, 177) / 255.,\n    vec3(109, 0, 135) / 255.,\n    vec3(210, 0, 100) / 255.,\n    vec3(185, 64, 0) / 255.,\n    vec3(115, 109, 0) / 255.,\n    vec3(0, 127, 0) / 255.,\n    vec3(0, 133, 115) / 255.,\n    vec3(0, 129, 203) / 255.,\n    vec3(0, 108, 234) / 255.,\n    vec3(165, 58, 189) / 255.,\n    vec3(255, 83, 150) / 255.,\n    vec3(248, 118, 54) / 255.,\n    vec3(171, 160, 0) / 255.,\n    vec3(26, 182, 61) / 255.,\n    vec3(0, 189, 167) / 255.,\n    vec3(0, 183, 255) / 255.,\n    vec3(55, 159, 255) / 255.,\n    vec3(223, 114, 246) / 255.,\n    vec3(255, 144, 204) / 255.,\n    vec3(255, 173, 105) / 255.,\n    vec3(230, 214, 53) / 255.,\n    vec3(103, 239, 114) / 255.,\n    vec3(0, 247, 222) / 255.,\n    vec3(0, 240, 255) / 255.,\n    vec3(134, 213, 255) / 255.,\n    vec3(255, 169, 255) / 255.\n);\n\n#if DITHERED\n    h = dither(h, 8., thres);\n    l = dither(.5 * cos(l * TURN) + .5, 3., thres);\n    return CMAP[int(h) % 8 + int(l) * 8];\n#else\n    h = h * 8.;\n    l = 3. * (.5 * cos(l * TURN) + .5);\n    return mix(\n        mix(\n            CMAP[int(h) % 8 + int(l) * 8],\n            CMAP[int(h + 1.0) % 8 + int(l) * 8],\n            fract(h)\n        ), mix(\n            CMAP[int(h) % 8 + int(l + 1.0) * 8],\n            CMAP[int(h + 1.0) % 8 + int(l + 1.0) * 8],\n            fract(h)\n        ), fract(l)\n    );\n#endif\n}\n\nfloat stepped(float v, float steps) {\n    return round(v * steps) / steps;\n}\n\nfloat timeStep(float t) {\n    const float w = 0.1;\n    t = 1. - abs(1. - fract(t) * 2.);\n    return mix(\n        step(0.5, t),\n        1.5 * (t - 0.5) + 0.5,\n        smoothstep(0.25 - w, 0.25 + w, t)\n        - smoothstep(0.75 - w, 0.75 + w, t)\n    );\n}\n\nfloat component(float x, float y, float t) {\n    float yStep = stepped(y, 7.);\n    float tStep = t + yStep;\n    return fract(\n        //8. * (x + y)\n        10. * x\n        + 4. * timeStep(tStep)\n    );\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n     float t = fract(iTime / 4.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * C - iResolution.xy) / iResolution.y;\n    \n    \n    \n    float thres = crosshatch(C);\n    const float scale = 0.4;\n    float comp0 = component(scale * uv.x, scale * uv.y, t);\n    float comp1 = component(scale * uv.y, scale *-uv.x, t + 0.25);\n\n\n   vec3 col = cmap(comp0, comp1, thres);\n    vec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n   \n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n\n    \n    rot*= TAU;\n    mat3 mX = RotationMatrix(vec3(-1.0, .0, 1.0), iTime);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -iTime);\n    mX= mY * mX;\n    \n       \n    \n \n\t\n    time = iTime - time;\n    float speed = time*.74;\n    \n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n       \n    for(float i=0.,a,s,e,g=0.;\n        ++i<90.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/5e3\n    )\n    {\n        p=g*d;\n     \n       float snd = texture(iChannel0, vec2(i/110., .25)).r;\n    \n   \n\t\tp.z+=iTime*3.;\n\t\n    \n   \n        a=30.;\n        \n        p=mod(p-a,a*2.)-a;\n        s=3.;\n         p*=mX;\n        for(int i=0;i++<8;){\n            p=.2-abs(p);\n    \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.7+sin(-.5*snd+iTime*0.0234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    25.+3.,\n                    120,\n                    7.+5.-snd*.5\n                 )+col.x;\n         }\n      \n         g+=e=length(p.yzz)/s;\n    }\n   \n            \n    \n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "music",
                        "id": 18,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3"
                    },
                    {
                        "channel": 2,
                        "ctype": "keyboard",
                        "id": 33,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/presets/tex00.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}