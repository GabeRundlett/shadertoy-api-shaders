{
    "Shader": {
        "info": {
            "date": "1527321893",
            "description": "A nice way to visualize the influence-area of smooth-minimum aka opCombine(). The visuals are pretty self-explanatory I guess. The discontinuities in the red influence-area also show the domain-repetition cells nicely.",
            "flags": 0,
            "hasliked": 0,
            "id": "lddfDs",
            "likes": 18,
            "name": "Sea of cubes with smooth-minimum",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "domain",
                "repetition",
                "spheretracing",
                "smoothminimum",
                "cineshader"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 2655
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// smooth-min influence visualized with a sea of cubes\n//\n// Copyright 2018 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst int MAX_ITER = 80;\nconst float EPSILON = .00025;\nconst float STEP_BIAS = .6;\n\nfloat sdSphere (in vec3 p, in float r)\n{\n\treturn length (p) - r;\n}\n\nfloat sdPlane (in vec3 p, in float h)\n{\n\treturn p.y - h;\n}\n\nfloat udBox (in vec3 p, in vec3 size, in float r)\n{\n\treturn length (max (abs (p) - size, .0)) - r;\n}\n\nfloat opCombine (in float d1, in float d2, in float r, inout int matIndex)\n{\n    float h = clamp (.5 + .5 * (d2 - d1) / r, .0, 1.);\n    float result = mix (d2, d1, h) - r * h * (1. - h);\n    float threshold = r*.001;\n\n\tmatIndex = 2;\n\n    if (abs (result - d1) <= threshold) {\n        matIndex = 0;\n    }\n\n    if (abs (result - d2) <= threshold) {\n        matIndex = 1;\n    }\n\n    return result;\n}\n\nvec2 opRepeat2 (inout vec2 p, in float size)\n{\n\tfloat h = size*.5;\n\tvec2 cell = floor ((p + h) / size);\n\tp = mod (p + h, size) - h;\n\treturn cell;\n}\n\nstruct HitResult {\n    float dist;\n    int matId;\n};\n\nHitResult scene (in vec3 p)\n{\n\tvec3 p2 = p + vec3 (-.1, -.3 - .1*(.5+.5*cos (3.*iTime)), .5);\n\tvec3 p3 = p + vec3 (.4, .0, 1.);\n\tfloat ball = sdSphere (p2, .1 + .1 * (.5+.5*cos(4.*iTime)));\n\tvec2 cell = opRepeat2 (p3.xz, .2);\n\tp3.y += .3*sin (.1*cell.x+1.5*iTime)*cos(.2*cell.y+2.*iTime);\n\tp3.y += .15*sin (.5*cell.y+3.*iTime)*cos(.5*cell.x+3.*iTime);\n\tfloat boxes = udBox (p3, vec3 (.075), .02);\n\n    int matIndex = 0;\n    float dist = opCombine (boxes, ball, .1, matIndex);\n    int cellId = int (mod (floor (cell.y+cell.x), 2.)) + 1;\n    int matIds[3] = int[3] (cellId, 0, 3);\n    HitResult result = HitResult (dist, matIds[matIndex]);\n    return result;\n}\n\nHitResult raymarch (in vec3 ro, in vec3 rd)\n{\n\tfloat d = .0;\n\tfloat t = .0;\n    HitResult result = HitResult (.0, -1);\n\tfor (int i = 0; i < MAX_ITER; ++i) {\n\t\tresult = scene (ro + t*rd);\n\t\td = result.dist;\n\t\tif (abs (d) < EPSILON*(1. + .125*d)) break;\n\t\tt += d*STEP_BIAS;\n\t}\n    result.dist = t;\n\treturn result;\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n\tvec2 e = vec2 (epsilon, .0);\n\tfloat d = scene (p).dist;\n\treturn normalize (vec3 (scene (p + e.xyy).dist,\n\t\t\t\t\t\t\tscene (p + e.yxy).dist,\n\t\t\t\t\t\t\tscene (p + e.yyx).dist) - d);\n}\n\nfloat shadow (in vec3 p, in vec3 n, in vec3 lPos)\n{\n\tfloat distanceToLight = distance (p, lPos);\n\tfloat distanceToObject = raymarch (p + .01*n, normalize (lPos - p)).dist;\n\tbool isShadowed = distanceToObject < distanceToLight;\n\treturn isShadowed ? .1 : 1.;\n}\n\n// coder-colors ;)\nvec3[4] materials = vec3[4] (vec3 (.0, 1., .0),  // green\n                             vec3 (1., .5, .25), // orange\n                             vec3 (.25, .5, 1.), // purple\n                             vec3 (1., .0, .0)); // red\n\nvec3 shade (in vec3 ro, in vec3 rd, in float d, in vec3 n, in int matId)\n{\n\tvec3 p = ro + d*rd;\n\tvec3 amb = vec3 (.1);\n\tvec3 diffC = vec3 (1., .5, .3);\n\tvec3 specC = vec3 (1., .95, .9);\n\tvec3 diffC2 = vec3 (.3, .5, 1.);\n\tvec3 specC2 = vec3 (.9, .95, 1.);\n\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, n, lPos);\n    float sha2 = shadow (p, n, lPos2);\n    float lDist = distance (p, lPos);\n    float lDist2 = distance (p, lPos2);\n    float attenuation = 8. / (lDist*lDist);\n    float attenuation2 = 8. / (lDist2*lDist2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n    vec3 h = normalize (lDir - rd);\n    vec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n    vec3 diffTerm = sha * attenuation * diff * diffC;\n    vec3 diffTerm2 = sha2 * attenuation2 * diff2 * diffC2;\n    vec3 specTerm = (sha > .1) ? attenuation * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? attenuation2 * spec2 * specC2 : vec3 (.0);\n\n    vec3 color = materials[matId];\n\n    return amb + diffTerm*color + specTerm + diffTerm2*color + specTerm2;\n}   \n\nvec3 camera (in vec2 uv, in vec3 ro, in float zoom, in vec3 aim)\n{\n\tvec3 forward = normalize (aim - ro);\n\tvec3 worldUp = vec3 (.0, 1., .0);\n\tvec3 right = normalize (cross (forward, worldUp));\n\tvec3 up = normalize (cross (right, forward));\n\tvec3 center = normalize (ro + forward*zoom);\n\treturn normalize ((center + uv.x*right + uv.y*up) - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n\tfloat offset = 1.75;\n\tvec3 ro = vec3 (offset*cos(.2*iTime), .9, offset*sin(.2*iTime));\n\tvec3 aim = vec3 (-offset*.1*cos (iTime),.1,-offset*.1*sin (iTime));\n\tfloat zoom = 2.;\n\tvec3 rd = camera (uv, ro, zoom, aim);\n\n\tHitResult result = raymarch (ro, rd);\n\tfloat d = result.dist;\n\tfloat fog = 1. / (1. + d*d*.2);\n\tvec3 p = ro + d*rd;\n\tvec3 n = normal (p, d*EPSILON);\n\tvec3 col = shade (ro, rd, d, n, result.matId);\n\n\tcol *= fog;\n\t//vec3 sky = mix (vec3 (.1, .2, .5), vec3 (1., 1., .3), 1. - .05*p.y*p.y);\n\t//col = mix (col, sky, pow (1. - 1. / d, 20.));\n\tcol = mix (col, vec3 (.65, .7, .9), pow (1. - 1. / d, 20.));\n\tcol = col / (1. + col);\n\tcol *= vec3 (.8, .7, .6);\n\tcol = .2*col + .8*sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}