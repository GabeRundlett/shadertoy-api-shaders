{
    "Shader": {
        "info": {
            "date": "1532686720",
            "description": "mouse does things\ntime interpolates 2 linear extreme cases with a quadratic bezier (solves for 2 of 3 roots)\n\nmaybe use this function instead of length() for a kifs, to make the sharp corners of a kaleidoscopic image rounder.\nor as jumpriope",
            "flags": 0,
            "hasliked": 0,
            "id": "XttcD4",
            "likes": 6,
            "name": "bezier smoothmirror kifs rope",
            "published": 3,
            "tags": [
                "bezier",
                "rainbow",
                "rope"
            ],
            "usePreview": 0,
            "username": "ollj",
            "viewed": 575
        },
        "renderpass": [
            {
                "code": "\n\n//sign 2d quadratiic bezier distance scaled-almostidentity\n\n//parent: https://www.shadertoy.com/view/4ddXRH  \n//2d shape bezier fast old\n//based on:\n//-Adam Simmons(@adamjsimmons)2015: Signed Distance to a Quadratic Bezier Curve\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Playing around with beziers,trying to find a way to get a bounding area \n// so I can limit where the more complex part of the rootsolver is run. \n// No luck so far.\n//\n// Inspired by http://www.pouet.net/topic.php?which=9119\n// and various shaders by iq,T21,and demofox\n\n\n//in the end ,a  cos(a)*b should be the best solution.\n//in the end ,a  cos(a)*b should be the best solution.\n//in the end ,a  cos(a)*b should be the best solution.\n\n//View.Zoom\n#define ViewZoom 1.\n//View.Frame\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n\n#define u5(a)((a)*.5+.5)\n#define sat(a)clamp(a,0.,1.)\n#define dd(a)dot(a,a)\nfloat suv(vec2 a){return a.x+a.y;}\nfloat miv(vec2 a){return min(a.x,a.y);}\nfloat miv(vec3 a){return min(miv(a.xy),a.z);}\nfloat miv(vec4 a){return min(miv(a.xy),miv(a.zw));}\nvec4 minx(vec4 a,vec4 b){return mix(b,a,step(a.x,b.x));}//return the vec4 with the smaller .x\n\n//for rainbow gradient:\n//hermite interpolation core\n#define h3(r)r*r*(3.-2.*r)\nvec3 hue2rgb(float h){return sat(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.);}//return rgb of hue[0..1]\n//iq.HSV.Smooth: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c){vec3 r=hue2rgb(c.x);return c.z*mix(vec3(1),h3(r),c.y);}//return rgb of hsv\n\n//distance to line segment dot()/dd()approach.\nfloat sdSegment(vec2 a,vec2 b,vec2 p){b-=a;p-=a;return length(b*sat(dot(p,b)/dd(b))-p);}//return distance to line segment,unsigned,sides are not distinguished\n//float sdSegment(vec2 a,vec2 b,vec2 p){a-=p;b-=p;vec2 c=b-a;return length(a+c*sat(-dot(a,c)/dd(c)));}//return distance to line segment,unsigned,sides are not distinguished\n\n//----trace plane,in n dimensions==solve linear equation:\n//[t]RayDirection.normalize()d!! //[u]RayOrigin \n//[n]PlaneNormal .normalize()d!! //[o]PlaneOrigin==distance of plane to local coordinate origin vecN(0)\n//return distacne from [u] to intersection of ray with plane;;To offset the plane,-offset Rayorigin instead;u=u-n*o\n#define gPRxZ(n,u,t)-(dot(n,u)/dot(n,t))//second life wiki geometric,see gPRxZ()\n//return intersection of rayOrigin=u,raydirection=normalize(t),PlaneNormal=normalize(n),Plane_Distance-To_vecN(0)=o //offset sign flipped!!!\n#define slo(u,t,n,o)(u)-(t)*(dot(n,(u)+(n)*(o))/dot(n,t))\n#define sl(u,t,n)(u)-(t)*(dot(n,u)/dot(n,t))\n//get [y] of(bi)quadratic f(t);\nvec2 EvalQuadratic(vec2 A,vec2 B,vec2 C,float t){float u=1.-t;return u*u*A+2.*u*t*B+t*t*C;}\n//\n//--root solving calculates where a polynomial intersects with f(x)=0;\n//the smallest(positive)(non-imaginary)root is relevant for raytracing.\n//differentials anf quotients of 2 polynomials(long division)is relevant for bounts of rootsa of higher degree polynomials here.\n//solve linear;y=a+b*x ;for roots ;y=0;assert b!=0;\nfloat solveLinear(float a,float b){return -a/b;}//0.=a+b*x;/b  0.=a/b+x;-a/b;x=-a/b;\n//Solving a linear equation   ,and generalizing for more domains,you solve where a straight line intersects ANY hyperplane.\n//Solving a quadratic equation,and generalizing for more domains,you solve where a parabola intersects ANY hyperplane.\n//this is relatively simple;with a dot()/dot()projection,becoming equal to tracing a plane.\n// Solve cubic equation for roots\nvec3 solveCubic(vec3 a){float p=a.y-a.x*a.x/3.,p3=p*p*p,q=a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z,d=q*q+4.*p3/27.,o=-a.x/3.\n;if(d>=.0){vec2 v=(vec2(1,-1)*sqrt(d)-q)/2.;return vec3(o+suv(sign(v)*pow(abs(v),vec2(1./3.))));}\n;float v=acos(-sqrt(-27./p3)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);return vec3(m+m,-n-m,n-m)*sqrt(-p/3.)+o;}\n//while the 3rd root is rarely needed,n and m are already calculated,this just adds 1sub();\n//return if roughly equal within absolute bounds. //not sure if this is GENERALLY good,but its fine for my special case.\nbool rea(float s,float b,float e){b-=s;return(abs(s-.5*b)*e<abs(b));}//return(abs(b-a*.5)<a*e);//return(s<b-e||s>b+e);\n//return the signed(positive.y has a negative sign)distance from a point to a quadratic bezier curve\nfloat sdBezierS(vec2 A,vec2 B,vec2 C,vec2 p){\n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)))//force non-colinear,but there should be better solution to it.\n//;if(!(rea(A.y,C.y,.0001)))return sdSegment(A,C,p);//the used function is likely not generally correct,it is an unsigned segment!\n;vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p\n;vec2 t=sat(solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b))).xy\n;vec2 d1=d+(c+b*t.x)*t.x,d2=d+(c+b*t.y)*t.y;\n;vec4 r=minx(vec4(dd(d1),t.x,d1),vec4(dd(d2),t.y,d2));\n;vec2 g=2.*b*r.y+c;\n;float s=sign(g.y*r.z-g.x*r.w);\n;return s*sqrt(min(dd(A+(c+b*t.x)*t.x-p),dd(A+(c+b*t.y)*t.y-p)));}\n//\n//above is signed,below is unsigned\n//return unsigned(always positive)distance from a point to a quadratic bezier curve\nfloat sdBezier(vec2 A,vec2 B,vec2 C,vec2 p){\n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.-A-C)))//force non-colinear,but there should be better solution to it.\n;if(!(rea(A.y,C.y,.001)))return sdSegment(A,C,p);//this is fine,not great,but a good enough upper bound to swiwch to linear.\n;vec2 a=B-A,b=A-B*2.+C,c=a*2.,d=A-p\n;vec2 t=sat(solveCubic(vec3(3.*dot(a,b),2.*dd(a)+dot(d,b),dot(d,a))/dd(b))).xy\n;return sqrt(min(dd(A+(c+b*t.x)*t.x-p),dd(A+(c+b*t.y)*t.y-p)));}\n//\n//above is the older analytic-bezier root-solver,and it seems that its 3rd root is not needed for the constrains of this shader.\n//bu the 3rd root is relevant for some other less constrained cases?\n//\n//bewlow is a faster 2 root bezier solver,but it doesnt stop at the ControlPoints A or B,and the wrapAround sis bad here.\n//it breaks trough the contrains of the above,and ignores them.\n//return signed distance from a point to a bezier curve without clamping,2 roots are not enough here?\nfloat sdBezier2(vec2 A,vec2 B,vec2 C,vec2 p){   \n//;vec2 D=A+B+C;if(D.x==D.y)return sdSegment(A,B,p);//if colinear,treat as line segment(not correct,not conform to signing)\n//;B=mix(B+vec2(1e-4),B,abs(sign(B*2.0-A-C)));//force non-colinear,but there should be better solution to it.\n;vec2 a=B-A,b=A-B*2.0 + C,c=a*2.0,d=A-p;\n;vec2 t=solveCubic(vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a))/dd(b)).xy;\n;vec2 dp1=d+(c+b*t.x)*t.x\n;vec2 dp2=d+(c+b*t.y)*t.y\n;vec4 r=minx(vec4(dd(dp1),t.x,dp1),vec4(dd(dp2),t.y,dp2))\n;vec2 g=2.*b*r.y + c\n;return sqrt(r.x)\n;float s=sign(g.x*r.w-g.y*r.z)\n;return s*sqrt(r.x);}\n\n \nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 p=fra(fragCoord.xy)//(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n;vec4 m=vec4(fra(iMouse.xy),fra(iMouse.zw));\n;p.x=abs(p.x);//optional mirror symmetry demo\n;m.x=abs(m.x);//optional mirror symmetry demo\n;vec2 N=m.xy*.5\n;vec2 C=N*2.;\n//;float o=.5//height ooffset\n;float o=(sl(N,N-C,vec2(1,0))).x;o=mix(o,m.y,-u5(cos(iTime)))//mix smoothness for identity lines\n;vec2 A=vec2(0,-o);\n;vec2 B=slo(N,N-C,vec2(0,1),o);//;B=solveLinear2d(m.xy*2.,m.xy*2.-C);\n;float d=sdBezier(A,B,C,p);\nd=abs(d*9.-.05);\n;fragColor=vec4(vec3(smoothstep(.05,0.,d))+hue2rgb(d)*.1*fract(log(d)-iTime*.1),1.);\n}\n\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}