{
    "Shader": {
        "info": {
            "date": "1536245899",
            "description": "uncomment the target at code end.  Display not significant, only relative timings.\n\nFor me:\ngold=15fps (+biased sum?), classical2 = 20fps, classical3 = 20fps, DH2 = 12fps, DH3:12fps, GlibC = 8.6fps, GlibC3 = 16.5/3\nno differences with #precision",
            "flags": 0,
            "hasliked": 0,
            "id": "MlGcWD",
            "likes": 0,
            "name": "bench Gold Noise perf vs others",
            "published": 3,
            "tags": [
                "noise",
                "random",
                "static",
                "generator"
            ],
            "usePreview": 0,
            "username": "FabriceNeyret2",
            "viewed": 665
        },
        "renderpass": [
            {
                "code": "// uncomment target noise to test at the end\n\nprecision lowp    float;\n\n// --- \"Gold Noise random generator\" by dcerisano. https://shadertoy.com/view/ltB3zD\n// claims:\n// - based on the Golden Ratio, PI and the Square Root of Two\n// - superior distribution\n// - fastest noise generator function\n// - works with all chipsets (including low precision)\n\n//precision lowp    float;\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat gold_noise(in vec2 coordinate, in float seed){\n    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);\n}\n\n// --- classical hash\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash3(p) fract(sin(dot(p, vec3(12.9898, 78.233, -2.347))) * 43758.5453)\n\n// --- Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// --- IQ int hash II https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 Ghash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x) / float(0xffffffffU);\n}\n\n// -----------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 u){  \n    O -= O;\n    float N = 1e4;\n    for (float i=0.; i<N; i++) {\n        vec2 U =u+i; float t = iTime+i;\n\t    O  += gold_noise(U, t);      // gold, float\n\t  //O  += hash(U + t);           // classical2, float\n\t  //O  += hash3(vec3(U, t));     // classical3, float\n\t  //O  += hash12(U + t);         // DH2, int\n\t  //O  += hash13(vec3(U, t));    // DH3, int\n\t  //O  += Ghash(uvec3(U, t)).x;  // IQ/GlibC 3, int\n\t  //O.xyz+= Ghash(uvec3(U, t));  // IQ/GlibC 3, int -> vec3\n    }\n    O /= N;\n    \n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}