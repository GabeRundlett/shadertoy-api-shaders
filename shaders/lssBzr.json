{
    "Shader": {
        "info": {
            "date": "1494700435",
            "description": "Playing with fractals (first successful experiment). A lot more to be understood :) ",
            "flags": 0,
            "hasliked": 0,
            "id": "lssBzr",
            "likes": 17,
            "name": "[ #16 ] - Fractal gem",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "fractal",
                "glow"
            ],
            "usePreview": 0,
            "username": "Yrai",
            "viewed": 1189
        },
        "renderpass": [
            {
                "code": "#define res_           iResolution\n#define time_          iTime\n#define pi_            3.14159265\n#define tau_           2.*pi_\n\n#define dom(f,s)             (2. * f.xy - res_.xy) / res_.y * s\n#define ry(a)                mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define rz(a)                mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.)\n\n#define march_steps_         1250\n#define max_range_           2048.\n\n#define hit_perc_            .0001\n#define grad_perc_           .001\n#define dist_perc_           .9\n\n#define rot_speed_           .22\n#define fractal_iters_       6\n#define fractal_divergence_  2140.\n\n\nfloat de(vec3 p);\nvec3  normal(vec3 p);\nmat3  look_at(vec3 ro, vec3 ta, float roll);\n\n\nvoid mainImage(out vec4 o, vec2 f) {\n\t// Domain x -> [-2., 2.]; y-> [-1., 1.]  & xn, yn -> [0., 1.]\n    // -----------------------------------------------------------\n    vec2 p  = dom(f, 1.); vec2 np = f / res_.xy;\n    \n    // Camera\n    // -----------------------------------------------------------\n    vec3 ro = vec3(0., 1.2, 1.4); vec3 target = vec3(0.);\n    mat3 lam = look_at(ro, target, 0.);    \n\tvec3 rd = normalize(lam * vec3(p.xy, .5));\n    \n    // Raytracing\n    // -----------------------------------------------------------\n    vec3 pos, nor = vec3(0.);\n    float d, step_, iters = 0.;\n    for(int i = 0; i < march_steps_; i++) {\n        pos    = ro + step_ * rd;\n        d      = de(pos);\n        step_ += d * dist_perc_;\n        iters++;\n    \tif(d < hit_perc_ || d > max_range_) break;    \n    }\n    \n    vec3 c = vec3(.0);\n    if(d < hit_perc_) {\n    \t// Obtain hit pos and normal\n        // --------------------------------------------------------\n        pos = ro + step_ * rd;\n        nor = normal(pos);\n\n        // Lightning\n        // --------------------------------------------------------\n        vec3 lg = vec3(0.345);\n        float diff = clamp(0., 1., 1. + dot(rd, nor) );\n        float spec = clamp(0., 1., dot(nor, lg) );\n        float lm = diff + .4*spec;\n        \n        // Shading\n        // --------------------------------------------------------\n        vec3 mat = vec3(1.9, .5 + clamp(0., 1., pos.y), .1);\n        mat.b += fract(length(nor))*length(rd);\n        c = mix(c, mat, lm);\n    }\n    else {\n    \t// Missed fractal\n        // ---------------------------------------------------------\n        c = smoothstep(0.5, 1.7, abs(vec3(log(log(iters)) - .7 * vec3(2., .4, .3))));\n    }\n        \n    \n    // Post-processing\n    // ----------------------------------------------------------------\n    c = pow(c, vec3(2.5));\n    \n    o = vec4(c, 1.);\n}\n\nvec2 zcos(vec2 z) {\n    vec2 d = vec2(exp(z.y), exp(-z.y));\n \treturn vec2(cos(z.x) * (d.x+d.y)*.5, -sin(z.x) * (d.x-d.y)*.5);\n}\n\nfloat de(vec3 p) {\n   \tp *= ry(time_ * rot_speed_) * rz(time_ * rot_speed_);\n    \n    vec3  c  = vec3(0.);\n    float r  = length(p);\n\tfloat dr = 1.;\n\n\tfor(int i = 0; i < fractal_iters_; i++){\n\t\tif(r > fractal_divergence_)\n            break;\n\t\t\n        float psi = abs(mod(atan(p.z ,p.y) + pi_/4., pi_/4.) - pi_/8.);\n\t\tp.yz = vec2(cos(psi), sin(psi)) * length(p.zy);\n\t\t\n        vec3 p2 = p * p;\n\t\tp = vec3(vec2(p2.x - p2.y, 1.5 * p.x * p.y), 2.*p.z * sqrt(p2.x + p2.y)) + c;\t\n        \n\t\tdr *= 1. / r + 2.*r;\n        r   = 1.2*length(p);\n\t}\n    \n\treturn log(r) * r / dr;    \n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(grad_perc_, .0);\n    return normalize(vec3(\n        de(p+e.xyy)-de(p-e.xyy),\n        de(p+e.yxy)-de(p-e.yxy),\n        de(p+e.yyx)-de(p-e.yyx)\n    ));\n}\n\nmat3 look_at(vec3 ro, vec3 ta, float roll) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}