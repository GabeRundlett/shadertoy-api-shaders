{
    "Shader": {
        "info": {
            "date": "1663875723",
            "description": "Abstract animated procedural background using a bit of geometry.",
            "flags": 0,
            "hasliked": 0,
            "id": "NlGBzR",
            "likes": 3,
            "name": "Anim Background 01 - by hugolnx",
            "published": 3,
            "tags": [
                "procedural",
                "animated",
                "abstract",
                "background",
                "geometry",
                "hugolnx"
            ],
            "usePreview": 0,
            "username": "hugolnx",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "#define SHADERTOY 1\n// GITHUB: https://github.com/HugoLnx/shaders-laboratory/tree/master/shaders/pattern-background-01\n\n//#define SEEDROLL 1\n\n// Aux simple functions\n#define TWO_PI 6.283185\n#define PI 3.14159\nfloat norm(float x) { return x*.5 + .5; }\nfloat denorm(float x) { return x*2. - 1.; }\nfloat xstep(float b, float e, float v) {\n    return step(b, v) - step(e, v);\n}\nfloat xsmoothstep(float b, float e, float v) {\n    return smoothstep(b, e, v) - step(e, v);\n}\nfloat flatten(float v, float layers) {\n  return floor(v*layers) * (1./layers);\n}\nfloat flattenfull(float v, float layers) {\n  return floor(v*layers)/(layers-1.);\n}\nfloat nsin(float t) {return norm(sin(t * TWO_PI));}\nfloat ncos(float t) {return norm(cos(t * TWO_PI));}\nfloat ntan(float t) {return norm(tan(t * TWO_PI));}\nfloat sat(float t) {return clamp(t, 0., 1.);}\nfloat rsat(float t) {return mod(t+10000.0, 1.);}\nfloat xclamp(float v, float minV, float maxV) {\n  return clamp(v, minV, maxV) * xstep(minV, maxV, v);\n}\nfloat xclampnorm(float v, float minV, float maxV) {\n  return (xclamp(v, minV, maxV) - minV) / (maxV-minV);\n}\nvec3 togrey(vec3 c) {\n  return vec3((c.r+c.g+c.b)/3.);\n}\nfloat normrange(float v, float minV, float maxV) { return sat((v-minV)/(maxV-minV)); }\nfloat xnormrange(float v, float minV, float maxV) { return normrange(v, minV, maxV) * xstep(minV, maxV, v); }\nvec3 mix3(vec3 cMin, vec3 cMid, vec3 cMax, float t) {\n  float t1 = normrange(t, -1., 0.);\n  float t2 = normrange(t, 0., 1.);\n  vec3 c = mix(cMin, cMid, t1);\n  c = mix(c, cMax, t2);\n  return c;\n}\n\nvec2 rotate(vec2 v, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c) * v;\n}\n\nvec3 compose(vec3 ocolor, float intensity, vec3 color) {\n  intensity = sat(intensity);\n  return mix(ocolor, color, intensity);\n}\n\nfloat stepang(vec2 uv, vec2 center,\nfloat minang, float maxang, float rot) {\n  uv -= center;\n  float angle = atan(uv.y, uv.x);\n  angle = mod(angle + TWO_PI*10., TWO_PI);\n  minang = mod(minang + rot + TWO_PI*10., TWO_PI);\n  maxang = mod(maxang + rot + TWO_PI*10., TWO_PI);\n  float iss1 = step(minang, maxang);\n  float niss1 = 1. - iss1;\n  float s1 = iss1*xstep(minang, maxang, angle);\n  float s2 = niss1*xstep(minang, TWO_PI, angle);\n  float s3 = niss1*xstep(0., maxang, angle);\n  float s4 = xstep(.0, .0001, abs(minang-maxang));\n  return sat(s1+s2+s3+s4);\n}\n\n#define RED vec3(1., 0., 0.)\n#define GRE vec3(0., 1., 0.)\n#define BLU vec3(0., 0., 1.)\n#define WRED vec3(1., .8, .8)\n#define WGRE vec3(.8, 1., .8)\n#define WBLU vec3(.8, .8, 1.)\n#define BLU2 vec3(0.35, 0.5, 1.)\n#define PUR vec3(1., 0., 1.)\n#define YEL vec3(1., 1., 0.)\n#define CYA vec3(0., 1., 1.)\n#define WHI vec3(1.)\n#define BLA vec3(0.)\n#define BLANK vec3(0.35, 0., 0.35)\n\n#ifndef SHADERTOY\nuniform sampler2D iChannel0;\nuniform float iTime;\nuniform vec2 iResolution2D;\n#define iResolution vec4(iResolution2D, 0., 0.)\nout vec4 outColor;\n#endif\n\nfloat rand(vec2 uv, float seed, float seedModifier){\n  seed += seedModifier;\n  uv *= seed+1937.71;\n  return fract(sin(\n    dot(uv, vec2(12.9898, 78.233)) + seed\n  ) * 43758.5453);\n}\nfloat rand(float x, float seed, float seedModifier) {\n  return rand(vec2(x, x+197.937), seed, seedModifier);\n}\nfloat circle(vec2 uv, vec2 center, float radius) {\n  uv -= center;\n  float dist = length(uv);\n  return step(dist, radius);\n}\n\nfloat doline(vec2 uv, vec2 pt1, vec2 pt2, float linewidth) {\n  vec2 v = pt2 - pt1;\n  uv -= pt1;\n  float vlen = length(v);\n  vec2 vhead = v / vlen;\n  float proj = dot(vhead, uv);\n  vec2 vproj = vhead * proj;\n  float toLine = length(uv - vproj);\n  return (1.-step(linewidth, toLine)) * xstep(0., vlen, proj);\n}\n\n#define PIECOLORCOUNT 3\n#define STRIPECOLORCOUNT 3\n//#define ZOOMGRID 1\n//#define MOBILE_SHADER_EDITOR 1\n\n#ifdef MOBILE_SHADER_EDITOR\n#define iResolution resolution\n#define iTime time\n#endif\n\nvec3 composeLine(vec3 ocolor, vec2 uv, vec2 guv, float t, float appearRate, float lineSeedMod,\nfloat seedModifier, vec3[STRIPECOLORCOUNT] stripecolors, vec2 linePt1, vec2 linePt2) {\n  float lineWidth = 0.075;\n  float maxTimeOffset = 100.;\n  float frameDuration = 2.;\n  float tRand = rand(guv, 771.339*lineSeedMod, seedModifier);\n  float tOffset = (tRand-.5)*2. * maxTimeOffset;\n  t += tOffset;\n  float frameInx = floor(t / frameDuration);\n  float frameTime = mod(t, frameDuration);\n  float frameStart = normrange(frameTime, 0., 1.);\n  float nFrameTime = normrange(frameTime, 0., frameDuration);\n  float frameEnd = 1.-normrange(frameTime, frameDuration-1., frameDuration);\n  float frameMod = frameInx * 372.297;\n\n  float invRand = step(.5, rand(guv, 771.339*lineSeedMod, seedModifier+frameMod));\n  vec2 pt1 = invRand == 1. ? linePt1 : linePt2;\n  vec2 pt2 = invRand == 1. ? linePt2 : linePt1;\n  float line = doline(uv, pt1, pt1+(pt2-pt1)*nFrameTime, lineWidth);\n\n  float dRand = rand(guv/17.73, 117.994*lineSeedMod, seedModifier+frameMod);\n  line *= step(1.-appearRate, dRand);\n  line *= frameStart * frameEnd * .5;\n\n  float colorRand = rand(guv, 171.274*lineSeedMod, seedModifier+frameMod);\n  int colorInx = int(floor(colorRand*float(STRIPECOLORCOUNT)));\n  vec3 stripecolor = stripecolors[colorInx];\n  vec3 color = compose(ocolor, line, stripecolor);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float mx = max(iResolution.x, iResolution.y);\n  vec2 ct = iResolution.xy / mx / 2.0;\n  vec2 uv = fragCoord/mx - ct;\n#ifndef MOBILE_SHADER_EDITOR\n  uv /= 2.5;\n#endif\n  vec2 ouv = uv;\n  float t = iTime;\n#ifdef SEEDROLL\n  float seedModifier = floor(t*.33);\n#else\n  float seedModifier = 0.;\n#endif\n\n#ifdef MOBILE_SHADER_EDITOR\n  float radius = .35;\n  float minRadiusVar = .35;\n#else\n  float radius = .45;\n  float minRadiusVar = .5;\n#endif\n  float maxCentervar = (.5-radius)*.5*0.95;\n#ifdef ZOOMGRID\n  float gridScale = 15.;\n#else\n  float gridScale = 40.;\n#endif\n  vec3[PIECOLORCOUNT] piecolors;\n  piecolors[0] = vec3(1., .4, .4);\n  piecolors[1] = vec3(1., .4, .7);\n  piecolors[2] = vec3(1., .7, .4);\n\n  vec3[STRIPECOLORCOUNT] stripecolors;\n  float lo = 0.75;\n  stripecolors[0] = vec3(lo, lo, 1.);\n  stripecolors[1] = vec3(1., lo, lo);\n  stripecolors[2] = vec3(lo, 1., lo);\n\n  uv *= gridScale;\n  vec2 guv = floor(uv);\n  uv = fract(uv);\n  uv -= .5;\n  vec2 center = vec2(.0);\n\n  float angsize = flattenfull(rand(guv, 137.791, seedModifier), 3.);\n  angsize = mix(PI/4.*3., PI/4.*7., angsize);\n  float rotlayers = 5.;\n  float pierot = flattenfull(rand(guv, 737.197, seedModifier), 4.);\n  pierot = mix(PI/2., TWO_PI, pierot);\n\n  int piecolorinx = int(floor(\n    rand(guv, 397.917, seedModifier)*float(PIECOLORCOUNT)\n  ));\n\n  float radiusvar = flattenfull(rand(guv, 587.173, seedModifier), 3.);\n  radiusvar = mix(minRadiusVar, 1., radiusvar);\n  //radiusvar = 1.;\n\n  vec2 centervar = vec2(\n    flattenfull(rand(guv.xy, 345.123, seedModifier), 3.),\n    flattenfull(rand(guv.yx, 354.132, seedModifier), 3.)\n  );\n  centervar = (centervar-.5)*2.;\n  centervar *= maxCentervar;\n  //center += centervar; \n\n  float pie = circle(uv, center, radius*radiusvar);\n  pie *= stepang(uv, center, 0., angsize, pierot);\n\n  float dotradius = flattenfull(rand(guv, 897.217, seedModifier), 3.);\n  dotradius = mix(.03, .15, dotradius);\n  float hasdot = step(.96, rand(guv, 227.994, seedModifier));\n  float dotted = hasdot*circle(uv, center, dotradius);\n\n\n  float npie = 1.-pie;\n  float ndotted = 1.-dotted;\n\n  vec3 color = vec3(0.);\n\n\n  vec2 diaguv = ouv;\n  diaguv *= gridScale;\n  diaguv -= .5;\n  vec2 diagGuv = floor(diaguv);\n  diaguv = fract(diaguv);\n  diaguv -= .5;\n\n  vec2 xuv = ouv;\n  xuv *= gridScale;\n  xuv.x -= .5;\n  vec2 xGuv = floor(xuv);\n  xuv = fract(xuv);\n  xuv -= .5;\n\n  vec2 yuv = ouv;\n  yuv *= gridScale;\n  yuv.y -= .5;\n  vec2 yGuv = floor(yuv);\n  yuv = fract(yuv);\n  yuv -= .5;\n  float diagAppearRate = .4;\n  float axisAppearRate = .3;\n  color = composeLine(color, diaguv, diagGuv, t, diagAppearRate, 0.  , seedModifier, stripecolors, vec2(-.5), vec2(.5));\n  color = composeLine(color, diaguv, diagGuv, t, diagAppearRate, 132., seedModifier, stripecolors, vec2(-.5, .5), vec2(.5, -.5));\n  color = composeLine(color, xuv, xGuv, t, axisAppearRate, 212., seedModifier, stripecolors, vec2(-.5, .0), vec2(.5, .0) );\n  color = composeLine(color, yuv, yGuv, t, axisAppearRate, 398., seedModifier, stripecolors, vec2(.0, .5), vec2(.0, -.5) );\n\n  color = compose(color, ndotted*pie, piecolors[piecolorinx]);\n\n  fragColor = vec4(color, 1.0);\n}\n\n#ifndef SHADERTOY\nvoid main()\n{\n  mainImage(outColor, gl_FragCoord.xy);\n}\n#endif",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}