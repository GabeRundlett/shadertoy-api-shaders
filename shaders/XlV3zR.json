{
    "Shader": {
        "info": {
            "date": "1472765278",
            "description": "Just playing with some shaders by Shane ([url=https://www.shadertoy.com/view/4l2XWK]#1[/url], [url=https://www.shadertoy.com/view/XsGXDV]#2[/url]) and dila ([url=https://www.shadertoy.com/view/MsSSRV]#3[/url]). Best viewed on fullscreen.",
            "flags": 0,
            "hasliked": 0,
            "id": "XlV3zR",
            "likes": 17,
            "name": "Bumpy Mobius Spiral",
            "published": 3,
            "tags": [
                "spiral",
                "mobius",
                "bumpmapping"
            ],
            "usePreview": 0,
            "username": "revers",
            "viewed": 1026
        },
        "renderpass": [
            {
                "code": "/**\n * Created by Kamil Kolaczynski (revers) - 2016\n *\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader is based on:\n *\n * - \"Bumped Sinusoidal Warp\" by Shane [ https://www.shadertoy.com/view/4l2XWK ]\n * - \"Mobius Sierpinski\" by Shane [ https://www.shadertoy.com/view/XsGXDV ]\n * - \"Mobius\" by dilla [ https://www.shadertoy.com/view/MsSSRV ]\n *\n * Thanks for sharing the code guys!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n/**\n * true - concave bumps, false - convex bumps\n * Thanks, Shane!\n */\nconst bool InvertNormal = true;\n\nconst float SpiralDensity = 0.2;\nconst float SpiralZoom = 0.5;\nconst int SpiralArms = 5;\nconst float BumpPower = 0.10150138;\nconst float BumpFactor = 0.0066746245;\nconst float LightSize = 2.9176579;\nconst float SampleDistance = 0.7;\nconst bool AntiAlias = true;\n\n#define TWO_PI 6.2831852\n\nvec2 cmul(vec2 a, vec2 b) {\n\treturn a * mat2(b.x, -b.y, b.y, b.x);\n}\n\nvec2 cinv(vec2 z) {\n\treturn vec2(z.x, -z.y) / dot(z, z);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n\treturn cmul(a, cinv(b));\n}\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn cdiv(cmul(a, z) + b, cmul(c, z) + d);\n}\n\nvec3 tex(vec2 uv) {\n\tfloat time = iTime * 0.1;\n\tvec2 t = vec2(sin(time), 0.0);\n\n\tvec2 A = vec2(cos(time * 5.0), sin(time * 5.0));\n\tvec2 B = vec2(0.0, 0.0);\n\tvec2 C = t * cos(iTime * 0.25) * 10.0;\n\tvec2 D = vec2(1.0, 1.0);\n\n\tuv = mobius(uv, A, B, C, D);\n\n\tfloat arm = float(SpiralArms);\n\tfloat den = SpiralDensity;\n\tfloat zoom = SpiralZoom;\n\tvec2 phase = vec2(-1.0, 1.0) * iTime * 0.125;\n\n\tfloat a1 = atan(uv.y, uv.x) / TWO_PI;\n\tfloat a2 = atan(uv.y, abs(uv.x)) / TWO_PI;\n\tfloat d = log(length(uv));\n\n\tvec2 uvL = vec2(a1 * arm + d * den, a1 - d * zoom) + phase;\n\tvec2 uvR = vec2(a2 * arm + d * den, a2 - d * zoom) + phase;\n\n\t// https://iquilezles.org/articles/tunnel\n\tvec3 col = textureGrad(iChannel0, uvL, dFdx(uvR), dFdy(uvR)).xyz;\n\n\tcol = pow(col, vec3(2.2));\n\treturn col;\n}\n\nfloat intensity(vec3 p) {\n\treturn p.x * 0.299 + p.y * 0.587 + p.z * 0.114;\n}\n\nfloat bump(vec2 p) {\n\treturn pow(intensity(tex(p)), BumpPower);\n}\n\nvec3 color(vec2 p) {\n\tp *= 0.5;\n\n\tvec3 pos = vec3(p, 0.0);\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n\tvec3 lig = vec3(cos(iTime) * 0.5, sin(iTime) * 0.2, -1.0) * LightSize;\n\tvec3 nor = vec3(0.0, 0.0, -1.0);\n\n\tvec2 eps = vec2(0.0002, 0.0);\n\tvec2 grad = vec2(\n        \tbump(pos.xy - eps.xy) - bump(pos.xy + eps.xy),\n\t\t\tbump(pos.xy - eps.yx) - bump(pos.xy + eps.yx)) / (2.0 * eps.xx);\n    \n    if (InvertNormal) {\n        grad = -grad;\n    }\n\n\tfloat r = pow(length(p), 0.1);\n\n\tnor = normalize(nor + vec3((grad), 0.0) * BumpFactor * r);\n\tvec3 ld = normalize(lig - pos);\n\n\tfloat dif = max(dot(nor, ld), 0.0);\n\n\tvec3 ref = reflect(-ld, nor);\n\tfloat spe = pow(max(dot(ref, -rd), 0.0), 32.0);\n\n\tvec3 texCol = tex(pos.xy);\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += dif * vec3(1, 0.97, 0.92) * texCol * 0.7;\n\tbrdf += spe * vec3(1.0, 0.6, 0.2) * 2.0;\n\n\treturn clamp(brdf, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\tvec3 col = vec3(0.0);\n\n\tif (AntiAlias) {\n\t\tfloat sdi = SampleDistance;\n\t\tvec2 p0 = ((fragCoord.xy + vec2(0.0, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p1 = ((fragCoord.xy + vec2(sdi, 0.0)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p2 = ((fragCoord.xy + vec2(sdi, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\t\tvec2 p3 = ((fragCoord.xy + vec2(0.0, sdi)) / iResolution.xy * 2.0 - 1.0) * aspect;\n\n\t\tcol = (color(p0) + color(p1) + color(p2) + color(p3)) / 4.0;\n\t} else {\n\t\tcol = color((fragCoord.xy / iResolution.xy * 2.0 - 1.0) * aspect);\n\t}\n\tcol = pow(col, vec3(0.4545));\n    \n\tfragColor = vec4(col, 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 2,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}