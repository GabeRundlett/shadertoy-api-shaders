{
    "Shader": {
        "info": {
            "date": "1597588823",
            "description": "Source Link : https://www.youtube.com/watch?v=qWk_ubAKosE\nMy Game : https://play.google.com/store/apps/details?id=com.BigBUFF.OnetIconConnect",
            "flags": 0,
            "hasliked": 0,
            "id": "tlXfWS",
            "likes": 7,
            "name": "14. Drive Home 5 - Environment L",
            "published": 3,
            "tags": [
                "drivehome"
            ],
            "usePreview": 0,
            "username": "altera0",
            "viewed": 1279
        },
        "renderpass": [
            {
                "code": "\n#define S( a , b , t ) smoothstep( a , b , t )\n\nstruct Ray {\n\tvec3 ro;\t\t// Ray Origin\n    vec3 rd;\t\t// Ray Direction\n};\n\n    \n\n// Noise\nfloat Noise(float t) {\n    float n = fract( sin( t * 3456.) * 4547. ) ;\n    return n;\n}\n\n// Noise 1 Input and 4 Output\nvec4 Noise14(float t ) {\n    vec4 n = fract( sin( t * vec4(123. , 1024. , 3456. , 9564. ) ) * vec4( 6547., 345., 8799., 1564. ) );    \n    return n;\n}\n\n\n// RAY\nRay GetRay( vec2 uv , vec3 camPos , float camZoom , vec3 lookAt ) {\n \n    Ray ray;\n     \n    ray.ro = camPos;\n    \n    vec3 F = normalize( lookAt - camPos );\n    vec3 R = normalize( cross( vec3( 0 , 1 , 0 ) , F ) );\n    vec3 U = cross( F , R );\n    \n    vec3 center  = camPos + F * camZoom;\n    vec3 intersectionPoint = center + uv.x * R  + uv.y * U;\n    \n    // rd have to do normalized.\n    // because where GetClosestPoint() , dot ( target - ro , rd ) * rd.\n    ray.rd = normalize( intersectionPoint - camPos );\n    \n    return ray;\n}\n\n\n// \nvec3 GetClosestPoint( Ray ray , vec3 targetPos ) {\n   \n    // 이때 반드시, rd가 노멀라이즈 되어 있어야,\n    // dot( targetPos - ray.ro , ray.rd )가 정확하게 계산이 된다.\n    return ray.ro + max( 0.0f , dot( targetPos - ray.ro , ray.rd ) ) * ray.rd;\n}\n\n\n// \nfloat GetDistance( Ray ray , vec3 targetPos ) {\n\tfloat d = length( targetPos - GetClosestPoint( ray , targetPos ) );\n    return d;\n}\n\n\n// BOKE\nfloat Boke(  Ray ray , vec3 targetPos ,  float lightDiameter , float blur ) {\n    \n    //vec3 targetPos = vec3( -1.0f , 0.15f , z );\n    float d = GetDistance( ray , targetPos );\n    float expandLight = lightDiameter * length( targetPos );\n    //c += Boke( d , expandLight , bokeBlur ) * fade;\n         \n\tfloat c = S( expandLight , expandLight * ( 1.0f - blur ) , d );\n    c *= mix( 0.7f , 1.0f , S( expandLight * 0.8f , expandLight , d ) );\n    return c;\n}\n\n\n\n\n// Street Light\nvec3 StreetLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    float c = 0.0f;\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        vec3 targetPos = vec3( 2.0f , 2.0f , 100.0f - ti * 100.0f );\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * ti * ti * ti;\n    }\n         \n    vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    return col;\n}\n\n\n// Head Light\nvec3 HeadLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 2.0f;\n    \n    float c = 0.0f;\n    float t = time * 0.1f;\n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\n\t\tif ( n > 0.1f ) continue;\n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n            \n        c += Boke( ray , vec3( -headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( -headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( +headLightDelta2 + -1.0f , 0.15f , z ) , size , bokeBlur ) * fade;\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( -headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( +headLightDelta2 + -1.0f , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    //vec3 col = vec3( 1.0f , 1.7f , 0.3f) * c;\n    vec3 col = vec3( 0.9f , 0.9f , 1.0f) * c;\n    \n    return col;\n}\n\n\n// Tail Light\nvec3 TailLights( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n\t\n    float headLightDelta = -0.25f;\n    float headLightDelta2 = headLightDelta* 1.2f;\n    \n    \n    time = time * 0.1f;\n    \n    float c = 0.0f;\n    //float t = time * 0.1f;\n    float t = time;\n    \n    float s = 1.0f / 15.0f; // in 1 sec, 100 count.\n    //float side = step( ray.rd.x , 0.0f );\n    //ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t \n        float n = Noise( i );\t\t\t// 0 ~ 1\n\t\tif ( n > 0.5f ) continue;\t\t// 0 ~ 0.5\n        \n        \n        \n        float ti = fract(t + i);\n        float z = 100.0f - ti * 100.0f;\n        float fade = ti * ti * ti * ti * ti;\n        float focus = S( 0.8f , 1.0f , ti );\n        float size = mix( lightDiameter , lightDiameter * 0.5f , focus );\n        \n        float lane = step( 0.25f , n );\t// 0 , 1\n        float laneShift = S(0.99f, 0.96f , ti );\n        float carPos = 1.5f - lane * laneShift;\n            \n        float blink = step( 0.0 , sin( t * 10000.0)) * 7.0f * lane * step( 0.9f , ti );\n        \n        c += Boke( ray , vec3( carPos -headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta , 0.15f , z ) , size , bokeBlur ) * fade;\n\n        c += Boke( ray , vec3( carPos -headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade;\n        c += Boke( ray , vec3( carPos +headLightDelta2 , 0.15f , z ) , size , bokeBlur ) * fade * (1.0f + blink);\n      \n    \n    \t// refection\n        float reflection = 0.0f;\n        \n        reflection += Boke( ray , vec3( carPos -headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        reflection += Boke( ray , vec3( carPos +headLightDelta2 , -0.15f , z ) , size * 3.0f , 1.0f ) * fade;\n        \n        c += reflection * focus;\n    }\n         \n    \n    vec3 col = vec3( 1.0f , 0.1f , 0.01f) * c;\n    \n    return col;\n}\n\n\n\n// Environment Light\nvec3 EnvironmentLight( Ray ray , float lightDiameter, float bokeBlur , float time ) {\n    vec3 c = vec3(0);\n    \n    float t = time * 0.1f;\n    float s = 1.0f / 10.0f; // in 1 sec, 100 count.\n    float side = step( ray.rd.x , 0.0f );\n    ray.rd.x = abs( ray.rd.x ); // reflect ray x\n    \n    vec3 col = vec3(0.);\n    \n    for ( float i = 0.0f ; i < 1.0f ; i+=s ) {    \n    \t\n        float ti = fract(t + i + side * s * 0.5f );\n        \n        vec4 n = Noise14( i + side * 100. );\n        float x = mix( 2.5f , 10.f , n.x );\n        float y = mix( 0.1f , 1.5f , n.y );\n        \n        float occulution = sin( ti * 6.28 * 10.0 ) * 0.5f + 0.5f; // 2 pie\n        float fade = ti * ti * ti;\n        fade = occulution;\n        \n        \n        vec3 targetPos = vec3( x , y , 50.0f - ti * 50.0f );\n        \n        col = n.wzy;\n        c += Boke( ray , targetPos , lightDiameter , bokeBlur ) * fade * col * 0.5f;\n    }\n         \n    //vec3 col = vec3( 1.0f , 0.7f , 0.3f) * c;\n    //return col;\n    return c;\n}\n\n\n// MAIN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / min( iResolution.x, iResolution.y);\n\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    //float m = length( mouseUv );\n    \n\n\tvec3 camPos = vec3( 0.5f , 0.2f , 0.0f );\n    vec3 lookAt = vec3( 0.5f , 0.2f , 1.0f );\n    float camZoom = 2.0f;\n    \n    \n    \n    float streetLightDiameter = 0.05f;\n    float headLightDiameter = 0.05f;\n    float bokeBlur = 0.1f;\n    \n    \n    Ray ray = GetRay( uv , camPos , camZoom , lookAt );\n    \n\n\tvec3 col = StreetLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= HeadLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= TailLights(ray , headLightDiameter , bokeBlur, iTime + mouseUv.x );\n    col+= EnvironmentLight( ray , streetLightDiameter , bokeBlur, iTime + mouseUv.x );\n    \n    \n    // Back ground Gradient color\n    col+= ( ray.rd.y + 0.25f ) * vec3( 0.2f , 0.1f, 0.5f );\n    \n    fragColor = vec4( col ,1.0);\n}",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}