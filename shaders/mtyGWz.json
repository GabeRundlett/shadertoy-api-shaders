{
    "Shader": {
        "info": {
            "date": "1685392221",
            "description": "All year long I'm going to just focus on truchet tiles and the likes!\n",
            "flags": 0,
            "hasliked": 0,
            "id": "mtyGWz",
            "likes": 19,
            "name": "Year of Truchets #027",
            "published": 3,
            "tags": [
                "2d",
                "truchet",
                "city",
                "track",
                "cars"
            ],
            "usePreview": 0,
            "username": "byt3_m3chanic",
            "viewed": 272
        },
        "renderpass": [
            {
                "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Year of Truchets #027\n    05/29/2023  @byt3_m3chanic\n    Truchet Core \\M/->.<-\\M/ 2023 \n    \n    @jorge2017a2 said my last truchet looked like a\n    car track - https://www.shadertoy.com/view/cltSzN\n    \n    so attempting a 2D version. Cross parts make \n    it hard cause direction - so faking it..\n    \n    @Shane & @iq for compact noise in common tab\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\n// scale - set in main\nfloat scale = 4.;\n\nconst float tc = .1;     // track thickness\nconst float trs = .75;     // threshold for cross tile\nconst float spd = .465;    // speed\nconst float amt = 3.;      // number of cars\nconst float amx = 2.;      // cross track cars\n\n// car params\nconst vec2 bx = vec2(.165,.1);\nconst vec2 bt = bx*.25;\nconst vec2 bk = vec2(.1,.13);\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec3 hue(float a) { return .55+.45*sin(PI*a*vec3(1,.97,.93)*vec3(0.898,0.204,0.875));}\nfloat hash21(vec2 a) { return fract(sin(dot(a, vec2(27.609, 47.583)+iDate.z))*43758.5453);}\n\n//@iq sdf\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    if(R.x>1200.) scale = 7.; //up scale on fullscreen\n    \n    vec3 C = vec3(.06,.38,.07);\n    vec3 G = vec3(.38,.29,.06);\n    \n    // set uv\n    vec2 uv = (2.*F-R.xy)/max(R.x,R.y);\n    \n    // scale + move + rotate\n    uv *= scale;\n    uv *= rot(.06*sin(T*.12));\n    uv += vec2(1.3*sin(T*.1),T*.2);\n    \n    // setup px + id and grid uv\n    float px = fwidth(uv.x); \n    vec2 id = floor(uv);\n    vec2 q = fract(uv)-.5;\n \n    // hash and every other check\n    float hs = hash21(id);\n    float ck = mod(id.x+id.y,2.)*2.-1.;\n    if(hs>.5) q.x = -q.x;\n    \n    float pt = fbm(vec3(id.x,0,id.y)*2.45);\n    pt = smoothstep(.5,.8,pt);\n    C = mix(C,G,clamp(pt,0.,1.));\n    C = mix(C,C*vec3(.1,.1,0),hs*.5);\n\n    vec2 uv2 = vec2(length(q-.5),length(q+.5));\n    vec2 p = uv2.x<uv2.y? q-.5 : q+.5;\n\n    // main pattern\n    float d = length(p)-.5;\n    d = abs(d)-tc;\n\n    float d2 = abs(max(abs(q.x),abs(q.y))-.5)-.005;\n    float c = min(length(q.x)-tc,length(q.y)-tc);\n    if (hs>trs) d = c;\n\n    // moving truchet parts\n    vec2 arc = q-sign(q.x+q.y+.001)*.5;\n    float angle = atan(arc.x, arc.y);\n    float ud = length(arc);\n\n    float x = fract(amt*ck*angle/PI+T*spd);\n    float y = (ud/.5)-.5;\n\n    vec2 cid = vec2(floor(ud-(.5-tc))/(2.*tc),floor(amt*ck*angle/PI+T*spd));\n    vec3 K = hue((mod(cid.y,amt)+5.)*25.9);\n\n    // direction operation\n    if(hs<.5 ^^ ck>0.) y=1.-y;\n    \n    vec2 tuv = vec2(x,y);\n    float k = box(tuv-.5,bx)-.015; \n    float kt= box(abs(tuv-.5)-bk,bt); \n    float kw= box(tuv-vec2(.45,.5),vec2(.04,.07))-.02; \n    \n    // cross track changes\n    if (hs>trs) {\n        x = fract(amx*ck*abs(q.x)-T*spd);\n        y = (q.y+.25)*2.;\n        tuv = vec2(x,y);\n        \n        y = fract(amx*ck*(abs(q.y)-.25)+T*spd);\n        x = (q.x+.25)*2.;\n        vec2 duv = vec2(x,y);\n        \n        k = min(box(tuv-.5,bx)-.015,box(duv-.5,bx.yx)-.015);\n        kt= min(box(abs(tuv-.5)-bk,bt),box(abs(duv-.5)-bk.yx,bt.yx));\n        kw= min(box(tuv-vec2(.55,.5),vec2(.04,.07))-.02,\n                box(duv-vec2(.5,.45),vec2(.07,.04))-.02 \n            ); \n    } \n    \n    float ct = box(q,vec2(.175))-.04;\n\n    // background tree stuff\n    vec2 iv = floor(uv*8.)+id;\n    vec2 vv = fract(uv*8.)-.5;\n    float xs = fbm(vec3(iv.x,0,iv.y)*.075);\n          xs = smoothstep(.5,.8,xs);\n    float cy = length(vv)-(xs*.35);\n    \n    // lines\n    d2 = smoothstep(px,-px,d2-.001);\n    C = mix(C,vec3(.1,.05,.02),d2);\n\n    // show trees if value is high enough\n    if (xs>.001) {\n        xs = fbm(vec3(iv.x,0,iv.y)*3.);\n        vec3 T = mix(C,G,mod(xs*32.2,1.));\n        C = mix(C,T*.25,smoothstep(.025+px,-px,cy-.1));\n        C = mix(C,T,smoothstep(px,-px,cy));\n    } \n\n    // track shadow\n    C = mix(C,C*.45,smoothstep(.05+px,-px,d-.035));\n\n    // main path\n    C = mix(C,vec3(0),smoothstep(px,-px,abs(d)-.015));\n    C = mix(C,vec3(.1),smoothstep(px,-px,d));\n\n    // cars\n    C = mix(C,C*.6,smoothstep(.05+px,-px,k-.02));\n    C = mix(C,vec3(0),smoothstep(px,-px,kt-.02));\n    C = mix(C,vec3(0),smoothstep(px,-px,abs(k)-.02));\n    C = mix(C,K,smoothstep(px,-px,k));\n    C = mix(C,C*.7,smoothstep(.04+px,-px,kw-.01));\n    C = mix(C,vec3(.9),smoothstep(px,-px,kw));\n\n    if (hs>trs) {\n        C = mix(C,vec3(0),smoothstep(px,-px,abs(ct)-.015));\n        C = mix(C,C*.45,smoothstep(.05+px,-px,ct-.025));\n        C = mix(C,vec3(.2),smoothstep(px,-px,ct));\n    }\n    \n    C = pow(C,vec3(.4545));\n    O = vec4(C,1.);\n}\n\n\n    \n        \n    \n        \n    \n    ",
                "description": "",
                "inputs": [
                    {
                        "channel": 1,
                        "ctype": "texture",
                        "id": 3,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg"
                    },
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 6,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n*/\n\n// @Shane - a very tightly compacted, self-contained version \n// of IQ's 3D value noise function.\n//---------------------------------------------------------------\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbm( in vec3 x) {\n    float a = 0.1,b = .5,f = 2.;\n    vec3  d = vec3(0.);\n    for (int i = 0; i < 4; ++i) {      \n        float n = n3D(f*x);\n        a += b*n;\n        b *= 0.5;\n        f *= 1.8;\n    }\n\treturn a;\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}