{
    "Shader": {
        "info": {
            "date": "1627893326",
            "description": "sponza.",
            "flags": 0,
            "hasliked": 0,
            "id": "flSSRz",
            "likes": 21,
            "name": "A sponza scene",
            "published": 3,
            "tags": [
                "raymarching",
                "sdf",
                "ao"
            ],
            "usePreview": 0,
            "username": "moranzcw",
            "viewed": 605
        },
        "renderpass": [
            {
                "code": "// A monster scene - by moranzcw - 2021\n// Email: moranzcw@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653;\n\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_T = 0.0;\nconst float MAX_T = 50.0;\n\nconst float K = 24.0; // for distance dunction soft shadows\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n// hash by Hugo Elias\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n\n// ambient\nfloat ambient = 0.4;\n\n// dot light\nvec3 DOT_LIGHT_POS = vec3(0.0, 6.0, 0.0); // position\nvec3 DOT_LIGHT_INT = 2.0 * vec3(1.0, 1.0, 0.9); // intensity\n\n// direction light\nvec3 DIR_LIGHT_DIR = normalize(vec3(0.15, 1.8, -0.45)); // direction\nvec3 DIR_LIGHT_IRR = 3.5 * vec3(1.0, 1.0, 0.9); // irradiance\n\n\n/* -------------------------------------\n\n  SDF\n\n------------------------------------- */\n\n// SDF boolean\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n//SDF functions by iq.\n//see https://iquilezles.org/articles/distfunctions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF_X( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.zy),p.x)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF_Y( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinderSDF_Z( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.yx),p.z)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// scene\nfloat columns1(vec3 p)\n{\n    p = vec3(mod(p.x, 3.0)-1.5, p.y-1.0, mod(p.z, 3.0)-1.5);\n    float d = cylinderSDF_Y(p, 1.0, 0.25);\n    p += vec3(0.0, -1.0, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.3, 0.05, 0.3)));\n    return d;\n}\n\nfloat columns2(vec3 p)\n{\n    p = vec3(mod(p.x, 3.0)-1.5, p.y-4.0, mod(p.z, 3.0)-1.5);\n    float d = boxSDF(p, vec3(0.22, 0.15, 0.22));\n    p += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.17, 0.75, 0.17)));\n    p += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(p, vec3(0.3, 0.05, 0.3)));\n    return d;\n}\n\nfloat columns3(vec3 p)\n{\n    vec3 tp = vec3(mod(p.x+1.5, 3.0)-1.5, p.y-4.0, mod(p.z, 3.0)-1.5);\n    float d = boxSDF(tp, vec3(0.22, 0.15, 0.22));\n    tp += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, cylinderSDF_Y(tp, 0.75, 0.17));\n    tp += vec3(0.0, -0.75, 0.0);\n    d = unionSDF(d, boxSDF(tp, vec3(0.3, 0.05, 0.3)));\n    \n    d = differenceSDF(d, boxSDF(p + vec3(-9.0, -5.0, 0.0), vec3(2.0, 4.0, 5.0)));\n    d = differenceSDF(d, boxSDF(p + vec3(9.0, -5.0, 0.0), vec3(2.0, 4.0, 5.0)));\n    return d;\n}\n\nfloat roof1(vec3 p)\n{\n    //\n    float box1 = boxSDF(p + vec3(0.0, -3.0, 0.0), vec3(100.0, 1.0, 20.0));\n    float box2 = boxSDF(p + vec3(0.0, -3.0, 0.0), vec3(7.25, 1.5, 1.25));\n    float roof = differenceSDF(box1, box2);\n    \n    //\n    float box3 = boxSDF(p + vec3(0.0, -4.0, -3.0), vec3(10.25, 0.6, 1.25));\n    float box4 = boxSDF(p + vec3(0.0, -4.0, 3.0), vec3(10.25, 0.6, 1.25));\n    roof = differenceSDF(roof, unionSDF(box3, box4));\n    \n    //\n    float box5 = boxSDF(p + vec3(9.0, -4.0, 0.0), vec3(1.25, 0.6, 2.0));\n    float box6 = boxSDF(p + vec3(-9.0, -4.0, 0.0), vec3(1.25, 0.6, 2.0));\n    roof = differenceSDF(roof, unionSDF(box5, box6));\n    \n    //\n    p = vec3(mod(p.x-1.5, 3.0) - 1.5, p.y, p.z);\n    float cylinderZ = cylinderSDF_Z(p + vec3(0.0, -2.0, 0.0), 100.0, 1.25);\n    float cylinderX = cylinderSDF_X(p + vec3(0.0, -2.0, 0.0), 100.0, 1.25);\n    return differenceSDF(roof, unionSDF(cylinderX, cylinderZ));\n}\n\nfloat roof2(vec3 p)\n{\n    //\n    float box1 = boxSDF(p + vec3(0.0, -7.5, 0.0), vec3(100.0, 2.0, 20.0));\n    float box2 = boxSDF(p + vec3(0.0, -7.5, 0.0), vec3(7.25, 2.5, 1.25));\n    float roof = differenceSDF(box1, box2);\n    \n    //\n    vec3 tp = vec3(mod(p.x-1.5, 3.0) - 1.5, p.y-5.5, mod(p.z-1.5, 3.0) - 1.5);\n    float cylinderZ = cylinderSDF_Z(tp, 100.0, 1.4);\n    float cylinderX = cylinderSDF_X(tp, 100.0, 1.25);\n    roof =  differenceSDF(roof, unionSDF(cylinderX, cylinderZ));\n    \n    //\n    float box3 = boxSDF(p + vec3(0.0, -7.5, 1.45), vec3(7.5, 2.0, 0.2));\n    float box4 = boxSDF(p + vec3(0.0, -7.5, -1.45), vec3(7.5, 2.0, 0.2));\n    float temp = unionSDF(box3, box4);\n    \n    //\n    tp = vec3(mod(p.x-1.5, 1.5)-1.5, p.y-5.5, p.z);\n    float cylinderZ1 = cylinderSDF_Z(tp + vec3(0.7, 0.0, 0.0), 100.0, 0.625);\n    temp =  differenceSDF(temp, cylinderZ1);\n\n    \n    return unionSDF(roof, temp);\n}\n\nfloat wall(vec3 p)\n{\n    float box1 = boxSDF(p + vec3(0.0, 0.0, 4.35), vec3(100.0, 9.5, 0.1));\n    float box2 = boxSDF(p + vec3(0.0, 0.0, -4.35), vec3(100.0, 9.5, 0.1));\n    float box3 = boxSDF(p + vec3(10.35, 0.0, 0.0), vec3(0.1, 9.5, 100.0));\n    float box4 = boxSDF(p + vec3(-10.35, 0.0, 0.0), vec3(0.1, 9.5, 100.0));\n    return unionSDF(unionSDF(box1, box2), unionSDF(box3, box4));\n}\n\nfloat ground(vec3 p)\n{\n    return quadSDF(p,vec3(100.0,0.0,100.0), vec3(100.0,0.0,-100.0),\n                     vec3(-100.0,0.0,-100.0), vec3(-100.0,0.0,100.0));\n}\n\n// scene\nfloat sceneSDF(vec3 p)\n{\n    float scene = MAX_T;\n    scene = unionSDF(scene, ground(p));\n    scene = unionSDF(scene, wall(p));\n    scene = unionSDF(scene, columns1(p));\n    scene = unionSDF(scene, roof1(p));\n    scene = unionSDF(scene, columns2(p));\n    scene = unionSDF(scene, columns3(p));\n    scene = unionSDF(scene, roof2(p));\n    \n    return scene;\n}\n\n/* -------------------------------------\n\n  Ray Marching\n\n------------------------------------- */\nfloat rayMarching(vec3 ro, vec3 rd, float start, float end) \n{\n    float t = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        float dist = sceneSDF(ro + t * rd);\n        if (dist < EPSILON * t) \n        {\n\t\t\treturn t;\n        }\n        t += dist;\n        if (t > end)\n        {\n            return t;\n        }\n    }\n    return t;\n}\n\n/* -------------------------------------\n\n  Visibility of the shading point to light source\n\n------------------------------------- */\nfloat visibility(vec3 ro, vec3 rd, float start, float end)\n{\n    float t = start;\n    vec3 p;\n    float dist;\n    float tempVisibility;\n    float visibility = 1.0;\n        \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        p = ro + t * rd;\n        dist = sceneSDF(p);\n        \n        tempVisibility = K * dist / t;\n        visibility = min(tempVisibility, visibility);\n        \n        if (dist < EPSILON) \n        {\n\t\t\treturn 0.0;\n        }\n        t += dist * (0.7 + frand() * 0.3); // dither\n        if (t >= end) \n        {\n            break;\n        }\n    }\n    return visibility;\n}\n\n\n/* -------------------------------------\n\n  Shading\n\n------------------------------------- */\n// normal\nvec3 surfaceNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// ambient occlusion\nfloat fakeAO(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float weight = 10.0;\n    for(int i=0; i<8; i++)\n    {\n        float spacing = 0.01 + 0.02 * float(i*i);\n        vec3 sp = p + n * spacing;\n        float d = sceneSDF(sp);\n        ao += weight * (spacing - d);\n        weight *= 0.5;\n    }\n    return 1.0 - clamp(ao, 0.0, 1.0);\n}\n\nvec3 lambert(vec3 diffuseColor, vec3 p, vec3 n, vec3 l, vec3 irradiance)\n{\n    float dotLN = clamp(dot(l, n), 0.0, 1.0);\n    return irradiance * dotLN * diffuseColor;\n}\n\n// shade\nvec3 shade(vec3 p)\n{\n    vec3 n = surfaceNormal(p);\n    vec3 tn = abs(n); \n    vec3 tex = texture(iChannel0, p.zy).rgb * tn.x \n                + texture(iChannel0, p.xz).rgb * tn.y\n                + texture(iChannel0, p.xy).rgb * tn.z;\n\n    // ambient occlusion\n    vec3 color = (0.2 + 0.8 * fakeAO(p, n)) * ambient * tex;\n    \n    // dot light\n    vec3 tempDotLightDir = DOT_LIGHT_POS - p;\n    vec3 direction = normalize(tempDotLightDir);\n    float dist = length(tempDotLightDir);\n    vec3 irradiance = DOT_LIGHT_INT / dist;  // Linear attenuation may be better\n    \n    float v = visibility(p, direction, 10.0*EPSILON, dist);\n    color += v * lambert(tex, p, n, direction, irradiance);\n    \n    // direction light\n    v = visibility(p, DIR_LIGHT_DIR, 10.0*EPSILON, MAX_T);\n    color += v * lambert(tex, p, n, DIR_LIGHT_DIR, DIR_LIGHT_IRR);\n    \n    // fog\n    //color = mix(color, 0.5 * vec3(0.8, 0.77, 0.75), 1.0 - exp2(-0.25 * dist));\n    return color;\n}\n\n\n/* -------------------------------------\n\n  Camera\n\n------------------------------------- */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 cameraOrigin, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - cameraOrigin);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\n    DOT_LIGHT_POS = vec3(4.0 + 2.0*sin(0.5*iTime), 6.0, 0.0);\n    \n    // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // camera ray\n\tvec3 cameraRayDirInView = rayDirection(110.0, iResolution.xy, fragCoord);\n    \n    vec3 cameraPos = vec3(9.3, 2.7 - 2.2 * sin(0.3 * iTime), - 2.5 * sin(0.2 * iTime));\n    mat3 viewToWorld = viewMatrix(cameraPos, vec3(0.0, 5.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 cameraRayDir = viewToWorld * cameraRayDirInView;\n    \n    // distance\n    float dist = rayMarching(cameraPos, cameraRayDir, MIN_T, MAX_T);\n    \n    // didn't hit\n    if (dist > MAX_T) \n    {\n        fragColor = vec4(.58, 0.77, 0.95, 0.0);\n\t\treturn;\n    }\n    \n    // hit point\n    vec3 p = cameraPos + dist * cameraRayDir;\n    \n    // shading\n    vec3 color = shade(p);\n    \n    fragColor = vec4(pow(color,vec3(1.0/2.2)), 1.0);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 1,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}