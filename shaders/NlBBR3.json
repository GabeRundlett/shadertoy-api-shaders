{
    "Shader": {
        "info": {
            "date": "1652573916",
            "description": "A desert terraiin. \n\n[UPDATE 2022-05-15]\nRaplaced FXAA with TAA,  much smoother",
            "flags": 32,
            "hasliked": 0,
            "id": "NlBBR3",
            "likes": 14,
            "name": "Just desert(s)",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "terrain",
                "clouds",
                "desert",
                "taa"
            ],
            "usePreview": 0,
            "username": "ruojake",
            "viewed": 384
        },
        "renderpass": [
            {
                "code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// This is a post-processing pass, adding dither and vignette\n// Rendering in Buffer A, TAA in buffer B\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nfloat vignette(vec2 fc)\n{\n    vec2 uv = fc / iResolution.xy * 2. - 1.;\n    float v = length(uv);\n    return 1. - v * v * v * .2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texelFetch(iChannel1, fc, 0).rgb;\n    \n    col *= vignette(fragCoord);\n    // dither\n    col += fract(dot(fragCoord + float((iFrame & 7) * 23), vec2(1.14321,1.23422))) * .0125 - .00625;\n    \n    fragColor = vec4(col,1.0);\n}\n\n/* \n//Old FXAA pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    float m = texelFetch(iChannel0, fc, 0).a;\n    \n    float l  = texelFetchOffset(iChannel0, fc, 0, ivec2(-1,  0)).a;\n    float r  = texelFetchOffset(iChannel0, fc, 0, ivec2( 1,  0)).a;\n    float t  = texelFetchOffset(iChannel0, fc, 0, ivec2( 0,  1)).a;\n    float b  = texelFetchOffset(iChannel0, fc, 0, ivec2( 0, -1)).a;\n    \n    float tl = texelFetchOffset(iChannel0, fc, 0, ivec2(-1,  1)).a;\n    float tr = texelFetchOffset(iChannel0, fc, 0, ivec2( 1,  1)).a;\n    float bl = texelFetchOffset(iChannel0, fc, 0, ivec2(-1, -1)).a;\n    float br = texelFetchOffset(iChannel0, fc, 0, ivec2( 1, -1)).a;\n    \n    float mn = min(l, min(r, min(t, min(b, m))));\n    float mx = max(l, max(r, max(t, max(b, m))));\n    float con = mx - mn;\n    \n    float thr = max(.03125, mx * .125);\n    \n    vec3 col = texture(iChannel0, uv).rgb; \n    if(con > thr)\n    {\n        float flt = 2. * (t + b + l + r)\n                  + tl + tr + bl + br;\n        flt = smoothstep(0., 1., abs(flt / 12. - m) / con);\n        flt *= flt;\n\n        float hz = abs(b + t - 2. * m) * 2.\n                 + abs(bl + tl - 2. * l)\n                 + abs(br + tr - 2. * r);\n        float vt = abs(l + r - 2. * m) * 2.\n                 + abs(bl + br - 2. * b)\n                 + abs(tl + tr - 2. * t);\n\n        float pLum, nLum;\n        vec2 o, uvE = uv;\n        if(vt > hz)\n        {\n            pLum = r;\n            nLum = l;\n            o = vec2(0,1);\n            uvE += vec2(.5 / iResolution.x, 0); \n        }\n        else\n        {\n            pLum = t;\n            nLum = b;\n            o = vec2(1,0);\n            uvE += vec2(0, .5 / iResolution.y);\n        }\n\n        float pGr = abs(pLum - m);\n        float nGr = abs(nLum - m);\n\n        o /= iResolution.xy;\n        vec2 oE = o;\n        float gr, oppLum;\n        if(pGr < nGr)\n        {\n            gr = nGr;\n            o *= -1.;\n            oppLum = nLum;\n        }\n        else\n        {\n            gr = pGr;\n            oppLum = pLum;\n        }\n\n        float lumE = (m + oppLum) * .5;\n        float grThr = gr * .25;\n        \n        float steps[10] = float[](1., 1.5, 2., 2., 2., 2., 2., 2., 2., 4.);\n        \n        vec2 uvP = uvE + oE;\n        float pDLum = texture(iChannel0, uvP).a - lumE;\n        bool atEnd = abs(pDLum) >= grThr;        \n        \n        for(int i = 0; i < 9 && !atEnd; ++i)\n        {\n            uvP += oE * steps[i];\n            pDLum = texture(iChannel0, uvP).a - lumE;\n            atEnd = abs(pDLum) >= grThr;\n        }\n        if (!atEnd) uvP += oE * 8.;\n        \n        vec2 uvN = uvE - oE;\n        float nDLum = texture(iChannel0, uvN).a - lumE;\n        atEnd = abs(nDLum) >= grThr;\n        \n        for(int i = 0; i < 9 && !atEnd; ++i)\n        {\n            uvN -= oE * steps[i];\n            nDLum = texture(iChannel0, uvN).a - lumE;\n            atEnd = abs(nDLum) >= grThr;\n        }\n        if (!atEnd) uvN -= oE * 8.;\n        \n        float distP = vt > hz ? uvP.y - uv.y : uvP.x - uv.x;\n        float distN = vt > hz ? uv.y - uvN.y : uv.x - uvN.x;\n        float dist = min(distP, distN);\n        bool dSgn = distN < distP ? nDLum >= 0. : pDLum >= 0.;\n        \n        float blFac = dSgn == ((m - lumE) >= 0.) ? 0. : .5 - dist / (distN + distP);\n        flt = max(blFac, flt * .8);\n        \n        uv += o * flt;\n        col = texture(iChannel0, uv).rgb;\n        //col = vec3(flt);\n    }\n    //else col *= 0.;\n    \n    col *= vignette(fragCoord);\n    // dither\n    col += fract(dot(fragCoord + float((iFrame & 7) * 23), vec2(1.14321,1.23422))) * .0125 - .00625;\n    \n    fragColor = vec4(col,1.0);\n}*/",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n#if 1\n\n#define FK(K) floatBitsToUint(K)^floatBitsToUint(cos(K))\n\nfloat hash12(vec2 p)\n{\n    uint x = FK(p.x);\n    uint y = FK(p.y);\n    \n    return float((x*x-y)*(y*y+x)-x)/4.28e9;\n}\n\n#else\n\nfloat hash12(vec2 p)\n{\n    vec3 q = fract(p.xyx * vec3(.15431,.16233,.14635) - .0001);\n    q -= p.y * q.y * .002312;\n    return fract((dot(p.yxy * 3.12103 + q.z, -q) - q.x + p.x) * 2. - q.y);\n}\n\n#endif\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = smoothstep(.1, .9, p - i);\n    \n    vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(hash12(i),hash12(i + o), f.x),\n        mix(hash12(i + o.yx), hash12(i + 1.), f.x), \n        f.y);\n}\n\nfloat fbm3(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 3; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat fbm5(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 5; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat fbm7(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 7; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat sceneLD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm3(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nfloat sceneMD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm5(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nfloat sceneHD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm7(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(.0001, 0.);\n    \n    return normalize(\n        sceneHD(p) - vec3(\n            sceneHD(p - e.xyy),\n            sceneHD(p - e.yxy),\n            sceneHD(p - e.yyx)\n        )\n    );\n}\n\nvec3 normLD(vec3 p, float d)\n{\n    const vec2 e = vec2(.01, 0.);\n    \n    return normalize(\n        d - vec3(\n            sceneLD(p - e.xyy),\n            sceneLD(p - e.yxy),\n            sceneLD(p - e.yyx)\n        )\n    );\n}\n\nvec3 normMD(vec3 p)\n{\n    const vec2 e = vec2(.01, 0.);\n    \n    return normalize(\n        sceneMD(p) - vec3(\n            sceneMD(p - e.xyy),\n            sceneMD(p - e.yxy),\n            sceneMD(p - e.yyx)\n        )\n    );\n}\n\nfloat clouds(vec2 p)\n{\n    p += iTime * vec2(-.2, .7); \n    p *= rot(1.4); \n    float res = smoothstep(0.,1.,fbm3(p * .05));\n    res *= smoothstep(.3, .7, fbm3(p * .02 + 2.));\n    return res;\n}\n\nvec3 sky(vec3 rd, vec3 ld)\n{\n    float sun = dot(ld, rd);\n    sun = pow(sun, 20.) + pow(sun, 900.) * 5.;\n    vec3 col = vec3(.05,.2,1.) + clamp(rd.y * -.6 + .5, 0., 1.);\n    if(rd.y > 0.)\n    {\n        vec2 p = (rd * 25. / rd.y).xz;\n        float c = clouds(p);\n        c *= smoothstep(0.,.1, rd.y);\n        sun *= clamp(1. - c, 0., 1.);\n        col += c * (1. + sun);\n        p += ld.xz / ld.y * .5;\n        col *= 1. - clouds(p) * c * .3;\n        p += ld.xz / ld.y * .5;\n        col *= 1. - clouds(p) * c * .3;\n    }\n    return col + sun * vec3(1., .8, .7);\n}\n\nvec4 matTerrain(vec3 p, vec3 n)\n{\n    float pat = fbm3(p.xz * .5);\n    pat = smoothstep(.1, .9, pat);\n    vec4 c = mix(vec4(.5,.125,.05, .8), vec4(.6,.3,.125, 0), clamp(pat + smoothstep(.7, 1., n.y) * .8, 0., 1.));\n    float t = iTime;\n    float h = smoothstep(.3, 1., noise(sin(p.xz * .7 + t)));\n    float w = n.y * n.y * n.y * n.y \n            * smoothstep(0., 1., sin(dot(vec2(3,-2), p.xz) - t * 4.) * noise(p.xz * 3.)) \n            * h * .1;\n    c.rgb += w * vec3(1., .7, .4);\n    c.a *= 1. - w;\n    return c;\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float t = .01;\n    float res = 1.;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = sceneLD(p);\n        if(abs(d) < .0001) return 0.;\n        res = min(d/t * 3., res);\n        t += d;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nvec3 reinhard(vec3 c)\n{\n    float l = lum(c);\n    float n = l * (1. + l / 9.) / (1. + l);\n    return c * n / l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ro = vec3(0,3,iTime - 200.), // my hash func is a bit bad, pull the camera back\n         rd = normalize(vec3(uv,3)),\n         p;\n    \n    // vary ray origin for TAA\n    ro.xy += fract((fragCoord + float((iFrame & 7) * 23)) * vec2(1.14321,1.23422)) * .006 - .003;\n    \n    vec3 ld = normalize(vec3(1,1,6));\n    vec3 col = sky(rd, ld);\n    float t = 100.;\n     \n    if(rd.y < 0.)\n    {\n        float i = 0.,\n              d, m;\n        t = 0.;\n\n        for(;i < 1.; i += 3./512.)\n        {\n            p = ro + rd * t;\n            d = sceneLD(p);\n\n            if(abs(d) < .001 * min(log(t), 1.)) break;\n            t += d;\n        }\n        \n        vec3 n = t < 80. ? normal(p) : t < 120. ? normMD(p) : normLD(p, d);\n        \n        float l = dot(n, ld) * .5 + .5;\n        l *= clamp(clouds((p + ld * (25. - p.y) / ld.y).xz) + .2, 0., 1.);\n        l *= 1. - i * .25;\n        float sh = shadow(p + n * .2, ld);\n        l *= sh;\n        \n        vec3 sk = col;\n        vec4 mat = matTerrain(p, n);\n        col = mat.rgb;\n        vec3 sd = reflect(rd, n);\n        float spec = max(pow(clamp(dot(sd, ld), 0., 1.), 16. * mat.a) * mat.a, 0.);\n        spec *= clouds((p + sd * (25. - p.y) / max(sd.y, .001)).xz);\n        col *= mix(vec3(.05, .1, .3), vec3(1.,.98,.92) * 3., l);\n        col += spec * clamp(1. - t * .01, 0. ,1.);\n        col = mix(col, sk, clamp(1. - exp(-t * .006 + .4 * (1. - sh) + .1), 0., 1.));\n    }\n\n    col = reinhard(col); // tonemapping\n    col = mix(vec3(lum(col)), col, 1.5); // some saturation\n    col = pow(col, vec3(1./2.2)); // gamma correction\n\n    //fragColor = vec4(col, clamp(lum(col), 0., 1.)); // output luminance for FXAA\n    fragColor = vec4(col, t * rd.z + iTime); // output Z position for TAA\n}",
                "description": "",
                "inputs": [],
                "name": "Buffer A",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 257
                    }
                ],
                "type": "buffer"
            },
            {
                "code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// TAA pass\n// An improvised hack, don't use as reference for anything!\n// Works surprisingly well here though.\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec4 a = texelFetch(iChannel0, fc, 0);\n    vec4 b = iFrame > 0 ? texelFetch(iChannel1, fc, 0) : a;\n    a.rgb = clamp(a.rgb, vec3(0), vec3(1));\n    b.rgb = clamp(b.rgb, vec3(0), vec3(1));\n    \n    float d = clamp(abs(b.a - a.a), 0., 1.);\n    float dl = lum(abs(a.rgb - b.rgb));\n    d = max(d, clamp((1.2 + d) * dl, .25, 1.));\n    fragColor = mix(b, a, d);\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "buffer",
                        "id": 257,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer00.png"
                    },
                    {
                        "channel": 1,
                        "ctype": "buffer",
                        "id": 258,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/previz/buffer01.png"
                    }
                ],
                "name": "Buffer B",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 258
                    }
                ],
                "type": "buffer"
            }
        ],
        "ver": "0.1"
    }
}