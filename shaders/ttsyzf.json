{
    "Shader": {
        "info": {
            "date": "1597090758",
            "description": "A volumetric renderer with sdf and value noise following Christopher Wallis Blog\nhttps://wallisc.github.io/rendering/2020/05/02/Volumetric-Rendering-Part-1.html",
            "flags": 0,
            "hasliked": 0,
            "id": "ttsyzf",
            "likes": 3,
            "name": "Volumetric Render for Practice",
            "published": 3,
            "tags": [
                "sdf",
                "volumetric",
                "valuenoise",
                "student"
            ],
            "usePreview": 0,
            "username": "specialsaucewc",
            "viewed": 432
        },
        "renderpass": [
            {
                "code": "// Base code by Christopher Wallis\n// https://www.shadertoy.com/view/tdffzn\n    \n\nOrbLightDescription GetLight(int lightIndex)\n{\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHTS);\n    float radius = 25.5;\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 5.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * LIGHT_INTENSITY;\n    orbLight.Radius = 1.0f;\n\n    return orbLight;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    materials[DEBUG_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    \n    for (int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++) {\n        materials[LAMP_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n\n\nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      // If the ray doesn't intersect\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      // If the ray is inside the sphere\n      if (firstIntersect < EPSILON) {\n         t = (dot(-rayDirection, eMinusC) + sqrt(discriminant))\n             / dDotD;\n      }\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LAMP_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\n\nfloat SdVolume(vec3 p) {\n    float t = iTime;\n    vec4 center = vec4(0, 7, 0, 11);\n    vec4 wisp = vec4(13., 8.*sin(t) + 16., 2., 6.5);\n    float offset = 8.*sin(t*.75);\n    vec4 roam = vec4(offset, 6.*sin(t*1.5)+14., offset, 9.);\n    \n    float d = SdSphere(p, center.xyz, center.a);\n    float dt = SdSphere(p, wisp.xyz, wisp.w);\n    d = SdSmoothUnion(d, dt, BLEND_STRENGTH);\n    float dr = SdSphere(p, roam.xyz, roam.w);\n    d = SdSmoothUnion(d, dr, BLEND_STRENGTH);\n    \n    vec3 fbmCoord = (p + 2. * vec3(iTime, 0., iTime)) / NOISE;\n    d += NOISE_HEIGHT * fbm(fbmCoord);\n    \n    dt = SdPlane(p + vec3(0., .1, 0.));\n    d = SdSmoothUnion(d, dt, BLEND_STRENGTH * GROUND_STICK);\n    \n    return d;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, in float maxDist, out int materialID, out vec3 normal) {\n    materialID = INVALID_MATERIAL_ID;\n\n    float dO = 0.;\n    vec3 p = vec3(0.);\n    for (int i=0; i<MAX_STEPS; i++) {\n        p = rayOrigin + dO*rayDirection;\n        float ds = SdVolume(p);\n        dO += ds;\n        if (ds < SURFACE_DIST || dO > maxDist) break;\n    }\n    \n    return dO;\n}\n\nfloat VolumeLightVisibility(in vec3 rO, in vec3 rDir, in float maxT, in int numSteps, in float marchSize) {\n\tfloat t = 0.;\n    float lightVis = 1.;\n    for(int i=0;i<numSteps;i++) {\n    \tt += marchSize;\n        if (t > maxT) break;\n        \n        vec3 p = rO + t*rDir;\n        if (SdVolume(p) < 0.) {\n            lightVis *= BeerLambert(VOLUMETRIC_ABSORPTION, marchSize);\n        }\n    }\n    return lightVis;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDir, Material material, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDir = (GetLight(lightIndex).Position - position);\n        float lightDist = length(lightDir);\n        lightDir = normalize(lightDir);\n\n        // Manually tuned light falloff for what looked best\n        vec3 lightColor = GetLight(lightIndex).LightColor\n            * GetLightAttenuation(lightDist);\n        \n        #if CAST_SHADOW_ON_OPAQUE\n        if (!IsColorInsignificant(lightColor)) {\n        \tlightColor *= VolumeLightVisibility(position, lightDir, lightDist, MAX_SHADOWMARCH_STEPS, .6);\n        }\n        #endif\n\n        color += lightColor * pow(max(dot(reflectionDir, lightDir), 0.0), 4.0);\n        color += lightColor * Diffuse(normal, lightDir, material.albedo);\n    \n    }\t\n    color += AMBIENT_LIGHT * material.albedo;\n}\n\nfloat FogDensity(vec3 p, float sdfValue) {\n\tfloat sdfMultiplier = sdfValue < 0.\n        ? min(abs(sdfValue), 1.)\n        : 0.;\n    float density = abs(fbm(p/6.)+.5);\n    return sdfMultiplier * density;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDir)\n{    \n    vec3 vColor = vec3(0.);\n    vec3 oColor = vec3(0.);\n    float fDepth = SCENE_MAX_T;\n    float oVisibility = 1.;\n    const float marchSize = .6;\n    \n    vec3 normal, vnormal;\n    int vmaterialId = INVALID_MATERIAL_ID;\n    int materialId = INVALID_MATERIAL_ID;\n    \n    float oDepth = IntersectOpaqueScene(rayOrigin, rayDir, materialId, normal);\n    \n    //we hit the ground or light, do lighting after volumetric\n    if (materialId != INVALID_MATERIAL_ID) {\n        fDepth = oDepth;\n    }\n    \n    float vDepth = IntersectVolumetric(rayOrigin, rayDir, fDepth, vmaterialId, vnormal);\n    \n    if (vDepth > 0.) {\n        //raymarch through volume\n        for (int i=0;i<MAX_VOLUME_STEPS;i++) {\n        \tvDepth += marchSize;\n            \n            if (vDepth > oDepth)\n                break;\n            \n            vec3 p = rayOrigin + rayDir * vDepth;\n            float sdfValue = SdVolume(p);\n            bool inVolume = sdfValue < 0.;\n            if (inVolume) {\n            \tfloat prevOVisibility = oVisibility;\n                //reduce visibility by volume density and absorption\n                oVisibility *= BeerLambert(VOLUMETRIC_ABSORPTION * FogDensity(p, sdfValue), marchSize);\n                //stop if results are negligable\n                if (oVisibility < MIN_OPACITY) break;\n                float marchAbsorption = prevOVisibility - oVisibility;\n                \n                //raymarch each light for its contribution at p\n                for(int lightIndex=0;lightIndex<NUM_LIGHTS;lightIndex++) {\n                \tvec3 lightDir = GetLight(lightIndex).Position - p;\n                    float lightDist = length(lightDir);\n                    lightDir = normalize(lightDir);\n                    vec3 lightCol = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDist);\n                    //raymarch to light only if value is noticable\n                    if (!IsColorInsignificant(lightCol)) {\n                        lightCol *= VolumeLightVisibility(p, lightDir, lightDist, MAX_LIGHTMARCH_STEPS, marchSize*1.4);\n                    }\n                    \n                    vColor += marchAbsorption * VOLUMETRIC_ALBEDO * lightCol;\n                }\n                //Add ambient volume color\n                vColor += marchAbsorption * VOLUMETRIC_ALBEDO * AMBIENT_LIGHT;\n            }\n        }\n    }\n    \n    //we hit opaque obj\n    if( materialId != INVALID_MATERIAL_ID )\n    {\n        vec3 position = rayOrigin + oDepth*rayDir;\n        Material material = GetMaterial(materialId, position);\n\t\tif(IsLightSource(material))\n        {\n            oColor = min(material.albedo, vec3(1.0));\n        }       \n        else {\n        \tvec3 reflectionDir = reflect( rayDir, normal);\n        \tCalculateLighting(position, normal, reflectionDir, material, oColor);\n        }\n    }\n    return min(vColor, 1.) + oVisibility * oColor; \n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 250.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    if(iMouse.x <= 0.0)\n    {\n        // Default value when shader is initially loaded up\n        return 0.65f;\n    }\n    \n    return iMouse.x / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    \n    #if USE_BLUE_NOISE\n    if (Luminance(color) > NOISE_THRESHOLD) {\n        float noise = (texture(iChannel0, uv).r -.5) * NOISE_JITTER;\n        color += noise;\n    }\n    #endif\n    \n    color = LinearToSRGB(color);\n    fragColor=vec4( color, 1.0 );\n}",
                "description": "",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "texture",
                        "id": 14854,
                        "published": 1,
                        "sampler": {
                            "filter": "mipmap",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "repeat"
                        },
                        "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            },
            {
                "code": "#define PI 3.14159\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define SCENE_MAX_T 900.0\n\n//features\n#define CAST_SHADOW_ON_OPAQUE 1\n#define USE_BLUE_NOISE 0\n\n//lighting\n#define NUM_LIGHTS 3\n#define LIGHT_ATTENUATION 1.65\n#define LIGHT_INTENSITY 15.\n#define AMBIENT_LIGHT vec3(.028, .016, .016)\n#define VOLUMETRIC_ALBEDO vec3(.9)\n#define VOLUMETRIC_ABSORPTION .25\n#define MIN_OPACITY .05\n#define NOISE_JITTER .02\n#define NOISE_THRESHOLD .03\n\n//volume shape\n#define BLEND_STRENGTH 1.75\n#define GROUND_STICK 13.\n#define NUM_OCTAVES 4\n#define NOISE 3.\n#define NOISE_HEIGHT 5.\n\n//raymarch\n#define MAX_STEPS 40\n#define MAX_VOLUME_STEPS 40\n#define MAX_SHADOWMARCH_STEPS 25\n#define MAX_LIGHTMARCH_STEPS 25\n#define SURFACE_DIST .03\n\n//materials\n#define INVALID_MATERIAL_ID int(-1)\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LAMP_MATERIAL_ID 2\n#define DEBUG_MATERIAL_ID 1\n#define NUM_MATERIALS (LAMP_MATERIAL_ID + NUM_LIGHTS + 1)\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 emissive;\n    int flags;\n};\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 70, 165),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n    \nvec3 GetLightColor(int lightIndex) {\n    switch(lightIndex % NUM_LIGHTS)\n    {\n        case 0: return vec3(1., 0., 1.);\n        case 1: return vec3(0., 1., 0.);\n        case 2: return vec3(1.0, .5, 0.02);\n        case 3: return vec3(0., 0., 1.);\n    }\n    return vec3(1., 0., 0.);\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1. / pow(distanceToLight, LIGHT_ATTENUATION);\n}\n\nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, vec3(0), flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.009;\n    return Luminance(color) < minValue;\n}\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n\n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\nfloat SdSmoothUnion( float d1, float d2, float k) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nfloat SdPlane( vec3 p ) {\n    return p.y;\n}\n\nfloat SdSphere( vec3 p, vec3 origin, float s ) {\n  p = p - origin;\n  return length(p)-s;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}",
                "description": "",
                "inputs": [],
                "name": "Common",
                "outputs": [],
                "type": "common"
            }
        ],
        "ver": "0.1"
    }
}