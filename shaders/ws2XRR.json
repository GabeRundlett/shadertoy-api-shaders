{
    "Shader": {
        "info": {
            "date": "1552755585",
            "description": "This is a first experiment of trying to create a random (but looping) motion-path for an object (ball in this case). The x-, y- and z-coordinates are offset by sampling 2D simplex-noise values at different areas in the noise-domain.",
            "flags": 0,
            "hasliked": 0,
            "id": "ws2XRR",
            "likes": 1,
            "name": "Simplex-noise motion-path",
            "published": 3,
            "tags": [
                "3d",
                "raymarching",
                "noise",
                "phong",
                "simplex",
                "spheretracing",
                "motion",
                "blinn",
                "path"
            ],
            "usePreview": 0,
            "username": "MacSlow",
            "viewed": 383
        },
        "renderpass": [
            {
                "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Trying out a looping motion-path for a ball by sampling 2D simplex-noise.\n//\n// Copyright 2019 Mirco Müller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Müller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float EPSILON = .001;\nconst int MAX_ITER = 48;\nconst float STEP_BIAS = 1.2;\n\nmat2 r2d (in float degree) {\n\tfloat c = cos (radians (degree));\n    float s = sin (radians (degree));\n    return mat2 (vec2(c, s), vec2(-s, c));\n}\n\n// using a slightly adapted implementation of iq's simplex noise from\n// https://www.shadertoy.com/view/Msf3WH with hash(), noise() and fbm()\nvec2 hash (in vec2 p)\n{\n    p = vec2 (dot (p, vec2 (127.1, 311.7)),\n              dot (p, vec2 (269.5, 183.3)));\n\n    return -1. + 2.*fract (sin (p)*43758.5453123);\n}\n\nfloat noise (in vec2 p)\n{\n    const float K1 = .366025404;\n    const float K2 = .211324865;\n\n    vec2 i = floor (p + (p.x + p.y)*K1);\n    \n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step (a.yx, a.xy);    \n    vec2 b = a - o + K2; \n    vec2 c = a - 1. + 2.*K2;\n\n    vec3 h = max (.5 - vec3 (dot (a, a), dot (b, b), dot (c, c) ), .0);\n\n    vec3 n = h*h*h*h*vec3 (dot (a, hash (i + .0)),\n                           dot (b, hash (i + o)),\n                           dot (c, hash (i + 1.)));\n\n    return dot (n, vec3 (70.));\n}\n\nfloat fbm (in vec2 p, in int iters)\n{\n    mat2 rot = r2d (27.5);\n    float d = .0;\n    float f = 1.;\n    float fsum = .0;\n\n    for (int i = 0; i < iters; ++i) {\n        d += f*noise (p);\n        p *= rot;\n        fsum += f;\n        f *= .5;\n    }\n    d /= fsum;\n\n    return d;\n}\n\nfloat sdSphere (in vec3 p, in float r) {\n    return length (p) - r;\n}\n\nfloat scene (in vec3 p) {\n    vec3 pBottom = p;\n\tfloat phase = p.x*p.x + p.z*p.z;\n    float bottom = pBottom.y + 1. + .25*(.5 + .5*cos (phase));\n\n    vec3 pTop = p;\n    float top = -(pTop.y - 3.);\n\n    // this, apart from the simplex-noise, is the most interesting piece\n    // of code imo... here a pseudo-random (but looping) motion-path for\n    // the ball is created\n\tfloat t = iTime;\n\tvec3 ballCenter = p;\n    int iters = 4;\n    vec2 sampleAt = vec2 (cos (t), sin(t));\n\tballCenter.x += fbm (1. + sampleAt, iters);\n\tballCenter.y += .5*fbm (2. + sampleAt, iters);\n\tballCenter.z += fbm (3. + sampleAt, iters);\n\tfloat ball = sdSphere (ballCenter, .3);\n\n    return min (ball, min (bottom, top));\n}\n\nfloat raymarch (in vec3 ro, in vec3 rd) {\n    float t = .0;\n    float d = .0;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + d * rd;\n        t = scene (p);\n        if (abs (t) < EPSILON * (1. + .125*t)) break;\n        d += t*STEP_BIAS;\n    }\n\n    return d;\n}\n\nvec3 normal (in vec3 p, in float epsilon) {\n\tfloat d = scene (p);\n    vec2 e = vec2 (epsilon, .0);\n    return normalize (vec3 (scene (p + e.xyy) - d,\n                            scene (p + e.yxy) - d,\n                            scene (p + e.yyx) - d));\n}\n\nfloat shadow (in vec3 p, in vec3 lPos)\n{\n\tfloat distanceToLight = distance (p, lPos);\n\tvec3 n = normal (p, EPSILON);\n\tfloat distanceToObject = raymarch (p + .01*n,\n\t\t\t\t\t\t\t\t\t   normalize (lPos - p));\n\tbool isShadowed = distanceToObject < distanceToLight;\n\treturn isShadowed ? .1 : 1.;\n}\n\nfloat falloff (in float dist) {\n\treturn 8. / (dist*dist);\n}\n\nvec3 shadeBlinnPhong (in vec3 ro, in vec3 rd, in float d) {\n\tvec3 p = ro + d*rd;\n    vec3 amb = vec3 (.1);\n\tvec3 diffC = vec3 (.95, .9, .5);\n    vec3 specC = vec3 (1., .95, .9);\n\tvec3 diffC2 = vec3 (.5, .5, .95);\n    vec3 specC2 = vec3 (.9, .9, 1.);\n\n    vec3 n = normal (p, d*EPSILON);\n    vec3 lPos = ro + vec3 (.5, 1.0, -3.);\n    vec3 lPos2 = ro + vec3 (-1., 1.2, 2.);\n    vec3 lDir = lPos - p;\n    vec3 lDir2 = lPos2 - p;\n    vec3 lnDir = normalize (lDir);\n    vec3 lnDir2 = normalize (lDir2);\n    float sha = shadow (p, lPos);\n    float sha2 = shadow (p, lPos2);\n\tfloat lDist = distance (p, lPos);\n\tfloat lDist2 = distance (p, lPos2);\n\n    float diff = max (dot (n, lnDir), .0);\n    float diff2 = max (dot (n, lnDir2), .0);\n\tvec3 h = normalize (lDir - rd);\n\tvec3 h2 = normalize (lDir2 - rd);\n    float spec = pow (max (dot (h, n), .0), 20.);\n    float spec2 = pow (max (dot (h2, n), .0), 40.);\n\n\tfloat phase = cos (13.*p.x);\n\tfloat phase2 = cos (13.*p.z);\n\tfloat mask = smoothstep (.01, .001, (.5 + .5*phase));\n\tfloat mask2 = smoothstep (.01, .001, (.5 + .5*phase2));\n\n    // coloring/texturing the floor and ball is on major hack ;)\n\tvec3 matC = mix (vec3 (1.), vec3 (.0), 1. - mask);\n\tvec3 matC2 = mix (vec3 (1.), vec3 (.0), 1. - mask2);\n\tmatC = (p.y > -1.9 && p.y < -.5) ? matC : vec3 (1.);\n\tmatC2 = (p.y > -1.9 && p.y < -.5) ? matC2 : vec3 (1.);\n\tvec3 color = matC + matC2;\n\n    vec3 diffTerm = sha * falloff (lDist) * diff * diffC * color;\n    vec3 diffTerm2 = sha2 * falloff (lDist2) * diff2 * diffC2 * color;\n    vec3 specTerm = (sha > .1) ? falloff (lDist) * spec * specC : vec3 (.0);\n    vec3 specTerm2 = (sha2 > .1) ? falloff (lDist2) * spec2 * specC2 : vec3 (.0);\n\n\treturn amb + diffTerm + specTerm + diffTerm2 + specTerm2;\n}\n\nvec3 camera (in vec2 uv, in vec3 ro, in vec3 aim, in float zoom)\n{\n    vec3 camForward = normalize (vec3 (aim - ro));\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 camRight = normalize (cross (worldUp, camForward));\n    vec3 camUp = normalize (cross (camForward, camRight));\n    vec3 camCenter = ro + camForward * zoom;\n\t    \n    return normalize (camCenter + uv.x*camRight + uv.y*camUp - ro);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalize and aspect-correct UVs\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 uvRaw = uv;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // setup camera motion, position and view-ray\n    float angle = radians (300. + 55.*iTime);\n    float dist = 3. + cos (.125*iTime);\n    vec3 ro = vec3 (dist*cos (angle), 1., dist*sin (angle));\n    vec3 aim = vec3 (.0);\n    float zoom = 2.;\n    vec3 rd = camera (uv, ro, aim, zoom);\n\n    // sphere-trace/ray-march the thing\n    float d = raymarch (ro, rd);\n\tfloat fog = 1. / (1. + d*d*.125);\n    vec3 p = ro + d * rd;\n\n    // shade the result\n    vec3 col = shadeBlinnPhong (ro, rd, d);\n\n    // fog, tone-mapping, gamme-correction, vignette\n\tcol *= fog;\n    col = col / (1. + col);\n    col = .1 * col + .9*sqrt (col);\n\tcol *= .8 + .2 * pow (16.*uvRaw.x*uvRaw.y*(1. - uvRaw.x)*(1. - uvRaw.y), .3);\n\n\tfragColor = vec4 (col, 1.);\n}\n",
                "description": "",
                "inputs": [],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}